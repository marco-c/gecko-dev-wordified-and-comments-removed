#
include
"
VRThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
gfx
{
static
StaticRefPtr
<
VRListenerThreadHolder
>
sVRListenerThreadHolder
;
static
bool
sFinishedVRListenerShutDown
=
false
;
static
const
uint32_t
kDefaultThreadLifeTime
=
60
;
static
const
uint32_t
kDelayPostTaskTime
=
20000
;
VRListenerThreadHolder
*
GetVRListenerThreadHolder
(
)
{
return
sVRListenerThreadHolder
;
}
base
:
:
Thread
*
VRListenerThread
(
)
{
return
sVRListenerThreadHolder
?
sVRListenerThreadHolder
-
>
GetThread
(
)
:
nullptr
;
}
MessageLoop
*
VRListenerThreadHolder
:
:
Loop
(
)
{
return
VRListenerThread
(
)
?
VRListenerThread
(
)
-
>
message_loop
(
)
:
nullptr
;
}
VRListenerThreadHolder
*
VRListenerThreadHolder
:
:
GetSingleton
(
)
{
return
sVRListenerThreadHolder
;
}
VRListenerThreadHolder
:
:
VRListenerThreadHolder
(
)
:
mThread
(
CreateThread
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
VRListenerThreadHolder
:
:
~
VRListenerThreadHolder
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DestroyThread
(
mThread
)
;
}
void
VRListenerThreadHolder
:
:
DestroyThread
(
base
:
:
Thread
*
aThread
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sVRListenerThreadHolder
"
We
shouldn
'
t
be
destroying
the
VR
listener
thread
yet
.
"
)
;
delete
aThread
;
sFinishedVRListenerShutDown
=
true
;
}
base
:
:
Thread
*
VRListenerThreadHolder
:
:
CreateThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sVRListenerThreadHolder
"
The
VR
listener
thread
has
already
been
started
!
"
)
;
base
:
:
Thread
*
vrThread
=
new
base
:
:
Thread
(
"
VRListener
"
)
;
base
:
:
Thread
:
:
Options
options
;
options
.
transient_hang_timeout
=
128
;
options
.
permanent_hang_timeout
=
2048
;
if
(
!
vrThread
-
>
StartWithOptions
(
options
)
)
{
delete
vrThread
;
return
nullptr
;
}
return
vrThread
;
}
void
VRListenerThreadHolder
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
!
"
)
;
MOZ_ASSERT
(
!
sVRListenerThreadHolder
"
The
VR
listener
thread
has
already
been
started
!
"
)
;
sVRListenerThreadHolder
=
new
VRListenerThreadHolder
(
)
;
}
void
VRListenerThreadHolder
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
!
"
)
;
MOZ_ASSERT
(
sVRListenerThreadHolder
"
The
VR
listener
thread
has
already
been
shut
down
!
"
)
;
sVRListenerThreadHolder
=
nullptr
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
sFinishedVRListenerShutDown
;
}
)
;
}
bool
VRListenerThreadHolder
:
:
IsInVRListenerThread
(
)
{
return
VRListenerThread
(
)
&
&
VRListenerThread
(
)
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
VRThread
:
:
VRThread
(
const
nsCString
&
aName
)
:
mThread
(
nullptr
)
mLifeTime
(
kDefaultThreadLifeTime
)
mStarted
(
false
)
{
mName
=
aName
;
}
VRThread
:
:
~
VRThread
(
)
{
Shutdown
(
)
;
}
void
VRThread
:
:
Start
(
)
{
MOZ_ASSERT
(
VRListenerThreadHolder
:
:
IsInVRListenerThread
(
)
)
;
if
(
!
mThread
)
{
nsresult
rv
=
NS_NewNamedThread
(
mName
getter_AddRefs
(
mThread
)
)
;
MOZ_ASSERT
(
mThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
create
a
vr
thread
.
"
)
;
}
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
TimeStamp
>
(
"
gfx
:
:
VRThread
:
:
CheckLife
"
this
&
VRThread
:
:
CheckLife
TimeStamp
:
:
Now
(
)
)
;
nsCOMPtr
<
nsIThread
>
mainThread
;
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
VRThread
:
:
Start
(
)
could
not
get
Main
thread
"
)
;
return
;
}
mainThread
-
>
DelayedDispatch
(
runnable
.
forget
(
)
kDelayPostTaskTime
)
;
}
mStarted
=
true
;
mLastActiveTime
=
TimeStamp
:
:
Now
(
)
;
}
void
VRThread
:
:
Shutdown
(
)
{
if
(
mThread
)
{
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
mStarted
=
false
;
}
const
nsCOMPtr
<
nsIThread
>
VRThread
:
:
GetThread
(
)
const
{
return
mThread
;
}
void
VRThread
:
:
PostTask
(
already_AddRefed
<
Runnable
>
aTask
)
{
PostDelayedTask
(
std
:
:
move
(
aTask
)
0
)
;
}
void
VRThread
:
:
PostDelayedTask
(
already_AddRefed
<
Runnable
>
aTask
uint32_t
aTime
)
{
MOZ_ASSERT
(
mStarted
"
Must
call
Start
(
)
before
posting
tasks
.
"
)
;
MOZ_ASSERT
(
mThread
)
;
mLastActiveTime
=
TimeStamp
:
:
Now
(
)
;
if
(
!
aTime
)
{
mThread
-
>
Dispatch
(
std
:
:
move
(
aTask
)
NS_DISPATCH_NORMAL
)
;
}
else
{
mThread
-
>
DelayedDispatch
(
std
:
:
move
(
aTask
)
aTime
)
;
}
}
void
VRThread
:
:
CheckLife
(
TimeStamp
aCheckTimestamp
)
{
if
(
!
mStarted
)
{
Shutdown
(
)
;
return
;
}
const
TimeDuration
timeout
=
TimeDuration
:
:
FromSeconds
(
mLifeTime
)
;
if
(
(
aCheckTimestamp
-
mLastActiveTime
)
>
timeout
)
{
Shutdown
(
)
;
}
else
{
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
<
TimeStamp
>
(
"
gfx
:
:
VRThread
:
:
CheckLife
"
this
&
VRThread
:
:
CheckLife
TimeStamp
:
:
Now
(
)
)
;
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
VRThread
:
:
CheckLife
(
)
could
not
get
Main
thread
"
)
;
return
;
}
mainThread
-
>
DelayedDispatch
(
runnable
.
forget
(
)
kDelayPostTaskTime
)
;
}
}
void
VRThread
:
:
SetLifeTime
(
uint32_t
aLifeTime
)
{
mLifeTime
=
aLifeTime
;
}
uint32_t
VRThread
:
:
GetLifeTime
(
)
{
return
mLifeTime
;
}
bool
VRThread
:
:
IsActive
(
)
{
return
!
!
mThread
;
}
}
}
