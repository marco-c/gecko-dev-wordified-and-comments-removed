#
include
"
VRShMem
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
endif
#
include
"
gfxVRMutex
.
h
"
#
if
defined
(
XP_MACOSX
)
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
GeckoVRManager
.
h
"
#
endif
#
if
!
defined
(
XP_WIN
)
#
include
<
unistd
.
h
>
#
endif
using
namespace
mozilla
:
:
gfx
;
#
ifdef
XP_WIN
static
const
char
*
kShmemName
=
"
moz
.
gecko
.
vr_ext
.
"
SHMEM_VERSION
;
static
LPCTSTR
kMutexName
=
TEXT
(
"
mozilla
:
:
vr
:
:
ShmemMutex
"
SHMEM_VERSION
)
;
#
elif
defined
(
XP_MACOSX
)
static
const
char
*
kShmemName
=
"
/
moz
.
gecko
.
vr_ext
.
"
SHMEM_VERSION
;
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
namespace
{
void
YieldThread
(
)
{
#
if
defined
(
XP_WIN
)
:
:
Sleep
(
0
)
;
#
else
:
:
sleep
(
0
)
;
#
endif
}
}
#
endif
VRShMem
:
:
VRShMem
(
volatile
VRExternalShmem
*
aShmem
bool
aRequiresMutex
)
:
mExternalShmem
(
aShmem
)
mIsSharedExternalShmem
(
aShmem
!
=
nullptr
)
#
if
defined
(
XP_WIN
)
mRequiresMutex
(
aRequiresMutex
)
#
endif
#
if
defined
(
XP_MACOSX
)
mShmemFD
(
0
)
#
elif
defined
(
XP_WIN
)
mShmemFile
(
nullptr
)
mMutex
(
nullptr
)
#
endif
{
}
volatile
VRExternalShmem
*
VRShMem
:
:
GetExternalShmem
(
)
const
{
#
if
defined
(
XP_MACOSX
)
MOZ_ASSERT
(
mShmemFD
=
=
0
)
;
#
elif
defined
(
XP_WIN
)
MOZ_ASSERT
(
mShmemFile
=
=
nullptr
)
;
#
endif
return
mExternalShmem
;
}
bool
VRShMem
:
:
IsDisplayStateShutdown
(
)
const
{
return
mExternalShmem
!
=
nullptr
&
&
mExternalShmem
-
>
state
.
displayState
.
shutdown
;
}
bool
VRShMem
:
:
IsCreatedOnSharedMemory
(
)
const
{
#
if
defined
(
XP_MACOSX
)
return
HasExternalShmem
(
)
&
&
(
mShmemFD
!
=
0
)
;
#
elif
defined
(
XP_WIN
)
return
HasExternalShmem
(
)
&
&
(
mShmemFile
!
=
nullptr
)
;
#
else
return
false
;
#
endif
}
void
VRShMem
:
:
CreateShMem
(
bool
aCreateOnSharedMemory
)
{
if
(
HasExternalShmem
(
)
)
{
MOZ_ASSERT
(
mIsSharedExternalShmem
&
&
!
IsCreatedOnSharedMemory
(
)
)
;
return
;
}
#
if
defined
(
XP_WIN
)
if
(
mMutex
=
=
nullptr
)
{
mMutex
=
CreateMutex
(
nullptr
false
kMutexName
)
;
if
(
mMutex
=
=
nullptr
)
{
#
ifdef
MOZILLA_INTERNAL_API
nsAutoCString
msg
;
msg
.
AppendPrintf
(
"
VRManager
CreateMutex
error
\
"
%
lu
\
"
.
"
GetLastError
(
)
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
#
endif
MOZ_ASSERT
(
false
)
;
return
;
}
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
|
|
GetLastError
(
)
=
=
ERROR_ALREADY_EXISTS
)
;
}
#
endif
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
aCreateOnSharedMemory
)
{
MOZ_ASSERT
(
mExternalShmem
=
=
nullptr
)
;
mExternalShmem
=
new
VRExternalShmem
(
)
;
ClearShMem
(
)
;
return
;
}
#
endif
MOZ_ASSERT
(
aCreateOnSharedMemory
)
;
#
if
defined
(
XP_MACOSX
)
if
(
mShmemFD
=
=
0
)
{
mShmemFD
=
shm_open
(
kShmemName
O_RDWR
S_IRUSR
|
S_IWUSR
|
S_IROTH
|
S_IWOTH
)
;
}
if
(
mShmemFD
<
=
0
)
{
mShmemFD
=
0
;
return
;
}
struct
stat
sb
;
fstat
(
mShmemFD
&
sb
)
;
off_t
length
=
sb
.
st_size
;
if
(
length
<
(
off_t
)
sizeof
(
VRExternalShmem
)
)
{
CloseShMem
(
)
;
return
;
}
mExternalShmem
=
(
VRExternalShmem
*
)
mmap
(
NULL
length
PROT_READ
|
PROT_WRITE
MAP_SHARED
mShmemFD
0
)
;
if
(
mExternalShmem
=
=
MAP_FAILED
)
{
mExternalShmem
=
NULL
;
CloseShMem
(
)
;
return
;
}
#
elif
defined
(
XP_WIN
)
if
(
mShmemFile
=
=
nullptr
)
{
mShmemFile
=
CreateFileMappingA
(
INVALID_HANDLE_VALUE
nullptr
PAGE_READWRITE
0
sizeof
(
VRExternalShmem
)
kShmemName
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
|
|
GetLastError
(
)
=
=
ERROR_ALREADY_EXISTS
)
;
MOZ_ASSERT
(
mShmemFile
)
;
if
(
mShmemFile
=
=
nullptr
)
{
CloseShMem
(
)
;
return
;
}
}
LARGE_INTEGER
length
;
length
.
QuadPart
=
sizeof
(
VRExternalShmem
)
;
mExternalShmem
=
(
VRExternalShmem
*
)
MapViewOfFile
(
mShmemFile
FILE_MAP_ALL_ACCESS
0
0
length
.
QuadPart
)
;
if
(
mExternalShmem
=
=
nullptr
)
{
CloseShMem
(
)
;
return
;
}
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
false
"
CreateShMem
should
not
be
called
for
Android
.
Use
"
"
CreateShMemForAndroid
instead
"
)
;
#
endif
}
void
VRShMem
:
:
CreateShMemForAndroid
(
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
&
&
defined
(
MOZILLA_INTERNAL_API
)
mExternalShmem
=
(
VRExternalShmem
*
)
mozilla
:
:
GeckoVRManager
:
:
GetExternalContext
(
)
;
if
(
!
mExternalShmem
)
{
return
;
}
else
{
mIsSharedExternalShmem
=
true
;
}
int32_t
version
=
-
1
;
int32_t
size
=
0
;
if
(
pthread_mutex_lock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
=
=
0
)
{
version
=
mExternalShmem
-
>
version
;
size
=
mExternalShmem
-
>
size
;
pthread_mutex_unlock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
;
}
else
{
return
;
}
if
(
version
!
=
kVRExternalVersion
)
{
mExternalShmem
=
nullptr
;
return
;
}
if
(
size
!
=
sizeof
(
VRExternalShmem
)
)
{
mExternalShmem
=
nullptr
;
return
;
}
#
endif
}
void
VRShMem
:
:
ClearShMem
(
)
{
if
(
mExternalShmem
!
=
nullptr
)
{
#
ifdef
MOZILLA_INTERNAL_API
mExternalShmem
-
>
Clear
(
)
;
#
else
memset
(
(
void
*
)
mExternalShmem
0
sizeof
(
VRExternalShmem
)
)
;
#
endif
}
}
void
VRShMem
:
:
CloseShMem
(
)
{
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
IsCreatedOnSharedMemory
(
)
)
{
MOZ_ASSERT
(
!
mIsSharedExternalShmem
)
;
if
(
mExternalShmem
)
{
delete
mExternalShmem
;
mExternalShmem
=
nullptr
;
}
return
;
}
#
endif
#
if
defined
(
XP_MACOSX
)
if
(
mExternalShmem
)
{
munmap
(
(
void
*
)
mExternalShmem
sizeof
(
VRExternalShmem
)
)
;
mExternalShmem
=
NULL
;
}
if
(
mShmemFD
)
{
close
(
mShmemFD
)
;
mShmemFD
=
0
;
}
#
elif
defined
(
XP_WIN
)
if
(
mExternalShmem
)
{
UnmapViewOfFile
(
(
void
*
)
mExternalShmem
)
;
mExternalShmem
=
nullptr
;
}
if
(
mShmemFile
)
{
CloseHandle
(
mShmemFile
)
;
mShmemFile
=
nullptr
;
}
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
mExternalShmem
=
NULL
;
#
endif
#
if
defined
(
XP_WIN
)
if
(
mMutex
)
{
MOZ_ASSERT
(
mRequiresMutex
)
;
CloseHandle
(
mMutex
)
;
mMutex
=
nullptr
;
}
#
endif
}
bool
VRShMem
:
:
JoinShMem
(
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mMutex
&
&
mRequiresMutex
)
{
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
mMutex
=
OpenMutex
(
MUTEX_ALL_ACCESS
false
kMutexName
)
;
if
(
mMutex
=
=
nullptr
)
{
#
ifdef
MOZILLA_INTERNAL_API
nsAutoCString
msg
;
msg
.
AppendPrintf
(
"
VRService
OpenMutex
error
\
"
%
lu
\
"
.
"
GetLastError
(
)
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
#
endif
return
false
;
}
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
}
#
endif
if
(
HasExternalShmem
(
)
)
{
return
true
;
}
#
if
defined
(
XP_WIN
)
base
:
:
ProcessHandle
targetHandle
=
OpenFileMappingA
(
FILE_MAP_ALL_ACCESS
FALSE
kShmemName
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
LARGE_INTEGER
length
;
length
.
QuadPart
=
sizeof
(
VRExternalShmem
)
;
mExternalShmem
=
(
VRExternalShmem
*
)
MapViewOfFile
(
reinterpret_cast
<
base
:
:
ProcessHandle
>
(
targetHandle
)
FILE_MAP_ALL_ACCESS
0
0
length
.
QuadPart
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
mShmemFile
=
targetHandle
;
if
(
!
mExternalShmem
)
{
MOZ_ASSERT
(
mExternalShmem
)
;
return
false
;
}
#
else
MOZ_ASSERT
(
false
"
JoinShMem
not
implemented
"
)
;
#
endif
return
true
;
}
void
VRShMem
:
:
LeaveShMem
(
)
{
#
if
defined
(
XP_WIN
)
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
if
(
mShmemFile
)
{
:
:
CloseHandle
(
mShmemFile
)
;
mShmemFile
=
nullptr
;
}
#
endif
if
(
mExternalShmem
!
=
nullptr
)
{
#
if
defined
(
XP_WIN
)
if
(
IsCreatedOnSharedMemory
(
)
)
{
UnmapViewOfFile
(
(
void
*
)
mExternalShmem
)
;
MOZ_ASSERT
(
GetLastError
(
)
=
=
0
)
;
}
#
endif
mExternalShmem
=
nullptr
;
}
#
if
defined
(
XP_WIN
)
if
(
mMutex
)
{
MOZ_ASSERT
(
mRequiresMutex
)
;
CloseHandle
(
mMutex
)
;
mMutex
=
nullptr
;
}
#
endif
}
void
VRShMem
:
:
PushBrowserState
(
VRBrowserState
&
aBrowserState
bool
aNotifyCond
)
{
if
(
!
mExternalShmem
)
{
return
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
pthread_mutex_lock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
geckoMutex
)
)
=
=
0
)
{
memcpy
(
(
void
*
)
&
(
mExternalShmem
-
>
geckoState
)
(
void
*
)
&
aBrowserState
sizeof
(
VRBrowserState
)
)
;
if
(
aNotifyCond
)
{
pthread_cond_signal
(
(
pthread_cond_t
*
)
&
(
mExternalShmem
-
>
geckoCond
)
)
;
}
pthread_mutex_unlock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
geckoMutex
)
)
;
}
#
else
bool
status
=
true
;
#
if
defined
(
XP_WIN
)
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
#
endif
if
(
status
)
{
mExternalShmem
-
>
geckoGenerationA
+
+
;
memcpy
(
(
void
*
)
&
(
mExternalShmem
-
>
geckoState
)
(
void
*
)
&
aBrowserState
sizeof
(
VRBrowserState
)
)
;
mExternalShmem
-
>
geckoGenerationB
+
+
;
}
#
endif
}
void
VRShMem
:
:
PullBrowserState
(
mozilla
:
:
gfx
:
:
VRBrowserState
&
aState
)
{
if
(
!
mExternalShmem
)
{
return
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
false
"
PullBrowserState
not
implemented
"
)
;
#
else
bool
status
=
true
;
#
if
defined
(
XP_WIN
)
if
(
mRequiresMutex
)
{
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
}
#
endif
if
(
status
)
{
VRExternalShmem
tmp
;
if
(
mExternalShmem
-
>
geckoGenerationA
!
=
mBrowserGeneration
)
{
memcpy
(
&
tmp
(
void
*
)
mExternalShmem
sizeof
(
VRExternalShmem
)
)
;
if
(
tmp
.
geckoGenerationA
=
=
tmp
.
geckoGenerationB
&
&
tmp
.
geckoGenerationA
!
=
0
)
{
memcpy
(
&
aState
&
tmp
.
geckoState
sizeof
(
VRBrowserState
)
)
;
mBrowserGeneration
=
tmp
.
geckoGenerationA
;
}
}
}
#
endif
}
void
VRShMem
:
:
PushSystemState
(
const
mozilla
:
:
gfx
:
:
VRSystemState
&
aState
)
{
if
(
!
mExternalShmem
)
{
return
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
false
"
JoinShMem
not
implemented
"
)
;
#
else
bool
lockState
=
true
;
#
if
defined
(
XP_WIN
)
if
(
mRequiresMutex
)
{
WaitForMutex
lock
(
mMutex
)
;
lockState
=
lock
.
GetStatus
(
)
;
}
#
endif
if
(
lockState
)
{
mExternalShmem
-
>
generationA
+
+
;
memcpy
(
(
void
*
)
&
mExternalShmem
-
>
state
&
aState
sizeof
(
VRSystemState
)
)
;
mExternalShmem
-
>
generationB
+
+
;
}
#
endif
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
VRShMem
:
:
PullSystemState
(
VRDisplayState
&
aDisplayState
VRHMDSensorState
&
aSensorState
VRControllerState
(
&
aControllerState
)
[
kVRControllerMaxCount
]
bool
&
aEnumerationCompleted
const
std
:
:
function
<
bool
(
)
>
&
aWaitCondition
)
{
if
(
!
mExternalShmem
)
{
return
;
}
bool
done
=
false
;
while
(
!
done
)
{
if
(
pthread_mutex_lock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
=
=
0
)
{
while
(
true
)
{
memcpy
(
&
aDisplayState
(
void
*
)
&
(
mExternalShmem
-
>
state
.
displayState
)
sizeof
(
VRDisplayState
)
)
;
memcpy
(
&
aSensorState
(
void
*
)
&
(
mExternalShmem
-
>
state
.
sensorState
)
sizeof
(
VRHMDSensorState
)
)
;
memcpy
(
aControllerState
(
void
*
)
&
(
mExternalShmem
-
>
state
.
controllerState
)
sizeof
(
VRControllerState
)
*
kVRControllerMaxCount
)
;
aEnumerationCompleted
=
mExternalShmem
-
>
state
.
enumerationCompleted
;
if
(
!
aWaitCondition
|
|
aWaitCondition
(
)
)
{
done
=
true
;
break
;
}
pthread_cond_wait
(
(
pthread_cond_t
*
)
&
mExternalShmem
-
>
systemCond
(
pthread_mutex_t
*
)
&
mExternalShmem
-
>
systemMutex
)
;
}
pthread_mutex_unlock
(
(
pthread_mutex_t
*
)
&
(
mExternalShmem
-
>
systemMutex
)
)
;
}
else
if
(
!
aWaitCondition
)
{
return
;
}
}
}
#
else
void
VRShMem
:
:
PullSystemState
(
VRDisplayState
&
aDisplayState
VRHMDSensorState
&
aSensorState
VRControllerState
(
&
aControllerState
)
[
kVRControllerMaxCount
]
bool
&
aEnumerationCompleted
const
std
:
:
function
<
bool
(
)
>
&
aWaitCondition
)
{
MOZ_ASSERT
(
mExternalShmem
)
;
if
(
!
mExternalShmem
)
{
return
;
}
while
(
true
)
{
{
#
if
defined
(
XP_WIN
)
bool
status
=
true
;
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
if
(
status
)
{
#
endif
VRExternalShmem
tmp
;
memcpy
(
&
tmp
(
void
*
)
mExternalShmem
sizeof
(
VRExternalShmem
)
)
;
bool
isCleanCopy
=
tmp
.
generationA
=
=
tmp
.
generationB
&
&
tmp
.
generationA
!
=
0
;
if
(
isCleanCopy
)
{
memcpy
(
&
aDisplayState
&
tmp
.
state
.
displayState
sizeof
(
VRDisplayState
)
)
;
memcpy
(
&
aSensorState
&
tmp
.
state
.
sensorState
sizeof
(
VRHMDSensorState
)
)
;
memcpy
(
aControllerState
(
void
*
)
&
(
mExternalShmem
-
>
state
.
controllerState
)
sizeof
(
VRControllerState
)
*
kVRControllerMaxCount
)
;
aEnumerationCompleted
=
mExternalShmem
-
>
state
.
enumerationCompleted
;
if
(
!
aWaitCondition
|
|
aWaitCondition
(
)
)
{
return
;
}
}
else
if
(
!
aWaitCondition
)
{
return
;
}
YieldThread
(
)
;
#
if
defined
(
XP_WIN
)
}
else
if
(
!
aWaitCondition
)
{
return
;
}
#
endif
}
YieldThread
(
)
;
}
}
#
endif
void
VRShMem
:
:
PushWindowState
(
VRWindowState
&
aState
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mExternalShmem
)
{
return
;
}
bool
status
=
true
;
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
if
(
status
)
{
memcpy
(
(
void
*
)
&
(
mExternalShmem
-
>
windowState
)
(
void
*
)
&
aState
sizeof
(
VRWindowState
)
)
;
}
#
endif
}
void
VRShMem
:
:
PullWindowState
(
VRWindowState
&
aState
)
{
#
if
defined
(
XP_WIN
)
if
(
!
mExternalShmem
)
{
return
;
}
bool
status
=
true
;
WaitForMutex
lock
(
mMutex
)
;
status
=
lock
.
GetStatus
(
)
;
if
(
status
)
{
memcpy
(
(
void
*
)
&
aState
(
void
*
)
&
(
mExternalShmem
-
>
windowState
)
sizeof
(
VRWindowState
)
)
;
}
#
endif
}
void
VRShMem
:
:
SendEvent
(
uint64_t
aWindowID
mozilla
:
:
gfx
:
:
VRFxEventType
aEventType
mozilla
:
:
gfx
:
:
VRFxEventState
aEventState
)
{
MOZ_ASSERT
(
!
HasExternalShmem
(
)
)
;
if
(
JoinShMem
(
)
)
{
mozilla
:
:
gfx
:
:
VRWindowState
windowState
=
{
0
}
;
PullWindowState
(
windowState
)
;
windowState
.
windowID
=
aWindowID
;
windowState
.
eventType
=
aEventType
;
windowState
.
eventState
=
aEventState
;
PushWindowState
(
windowState
)
;
LeaveShMem
(
)
;
#
if
defined
(
XP_WIN
)
HANDLE
hSignal
=
:
:
OpenEventA
(
EVENT_ALL_ACCESS
FALSE
windowState
.
signalName
)
;
:
:
SetEvent
(
hSignal
)
;
:
:
CloseHandle
(
hSignal
)
;
#
endif
}
}
void
VRShMem
:
:
SendIMEState
(
uint64_t
aWindowID
mozilla
:
:
gfx
:
:
VRFxEventState
aEventState
)
{
SendEvent
(
aWindowID
mozilla
:
:
gfx
:
:
VRFxEventType
:
:
IME
aEventState
)
;
}
void
VRShMem
:
:
SendFullscreenState
(
uint64_t
aWindowID
bool
aFullscreen
)
{
SendEvent
(
aWindowID
mozilla
:
:
gfx
:
:
VRFxEventType
:
:
FULLSCREEN
aFullscreen
?
mozilla
:
:
gfx
:
:
VRFxEventState
:
:
FULLSCREEN_ENTER
:
mozilla
:
:
gfx
:
:
VRFxEventState
:
:
FULLSCREEN_EXIT
)
;
}
void
VRShMem
:
:
SendShutdowmState
(
uint64_t
aWindowID
)
{
MOZ_ASSERT
(
HasExternalShmem
(
)
)
;
mozilla
:
:
gfx
:
:
VRWindowState
windowState
=
{
0
}
;
PullWindowState
(
windowState
)
;
windowState
.
windowID
=
aWindowID
;
windowState
.
eventType
=
mozilla
:
:
gfx
:
:
VRFxEventType
:
:
SHUTDOWN
;
PushWindowState
(
windowState
)
;
#
if
defined
(
XP_WIN
)
HANDLE
hSignal
=
:
:
OpenEventA
(
EVENT_ALL_ACCESS
FALSE
windowState
.
signalName
)
;
:
:
SetEvent
(
hSignal
)
;
:
:
CloseHandle
(
hSignal
)
;
#
endif
}
