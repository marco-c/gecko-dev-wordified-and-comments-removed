#
ifndef
GFX_VR_EXTERNAL_API_H
#
define
GFX_VR_EXTERNAL_API_H
#
define
GFX_VR_EIGHTCC
(
c1
c2
c3
c4
c5
c6
c7
c8
)
\
(
(
uint64_t
)
(
c1
)
<
<
56
|
(
uint64_t
)
(
c2
)
<
<
48
|
(
uint64_t
)
(
c3
)
<
<
40
|
\
(
uint64_t
)
(
c4
)
<
<
32
|
(
uint64_t
)
(
c5
)
<
<
24
|
(
uint64_t
)
(
c6
)
<
<
16
|
\
(
uint64_t
)
(
c7
)
<
<
8
|
(
uint64_t
)
(
c8
)
)
#
ifdef
MOZILLA_INTERNAL_API
#
ifndef
__STDC_WANT_LIB_EXT1__
#
define
__STDC_WANT_LIB_EXT1__
1
#
endif
static_assert
(
__STDC_WANT_LIB_EXT1__
=
=
1
"
__STDC_WANT_LIB_EXT1__
must
be
set
"
)
;
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
"
mozilla
/
TiedFields
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
endif
#
if
defined
(
__ANDROID__
)
#
include
<
pthread
.
h
>
#
endif
#
include
<
array
>
#
include
<
cstdint
>
#
include
<
type_traits
>
namespace
mozilla
{
#
ifdef
MOZILLA_INTERNAL_API
namespace
dom
{
enum
class
GamepadHand
:
uint8_t
;
enum
class
GamepadCapabilityFlags
:
uint16_t
;
}
#
endif
namespace
gfx
{
#
define
SHMEM_VERSION
"
0
.
0
.
12
"
static
const
int32_t
kVRExternalVersion
=
19
;
static
const
uint32_t
kVRGroupNone
=
0
;
static
const
uint32_t
kVRGroupContent
=
1
<
<
0
;
static
const
uint32_t
kVRGroupChrome
=
1
<
<
1
;
static
const
uint32_t
kVRGroupAll
=
0xffffffff
;
static
const
int
kVRDisplayNameMaxLen
=
256
;
static
const
int
kVRControllerNameMaxLen
=
256
;
static
const
int
kVRControllerMaxCount
=
16
;
static
const
int
kVRControllerMaxButtons
=
64
;
static
const
int
kVRControllerMaxAxis
=
16
;
static
const
int
kVRLayerMaxCount
=
8
;
static
const
int
kVRHapticsMaxCount
=
32
;
#
if
defined
(
__ANDROID__
)
typedef
uint64_t
VRLayerTextureHandle
;
#
elif
defined
(
XP_MACOSX
)
typedef
uint32_t
VRLayerTextureHandle
;
#
else
typedef
void
*
VRLayerTextureHandle
;
#
endif
struct
Point3D_POD
{
float
x
;
float
y
;
float
z
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
x
y
z
)
;
}
bool
operator
=
=
(
const
Point3D_POD
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
#
endif
}
;
struct
IntSize_POD
{
int32_t
width
;
int32_t
height
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
width
height
)
;
}
bool
operator
=
=
(
const
IntSize_POD
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
#
endif
}
;
struct
FloatSize_POD
{
float
width
;
float
height
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
width
height
)
;
}
bool
operator
=
=
(
const
FloatSize_POD
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
#
endif
}
;
#
ifndef
MOZILLA_INTERNAL_API
enum
class
ControllerHand
:
uint8_t
{
_empty
Left
Right
EndGuard_
}
;
enum
class
ControllerCapabilityFlags
:
uint16_t
{
Cap_None
=
0
Cap_Position
=
1
<
<
1
Cap_Orientation
=
1
<
<
2
Cap_AngularAcceleration
=
1
<
<
3
Cap_LinearAcceleration
=
1
<
<
4
Cap_GripSpacePosition
=
1
<
<
5
Cap_PositionEmulated
=
1
<
<
6
Cap_All
=
(
1
<
<
7
)
-
1
}
;
#
endif
enum
class
VRControllerType
:
uint8_t
{
_empty
HTCVive
HTCViveCosmos
HTCViveFocus
HTCViveFocusPlus
MSMR
ValveIndex
OculusGo
OculusTouch
OculusTouch2
OculusTouch3
PicoGaze
PicoG2
PicoNeo2
_end
}
;
}
template
<
class
T
>
bool
IsEnumCase
(
T
)
;
template
<
>
inline
constexpr
bool
IsEnumCase
<
gfx
:
:
VRControllerType
>
(
const
gfx
:
:
VRControllerType
raw
)
{
switch
(
raw
)
{
case
gfx
:
:
VRControllerType
:
:
_empty
:
case
gfx
:
:
VRControllerType
:
:
HTCVive
:
case
gfx
:
:
VRControllerType
:
:
HTCViveCosmos
:
case
gfx
:
:
VRControllerType
:
:
HTCViveFocus
:
case
gfx
:
:
VRControllerType
:
:
HTCViveFocusPlus
:
case
gfx
:
:
VRControllerType
:
:
MSMR
:
case
gfx
:
:
VRControllerType
:
:
ValveIndex
:
case
gfx
:
:
VRControllerType
:
:
OculusGo
:
case
gfx
:
:
VRControllerType
:
:
OculusTouch
:
case
gfx
:
:
VRControllerType
:
:
OculusTouch2
:
case
gfx
:
:
VRControllerType
:
:
OculusTouch3
:
case
gfx
:
:
VRControllerType
:
:
PicoGaze
:
case
gfx
:
:
VRControllerType
:
:
PicoG2
:
case
gfx
:
:
VRControllerType
:
:
PicoNeo2
:
case
gfx
:
:
VRControllerType
:
:
_end
:
return
true
;
}
return
false
;
}
namespace
gfx
{
enum
class
TargetRayMode
:
uint8_t
{
Gaze
TrackedPointer
Screen
}
;
}
template
<
>
inline
constexpr
bool
IsEnumCase
<
gfx
:
:
TargetRayMode
>
(
const
gfx
:
:
TargetRayMode
raw
)
{
switch
(
raw
)
{
case
gfx
:
:
TargetRayMode
:
:
Gaze
:
case
gfx
:
:
TargetRayMode
:
:
TrackedPointer
:
case
gfx
:
:
TargetRayMode
:
:
Screen
:
return
true
;
}
return
false
;
}
namespace
gfx
{
enum
class
GamepadMappingType
:
uint8_t
{
_empty
Standard
XRStandard
}
;
}
template
<
>
inline
constexpr
bool
IsEnumCase
<
gfx
:
:
GamepadMappingType
>
(
const
gfx
:
:
GamepadMappingType
raw
)
{
switch
(
raw
)
{
case
gfx
:
:
GamepadMappingType
:
:
_empty
:
case
gfx
:
:
GamepadMappingType
:
:
Standard
:
case
gfx
:
:
GamepadMappingType
:
:
XRStandard
:
return
true
;
}
return
false
;
}
namespace
gfx
{
enum
class
VRDisplayBlendMode
:
uint8_t
{
Opaque
Additive
AlphaBlend
}
;
}
template
<
>
inline
constexpr
bool
IsEnumCase
<
gfx
:
:
VRDisplayBlendMode
>
(
const
gfx
:
:
VRDisplayBlendMode
raw
)
{
switch
(
raw
)
{
case
gfx
:
:
VRDisplayBlendMode
:
:
Opaque
:
case
gfx
:
:
VRDisplayBlendMode
:
:
Additive
:
case
gfx
:
:
VRDisplayBlendMode
:
:
AlphaBlend
:
return
true
;
}
return
false
;
}
namespace
gfx
{
enum
class
VRDisplayCapabilityFlags
:
uint16_t
{
Cap_None
=
0
Cap_Position
=
1
<
<
1
Cap_Orientation
=
1
<
<
2
Cap_Present
=
1
<
<
3
Cap_External
=
1
<
<
4
Cap_AngularAcceleration
=
1
<
<
5
Cap_LinearAcceleration
=
1
<
<
6
Cap_StageParameters
=
1
<
<
7
Cap_MountDetection
=
1
<
<
8
Cap_PositionEmulated
=
1
<
<
9
Cap_Inline
=
1
<
<
10
Cap_ImmersiveVR
=
1
<
<
11
Cap_ImmersiveAR
=
1
<
<
12
Cap_UseDepthValues
=
1
<
<
13
Cap_All
=
(
1
<
<
14
)
-
1
}
;
#
ifdef
MOZILLA_INTERNAL_API
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
VRDisplayCapabilityFlags
)
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
VRDisplayBlendMode
)
#
endif
struct
VRPose
{
std
:
:
array
<
float
4
>
orientation
;
std
:
:
array
<
float
3
>
position
;
std
:
:
array
<
float
3
>
angularVelocity
;
std
:
:
array
<
float
3
>
angularAcceleration
;
std
:
:
array
<
float
3
>
linearVelocity
;
std
:
:
array
<
float
3
>
linearAcceleration
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
orientation
position
angularVelocity
angularAcceleration
linearVelocity
linearAcceleration
)
;
}
bool
operator
=
=
(
const
VRPose
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
#
endif
}
;
struct
VRHMDSensorState
{
uint64_t
inputFrameID
;
double
timestamp
;
VRDisplayCapabilityFlags
flags
;
uint16_t
_padding
;
VRPose
pose
;
std
:
:
array
<
float
16
>
leftViewMatrix
;
std
:
:
array
<
float
16
>
rightViewMatrix
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
inputFrameID
timestamp
flags
_padding
pose
leftViewMatrix
rightViewMatrix
)
;
}
void
Clear
(
)
{
memset
(
this
0
sizeof
(
VRHMDSensorState
)
)
;
}
bool
operator
=
=
(
const
VRHMDSensorState
&
other
)
const
{
return
inputFrameID
=
=
other
.
inputFrameID
&
&
timestamp
=
=
other
.
timestamp
;
}
bool
operator
!
=
(
const
VRHMDSensorState
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
void
CalcViewMatrices
(
const
gfx
:
:
Matrix4x4
*
aHeadToEyeTransforms
)
;
#
endif
}
;
struct
VRFieldOfView
{
double
upDegrees
;
double
rightDegrees
;
double
downDegrees
;
double
leftDegrees
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
upDegrees
rightDegrees
downDegrees
leftDegrees
)
;
}
bool
operator
=
=
(
const
VRFieldOfView
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
VRFieldOfView
(
)
=
default
;
VRFieldOfView
(
double
up
double
right
double
down
double
left
)
:
upDegrees
(
up
)
rightDegrees
(
right
)
downDegrees
(
down
)
leftDegrees
(
left
)
{
}
void
SetFromTanRadians
(
double
up
double
right
double
down
double
left
)
{
upDegrees
=
atan
(
up
)
*
180
.
0
/
M_PI
;
rightDegrees
=
atan
(
right
)
*
180
.
0
/
M_PI
;
downDegrees
=
atan
(
down
)
*
180
.
0
/
M_PI
;
leftDegrees
=
atan
(
left
)
*
180
.
0
/
M_PI
;
}
bool
operator
!
=
(
const
VRFieldOfView
&
other
)
const
{
return
!
(
*
this
=
=
other
)
;
}
bool
IsZero
(
)
const
{
return
upDegrees
=
=
0
.
0
|
|
rightDegrees
=
=
0
.
0
|
|
downDegrees
=
=
0
.
0
|
|
leftDegrees
=
=
0
.
0
;
}
Matrix4x4
ConstructProjectionMatrix
(
float
zNear
float
zFar
bool
rightHanded
)
const
;
#
endif
}
;
struct
VRDisplayState
{
enum
Eye
{
Eye_Left
Eye_Right
NumEyes
}
;
bool
shutdown
;
std
:
:
array
<
uint8_t
3
>
_padding1
;
uint32_t
minRestartInterval
;
std
:
:
array
<
char
kVRDisplayNameMaxLen
>
displayName
;
uint64_t
eightCC
;
VRDisplayCapabilityFlags
capabilityFlags
;
VRDisplayBlendMode
blendMode
;
std
:
:
array
<
uint8_t
5
>
_padding2
;
std
:
:
array
<
VRFieldOfView
VRDisplayState
:
:
NumEyes
>
eyeFOV
;
static_assert
(
std
:
:
is_trivial_v
<
VRFieldOfView
>
)
;
std
:
:
array
<
Point3D_POD
VRDisplayState
:
:
NumEyes
>
eyeTranslation
;
static_assert
(
std
:
:
is_trivial_v
<
Point3D_POD
>
)
;
IntSize_POD
eyeResolution
;
static_assert
(
std
:
:
is_trivial_v
<
IntSize_POD
>
)
;
float
nativeFramebufferScaleFactor
;
bool
suppressFrames
;
bool
isConnected
;
bool
isMounted
;
uint8_t
_padding3
;
FloatSize_POD
stageSize
;
static_assert
(
std
:
:
is_trivial_v
<
FloatSize_POD
>
)
;
std
:
:
array
<
float
16
>
sittingToStandingTransform
;
uint64_t
lastSubmittedFrameId
;
bool
lastSubmittedFrameSuccessful
;
std
:
:
array
<
uint8_t
3
>
_padding4
;
uint32_t
presentingGeneration
;
bool
reportsDroppedFrames
;
std
:
:
array
<
uint8_t
7
>
_padding5
;
uint64_t
droppedFrameCount
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
shutdown
_padding1
minRestartInterval
displayName
eightCC
capabilityFlags
blendMode
_padding2
eyeFOV
eyeTranslation
eyeResolution
nativeFramebufferScaleFactor
suppressFrames
isConnected
isMounted
_padding3
stageSize
sittingToStandingTransform
lastSubmittedFrameId
lastSubmittedFrameSuccessful
_padding4
presentingGeneration
reportsDroppedFrames
_padding5
droppedFrameCount
)
;
}
bool
operator
=
=
(
const
VRDisplayState
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
void
Clear
(
)
{
memset
(
this
0
sizeof
(
VRDisplayState
)
)
;
}
#
endif
}
;
static_assert
(
std
:
:
is_trivial_v
<
VRDisplayState
>
)
;
struct
VRControllerState
{
std
:
:
array
<
char
kVRControllerNameMaxLen
>
controllerName
;
#
ifdef
MOZILLA_INTERNAL_API
dom
:
:
GamepadHand
hand
;
#
else
ControllerHand
hand
;
#
endif
VRControllerType
type
;
TargetRayMode
targetRayMode
;
GamepadMappingType
mappingType
;
uint32_t
_padding1
;
uint64_t
selectActionStartFrameId
;
uint64_t
selectActionStopFrameId
;
uint64_t
squeezeActionStartFrameId
;
uint64_t
squeezeActionStopFrameId
;
uint32_t
numButtons
;
uint32_t
numAxes
;
uint32_t
numHaptics
;
uint32_t
_padding2
;
uint64_t
buttonPressed
;
uint64_t
buttonTouched
;
std
:
:
array
<
float
kVRControllerMaxButtons
>
triggerValue
;
std
:
:
array
<
float
kVRControllerMaxAxis
>
axisValue
;
#
ifdef
MOZILLA_INTERNAL_API
dom
:
:
GamepadCapabilityFlags
flags
;
#
else
ControllerCapabilityFlags
flags
;
#
endif
uint16_t
_padding3
;
VRPose
pose
;
VRPose
targetRayPose
;
bool
isPositionValid
;
bool
isOrientationValid
;
uint16_t
_padding4
;
#
ifdef
MOZILLA_INTERNAL_API
auto
MutTiedFields
(
)
{
return
std
:
:
tie
(
controllerName
hand
type
targetRayMode
mappingType
_padding1
selectActionStartFrameId
selectActionStopFrameId
squeezeActionStartFrameId
squeezeActionStopFrameId
numButtons
numAxes
numHaptics
_padding2
buttonPressed
buttonTouched
triggerValue
axisValue
flags
_padding3
pose
targetRayPose
isPositionValid
isOrientationValid
_padding4
)
;
}
bool
operator
=
=
(
const
VRControllerState
&
other
)
const
{
return
TiedFields
(
*
this
)
=
=
TiedFields
(
other
)
;
}
void
Clear
(
)
{
memset
(
this
0
sizeof
(
VRControllerState
)
)
;
}
#
endif
}
;
struct
VRLayerEyeRect
{
float
x
;
float
y
;
float
width
;
float
height
;
}
;
enum
class
VRLayerType
:
uint16_t
{
LayerType_None
=
0
LayerType_2D_Content
=
1
LayerType_Stereo_Immersive
=
2
}
;
enum
class
VRLayerTextureType
:
uint16_t
{
LayerTextureType_None
=
0
LayerTextureType_D3D10SurfaceDescriptor
=
1
LayerTextureType_MacIOSurface
=
2
LayerTextureType_GeckoSurfaceTexture
=
3
}
;
struct
VRLayer_2D_Content
{
VRLayerTextureHandle
textureHandle
;
VRLayerTextureType
textureType
;
uint64_t
frameId
;
}
;
struct
VRLayer_Stereo_Immersive
{
VRLayerTextureHandle
textureHandle
;
VRLayerTextureType
textureType
;
uint64_t
frameId
;
uint64_t
inputFrameId
;
VRLayerEyeRect
leftEyeRect
;
VRLayerEyeRect
rightEyeRect
;
IntSize_POD
textureSize
;
}
;
struct
VRLayerState
{
VRLayerType
type
;
union
{
VRLayer_2D_Content
layer_2d_content
;
VRLayer_Stereo_Immersive
layer_stereo_immersive
;
}
;
}
;
struct
VRHapticState
{
uint64_t
inputFrameID
;
uint32_t
controllerIndex
;
uint32_t
hapticIndex
;
float
pulseStart
;
float
pulseDuration
;
float
pulseIntensity
;
}
;
struct
VRBrowserState
{
#
if
defined
(
__ANDROID__
)
bool
shutdown
;
#
endif
bool
detectRuntimesOnly
;
bool
presentationActive
;
bool
navigationTransitionActive
;
VRLayerState
layerState
[
kVRLayerMaxCount
]
;
VRHapticState
hapticState
[
kVRHapticsMaxCount
]
;
#
ifdef
MOZILLA_INTERNAL_API
void
Clear
(
)
{
memset
(
this
0
sizeof
(
VRBrowserState
)
)
;
}
#
endif
}
;
struct
VRSystemState
{
bool
enumerationCompleted
;
VRDisplayState
displayState
;
VRHMDSensorState
sensorState
;
std
:
:
array
<
VRControllerState
kVRControllerMaxCount
>
controllerState
;
}
;
static_assert
(
std
:
:
is_trivial_v
<
VRDisplayState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRHMDSensorState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRControllerState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRSystemState
>
)
;
enum
class
VRFxEventType
:
uint8_t
{
NONE
=
0
IME
SHUTDOWN
FULLSCREEN
TOTAL
}
;
enum
class
VRFxEventState
:
uint8_t
{
NONE
=
0
BLUR
FOCUS
FULLSCREEN_ENTER
FULLSCREEN_EXIT
TOTAL
}
;
struct
VRWindowState
{
uint64_t
hwndFx
;
uint32_t
widthFx
;
uint32_t
heightFx
;
VRLayerTextureHandle
textureFx
;
uint32_t
windowID
;
VRFxEventType
eventType
;
VRFxEventState
eventState
;
uint32_t
dxgiAdapterHost
;
uint32_t
widthHost
;
uint32_t
heightHost
;
char
signalName
[
32
]
;
}
;
enum
class
VRTelemetryId
:
uint8_t
{
NONE
=
0
INSTALLED_FROM
=
1
ENTRY_METHOD
=
2
FIRST_RUN
=
3
TOTAL
=
4
}
;
enum
class
VRTelemetryInstallFrom
:
uint8_t
{
User
=
0
FxR
=
1
HTC
=
2
Valve
=
3
TOTAL
=
4
}
;
enum
class
VRTelemetryEntryMethod
:
uint8_t
{
SystemBtn
=
0
Library
=
1
Gaze
=
2
TOTAL
=
3
}
;
struct
VRTelemetryState
{
uint32_t
uid
;
bool
installedFrom
:
1
;
bool
entryMethod
:
1
;
bool
firstRun
:
1
;
uint8_t
installedFromValue
:
3
;
uint8_t
entryMethodValue
:
3
;
bool
firstRunValue
:
1
;
}
;
struct
VRExternalShmem
{
int32_t
version
;
int32_t
size
;
#
if
defined
(
__ANDROID__
)
pthread_mutex_t
systemMutex
;
pthread_mutex_t
geckoMutex
;
pthread_mutex_t
servoMutex
;
pthread_cond_t
systemCond
;
pthread_cond_t
geckoCond
;
pthread_cond_t
servoCond
;
#
else
int64_t
generationA
;
#
endif
VRSystemState
state
;
#
if
!
defined
(
__ANDROID__
)
int64_t
generationB
;
int64_t
geckoGenerationA
;
int64_t
servoGenerationA
;
#
endif
VRBrowserState
geckoState
;
VRBrowserState
servoState
;
#
if
!
defined
(
__ANDROID__
)
int64_t
geckoGenerationB
;
int64_t
servoGenerationB
;
#
endif
#
if
defined
(
XP_WIN
)
VRWindowState
windowState
;
VRTelemetryState
telemetryState
;
#
endif
#
ifdef
MOZILLA_INTERNAL_API
void
Clear
(
)
volatile
{
#
ifdef
__STDC_LIB_EXT1__
memset_s
(
(
void
*
)
this
sizeof
(
VRExternalShmem
)
0
sizeof
(
VRExternalShmem
)
)
;
#
else
size_t
remaining
=
sizeof
(
VRExternalShmem
)
;
volatile
unsigned
char
*
d
=
(
volatile
unsigned
char
*
)
this
;
while
(
remaining
-
-
)
{
*
d
+
+
=
0
;
}
#
endif
}
#
endif
}
;
static_assert
(
std
:
:
is_trivial_v
<
VRSystemState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRBrowserState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRWindowState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRTelemetryState
>
)
;
static_assert
(
std
:
:
is_trivial_v
<
VRExternalShmem
>
"
VRExternalShmem
must
be
a
trivial
type
.
"
)
;
}
}
#
endif
