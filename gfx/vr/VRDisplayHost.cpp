#
include
"
VRDisplayHost
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
ipc
/
VRLayerParent
.
h
"
#
include
"
mozilla
/
layers
/
TextureHost
.
h
"
#
include
"
mozilla
/
dom
/
GamepadBinding
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
d3d11
.
h
>
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
.
.
/
layers
/
d3d11
/
CompositorD3D11
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
elif
defined
(
XP_MACOSX
)
#
include
"
mozilla
/
gfx
/
MacIOSurface
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
VRDisplayHost
:
:
VRDisplayHost
(
VRDeviceType
aType
)
:
mFrameStarted
(
false
)
{
MOZ_COUNT_CTOR
(
VRDisplayHost
)
;
mDisplayInfo
.
mType
=
aType
;
mDisplayInfo
.
mDisplayID
=
VRSystemManager
:
:
AllocateDisplayID
(
)
;
mDisplayInfo
.
mPresentingGroups
=
0
;
mDisplayInfo
.
mGroupMask
=
kVRGroupContent
;
mDisplayInfo
.
mFrameId
=
0
;
}
VRDisplayHost
:
:
~
VRDisplayHost
(
)
{
MOZ_COUNT_DTOR
(
VRDisplayHost
)
;
}
void
VRDisplayHost
:
:
SetGroupMask
(
uint32_t
aGroupMask
)
{
mDisplayInfo
.
mGroupMask
=
aGroupMask
;
}
bool
VRDisplayHost
:
:
GetIsConnected
(
)
{
return
mDisplayInfo
.
mIsConnected
;
}
void
VRDisplayHost
:
:
AddLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
AppendElement
(
aLayer
)
;
mDisplayInfo
.
mPresentingGroups
|
=
aLayer
-
>
GetGroup
(
)
;
if
(
mLayers
.
Length
(
)
=
=
1
)
{
StartPresentation
(
)
;
}
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
vm
-
>
RefreshVRDisplays
(
)
;
}
void
VRDisplayHost
:
:
RemoveLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
RemoveElement
(
aLayer
)
;
if
(
mLayers
.
Length
(
)
=
=
0
)
{
StopPresentation
(
)
;
}
mDisplayInfo
.
mPresentingGroups
=
0
;
for
(
auto
layer
:
mLayers
)
{
mDisplayInfo
.
mPresentingGroups
|
=
layer
-
>
GetGroup
(
)
;
}
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
vm
-
>
RefreshVRDisplays
(
)
;
}
void
VRDisplayHost
:
:
StartFrame
(
)
{
mLastFrameStart
=
TimeStamp
:
:
Now
(
)
;
+
+
mDisplayInfo
.
mFrameId
;
mDisplayInfo
.
mLastSensorState
[
mDisplayInfo
.
mFrameId
%
kVRMaxLatencyFrames
]
=
GetSensorState
(
)
;
mFrameStarted
=
true
;
}
void
VRDisplayHost
:
:
NotifyVSync
(
)
{
const
double
kVRDisplayRAFMaxDuration
=
50
;
bool
bShouldStartFrame
=
false
;
if
(
mDisplayInfo
.
mPresentingGroups
=
=
0
)
{
bShouldStartFrame
=
true
;
}
else
{
if
(
mLastFrameStart
.
IsNull
(
)
)
{
bShouldStartFrame
=
true
;
}
else
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastFrameStart
;
if
(
duration
.
ToMilliseconds
(
)
>
kVRDisplayRAFMaxDuration
)
{
bShouldStartFrame
=
true
;
}
}
}
if
(
bShouldStartFrame
)
{
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
MOZ_ASSERT
(
vm
)
;
vm
-
>
NotifyVRVsync
(
mDisplayInfo
.
mDisplayID
)
;
}
}
void
VRDisplayHost
:
:
SubmitFrame
(
VRLayerParent
*
aLayer
PTextureParent
*
aTexture
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
if
(
(
mDisplayInfo
.
mGroupMask
&
aLayer
-
>
GetGroup
(
)
)
=
=
0
)
{
return
;
}
if
(
!
mFrameStarted
)
{
return
;
}
mFrameStarted
=
false
;
#
if
defined
(
XP_WIN
)
TextureHost
*
th
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
AutoLockTextureHostWithoutCompositor
autoLock
(
th
)
;
if
(
autoLock
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
lock
the
VR
layer
texture
"
)
;
return
;
}
CompositableTextureSourceRef
source
;
if
(
!
th
-
>
BindTextureSource
(
source
)
)
{
NS_WARNING
(
"
The
TextureHost
was
successfully
locked
but
can
'
t
provide
a
TextureSource
"
)
;
return
;
}
MOZ_ASSERT
(
source
)
;
IntSize
texSize
=
source
-
>
GetSize
(
)
;
TextureSourceD3D11
*
sourceD3D11
=
source
-
>
AsSourceD3D11
(
)
;
if
(
!
sourceD3D11
)
{
NS_WARNING
(
"
VRDisplayHost
:
:
SubmitFrame
failed
to
get
a
TextureSourceD3D11
"
)
;
return
;
}
if
(
!
SubmitFrame
(
sourceD3D11
texSize
aLeftEyeRect
aRightEyeRect
)
)
{
return
;
}
#
elif
defined
(
XP_MACOSX
)
TextureHost
*
th
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
MacIOSurface
*
surf
=
th
-
>
GetMacIOSurface
(
)
;
if
(
!
surf
)
{
NS_WARNING
(
"
VRDisplayHost
:
:
SubmitFrame
failed
to
get
a
MacIOSurface
"
)
;
return
;
}
IntSize
texSize
=
gfx
:
:
IntSize
(
surf
-
>
GetDevicePixelWidth
(
)
surf
-
>
GetDevicePixelHeight
(
)
)
;
if
(
!
SubmitFrame
(
surf
texSize
aLeftEyeRect
aRightEyeRect
)
)
{
return
;
}
#
else
NS_WARNING
(
"
WebVR
is
not
supported
on
this
platform
.
"
)
;
return
;
#
endif
#
if
defined
(
XP_WIN
)
|
|
defined
(
XP_MACOSX
)
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
MOZ_ASSERT
(
vm
)
;
vm
-
>
NotifyVRVsync
(
mDisplayInfo
.
mDisplayID
)
;
#
endif
}
bool
VRDisplayHost
:
:
CheckClearDisplayInfoDirty
(
)
{
if
(
mDisplayInfo
=
=
mLastUpdateDisplayInfo
)
{
return
false
;
}
mLastUpdateDisplayInfo
=
mDisplayInfo
;
return
true
;
}
VRControllerHost
:
:
VRControllerHost
(
VRDeviceType
aType
dom
:
:
GamepadHand
aHand
uint32_t
aDisplayID
)
:
mButtonPressed
(
0
)
mButtonTouched
(
0
)
mVibrateIndex
(
0
)
{
MOZ_COUNT_CTOR
(
VRControllerHost
)
;
mControllerInfo
.
mType
=
aType
;
mControllerInfo
.
mHand
=
aHand
;
mControllerInfo
.
mMappingType
=
dom
:
:
GamepadMappingType
:
:
_empty
;
mControllerInfo
.
mDisplayID
=
aDisplayID
;
mControllerInfo
.
mControllerID
=
VRSystemManager
:
:
AllocateControllerID
(
)
;
}
VRControllerHost
:
:
~
VRControllerHost
(
)
{
MOZ_COUNT_DTOR
(
VRControllerHost
)
;
}
const
VRControllerInfo
&
VRControllerHost
:
:
GetControllerInfo
(
)
const
{
return
mControllerInfo
;
}
void
VRControllerHost
:
:
SetButtonPressed
(
uint64_t
aBit
)
{
mButtonPressed
=
aBit
;
}
uint64_t
VRControllerHost
:
:
GetButtonPressed
(
)
{
return
mButtonPressed
;
}
void
VRControllerHost
:
:
SetButtonTouched
(
uint64_t
aBit
)
{
mButtonTouched
=
aBit
;
}
uint64_t
VRControllerHost
:
:
GetButtonTouched
(
)
{
return
mButtonTouched
;
}
void
VRControllerHost
:
:
SetPose
(
const
dom
:
:
GamepadPoseState
&
aPose
)
{
mPose
=
aPose
;
}
const
dom
:
:
GamepadPoseState
&
VRControllerHost
:
:
GetPose
(
)
{
return
mPose
;
}
dom
:
:
GamepadHand
VRControllerHost
:
:
GetHand
(
)
{
return
mControllerInfo
.
mHand
;
}
void
VRControllerHost
:
:
SetVibrateIndex
(
uint64_t
aIndex
)
{
mVibrateIndex
=
aIndex
;
}
uint64_t
VRControllerHost
:
:
GetVibrateIndex
(
)
{
return
mVibrateIndex
;
}
