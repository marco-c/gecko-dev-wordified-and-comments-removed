#
include
"
VRDisplayHost
.
h
"
#
include
"
gfxVR
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
d3d11
.
h
>
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
.
.
/
layers
/
d3d11
/
CompositorD3D11
.
h
"
#
include
"
mozilla
/
layers
/
TextureD3D11
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
VRDisplayHost
:
:
VRDisplayHost
(
VRDeviceType
aType
)
:
mInputFrameID
(
0
)
{
MOZ_COUNT_CTOR
(
VRDisplayHost
)
;
mDisplayInfo
.
mType
=
aType
;
mDisplayInfo
.
mDisplayID
=
VRSystemManager
:
:
AllocateDisplayID
(
)
;
mDisplayInfo
.
mIsPresenting
=
false
;
for
(
int
i
=
0
;
i
<
kMaxLatencyFrames
;
i
+
+
)
{
mLastSensorState
[
i
]
.
Clear
(
)
;
}
}
VRDisplayHost
:
:
~
VRDisplayHost
(
)
{
MOZ_COUNT_DTOR
(
VRDisplayHost
)
;
}
void
VRDisplayHost
:
:
AddLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
AppendElement
(
aLayer
)
;
if
(
mLayers
.
Length
(
)
=
=
1
)
{
StartPresentation
(
)
;
}
mDisplayInfo
.
mIsPresenting
=
mLayers
.
Length
(
)
>
0
;
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
vm
-
>
RefreshVRDisplays
(
)
;
}
void
VRDisplayHost
:
:
RemoveLayer
(
VRLayerParent
*
aLayer
)
{
mLayers
.
RemoveElement
(
aLayer
)
;
if
(
mLayers
.
Length
(
)
=
=
0
)
{
StopPresentation
(
)
;
}
mDisplayInfo
.
mIsPresenting
=
mLayers
.
Length
(
)
>
0
;
VRManager
*
vm
=
VRManager
:
:
Get
(
)
;
vm
-
>
RefreshVRDisplays
(
)
;
}
#
if
defined
(
XP_WIN
)
void
VRDisplayHost
:
:
SubmitFrame
(
VRLayerParent
*
aLayer
const
int32_t
&
aInputFrameID
PTextureParent
*
aTexture
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
int32_t
inputFrameID
=
aInputFrameID
;
if
(
inputFrameID
=
=
0
)
{
inputFrameID
=
mInputFrameID
;
}
if
(
inputFrameID
<
0
)
{
inputFrameID
=
0
;
}
VRHMDSensorState
sensorState
=
mLastSensorState
[
inputFrameID
%
kMaxLatencyFrames
]
;
TextureHost
*
th
=
TextureHost
:
:
AsTextureHost
(
aTexture
)
;
AutoLockTextureHostWithoutCompositor
autoLock
(
th
)
;
if
(
autoLock
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
lock
the
VR
layer
texture
"
)
;
return
;
}
CompositableTextureSourceRef
source
;
if
(
!
th
-
>
BindTextureSource
(
source
)
)
{
NS_WARNING
(
"
The
TextureHost
was
successfully
locked
but
can
'
t
provide
a
TextureSource
"
)
;
return
;
}
MOZ_ASSERT
(
source
)
;
IntSize
texSize
=
source
-
>
GetSize
(
)
;
TextureSourceD3D11
*
sourceD3D11
=
source
-
>
AsSourceD3D11
(
)
;
if
(
!
sourceD3D11
)
{
NS_WARNING
(
"
WebVR
support
currently
only
implemented
for
D3D11
"
)
;
return
;
}
SubmitFrame
(
sourceD3D11
texSize
sensorState
aLeftEyeRect
aRightEyeRect
)
;
}
#
else
void
VRDisplayHost
:
:
SubmitFrame
(
VRLayerParent
*
aLayer
const
int32_t
&
aInputFrameID
PTextureParent
*
aTexture
const
gfx
:
:
Rect
&
aLeftEyeRect
const
gfx
:
:
Rect
&
aRightEyeRect
)
{
NS_WARNING
(
"
WebVR
only
supported
in
Windows
.
"
)
;
}
#
endif
bool
VRDisplayHost
:
:
CheckClearDisplayInfoDirty
(
)
{
if
(
mDisplayInfo
=
=
mLastUpdateDisplayInfo
)
{
return
false
;
}
mLastUpdateDisplayInfo
=
mDisplayInfo
;
return
true
;
}
VRControllerHost
:
:
VRControllerHost
(
VRDeviceType
aType
)
{
MOZ_COUNT_CTOR
(
VRControllerHost
)
;
mControllerInfo
.
mType
=
aType
;
mControllerInfo
.
mControllerID
=
VRSystemManager
:
:
AllocateDisplayID
(
)
;
}
VRControllerHost
:
:
~
VRControllerHost
(
)
{
MOZ_COUNT_DTOR
(
VRControllerHost
)
;
}
const
VRControllerInfo
&
VRControllerHost
:
:
GetControllerInfo
(
)
const
{
return
mControllerInfo
;
}
void
VRControllerHost
:
:
SetIndex
(
uint32_t
aIndex
)
{
mIndex
=
aIndex
;
}
uint32_t
VRControllerHost
:
:
GetIndex
(
)
{
return
mIndex
;
}
void
VRControllerHost
:
:
SetButtonPressed
(
uint64_t
aBit
)
{
mButtonPressed
=
aBit
;
}
uint64_t
VRControllerHost
:
:
GetButtonPressed
(
)
{
return
mButtonPressed
;
}
void
VRControllerHost
:
:
SetPose
(
const
dom
:
:
GamepadPoseState
&
aPose
)
{
mPose
=
aPose
;
}
const
dom
:
:
GamepadPoseState
&
VRControllerHost
:
:
GetPose
(
)
{
return
mPose
;
}
void
VRControllerHost
:
:
SetHand
(
dom
:
:
GamepadHand
aHand
)
{
mControllerInfo
.
mHand
=
aHand
;
}
dom
:
:
GamepadHand
VRControllerHost
:
:
GetHand
(
)
{
return
mControllerInfo
.
mHand
;
}
