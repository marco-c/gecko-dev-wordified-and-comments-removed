#
include
"
cairoint
.
h
"
#
include
"
cairo
-
spans
-
private
.
h
"
#
include
"
cairo
-
error
-
private
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
.
h
>
#
include
<
setjmp
.
h
>
#
define
I
static
#
define
GLITTER_HAVE_STATUS_T
1
#
define
GLITTER_STATUS_SUCCESS
CAIRO_STATUS_SUCCESS
#
define
GLITTER_STATUS_NO_MEMORY
CAIRO_STATUS_NO_MEMORY
typedef
cairo_status_t
glitter_status_t
;
#
define
GLITTER_INPUT_BITS
CAIRO_FIXED_FRAC_BITS
#
define
GRID_X_BITS
2
#
define
GRID_Y_BITS
2
struct
pool
;
struct
cell_list
;
#
ifndef
GLITTER_INPUT_BITS
#
define
GLITTER_INPUT_BITS
8
#
endif
#
define
GLITTER_INPUT_SCALE
(
1
<
<
GLITTER_INPUT_BITS
)
typedef
int
glitter_input_scaled_t
;
#
if
!
GLITTER_HAVE_STATUS_T
typedef
enum
{
GLITTER_STATUS_SUCCESS
=
0
GLITTER_STATUS_NO_MEMORY
}
glitter_status_t
;
#
endif
#
ifndef
I
#
define
I
#
endif
typedef
struct
glitter_scan_converter
glitter_scan_converter_t
;
I
glitter_status_t
glitter_scan_converter_reset
(
glitter_scan_converter_t
*
converter
int
xmin
int
ymin
int
xmax
int
ymax
)
;
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
.
h
>
typedef
int
grid_scaled_t
;
typedef
int
grid_scaled_x_t
;
typedef
int
grid_scaled_y_t
;
#
if
!
defined
(
GRID_X
)
&
&
!
defined
(
GRID_X_BITS
)
#
define
GRID_X_BITS
8
#
endif
#
if
!
defined
(
GRID_Y
)
&
&
!
defined
(
GRID_Y_BITS
)
#
define
GRID_Y
15
#
endif
#
ifdef
GRID_X_BITS
#
define
GRID_X
(
1
<
<
GRID_X_BITS
)
#
endif
#
ifdef
GRID_Y_BITS
#
define
GRID_Y
(
1
<
<
GRID_Y_BITS
)
#
endif
#
if
defined
(
GRID_X_TO_INT_FRAC
)
#
elif
defined
(
GRID_X_BITS
)
#
define
GRID_X_TO_INT_FRAC
(
x
i
f
)
\
_GRID_TO_INT_FRAC_shift
(
x
i
f
GRID_X_BITS
)
#
else
#
define
GRID_X_TO_INT_FRAC
(
x
i
f
)
\
_GRID_TO_INT_FRAC_general
(
x
i
f
GRID_X
)
#
endif
#
define
_GRID_TO_INT_FRAC_general
(
t
i
f
m
)
do
{
\
(
i
)
=
(
t
)
/
(
m
)
;
\
(
f
)
=
(
t
)
%
(
m
)
;
\
if
(
(
f
)
<
0
)
{
\
-
-
(
i
)
;
\
(
f
)
+
=
(
m
)
;
\
}
\
}
while
(
0
)
#
define
_GRID_TO_INT_FRAC_shift
(
t
i
f
b
)
do
{
\
(
f
)
=
(
t
)
&
(
(
1
<
<
(
b
)
)
-
1
)
;
\
(
i
)
=
(
t
)
>
>
(
b
)
;
\
}
while
(
0
)
#
define
GRID_XY
(
2
*
GRID_X
*
GRID_Y
)
/
*
Unit
area
on
the
grid
.
*
/
#
if
GRID_XY
=
=
510
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
+
1
)
>
>
1
)
#
elif
GRID_XY
=
=
255
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
c
)
#
elif
GRID_XY
=
=
64
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
<
<
2
)
|
-
(
(
(
c
)
&
0x40
)
>
>
6
)
)
#
elif
GRID_XY
=
=
32
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
<
<
3
)
|
-
(
(
(
c
)
&
0x20
)
>
>
5
)
)
#
elif
GRID_XY
=
=
128
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
(
c
)
<
<
1
)
|
-
(
(
c
)
>
>
7
)
)
&
255
)
#
elif
GRID_XY
=
=
256
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
|
-
(
(
c
)
>
>
8
)
)
&
255
)
#
elif
GRID_XY
=
=
15
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
<
<
4
)
+
(
c
)
)
#
elif
GRID_XY
=
=
2
*
256
*
15
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
+
(
(
c
)
<
<
4
)
+
256
)
>
>
9
)
#
else
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
*
255
+
GRID_XY
/
2
)
/
GRID_XY
)
#
endif
#
define
UNROLL3
(
x
)
x
x
x
struct
quorem
{
int32_t
quo
;
int32_t
rem
;
}
;
struct
_pool_chunk
{
size_t
size
;
size_t
capacity
;
struct
_pool_chunk
*
prev_chunk
;
}
;
struct
pool
{
struct
_pool_chunk
*
current
;
jmp_buf
*
jmp
;
struct
_pool_chunk
*
first_free
;
size_t
default_capacity
;
struct
_pool_chunk
sentinel
[
1
]
;
}
;
struct
edge
{
struct
edge
*
next
*
prev
;
grid_scaled_y_t
height_left
;
int
dir
;
int
vertical
;
struct
quorem
x
;
struct
quorem
dxdy
;
grid_scaled_y_t
ytop
;
grid_scaled_y_t
dy
;
}
;
#
define
EDGE_Y_BUCKET_INDEX
(
y
ymin
)
(
(
(
y
)
-
(
ymin
)
)
/
GRID_Y
)
struct
polygon
{
grid_scaled_y_t
ymin
ymax
;
struct
edge
*
*
y_buckets
;
struct
edge
*
y_buckets_embedded
[
64
]
;
struct
{
struct
pool
base
[
1
]
;
struct
edge
embedded
[
32
]
;
}
edge_pool
;
}
;
struct
cell
{
struct
cell
*
next
;
int
x
;
int16_t
uncovered_area
;
int16_t
covered_height
;
}
;
struct
cell_list
{
struct
cell
head
tail
;
struct
cell
*
cursor
*
rewind
;
struct
{
struct
pool
base
[
1
]
;
struct
cell
embedded
[
32
]
;
}
cell_pool
;
}
;
struct
cell_pair
{
struct
cell
*
cell1
;
struct
cell
*
cell2
;
}
;
struct
active_list
{
struct
edge
head
tail
;
grid_scaled_y_t
min_height
;
int
is_vertical
;
}
;
struct
glitter_scan_converter
{
struct
polygon
polygon
[
1
]
;
struct
active_list
active
[
1
]
;
struct
cell_list
coverages
[
1
]
;
cairo_half_open_span_t
*
spans
;
cairo_half_open_span_t
spans_embedded
[
64
]
;
grid_scaled_x_t
xmin
xmax
;
grid_scaled_y_t
ymin
ymax
;
}
;
inline
static
struct
quorem
floored_divrem
(
int
a
int
b
)
{
struct
quorem
qr
;
qr
.
quo
=
a
/
b
;
qr
.
rem
=
a
%
b
;
if
(
(
a
^
b
)
<
0
&
&
qr
.
rem
)
{
qr
.
quo
-
=
1
;
qr
.
rem
+
=
b
;
}
return
qr
;
}
static
struct
quorem
floored_muldivrem
(
int
x
int
a
int
b
)
{
struct
quorem
qr
;
long
long
xa
=
(
long
long
)
x
*
a
;
qr
.
quo
=
xa
/
b
;
qr
.
rem
=
xa
%
b
;
if
(
(
xa
>
=
0
)
!
=
(
b
>
=
0
)
&
&
qr
.
rem
)
{
qr
.
quo
-
=
1
;
qr
.
rem
+
=
b
;
}
return
qr
;
}
static
struct
_pool_chunk
*
_pool_chunk_init
(
struct
_pool_chunk
*
p
struct
_pool_chunk
*
prev_chunk
size_t
capacity
)
{
p
-
>
prev_chunk
=
prev_chunk
;
p
-
>
size
=
0
;
p
-
>
capacity
=
capacity
;
return
p
;
}
static
struct
_pool_chunk
*
_pool_chunk_create
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
p
;
p
=
_cairo_malloc
(
size
+
sizeof
(
struct
_pool_chunk
)
)
;
if
(
unlikely
(
NULL
=
=
p
)
)
longjmp
(
*
pool
-
>
jmp
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
)
;
return
_pool_chunk_init
(
p
pool
-
>
current
size
)
;
}
static
void
pool_init
(
struct
pool
*
pool
jmp_buf
*
jmp
size_t
default_capacity
size_t
embedded_capacity
)
{
pool
-
>
jmp
=
jmp
;
pool
-
>
current
=
pool
-
>
sentinel
;
pool
-
>
first_free
=
NULL
;
pool
-
>
default_capacity
=
default_capacity
;
_pool_chunk_init
(
pool
-
>
sentinel
NULL
embedded_capacity
)
;
}
static
void
pool_fini
(
struct
pool
*
pool
)
{
struct
_pool_chunk
*
p
=
pool
-
>
current
;
do
{
while
(
NULL
!
=
p
)
{
struct
_pool_chunk
*
prev
=
p
-
>
prev_chunk
;
if
(
p
!
=
pool
-
>
sentinel
)
free
(
p
)
;
p
=
prev
;
}
p
=
pool
-
>
first_free
;
pool
-
>
first_free
=
NULL
;
}
while
(
NULL
!
=
p
)
;
}
static
void
*
_pool_alloc_from_new_chunk
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
chunk
;
void
*
obj
;
size_t
capacity
;
capacity
=
size
;
chunk
=
NULL
;
if
(
size
<
pool
-
>
default_capacity
)
{
capacity
=
pool
-
>
default_capacity
;
chunk
=
pool
-
>
first_free
;
if
(
chunk
)
{
pool
-
>
first_free
=
chunk
-
>
prev_chunk
;
_pool_chunk_init
(
chunk
pool
-
>
current
chunk
-
>
capacity
)
;
}
}
if
(
NULL
=
=
chunk
)
chunk
=
_pool_chunk_create
(
pool
capacity
)
;
pool
-
>
current
=
chunk
;
obj
=
(
(
unsigned
char
*
)
chunk
+
sizeof
(
*
chunk
)
+
chunk
-
>
size
)
;
chunk
-
>
size
+
=
size
;
return
obj
;
}
inline
static
void
*
pool_alloc
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
chunk
=
pool
-
>
current
;
if
(
size
<
=
chunk
-
>
capacity
-
chunk
-
>
size
)
{
void
*
obj
=
(
(
unsigned
char
*
)
chunk
+
sizeof
(
*
chunk
)
+
chunk
-
>
size
)
;
chunk
-
>
size
+
=
size
;
return
obj
;
}
else
{
return
_pool_alloc_from_new_chunk
(
pool
size
)
;
}
}
static
void
pool_reset
(
struct
pool
*
pool
)
{
struct
_pool_chunk
*
chunk
=
pool
-
>
current
;
if
(
chunk
!
=
pool
-
>
sentinel
)
{
while
(
chunk
-
>
prev_chunk
!
=
pool
-
>
sentinel
)
{
chunk
=
chunk
-
>
prev_chunk
;
}
chunk
-
>
prev_chunk
=
pool
-
>
first_free
;
pool
-
>
first_free
=
pool
-
>
current
;
}
pool
-
>
current
=
pool
-
>
sentinel
;
pool
-
>
sentinel
-
>
size
=
0
;
}
inline
static
void
cell_list_rewind
(
struct
cell_list
*
cells
)
{
cells
-
>
cursor
=
&
cells
-
>
head
;
}
inline
static
void
cell_list_maybe_rewind
(
struct
cell_list
*
cells
int
x
)
{
if
(
x
<
cells
-
>
cursor
-
>
x
)
{
cells
-
>
cursor
=
cells
-
>
rewind
;
if
(
x
<
cells
-
>
cursor
-
>
x
)
cells
-
>
cursor
=
&
cells
-
>
head
;
}
}
inline
static
void
cell_list_set_rewind
(
struct
cell_list
*
cells
)
{
cells
-
>
rewind
=
cells
-
>
cursor
;
}
static
void
cell_list_init
(
struct
cell_list
*
cells
jmp_buf
*
jmp
)
{
pool_init
(
cells
-
>
cell_pool
.
base
jmp
256
*
sizeof
(
struct
cell
)
sizeof
(
cells
-
>
cell_pool
.
embedded
)
)
;
cells
-
>
tail
.
next
=
NULL
;
cells
-
>
tail
.
x
=
INT_MAX
;
cells
-
>
head
.
x
=
INT_MIN
;
cells
-
>
head
.
next
=
&
cells
-
>
tail
;
cell_list_rewind
(
cells
)
;
}
static
void
cell_list_fini
(
struct
cell_list
*
cells
)
{
pool_fini
(
cells
-
>
cell_pool
.
base
)
;
}
inline
static
void
cell_list_reset
(
struct
cell_list
*
cells
)
{
cell_list_rewind
(
cells
)
;
cells
-
>
head
.
next
=
&
cells
-
>
tail
;
pool_reset
(
cells
-
>
cell_pool
.
base
)
;
}
inline
static
struct
cell
*
cell_list_alloc
(
struct
cell_list
*
cells
struct
cell
*
tail
int
x
)
{
struct
cell
*
cell
;
cell
=
pool_alloc
(
cells
-
>
cell_pool
.
base
sizeof
(
struct
cell
)
)
;
cell
-
>
next
=
tail
-
>
next
;
tail
-
>
next
=
cell
;
cell
-
>
x
=
x
;
*
(
uint32_t
*
)
&
cell
-
>
uncovered_area
=
0
;
return
cell
;
}
inline
static
struct
cell
*
cell_list_find
(
struct
cell_list
*
cells
int
x
)
{
struct
cell
*
tail
=
cells
-
>
cursor
;
if
(
tail
-
>
x
=
=
x
)
return
tail
;
while
(
1
)
{
UNROLL3
(
{
if
(
tail
-
>
next
-
>
x
>
x
)
break
;
tail
=
tail
-
>
next
;
}
)
;
}
if
(
tail
-
>
x
!
=
x
)
tail
=
cell_list_alloc
(
cells
tail
x
)
;
return
cells
-
>
cursor
=
tail
;
}
inline
static
struct
cell_pair
cell_list_find_pair
(
struct
cell_list
*
cells
int
x1
int
x2
)
{
struct
cell_pair
pair
;
pair
.
cell1
=
cells
-
>
cursor
;
while
(
1
)
{
UNROLL3
(
{
if
(
pair
.
cell1
-
>
next
-
>
x
>
x1
)
break
;
pair
.
cell1
=
pair
.
cell1
-
>
next
;
}
)
;
}
if
(
pair
.
cell1
-
>
x
!
=
x1
)
pair
.
cell1
=
cell_list_alloc
(
cells
pair
.
cell1
x1
)
;
pair
.
cell2
=
pair
.
cell1
;
while
(
1
)
{
UNROLL3
(
{
if
(
pair
.
cell2
-
>
next
-
>
x
>
x2
)
break
;
pair
.
cell2
=
pair
.
cell2
-
>
next
;
}
)
;
}
if
(
pair
.
cell2
-
>
x
!
=
x2
)
pair
.
cell2
=
cell_list_alloc
(
cells
pair
.
cell2
x2
)
;
cells
-
>
cursor
=
pair
.
cell2
;
return
pair
;
}
inline
static
void
cell_list_add_subspan
(
struct
cell_list
*
cells
grid_scaled_x_t
x1
grid_scaled_x_t
x2
)
{
int
ix1
fx1
;
int
ix2
fx2
;
if
(
x1
=
=
x2
)
return
;
GRID_X_TO_INT_FRAC
(
x1
ix1
fx1
)
;
GRID_X_TO_INT_FRAC
(
x2
ix2
fx2
)
;
if
(
ix1
!
=
ix2
)
{
struct
cell_pair
p
;
p
=
cell_list_find_pair
(
cells
ix1
ix2
)
;
p
.
cell1
-
>
uncovered_area
+
=
2
*
fx1
;
+
+
p
.
cell1
-
>
covered_height
;
p
.
cell2
-
>
uncovered_area
-
=
2
*
fx2
;
-
-
p
.
cell2
-
>
covered_height
;
}
else
{
struct
cell
*
cell
=
cell_list_find
(
cells
ix1
)
;
cell
-
>
uncovered_area
+
=
2
*
(
fx1
-
fx2
)
;
}
}
static
void
cell_list_render_edge
(
struct
cell_list
*
cells
struct
edge
*
edge
int
sign
)
{
grid_scaled_x_t
fx
;
struct
cell
*
cell
;
int
ix
;
GRID_X_TO_INT_FRAC
(
edge
-
>
x
.
quo
ix
fx
)
;
cell
=
cell_list_find
(
cells
ix
)
;
cell
-
>
covered_height
+
=
sign
*
GRID_Y
;
cell
-
>
uncovered_area
+
=
sign
*
2
*
fx
*
GRID_Y
;
}
static
void
polygon_init
(
struct
polygon
*
polygon
jmp_buf
*
jmp
)
{
polygon
-
>
ymin
=
polygon
-
>
ymax
=
0
;
polygon
-
>
y_buckets
=
polygon
-
>
y_buckets_embedded
;
pool_init
(
polygon
-
>
edge_pool
.
base
jmp
8192
-
sizeof
(
struct
_pool_chunk
)
sizeof
(
polygon
-
>
edge_pool
.
embedded
)
)
;
}
static
void
polygon_fini
(
struct
polygon
*
polygon
)
{
if
(
polygon
-
>
y_buckets
!
=
polygon
-
>
y_buckets_embedded
)
free
(
polygon
-
>
y_buckets
)
;
pool_fini
(
polygon
-
>
edge_pool
.
base
)
;
}
static
glitter_status_t
polygon_reset
(
struct
polygon
*
polygon
grid_scaled_y_t
ymin
grid_scaled_y_t
ymax
)
{
unsigned
h
=
ymax
-
ymin
;
unsigned
num_buckets
=
EDGE_Y_BUCKET_INDEX
(
ymax
+
GRID_Y
-
1
ymin
)
;
pool_reset
(
polygon
-
>
edge_pool
.
base
)
;
if
(
unlikely
(
h
>
0x7FFFFFFFU
-
GRID_Y
)
)
goto
bail_no_mem
;
if
(
polygon
-
>
y_buckets
!
=
polygon
-
>
y_buckets_embedded
)
free
(
polygon
-
>
y_buckets
)
;
polygon
-
>
y_buckets
=
polygon
-
>
y_buckets_embedded
;
if
(
num_buckets
>
ARRAY_LENGTH
(
polygon
-
>
y_buckets_embedded
)
)
{
polygon
-
>
y_buckets
=
_cairo_malloc_ab
(
num_buckets
sizeof
(
struct
edge
*
)
)
;
if
(
unlikely
(
NULL
=
=
polygon
-
>
y_buckets
)
)
goto
bail_no_mem
;
}
memset
(
polygon
-
>
y_buckets
0
num_buckets
*
sizeof
(
struct
edge
*
)
)
;
polygon
-
>
ymin
=
ymin
;
polygon
-
>
ymax
=
ymax
;
return
GLITTER_STATUS_SUCCESS
;
bail_no_mem
:
polygon
-
>
ymin
=
0
;
polygon
-
>
ymax
=
0
;
return
GLITTER_STATUS_NO_MEMORY
;
}
static
void
_polygon_insert_edge_into_its_y_bucket
(
struct
polygon
*
polygon
struct
edge
*
e
)
{
unsigned
ix
=
EDGE_Y_BUCKET_INDEX
(
e
-
>
ytop
polygon
-
>
ymin
)
;
struct
edge
*
*
ptail
=
&
polygon
-
>
y_buckets
[
ix
]
;
e
-
>
next
=
*
ptail
;
*
ptail
=
e
;
}
inline
static
void
polygon_add_edge
(
struct
polygon
*
polygon
const
cairo_edge_t
*
edge
)
{
struct
edge
*
e
;
grid_scaled_x_t
dx
;
grid_scaled_y_t
dy
;
grid_scaled_y_t
ytop
ybot
;
grid_scaled_y_t
ymin
=
polygon
-
>
ymin
;
grid_scaled_y_t
ymax
=
polygon
-
>
ymax
;
if
(
unlikely
(
edge
-
>
top
>
=
ymax
|
|
edge
-
>
bottom
<
=
ymin
)
)
return
;
e
=
pool_alloc
(
polygon
-
>
edge_pool
.
base
sizeof
(
struct
edge
)
)
;
dx
=
edge
-
>
line
.
p2
.
x
-
edge
-
>
line
.
p1
.
x
;
dy
=
edge
-
>
line
.
p2
.
y
-
edge
-
>
line
.
p1
.
y
;
e
-
>
dy
=
dy
;
e
-
>
dir
=
edge
-
>
dir
;
ytop
=
edge
-
>
top
>
=
ymin
?
edge
-
>
top
:
ymin
;
ybot
=
edge
-
>
bottom
<
=
ymax
?
edge
-
>
bottom
:
ymax
;
e
-
>
ytop
=
ytop
;
e
-
>
height_left
=
ybot
-
ytop
;
if
(
dx
=
=
0
)
{
e
-
>
vertical
=
TRUE
;
e
-
>
x
.
quo
=
edge
-
>
line
.
p1
.
x
;
e
-
>
x
.
rem
=
0
;
e
-
>
dxdy
.
quo
=
0
;
e
-
>
dxdy
.
rem
=
0
;
}
else
{
e
-
>
vertical
=
FALSE
;
e
-
>
dxdy
=
floored_divrem
(
dx
dy
)
;
if
(
ytop
=
=
edge
-
>
line
.
p1
.
y
)
{
e
-
>
x
.
quo
=
edge
-
>
line
.
p1
.
x
;
e
-
>
x
.
rem
=
0
;
}
else
{
e
-
>
x
=
floored_muldivrem
(
ytop
-
edge
-
>
line
.
p1
.
y
dx
dy
)
;
e
-
>
x
.
quo
+
=
edge
-
>
line
.
p1
.
x
;
}
}
_polygon_insert_edge_into_its_y_bucket
(
polygon
e
)
;
e
-
>
x
.
rem
-
=
dy
;
}
static
void
active_list_reset
(
struct
active_list
*
active
)
{
active
-
>
head
.
vertical
=
1
;
active
-
>
head
.
height_left
=
INT_MAX
;
active
-
>
head
.
x
.
quo
=
INT_MIN
;
active
-
>
head
.
prev
=
NULL
;
active
-
>
head
.
next
=
&
active
-
>
tail
;
active
-
>
tail
.
prev
=
&
active
-
>
head
;
active
-
>
tail
.
next
=
NULL
;
active
-
>
tail
.
x
.
quo
=
INT_MAX
;
active
-
>
tail
.
height_left
=
INT_MAX
;
active
-
>
tail
.
vertical
=
1
;
active
-
>
min_height
=
0
;
active
-
>
is_vertical
=
1
;
}
static
void
active_list_init
(
struct
active_list
*
active
)
{
active_list_reset
(
active
)
;
}
static
struct
edge
*
merge_sorted_edges
(
struct
edge
*
head_a
struct
edge
*
head_b
)
{
struct
edge
*
head
*
*
next
*
prev
;
int32_t
x
;
prev
=
head_a
-
>
prev
;
next
=
&
head
;
if
(
head_a
-
>
x
.
quo
<
=
head_b
-
>
x
.
quo
)
{
head
=
head_a
;
}
else
{
head
=
head_b
;
head_b
-
>
prev
=
prev
;
goto
start_with_b
;
}
do
{
x
=
head_b
-
>
x
.
quo
;
while
(
head_a
!
=
NULL
&
&
head_a
-
>
x
.
quo
<
=
x
)
{
prev
=
head_a
;
next
=
&
head_a
-
>
next
;
head_a
=
head_a
-
>
next
;
}
head_b
-
>
prev
=
prev
;
*
next
=
head_b
;
if
(
head_a
=
=
NULL
)
return
head
;
start_with_b
:
x
=
head_a
-
>
x
.
quo
;
while
(
head_b
!
=
NULL
&
&
head_b
-
>
x
.
quo
<
=
x
)
{
prev
=
head_b
;
next
=
&
head_b
-
>
next
;
head_b
=
head_b
-
>
next
;
}
head_a
-
>
prev
=
prev
;
*
next
=
head_a
;
if
(
head_b
=
=
NULL
)
return
head
;
}
while
(
1
)
;
}
static
struct
edge
*
sort_edges
(
struct
edge
*
list
unsigned
int
level
struct
edge
*
*
head_out
)
{
struct
edge
*
head_other
*
remaining
;
unsigned
int
i
;
head_other
=
list
-
>
next
;
if
(
head_other
=
=
NULL
)
{
*
head_out
=
list
;
return
NULL
;
}
remaining
=
head_other
-
>
next
;
if
(
list
-
>
x
.
quo
<
=
head_other
-
>
x
.
quo
)
{
*
head_out
=
list
;
head_other
-
>
next
=
NULL
;
}
else
{
*
head_out
=
head_other
;
head_other
-
>
prev
=
list
-
>
prev
;
head_other
-
>
next
=
list
;
list
-
>
prev
=
head_other
;
list
-
>
next
=
NULL
;
}
for
(
i
=
0
;
i
<
level
&
&
remaining
;
i
+
+
)
{
remaining
=
sort_edges
(
remaining
i
&
head_other
)
;
*
head_out
=
merge_sorted_edges
(
*
head_out
head_other
)
;
}
return
remaining
;
}
static
struct
edge
*
merge_unsorted_edges
(
struct
edge
*
head
struct
edge
*
unsorted
)
{
sort_edges
(
unsorted
UINT_MAX
&
unsorted
)
;
return
merge_sorted_edges
(
head
unsorted
)
;
}
inline
static
int
can_do_full_row
(
struct
active_list
*
active
)
{
const
struct
edge
*
e
;
if
(
active
-
>
min_height
<
=
0
)
{
int
min_height
=
INT_MAX
;
int
is_vertical
=
1
;
e
=
active
-
>
head
.
next
;
while
(
NULL
!
=
e
)
{
if
(
e
-
>
height_left
<
min_height
)
min_height
=
e
-
>
height_left
;
is_vertical
&
=
e
-
>
vertical
;
e
=
e
-
>
next
;
}
active
-
>
is_vertical
=
is_vertical
;
active
-
>
min_height
=
min_height
;
}
if
(
active
-
>
min_height
<
GRID_Y
)
return
0
;
return
active
-
>
is_vertical
;
}
inline
static
void
active_list_merge_edges_from_bucket
(
struct
active_list
*
active
struct
edge
*
edges
)
{
active
-
>
head
.
next
=
merge_unsorted_edges
(
active
-
>
head
.
next
edges
)
;
}
inline
static
void
polygon_fill_buckets
(
struct
active_list
*
active
struct
edge
*
edge
int
y
struct
edge
*
*
buckets
)
{
grid_scaled_y_t
min_height
=
active
-
>
min_height
;
int
is_vertical
=
active
-
>
is_vertical
;
while
(
edge
)
{
struct
edge
*
next
=
edge
-
>
next
;
int
suby
=
edge
-
>
ytop
-
y
;
if
(
buckets
[
suby
]
)
buckets
[
suby
]
-
>
prev
=
edge
;
edge
-
>
next
=
buckets
[
suby
]
;
edge
-
>
prev
=
NULL
;
buckets
[
suby
]
=
edge
;
if
(
edge
-
>
height_left
<
min_height
)
min_height
=
edge
-
>
height_left
;
is_vertical
&
=
edge
-
>
vertical
;
edge
=
next
;
}
active
-
>
is_vertical
=
is_vertical
;
active
-
>
min_height
=
min_height
;
}
inline
static
void
sub_row
(
struct
active_list
*
active
struct
cell_list
*
coverages
unsigned
int
mask
)
{
struct
edge
*
edge
=
active
-
>
head
.
next
;
int
xstart
=
INT_MIN
prev_x
=
INT_MIN
;
int
winding
=
0
;
cell_list_rewind
(
coverages
)
;
while
(
&
active
-
>
tail
!
=
edge
)
{
struct
edge
*
next
=
edge
-
>
next
;
int
xend
=
edge
-
>
x
.
quo
;
if
(
-
-
edge
-
>
height_left
)
{
edge
-
>
x
.
quo
+
=
edge
-
>
dxdy
.
quo
;
edge
-
>
x
.
rem
+
=
edge
-
>
dxdy
.
rem
;
if
(
edge
-
>
x
.
rem
>
=
0
)
{
+
+
edge
-
>
x
.
quo
;
edge
-
>
x
.
rem
-
=
edge
-
>
dy
;
}
if
(
edge
-
>
x
.
quo
<
prev_x
)
{
struct
edge
*
pos
=
edge
-
>
prev
;
pos
-
>
next
=
next
;
next
-
>
prev
=
pos
;
do
{
pos
=
pos
-
>
prev
;
}
while
(
edge
-
>
x
.
quo
<
pos
-
>
x
.
quo
)
;
pos
-
>
next
-
>
prev
=
edge
;
edge
-
>
next
=
pos
-
>
next
;
edge
-
>
prev
=
pos
;
pos
-
>
next
=
edge
;
}
else
prev_x
=
edge
-
>
x
.
quo
;
}
else
{
edge
-
>
prev
-
>
next
=
next
;
next
-
>
prev
=
edge
-
>
prev
;
}
winding
+
=
edge
-
>
dir
;
if
(
(
winding
&
mask
)
=
=
0
)
{
if
(
next
-
>
x
.
quo
!
=
xend
)
{
cell_list_add_subspan
(
coverages
xstart
xend
)
;
xstart
=
INT_MIN
;
}
}
else
if
(
xstart
=
=
INT_MIN
)
xstart
=
xend
;
edge
=
next
;
}
}
inline
static
void
dec
(
struct
edge
*
e
int
h
)
{
e
-
>
height_left
-
=
h
;
if
(
e
-
>
height_left
=
=
0
)
{
e
-
>
prev
-
>
next
=
e
-
>
next
;
e
-
>
next
-
>
prev
=
e
-
>
prev
;
}
}
static
void
full_row
(
struct
active_list
*
active
struct
cell_list
*
coverages
unsigned
int
mask
)
{
struct
edge
*
left
=
active
-
>
head
.
next
;
while
(
&
active
-
>
tail
!
=
left
)
{
struct
edge
*
right
;
int
winding
;
dec
(
left
GRID_Y
)
;
winding
=
left
-
>
dir
;
right
=
left
-
>
next
;
do
{
dec
(
right
GRID_Y
)
;
winding
+
=
right
-
>
dir
;
if
(
(
winding
&
mask
)
=
=
0
&
&
right
-
>
next
-
>
x
.
quo
!
=
right
-
>
x
.
quo
)
break
;
right
=
right
-
>
next
;
}
while
(
1
)
;
cell_list_set_rewind
(
coverages
)
;
cell_list_render_edge
(
coverages
left
+
1
)
;
cell_list_render_edge
(
coverages
right
-
1
)
;
left
=
right
-
>
next
;
}
}
static
void
_glitter_scan_converter_init
(
glitter_scan_converter_t
*
converter
jmp_buf
*
jmp
)
{
polygon_init
(
converter
-
>
polygon
jmp
)
;
active_list_init
(
converter
-
>
active
)
;
cell_list_init
(
converter
-
>
coverages
jmp
)
;
converter
-
>
xmin
=
0
;
converter
-
>
ymin
=
0
;
converter
-
>
xmax
=
0
;
converter
-
>
ymax
=
0
;
}
static
void
_glitter_scan_converter_fini
(
glitter_scan_converter_t
*
self
)
{
if
(
self
-
>
spans
!
=
self
-
>
spans_embedded
)
free
(
self
-
>
spans
)
;
polygon_fini
(
self
-
>
polygon
)
;
cell_list_fini
(
self
-
>
coverages
)
;
self
-
>
xmin
=
0
;
self
-
>
ymin
=
0
;
self
-
>
xmax
=
0
;
self
-
>
ymax
=
0
;
}
static
grid_scaled_t
int_to_grid_scaled
(
int
i
int
scale
)
{
if
(
i
>
=
0
)
{
if
(
i
>
=
INT_MAX
/
scale
)
i
=
INT_MAX
/
scale
;
}
else
{
if
(
i
<
=
INT_MIN
/
scale
)
i
=
INT_MIN
/
scale
;
}
return
i
*
scale
;
}
#
define
int_to_grid_scaled_x
(
x
)
int_to_grid_scaled
(
(
x
)
GRID_X
)
#
define
int_to_grid_scaled_y
(
x
)
int_to_grid_scaled
(
(
x
)
GRID_Y
)
I
glitter_status_t
glitter_scan_converter_reset
(
glitter_scan_converter_t
*
converter
int
xmin
int
ymin
int
xmax
int
ymax
)
{
glitter_status_t
status
;
int
max_num_spans
;
converter
-
>
xmin
=
0
;
converter
-
>
xmax
=
0
;
converter
-
>
ymin
=
0
;
converter
-
>
ymax
=
0
;
max_num_spans
=
xmax
-
xmin
+
1
;
if
(
max_num_spans
>
ARRAY_LENGTH
(
converter
-
>
spans_embedded
)
)
{
converter
-
>
spans
=
_cairo_malloc_ab
(
max_num_spans
sizeof
(
cairo_half_open_span_t
)
)
;
if
(
unlikely
(
converter
-
>
spans
=
=
NULL
)
)
return
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
}
else
converter
-
>
spans
=
converter
-
>
spans_embedded
;
xmin
=
int_to_grid_scaled_x
(
xmin
)
;
ymin
=
int_to_grid_scaled_y
(
ymin
)
;
xmax
=
int_to_grid_scaled_x
(
xmax
)
;
ymax
=
int_to_grid_scaled_y
(
ymax
)
;
active_list_reset
(
converter
-
>
active
)
;
cell_list_reset
(
converter
-
>
coverages
)
;
status
=
polygon_reset
(
converter
-
>
polygon
ymin
ymax
)
;
if
(
status
)
return
status
;
converter
-
>
xmin
=
xmin
;
converter
-
>
xmax
=
xmax
;
converter
-
>
ymin
=
ymin
;
converter
-
>
ymax
=
ymax
;
return
GLITTER_STATUS_SUCCESS
;
}
#
if
!
defined
(
INPUT_TO_GRID_Y
)
&
&
defined
(
GRID_Y_BITS
)
&
&
GRID_Y_BITS
<
=
GLITTER_INPUT_BITS
#
define
INPUT_TO_GRID_Y
(
in
out
)
(
out
)
=
(
in
)
>
>
(
GLITTER_INPUT_BITS
-
GRID_Y_BITS
)
#
else
#
define
INPUT_TO_GRID_Y
(
in
out
)
INPUT_TO_GRID_general
(
in
out
GRID_Y
)
#
endif
#
if
!
defined
(
INPUT_TO_GRID_X
)
&
&
defined
(
GRID_X_BITS
)
&
&
GRID_X_BITS
<
=
GLITTER_INPUT_BITS
#
define
INPUT_TO_GRID_X
(
in
out
)
(
out
)
=
(
in
)
>
>
(
GLITTER_INPUT_BITS
-
GRID_X_BITS
)
#
else
#
define
INPUT_TO_GRID_X
(
in
out
)
INPUT_TO_GRID_general
(
in
out
GRID_X
)
#
endif
#
define
INPUT_TO_GRID_general
(
in
out
grid_scale
)
do
{
\
long
long
tmp__
=
(
long
long
)
(
grid_scale
)
*
(
in
)
;
\
tmp__
>
>
=
GLITTER_INPUT_BITS
;
\
(
out
)
=
tmp__
;
\
}
while
(
0
)
I
void
glitter_scan_converter_add_edge
(
glitter_scan_converter_t
*
converter
const
cairo_edge_t
*
edge
)
{
cairo_edge_t
e
;
INPUT_TO_GRID_Y
(
edge
-
>
top
e
.
top
)
;
INPUT_TO_GRID_Y
(
edge
-
>
bottom
e
.
bottom
)
;
if
(
e
.
top
>
=
e
.
bottom
)
return
;
INPUT_TO_GRID_Y
(
edge
-
>
line
.
p1
.
y
e
.
line
.
p1
.
y
)
;
INPUT_TO_GRID_Y
(
edge
-
>
line
.
p2
.
y
e
.
line
.
p2
.
y
)
;
if
(
e
.
line
.
p1
.
y
=
=
e
.
line
.
p2
.
y
)
e
.
line
.
p2
.
y
+
+
;
INPUT_TO_GRID_X
(
edge
-
>
line
.
p1
.
x
e
.
line
.
p1
.
x
)
;
INPUT_TO_GRID_X
(
edge
-
>
line
.
p2
.
x
e
.
line
.
p2
.
x
)
;
e
.
dir
=
edge
-
>
dir
;
polygon_add_edge
(
converter
-
>
polygon
&
e
)
;
}
static
void
step_edges
(
struct
active_list
*
active
int
count
)
{
struct
edge
*
edge
;
count
*
=
GRID_Y
;
for
(
edge
=
active
-
>
head
.
next
;
edge
!
=
&
active
-
>
tail
;
edge
=
edge
-
>
next
)
{
edge
-
>
height_left
-
=
count
;
if
(
!
edge
-
>
height_left
)
{
edge
-
>
prev
-
>
next
=
edge
-
>
next
;
edge
-
>
next
-
>
prev
=
edge
-
>
prev
;
}
}
}
static
glitter_status_t
blit_a8
(
struct
cell_list
*
cells
cairo_span_renderer_t
*
renderer
cairo_half_open_span_t
*
spans
int
y
int
height
int
xmin
int
xmax
)
{
struct
cell
*
cell
=
cells
-
>
head
.
next
;
int
prev_x
=
xmin
last_x
=
-
1
;
int16_t
cover
=
0
last_cover
=
0
;
unsigned
num_spans
;
if
(
cell
=
=
&
cells
-
>
tail
)
return
CAIRO_STATUS_SUCCESS
;
while
(
cell
-
>
x
<
xmin
)
{
cover
+
=
cell
-
>
covered_height
;
cell
=
cell
-
>
next
;
}
cover
*
=
GRID_X
*
2
;
num_spans
=
0
;
for
(
;
cell
-
>
x
<
xmax
;
cell
=
cell
-
>
next
)
{
int
x
=
cell
-
>
x
;
int16_t
area
;
if
(
x
>
prev_x
&
&
cover
!
=
last_cover
)
{
spans
[
num_spans
]
.
x
=
prev_x
;
spans
[
num_spans
]
.
coverage
=
GRID_AREA_TO_ALPHA
(
cover
)
;
last_cover
=
cover
;
last_x
=
prev_x
;
+
+
num_spans
;
}
cover
+
=
cell
-
>
covered_height
*
GRID_X
*
2
;
area
=
cover
-
cell
-
>
uncovered_area
;
if
(
area
!
=
last_cover
)
{
spans
[
num_spans
]
.
x
=
x
;
spans
[
num_spans
]
.
coverage
=
GRID_AREA_TO_ALPHA
(
area
)
;
last_cover
=
area
;
last_x
=
x
;
+
+
num_spans
;
}
prev_x
=
x
+
1
;
}
if
(
prev_x
<
=
xmax
&
&
cover
!
=
last_cover
)
{
spans
[
num_spans
]
.
x
=
prev_x
;
spans
[
num_spans
]
.
coverage
=
GRID_AREA_TO_ALPHA
(
cover
)
;
last_cover
=
cover
;
last_x
=
prev_x
;
+
+
num_spans
;
}
if
(
last_x
<
xmax
&
&
last_cover
)
{
spans
[
num_spans
]
.
x
=
xmax
;
spans
[
num_spans
]
.
coverage
=
0
;
+
+
num_spans
;
}
return
renderer
-
>
render_rows
(
renderer
y
height
spans
num_spans
)
;
}
#
define
GRID_AREA_TO_A1
(
A
)
(
(
GRID_AREA_TO_ALPHA
(
A
)
>
127
)
?
255
:
0
)
static
glitter_status_t
blit_a1
(
struct
cell_list
*
cells
cairo_span_renderer_t
*
renderer
cairo_half_open_span_t
*
spans
int
y
int
height
int
xmin
int
xmax
)
{
struct
cell
*
cell
=
cells
-
>
head
.
next
;
int
prev_x
=
xmin
last_x
=
-
1
;
int16_t
cover
=
0
;
uint8_t
coverage
last_cover
=
0
;
unsigned
num_spans
;
if
(
cell
=
=
&
cells
-
>
tail
)
return
CAIRO_STATUS_SUCCESS
;
while
(
cell
-
>
x
<
xmin
)
{
cover
+
=
cell
-
>
covered_height
;
cell
=
cell
-
>
next
;
}
cover
*
=
GRID_X
*
2
;
num_spans
=
0
;
for
(
;
cell
-
>
x
<
xmax
;
cell
=
cell
-
>
next
)
{
int
x
=
cell
-
>
x
;
int16_t
area
;
coverage
=
GRID_AREA_TO_A1
(
cover
)
;
if
(
x
>
prev_x
&
&
coverage
!
=
last_cover
)
{
last_x
=
spans
[
num_spans
]
.
x
=
prev_x
;
last_cover
=
spans
[
num_spans
]
.
coverage
=
coverage
;
+
+
num_spans
;
}
cover
+
=
cell
-
>
covered_height
*
GRID_X
*
2
;
area
=
cover
-
cell
-
>
uncovered_area
;
coverage
=
GRID_AREA_TO_A1
(
area
)
;
if
(
coverage
!
=
last_cover
)
{
last_x
=
spans
[
num_spans
]
.
x
=
x
;
last_cover
=
spans
[
num_spans
]
.
coverage
=
coverage
;
+
+
num_spans
;
}
prev_x
=
x
+
1
;
}
coverage
=
GRID_AREA_TO_A1
(
cover
)
;
if
(
prev_x
<
=
xmax
&
&
coverage
!
=
last_cover
)
{
last_x
=
spans
[
num_spans
]
.
x
=
prev_x
;
last_cover
=
spans
[
num_spans
]
.
coverage
=
coverage
;
+
+
num_spans
;
}
if
(
last_x
<
xmax
&
&
last_cover
)
{
spans
[
num_spans
]
.
x
=
xmax
;
spans
[
num_spans
]
.
coverage
=
0
;
+
+
num_spans
;
}
if
(
num_spans
=
=
1
)
return
CAIRO_STATUS_SUCCESS
;
return
renderer
-
>
render_rows
(
renderer
y
height
spans
num_spans
)
;
}
I
void
glitter_scan_converter_render
(
glitter_scan_converter_t
*
converter
unsigned
int
winding_mask
int
antialias
cairo_span_renderer_t
*
renderer
)
{
int
i
j
;
int
ymax_i
=
converter
-
>
ymax
/
GRID_Y
;
int
ymin_i
=
converter
-
>
ymin
/
GRID_Y
;
int
xmin_i
xmax_i
;
int
h
=
ymax_i
-
ymin_i
;
struct
polygon
*
polygon
=
converter
-
>
polygon
;
struct
cell_list
*
coverages
=
converter
-
>
coverages
;
struct
active_list
*
active
=
converter
-
>
active
;
struct
edge
*
buckets
[
GRID_Y
]
=
{
0
}
;
xmin_i
=
converter
-
>
xmin
/
GRID_X
;
xmax_i
=
converter
-
>
xmax
/
GRID_X
;
if
(
xmin_i
>
=
xmax_i
)
return
;
for
(
i
=
0
;
i
<
h
;
i
=
j
)
{
int
do_full_row
=
0
;
j
=
i
+
1
;
if
(
!
polygon
-
>
y_buckets
[
i
]
)
{
if
(
active
-
>
head
.
next
=
=
&
active
-
>
tail
)
{
active
-
>
min_height
=
INT_MAX
;
active
-
>
is_vertical
=
1
;
for
(
;
j
<
h
&
&
!
polygon
-
>
y_buckets
[
j
]
;
j
+
+
)
;
continue
;
}
do_full_row
=
can_do_full_row
(
active
)
;
}
if
(
do_full_row
)
{
full_row
(
active
coverages
winding_mask
)
;
if
(
active
-
>
is_vertical
)
{
while
(
j
<
h
&
&
polygon
-
>
y_buckets
[
j
]
=
=
NULL
&
&
active
-
>
min_height
>
=
2
*
GRID_Y
)
{
active
-
>
min_height
-
=
GRID_Y
;
j
+
+
;
}
if
(
j
!
=
i
+
1
)
step_edges
(
active
j
-
(
i
+
1
)
)
;
}
}
else
{
int
sub
;
polygon_fill_buckets
(
active
polygon
-
>
y_buckets
[
i
]
(
i
+
ymin_i
)
*
GRID_Y
buckets
)
;
for
(
sub
=
0
;
sub
<
GRID_Y
;
sub
+
+
)
{
if
(
buckets
[
sub
]
)
{
active_list_merge_edges_from_bucket
(
active
buckets
[
sub
]
)
;
buckets
[
sub
]
=
NULL
;
}
sub_row
(
active
coverages
winding_mask
)
;
}
}
if
(
antialias
)
blit_a8
(
coverages
renderer
converter
-
>
spans
i
+
ymin_i
j
-
i
xmin_i
xmax_i
)
;
else
blit_a1
(
coverages
renderer
converter
-
>
spans
i
+
ymin_i
j
-
i
xmin_i
xmax_i
)
;
cell_list_reset
(
coverages
)
;
active
-
>
min_height
-
=
GRID_Y
;
}
}
struct
_cairo_tor22_scan_converter
{
cairo_scan_converter_t
base
;
glitter_scan_converter_t
converter
[
1
]
;
cairo_fill_rule_t
fill_rule
;
cairo_antialias_t
antialias
;
jmp_buf
jmp
;
}
;
typedef
struct
_cairo_tor22_scan_converter
cairo_tor22_scan_converter_t
;
static
void
_cairo_tor22_scan_converter_destroy
(
void
*
converter
)
{
cairo_tor22_scan_converter_t
*
self
=
converter
;
if
(
self
=
=
NULL
)
{
return
;
}
_glitter_scan_converter_fini
(
self
-
>
converter
)
;
free
(
self
)
;
}
cairo_status_t
_cairo_tor22_scan_converter_add_polygon
(
void
*
converter
const
cairo_polygon_t
*
polygon
)
{
cairo_tor22_scan_converter_t
*
self
=
converter
;
int
i
;
#
if
0
FILE
*
file
=
fopen
(
"
polygon
.
txt
"
"
w
"
)
;
_cairo_debug_print_polygon
(
file
polygon
)
;
fclose
(
file
)
;
#
endif
for
(
i
=
0
;
i
<
polygon
-
>
num_edges
;
i
+
+
)
glitter_scan_converter_add_edge
(
self
-
>
converter
&
polygon
-
>
edges
[
i
]
)
;
return
CAIRO_STATUS_SUCCESS
;
}
static
cairo_status_t
_cairo_tor22_scan_converter_generate
(
void
*
converter
cairo_span_renderer_t
*
renderer
)
{
cairo_tor22_scan_converter_t
*
self
=
converter
;
cairo_status_t
status
;
if
(
(
status
=
setjmp
(
self
-
>
jmp
)
)
)
return
_cairo_scan_converter_set_error
(
self
_cairo_error
(
status
)
)
;
glitter_scan_converter_render
(
self
-
>
converter
self
-
>
fill_rule
=
=
CAIRO_FILL_RULE_WINDING
?
~
0
:
1
self
-
>
antialias
!
=
CAIRO_ANTIALIAS_NONE
renderer
)
;
return
CAIRO_STATUS_SUCCESS
;
}
cairo_scan_converter_t
*
_cairo_tor22_scan_converter_create
(
int
xmin
int
ymin
int
xmax
int
ymax
cairo_fill_rule_t
fill_rule
cairo_antialias_t
antialias
)
{
cairo_tor22_scan_converter_t
*
self
;
cairo_status_t
status
;
self
=
_cairo_malloc
(
sizeof
(
struct
_cairo_tor22_scan_converter
)
)
;
if
(
unlikely
(
self
=
=
NULL
)
)
{
status
=
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
goto
bail_nomem
;
}
self
-
>
base
.
destroy
=
_cairo_tor22_scan_converter_destroy
;
self
-
>
base
.
generate
=
_cairo_tor22_scan_converter_generate
;
_glitter_scan_converter_init
(
self
-
>
converter
&
self
-
>
jmp
)
;
status
=
glitter_scan_converter_reset
(
self
-
>
converter
xmin
ymin
xmax
ymax
)
;
if
(
unlikely
(
status
)
)
goto
bail
;
self
-
>
fill_rule
=
fill_rule
;
self
-
>
antialias
=
antialias
;
return
&
self
-
>
base
;
bail
:
self
-
>
base
.
destroy
(
&
self
-
>
base
)
;
bail_nomem
:
return
_cairo_scan_converter_create_in_error
(
status
)
;
}
