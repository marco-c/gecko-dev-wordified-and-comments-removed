#
include
"
cairoint
.
h
"
#
include
"
cairo
-
mempool
-
private
.
h
"
#
include
"
cairo
-
list
-
inline
.
h
"
#
define
BITTEST
(
p
n
)
(
(
p
)
-
>
map
[
(
n
)
>
>
3
]
&
(
128
>
>
(
(
n
)
&
7
)
)
)
#
define
BITSET
(
p
n
)
(
(
p
)
-
>
map
[
(
n
)
>
>
3
]
|
=
(
128
>
>
(
(
n
)
&
7
)
)
)
#
define
BITCLEAR
(
p
n
)
(
(
p
)
-
>
map
[
(
n
)
>
>
3
]
&
=
~
(
128
>
>
(
(
n
)
&
7
)
)
)
static
void
clear_bits
(
cairo_mempool_t
*
pool
size_t
first
size_t
last
)
{
size_t
i
n
=
last
;
size_t
first_full
=
(
first
+
7
)
&
~
7
;
size_t
past_full
=
last
&
~
7
;
size_t
bytes
;
if
(
n
>
first_full
)
n
=
first_full
;
for
(
i
=
first
;
i
<
n
;
i
+
+
)
BITCLEAR
(
pool
i
)
;
if
(
past_full
>
first_full
)
{
bytes
=
past_full
-
first_full
;
bytes
=
bytes
>
>
3
;
memset
(
pool
-
>
map
+
(
first_full
>
>
3
)
0
bytes
)
;
}
if
(
past_full
<
n
)
past_full
=
n
;
for
(
i
=
past_full
;
i
<
last
;
i
+
+
)
BITCLEAR
(
pool
i
)
;
}
static
void
free_bits
(
cairo_mempool_t
*
pool
size_t
start
int
bits
cairo_bool_t
clear
)
{
struct
_cairo_memblock
*
block
;
if
(
clear
)
clear_bits
(
pool
start
start
+
(
1
<
<
bits
)
)
;
block
=
pool
-
>
blocks
+
start
;
block
-
>
bits
=
bits
;
cairo_list_add
(
&
block
-
>
link
&
pool
-
>
free
[
bits
]
)
;
pool
-
>
free_bytes
+
=
1
<
<
(
bits
+
pool
-
>
min_bits
)
;
if
(
bits
>
pool
-
>
max_free_bits
)
pool
-
>
max_free_bits
=
bits
;
}
static
void
free_blocks
(
cairo_mempool_t
*
pool
size_t
first
size_t
last
cairo_bool_t
clear
)
{
size_t
i
len
;
int
bits
=
0
;
for
(
i
=
first
len
=
1
;
i
<
last
;
i
+
=
len
)
{
while
(
bits
<
pool
-
>
num_sizes
-
1
)
{
size_t
next_bits
=
bits
+
1
;
size_t
next_len
=
len
<
<
1
;
if
(
i
+
next_bits
>
last
)
{
break
;
}
if
(
i
&
(
next_len
-
1
)
)
break
;
bits
=
next_bits
;
len
=
next_len
;
}
do
{
if
(
i
+
len
<
=
last
&
&
(
i
&
(
len
-
1
)
)
=
=
0
)
break
;
bits
-
-
;
len
>
>
=
1
;
}
while
(
len
)
;
if
(
len
=
=
0
)
break
;
free_bits
(
pool
i
bits
clear
)
;
}
}
static
struct
_cairo_memblock
*
get_buddy
(
cairo_mempool_t
*
pool
size_t
offset
int
bits
)
{
struct
_cairo_memblock
*
block
;
if
(
offset
+
(
1
<
<
bits
)
>
=
pool
-
>
num_blocks
)
return
NULL
;
if
(
BITTEST
(
pool
offset
+
(
1
<
<
bits
)
-
1
)
)
return
NULL
;
block
=
pool
-
>
blocks
+
offset
;
if
(
block
-
>
bits
!
=
bits
)
return
NULL
;
return
block
;
}
static
void
merge_buddies
(
cairo_mempool_t
*
pool
struct
_cairo_memblock
*
block
int
max_bits
)
{
size_t
block_offset
=
block
-
pool
-
>
blocks
;
int
bits
=
block
-
>
bits
;
while
(
bits
<
max_bits
-
1
)
{
size_t
buddy_offset
=
block_offset
^
(
1
<
<
bits
)
;
block
=
get_buddy
(
pool
buddy_offset
bits
)
;
if
(
block
=
=
NULL
)
break
;
cairo_list_del
(
&
block
-
>
link
)
;
if
(
buddy_offset
<
block_offset
)
block_offset
=
buddy_offset
;
bits
+
+
;
}
block
=
pool
-
>
blocks
+
block_offset
;
block
-
>
bits
=
bits
;
cairo_list_add
(
&
block
-
>
link
&
pool
-
>
free
[
bits
]
)
;
if
(
bits
>
pool
-
>
max_free_bits
)
pool
-
>
max_free_bits
=
bits
;
}
static
int
merge_bits
(
cairo_mempool_t
*
pool
int
max_bits
)
{
struct
_cairo_memblock
*
block
*
buddy
*
next
;
int
bits
;
for
(
bits
=
0
;
bits
<
max_bits
-
1
;
bits
+
+
)
{
cairo_list_foreach_entry_safe
(
block
next
struct
_cairo_memblock
&
pool
-
>
free
[
bits
]
link
)
{
size_t
buddy_offset
=
(
block
-
pool
-
>
blocks
)
^
(
1
<
<
bits
)
;
buddy
=
get_buddy
(
pool
buddy_offset
bits
)
;
if
(
buddy
=
=
NULL
)
continue
;
if
(
buddy
=
=
next
)
{
next
=
cairo_container_of
(
buddy
-
>
link
.
next
struct
_cairo_memblock
link
)
;
}
cairo_list_del
(
&
block
-
>
link
)
;
merge_buddies
(
pool
block
max_bits
)
;
}
}
return
pool
-
>
max_free_bits
;
}
static
void
*
buddy_malloc
(
cairo_mempool_t
*
pool
int
bits
)
{
size_t
past
offset
;
struct
_cairo_memblock
*
block
;
int
b
;
if
(
bits
>
pool
-
>
max_free_bits
&
&
bits
>
merge_bits
(
pool
bits
)
)
return
NULL
;
block
=
NULL
;
for
(
b
=
bits
;
b
<
=
pool
-
>
max_free_bits
;
b
+
+
)
{
if
(
!
cairo_list_is_empty
(
&
pool
-
>
free
[
b
]
)
)
{
block
=
cairo_list_first_entry
(
&
pool
-
>
free
[
b
]
struct
_cairo_memblock
link
)
;
break
;
}
}
assert
(
block
!
=
NULL
)
;
cairo_list_del
(
&
block
-
>
link
)
;
while
(
cairo_list_is_empty
(
&
pool
-
>
free
[
pool
-
>
max_free_bits
]
)
)
{
if
(
-
-
pool
-
>
max_free_bits
=
=
-
1
)
break
;
}
offset
=
block
-
pool
-
>
blocks
;
past
=
offset
+
(
1
<
<
bits
)
;
BITSET
(
pool
past
-
1
)
;
block
-
>
bits
=
bits
;
pool
-
>
free_bytes
-
=
1
<
<
(
b
+
pool
-
>
min_bits
)
;
free_blocks
(
pool
past
offset
+
(
1
<
<
b
)
0
)
;
return
pool
-
>
base
+
(
(
block
-
pool
-
>
blocks
)
<
<
pool
-
>
min_bits
)
;
}
cairo_status_t
_cairo_mempool_init
(
cairo_mempool_t
*
pool
void
*
base
size_t
bytes
int
min_bits
int
num_sizes
)
{
unsigned
long
tmp
;
int
num_blocks
;
int
i
;
tmp
=
(
(
unsigned
long
)
base
)
&
(
(
1
<
<
min_bits
)
-
1
)
;
if
(
tmp
)
{
tmp
=
(
1
<
<
min_bits
)
-
tmp
;
base
=
(
char
*
)
base
+
tmp
;
bytes
-
=
tmp
;
}
assert
(
(
(
(
unsigned
long
)
base
)
&
(
(
1
<
<
min_bits
)
-
1
)
)
=
=
0
)
;
assert
(
num_sizes
<
ARRAY_LENGTH
(
pool
-
>
free
)
)
;
pool
-
>
base
=
base
;
pool
-
>
free_bytes
=
0
;
pool
-
>
max_bytes
=
bytes
;
pool
-
>
max_free_bits
=
-
1
;
num_blocks
=
bytes
>
>
min_bits
;
pool
-
>
blocks
=
calloc
(
num_blocks
sizeof
(
struct
_cairo_memblock
)
)
;
if
(
pool
-
>
blocks
=
=
NULL
)
return
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
pool
-
>
num_blocks
=
num_blocks
;
pool
-
>
min_bits
=
min_bits
;
pool
-
>
num_sizes
=
num_sizes
;
for
(
i
=
0
;
i
<
ARRAY_LENGTH
(
pool
-
>
free
)
;
i
+
+
)
cairo_list_init
(
&
pool
-
>
free
[
i
]
)
;
pool
-
>
map
=
_cairo_malloc
(
(
num_blocks
+
7
)
>
>
3
)
;
if
(
pool
-
>
map
=
=
NULL
)
{
free
(
pool
-
>
blocks
)
;
return
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
}
memset
(
pool
-
>
map
-
1
(
num_blocks
+
7
)
>
>
3
)
;
clear_bits
(
pool
0
num_blocks
)
;
free_blocks
(
pool
0
num_blocks
1
)
;
return
CAIRO_STATUS_SUCCESS
;
}
void
*
_cairo_mempool_alloc
(
cairo_mempool_t
*
pool
size_t
bytes
)
{
size_t
size
;
int
bits
;
size
=
1
<
<
pool
-
>
min_bits
;
for
(
bits
=
0
;
size
<
bytes
;
bits
+
+
)
size
<
<
=
1
;
if
(
bits
>
=
pool
-
>
num_sizes
)
return
NULL
;
return
buddy_malloc
(
pool
bits
)
;
}
void
_cairo_mempool_free
(
cairo_mempool_t
*
pool
void
*
storage
)
{
size_t
block_offset
;
struct
_cairo_memblock
*
block
;
block_offset
=
(
(
char
*
)
storage
-
pool
-
>
base
)
>
>
pool
-
>
min_bits
;
block
=
pool
-
>
blocks
+
block_offset
;
BITCLEAR
(
pool
block_offset
+
(
(
1
<
<
block
-
>
bits
)
-
1
)
)
;
pool
-
>
free_bytes
+
=
1
<
<
(
block
-
>
bits
+
pool
-
>
min_bits
)
;
merge_buddies
(
pool
block
pool
-
>
num_sizes
)
;
}
void
_cairo_mempool_fini
(
cairo_mempool_t
*
pool
)
{
free
(
pool
-
>
map
)
;
free
(
pool
-
>
blocks
)
;
}
