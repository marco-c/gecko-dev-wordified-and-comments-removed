#
include
"
cairoint
.
h
"
#
include
"
cairo
-
spans
-
private
.
h
"
#
include
"
cairo
-
error
-
private
.
h
"
#
include
<
assert
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
.
h
>
#
include
<
setjmp
.
h
>
#
define
GLITTER_INPUT_BITS
CAIRO_FIXED_FRAC_BITS
#
define
GRID_X_BITS
CAIRO_FIXED_FRAC_BITS
#
define
GRID_Y
15
struct
pool
;
struct
cell_list
;
#
ifndef
GLITTER_INPUT_BITS
#
define
GLITTER_INPUT_BITS
8
#
endif
#
define
GLITTER_INPUT_SCALE
(
1
<
<
GLITTER_INPUT_BITS
)
typedef
int
glitter_input_scaled_t
;
typedef
struct
glitter_scan_converter
glitter_scan_converter_t
;
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
.
h
>
typedef
int
grid_scaled_t
;
typedef
int
grid_scaled_x_t
;
typedef
int
grid_scaled_y_t
;
#
if
!
defined
(
GRID_X
)
&
&
!
defined
(
GRID_X_BITS
)
#
define
GRID_X_BITS
8
#
endif
#
if
!
defined
(
GRID_Y
)
&
&
!
defined
(
GRID_Y_BITS
)
#
define
GRID_Y
15
#
endif
#
ifdef
GRID_X_BITS
#
define
GRID_X
(
1
<
<
GRID_X_BITS
)
#
endif
#
ifdef
GRID_Y_BITS
#
define
GRID_Y
(
1
<
<
GRID_Y_BITS
)
#
endif
#
if
defined
(
GRID_X_TO_INT_FRAC
)
#
elif
defined
(
GRID_X_BITS
)
#
define
GRID_X_TO_INT_FRAC
(
x
i
f
)
\
_GRID_TO_INT_FRAC_shift
(
x
i
f
GRID_X_BITS
)
#
else
#
define
GRID_X_TO_INT_FRAC
(
x
i
f
)
\
_GRID_TO_INT_FRAC_general
(
x
i
f
GRID_X
)
#
endif
#
define
_GRID_TO_INT_FRAC_general
(
t
i
f
m
)
do
{
\
(
i
)
=
(
t
)
/
(
m
)
;
\
(
f
)
=
(
t
)
%
(
m
)
;
\
if
(
(
f
)
<
0
)
{
\
-
-
(
i
)
;
\
(
f
)
+
=
(
m
)
;
\
}
\
}
while
(
0
)
#
define
_GRID_TO_INT_FRAC_shift
(
t
i
f
b
)
do
{
\
(
f
)
=
(
t
)
&
(
(
1
<
<
(
b
)
)
-
1
)
;
\
(
i
)
=
(
t
)
>
>
(
b
)
;
\
}
while
(
0
)
typedef
int
grid_area_t
;
#
define
GRID_XY
(
2
*
GRID_X
*
GRID_Y
)
/
*
Unit
area
on
the
grid
.
*
/
#
if
GRID_XY
=
=
510
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
+
1
)
>
>
1
)
#
elif
GRID_XY
=
=
255
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
c
)
#
elif
GRID_XY
=
=
64
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
<
<
2
)
|
-
(
(
(
c
)
&
0x40
)
>
>
6
)
)
#
elif
GRID_XY
=
=
128
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
(
c
)
<
<
1
)
|
-
(
(
c
)
>
>
7
)
)
&
255
)
#
elif
GRID_XY
=
=
256
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
|
-
(
(
c
)
>
>
8
)
)
&
255
)
#
elif
GRID_XY
=
=
15
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
<
<
4
)
+
(
c
)
)
#
elif
GRID_XY
=
=
2
*
256
*
15
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
+
(
(
c
)
<
<
4
)
+
256
)
>
>
9
)
#
else
#
define
GRID_AREA_TO_ALPHA
(
c
)
(
(
(
c
)
*
255
+
GRID_XY
/
2
)
/
GRID_XY
)
#
endif
#
define
UNROLL3
(
x
)
x
x
x
struct
quorem
{
int32_t
quo
;
int32_t
rem
;
}
;
struct
_pool_chunk
{
size_t
size
;
size_t
capacity
;
struct
_pool_chunk
*
prev_chunk
;
}
;
struct
pool
{
struct
_pool_chunk
*
current
;
jmp_buf
*
jmp
;
struct
_pool_chunk
*
first_free
;
size_t
default_capacity
;
struct
_pool_chunk
sentinel
[
1
]
;
}
;
struct
edge
{
struct
edge
*
next
;
struct
quorem
x
;
struct
quorem
dxdy
;
struct
quorem
dxdy_full
;
grid_scaled_y_t
ytop
;
grid_scaled_y_t
dy
;
grid_scaled_y_t
height_left
;
int
dir
;
int
vertical
;
int
clip
;
}
;
#
define
EDGE_Y_BUCKET_HEIGHT
GRID_Y
#
define
EDGE_Y_BUCKET_INDEX
(
y
ymin
)
(
(
(
y
)
-
(
ymin
)
)
/
EDGE_Y_BUCKET_HEIGHT
)
struct
polygon
{
grid_scaled_y_t
ymin
ymax
;
struct
edge
*
*
y_buckets
;
struct
edge
*
y_buckets_embedded
[
64
]
;
struct
{
struct
pool
base
[
1
]
;
struct
edge
embedded
[
32
]
;
}
edge_pool
;
}
;
struct
cell
{
struct
cell
*
next
;
int
x
;
grid_area_t
uncovered_area
;
grid_scaled_y_t
covered_height
;
grid_scaled_y_t
clipped_height
;
}
;
struct
cell_list
{
struct
cell
head
tail
;
struct
cell
*
cursor
;
struct
{
struct
pool
base
[
1
]
;
struct
cell
embedded
[
32
]
;
}
cell_pool
;
}
;
struct
cell_pair
{
struct
cell
*
cell1
;
struct
cell
*
cell2
;
}
;
struct
active_list
{
struct
edge
*
head
;
grid_scaled_y_t
min_height
;
}
;
struct
glitter_scan_converter
{
struct
polygon
polygon
[
1
]
;
struct
active_list
active
[
1
]
;
struct
cell_list
coverages
[
1
]
;
grid_scaled_y_t
ymin
ymax
;
}
;
inline
static
struct
quorem
floored_divrem
(
int
a
int
b
)
{
struct
quorem
qr
;
qr
.
quo
=
a
/
b
;
qr
.
rem
=
a
%
b
;
if
(
(
a
^
b
)
<
0
&
&
qr
.
rem
)
{
qr
.
quo
-
=
1
;
qr
.
rem
+
=
b
;
}
return
qr
;
}
static
struct
quorem
floored_muldivrem
(
int
x
int
a
int
b
)
{
struct
quorem
qr
;
long
long
xa
=
(
long
long
)
x
*
a
;
qr
.
quo
=
xa
/
b
;
qr
.
rem
=
xa
%
b
;
if
(
(
xa
>
=
0
)
!
=
(
b
>
=
0
)
&
&
qr
.
rem
)
{
qr
.
quo
-
=
1
;
qr
.
rem
+
=
b
;
}
return
qr
;
}
static
struct
_pool_chunk
*
_pool_chunk_init
(
struct
_pool_chunk
*
p
struct
_pool_chunk
*
prev_chunk
size_t
capacity
)
{
p
-
>
prev_chunk
=
prev_chunk
;
p
-
>
size
=
0
;
p
-
>
capacity
=
capacity
;
return
p
;
}
static
struct
_pool_chunk
*
_pool_chunk_create
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
p
;
p
=
_cairo_malloc
(
size
+
sizeof
(
struct
_pool_chunk
)
)
;
if
(
unlikely
(
NULL
=
=
p
)
)
longjmp
(
*
pool
-
>
jmp
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
)
;
return
_pool_chunk_init
(
p
pool
-
>
current
size
)
;
}
static
void
pool_init
(
struct
pool
*
pool
jmp_buf
*
jmp
size_t
default_capacity
size_t
embedded_capacity
)
{
pool
-
>
jmp
=
jmp
;
pool
-
>
current
=
pool
-
>
sentinel
;
pool
-
>
first_free
=
NULL
;
pool
-
>
default_capacity
=
default_capacity
;
_pool_chunk_init
(
pool
-
>
sentinel
NULL
embedded_capacity
)
;
}
static
void
pool_fini
(
struct
pool
*
pool
)
{
struct
_pool_chunk
*
p
=
pool
-
>
current
;
do
{
while
(
NULL
!
=
p
)
{
struct
_pool_chunk
*
prev
=
p
-
>
prev_chunk
;
if
(
p
!
=
pool
-
>
sentinel
)
free
(
p
)
;
p
=
prev
;
}
p
=
pool
-
>
first_free
;
pool
-
>
first_free
=
NULL
;
}
while
(
NULL
!
=
p
)
;
}
static
void
*
_pool_alloc_from_new_chunk
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
chunk
;
void
*
obj
;
size_t
capacity
;
capacity
=
size
;
chunk
=
NULL
;
if
(
size
<
pool
-
>
default_capacity
)
{
capacity
=
pool
-
>
default_capacity
;
chunk
=
pool
-
>
first_free
;
if
(
chunk
)
{
pool
-
>
first_free
=
chunk
-
>
prev_chunk
;
_pool_chunk_init
(
chunk
pool
-
>
current
chunk
-
>
capacity
)
;
}
}
if
(
NULL
=
=
chunk
)
chunk
=
_pool_chunk_create
(
pool
capacity
)
;
pool
-
>
current
=
chunk
;
obj
=
(
(
unsigned
char
*
)
chunk
+
sizeof
(
*
chunk
)
+
chunk
-
>
size
)
;
chunk
-
>
size
+
=
size
;
return
obj
;
}
inline
static
void
*
pool_alloc
(
struct
pool
*
pool
size_t
size
)
{
struct
_pool_chunk
*
chunk
=
pool
-
>
current
;
if
(
size
<
=
chunk
-
>
capacity
-
chunk
-
>
size
)
{
void
*
obj
=
(
(
unsigned
char
*
)
chunk
+
sizeof
(
*
chunk
)
+
chunk
-
>
size
)
;
chunk
-
>
size
+
=
size
;
return
obj
;
}
else
{
return
_pool_alloc_from_new_chunk
(
pool
size
)
;
}
}
static
void
pool_reset
(
struct
pool
*
pool
)
{
struct
_pool_chunk
*
chunk
=
pool
-
>
current
;
if
(
chunk
!
=
pool
-
>
sentinel
)
{
while
(
chunk
-
>
prev_chunk
!
=
pool
-
>
sentinel
)
{
chunk
=
chunk
-
>
prev_chunk
;
}
chunk
-
>
prev_chunk
=
pool
-
>
first_free
;
pool
-
>
first_free
=
pool
-
>
current
;
}
pool
-
>
current
=
pool
-
>
sentinel
;
pool
-
>
sentinel
-
>
size
=
0
;
}
inline
static
void
cell_list_rewind
(
struct
cell_list
*
cells
)
{
cells
-
>
cursor
=
&
cells
-
>
head
;
}
inline
static
void
cell_list_maybe_rewind
(
struct
cell_list
*
cells
int
x
)
{
struct
cell
*
tail
=
cells
-
>
cursor
;
if
(
tail
-
>
x
>
x
)
cell_list_rewind
(
cells
)
;
}
static
void
cell_list_init
(
struct
cell_list
*
cells
jmp_buf
*
jmp
)
{
pool_init
(
cells
-
>
cell_pool
.
base
jmp
256
*
sizeof
(
struct
cell
)
sizeof
(
cells
-
>
cell_pool
.
embedded
)
)
;
cells
-
>
tail
.
next
=
NULL
;
cells
-
>
tail
.
x
=
INT_MAX
;
cells
-
>
head
.
x
=
INT_MIN
;
cells
-
>
head
.
next
=
&
cells
-
>
tail
;
cell_list_rewind
(
cells
)
;
}
static
void
cell_list_fini
(
struct
cell_list
*
cells
)
{
pool_fini
(
cells
-
>
cell_pool
.
base
)
;
}
inline
static
void
cell_list_reset
(
struct
cell_list
*
cells
)
{
cell_list_rewind
(
cells
)
;
cells
-
>
head
.
next
=
&
cells
-
>
tail
;
pool_reset
(
cells
-
>
cell_pool
.
base
)
;
}
static
struct
cell
*
cell_list_alloc
(
struct
cell_list
*
cells
struct
cell
*
tail
int
x
)
{
struct
cell
*
cell
;
cell
=
pool_alloc
(
cells
-
>
cell_pool
.
base
sizeof
(
struct
cell
)
)
;
cell
-
>
next
=
tail
-
>
next
;
tail
-
>
next
=
cell
;
cell
-
>
x
=
x
;
cell
-
>
uncovered_area
=
0
;
cell
-
>
covered_height
=
0
;
cell
-
>
clipped_height
=
0
;
return
cell
;
}
inline
static
struct
cell
*
cell_list_find
(
struct
cell_list
*
cells
int
x
)
{
struct
cell
*
tail
=
cells
-
>
cursor
;
while
(
1
)
{
UNROLL3
(
{
if
(
tail
-
>
next
-
>
x
>
x
)
break
;
tail
=
tail
-
>
next
;
}
)
;
}
if
(
tail
-
>
x
!
=
x
)
tail
=
cell_list_alloc
(
cells
tail
x
)
;
return
cells
-
>
cursor
=
tail
;
}
inline
static
struct
cell_pair
cell_list_find_pair
(
struct
cell_list
*
cells
int
x1
int
x2
)
{
struct
cell_pair
pair
;
pair
.
cell1
=
cells
-
>
cursor
;
while
(
1
)
{
UNROLL3
(
{
if
(
pair
.
cell1
-
>
next
-
>
x
>
x1
)
break
;
pair
.
cell1
=
pair
.
cell1
-
>
next
;
}
)
;
}
if
(
pair
.
cell1
-
>
x
!
=
x1
)
{
struct
cell
*
cell
=
pool_alloc
(
cells
-
>
cell_pool
.
base
sizeof
(
struct
cell
)
)
;
cell
-
>
x
=
x1
;
cell
-
>
uncovered_area
=
0
;
cell
-
>
covered_height
=
0
;
cell
-
>
clipped_height
=
0
;
cell
-
>
next
=
pair
.
cell1
-
>
next
;
pair
.
cell1
-
>
next
=
cell
;
pair
.
cell1
=
cell
;
}
pair
.
cell2
=
pair
.
cell1
;
while
(
1
)
{
UNROLL3
(
{
if
(
pair
.
cell2
-
>
next
-
>
x
>
x2
)
break
;
pair
.
cell2
=
pair
.
cell2
-
>
next
;
}
)
;
}
if
(
pair
.
cell2
-
>
x
!
=
x2
)
{
struct
cell
*
cell
=
pool_alloc
(
cells
-
>
cell_pool
.
base
sizeof
(
struct
cell
)
)
;
cell
-
>
uncovered_area
=
0
;
cell
-
>
covered_height
=
0
;
cell
-
>
clipped_height
=
0
;
cell
-
>
x
=
x2
;
cell
-
>
next
=
pair
.
cell2
-
>
next
;
pair
.
cell2
-
>
next
=
cell
;
pair
.
cell2
=
cell
;
}
cells
-
>
cursor
=
pair
.
cell2
;
return
pair
;
}
inline
static
void
cell_list_add_subspan
(
struct
cell_list
*
cells
grid_scaled_x_t
x1
grid_scaled_x_t
x2
)
{
int
ix1
fx1
;
int
ix2
fx2
;
GRID_X_TO_INT_FRAC
(
x1
ix1
fx1
)
;
GRID_X_TO_INT_FRAC
(
x2
ix2
fx2
)
;
if
(
ix1
!
=
ix2
)
{
struct
cell_pair
p
;
p
=
cell_list_find_pair
(
cells
ix1
ix2
)
;
p
.
cell1
-
>
uncovered_area
+
=
2
*
fx1
;
+
+
p
.
cell1
-
>
covered_height
;
p
.
cell2
-
>
uncovered_area
-
=
2
*
fx2
;
-
-
p
.
cell2
-
>
covered_height
;
}
else
{
struct
cell
*
cell
=
cell_list_find
(
cells
ix1
)
;
cell
-
>
uncovered_area
+
=
2
*
(
fx1
-
fx2
)
;
}
}
static
void
cell_list_render_edge
(
struct
cell_list
*
cells
struct
edge
*
edge
int
sign
)
{
grid_scaled_y_t
y1
y2
dy
;
grid_scaled_x_t
dx
;
int
ix1
ix2
;
grid_scaled_x_t
fx1
fx2
;
struct
quorem
x1
=
edge
-
>
x
;
struct
quorem
x2
=
x1
;
if
(
!
edge
-
>
vertical
)
{
x2
.
quo
+
=
edge
-
>
dxdy_full
.
quo
;
x2
.
rem
+
=
edge
-
>
dxdy_full
.
rem
;
if
(
x2
.
rem
>
=
0
)
{
+
+
x2
.
quo
;
x2
.
rem
-
=
edge
-
>
dy
;
}
edge
-
>
x
=
x2
;
}
GRID_X_TO_INT_FRAC
(
x1
.
quo
ix1
fx1
)
;
GRID_X_TO_INT_FRAC
(
x2
.
quo
ix2
fx2
)
;
if
(
ix1
=
=
ix2
)
{
struct
cell
*
cell
=
cell_list_find
(
cells
ix1
)
;
cell
-
>
covered_height
+
=
sign
*
GRID_Y
;
cell
-
>
uncovered_area
+
=
sign
*
(
fx1
+
fx2
)
*
GRID_Y
;
return
;
}
dx
=
x2
.
quo
-
x1
.
quo
;
if
(
dx
>
=
0
)
{
y1
=
0
;
y2
=
GRID_Y
;
}
else
{
int
tmp
;
tmp
=
ix1
;
ix1
=
ix2
;
ix2
=
tmp
;
tmp
=
fx1
;
fx1
=
fx2
;
fx2
=
tmp
;
dx
=
-
dx
;
sign
=
-
sign
;
y1
=
GRID_Y
;
y2
=
0
;
}
dy
=
y2
-
y1
;
{
struct
cell_pair
pair
;
struct
quorem
y
=
floored_divrem
(
(
GRID_X
-
fx1
)
*
dy
dx
)
;
cell_list_maybe_rewind
(
cells
ix1
)
;
pair
=
cell_list_find_pair
(
cells
ix1
ix1
+
1
)
;
pair
.
cell1
-
>
uncovered_area
+
=
sign
*
y
.
quo
*
(
GRID_X
+
fx1
)
;
pair
.
cell1
-
>
covered_height
+
=
sign
*
y
.
quo
;
y
.
quo
+
=
y1
;
if
(
ix1
+
1
<
ix2
)
{
struct
quorem
dydx_full
=
floored_divrem
(
GRID_X
*
dy
dx
)
;
struct
cell
*
cell
=
pair
.
cell2
;
+
+
ix1
;
do
{
grid_scaled_y_t
y_skip
=
dydx_full
.
quo
;
y
.
rem
+
=
dydx_full
.
rem
;
if
(
y
.
rem
>
=
dx
)
{
+
+
y_skip
;
y
.
rem
-
=
dx
;
}
y
.
quo
+
=
y_skip
;
y_skip
*
=
sign
;
cell
-
>
uncovered_area
+
=
y_skip
*
GRID_X
;
cell
-
>
covered_height
+
=
y_skip
;
+
+
ix1
;
cell
=
cell_list_find
(
cells
ix1
)
;
}
while
(
ix1
!
=
ix2
)
;
pair
.
cell2
=
cell
;
}
pair
.
cell2
-
>
uncovered_area
+
=
sign
*
(
y2
-
y
.
quo
)
*
fx2
;
pair
.
cell2
-
>
covered_height
+
=
sign
*
(
y2
-
y
.
quo
)
;
}
}
static
void
polygon_init
(
struct
polygon
*
polygon
jmp_buf
*
jmp
)
{
polygon
-
>
ymin
=
polygon
-
>
ymax
=
0
;
polygon
-
>
y_buckets
=
polygon
-
>
y_buckets_embedded
;
pool_init
(
polygon
-
>
edge_pool
.
base
jmp
8192
-
sizeof
(
struct
_pool_chunk
)
sizeof
(
polygon
-
>
edge_pool
.
embedded
)
)
;
}
static
void
polygon_fini
(
struct
polygon
*
polygon
)
{
if
(
polygon
-
>
y_buckets
!
=
polygon
-
>
y_buckets_embedded
)
free
(
polygon
-
>
y_buckets
)
;
pool_fini
(
polygon
-
>
edge_pool
.
base
)
;
}
static
cairo_status_t
polygon_reset
(
struct
polygon
*
polygon
grid_scaled_y_t
ymin
grid_scaled_y_t
ymax
)
{
unsigned
h
=
ymax
-
ymin
;
unsigned
num_buckets
=
EDGE_Y_BUCKET_INDEX
(
ymax
+
EDGE_Y_BUCKET_HEIGHT
-
1
ymin
)
;
pool_reset
(
polygon
-
>
edge_pool
.
base
)
;
if
(
unlikely
(
h
>
0x7FFFFFFFU
-
EDGE_Y_BUCKET_HEIGHT
)
)
goto
bail_no_mem
;
if
(
polygon
-
>
y_buckets
!
=
polygon
-
>
y_buckets_embedded
)
free
(
polygon
-
>
y_buckets
)
;
polygon
-
>
y_buckets
=
polygon
-
>
y_buckets_embedded
;
if
(
num_buckets
>
ARRAY_LENGTH
(
polygon
-
>
y_buckets_embedded
)
)
{
polygon
-
>
y_buckets
=
_cairo_malloc_ab
(
num_buckets
sizeof
(
struct
edge
*
)
)
;
if
(
unlikely
(
NULL
=
=
polygon
-
>
y_buckets
)
)
goto
bail_no_mem
;
}
memset
(
polygon
-
>
y_buckets
0
num_buckets
*
sizeof
(
struct
edge
*
)
)
;
polygon
-
>
ymin
=
ymin
;
polygon
-
>
ymax
=
ymax
;
return
CAIRO_STATUS_SUCCESS
;
bail_no_mem
:
polygon
-
>
ymin
=
0
;
polygon
-
>
ymax
=
0
;
return
CAIRO_STATUS_NO_MEMORY
;
}
static
void
_polygon_insert_edge_into_its_y_bucket
(
struct
polygon
*
polygon
struct
edge
*
e
)
{
unsigned
ix
=
EDGE_Y_BUCKET_INDEX
(
e
-
>
ytop
polygon
-
>
ymin
)
;
struct
edge
*
*
ptail
=
&
polygon
-
>
y_buckets
[
ix
]
;
e
-
>
next
=
*
ptail
;
*
ptail
=
e
;
}
inline
static
void
polygon_add_edge
(
struct
polygon
*
polygon
const
cairo_edge_t
*
edge
int
clip
)
{
struct
edge
*
e
;
grid_scaled_x_t
dx
;
grid_scaled_y_t
dy
;
grid_scaled_y_t
ytop
ybot
;
grid_scaled_y_t
ymin
=
polygon
-
>
ymin
;
grid_scaled_y_t
ymax
=
polygon
-
>
ymax
;
assert
(
edge
-
>
bottom
>
edge
-
>
top
)
;
if
(
unlikely
(
edge
-
>
top
>
=
ymax
|
|
edge
-
>
bottom
<
=
ymin
)
)
return
;
e
=
pool_alloc
(
polygon
-
>
edge_pool
.
base
sizeof
(
struct
edge
)
)
;
dx
=
edge
-
>
line
.
p2
.
x
-
edge
-
>
line
.
p1
.
x
;
dy
=
edge
-
>
line
.
p2
.
y
-
edge
-
>
line
.
p1
.
y
;
e
-
>
dy
=
dy
;
e
-
>
dir
=
edge
-
>
dir
;
e
-
>
clip
=
clip
;
ytop
=
edge
-
>
top
>
=
ymin
?
edge
-
>
top
:
ymin
;
ybot
=
edge
-
>
bottom
<
=
ymax
?
edge
-
>
bottom
:
ymax
;
e
-
>
ytop
=
ytop
;
e
-
>
height_left
=
ybot
-
ytop
;
if
(
dx
=
=
0
)
{
e
-
>
vertical
=
TRUE
;
e
-
>
x
.
quo
=
edge
-
>
line
.
p1
.
x
;
e
-
>
x
.
rem
=
0
;
e
-
>
dxdy
.
quo
=
0
;
e
-
>
dxdy
.
rem
=
0
;
e
-
>
dxdy_full
.
quo
=
0
;
e
-
>
dxdy_full
.
rem
=
0
;
}
else
{
e
-
>
vertical
=
FALSE
;
e
-
>
dxdy
=
floored_divrem
(
dx
dy
)
;
if
(
ytop
=
=
edge
-
>
line
.
p1
.
y
)
{
e
-
>
x
.
quo
=
edge
-
>
line
.
p1
.
x
;
e
-
>
x
.
rem
=
0
;
}
else
{
e
-
>
x
=
floored_muldivrem
(
ytop
-
edge
-
>
line
.
p1
.
y
dx
dy
)
;
e
-
>
x
.
quo
+
=
edge
-
>
line
.
p1
.
x
;
}
if
(
e
-
>
height_left
>
=
GRID_Y
)
{
e
-
>
dxdy_full
=
floored_muldivrem
(
GRID_Y
dx
dy
)
;
}
else
{
e
-
>
dxdy_full
.
quo
=
0
;
e
-
>
dxdy_full
.
rem
=
0
;
}
}
_polygon_insert_edge_into_its_y_bucket
(
polygon
e
)
;
e
-
>
x
.
rem
-
=
dy
;
}
static
void
active_list_reset
(
struct
active_list
*
active
)
{
active
-
>
head
=
NULL
;
active
-
>
min_height
=
0
;
}
static
void
active_list_init
(
struct
active_list
*
active
)
{
active_list_reset
(
active
)
;
}
static
struct
edge
*
merge_sorted_edges
(
struct
edge
*
head_a
struct
edge
*
head_b
)
{
struct
edge
*
head
*
*
next
;
int32_t
x
;
if
(
head_a
=
=
NULL
)
return
head_b
;
next
=
&
head
;
if
(
head_a
-
>
x
.
quo
<
=
head_b
-
>
x
.
quo
)
{
head
=
head_a
;
}
else
{
head
=
head_b
;
goto
start_with_b
;
}
do
{
x
=
head_b
-
>
x
.
quo
;
while
(
head_a
!
=
NULL
&
&
head_a
-
>
x
.
quo
<
=
x
)
{
next
=
&
head_a
-
>
next
;
head_a
=
head_a
-
>
next
;
}
*
next
=
head_b
;
if
(
head_a
=
=
NULL
)
return
head
;
start_with_b
:
x
=
head_a
-
>
x
.
quo
;
while
(
head_b
!
=
NULL
&
&
head_b
-
>
x
.
quo
<
=
x
)
{
next
=
&
head_b
-
>
next
;
head_b
=
head_b
-
>
next
;
}
*
next
=
head_a
;
if
(
head_b
=
=
NULL
)
return
head
;
}
while
(
1
)
;
}
static
struct
edge
*
sort_edges
(
struct
edge
*
list
unsigned
int
level
struct
edge
*
*
head_out
)
{
struct
edge
*
head_other
*
remaining
;
unsigned
int
i
;
head_other
=
list
-
>
next
;
if
(
head_other
=
=
NULL
)
{
*
head_out
=
list
;
return
NULL
;
}
remaining
=
head_other
-
>
next
;
if
(
list
-
>
x
.
quo
<
=
head_other
-
>
x
.
quo
)
{
*
head_out
=
list
;
head_other
-
>
next
=
NULL
;
}
else
{
*
head_out
=
head_other
;
head_other
-
>
next
=
list
;
list
-
>
next
=
NULL
;
}
for
(
i
=
0
;
i
<
level
&
&
remaining
;
i
+
+
)
{
remaining
=
sort_edges
(
remaining
i
&
head_other
)
;
*
head_out
=
merge_sorted_edges
(
*
head_out
head_other
)
;
}
return
remaining
;
}
inline
static
int
active_list_can_step_full_row
(
struct
active_list
*
active
)
{
const
struct
edge
*
e
;
int
prev_x
=
INT_MIN
;
if
(
active
-
>
min_height
<
=
0
)
{
int
min_height
=
INT_MAX
;
e
=
active
-
>
head
;
while
(
NULL
!
=
e
)
{
if
(
e
-
>
height_left
<
min_height
)
min_height
=
e
-
>
height_left
;
e
=
e
-
>
next
;
}
active
-
>
min_height
=
min_height
;
}
if
(
active
-
>
min_height
<
GRID_Y
)
return
0
;
e
=
active
-
>
head
;
while
(
NULL
!
=
e
)
{
struct
quorem
x
=
e
-
>
x
;
if
(
!
e
-
>
vertical
)
{
x
.
quo
+
=
e
-
>
dxdy_full
.
quo
;
x
.
rem
+
=
e
-
>
dxdy_full
.
rem
;
if
(
x
.
rem
>
=
0
)
+
+
x
.
quo
;
}
if
(
x
.
quo
<
=
prev_x
)
return
0
;
prev_x
=
x
.
quo
;
e
=
e
-
>
next
;
}
return
1
;
}
inline
static
void
active_list_merge_edges_from_polygon
(
struct
active_list
*
active
struct
edge
*
*
ptail
grid_scaled_y_t
y
struct
polygon
*
polygon
)
{
int
min_height
=
active
-
>
min_height
;
struct
edge
*
subrow_edges
=
NULL
;
struct
edge
*
tail
=
*
ptail
;
do
{
struct
edge
*
next
=
tail
-
>
next
;
if
(
y
=
=
tail
-
>
ytop
)
{
tail
-
>
next
=
subrow_edges
;
subrow_edges
=
tail
;
if
(
tail
-
>
height_left
<
min_height
)
min_height
=
tail
-
>
height_left
;
*
ptail
=
next
;
}
else
ptail
=
&
tail
-
>
next
;
tail
=
next
;
}
while
(
tail
)
;
if
(
subrow_edges
)
{
sort_edges
(
subrow_edges
UINT_MAX
&
subrow_edges
)
;
active
-
>
head
=
merge_sorted_edges
(
active
-
>
head
subrow_edges
)
;
active
-
>
min_height
=
min_height
;
}
}
inline
static
void
active_list_substep_edges
(
struct
active_list
*
active
)
{
struct
edge
*
*
cursor
=
&
active
-
>
head
;
grid_scaled_x_t
prev_x
=
INT_MIN
;
struct
edge
*
unsorted
=
NULL
;
struct
edge
*
edge
=
*
cursor
;
do
{
UNROLL3
(
{
struct
edge
*
next
;
if
(
NULL
=
=
edge
)
break
;
next
=
edge
-
>
next
;
if
(
-
-
edge
-
>
height_left
)
{
edge
-
>
x
.
quo
+
=
edge
-
>
dxdy
.
quo
;
edge
-
>
x
.
rem
+
=
edge
-
>
dxdy
.
rem
;
if
(
edge
-
>
x
.
rem
>
=
0
)
{
+
+
edge
-
>
x
.
quo
;
edge
-
>
x
.
rem
-
=
edge
-
>
dy
;
}
if
(
edge
-
>
x
.
quo
<
prev_x
)
{
*
cursor
=
next
;
edge
-
>
next
=
unsorted
;
unsorted
=
edge
;
}
else
{
prev_x
=
edge
-
>
x
.
quo
;
cursor
=
&
edge
-
>
next
;
}
}
else
{
*
cursor
=
next
;
}
edge
=
next
;
}
)
}
while
(
1
)
;
if
(
unsorted
)
{
sort_edges
(
unsorted
UINT_MAX
&
unsorted
)
;
active
-
>
head
=
merge_sorted_edges
(
active
-
>
head
unsorted
)
;
}
}
inline
static
void
apply_nonzero_fill_rule_for_subrow
(
struct
active_list
*
active
struct
cell_list
*
coverages
)
{
struct
edge
*
edge
=
active
-
>
head
;
int
winding
=
0
;
int
xstart
;
int
xend
;
cell_list_rewind
(
coverages
)
;
while
(
NULL
!
=
edge
)
{
xstart
=
edge
-
>
x
.
quo
;
winding
=
edge
-
>
dir
;
while
(
1
)
{
edge
=
edge
-
>
next
;
if
(
NULL
=
=
edge
)
{
ASSERT_NOT_REACHED
;
return
;
}
winding
+
=
edge
-
>
dir
;
if
(
0
=
=
winding
)
{
if
(
edge
-
>
next
=
=
NULL
|
|
edge
-
>
next
-
>
x
.
quo
!
=
edge
-
>
x
.
quo
)
break
;
}
}
xend
=
edge
-
>
x
.
quo
;
cell_list_add_subspan
(
coverages
xstart
xend
)
;
edge
=
edge
-
>
next
;
}
}
static
void
apply_evenodd_fill_rule_for_subrow
(
struct
active_list
*
active
struct
cell_list
*
coverages
)
{
struct
edge
*
edge
=
active
-
>
head
;
int
xstart
;
int
xend
;
cell_list_rewind
(
coverages
)
;
while
(
NULL
!
=
edge
)
{
xstart
=
edge
-
>
x
.
quo
;
while
(
1
)
{
edge
=
edge
-
>
next
;
if
(
NULL
=
=
edge
)
{
ASSERT_NOT_REACHED
;
return
;
}
if
(
edge
-
>
next
=
=
NULL
|
|
edge
-
>
next
-
>
x
.
quo
!
=
edge
-
>
x
.
quo
)
break
;
edge
=
edge
-
>
next
;
}
xend
=
edge
-
>
x
.
quo
;
cell_list_add_subspan
(
coverages
xstart
xend
)
;
edge
=
edge
-
>
next
;
}
}
static
void
apply_nonzero_fill_rule_and_step_edges
(
struct
active_list
*
active
struct
cell_list
*
coverages
)
{
struct
edge
*
*
cursor
=
&
active
-
>
head
;
struct
edge
*
left_edge
;
left_edge
=
*
cursor
;
while
(
NULL
!
=
left_edge
)
{
struct
edge
*
right_edge
;
int
winding
=
left_edge
-
>
dir
;
left_edge
-
>
height_left
-
=
GRID_Y
;
if
(
left_edge
-
>
height_left
)
cursor
=
&
left_edge
-
>
next
;
else
*
cursor
=
left_edge
-
>
next
;
while
(
1
)
{
right_edge
=
*
cursor
;
if
(
NULL
=
=
right_edge
)
{
cell_list_render_edge
(
coverages
left_edge
+
1
)
;
return
;
}
right_edge
-
>
height_left
-
=
GRID_Y
;
if
(
right_edge
-
>
height_left
)
cursor
=
&
right_edge
-
>
next
;
else
*
cursor
=
right_edge
-
>
next
;
winding
+
=
right_edge
-
>
dir
;
if
(
0
=
=
winding
)
{
if
(
right_edge
-
>
next
=
=
NULL
|
|
right_edge
-
>
next
-
>
x
.
quo
!
=
right_edge
-
>
x
.
quo
)
{
break
;
}
}
if
(
!
right_edge
-
>
vertical
)
{
right_edge
-
>
x
.
quo
+
=
right_edge
-
>
dxdy_full
.
quo
;
right_edge
-
>
x
.
rem
+
=
right_edge
-
>
dxdy_full
.
rem
;
if
(
right_edge
-
>
x
.
rem
>
=
0
)
{
+
+
right_edge
-
>
x
.
quo
;
right_edge
-
>
x
.
rem
-
=
right_edge
-
>
dy
;
}
}
}
cell_list_render_edge
(
coverages
left_edge
+
1
)
;
cell_list_render_edge
(
coverages
right_edge
-
1
)
;
left_edge
=
*
cursor
;
}
}
static
void
apply_evenodd_fill_rule_and_step_edges
(
struct
active_list
*
active
struct
cell_list
*
coverages
)
{
struct
edge
*
*
cursor
=
&
active
-
>
head
;
struct
edge
*
left_edge
;
left_edge
=
*
cursor
;
while
(
NULL
!
=
left_edge
)
{
struct
edge
*
right_edge
;
left_edge
-
>
height_left
-
=
GRID_Y
;
if
(
left_edge
-
>
height_left
)
cursor
=
&
left_edge
-
>
next
;
else
*
cursor
=
left_edge
-
>
next
;
while
(
1
)
{
right_edge
=
*
cursor
;
if
(
NULL
=
=
right_edge
)
{
cell_list_render_edge
(
coverages
left_edge
+
1
)
;
return
;
}
right_edge
-
>
height_left
-
=
GRID_Y
;
if
(
right_edge
-
>
height_left
)
cursor
=
&
right_edge
-
>
next
;
else
*
cursor
=
right_edge
-
>
next
;
if
(
right_edge
-
>
next
=
=
NULL
|
|
right_edge
-
>
next
-
>
x
.
quo
!
=
right_edge
-
>
x
.
quo
)
{
break
;
}
if
(
!
right_edge
-
>
vertical
)
{
right_edge
-
>
x
.
quo
+
=
right_edge
-
>
dxdy_full
.
quo
;
right_edge
-
>
x
.
rem
+
=
right_edge
-
>
dxdy_full
.
rem
;
if
(
right_edge
-
>
x
.
rem
>
=
0
)
{
+
+
right_edge
-
>
x
.
quo
;
right_edge
-
>
x
.
rem
-
=
right_edge
-
>
dy
;
}
}
}
cell_list_render_edge
(
coverages
left_edge
+
1
)
;
cell_list_render_edge
(
coverages
right_edge
-
1
)
;
left_edge
=
*
cursor
;
}
}
static
void
_glitter_scan_converter_init
(
glitter_scan_converter_t
*
converter
jmp_buf
*
jmp
)
{
polygon_init
(
converter
-
>
polygon
jmp
)
;
active_list_init
(
converter
-
>
active
)
;
cell_list_init
(
converter
-
>
coverages
jmp
)
;
converter
-
>
ymin
=
0
;
converter
-
>
ymax
=
0
;
}
static
void
_glitter_scan_converter_fini
(
glitter_scan_converter_t
*
converter
)
{
polygon_fini
(
converter
-
>
polygon
)
;
cell_list_fini
(
converter
-
>
coverages
)
;
converter
-
>
ymin
=
0
;
converter
-
>
ymax
=
0
;
}
static
grid_scaled_t
int_to_grid_scaled
(
int
i
int
scale
)
{
if
(
i
>
=
0
)
{
if
(
i
>
=
INT_MAX
/
scale
)
i
=
INT_MAX
/
scale
;
}
else
{
if
(
i
<
=
INT_MIN
/
scale
)
i
=
INT_MIN
/
scale
;
}
return
i
*
scale
;
}
#
define
int_to_grid_scaled_x
(
x
)
int_to_grid_scaled
(
(
x
)
GRID_X
)
#
define
int_to_grid_scaled_y
(
x
)
int_to_grid_scaled
(
(
x
)
GRID_Y
)
static
cairo_status_t
glitter_scan_converter_reset
(
glitter_scan_converter_t
*
converter
int
ymin
int
ymax
)
{
cairo_status_t
status
;
converter
-
>
ymin
=
0
;
converter
-
>
ymax
=
0
;
ymin
=
int_to_grid_scaled_y
(
ymin
)
;
ymax
=
int_to_grid_scaled_y
(
ymax
)
;
active_list_reset
(
converter
-
>
active
)
;
cell_list_reset
(
converter
-
>
coverages
)
;
status
=
polygon_reset
(
converter
-
>
polygon
ymin
ymax
)
;
if
(
status
)
return
status
;
converter
-
>
ymin
=
ymin
;
converter
-
>
ymax
=
ymax
;
return
CAIRO_STATUS_SUCCESS
;
}
#
if
!
defined
(
INPUT_TO_GRID_Y
)
&
&
defined
(
GRID_Y_BITS
)
&
&
GRID_Y_BITS
<
=
GLITTER_INPUT_BITS
#
define
INPUT_TO_GRID_Y
(
in
out
)
(
out
)
=
(
in
)
>
>
(
GLITTER_INPUT_BITS
-
GRID_Y_BITS
)
#
else
#
define
INPUT_TO_GRID_Y
(
in
out
)
INPUT_TO_GRID_general
(
in
out
GRID_Y
)
#
endif
#
if
!
defined
(
INPUT_TO_GRID_X
)
&
&
defined
(
GRID_X_BITS
)
&
&
GRID_X_BITS
<
=
GLITTER_INPUT_BITS
#
define
INPUT_TO_GRID_X
(
in
out
)
(
out
)
=
(
in
)
>
>
(
GLITTER_INPUT_BITS
-
GRID_X_BITS
)
#
else
#
define
INPUT_TO_GRID_X
(
in
out
)
INPUT_TO_GRID_general
(
in
out
GRID_X
)
#
endif
#
define
INPUT_TO_GRID_general
(
in
out
grid_scale
)
do
{
\
long
long
tmp__
=
(
long
long
)
(
grid_scale
)
*
(
in
)
;
\
tmp__
>
>
=
GLITTER_INPUT_BITS
;
\
(
out
)
=
tmp__
;
\
}
while
(
0
)
static
void
glitter_scan_converter_add_edge
(
glitter_scan_converter_t
*
converter
const
cairo_edge_t
*
edge
int
clip
)
{
cairo_edge_t
e
;
INPUT_TO_GRID_Y
(
edge
-
>
top
e
.
top
)
;
INPUT_TO_GRID_Y
(
edge
-
>
bottom
e
.
bottom
)
;
if
(
e
.
top
>
=
e
.
bottom
)
return
;
INPUT_TO_GRID_Y
(
edge
-
>
line
.
p1
.
y
e
.
line
.
p1
.
y
)
;
INPUT_TO_GRID_Y
(
edge
-
>
line
.
p2
.
y
e
.
line
.
p2
.
y
)
;
if
(
e
.
line
.
p1
.
y
=
=
e
.
line
.
p2
.
y
)
return
;
INPUT_TO_GRID_X
(
edge
-
>
line
.
p1
.
x
e
.
line
.
p1
.
x
)
;
INPUT_TO_GRID_X
(
edge
-
>
line
.
p2
.
x
e
.
line
.
p2
.
x
)
;
e
.
dir
=
edge
-
>
dir
;
polygon_add_edge
(
converter
-
>
polygon
&
e
clip
)
;
}
static
cairo_bool_t
active_list_is_vertical
(
struct
active_list
*
active
)
{
struct
edge
*
e
;
for
(
e
=
active
-
>
head
;
e
!
=
NULL
;
e
=
e
-
>
next
)
{
if
(
!
e
-
>
vertical
)
return
FALSE
;
}
return
TRUE
;
}
static
void
step_edges
(
struct
active_list
*
active
int
count
)
{
struct
edge
*
*
cursor
=
&
active
-
>
head
;
struct
edge
*
edge
;
for
(
edge
=
*
cursor
;
edge
!
=
NULL
;
edge
=
*
cursor
)
{
edge
-
>
height_left
-
=
GRID_Y
*
count
;
if
(
edge
-
>
height_left
)
cursor
=
&
edge
-
>
next
;
else
*
cursor
=
edge
-
>
next
;
}
}
static
cairo_status_t
blit_coverages
(
struct
cell_list
*
cells
cairo_span_renderer_t
*
renderer
struct
pool
*
span_pool
int
y
int
height
)
{
struct
cell
*
cell
=
cells
-
>
head
.
next
;
int
prev_x
=
-
1
;
int
cover
=
0
last_cover
=
0
;
int
clip
=
0
;
cairo_half_open_span_t
*
spans
;
unsigned
num_spans
;
assert
(
cell
!
=
&
cells
-
>
tail
)
;
{
struct
cell
*
next
=
cell
;
num_spans
=
2
;
while
(
next
-
>
next
)
{
next
=
next
-
>
next
;
+
+
num_spans
;
}
num_spans
=
2
*
num_spans
;
}
pool_reset
(
span_pool
)
;
spans
=
pool_alloc
(
span_pool
sizeof
(
spans
[
0
]
)
*
num_spans
)
;
num_spans
=
0
;
for
(
;
cell
-
>
next
;
cell
=
cell
-
>
next
)
{
int
x
=
cell
-
>
x
;
int
area
;
if
(
x
>
prev_x
&
&
cover
!
=
last_cover
)
{
spans
[
num_spans
]
.
x
=
prev_x
;
spans
[
num_spans
]
.
coverage
=
GRID_AREA_TO_ALPHA
(
cover
)
;
spans
[
num_spans
]
.
inverse
=
0
;
last_cover
=
cover
;
+
+
num_spans
;
}
cover
+
=
cell
-
>
covered_height
*
GRID_X
*
2
;
clip
+
=
cell
-
>
covered_height
*
GRID_X
*
2
;
area
=
cover
-
cell
-
>
uncovered_area
;
if
(
area
!
=
last_cover
)
{
spans
[
num_spans
]
.
x
=
x
;
spans
[
num_spans
]
.
coverage
=
GRID_AREA_TO_ALPHA
(
area
)
;
spans
[
num_spans
]
.
inverse
=
0
;
last_cover
=
area
;
+
+
num_spans
;
}
prev_x
=
x
+
1
;
}
return
renderer
-
>
render_rows
(
renderer
y
height
spans
num_spans
)
;
}
static
void
glitter_scan_converter_render
(
glitter_scan_converter_t
*
converter
int
nonzero_fill
cairo_span_renderer_t
*
span_renderer
struct
pool
*
span_pool
)
{
int
i
j
;
int
ymax_i
=
converter
-
>
ymax
/
GRID_Y
;
int
ymin_i
=
converter
-
>
ymin
/
GRID_Y
;
int
h
=
ymax_i
-
ymin_i
;
struct
polygon
*
polygon
=
converter
-
>
polygon
;
struct
cell_list
*
coverages
=
converter
-
>
coverages
;
struct
active_list
*
active
=
converter
-
>
active
;
for
(
i
=
0
;
i
<
h
;
i
=
j
)
{
int
do_full_step
=
0
;
j
=
i
+
1
;
if
(
GRID_Y
=
=
EDGE_Y_BUCKET_HEIGHT
&
&
!
polygon
-
>
y_buckets
[
i
]
)
{
if
(
!
active
-
>
head
)
{
for
(
;
j
<
h
&
&
!
polygon
-
>
y_buckets
[
j
]
;
j
+
+
)
;
continue
;
}
do_full_step
=
active_list_can_step_full_row
(
active
)
;
}
if
(
do_full_step
)
{
if
(
nonzero_fill
)
apply_nonzero_fill_rule_and_step_edges
(
active
coverages
)
;
else
apply_evenodd_fill_rule_and_step_edges
(
active
coverages
)
;
if
(
active_list_is_vertical
(
active
)
)
{
while
(
j
<
h
&
&
polygon
-
>
y_buckets
[
j
]
=
=
NULL
&
&
active
-
>
min_height
>
=
2
*
GRID_Y
)
{
active
-
>
min_height
-
=
GRID_Y
;
j
+
+
;
}
if
(
j
!
=
i
+
1
)
step_edges
(
active
j
-
(
i
+
1
)
)
;
}
}
else
{
grid_scaled_y_t
suby
;
for
(
suby
=
0
;
suby
<
GRID_Y
;
suby
+
+
)
{
grid_scaled_y_t
y
=
(
i
+
ymin_i
)
*
GRID_Y
+
suby
;
if
(
polygon
-
>
y_buckets
[
i
]
)
{
active_list_merge_edges_from_polygon
(
active
&
polygon
-
>
y_buckets
[
i
]
y
polygon
)
;
}
if
(
nonzero_fill
)
apply_nonzero_fill_rule_for_subrow
(
active
coverages
)
;
else
apply_evenodd_fill_rule_for_subrow
(
active
coverages
)
;
active_list_substep_edges
(
active
)
;
}
}
blit_coverages
(
coverages
span_renderer
span_pool
i
+
ymin_i
j
-
i
)
;
cell_list_reset
(
coverages
)
;
if
(
!
active
-
>
head
)
active
-
>
min_height
=
INT_MAX
;
else
active
-
>
min_height
-
=
GRID_Y
;
}
}
struct
_cairo_clip_tor_scan_converter
{
cairo_scan_converter_t
base
;
glitter_scan_converter_t
converter
[
1
]
;
cairo_fill_rule_t
fill_rule
;
cairo_antialias_t
antialias
;
cairo_fill_rule_t
clip_fill_rule
;
cairo_antialias_t
clip_antialias
;
jmp_buf
jmp
;
struct
{
struct
pool
base
[
1
]
;
cairo_half_open_span_t
embedded
[
32
]
;
}
span_pool
;
}
;
typedef
struct
_cairo_clip_tor_scan_converter
cairo_clip_tor_scan_converter_t
;
static
void
_cairo_clip_tor_scan_converter_destroy
(
void
*
converter
)
{
cairo_clip_tor_scan_converter_t
*
self
=
converter
;
if
(
self
=
=
NULL
)
{
return
;
}
_glitter_scan_converter_fini
(
self
-
>
converter
)
;
pool_fini
(
self
-
>
span_pool
.
base
)
;
free
(
self
)
;
}
static
cairo_status_t
_cairo_clip_tor_scan_converter_generate
(
void
*
converter
cairo_span_renderer_t
*
renderer
)
{
cairo_clip_tor_scan_converter_t
*
self
=
converter
;
cairo_status_t
status
;
if
(
(
status
=
setjmp
(
self
-
>
jmp
)
)
)
return
_cairo_scan_converter_set_error
(
self
_cairo_error
(
status
)
)
;
glitter_scan_converter_render
(
self
-
>
converter
self
-
>
fill_rule
=
=
CAIRO_FILL_RULE_WINDING
renderer
self
-
>
span_pool
.
base
)
;
return
CAIRO_STATUS_SUCCESS
;
}
cairo_scan_converter_t
*
_cairo_clip_tor_scan_converter_create
(
cairo_clip_t
*
clip
cairo_polygon_t
*
polygon
cairo_fill_rule_t
fill_rule
cairo_antialias_t
antialias
)
{
cairo_clip_tor_scan_converter_t
*
self
;
cairo_polygon_t
clipper
;
cairo_status_t
status
;
int
i
;
self
=
calloc
(
1
sizeof
(
struct
_cairo_clip_tor_scan_converter
)
)
;
if
(
unlikely
(
self
=
=
NULL
)
)
{
status
=
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
goto
bail_nomem
;
}
self
-
>
base
.
destroy
=
_cairo_clip_tor_scan_converter_destroy
;
self
-
>
base
.
generate
=
_cairo_clip_tor_scan_converter_generate
;
pool_init
(
self
-
>
span_pool
.
base
&
self
-
>
jmp
250
*
sizeof
(
self
-
>
span_pool
.
embedded
[
0
]
)
sizeof
(
self
-
>
span_pool
.
embedded
)
)
;
_glitter_scan_converter_init
(
self
-
>
converter
&
self
-
>
jmp
)
;
status
=
glitter_scan_converter_reset
(
self
-
>
converter
clip
-
>
extents
.
y
clip
-
>
extents
.
y
+
clip
-
>
extents
.
height
)
;
if
(
unlikely
(
status
)
)
goto
bail
;
self
-
>
fill_rule
=
fill_rule
;
self
-
>
antialias
=
antialias
;
for
(
i
=
0
;
i
<
polygon
-
>
num_edges
;
i
+
+
)
glitter_scan_converter_add_edge
(
self
-
>
converter
&
polygon
-
>
edges
[
i
]
FALSE
)
;
status
=
_cairo_clip_get_polygon
(
clip
&
clipper
&
self
-
>
clip_fill_rule
&
self
-
>
clip_antialias
)
;
if
(
unlikely
(
status
)
)
goto
bail
;
for
(
i
=
0
;
i
<
clipper
.
num_edges
;
i
+
+
)
glitter_scan_converter_add_edge
(
self
-
>
converter
&
clipper
.
edges
[
i
]
TRUE
)
;
_cairo_polygon_fini
(
&
clipper
)
;
return
&
self
-
>
base
;
bail
:
self
-
>
base
.
destroy
(
&
self
-
>
base
)
;
bail_nomem
:
return
_cairo_scan_converter_create_in_error
(
status
)
;
}
