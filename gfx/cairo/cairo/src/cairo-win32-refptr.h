#
ifndef
CAIRO_WIN32_REFPTR_H
#
define
CAIRO_WIN32_REFPTR_H
template
<
typename
T
>
class
TemporaryRef
;
template
<
typename
T
>
class
RefPtr
{
friend
class
TemporaryRef
<
T
>
;
struct
dontRef
{
}
;
public
:
RefPtr
(
)
:
ptr
(
0
)
{
}
RefPtr
(
const
RefPtr
&
o
)
:
ptr
(
ref
(
o
.
ptr
)
)
{
}
RefPtr
(
const
TemporaryRef
<
T
>
&
o
)
:
ptr
(
o
.
drop
(
)
)
{
}
RefPtr
(
T
*
t
)
:
ptr
(
ref
(
t
)
)
{
}
template
<
typename
U
>
RefPtr
(
const
RefPtr
<
U
>
&
o
)
:
ptr
(
ref
(
o
.
get
(
)
)
)
{
}
~
RefPtr
(
)
{
unref
(
ptr
)
;
}
RefPtr
&
operator
=
(
const
RefPtr
&
o
)
{
assign
(
ref
(
o
.
ptr
)
)
;
return
*
this
;
}
RefPtr
&
operator
=
(
const
TemporaryRef
<
T
>
&
o
)
{
assign
(
o
.
drop
(
)
)
;
return
*
this
;
}
RefPtr
&
operator
=
(
T
*
t
)
{
assign
(
ref
(
t
)
)
;
return
*
this
;
}
template
<
typename
U
>
RefPtr
&
operator
=
(
const
RefPtr
<
U
>
&
o
)
{
assign
(
ref
(
o
.
get
(
)
)
)
;
return
*
this
;
}
TemporaryRef
<
T
>
forget
(
)
{
T
*
tmp
=
ptr
;
ptr
=
0
;
return
TemporaryRef
<
T
>
(
tmp
dontRef
(
)
)
;
}
T
*
get
(
)
const
{
return
ptr
;
}
operator
T
*
(
)
const
{
return
ptr
;
}
T
*
operator
-
>
(
)
const
{
return
ptr
;
}
T
&
operator
*
(
)
const
{
return
*
ptr
;
}
template
<
typename
U
>
operator
TemporaryRef
<
U
>
(
)
{
return
TemporaryRef
<
U
>
(
ptr
)
;
}
T
*
*
operator
&
(
)
{
if
(
ptr
)
{
ptr
-
>
Release
(
)
;
ptr
=
NULL
;
}
return
&
ptr
;
}
private
:
void
assign
(
T
*
t
)
{
unref
(
ptr
)
;
ptr
=
t
;
}
T
*
ptr
;
static
inline
T
*
ref
(
T
*
t
)
{
if
(
t
)
{
t
-
>
AddRef
(
)
;
}
return
t
;
}
static
inline
void
unref
(
T
*
t
)
{
if
(
t
)
{
t
-
>
Release
(
)
;
}
}
}
;
template
<
typename
T
>
class
TemporaryRef
{
friend
class
RefPtr
<
T
>
;
typedef
typename
RefPtr
<
T
>
:
:
dontRef
dontRef
;
public
:
TemporaryRef
(
T
*
t
)
:
ptr
(
RefPtr
<
T
>
:
:
ref
(
t
)
)
{
}
TemporaryRef
(
const
TemporaryRef
&
o
)
:
ptr
(
o
.
drop
(
)
)
{
}
template
<
typename
U
>
TemporaryRef
(
const
TemporaryRef
<
U
>
&
o
)
:
ptr
(
o
.
drop
(
)
)
{
}
~
TemporaryRef
(
)
{
RefPtr
<
T
>
:
:
unref
(
ptr
)
;
}
T
*
drop
(
)
const
{
T
*
tmp
=
ptr
;
ptr
=
0
;
return
tmp
;
}
private
:
TemporaryRef
(
T
*
t
const
dontRef
&
)
:
ptr
(
t
)
{
}
mutable
T
*
ptr
;
TemporaryRef
(
)
;
TemporaryRef
&
operator
=
(
const
TemporaryRef
&
)
;
}
;
#
endif
