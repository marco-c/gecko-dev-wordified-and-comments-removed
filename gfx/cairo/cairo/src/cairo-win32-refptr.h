#
ifndef
CAIRO_WIN32_REFPTR_H
#
define
CAIRO_WIN32_REFPTR_H
template
<
class
T
>
class
RefPtr
{
public
:
RefPtr
(
)
:
mPtr
(
NULL
)
{
}
RefPtr
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
if
(
mPtr
)
{
mPtr
-
>
AddRef
(
)
;
}
}
RefPtr
(
const
RefPtr
<
T
>
&
aRefPtr
)
{
mPtr
=
aRefPtr
.
mPtr
;
if
(
mPtr
)
{
mPtr
-
>
AddRef
(
)
;
}
}
template
<
class
newType
>
explicit
RefPtr
(
const
RefPtr
<
newType
>
&
aRefPtr
)
{
mPtr
=
aRefPtr
.
get
(
)
;
if
(
mPtr
)
{
mPtr
-
>
AddRef
(
)
;
}
}
~
RefPtr
(
)
{
if
(
mPtr
)
{
mPtr
-
>
Release
(
)
;
}
}
template
<
typename
U
>
RefPtr
<
T
>
&
operator
=
(
const
RefPtr
<
U
>
aPtr
)
{
assignPtr
(
aPtr
)
;
return
*
this
;
}
RefPtr
<
T
>
&
operator
=
(
T
*
aPtr
)
{
assignPtr
(
aPtr
)
;
return
*
this
;
}
T
*
*
operator
&
(
)
{
if
(
mPtr
)
{
mPtr
-
>
Release
(
)
;
mPtr
=
NULL
;
}
return
&
mPtr
;
}
T
*
operator
-
>
(
)
{
return
mPtr
;
}
T
*
operator
-
>
(
)
const
{
return
mPtr
;
}
operator
bool
(
)
{
return
(
mPtr
?
true
:
false
)
;
}
operator
T
*
(
)
const
{
return
mPtr
;
}
template
<
class
newType
>
operator
RefPtr
<
newType
>
(
)
{
RefPtr
<
newType
>
newPtr
;
newPtr
=
mPtr
;
return
newPtr
;
}
T
*
get
(
)
const
{
return
mPtr
;
}
T
*
forget
(
)
{
T
*
ptr
=
mPtr
;
mPtr
=
NULL
;
return
ptr
;
}
private
:
void
assignPtr
(
T
*
aPtr
)
{
T
*
oldPtr
=
mPtr
;
mPtr
=
aPtr
;
if
(
mPtr
)
{
mPtr
-
>
AddRef
(
)
;
}
if
(
oldPtr
)
{
oldPtr
-
>
Release
(
)
;
}
}
T
*
mPtr
;
}
;
#
endif
