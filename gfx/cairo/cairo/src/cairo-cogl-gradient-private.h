#
ifndef
CAIRO_COGL_GRADIENT_PRIVATE_H
#
define
CAIRO_COGL_GRADIENT_PRIVATE_H
#
include
"
cairoint
.
h
"
#
include
"
cairo
-
pattern
-
private
.
h
"
#
include
<
cogl
/
cogl2
-
experimental
.
h
>
#
define
CAIRO_COGL_LINEAR_GRADIENT_CACHE_SIZE
(
1024
*
1024
)
typedef
enum
_cairo_cogl_gradient_compatibility
{
CAIRO_COGL_GRADIENT_CAN_EXTEND_PAD
=
1
<
<
0
CAIRO_COGL_GRADIENT_CAN_EXTEND_REPEAT
=
1
<
<
1
CAIRO_COGL_GRADIENT_CAN_EXTEND_REFLECT
=
1
<
<
2
CAIRO_COGL_GRADIENT_CAN_EXTEND_NONE
=
1
<
<
3
}
cairo_cogl_gradient_compatibility_t
;
#
define
CAIRO_COGL_GRADIENT_CAN_EXTEND_ALL
(
CAIRO_COGL_GRADIENT_CAN_EXTEND_PAD
|
\
CAIRO_COGL_GRADIENT_CAN_EXTEND_REPEAT
|
\
CAIRO_COGL_GRADIENT_CAN_EXTEND_REFLECT
|
\
CAIRO_COGL_GRADIENT_CAN_EXTEND_NONE
)
typedef
struct
_cairo_cogl_linear_texture_entry
{
cairo_cogl_gradient_compatibility_t
compatibility
;
CoglTexture
*
texture
;
float
translate_x
;
float
scale_x
;
}
cairo_cogl_linear_texture_entry_t
;
typedef
struct
_cairo_cogl_linear_gradient
{
cairo_cache_entry_t
cache_entry
;
cairo_reference_count_t
ref_count
;
GList
*
textures
;
int
n_stops
;
const
cairo_gradient_stop_t
*
stops
;
cairo_gradient_stop_t
stops_embedded
[
1
]
;
}
cairo_cogl_linear_gradient_t
;
cairo_int_status_t
_cairo_cogl_get_linear_gradient
(
cairo_cogl_device_t
*
context
cairo_extend_t
extend_mode
int
n_stops
const
cairo_gradient_stop_t
*
stops
const
cairo_bool_t
need_mirrored_gradient
cairo_cogl_linear_gradient_t
*
*
gradient_out
)
;
cairo_cogl_linear_texture_entry_t
*
_cairo_cogl_linear_gradient_texture_for_extend
(
cairo_cogl_linear_gradient_t
*
gradient
cairo_extend_t
extend_mode
)
;
cairo_cogl_linear_gradient_t
*
_cairo_cogl_linear_gradient_reference
(
cairo_cogl_linear_gradient_t
*
gradient
)
;
void
_cairo_cogl_linear_gradient_destroy
(
cairo_cogl_linear_gradient_t
*
gradient
)
;
cairo_bool_t
_cairo_cogl_linear_gradient_equal
(
const
void
*
key_a
const
void
*
key_b
)
;
#
endif
