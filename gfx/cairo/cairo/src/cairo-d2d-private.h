#
ifndef
CAIRO_D2D_PRIVATE_H
#
define
CAIRO_D2D_PRIVATE_H
#
ifdef
CAIRO_HAS_D2D_SURFACE
#
include
<
windows
.
h
>
#
include
<
d2d1
.
h
>
#
include
<
d3d10
.
h
>
#
include
<
dxgi
.
h
>
extern
"
C
"
{
#
include
"
cairoint
.
h
"
#
include
"
cairo
-
surface
-
clipper
-
private
.
h
"
}
#
include
"
cairo
-
win32
-
refptr
.
h
"
struct
d2d_clip
;
struct
_cairo_d2d_surface
{
_cairo_d2d_surface
(
)
:
d2d_clip
(
NULL
)
clipping
(
false
)
isDrawing
(
false
)
textRenderingInit
(
true
)
{
_cairo_clip_init
(
&
this
-
>
clip
)
;
}
cairo_surface_t
base
;
RefPtr
<
ID2D1RenderTarget
>
rt
;
RefPtr
<
ID3D10Resource
>
surface
;
RefPtr
<
ID3D10Texture2D
>
bufferTexture
;
RefPtr
<
IDXGISurface
>
backBuf
;
RefPtr
<
ID2D1Bitmap
>
surfaceBitmap
;
RefPtr
<
IDXGISwapChain
>
dxgiChain
;
HWND
hwnd
;
cairo_format_t
format
;
cairo_clip_t
clip
;
d2d_clip
*
d2d_clip
;
RefPtr
<
ID2D1Layer
>
maskLayer
;
RefPtr
<
ID2D1Layer
>
helperLayer
;
bool
clipping
;
RefPtr
<
ID2D1BitmapBrush
>
bitmapBrush
;
RefPtr
<
ID2D1SolidColorBrush
>
solidColorBrush
;
bool
isDrawing
;
bool
textRenderingInit
;
}
;
typedef
struct
_cairo_d2d_surface
cairo_d2d_surface_t
;
typedef
HRESULT
(
WINAPI
*
D2D1CreateFactoryFunc
)
(
__in
D2D1_FACTORY_TYPE
factoryType
__in
REFIID
iid
__in_opt
CONST
D2D1_FACTORY_OPTIONS
*
pFactoryOptions
__out
void
*
*
factory
)
;
typedef
HRESULT
(
WINAPI
*
D3D10CreateDevice1Func
)
(
IDXGIAdapter
*
pAdapter
D3D10_DRIVER_TYPE
DriverType
HMODULE
Software
UINT
Flags
D3D10_FEATURE_LEVEL1
HardwareLevel
UINT
SDKVersion
ID3D10Device1
*
*
ppDevice
)
;
class
D2DSurfFactory
{
public
:
static
ID2D1Factory
*
Instance
(
)
{
if
(
!
mFactoryInstance
)
{
D2D1CreateFactoryFunc
createD2DFactory
=
(
D2D1CreateFactoryFunc
)
GetProcAddress
(
LoadLibraryW
(
L
"
d2d1
.
dll
"
)
"
D2D1CreateFactory
"
)
;
if
(
createD2DFactory
)
{
D2D1_FACTORY_OPTIONS
options
;
#
ifdef
DEBUG
options
.
debugLevel
=
D2D1_DEBUG_LEVEL_INFORMATION
;
#
else
options
.
debugLevel
=
D2D1_DEBUG_LEVEL_NONE
;
#
endif
createD2DFactory
(
D2D1_FACTORY_TYPE_SINGLE_THREADED
__uuidof
(
ID2D1Factory
)
&
options
(
void
*
*
)
&
mFactoryInstance
)
;
}
}
return
mFactoryInstance
;
}
private
:
static
ID2D1Factory
*
mFactoryInstance
;
}
;
class
D3D10Factory
{
public
:
static
ID3D10Device1
*
Device
(
)
{
if
(
!
mDeviceInstance
)
{
D3D10CreateDevice1Func
createD3DDevice
=
(
D3D10CreateDevice1Func
)
GetProcAddress
(
LoadLibraryA
(
"
d3d10_1
.
dll
"
)
"
D3D10CreateDevice1
"
)
;
if
(
createD3DDevice
)
{
HRESULT
hr
=
createD3DDevice
(
NULL
D3D10_DRIVER_TYPE_HARDWARE
NULL
D3D10_CREATE_DEVICE_BGRA_SUPPORT
|
D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS
D3D10_FEATURE_LEVEL_10_1
D3D10_1_SDK_VERSION
&
mDeviceInstance
)
;
if
(
FAILED
(
hr
)
)
{
HRESULT
hr
=
createD3DDevice
(
NULL
D3D10_DRIVER_TYPE_HARDWARE
NULL
D3D10_CREATE_DEVICE_BGRA_SUPPORT
|
D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS
D3D10_FEATURE_LEVEL_10_0
D3D10_1_SDK_VERSION
&
mDeviceInstance
)
;
if
(
FAILED
(
hr
)
)
{
HRESULT
hr
=
createD3DDevice
(
NULL
D3D10_DRIVER_TYPE_HARDWARE
NULL
D3D10_CREATE_DEVICE_BGRA_SUPPORT
|
D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS
D3D10_FEATURE_LEVEL_9_3
D3D10_1_SDK_VERSION
&
mDeviceInstance
)
;
}
}
if
(
SUCCEEDED
(
hr
)
)
{
mDeviceInstance
-
>
IASetPrimitiveTopology
(
D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP
)
;
}
}
}
return
mDeviceInstance
;
}
private
:
static
ID3D10Device1
*
mDeviceInstance
;
}
;
RefPtr
<
ID2D1Brush
>
_cairo_d2d_create_brush_for_pattern
(
cairo_d2d_surface_t
*
d2dsurf
const
cairo_pattern_t
*
pattern
bool
unique
=
false
)
;
void
_cairo_d2d_begin_draw_state
(
cairo_d2d_surface_t
*
d2dsurf
)
;
cairo_status_t
_cairo_d2d_set_clip
(
cairo_d2d_surface_t
*
d2dsurf
cairo_clip_t
*
clip
)
;
#
endif
#
endif
