#
include
"
cairoint
.
h
"
#
if
CAIRO_HAS_PDF_OPERATORS
#
include
"
cairo
-
pdf
-
shading
-
private
.
h
"
#
include
"
cairo
-
array
-
private
.
h
"
#
include
"
cairo
-
error
-
private
.
h
"
#
include
<
float
.
h
>
static
unsigned
char
*
encode_coordinate
(
unsigned
char
*
p
double
c
)
{
uint32_t
f
;
f
=
c
;
*
p
+
+
=
f
>
>
24
;
*
p
+
+
=
(
f
>
>
16
)
&
0xff
;
*
p
+
+
=
(
f
>
>
8
)
&
0xff
;
*
p
+
+
=
f
&
0xff
;
return
p
;
}
static
unsigned
char
*
encode_point
(
unsigned
char
*
p
const
cairo_point_double_t
*
point
)
{
p
=
encode_coordinate
(
p
point
-
>
x
)
;
p
=
encode_coordinate
(
p
point
-
>
y
)
;
return
p
;
}
static
unsigned
char
*
encode_color_component
(
unsigned
char
*
p
double
color
)
{
uint16_t
c
;
c
=
_cairo_color_double_to_short
(
color
)
;
*
p
+
+
=
c
>
>
8
;
*
p
+
+
=
c
&
0xff
;
return
p
;
}
static
unsigned
char
*
encode_color
(
unsigned
char
*
p
const
cairo_color_t
*
color
)
{
p
=
encode_color_component
(
p
color
-
>
red
)
;
p
=
encode_color_component
(
p
color
-
>
green
)
;
p
=
encode_color_component
(
p
color
-
>
blue
)
;
return
p
;
}
static
unsigned
char
*
encode_alpha
(
unsigned
char
*
p
const
cairo_color_t
*
color
)
{
p
=
encode_color_component
(
p
color
-
>
alpha
)
;
return
p
;
}
static
cairo_status_t
_cairo_pdf_shading_generate_decode_array
(
cairo_pdf_shading_t
*
shading
const
cairo_mesh_pattern_t
*
mesh
cairo_bool_t
is_alpha
)
{
unsigned
int
num_color_components
i
;
cairo_bool_t
is_valid
;
if
(
is_alpha
)
num_color_components
=
1
;
else
num_color_components
=
3
;
shading
-
>
decode_array_length
=
4
+
num_color_components
*
2
;
shading
-
>
decode_array
=
_cairo_malloc_ab
(
shading
-
>
decode_array_length
sizeof
(
double
)
)
;
if
(
unlikely
(
shading
-
>
decode_array
=
=
NULL
)
)
return
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
is_valid
=
_cairo_mesh_pattern_coord_box
(
mesh
&
shading
-
>
decode_array
[
0
]
&
shading
-
>
decode_array
[
2
]
&
shading
-
>
decode_array
[
1
]
&
shading
-
>
decode_array
[
3
]
)
;
assert
(
is_valid
)
;
assert
(
shading
-
>
decode_array
[
1
]
-
shading
-
>
decode_array
[
0
]
>
=
DBL_EPSILON
)
;
assert
(
shading
-
>
decode_array
[
3
]
-
shading
-
>
decode_array
[
2
]
>
=
DBL_EPSILON
)
;
for
(
i
=
0
;
i
<
num_color_components
;
i
+
+
)
{
shading
-
>
decode_array
[
4
+
2
*
i
]
=
0
;
shading
-
>
decode_array
[
5
+
2
*
i
]
=
1
;
}
return
CAIRO_STATUS_SUCCESS
;
}
static
const
int
pdf_points_order_i
[
16
]
=
{
0
0
0
0
1
2
3
3
3
3
2
1
1
1
2
2
}
;
static
const
int
pdf_points_order_j
[
16
]
=
{
0
1
2
3
3
3
3
2
1
0
0
0
1
2
2
1
}
;
static
cairo_status_t
_cairo_pdf_shading_generate_data
(
cairo_pdf_shading_t
*
shading
const
cairo_mesh_pattern_t
*
mesh
cairo_bool_t
is_alpha
)
{
const
cairo_mesh_patch_t
*
patch
;
double
x_off
y_off
x_scale
y_scale
;
unsigned
int
num_patches
;
unsigned
int
num_color_components
;
unsigned
char
*
p
;
unsigned
int
i
j
;
if
(
is_alpha
)
num_color_components
=
1
;
else
num_color_components
=
3
;
num_patches
=
_cairo_array_num_elements
(
&
mesh
-
>
patches
)
;
patch
=
_cairo_array_index_const
(
&
mesh
-
>
patches
0
)
;
shading
-
>
data_length
=
num_patches
*
(
1
+
16
*
2
*
4
+
4
*
2
*
num_color_components
)
;
shading
-
>
data
=
_cairo_malloc
(
shading
-
>
data_length
)
;
if
(
unlikely
(
shading
-
>
data
=
=
NULL
)
)
return
_cairo_error
(
CAIRO_STATUS_NO_MEMORY
)
;
x_off
=
shading
-
>
decode_array
[
0
]
;
y_off
=
shading
-
>
decode_array
[
2
]
;
x_scale
=
UINT32_MAX
/
(
shading
-
>
decode_array
[
1
]
-
x_off
)
;
y_scale
=
UINT32_MAX
/
(
shading
-
>
decode_array
[
3
]
-
y_off
)
;
p
=
shading
-
>
data
;
for
(
i
=
0
;
i
<
num_patches
;
i
+
+
)
{
*
p
+
+
=
0
;
for
(
j
=
0
;
j
<
16
;
j
+
+
)
{
cairo_point_double_t
point
;
int
pi
pj
;
pi
=
pdf_points_order_i
[
j
]
;
pj
=
pdf_points_order_j
[
j
]
;
point
=
patch
[
i
]
.
points
[
pi
]
[
pj
]
;
point
.
x
-
=
x_off
;
point
.
y
-
=
y_off
;
point
.
x
*
=
x_scale
;
point
.
y
*
=
y_scale
;
point
.
x
=
_cairo_restrict_value
(
point
.
x
0
UINT32_MAX
)
;
point
.
y
=
_cairo_restrict_value
(
point
.
y
0
UINT32_MAX
)
;
p
=
encode_point
(
p
&
point
)
;
}
for
(
j
=
0
;
j
<
4
;
j
+
+
)
{
if
(
is_alpha
)
p
=
encode_alpha
(
p
&
patch
[
i
]
.
colors
[
j
]
)
;
else
p
=
encode_color
(
p
&
patch
[
i
]
.
colors
[
j
]
)
;
}
}
assert
(
p
=
=
shading
-
>
data
+
shading
-
>
data_length
)
;
return
CAIRO_STATUS_SUCCESS
;
}
static
cairo_status_t
_cairo_pdf_shading_init
(
cairo_pdf_shading_t
*
shading
const
cairo_mesh_pattern_t
*
mesh
cairo_bool_t
is_alpha
)
{
cairo_status_t
status
;
assert
(
mesh
-
>
base
.
status
=
=
CAIRO_STATUS_SUCCESS
)
;
assert
(
mesh
-
>
current_patch
=
=
NULL
)
;
shading
-
>
shading_type
=
7
;
shading
-
>
bits_per_coordinate
=
32
;
shading
-
>
bits_per_component
=
16
;
shading
-
>
bits_per_flag
=
8
;
shading
-
>
decode_array
=
NULL
;
shading
-
>
data
=
NULL
;
status
=
_cairo_pdf_shading_generate_decode_array
(
shading
mesh
is_alpha
)
;
if
(
unlikely
(
status
)
)
return
status
;
return
_cairo_pdf_shading_generate_data
(
shading
mesh
is_alpha
)
;
}
cairo_status_t
_cairo_pdf_shading_init_color
(
cairo_pdf_shading_t
*
shading
const
cairo_mesh_pattern_t
*
pattern
)
{
return
_cairo_pdf_shading_init
(
shading
pattern
FALSE
)
;
}
cairo_status_t
_cairo_pdf_shading_init_alpha
(
cairo_pdf_shading_t
*
shading
const
cairo_mesh_pattern_t
*
pattern
)
{
return
_cairo_pdf_shading_init
(
shading
pattern
TRUE
)
;
}
void
_cairo_pdf_shading_fini
(
cairo_pdf_shading_t
*
shading
)
{
free
(
shading
-
>
data
)
;
free
(
shading
-
>
decode_array
)
;
}
#
endif
