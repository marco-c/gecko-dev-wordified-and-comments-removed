extern
crate
app_units
;
extern
crate
euclid
;
extern
crate
gleam
;
extern
crate
glutin
;
extern
crate
webrender
;
extern
crate
webrender_traits
;
extern
crate
rayon
;
#
[
path
=
"
common
/
boilerplate
.
rs
"
]
mod
boilerplate
;
use
boilerplate
:
:
HandyDandyRectBuilder
;
use
rayon
:
:
ThreadPool
;
use
rayon
:
:
Configuration
as
ThreadPoolConfig
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
}
;
use
webrender_traits
as
wt
;
type
ImageRenderingCommands
=
wt
:
:
ColorU
;
fn
serialize_blob
(
color
:
wt
:
:
ColorU
)
-
>
Vec
<
u8
>
{
vec
!
[
color
.
r
color
.
g
color
.
b
color
.
a
]
}
fn
deserialize_blob
(
blob
:
&
[
u8
]
)
-
>
Result
<
ImageRenderingCommands
(
)
>
{
let
mut
iter
=
blob
.
iter
(
)
;
return
match
(
iter
.
next
(
)
iter
.
next
(
)
iter
.
next
(
)
iter
.
next
(
)
)
{
(
Some
(
&
r
)
Some
(
&
g
)
Some
(
&
b
)
Some
(
&
a
)
)
=
>
Ok
(
wt
:
:
ColorU
:
:
new
(
r
g
b
a
)
)
(
Some
(
&
a
)
None
None
None
)
=
>
Ok
(
wt
:
:
ColorU
:
:
new
(
a
a
a
a
)
)
_
=
>
Err
(
(
)
)
}
}
fn
render_blob
(
commands
:
Arc
<
ImageRenderingCommands
>
descriptor
:
&
wt
:
:
BlobImageDescriptor
tile
:
Option
<
wt
:
:
TileOffset
>
)
-
>
wt
:
:
BlobImageResult
{
let
color
=
*
commands
;
let
mut
texels
=
Vec
:
:
with_capacity
(
(
descriptor
.
width
*
descriptor
.
height
*
4
)
as
usize
)
;
let
tile_checker
=
match
tile
{
Some
(
tile
)
=
>
(
tile
.
x
%
2
=
=
0
)
!
=
(
tile
.
y
%
2
=
=
0
)
None
=
>
true
}
;
for
y
in
0
.
.
descriptor
.
height
{
for
x
in
0
.
.
descriptor
.
width
{
let
x2
=
x
+
descriptor
.
offset
.
x
as
u32
;
let
y2
=
y
+
descriptor
.
offset
.
y
as
u32
;
let
checker
=
if
(
x2
%
20
>
=
10
)
!
=
(
y2
%
20
>
=
10
)
{
1
}
else
{
0
}
;
let
tc
=
if
tile_checker
{
0
}
else
{
(
1
-
checker
)
*
40
}
;
match
descriptor
.
format
{
wt
:
:
ImageFormat
:
:
RGBA8
=
>
{
texels
.
push
(
color
.
b
*
checker
+
tc
)
;
texels
.
push
(
color
.
g
*
checker
+
tc
)
;
texels
.
push
(
color
.
r
*
checker
+
tc
)
;
texels
.
push
(
color
.
a
*
checker
+
tc
)
;
}
wt
:
:
ImageFormat
:
:
A8
=
>
{
texels
.
push
(
color
.
a
*
checker
+
tc
)
;
}
_
=
>
{
return
Err
(
wt
:
:
BlobImageError
:
:
Other
(
format
!
(
"
Usupported
image
format
{
:
?
}
"
descriptor
.
format
)
)
)
;
}
}
}
}
Ok
(
wt
:
:
RasterizedBlobImage
{
data
:
texels
width
:
descriptor
.
width
height
:
descriptor
.
height
}
)
}
struct
CheckerboardRenderer
{
workers
:
Arc
<
ThreadPool
>
tx
:
Sender
<
(
wt
:
:
BlobImageRequest
wt
:
:
BlobImageResult
)
>
rx
:
Receiver
<
(
wt
:
:
BlobImageRequest
wt
:
:
BlobImageResult
)
>
image_cmds
:
HashMap
<
wt
:
:
ImageKey
Arc
<
ImageRenderingCommands
>
>
rendered_images
:
HashMap
<
wt
:
:
BlobImageRequest
Option
<
wt
:
:
BlobImageResult
>
>
}
impl
CheckerboardRenderer
{
fn
new
(
workers
:
Arc
<
ThreadPool
>
)
-
>
Self
{
let
(
tx
rx
)
=
channel
(
)
;
CheckerboardRenderer
{
image_cmds
:
HashMap
:
:
new
(
)
rendered_images
:
HashMap
:
:
new
(
)
workers
:
workers
tx
:
tx
rx
:
rx
}
}
}
impl
wt
:
:
BlobImageRenderer
for
CheckerboardRenderer
{
fn
add
(
&
mut
self
key
:
wt
:
:
ImageKey
cmds
:
wt
:
:
BlobImageData
_
:
Option
<
wt
:
:
TileSize
>
)
{
self
.
image_cmds
.
insert
(
key
Arc
:
:
new
(
deserialize_blob
(
&
cmds
[
.
.
]
)
.
unwrap
(
)
)
)
;
}
fn
update
(
&
mut
self
key
:
wt
:
:
ImageKey
cmds
:
wt
:
:
BlobImageData
)
{
self
.
image_cmds
.
insert
(
key
Arc
:
:
new
(
deserialize_blob
(
&
cmds
[
.
.
]
)
.
unwrap
(
)
)
)
;
}
fn
delete
(
&
mut
self
key
:
wt
:
:
ImageKey
)
{
self
.
image_cmds
.
remove
(
&
key
)
;
}
fn
request
(
&
mut
self
resources
:
&
wt
:
:
BlobImageResources
request
:
wt
:
:
BlobImageRequest
descriptor
:
&
wt
:
:
BlobImageDescriptor
_dirty_rect
:
Option
<
wt
:
:
DeviceUintRect
>
)
{
let
cmds
=
Arc
:
:
clone
(
&
self
.
image_cmds
.
get
(
&
request
.
key
)
.
unwrap
(
)
)
;
let
tx
=
self
.
tx
.
clone
(
)
;
let
descriptor
=
descriptor
.
clone
(
)
;
self
.
workers
.
spawn
(
move
|
|
{
let
result
=
render_blob
(
cmds
&
descriptor
request
.
tile
)
;
tx
.
send
(
(
request
result
)
)
.
unwrap
(
)
;
}
)
;
self
.
rendered_images
.
insert
(
request
None
)
;
}
fn
resolve
(
&
mut
self
request
:
wt
:
:
BlobImageRequest
)
-
>
wt
:
:
BlobImageResult
{
match
self
.
rendered_images
.
entry
(
request
)
{
Entry
:
:
Vacant
(
_
)
=
>
{
return
Err
(
wt
:
:
BlobImageError
:
:
InvalidKey
)
;
}
Entry
:
:
Occupied
(
entry
)
=
>
{
if
entry
.
get
(
)
.
is_some
(
)
{
let
result
=
entry
.
remove
(
)
;
return
result
.
unwrap
(
)
;
}
}
}
while
let
Ok
(
(
req
result
)
)
=
self
.
rx
.
recv
(
)
{
if
req
=
=
request
{
return
result
}
self
.
rendered_images
.
insert
(
req
Some
(
result
)
)
;
}
Err
(
wt
:
:
BlobImageError
:
:
Other
(
"
Channel
closed
"
.
into
(
)
)
)
}
fn
delete_font
(
&
mut
self
font
:
wt
:
:
FontKey
)
{
}
}
fn
body
(
api
:
&
wt
:
:
RenderApi
builder
:
&
mut
wt
:
:
DisplayListBuilder
_pipeline_id
:
&
wt
:
:
PipelineId
layout_size
:
&
wt
:
:
LayoutSize
)
{
let
blob_img1
=
api
.
generate_image_key
(
)
;
api
.
add_image
(
blob_img1
wt
:
:
ImageDescriptor
:
:
new
(
500
500
wt
:
:
ImageFormat
:
:
RGBA8
true
)
wt
:
:
ImageData
:
:
new_blob_image
(
serialize_blob
(
wt
:
:
ColorU
:
:
new
(
50
50
150
255
)
)
)
Some
(
128
)
)
;
let
blob_img2
=
api
.
generate_image_key
(
)
;
api
.
add_image
(
blob_img2
wt
:
:
ImageDescriptor
:
:
new
(
200
200
wt
:
:
ImageFormat
:
:
RGBA8
true
)
wt
:
:
ImageData
:
:
new_blob_image
(
serialize_blob
(
wt
:
:
ColorU
:
:
new
(
50
150
50
255
)
)
)
None
)
;
let
bounds
=
wt
:
:
LayoutRect
:
:
new
(
wt
:
:
LayoutPoint
:
:
zero
(
)
*
layout_size
)
;
builder
.
push_stacking_context
(
wt
:
:
ScrollPolicy
:
:
Scrollable
bounds
None
wt
:
:
TransformStyle
:
:
Flat
None
wt
:
:
MixBlendMode
:
:
Normal
Vec
:
:
new
(
)
)
;
let
clip
=
builder
.
push_clip_region
(
&
bounds
vec
!
[
]
None
)
;
builder
.
push_image
(
(
30
30
)
.
by
(
500
500
)
clip
wt
:
:
LayoutSize
:
:
new
(
500
.
0
500
.
0
)
wt
:
:
LayoutSize
:
:
new
(
0
.
0
0
.
0
)
wt
:
:
ImageRendering
:
:
Auto
blob_img1
)
;
let
clip
=
builder
.
push_clip_region
(
&
bounds
vec
!
[
]
None
)
;
builder
.
push_image
(
(
600
600
)
.
by
(
200
200
)
clip
wt
:
:
LayoutSize
:
:
new
(
200
.
0
200
.
0
)
wt
:
:
LayoutSize
:
:
new
(
0
.
0
0
.
0
)
wt
:
:
ImageRendering
:
:
Auto
blob_img2
)
;
builder
.
pop_stacking_context
(
)
;
}
fn
event_handler
(
_event
:
&
glutin
:
:
Event
_api
:
&
wt
:
:
RenderApi
)
{
}
fn
main
(
)
{
let
worker_config
=
ThreadPoolConfig
:
:
new
(
)
.
thread_name
(
|
idx
|
{
format
!
(
"
WebRender
:
Worker
#
{
}
"
idx
)
}
)
;
let
workers
=
Arc
:
:
new
(
ThreadPool
:
:
new
(
worker_config
)
.
unwrap
(
)
)
;
let
opts
=
webrender
:
:
RendererOptions
{
workers
:
Some
(
Arc
:
:
clone
(
&
workers
)
)
blob_image_renderer
:
Some
(
Box
:
:
new
(
CheckerboardRenderer
:
:
new
(
Arc
:
:
clone
(
&
workers
)
)
)
)
.
.
Default
:
:
default
(
)
}
;
boilerplate
:
:
main_wrapper
(
body
event_handler
Some
(
opts
)
)
;
}
