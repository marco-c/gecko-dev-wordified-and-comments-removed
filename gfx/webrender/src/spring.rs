use
euclid
:
:
Point2D
;
pub
const
EPSILON
:
f32
=
0
.
1
;
pub
const
STIFFNESS
:
f32
=
0
.
2
;
pub
const
DAMPING
:
f32
=
1
.
0
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
Spring
{
cur
:
Point2D
<
f32
>
prev
:
Point2D
<
f32
>
dest
:
Point2D
<
f32
>
stiffness
:
f32
damping
:
f32
}
impl
Spring
{
pub
fn
at
(
pos
:
Point2D
<
f32
>
stiffness
:
f32
damping
:
f32
)
-
>
Spring
{
Spring
{
cur
:
pos
prev
:
pos
dest
:
pos
stiffness
:
stiffness
damping
:
damping
}
}
pub
fn
coords
(
&
mut
self
cur
:
Point2D
<
f32
>
prev
:
Point2D
<
f32
>
dest
:
Point2D
<
f32
>
)
{
self
.
cur
=
cur
;
self
.
prev
=
prev
;
self
.
dest
=
dest
}
pub
fn
current
(
&
self
)
-
>
Point2D
<
f32
>
{
self
.
cur
}
pub
fn
animate
(
&
mut
self
)
-
>
bool
{
if
!
is_resting
(
self
.
cur
.
x
self
.
prev
.
x
self
.
dest
.
x
)
|
|
!
is_resting
(
self
.
cur
.
y
self
.
prev
.
y
self
.
dest
.
y
)
{
let
next
=
Point2D
:
:
new
(
next
(
self
.
cur
.
x
self
.
prev
.
x
self
.
dest
.
x
self
.
stiffness
self
.
damping
)
next
(
self
.
cur
.
y
self
.
prev
.
y
self
.
dest
.
y
self
.
stiffness
self
.
damping
)
)
;
let
(
cur
dest
)
=
(
self
.
cur
self
.
dest
)
;
self
.
coords
(
next
cur
dest
)
;
false
}
else
{
let
dest
=
self
.
dest
;
self
.
coords
(
dest
dest
dest
)
;
true
}
}
}
fn
next
(
cur
:
f32
prev
:
f32
dest
:
f32
stiffness
:
f32
damping
:
f32
)
-
>
f32
{
let
fspring
=
-
stiffness
*
(
cur
-
dest
)
;
let
vel
=
cur
-
prev
;
let
fdamping
=
-
damping
*
vel
;
let
acc
=
fspring
+
fdamping
;
let
nextv
=
vel
+
acc
;
let
next
=
cur
+
nextv
;
next
}
fn
is_resting
(
cur
:
f32
prev
:
f32
dest
:
f32
)
-
>
bool
{
(
cur
-
prev
)
.
abs
(
)
<
EPSILON
&
&
(
cur
-
dest
)
.
abs
(
)
<
EPSILON
}
