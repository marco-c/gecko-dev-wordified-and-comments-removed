use
api
:
:
{
AlphaType
BorderDetails
BorderDisplayItem
BuiltDisplayListIter
ClipAndScrollInfo
}
;
use
api
:
:
{
ClipId
ColorF
ComplexClipRegion
DeviceIntPoint
DeviceIntRect
DeviceIntSize
}
;
use
api
:
:
{
DevicePixelScale
DeviceUintRect
DisplayItemRef
Epoch
ExtendMode
ExternalScrollId
}
;
use
api
:
:
{
FilterOp
FontInstanceKey
FontRenderMode
GlyphInstance
GlyphOptions
GradientStop
}
;
use
api
:
:
{
IframeDisplayItem
ImageKey
ImageRendering
ItemRange
LayerPoint
LayerPrimitiveInfo
}
;
use
api
:
:
{
LayerRect
LayerSize
LayerVector2D
LayoutRect
LayoutSize
LayoutTransform
}
;
use
api
:
:
{
LayoutVector2D
LineOrientation
LineStyle
LocalClip
PipelineId
PropertyBinding
}
;
use
api
:
:
{
RepeatMode
ScrollFrameDisplayItem
ScrollPolicy
ScrollSensitivity
Shadow
}
;
use
api
:
:
{
SpecificDisplayItem
StackingContext
StickyFrameDisplayItem
TexelRect
TileOffset
}
;
use
api
:
:
{
TransformStyle
YuvColorSpace
YuvData
}
;
use
app_units
:
:
Au
;
use
border
:
:
ImageBorderSegment
;
use
clip
:
:
{
ClipRegion
ClipSource
ClipSources
ClipStore
}
;
use
clip_scroll_node
:
:
{
ClipScrollNode
NodeType
StickyFrameInfo
}
;
use
clip_scroll_tree
:
:
{
ClipChainIndex
ClipScrollNodeIndex
ClipScrollTree
}
;
use
euclid
:
:
{
SideOffsets2D
vec2
}
;
use
frame_builder
:
:
{
FrameBuilder
FrameBuilderConfig
}
;
use
glyph_rasterizer
:
:
FontInstance
;
use
hit_test
:
:
{
HitTestingItem
HitTestingRun
}
;
use
image
:
:
{
decompose_image
TiledImageInfo
}
;
use
internal_types
:
:
{
FastHashMap
FastHashSet
}
;
use
picture
:
:
{
PictureCompositeMode
PictureKind
}
;
use
prim_store
:
:
{
BrushKind
BrushPrimitive
BrushSegmentDescriptor
CachedGradient
}
;
use
prim_store
:
:
{
CachedGradientIndex
ImageCacheKey
ImagePrimitiveCpu
ImageSource
}
;
use
prim_store
:
:
{
PictureIndex
PrimitiveContainer
PrimitiveIndex
PrimitiveKind
PrimitiveStore
}
;
use
prim_store
:
:
{
ScrollNodeAndClipChain
TextRunPrimitiveCpu
}
;
use
render_backend
:
:
{
DocumentView
}
;
use
resource_cache
:
:
{
FontInstanceMap
ImageRequest
TiledImageMap
}
;
use
scene
:
:
{
Scene
ScenePipeline
StackingContextHelpers
}
;
use
scene_builder
:
:
{
BuiltScene
SceneRequest
}
;
use
std
:
:
{
f32
mem
usize
}
;
use
tiling
:
:
{
CompositeOps
ScrollbarPrimitive
}
;
use
util
:
:
{
MaxRect
RectHelpers
recycle_vec
}
;
static
DEFAULT_SCROLLBAR_COLOR
:
ColorF
=
ColorF
{
r
:
0
.
3
g
:
0
.
3
b
:
0
.
3
a
:
0
.
6
}
;
#
[
derive
(
Default
)
]
pub
struct
ClipIdToIndexMapper
{
clip_chain_map
:
FastHashMap
<
ClipId
ClipChainIndex
>
cached_clip_chain_index
:
Option
<
(
ClipId
ClipChainIndex
)
>
pipeline_offsets
:
FastHashMap
<
PipelineId
usize
>
cached_pipeline_offset
:
Option
<
(
PipelineId
usize
)
>
next_available_offset
:
usize
}
impl
ClipIdToIndexMapper
{
pub
fn
add_clip_chain
(
&
mut
self
id
:
ClipId
index
:
ClipChainIndex
)
{
debug_assert
!
(
!
self
.
clip_chain_map
.
contains_key
(
&
id
)
)
;
self
.
clip_chain_map
.
insert
(
id
index
)
;
}
pub
fn
map_to_parent_clip_chain
(
&
mut
self
id
:
ClipId
parent_id
:
&
ClipId
)
{
let
parent_chain_index
=
self
.
get_clip_chain_index
(
parent_id
)
;
self
.
add_clip_chain
(
id
parent_chain_index
)
;
}
pub
fn
get_clip_chain_index
(
&
mut
self
id
:
&
ClipId
)
-
>
ClipChainIndex
{
match
self
.
cached_clip_chain_index
{
Some
(
(
cached_id
cached_clip_chain_index
)
)
if
cached_id
=
=
*
id
=
>
return
cached_clip_chain_index
_
=
>
{
}
}
self
.
clip_chain_map
[
id
]
}
pub
fn
get_clip_chain_index_and_cache_result
(
&
mut
self
id
:
&
ClipId
)
-
>
ClipChainIndex
{
let
index
=
self
.
get_clip_chain_index
(
id
)
;
self
.
cached_clip_chain_index
=
Some
(
(
*
id
index
)
)
;
index
}
pub
fn
map_clip_and_scroll
(
&
mut
self
info
:
&
ClipAndScrollInfo
)
-
>
ScrollNodeAndClipChain
{
ScrollNodeAndClipChain
:
:
new
(
self
.
get_node_index
(
info
.
scroll_node_id
)
self
.
get_clip_chain_index_and_cache_result
(
&
info
.
clip_node_id
(
)
)
)
}
pub
fn
simple_scroll_and_clip_chain
(
&
mut
self
id
:
&
ClipId
)
-
>
ScrollNodeAndClipChain
{
self
.
map_clip_and_scroll
(
&
ClipAndScrollInfo
:
:
simple
(
*
id
)
)
}
pub
fn
initialize_for_pipeline
(
&
mut
self
pipeline
:
&
ScenePipeline
)
{
debug_assert
!
(
!
self
.
pipeline_offsets
.
contains_key
(
&
pipeline
.
pipeline_id
)
)
;
self
.
pipeline_offsets
.
insert
(
pipeline
.
pipeline_id
self
.
next_available_offset
)
;
self
.
next_available_offset
+
=
pipeline
.
display_list
.
total_clip_ids
(
)
;
}
pub
fn
get_node_index
(
&
mut
self
id
:
ClipId
)
-
>
ClipScrollNodeIndex
{
let
(
index
pipeline_id
)
=
match
id
{
ClipId
:
:
Clip
(
index
pipeline_id
)
=
>
(
index
pipeline_id
)
ClipId
:
:
ClipChain
(
_
)
=
>
panic
!
(
"
Tried
to
use
ClipChain
as
scroll
node
.
"
)
}
;
let
pipeline_offset
=
match
self
.
cached_pipeline_offset
{
Some
(
(
last_used_id
offset
)
)
if
last_used_id
=
=
pipeline_id
=
>
offset
_
=
>
{
let
offset
=
self
.
pipeline_offsets
[
&
pipeline_id
]
;
self
.
cached_pipeline_offset
=
Some
(
(
pipeline_id
offset
)
)
;
offset
}
}
;
ClipScrollNodeIndex
(
pipeline_offset
+
index
)
}
}
pub
struct
DisplayListFlattener
<
'
a
>
{
scene
:
&
'
a
Scene
clip_scroll_tree
:
&
'
a
mut
ClipScrollTree
font_instances
:
FontInstanceMap
tiled_image_map
:
TiledImageMap
pipeline_epochs
:
Vec
<
(
PipelineId
Epoch
)
>
output_pipelines
:
&
'
a
FastHashSet
<
PipelineId
>
replacements
:
Vec
<
(
ClipId
ClipId
)
>
id_to_index_mapper
:
ClipIdToIndexMapper
shadow_prim_stack
:
Vec
<
(
PrimitiveIndex
Vec
<
(
PrimitiveIndex
ScrollNodeAndClipChain
)
>
)
>
pending_shadow_contents
:
Vec
<
(
PrimitiveIndex
ScrollNodeAndClipChain
LayerPrimitiveInfo
)
>
reference_frame_stack
:
Vec
<
(
ClipId
ClipScrollNodeIndex
)
>
sc_stack
:
Vec
<
FlattenedStackingContext
>
picture_stack
:
Vec
<
PictureIndex
>
pub
scrollbar_prims
:
Vec
<
ScrollbarPrimitive
>
pub
prim_store
:
PrimitiveStore
pub
hit_testing_runs
:
Vec
<
HitTestingRun
>
pub
clip_store
:
ClipStore
pub
config
:
FrameBuilderConfig
pub
cached_gradients
:
Vec
<
CachedGradient
>
}
impl
<
'
a
>
DisplayListFlattener
<
'
a
>
{
pub
fn
create_frame_builder
(
old_builder
:
FrameBuilder
scene
:
&
Scene
clip_scroll_tree
:
&
mut
ClipScrollTree
font_instances
:
FontInstanceMap
tiled_image_map
:
TiledImageMap
view
:
&
DocumentView
output_pipelines
:
&
FastHashSet
<
PipelineId
>
frame_builder_config
:
&
FrameBuilderConfig
new_scene
:
&
mut
Scene
)
-
>
FrameBuilder
{
let
root_pipeline_id
=
scene
.
root_pipeline_id
.
unwrap
(
)
;
let
root_pipeline
=
scene
.
pipelines
.
get
(
&
root_pipeline_id
)
.
unwrap
(
)
;
let
root_epoch
=
scene
.
pipeline_epochs
[
&
root_pipeline_id
]
;
let
background_color
=
root_pipeline
.
background_color
.
and_then
(
|
color
|
if
color
.
a
>
0
.
0
{
Some
(
color
)
}
else
{
None
}
)
;
let
mut
flattener
=
DisplayListFlattener
{
scene
clip_scroll_tree
font_instances
tiled_image_map
config
:
*
frame_builder_config
pipeline_epochs
:
Vec
:
:
new
(
)
replacements
:
Vec
:
:
new
(
)
output_pipelines
id_to_index_mapper
:
ClipIdToIndexMapper
:
:
default
(
)
hit_testing_runs
:
recycle_vec
(
old_builder
.
hit_testing_runs
)
shadow_prim_stack
:
Vec
:
:
new
(
)
cached_gradients
:
recycle_vec
(
old_builder
.
cached_gradients
)
pending_shadow_contents
:
Vec
:
:
new
(
)
scrollbar_prims
:
recycle_vec
(
old_builder
.
scrollbar_prims
)
reference_frame_stack
:
Vec
:
:
new
(
)
picture_stack
:
Vec
:
:
new
(
)
sc_stack
:
Vec
:
:
new
(
)
prim_store
:
old_builder
.
prim_store
.
recycle
(
)
clip_store
:
old_builder
.
clip_store
.
recycle
(
)
}
;
flattener
.
id_to_index_mapper
.
initialize_for_pipeline
(
root_pipeline
)
;
flattener
.
push_root
(
root_pipeline_id
&
root_pipeline
.
viewport_size
&
root_pipeline
.
content_size
)
;
flattener
.
setup_viewport_offset
(
view
.
inner_rect
view
.
accumulated_scale_factor
(
)
)
;
flattener
.
flatten_root
(
root_pipeline
&
root_pipeline
.
viewport_size
)
;
debug_assert
!
(
flattener
.
picture_stack
.
is_empty
(
)
)
;
new_scene
.
root_pipeline_id
=
Some
(
root_pipeline_id
)
;
new_scene
.
pipeline_epochs
.
insert
(
root_pipeline_id
root_epoch
)
;
new_scene
.
pipeline_epochs
.
extend
(
flattener
.
pipeline_epochs
.
drain
(
.
.
)
)
;
new_scene
.
pipelines
=
scene
.
pipelines
.
clone
(
)
;
FrameBuilder
:
:
with_display_list_flattener
(
view
.
inner_rect
background_color
view
.
window_size
flattener
)
}
fn
apply_scroll_frame_id_replacement
(
&
self
index
:
ClipId
)
-
>
ClipId
{
match
self
.
replacements
.
last
(
)
{
Some
(
&
(
to_replace
replacement
)
)
if
to_replace
=
=
index
=
>
replacement
_
=
>
index
}
}
fn
get_complex_clips
(
&
self
pipeline_id
:
PipelineId
complex_clips
:
ItemRange
<
ComplexClipRegion
>
)
-
>
Vec
<
ComplexClipRegion
>
{
if
complex_clips
.
is_empty
(
)
{
return
vec
!
[
]
;
}
self
.
scene
.
pipelines
.
get
(
&
pipeline_id
)
.
expect
(
"
No
display
list
?
"
)
.
display_list
.
get
(
complex_clips
)
.
collect
(
)
}
fn
get_clip_chain_items
(
&
self
pipeline_id
:
PipelineId
items
:
ItemRange
<
ClipId
>
)
-
>
Vec
<
ClipId
>
{
if
items
.
is_empty
(
)
{
return
vec
!
[
]
;
}
self
.
scene
.
pipelines
.
get
(
&
pipeline_id
)
.
expect
(
"
No
display
list
?
"
)
.
display_list
.
get
(
items
)
.
collect
(
)
}
fn
flatten_root
(
&
mut
self
pipeline
:
&
'
a
ScenePipeline
frame_size
:
&
LayoutSize
)
{
let
pipeline_id
=
pipeline
.
pipeline_id
;
let
reference_frame_info
=
self
.
id_to_index_mapper
.
simple_scroll_and_clip_chain
(
&
ClipId
:
:
root_reference_frame
(
pipeline_id
)
)
;
let
scroll_frame_info
=
self
.
id_to_index_mapper
.
simple_scroll_and_clip_chain
(
&
ClipId
:
:
root_scroll_node
(
pipeline_id
)
)
;
self
.
push_stacking_context
(
pipeline_id
CompositeOps
:
:
default
(
)
TransformStyle
:
:
Flat
true
true
scroll_frame_info
)
;
if
self
.
scene
.
root_pipeline_id
!
=
Some
(
pipeline_id
)
{
if
let
Some
(
pipeline
)
=
self
.
scene
.
pipelines
.
get
(
&
pipeline_id
)
{
if
let
Some
(
bg_color
)
=
pipeline
.
background_color
{
let
root_bounds
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
*
frame_size
)
;
let
info
=
LayerPrimitiveInfo
:
:
new
(
root_bounds
)
;
self
.
add_solid_rectangle
(
reference_frame_info
&
info
bg_color
None
)
;
}
}
}
self
.
flatten_items
(
&
mut
pipeline
.
display_list
.
iter
(
)
pipeline_id
LayerVector2D
:
:
zero
(
)
)
;
if
self
.
config
.
enable_scrollbars
{
let
scrollbar_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
LayerSize
:
:
new
(
10
.
0
70
.
0
)
)
;
let
container_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
*
frame_size
)
;
self
.
add_scroll_bar
(
reference_frame_info
&
LayerPrimitiveInfo
:
:
new
(
scrollbar_rect
)
DEFAULT_SCROLLBAR_COLOR
ScrollbarInfo
(
scroll_frame_info
.
scroll_node_id
container_rect
)
)
;
}
self
.
pop_stacking_context
(
)
;
}
fn
flatten_items
(
&
mut
self
traversal
:
&
mut
BuiltDisplayListIter
<
'
a
>
pipeline_id
:
PipelineId
reference_frame_relative_offset
:
LayerVector2D
)
{
loop
{
let
subtraversal
=
{
let
item
=
match
traversal
.
next
(
)
{
Some
(
item
)
=
>
item
None
=
>
break
}
;
if
SpecificDisplayItem
:
:
PopStackingContext
=
=
*
item
.
item
(
)
{
return
;
}
self
.
flatten_item
(
item
pipeline_id
reference_frame_relative_offset
)
}
;
if
let
Some
(
subtraversal
)
=
subtraversal
{
*
traversal
=
subtraversal
;
}
}
}
fn
flatten_sticky_frame
(
&
mut
self
item
:
&
DisplayItemRef
info
:
&
StickyFrameDisplayItem
clip_and_scroll
:
&
ScrollNodeAndClipChain
parent_id
:
&
ClipId
reference_frame_relative_offset
:
&
LayerVector2D
)
{
let
frame_rect
=
item
.
rect
(
)
.
translate
(
&
reference_frame_relative_offset
)
;
let
sticky_frame_info
=
StickyFrameInfo
:
:
new
(
info
.
margins
info
.
vertical_offset_bounds
info
.
horizontal_offset_bounds
info
.
previously_applied_offset
)
;
let
index
=
self
.
id_to_index_mapper
.
get_node_index
(
info
.
id
)
;
self
.
clip_scroll_tree
.
add_sticky_frame
(
index
clip_and_scroll
.
scroll_node_id
frame_rect
sticky_frame_info
info
.
id
.
pipeline_id
(
)
)
;
self
.
id_to_index_mapper
.
map_to_parent_clip_chain
(
info
.
id
&
parent_id
)
;
}
fn
flatten_scroll_frame
(
&
mut
self
item
:
&
DisplayItemRef
info
:
&
ScrollFrameDisplayItem
pipeline_id
:
PipelineId
clip_and_scroll_ids
:
&
ClipAndScrollInfo
reference_frame_relative_offset
:
&
LayerVector2D
)
{
let
complex_clips
=
self
.
get_complex_clips
(
pipeline_id
item
.
complex_clip
(
)
.
0
)
;
let
clip_region
=
ClipRegion
:
:
create_for_clip_node
(
*
item
.
clip_rect
(
)
complex_clips
info
.
image_mask
&
reference_frame_relative_offset
)
;
let
frame_rect
=
item
.
clip_rect
(
)
.
translate
(
&
reference_frame_relative_offset
)
;
let
content_rect
=
item
.
rect
(
)
.
translate
(
&
reference_frame_relative_offset
)
;
debug_assert
!
(
info
.
clip_id
!
=
info
.
scroll_frame_id
)
;
self
.
add_clip_node
(
info
.
clip_id
clip_and_scroll_ids
.
scroll_node_id
clip_region
)
;
self
.
add_scroll_frame
(
info
.
scroll_frame_id
info
.
clip_id
info
.
external_id
pipeline_id
&
frame_rect
&
content_rect
.
size
info
.
scroll_sensitivity
)
;
}
fn
flatten_stacking_context
(
&
mut
self
traversal
:
&
mut
BuiltDisplayListIter
<
'
a
>
pipeline_id
:
PipelineId
unreplaced_scroll_id
:
ClipId
mut
scroll_node_id
:
ClipId
mut
reference_frame_relative_offset
:
LayerVector2D
bounds
:
&
LayerRect
stacking_context
:
&
StackingContext
filters
:
ItemRange
<
FilterOp
>
is_backface_visible
:
bool
)
{
if
traversal
.
current_stacking_context_empty
(
)
{
traversal
.
skip_current_stacking_context
(
)
;
return
;
}
let
composition_operations
=
{
let
display_list
=
&
self
.
scene
.
pipelines
.
get
(
&
pipeline_id
)
.
expect
(
"
No
display
list
?
!
"
)
.
display_list
;
CompositeOps
:
:
new
(
stacking_context
.
filter_ops_for_compositing
(
display_list
filters
)
stacking_context
.
mix_blend_mode_for_compositing
(
)
)
}
;
if
stacking_context
.
scroll_policy
=
=
ScrollPolicy
:
:
Fixed
{
scroll_node_id
=
self
.
current_reference_frame_id
(
)
;
self
.
replacements
.
push
(
(
unreplaced_scroll_id
scroll_node_id
)
)
;
}
reference_frame_relative_offset
+
=
bounds
.
origin
.
to_vector
(
)
;
if
let
Some
(
reference_frame_id
)
=
stacking_context
.
reference_frame_id
{
debug_assert
!
(
stacking_context
.
transform
.
is_some
(
)
|
|
stacking_context
.
perspective
.
is_some
(
)
)
;
let
reference_frame_bounds
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
bounds
.
size
)
;
self
.
push_reference_frame
(
reference_frame_id
Some
(
scroll_node_id
)
pipeline_id
&
reference_frame_bounds
stacking_context
.
transform
stacking_context
.
perspective
reference_frame_relative_offset
)
;
self
.
replacements
.
push
(
(
unreplaced_scroll_id
reference_frame_id
)
)
;
reference_frame_relative_offset
=
LayerVector2D
:
:
zero
(
)
;
}
let
sc_scroll_node
=
self
.
apply_scroll_frame_id_replacement
(
unreplaced_scroll_id
)
;
let
stacking_context_clip_and_scroll
=
self
.
id_to_index_mapper
.
simple_scroll_and_clip_chain
(
&
sc_scroll_node
)
;
self
.
push_stacking_context
(
pipeline_id
composition_operations
stacking_context
.
transform_style
is_backface_visible
false
stacking_context_clip_and_scroll
)
;
self
.
flatten_items
(
traversal
pipeline_id
reference_frame_relative_offset
)
;
if
stacking_context
.
scroll_policy
=
=
ScrollPolicy
:
:
Fixed
{
self
.
replacements
.
pop
(
)
;
}
if
stacking_context
.
reference_frame_id
.
is_some
(
)
{
self
.
replacements
.
pop
(
)
;
self
.
pop_reference_frame
(
)
;
}
self
.
pop_stacking_context
(
)
;
}
fn
flatten_iframe
(
&
mut
self
item
:
&
DisplayItemRef
info
:
&
IframeDisplayItem
clip_and_scroll_ids
:
&
ClipAndScrollInfo
reference_frame_relative_offset
:
&
LayerVector2D
)
{
let
iframe_pipeline_id
=
info
.
pipeline_id
;
let
pipeline
=
match
self
.
scene
.
pipelines
.
get
(
&
iframe_pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
return
}
;
self
.
id_to_index_mapper
.
initialize_for_pipeline
(
pipeline
)
;
self
.
add_clip_node
(
info
.
clip_id
clip_and_scroll_ids
.
scroll_node_id
ClipRegion
:
:
create_for_clip_node_with_local_clip
(
&
LocalClip
:
:
from
(
*
item
.
clip_rect
(
)
)
&
reference_frame_relative_offset
)
)
;
let
epoch
=
self
.
scene
.
pipeline_epochs
[
&
iframe_pipeline_id
]
;
self
.
pipeline_epochs
.
push
(
(
iframe_pipeline_id
epoch
)
)
;
let
bounds
=
item
.
rect
(
)
;
let
iframe_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
bounds
.
size
)
;
let
origin
=
*
reference_frame_relative_offset
+
bounds
.
origin
.
to_vector
(
)
;
self
.
push_reference_frame
(
ClipId
:
:
root_reference_frame
(
iframe_pipeline_id
)
Some
(
info
.
clip_id
)
iframe_pipeline_id
&
iframe_rect
None
None
origin
)
;
self
.
add_scroll_frame
(
ClipId
:
:
root_scroll_node
(
iframe_pipeline_id
)
ClipId
:
:
root_reference_frame
(
iframe_pipeline_id
)
Some
(
ExternalScrollId
(
0
iframe_pipeline_id
)
)
iframe_pipeline_id
&
iframe_rect
&
pipeline
.
content_size
ScrollSensitivity
:
:
ScriptAndInputEvents
)
;
self
.
flatten_root
(
pipeline
&
iframe_rect
.
size
)
;
self
.
pop_reference_frame
(
)
;
}
fn
flatten_item
<
'
b
>
(
&
'
b
mut
self
item
:
DisplayItemRef
<
'
a
'
b
>
pipeline_id
:
PipelineId
reference_frame_relative_offset
:
LayerVector2D
)
-
>
Option
<
BuiltDisplayListIter
<
'
a
>
>
{
let
mut
clip_and_scroll_ids
=
item
.
clip_and_scroll
(
)
;
let
unreplaced_scroll_id
=
clip_and_scroll_ids
.
scroll_node_id
;
clip_and_scroll_ids
.
scroll_node_id
=
self
.
apply_scroll_frame_id_replacement
(
clip_and_scroll_ids
.
scroll_node_id
)
;
let
clip_and_scroll
=
self
.
id_to_index_mapper
.
map_clip_and_scroll
(
&
clip_and_scroll_ids
)
;
let
prim_info
=
item
.
get_layer_primitive_info
(
&
reference_frame_relative_offset
)
;
match
*
item
.
item
(
)
{
SpecificDisplayItem
:
:
Image
(
ref
info
)
=
>
{
match
self
.
tiled_image_map
.
get
(
&
info
.
image_key
)
.
cloned
(
)
{
Some
(
tiling
)
=
>
{
decompose_image
(
&
TiledImageInfo
{
rect
:
prim_info
.
rect
tile_spacing
:
info
.
tile_spacing
stretch_size
:
info
.
stretch_size
device_image_size
:
tiling
.
image_size
device_tile_size
:
tiling
.
tile_size
as
u32
}
&
mut
|
tile
|
{
let
mut
prim_info
=
prim_info
.
clone
(
)
;
prim_info
.
rect
=
tile
.
rect
;
self
.
add_image
(
clip_and_scroll
&
prim_info
tile
.
stretch_size
info
.
tile_spacing
None
info
.
image_key
info
.
image_rendering
info
.
alpha_type
Some
(
tile
.
tile_offset
)
)
;
}
)
;
}
None
=
>
{
self
.
add_image
(
clip_and_scroll
&
prim_info
info
.
stretch_size
info
.
tile_spacing
None
info
.
image_key
info
.
image_rendering
info
.
alpha_type
None
)
;
}
}
}
SpecificDisplayItem
:
:
YuvImage
(
ref
info
)
=
>
{
self
.
add_yuv_image
(
clip_and_scroll
&
prim_info
info
.
yuv_data
info
.
color_space
info
.
image_rendering
)
;
}
SpecificDisplayItem
:
:
Text
(
ref
text_info
)
=
>
{
self
.
add_text
(
clip_and_scroll
reference_frame_relative_offset
&
prim_info
&
text_info
.
font_key
&
text_info
.
color
item
.
glyphs
(
)
item
.
display_list
(
)
.
get
(
item
.
glyphs
(
)
)
.
count
(
)
text_info
.
glyph_options
)
;
}
SpecificDisplayItem
:
:
Rectangle
(
ref
info
)
=
>
{
self
.
add_solid_rectangle
(
clip_and_scroll
&
prim_info
info
.
color
None
)
;
}
SpecificDisplayItem
:
:
ClearRectangle
=
>
{
self
.
add_clear_rectangle
(
clip_and_scroll
&
prim_info
)
;
}
SpecificDisplayItem
:
:
Line
(
ref
info
)
=
>
{
self
.
add_line
(
clip_and_scroll
&
prim_info
info
.
wavy_line_thickness
info
.
orientation
&
info
.
color
info
.
style
)
;
}
SpecificDisplayItem
:
:
Gradient
(
ref
info
)
=
>
{
self
.
add_gradient
(
clip_and_scroll
&
prim_info
info
.
gradient
.
start_point
info
.
gradient
.
end_point
item
.
gradient_stops
(
)
item
.
display_list
(
)
.
get
(
item
.
gradient_stops
(
)
)
.
count
(
)
info
.
gradient
.
extend_mode
info
.
tile_size
info
.
tile_spacing
)
;
}
SpecificDisplayItem
:
:
RadialGradient
(
ref
info
)
=
>
{
self
.
add_radial_gradient
(
clip_and_scroll
&
prim_info
info
.
gradient
.
center
info
.
gradient
.
start_radius
info
.
gradient
.
end_radius
info
.
gradient
.
radius
.
width
/
info
.
gradient
.
radius
.
height
item
.
gradient_stops
(
)
info
.
gradient
.
extend_mode
info
.
tile_size
info
.
tile_spacing
)
;
}
SpecificDisplayItem
:
:
BoxShadow
(
ref
box_shadow_info
)
=
>
{
let
bounds
=
box_shadow_info
.
box_bounds
.
translate
(
&
reference_frame_relative_offset
)
;
let
mut
prim_info
=
prim_info
.
clone
(
)
;
prim_info
.
rect
=
bounds
;
self
.
add_box_shadow
(
clip_and_scroll
&
prim_info
&
box_shadow_info
.
offset
&
box_shadow_info
.
color
box_shadow_info
.
blur_radius
box_shadow_info
.
spread_radius
box_shadow_info
.
border_radius
box_shadow_info
.
clip_mode
)
;
}
SpecificDisplayItem
:
:
Border
(
ref
info
)
=
>
{
self
.
add_border
(
clip_and_scroll
&
prim_info
info
item
.
gradient_stops
(
)
item
.
display_list
(
)
.
get
(
item
.
gradient_stops
(
)
)
.
count
(
)
)
;
}
SpecificDisplayItem
:
:
PushStackingContext
(
ref
info
)
=
>
{
let
mut
subtraversal
=
item
.
sub_iter
(
)
;
self
.
flatten_stacking_context
(
&
mut
subtraversal
pipeline_id
unreplaced_scroll_id
clip_and_scroll_ids
.
scroll_node_id
reference_frame_relative_offset
&
item
.
rect
(
)
&
info
.
stacking_context
item
.
filters
(
)
prim_info
.
is_backface_visible
)
;
return
Some
(
subtraversal
)
;
}
SpecificDisplayItem
:
:
Iframe
(
ref
info
)
=
>
{
self
.
flatten_iframe
(
&
item
info
&
clip_and_scroll_ids
&
reference_frame_relative_offset
)
;
}
SpecificDisplayItem
:
:
Clip
(
ref
info
)
=
>
{
let
complex_clips
=
self
.
get_complex_clips
(
pipeline_id
item
.
complex_clip
(
)
.
0
)
;
let
clip_region
=
ClipRegion
:
:
create_for_clip_node
(
*
item
.
clip_rect
(
)
complex_clips
info
.
image_mask
&
reference_frame_relative_offset
)
;
self
.
add_clip_node
(
info
.
id
clip_and_scroll_ids
.
scroll_node_id
clip_region
)
;
}
SpecificDisplayItem
:
:
ClipChain
(
ref
info
)
=
>
{
let
items
=
self
.
get_clip_chain_items
(
pipeline_id
item
.
clip_chain_items
(
)
)
.
iter
(
)
.
map
(
|
id
|
self
.
id_to_index_mapper
.
get_node_index
(
*
id
)
)
.
collect
(
)
;
let
parent
=
info
.
parent
.
map
(
|
id
|
self
.
id_to_index_mapper
.
get_clip_chain_index
(
&
ClipId
:
:
ClipChain
(
id
)
)
)
;
let
clip_chain_index
=
self
.
clip_scroll_tree
.
add_clip_chain_descriptor
(
parent
items
)
;
self
.
id_to_index_mapper
.
add_clip_chain
(
ClipId
:
:
ClipChain
(
info
.
id
)
clip_chain_index
)
;
}
SpecificDisplayItem
:
:
ScrollFrame
(
ref
info
)
=
>
{
self
.
flatten_scroll_frame
(
&
item
info
pipeline_id
&
clip_and_scroll_ids
&
reference_frame_relative_offset
)
;
}
SpecificDisplayItem
:
:
StickyFrame
(
ref
info
)
=
>
{
self
.
flatten_sticky_frame
(
&
item
info
&
clip_and_scroll
&
clip_and_scroll_ids
.
scroll_node_id
&
reference_frame_relative_offset
)
;
}
SpecificDisplayItem
:
:
SetGradientStops
=
>
{
}
SpecificDisplayItem
:
:
PopStackingContext
=
>
{
unreachable
!
(
"
Should
have
returned
in
parent
method
.
"
)
}
SpecificDisplayItem
:
:
PushShadow
(
shadow
)
=
>
{
let
mut
prim_info
=
prim_info
.
clone
(
)
;
prim_info
.
rect
=
LayerRect
:
:
zero
(
)
;
self
.
push_shadow
(
shadow
clip_and_scroll
&
prim_info
)
;
}
SpecificDisplayItem
:
:
PopAllShadows
=
>
{
self
.
pop_all_shadows
(
)
;
}
}
None
}
pub
fn
create_primitive
(
&
mut
self
info
:
&
LayerPrimitiveInfo
clip_sources
:
Vec
<
ClipSource
>
container
:
PrimitiveContainer
)
-
>
PrimitiveIndex
{
let
stacking_context
=
self
.
sc_stack
.
last
(
)
.
expect
(
"
bug
:
no
stacking
context
!
"
)
;
let
clip_sources
=
if
clip_sources
.
is_empty
(
)
{
None
}
else
{
Some
(
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
clip_sources
)
)
)
}
;
let
prim_index
=
self
.
prim_store
.
add_primitive
(
&
info
.
rect
&
info
.
clip_rect
info
.
is_backface_visible
&
&
stacking_context
.
is_backface_visible
clip_sources
info
.
tag
container
)
;
prim_index
}
pub
fn
add_primitive_to_hit_testing_list
(
&
mut
self
info
:
&
LayerPrimitiveInfo
clip_and_scroll
:
ScrollNodeAndClipChain
)
{
let
tag
=
match
info
.
tag
{
Some
(
tag
)
=
>
tag
None
=
>
return
}
;
let
new_item
=
HitTestingItem
:
:
new
(
tag
info
)
;
match
self
.
hit_testing_runs
.
last_mut
(
)
{
Some
(
&
mut
HitTestingRun
(
ref
mut
items
prev_clip_and_scroll
)
)
if
prev_clip_and_scroll
=
=
clip_and_scroll
=
>
{
items
.
push
(
new_item
)
;
return
;
}
_
=
>
{
}
}
self
.
hit_testing_runs
.
push
(
HitTestingRun
(
vec
!
[
new_item
]
clip_and_scroll
)
)
;
}
pub
fn
add_primitive_to_draw_list
(
&
mut
self
prim_index
:
PrimitiveIndex
clip_and_scroll
:
ScrollNodeAndClipChain
)
{
let
pic_index
=
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
;
let
pic
=
&
mut
self
.
prim_store
.
pictures
[
pic_index
.
0
]
;
pic
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
pub
fn
add_primitive
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
clip_sources
:
Vec
<
ClipSource
>
container
:
PrimitiveContainer
)
-
>
PrimitiveIndex
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
let
prim_index
=
self
.
create_primitive
(
info
clip_sources
container
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
prim_index
}
pub
fn
push_stacking_context
(
&
mut
self
pipeline_id
:
PipelineId
composite_ops
:
CompositeOps
transform_style
:
TransformStyle
is_backface_visible
:
bool
is_pipeline_root
:
bool
clip_and_scroll
:
ScrollNodeAndClipChain
)
{
let
current_reference_frame_index
=
self
.
current_reference_frame_index
(
)
;
let
max_clip
=
LayerRect
:
:
max_rect
(
)
;
if
self
.
sc_stack
.
is_empty
(
)
{
debug_assert
!
(
self
.
prim_store
.
pictures
.
is_empty
(
)
)
;
debug_assert_eq
!
(
transform_style
TransformStyle
:
:
Flat
)
;
let
pic_index
=
self
.
prim_store
.
add_image_picture
(
None
false
pipeline_id
current_reference_frame_index
None
)
;
self
.
picture_stack
.
push
(
pic_index
)
;
}
else
if
composite_ops
.
mix_blend_mode
.
is_some
(
)
&
&
self
.
sc_stack
.
len
(
)
>
2
{
let
parent_pic_index
=
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
;
let
parent_pic
=
&
mut
self
.
prim_store
.
pictures
[
parent_pic_index
.
0
]
;
match
parent_pic
.
kind
{
PictureKind
:
:
Image
{
ref
mut
composite_mode
.
.
}
=
>
{
if
composite_mode
.
is_none
(
)
{
*
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
}
}
PictureKind
:
:
TextShadow
{
.
.
}
=
>
{
panic
!
(
"
bug
:
text
pictures
invalid
here
"
)
;
}
}
}
let
parent_transform_style
=
match
self
.
sc_stack
.
last
(
)
{
Some
(
sc
)
=
>
sc
.
transform_style
None
=
>
TransformStyle
:
:
Flat
}
;
let
participating_in_3d_context
=
composite_ops
.
count
(
)
=
=
0
&
&
(
parent_transform_style
=
=
TransformStyle
:
:
Preserve3D
|
|
transform_style
=
=
TransformStyle
:
:
Preserve3D
)
;
let
establishes_3d_context
=
participating_in_3d_context
&
&
parent_transform_style
=
=
TransformStyle
:
:
Flat
;
let
rendering_context_3d_pic_index
=
if
establishes_3d_context
{
let
container_index
=
self
.
prim_store
.
add_image_picture
(
None
false
pipeline_id
current_reference_frame_index
None
)
;
let
prim
=
BrushPrimitive
:
:
new_picture
(
container_index
)
;
let
prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
None
None
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
let
parent_pic_index
=
*
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
;
let
pic
=
&
mut
self
.
prim_store
.
pictures
[
parent_pic_index
.
0
]
;
pic
.
add_primitive
(
prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
container_index
)
;
Some
(
container_index
)
}
else
{
None
}
;
let
mut
parent_pic_index
=
if
!
establishes_3d_context
&
&
participating_in_3d_context
{
self
.
sc_stack
.
iter
(
)
.
rev
(
)
.
find
(
|
sc
|
sc
.
rendering_context_3d_pic_index
.
is_some
(
)
)
.
map
(
|
sc
|
sc
.
rendering_context_3d_pic_index
.
unwrap
(
)
)
.
unwrap
(
)
}
else
{
*
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
}
;
for
filter
in
composite_ops
.
filters
.
iter
(
)
.
rev
(
)
{
let
src_pic_index
=
self
.
prim_store
.
add_image_picture
(
Some
(
PictureCompositeMode
:
:
Filter
(
*
filter
)
)
false
pipeline_id
current_reference_frame_index
None
)
;
let
src_prim
=
BrushPrimitive
:
:
new_picture
(
src_pic_index
)
;
let
src_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
None
None
PrimitiveContainer
:
:
Brush
(
src_prim
)
)
;
let
parent_pic
=
&
mut
self
.
prim_store
.
pictures
[
parent_pic_index
.
0
]
;
parent_pic_index
=
src_pic_index
;
parent_pic
.
add_primitive
(
src_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
src_pic_index
)
;
}
if
let
Some
(
mix_blend_mode
)
=
composite_ops
.
mix_blend_mode
{
let
src_pic_index
=
self
.
prim_store
.
add_image_picture
(
Some
(
PictureCompositeMode
:
:
MixBlend
(
mix_blend_mode
)
)
false
pipeline_id
current_reference_frame_index
None
)
;
let
src_prim
=
BrushPrimitive
:
:
new_picture
(
src_pic_index
)
;
let
src_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
None
None
PrimitiveContainer
:
:
Brush
(
src_prim
)
)
;
let
parent_pic
=
&
mut
self
.
prim_store
.
pictures
[
parent_pic_index
.
0
]
;
parent_pic_index
=
src_pic_index
;
parent_pic
.
add_primitive
(
src_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
src_pic_index
)
;
}
let
mut
composite_mode
=
None
;
let
mut
frame_output_pipeline_id
=
None
;
if
is_pipeline_root
&
&
self
.
output_pipelines
.
contains
(
&
pipeline_id
)
{
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
frame_output_pipeline_id
=
Some
(
pipeline_id
)
;
}
if
participating_in_3d_context
{
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
}
let
pic_index
=
self
.
prim_store
.
add_image_picture
(
composite_mode
participating_in_3d_context
pipeline_id
current_reference_frame_index
frame_output_pipeline_id
)
;
let
sc_prim
=
BrushPrimitive
:
:
new_picture
(
pic_index
)
;
let
sc_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
None
None
PrimitiveContainer
:
:
Brush
(
sc_prim
)
)
;
let
parent_pic
=
&
mut
self
.
prim_store
.
pictures
[
parent_pic_index
.
0
]
;
parent_pic
.
add_primitive
(
sc_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
pic_index
)
;
let
allow_subpixel_aa
=
composite_ops
.
count
(
)
=
=
0
&
&
transform_style
=
=
TransformStyle
:
:
Flat
;
let
sc
=
FlattenedStackingContext
{
composite_ops
is_backface_visible
pipeline_id
allow_subpixel_aa
transform_style
rendering_context_3d_pic_index
}
;
self
.
sc_stack
.
push
(
sc
)
;
}
pub
fn
pop_stacking_context
(
&
mut
self
)
{
let
sc
=
self
.
sc_stack
.
pop
(
)
.
unwrap
(
)
;
let
mut
pop_count
=
1
;
pop_count
+
=
sc
.
composite_ops
.
count
(
)
;
if
sc
.
rendering_context_3d_pic_index
.
is_some
(
)
{
pop_count
+
=
1
;
}
for
_
in
0
.
.
pop_count
{
self
.
picture_stack
.
pop
(
)
.
expect
(
"
bug
:
mismatched
picture
stack
"
)
;
}
if
self
.
sc_stack
.
is_empty
(
)
{
self
.
picture_stack
.
pop
(
)
.
expect
(
"
bug
:
picture
stack
invalid
"
)
;
debug_assert
!
(
self
.
picture_stack
.
is_empty
(
)
)
;
}
assert
!
(
self
.
shadow_prim_stack
.
is_empty
(
)
"
Found
unpopped
text
shadows
when
popping
stacking
context
!
"
)
;
}
pub
fn
push_reference_frame
(
&
mut
self
reference_frame_id
:
ClipId
parent_id
:
Option
<
ClipId
>
pipeline_id
:
PipelineId
rect
:
&
LayerRect
source_transform
:
Option
<
PropertyBinding
<
LayoutTransform
>
>
source_perspective
:
Option
<
LayoutTransform
>
origin_in_parent_reference_frame
:
LayerVector2D
)
-
>
ClipScrollNodeIndex
{
let
index
=
self
.
id_to_index_mapper
.
get_node_index
(
reference_frame_id
)
;
let
node
=
ClipScrollNode
:
:
new_reference_frame
(
parent_id
.
map
(
|
id
|
self
.
id_to_index_mapper
.
get_node_index
(
id
)
)
rect
source_transform
source_perspective
origin_in_parent_reference_frame
pipeline_id
)
;
self
.
clip_scroll_tree
.
add_node
(
node
index
)
;
self
.
reference_frame_stack
.
push
(
(
reference_frame_id
index
)
)
;
match
parent_id
{
Some
(
ref
parent_id
)
=
>
self
.
id_to_index_mapper
.
map_to_parent_clip_chain
(
reference_frame_id
parent_id
)
_
=
>
self
.
id_to_index_mapper
.
add_clip_chain
(
reference_frame_id
ClipChainIndex
(
0
)
)
}
index
}
pub
fn
current_reference_frame_index
(
&
self
)
-
>
ClipScrollNodeIndex
{
self
.
reference_frame_stack
.
last
(
)
.
unwrap
(
)
.
1
}
pub
fn
current_reference_frame_id
(
&
self
)
-
>
ClipId
{
self
.
reference_frame_stack
.
last
(
)
.
unwrap
(
)
.
0
}
pub
fn
setup_viewport_offset
(
&
mut
self
inner_rect
:
DeviceUintRect
device_pixel_scale
:
DevicePixelScale
)
{
let
viewport_offset
=
(
inner_rect
.
origin
.
to_vector
(
)
.
to_f32
(
)
/
device_pixel_scale
)
.
round
(
)
;
let
root_id
=
self
.
clip_scroll_tree
.
root_reference_frame_index
(
)
;
let
root_node
=
&
mut
self
.
clip_scroll_tree
.
nodes
[
root_id
.
0
]
;
if
let
NodeType
:
:
ReferenceFrame
(
ref
mut
info
)
=
root_node
.
node_type
{
info
.
resolved_transform
=
LayerVector2D
:
:
new
(
viewport_offset
.
x
viewport_offset
.
y
)
.
into
(
)
;
}
}
pub
fn
push_root
(
&
mut
self
pipeline_id
:
PipelineId
viewport_size
:
&
LayerSize
content_size
:
&
LayerSize
)
{
let
viewport_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
*
viewport_size
)
;
self
.
push_reference_frame
(
ClipId
:
:
root_reference_frame
(
pipeline_id
)
None
pipeline_id
&
viewport_rect
None
None
LayerVector2D
:
:
zero
(
)
)
;
self
.
add_scroll_frame
(
ClipId
:
:
root_scroll_node
(
pipeline_id
)
ClipId
:
:
root_reference_frame
(
pipeline_id
)
Some
(
ExternalScrollId
(
0
pipeline_id
)
)
pipeline_id
&
viewport_rect
content_size
ScrollSensitivity
:
:
ScriptAndInputEvents
)
;
}
pub
fn
add_clip_node
(
&
mut
self
new_node_id
:
ClipId
parent_id
:
ClipId
clip_region
:
ClipRegion
)
-
>
ClipScrollNodeIndex
{
let
clip_rect
=
clip_region
.
main
;
let
clip_sources
=
ClipSources
:
:
from
(
clip_region
)
;
let
handle
=
self
.
clip_store
.
insert
(
clip_sources
)
;
let
node_index
=
self
.
id_to_index_mapper
.
get_node_index
(
new_node_id
)
;
let
clip_chain_index
=
self
.
clip_scroll_tree
.
add_clip_node
(
node_index
self
.
id_to_index_mapper
.
get_node_index
(
parent_id
)
handle
clip_rect
new_node_id
.
pipeline_id
(
)
)
;
self
.
id_to_index_mapper
.
add_clip_chain
(
new_node_id
clip_chain_index
)
;
node_index
}
pub
fn
add_scroll_frame
(
&
mut
self
new_node_id
:
ClipId
parent_id
:
ClipId
external_id
:
Option
<
ExternalScrollId
>
pipeline_id
:
PipelineId
frame_rect
:
&
LayerRect
content_size
:
&
LayerSize
scroll_sensitivity
:
ScrollSensitivity
)
-
>
ClipScrollNodeIndex
{
let
node_index
=
self
.
id_to_index_mapper
.
get_node_index
(
new_node_id
)
;
let
node
=
ClipScrollNode
:
:
new_scroll_frame
(
pipeline_id
self
.
id_to_index_mapper
.
get_node_index
(
parent_id
)
external_id
frame_rect
content_size
scroll_sensitivity
)
;
self
.
clip_scroll_tree
.
add_node
(
node
node_index
)
;
self
.
id_to_index_mapper
.
map_to_parent_clip_chain
(
new_node_id
&
parent_id
)
;
node_index
}
pub
fn
pop_reference_frame
(
&
mut
self
)
{
self
.
reference_frame_stack
.
pop
(
)
;
}
pub
fn
push_shadow
(
&
mut
self
shadow
:
Shadow
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
)
{
let
pipeline_id
=
self
.
sc_stack
.
last
(
)
.
unwrap
(
)
.
pipeline_id
;
let
pic_index
=
self
.
prim_store
.
add_shadow_picture
(
shadow
pipeline_id
)
;
let
prim
=
BrushPrimitive
:
:
new_picture
(
pic_index
)
;
let
prim_index
=
self
.
create_primitive
(
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
let
pending
=
vec
!
[
(
prim_index
clip_and_scroll
)
]
;
self
.
shadow_prim_stack
.
push
(
(
prim_index
pending
)
)
;
}
pub
fn
pop_all_shadows
(
&
mut
self
)
{
assert
!
(
self
.
shadow_prim_stack
.
len
(
)
>
0
"
popped
shadows
but
none
were
present
"
)
;
let
mut
shadows
=
mem
:
:
replace
(
&
mut
self
.
shadow_prim_stack
Vec
:
:
new
(
)
)
;
for
(
_
pending_primitives
)
in
shadows
.
drain
(
.
.
)
{
for
(
prim_index
clip_and_scroll
)
in
pending_primitives
{
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
}
let
mut
pending_primitives
=
mem
:
:
replace
(
&
mut
self
.
pending_shadow_contents
Vec
:
:
new
(
)
)
;
for
(
prim_index
clip_and_scroll
info
)
in
pending_primitives
.
drain
(
.
.
)
{
self
.
add_primitive_to_hit_testing_list
(
&
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
mem
:
:
replace
(
&
mut
self
.
pending_shadow_contents
pending_primitives
)
;
mem
:
:
replace
(
&
mut
self
.
shadow_prim_stack
shadows
)
;
}
pub
fn
add_solid_rectangle
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
color
:
ColorF
segments
:
Option
<
BrushSegmentDescriptor
>
)
{
if
color
.
a
=
=
0
.
0
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
return
;
}
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Solid
{
color
}
segments
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
pub
fn
add_clear_rectangle
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
)
{
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Clear
None
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
pub
fn
add_scroll_bar
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
color
:
ColorF
scrollbar_info
:
ScrollbarInfo
)
{
if
color
.
a
=
=
0
.
0
{
return
;
}
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Solid
{
color
}
None
)
;
let
prim_index
=
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
self
.
scrollbar_prims
.
push
(
ScrollbarPrimitive
{
prim_index
scroll_frame_index
:
scrollbar_info
.
0
frame_rect
:
scrollbar_info
.
1
}
)
;
}
pub
fn
add_line
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
wavy_line_thickness
:
f32
orientation
:
LineOrientation
line_color
:
&
ColorF
style
:
LineStyle
)
{
let
line
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Line
{
wavy_line_thickness
color
:
line_color
.
premultiplied
(
)
style
orientation
}
None
)
;
let
mut
fast_shadow_prims
=
Vec
:
:
new
(
)
;
for
(
idx
&
(
shadow_prim_index
_
)
)
in
self
.
shadow_prim_stack
.
iter
(
)
.
enumerate
(
)
{
let
shadow_metadata
=
&
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
let
brush
=
&
self
.
prim_store
.
cpu_brushes
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
let
picture
=
&
self
.
prim_store
.
pictures
[
brush
.
get_picture_index
(
)
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
offset
color
blur_radius
.
.
}
if
blur_radius
=
=
0
.
0
=
>
{
fast_shadow_prims
.
push
(
(
idx
offset
color
)
)
;
}
_
=
>
{
}
}
}
for
(
idx
shadow_offset
shadow_color
)
in
fast_shadow_prims
{
let
line
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Line
{
wavy_line_thickness
color
:
shadow_color
.
premultiplied
(
)
style
orientation
}
None
)
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
info
.
rect
.
translate
(
&
shadow_offset
)
;
info
.
clip_rect
=
info
.
clip_rect
.
translate
(
&
shadow_offset
)
;
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
line
)
)
;
self
.
shadow_prim_stack
[
idx
]
.
1
.
push
(
(
prim_index
clip_and_scroll
)
)
;
}
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
line
)
)
;
if
line_color
.
a
>
0
.
0
{
if
self
.
shadow_prim_stack
.
is_empty
(
)
{
self
.
add_primitive_to_hit_testing_list
(
&
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
else
{
self
.
pending_shadow_contents
.
push
(
(
prim_index
clip_and_scroll
*
info
)
)
;
}
}
for
&
(
shadow_prim_index
_
)
in
&
self
.
shadow_prim_stack
{
let
shadow_metadata
=
&
mut
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
debug_assert_eq
!
(
shadow_metadata
.
prim_kind
PrimitiveKind
:
:
Brush
)
;
let
brush
=
&
self
.
prim_store
.
cpu_brushes
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
let
picture
=
&
mut
self
.
prim_store
.
pictures
[
brush
.
get_picture_index
(
)
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
blur_radius
.
.
}
if
blur_radius
>
0
.
0
=
>
{
picture
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
_
=
>
{
}
}
}
}
pub
fn
add_border
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
border_item
:
&
BorderDisplayItem
gradient_stops
:
ItemRange
<
GradientStop
>
gradient_stops_count
:
usize
)
{
let
rect
=
info
.
rect
;
let
create_segments
=
|
outset
:
SideOffsets2D
<
f32
>
|
{
let
origin
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
-
outset
.
left
rect
.
origin
.
y
-
outset
.
top
)
;
let
size
=
LayerSize
:
:
new
(
rect
.
size
.
width
+
outset
.
left
+
outset
.
right
rect
.
size
.
height
+
outset
.
top
+
outset
.
bottom
)
;
let
rect
=
LayerRect
:
:
new
(
origin
size
)
;
let
tl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
;
let
tl_inner
=
tl_outer
+
vec2
(
border_item
.
widths
.
left
border_item
.
widths
.
top
)
;
let
tr_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
)
;
let
tr_inner
=
tr_outer
+
vec2
(
-
border_item
.
widths
.
right
border_item
.
widths
.
top
)
;
let
bl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
bl_inner
=
bl_outer
+
vec2
(
border_item
.
widths
.
left
-
border_item
.
widths
.
bottom
)
;
let
br_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
br_inner
=
br_outer
-
vec2
(
border_item
.
widths
.
right
border_item
.
widths
.
bottom
)
;
vec
!
[
/
/
Top
left
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_outer
.
y
tl_inner
.
x
tl_inner
.
y
)
/
/
Top
right
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_outer
.
y
tr_outer
.
x
tr_inner
.
y
)
/
/
Bottom
right
LayerRect
:
:
from_floats
(
br_inner
.
x
br_inner
.
y
br_outer
.
x
br_outer
.
y
)
/
/
Bottom
left
LayerRect
:
:
from_floats
(
bl_outer
.
x
bl_inner
.
y
bl_inner
.
x
bl_outer
.
y
)
/
/
Top
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_outer
.
y
tr_inner
.
x
tl_inner
.
y
)
/
/
Bottom
LayerRect
:
:
from_floats
(
bl_inner
.
x
bl_inner
.
y
br_inner
.
x
bl_outer
.
y
)
/
/
Left
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_inner
.
y
tl_inner
.
x
bl_inner
.
y
)
/
/
Right
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_inner
.
y
br_outer
.
x
br_inner
.
y
)
]
}
;
match
border_item
.
details
{
BorderDetails
:
:
Image
(
ref
border
)
=
>
{
let
origin
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
-
border
.
outset
.
left
rect
.
origin
.
y
-
border
.
outset
.
top
)
;
let
size
=
LayerSize
:
:
new
(
rect
.
size
.
width
+
border
.
outset
.
left
+
border
.
outset
.
right
rect
.
size
.
height
+
border
.
outset
.
top
+
border
.
outset
.
bottom
)
;
let
rect
=
LayerRect
:
:
new
(
origin
size
)
;
let
px0
=
0
.
0
;
let
px1
=
border
.
patch
.
slice
.
left
as
f32
;
let
px2
=
border
.
patch
.
width
as
f32
-
border
.
patch
.
slice
.
right
as
f32
;
let
px3
=
border
.
patch
.
width
as
f32
;
let
py0
=
0
.
0
;
let
py1
=
border
.
patch
.
slice
.
top
as
f32
;
let
py2
=
border
.
patch
.
height
as
f32
-
border
.
patch
.
slice
.
bottom
as
f32
;
let
py3
=
border
.
patch
.
height
as
f32
;
let
tl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
;
let
tl_inner
=
tl_outer
+
vec2
(
border_item
.
widths
.
left
border_item
.
widths
.
top
)
;
let
tr_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
)
;
let
tr_inner
=
tr_outer
+
vec2
(
-
border_item
.
widths
.
right
border_item
.
widths
.
top
)
;
let
bl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
bl_inner
=
bl_outer
+
vec2
(
border_item
.
widths
.
left
-
border_item
.
widths
.
bottom
)
;
let
br_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
br_inner
=
br_outer
-
vec2
(
border_item
.
widths
.
right
border_item
.
widths
.
bottom
)
;
fn
add_segment
(
segments
:
&
mut
Vec
<
ImageBorderSegment
>
rect
:
LayerRect
uv_rect
:
TexelRect
repeat_horizontal
:
RepeatMode
repeat_vertical
:
RepeatMode
)
{
if
uv_rect
.
uv1
.
x
>
uv_rect
.
uv0
.
x
&
&
uv_rect
.
uv1
.
y
>
uv_rect
.
uv0
.
y
{
segments
.
push
(
ImageBorderSegment
:
:
new
(
rect
uv_rect
repeat_horizontal
repeat_vertical
)
)
;
}
}
let
mut
segments
=
vec
!
[
]
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_outer
.
y
tl_inner
.
x
tl_inner
.
y
)
TexelRect
:
:
new
(
px0
py0
px1
py1
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_outer
.
y
tr_outer
.
x
tr_inner
.
y
)
TexelRect
:
:
new
(
px2
py0
px3
py1
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
br_inner
.
x
br_inner
.
y
br_outer
.
x
br_outer
.
y
)
TexelRect
:
:
new
(
px2
py2
px3
py3
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
bl_outer
.
x
bl_inner
.
y
bl_inner
.
x
bl_outer
.
y
)
TexelRect
:
:
new
(
px0
py2
px1
py3
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
if
border
.
fill
{
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_inner
.
y
tr_inner
.
x
bl_inner
.
y
)
TexelRect
:
:
new
(
px1
py1
px2
py2
)
border
.
repeat_horizontal
border
.
repeat_vertical
)
;
}
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_outer
.
y
tr_inner
.
x
tl_inner
.
y
)
TexelRect
:
:
new
(
px1
py0
px2
py1
)
border
.
repeat_horizontal
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
bl_inner
.
x
bl_inner
.
y
br_inner
.
x
bl_outer
.
y
)
TexelRect
:
:
new
(
px1
py2
px2
py3
)
border
.
repeat_horizontal
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_inner
.
y
tl_inner
.
x
bl_inner
.
y
)
TexelRect
:
:
new
(
px0
py1
px1
py2
)
RepeatMode
:
:
Stretch
border
.
repeat_vertical
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_inner
.
y
br_outer
.
x
br_inner
.
y
)
TexelRect
:
:
new
(
px2
py1
px3
py2
)
RepeatMode
:
:
Stretch
border
.
repeat_vertical
)
;
for
segment
in
segments
{
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
.
geom_rect
;
self
.
add_image
(
clip_and_scroll
&
info
segment
.
stretch_size
segment
.
tile_spacing
Some
(
segment
.
sub_rect
)
border
.
image_key
ImageRendering
:
:
Auto
AlphaType
:
:
PremultipliedAlpha
None
)
;
}
}
BorderDetails
:
:
Normal
(
ref
border
)
=
>
{
self
.
add_normal_border
(
info
border
&
border_item
.
widths
clip_and_scroll
)
;
}
BorderDetails
:
:
Gradient
(
ref
border
)
=
>
for
segment
in
create_segments
(
border
.
outset
)
{
let
segment_rel
=
segment
.
origin
-
rect
.
origin
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
;
self
.
add_gradient
(
clip_and_scroll
&
info
border
.
gradient
.
start_point
-
segment_rel
border
.
gradient
.
end_point
-
segment_rel
gradient_stops
gradient_stops_count
border
.
gradient
.
extend_mode
segment
.
size
LayerSize
:
:
zero
(
)
)
;
}
BorderDetails
:
:
RadialGradient
(
ref
border
)
=
>
{
for
segment
in
create_segments
(
border
.
outset
)
{
let
segment_rel
=
segment
.
origin
-
rect
.
origin
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
;
self
.
add_radial_gradient
(
clip_and_scroll
&
info
border
.
gradient
.
center
-
segment_rel
border
.
gradient
.
start_radius
border
.
gradient
.
end_radius
border
.
gradient
.
radius
.
width
/
border
.
gradient
.
radius
.
height
gradient_stops
border
.
gradient
.
extend_mode
segment
.
size
LayerSize
:
:
zero
(
)
)
;
}
}
}
}
fn
add_gradient_impl
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
start_point
:
LayerPoint
end_point
:
LayerPoint
stops
:
ItemRange
<
GradientStop
>
stops_count
:
usize
extend_mode
:
ExtendMode
gradient_index
:
CachedGradientIndex
)
{
let
reverse_stops
=
start_point
.
x
>
end_point
.
x
|
|
(
start_point
.
x
=
=
end_point
.
x
&
&
start_point
.
y
>
end_point
.
y
)
;
let
(
sp
ep
)
=
if
reverse_stops
{
(
end_point
start_point
)
}
else
{
(
start_point
end_point
)
}
;
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
LinearGradient
{
stops_range
:
stops
stops_count
extend_mode
reverse_stops
start_point
:
sp
end_point
:
ep
gradient_index
}
None
)
;
let
prim
=
PrimitiveContainer
:
:
Brush
(
prim
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
prim
)
;
}
pub
fn
add_gradient
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
start_point
:
LayerPoint
end_point
:
LayerPoint
stops
:
ItemRange
<
GradientStop
>
stops_count
:
usize
extend_mode
:
ExtendMode
tile_size
:
LayerSize
tile_spacing
:
LayerSize
)
{
let
gradient_index
=
CachedGradientIndex
(
self
.
cached_gradients
.
len
(
)
)
;
self
.
cached_gradients
.
push
(
CachedGradient
:
:
new
(
)
)
;
let
prim_infos
=
info
.
decompose
(
tile_size
tile_spacing
64
*
64
)
;
if
prim_infos
.
is_empty
(
)
{
self
.
add_gradient_impl
(
clip_and_scroll
info
start_point
end_point
stops
stops_count
extend_mode
gradient_index
)
;
}
else
{
for
prim_info
in
prim_infos
{
self
.
add_gradient_impl
(
clip_and_scroll
&
prim_info
start_point
end_point
stops
stops_count
extend_mode
gradient_index
)
;
}
}
}
fn
add_radial_gradient_impl
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
center
:
LayerPoint
start_radius
:
f32
end_radius
:
f32
ratio_xy
:
f32
stops
:
ItemRange
<
GradientStop
>
extend_mode
:
ExtendMode
gradient_index
:
CachedGradientIndex
)
{
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
RadialGradient
{
stops_range
:
stops
extend_mode
center
start_radius
end_radius
ratio_xy
gradient_index
}
None
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
pub
fn
add_radial_gradient
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
center
:
LayerPoint
start_radius
:
f32
end_radius
:
f32
ratio_xy
:
f32
stops
:
ItemRange
<
GradientStop
>
extend_mode
:
ExtendMode
tile_size
:
LayerSize
tile_spacing
:
LayerSize
)
{
let
gradient_index
=
CachedGradientIndex
(
self
.
cached_gradients
.
len
(
)
)
;
self
.
cached_gradients
.
push
(
CachedGradient
:
:
new
(
)
)
;
let
prim_infos
=
info
.
decompose
(
tile_size
tile_spacing
64
*
64
)
;
if
prim_infos
.
is_empty
(
)
{
self
.
add_radial_gradient_impl
(
clip_and_scroll
info
center
start_radius
end_radius
ratio_xy
stops
extend_mode
gradient_index
)
;
}
else
{
for
prim_info
in
prim_infos
{
self
.
add_radial_gradient_impl
(
clip_and_scroll
&
prim_info
center
start_radius
end_radius
ratio_xy
stops
extend_mode
gradient_index
)
;
}
}
}
pub
fn
add_text
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
run_offset
:
LayoutVector2D
info
:
&
LayerPrimitiveInfo
font_instance_key
:
&
FontInstanceKey
text_color
:
&
ColorF
glyph_range
:
ItemRange
<
GlyphInstance
>
glyph_count
:
usize
glyph_options
:
Option
<
GlyphOptions
>
)
{
let
prim
=
{
let
instance_map
=
self
.
font_instances
.
read
(
)
.
unwrap
(
)
;
let
font_instance
=
match
instance_map
.
get
(
&
font_instance_key
)
{
Some
(
instance
)
=
>
instance
None
=
>
{
warn
!
(
"
Unknown
font
instance
key
"
)
;
debug
!
(
"
key
=
{
:
?
}
"
font_instance_key
)
;
return
;
}
}
;
if
font_instance
.
size
.
0
<
=
0
{
return
;
}
if
font_instance
.
size
>
=
Au
:
:
from_px
(
4096
)
{
return
;
}
let
mut
render_mode
=
self
.
config
.
default_font_render_mode
.
limit_by
(
font_instance
.
render_mode
)
;
let
mut
flags
=
font_instance
.
flags
;
if
let
Some
(
options
)
=
glyph_options
{
render_mode
=
render_mode
.
limit_by
(
options
.
render_mode
)
;
flags
|
=
options
.
flags
;
}
if
render_mode
=
=
FontRenderMode
:
:
Subpixel
{
if
let
Some
(
ref
stacking_context
)
=
self
.
sc_stack
.
last
(
)
{
if
!
stacking_context
.
allow_subpixel_aa
{
render_mode
=
FontRenderMode
:
:
Alpha
;
}
}
}
let
prim_font
=
FontInstance
:
:
new
(
font_instance
.
font_key
font_instance
.
size
*
text_color
font_instance
.
bg_color
render_mode
font_instance
.
subpx_dir
flags
font_instance
.
platform_options
font_instance
.
variations
.
clone
(
)
)
;
TextRunPrimitiveCpu
{
font
:
prim_font
glyph_range
glyph_count
glyph_gpu_blocks
:
Vec
:
:
new
(
)
glyph_keys
:
Vec
:
:
new
(
)
offset
:
run_offset
shadow
:
false
}
}
;
let
mut
fast_shadow_prims
=
Vec
:
:
new
(
)
;
for
(
idx
&
(
shadow_prim_index
_
)
)
in
self
.
shadow_prim_stack
.
iter
(
)
.
enumerate
(
)
{
let
shadow_metadata
=
&
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
let
brush
=
&
self
.
prim_store
.
cpu_brushes
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
let
picture_prim
=
&
self
.
prim_store
.
pictures
[
brush
.
get_picture_index
(
)
.
0
]
;
match
picture_prim
.
kind
{
PictureKind
:
:
TextShadow
{
offset
color
blur_radius
.
.
}
if
blur_radius
=
=
0
.
0
=
>
{
let
mut
text_prim
=
prim
.
clone
(
)
;
text_prim
.
font
.
color
=
color
.
into
(
)
;
text_prim
.
shadow
=
true
;
text_prim
.
offset
+
=
offset
;
fast_shadow_prims
.
push
(
(
idx
text_prim
)
)
;
}
_
=
>
{
}
}
}
for
(
idx
text_prim
)
in
fast_shadow_prims
{
let
rect
=
info
.
rect
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
rect
.
translate
(
&
text_prim
.
offset
)
;
info
.
clip_rect
=
info
.
clip_rect
.
translate
(
&
text_prim
.
offset
)
;
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
TextRun
(
text_prim
)
)
;
self
.
shadow_prim_stack
[
idx
]
.
1
.
push
(
(
prim_index
clip_and_scroll
)
)
;
}
let
prim_index
=
self
.
create_primitive
(
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
TextRun
(
prim
)
)
;
if
text_color
.
a
>
0
.
0
{
if
self
.
shadow_prim_stack
.
is_empty
(
)
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
else
{
self
.
pending_shadow_contents
.
push
(
(
prim_index
clip_and_scroll
*
info
)
)
;
}
}
for
&
(
shadow_prim_index
_
)
in
&
self
.
shadow_prim_stack
{
let
shadow_metadata
=
&
mut
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
debug_assert_eq
!
(
shadow_metadata
.
prim_kind
PrimitiveKind
:
:
Brush
)
;
let
brush
=
&
self
.
prim_store
.
cpu_brushes
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
let
picture
=
&
mut
self
.
prim_store
.
pictures
[
brush
.
get_picture_index
(
)
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
blur_radius
.
.
}
if
blur_radius
>
0
.
0
=
>
{
picture
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
_
=
>
{
}
}
}
}
pub
fn
add_image
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
stretch_size
:
LayerSize
mut
tile_spacing
:
LayerSize
sub_rect
:
Option
<
TexelRect
>
image_key
:
ImageKey
image_rendering
:
ImageRendering
alpha_type
:
AlphaType
tile_offset
:
Option
<
TileOffset
>
)
{
if
tile_spacing
=
=
info
.
rect
.
size
{
tile_spacing
=
LayerSize
:
:
zero
(
)
;
}
let
request
=
ImageRequest
{
key
:
image_key
rendering
:
image_rendering
tile
:
tile_offset
}
;
if
tile_spacing
=
=
LayerSize
:
:
zero
(
)
&
&
stretch_size
=
=
info
.
rect
.
size
&
&
sub_rect
.
is_none
(
)
&
&
tile_offset
.
is_none
(
)
{
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Image
{
request
current_epoch
:
Epoch
:
:
invalid
(
)
alpha_type
}
None
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
else
{
let
prim_cpu
=
ImagePrimitiveCpu
{
tile_spacing
alpha_type
stretch_size
current_epoch
:
Epoch
:
:
invalid
(
)
source
:
ImageSource
:
:
Default
key
:
ImageCacheKey
{
request
texel_rect
:
sub_rect
.
map
(
|
texel_rect
|
{
DeviceIntRect
:
:
new
(
DeviceIntPoint
:
:
new
(
texel_rect
.
uv0
.
x
as
i32
texel_rect
.
uv0
.
y
as
i32
)
DeviceIntSize
:
:
new
(
(
texel_rect
.
uv1
.
x
-
texel_rect
.
uv0
.
x
)
as
i32
(
texel_rect
.
uv1
.
y
-
texel_rect
.
uv0
.
y
)
as
i32
)
)
}
)
}
}
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Image
(
prim_cpu
)
)
;
}
}
pub
fn
add_yuv_image
(
&
mut
self
clip_and_scroll
:
ScrollNodeAndClipChain
info
:
&
LayerPrimitiveInfo
yuv_data
:
YuvData
color_space
:
YuvColorSpace
image_rendering
:
ImageRendering
)
{
let
format
=
yuv_data
.
get_format
(
)
;
let
yuv_key
=
match
yuv_data
{
YuvData
:
:
NV12
(
plane_0
plane_1
)
=
>
[
plane_0
plane_1
ImageKey
:
:
DUMMY
]
YuvData
:
:
PlanarYCbCr
(
plane_0
plane_1
plane_2
)
=
>
[
plane_0
plane_1
plane_2
]
YuvData
:
:
InterleavedYCbCr
(
plane_0
)
=
>
[
plane_0
ImageKey
:
:
DUMMY
ImageKey
:
:
DUMMY
]
}
;
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
YuvImage
{
yuv_key
format
color_space
image_rendering
}
None
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
}
pub
fn
build_scene
(
config
:
&
FrameBuilderConfig
request
:
SceneRequest
)
-
>
BuiltScene
{
let
mut
clip_scroll_tree
=
ClipScrollTree
:
:
new
(
)
;
let
mut
new_scene
=
Scene
:
:
new
(
)
;
let
frame_builder
=
DisplayListFlattener
:
:
create_frame_builder
(
FrameBuilder
:
:
empty
(
)
&
request
.
scene
&
mut
clip_scroll_tree
request
.
font_instances
request
.
tiled_image_map
&
request
.
view
&
request
.
output_pipelines
config
&
mut
new_scene
)
;
BuiltScene
{
scene
:
new_scene
frame_builder
clip_scroll_tree
removed_pipelines
:
request
.
removed_pipelines
}
}
trait
PrimitiveInfoTiler
{
fn
decompose
(
&
self
tile_size
:
LayerSize
tile_spacing
:
LayerSize
max_prims
:
usize
)
-
>
Vec
<
LayerPrimitiveInfo
>
;
}
impl
PrimitiveInfoTiler
for
LayerPrimitiveInfo
{
fn
decompose
(
&
self
tile_size
:
LayerSize
tile_spacing
:
LayerSize
max_prims
:
usize
)
-
>
Vec
<
LayerPrimitiveInfo
>
{
let
mut
prims
=
Vec
:
:
new
(
)
;
let
tile_repeat
=
tile_size
+
tile_spacing
;
if
tile_repeat
.
width
<
=
0
.
0
|
|
tile_repeat
.
height
<
=
0
.
0
{
return
prims
;
}
if
tile_repeat
.
width
<
self
.
rect
.
size
.
width
|
|
tile_repeat
.
height
<
self
.
rect
.
size
.
height
{
let
clip_rect
=
self
.
clip_rect
.
intersection
(
&
self
.
rect
)
.
unwrap_or_else
(
LayoutRect
:
:
zero
)
;
let
rect_p0
=
self
.
rect
.
origin
;
let
rect_p1
=
self
.
rect
.
bottom_right
(
)
;
let
mut
y0
=
rect_p0
.
y
;
while
y0
<
rect_p1
.
y
{
let
mut
x0
=
rect_p0
.
x
;
while
x0
<
rect_p1
.
x
{
prims
.
push
(
LayerPrimitiveInfo
{
rect
:
LayerRect
:
:
new
(
LayerPoint
:
:
new
(
x0
y0
)
tile_size
)
clip_rect
is_backface_visible
:
self
.
is_backface_visible
tag
:
self
.
tag
}
)
;
if
prims
.
len
(
)
>
max_prims
{
warn
!
(
"
too
many
prims
found
due
to
repeat
/
tile
.
dropping
extra
prims
!
"
)
;
return
prims
;
}
x0
+
=
tile_repeat
.
width
;
}
y0
+
=
tile_repeat
.
height
;
}
}
prims
}
}
struct
FlattenedStackingContext
{
pipeline_id
:
PipelineId
composite_ops
:
CompositeOps
is_backface_visible
:
bool
allow_subpixel_aa
:
bool
transform_style
:
TransformStyle
rendering_context_3d_pic_index
:
Option
<
PictureIndex
>
}
#
[
derive
(
Debug
)
]
pub
struct
ScrollbarInfo
(
pub
ClipScrollNodeIndex
pub
LayerRect
)
;
