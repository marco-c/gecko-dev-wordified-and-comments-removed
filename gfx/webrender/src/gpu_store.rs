use
renderer
:
:
MAX_VERTEX_TEXTURE_WIDTH
;
use
std
:
:
mem
;
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
PartialEq
)
]
pub
struct
GpuStoreAddress
(
pub
i32
)
;
pub
struct
GpuStore
<
T
>
{
data
:
Vec
<
T
>
}
impl
<
T
:
Clone
+
Default
>
GpuStore
<
T
>
{
pub
fn
new
(
)
-
>
GpuStore
<
T
>
{
GpuStore
{
data
:
Vec
:
:
new
(
)
}
}
pub
fn
push
<
E
>
(
&
mut
self
data
:
E
)
-
>
GpuStoreAddress
where
T
:
From
<
E
>
{
let
address
=
GpuStoreAddress
(
self
.
data
.
len
(
)
as
i32
)
;
self
.
data
.
push
(
T
:
:
from
(
data
)
)
;
address
}
pub
fn
build
(
&
self
)
-
>
Vec
<
T
>
{
let
item_size
=
mem
:
:
size_of
:
:
<
T
>
(
)
;
debug_assert
!
(
item_size
%
16
=
=
0
)
;
let
vecs_per_item
=
item_size
/
16
;
let
items_per_row
=
MAX_VERTEX_TEXTURE_WIDTH
/
vecs_per_item
;
let
mut
items
=
self
.
data
.
clone
(
)
;
while
items
.
len
(
)
%
items_per_row
!
=
0
{
items
.
push
(
T
:
:
default
(
)
)
;
}
items
}
pub
fn
alloc
(
&
mut
self
count
:
usize
)
-
>
GpuStoreAddress
{
let
address
=
self
.
get_next_address
(
)
;
for
_
in
0
.
.
count
{
self
.
data
.
push
(
T
:
:
default
(
)
)
;
}
address
}
pub
fn
get_next_address
(
&
self
)
-
>
GpuStoreAddress
{
GpuStoreAddress
(
self
.
data
.
len
(
)
as
i32
)
}
pub
fn
get
(
&
mut
self
address
:
GpuStoreAddress
)
-
>
&
T
{
&
self
.
data
[
address
.
0
as
usize
]
}
pub
fn
get_mut
(
&
mut
self
address
:
GpuStoreAddress
)
-
>
&
mut
T
{
&
mut
self
.
data
[
address
.
0
as
usize
]
}
pub
fn
get_slice_mut
(
&
mut
self
address
:
GpuStoreAddress
count
:
usize
)
-
>
&
mut
[
T
]
{
let
offset
=
address
.
0
as
usize
;
&
mut
self
.
data
[
offset
.
.
offset
+
count
]
}
}
