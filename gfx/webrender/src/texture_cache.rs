use
api
:
:
{
DeviceUintPoint
DeviceUintRect
DeviceUintSize
}
;
use
api
:
:
{
ExternalImageType
ImageData
ImageFormat
}
;
use
api
:
:
ImageDescriptor
;
use
device
:
:
TextureFilter
;
use
frame
:
:
FrameId
;
use
freelist
:
:
{
FreeList
FreeListHandle
UpsertResult
WeakFreeListHandle
}
;
use
gpu_cache
:
:
{
GpuCache
GpuCacheHandle
}
;
use
internal_types
:
:
{
CacheTextureId
FastHashMap
TextureUpdateList
TextureUpdateSource
}
;
use
internal_types
:
:
{
RenderTargetInfo
SourceTexture
TextureUpdate
TextureUpdateOp
}
;
use
profiler
:
:
{
ResourceProfileCounter
TextureCacheProfileCounters
}
;
use
resource_cache
:
:
CacheItem
;
use
std
:
:
cmp
;
use
std
:
:
mem
;
const
TEXTURE_ARRAY_LAYERS_LINEAR
:
usize
=
4
;
const
TEXTURE_ARRAY_LAYERS_NEAREST
:
usize
=
1
;
const
TEXTURE_LAYER_DIMENSIONS
:
u32
=
2048
;
const
TEXTURE_REGION_DIMENSIONS
:
u32
=
512
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
CacheTextureIdList
{
free_lists
:
FastHashMap
<
ImageFormat
Vec
<
CacheTextureId
>
>
next_id
:
usize
}
impl
CacheTextureIdList
{
fn
new
(
)
-
>
Self
{
CacheTextureIdList
{
next_id
:
0
free_lists
:
FastHashMap
:
:
default
(
)
}
}
fn
allocate
(
&
mut
self
format
:
ImageFormat
)
-
>
CacheTextureId
{
self
.
free_lists
.
get_mut
(
&
format
)
.
and_then
(
|
fl
|
fl
.
pop
(
)
)
.
unwrap_or_else
(
|
|
{
self
.
next_id
+
=
1
;
CacheTextureId
(
self
.
next_id
-
1
)
}
)
}
fn
free
(
&
mut
self
id
:
CacheTextureId
format
:
ImageFormat
)
{
self
.
free_lists
.
entry
(
format
)
.
or_insert
(
Vec
:
:
new
(
)
)
.
push
(
id
)
;
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
enum
EntryKind
{
Standalone
Cache
{
origin
:
DeviceUintPoint
layer_index
:
u16
region_index
:
u16
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
CacheEntry
{
size
:
DeviceUintSize
kind
:
EntryKind
user_data
:
[
f32
;
3
]
last_access
:
FrameId
uv_rect_handle
:
GpuCacheHandle
format
:
ImageFormat
filter
:
TextureFilter
texture_id
:
CacheTextureId
}
impl
CacheEntry
{
fn
new_standalone
(
texture_id
:
CacheTextureId
size
:
DeviceUintSize
format
:
ImageFormat
filter
:
TextureFilter
user_data
:
[
f32
;
3
]
last_access
:
FrameId
)
-
>
Self
{
CacheEntry
{
size
user_data
last_access
kind
:
EntryKind
:
:
Standalone
texture_id
format
filter
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
}
}
fn
update_gpu_cache
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
)
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
uv_rect_handle
)
{
let
(
origin
layer_index
)
=
match
self
.
kind
{
EntryKind
:
:
Standalone
{
.
.
}
=
>
(
DeviceUintPoint
:
:
zero
(
)
0
.
0
)
EntryKind
:
:
Cache
{
origin
layer_index
.
.
}
=
>
(
origin
layer_index
as
f32
)
}
;
request
.
push
(
[
origin
.
x
as
f32
origin
.
y
as
f32
(
origin
.
x
+
self
.
size
.
width
)
as
f32
(
origin
.
y
+
self
.
size
.
height
)
as
f32
]
)
;
request
.
push
(
[
layer_index
self
.
user_data
[
0
]
self
.
user_data
[
1
]
self
.
user_data
[
2
]
]
)
;
}
}
}
type
WeakCacheEntryHandle
=
WeakFreeListHandle
<
CacheEntry
>
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Clone
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureCacheHandle
{
entry
:
Option
<
WeakCacheEntryHandle
>
}
impl
TextureCacheHandle
{
pub
fn
new
(
)
-
>
Self
{
TextureCacheHandle
{
entry
:
None
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureCache
{
array_rgba8_nearest
:
TextureArray
array_a8_linear
:
TextureArray
array_rgba8_linear
:
TextureArray
max_texture_size
:
u32
cache_textures
:
CacheTextureIdList
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
skip
)
)
]
pending_updates
:
TextureUpdateList
frame_id
:
FrameId
entries
:
FreeList
<
CacheEntry
>
standalone_entry_handles
:
Vec
<
FreeListHandle
<
CacheEntry
>
>
shared_entry_handles
:
Vec
<
FreeListHandle
<
CacheEntry
>
>
}
impl
TextureCache
{
pub
fn
new
(
max_texture_size
:
u32
)
-
>
Self
{
TextureCache
{
max_texture_size
array_a8_linear
:
TextureArray
:
:
new
(
ImageFormat
:
:
R8
TextureFilter
:
:
Linear
TEXTURE_ARRAY_LAYERS_LINEAR
)
array_rgba8_linear
:
TextureArray
:
:
new
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Linear
TEXTURE_ARRAY_LAYERS_LINEAR
)
array_rgba8_nearest
:
TextureArray
:
:
new
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Nearest
TEXTURE_ARRAY_LAYERS_NEAREST
)
cache_textures
:
CacheTextureIdList
:
:
new
(
)
pending_updates
:
TextureUpdateList
:
:
new
(
)
frame_id
:
FrameId
(
0
)
entries
:
FreeList
:
:
new
(
)
standalone_entry_handles
:
Vec
:
:
new
(
)
shared_entry_handles
:
Vec
:
:
new
(
)
}
}
pub
fn
begin_frame
(
&
mut
self
frame_id
:
FrameId
)
{
self
.
frame_id
=
frame_id
;
}
pub
fn
end_frame
(
&
mut
self
texture_cache_profile
:
&
mut
TextureCacheProfileCounters
)
{
self
.
expire_old_standalone_entries
(
)
;
self
.
array_a8_linear
.
update_profile
(
&
mut
texture_cache_profile
.
pages_a8_linear
)
;
self
.
array_rgba8_linear
.
update_profile
(
&
mut
texture_cache_profile
.
pages_rgba8_linear
)
;
self
.
array_rgba8_nearest
.
update_profile
(
&
mut
texture_cache_profile
.
pages_rgba8_nearest
)
;
}
pub
fn
request
(
&
mut
self
handle
:
&
mut
TextureCacheHandle
gpu_cache
:
&
mut
GpuCache
)
-
>
bool
{
match
handle
.
entry
{
Some
(
ref
handle
)
=
>
{
match
self
.
entries
.
get_opt_mut
(
handle
)
{
Some
(
entry
)
=
>
{
entry
.
last_access
=
self
.
frame_id
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
false
}
None
=
>
true
}
}
None
=
>
true
}
}
pub
fn
max_texture_size
(
&
self
)
-
>
u32
{
self
.
max_texture_size
}
pub
fn
pending_updates
(
&
mut
self
)
-
>
TextureUpdateList
{
mem
:
:
replace
(
&
mut
self
.
pending_updates
TextureUpdateList
:
:
new
(
)
)
}
pub
fn
update
(
&
mut
self
handle
:
&
mut
TextureCacheHandle
descriptor
:
ImageDescriptor
filter
:
TextureFilter
data
:
Option
<
ImageData
>
user_data
:
[
f32
;
3
]
mut
dirty_rect
:
Option
<
DeviceUintRect
>
gpu_cache
:
&
mut
GpuCache
)
{
let
realloc
=
match
handle
.
entry
{
Some
(
ref
handle
)
=
>
{
match
self
.
entries
.
get_opt
(
handle
)
{
Some
(
entry
)
=
>
{
entry
.
size
.
width
!
=
descriptor
.
width
|
|
entry
.
size
.
height
!
=
descriptor
.
height
|
|
entry
.
format
!
=
descriptor
.
format
}
None
=
>
{
true
}
}
}
None
=
>
{
true
}
}
;
if
realloc
{
self
.
allocate
(
handle
descriptor
filter
user_data
)
;
dirty_rect
=
None
;
}
let
entry
=
self
.
entries
.
get_opt_mut
(
handle
.
entry
.
as_ref
(
)
.
unwrap
(
)
)
.
expect
(
"
BUG
:
handle
must
be
valid
now
"
)
;
gpu_cache
.
invalidate
(
&
entry
.
uv_rect_handle
)
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
if
let
Some
(
data
)
=
data
{
let
(
layer_index
origin
)
=
match
entry
.
kind
{
EntryKind
:
:
Standalone
{
.
.
}
=
>
(
0
DeviceUintPoint
:
:
zero
(
)
)
EntryKind
:
:
Cache
{
layer_index
origin
.
.
}
=
>
(
layer_index
origin
)
}
;
let
op
=
TextureUpdate
:
:
new_update
(
data
&
descriptor
origin
entry
.
size
entry
.
texture_id
layer_index
as
i32
dirty_rect
)
;
self
.
pending_updates
.
push
(
op
)
;
}
}
fn
get_region_mut
(
&
mut
self
format
:
ImageFormat
filter
:
TextureFilter
region_index
:
u16
)
-
>
&
mut
TextureRegion
{
let
texture_array
=
match
(
format
filter
)
{
(
ImageFormat
:
:
R8
TextureFilter
:
:
Linear
)
=
>
&
mut
self
.
array_a8_linear
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Linear
)
=
>
&
mut
self
.
array_rgba8_linear
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Nearest
)
=
>
&
mut
self
.
array_rgba8_nearest
(
ImageFormat
:
:
RGBAF32
_
)
|
(
ImageFormat
:
:
RG8
_
)
|
(
ImageFormat
:
:
R8
TextureFilter
:
:
Nearest
)
|
(
ImageFormat
:
:
R8
TextureFilter
:
:
Trilinear
)
|
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Trilinear
)
=
>
unreachable
!
(
)
}
;
&
mut
texture_array
.
regions
[
region_index
as
usize
]
}
pub
fn
is_allocated
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
bool
{
handle
.
entry
.
as_ref
(
)
.
map_or
(
false
|
handle
|
{
self
.
entries
.
get_opt
(
handle
)
.
is_some
(
)
}
)
}
pub
fn
get
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
CacheItem
{
match
handle
.
entry
{
Some
(
ref
handle
)
=
>
{
let
entry
=
self
.
entries
.
get_opt
(
handle
)
.
expect
(
"
BUG
:
was
dropped
from
cache
or
not
updated
!
"
)
;
debug_assert_eq
!
(
entry
.
last_access
self
.
frame_id
)
;
let
(
layer_index
origin
)
=
match
entry
.
kind
{
EntryKind
:
:
Standalone
{
.
.
}
=
>
{
(
0
DeviceUintPoint
:
:
zero
(
)
)
}
EntryKind
:
:
Cache
{
layer_index
origin
.
.
}
=
>
(
layer_index
origin
)
}
;
CacheItem
{
uv_rect_handle
:
entry
.
uv_rect_handle
texture_id
:
SourceTexture
:
:
TextureCache
(
entry
.
texture_id
)
uv_rect
:
DeviceUintRect
:
:
new
(
origin
entry
.
size
)
texture_layer
:
layer_index
as
i32
}
}
None
=
>
panic
!
(
"
BUG
:
handle
not
requested
earlier
in
frame
"
)
}
}
pub
fn
get_cache_location
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
(
SourceTexture
i32
DeviceUintRect
)
{
let
handle
=
handle
.
entry
.
as_ref
(
)
.
expect
(
"
BUG
:
handle
not
requested
earlier
in
frame
"
)
;
let
entry
=
self
.
entries
.
get_opt
(
handle
)
.
expect
(
"
BUG
:
was
dropped
from
cache
or
not
updated
!
"
)
;
debug_assert_eq
!
(
entry
.
last_access
self
.
frame_id
)
;
let
(
layer_index
origin
)
=
match
entry
.
kind
{
EntryKind
:
:
Standalone
{
.
.
}
=
>
{
(
0
DeviceUintPoint
:
:
zero
(
)
)
}
EntryKind
:
:
Cache
{
layer_index
origin
.
.
}
=
>
(
layer_index
origin
)
}
;
(
SourceTexture
:
:
TextureCache
(
entry
.
texture_id
)
layer_index
as
i32
DeviceUintRect
:
:
new
(
origin
entry
.
size
)
)
}
fn
expire_old_standalone_entries
(
&
mut
self
)
{
let
mut
eviction_candidates
=
Vec
:
:
new
(
)
;
let
mut
retained_entries
=
Vec
:
:
new
(
)
;
for
handle
in
self
.
standalone_entry_handles
.
drain
(
.
.
)
{
let
entry
=
self
.
entries
.
get
(
&
handle
)
;
if
entry
.
last_access
=
=
self
.
frame_id
{
retained_entries
.
push
(
handle
)
;
}
else
{
eviction_candidates
.
push
(
handle
)
;
}
}
eviction_candidates
.
sort_by_key
(
|
handle
|
{
let
entry
=
self
.
entries
.
get
(
handle
)
;
entry
.
last_access
}
)
;
if
eviction_candidates
.
len
(
)
>
32
{
let
entries_to_keep
=
eviction_candidates
.
split_off
(
32
)
;
retained_entries
.
extend
(
entries_to_keep
)
;
}
for
handle
in
eviction_candidates
{
let
entry
=
self
.
entries
.
free
(
handle
)
;
self
.
free
(
entry
)
;
}
self
.
standalone_entry_handles
=
retained_entries
;
}
fn
expire_old_shared_entries
(
&
mut
self
required_alloc
:
&
ImageDescriptor
)
{
let
mut
eviction_candidates
=
Vec
:
:
new
(
)
;
let
mut
retained_entries
=
Vec
:
:
new
(
)
;
for
handle
in
self
.
shared_entry_handles
.
drain
(
.
.
)
{
let
entry
=
self
.
entries
.
get
(
&
handle
)
;
if
entry
.
last_access
=
=
self
.
frame_id
{
retained_entries
.
push
(
handle
)
;
}
else
{
eviction_candidates
.
push
(
handle
)
;
}
}
eviction_candidates
.
sort_by_key
(
|
handle
|
{
let
entry
=
self
.
entries
.
get
(
handle
)
;
entry
.
last_access
}
)
;
let
needed_slab_size
=
SlabSize
:
:
new
(
required_alloc
.
width
required_alloc
.
height
)
.
get_size
(
)
;
let
mut
found_matching_slab
=
false
;
let
mut
freed_complete_page
=
false
;
let
mut
evicted_items
=
0
;
for
handle
in
eviction_candidates
{
if
evicted_items
>
512
&
&
(
found_matching_slab
|
|
freed_complete_page
)
{
retained_entries
.
push
(
handle
)
;
}
else
{
let
entry
=
self
.
entries
.
free
(
handle
)
;
if
let
Some
(
region
)
=
self
.
free
(
entry
)
{
found_matching_slab
|
=
region
.
slab_size
=
=
needed_slab_size
;
freed_complete_page
|
=
region
.
is_empty
(
)
;
}
evicted_items
+
=
1
;
}
}
self
.
shared_entry_handles
=
retained_entries
;
}
fn
free
(
&
mut
self
entry
:
CacheEntry
)
-
>
Option
<
&
TextureRegion
>
{
match
entry
.
kind
{
EntryKind
:
:
Standalone
{
.
.
}
=
>
{
self
.
pending_updates
.
push
(
TextureUpdate
{
id
:
entry
.
texture_id
op
:
TextureUpdateOp
:
:
Free
}
)
;
self
.
cache_textures
.
free
(
entry
.
texture_id
entry
.
format
)
;
None
}
EntryKind
:
:
Cache
{
origin
region_index
.
.
}
=
>
{
let
region
=
self
.
get_region_mut
(
entry
.
format
entry
.
filter
region_index
)
;
region
.
free
(
origin
)
;
Some
(
region
)
}
}
}
fn
allocate_from_shared_cache
(
&
mut
self
descriptor
:
&
ImageDescriptor
filter
:
TextureFilter
user_data
:
[
f32
;
3
]
)
-
>
Option
<
CacheEntry
>
{
let
texture_array
=
match
(
descriptor
.
format
filter
)
{
(
ImageFormat
:
:
R8
TextureFilter
:
:
Linear
)
=
>
&
mut
self
.
array_a8_linear
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Linear
)
=
>
&
mut
self
.
array_rgba8_linear
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Nearest
)
=
>
&
mut
self
.
array_rgba8_nearest
(
ImageFormat
:
:
RGBAF32
_
)
|
(
ImageFormat
:
:
R8
TextureFilter
:
:
Nearest
)
|
(
ImageFormat
:
:
R8
TextureFilter
:
:
Trilinear
)
|
(
ImageFormat
:
:
BGRA8
TextureFilter
:
:
Trilinear
)
|
(
ImageFormat
:
:
RG8
_
)
=
>
unreachable
!
(
)
}
;
if
texture_array
.
texture_id
.
is_none
(
)
{
let
texture_id
=
self
.
cache_textures
.
allocate
(
descriptor
.
format
)
;
let
update_op
=
TextureUpdate
{
id
:
texture_id
op
:
TextureUpdateOp
:
:
Create
{
width
:
TEXTURE_LAYER_DIMENSIONS
height
:
TEXTURE_LAYER_DIMENSIONS
format
:
descriptor
.
format
filter
:
texture_array
.
filter
render_target
:
Some
(
RenderTargetInfo
{
has_depth
:
false
}
)
layer_count
:
texture_array
.
layer_count
as
i32
}
}
;
self
.
pending_updates
.
push
(
update_op
)
;
texture_array
.
texture_id
=
Some
(
texture_id
)
;
}
texture_array
.
alloc
(
descriptor
.
width
descriptor
.
height
user_data
self
.
frame_id
)
}
pub
fn
is_allowed_in_shared_cache
(
&
self
filter
:
TextureFilter
descriptor
:
&
ImageDescriptor
)
-
>
bool
{
let
mut
allowed_in_shared_cache
=
true
;
if
filter
=
=
TextureFilter
:
:
Nearest
&
&
descriptor
.
format
!
=
ImageFormat
:
:
BGRA8
{
allowed_in_shared_cache
=
false
;
}
if
descriptor
.
width
>
512
|
|
descriptor
.
height
>
512
{
allowed_in_shared_cache
=
false
;
}
allowed_in_shared_cache
}
fn
allocate
(
&
mut
self
handle
:
&
mut
TextureCacheHandle
descriptor
:
ImageDescriptor
filter
:
TextureFilter
user_data
:
[
f32
;
3
]
)
{
assert
!
(
descriptor
.
width
>
0
&
&
descriptor
.
height
>
0
)
;
let
allowed_in_shared_cache
=
self
.
is_allowed_in_shared_cache
(
filter
&
descriptor
)
;
let
mut
allocated_in_shared_cache
=
true
;
let
mut
new_cache_entry
=
None
;
let
size
=
DeviceUintSize
:
:
new
(
descriptor
.
width
descriptor
.
height
)
;
let
frame_id
=
self
.
frame_id
;
if
allowed_in_shared_cache
{
new_cache_entry
=
self
.
allocate_from_shared_cache
(
&
descriptor
filter
user_data
)
;
if
new_cache_entry
.
is_none
(
)
{
self
.
expire_old_shared_entries
(
&
descriptor
)
;
new_cache_entry
=
self
.
allocate_from_shared_cache
(
&
descriptor
filter
user_data
)
;
}
}
if
new_cache_entry
.
is_none
(
)
{
let
texture_id
=
self
.
cache_textures
.
allocate
(
descriptor
.
format
)
;
let
update_op
=
TextureUpdate
{
id
:
texture_id
op
:
TextureUpdateOp
:
:
Create
{
width
:
descriptor
.
width
height
:
descriptor
.
height
format
:
descriptor
.
format
filter
render_target
:
Some
(
RenderTargetInfo
{
has_depth
:
false
}
)
layer_count
:
1
}
}
;
self
.
pending_updates
.
push
(
update_op
)
;
new_cache_entry
=
Some
(
CacheEntry
:
:
new_standalone
(
texture_id
size
descriptor
.
format
filter
user_data
frame_id
)
)
;
allocated_in_shared_cache
=
false
;
}
let
new_cache_entry
=
new_cache_entry
.
expect
(
"
BUG
:
must
have
allocated
by
now
"
)
;
let
new_entry_handle
=
match
handle
.
entry
{
Some
(
ref
existing_entry
)
=
>
{
match
self
.
entries
.
upsert
(
existing_entry
new_cache_entry
)
{
UpsertResult
:
:
Updated
(
old_entry
)
=
>
{
self
.
free
(
old_entry
)
;
None
}
UpsertResult
:
:
Inserted
(
new_handle
)
=
>
Some
(
new_handle
)
}
}
None
=
>
{
Some
(
self
.
entries
.
insert
(
new_cache_entry
)
)
}
}
;
if
let
Some
(
new_entry_handle
)
=
new_entry_handle
{
handle
.
entry
=
Some
(
new_entry_handle
.
weak
(
)
)
;
if
allocated_in_shared_cache
{
self
.
shared_entry_handles
.
push
(
new_entry_handle
)
;
}
else
{
self
.
standalone_entry_handles
.
push
(
new_entry_handle
)
;
}
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
)
]
enum
SlabSize
{
Size16x16
Size32x32
Size64x64
Size128x128
Size256x256
Size512x512
}
impl
SlabSize
{
fn
new
(
width
:
u32
height
:
u32
)
-
>
SlabSize
{
let
max_dim
=
cmp
:
:
max
(
width
height
)
;
match
max_dim
{
0
=
>
unreachable
!
(
)
1
.
.
.
16
=
>
SlabSize
:
:
Size16x16
17
.
.
.
32
=
>
SlabSize
:
:
Size32x32
33
.
.
.
64
=
>
SlabSize
:
:
Size64x64
65
.
.
.
128
=
>
SlabSize
:
:
Size128x128
129
.
.
.
256
=
>
SlabSize
:
:
Size256x256
257
.
.
.
512
=
>
SlabSize
:
:
Size512x512
_
=
>
panic
!
(
"
Invalid
dimensions
for
cache
!
"
)
}
}
fn
get_size
(
&
self
)
-
>
u32
{
match
*
self
{
SlabSize
:
:
Size16x16
=
>
16
SlabSize
:
:
Size32x32
=
>
32
SlabSize
:
:
Size64x64
=
>
64
SlabSize
:
:
Size128x128
=
>
128
SlabSize
:
:
Size256x256
=
>
256
SlabSize
:
:
Size512x512
=
>
512
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureLocation
(
u8
u8
)
;
impl
TextureLocation
{
fn
new
(
x
:
u32
y
:
u32
)
-
>
Self
{
debug_assert
!
(
x
<
0x100
&
&
y
<
0x100
)
;
TextureLocation
(
x
as
u8
y
as
u8
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureRegion
{
layer_index
:
i32
region_size
:
u32
slab_size
:
u32
free_slots
:
Vec
<
TextureLocation
>
slots_per_axis
:
u32
total_slot_count
:
usize
origin
:
DeviceUintPoint
}
impl
TextureRegion
{
fn
new
(
region_size
:
u32
layer_index
:
i32
origin
:
DeviceUintPoint
)
-
>
Self
{
TextureRegion
{
layer_index
region_size
slab_size
:
0
free_slots
:
Vec
:
:
new
(
)
slots_per_axis
:
0
total_slot_count
:
0
origin
}
}
fn
init
(
&
mut
self
slab_size
:
SlabSize
)
{
debug_assert
!
(
self
.
slab_size
=
=
0
)
;
debug_assert
!
(
self
.
free_slots
.
is_empty
(
)
)
;
self
.
slab_size
=
slab_size
.
get_size
(
)
;
self
.
slots_per_axis
=
self
.
region_size
/
self
.
slab_size
;
for
y
in
0
.
.
self
.
slots_per_axis
{
for
x
in
0
.
.
self
.
slots_per_axis
{
self
.
free_slots
.
push
(
TextureLocation
:
:
new
(
x
y
)
)
;
}
}
self
.
total_slot_count
=
self
.
free_slots
.
len
(
)
;
}
fn
deinit
(
&
mut
self
)
{
self
.
slab_size
=
0
;
self
.
free_slots
.
clear
(
)
;
self
.
slots_per_axis
=
0
;
self
.
total_slot_count
=
0
;
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
slab_size
=
=
0
}
fn
alloc
(
&
mut
self
)
-
>
Option
<
DeviceUintPoint
>
{
self
.
free_slots
.
pop
(
)
.
map
(
|
location
|
{
DeviceUintPoint
:
:
new
(
self
.
origin
.
x
+
self
.
slab_size
*
location
.
0
as
u32
self
.
origin
.
y
+
self
.
slab_size
*
location
.
1
as
u32
)
}
)
}
fn
free
(
&
mut
self
point
:
DeviceUintPoint
)
{
let
x
=
(
point
.
x
-
self
.
origin
.
x
)
/
self
.
slab_size
;
let
y
=
(
point
.
y
-
self
.
origin
.
y
)
/
self
.
slab_size
;
self
.
free_slots
.
push
(
TextureLocation
:
:
new
(
x
y
)
)
;
if
self
.
free_slots
.
len
(
)
=
=
self
.
total_slot_count
{
self
.
deinit
(
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureArray
{
filter
:
TextureFilter
layer_count
:
usize
format
:
ImageFormat
is_allocated
:
bool
regions
:
Vec
<
TextureRegion
>
texture_id
:
Option
<
CacheTextureId
>
}
impl
TextureArray
{
fn
new
(
format
:
ImageFormat
filter
:
TextureFilter
layer_count
:
usize
)
-
>
Self
{
TextureArray
{
format
filter
layer_count
is_allocated
:
false
regions
:
Vec
:
:
new
(
)
texture_id
:
None
}
}
fn
update_profile
(
&
self
counter
:
&
mut
ResourceProfileCounter
)
{
if
self
.
is_allocated
{
let
size
=
self
.
layer_count
as
u32
*
TEXTURE_LAYER_DIMENSIONS
*
TEXTURE_LAYER_DIMENSIONS
*
self
.
format
.
bytes_per_pixel
(
)
;
counter
.
set
(
self
.
layer_count
as
usize
size
as
usize
)
;
}
else
{
counter
.
set
(
0
0
)
;
}
}
fn
alloc
(
&
mut
self
width
:
u32
height
:
u32
user_data
:
[
f32
;
3
]
frame_id
:
FrameId
)
-
>
Option
<
CacheEntry
>
{
if
!
self
.
is_allocated
{
debug_assert
!
(
TEXTURE_LAYER_DIMENSIONS
%
TEXTURE_REGION_DIMENSIONS
=
=
0
)
;
let
regions_per_axis
=
TEXTURE_LAYER_DIMENSIONS
/
TEXTURE_REGION_DIMENSIONS
;
for
layer_index
in
0
.
.
self
.
layer_count
{
for
y
in
0
.
.
regions_per_axis
{
for
x
in
0
.
.
regions_per_axis
{
let
origin
=
DeviceUintPoint
:
:
new
(
x
*
TEXTURE_REGION_DIMENSIONS
y
*
TEXTURE_REGION_DIMENSIONS
)
;
let
region
=
TextureRegion
:
:
new
(
TEXTURE_REGION_DIMENSIONS
layer_index
as
i32
origin
)
;
self
.
regions
.
push
(
region
)
;
}
}
}
self
.
is_allocated
=
true
;
}
let
slab_size
=
SlabSize
:
:
new
(
width
height
)
;
let
slab_size_dim
=
slab_size
.
get_size
(
)
;
let
mut
empty_region_index
=
None
;
let
mut
entry_kind
=
None
;
for
(
i
region
)
in
self
.
regions
.
iter_mut
(
)
.
enumerate
(
)
{
if
region
.
slab_size
=
=
0
{
empty_region_index
=
Some
(
i
)
;
}
else
if
region
.
slab_size
=
=
slab_size_dim
{
if
let
Some
(
location
)
=
region
.
alloc
(
)
{
entry_kind
=
Some
(
EntryKind
:
:
Cache
{
layer_index
:
region
.
layer_index
as
u16
region_index
:
i
as
u16
origin
:
location
}
)
;
break
;
}
}
}
if
entry_kind
.
is_none
(
)
{
if
let
Some
(
empty_region_index
)
=
empty_region_index
{
let
region
=
&
mut
self
.
regions
[
empty_region_index
]
;
region
.
init
(
slab_size
)
;
entry_kind
=
region
.
alloc
(
)
.
map
(
|
location
|
{
EntryKind
:
:
Cache
{
layer_index
:
region
.
layer_index
as
u16
region_index
:
empty_region_index
as
u16
origin
:
location
}
}
)
;
}
}
entry_kind
.
map
(
|
kind
|
{
CacheEntry
{
size
:
DeviceUintSize
:
:
new
(
width
height
)
user_data
last_access
:
frame_id
kind
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
format
:
self
.
format
filter
:
self
.
filter
texture_id
:
self
.
texture_id
.
unwrap
(
)
}
}
)
}
}
impl
TextureUpdate
{
fn
new_update
(
data
:
ImageData
descriptor
:
&
ImageDescriptor
origin
:
DeviceUintPoint
size
:
DeviceUintSize
texture_id
:
CacheTextureId
layer_index
:
i32
dirty_rect
:
Option
<
DeviceUintRect
>
)
-
>
TextureUpdate
{
let
data_src
=
match
data
{
ImageData
:
:
Blob
(
.
.
)
=
>
{
panic
!
(
"
The
vector
image
should
have
been
rasterized
.
"
)
;
}
ImageData
:
:
External
(
ext_image
)
=
>
match
ext_image
.
image_type
{
ExternalImageType
:
:
TextureHandle
(
_
)
=
>
{
panic
!
(
"
External
texture
handle
should
not
go
through
texture_cache
.
"
)
;
}
ExternalImageType
:
:
Buffer
=
>
TextureUpdateSource
:
:
External
{
id
:
ext_image
.
id
channel_index
:
ext_image
.
channel_index
}
}
ImageData
:
:
Raw
(
bytes
)
=
>
{
let
finish
=
descriptor
.
offset
+
descriptor
.
width
*
descriptor
.
format
.
bytes_per_pixel
(
)
+
(
descriptor
.
height
-
1
)
*
descriptor
.
compute_stride
(
)
;
assert
!
(
bytes
.
len
(
)
>
=
finish
as
usize
)
;
TextureUpdateSource
:
:
Bytes
{
data
:
bytes
}
}
}
;
let
update_op
=
match
dirty_rect
{
Some
(
dirty
)
=
>
{
let
stride
=
descriptor
.
compute_stride
(
)
;
let
offset
=
descriptor
.
offset
+
dirty
.
origin
.
y
*
stride
+
dirty
.
origin
.
x
*
descriptor
.
format
.
bytes_per_pixel
(
)
;
let
origin
=
DeviceUintPoint
:
:
new
(
origin
.
x
+
dirty
.
origin
.
x
origin
.
y
+
dirty
.
origin
.
y
)
;
TextureUpdateOp
:
:
Update
{
rect
:
DeviceUintRect
:
:
new
(
origin
dirty
.
size
)
source
:
data_src
stride
:
Some
(
stride
)
offset
layer_index
}
}
None
=
>
TextureUpdateOp
:
:
Update
{
rect
:
DeviceUintRect
:
:
new
(
origin
size
)
source
:
data_src
stride
:
descriptor
.
stride
offset
:
descriptor
.
offset
layer_index
}
}
;
TextureUpdate
{
id
:
texture_id
op
:
update_op
}
}
}
