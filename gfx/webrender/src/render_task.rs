use
api
:
:
{
DeviceIntPoint
DeviceIntRect
DeviceIntSize
ImageDescriptor
ImageFormat
}
;
use
api
:
:
{
DeviceSize
PremultipliedColorF
}
;
use
box_shadow
:
:
{
BoxShadowCacheKey
}
;
use
clip
:
:
{
ClipSource
ClipStore
ClipWorkItem
}
;
use
clip_scroll_tree
:
:
CoordinateSystemId
;
use
device
:
:
TextureFilter
;
use
gpu_cache
:
:
{
GpuCache
GpuCacheAddress
GpuCacheHandle
}
;
use
gpu_types
:
:
{
ImageSource
PictureType
RasterizationSpace
}
;
use
internal_types
:
:
{
FastHashMap
SavedTargetIndex
SourceTexture
}
;
use
prim_store
:
:
{
PrimitiveIndex
ImageCacheKey
}
;
#
[
cfg
(
feature
=
"
debugger
"
)
]
use
print_tree
:
:
{
PrintTreePrinter
}
;
use
resource_cache
:
:
{
CacheItem
ResourceCache
}
;
use
std
:
:
{
cmp
ops
usize
f32
i32
}
;
use
texture_cache
:
:
{
TextureCache
TextureCacheHandle
}
;
use
tiling
:
:
{
RenderPass
RenderTargetIndex
}
;
use
tiling
:
:
{
RenderTargetKind
}
;
const
FLOATS_PER_RENDER_TASK_INFO
:
usize
=
12
;
pub
const
MAX_BLUR_STD_DEVIATION
:
f32
=
4
.
0
;
pub
const
MIN_DOWNSCALING_RT_SIZE
:
i32
=
128
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskId
(
pub
u32
)
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskAddress
(
pub
u32
)
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskTree
{
pub
tasks
:
Vec
<
RenderTask
>
pub
task_data
:
Vec
<
RenderTaskData
>
next_saved
:
SavedTargetIndex
}
impl
RenderTaskTree
{
pub
fn
new
(
)
-
>
Self
{
RenderTaskTree
{
tasks
:
Vec
:
:
new
(
)
task_data
:
Vec
:
:
new
(
)
next_saved
:
SavedTargetIndex
(
0
)
}
}
pub
fn
add
(
&
mut
self
task
:
RenderTask
)
-
>
RenderTaskId
{
let
id
=
RenderTaskId
(
self
.
tasks
.
len
(
)
as
u32
)
;
self
.
tasks
.
push
(
task
)
;
id
}
pub
fn
max_depth
(
&
self
id
:
RenderTaskId
depth
:
usize
max_depth
:
&
mut
usize
)
{
let
depth
=
depth
+
1
;
*
max_depth
=
cmp
:
:
max
(
*
max_depth
depth
)
;
let
task
=
&
self
.
tasks
[
id
.
0
as
usize
]
;
for
child
in
&
task
.
children
{
self
.
max_depth
(
*
child
depth
max_depth
)
;
}
}
pub
fn
assign_to_passes
(
&
self
id
:
RenderTaskId
pass_index
:
usize
passes
:
&
mut
Vec
<
RenderPass
>
)
{
let
task
=
&
self
.
tasks
[
id
.
0
as
usize
]
;
for
child
in
&
task
.
children
{
self
.
assign_to_passes
(
*
child
pass_index
-
1
passes
)
;
}
match
task
.
location
{
RenderTaskLocation
:
:
Fixed
(
.
.
)
=
>
{
debug_assert
!
(
pass_index
=
=
passes
.
len
(
)
-
1
)
;
}
RenderTaskLocation
:
:
Dynamic
(
.
.
)
|
RenderTaskLocation
:
:
TextureCache
(
.
.
)
=
>
{
debug_assert
!
(
pass_index
<
passes
.
len
(
)
-
1
)
;
}
}
let
pass_index
=
if
task
.
is_shared
(
)
{
debug_assert
!
(
task
.
children
.
is_empty
(
)
)
;
0
}
else
{
pass_index
}
;
let
pass
=
&
mut
passes
[
pass_index
]
;
pass
.
add_render_task
(
id
task
.
get_dynamic_size
(
)
task
.
target_kind
(
)
)
;
}
pub
fn
get_task_address
(
&
self
id
:
RenderTaskId
)
-
>
RenderTaskAddress
{
RenderTaskAddress
(
id
.
0
)
}
pub
fn
build
(
&
mut
self
)
{
for
task
in
&
self
.
tasks
{
self
.
task_data
.
push
(
task
.
write_task_data
(
)
)
;
}
}
pub
fn
save_target
(
&
mut
self
)
-
>
SavedTargetIndex
{
let
id
=
self
.
next_saved
;
self
.
next_saved
.
0
+
=
1
;
id
}
}
impl
ops
:
:
Index
<
RenderTaskId
>
for
RenderTaskTree
{
type
Output
=
RenderTask
;
fn
index
(
&
self
id
:
RenderTaskId
)
-
>
&
RenderTask
{
&
self
.
tasks
[
id
.
0
as
usize
]
}
}
impl
ops
:
:
IndexMut
<
RenderTaskId
>
for
RenderTaskTree
{
fn
index_mut
(
&
mut
self
id
:
RenderTaskId
)
-
>
&
mut
RenderTask
{
&
mut
self
.
tasks
[
id
.
0
as
usize
]
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskLocation
{
Fixed
(
DeviceIntRect
)
Dynamic
(
Option
<
(
DeviceIntPoint
RenderTargetIndex
)
>
DeviceIntSize
)
TextureCache
(
SourceTexture
i32
DeviceIntRect
)
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheMaskTask
{
actual_rect
:
DeviceIntRect
pub
clips
:
Vec
<
ClipWorkItem
>
pub
coordinate_system_id
:
CoordinateSystemId
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ClipRegionTask
{
pub
clip_data_address
:
GpuCacheAddress
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureTask
{
pub
prim_index
:
PrimitiveIndex
pub
target_kind
:
RenderTargetKind
pub
content_origin
:
DeviceIntPoint
pub
color
:
PremultipliedColorF
pub
pic_type
:
PictureType
pub
uv_rect_handle
:
GpuCacheHandle
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BlurTask
{
pub
blur_std_deviation
:
f32
pub
target_kind
:
RenderTargetKind
pub
uv_rect_handle
:
GpuCacheHandle
}
impl
BlurTask
{
#
[
cfg
(
feature
=
"
debugger
"
)
]
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
)
{
pt
.
add_item
(
format
!
(
"
std
deviation
:
{
}
"
self
.
blur_std_deviation
)
)
;
pt
.
add_item
(
format
!
(
"
target
:
{
:
?
}
"
self
.
target_kind
)
)
;
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BlitSource
{
Image
{
key
:
ImageCacheKey
}
RenderTask
{
task_id
:
RenderTaskId
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BlitTask
{
pub
source
:
BlitSource
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskData
{
pub
data
:
[
f32
;
FLOATS_PER_RENDER_TASK_INFO
]
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskKind
{
Picture
(
PictureTask
)
CacheMask
(
CacheMaskTask
)
ClipRegion
(
ClipRegionTask
)
VerticalBlur
(
BlurTask
)
HorizontalBlur
(
BlurTask
)
Readback
(
DeviceIntRect
)
Scaling
(
RenderTargetKind
)
Blit
(
BlitTask
)
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ClearMode
{
Zero
One
Transparent
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTask
{
pub
location
:
RenderTaskLocation
pub
children
:
Vec
<
RenderTaskId
>
pub
kind
:
RenderTaskKind
pub
clear_mode
:
ClearMode
pub
saved_index
:
Option
<
SavedTargetIndex
>
}
impl
RenderTask
{
pub
fn
new_picture
(
location
:
RenderTaskLocation
prim_index
:
PrimitiveIndex
target_kind
:
RenderTargetKind
content_origin
:
DeviceIntPoint
color
:
PremultipliedColorF
clear_mode
:
ClearMode
children
:
Vec
<
RenderTaskId
>
pic_type
:
PictureType
)
-
>
Self
{
RenderTask
{
children
location
kind
:
RenderTaskKind
:
:
Picture
(
PictureTask
{
prim_index
target_kind
content_origin
color
pic_type
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
}
)
clear_mode
saved_index
:
None
}
}
pub
fn
new_readback
(
screen_rect
:
DeviceIntRect
)
-
>
Self
{
RenderTask
{
children
:
Vec
:
:
new
(
)
location
:
RenderTaskLocation
:
:
Dynamic
(
None
screen_rect
.
size
)
kind
:
RenderTaskKind
:
:
Readback
(
screen_rect
)
clear_mode
:
ClearMode
:
:
Transparent
saved_index
:
None
}
}
pub
fn
new_blit
(
size
:
DeviceIntSize
source
:
BlitSource
)
-
>
Self
{
let
mut
children
=
Vec
:
:
new
(
)
;
if
let
BlitSource
:
:
RenderTask
{
task_id
}
=
source
{
children
.
push
(
task_id
)
;
}
RenderTask
{
children
location
:
RenderTaskLocation
:
:
Dynamic
(
None
size
)
kind
:
RenderTaskKind
:
:
Blit
(
BlitTask
{
source
}
)
clear_mode
:
ClearMode
:
:
Transparent
saved_index
:
None
}
}
pub
fn
new_mask
(
outer_rect
:
DeviceIntRect
clips
:
Vec
<
ClipWorkItem
>
prim_coordinate_system_id
:
CoordinateSystemId
clip_store
:
&
mut
ClipStore
gpu_cache
:
&
mut
GpuCache
resource_cache
:
&
mut
ResourceCache
render_tasks
:
&
mut
RenderTaskTree
)
-
>
Self
{
let
mut
children
=
Vec
:
:
new
(
)
;
for
clip_item
in
&
clips
{
let
clip_sources
=
clip_store
.
get_opt_mut
(
&
clip_item
.
clip_sources
)
.
expect
(
"
bug
"
)
;
for
&
mut
(
ref
mut
clip
_
)
in
&
mut
clip_sources
.
clips
{
match
*
clip
{
ClipSource
:
:
BoxShadow
(
ref
mut
info
)
=
>
{
let
(
cache_size
cache_key
)
=
info
.
cache_key
.
as_ref
(
)
.
expect
(
"
bug
:
no
cache
key
set
"
)
.
clone
(
)
;
let
blur_radius_dp
=
cache_key
.
blur_radius_dp
as
f32
;
let
clip_data_address
=
gpu_cache
.
get_address
(
&
info
.
clip_data_handle
)
;
info
.
cache_item
=
resource_cache
.
request_render_task
(
RenderTaskCacheKey
{
size
:
cache_size
kind
:
RenderTaskCacheKeyKind
:
:
BoxShadow
(
cache_key
)
}
gpu_cache
render_tasks
|
render_tasks
|
{
let
mask_task
=
RenderTask
:
:
new_rounded_rect_mask
(
cache_size
clip_data_address
)
;
let
mask_task_id
=
render_tasks
.
add
(
mask_task
)
;
let
blur_render_task
=
RenderTask
:
:
new_blur
(
blur_radius_dp
mask_task_id
render_tasks
RenderTargetKind
:
:
Alpha
ClearMode
:
:
Zero
)
;
let
root_task_id
=
render_tasks
.
add
(
blur_render_task
)
;
children
.
push
(
root_task_id
)
;
(
root_task_id
false
)
}
)
;
}
ClipSource
:
:
Rectangle
(
.
.
)
|
ClipSource
:
:
RoundedRectangle
(
.
.
)
|
ClipSource
:
:
Image
(
.
.
)
|
ClipSource
:
:
BorderCorner
(
.
.
)
=
>
{
}
}
}
}
RenderTask
{
children
location
:
RenderTaskLocation
:
:
Dynamic
(
None
outer_rect
.
size
)
kind
:
RenderTaskKind
:
:
CacheMask
(
CacheMaskTask
{
actual_rect
:
outer_rect
clips
coordinate_system_id
:
prim_coordinate_system_id
}
)
clear_mode
:
ClearMode
:
:
One
saved_index
:
None
}
}
pub
fn
new_rounded_rect_mask
(
size
:
DeviceIntSize
clip_data_address
:
GpuCacheAddress
)
-
>
Self
{
RenderTask
{
children
:
Vec
:
:
new
(
)
location
:
RenderTaskLocation
:
:
Dynamic
(
None
size
)
kind
:
RenderTaskKind
:
:
ClipRegion
(
ClipRegionTask
{
clip_data_address
}
)
clear_mode
:
ClearMode
:
:
One
saved_index
:
None
}
}
pub
fn
new_blur
(
blur_std_deviation
:
f32
src_task_id
:
RenderTaskId
render_tasks
:
&
mut
RenderTaskTree
target_kind
:
RenderTargetKind
clear_mode
:
ClearMode
)
-
>
Self
{
let
mut
adjusted_blur_std_deviation
=
blur_std_deviation
;
let
blur_target_size
=
render_tasks
[
src_task_id
]
.
get_dynamic_size
(
)
;
let
mut
adjusted_blur_target_size
=
blur_target_size
;
let
mut
downscaling_src_task_id
=
src_task_id
;
let
mut
scale_factor
=
1
.
0
;
while
adjusted_blur_std_deviation
>
MAX_BLUR_STD_DEVIATION
{
if
adjusted_blur_target_size
.
width
<
MIN_DOWNSCALING_RT_SIZE
|
|
adjusted_blur_target_size
.
height
<
MIN_DOWNSCALING_RT_SIZE
{
break
;
}
adjusted_blur_std_deviation
*
=
0
.
5
;
scale_factor
*
=
2
.
0
;
adjusted_blur_target_size
=
(
blur_target_size
.
to_f32
(
)
/
scale_factor
)
.
to_i32
(
)
;
let
downscaling_task
=
RenderTask
:
:
new_scaling
(
target_kind
downscaling_src_task_id
adjusted_blur_target_size
)
;
downscaling_src_task_id
=
render_tasks
.
add
(
downscaling_task
)
;
}
let
blur_task_v
=
RenderTask
{
children
:
vec
!
[
downscaling_src_task_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
adjusted_blur_target_size
)
kind
:
RenderTaskKind
:
:
VerticalBlur
(
BlurTask
{
blur_std_deviation
:
adjusted_blur_std_deviation
target_kind
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
}
)
clear_mode
saved_index
:
None
}
;
let
blur_task_v_id
=
render_tasks
.
add
(
blur_task_v
)
;
let
blur_task_h
=
RenderTask
{
children
:
vec
!
[
blur_task_v_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
adjusted_blur_target_size
)
kind
:
RenderTaskKind
:
:
HorizontalBlur
(
BlurTask
{
blur_std_deviation
:
adjusted_blur_std_deviation
target_kind
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
}
)
clear_mode
saved_index
:
None
}
;
blur_task_h
}
pub
fn
new_scaling
(
target_kind
:
RenderTargetKind
src_task_id
:
RenderTaskId
target_size
:
DeviceIntSize
)
-
>
Self
{
RenderTask
{
children
:
vec
!
[
src_task_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
target_size
)
kind
:
RenderTaskKind
:
:
Scaling
(
target_kind
)
clear_mode
:
match
target_kind
{
RenderTargetKind
:
:
Color
=
>
ClearMode
:
:
Transparent
RenderTargetKind
:
:
Alpha
=
>
ClearMode
:
:
One
}
saved_index
:
None
}
}
pub
fn
write_task_data
(
&
self
)
-
>
RenderTaskData
{
let
(
data1
data2
)
=
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
task
)
=
>
{
(
[
task
.
content_origin
.
x
as
f32
task
.
content_origin
.
y
as
f32
task
.
pic_type
as
u32
as
f32
]
task
.
color
.
to_array
(
)
)
}
RenderTaskKind
:
:
CacheMask
(
ref
task
)
=
>
{
(
[
task
.
actual_rect
.
origin
.
x
as
f32
task
.
actual_rect
.
origin
.
y
as
f32
RasterizationSpace
:
:
Screen
as
i32
as
f32
]
[
0
.
0
;
4
]
)
}
RenderTaskKind
:
:
ClipRegion
(
.
.
)
=
>
{
(
[
0
.
0
0
.
0
RasterizationSpace
:
:
Local
as
i32
as
f32
]
[
0
.
0
;
4
]
)
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task
)
|
RenderTaskKind
:
:
HorizontalBlur
(
ref
task
)
=
>
{
(
[
task
.
blur_std_deviation
0
.
0
0
.
0
]
[
0
.
0
;
4
]
)
}
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
{
(
[
0
.
0
;
3
]
[
0
.
0
;
4
]
)
}
}
;
let
(
target_rect
target_index
)
=
self
.
get_target_rect
(
)
;
RenderTaskData
{
data
:
[
target_rect
.
origin
.
x
as
f32
target_rect
.
origin
.
y
as
f32
target_rect
.
size
.
width
as
f32
target_rect
.
size
.
height
as
f32
target_index
.
0
as
f32
data1
[
0
]
data1
[
1
]
data1
[
2
]
data2
[
0
]
data2
[
1
]
data2
[
2
]
data2
[
3
]
]
}
}
pub
fn
get_texture_handle
(
&
self
)
-
>
&
GpuCacheHandle
{
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
&
info
.
uv_rect_handle
}
RenderTaskKind
:
:
VerticalBlur
(
ref
info
)
|
RenderTaskKind
:
:
HorizontalBlur
(
ref
info
)
=
>
{
&
info
.
uv_rect_handle
}
RenderTaskKind
:
:
ClipRegion
(
.
.
)
|
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
|
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
{
panic
!
(
"
texture
handle
not
supported
for
this
task
kind
"
)
;
}
}
}
pub
fn
get_dynamic_size
(
&
self
)
-
>
DeviceIntSize
{
match
self
.
location
{
RenderTaskLocation
:
:
Fixed
(
.
.
)
=
>
DeviceIntSize
:
:
zero
(
)
RenderTaskLocation
:
:
Dynamic
(
_
size
)
=
>
size
RenderTaskLocation
:
:
TextureCache
(
_
_
rect
)
=
>
rect
.
size
}
}
pub
fn
get_target_rect
(
&
self
)
-
>
(
DeviceIntRect
RenderTargetIndex
)
{
match
self
.
location
{
RenderTaskLocation
:
:
Fixed
(
rect
)
=
>
{
(
rect
RenderTargetIndex
(
0
)
)
}
RenderTaskLocation
:
:
Dynamic
(
Some
(
(
origin
target_index
)
)
size
)
=
>
{
(
DeviceIntRect
:
:
new
(
origin
size
)
target_index
)
}
RenderTaskLocation
:
:
Dynamic
(
None
_
)
=
>
{
(
DeviceIntRect
:
:
zero
(
)
RenderTargetIndex
(
0
)
)
}
RenderTaskLocation
:
:
TextureCache
(
_
layer
rect
)
=
>
{
(
rect
RenderTargetIndex
(
layer
as
usize
)
)
}
}
}
pub
fn
target_kind
(
&
self
)
-
>
RenderTargetKind
{
match
self
.
kind
{
RenderTaskKind
:
:
Readback
(
.
.
)
=
>
RenderTargetKind
:
:
Color
RenderTaskKind
:
:
ClipRegion
(
.
.
)
|
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
{
RenderTargetKind
:
:
Alpha
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task_info
)
|
RenderTaskKind
:
:
HorizontalBlur
(
ref
task_info
)
=
>
{
task_info
.
target_kind
}
RenderTaskKind
:
:
Scaling
(
target_kind
)
=
>
{
target_kind
}
RenderTaskKind
:
:
Picture
(
ref
task_info
)
=
>
{
task_info
.
target_kind
}
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
{
RenderTargetKind
:
:
Color
}
}
}
pub
fn
is_shared
(
&
self
)
-
>
bool
{
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
.
.
)
|
RenderTaskKind
:
:
VerticalBlur
(
.
.
)
|
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
HorizontalBlur
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
ClipRegion
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
false
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
false
}
}
pub
fn
prepare_for_render
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
)
{
let
(
target_rect
target_index
)
=
self
.
get_target_rect
(
)
;
let
cache_handle
=
match
self
.
kind
{
RenderTaskKind
:
:
HorizontalBlur
(
ref
mut
info
)
|
RenderTaskKind
:
:
VerticalBlur
(
ref
mut
info
)
=
>
{
&
mut
info
.
uv_rect_handle
}
RenderTaskKind
:
:
Picture
(
ref
mut
info
)
=
>
{
&
mut
info
.
uv_rect_handle
}
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
|
RenderTaskKind
:
:
ClipRegion
(
.
.
)
|
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
{
return
;
}
}
;
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
cache_handle
)
{
let
image_source
=
ImageSource
{
p0
:
target_rect
.
origin
.
to_f32
(
)
p1
:
target_rect
.
bottom_right
(
)
.
to_f32
(
)
texture_layer
:
target_index
.
0
as
f32
user_data
:
[
0
.
0
;
3
]
}
;
image_source
.
write_gpu_blocks
(
&
mut
request
)
;
}
}
#
[
cfg
(
feature
=
"
debugger
"
)
]
pub
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
tree
:
&
RenderTaskTree
)
-
>
bool
{
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
task
)
=
>
{
pt
.
new_level
(
format
!
(
"
Picture
of
{
:
?
}
"
task
.
prim_index
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
task
.
target_kind
)
)
;
}
RenderTaskKind
:
:
CacheMask
(
ref
task
)
=
>
{
pt
.
new_level
(
format
!
(
"
CacheMask
with
{
}
clips
"
task
.
clips
.
len
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
rect
:
{
:
?
}
"
task
.
actual_rect
)
)
;
}
RenderTaskKind
:
:
ClipRegion
(
.
.
)
=
>
{
pt
.
new_level
(
"
ClipRegion
"
.
to_owned
(
)
)
;
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task
)
=
>
{
pt
.
new_level
(
"
VerticalBlur
"
.
to_owned
(
)
)
;
task
.
print_with
(
pt
)
;
}
RenderTaskKind
:
:
HorizontalBlur
(
ref
task
)
=
>
{
pt
.
new_level
(
"
HorizontalBlur
"
.
to_owned
(
)
)
;
task
.
print_with
(
pt
)
;
}
RenderTaskKind
:
:
Readback
(
ref
rect
)
=
>
{
pt
.
new_level
(
"
Readback
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
rect
:
{
:
?
}
"
rect
)
)
;
}
RenderTaskKind
:
:
Scaling
(
ref
kind
)
=
>
{
pt
.
new_level
(
"
Scaling
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
kind
)
)
;
}
RenderTaskKind
:
:
Blit
(
ref
task
)
=
>
{
pt
.
new_level
(
"
Blit
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
source
:
{
:
?
}
"
task
.
source
)
)
;
}
}
pt
.
add_item
(
format
!
(
"
clear
to
:
{
:
?
}
"
self
.
clear_mode
)
)
;
for
&
child_id
in
&
self
.
children
{
if
tree
[
child_id
]
.
print_with
(
pt
tree
)
{
pt
.
add_item
(
format
!
(
"
self
:
{
:
?
}
"
child_id
)
)
}
}
pt
.
end_level
(
)
;
true
}
pub
fn
mark_for_saving
(
&
mut
self
)
{
match
self
.
location
{
RenderTaskLocation
:
:
Fixed
(
.
.
)
|
RenderTaskLocation
:
:
Dynamic
(
.
.
)
=
>
{
self
.
saved_index
=
Some
(
SavedTargetIndex
:
:
PENDING
)
;
}
RenderTaskLocation
:
:
TextureCache
(
.
.
)
=
>
{
panic
!
(
"
Unable
to
mark
a
permanently
cached
task
for
saving
!
"
)
;
}
}
}
}
#
[
derive
(
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskCacheKeyKind
{
BoxShadow
(
BoxShadowCacheKey
)
Image
(
ImageCacheKey
)
}
#
[
derive
(
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskCacheKey
{
pub
size
:
DeviceIntSize
pub
kind
:
RenderTaskCacheKeyKind
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
RenderTaskCacheEntry
{
handle
:
TextureCacheHandle
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskCache
{
entries
:
FastHashMap
<
RenderTaskCacheKey
RenderTaskCacheEntry
>
}
impl
RenderTaskCache
{
pub
fn
new
(
)
-
>
Self
{
RenderTaskCache
{
entries
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
pub
fn
begin_frame
(
&
mut
self
texture_cache
:
&
mut
TextureCache
)
{
self
.
entries
.
retain
(
|
_
value
|
{
texture_cache
.
is_allocated
(
&
value
.
handle
)
}
)
;
}
pub
fn
request_render_task
<
F
>
(
&
mut
self
key
:
RenderTaskCacheKey
texture_cache
:
&
mut
TextureCache
gpu_cache
:
&
mut
GpuCache
render_tasks
:
&
mut
RenderTaskTree
mut
f
:
F
)
-
>
CacheItem
where
F
:
FnMut
(
&
mut
RenderTaskTree
)
-
>
(
RenderTaskId
bool
)
{
let
cache_entry
=
self
.
entries
.
entry
(
key
)
.
or_insert
(
RenderTaskCacheEntry
{
handle
:
TextureCacheHandle
:
:
new
(
)
}
)
;
if
texture_cache
.
request
(
&
mut
cache_entry
.
handle
gpu_cache
)
{
let
(
render_task_id
is_opaque
)
=
f
(
render_tasks
)
;
let
render_task
=
&
mut
render_tasks
[
render_task_id
]
;
let
image_format
=
match
render_task
.
target_kind
(
)
{
RenderTargetKind
:
:
Color
=
>
ImageFormat
:
:
BGRA8
RenderTargetKind
:
:
Alpha
=
>
ImageFormat
:
:
R8
}
;
let
size
=
match
render_task
.
location
{
RenderTaskLocation
:
:
Fixed
(
.
.
)
|
RenderTaskLocation
:
:
TextureCache
(
.
.
)
=
>
{
panic
!
(
"
BUG
:
dynamic
task
was
expected
"
)
;
}
RenderTaskLocation
:
:
Dynamic
(
_
size
)
=
>
size
}
;
let
descriptor
=
ImageDescriptor
:
:
new
(
size
.
width
as
u32
size
.
height
as
u32
image_format
is_opaque
false
)
;
texture_cache
.
update
(
&
mut
cache_entry
.
handle
descriptor
TextureFilter
:
:
Linear
None
[
0
.
0
;
3
]
None
gpu_cache
None
)
;
let
(
texture_id
texture_layer
uv_rect
)
=
texture_cache
.
get_cache_location
(
&
cache_entry
.
handle
)
;
render_task
.
location
=
RenderTaskLocation
:
:
TextureCache
(
texture_id
texture_layer
uv_rect
.
to_i32
(
)
)
;
}
texture_cache
.
get
(
&
cache_entry
.
handle
)
}
}
pub
fn
to_cache_size
(
size
:
DeviceSize
)
-
>
DeviceIntSize
{
DeviceIntSize
:
:
new
(
1
.
max
(
size
.
width
.
round
(
)
as
i32
)
1
.
max
(
size
.
height
.
round
(
)
as
i32
)
)
}
