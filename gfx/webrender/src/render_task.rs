use
api
:
:
{
DeviceIntPoint
DeviceIntRect
DeviceIntSize
}
;
use
api
:
:
{
ImageDescriptor
ImageFormat
LayerRect
PremultipliedColorF
}
;
use
box_shadow
:
:
BoxShadowCacheKey
;
use
clip
:
:
{
ClipSourcesWeakHandle
}
;
use
clip_scroll_tree
:
:
CoordinateSystemId
;
use
device
:
:
TextureFilter
;
use
gpu_cache
:
:
GpuCache
;
use
gpu_types
:
:
{
ClipScrollNodeIndex
PictureType
}
;
use
internal_types
:
:
{
FastHashMap
RenderPassIndex
SourceTexture
}
;
use
picture
:
:
ContentOrigin
;
use
prim_store
:
:
{
PrimitiveIndex
ImageCacheKey
}
;
#
[
cfg
(
feature
=
"
debugger
"
)
]
use
print_tree
:
:
{
PrintTreePrinter
}
;
use
resource_cache
:
:
CacheItem
;
use
std
:
:
{
cmp
ops
usize
f32
i32
}
;
use
std
:
:
rc
:
:
Rc
;
use
texture_cache
:
:
{
TextureCache
TextureCacheHandle
}
;
use
tiling
:
:
{
RenderPass
RenderTargetIndex
}
;
use
tiling
:
:
{
RenderTargetKind
}
;
const
FLOATS_PER_RENDER_TASK_INFO
:
usize
=
12
;
pub
const
MAX_BLUR_STD_DEVIATION
:
f32
=
4
.
0
;
pub
const
MIN_DOWNSCALING_RT_SIZE
:
i32
=
128
;
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskId
(
pub
u32
)
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
repr
(
C
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskAddress
(
pub
u32
)
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskTree
{
pub
tasks
:
Vec
<
RenderTask
>
pub
task_data
:
Vec
<
RenderTaskData
>
}
pub
type
ClipChainNodeRef
=
Option
<
Rc
<
ClipChainNode
>
>
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
ClipChainNode
{
pub
work_item
:
ClipWorkItem
pub
local_clip_rect
:
LayerRect
pub
screen_outer_rect
:
DeviceIntRect
pub
screen_inner_rect
:
DeviceIntRect
pub
prev
:
ClipChainNodeRef
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
ClipChain
{
pub
combined_outer_screen_rect
:
DeviceIntRect
pub
combined_inner_screen_rect
:
DeviceIntRect
pub
nodes
:
ClipChainNodeRef
}
impl
ClipChain
{
pub
fn
empty
(
screen_rect
:
&
DeviceIntRect
)
-
>
ClipChain
{
ClipChain
{
combined_inner_screen_rect
:
*
screen_rect
combined_outer_screen_rect
:
*
screen_rect
nodes
:
None
}
}
pub
fn
new_with_added_node
(
&
self
work_item
:
ClipWorkItem
local_clip_rect
:
LayerRect
screen_outer_rect
:
DeviceIntRect
screen_inner_rect
:
DeviceIntRect
)
-
>
ClipChain
{
let
new_node
=
ClipChainNode
{
work_item
local_clip_rect
screen_outer_rect
screen_inner_rect
prev
:
None
}
;
let
mut
new_chain
=
self
.
clone
(
)
;
new_chain
.
add_node
(
new_node
)
;
new_chain
}
pub
fn
add_node
(
&
mut
self
mut
new_node
:
ClipChainNode
)
{
new_node
.
prev
=
self
.
nodes
.
clone
(
)
;
if
self
.
combined_inner_screen_rect
.
contains_rect
(
&
new_node
.
screen_outer_rect
)
{
new_node
.
prev
=
None
;
}
self
.
combined_outer_screen_rect
=
self
.
combined_outer_screen_rect
.
intersection
(
&
new_node
.
screen_outer_rect
)
.
unwrap_or_else
(
DeviceIntRect
:
:
zero
)
;
self
.
combined_inner_screen_rect
=
self
.
combined_inner_screen_rect
.
intersection
(
&
new_node
.
screen_inner_rect
)
.
unwrap_or_else
(
DeviceIntRect
:
:
zero
)
;
self
.
nodes
=
Some
(
Rc
:
:
new
(
new_node
)
)
;
}
}
pub
struct
ClipChainNodeIter
{
pub
current
:
ClipChainNodeRef
}
impl
Iterator
for
ClipChainNodeIter
{
type
Item
=
Rc
<
ClipChainNode
>
;
fn
next
(
&
mut
self
)
-
>
ClipChainNodeRef
{
let
previous
=
self
.
current
.
clone
(
)
;
self
.
current
=
match
self
.
current
{
Some
(
ref
item
)
=
>
item
.
prev
.
clone
(
)
None
=
>
return
None
}
;
previous
}
}
impl
RenderTaskTree
{
pub
fn
new
(
)
-
>
Self
{
RenderTaskTree
{
tasks
:
Vec
:
:
new
(
)
task_data
:
Vec
:
:
new
(
)
}
}
pub
fn
add
(
&
mut
self
task
:
RenderTask
)
-
>
RenderTaskId
{
let
id
=
RenderTaskId
(
self
.
tasks
.
len
(
)
as
u32
)
;
self
.
tasks
.
push
(
task
)
;
id
}
pub
fn
max_depth
(
&
self
id
:
RenderTaskId
depth
:
usize
max_depth
:
&
mut
usize
)
{
let
depth
=
depth
+
1
;
*
max_depth
=
cmp
:
:
max
(
*
max_depth
depth
)
;
let
task
=
&
self
.
tasks
[
id
.
0
as
usize
]
;
for
child
in
&
task
.
children
{
self
.
max_depth
(
*
child
depth
max_depth
)
;
}
}
pub
fn
assign_to_passes
(
&
self
id
:
RenderTaskId
pass_index
:
usize
passes
:
&
mut
Vec
<
RenderPass
>
)
{
let
task
=
&
self
.
tasks
[
id
.
0
as
usize
]
;
for
child
in
&
task
.
children
{
self
.
assign_to_passes
(
*
child
pass_index
-
1
passes
)
;
}
match
task
.
location
{
RenderTaskLocation
:
:
Fixed
=
>
{
debug_assert
!
(
pass_index
=
=
passes
.
len
(
)
-
1
)
;
}
RenderTaskLocation
:
:
Dynamic
(
.
.
)
|
RenderTaskLocation
:
:
TextureCache
(
.
.
)
=
>
{
debug_assert
!
(
pass_index
<
passes
.
len
(
)
-
1
)
;
}
}
let
pass_index
=
if
task
.
is_shared
(
)
{
debug_assert
!
(
task
.
children
.
is_empty
(
)
)
;
0
}
else
{
pass_index
}
;
let
pass
=
&
mut
passes
[
pass_index
]
;
pass
.
add_render_task
(
id
task
.
get_dynamic_size
(
)
task
.
target_kind
(
)
)
;
}
pub
fn
get_task_address
(
&
self
id
:
RenderTaskId
)
-
>
RenderTaskAddress
{
RenderTaskAddress
(
id
.
0
)
}
pub
fn
build
(
&
mut
self
)
{
for
task
in
&
mut
self
.
tasks
{
self
.
task_data
.
push
(
task
.
write_task_data
(
)
)
;
}
}
}
impl
ops
:
:
Index
<
RenderTaskId
>
for
RenderTaskTree
{
type
Output
=
RenderTask
;
fn
index
(
&
self
id
:
RenderTaskId
)
-
>
&
RenderTask
{
&
self
.
tasks
[
id
.
0
as
usize
]
}
}
impl
ops
:
:
IndexMut
<
RenderTaskId
>
for
RenderTaskTree
{
fn
index_mut
(
&
mut
self
id
:
RenderTaskId
)
-
>
&
mut
RenderTask
{
&
mut
self
.
tasks
[
id
.
0
as
usize
]
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskLocation
{
Fixed
Dynamic
(
Option
<
(
DeviceIntPoint
RenderTargetIndex
)
>
DeviceIntSize
)
TextureCache
(
SourceTexture
i32
DeviceIntRect
)
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ClipWorkItem
{
pub
scroll_node_data_index
:
ClipScrollNodeIndex
pub
clip_sources
:
ClipSourcesWeakHandle
pub
coordinate_system_id
:
CoordinateSystemId
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheMaskTask
{
actual_rect
:
DeviceIntRect
pub
clips
:
Vec
<
ClipWorkItem
>
pub
coordinate_system_id
:
CoordinateSystemId
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureTask
{
pub
prim_index
:
PrimitiveIndex
pub
target_kind
:
RenderTargetKind
pub
content_origin
:
ContentOrigin
pub
color
:
PremultipliedColorF
pub
pic_type
:
PictureType
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BlurTask
{
pub
blur_std_deviation
:
f32
pub
target_kind
:
RenderTargetKind
pub
color
:
PremultipliedColorF
pub
scale_factor
:
f32
}
impl
BlurTask
{
#
[
cfg
(
feature
=
"
debugger
"
)
]
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
)
{
pt
.
add_item
(
format
!
(
"
std
deviation
:
{
}
"
self
.
blur_std_deviation
)
)
;
pt
.
add_item
(
format
!
(
"
target
:
{
:
?
}
"
self
.
target_kind
)
)
;
pt
.
add_item
(
format
!
(
"
scale
:
{
}
"
self
.
scale_factor
)
)
;
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
BlitSource
{
Image
{
key
:
ImageCacheKey
}
RenderTask
{
task_id
:
RenderTaskId
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BlitTask
{
pub
source
:
BlitSource
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskData
{
pub
data
:
[
f32
;
FLOATS_PER_RENDER_TASK_INFO
]
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskKind
{
Picture
(
PictureTask
)
CacheMask
(
CacheMaskTask
)
VerticalBlur
(
BlurTask
)
HorizontalBlur
(
BlurTask
)
Readback
(
DeviceIntRect
)
Scaling
(
RenderTargetKind
)
Blit
(
BlitTask
)
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ClearMode
{
Zero
One
Transparent
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTask
{
pub
location
:
RenderTaskLocation
pub
children
:
Vec
<
RenderTaskId
>
pub
kind
:
RenderTaskKind
pub
clear_mode
:
ClearMode
pub
pass_index
:
Option
<
RenderPassIndex
>
}
impl
RenderTask
{
pub
fn
new_picture
(
size
:
Option
<
DeviceIntSize
>
prim_index
:
PrimitiveIndex
target_kind
:
RenderTargetKind
content_origin
:
ContentOrigin
color
:
PremultipliedColorF
clear_mode
:
ClearMode
children
:
Vec
<
RenderTaskId
>
pic_type
:
PictureType
)
-
>
Self
{
let
location
=
match
size
{
Some
(
size
)
=
>
RenderTaskLocation
:
:
Dynamic
(
None
size
)
None
=
>
RenderTaskLocation
:
:
Fixed
}
;
RenderTask
{
children
location
kind
:
RenderTaskKind
:
:
Picture
(
PictureTask
{
prim_index
target_kind
content_origin
color
pic_type
}
)
clear_mode
pass_index
:
None
}
}
pub
fn
new_readback
(
screen_rect
:
DeviceIntRect
)
-
>
Self
{
RenderTask
{
children
:
Vec
:
:
new
(
)
location
:
RenderTaskLocation
:
:
Dynamic
(
None
screen_rect
.
size
)
kind
:
RenderTaskKind
:
:
Readback
(
screen_rect
)
clear_mode
:
ClearMode
:
:
Transparent
pass_index
:
None
}
}
pub
fn
new_blit
(
size
:
DeviceIntSize
source
:
BlitSource
)
-
>
Self
{
let
mut
children
=
Vec
:
:
new
(
)
;
if
let
BlitSource
:
:
RenderTask
{
task_id
}
=
source
{
children
.
push
(
task_id
)
;
}
RenderTask
{
children
location
:
RenderTaskLocation
:
:
Dynamic
(
None
size
)
kind
:
RenderTaskKind
:
:
Blit
(
BlitTask
{
source
}
)
clear_mode
:
ClearMode
:
:
Transparent
pass_index
:
None
}
}
pub
fn
new_mask
(
outer_rect
:
DeviceIntRect
clips
:
Vec
<
ClipWorkItem
>
prim_coordinate_system_id
:
CoordinateSystemId
)
-
>
RenderTask
{
RenderTask
{
children
:
Vec
:
:
new
(
)
location
:
RenderTaskLocation
:
:
Dynamic
(
None
outer_rect
.
size
)
kind
:
RenderTaskKind
:
:
CacheMask
(
CacheMaskTask
{
actual_rect
:
outer_rect
clips
coordinate_system_id
:
prim_coordinate_system_id
}
)
clear_mode
:
ClearMode
:
:
One
pass_index
:
None
}
}
pub
fn
new_blur
(
blur_std_deviation
:
f32
src_task_id
:
RenderTaskId
render_tasks
:
&
mut
RenderTaskTree
target_kind
:
RenderTargetKind
clear_mode
:
ClearMode
color
:
PremultipliedColorF
)
-
>
(
Self
f32
)
{
let
mut
adjusted_blur_std_deviation
=
blur_std_deviation
;
let
blur_target_size
=
render_tasks
[
src_task_id
]
.
get_dynamic_size
(
)
;
let
mut
adjusted_blur_target_size
=
blur_target_size
;
let
mut
downscaling_src_task_id
=
src_task_id
;
let
mut
scale_factor
=
1
.
0
;
while
adjusted_blur_std_deviation
>
MAX_BLUR_STD_DEVIATION
{
if
adjusted_blur_target_size
.
width
<
MIN_DOWNSCALING_RT_SIZE
|
|
adjusted_blur_target_size
.
height
<
MIN_DOWNSCALING_RT_SIZE
{
break
;
}
adjusted_blur_std_deviation
*
=
0
.
5
;
scale_factor
*
=
2
.
0
;
adjusted_blur_target_size
=
(
blur_target_size
.
to_f32
(
)
/
scale_factor
)
.
to_i32
(
)
;
let
downscaling_task
=
RenderTask
:
:
new_scaling
(
target_kind
downscaling_src_task_id
adjusted_blur_target_size
)
;
downscaling_src_task_id
=
render_tasks
.
add
(
downscaling_task
)
;
}
scale_factor
=
blur_target_size
.
width
as
f32
/
adjusted_blur_target_size
.
width
as
f32
;
let
blur_task_v
=
RenderTask
{
children
:
vec
!
[
downscaling_src_task_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
adjusted_blur_target_size
)
kind
:
RenderTaskKind
:
:
VerticalBlur
(
BlurTask
{
blur_std_deviation
:
adjusted_blur_std_deviation
target_kind
color
scale_factor
}
)
clear_mode
pass_index
:
None
}
;
let
blur_task_v_id
=
render_tasks
.
add
(
blur_task_v
)
;
let
blur_task_h
=
RenderTask
{
children
:
vec
!
[
blur_task_v_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
adjusted_blur_target_size
)
kind
:
RenderTaskKind
:
:
HorizontalBlur
(
BlurTask
{
blur_std_deviation
:
adjusted_blur_std_deviation
target_kind
color
scale_factor
}
)
clear_mode
pass_index
:
None
}
;
(
blur_task_h
scale_factor
)
}
pub
fn
new_scaling
(
target_kind
:
RenderTargetKind
src_task_id
:
RenderTaskId
target_size
:
DeviceIntSize
)
-
>
Self
{
RenderTask
{
children
:
vec
!
[
src_task_id
]
location
:
RenderTaskLocation
:
:
Dynamic
(
None
target_size
)
kind
:
RenderTaskKind
:
:
Scaling
(
target_kind
)
clear_mode
:
match
target_kind
{
RenderTargetKind
:
:
Color
=
>
ClearMode
:
:
Transparent
RenderTargetKind
:
:
Alpha
=
>
ClearMode
:
:
One
}
pass_index
:
None
}
}
pub
fn
write_task_data
(
&
self
)
-
>
RenderTaskData
{
let
(
data1
data2
)
=
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
task
)
=
>
{
(
match
task
.
content_origin
{
ContentOrigin
:
:
Local
(
point
)
=
>
[
point
.
x
point
.
y
task
.
pic_type
as
u32
as
f32
]
ContentOrigin
:
:
Screen
(
point
)
=
>
[
point
.
x
as
f32
point
.
y
as
f32
-
(
task
.
pic_type
as
u32
as
f32
)
]
}
task
.
color
.
to_array
(
)
)
}
RenderTaskKind
:
:
CacheMask
(
ref
task
)
=
>
{
(
[
task
.
actual_rect
.
origin
.
x
as
f32
task
.
actual_rect
.
origin
.
y
as
f32
0
.
0
]
[
0
.
0
;
4
]
)
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task
)
|
RenderTaskKind
:
:
HorizontalBlur
(
ref
task
)
=
>
{
(
[
task
.
blur_std_deviation
task
.
scale_factor
0
.
0
]
task
.
color
.
to_array
(
)
)
}
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
{
(
[
0
.
0
;
3
]
[
0
.
0
;
4
]
)
}
}
;
let
(
target_rect
target_index
)
=
self
.
get_target_rect
(
)
;
RenderTaskData
{
data
:
[
target_rect
.
origin
.
x
as
f32
target_rect
.
origin
.
y
as
f32
target_rect
.
size
.
width
as
f32
target_rect
.
size
.
height
as
f32
target_index
.
0
as
f32
data1
[
0
]
data1
[
1
]
data1
[
2
]
data2
[
0
]
data2
[
1
]
data2
[
2
]
data2
[
3
]
]
}
}
pub
fn
get_dynamic_size
(
&
self
)
-
>
DeviceIntSize
{
match
self
.
location
{
RenderTaskLocation
:
:
Fixed
=
>
DeviceIntSize
:
:
zero
(
)
RenderTaskLocation
:
:
Dynamic
(
_
size
)
=
>
size
RenderTaskLocation
:
:
TextureCache
(
_
_
rect
)
=
>
rect
.
size
}
}
pub
fn
get_target_rect
(
&
self
)
-
>
(
DeviceIntRect
RenderTargetIndex
)
{
match
self
.
location
{
RenderTaskLocation
:
:
Fixed
=
>
{
(
DeviceIntRect
:
:
zero
(
)
RenderTargetIndex
(
0
)
)
}
RenderTaskLocation
:
:
Dynamic
(
Some
(
(
origin
target_index
)
)
size
)
=
>
{
(
DeviceIntRect
:
:
new
(
origin
size
)
target_index
)
}
RenderTaskLocation
:
:
Dynamic
(
None
_
)
=
>
{
(
DeviceIntRect
:
:
zero
(
)
RenderTargetIndex
(
0
)
)
}
RenderTaskLocation
:
:
TextureCache
(
_
layer
rect
)
=
>
{
(
rect
RenderTargetIndex
(
layer
as
usize
)
)
}
}
}
pub
fn
target_kind
(
&
self
)
-
>
RenderTargetKind
{
match
self
.
kind
{
RenderTaskKind
:
:
Readback
(
.
.
)
=
>
RenderTargetKind
:
:
Color
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
{
RenderTargetKind
:
:
Alpha
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task_info
)
|
RenderTaskKind
:
:
HorizontalBlur
(
ref
task_info
)
=
>
{
task_info
.
target_kind
}
RenderTaskKind
:
:
Scaling
(
target_kind
)
=
>
{
target_kind
}
RenderTaskKind
:
:
Picture
(
ref
task_info
)
=
>
{
task_info
.
target_kind
}
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
{
RenderTargetKind
:
:
Color
}
}
}
pub
fn
is_shared
(
&
self
)
-
>
bool
{
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
.
.
)
|
RenderTaskKind
:
:
VerticalBlur
(
.
.
)
|
RenderTaskKind
:
:
Readback
(
.
.
)
|
RenderTaskKind
:
:
HorizontalBlur
(
.
.
)
|
RenderTaskKind
:
:
Scaling
(
.
.
)
|
RenderTaskKind
:
:
Blit
(
.
.
)
=
>
false
RenderTaskKind
:
:
CacheMask
(
.
.
)
=
>
true
}
}
#
[
cfg
(
feature
=
"
debugger
"
)
]
pub
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
tree
:
&
RenderTaskTree
)
-
>
bool
{
match
self
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
task
)
=
>
{
pt
.
new_level
(
format
!
(
"
Picture
of
{
:
?
}
"
task
.
prim_index
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
task
.
target_kind
)
)
;
}
RenderTaskKind
:
:
CacheMask
(
ref
task
)
=
>
{
pt
.
new_level
(
format
!
(
"
CacheMask
with
{
}
clips
"
task
.
clips
.
len
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
rect
:
{
:
?
}
"
task
.
actual_rect
)
)
;
}
RenderTaskKind
:
:
VerticalBlur
(
ref
task
)
=
>
{
pt
.
new_level
(
"
VerticalBlur
"
.
to_owned
(
)
)
;
task
.
print_with
(
pt
)
;
}
RenderTaskKind
:
:
HorizontalBlur
(
ref
task
)
=
>
{
pt
.
new_level
(
"
HorizontalBlur
"
.
to_owned
(
)
)
;
task
.
print_with
(
pt
)
;
}
RenderTaskKind
:
:
Readback
(
ref
rect
)
=
>
{
pt
.
new_level
(
"
Readback
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
rect
:
{
:
?
}
"
rect
)
)
;
}
RenderTaskKind
:
:
Scaling
(
ref
kind
)
=
>
{
pt
.
new_level
(
"
Scaling
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
kind
)
)
;
}
RenderTaskKind
:
:
Blit
(
ref
task
)
=
>
{
pt
.
new_level
(
"
Blit
"
.
to_owned
(
)
)
;
pt
.
add_item
(
format
!
(
"
source
:
{
:
?
}
"
task
.
source
)
)
;
}
}
pt
.
add_item
(
format
!
(
"
clear
to
:
{
:
?
}
"
self
.
clear_mode
)
)
;
for
&
child_id
in
&
self
.
children
{
if
tree
[
child_id
]
.
print_with
(
pt
tree
)
{
pt
.
add_item
(
format
!
(
"
self
:
{
:
?
}
"
child_id
)
)
}
}
pt
.
end_level
(
)
;
true
}
}
#
[
derive
(
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
RenderTaskCacheKeyKind
{
BoxShadow
(
BoxShadowCacheKey
)
Image
(
ImageCacheKey
)
}
#
[
derive
(
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskCacheKey
{
pub
size
:
DeviceIntSize
pub
kind
:
RenderTaskCacheKeyKind
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
RenderTaskCacheEntry
{
handle
:
TextureCacheHandle
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskCache
{
entries
:
FastHashMap
<
RenderTaskCacheKey
RenderTaskCacheEntry
>
}
impl
RenderTaskCache
{
pub
fn
new
(
)
-
>
Self
{
RenderTaskCache
{
entries
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
entries
.
clear
(
)
;
}
pub
fn
begin_frame
(
&
mut
self
texture_cache
:
&
mut
TextureCache
)
{
self
.
entries
.
retain
(
|
_
value
|
{
texture_cache
.
is_allocated
(
&
value
.
handle
)
}
)
;
}
pub
fn
request_render_task
<
F
>
(
&
mut
self
key
:
RenderTaskCacheKey
texture_cache
:
&
mut
TextureCache
gpu_cache
:
&
mut
GpuCache
render_tasks
:
&
mut
RenderTaskTree
mut
f
:
F
)
-
>
CacheItem
where
F
:
FnMut
(
&
mut
RenderTaskTree
)
-
>
(
RenderTaskId
[
f32
;
3
]
bool
)
{
let
cache_entry
=
self
.
entries
.
entry
(
key
)
.
or_insert
(
RenderTaskCacheEntry
{
handle
:
TextureCacheHandle
:
:
new
(
)
}
)
;
if
texture_cache
.
request
(
&
mut
cache_entry
.
handle
gpu_cache
)
{
let
(
render_task_id
user_data
is_opaque
)
=
f
(
render_tasks
)
;
let
render_task
=
&
mut
render_tasks
[
render_task_id
]
;
let
image_format
=
match
render_task
.
target_kind
(
)
{
RenderTargetKind
:
:
Color
=
>
ImageFormat
:
:
BGRA8
RenderTargetKind
:
:
Alpha
=
>
ImageFormat
:
:
R8
}
;
let
size
=
match
render_task
.
location
{
RenderTaskLocation
:
:
Fixed
|
RenderTaskLocation
:
:
TextureCache
(
.
.
)
=
>
{
panic
!
(
"
BUG
:
dynamic
task
was
expected
"
)
;
}
RenderTaskLocation
:
:
Dynamic
(
_
size
)
=
>
size
}
;
let
descriptor
=
ImageDescriptor
:
:
new
(
size
.
width
as
u32
size
.
height
as
u32
image_format
is_opaque
)
;
texture_cache
.
update
(
&
mut
cache_entry
.
handle
descriptor
TextureFilter
:
:
Linear
None
user_data
None
gpu_cache
)
;
let
(
texture_id
texture_layer
uv_rect
)
=
texture_cache
.
get_cache_location
(
&
cache_entry
.
handle
)
;
render_task
.
location
=
RenderTaskLocation
:
:
TextureCache
(
texture_id
texture_layer
uv_rect
.
to_i32
(
)
)
;
}
texture_cache
.
get
(
&
cache_entry
.
handle
)
}
}
