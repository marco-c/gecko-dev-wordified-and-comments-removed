use
api
:
:
{
AlphaType
BorderDetails
BorderDisplayItem
BuiltDisplayList
ClipAndScrollInfo
ClipId
}
;
use
api
:
:
{
ColorF
ColorU
DeviceIntPoint
DevicePixelScale
DeviceUintPoint
DeviceUintRect
}
;
use
api
:
:
{
DeviceUintSize
DocumentLayer
ExtendMode
FontRenderMode
GlyphInstance
GlyphOptions
}
;
use
api
:
:
{
GradientStop
HitTestFlags
HitTestItem
HitTestResult
ImageKey
ImageRendering
}
;
use
api
:
:
{
ItemRange
ItemTag
LayerPoint
LayerPrimitiveInfo
LayerRect
LayerSize
}
;
use
api
:
:
{
LayerTransform
LayerVector2D
LayoutTransform
LayoutVector2D
LineOrientation
}
;
use
api
:
:
{
LineStyle
LocalClip
PipelineId
PremultipliedColorF
PropertyBinding
RepeatMode
}
;
use
api
:
:
{
ScrollSensitivity
Shadow
TileOffset
TransformStyle
WorldPoint
YuvColorSpace
}
;
use
api
:
:
YuvData
;
use
app_units
:
:
Au
;
use
border
:
:
ImageBorderSegment
;
use
clip
:
:
{
ClipRegion
ClipSource
ClipSources
ClipStore
Contains
}
;
use
clip_scroll_node
:
:
{
ClipScrollNode
NodeType
}
;
use
clip_scroll_tree
:
:
ClipScrollTree
;
use
euclid
:
:
{
SideOffsets2D
vec2
}
;
use
frame
:
:
FrameId
;
use
glyph_rasterizer
:
:
FontInstance
;
use
gpu_cache
:
:
GpuCache
;
use
gpu_types
:
:
{
ClipScrollNodeData
PictureType
}
;
use
internal_types
:
:
{
FastHashMap
FastHashSet
RenderPassIndex
}
;
use
picture
:
:
{
ContentOrigin
PictureCompositeMode
PictureKind
PicturePrimitive
PictureSurface
}
;
use
prim_store
:
:
{
BrushKind
BrushPrimitive
TexelRect
YuvImagePrimitiveCpu
}
;
use
prim_store
:
:
{
GradientPrimitiveCpu
ImagePrimitiveCpu
PrimitiveKind
}
;
use
prim_store
:
:
{
PrimitiveContainer
PrimitiveIndex
SpecificPrimitiveIndex
}
;
use
prim_store
:
:
{
PrimitiveStore
RadialGradientPrimitiveCpu
}
;
use
prim_store
:
:
{
BrushSegmentDescriptor
TextRunPrimitiveCpu
}
;
use
profiler
:
:
{
FrameProfileCounters
GpuCacheProfileCounters
TextureCacheProfileCounters
}
;
use
render_task
:
:
{
ClearMode
ClipChain
RenderTask
RenderTaskId
RenderTaskTree
}
;
use
resource_cache
:
:
ResourceCache
;
use
scene
:
:
{
ScenePipeline
SceneProperties
}
;
use
std
:
:
{
mem
usize
f32
}
;
use
tiling
:
:
{
CompositeOps
Frame
RenderPass
RenderTargetKind
}
;
use
tiling
:
:
{
RenderTargetContext
ScrollbarPrimitive
}
;
use
util
:
:
{
self
MaxRect
pack_as_float
RectHelpers
recycle_vec
}
;
#
[
derive
(
Debug
)
]
pub
struct
ScrollbarInfo
(
pub
ClipId
pub
LayerRect
)
;
struct
StackingContext
{
pipeline_id
:
PipelineId
composite_ops
:
CompositeOps
is_backface_visible
:
bool
allow_subpixel_aa
:
bool
transform_style
:
TransformStyle
pic_prim_index
:
PrimitiveIndex
}
#
[
derive
(
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
Deserialize
)
)
]
pub
struct
FrameBuilderConfig
{
pub
enable_scrollbars
:
bool
pub
default_font_render_mode
:
FontRenderMode
pub
debug
:
bool
pub
dual_source_blending_is_supported
:
bool
pub
dual_source_blending_is_enabled
:
bool
}
#
[
derive
(
Debug
)
]
pub
struct
HitTestingItem
{
rect
:
LayerRect
clip
:
LocalClip
tag
:
ItemTag
}
impl
HitTestingItem
{
fn
new
(
tag
:
ItemTag
info
:
&
LayerPrimitiveInfo
)
-
>
HitTestingItem
{
HitTestingItem
{
rect
:
info
.
rect
clip
:
info
.
local_clip
tag
:
tag
}
}
}
pub
struct
HitTestingRun
(
Vec
<
HitTestingItem
>
ClipAndScrollInfo
)
;
pub
struct
FrameBuilder
{
screen_rect
:
DeviceUintRect
background_color
:
Option
<
ColorF
>
prim_store
:
PrimitiveStore
pub
clip_store
:
ClipStore
hit_testing_runs
:
Vec
<
HitTestingRun
>
pub
config
:
FrameBuilderConfig
shadow_prim_stack
:
Vec
<
(
PrimitiveIndex
Vec
<
(
PrimitiveIndex
ClipAndScrollInfo
)
>
)
>
pending_shadow_contents
:
Vec
<
(
PrimitiveIndex
ClipAndScrollInfo
LayerPrimitiveInfo
)
>
scrollbar_prims
:
Vec
<
ScrollbarPrimitive
>
reference_frame_stack
:
Vec
<
ClipId
>
pub
picture_stack
:
Vec
<
PrimitiveIndex
>
sc_stack
:
Vec
<
StackingContext
>
}
pub
struct
PrimitiveContext
<
'
a
>
{
pub
device_pixel_scale
:
DevicePixelScale
pub
display_list
:
&
'
a
BuiltDisplayList
pub
clip_chain
:
Option
<
&
'
a
ClipChain
>
pub
scroll_node
:
&
'
a
ClipScrollNode
}
impl
<
'
a
>
PrimitiveContext
<
'
a
>
{
pub
fn
new
(
device_pixel_scale
:
DevicePixelScale
display_list
:
&
'
a
BuiltDisplayList
clip_chain
:
Option
<
&
'
a
ClipChain
>
scroll_node
:
&
'
a
ClipScrollNode
)
-
>
Self
{
PrimitiveContext
{
device_pixel_scale
display_list
clip_chain
scroll_node
}
}
}
impl
FrameBuilder
{
pub
fn
empty
(
)
-
>
Self
{
FrameBuilder
{
hit_testing_runs
:
Vec
:
:
new
(
)
shadow_prim_stack
:
Vec
:
:
new
(
)
pending_shadow_contents
:
Vec
:
:
new
(
)
scrollbar_prims
:
Vec
:
:
new
(
)
reference_frame_stack
:
Vec
:
:
new
(
)
picture_stack
:
Vec
:
:
new
(
)
sc_stack
:
Vec
:
:
new
(
)
prim_store
:
PrimitiveStore
:
:
new
(
)
clip_store
:
ClipStore
:
:
new
(
)
screen_rect
:
DeviceUintRect
:
:
zero
(
)
background_color
:
None
config
:
FrameBuilderConfig
{
enable_scrollbars
:
false
default_font_render_mode
:
FontRenderMode
:
:
Mono
debug
:
false
dual_source_blending_is_enabled
:
true
dual_source_blending_is_supported
:
false
}
}
}
pub
fn
recycle
(
self
screen_rect
:
DeviceUintRect
background_color
:
Option
<
ColorF
>
config
:
FrameBuilderConfig
)
-
>
Self
{
FrameBuilder
{
hit_testing_runs
:
recycle_vec
(
self
.
hit_testing_runs
)
shadow_prim_stack
:
recycle_vec
(
self
.
shadow_prim_stack
)
pending_shadow_contents
:
recycle_vec
(
self
.
pending_shadow_contents
)
scrollbar_prims
:
recycle_vec
(
self
.
scrollbar_prims
)
reference_frame_stack
:
recycle_vec
(
self
.
reference_frame_stack
)
picture_stack
:
recycle_vec
(
self
.
picture_stack
)
sc_stack
:
recycle_vec
(
self
.
sc_stack
)
prim_store
:
self
.
prim_store
.
recycle
(
)
clip_store
:
self
.
clip_store
.
recycle
(
)
screen_rect
background_color
config
}
}
pub
fn
create_primitive
(
&
mut
self
info
:
&
LayerPrimitiveInfo
mut
clip_sources
:
Vec
<
ClipSource
>
container
:
PrimitiveContainer
)
-
>
PrimitiveIndex
{
if
let
&
LocalClip
:
:
RoundedRect
(
main
region
)
=
&
info
.
local_clip
{
clip_sources
.
push
(
ClipSource
:
:
Rectangle
(
main
)
)
;
clip_sources
.
push
(
ClipSource
:
:
new_rounded_rect
(
region
.
rect
region
.
radii
region
.
mode
)
)
;
}
let
stacking_context
=
self
.
sc_stack
.
last
(
)
.
expect
(
"
bug
:
no
stacking
context
!
"
)
;
let
clip_sources
=
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
clip_sources
)
)
;
let
prim_index
=
self
.
prim_store
.
add_primitive
(
&
info
.
rect
&
info
.
local_clip
.
clip_rect
(
)
info
.
is_backface_visible
&
&
stacking_context
.
is_backface_visible
clip_sources
info
.
tag
container
)
;
prim_index
}
pub
fn
add_primitive_to_hit_testing_list
(
&
mut
self
info
:
&
LayerPrimitiveInfo
clip_and_scroll
:
ClipAndScrollInfo
)
{
let
tag
=
match
info
.
tag
{
Some
(
tag
)
=
>
tag
None
=
>
return
}
;
let
new_item
=
HitTestingItem
:
:
new
(
tag
info
)
;
match
self
.
hit_testing_runs
.
last_mut
(
)
{
Some
(
&
mut
HitTestingRun
(
ref
mut
items
prev_clip_and_scroll
)
)
if
prev_clip_and_scroll
=
=
clip_and_scroll
=
>
{
items
.
push
(
new_item
)
;
return
;
}
_
=
>
{
}
}
self
.
hit_testing_runs
.
push
(
HitTestingRun
(
vec
!
[
new_item
]
clip_and_scroll
)
)
;
}
pub
fn
add_primitive_to_draw_list
(
&
mut
self
prim_index
:
PrimitiveIndex
clip_and_scroll
:
ClipAndScrollInfo
)
{
let
pic_prim_index
=
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
;
let
metadata
=
&
self
.
prim_store
.
cpu_metadata
[
pic_prim_index
.
0
]
;
let
pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
metadata
.
cpu_prim_index
.
0
]
;
pic
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
pub
fn
add_primitive
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
clip_sources
:
Vec
<
ClipSource
>
container
:
PrimitiveContainer
)
-
>
PrimitiveIndex
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
let
prim_index
=
self
.
create_primitive
(
info
clip_sources
container
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
prim_index
}
pub
fn
push_stacking_context
(
&
mut
self
pipeline_id
:
PipelineId
composite_ops
:
CompositeOps
transform_style
:
TransformStyle
is_backface_visible
:
bool
is_pipeline_root
:
bool
clip_and_scroll
:
ClipAndScrollInfo
output_pipelines
:
&
FastHashSet
<
PipelineId
>
)
{
let
current_reference_frame_id
=
self
.
current_reference_frame_id
(
)
;
let
max_clip
=
LayerRect
:
:
max_rect
(
)
;
if
self
.
sc_stack
.
is_empty
(
)
{
debug_assert
!
(
self
.
prim_store
.
cpu_pictures
.
is_empty
(
)
)
;
debug_assert_eq
!
(
transform_style
TransformStyle
:
:
Flat
)
;
let
pic
=
PicturePrimitive
:
:
new_image
(
None
false
pipeline_id
current_reference_frame_id
None
)
;
let
clip_sources
=
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
Vec
:
:
new
(
)
)
)
;
let
prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
true
clip_sources
None
PrimitiveContainer
:
:
Picture
(
pic
)
)
;
self
.
picture_stack
.
push
(
prim_index
)
;
}
else
if
composite_ops
.
mix_blend_mode
.
is_some
(
)
&
&
self
.
sc_stack
.
len
(
)
>
2
{
let
current_pic_prim_index
=
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
;
let
pic_cpu_prim_index
=
self
.
prim_store
.
cpu_metadata
[
current_pic_prim_index
.
0
]
.
cpu_prim_index
;
let
parent_pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
pic_cpu_prim_index
.
0
]
;
match
parent_pic
.
kind
{
PictureKind
:
:
Image
{
ref
mut
composite_mode
.
.
}
=
>
{
if
composite_mode
.
is_none
(
)
{
*
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
}
}
PictureKind
:
:
TextShadow
{
.
.
}
|
PictureKind
:
:
BoxShadow
{
.
.
}
=
>
{
panic
!
(
"
bug
:
text
/
box
pictures
invalid
here
"
)
;
}
}
}
let
parent_transform_style
=
match
self
.
sc_stack
.
last
(
)
{
Some
(
sc
)
=
>
sc
.
transform_style
None
=
>
TransformStyle
:
:
Flat
}
;
let
is_in_3d_context
=
composite_ops
.
count
(
)
=
=
0
&
&
(
parent_transform_style
=
=
TransformStyle
:
:
Preserve3D
|
|
transform_style
=
=
TransformStyle
:
:
Preserve3D
)
;
let
mut
parent_pic_prim_index
=
if
is_in_3d_context
{
self
.
sc_stack
.
iter
(
)
.
rev
(
)
.
find
(
|
sc
|
sc
.
transform_style
=
=
TransformStyle
:
:
Flat
)
.
map
(
|
sc
|
sc
.
pic_prim_index
)
.
unwrap
(
)
}
else
{
*
self
.
picture_stack
.
last
(
)
.
unwrap
(
)
}
;
for
filter
in
composite_ops
.
filters
.
iter
(
)
.
rev
(
)
{
let
src_prim
=
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
Filter
(
*
filter
)
)
false
pipeline_id
current_reference_frame_id
None
)
;
let
src_clip_sources
=
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
Vec
:
:
new
(
)
)
)
;
let
src_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
src_clip_sources
None
PrimitiveContainer
:
:
Picture
(
src_prim
)
)
;
let
pic_prim_index
=
self
.
prim_store
.
cpu_metadata
[
parent_pic_prim_index
.
0
]
.
cpu_prim_index
;
parent_pic_prim_index
=
src_prim_index
;
let
pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
pic_prim_index
.
0
]
;
pic
.
add_primitive
(
src_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
src_prim_index
)
;
}
if
let
Some
(
mix_blend_mode
)
=
composite_ops
.
mix_blend_mode
{
let
src_prim
=
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
MixBlend
(
mix_blend_mode
)
)
false
pipeline_id
current_reference_frame_id
None
)
;
let
src_clip_sources
=
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
Vec
:
:
new
(
)
)
)
;
let
src_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
src_clip_sources
None
PrimitiveContainer
:
:
Picture
(
src_prim
)
)
;
let
pic_prim_index
=
self
.
prim_store
.
cpu_metadata
[
parent_pic_prim_index
.
0
]
.
cpu_prim_index
;
parent_pic_prim_index
=
src_prim_index
;
let
pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
pic_prim_index
.
0
]
;
pic
.
add_primitive
(
src_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
src_prim_index
)
;
}
let
mut
composite_mode
=
None
;
let
mut
frame_output_pipeline_id
=
None
;
if
is_pipeline_root
&
&
output_pipelines
.
contains
(
&
pipeline_id
)
{
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
frame_output_pipeline_id
=
Some
(
pipeline_id
)
;
}
if
is_in_3d_context
{
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
)
;
}
let
sc_prim
=
PicturePrimitive
:
:
new_image
(
composite_mode
is_in_3d_context
pipeline_id
current_reference_frame_id
frame_output_pipeline_id
)
;
let
sc_clip_sources
=
self
.
clip_store
.
insert
(
ClipSources
:
:
new
(
Vec
:
:
new
(
)
)
)
;
let
sc_prim_index
=
self
.
prim_store
.
add_primitive
(
&
LayerRect
:
:
zero
(
)
&
max_clip
is_backface_visible
sc_clip_sources
None
PrimitiveContainer
:
:
Picture
(
sc_prim
)
)
;
let
pic_prim_index
=
self
.
prim_store
.
cpu_metadata
[
parent_pic_prim_index
.
0
]
.
cpu_prim_index
;
let
sc_pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
pic_prim_index
.
0
]
;
sc_pic
.
add_primitive
(
sc_prim_index
clip_and_scroll
)
;
self
.
picture_stack
.
push
(
sc_prim_index
)
;
let
allow_subpixel_aa
=
composite_ops
.
count
(
)
=
=
0
&
&
transform_style
=
=
TransformStyle
:
:
Flat
;
let
sc
=
StackingContext
{
composite_ops
is_backface_visible
pipeline_id
allow_subpixel_aa
transform_style
pic_prim_index
:
sc_prim_index
}
;
self
.
sc_stack
.
push
(
sc
)
;
}
pub
fn
pop_stacking_context
(
&
mut
self
)
{
let
sc
=
self
.
sc_stack
.
pop
(
)
.
unwrap
(
)
;
self
.
picture_stack
.
pop
(
)
.
expect
(
"
bug
"
)
;
for
_
in
0
.
.
sc
.
composite_ops
.
count
(
)
{
self
.
picture_stack
.
pop
(
)
.
expect
(
"
bug
:
mismatched
picture
stack
"
)
;
}
if
self
.
sc_stack
.
is_empty
(
)
{
self
.
picture_stack
.
pop
(
)
.
expect
(
"
bug
:
picture
stack
invalid
"
)
;
debug_assert
!
(
self
.
picture_stack
.
is_empty
(
)
)
;
}
assert
!
(
self
.
shadow_prim_stack
.
is_empty
(
)
"
Found
unpopped
text
shadows
when
popping
stacking
context
!
"
)
;
}
pub
fn
push_reference_frame
(
&
mut
self
parent_id
:
Option
<
ClipId
>
pipeline_id
:
PipelineId
rect
:
&
LayerRect
source_transform
:
Option
<
PropertyBinding
<
LayoutTransform
>
>
source_perspective
:
Option
<
LayoutTransform
>
origin_in_parent_reference_frame
:
LayerVector2D
root_for_pipeline
:
bool
clip_scroll_tree
:
&
mut
ClipScrollTree
)
-
>
ClipId
{
let
new_id
=
clip_scroll_tree
.
add_reference_frame
(
rect
source_transform
source_perspective
origin_in_parent_reference_frame
pipeline_id
parent_id
root_for_pipeline
)
;
self
.
reference_frame_stack
.
push
(
new_id
)
;
new_id
}
pub
fn
current_reference_frame_id
(
&
self
)
-
>
ClipId
{
*
self
.
reference_frame_stack
.
last
(
)
.
unwrap
(
)
}
pub
fn
setup_viewport_offset
(
&
mut
self
inner_rect
:
DeviceUintRect
device_pixel_scale
:
DevicePixelScale
clip_scroll_tree
:
&
mut
ClipScrollTree
)
{
let
viewport_offset
=
(
inner_rect
.
origin
.
to_vector
(
)
.
to_f32
(
)
/
device_pixel_scale
)
.
round
(
)
;
let
root_id
=
clip_scroll_tree
.
root_reference_frame_id
(
)
;
if
let
Some
(
root_node
)
=
clip_scroll_tree
.
nodes
.
get_mut
(
&
root_id
)
{
if
let
NodeType
:
:
ReferenceFrame
(
ref
mut
info
)
=
root_node
.
node_type
{
info
.
resolved_transform
=
LayerTransform
:
:
create_translation
(
viewport_offset
.
x
viewport_offset
.
y
0
.
0
)
;
}
}
}
pub
fn
push_root
(
&
mut
self
pipeline_id
:
PipelineId
viewport_size
:
&
LayerSize
content_size
:
&
LayerSize
clip_scroll_tree
:
&
mut
ClipScrollTree
)
-
>
ClipId
{
let
viewport_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
*
viewport_size
)
;
self
.
push_reference_frame
(
None
pipeline_id
&
viewport_rect
None
None
LayerVector2D
:
:
zero
(
)
true
clip_scroll_tree
)
;
let
topmost_scrolling_node_id
=
ClipId
:
:
root_scroll_node
(
pipeline_id
)
;
clip_scroll_tree
.
topmost_scrolling_node_id
=
topmost_scrolling_node_id
;
self
.
add_scroll_frame
(
topmost_scrolling_node_id
clip_scroll_tree
.
root_reference_frame_id
pipeline_id
&
viewport_rect
content_size
ScrollSensitivity
:
:
ScriptAndInputEvents
clip_scroll_tree
)
;
topmost_scrolling_node_id
}
pub
fn
add_clip_node
(
&
mut
self
new_node_id
:
ClipId
parent_id
:
ClipId
pipeline_id
:
PipelineId
clip_region
:
ClipRegion
clip_scroll_tree
:
&
mut
ClipScrollTree
)
{
let
clip_rect
=
clip_region
.
main
;
let
clip_sources
=
ClipSources
:
:
from
(
clip_region
)
;
debug_assert
!
(
clip_sources
.
has_clips
(
)
)
;
let
handle
=
self
.
clip_store
.
insert
(
clip_sources
)
;
let
node
=
ClipScrollNode
:
:
new_clip_node
(
pipeline_id
parent_id
handle
clip_rect
)
;
clip_scroll_tree
.
add_node
(
node
new_node_id
)
;
}
pub
fn
add_scroll_frame
(
&
mut
self
new_node_id
:
ClipId
parent_id
:
ClipId
pipeline_id
:
PipelineId
frame_rect
:
&
LayerRect
content_size
:
&
LayerSize
scroll_sensitivity
:
ScrollSensitivity
clip_scroll_tree
:
&
mut
ClipScrollTree
)
{
let
node
=
ClipScrollNode
:
:
new_scroll_frame
(
pipeline_id
parent_id
frame_rect
content_size
scroll_sensitivity
)
;
clip_scroll_tree
.
add_node
(
node
new_node_id
)
;
}
pub
fn
pop_reference_frame
(
&
mut
self
)
{
self
.
reference_frame_stack
.
pop
(
)
;
}
pub
fn
push_shadow
(
&
mut
self
shadow
:
Shadow
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
)
{
let
pipeline_id
=
self
.
sc_stack
.
last
(
)
.
unwrap
(
)
.
pipeline_id
;
let
prim
=
PicturePrimitive
:
:
new_text_shadow
(
shadow
pipeline_id
)
;
let
prim_index
=
self
.
create_primitive
(
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Picture
(
prim
)
)
;
let
pending
=
vec
!
[
(
prim_index
clip_and_scroll
)
]
;
self
.
shadow_prim_stack
.
push
(
(
prim_index
pending
)
)
;
}
pub
fn
pop_all_shadows
(
&
mut
self
)
{
assert
!
(
self
.
shadow_prim_stack
.
len
(
)
>
0
"
popped
shadows
but
none
were
present
"
)
;
let
mut
shadows
=
mem
:
:
replace
(
&
mut
self
.
shadow_prim_stack
Vec
:
:
new
(
)
)
;
for
(
_
pending_primitives
)
in
shadows
.
drain
(
.
.
)
{
for
(
prim_index
clip_and_scroll
)
in
pending_primitives
{
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
}
let
mut
pending_primitives
=
mem
:
:
replace
(
&
mut
self
.
pending_shadow_contents
Vec
:
:
new
(
)
)
;
for
(
prim_index
clip_and_scroll
info
)
in
pending_primitives
.
drain
(
.
.
)
{
self
.
add_primitive_to_hit_testing_list
(
&
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
mem
:
:
replace
(
&
mut
self
.
pending_shadow_contents
pending_primitives
)
;
mem
:
:
replace
(
&
mut
self
.
shadow_prim_stack
shadows
)
;
}
pub
fn
add_solid_rectangle
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
color
:
ColorF
segments
:
Option
<
BrushSegmentDescriptor
>
)
{
if
color
.
a
=
=
0
.
0
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
return
;
}
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Solid
{
color
}
segments
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
pub
fn
add_clear_rectangle
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
)
{
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Clear
None
)
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
}
pub
fn
add_scroll_bar
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
color
:
ColorF
scrollbar_info
:
ScrollbarInfo
)
{
if
color
.
a
=
=
0
.
0
{
return
;
}
let
prim
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Solid
{
color
}
None
)
;
let
prim_index
=
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
prim
)
)
;
self
.
scrollbar_prims
.
push
(
ScrollbarPrimitive
{
prim_index
clip_id
:
scrollbar_info
.
0
frame_rect
:
scrollbar_info
.
1
}
)
;
}
pub
fn
add_line
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
wavy_line_thickness
:
f32
orientation
:
LineOrientation
line_color
:
&
ColorF
style
:
LineStyle
)
{
let
line
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Line
{
wavy_line_thickness
color
:
line_color
.
premultiplied
(
)
style
orientation
}
None
)
;
let
mut
fast_shadow_prims
=
Vec
:
:
new
(
)
;
for
(
idx
&
(
shadow_prim_index
_
)
)
in
self
.
shadow_prim_stack
.
iter
(
)
.
enumerate
(
)
{
let
shadow_metadata
=
&
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
let
picture
=
&
self
.
prim_store
.
cpu_pictures
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
offset
color
blur_radius
.
.
}
if
blur_radius
=
=
0
.
0
=
>
{
fast_shadow_prims
.
push
(
(
idx
offset
color
)
)
;
}
_
=
>
{
}
}
}
for
(
idx
shadow_offset
shadow_color
)
in
fast_shadow_prims
{
let
line
=
BrushPrimitive
:
:
new
(
BrushKind
:
:
Line
{
wavy_line_thickness
color
:
shadow_color
.
premultiplied
(
)
style
orientation
}
None
)
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
info
.
rect
.
translate
(
&
shadow_offset
)
;
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
line
)
)
;
self
.
shadow_prim_stack
[
idx
]
.
1
.
push
(
(
prim_index
clip_and_scroll
)
)
;
}
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
line
)
)
;
if
line_color
.
a
>
0
.
0
{
if
self
.
shadow_prim_stack
.
is_empty
(
)
{
self
.
add_primitive_to_hit_testing_list
(
&
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
else
{
self
.
pending_shadow_contents
.
push
(
(
prim_index
clip_and_scroll
*
info
)
)
;
}
}
for
&
(
shadow_prim_index
_
)
in
&
self
.
shadow_prim_stack
{
let
shadow_metadata
=
&
mut
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
debug_assert_eq
!
(
shadow_metadata
.
prim_kind
PrimitiveKind
:
:
Picture
)
;
let
picture
=
&
mut
self
.
prim_store
.
cpu_pictures
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
blur_radius
.
.
}
if
blur_radius
>
0
.
0
=
>
{
picture
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
_
=
>
{
}
}
}
}
pub
fn
add_border
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
border_item
:
&
BorderDisplayItem
gradient_stops
:
ItemRange
<
GradientStop
>
gradient_stops_count
:
usize
)
{
let
rect
=
info
.
rect
;
let
create_segments
=
|
outset
:
SideOffsets2D
<
f32
>
|
{
let
origin
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
-
outset
.
left
rect
.
origin
.
y
-
outset
.
top
)
;
let
size
=
LayerSize
:
:
new
(
rect
.
size
.
width
+
outset
.
left
+
outset
.
right
rect
.
size
.
height
+
outset
.
top
+
outset
.
bottom
)
;
let
rect
=
LayerRect
:
:
new
(
origin
size
)
;
let
tl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
;
let
tl_inner
=
tl_outer
+
vec2
(
border_item
.
widths
.
left
border_item
.
widths
.
top
)
;
let
tr_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
)
;
let
tr_inner
=
tr_outer
+
vec2
(
-
border_item
.
widths
.
right
border_item
.
widths
.
top
)
;
let
bl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
bl_inner
=
bl_outer
+
vec2
(
border_item
.
widths
.
left
-
border_item
.
widths
.
bottom
)
;
let
br_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
br_inner
=
br_outer
-
vec2
(
border_item
.
widths
.
right
border_item
.
widths
.
bottom
)
;
vec
!
[
/
/
Top
left
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_outer
.
y
tl_inner
.
x
tl_inner
.
y
)
/
/
Top
right
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_outer
.
y
tr_outer
.
x
tr_inner
.
y
)
/
/
Bottom
right
LayerRect
:
:
from_floats
(
br_inner
.
x
br_inner
.
y
br_outer
.
x
br_outer
.
y
)
/
/
Bottom
left
LayerRect
:
:
from_floats
(
bl_outer
.
x
bl_inner
.
y
bl_inner
.
x
bl_outer
.
y
)
/
/
Top
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_outer
.
y
tr_inner
.
x
tl_inner
.
y
)
/
/
Bottom
LayerRect
:
:
from_floats
(
bl_inner
.
x
bl_inner
.
y
br_inner
.
x
bl_outer
.
y
)
/
/
Left
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_inner
.
y
tl_inner
.
x
bl_inner
.
y
)
/
/
Right
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_inner
.
y
br_outer
.
x
br_inner
.
y
)
]
}
;
match
border_item
.
details
{
BorderDetails
:
:
Image
(
ref
border
)
=
>
{
let
origin
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
-
border
.
outset
.
left
rect
.
origin
.
y
-
border
.
outset
.
top
)
;
let
size
=
LayerSize
:
:
new
(
rect
.
size
.
width
+
border
.
outset
.
left
+
border
.
outset
.
right
rect
.
size
.
height
+
border
.
outset
.
top
+
border
.
outset
.
bottom
)
;
let
rect
=
LayerRect
:
:
new
(
origin
size
)
;
let
px0
=
0
.
0
;
let
px1
=
border
.
patch
.
slice
.
left
as
f32
;
let
px2
=
border
.
patch
.
width
as
f32
-
border
.
patch
.
slice
.
right
as
f32
;
let
px3
=
border
.
patch
.
width
as
f32
;
let
py0
=
0
.
0
;
let
py1
=
border
.
patch
.
slice
.
top
as
f32
;
let
py2
=
border
.
patch
.
height
as
f32
-
border
.
patch
.
slice
.
bottom
as
f32
;
let
py3
=
border
.
patch
.
height
as
f32
;
let
tl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
;
let
tl_inner
=
tl_outer
+
vec2
(
border_item
.
widths
.
left
border_item
.
widths
.
top
)
;
let
tr_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
)
;
let
tr_inner
=
tr_outer
+
vec2
(
-
border_item
.
widths
.
right
border_item
.
widths
.
top
)
;
let
bl_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
bl_inner
=
bl_outer
+
vec2
(
border_item
.
widths
.
left
-
border_item
.
widths
.
bottom
)
;
let
br_outer
=
LayerPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
rect
.
origin
.
y
+
rect
.
size
.
height
)
;
let
br_inner
=
br_outer
-
vec2
(
border_item
.
widths
.
right
border_item
.
widths
.
bottom
)
;
fn
add_segment
(
segments
:
&
mut
Vec
<
ImageBorderSegment
>
rect
:
LayerRect
uv_rect
:
TexelRect
repeat_horizontal
:
RepeatMode
repeat_vertical
:
RepeatMode
)
{
if
uv_rect
.
uv1
.
x
>
uv_rect
.
uv0
.
x
&
&
uv_rect
.
uv1
.
y
>
uv_rect
.
uv0
.
y
{
segments
.
push
(
ImageBorderSegment
:
:
new
(
rect
uv_rect
repeat_horizontal
repeat_vertical
)
)
;
}
}
let
mut
segments
=
vec
!
[
]
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_outer
.
y
tl_inner
.
x
tl_inner
.
y
)
TexelRect
:
:
new
(
px0
py0
px1
py1
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_outer
.
y
tr_outer
.
x
tr_inner
.
y
)
TexelRect
:
:
new
(
px2
py0
px3
py1
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
br_inner
.
x
br_inner
.
y
br_outer
.
x
br_outer
.
y
)
TexelRect
:
:
new
(
px2
py2
px3
py3
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
bl_outer
.
x
bl_inner
.
y
bl_inner
.
x
bl_outer
.
y
)
TexelRect
:
:
new
(
px0
py2
px1
py3
)
RepeatMode
:
:
Stretch
RepeatMode
:
:
Stretch
)
;
if
border
.
fill
{
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_inner
.
y
tr_inner
.
x
bl_inner
.
y
)
TexelRect
:
:
new
(
px1
py1
px2
py2
)
border
.
repeat_horizontal
border
.
repeat_vertical
)
;
}
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_inner
.
x
tl_outer
.
y
tr_inner
.
x
tl_inner
.
y
)
TexelRect
:
:
new
(
px1
py0
px2
py1
)
border
.
repeat_horizontal
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
bl_inner
.
x
bl_inner
.
y
br_inner
.
x
bl_outer
.
y
)
TexelRect
:
:
new
(
px1
py2
px2
py3
)
border
.
repeat_horizontal
RepeatMode
:
:
Stretch
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tl_outer
.
x
tl_inner
.
y
tl_inner
.
x
bl_inner
.
y
)
TexelRect
:
:
new
(
px0
py1
px1
py2
)
RepeatMode
:
:
Stretch
border
.
repeat_vertical
)
;
add_segment
(
&
mut
segments
LayerRect
:
:
from_floats
(
tr_inner
.
x
tr_inner
.
y
br_outer
.
x
br_inner
.
y
)
TexelRect
:
:
new
(
px2
py1
px3
py2
)
RepeatMode
:
:
Stretch
border
.
repeat_vertical
)
;
for
segment
in
segments
{
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
.
geom_rect
;
self
.
add_image
(
clip_and_scroll
&
info
&
segment
.
stretch_size
&
segment
.
tile_spacing
Some
(
segment
.
sub_rect
)
border
.
image_key
ImageRendering
:
:
Auto
AlphaType
:
:
PremultipliedAlpha
None
)
;
}
}
BorderDetails
:
:
Normal
(
ref
border
)
=
>
{
self
.
add_normal_border
(
info
border
&
border_item
.
widths
clip_and_scroll
)
;
}
BorderDetails
:
:
Gradient
(
ref
border
)
=
>
for
segment
in
create_segments
(
border
.
outset
)
{
let
segment_rel
=
segment
.
origin
-
rect
.
origin
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
;
self
.
add_gradient
(
clip_and_scroll
&
info
border
.
gradient
.
start_point
-
segment_rel
border
.
gradient
.
end_point
-
segment_rel
gradient_stops
gradient_stops_count
border
.
gradient
.
extend_mode
segment
.
size
LayerSize
:
:
zero
(
)
)
;
}
BorderDetails
:
:
RadialGradient
(
ref
border
)
=
>
{
for
segment
in
create_segments
(
border
.
outset
)
{
let
segment_rel
=
segment
.
origin
-
rect
.
origin
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
segment
;
self
.
add_radial_gradient
(
clip_and_scroll
&
info
border
.
gradient
.
start_center
-
segment_rel
border
.
gradient
.
start_radius
border
.
gradient
.
end_center
-
segment_rel
border
.
gradient
.
end_radius
border
.
gradient
.
ratio_xy
gradient_stops
border
.
gradient
.
extend_mode
segment
.
size
LayerSize
:
:
zero
(
)
)
;
}
}
}
}
pub
fn
add_gradient
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
start_point
:
LayerPoint
end_point
:
LayerPoint
stops
:
ItemRange
<
GradientStop
>
stops_count
:
usize
extend_mode
:
ExtendMode
tile_size
:
LayerSize
tile_spacing
:
LayerSize
)
{
let
tile_repeat
=
tile_size
+
tile_spacing
;
let
is_not_tiled
=
tile_repeat
.
width
>
=
info
.
rect
.
size
.
width
&
&
tile_repeat
.
height
>
=
info
.
rect
.
size
.
height
;
let
aligned_and_fills_rect
=
(
start_point
.
x
=
=
end_point
.
x
&
&
start_point
.
y
.
min
(
end_point
.
y
)
<
=
0
.
0
&
&
start_point
.
y
.
max
(
end_point
.
y
)
>
=
info
.
rect
.
size
.
height
)
|
|
(
start_point
.
y
=
=
end_point
.
y
&
&
start_point
.
x
.
min
(
end_point
.
x
)
<
=
0
.
0
&
&
start_point
.
x
.
max
(
end_point
.
x
)
>
=
info
.
rect
.
size
.
width
)
;
let
aligned
=
extend_mode
=
=
ExtendMode
:
:
Clamp
&
&
is_not_tiled
&
&
aligned_and_fills_rect
;
let
reverse_stops
=
!
aligned
&
&
(
start_point
.
x
>
end_point
.
x
|
|
(
start_point
.
x
=
=
end_point
.
x
&
&
start_point
.
y
>
end_point
.
y
)
)
;
let
(
sp
ep
)
=
if
reverse_stops
{
(
end_point
start_point
)
}
else
{
(
start_point
end_point
)
}
;
let
gradient_cpu
=
GradientPrimitiveCpu
{
stops_range
:
stops
stops_count
extend_mode
reverse_stops
gpu_blocks
:
[
[
sp
.
x
sp
.
y
ep
.
x
ep
.
y
]
.
into
(
)
[
tile_size
.
width
tile_size
.
height
tile_repeat
.
width
tile_repeat
.
height
]
.
into
(
)
[
pack_as_float
(
extend_mode
as
u32
)
0
.
0
0
.
0
0
.
0
]
.
into
(
)
]
}
;
let
prim
=
if
aligned
{
PrimitiveContainer
:
:
AlignedGradient
(
gradient_cpu
)
}
else
{
PrimitiveContainer
:
:
AngleGradient
(
gradient_cpu
)
}
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
prim
)
;
}
pub
fn
add_radial_gradient
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
start_center
:
LayerPoint
start_radius
:
f32
end_center
:
LayerPoint
end_radius
:
f32
ratio_xy
:
f32
stops
:
ItemRange
<
GradientStop
>
extend_mode
:
ExtendMode
tile_size
:
LayerSize
tile_spacing
:
LayerSize
)
{
let
tile_repeat
=
tile_size
+
tile_spacing
;
let
radial_gradient_cpu
=
RadialGradientPrimitiveCpu
{
stops_range
:
stops
extend_mode
gpu_data_count
:
0
gpu_blocks
:
[
[
start_center
.
x
start_center
.
y
end_center
.
x
end_center
.
y
]
.
into
(
)
[
start_radius
end_radius
ratio_xy
pack_as_float
(
extend_mode
as
u32
)
]
.
into
(
)
[
tile_size
.
width
tile_size
.
height
tile_repeat
.
width
tile_repeat
.
height
]
.
into
(
)
]
}
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
RadialGradient
(
radial_gradient_cpu
)
)
;
}
pub
fn
add_text
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
run_offset
:
LayoutVector2D
info
:
&
LayerPrimitiveInfo
font
:
&
FontInstance
text_color
:
&
ColorF
glyph_range
:
ItemRange
<
GlyphInstance
>
glyph_count
:
usize
glyph_options
:
Option
<
GlyphOptions
>
)
{
if
font
.
size
.
0
<
=
0
{
return
;
}
if
font
.
size
>
=
Au
:
:
from_px
(
4096
)
{
return
;
}
let
mut
render_mode
=
self
.
config
.
default_font_render_mode
.
limit_by
(
font
.
render_mode
)
;
let
mut
flags
=
font
.
flags
;
if
let
Some
(
options
)
=
glyph_options
{
render_mode
=
render_mode
.
limit_by
(
options
.
render_mode
)
;
flags
|
=
options
.
flags
;
}
if
render_mode
=
=
FontRenderMode
:
:
Subpixel
{
if
let
Some
(
ref
stacking_context
)
=
self
.
sc_stack
.
last
(
)
{
if
!
stacking_context
.
allow_subpixel_aa
{
render_mode
=
FontRenderMode
:
:
Alpha
;
}
}
}
let
prim_font
=
FontInstance
:
:
new
(
font
.
font_key
font
.
size
*
text_color
font
.
bg_color
render_mode
font
.
subpx_dir
flags
font
.
platform_options
font
.
variations
.
clone
(
)
)
;
let
prim
=
TextRunPrimitiveCpu
{
font
:
prim_font
glyph_range
glyph_count
glyph_gpu_blocks
:
Vec
:
:
new
(
)
glyph_keys
:
Vec
:
:
new
(
)
offset
:
run_offset
shadow_color
:
ColorU
:
:
new
(
0
0
0
0
)
}
;
let
mut
fast_shadow_prims
=
Vec
:
:
new
(
)
;
for
(
idx
&
(
shadow_prim_index
_
)
)
in
self
.
shadow_prim_stack
.
iter
(
)
.
enumerate
(
)
{
let
shadow_metadata
=
&
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
let
picture_prim
=
&
self
.
prim_store
.
cpu_pictures
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
match
picture_prim
.
kind
{
PictureKind
:
:
TextShadow
{
offset
color
blur_radius
.
.
}
if
blur_radius
=
=
0
.
0
=
>
{
let
mut
text_prim
=
prim
.
clone
(
)
;
text_prim
.
shadow_color
=
color
.
into
(
)
;
text_prim
.
offset
+
=
offset
;
fast_shadow_prims
.
push
(
(
idx
text_prim
)
)
;
}
_
=
>
{
}
}
}
for
(
idx
text_prim
)
in
fast_shadow_prims
{
let
rect
=
info
.
rect
;
let
mut
info
=
info
.
clone
(
)
;
info
.
rect
=
rect
.
translate
(
&
text_prim
.
offset
)
;
let
prim_index
=
self
.
create_primitive
(
&
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
TextRun
(
text_prim
)
)
;
self
.
shadow_prim_stack
[
idx
]
.
1
.
push
(
(
prim_index
clip_and_scroll
)
)
;
}
let
prim_index
=
self
.
create_primitive
(
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
TextRun
(
prim
)
)
;
if
text_color
.
a
>
0
.
0
{
if
self
.
shadow_prim_stack
.
is_empty
(
)
{
self
.
add_primitive_to_hit_testing_list
(
info
clip_and_scroll
)
;
self
.
add_primitive_to_draw_list
(
prim_index
clip_and_scroll
)
;
}
else
{
self
.
pending_shadow_contents
.
push
(
(
prim_index
clip_and_scroll
*
info
)
)
;
}
}
for
&
(
shadow_prim_index
_
)
in
&
self
.
shadow_prim_stack
{
let
shadow_metadata
=
&
mut
self
.
prim_store
.
cpu_metadata
[
shadow_prim_index
.
0
]
;
debug_assert_eq
!
(
shadow_metadata
.
prim_kind
PrimitiveKind
:
:
Picture
)
;
let
picture
=
&
mut
self
.
prim_store
.
cpu_pictures
[
shadow_metadata
.
cpu_prim_index
.
0
]
;
match
picture
.
kind
{
PictureKind
:
:
TextShadow
{
blur_radius
.
.
}
if
blur_radius
>
0
.
0
=
>
{
picture
.
add_primitive
(
prim_index
clip_and_scroll
)
;
}
_
=
>
{
}
}
}
}
pub
fn
add_image
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
stretch_size
:
&
LayerSize
tile_spacing
:
&
LayerSize
sub_rect
:
Option
<
TexelRect
>
image_key
:
ImageKey
image_rendering
:
ImageRendering
alpha_type
:
AlphaType
tile
:
Option
<
TileOffset
>
)
{
let
sub_rect_block
=
sub_rect
.
unwrap_or
(
TexelRect
:
:
invalid
(
)
)
.
into
(
)
;
let
tile_spacing
=
if
*
tile_spacing
=
=
info
.
rect
.
size
{
LayerSize
:
:
zero
(
)
}
else
{
*
tile_spacing
}
;
let
prim_cpu
=
ImagePrimitiveCpu
{
image_key
image_rendering
tile_offset
:
tile
tile_spacing
alpha_type
gpu_blocks
:
[
[
stretch_size
.
width
stretch_size
.
height
tile_spacing
.
width
tile_spacing
.
height
]
.
into
(
)
sub_rect_block
]
}
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Image
(
prim_cpu
)
)
;
}
pub
fn
add_yuv_image
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
info
:
&
LayerPrimitiveInfo
yuv_data
:
YuvData
color_space
:
YuvColorSpace
image_rendering
:
ImageRendering
)
{
let
format
=
yuv_data
.
get_format
(
)
;
let
yuv_key
=
match
yuv_data
{
YuvData
:
:
NV12
(
plane_0
plane_1
)
=
>
[
plane_0
plane_1
ImageKey
:
:
dummy
(
)
]
YuvData
:
:
PlanarYCbCr
(
plane_0
plane_1
plane_2
)
=
>
[
plane_0
plane_1
plane_2
]
YuvData
:
:
InterleavedYCbCr
(
plane_0
)
=
>
[
plane_0
ImageKey
:
:
dummy
(
)
ImageKey
:
:
dummy
(
)
]
}
;
let
prim_cpu
=
YuvImagePrimitiveCpu
{
yuv_key
format
color_space
image_rendering
gpu_block
:
[
info
.
rect
.
size
.
width
info
.
rect
.
size
.
height
0
.
0
0
.
0
]
.
into
(
)
}
;
self
.
add_primitive
(
clip_and_scroll
info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
YuvImage
(
prim_cpu
)
)
;
}
pub
fn
hit_test
(
&
self
clip_scroll_tree
:
&
ClipScrollTree
pipeline_id
:
Option
<
PipelineId
>
point
:
WorldPoint
flags
:
HitTestFlags
)
-
>
HitTestResult
{
let
point
=
if
flags
.
contains
(
HitTestFlags
:
:
POINT_RELATIVE_TO_PIPELINE_VIEWPORT
)
{
let
point
=
LayerPoint
:
:
new
(
point
.
x
point
.
y
)
;
clip_scroll_tree
.
make_node_relative_point_absolute
(
pipeline_id
&
point
)
}
else
{
point
}
;
let
mut
node_cache
=
FastHashMap
:
:
default
(
)
;
let
mut
result
=
HitTestResult
:
:
default
(
)
;
for
&
HitTestingRun
(
ref
items
ref
clip_and_scroll
)
in
self
.
hit_testing_runs
.
iter
(
)
.
rev
(
)
{
let
scroll_node
=
&
clip_scroll_tree
.
nodes
[
&
clip_and_scroll
.
scroll_node_id
]
;
match
(
pipeline_id
scroll_node
.
pipeline_id
)
{
(
Some
(
id
)
node_id
)
if
node_id
!
=
id
=
>
continue
_
=
>
{
}
}
let
transform
=
scroll_node
.
world_content_transform
;
let
point_in_layer
=
match
transform
.
inverse
(
)
{
Some
(
inverted
)
=
>
inverted
.
transform_point2d
(
&
point
)
None
=
>
continue
}
;
let
mut
clipped_in
=
false
;
for
item
in
items
.
iter
(
)
.
rev
(
)
{
if
!
item
.
rect
.
contains
(
&
point_in_layer
)
|
|
!
item
.
clip
.
contains
(
&
point_in_layer
)
{
continue
;
}
let
clip_id
=
&
clip_and_scroll
.
clip_node_id
(
)
;
if
!
clipped_in
{
clipped_in
=
clip_scroll_tree
.
is_point_clipped_in_for_node
(
point
clip_id
&
mut
node_cache
&
self
.
clip_store
)
;
if
!
clipped_in
{
break
;
}
}
let
root_pipeline_reference_frame_id
=
ClipId
:
:
root_reference_frame
(
clip_id
.
pipeline_id
(
)
)
;
let
point_in_viewport
=
match
node_cache
.
get
(
&
root_pipeline_reference_frame_id
)
{
Some
(
&
Some
(
point
)
)
=
>
point
_
=
>
unreachable
!
(
"
Hittest
target
'
s
root
reference
frame
not
hit
.
"
)
}
;
result
.
items
.
push
(
HitTestItem
{
pipeline
:
clip_and_scroll
.
clip_node_id
(
)
.
pipeline_id
(
)
tag
:
item
.
tag
point_in_viewport
point_relative_to_item
:
point_in_layer
-
item
.
rect
.
origin
.
to_vector
(
)
}
)
;
if
!
flags
.
contains
(
HitTestFlags
:
:
FIND_ALL
)
{
return
result
;
}
}
}
result
.
items
.
dedup
(
)
;
result
}
fn
build_layer_screen_rects_and_cull_layers
(
&
mut
self
clip_scroll_tree
:
&
mut
ClipScrollTree
pipelines
:
&
FastHashMap
<
PipelineId
ScenePipeline
>
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
render_tasks
:
&
mut
RenderTaskTree
profile_counters
:
&
mut
FrameProfileCounters
device_pixel_scale
:
DevicePixelScale
scene_properties
:
&
SceneProperties
node_data
:
&
[
ClipScrollNodeData
]
local_rects
:
&
mut
Vec
<
LayerRect
>
)
-
>
Option
<
RenderTaskId
>
{
profile_scope
!
(
"
cull
"
)
;
if
self
.
prim_store
.
cpu_pictures
.
is_empty
(
)
{
return
None
}
let
prim_run_cmds
=
mem
:
:
replace
(
&
mut
self
.
prim_store
.
cpu_pictures
[
0
]
.
runs
Vec
:
:
new
(
)
)
;
let
root_clip_scroll_node
=
&
clip_scroll_tree
.
nodes
[
&
clip_scroll_tree
.
root_reference_frame_id
(
)
]
;
let
display_list
=
&
pipelines
.
get
(
&
root_clip_scroll_node
.
pipeline_id
)
.
expect
(
"
No
display
list
?
"
)
.
display_list
;
let
root_prim_context
=
PrimitiveContext
:
:
new
(
device_pixel_scale
display_list
root_clip_scroll_node
.
clip_chain
.
as_ref
(
)
root_clip_scroll_node
)
;
let
mut
child_tasks
=
Vec
:
:
new
(
)
;
self
.
prim_store
.
reset_prim_visibility
(
)
;
self
.
prim_store
.
prepare_prim_runs
(
&
prim_run_cmds
root_clip_scroll_node
.
pipeline_id
gpu_cache
resource_cache
render_tasks
&
mut
self
.
clip_store
clip_scroll_tree
pipelines
&
root_prim_context
true
&
mut
child_tasks
profile_counters
None
scene_properties
SpecificPrimitiveIndex
(
0
)
&
self
.
screen_rect
.
to_i32
(
)
node_data
local_rects
)
;
let
pic
=
&
mut
self
.
prim_store
.
cpu_pictures
[
0
]
;
pic
.
runs
=
prim_run_cmds
;
let
root_render_task
=
RenderTask
:
:
new_picture
(
None
PrimitiveIndex
(
0
)
RenderTargetKind
:
:
Color
ContentOrigin
:
:
Screen
(
DeviceIntPoint
:
:
zero
(
)
)
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
render_task_id
=
render_tasks
.
add
(
root_render_task
)
;
pic
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
Some
(
render_task_id
)
}
fn
update_scroll_bars
(
&
mut
self
clip_scroll_tree
:
&
ClipScrollTree
gpu_cache
:
&
mut
GpuCache
)
{
static
SCROLLBAR_PADDING
:
f32
=
8
.
0
;
for
scrollbar_prim
in
&
self
.
scrollbar_prims
{
let
metadata
=
&
mut
self
.
prim_store
.
cpu_metadata
[
scrollbar_prim
.
prim_index
.
0
]
;
let
scroll_frame
=
&
clip_scroll_tree
.
nodes
[
&
scrollbar_prim
.
clip_id
]
;
gpu_cache
.
invalidate
(
&
metadata
.
gpu_location
)
;
let
scrollable_distance
=
scroll_frame
.
scrollable_size
(
)
.
height
;
if
scrollable_distance
<
=
0
.
0
{
metadata
.
local_clip_rect
.
size
=
LayerSize
:
:
zero
(
)
;
continue
;
}
let
amount_scrolled
=
-
scroll_frame
.
scroll_offset
(
)
.
y
/
scrollable_distance
;
let
frame_rect
=
scrollbar_prim
.
frame_rect
;
let
min_y
=
frame_rect
.
origin
.
y
+
SCROLLBAR_PADDING
;
let
max_y
=
frame_rect
.
origin
.
y
+
frame_rect
.
size
.
height
-
(
SCROLLBAR_PADDING
+
metadata
.
local_rect
.
size
.
height
)
;
metadata
.
local_rect
.
origin
.
x
=
frame_rect
.
origin
.
x
+
frame_rect
.
size
.
width
-
(
metadata
.
local_rect
.
size
.
width
+
SCROLLBAR_PADDING
)
;
metadata
.
local_rect
.
origin
.
y
=
util
:
:
lerp
(
min_y
max_y
amount_scrolled
)
;
metadata
.
local_clip_rect
=
metadata
.
local_rect
;
}
}
pub
fn
build
(
&
mut
self
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
frame_id
:
FrameId
clip_scroll_tree
:
&
mut
ClipScrollTree
pipelines
:
&
FastHashMap
<
PipelineId
ScenePipeline
>
window_size
:
DeviceUintSize
device_pixel_scale
:
DevicePixelScale
layer
:
DocumentLayer
pan
:
WorldPoint
texture_cache_profile
:
&
mut
TextureCacheProfileCounters
gpu_cache_profile
:
&
mut
GpuCacheProfileCounters
scene_properties
:
&
SceneProperties
)
-
>
Frame
{
profile_scope
!
(
"
build
"
)
;
debug_assert
!
(
DeviceUintRect
:
:
new
(
DeviceUintPoint
:
:
zero
(
)
window_size
)
.
contains_rect
(
&
self
.
screen_rect
)
)
;
let
mut
profile_counters
=
FrameProfileCounters
:
:
new
(
)
;
profile_counters
.
total_primitives
.
set
(
self
.
prim_store
.
prim_count
(
)
)
;
resource_cache
.
begin_frame
(
frame_id
)
;
gpu_cache
.
begin_frame
(
)
;
let
mut
node_data
=
Vec
:
:
with_capacity
(
clip_scroll_tree
.
nodes
.
len
(
)
)
;
let
total_prim_runs
=
self
.
prim_store
.
cpu_pictures
.
iter
(
)
.
fold
(
1
|
count
ref
pic
|
count
+
pic
.
runs
.
len
(
)
)
;
let
mut
clip_chain_local_clip_rects
=
Vec
:
:
with_capacity
(
total_prim_runs
)
;
clip_chain_local_clip_rects
.
push
(
LayerRect
:
:
max_rect
(
)
)
;
clip_scroll_tree
.
update_tree
(
&
self
.
screen_rect
.
to_i32
(
)
device_pixel_scale
&
mut
self
.
clip_store
resource_cache
gpu_cache
pan
&
mut
node_data
scene_properties
)
;
self
.
update_scroll_bars
(
clip_scroll_tree
gpu_cache
)
;
let
mut
render_tasks
=
RenderTaskTree
:
:
new
(
)
;
let
main_render_task_id
=
self
.
build_layer_screen_rects_and_cull_layers
(
clip_scroll_tree
pipelines
resource_cache
gpu_cache
&
mut
render_tasks
&
mut
profile_counters
device_pixel_scale
scene_properties
&
node_data
&
mut
clip_chain_local_clip_rects
)
;
let
mut
passes
=
Vec
:
:
new
(
)
;
resource_cache
.
block_until_all_resources_added
(
gpu_cache
texture_cache_profile
)
;
if
let
Some
(
main_render_task_id
)
=
main_render_task_id
{
let
mut
required_pass_count
=
0
;
render_tasks
.
max_depth
(
main_render_task_id
0
&
mut
required_pass_count
)
;
assert_ne
!
(
required_pass_count
0
)
;
for
_
in
0
.
.
required_pass_count
-
1
{
passes
.
push
(
RenderPass
:
:
new_off_screen
(
self
.
screen_rect
.
size
.
to_i32
(
)
)
)
;
}
passes
.
push
(
RenderPass
:
:
new_main_framebuffer
(
self
.
screen_rect
.
size
.
to_i32
(
)
)
)
;
render_tasks
.
assign_to_passes
(
main_render_task_id
required_pass_count
-
1
&
mut
passes
)
;
}
let
mut
deferred_resolves
=
vec
!
[
]
;
let
use_dual_source_blending
=
self
.
config
.
dual_source_blending_is_enabled
&
&
self
.
config
.
dual_source_blending_is_supported
;
for
(
pass_index
pass
)
in
passes
.
iter_mut
(
)
.
enumerate
(
)
{
let
ctx
=
RenderTargetContext
{
device_pixel_scale
prim_store
:
&
self
.
prim_store
resource_cache
node_data
:
&
node_data
clip_scroll_tree
use_dual_source_blending
}
;
pass
.
build
(
&
ctx
gpu_cache
&
mut
render_tasks
&
mut
deferred_resolves
&
self
.
clip_store
RenderPassIndex
(
pass_index
)
)
;
}
let
gpu_cache_updates
=
gpu_cache
.
end_frame
(
gpu_cache_profile
)
;
render_tasks
.
build
(
)
;
resource_cache
.
end_frame
(
)
;
Frame
{
window_size
inner_rect
:
self
.
screen_rect
device_pixel_ratio
:
device_pixel_scale
.
0
background_color
:
self
.
background_color
layer
profile_counters
passes
node_data
clip_chain_local_clip_rects
render_tasks
deferred_resolves
gpu_cache_updates
:
Some
(
gpu_cache_updates
)
}
}
}
