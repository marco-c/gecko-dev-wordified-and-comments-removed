use
device
:
:
FrameId
;
use
internal_types
:
:
UvRect
;
use
profiler
:
:
GpuCacheProfileCounters
;
use
renderer
:
:
MAX_VERTEX_TEXTURE_WIDTH
;
use
std
:
:
{
mem
u32
}
;
use
api
:
:
{
ColorF
LayerRect
}
;
pub
const
GPU_CACHE_INITIAL_HEIGHT
:
u32
=
512
;
const
FRAMES_BEFORE_EVICTION
:
usize
=
10
;
const
NEW_ROWS_PER_RESIZE
:
u32
=
512
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
)
]
struct
Epoch
(
u32
)
;
impl
Epoch
{
fn
next
(
&
mut
self
)
{
*
self
=
Epoch
(
self
.
0
.
wrapping_add
(
1
)
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
CacheLocation
{
block_index
:
BlockIndex
epoch
:
Epoch
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
GpuBlockData
{
pub
data
:
[
f32
;
4
]
}
impl
GpuBlockData
{
pub
fn
empty
(
)
-
>
GpuBlockData
{
GpuBlockData
{
data
:
[
0
.
0
;
4
]
}
}
}
impl
Into
<
GpuBlockData
>
for
ColorF
{
fn
into
(
self
)
-
>
GpuBlockData
{
GpuBlockData
{
data
:
[
self
.
r
self
.
g
self
.
b
self
.
a
]
}
}
}
impl
Into
<
GpuBlockData
>
for
[
f32
;
4
]
{
fn
into
(
self
)
-
>
GpuBlockData
{
GpuBlockData
{
data
:
self
}
}
}
impl
Into
<
GpuBlockData
>
for
LayerRect
{
fn
into
(
self
)
-
>
GpuBlockData
{
GpuBlockData
{
data
:
[
self
.
origin
.
x
self
.
origin
.
y
self
.
size
.
width
self
.
size
.
height
]
}
}
}
impl
Into
<
GpuBlockData
>
for
UvRect
{
fn
into
(
self
)
-
>
GpuBlockData
{
GpuBlockData
{
data
:
[
self
.
uv0
.
x
self
.
uv0
.
y
self
.
uv1
.
x
self
.
uv1
.
y
]
}
}
}
pub
trait
ToGpuBlocks
{
fn
write_gpu_blocks
(
&
self
GpuDataRequest
)
;
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
GpuCacheHandle
{
location
:
Option
<
CacheLocation
>
}
impl
GpuCacheHandle
{
pub
fn
new
(
)
-
>
GpuCacheHandle
{
GpuCacheHandle
{
location
:
None
}
}
}
#
[
derive
(
Copy
Debug
Clone
)
]
pub
struct
GpuCacheAddress
{
pub
u
:
u16
pub
v
:
u16
}
impl
GpuCacheAddress
{
fn
new
(
u
:
usize
v
:
usize
)
-
>
GpuCacheAddress
{
GpuCacheAddress
{
u
:
u
as
u16
v
:
v
as
u16
}
}
}
#
[
derive
(
Debug
)
]
struct
Block
{
address
:
GpuCacheAddress
next
:
Option
<
BlockIndex
>
epoch
:
Epoch
last_access_time
:
FrameId
}
impl
Block
{
fn
new
(
address
:
GpuCacheAddress
next
:
Option
<
BlockIndex
>
frame_id
:
FrameId
)
-
>
Block
{
Block
{
address
next
last_access_time
:
frame_id
epoch
:
Epoch
(
0
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
BlockIndex
(
usize
)
;
struct
Row
{
block_count_per_item
:
usize
}
impl
Row
{
fn
new
(
block_count_per_item
:
usize
)
-
>
Row
{
Row
{
block_count_per_item
}
}
}
pub
enum
GpuCacheUpdate
{
Copy
{
block_index
:
usize
block_count
:
usize
address
:
GpuCacheAddress
}
}
pub
struct
GpuCacheUpdateList
{
pub
height
:
u32
pub
updates
:
Vec
<
GpuCacheUpdate
>
pub
blocks
:
Vec
<
GpuBlockData
>
}
struct
FreeBlockLists
{
free_list_1
:
Option
<
BlockIndex
>
free_list_2
:
Option
<
BlockIndex
>
free_list_4
:
Option
<
BlockIndex
>
free_list_8
:
Option
<
BlockIndex
>
free_list_16
:
Option
<
BlockIndex
>
free_list_32
:
Option
<
BlockIndex
>
free_list_64
:
Option
<
BlockIndex
>
free_list_128
:
Option
<
BlockIndex
>
free_list_large
:
Option
<
BlockIndex
>
}
impl
FreeBlockLists
{
fn
new
(
)
-
>
FreeBlockLists
{
FreeBlockLists
{
free_list_1
:
None
free_list_2
:
None
free_list_4
:
None
free_list_8
:
None
free_list_16
:
None
free_list_32
:
None
free_list_64
:
None
free_list_128
:
None
free_list_large
:
None
}
}
fn
get_actual_block_count_and_free_list
(
&
mut
self
block_count
:
usize
)
-
>
(
usize
&
mut
Option
<
BlockIndex
>
)
{
match
block_count
{
0
=
>
panic
!
(
"
Can
'
t
allocate
zero
sized
blocks
!
"
)
1
=
>
(
1
&
mut
self
.
free_list_1
)
2
=
>
(
2
&
mut
self
.
free_list_2
)
3
.
.
.
4
=
>
(
4
&
mut
self
.
free_list_4
)
5
.
.
.
8
=
>
(
8
&
mut
self
.
free_list_8
)
9
.
.
.
16
=
>
(
16
&
mut
self
.
free_list_16
)
17
.
.
.
32
=
>
(
32
&
mut
self
.
free_list_32
)
33
.
.
.
64
=
>
(
64
&
mut
self
.
free_list_64
)
65
.
.
.
128
=
>
(
128
&
mut
self
.
free_list_128
)
129
.
.
.
MAX_VERTEX_TEXTURE_WIDTH
=
>
(
MAX_VERTEX_TEXTURE_WIDTH
&
mut
self
.
free_list_large
)
_
=
>
panic
!
(
"
Can
'
t
allocate
>
MAX_VERTEX_TEXTURE_WIDTH
per
resource
!
"
)
}
}
}
struct
Texture
{
height
:
u32
blocks
:
Vec
<
Block
>
rows
:
Vec
<
Row
>
free_lists
:
FreeBlockLists
occupied_list_head
:
Option
<
BlockIndex
>
pending_blocks
:
Vec
<
GpuBlockData
>
updates
:
Vec
<
GpuCacheUpdate
>
allocated_block_count
:
usize
}
impl
Texture
{
fn
new
(
)
-
>
Texture
{
Texture
{
height
:
GPU_CACHE_INITIAL_HEIGHT
blocks
:
Vec
:
:
new
(
)
rows
:
Vec
:
:
new
(
)
free_lists
:
FreeBlockLists
:
:
new
(
)
pending_blocks
:
Vec
:
:
new
(
)
updates
:
Vec
:
:
new
(
)
occupied_list_head
:
None
allocated_block_count
:
0
}
}
fn
push_data
(
&
mut
self
pending_block_index
:
Option
<
usize
>
block_count
:
usize
frame_id
:
FrameId
)
-
>
CacheLocation
{
let
(
alloc_size
free_list
)
=
self
.
free_lists
.
get_actual_block_count_and_free_list
(
block_count
)
;
if
free_list
.
is_none
(
)
{
if
self
.
rows
.
len
(
)
as
u32
=
=
self
.
height
{
self
.
height
+
=
NEW_ROWS_PER_RESIZE
;
}
let
items_per_row
=
MAX_VERTEX_TEXTURE_WIDTH
/
alloc_size
;
let
row_index
=
self
.
rows
.
len
(
)
;
self
.
rows
.
push
(
Row
:
:
new
(
alloc_size
)
)
;
let
mut
prev_block_index
=
None
;
for
i
in
0
.
.
items_per_row
{
let
address
=
GpuCacheAddress
:
:
new
(
i
*
alloc_size
row_index
)
;
let
block_index
=
BlockIndex
(
self
.
blocks
.
len
(
)
)
;
let
block
=
Block
:
:
new
(
address
prev_block_index
frame_id
)
;
self
.
blocks
.
push
(
block
)
;
prev_block_index
=
Some
(
block_index
)
;
}
*
free_list
=
prev_block_index
;
}
let
free_block_index
=
free_list
.
take
(
)
.
unwrap
(
)
;
let
block
=
&
mut
self
.
blocks
[
free_block_index
.
0
as
usize
]
;
*
free_list
=
block
.
next
;
block
.
next
=
self
.
occupied_list_head
;
block
.
last_access_time
=
frame_id
;
self
.
occupied_list_head
=
Some
(
free_block_index
)
;
self
.
allocated_block_count
+
=
alloc_size
;
if
let
Some
(
pending_block_index
)
=
pending_block_index
{
self
.
updates
.
push
(
GpuCacheUpdate
:
:
Copy
{
block_index
:
pending_block_index
block_count
address
:
block
.
address
}
)
;
}
CacheLocation
{
block_index
:
free_block_index
epoch
:
block
.
epoch
}
}
fn
evict_old_blocks
(
&
mut
self
frame_id
:
FrameId
)
{
let
mut
current_block
=
self
.
occupied_list_head
;
let
mut
prev_block
:
Option
<
BlockIndex
>
=
None
;
while
let
Some
(
index
)
=
current_block
{
let
(
next_block
should_unlink
)
=
{
let
block
=
&
mut
self
.
blocks
[
index
.
0
as
usize
]
;
let
next_block
=
block
.
next
;
let
mut
should_unlink
=
false
;
if
block
.
last_access_time
+
FRAMES_BEFORE_EVICTION
<
frame_id
{
should_unlink
=
true
;
let
row
=
&
mut
self
.
rows
[
block
.
address
.
v
as
usize
]
;
let
(
_
free_list
)
=
self
.
free_lists
.
get_actual_block_count_and_free_list
(
row
.
block_count_per_item
)
;
block
.
epoch
.
next
(
)
;
block
.
next
=
*
free_list
;
*
free_list
=
Some
(
index
)
;
self
.
allocated_block_count
-
=
row
.
block_count_per_item
;
}
;
(
next_block
should_unlink
)
}
;
if
should_unlink
{
match
prev_block
{
Some
(
prev_block
)
=
>
{
self
.
blocks
[
prev_block
.
0
as
usize
]
.
next
=
next_block
;
}
None
=
>
{
self
.
occupied_list_head
=
next_block
;
}
}
}
else
{
prev_block
=
current_block
;
}
current_block
=
next_block
;
}
}
}
#
[
must_use
]
pub
struct
GpuDataRequest
<
'
a
>
{
handle
:
&
'
a
mut
GpuCacheHandle
frame_id
:
FrameId
start_index
:
usize
texture
:
&
'
a
mut
Texture
}
impl
<
'
a
>
GpuDataRequest
<
'
a
>
{
pub
fn
push
<
B
>
(
&
mut
self
block
:
B
)
where
B
:
Into
<
GpuBlockData
>
{
self
.
texture
.
pending_blocks
.
push
(
block
.
into
(
)
)
;
}
pub
fn
extend_from_slice
(
&
mut
self
blocks
:
&
[
GpuBlockData
]
)
{
self
.
texture
.
pending_blocks
.
extend_from_slice
(
blocks
)
;
}
pub
fn
close
(
self
)
-
>
usize
{
self
.
texture
.
pending_blocks
.
len
(
)
-
self
.
start_index
}
}
impl
<
'
a
>
Drop
for
GpuDataRequest
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
let
block_count
=
self
.
texture
.
pending_blocks
.
len
(
)
-
self
.
start_index
;
let
location
=
self
.
texture
.
push_data
(
Some
(
self
.
start_index
)
block_count
self
.
frame_id
)
;
self
.
handle
.
location
=
Some
(
location
)
;
}
}
pub
struct
GpuCache
{
frame_id
:
FrameId
texture
:
Texture
}
impl
GpuCache
{
pub
fn
new
(
)
-
>
GpuCache
{
GpuCache
{
frame_id
:
FrameId
:
:
new
(
0
)
texture
:
Texture
:
:
new
(
)
}
}
pub
fn
begin_frame
(
&
mut
self
)
{
debug_assert
!
(
self
.
texture
.
pending_blocks
.
is_empty
(
)
)
;
self
.
frame_id
=
self
.
frame_id
+
1
;
self
.
texture
.
evict_old_blocks
(
self
.
frame_id
)
;
}
pub
fn
invalidate
(
&
mut
self
handle
:
&
GpuCacheHandle
)
{
if
let
Some
(
ref
location
)
=
handle
.
location
{
let
block
=
&
mut
self
.
texture
.
blocks
[
location
.
block_index
.
0
]
;
block
.
epoch
.
next
(
)
;
}
}
pub
fn
request
<
'
a
>
(
&
'
a
mut
self
handle
:
&
'
a
mut
GpuCacheHandle
)
-
>
Option
<
GpuDataRequest
<
'
a
>
>
{
if
let
Some
(
ref
location
)
=
handle
.
location
{
let
block
=
&
mut
self
.
texture
.
blocks
[
location
.
block_index
.
0
]
;
if
block
.
epoch
=
=
location
.
epoch
{
block
.
last_access_time
=
self
.
frame_id
;
return
None
}
}
Some
(
GpuDataRequest
{
handle
frame_id
:
self
.
frame_id
start_index
:
self
.
texture
.
pending_blocks
.
len
(
)
texture
:
&
mut
self
.
texture
}
)
}
pub
fn
push_per_frame_blocks
(
&
mut
self
blocks
:
&
[
GpuBlockData
]
)
-
>
GpuCacheHandle
{
let
start_index
=
self
.
texture
.
pending_blocks
.
len
(
)
;
self
.
texture
.
pending_blocks
.
extend_from_slice
(
blocks
)
;
let
location
=
self
.
texture
.
push_data
(
Some
(
start_index
)
blocks
.
len
(
)
self
.
frame_id
)
;
GpuCacheHandle
{
location
:
Some
(
location
)
}
}
pub
fn
push_deferred_per_frame_blocks
(
&
mut
self
block_count
:
usize
)
-
>
GpuCacheHandle
{
let
location
=
self
.
texture
.
push_data
(
None
block_count
self
.
frame_id
)
;
GpuCacheHandle
{
location
:
Some
(
location
)
}
}
pub
fn
end_frame
(
&
mut
self
profile_counters
:
&
mut
GpuCacheProfileCounters
)
-
>
GpuCacheUpdateList
{
profile_counters
.
allocated_rows
.
set
(
self
.
texture
.
rows
.
len
(
)
)
;
profile_counters
.
allocated_blocks
.
set
(
self
.
texture
.
allocated_block_count
)
;
GpuCacheUpdateList
{
height
:
self
.
texture
.
height
updates
:
mem
:
:
replace
(
&
mut
self
.
texture
.
updates
Vec
:
:
new
(
)
)
blocks
:
mem
:
:
replace
(
&
mut
self
.
texture
.
pending_blocks
Vec
:
:
new
(
)
)
}
}
pub
fn
get_address
(
&
self
id
:
&
GpuCacheHandle
)
-
>
GpuCacheAddress
{
let
location
=
id
.
location
.
expect
(
"
handle
not
requested
or
allocated
!
"
)
;
let
block
=
&
self
.
texture
.
blocks
[
location
.
block_index
.
0
]
;
debug_assert_eq
!
(
block
.
epoch
location
.
epoch
)
;
debug_assert_eq
!
(
block
.
last_access_time
self
.
frame_id
)
;
block
.
address
}
}
