use
api
:
:
{
TileOffset
LayoutRect
LayoutSize
LayoutVector2D
DeviceUintSize
}
;
use
euclid
:
:
rect
;
pub
fn
simplify_repeated_primitive
(
stretch_size
:
&
LayoutSize
tile_spacing
:
&
mut
LayoutSize
prim_rect
:
&
mut
LayoutRect
)
{
let
stride
=
*
stretch_size
+
*
tile_spacing
;
if
stride
.
width
>
=
prim_rect
.
size
.
width
{
tile_spacing
.
width
=
0
.
0
;
prim_rect
.
size
.
width
=
f32
:
:
min
(
prim_rect
.
size
.
width
stretch_size
.
width
)
;
}
if
stride
.
height
>
=
prim_rect
.
size
.
height
{
tile_spacing
.
height
=
0
.
0
;
prim_rect
.
size
.
height
=
f32
:
:
min
(
prim_rect
.
size
.
height
stretch_size
.
height
)
;
}
}
pub
struct
DecomposedTile
{
pub
rect
:
LayoutRect
pub
stretch_size
:
LayoutSize
pub
tile_offset
:
TileOffset
}
pub
struct
TiledImageInfo
{
pub
rect
:
LayoutRect
pub
tile_spacing
:
LayoutSize
pub
stretch_size
:
LayoutSize
pub
device_image_size
:
DeviceUintSize
pub
device_tile_size
:
u32
}
pub
fn
decompose_image
(
info
:
&
TiledImageInfo
callback
:
&
mut
FnMut
(
&
DecomposedTile
)
)
{
let
no_vertical_tiling
=
info
.
device_image_size
.
height
<
=
info
.
device_tile_size
;
let
no_vertical_spacing
=
info
.
tile_spacing
.
height
=
=
0
.
0
;
if
no_vertical_tiling
&
&
no_vertical_spacing
{
decompose_row
(
&
info
.
rect
info
callback
)
;
return
;
}
let
layout_stride
=
info
.
stretch_size
.
height
+
info
.
tile_spacing
.
height
;
let
num_repetitions
=
(
info
.
rect
.
size
.
height
/
layout_stride
)
.
ceil
(
)
as
u32
;
for
i
in
0
.
.
num_repetitions
{
let
row_rect
=
rect
(
info
.
rect
.
origin
.
x
info
.
rect
.
origin
.
y
+
(
i
as
f32
)
*
layout_stride
info
.
rect
.
size
.
width
info
.
stretch_size
.
height
)
.
intersection
(
&
info
.
rect
)
;
if
let
Some
(
row_rect
)
=
row_rect
{
decompose_row
(
&
row_rect
info
callback
)
;
}
}
}
fn
decompose_row
(
item_rect
:
&
LayoutRect
info
:
&
TiledImageInfo
callback
:
&
mut
FnMut
(
&
DecomposedTile
)
)
{
let
no_horizontal_tiling
=
info
.
device_image_size
.
width
<
=
info
.
device_tile_size
;
let
no_horizontal_spacing
=
info
.
tile_spacing
.
width
=
=
0
.
0
;
if
no_horizontal_tiling
&
&
no_horizontal_spacing
{
decompose_cache_tiles
(
item_rect
info
callback
)
;
return
;
}
let
layout_stride
=
info
.
stretch_size
.
width
+
info
.
tile_spacing
.
width
;
let
num_repetitions
=
(
item_rect
.
size
.
width
/
layout_stride
)
.
ceil
(
)
as
u32
;
for
i
in
0
.
.
num_repetitions
{
let
decomposed_rect
=
rect
(
item_rect
.
origin
.
x
+
(
i
as
f32
)
*
layout_stride
item_rect
.
origin
.
y
info
.
stretch_size
.
width
item_rect
.
size
.
height
)
.
intersection
(
item_rect
)
;
if
let
Some
(
decomposed_rect
)
=
decomposed_rect
{
decompose_cache_tiles
(
&
decomposed_rect
info
callback
)
;
}
}
}
fn
decompose_cache_tiles
(
item_rect
:
&
LayoutRect
info
:
&
TiledImageInfo
callback
:
&
mut
FnMut
(
&
DecomposedTile
)
)
{
let
needs_repeat_x
=
info
.
stretch_size
.
width
<
item_rect
.
size
.
width
;
let
needs_repeat_y
=
info
.
stretch_size
.
height
<
item_rect
.
size
.
height
;
let
tiled_in_x
=
info
.
device_image_size
.
width
>
info
.
device_tile_size
;
let
tiled_in_y
=
info
.
device_image_size
.
height
>
info
.
device_tile_size
;
let
shader_repeat_x
=
needs_repeat_x
&
&
!
tiled_in_x
;
let
shader_repeat_y
=
needs_repeat_y
&
&
!
tiled_in_y
;
let
tile_size_f32
=
info
.
device_tile_size
as
f32
;
let
num_tiles_x
=
(
info
.
device_image_size
.
width
/
info
.
device_tile_size
)
as
u16
;
let
num_tiles_y
=
(
info
.
device_image_size
.
height
/
info
.
device_tile_size
)
as
u16
;
let
img_dw
=
tile_size_f32
/
(
info
.
device_image_size
.
width
as
f32
)
;
let
img_dh
=
tile_size_f32
/
(
info
.
device_image_size
.
height
as
f32
)
;
let
stretched_tile_size
=
LayoutSize
:
:
new
(
img_dw
*
info
.
stretch_size
.
width
img_dh
*
info
.
stretch_size
.
height
)
;
let
leftover
=
DeviceUintSize
:
:
new
(
info
.
device_image_size
.
width
%
info
.
device_tile_size
info
.
device_image_size
.
height
%
info
.
device_tile_size
)
;
for
ty
in
0
.
.
num_tiles_y
{
for
tx
in
0
.
.
num_tiles_x
{
add_device_tile
(
item_rect
stretched_tile_size
TileOffset
:
:
new
(
tx
ty
)
1
.
0
1
.
0
shader_repeat_x
shader_repeat_y
callback
)
;
}
if
leftover
.
width
!
=
0
{
add_device_tile
(
item_rect
stretched_tile_size
TileOffset
:
:
new
(
num_tiles_x
ty
)
(
leftover
.
width
as
f32
)
/
tile_size_f32
1
.
0
shader_repeat_x
shader_repeat_y
callback
)
;
}
}
if
leftover
.
height
!
=
0
{
for
tx
in
0
.
.
num_tiles_x
{
add_device_tile
(
item_rect
stretched_tile_size
TileOffset
:
:
new
(
tx
num_tiles_y
)
1
.
0
(
leftover
.
height
as
f32
)
/
tile_size_f32
shader_repeat_x
shader_repeat_y
callback
)
;
}
if
leftover
.
width
!
=
0
{
add_device_tile
(
item_rect
stretched_tile_size
TileOffset
:
:
new
(
num_tiles_x
num_tiles_y
)
(
leftover
.
width
as
f32
)
/
tile_size_f32
(
leftover
.
height
as
f32
)
/
tile_size_f32
shader_repeat_x
shader_repeat_y
callback
)
;
}
}
}
fn
add_device_tile
(
item_rect
:
&
LayoutRect
stretched_tile_size
:
LayoutSize
tile_offset
:
TileOffset
tile_ratio_width
:
f32
tile_ratio_height
:
f32
shader_repeat_x
:
bool
shader_repeat_y
:
bool
callback
:
&
mut
FnMut
(
&
DecomposedTile
)
)
{
let
stretch_size
=
LayoutSize
:
:
new
(
stretched_tile_size
.
width
*
tile_ratio_width
stretched_tile_size
.
height
*
tile_ratio_height
)
;
let
mut
prim_rect
=
LayoutRect
:
:
new
(
item_rect
.
origin
+
LayoutVector2D
:
:
new
(
tile_offset
.
x
as
f32
*
stretched_tile_size
.
width
tile_offset
.
y
as
f32
*
stretched_tile_size
.
height
)
stretch_size
)
;
if
shader_repeat_x
{
assert_eq
!
(
tile_offset
.
x
0
)
;
prim_rect
.
size
.
width
=
item_rect
.
size
.
width
;
}
if
shader_repeat_y
{
assert_eq
!
(
tile_offset
.
y
0
)
;
prim_rect
.
size
.
height
=
item_rect
.
size
.
height
;
}
if
let
Some
(
rect
)
=
prim_rect
.
intersection
(
item_rect
)
{
callback
(
&
DecomposedTile
{
tile_offset
rect
stretch_size
}
)
;
}
}
