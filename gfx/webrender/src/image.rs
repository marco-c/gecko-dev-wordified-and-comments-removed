use
api
:
:
{
TileOffset
LayoutRect
LayoutSize
LayoutPoint
DeviceUintSize
}
;
use
euclid
:
:
vec2
;
use
prim_store
:
:
EdgeAaSegmentMask
;
pub
fn
simplify_repeated_primitive
(
stretch_size
:
&
LayoutSize
tile_spacing
:
&
mut
LayoutSize
prim_rect
:
&
mut
LayoutRect
)
{
let
stride
=
*
stretch_size
+
*
tile_spacing
;
if
stride
.
width
>
=
prim_rect
.
size
.
width
{
tile_spacing
.
width
=
0
.
0
;
prim_rect
.
size
.
width
=
f32
:
:
min
(
prim_rect
.
size
.
width
stretch_size
.
width
)
;
}
if
stride
.
height
>
=
prim_rect
.
size
.
height
{
tile_spacing
.
height
=
0
.
0
;
prim_rect
.
size
.
height
=
f32
:
:
min
(
prim_rect
.
size
.
height
stretch_size
.
height
)
;
}
}
pub
fn
for_each_repetition
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
stride
:
&
LayoutSize
callback
:
&
mut
FnMut
(
&
LayoutPoint
EdgeAaSegmentMask
)
)
{
assert
!
(
stride
.
width
>
0
.
0
)
;
assert
!
(
stride
.
height
>
0
.
0
)
;
let
visible_rect
=
match
prim_rect
.
intersection
(
&
visible_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
}
;
let
nx
=
if
visible_rect
.
origin
.
x
>
prim_rect
.
origin
.
x
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
x
-
prim_rect
.
origin
.
x
)
/
stride
.
width
)
}
else
{
0
.
0
}
;
let
ny
=
if
visible_rect
.
origin
.
y
>
prim_rect
.
origin
.
y
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
y
-
prim_rect
.
origin
.
y
)
/
stride
.
height
)
}
else
{
0
.
0
}
;
let
x0
=
prim_rect
.
origin
.
x
+
nx
*
stride
.
width
;
let
y0
=
prim_rect
.
origin
.
y
+
ny
*
stride
.
height
;
let
mut
p
=
LayoutPoint
:
:
new
(
x0
y0
)
;
let
x_most
=
visible_rect
.
max_x
(
)
;
let
y_most
=
visible_rect
.
max_y
(
)
;
let
x_count
=
f32
:
:
ceil
(
(
x_most
-
x0
)
/
stride
.
width
)
as
i32
;
let
y_count
=
f32
:
:
ceil
(
(
y_most
-
y0
)
/
stride
.
height
)
as
i32
;
for
y
in
0
.
.
y_count
{
let
mut
row_flags
=
EdgeAaSegmentMask
:
:
empty
(
)
;
if
y
=
=
0
{
row_flags
|
=
EdgeAaSegmentMask
:
:
TOP
;
}
if
y
=
=
y_count
-
1
{
row_flags
|
=
EdgeAaSegmentMask
:
:
BOTTOM
;
}
for
x
in
0
.
.
x_count
{
let
mut
edge_flags
=
row_flags
;
if
x
=
=
0
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
LEFT
;
}
if
x
=
=
x_count
-
1
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
RIGHT
;
}
callback
(
&
p
edge_flags
)
;
p
.
x
+
=
stride
.
width
;
}
p
.
x
=
x0
;
p
.
y
+
=
stride
.
height
;
}
}
pub
fn
for_each_tile
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
device_image_size
:
&
DeviceUintSize
device_tile_size
:
u32
callback
:
&
mut
FnMut
(
&
LayoutRect
TileOffset
EdgeAaSegmentMask
)
)
{
let
visible_rect
=
match
prim_rect
.
intersection
(
&
visible_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
}
;
let
device_tile_size_f32
=
device_tile_size
as
f32
;
let
tile_dw
=
device_tile_size_f32
/
(
device_image_size
.
width
as
f32
)
;
let
tile_dh
=
device_tile_size_f32
/
(
device_image_size
.
height
as
f32
)
;
let
layer_tile_size
=
LayoutSize
:
:
new
(
tile_dw
*
prim_rect
.
size
.
width
tile_dh
*
prim_rect
.
size
.
height
)
;
let
leftover_device_size
=
DeviceUintSize
:
:
new
(
device_image_size
.
width
%
device_tile_size
device_image_size
.
height
%
device_tile_size
)
;
let
leftover_layer_size
=
LayoutSize
:
:
new
(
layer_tile_size
.
width
*
leftover_device_size
.
width
as
f32
/
device_tile_size_f32
layer_tile_size
.
height
*
leftover_device_size
.
height
as
f32
/
device_tile_size_f32
)
;
let
leftover_offset
=
TileOffset
:
:
new
(
(
device_image_size
.
width
/
device_tile_size
)
as
u16
(
device_image_size
.
height
/
device_tile_size
)
as
u16
)
;
let
t0
=
TileOffset
:
:
new
(
if
visible_rect
.
origin
.
x
>
prim_rect
.
origin
.
x
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
x
-
prim_rect
.
origin
.
x
)
/
layer_tile_size
.
width
)
as
u16
}
else
{
0
}
if
visible_rect
.
origin
.
y
>
prim_rect
.
origin
.
y
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
y
-
prim_rect
.
origin
.
y
)
/
layer_tile_size
.
height
)
as
u16
}
else
{
0
}
)
;
let
x_count
=
f32
:
:
ceil
(
(
visible_rect
.
max_x
(
)
-
prim_rect
.
origin
.
x
)
/
layer_tile_size
.
width
)
as
u16
-
t0
.
x
;
let
y_count
=
f32
:
:
ceil
(
(
visible_rect
.
max_y
(
)
-
prim_rect
.
origin
.
y
)
/
layer_tile_size
.
height
)
as
u16
-
t0
.
y
;
for
y
in
0
.
.
y_count
{
let
mut
row_flags
=
EdgeAaSegmentMask
:
:
empty
(
)
;
if
y
=
=
0
{
row_flags
|
=
EdgeAaSegmentMask
:
:
TOP
;
}
if
y
=
=
y_count
-
1
{
row_flags
|
=
EdgeAaSegmentMask
:
:
BOTTOM
;
}
for
x
in
0
.
.
x_count
{
let
tile_offset
=
t0
+
vec2
(
x
y
)
;
let
mut
segment_rect
=
LayoutRect
{
origin
:
LayoutPoint
:
:
new
(
prim_rect
.
origin
.
x
+
tile_offset
.
x
as
f32
*
layer_tile_size
.
width
prim_rect
.
origin
.
y
+
tile_offset
.
y
as
f32
*
layer_tile_size
.
height
)
size
:
layer_tile_size
}
;
if
tile_offset
.
x
=
=
leftover_offset
.
x
{
segment_rect
.
size
.
width
=
leftover_layer_size
.
width
;
}
if
tile_offset
.
y
=
=
leftover_offset
.
y
{
segment_rect
.
size
.
height
=
leftover_layer_size
.
height
;
}
let
mut
edge_flags
=
row_flags
;
if
x
=
=
0
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
LEFT
;
}
if
x
=
=
x_count
-
1
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
RIGHT
;
}
callback
(
&
segment_rect
tile_offset
edge_flags
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
std
:
:
collections
:
:
HashSet
;
use
api
:
:
{
LayoutRect
DeviceUintSize
}
;
use
euclid
:
:
{
rect
size2
}
;
fn
checked_for_each_tile
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
device_image_size
:
&
DeviceUintSize
device_tile_size
:
u32
callback
:
&
mut
FnMut
(
&
LayoutRect
TileOffset
EdgeAaSegmentMask
)
)
{
let
mut
coverage
=
LayoutRect
:
:
zero
(
)
;
let
mut
tiles
=
HashSet
:
:
new
(
)
;
for_each_tile
(
prim_rect
visible_rect
device_image_size
device_tile_size
&
mut
|
tile_rect
tile_offset
tile_flags
|
{
assert
!
(
!
tiles
.
contains
(
&
tile_offset
)
)
;
tiles
.
insert
(
tile_offset
)
;
coverage
=
coverage
.
union
(
tile_rect
)
;
assert
!
(
prim_rect
.
contains_rect
(
&
tile_rect
)
)
;
callback
(
tile_rect
tile_offset
tile_flags
)
;
}
)
;
assert
!
(
prim_rect
.
contains_rect
(
&
coverage
)
)
;
assert
!
(
coverage
.
contains_rect
(
&
visible_rect
.
intersection
(
&
prim_rect
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
)
)
;
}
#
[
test
]
fn
basic
(
)
{
let
mut
count
=
0
;
checked_for_each_tile
(
&
rect
(
0
.
0
.
1000
.
1000
.
)
&
rect
(
75
.
75
.
400
.
400
.
)
&
size2
(
400
400
)
36
&
mut
|
_tile_rect
_tile_offset
_tile_flags
|
{
count
+
=
1
;
}
)
;
assert_eq
!
(
count
36
)
;
}
#
[
test
]
fn
empty
(
)
{
let
mut
count
=
0
;
checked_for_each_tile
(
&
rect
(
0
.
0
.
74
.
74
.
)
&
rect
(
75
.
75
.
400
.
400
.
)
&
size2
(
400
400
)
36
&
mut
|
_tile_rect
_tile_offset
_tile_flags
|
{
count
+
=
1
;
}
)
;
assert_eq
!
(
count
0
)
;
}
}
