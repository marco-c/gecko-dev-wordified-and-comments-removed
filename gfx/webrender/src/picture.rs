use
api
:
:
{
DeviceRect
FilterOp
MixBlendMode
PipelineId
PremultipliedColorF
PictureRect
}
;
use
api
:
:
{
DeviceIntRect
DeviceIntSize
DevicePoint
LayoutPoint
LayoutRect
}
;
use
api
:
:
{
DevicePixelScale
PictureIntPoint
PictureIntRect
PictureIntSize
}
;
use
box_shadow
:
:
{
BLUR_SAMPLE_SCALE
}
;
use
frame_builder
:
:
{
FrameBuildingContext
FrameBuildingState
PictureState
}
;
use
frame_builder
:
:
{
PictureContext
PrimitiveContext
}
;
use
gpu_cache
:
:
{
GpuCacheHandle
}
;
use
gpu_types
:
:
UvRectKind
;
use
prim_store
:
:
{
PrimitiveIndex
PrimitiveRun
}
;
use
prim_store
:
:
{
PrimitiveMetadata
Transform
}
;
use
render_task
:
:
{
ClearMode
RenderTask
RenderTaskCacheEntryHandle
}
;
use
render_task
:
:
{
RenderTaskCacheKey
RenderTaskCacheKeyKind
RenderTaskId
RenderTaskLocation
}
;
use
scene
:
:
{
FilterOpHelpers
SceneProperties
}
;
use
std
:
:
mem
;
use
tiling
:
:
RenderTargetKind
;
use
util
:
:
{
TransformedRectKind
world_rect_to_device_pixels
}
;
#
[
derive
(
Debug
)
]
pub
struct
RasterConfig
{
pub
composite_mode
:
PictureCompositeMode
pub
surface
:
Option
<
PictureSurface
>
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
PictureCompositeMode
{
MixBlend
(
MixBlendMode
)
Filter
(
FilterOp
)
Blit
}
#
[
derive
(
Debug
)
]
pub
enum
PictureSurface
{
RenderTask
(
RenderTaskId
)
TextureCache
(
RenderTaskCacheEntryHandle
)
}
#
[
derive
(
Copy
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureId
(
pub
u64
)
;
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureCacheKey
{
scene_id
:
u64
picture_id
:
PictureId
pic_relative_render_rect
:
PictureIntRect
unclipped_size
:
DeviceIntSize
}
#
[
derive
(
Debug
)
]
pub
struct
PicturePrimitive
{
pub
runs
:
Vec
<
PrimitiveRun
>
pub
state
:
Option
<
PictureState
>
pub
pipeline_id
:
PipelineId
pub
apply_local_clip_rect
:
bool
pub
secondary_render_task_id
:
Option
<
RenderTaskId
>
pub
requested_composite_mode
:
Option
<
PictureCompositeMode
>
pub
raster_config
:
Option
<
RasterConfig
>
pub
is_in_3d_context
:
bool
pub
frame_output_pipeline_id
:
Option
<
PipelineId
>
pub
extra_gpu_data_handle
:
GpuCacheHandle
pub
id
:
PictureId
}
impl
PicturePrimitive
{
fn
resolve_scene_properties
(
&
mut
self
properties
:
&
SceneProperties
)
-
>
bool
{
match
self
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
ref
mut
filter
)
)
=
>
{
match
*
filter
{
FilterOp
:
:
Opacity
(
ref
binding
ref
mut
value
)
=
>
{
*
value
=
properties
.
resolve_float
(
binding
)
;
}
_
=
>
{
}
}
filter
.
is_visible
(
)
}
_
=
>
true
}
}
pub
fn
new_image
(
id
:
PictureId
requested_composite_mode
:
Option
<
PictureCompositeMode
>
is_in_3d_context
:
bool
pipeline_id
:
PipelineId
frame_output_pipeline_id
:
Option
<
PipelineId
>
apply_local_clip_rect
:
bool
)
-
>
Self
{
PicturePrimitive
{
runs
:
Vec
:
:
new
(
)
state
:
None
secondary_render_task_id
:
None
requested_composite_mode
raster_config
:
None
is_in_3d_context
frame_output_pipeline_id
extra_gpu_data_handle
:
GpuCacheHandle
:
:
new
(
)
apply_local_clip_rect
pipeline_id
id
}
}
pub
fn
take_context
(
&
mut
self
parent_allows_subpixel_aa
:
bool
scene_properties
:
&
SceneProperties
is_chased
:
bool
)
-
>
Option
<
PictureContext
>
{
if
!
self
.
resolve_scene_properties
(
scene_properties
)
{
if
cfg
!
(
debug_assertions
)
&
&
is_chased
{
println
!
(
"
\
tculled
for
carrying
an
invisible
composite
filter
"
)
;
}
return
None
;
}
let
actual_composite_mode
=
match
self
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
filter
)
)
if
filter
.
is_noop
(
)
=
>
None
mode
=
>
mode
}
;
self
.
raster_config
=
actual_composite_mode
.
map
(
|
composite_mode
|
{
RasterConfig
{
composite_mode
surface
:
None
}
}
)
;
let
allow_subpixel_aa
=
parent_allows_subpixel_aa
&
&
self
.
raster_config
.
is_none
(
)
;
let
inflation_factor
=
match
self
.
raster_config
{
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Blur
(
blur_radius
)
)
.
.
}
)
=
>
{
BLUR_SAMPLE_SCALE
*
blur_radius
}
_
=
>
{
0
.
0
}
}
;
Some
(
PictureContext
{
pipeline_id
:
self
.
pipeline_id
prim_runs
:
mem
:
:
replace
(
&
mut
self
.
runs
Vec
:
:
new
(
)
)
apply_local_clip_rect
:
self
.
apply_local_clip_rect
inflation_factor
allow_subpixel_aa
has_surface
:
self
.
raster_config
.
is_some
(
)
}
)
}
pub
fn
add_primitive
(
&
mut
self
prim_index
:
PrimitiveIndex
)
{
if
let
Some
(
ref
mut
run
)
=
self
.
runs
.
last_mut
(
)
{
if
run
.
base_prim_index
.
0
+
run
.
count
=
=
prim_index
.
0
{
run
.
count
+
=
1
;
return
;
}
}
self
.
runs
.
push
(
PrimitiveRun
{
base_prim_index
:
prim_index
count
:
1
}
)
;
}
pub
fn
restore_context
(
&
mut
self
context
:
PictureContext
state
:
PictureState
local_rect
:
Option
<
PictureRect
>
)
-
>
LayoutRect
{
self
.
runs
=
context
.
prim_runs
;
self
.
state
=
Some
(
state
)
;
match
local_rect
{
Some
(
local_rect
)
=
>
{
let
local_content_rect
=
LayoutRect
:
:
from_untyped
(
&
local_rect
.
to_untyped
(
)
)
;
match
self
.
raster_config
{
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Blur
(
blur_radius
)
)
.
.
}
)
=
>
{
let
inflate_size
=
(
blur_radius
*
BLUR_SAMPLE_SCALE
)
.
ceil
(
)
;
local_content_rect
.
inflate
(
inflate_size
inflate_size
)
}
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
DropShadow
(
_
blur_radius
_
)
)
.
.
}
)
=
>
{
let
inflate_size
=
(
blur_radius
*
BLUR_SAMPLE_SCALE
)
.
ceil
(
)
;
local_content_rect
.
inflate
(
inflate_size
inflate_size
)
}
_
=
>
{
local_content_rect
}
}
}
None
=
>
{
assert
!
(
self
.
raster_config
.
is_none
(
)
)
;
LayoutRect
:
:
zero
(
)
}
}
}
pub
fn
take_state
(
&
mut
self
)
-
>
PictureState
{
self
.
state
.
take
(
)
.
expect
(
"
bug
:
no
state
present
!
"
)
}
pub
fn
prepare_for_render
(
&
mut
self
prim_index
:
PrimitiveIndex
prim_metadata
:
&
mut
PrimitiveMetadata
prim_context
:
&
PrimitiveContext
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
)
{
let
mut
pic_state_for_children
=
self
.
take_state
(
)
;
match
self
.
raster_config
{
Some
(
ref
mut
raster_config
)
=
>
{
let
clipped_world_rect
=
prim_metadata
.
clipped_world_rect
.
as_ref
(
)
.
expect
(
"
bug
:
trying
to
draw
an
off
-
screen
picture
!
?
"
)
;
let
clipped
=
world_rect_to_device_pixels
(
*
clipped_world_rect
frame_context
.
device_pixel_scale
)
.
to_i32
(
)
;
let
pic_rect
=
pic_state
.
map_local_to_pic
.
map
(
&
prim_metadata
.
local_rect
)
.
unwrap
(
)
;
let
world_rect
=
pic_state
.
map_pic_to_world
.
map
(
&
pic_rect
)
.
unwrap
(
)
;
let
unclipped
=
world_rect_to_device_pixels
(
world_rect
frame_context
.
device_pixel_scale
)
;
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Blur
(
blur_radius
)
)
=
>
{
let
blur_std_deviation
=
blur_radius
*
frame_context
.
device_pixel_scale
.
0
;
let
blur_range
=
(
blur_std_deviation
*
BLUR_SAMPLE_SCALE
)
.
ceil
(
)
as
i32
;
let
device_rect
=
clipped
.
inflate
(
blur_range
blur_range
)
.
intersection
(
&
unclipped
.
to_i32
(
)
)
.
unwrap
(
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
prim_metadata
.
local_rect
&
prim_context
.
transform
&
device_rect
frame_context
.
device_pixel_scale
)
;
let
surface
=
if
pic_state_for_children
.
has_non_root_coord_system
{
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
device_rect
.
size
)
unclipped
.
size
prim_index
device_rect
.
origin
pic_state_for_children
.
tasks
uv_rect_kind
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
blur_render_task
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
blur_render_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
PictureSurface
:
:
RenderTask
(
render_task_id
)
}
else
{
let
pic_relative_render_rect
=
PictureIntRect
:
:
new
(
PictureIntPoint
:
:
new
(
device_rect
.
origin
.
x
-
unclipped
.
origin
.
x
as
i32
device_rect
.
origin
.
y
-
unclipped
.
origin
.
y
as
i32
)
PictureIntSize
:
:
new
(
device_rect
.
size
.
width
device_rect
.
size
.
height
)
)
;
let
cache_item
=
frame_state
.
resource_cache
.
request_render_task
(
RenderTaskCacheKey
{
size
:
device_rect
.
size
kind
:
RenderTaskCacheKeyKind
:
:
Picture
(
PictureCacheKey
{
scene_id
:
frame_context
.
scene_id
picture_id
:
self
.
id
unclipped_size
:
unclipped
.
size
.
to_i32
(
)
pic_relative_render_rect
}
)
}
frame_state
.
gpu_cache
frame_state
.
render_tasks
None
false
|
render_tasks
|
{
let
child_tasks
=
mem
:
:
replace
(
&
mut
pic_state_for_children
.
tasks
Vec
:
:
new
(
)
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
device_rect
.
size
)
unclipped
.
size
prim_index
device_rect
.
origin
child_tasks
uv_rect_kind
)
;
let
picture_task_id
=
render_tasks
.
add
(
picture_task
)
;
let
blur_render_task
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
)
;
let
render_task_id
=
render_tasks
.
add
(
blur_render_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
render_task_id
}
)
;
PictureSurface
:
:
TextureCache
(
cache_item
)
}
;
raster_config
.
surface
=
Some
(
surface
)
;
}
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
DropShadow
(
offset
blur_radius
color
)
)
=
>
{
let
blur_std_deviation
=
blur_radius
*
frame_context
.
device_pixel_scale
.
0
;
let
blur_range
=
(
blur_std_deviation
*
BLUR_SAMPLE_SCALE
)
.
ceil
(
)
as
i32
;
let
device_rect
=
clipped
.
inflate
(
blur_range
blur_range
)
.
intersection
(
&
unclipped
.
to_i32
(
)
)
.
unwrap
(
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
prim_metadata
.
local_rect
&
prim_context
.
transform
&
device_rect
frame_context
.
device_pixel_scale
)
;
let
mut
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
device_rect
.
size
)
unclipped
.
size
prim_index
device_rect
.
origin
pic_state_for_children
.
tasks
uv_rect_kind
)
;
picture_task
.
mark_for_saving
(
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
blur_render_task
=
RenderTask
:
:
new_blur
(
blur_std_deviation
.
round
(
)
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
)
;
self
.
secondary_render_task_id
=
Some
(
picture_task_id
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
blur_render_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
raster_config
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
if
pic_state
.
local_rect_changed
{
frame_state
.
gpu_cache
.
invalidate
(
&
mut
self
.
extra_gpu_data_handle
)
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handle
)
{
let
shadow_rect
=
prim_metadata
.
local_rect
.
translate
(
&
offset
)
;
request
.
push
(
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
prim_metadata
.
local_rect
.
size
.
width
prim_metadata
.
local_rect
.
size
.
height
0
.
0
0
.
0
]
)
;
request
.
push
(
shadow_rect
)
;
request
.
push
(
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
prim_metadata
.
local_rect
&
prim_context
.
transform
&
clipped
frame_context
.
device_pixel_scale
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
prim_index
clipped
.
origin
pic_state_for_children
.
tasks
uv_rect_kind
)
;
let
readback_task_id
=
frame_state
.
render_tasks
.
add
(
RenderTask
:
:
new_readback
(
clipped
)
)
;
self
.
secondary_render_task_id
=
Some
(
readback_task_id
)
;
pic_state
.
tasks
.
push
(
readback_task_id
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
raster_config
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
PictureCompositeMode
:
:
Filter
(
filter
)
=
>
{
if
let
FilterOp
:
:
ColorMatrix
(
m
)
=
filter
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handle
)
{
for
i
in
0
.
.
5
{
request
.
push
(
[
m
[
i
*
4
]
m
[
i
*
4
+
1
]
m
[
i
*
4
+
2
]
m
[
i
*
4
+
3
]
]
)
;
}
}
}
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
prim_metadata
.
local_rect
&
prim_context
.
transform
&
clipped
frame_context
.
device_pixel_scale
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
prim_index
clipped
.
origin
pic_state_for_children
.
tasks
uv_rect_kind
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
raster_config
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
PictureCompositeMode
:
:
Blit
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
prim_metadata
.
local_rect
&
prim_context
.
transform
&
clipped
frame_context
.
device_pixel_scale
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
prim_index
clipped
.
origin
pic_state_for_children
.
tasks
uv_rect_kind
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
pic_state
.
tasks
.
push
(
render_task_id
)
;
raster_config
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
}
}
None
=
>
{
pic_state
.
tasks
.
extend
(
pic_state_for_children
.
tasks
)
;
}
}
}
}
fn
calculate_screen_uv
(
local_pos
:
&
LayoutPoint
transform
:
&
Transform
rendered_rect
:
&
DeviceRect
device_pixel_scale
:
DevicePixelScale
)
-
>
DevicePoint
{
let
world_pos
=
match
transform
.
m
.
transform_point2d
(
local_pos
)
{
Some
(
pos
)
=
>
pos
None
=
>
{
return
DevicePoint
:
:
new
(
0
.
5
0
.
5
)
;
}
}
;
let
mut
device_pos
=
world_pos
*
device_pixel_scale
;
if
transform
.
transform_kind
=
=
TransformedRectKind
:
:
AxisAligned
{
device_pos
.
x
=
(
device_pos
.
x
+
0
.
5
)
.
floor
(
)
;
device_pos
.
y
=
(
device_pos
.
y
+
0
.
5
)
.
floor
(
)
;
}
DevicePoint
:
:
new
(
(
device_pos
.
x
-
rendered_rect
.
origin
.
x
)
/
rendered_rect
.
size
.
width
(
device_pos
.
y
-
rendered_rect
.
origin
.
y
)
/
rendered_rect
.
size
.
height
)
}
fn
calculate_uv_rect_kind
(
local_rect
:
&
LayoutRect
transform
:
&
Transform
rendered_rect
:
&
DeviceIntRect
device_pixel_scale
:
DevicePixelScale
)
-
>
UvRectKind
{
let
rendered_rect
=
rendered_rect
.
to_f32
(
)
;
let
top_left
=
calculate_screen_uv
(
&
local_rect
.
origin
transform
&
rendered_rect
device_pixel_scale
)
;
let
top_right
=
calculate_screen_uv
(
&
local_rect
.
top_right
(
)
transform
&
rendered_rect
device_pixel_scale
)
;
let
bottom_left
=
calculate_screen_uv
(
&
local_rect
.
bottom_left
(
)
transform
&
rendered_rect
device_pixel_scale
)
;
let
bottom_right
=
calculate_screen_uv
(
&
local_rect
.
bottom_right
(
)
transform
&
rendered_rect
device_pixel_scale
)
;
UvRectKind
:
:
Quad
{
top_left
top_right
bottom_left
bottom_right
}
}
