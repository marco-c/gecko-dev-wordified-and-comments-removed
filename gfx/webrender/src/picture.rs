use
api
:
:
{
ColorF
ClipAndScrollInfo
FilterOp
MixBlendMode
}
;
use
api
:
:
{
DeviceIntPoint
DeviceIntRect
LayerToWorldScale
PipelineId
}
;
use
api
:
:
{
BoxShadowClipMode
LayerPoint
LayerRect
LayerVector2D
Shadow
}
;
use
api
:
:
{
ClipId
PremultipliedColorF
}
;
use
box_shadow
:
:
{
BLUR_SAMPLE_SCALE
BoxShadowCacheKey
}
;
use
frame_builder
:
:
{
FrameContext
FrameState
}
;
use
gpu_cache
:
:
GpuDataRequest
;
use
gpu_types
:
:
{
BrushImageKind
PictureType
}
;
use
prim_store
:
:
{
BrushKind
BrushPrimitive
PrimitiveIndex
PrimitiveRun
PrimitiveRunLocalRect
}
;
use
render_task
:
:
{
ClearMode
RenderTask
RenderTaskCacheKey
}
;
use
render_task
:
:
{
RenderTaskCacheKeyKind
RenderTaskId
}
;
use
resource_cache
:
:
CacheItem
;
use
scene
:
:
{
FilterOpHelpers
SceneProperties
}
;
use
tiling
:
:
RenderTargetKind
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
PictureCompositeMode
{
MixBlend
(
MixBlendMode
)
Filter
(
FilterOp
)
Blit
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ContentOrigin
{
Local
(
LayerPoint
)
Screen
(
DeviceIntPoint
)
}
#
[
derive
(
Debug
)
]
pub
enum
PictureKind
{
TextShadow
{
offset
:
LayerVector2D
color
:
ColorF
blur_radius
:
f32
content_rect
:
LayerRect
}
BoxShadow
{
blur_radius
:
f32
color
:
ColorF
clip_mode
:
BoxShadowClipMode
image_kind
:
BrushImageKind
content_rect
:
LayerRect
cache_key
:
BoxShadowCacheKey
}
Image
{
secondary_render_task_id
:
Option
<
RenderTaskId
>
composite_mode
:
Option
<
PictureCompositeMode
>
is_in_3d_context
:
bool
frame_output_pipeline_id
:
Option
<
PipelineId
>
reference_frame_id
:
ClipId
real_local_rect
:
LayerRect
}
}
#
[
derive
(
Debug
)
]
pub
enum
PictureSurface
{
RenderTask
(
RenderTaskId
)
TextureCache
(
CacheItem
)
}
#
[
derive
(
Debug
)
]
pub
struct
PicturePrimitive
{
pub
surface
:
Option
<
PictureSurface
>
pub
kind
:
PictureKind
pub
runs
:
Vec
<
PrimitiveRun
>
pub
pipeline_id
:
PipelineId
pub
cull_children
:
bool
pub
brush
:
BrushPrimitive
}
impl
PicturePrimitive
{
pub
fn
new_text_shadow
(
shadow
:
Shadow
pipeline_id
:
PipelineId
)
-
>
Self
{
PicturePrimitive
{
runs
:
Vec
:
:
new
(
)
surface
:
None
kind
:
PictureKind
:
:
TextShadow
{
offset
:
shadow
.
offset
color
:
shadow
.
color
blur_radius
:
shadow
.
blur_radius
content_rect
:
LayerRect
:
:
zero
(
)
}
pipeline_id
cull_children
:
false
brush
:
BrushPrimitive
:
:
new
(
BrushKind
:
:
Picture
None
)
}
}
pub
fn
resolve_scene_properties
(
&
mut
self
properties
:
&
SceneProperties
)
-
>
bool
{
match
self
.
kind
{
PictureKind
:
:
Image
{
ref
mut
composite_mode
.
.
}
=
>
{
match
composite_mode
{
&
mut
Some
(
PictureCompositeMode
:
:
Filter
(
ref
mut
filter
)
)
=
>
{
match
filter
{
&
mut
FilterOp
:
:
Opacity
(
ref
binding
ref
mut
value
)
=
>
{
*
value
=
properties
.
resolve_float
(
binding
*
value
)
;
}
_
=
>
{
}
}
filter
.
is_visible
(
)
}
_
=
>
true
}
}
_
=
>
true
}
}
pub
fn
new_box_shadow
(
blur_radius
:
f32
color
:
ColorF
clip_mode
:
BoxShadowClipMode
image_kind
:
BrushImageKind
cache_key
:
BoxShadowCacheKey
pipeline_id
:
PipelineId
)
-
>
Self
{
PicturePrimitive
{
runs
:
Vec
:
:
new
(
)
surface
:
None
kind
:
PictureKind
:
:
BoxShadow
{
blur_radius
color
clip_mode
image_kind
content_rect
:
LayerRect
:
:
zero
(
)
cache_key
}
pipeline_id
cull_children
:
false
brush
:
BrushPrimitive
:
:
new
(
BrushKind
:
:
Picture
None
)
}
}
pub
fn
new_image
(
composite_mode
:
Option
<
PictureCompositeMode
>
is_in_3d_context
:
bool
pipeline_id
:
PipelineId
reference_frame_id
:
ClipId
frame_output_pipeline_id
:
Option
<
PipelineId
>
)
-
>
Self
{
PicturePrimitive
{
runs
:
Vec
:
:
new
(
)
surface
:
None
kind
:
PictureKind
:
:
Image
{
secondary_render_task_id
:
None
composite_mode
is_in_3d_context
frame_output_pipeline_id
reference_frame_id
real_local_rect
:
LayerRect
:
:
zero
(
)
}
pipeline_id
cull_children
:
true
brush
:
BrushPrimitive
:
:
new
(
BrushKind
:
:
Picture
None
)
}
}
pub
fn
add_primitive
(
&
mut
self
prim_index
:
PrimitiveIndex
clip_and_scroll
:
ClipAndScrollInfo
)
{
if
let
Some
(
ref
mut
run
)
=
self
.
runs
.
last_mut
(
)
{
if
run
.
clip_and_scroll
=
=
clip_and_scroll
&
&
run
.
base_prim_index
.
0
+
run
.
count
=
=
prim_index
.
0
{
run
.
count
+
=
1
;
return
;
}
}
self
.
runs
.
push
(
PrimitiveRun
{
base_prim_index
:
prim_index
count
:
1
clip_and_scroll
}
)
;
}
pub
fn
update_local_rect
(
&
mut
self
prim_local_rect
:
LayerRect
prim_run_rect
:
PrimitiveRunLocalRect
)
-
>
LayerRect
{
let
local_content_rect
=
prim_run_rect
.
local_rect_in_actual_parent_space
;
match
self
.
kind
{
PictureKind
:
:
Image
{
composite_mode
ref
mut
real_local_rect
.
.
}
=
>
{
*
real_local_rect
=
prim_run_rect
.
local_rect_in_original_parent_space
;
match
composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Blur
(
blur_radius
)
)
)
=
>
{
let
inflate_size
=
blur_radius
*
BLUR_SAMPLE_SCALE
;
local_content_rect
.
inflate
(
inflate_size
inflate_size
)
}
Some
(
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
DropShadow
(
offset
blur_radius
_
)
)
)
=
>
{
let
inflate_size
=
blur_radius
*
BLUR_SAMPLE_SCALE
;
local_content_rect
.
inflate
(
inflate_size
inflate_size
)
.
translate
(
&
offset
)
}
_
=
>
{
local_content_rect
}
}
}
PictureKind
:
:
TextShadow
{
offset
blur_radius
ref
mut
content_rect
.
.
}
=
>
{
let
blur_offset
=
blur_radius
*
BLUR_SAMPLE_SCALE
;
*
content_rect
=
local_content_rect
.
inflate
(
blur_offset
blur_offset
)
;
content_rect
.
translate
(
&
offset
)
}
PictureKind
:
:
BoxShadow
{
blur_radius
clip_mode
image_kind
ref
mut
content_rect
.
.
}
=
>
{
*
content_rect
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
match
image_kind
{
BrushImageKind
:
:
Mirror
=
>
{
let
half_offset
=
0
.
5
*
blur_radius
*
BLUR_SAMPLE_SCALE
;
local_content_rect
.
translate
(
&
-
LayerVector2D
:
:
new
(
half_offset
half_offset
)
)
.
inflate
(
half_offset
half_offset
)
}
BrushImageKind
:
:
NinePatch
|
BrushImageKind
:
:
Simple
=
>
{
let
full_offset
=
blur_radius
*
BLUR_SAMPLE_SCALE
;
local_content_rect
.
inflate
(
full_offset
full_offset
)
}
}
}
BoxShadowClipMode
:
:
Inset
=
>
{
local_content_rect
}
}
;
prim_local_rect
}
}
}
pub
fn
picture_type
(
&
self
)
-
>
PictureType
{
match
self
.
kind
{
PictureKind
:
:
Image
{
.
.
}
=
>
PictureType
:
:
Image
PictureKind
:
:
BoxShadow
{
.
.
}
=
>
PictureType
:
:
BoxShadow
PictureKind
:
:
TextShadow
{
.
.
}
=
>
PictureType
:
:
TextShadow
}
}
pub
fn
prepare_for_render
(
&
mut
self
prim_index
:
PrimitiveIndex
prim_screen_rect
:
&
DeviceIntRect
prim_local_rect
:
&
LayerRect
child_tasks
:
Vec
<
RenderTaskId
>
parent_tasks
:
&
mut
Vec
<
RenderTaskId
>
frame_context
:
&
FrameContext
frame_state
:
&
mut
FrameState
)
{
let
content_scale
=
LayerToWorldScale
:
:
new
(
1
.
0
)
*
frame_context
.
device_pixel_scale
;
match
self
.
kind
{
PictureKind
:
:
Image
{
ref
mut
secondary_render_task_id
composite_mode
.
.
}
=
>
{
let
content_origin
=
ContentOrigin
:
:
Screen
(
prim_screen_rect
.
origin
)
;
match
composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Blur
(
blur_radius
)
)
)
=
>
{
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
prim_screen_rect
.
size
)
prim_index
RenderTargetKind
:
:
Color
content_origin
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
blur_std_deviation
=
blur_radius
*
frame_context
.
device_pixel_scale
.
0
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
(
blur_render_task
_
)
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
PremultipliedColorF
:
:
TRANSPARENT
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
blur_render_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
Some
(
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
DropShadow
(
offset
blur_radius
color
)
)
)
=
>
{
let
rect
=
(
prim_local_rect
.
translate
(
&
-
offset
)
*
content_scale
)
.
round
(
)
.
to_i32
(
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
rect
.
size
)
prim_index
RenderTargetKind
:
:
Color
ContentOrigin
:
:
Screen
(
rect
.
origin
)
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
blur_std_deviation
=
blur_radius
*
frame_context
.
device_pixel_scale
.
0
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
(
blur_render_task
_
)
=
RenderTask
:
:
new_blur
(
blur_std_deviation
.
round
(
)
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
color
.
premultiplied
(
)
)
;
*
secondary_render_task_id
=
Some
(
picture_task_id
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
blur_render_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
Some
(
PictureCompositeMode
:
:
MixBlend
(
.
.
)
)
=
>
{
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
prim_screen_rect
.
size
)
prim_index
RenderTargetKind
:
:
Color
content_origin
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
readback_task_id
=
frame_state
.
render_tasks
.
add
(
RenderTask
:
:
new_readback
(
*
prim_screen_rect
)
)
;
*
secondary_render_task_id
=
Some
(
readback_task_id
)
;
parent_tasks
.
push
(
readback_task_id
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
Some
(
PictureCompositeMode
:
:
Filter
(
filter
)
)
=
>
{
if
filter
.
is_noop
(
)
{
parent_tasks
.
extend
(
child_tasks
)
;
self
.
surface
=
None
;
}
else
{
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
prim_screen_rect
.
size
)
prim_index
RenderTargetKind
:
:
Color
content_origin
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
}
Some
(
PictureCompositeMode
:
:
Blit
)
=
>
{
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
prim_screen_rect
.
size
)
prim_index
RenderTargetKind
:
:
Color
content_origin
PremultipliedColorF
:
:
TRANSPARENT
ClearMode
:
:
Transparent
child_tasks
PictureType
:
:
Image
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
None
=
>
{
parent_tasks
.
extend
(
child_tasks
)
;
self
.
surface
=
None
;
}
}
}
PictureKind
:
:
TextShadow
{
blur_radius
color
content_rect
.
.
}
=
>
{
let
cache_size
=
(
content_rect
.
size
*
content_scale
)
.
round
(
)
.
to_i32
(
)
;
let
device_radius
=
(
blur_radius
*
frame_context
.
device_pixel_scale
.
0
)
.
round
(
)
;
let
blur_std_deviation
=
device_radius
*
0
.
5
;
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
cache_size
)
prim_index
RenderTargetKind
:
:
Color
ContentOrigin
:
:
Local
(
content_rect
.
origin
)
color
.
premultiplied
(
)
ClearMode
:
:
Transparent
Vec
:
:
new
(
)
PictureType
:
:
TextShadow
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
(
blur_render_task
_
)
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
color
.
premultiplied
(
)
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
blur_render_task
)
;
parent_tasks
.
push
(
render_task_id
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
RenderTask
(
render_task_id
)
)
;
}
PictureKind
:
:
BoxShadow
{
blur_radius
clip_mode
color
content_rect
cache_key
.
.
}
=
>
{
let
cache_size
=
(
content_rect
.
size
*
content_scale
)
.
round
(
)
.
to_i32
(
)
;
let
cache_item
=
frame_state
.
resource_cache
.
request_render_task
(
RenderTaskCacheKey
{
size
:
cache_size
kind
:
RenderTaskCacheKeyKind
:
:
BoxShadow
(
cache_key
)
}
frame_state
.
gpu_cache
frame_state
.
render_tasks
|
render_tasks
|
{
let
device_radius
=
(
blur_radius
*
frame_context
.
device_pixel_scale
.
0
)
.
round
(
)
;
let
blur_std_deviation
=
device_radius
*
0
.
5
;
let
blur_clear_mode
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
ClearMode
:
:
One
}
BoxShadowClipMode
:
:
Inset
=
>
{
ClearMode
:
:
Zero
}
}
;
let
picture_task
=
RenderTask
:
:
new_picture
(
Some
(
cache_size
)
prim_index
RenderTargetKind
:
:
Alpha
ContentOrigin
:
:
Local
(
content_rect
.
origin
)
color
.
premultiplied
(
)
ClearMode
:
:
Zero
Vec
:
:
new
(
)
PictureType
:
:
BoxShadow
)
;
let
picture_task_id
=
render_tasks
.
add
(
picture_task
)
;
let
(
blur_render_task
scale_factor
)
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
render_tasks
RenderTargetKind
:
:
Alpha
blur_clear_mode
color
.
premultiplied
(
)
)
;
let
root_task_id
=
render_tasks
.
add
(
blur_render_task
)
;
parent_tasks
.
push
(
root_task_id
)
;
(
root_task_id
[
scale_factor
0
.
0
0
.
0
]
false
)
}
)
;
self
.
surface
=
Some
(
PictureSurface
:
:
TextureCache
(
cache_item
)
)
;
}
}
}
pub
fn
write_gpu_blocks
(
&
self
request
:
&
mut
GpuDataRequest
)
{
match
self
.
kind
{
PictureKind
:
:
TextShadow
{
.
.
}
|
PictureKind
:
:
Image
{
.
.
}
=
>
{
request
.
push
(
[
0
.
0
;
4
]
)
;
}
PictureKind
:
:
BoxShadow
{
color
.
.
}
=
>
{
request
.
push
(
color
.
premultiplied
(
)
)
;
}
}
}
pub
fn
target_kind
(
&
self
)
-
>
RenderTargetKind
{
match
self
.
kind
{
PictureKind
:
:
TextShadow
{
.
.
}
=
>
RenderTargetKind
:
:
Color
PictureKind
:
:
BoxShadow
{
.
.
}
=
>
RenderTargetKind
:
:
Alpha
PictureKind
:
:
Image
{
.
.
}
=
>
RenderTargetKind
:
:
Color
}
}
}
