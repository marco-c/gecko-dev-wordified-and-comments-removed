use
api
:
:
{
ClipAndScrollInfo
Shadow
}
;
use
prim_store
:
:
PrimitiveIndex
;
use
render_task
:
:
RenderTaskId
;
use
tiling
:
:
RenderTargetKind
;
#
[
derive
(
Clone
Debug
)
]
pub
struct
PrimitiveRun
{
pub
prim_index
:
PrimitiveIndex
pub
count
:
usize
pub
clip_and_scroll
:
ClipAndScrollInfo
}
#
[
derive
(
Debug
)
]
pub
enum
CompositeOp
{
Shadow
(
Shadow
)
}
#
[
derive
(
Debug
)
]
pub
struct
PicturePrimitive
{
pub
prim_runs
:
Vec
<
PrimitiveRun
>
pub
composite_op
:
CompositeOp
pub
render_task_id
:
Option
<
RenderTaskId
>
pub
kind
:
RenderTargetKind
}
impl
PicturePrimitive
{
pub
fn
new_shadow
(
shadow
:
Shadow
kind
:
RenderTargetKind
)
-
>
PicturePrimitive
{
PicturePrimitive
{
prim_runs
:
Vec
:
:
new
(
)
composite_op
:
CompositeOp
:
:
Shadow
(
shadow
)
render_task_id
:
None
kind
}
}
pub
fn
as_shadow
(
&
self
)
-
>
&
Shadow
{
match
self
.
composite_op
{
CompositeOp
:
:
Shadow
(
ref
shadow
)
=
>
shadow
}
}
pub
fn
add_primitive
(
&
mut
self
prim_index
:
PrimitiveIndex
clip_and_scroll
:
ClipAndScrollInfo
)
{
if
let
Some
(
ref
mut
run
)
=
self
.
prim_runs
.
last_mut
(
)
{
if
run
.
clip_and_scroll
=
=
clip_and_scroll
&
&
run
.
prim_index
.
0
+
run
.
count
=
=
prim_index
.
0
{
run
.
count
+
=
1
;
return
;
}
}
self
.
prim_runs
.
push
(
PrimitiveRun
{
prim_index
count
:
1
clip_and_scroll
}
)
;
}
}
