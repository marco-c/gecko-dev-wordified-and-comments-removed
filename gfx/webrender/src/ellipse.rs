use
api
:
:
{
LayerPoint
LayerSize
}
;
use
std
:
:
f32
:
:
consts
:
:
FRAC_PI_2
;
const
STEP_COUNT
:
usize
=
20
;
#
[
derive
(
Debug
Clone
)
]
pub
struct
Ellipse
{
pub
radius
:
LayerSize
pub
total_arc_length
:
f32
}
impl
Ellipse
{
pub
fn
new
(
radius
:
LayerSize
)
-
>
Ellipse
{
let
total_arc_length
=
get_simpson_length
(
FRAC_PI_2
radius
.
width
radius
.
height
)
;
Ellipse
{
radius
total_arc_length
}
}
pub
fn
find_angle_for_arc_length
(
&
self
arc_length
:
f32
)
-
>
f32
{
let
arc_length
=
arc_length
.
max
(
0
.
0
)
.
min
(
self
.
total_arc_length
)
;
let
epsilon
=
0
.
01
;
let
mut
low
=
0
.
0
;
let
mut
high
=
FRAC_PI_2
;
let
mut
theta
=
0
.
0
;
while
low
<
=
high
{
theta
=
0
.
5
*
(
low
+
high
)
;
let
length
=
get_simpson_length
(
theta
self
.
radius
.
width
self
.
radius
.
height
)
;
if
(
length
-
arc_length
)
.
abs
(
)
<
epsilon
{
break
;
}
else
if
length
<
arc_length
{
low
=
theta
;
}
else
{
high
=
theta
;
}
}
theta
}
pub
fn
get_point_and_tangent
(
&
self
theta
:
f32
)
-
>
(
LayerPoint
LayerPoint
)
{
let
(
sin_theta
cos_theta
)
=
theta
.
sin_cos
(
)
;
let
point
=
LayerPoint
:
:
new
(
self
.
radius
.
width
*
cos_theta
self
.
radius
.
height
*
sin_theta
)
;
let
tangent
=
LayerPoint
:
:
new
(
-
self
.
radius
.
width
*
sin_theta
self
.
radius
.
height
*
cos_theta
)
;
(
point
tangent
)
}
}
fn
get_simpson_length
(
theta
:
f32
rx
:
f32
ry
:
f32
)
-
>
f32
{
let
df
=
theta
/
STEP_COUNT
as
f32
;
let
mut
sum
=
0
.
0
;
for
i
in
0
.
.
(
STEP_COUNT
+
1
)
{
let
(
sin_theta
cos_theta
)
=
(
i
as
f32
*
df
)
.
sin_cos
(
)
;
let
a
=
rx
*
sin_theta
;
let
b
=
ry
*
cos_theta
;
let
y
=
(
a
*
a
+
b
*
b
)
.
sqrt
(
)
;
let
q
=
if
i
=
=
0
|
|
i
=
=
STEP_COUNT
{
1
.
0
}
else
if
i
%
2
=
=
0
{
2
.
0
}
else
{
4
.
0
}
;
sum
+
=
q
*
y
;
}
(
df
/
3
.
0
)
*
sum
}
