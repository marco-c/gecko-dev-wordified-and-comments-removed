use
api
:
:
{
BorderRadiusKind
ColorF
LayerPoint
LayerRect
LayerSize
LayerVector2D
}
;
use
api
:
:
{
BorderRadius
BoxShadowClipMode
LayoutSize
LayerPrimitiveInfo
}
;
use
api
:
:
{
ClipMode
ComplexClipRegion
LocalClip
ClipAndScrollInfo
}
;
use
clip
:
:
ClipSource
;
use
frame_builder
:
:
FrameBuilder
;
use
prim_store
:
:
{
PrimitiveContainer
RectangleContent
RectanglePrimitive
}
;
use
prim_store
:
:
{
BrushMaskKind
BrushKind
BrushPrimitive
}
;
use
picture
:
:
PicturePrimitive
;
use
util
:
:
RectHelpers
;
pub
const
BLUR_SAMPLE_SCALE
:
f32
=
3
.
0
;
pub
const
MASK_CORNER_PADDING
:
f32
=
4
.
0
;
impl
FrameBuilder
{
pub
fn
add_box_shadow
(
&
mut
self
clip_and_scroll
:
ClipAndScrollInfo
prim_info
:
&
LayerPrimitiveInfo
box_offset
:
&
LayerVector2D
color
:
&
ColorF
blur_radius
:
f32
spread_radius
:
f32
border_radius
:
BorderRadius
clip_mode
:
BoxShadowClipMode
)
{
if
color
.
a
=
=
0
.
0
{
return
;
}
let
(
spread_amount
brush_clip_mode
)
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
(
spread_radius
ClipMode
:
:
Clip
)
}
BoxShadowClipMode
:
:
Inset
=
>
{
(
-
spread_radius
ClipMode
:
:
ClipOut
)
}
}
;
let
shadow_radius
=
adjust_border_radius_for_box_shadow
(
border_radius
spread_amount
)
;
let
shadow_rect
=
prim_info
.
rect
.
translate
(
box_offset
)
.
inflate
(
spread_amount
spread_amount
)
;
if
blur_radius
=
=
0
.
0
{
let
mut
clips
=
Vec
:
:
new
(
)
;
let
fast_info
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
clips
.
push
(
ClipSource
:
:
RoundedRectangle
(
prim_info
.
rect
border_radius
ClipMode
:
:
ClipOut
)
)
;
LayerPrimitiveInfo
:
:
with_clip
(
shadow_rect
LocalClip
:
:
RoundedRect
(
shadow_rect
ComplexClipRegion
:
:
new
(
shadow_rect
shadow_radius
ClipMode
:
:
Clip
)
)
)
}
BoxShadowClipMode
:
:
Inset
=
>
{
clips
.
push
(
ClipSource
:
:
RoundedRectangle
(
shadow_rect
shadow_radius
ClipMode
:
:
ClipOut
)
)
;
LayerPrimitiveInfo
:
:
with_clip
(
prim_info
.
rect
LocalClip
:
:
RoundedRect
(
prim_info
.
rect
ComplexClipRegion
:
:
new
(
prim_info
.
rect
border_radius
ClipMode
:
:
Clip
)
)
)
}
}
;
self
.
add_primitive
(
clip_and_scroll
&
fast_info
clips
PrimitiveContainer
:
:
Rectangle
(
RectanglePrimitive
{
content
:
RectangleContent
:
:
Fill
(
*
color
)
}
)
)
;
}
else
{
let
blur_offset
=
BLUR_SAMPLE_SCALE
*
blur_radius
;
let
mut
extra_clips
=
vec
!
[
]
;
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
let
width
;
let
height
;
let
brush_prim
;
let
corner_size
=
shadow_radius
.
is_uniform_size
(
)
;
let
radii_kind
;
if
!
shadow_rect
.
is_well_formed_and_nonempty
(
)
{
return
;
}
if
let
Some
(
corner_size
)
=
corner_size
{
radii_kind
=
BorderRadiusKind
:
:
Uniform
;
width
=
MASK_CORNER_PADDING
+
corner_size
.
width
.
max
(
BLUR_SAMPLE_SCALE
*
blur_radius
)
;
height
=
MASK_CORNER_PADDING
+
corner_size
.
height
.
max
(
BLUR_SAMPLE_SCALE
*
blur_radius
)
;
brush_prim
=
BrushPrimitive
{
kind
:
BrushKind
:
:
Mask
{
clip_mode
:
brush_clip_mode
kind
:
BrushMaskKind
:
:
Corner
(
corner_size
)
}
}
;
}
else
{
radii_kind
=
BorderRadiusKind
:
:
NonUniform
;
let
max_width
=
shadow_radius
.
top_left
.
width
.
max
(
shadow_radius
.
bottom_left
.
width
)
.
max
(
shadow_radius
.
top_right
.
width
)
.
max
(
shadow_radius
.
bottom_right
.
width
)
;
let
max_height
=
shadow_radius
.
top_left
.
height
.
max
(
shadow_radius
.
bottom_left
.
height
)
.
max
(
shadow_radius
.
top_right
.
height
)
.
max
(
shadow_radius
.
bottom_right
.
height
)
;
width
=
2
.
0
*
max_width
+
BLUR_SAMPLE_SCALE
*
blur_radius
;
height
=
2
.
0
*
max_height
+
BLUR_SAMPLE_SCALE
*
blur_radius
;
let
clip_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
LayerSize
:
:
new
(
width
height
)
)
;
brush_prim
=
BrushPrimitive
{
kind
:
BrushKind
:
:
Mask
{
clip_mode
:
brush_clip_mode
kind
:
BrushMaskKind
:
:
RoundedRect
(
clip_rect
shadow_radius
)
}
}
;
}
;
let
brush_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
LayerSize
:
:
new
(
width
height
)
)
;
let
brush_info
=
LayerPrimitiveInfo
:
:
new
(
brush_rect
)
;
let
brush_prim_index
=
self
.
create_primitive
(
clip_and_scroll
&
brush_info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
brush_prim
)
)
;
let
pic_rect
=
shadow_rect
.
inflate
(
blur_offset
blur_offset
)
;
let
mut
pic_prim
=
PicturePrimitive
:
:
new_box_shadow
(
blur_radius
*
color
Vec
:
:
new
(
)
clip_mode
radii_kind
)
;
pic_prim
.
add_primitive
(
brush_prim_index
&
brush_rect
clip_and_scroll
)
;
pic_prim
.
build
(
)
;
extra_clips
.
push
(
ClipSource
:
:
RoundedRectangle
(
prim_info
.
rect
border_radius
ClipMode
:
:
ClipOut
)
)
;
let
pic_info
=
LayerPrimitiveInfo
:
:
new
(
pic_rect
)
;
self
.
add_primitive
(
clip_and_scroll
&
pic_info
extra_clips
PrimitiveContainer
:
:
Picture
(
pic_prim
)
)
;
}
BoxShadowClipMode
:
:
Inset
=
>
{
let
brush_rect
=
LayerRect
:
:
new
(
LayerPoint
:
:
zero
(
)
prim_info
.
rect
.
size
)
;
let
clip_rect
=
brush_rect
.
translate
(
box_offset
)
.
inflate
(
spread_amount
spread_amount
)
;
let
brush_rect
=
brush_rect
.
inflate
(
1
.
0
1
.
0
)
;
let
brush_prim
=
BrushPrimitive
{
kind
:
BrushKind
:
:
Mask
{
clip_mode
:
brush_clip_mode
kind
:
BrushMaskKind
:
:
RoundedRect
(
clip_rect
shadow_radius
)
}
}
;
let
brush_info
=
LayerPrimitiveInfo
:
:
new
(
brush_rect
)
;
let
brush_prim_index
=
self
.
create_primitive
(
clip_and_scroll
&
brush_info
Vec
:
:
new
(
)
PrimitiveContainer
:
:
Brush
(
brush_prim
)
)
;
let
mut
pic_prim
=
PicturePrimitive
:
:
new_box_shadow
(
blur_radius
*
color
Vec
:
:
new
(
)
BoxShadowClipMode
:
:
Inset
BorderRadiusKind
:
:
NonUniform
)
;
pic_prim
.
add_primitive
(
brush_prim_index
&
brush_rect
clip_and_scroll
)
;
pic_prim
.
build
(
)
;
let
pic_rect
=
prim_info
.
rect
.
inflate
(
1
.
0
1
.
0
)
;
let
pic_info
=
LayerPrimitiveInfo
:
:
with_clip_rect
(
pic_rect
prim_info
.
rect
)
;
if
!
border_radius
.
is_zero
(
)
{
extra_clips
.
push
(
ClipSource
:
:
RoundedRectangle
(
prim_info
.
rect
border_radius
ClipMode
:
:
Clip
)
)
;
}
self
.
add_primitive
(
clip_and_scroll
&
pic_info
extra_clips
PrimitiveContainer
:
:
Picture
(
pic_prim
)
)
;
}
}
}
}
}
fn
adjust_border_radius_for_box_shadow
(
radius
:
BorderRadius
spread_amount
:
f32
)
-
>
BorderRadius
{
BorderRadius
{
top_left
:
adjust_corner_for_box_shadow
(
radius
.
top_left
spread_amount
)
top_right
:
adjust_corner_for_box_shadow
(
radius
.
top_right
spread_amount
)
bottom_right
:
adjust_corner_for_box_shadow
(
radius
.
bottom_right
spread_amount
)
bottom_left
:
adjust_corner_for_box_shadow
(
radius
.
bottom_left
spread_amount
)
}
}
fn
adjust_corner_for_box_shadow
(
corner
:
LayoutSize
spread_amount
:
f32
)
-
>
LayoutSize
{
LayoutSize
:
:
new
(
adjust_radius_for_box_shadow
(
corner
.
width
spread_amount
)
adjust_radius_for_box_shadow
(
corner
.
height
spread_amount
)
)
}
fn
adjust_radius_for_box_shadow
(
border_radius
:
f32
spread_amount
:
f32
)
-
>
f32
{
if
border_radius
>
0
.
0
{
(
border_radius
+
spread_amount
)
.
max
(
0
.
0
)
}
else
{
0
.
0
}
}
