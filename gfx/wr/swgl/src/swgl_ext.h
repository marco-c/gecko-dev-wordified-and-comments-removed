template
<
typename
V
>
static
ALWAYS_INLINE
WideRGBA8
pack_span
(
uint32_t
*
const
V
&
v
float
scale
=
255
.
0f
)
{
return
pack_pixels_RGBA8
(
v
scale
)
;
}
static
ALWAYS_INLINE
WideRGBA8
pack_span
(
uint32_t
*
)
{
return
pack_pixels_RGBA8
(
)
;
}
template
<
typename
C
>
static
ALWAYS_INLINE
WideR8
pack_span
(
uint8_t
*
C
c
float
scale
=
255
.
0f
)
{
return
pack_pixels_R8
(
c
scale
)
;
}
static
ALWAYS_INLINE
WideR8
pack_span
(
uint8_t
*
)
{
return
pack_pixels_R8
(
)
;
}
struct
NoColor
{
}
;
template
<
typename
P
>
static
ALWAYS_INLINE
P
applyColor
(
P
src
NoColor
)
{
return
src
;
}
template
<
typename
P
>
static
ALWAYS_INLINE
P
applyColor
(
P
src
P
color
)
{
return
muldiv256
(
src
color
)
;
}
static
ALWAYS_INLINE
PackedRGBA8
applyColor
(
PackedRGBA8
src
WideRGBA8
color
)
{
return
pack
(
muldiv256
(
unpack
(
src
)
color
)
)
;
}
static
ALWAYS_INLINE
PackedR8
applyColor
(
PackedR8
src
WideR8
color
)
{
return
pack
(
muldiv256
(
unpack
(
src
)
color
)
)
;
}
template
<
typename
P
typename
C
>
static
ALWAYS_INLINE
auto
packColor
(
P
*
buf
C
color
)
{
return
pack_span
(
buf
color
256
.
0f
)
;
}
template
<
typename
P
>
static
ALWAYS_INLINE
NoColor
packColor
(
UNUSED
P
*
buf
NoColor
noColor
)
{
return
noColor
;
}
static
ALWAYS_INLINE
void
commit_span
(
uint32_t
*
buf
WideRGBA8
r
)
{
unaligned_store
(
buf
pack
(
r
)
)
;
}
static
ALWAYS_INLINE
WideRGBA8
blend_span
(
uint32_t
*
buf
WideRGBA8
r
)
{
return
blend_pixels
(
buf
unaligned_load
<
PackedRGBA8
>
(
buf
)
r
)
;
}
static
ALWAYS_INLINE
WideRGBA8
blend_span
(
uint32_t
*
buf
WideRGBA8
r
int
len
)
{
return
blend_pixels
(
buf
partial_load_span
<
PackedRGBA8
>
(
buf
len
)
r
len
)
;
}
static
ALWAYS_INLINE
void
commit_span
(
uint32_t
*
buf
PackedRGBA8
r
)
{
unaligned_store
(
buf
r
)
;
}
static
ALWAYS_INLINE
PackedRGBA8
blend_span
(
uint32_t
*
buf
PackedRGBA8
r
)
{
return
pack
(
blend_span
(
buf
unpack
(
r
)
)
)
;
}
static
ALWAYS_INLINE
void
commit_span
(
uint8_t
*
buf
WideR8
r
)
{
unaligned_store
(
buf
pack
(
r
)
)
;
}
static
ALWAYS_INLINE
WideR8
blend_span
(
uint8_t
*
buf
WideR8
r
)
{
return
blend_pixels
(
buf
unpack
(
unaligned_load
<
PackedR8
>
(
buf
)
)
r
)
;
}
static
ALWAYS_INLINE
WideR8
blend_span
(
uint8_t
*
buf
WideR8
r
int
len
)
{
return
blend_pixels
(
buf
unpack
(
partial_load_span
<
PackedR8
>
(
buf
len
)
)
r
len
)
;
}
template
<
typename
P
typename
R
>
static
ALWAYS_INLINE
void
commit_blend_solid_span
(
P
*
buf
R
r
int
len
)
{
for
(
P
*
end
=
&
buf
[
len
&
~
3
]
;
buf
<
end
;
buf
+
=
4
)
{
commit_span
(
buf
blend_span
(
buf
r
)
)
;
}
len
&
=
3
;
if
(
len
>
0
)
{
partial_store_span
(
buf
pack
(
blend_span
(
buf
r
len
)
)
len
)
;
}
}
template
<
bool
BLEND
>
static
void
commit_solid_span
(
uint32_t
*
buf
WideRGBA8
r
int
len
)
{
commit_blend_solid_span
(
buf
r
len
)
;
}
template
<
>
ALWAYS_INLINE
void
commit_solid_span
<
false
>
(
uint32_t
*
buf
WideRGBA8
r
int
len
)
{
fill_n
(
buf
len
bit_cast
<
U32
>
(
pack
(
r
)
)
.
x
)
;
}
template
<
bool
BLEND
>
static
void
commit_solid_span
(
uint8_t
*
buf
WideR8
r
int
len
)
{
commit_blend_solid_span
(
buf
r
len
)
;
}
template
<
>
ALWAYS_INLINE
void
commit_solid_span
<
false
>
(
uint8_t
*
buf
WideR8
r
int
len
)
{
PackedR8
p
=
pack
(
r
)
;
fill_n
(
(
uint32_t
*
)
buf
len
/
4
bit_cast
<
uint32_t
>
(
p
)
)
;
buf
+
=
len
&
~
3
;
len
&
=
3
;
if
(
len
>
0
)
{
partial_store_span
(
buf
p
len
)
;
}
}
template
<
typename
P
typename
C
>
static
void
commit_masked_solid_span
(
P
*
buf
C
color
int
len
)
{
override_clip_mask
(
)
;
uint8_t
*
mask
=
get_clip_mask
(
buf
)
;
for
(
P
*
end
=
&
buf
[
len
]
;
buf
<
end
;
buf
+
=
4
mask
+
=
4
)
{
commit_span
(
buf
blend_span
(
buf
applyColor
(
expand_clip_mask
(
buf
unpack
(
unaligned_load
<
PackedR8
>
(
mask
)
)
)
color
)
)
)
;
}
restore_clip_mask
(
)
;
}
template
<
typename
P
typename
R
>
static
ALWAYS_INLINE
void
commit_aa_solid_span
(
P
*
buf
R
r
int
len
)
{
if
(
int
start
=
min
(
(
get_aa_opaque_start
(
buf
)
+
3
)
&
~
3
len
)
)
{
commit_solid_span
<
true
>
(
buf
r
start
)
;
buf
+
=
start
;
len
-
=
start
;
}
if
(
int
opaque
=
min
(
(
get_aa_opaque_size
(
buf
)
+
3
)
&
~
3
len
)
)
{
override_aa
(
)
;
commit_solid_span
<
true
>
(
buf
r
opaque
)
;
restore_aa
(
)
;
buf
+
=
opaque
;
len
-
=
opaque
;
}
if
(
len
>
0
)
{
commit_solid_span
<
true
>
(
buf
r
len
)
;
}
}
template
<
bool
BLEND
typename
P
typename
R
>
static
ALWAYS_INLINE
void
commit_blend_span
(
P
*
buf
R
r
)
{
if
(
BLEND
)
{
commit_span
(
buf
blend_span
(
buf
r
)
)
;
}
else
{
commit_span
(
buf
r
)
;
}
}
template
<
typename
T
>
static
ALWAYS_INLINE
auto
swgl_forceScalar
(
T
v
)
-
>
decltype
(
force_scalar
(
v
)
)
{
return
force_scalar
(
v
)
;
}
#
define
swgl_stepInterp
(
)
step_interp_inputs
(
)
#
define
swgl_interpStep
(
v
)
(
interp_step
.
v
)
#
define
swgl_commitSolid
(
format
v
)
\
do
{
\
if
(
blend_key
)
{
\
if
(
swgl_ClipFlags
&
SWGL_CLIP_FLAG_MASK
)
{
\
commit_masked_solid_span
(
swgl_Out
#
#
format
\
packColor
(
swgl_Out
#
#
format
(
v
)
)
\
swgl_SpanLength
)
;
\
}
else
if
(
swgl_ClipFlags
&
SWGL_CLIP_FLAG_AA
)
{
\
commit_aa_solid_span
(
swgl_Out
#
#
format
\
pack_span
(
swgl_Out
#
#
format
(
v
)
)
\
swgl_SpanLength
)
;
\
}
else
{
\
commit_solid_span
<
true
>
(
swgl_Out
#
#
format
\
pack_span
(
swgl_Out
#
#
format
(
v
)
)
\
swgl_SpanLength
)
;
\
}
\
}
else
{
\
commit_solid_span
<
false
>
(
swgl_Out
#
#
format
\
pack_span
(
swgl_Out
#
#
format
(
v
)
)
\
swgl_SpanLength
)
;
\
}
\
swgl_Out
#
#
format
+
=
swgl_SpanLength
;
\
swgl_SpanLength
=
0
;
\
}
while
(
0
)
#
define
swgl_commitSolidRGBA8
(
v
)
swgl_commitSolid
(
RGBA8
v
)
#
define
swgl_commitSolidR8
(
v
)
swgl_commitSolid
(
R8
v
)
#
define
swgl_commitChunk
(
format
chunk
)
\
do
{
\
auto
r
=
chunk
;
\
if
(
blend_key
)
r
=
blend_span
(
swgl_Out
#
#
format
r
)
;
\
commit_span
(
swgl_Out
#
#
format
r
)
;
\
swgl_Out
#
#
format
+
=
swgl_StepSize
;
\
swgl_SpanLength
-
=
swgl_StepSize
;
\
}
while
(
0
)
#
define
swgl_commitColor
(
format
color
alpha
)
\
swgl_commitChunk
(
format
applyColor
(
pack_pixels_
#
#
format
(
color
)
\
packColor
(
swgl_Out
#
#
format
alpha
)
)
)
#
define
swgl_commitColorRGBA8
(
color
alpha
)
\
swgl_commitColor
(
RGBA8
color
alpha
)
#
define
swgl_commitColorR8
(
color
alpha
)
swgl_commitColor
(
R8
color
alpha
)
template
<
typename
S
>
static
ALWAYS_INLINE
bool
swgl_isTextureLinear
(
S
s
)
{
return
s
-
>
filter
=
=
TextureFilter
:
:
LINEAR
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
bool
swgl_isTextureRGBA8
(
S
s
)
{
return
s
-
>
format
=
=
TextureFormat
:
:
RGBA8
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
bool
swgl_isTextureR8
(
S
s
)
{
return
s
-
>
format
=
=
TextureFormat
:
:
R8
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
int
swgl_textureLayerOffset
(
UNUSED
S
s
UNUSED
float
layer
)
{
return
0
;
}
UNUSED
static
ALWAYS_INLINE
int
swgl_textureLayerOffset
(
sampler2DArray
s
float
layer
)
{
return
clampCoord
(
int
(
layer
)
s
-
>
depth
)
*
s
-
>
height_stride
;
}
const
int
swgl_LinearQuantizeScale
=
128
;
template
<
typename
S
typename
T
>
static
ALWAYS_INLINE
T
swgl_linearQuantize
(
S
s
T
p
)
{
return
linearQuantize
(
p
swgl_LinearQuantizeScale
s
)
;
}
template
<
typename
S
typename
T
>
static
ALWAYS_INLINE
T
swgl_linearQuantizeStep
(
S
s
T
p
)
{
return
samplerScale
(
s
p
)
*
swgl_LinearQuantizeScale
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
WideRGBA8
textureLinearUnpacked
(
UNUSED
uint32_t
*
buf
S
sampler
ivec2
i
int
zoffset
)
{
return
textureLinearUnpackedRGBA8
(
sampler
i
zoffset
)
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
WideR8
textureLinearUnpacked
(
UNUSED
uint8_t
*
buf
S
sampler
ivec2
i
int
zoffset
)
{
return
textureLinearUnpackedR8
(
sampler
i
zoffset
)
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
bool
matchTextureFormat
(
S
s
UNUSED
uint32_t
*
buf
)
{
return
swgl_isTextureRGBA8
(
s
)
;
}
template
<
typename
S
>
static
ALWAYS_INLINE
bool
matchTextureFormat
(
S
s
UNUSED
uint8_t
*
buf
)
{
return
swgl_isTextureR8
(
s
)
;
}
#
define
LINEAR_QUANTIZE_UV
(
sampler
uv
uv_step
uv_rect
min_uv
max_uv
\
uv_z
zoffset
)
\
uv
=
swgl_linearQuantize
(
sampler
uv
)
;
\
vec2_scalar
uv_step
=
\
float
(
swgl_StepSize
)
*
vec2_scalar
{
uv
.
x
.
y
-
uv
.
x
.
x
uv
.
y
.
y
-
uv
.
y
.
x
}
;
\
vec2_scalar
min_uv
=
\
swgl_linearQuantize
(
sampler
vec2_scalar
{
uv_rect
.
x
uv_rect
.
y
}
)
;
\
vec2_scalar
max_uv
=
\
swgl_linearQuantize
(
sampler
vec2_scalar
{
uv_rect
.
z
uv_rect
.
w
}
)
;
\
int
zoffset
=
swgl_textureLayerOffset
(
sampler
uv_z
)
;
template
<
bool
BLEND
typename
S
typename
C
typename
P
>
static
void
blendTextureLinearFallback
(
S
sampler
vec2
uv
int
span
vec2_scalar
uv_step
vec2_scalar
min_uv
vec2_scalar
max_uv
C
color
P
*
buf
int
zoffset
)
{
for
(
P
*
end
=
buf
+
span
;
buf
<
end
;
buf
+
=
swgl_StepSize
uv
+
=
uv_step
)
{
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
textureLinearUnpacked
(
buf
sampler
ivec2
(
clamp
(
uv
min_uv
max_uv
)
)
zoffset
)
color
)
)
;
}
}
static
ALWAYS_INLINE
U64
castForShuffle
(
V16
<
int16_t
>
r
)
{
return
bit_cast
<
U64
>
(
r
)
;
}
static
ALWAYS_INLINE
U16
castForShuffle
(
V4
<
int16_t
>
r
)
{
return
bit_cast
<
U16
>
(
r
)
;
}
static
ALWAYS_INLINE
V16
<
int16_t
>
applyFracX
(
V16
<
int16_t
>
r
I16
fracx
)
{
return
r
*
fracx
.
xxxxyyyyzzzzwwww
;
}
static
ALWAYS_INLINE
V4
<
int16_t
>
applyFracX
(
V4
<
int16_t
>
r
I16
fracx
)
{
return
r
*
fracx
;
}
template
<
bool
BLEND
typename
S
typename
C
typename
P
>
static
void
blendTextureLinearUpscale
(
S
sampler
vec2
uv
int
span
vec2_scalar
uv_step
vec2_scalar
min_uv
vec2_scalar
max_uv
C
color
P
*
buf
int
zoffset
)
{
typedef
VectorType
<
uint8_t
4
*
sizeof
(
P
)
>
packed_type
;
typedef
VectorType
<
uint16_t
4
*
sizeof
(
P
)
>
unpacked_type
;
typedef
VectorType
<
int16_t
4
*
sizeof
(
P
)
>
signed_unpacked_type
;
ivec2
i
(
clamp
(
uv
min_uv
max_uv
)
)
;
ivec2
frac
=
i
;
i
>
>
=
7
;
P
*
row0
=
(
P
*
)
sampler
-
>
buf
+
computeRow
(
sampler
ivec2_scalar
(
0
i
.
y
.
x
)
zoffset
)
;
P
*
row1
=
row0
+
computeNextRowOffset
(
sampler
ivec2_scalar
(
0
i
.
y
.
x
)
)
;
I16
fracx
=
computeFracX
(
sampler
i
frac
)
;
int16_t
fracy
=
computeFracY
(
frac
)
.
x
;
auto
src0
=
CONVERT
(
unaligned_load
<
packed_type
>
(
&
row0
[
i
.
x
.
x
]
)
signed_unpacked_type
)
;
auto
src1
=
CONVERT
(
unaligned_load
<
packed_type
>
(
&
row1
[
i
.
x
.
x
]
)
signed_unpacked_type
)
;
auto
src
=
castForShuffle
(
src0
+
(
(
(
src1
-
src0
)
*
fracy
)
>
>
7
)
)
;
for
(
P
*
end
=
buf
+
span
;
buf
<
end
;
buf
+
=
4
)
{
uv
.
x
+
=
uv_step
.
x
;
I32
ixn
=
cast
(
uv
.
x
)
;
I16
fracn
=
computeFracNoClamp
(
ixn
)
;
ixn
>
>
=
7
;
auto
src0n
=
CONVERT
(
unaligned_load
<
packed_type
>
(
&
row0
[
ixn
.
x
]
)
signed_unpacked_type
)
;
auto
src1n
=
CONVERT
(
unaligned_load
<
packed_type
>
(
&
row1
[
ixn
.
x
]
)
signed_unpacked_type
)
;
auto
srcn
=
castForShuffle
(
src0n
+
(
(
(
src1n
-
src0n
)
*
fracy
)
>
>
7
)
)
;
auto
shuf
=
src
;
auto
shufn
=
SHUFFLE
(
src
ixn
.
x
=
=
i
.
x
.
w
?
srcn
.
yyyy
:
srcn
1
2
3
4
)
;
if
(
i
.
x
.
y
=
=
i
.
x
.
x
)
{
shuf
=
shuf
.
xxyz
;
shufn
=
shufn
.
xxyz
;
}
if
(
i
.
x
.
z
=
=
i
.
x
.
y
)
{
shuf
=
shuf
.
xyyz
;
shufn
=
shufn
.
xyyz
;
}
if
(
i
.
x
.
w
=
=
i
.
x
.
z
)
{
shuf
=
shuf
.
xyzz
;
shufn
=
shufn
.
xyzz
;
}
auto
interp
=
bit_cast
<
signed_unpacked_type
>
(
shuf
)
;
auto
interpn
=
bit_cast
<
signed_unpacked_type
>
(
shufn
)
;
interp
+
=
applyFracX
(
interpn
-
interp
fracx
)
>
>
7
;
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
bit_cast
<
unpacked_type
>
(
interp
)
color
)
)
;
i
.
x
=
ixn
;
fracx
=
fracn
;
src
=
srcn
;
}
}
template
<
bool
BLEND
typename
S
typename
C
typename
P
>
static
void
blendTextureLinearFast
(
S
sampler
vec2
uv
int
span
vec2_scalar
min_uv
vec2_scalar
max_uv
C
color
P
*
buf
int
zoffset
)
{
typedef
VectorType
<
uint8_t
4
*
sizeof
(
P
)
>
packed_type
;
typedef
VectorType
<
uint16_t
4
*
sizeof
(
P
)
>
unpacked_type
;
typedef
VectorType
<
int16_t
4
*
sizeof
(
P
)
>
signed_unpacked_type
;
ivec2
i
(
clamp
(
uv
min_uv
max_uv
)
)
;
ivec2
frac
=
i
;
i
>
>
=
7
;
P
*
row0
=
(
P
*
)
sampler
-
>
buf
+
computeRow
(
sampler
force_scalar
(
i
)
zoffset
)
;
P
*
row1
=
row0
+
computeNextRowOffset
(
sampler
force_scalar
(
i
)
)
;
int16_t
fracx
=
computeFracX
(
sampler
i
frac
)
.
x
;
int16_t
fracy
=
computeFracY
(
frac
)
.
x
;
auto
src0
=
CONVERT
(
unaligned_load
<
packed_type
>
(
row0
)
signed_unpacked_type
)
;
auto
src1
=
CONVERT
(
unaligned_load
<
packed_type
>
(
row1
)
signed_unpacked_type
)
;
auto
src
=
castForShuffle
(
src0
+
(
(
(
src1
-
src0
)
*
fracy
)
>
>
7
)
)
;
for
(
P
*
end
=
buf
+
span
;
buf
<
end
;
buf
+
=
4
)
{
row0
+
=
4
;
row1
+
=
4
;
auto
src0n
=
CONVERT
(
unaligned_load
<
packed_type
>
(
row0
)
signed_unpacked_type
)
;
auto
src1n
=
CONVERT
(
unaligned_load
<
packed_type
>
(
row1
)
signed_unpacked_type
)
;
auto
srcn
=
castForShuffle
(
src0n
+
(
(
(
src1n
-
src0n
)
*
fracy
)
>
>
7
)
)
;
auto
interp
=
bit_cast
<
signed_unpacked_type
>
(
src
)
;
auto
interpn
=
bit_cast
<
signed_unpacked_type
>
(
SHUFFLE
(
src
srcn
1
2
3
4
)
)
;
interp
+
=
(
(
interpn
-
interp
)
*
fracx
)
>
>
7
;
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
bit_cast
<
unpacked_type
>
(
interp
)
color
)
)
;
src
=
srcn
;
}
}
enum
LinearFilter
{
LINEAR_FILTER_NEAREST
=
0
LINEAR_FILTER_FALLBACK
LINEAR_FILTER_UPSCALE
LINEAR_FILTER_FAST
}
;
template
<
bool
BLEND
typename
S
typename
C
typename
P
>
static
int
blendTextureLinear
(
S
sampler
vec2
uv
int
span
const
vec4_scalar
&
uv_rect
C
color
P
*
buf
LinearFilter
filter
float
z
=
0
)
{
if
(
!
matchTextureFormat
(
sampler
buf
)
)
{
return
0
;
}
LINEAR_QUANTIZE_UV
(
sampler
uv
uv_step
uv_rect
min_uv
max_uv
z
zoffset
)
;
P
*
end
=
buf
+
span
;
if
(
filter
!
=
LINEAR_FILTER_FALLBACK
)
{
float
beforeDist
=
max
(
0
.
0f
min_uv
.
x
)
-
uv
.
x
.
x
;
if
(
beforeDist
>
0
)
{
int
before
=
clamp
(
int
(
ceil
(
beforeDist
/
uv_step
.
x
)
)
*
swgl_StepSize
0
int
(
end
-
buf
)
)
;
blendTextureLinearFallback
<
BLEND
>
(
sampler
uv
before
uv_step
min_uv
max_uv
color
buf
zoffset
)
;
buf
+
=
before
;
uv
.
x
+
=
(
before
/
swgl_StepSize
)
*
uv_step
.
x
;
}
float
insideDist
=
min
(
max_uv
.
x
float
(
(
int
(
sampler
-
>
width
)
-
swgl_StepSize
)
<
<
7
)
)
-
uv
.
x
.
x
;
if
(
insideDist
>
=
uv_step
.
x
)
{
int
inside
=
clamp
(
int
(
insideDist
/
uv_step
.
x
)
*
swgl_StepSize
0
int
(
end
-
buf
)
)
;
if
(
filter
=
=
LINEAR_FILTER_FAST
)
{
blendTextureLinearFast
<
BLEND
>
(
sampler
uv
inside
min_uv
max_uv
color
buf
zoffset
)
;
}
else
{
blendTextureLinearUpscale
<
BLEND
>
(
sampler
uv
inside
uv_step
min_uv
max_uv
color
buf
zoffset
)
;
}
buf
+
=
inside
;
uv
.
x
+
=
(
inside
/
swgl_StepSize
)
*
uv_step
.
x
;
}
}
if
(
buf
<
end
)
{
blendTextureLinearFallback
<
BLEND
>
(
sampler
uv
int
(
end
-
buf
)
uv_step
min_uv
max_uv
color
buf
zoffset
)
;
}
return
span
;
}
template
<
bool
BLEND
typename
S
typename
C
typename
P
>
static
int
blendTextureNearest
(
S
sampler
vec2
uv
int
span
const
vec4_scalar
&
uv_rect
C
color
P
*
buf
float
layer
=
0
)
{
if
(
!
matchTextureFormat
(
sampler
buf
)
)
{
return
0
;
}
typedef
VectorType
<
uint8_t
4
*
sizeof
(
P
)
>
packed_type
;
ivec2_scalar
i
=
make_ivec2
(
samplerScale
(
sampler
force_scalar
(
uv
)
)
)
;
ivec2_scalar
minUV
=
make_ivec2
(
samplerScale
(
sampler
vec2_scalar
{
uv_rect
.
x
uv_rect
.
y
}
)
)
;
ivec2_scalar
maxUV
=
make_ivec2
(
samplerScale
(
sampler
vec2_scalar
{
uv_rect
.
z
uv_rect
.
w
}
)
)
;
int
layerOffset
=
swgl_textureLayerOffset
(
sampler
layer
)
;
P
*
row
=
&
sampler
-
>
buf
[
clamp
(
clampCoord
(
i
.
y
sampler
-
>
height
)
minUV
.
y
maxUV
.
y
)
*
sampler
-
>
stride
+
layerOffset
]
;
int
minX
=
clamp
(
minUV
.
x
0
sampler
-
>
width
-
1
)
;
int
maxX
=
clamp
(
maxUV
.
x
minX
sampler
-
>
width
-
1
)
;
int
curX
=
i
.
x
;
int
endX
=
i
.
x
+
span
;
if
(
curX
<
minX
)
{
int
n
=
min
(
minX
endX
)
-
curX
;
auto
src
=
applyColor
(
unpack
(
bit_cast
<
packed_type
>
(
V4
<
P
>
(
row
[
minX
]
)
)
)
color
)
;
commit_solid_span
<
BLEND
>
(
buf
src
n
)
;
buf
+
=
n
;
curX
+
=
n
;
}
int
n
=
max
(
min
(
maxX
+
1
endX
)
-
curX
0
)
;
for
(
int
end
=
curX
+
(
n
&
~
3
)
;
curX
<
end
;
curX
+
=
4
buf
+
=
4
)
{
auto
src
=
applyColor
(
unpack
(
unaligned_load
<
packed_type
>
(
&
row
[
curX
]
)
)
color
)
;
commit_blend_span
<
BLEND
>
(
buf
src
)
;
}
n
&
=
3
;
if
(
n
>
0
)
{
if
(
BLEND
)
{
auto
src
=
applyColor
(
unpack
(
partial_load_span
<
packed_type
>
(
&
row
[
curX
]
n
)
)
color
)
;
partial_store_span
(
buf
pack
(
blend_span
(
buf
src
n
)
)
n
)
;
}
else
{
auto
src
=
applyColor
(
partial_load_span
<
packed_type
>
(
&
row
[
curX
]
n
)
color
)
;
partial_store_span
(
buf
src
n
)
;
}
buf
+
=
n
;
curX
+
=
n
;
}
if
(
curX
<
endX
)
{
auto
src
=
applyColor
(
unpack
(
bit_cast
<
packed_type
>
(
U32
(
row
[
maxX
]
)
)
)
color
)
;
commit_solid_span
<
BLEND
>
(
buf
src
endX
-
curX
)
;
}
return
span
;
}
template
<
typename
S
typename
T
>
static
inline
LinearFilter
needsTextureLinear
(
S
sampler
T
P
int
span
)
{
if
(
P
.
y
.
x
!
=
P
.
y
.
y
)
{
return
LINEAR_FILTER_FALLBACK
;
}
P
=
samplerScale
(
sampler
P
)
;
span
&
=
~
(
128
-
1
)
;
span
+
=
128
;
float
dx
=
P
.
x
.
y
-
P
.
x
.
x
;
if
(
round
(
dx
*
span
)
!
=
span
)
{
return
dx
>
=
0
&
&
dx
<
=
1
?
LINEAR_FILTER_UPSCALE
:
LINEAR_FILTER_FALLBACK
;
}
if
(
(
int
(
P
.
x
.
x
*
4
.
0f
+
0
.
5f
)
&
3
)
!
=
2
|
|
(
int
(
P
.
y
.
x
*
4
.
0f
+
0
.
5f
)
&
3
)
!
=
2
)
{
return
LINEAR_FILTER_FAST
;
}
return
LINEAR_FILTER_NEAREST
;
}
#
define
swgl_commitTextureLinear
(
format
s
p
uv_rect
color
.
.
.
)
\
do
{
\
auto
packed_color
=
packColor
(
swgl_Out
#
#
format
color
)
;
\
int
drawn
=
0
;
\
if
(
LinearFilter
filter
=
needsTextureLinear
(
s
p
swgl_SpanLength
)
)
{
\
if
(
blend_key
)
{
\
drawn
=
blendTextureLinear
<
true
>
(
s
p
swgl_SpanLength
uv_rect
\
packed_color
swgl_Out
#
#
format
\
filter
__VA_ARGS__
)
;
\
}
else
{
\
drawn
=
blendTextureLinear
<
false
>
(
s
p
swgl_SpanLength
uv_rect
\
packed_color
swgl_Out
#
#
format
\
filter
__VA_ARGS__
)
;
\
}
\
}
else
if
(
blend_key
)
{
\
drawn
=
blendTextureNearest
<
true
>
(
s
p
swgl_SpanLength
uv_rect
\
packed_color
swgl_Out
#
#
format
\
__VA_ARGS__
)
;
\
}
else
{
\
drawn
=
blendTextureNearest
<
false
>
(
s
p
swgl_SpanLength
uv_rect
\
packed_color
swgl_Out
#
#
format
\
__VA_ARGS__
)
;
\
}
\
swgl_Out
#
#
format
+
=
drawn
;
\
swgl_SpanLength
-
=
drawn
;
\
}
while
(
0
)
#
define
swgl_commitTextureLinearRGBA8
(
s
p
uv_rect
.
.
.
)
\
swgl_commitTextureLinear
(
RGBA8
s
p
uv_rect
NoColor
(
)
__VA_ARGS__
)
#
define
swgl_commitTextureLinearR8
(
s
p
uv_rect
.
.
.
)
\
swgl_commitTextureLinear
(
R8
s
p
uv_rect
NoColor
(
)
__VA_ARGS__
)
#
define
swgl_commitTextureLinearColorRGBA8
(
s
p
uv_rect
color
.
.
.
)
\
swgl_commitTextureLinear
(
RGBA8
s
p
uv_rect
color
__VA_ARGS__
)
#
define
swgl_commitTextureLinearColorR8
(
s
p
uv_rect
color
.
.
.
)
\
swgl_commitTextureLinear
(
R8
s
p
uv_rect
color
__VA_ARGS__
)
#
define
swgl_commitTextureLinearChunk
(
format
s
p
color
.
.
.
)
\
swgl_commitChunk
(
format
applyColor
(
textureLinearUnpacked
#
#
format
(
\
s
ivec2
(
p
)
__VA_ARGS__
)
\
packColor
(
swgl_Out
#
#
format
color
)
)
)
#
define
swgl_commitTextureLinearChunkRGBA8
(
s
p
.
.
.
)
\
swgl_commitTextureLinearChunk
(
RGBA8
s
p
NoColor
(
)
__VA_ARGS__
)
#
define
swgl_commitTextureLinearChunkR8
(
s
p
.
.
.
)
\
swgl_commitTextureLinearChunk
(
R8
s
p
NoColor
(
)
__VA_ARGS__
)
#
define
swgl_commitTextureLinearChunkColorRGBA8
(
s
p
color
.
.
.
)
\
swgl_commitTextureLinearChunk
(
RGBA8
s
p
color
__VA_ARGS__
)
#
define
swgl_commitTextureLinearChunkColorR8
(
s
p
color
.
.
.
)
\
swgl_commitTextureLinearChunk
(
R8
s
p
color
__VA_ARGS__
)
template
<
bool
BLEND
typename
S
typename
P
>
static
int
blendGaussianBlur
(
S
sampler
vec2
uv
const
vec4_scalar
&
uv_rect
P
*
buf
int
span
bool
hori
int
radius
vec2_scalar
coeffs
float
z
=
0
)
{
if
(
!
matchTextureFormat
(
sampler
buf
)
)
{
return
0
;
}
vec2_scalar
size
=
{
float
(
sampler
-
>
width
)
float
(
sampler
-
>
height
)
}
;
ivec2_scalar
curUV
=
make_ivec2
(
force_scalar
(
uv
)
*
size
)
;
ivec4_scalar
bounds
=
make_ivec4
(
uv_rect
*
make_vec4
(
size
size
)
)
;
int
zoffset
=
swgl_textureLayerOffset
(
sampler
z
)
;
int
startX
=
curUV
.
x
;
int
endX
=
min
(
bounds
.
z
curUV
.
x
+
span
)
;
if
(
hori
)
{
for
(
;
curUV
.
x
+
swgl_StepSize
<
=
endX
;
buf
+
=
swgl_StepSize
curUV
.
x
+
=
swgl_StepSize
)
{
commit_blend_span
<
BLEND
>
(
buf
gaussianBlurHorizontal
<
P
>
(
sampler
curUV
bounds
.
x
bounds
.
z
radius
coeffs
.
x
coeffs
.
y
zoffset
)
)
;
}
}
else
{
for
(
;
curUV
.
x
+
swgl_StepSize
<
=
endX
;
buf
+
=
swgl_StepSize
curUV
.
x
+
=
swgl_StepSize
)
{
commit_blend_span
<
BLEND
>
(
buf
gaussianBlurVertical
<
P
>
(
sampler
curUV
bounds
.
y
bounds
.
w
radius
coeffs
.
x
coeffs
.
y
zoffset
)
)
;
}
}
return
curUV
.
x
-
startX
;
}
#
define
swgl_commitGaussianBlur
(
format
s
p
uv_rect
hori
radius
coeffs
\
.
.
.
)
\
do
{
\
int
drawn
=
0
;
\
if
(
blend_key
)
{
\
drawn
=
blendGaussianBlur
<
true
>
(
s
p
uv_rect
swgl_Out
#
#
format
\
swgl_SpanLength
hori
radius
coeffs
\
__VA_ARGS__
)
;
\
}
else
{
\
drawn
=
blendGaussianBlur
<
false
>
(
s
p
uv_rect
swgl_Out
#
#
format
\
swgl_SpanLength
hori
radius
coeffs
\
__VA_ARGS__
)
;
\
}
\
swgl_Out
#
#
format
+
=
drawn
;
\
swgl_SpanLength
-
=
drawn
;
\
}
while
(
0
)
#
define
swgl_commitGaussianBlurRGBA8
(
s
p
uv_rect
hori
radius
coeffs
.
.
.
)
\
swgl_commitGaussianBlur
(
RGBA8
s
p
uv_rect
hori
radius
coeffs
\
__VA_ARGS__
)
#
define
swgl_commitGaussianBlurR8
(
s
p
uv_rect
hori
radius
coeffs
.
.
.
)
\
swgl_commitGaussianBlur
(
R8
s
p
uv_rect
hori
radius
coeffs
__VA_ARGS__
)
static
ALWAYS_INLINE
PackedRGBA8
convertYUV
(
int
colorSpace
U16
y
U16
u
U16
v
)
{
auto
yy
=
V8
<
int16_t
>
(
zip
(
y
y
)
)
;
auto
uv
=
V8
<
int16_t
>
(
zip
(
u
v
)
)
;
return
yuvMatrix
[
colorSpace
]
.
convert
(
yy
uv
)
;
}
template
<
typename
S0
>
static
ALWAYS_INLINE
PackedRGBA8
sampleYUV
(
S0
sampler0
ivec2
uv0
int
layer0
int
colorSpace
UNUSED
int
rescaleFactor
)
{
switch
(
sampler0
-
>
format
)
{
case
TextureFormat
:
:
RGBA8
:
{
auto
planar
=
textureLinearPlanarRGBA8
(
sampler0
uv0
layer0
)
;
return
convertYUV
(
colorSpace
highHalf
(
planar
.
rg
)
lowHalf
(
planar
.
rg
)
lowHalf
(
planar
.
ba
)
)
;
}
case
TextureFormat
:
:
YUV422
:
{
auto
planar
=
textureLinearPlanarYUV422
(
sampler0
uv0
layer0
)
;
return
convertYUV
(
colorSpace
planar
.
y
planar
.
u
planar
.
v
)
;
}
default
:
assert
(
false
)
;
return
PackedRGBA8
(
0
)
;
}
}
template
<
bool
BLEND
typename
S0
typename
P
typename
C
=
NoColor
>
static
void
blendYUV
(
P
*
buf
int
span
S0
sampler0
vec2
uv0
const
vec4_scalar
uv_rect0
float
z0
int
colorSpace
int
rescaleFactor
C
color
=
C
(
)
)
{
LINEAR_QUANTIZE_UV
(
sampler0
uv0
uv_step0
uv_rect0
min_uv0
max_uv0
z0
layer0
)
;
auto
c
=
packColor
(
buf
color
)
;
auto
*
end
=
buf
+
span
;
for
(
;
buf
<
end
;
buf
+
=
swgl_StepSize
uv0
+
=
uv_step0
)
{
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
sampleYUV
(
sampler0
ivec2
(
clamp
(
uv0
min_uv0
max_uv0
)
)
layer0
colorSpace
rescaleFactor
)
c
)
)
;
}
}
template
<
typename
S0
typename
S1
>
static
ALWAYS_INLINE
PackedRGBA8
sampleYUV
(
S0
sampler0
ivec2
uv0
int
layer0
S1
sampler1
ivec2
uv1
int
layer1
int
colorSpace
UNUSED
int
rescaleFactor
)
{
switch
(
sampler1
-
>
format
)
{
case
TextureFormat
:
:
RG8
:
{
assert
(
sampler0
-
>
format
=
=
TextureFormat
:
:
R8
)
;
auto
y
=
textureLinearUnpackedR8
(
sampler0
uv0
layer0
)
;
auto
planar
=
textureLinearPlanarRG8
(
sampler1
uv1
layer1
)
;
return
convertYUV
(
colorSpace
y
lowHalf
(
planar
.
rg
)
highHalf
(
planar
.
rg
)
)
;
}
case
TextureFormat
:
:
RGBA8
:
{
assert
(
sampler0
-
>
format
=
=
TextureFormat
:
:
R8
)
;
auto
y
=
textureLinearUnpackedR8
(
sampler0
uv0
layer0
)
;
auto
planar
=
textureLinearPlanarRGBA8
(
sampler1
uv1
layer1
)
;
return
convertYUV
(
colorSpace
y
lowHalf
(
planar
.
ba
)
highHalf
(
planar
.
rg
)
)
;
}
default
:
assert
(
false
)
;
return
PackedRGBA8
(
0
)
;
}
}
template
<
bool
BLEND
typename
S0
typename
S1
typename
P
typename
C
=
NoColor
>
static
void
blendYUV
(
P
*
buf
int
span
S0
sampler0
vec2
uv0
const
vec4_scalar
uv_rect0
float
z0
S1
sampler1
vec2
uv1
const
vec4_scalar
uv_rect1
float
z1
int
colorSpace
int
rescaleFactor
C
color
=
C
(
)
)
{
LINEAR_QUANTIZE_UV
(
sampler0
uv0
uv_step0
uv_rect0
min_uv0
max_uv0
z0
layer0
)
;
LINEAR_QUANTIZE_UV
(
sampler1
uv1
uv_step1
uv_rect1
min_uv1
max_uv1
z1
layer1
)
;
auto
c
=
packColor
(
buf
color
)
;
auto
*
end
=
buf
+
span
;
for
(
;
buf
<
end
;
buf
+
=
swgl_StepSize
uv0
+
=
uv_step0
uv1
+
=
uv_step1
)
{
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
sampleYUV
(
sampler0
ivec2
(
clamp
(
uv0
min_uv0
max_uv0
)
)
layer0
sampler1
ivec2
(
clamp
(
uv1
min_uv1
max_uv1
)
)
layer1
colorSpace
rescaleFactor
)
c
)
)
;
}
}
template
<
typename
S0
typename
S1
typename
S2
>
static
ALWAYS_INLINE
PackedRGBA8
sampleYUV
(
S0
sampler0
ivec2
uv0
int
layer0
S1
sampler1
ivec2
uv1
int
layer1
S2
sampler2
ivec2
uv2
int
layer2
int
colorSpace
int
rescaleFactor
)
{
assert
(
sampler0
-
>
format
=
=
sampler1
-
>
format
&
&
sampler0
-
>
format
=
=
sampler2
-
>
format
)
;
switch
(
sampler0
-
>
format
)
{
case
TextureFormat
:
:
R8
:
{
auto
y
=
textureLinearUnpackedR8
(
sampler0
uv0
layer0
)
;
auto
u
=
textureLinearUnpackedR8
(
sampler1
uv1
layer1
)
;
auto
v
=
textureLinearUnpackedR8
(
sampler2
uv2
layer2
)
;
return
convertYUV
(
colorSpace
y
u
v
)
;
}
case
TextureFormat
:
:
R16
:
{
int
colorDepth
=
16
-
rescaleFactor
;
int
rescaleBits
=
(
colorDepth
-
1
)
-
8
;
auto
y
=
textureLinearUnpackedR16
(
sampler0
uv0
layer0
)
>
>
rescaleBits
;
auto
u
=
textureLinearUnpackedR16
(
sampler1
uv1
layer1
)
>
>
rescaleBits
;
auto
v
=
textureLinearUnpackedR16
(
sampler2
uv2
layer2
)
>
>
rescaleBits
;
return
convertYUV
(
colorSpace
U16
(
y
)
U16
(
u
)
U16
(
v
)
)
;
}
default
:
assert
(
false
)
;
return
PackedRGBA8
(
0
)
;
}
}
template
<
bool
BLEND
typename
S0
typename
S1
typename
S2
typename
P
typename
C
=
NoColor
>
static
void
blendYUV
(
P
*
buf
int
span
S0
sampler0
vec2
uv0
const
vec4_scalar
uv_rect0
float
z0
S1
sampler1
vec2
uv1
const
vec4_scalar
uv_rect1
float
z1
S2
sampler2
vec2
uv2
const
vec4_scalar
uv_rect2
float
z2
int
colorSpace
int
rescaleFactor
C
color
=
C
(
)
)
{
LINEAR_QUANTIZE_UV
(
sampler0
uv0
uv_step0
uv_rect0
min_uv0
max_uv0
z0
layer0
)
;
LINEAR_QUANTIZE_UV
(
sampler1
uv1
uv_step1
uv_rect1
min_uv1
max_uv1
z1
layer1
)
;
LINEAR_QUANTIZE_UV
(
sampler2
uv2
uv_step2
uv_rect2
min_uv2
max_uv2
z2
layer2
)
;
auto
c
=
packColor
(
buf
color
)
;
auto
*
end
=
buf
+
span
;
for
(
;
buf
<
end
;
buf
+
=
swgl_StepSize
uv0
+
=
uv_step0
uv1
+
=
uv_step1
uv2
+
=
uv_step2
)
{
commit_blend_span
<
BLEND
>
(
buf
applyColor
(
sampleYUV
(
sampler0
ivec2
(
clamp
(
uv0
min_uv0
max_uv0
)
)
layer0
sampler1
ivec2
(
clamp
(
uv1
min_uv1
max_uv1
)
)
layer1
sampler2
ivec2
(
clamp
(
uv2
min_uv2
max_uv2
)
)
layer2
colorSpace
rescaleFactor
)
c
)
)
;
}
}
#
define
swgl_commitTextureLinearYUV
(
.
.
.
)
\
do
{
\
if
(
blend_key
)
{
\
blendYUV
<
true
>
(
swgl_OutRGBA8
swgl_SpanLength
__VA_ARGS__
)
;
\
}
else
{
\
blendYUV
<
false
>
(
swgl_OutRGBA8
swgl_SpanLength
__VA_ARGS__
)
;
\
}
\
swgl_OutRGBA8
+
=
swgl_SpanLength
;
\
swgl_SpanLength
=
0
;
\
}
while
(
0
)
#
define
swgl_commitTextureLinearColorYUV
(
.
.
.
)
\
swgl_commitTextureLinearYUV
(
__VA_ARGS__
)
struct
GradientStops
{
Float
startColor
;
union
{
Float
stepColor
;
vec4_scalar
stepData
;
}
;
bool
can_merge
(
const
GradientStops
&
next
)
const
{
return
stepData
=
=
next
.
stepData
;
}
Float
interpolate
(
float
offset
)
const
{
return
startColor
+
stepColor
*
offset
;
}
Float
end_color
(
)
const
{
return
startColor
+
stepColor
;
}
}
;
static
inline
int
swgl_validateGradient
(
sampler2D
sampler
ivec2_scalar
address
int
entries
)
{
return
sampler
-
>
format
=
=
TextureFormat
:
:
RGBA32F
&
&
address
.
y
>
=
0
&
&
address
.
y
<
int
(
sampler
-
>
height
)
&
&
address
.
x
>
=
0
&
&
address
.
x
<
int
(
sampler
-
>
width
)
&
&
entries
>
0
&
&
address
.
x
+
int
(
sizeof
(
GradientStops
)
/
sizeof
(
Float
)
)
*
entries
<
=
int
(
sampler
-
>
width
)
?
address
.
y
*
sampler
-
>
stride
+
address
.
x
*
4
:
-
1
;
}
static
inline
WideRGBA8
sampleGradient
(
sampler2D
sampler
int
address
Float
entry
)
{
assert
(
sampler
-
>
format
=
=
TextureFormat
:
:
RGBA32F
)
;
assert
(
address
>
=
0
&
&
address
<
int
(
sampler
-
>
height
*
sampler
-
>
stride
)
)
;
I32
index
=
cast
(
entry
)
;
Float
offset
=
entry
-
cast
(
index
)
;
assert
(
test_all
(
index
>
=
0
&
&
index
*
int
(
sizeof
(
GradientStops
)
/
sizeof
(
Float
)
)
<
int
(
sampler
-
>
width
)
)
)
;
GradientStops
*
stops
=
(
GradientStops
*
)
&
sampler
-
>
buf
[
address
]
;
return
combine
(
packRGBA8
(
round_pixel
(
stops
[
index
.
x
]
.
interpolate
(
offset
.
x
)
.
zyxw
)
round_pixel
(
stops
[
index
.
y
]
.
interpolate
(
offset
.
y
)
.
zyxw
)
)
packRGBA8
(
round_pixel
(
stops
[
index
.
z
]
.
interpolate
(
offset
.
z
)
.
zyxw
)
round_pixel
(
stops
[
index
.
w
]
.
interpolate
(
offset
.
w
)
.
zyxw
)
)
)
;
}
#
define
swgl_commitGradientRGBA8
(
sampler
address
entry
)
\
swgl_commitChunk
(
RGBA8
sampleGradient
(
sampler
address
entry
)
)
#
define
swgl_commitGradientColorRGBA8
(
sampler
address
entry
color
)
\
swgl_commitChunk
(
RGBA8
applyColor
(
sampleGradient
(
sampler
address
entry
)
\
packColor
(
swgl_OutRGBA
color
)
)
)
template
<
bool
BLEND
>
static
void
commitLinearGradient
(
sampler2D
sampler
int
address
float
size
bool
repeat
Float
offset
uint32_t
*
buf
int
span
)
{
assert
(
sampler
-
>
format
=
=
TextureFormat
:
:
RGBA32F
)
;
assert
(
address
>
=
0
&
&
address
<
int
(
sampler
-
>
height
*
sampler
-
>
stride
)
)
;
GradientStops
*
stops
=
(
GradientStops
*
)
&
sampler
-
>
buf
[
address
]
;
float
delta
=
(
offset
.
y
-
offset
.
x
)
*
4
.
0f
;
for
(
;
span
>
0
;
)
{
if
(
repeat
)
{
offset
=
fract
(
offset
)
;
}
float
chunks
=
0
.
25f
*
span
;
float
startEntry
;
int
minIndex
maxIndex
;
if
(
offset
.
x
<
0
)
{
startEntry
=
0
;
minIndex
=
int
(
startEntry
)
;
maxIndex
=
minIndex
;
if
(
delta
>
0
)
{
chunks
=
min
(
chunks
-
offset
.
x
/
delta
)
;
}
}
else
if
(
offset
.
x
>
=
1
)
{
startEntry
=
1
.
0f
+
size
;
minIndex
=
int
(
startEntry
)
;
maxIndex
=
minIndex
;
if
(
delta
<
0
)
{
chunks
=
min
(
chunks
(
1
-
offset
.
x
)
/
delta
)
;
}
}
else
{
startEntry
=
1
.
0f
+
offset
.
x
*
size
;
if
(
delta
<
0
)
{
chunks
=
min
(
chunks
-
offset
.
x
/
delta
)
;
}
else
if
(
delta
>
0
)
{
chunks
=
min
(
chunks
(
1
-
offset
.
x
)
/
delta
)
;
}
float
endEntry
=
clamp
(
1
.
0f
+
(
offset
.
x
+
delta
*
int
(
chunks
)
)
*
size
0
.
0f
1
.
0f
+
size
)
;
minIndex
=
int
(
startEntry
)
;
maxIndex
=
minIndex
;
if
(
delta
>
0
)
{
while
(
maxIndex
+
1
<
endEntry
&
&
stops
[
maxIndex
]
.
can_merge
(
stops
[
maxIndex
+
1
]
)
)
{
maxIndex
+
+
;
}
chunks
=
min
(
chunks
(
maxIndex
+
1
-
startEntry
)
/
(
delta
*
size
)
)
;
}
else
if
(
delta
<
0
)
{
while
(
minIndex
-
1
>
endEntry
&
&
stops
[
minIndex
-
1
]
.
can_merge
(
stops
[
minIndex
]
)
)
{
minIndex
-
-
;
}
chunks
=
min
(
chunks
(
minIndex
-
startEntry
)
/
(
delta
*
size
)
)
;
}
}
int
inside
=
int
(
chunks
)
;
if
(
inside
>
0
)
{
auto
minColorF
=
stops
[
minIndex
]
.
startColor
.
zyxw
*
float
(
0xFF00
)
;
auto
maxColorF
=
stops
[
maxIndex
]
.
end_color
(
)
.
zyxw
*
float
(
0xFF00
)
;
auto
colorRangeF
=
(
maxColorF
-
minColorF
)
*
(
1
.
0f
/
(
maxIndex
+
1
-
minIndex
)
)
;
auto
colorF
=
minColorF
+
colorRangeF
*
(
startEntry
-
minIndex
)
+
float
(
0x80
)
;
Float
deltaColorF
=
colorRangeF
*
(
delta
*
size
)
;
auto
deltaColor
=
repeat4
(
CONVERT
(
round_pixel
(
deltaColorF
1
)
U16
)
)
;
auto
color
=
combine
(
CONVERT
(
round_pixel
(
colorF
1
)
U16
)
CONVERT
(
round_pixel
(
colorF
+
deltaColorF
*
0
.
25f
1
)
U16
)
CONVERT
(
round_pixel
(
colorF
+
deltaColorF
*
0
.
5f
1
)
U16
)
CONVERT
(
round_pixel
(
colorF
+
deltaColorF
*
0
.
75f
1
)
U16
)
)
;
for
(
auto
*
end
=
buf
+
inside
*
4
;
buf
<
end
;
buf
+
=
4
)
{
commit_blend_span
<
BLEND
>
(
buf
bit_cast
<
WideRGBA8
>
(
color
>
>
8
)
)
;
color
+
=
deltaColor
;
}
span
-
=
inside
*
4
;
if
(
span
<
=
0
)
{
break
;
}
offset
+
=
inside
*
delta
;
if
(
repeat
)
{
offset
=
fract
(
offset
)
;
}
}
Float
entry
=
clamp
(
offset
*
size
+
1
.
0f
0
.
0f
1
.
0f
+
size
)
;
commit_blend_span
<
BLEND
>
(
buf
sampleGradient
(
sampler
address
entry
)
)
;
span
-
=
4
;
buf
+
=
4
;
offset
+
=
delta
;
}
}
#
define
swgl_commitLinearGradientRGBA8
(
sampler
address
size
repeat
offset
)
\
do
{
\
if
(
blend_key
)
{
\
commitLinearGradient
<
true
>
(
sampler
address
size
repeat
offset
\
swgl_OutRGBA8
swgl_SpanLength
)
;
\
}
else
{
\
commitLinearGradient
<
false
>
(
sampler
address
size
repeat
offset
\
swgl_OutRGBA8
swgl_SpanLength
)
;
\
}
\
swgl_OutRGBA8
+
=
swgl_SpanLength
;
\
swgl_SpanLength
=
0
;
\
}
while
(
0
)
static
sampler2D
swgl_ClipMask
=
nullptr
;
static
IntPoint
swgl_ClipMaskOffset
=
{
0
0
}
;
static
IntRect
swgl_ClipMaskBounds
=
{
0
0
0
0
}
;
#
define
swgl_clipMask
(
mask
offset
bb_origin
bb_size
)
\
do
{
\
if
(
bb_size
!
=
vec2_scalar
(
0
.
0f
0
.
0f
)
)
{
\
swgl_ClipFlags
|
=
SWGL_CLIP_FLAG_MASK
;
\
swgl_ClipMask
=
mask
;
\
swgl_ClipMaskOffset
=
make_ivec2
(
offset
)
;
\
swgl_ClipMaskBounds
=
\
IntRect
(
make_ivec2
(
bb_origin
)
make_ivec2
(
bb_size
)
)
;
\
}
\
}
while
(
0
)
static
int
swgl_AAEdgeMask
=
0
;
static
ALWAYS_INLINE
int
calcAAEdgeMask
(
bool
on
)
{
return
on
?
0xF
:
0
;
}
static
ALWAYS_INLINE
int
calcAAEdgeMask
(
int
mask
)
{
return
mask
;
}
static
ALWAYS_INLINE
int
calcAAEdgeMask
(
bvec4_scalar
mask
)
{
return
(
mask
.
x
?
1
:
0
)
|
(
mask
.
y
?
2
:
0
)
|
(
mask
.
z
?
4
:
0
)
|
(
mask
.
w
?
8
:
0
)
;
}
#
define
swgl_antiAlias
(
edges
)
\
do
{
\
swgl_AAEdgeMask
=
calcAAEdgeMask
(
edges
)
;
\
if
(
swgl_AAEdgeMask
)
{
\
swgl_ClipFlags
|
=
SWGL_CLIP_FLAG_AA
;
\
}
\
}
while
(
0
)
#
define
DISPATCH_DRAW_SPAN
(
self
format
)
\
do
{
\
int
total
=
self
-
>
swgl_SpanLength
;
\
self
-
>
swgl_drawSpan
#
#
format
(
)
;
\
int
drawn
=
total
-
self
-
>
swgl_SpanLength
;
\
if
(
drawn
)
self
-
>
step_interp_inputs
(
drawn
)
;
\
return
drawn
;
\
}
while
(
0
)
