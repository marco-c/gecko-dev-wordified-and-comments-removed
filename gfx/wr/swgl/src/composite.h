template
<
typename
P
>
static
inline
void
scale_row
(
P
*
dst
int
dstWidth
const
P
*
src
int
srcWidth
int
span
)
{
int
frac
=
0
;
for
(
P
*
end
=
dst
+
span
;
dst
<
end
;
dst
+
+
)
{
*
dst
=
*
src
;
for
(
frac
+
=
srcWidth
;
frac
>
=
dstWidth
;
frac
-
=
dstWidth
)
{
src
+
+
;
}
}
}
static
void
scale_blit
(
Texture
&
srctex
const
IntRect
&
srcReq
int
srcZ
Texture
&
dsttex
const
IntRect
&
dstReq
int
dstZ
bool
invertY
int
bandOffset
int
bandHeight
)
{
int
srcWidth
=
srcReq
.
width
(
)
;
int
srcHeight
=
srcReq
.
height
(
)
;
int
dstWidth
=
dstReq
.
width
(
)
;
int
dstHeight
=
dstReq
.
height
(
)
;
IntRect
dstBounds
=
dsttex
.
sample_bounds
(
dstReq
invertY
)
;
IntRect
srcBounds
=
srctex
.
sample_bounds
(
srcReq
)
.
scale
(
srcWidth
srcHeight
dstWidth
dstHeight
true
)
;
dstBounds
.
intersect
(
srcBounds
)
;
if
(
dstBounds
.
is_empty
(
)
)
{
return
;
}
srcBounds
=
IntRect
(
dstBounds
)
.
scale
(
dstWidth
dstHeight
srcWidth
srcHeight
)
;
int
bpp
=
srctex
.
bpp
(
)
;
int
srcStride
=
srctex
.
stride
(
)
;
int
destStride
=
dsttex
.
stride
(
)
;
char
*
dest
=
dsttex
.
sample_ptr
(
dstReq
dstBounds
dstZ
invertY
)
;
char
*
src
=
srctex
.
sample_ptr
(
srcReq
srcBounds
srcZ
)
;
if
(
invertY
)
{
destStride
=
-
destStride
;
}
int
span
=
dstBounds
.
width
(
)
;
int
frac
=
srcHeight
*
bandOffset
;
dest
+
=
destStride
*
bandOffset
;
src
+
=
srcStride
*
(
frac
/
dstHeight
)
;
frac
%
=
dstHeight
;
for
(
int
rows
=
min
(
dstBounds
.
height
(
)
bandHeight
)
;
rows
>
0
;
rows
-
-
)
{
if
(
srcWidth
=
=
dstWidth
)
{
memcpy
(
dest
src
span
*
bpp
)
;
}
else
{
switch
(
bpp
)
{
case
1
:
scale_row
(
(
uint8_t
*
)
dest
dstWidth
(
uint8_t
*
)
src
srcWidth
span
)
;
break
;
case
2
:
scale_row
(
(
uint16_t
*
)
dest
dstWidth
(
uint16_t
*
)
src
srcWidth
span
)
;
break
;
case
4
:
scale_row
(
(
uint32_t
*
)
dest
dstWidth
(
uint32_t
*
)
src
srcWidth
span
)
;
break
;
default
:
assert
(
false
)
;
break
;
}
}
dest
+
=
destStride
;
for
(
frac
+
=
srcHeight
;
frac
>
=
dstHeight
;
frac
-
=
dstHeight
)
{
src
+
=
srcStride
;
}
}
}
static
void
linear_row_blit
(
uint32_t
*
dest
int
span
const
vec2_scalar
&
srcUV
float
srcDU
int
srcZOffset
sampler2DArray
sampler
)
{
vec2
uv
=
init_interp
(
srcUV
vec2_scalar
(
srcDU
0
.
0f
)
)
;
for
(
;
span
>
=
4
;
span
-
=
4
)
{
auto
srcpx
=
textureLinearPackedRGBA8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
unaligned_store
(
dest
srcpx
)
;
dest
+
=
4
;
uv
.
x
+
=
4
*
srcDU
;
}
if
(
span
>
0
)
{
auto
srcpx
=
textureLinearPackedRGBA8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
auto
mask
=
span_mask_RGBA8
(
span
)
;
auto
dstpx
=
unaligned_load
<
PackedRGBA8
>
(
dest
)
;
unaligned_store
(
dest
(
mask
&
dstpx
)
|
(
~
mask
&
srcpx
)
)
;
}
}
static
void
linear_row_blit
(
uint8_t
*
dest
int
span
const
vec2_scalar
&
srcUV
float
srcDU
int
srcZOffset
sampler2DArray
sampler
)
{
vec2
uv
=
init_interp
(
srcUV
vec2_scalar
(
srcDU
0
.
0f
)
)
;
for
(
;
span
>
=
4
;
span
-
=
4
)
{
auto
srcpx
=
textureLinearPackedR8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
unaligned_store
(
dest
pack
(
srcpx
)
)
;
dest
+
=
4
;
uv
.
x
+
=
4
*
srcDU
;
}
if
(
span
>
0
)
{
auto
srcpx
=
textureLinearPackedR8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
auto
mask
=
span_mask_R8
(
span
)
;
auto
dstpx
=
unpack
(
unaligned_load
<
PackedR8
>
(
dest
)
)
;
unaligned_store
(
dest
pack
(
(
mask
&
dstpx
)
|
(
~
mask
&
srcpx
)
)
)
;
}
}
static
void
linear_row_blit
(
uint16_t
*
dest
int
span
const
vec2_scalar
&
srcUV
float
srcDU
int
srcZOffset
sampler2DArray
sampler
)
{
vec2
uv
=
init_interp
(
srcUV
vec2_scalar
(
srcDU
0
.
0f
)
)
;
for
(
;
span
>
=
4
;
span
-
=
4
)
{
auto
srcpx
=
textureLinearPackedRG8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
unaligned_store
(
dest
srcpx
)
;
dest
+
=
4
;
uv
.
x
+
=
4
*
srcDU
;
}
if
(
span
>
0
)
{
auto
srcpx
=
textureLinearPackedRG8
(
sampler
ivec2
(
uv
)
srcZOffset
)
;
auto
mask
=
span_mask_RG8
(
span
)
;
auto
dstpx
=
unaligned_load
<
PackedRG8
>
(
dest
)
;
unaligned_store
(
dest
(
mask
&
dstpx
)
|
(
~
mask
&
srcpx
)
)
;
}
}
static
void
linear_blit
(
Texture
&
srctex
const
IntRect
&
srcReq
int
srcZ
Texture
&
dsttex
const
IntRect
&
dstReq
int
dstZ
bool
invertY
int
bandOffset
int
bandHeight
)
{
assert
(
srctex
.
internal_format
=
=
GL_RGBA8
|
|
srctex
.
internal_format
=
=
GL_R8
|
|
srctex
.
internal_format
=
=
GL_RG8
)
;
IntRect
dstBounds
=
dsttex
.
sample_bounds
(
dstReq
invertY
)
;
if
(
dstBounds
.
is_empty
(
)
)
{
return
;
}
sampler2DArray_impl
sampler
;
init_sampler
(
&
sampler
srctex
)
;
init_depth
(
&
sampler
srctex
)
;
sampler
.
filter
=
TextureFilter
:
:
LINEAR
;
int
srcZOffset
=
srcZ
*
sampler
.
height_stride
;
vec2_scalar
srcUV
(
srcReq
.
x0
srcReq
.
y0
)
;
vec2_scalar
srcDUV
(
float
(
srcReq
.
width
(
)
)
/
dstReq
.
width
(
)
float
(
srcReq
.
height
(
)
)
/
dstReq
.
height
(
)
)
;
srcUV
+
=
srcDUV
*
(
vec2_scalar
(
dstBounds
.
x0
dstBounds
.
y0
)
+
0
.
5f
)
;
srcUV
=
linearQuantize
(
srcUV
128
)
;
srcDUV
*
=
128
.
0f
;
int
bpp
=
dsttex
.
bpp
(
)
;
int
destStride
=
dsttex
.
stride
(
)
;
char
*
dest
=
dsttex
.
sample_ptr
(
dstReq
dstBounds
dstZ
invertY
)
;
if
(
invertY
)
{
destStride
=
-
destStride
;
}
dest
+
=
destStride
*
bandOffset
;
srcUV
.
y
+
=
srcDUV
.
y
*
bandOffset
;
int
span
=
dstBounds
.
width
(
)
;
for
(
int
rows
=
min
(
dstBounds
.
height
(
)
bandHeight
)
;
rows
>
0
;
rows
-
-
)
{
switch
(
bpp
)
{
case
1
:
linear_row_blit
(
(
uint8_t
*
)
dest
span
srcUV
srcDUV
.
x
srcZOffset
&
sampler
)
;
break
;
case
2
:
linear_row_blit
(
(
uint16_t
*
)
dest
span
srcUV
srcDUV
.
x
srcZOffset
&
sampler
)
;
break
;
case
4
:
linear_row_blit
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
srcZOffset
&
sampler
)
;
break
;
default
:
assert
(
false
)
;
break
;
}
dest
+
=
destStride
;
srcUV
.
y
+
=
srcDUV
.
y
;
}
}
static
void
linear_row_composite
(
uint32_t
*
dest
int
span
const
vec2_scalar
&
srcUV
float
srcDU
sampler2D
sampler
)
{
vec2
uv
=
init_interp
(
srcUV
vec2_scalar
(
srcDU
0
.
0f
)
)
;
for
(
;
span
>
=
4
;
span
-
=
4
)
{
WideRGBA8
srcpx
=
textureLinearUnpackedRGBA8
(
sampler
ivec2
(
uv
)
0
)
;
WideRGBA8
dstpx
=
unpack
(
unaligned_load
<
PackedRGBA8
>
(
dest
)
)
;
PackedRGBA8
r
=
pack
(
srcpx
+
dstpx
-
muldiv255
(
dstpx
alphas
(
srcpx
)
)
)
;
unaligned_store
(
dest
r
)
;
dest
+
=
4
;
uv
.
x
+
=
4
*
srcDU
;
}
if
(
span
>
0
)
{
WideRGBA8
srcpx
=
textureLinearUnpackedRGBA8
(
sampler
ivec2
(
uv
)
0
)
;
PackedRGBA8
dstpx
=
unaligned_load
<
PackedRGBA8
>
(
dest
)
;
WideRGBA8
dstpxu
=
unpack
(
dstpx
)
;
PackedRGBA8
r
=
pack
(
srcpx
+
dstpxu
-
muldiv255
(
dstpxu
alphas
(
srcpx
)
)
)
;
auto
mask
=
span_mask_RGBA8
(
span
)
;
unaligned_store
(
dest
(
mask
&
dstpx
)
|
(
~
mask
&
r
)
)
;
}
}
static
void
linear_composite
(
Texture
&
srctex
const
IntRect
&
srcReq
Texture
&
dsttex
const
IntRect
&
dstReq
bool
invertY
int
bandOffset
int
bandHeight
)
{
assert
(
srctex
.
bpp
(
)
=
=
4
)
;
assert
(
dsttex
.
bpp
(
)
=
=
4
)
;
IntRect
dstBounds
=
dsttex
.
sample_bounds
(
dstReq
invertY
)
;
if
(
dstBounds
.
is_empty
(
)
)
{
return
;
}
sampler2D_impl
sampler
;
init_sampler
(
&
sampler
srctex
)
;
sampler
.
filter
=
TextureFilter
:
:
LINEAR
;
vec2_scalar
srcUV
(
srcReq
.
x0
srcReq
.
y0
)
;
vec2_scalar
srcDUV
(
float
(
srcReq
.
width
(
)
)
/
dstReq
.
width
(
)
float
(
srcReq
.
height
(
)
)
/
dstReq
.
height
(
)
)
;
srcUV
+
=
srcDUV
*
(
vec2_scalar
(
dstBounds
.
x0
dstBounds
.
y0
)
+
0
.
5f
)
;
srcUV
=
linearQuantize
(
srcUV
128
)
;
srcDUV
*
=
128
.
0f
;
int
destStride
=
dsttex
.
stride
(
)
;
char
*
dest
=
dsttex
.
sample_ptr
(
dstReq
dstBounds
0
invertY
)
;
if
(
invertY
)
{
destStride
=
-
destStride
;
}
dest
+
=
destStride
*
bandOffset
;
srcUV
.
y
+
=
srcDUV
.
y
*
bandOffset
;
int
span
=
dstBounds
.
width
(
)
;
for
(
int
rows
=
min
(
dstBounds
.
height
(
)
bandHeight
)
;
rows
>
0
;
rows
-
-
)
{
linear_row_composite
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
&
sampler
)
;
dest
+
=
destStride
;
srcUV
.
y
+
=
srcDUV
.
y
;
}
}
extern
"
C
"
{
void
BlitFramebuffer
(
GLint
srcX0
GLint
srcY0
GLint
srcX1
GLint
srcY1
GLint
dstX0
GLint
dstY0
GLint
dstX1
GLint
dstY1
GLbitfield
mask
GLenum
filter
)
{
assert
(
mask
=
=
GL_COLOR_BUFFER_BIT
)
;
Framebuffer
*
srcfb
=
get_framebuffer
(
GL_READ_FRAMEBUFFER
)
;
if
(
!
srcfb
|
|
srcfb
-
>
layer
<
0
)
return
;
Framebuffer
*
dstfb
=
get_framebuffer
(
GL_DRAW_FRAMEBUFFER
)
;
if
(
!
dstfb
|
|
dstfb
-
>
layer
<
0
)
return
;
Texture
&
srctex
=
ctx
-
>
textures
[
srcfb
-
>
color_attachment
]
;
if
(
!
srctex
.
buf
|
|
srcfb
-
>
layer
>
=
max
(
srctex
.
depth
1
)
)
return
;
Texture
&
dsttex
=
ctx
-
>
textures
[
dstfb
-
>
color_attachment
]
;
if
(
!
dsttex
.
buf
|
|
dstfb
-
>
layer
>
=
max
(
dsttex
.
depth
1
)
)
return
;
assert
(
!
dsttex
.
locked
)
;
if
(
srctex
.
internal_format
!
=
dsttex
.
internal_format
)
{
assert
(
false
)
;
return
;
}
if
(
srcY1
<
srcY0
)
{
swap
(
srcY0
srcY1
)
;
swap
(
dstY0
dstY1
)
;
}
bool
invertY
=
dstY1
<
dstY0
;
if
(
invertY
)
{
swap
(
dstY0
dstY1
)
;
}
IntRect
srcReq
=
{
srcX0
srcY0
srcX1
srcY1
}
;
IntRect
dstReq
=
{
dstX0
dstY0
dstX1
dstY1
}
;
if
(
srcReq
.
is_empty
(
)
|
|
dstReq
.
is_empty
(
)
)
{
return
;
}
prepare_texture
(
srctex
)
;
prepare_texture
(
dsttex
&
dstReq
)
;
if
(
!
srcReq
.
same_size
(
dstReq
)
&
&
filter
=
=
GL_LINEAR
&
&
(
srctex
.
internal_format
=
=
GL_RGBA8
|
|
srctex
.
internal_format
=
=
GL_R8
|
|
srctex
.
internal_format
=
=
GL_RG8
)
)
{
linear_blit
(
srctex
srcReq
srcfb
-
>
layer
dsttex
dstReq
dstfb
-
>
layer
invertY
0
dstReq
.
height
(
)
)
;
}
else
{
scale_blit
(
srctex
srcReq
srcfb
-
>
layer
dsttex
dstReq
dstfb
-
>
layer
invertY
0
dstReq
.
height
(
)
)
;
}
}
typedef
Texture
LockedTexture
;
LockedTexture
*
LockTexture
(
GLuint
texId
)
{
Texture
&
tex
=
ctx
-
>
textures
[
texId
]
;
if
(
!
tex
.
buf
)
{
return
nullptr
;
}
if
(
__sync_fetch_and_add
(
&
tex
.
locked
1
)
=
=
0
)
{
prepare_texture
(
tex
)
;
}
return
(
LockedTexture
*
)
&
tex
;
}
LockedTexture
*
LockFramebuffer
(
GLuint
fboId
)
{
Framebuffer
&
fb
=
ctx
-
>
framebuffers
[
fboId
]
;
if
(
!
fb
.
color_attachment
|
|
fb
.
layer
>
0
)
{
return
nullptr
;
}
return
LockTexture
(
fb
.
color_attachment
)
;
}
void
LockResource
(
LockedTexture
*
resource
)
{
if
(
!
resource
)
{
return
;
}
__sync_fetch_and_add
(
&
resource
-
>
locked
1
)
;
}
void
UnlockResource
(
LockedTexture
*
resource
)
{
if
(
!
resource
)
{
return
;
}
if
(
__sync_fetch_and_add
(
&
resource
-
>
locked
-
1
)
<
=
0
)
{
assert
(
0
)
;
}
}
void
*
GetResourceBuffer
(
LockedTexture
*
resource
int32_t
*
width
int32_t
*
height
int32_t
*
stride
)
{
*
width
=
resource
-
>
width
;
*
height
=
resource
-
>
height
;
*
stride
=
resource
-
>
stride
(
)
;
return
resource
-
>
buf
;
}
void
Composite
(
LockedTexture
*
lockedDst
LockedTexture
*
lockedSrc
GLint
srcX
GLint
srcY
GLsizei
srcWidth
GLsizei
srcHeight
GLint
dstX
GLint
dstY
GLsizei
dstWidth
GLsizei
dstHeight
GLboolean
opaque
GLboolean
flip
GLenum
filter
GLint
bandOffset
GLsizei
bandHeight
)
{
if
(
!
lockedDst
|
|
!
lockedSrc
)
{
return
;
}
Texture
&
srctex
=
*
lockedSrc
;
Texture
&
dsttex
=
*
lockedDst
;
assert
(
srctex
.
bpp
(
)
=
=
4
)
;
assert
(
dsttex
.
bpp
(
)
=
=
4
)
;
IntRect
srcReq
=
{
srcX
srcY
srcX
+
srcWidth
srcY
+
srcHeight
}
;
IntRect
dstReq
=
{
dstX
dstY
dstX
+
dstWidth
dstY
+
dstHeight
}
;
if
(
opaque
)
{
if
(
!
srcReq
.
same_size
(
dstReq
)
&
&
filter
=
=
GL_LINEAR
)
{
linear_blit
(
srctex
srcReq
0
dsttex
dstReq
0
flip
bandOffset
bandHeight
)
;
}
else
{
scale_blit
(
srctex
srcReq
0
dsttex
dstReq
0
flip
bandOffset
bandHeight
)
;
}
}
else
{
if
(
!
srcReq
.
same_size
(
dstReq
)
|
|
filter
=
=
GL_LINEAR
)
{
linear_composite
(
srctex
srcReq
dsttex
dstReq
flip
bandOffset
bandHeight
)
;
}
else
{
const
int
bpp
=
4
;
IntRect
bounds
=
dsttex
.
sample_bounds
(
dstReq
flip
)
;
bounds
.
intersect
(
srctex
.
sample_bounds
(
srcReq
)
)
;
char
*
dest
=
dsttex
.
sample_ptr
(
dstReq
bounds
0
flip
)
;
char
*
src
=
srctex
.
sample_ptr
(
srcReq
bounds
0
)
;
int
srcStride
=
srctex
.
stride
(
)
;
int
destStride
=
dsttex
.
stride
(
)
;
if
(
flip
)
{
destStride
=
-
destStride
;
}
dest
+
=
destStride
*
bandOffset
;
src
+
=
srcStride
*
bandOffset
;
for
(
int
rows
=
min
(
bounds
.
height
(
)
bandHeight
)
;
rows
>
0
;
rows
-
-
)
{
char
*
end
=
src
+
bounds
.
width
(
)
*
bpp
;
while
(
src
+
4
*
bpp
<
=
end
)
{
WideRGBA8
srcpx
=
unpack
(
unaligned_load
<
PackedRGBA8
>
(
src
)
)
;
WideRGBA8
dstpx
=
unpack
(
unaligned_load
<
PackedRGBA8
>
(
dest
)
)
;
PackedRGBA8
r
=
pack
(
srcpx
+
dstpx
-
muldiv255
(
dstpx
alphas
(
srcpx
)
)
)
;
unaligned_store
(
dest
r
)
;
src
+
=
4
*
bpp
;
dest
+
=
4
*
bpp
;
}
if
(
src
<
end
)
{
WideRGBA8
srcpx
=
unpack
(
unaligned_load
<
PackedRGBA8
>
(
src
)
)
;
WideRGBA8
dstpx
=
unpack
(
unaligned_load
<
PackedRGBA8
>
(
dest
)
)
;
U32
r
=
bit_cast
<
U32
>
(
pack
(
srcpx
+
dstpx
-
muldiv255
(
dstpx
alphas
(
srcpx
)
)
)
)
;
unaligned_store
(
dest
r
.
x
)
;
if
(
src
+
bpp
<
end
)
{
unaligned_store
(
dest
+
bpp
r
.
y
)
;
if
(
src
+
2
*
bpp
<
end
)
{
unaligned_store
(
dest
+
2
*
bpp
r
.
z
)
;
}
}
dest
+
=
end
-
src
;
src
=
end
;
}
dest
+
=
destStride
-
bounds
.
width
(
)
*
bpp
;
src
+
=
srcStride
-
bounds
.
width
(
)
*
bpp
;
}
}
}
}
}
static
inline
V8
<
int16_t
>
addsat
(
V8
<
int16_t
>
x
V8
<
int16_t
>
y
)
{
#
if
USE_SSE2
return
_mm_adds_epi16
(
x
y
)
;
#
elif
USE_NEON
return
vqaddq_s16
(
x
y
)
;
#
else
auto
r
=
x
+
y
;
auto
overflow
=
(
~
(
x
^
y
)
&
(
r
^
x
)
)
>
>
15
;
auto
limit
=
(
x
>
>
15
)
^
0x7FFF
;
return
(
~
overflow
&
r
)
|
(
overflow
&
limit
)
;
#
endif
}
static
inline
PackedRGBA8
packYUV
(
V8
<
int16_t
>
gg
V8
<
int16_t
>
br
)
{
return
pack
(
bit_cast
<
WideRGBA8
>
(
zip
(
br
gg
)
)
)
|
PackedRGBA8
{
0
0
0
255
0
0
0
255
0
0
0
255
0
0
0
255
}
;
}
enum
YUVColorSpace
{
REC_601
=
0
REC_709
REC_2020
IDENTITY
}
;
template
<
const
double
MATRIX
[
4
]
>
struct
YUVConverterImpl
{
static
inline
PackedRGBA8
convert
(
V8
<
int16_t
>
yy
V8
<
int16_t
>
uv
)
{
constexpr
int16_t
mrv
=
int16_t
(
MATRIX
[
0
]
*
64
.
0
+
0
.
5
)
;
constexpr
int16_t
mgu
=
-
int16_t
(
MATRIX
[
1
]
*
-
64
.
0
+
0
.
5
)
;
constexpr
int16_t
mgv
=
-
int16_t
(
MATRIX
[
2
]
*
-
64
.
0
+
0
.
5
)
;
constexpr
int16_t
mbu
=
int16_t
(
MATRIX
[
3
]
*
64
.
0
+
0
.
5
)
;
yy
=
yy
*
74
+
(
yy
>
>
1
)
+
(
int16_t
(
-
16
*
74
.
5
)
+
(
1
<
<
5
)
)
;
uv
-
=
128
;
auto
br
=
V8
<
int16_t
>
{
mbu
mrv
mbu
mrv
mbu
mrv
mbu
mrv
}
*
uv
;
br
=
addsat
(
yy
br
)
;
br
>
>
=
6
;
auto
gg
=
V8
<
int16_t
>
{
mgu
mgv
mgu
mgv
mgu
mgv
mgu
mgv
}
*
uv
;
gg
=
addsat
(
yy
addsat
(
gg
bit_cast
<
V8
<
int16_t
>
>
(
bit_cast
<
V4
<
uint32_t
>
>
(
gg
)
>
>
16
)
)
)
;
gg
>
>
=
6
;
return
packYUV
(
gg
br
)
;
}
}
;
template
<
YUVColorSpace
COLOR_SPACE
>
struct
YUVConverter
{
}
;
static
constexpr
double
YUVMatrix601
[
4
]
=
{
1
.
5960267857142858
-
0
.
3917622900949137
-
0
.
8129676472377708
2
.
017232142857143
}
;
template
<
>
struct
YUVConverter
<
REC_601
>
:
YUVConverterImpl
<
YUVMatrix601
>
{
}
;
static
constexpr
double
YUVMatrix709
[
4
]
=
{
1
.
7927410714285714
-
0
.
21324861427372963
-
0
.
532909328559444
2
.
1124017857142854
}
;
template
<
>
struct
YUVConverter
<
REC_709
>
:
YUVConverterImpl
<
YUVMatrix709
>
{
}
;
static
constexpr
double
YUVMatrix2020
[
4
]
=
{
1
.
678674107142860
-
0
.
187326104219343
-
0
.
650424318505057
2
.
14177232142857
}
;
template
<
>
struct
YUVConverter
<
REC_2020
>
:
YUVConverterImpl
<
YUVMatrix2020
>
{
}
;
template
<
>
struct
YUVConverter
<
IDENTITY
>
{
static
inline
PackedRGBA8
convert
(
V8
<
int16_t
>
y
V8
<
int16_t
>
uv
)
{
return
packYUV
(
y
uv
)
;
}
}
;
template
<
typename
S
>
static
ALWAYS_INLINE
V8
<
int16_t
>
linearRowTapsR8
(
S
sampler
I32
ix
int32_t
offsety
int32_t
stridey
int16_t
fracy
)
{
uint8_t
*
buf
=
(
uint8_t
*
)
sampler
-
>
buf
+
offsety
;
auto
a0
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
x
]
)
;
auto
b0
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
y
]
)
;
auto
c0
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
z
]
)
;
auto
d0
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
w
]
)
;
auto
abcd0
=
CONVERT
(
combine
(
combine
(
a0
b0
)
combine
(
c0
d0
)
)
V8
<
int16_t
>
)
;
buf
+
=
stridey
;
auto
a1
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
x
]
)
;
auto
b1
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
y
]
)
;
auto
c1
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
z
]
)
;
auto
d1
=
unaligned_load
<
V2
<
uint8_t
>
>
(
&
buf
[
ix
.
w
]
)
;
auto
abcd1
=
CONVERT
(
combine
(
combine
(
a1
b1
)
combine
(
c1
d1
)
)
V8
<
int16_t
>
)
;
abcd0
+
=
(
(
abcd1
-
abcd0
)
*
fracy
)
>
>
7
;
return
abcd0
;
}
template
<
typename
S
>
static
inline
V8
<
int16_t
>
textureLinearRowR8
(
S
sampler
I32
ix
int32_t
offsety
int32_t
stridey
int16_t
fracy
)
{
assert
(
sampler
-
>
format
=
=
TextureFormat
:
:
R8
)
;
I32
fracx
=
ix
&
(
I32
)
0x7F
;
ix
>
>
=
7
;
fracx
&
=
(
ix
>
=
0
&
&
ix
<
int32_t
(
sampler
-
>
width
)
-
1
)
;
ix
=
clampCoord
(
ix
sampler
-
>
width
)
;
auto
abcd
=
linearRowTapsR8
(
sampler
ix
offsety
stridey
fracy
)
;
auto
abcdl
=
SHUFFLE
(
abcd
abcd
0
0
2
2
4
4
6
6
)
;
auto
abcdh
=
SHUFFLE
(
abcd
abcd
1
1
3
3
5
5
7
7
)
;
abcdl
+
=
(
(
abcdh
-
abcdl
)
*
CONVERT
(
fracx
I16
)
.
xxyyzzww
)
>
>
7
;
return
abcdl
;
}
template
<
typename
S
>
static
inline
V8
<
int16_t
>
textureLinearRowPairedR8
(
S
sampler
S
sampler2
I32
ix
int32_t
offsety
int32_t
stridey
int16_t
fracy
)
{
assert
(
sampler
-
>
format
=
=
TextureFormat
:
:
R8
&
&
sampler2
-
>
format
=
=
TextureFormat
:
:
R8
)
;
assert
(
sampler
-
>
width
=
=
sampler2
-
>
width
&
&
sampler
-
>
height
=
=
sampler2
-
>
height
)
;
assert
(
sampler
-
>
stride
=
=
sampler2
-
>
stride
)
;
I32
fracx
=
ix
&
(
I32
)
0x7F
;
ix
>
>
=
7
;
fracx
&
=
(
ix
>
=
0
&
&
ix
<
int32_t
(
sampler
-
>
width
)
-
1
)
;
ix
=
clampCoord
(
ix
sampler
-
>
width
)
;
auto
abcd
=
linearRowTapsR8
(
sampler
ix
offsety
stridey
fracy
)
;
auto
xyzw
=
linearRowTapsR8
(
sampler2
ix
offsety
stridey
fracy
)
;
auto
abcdxyzwl
=
SHUFFLE
(
abcd
xyzw
0
8
2
10
4
12
6
14
)
;
auto
abcdxyzwh
=
SHUFFLE
(
abcd
xyzw
1
9
3
11
5
13
7
15
)
;
abcdxyzwl
+
=
(
(
abcdxyzwh
-
abcdxyzwl
)
*
CONVERT
(
fracx
I16
)
.
xxyyzzww
)
>
>
7
;
return
abcdxyzwl
;
}
template
<
YUVColorSpace
COLOR_SPACE
>
static
void
linear_row_yuv
(
uint32_t
*
dest
int
span
const
vec2_scalar
&
srcUV
float
srcDU
const
vec2_scalar
&
chromaUV
float
chromaDU
sampler2D_impl
sampler
[
3
]
)
{
I32
yU
=
cast
(
init_interp
(
srcUV
.
x
srcDU
)
)
;
int32_t
yV
=
int32_t
(
srcUV
.
y
)
;
int16_t
yFracV
=
yV
&
0x7F
;
yV
>
>
=
7
;
int32_t
yOffsetV
=
clampCoord
(
yV
sampler
[
0
]
.
height
)
*
sampler
[
0
]
.
stride
;
int32_t
yStrideV
=
yV
>
=
0
&
&
yV
<
int32_t
(
sampler
[
0
]
.
height
)
-
1
?
sampler
[
0
]
.
stride
:
0
;
I32
cU
=
cast
(
init_interp
(
chromaUV
.
x
chromaDU
)
)
;
int32_t
cV
=
int32_t
(
chromaUV
.
y
)
;
int16_t
cFracV
=
cV
&
0x7F
;
cV
>
>
=
7
;
int32_t
cOffsetV
=
clampCoord
(
cV
sampler
[
1
]
.
height
)
*
sampler
[
1
]
.
stride
;
int32_t
cStrideV
=
cV
>
=
0
&
&
cV
<
int32_t
(
sampler
[
1
]
.
height
)
-
1
?
sampler
[
1
]
.
stride
:
0
;
int32_t
yDU
=
int32_t
(
4
*
srcDU
)
;
int32_t
cDU
=
int32_t
(
4
*
chromaDU
)
;
for
(
;
span
>
=
4
;
span
-
=
4
)
{
auto
yPx
=
textureLinearRowR8
(
&
sampler
[
0
]
yU
yOffsetV
yStrideV
yFracV
)
;
auto
uvPx
=
textureLinearRowPairedR8
(
&
sampler
[
1
]
&
sampler
[
2
]
cU
cOffsetV
cStrideV
cFracV
)
;
unaligned_store
(
dest
YUVConverter
<
COLOR_SPACE
>
:
:
convert
(
yPx
uvPx
)
)
;
dest
+
=
4
;
yU
+
=
yDU
;
cU
+
=
cDU
;
}
if
(
span
>
0
)
{
auto
yPx
=
textureLinearRowR8
(
&
sampler
[
0
]
yU
yOffsetV
yStrideV
yFracV
)
;
auto
uvPx
=
textureLinearRowPairedR8
(
&
sampler
[
1
]
&
sampler
[
2
]
cU
cOffsetV
cStrideV
cFracV
)
;
auto
srcpx
=
YUVConverter
<
COLOR_SPACE
>
:
:
convert
(
yPx
uvPx
)
;
auto
mask
=
span_mask_RGBA8
(
span
)
;
auto
dstpx
=
unaligned_load
<
PackedRGBA8
>
(
dest
)
;
unaligned_store
(
dest
(
mask
&
dstpx
)
|
(
~
mask
&
srcpx
)
)
;
}
}
static
void
linear_convert_yuv
(
Texture
&
ytex
Texture
&
utex
Texture
&
vtex
YUVColorSpace
colorSpace
const
IntRect
&
srcReq
Texture
&
dsttex
const
IntRect
&
dstReq
bool
invertY
int
bandOffset
int
bandHeight
)
{
IntRect
dstBounds
=
dsttex
.
sample_bounds
(
dstReq
invertY
)
;
if
(
dstBounds
.
is_empty
(
)
)
{
return
;
}
sampler2D_impl
sampler
[
3
]
;
init_sampler
(
&
sampler
[
0
]
ytex
)
;
init_sampler
(
&
sampler
[
1
]
utex
)
;
init_sampler
(
&
sampler
[
2
]
vtex
)
;
vec2_scalar
srcUV
(
srcReq
.
x0
srcReq
.
y0
)
;
vec2_scalar
srcDUV
(
float
(
srcReq
.
width
(
)
)
/
dstReq
.
width
(
)
float
(
srcReq
.
height
(
)
)
/
dstReq
.
height
(
)
)
;
srcUV
+
=
srcDUV
*
(
vec2_scalar
(
dstBounds
.
x0
dstBounds
.
y0
)
+
0
.
5f
)
;
vec2_scalar
chromaScale
(
float
(
utex
.
width
)
/
ytex
.
width
float
(
utex
.
height
)
/
ytex
.
height
)
;
vec2_scalar
chromaUV
=
srcUV
*
chromaScale
;
vec2_scalar
chromaDUV
=
srcDUV
*
chromaScale
;
srcUV
=
linearQuantize
(
srcUV
128
)
;
srcDUV
*
=
128
.
0f
;
chromaUV
=
linearQuantize
(
chromaUV
128
)
;
chromaDUV
*
=
128
.
0f
;
int
destStride
=
dsttex
.
stride
(
)
;
char
*
dest
=
dsttex
.
sample_ptr
(
dstReq
dstBounds
0
invertY
)
;
if
(
invertY
)
{
destStride
=
-
destStride
;
}
dest
+
=
destStride
*
bandOffset
;
srcUV
.
y
+
=
srcDUV
.
y
*
bandOffset
;
chromaUV
.
y
+
=
chromaDUV
.
y
*
bandOffset
;
int
span
=
dstBounds
.
width
(
)
;
for
(
int
rows
=
min
(
dstBounds
.
height
(
)
bandHeight
)
;
rows
>
0
;
rows
-
-
)
{
switch
(
colorSpace
)
{
case
REC_601
:
linear_row_yuv
<
REC_601
>
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
chromaUV
chromaDUV
.
x
sampler
)
;
break
;
case
REC_709
:
linear_row_yuv
<
REC_709
>
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
chromaUV
chromaDUV
.
x
sampler
)
;
break
;
case
REC_2020
:
linear_row_yuv
<
REC_2020
>
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
chromaUV
chromaDUV
.
x
sampler
)
;
break
;
case
IDENTITY
:
linear_row_yuv
<
IDENTITY
>
(
(
uint32_t
*
)
dest
span
srcUV
srcDUV
.
x
chromaUV
chromaDUV
.
x
sampler
)
;
break
;
default
:
debugf
(
"
unknown
YUV
color
space
%
d
\
n
"
colorSpace
)
;
assert
(
false
)
;
break
;
}
dest
+
=
destStride
;
srcUV
.
y
+
=
srcDUV
.
y
;
chromaUV
.
y
+
=
chromaDUV
.
y
;
}
}
extern
"
C
"
{
void
CompositeYUV
(
LockedTexture
*
lockedDst
LockedTexture
*
lockedY
LockedTexture
*
lockedU
LockedTexture
*
lockedV
YUVColorSpace
colorSpace
GLint
srcX
GLint
srcY
GLsizei
srcWidth
GLsizei
srcHeight
GLint
dstX
GLint
dstY
GLsizei
dstWidth
GLsizei
dstHeight
GLboolean
flip
GLint
bandOffset
GLsizei
bandHeight
)
{
if
(
!
lockedDst
|
|
!
lockedY
|
|
!
lockedU
|
|
!
lockedV
)
{
return
;
}
Texture
&
ytex
=
*
lockedY
;
Texture
&
utex
=
*
lockedU
;
Texture
&
vtex
=
*
lockedV
;
Texture
&
dsttex
=
*
lockedDst
;
assert
(
ytex
.
bpp
(
)
=
=
1
&
&
utex
.
bpp
(
)
=
=
1
&
&
vtex
.
bpp
(
)
=
=
1
)
;
assert
(
utex
.
width
=
=
vtex
.
width
&
&
utex
.
height
=
=
vtex
.
height
)
;
assert
(
dsttex
.
bpp
(
)
=
=
4
)
;
IntRect
srcReq
=
{
srcX
srcY
srcX
+
srcWidth
srcY
+
srcHeight
}
;
IntRect
dstReq
=
{
dstX
dstY
dstX
+
dstWidth
dstY
+
dstHeight
}
;
linear_convert_yuv
(
ytex
utex
vtex
colorSpace
srcReq
dsttex
dstReq
flip
bandOffset
bandHeight
)
;
}
}
