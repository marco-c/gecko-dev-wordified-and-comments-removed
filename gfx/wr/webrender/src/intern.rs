use
crate
:
:
internal_types
:
:
FastHashMap
;
use
malloc_size_of
:
:
MallocSizeOf
;
use
crate
:
:
profiler
:
:
ResourceProfileCounter
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
mem
ops
u64
}
;
use
crate
:
:
util
:
:
VecHelper
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
MallocSizeOf
PartialEq
)
]
struct
Epoch
(
u32
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
UpdateList
<
S
>
{
pub
insertions
:
Vec
<
Insertion
<
S
>
>
pub
removals
:
Vec
<
Removal
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Insertion
<
S
>
{
pub
index
:
usize
pub
uid
:
ItemUid
pub
value
:
S
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Removal
{
pub
index
:
usize
pub
uid
:
ItemUid
}
impl
<
S
>
UpdateList
<
S
>
{
fn
new
(
)
-
>
UpdateList
<
S
>
{
UpdateList
{
insertions
:
Vec
:
:
new
(
)
removals
:
Vec
:
:
new
(
)
}
}
fn
take_and_preallocate
(
&
mut
self
)
-
>
UpdateList
<
S
>
{
UpdateList
{
insertions
:
self
.
insertions
.
take_and_preallocate
(
)
removals
:
self
.
removals
.
take_and_preallocate
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
ItemUid
{
uid
:
u64
}
impl
ItemUid
{
pub
fn
get_uid
(
&
self
)
-
>
u64
{
self
.
uid
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
Handle
<
I
>
{
index
:
u32
epoch
:
Epoch
_marker
:
PhantomData
<
I
>
}
impl
<
I
>
Clone
for
Handle
<
I
>
{
fn
clone
(
&
self
)
-
>
Self
{
Handle
{
index
:
self
.
index
epoch
:
self
.
epoch
_marker
:
self
.
_marker
}
}
}
impl
<
I
>
Copy
for
Handle
<
I
>
{
}
impl
<
I
>
Handle
<
I
>
{
pub
fn
uid
(
&
self
)
-
>
ItemUid
{
ItemUid
{
uid
:
(
(
self
.
index
as
u64
)
<
<
32
)
|
self
.
epoch
.
0
as
u64
}
}
}
pub
trait
InternDebug
{
fn
on_interned
(
&
self
_uid
:
ItemUid
)
{
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
DataStore
<
I
:
Internable
>
{
items
:
Vec
<
Option
<
I
:
:
StoreData
>
>
}
impl
<
I
:
Internable
>
Default
for
DataStore
<
I
>
{
fn
default
(
)
-
>
Self
{
DataStore
{
items
:
Vec
:
:
new
(
)
}
}
}
impl
<
I
:
Internable
>
DataStore
<
I
>
{
pub
fn
apply_updates
(
&
mut
self
update_list
:
UpdateList
<
I
:
:
Key
>
profile_counter
:
&
mut
ResourceProfileCounter
)
{
for
insertion
in
update_list
.
insertions
{
self
.
items
.
entry
(
insertion
.
index
)
.
set
(
Some
(
insertion
.
value
.
into
(
)
)
)
;
}
for
removal
in
update_list
.
removals
{
self
.
items
[
removal
.
index
]
=
None
;
}
let
per_item_size
=
mem
:
:
size_of
:
:
<
I
:
:
Key
>
(
)
+
mem
:
:
size_of
:
:
<
I
:
:
StoreData
>
(
)
;
profile_counter
.
set
(
self
.
items
.
len
(
)
per_item_size
*
self
.
items
.
len
(
)
)
;
}
}
impl
<
I
:
Internable
>
ops
:
:
Index
<
Handle
<
I
>
>
for
DataStore
<
I
>
{
type
Output
=
I
:
:
StoreData
;
fn
index
(
&
self
handle
:
Handle
<
I
>
)
-
>
&
I
:
:
StoreData
{
self
.
items
[
handle
.
index
as
usize
]
.
as_ref
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
impl
<
I
:
Internable
>
ops
:
:
IndexMut
<
Handle
<
I
>
>
for
DataStore
<
I
>
{
fn
index_mut
(
&
mut
self
handle
:
Handle
<
I
>
)
-
>
&
mut
I
:
:
StoreData
{
self
.
items
[
handle
.
index
as
usize
]
.
as_mut
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
struct
ItemDetails
<
I
>
{
interned_epoch
:
Epoch
last_used_epoch
:
Epoch
index
:
usize
_marker
:
PhantomData
<
I
>
}
impl
<
I
>
ItemDetails
<
I
>
{
fn
create_handle
(
&
self
)
-
>
Handle
<
I
>
{
Handle
{
index
:
self
.
index
as
u32
epoch
:
self
.
interned_epoch
_marker
:
PhantomData
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Interner
<
I
:
Internable
>
{
map
:
FastHashMap
<
I
:
:
Key
ItemDetails
<
I
>
>
free_list
:
Vec
<
usize
>
update_list
:
UpdateList
<
I
:
:
Key
>
current_epoch
:
Epoch
local_data
:
Vec
<
I
:
:
InternData
>
}
impl
<
I
:
Internable
>
Default
for
Interner
<
I
>
{
fn
default
(
)
-
>
Self
{
Interner
{
map
:
FastHashMap
:
:
default
(
)
free_list
:
Vec
:
:
new
(
)
update_list
:
UpdateList
:
:
new
(
)
current_epoch
:
Epoch
(
1
)
local_data
:
Vec
:
:
new
(
)
}
}
}
impl
<
I
:
Internable
>
Interner
<
I
>
{
pub
fn
intern
<
F
>
(
&
mut
self
data
:
&
I
:
:
Key
fun
:
F
)
-
>
Handle
<
I
>
where
F
:
FnOnce
(
)
-
>
I
:
:
InternData
{
if
let
Some
(
details
)
=
self
.
map
.
get_mut
(
data
)
{
details
.
last_used_epoch
=
self
.
current_epoch
;
return
details
.
create_handle
(
)
;
}
let
index
=
match
self
.
free_list
.
pop
(
)
{
Some
(
index
)
=
>
index
None
=
>
self
.
local_data
.
len
(
)
}
;
let
handle
=
Handle
{
index
:
index
as
u32
epoch
:
self
.
current_epoch
_marker
:
PhantomData
}
;
let
uid
=
handle
.
uid
(
)
;
self
.
update_list
.
insertions
.
push
(
Insertion
{
index
uid
value
:
data
.
clone
(
)
}
)
;
#
[
cfg
(
debug_assertions
)
]
data
.
on_interned
(
uid
)
;
self
.
map
.
insert
(
data
.
clone
(
)
ItemDetails
{
interned_epoch
:
self
.
current_epoch
last_used_epoch
:
self
.
current_epoch
index
_marker
:
PhantomData
}
)
;
self
.
local_data
.
entry
(
index
)
.
set
(
fun
(
)
)
;
handle
}
pub
fn
end_frame_and_get_pending_updates
(
&
mut
self
)
-
>
UpdateList
<
I
:
:
Key
>
{
let
mut
update_list
=
self
.
update_list
.
take_and_preallocate
(
)
;
let
free_list
=
&
mut
self
.
free_list
;
let
current_epoch
=
self
.
current_epoch
.
0
;
self
.
map
.
retain
(
|
_
details
|
{
if
details
.
last_used_epoch
.
0
+
10
<
current_epoch
{
free_list
.
push
(
details
.
index
)
;
update_list
.
removals
.
push
(
Removal
{
index
:
details
.
index
uid
:
details
.
create_handle
(
)
.
uid
(
)
}
)
;
return
false
;
}
true
}
)
;
self
.
current_epoch
=
Epoch
(
self
.
current_epoch
.
0
+
1
)
;
update_list
}
}
impl
<
I
:
Internable
>
ops
:
:
Index
<
Handle
<
I
>
>
for
Interner
<
I
>
{
type
Output
=
I
:
:
InternData
;
fn
index
(
&
self
handle
:
Handle
<
I
>
)
-
>
&
I
:
:
InternData
{
&
self
.
local_data
[
handle
.
index
as
usize
]
}
}
mod
dummy
{
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
pub
trait
Serialize
{
}
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
impl
<
T
>
Serialize
for
T
{
}
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
pub
trait
Deserialize
<
'
a
>
{
}
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
impl
<
'
a
T
>
Deserialize
<
'
a
>
for
T
{
}
}
#
[
cfg
(
feature
=
"
capture
"
)
]
use
serde
:
:
Serialize
as
InternSerialize
;
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
use
self
:
:
dummy
:
:
Serialize
as
InternSerialize
;
#
[
cfg
(
feature
=
"
replay
"
)
]
use
serde
:
:
Deserialize
as
InternDeserialize
;
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
use
self
:
:
dummy
:
:
Deserialize
as
InternDeserialize
;
pub
trait
Internable
:
MallocSizeOf
{
type
Key
:
Eq
+
Hash
+
Clone
+
Debug
+
MallocSizeOf
+
InternDebug
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
type
StoreData
:
From
<
Self
:
:
Key
>
+
MallocSizeOf
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
type
InternData
:
MallocSizeOf
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
}
