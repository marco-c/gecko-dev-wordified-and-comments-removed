use
api
:
:
{
LayoutPrimitiveInfo
}
;
use
internal_types
:
:
FastHashMap
;
use
malloc_size_of
:
:
MallocSizeOf
;
use
profiler
:
:
ResourceProfileCounter
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
mem
ops
u64
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
util
:
:
VecHelper
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
MallocSizeOf
PartialEq
)
]
struct
Epoch
(
u64
)
;
pub
struct
UpdateList
<
S
>
{
updates
:
Vec
<
Update
>
data
:
Vec
<
S
>
}
lazy_static
!
{
static
ref
NEXT_UID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
ItemUid
{
uid
:
usize
}
impl
ItemUid
{
pub
fn
next_uid
(
)
-
>
ItemUid
{
let
uid
=
NEXT_UID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
ItemUid
{
uid
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
MallocSizeOf
)
]
pub
struct
Handle
<
M
:
Copy
>
{
index
:
u32
epoch
:
Epoch
uid
:
ItemUid
_marker
:
PhantomData
<
M
>
}
impl
<
M
>
Handle
<
M
>
where
M
:
Copy
{
pub
fn
uid
(
&
self
)
-
>
ItemUid
{
self
.
uid
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
enum
UpdateKind
{
Insert
Remove
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Update
{
index
:
usize
kind
:
UpdateKind
}
pub
trait
InternDebug
{
fn
on_interned
(
&
self
_uid
:
ItemUid
)
{
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
DataStore
<
S
T
:
MallocSizeOf
M
>
{
items
:
Vec
<
Option
<
T
>
>
_source
:
PhantomData
<
S
>
_marker
:
PhantomData
<
M
>
}
impl
<
S
T
M
>
:
:
std
:
:
default
:
:
Default
for
DataStore
<
S
T
M
>
where
S
:
Debug
+
MallocSizeOf
T
:
From
<
S
>
+
MallocSizeOf
M
:
Debug
{
fn
default
(
)
-
>
Self
{
DataStore
{
items
:
Vec
:
:
new
(
)
_source
:
PhantomData
_marker
:
PhantomData
}
}
}
impl
<
S
T
M
>
DataStore
<
S
T
M
>
where
S
:
Debug
+
MallocSizeOf
T
:
From
<
S
>
+
MallocSizeOf
M
:
Debug
{
pub
fn
apply_updates
(
&
mut
self
update_list
:
UpdateList
<
S
>
profile_counter
:
&
mut
ResourceProfileCounter
)
{
let
mut
data_iter
=
update_list
.
data
.
into_iter
(
)
;
for
update
in
update_list
.
updates
{
match
update
.
kind
{
UpdateKind
:
:
Insert
=
>
{
self
.
items
.
entry
(
update
.
index
)
.
set
(
Some
(
T
:
:
from
(
data_iter
.
next
(
)
.
unwrap
(
)
)
)
)
;
}
UpdateKind
:
:
Remove
=
>
{
self
.
items
[
update
.
index
]
=
None
;
}
}
}
let
per_item_size
=
mem
:
:
size_of
:
:
<
S
>
(
)
+
mem
:
:
size_of
:
:
<
T
>
(
)
;
profile_counter
.
set
(
self
.
items
.
len
(
)
per_item_size
*
self
.
items
.
len
(
)
)
;
debug_assert
!
(
data_iter
.
next
(
)
.
is_none
(
)
)
;
}
}
impl
<
S
T
M
>
ops
:
:
Index
<
Handle
<
M
>
>
for
DataStore
<
S
T
M
>
where
S
:
MallocSizeOf
T
:
MallocSizeOf
M
:
Copy
{
type
Output
=
T
;
fn
index
(
&
self
handle
:
Handle
<
M
>
)
-
>
&
T
{
self
.
items
[
handle
.
index
as
usize
]
.
as_ref
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
impl
<
S
T
M
>
ops
:
:
IndexMut
<
Handle
<
M
>
>
for
DataStore
<
S
T
M
>
where
S
:
MallocSizeOf
T
:
MallocSizeOf
M
:
Copy
{
fn
index_mut
(
&
mut
self
handle
:
Handle
<
M
>
)
-
>
&
mut
T
{
self
.
items
[
handle
.
index
as
usize
]
.
as_mut
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Interner
<
S
D
M
>
where
S
:
Eq
+
Hash
+
Clone
+
Debug
+
MallocSizeOf
D
:
MallocSizeOf
M
:
Copy
+
MallocSizeOf
{
map
:
FastHashMap
<
S
Handle
<
M
>
>
free_list
:
Vec
<
usize
>
updates
:
Vec
<
Update
>
update_data
:
Vec
<
S
>
current_epoch
:
Epoch
local_data
:
Vec
<
D
>
}
impl
<
S
D
M
>
:
:
std
:
:
default
:
:
Default
for
Interner
<
S
D
M
>
where
S
:
Eq
+
Hash
+
Clone
+
Debug
+
MallocSizeOf
D
:
MallocSizeOf
M
:
Copy
+
Debug
+
MallocSizeOf
{
fn
default
(
)
-
>
Self
{
Interner
{
map
:
FastHashMap
:
:
default
(
)
free_list
:
Vec
:
:
new
(
)
updates
:
Vec
:
:
new
(
)
update_data
:
Vec
:
:
new
(
)
current_epoch
:
Epoch
(
1
)
local_data
:
Vec
:
:
new
(
)
}
}
}
impl
<
S
D
M
>
Interner
<
S
D
M
>
where
S
:
Eq
+
Hash
+
Clone
+
Debug
+
InternDebug
+
MallocSizeOf
D
:
MallocSizeOf
M
:
Copy
+
Debug
+
MallocSizeOf
{
pub
fn
intern
<
F
>
(
&
mut
self
data
:
&
S
f
:
F
)
-
>
Handle
<
M
>
where
F
:
FnOnce
(
)
-
>
D
{
if
let
Some
(
handle
)
=
self
.
map
.
get_mut
(
data
)
{
handle
.
epoch
=
self
.
current_epoch
;
return
*
handle
;
}
let
index
=
match
self
.
free_list
.
pop
(
)
{
Some
(
index
)
=
>
index
None
=
>
self
.
local_data
.
len
(
)
}
;
self
.
updates
.
push
(
Update
{
index
kind
:
UpdateKind
:
:
Insert
}
)
;
self
.
update_data
.
alloc
(
)
.
init
(
data
.
clone
(
)
)
;
let
handle
=
Handle
{
index
:
index
as
u32
epoch
:
self
.
current_epoch
uid
:
ItemUid
:
:
next_uid
(
)
_marker
:
PhantomData
}
;
#
[
cfg
(
debug_assertions
)
]
data
.
on_interned
(
handle
.
uid
)
;
self
.
map
.
insert
(
data
.
clone
(
)
handle
)
;
self
.
local_data
.
entry
(
index
)
.
set
(
f
(
)
)
;
handle
}
pub
fn
end_frame_and_get_pending_updates
(
&
mut
self
)
-
>
UpdateList
<
S
>
{
let
mut
updates
=
self
.
updates
.
take_and_preallocate
(
)
;
let
data
=
self
.
update_data
.
take_and_preallocate
(
)
;
let
free_list
=
&
mut
self
.
free_list
;
let
current_epoch
=
self
.
current_epoch
.
0
;
self
.
map
.
retain
(
|
_
handle
|
{
if
handle
.
epoch
.
0
+
10
<
current_epoch
{
free_list
.
push
(
handle
.
index
as
usize
)
;
updates
.
push
(
Update
{
index
:
handle
.
index
as
usize
kind
:
UpdateKind
:
:
Remove
}
)
;
return
false
;
}
true
}
)
;
let
updates
=
UpdateList
{
updates
data
}
;
self
.
current_epoch
=
Epoch
(
self
.
current_epoch
.
0
+
1
)
;
updates
}
}
impl
<
S
D
M
>
ops
:
:
Index
<
Handle
<
M
>
>
for
Interner
<
S
D
M
>
where
S
:
Eq
+
Clone
+
Hash
+
Debug
+
MallocSizeOf
D
:
MallocSizeOf
M
:
Copy
+
Debug
+
MallocSizeOf
{
type
Output
=
D
;
fn
index
(
&
self
handle
:
Handle
<
M
>
)
-
>
&
D
{
&
self
.
local_data
[
handle
.
index
as
usize
]
}
}
pub
trait
Internable
{
type
Marker
:
Copy
+
Debug
+
MallocSizeOf
;
type
Source
:
Eq
+
Hash
+
Clone
+
Debug
+
MallocSizeOf
;
type
StoreData
:
From
<
Self
:
:
Source
>
+
MallocSizeOf
;
type
InternData
:
MallocSizeOf
;
fn
build_key
(
self
info
:
&
LayoutPrimitiveInfo
)
-
>
Self
:
:
Source
;
}
