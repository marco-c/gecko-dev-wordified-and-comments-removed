use
crate
:
:
internal_types
:
:
FastHashMap
;
use
malloc_size_of
:
:
MallocSizeOf
;
use
crate
:
:
profiler
:
:
ResourceProfileCounter
;
use
std
:
:
fmt
:
:
Debug
;
use
std
:
:
hash
:
:
Hash
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
{
mem
ops
u64
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
crate
:
:
util
:
:
VecHelper
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
MallocSizeOf
PartialEq
)
]
struct
Epoch
(
u64
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
UpdateList
<
S
>
{
pub
updates
:
Vec
<
Update
>
pub
data
:
Vec
<
S
>
}
lazy_static
!
{
static
ref
NEXT_UID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
ItemUid
{
uid
:
usize
}
impl
ItemUid
{
pub
fn
next_uid
(
)
-
>
ItemUid
{
let
uid
=
NEXT_UID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
ItemUid
{
uid
}
}
pub
fn
get_uid
(
&
self
)
-
>
usize
{
self
.
uid
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
MallocSizeOf
)
]
pub
struct
Handle
<
I
>
{
index
:
u32
epoch
:
Epoch
uid
:
ItemUid
_marker
:
PhantomData
<
I
>
}
impl
<
I
>
Clone
for
Handle
<
I
>
{
fn
clone
(
&
self
)
-
>
Self
{
Handle
{
index
:
self
.
index
epoch
:
self
.
epoch
uid
:
self
.
uid
_marker
:
self
.
_marker
}
}
}
impl
<
I
>
Copy
for
Handle
<
I
>
{
}
impl
<
I
>
Handle
<
I
>
{
pub
fn
uid
(
&
self
)
-
>
ItemUid
{
self
.
uid
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
enum
UpdateKind
{
Insert
Remove
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Update
{
pub
index
:
usize
pub
kind
:
UpdateKind
}
pub
trait
InternDebug
{
fn
on_interned
(
&
self
_uid
:
ItemUid
)
{
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
DataStore
<
I
:
Internable
>
{
items
:
Vec
<
Option
<
I
:
:
StoreData
>
>
}
impl
<
I
:
Internable
>
Default
for
DataStore
<
I
>
{
fn
default
(
)
-
>
Self
{
DataStore
{
items
:
Vec
:
:
new
(
)
}
}
}
impl
<
I
:
Internable
>
DataStore
<
I
>
{
pub
fn
apply_updates
(
&
mut
self
update_list
:
UpdateList
<
I
:
:
Key
>
profile_counter
:
&
mut
ResourceProfileCounter
)
{
let
mut
data_iter
=
update_list
.
data
.
into_iter
(
)
;
for
update
in
update_list
.
updates
{
match
update
.
kind
{
UpdateKind
:
:
Insert
=
>
{
let
value
=
data_iter
.
next
(
)
.
unwrap
(
)
.
into
(
)
;
self
.
items
.
entry
(
update
.
index
)
.
set
(
Some
(
value
)
)
;
}
UpdateKind
:
:
Remove
=
>
{
self
.
items
[
update
.
index
]
=
None
;
}
}
}
let
per_item_size
=
mem
:
:
size_of
:
:
<
I
:
:
Key
>
(
)
+
mem
:
:
size_of
:
:
<
I
:
:
StoreData
>
(
)
;
profile_counter
.
set
(
self
.
items
.
len
(
)
per_item_size
*
self
.
items
.
len
(
)
)
;
debug_assert
!
(
data_iter
.
next
(
)
.
is_none
(
)
)
;
}
}
impl
<
I
:
Internable
>
ops
:
:
Index
<
Handle
<
I
>
>
for
DataStore
<
I
>
{
type
Output
=
I
:
:
StoreData
;
fn
index
(
&
self
handle
:
Handle
<
I
>
)
-
>
&
I
:
:
StoreData
{
self
.
items
[
handle
.
index
as
usize
]
.
as_ref
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
impl
<
I
:
Internable
>
ops
:
:
IndexMut
<
Handle
<
I
>
>
for
DataStore
<
I
>
{
fn
index_mut
(
&
mut
self
handle
:
Handle
<
I
>
)
-
>
&
mut
I
:
:
StoreData
{
self
.
items
[
handle
.
index
as
usize
]
.
as_mut
(
)
.
expect
(
"
Bad
datastore
lookup
"
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
Interner
<
I
:
Internable
>
{
map
:
FastHashMap
<
I
:
:
Key
Handle
<
I
>
>
free_list
:
Vec
<
usize
>
updates
:
Vec
<
Update
>
update_data
:
Vec
<
I
:
:
Key
>
current_epoch
:
Epoch
local_data
:
Vec
<
I
:
:
InternData
>
}
impl
<
I
:
Internable
>
Default
for
Interner
<
I
>
{
fn
default
(
)
-
>
Self
{
Interner
{
map
:
FastHashMap
:
:
default
(
)
free_list
:
Vec
:
:
new
(
)
updates
:
Vec
:
:
new
(
)
update_data
:
Vec
:
:
new
(
)
current_epoch
:
Epoch
(
1
)
local_data
:
Vec
:
:
new
(
)
}
}
}
impl
<
I
:
Internable
>
Interner
<
I
>
{
pub
fn
intern
<
F
>
(
&
mut
self
data
:
&
I
:
:
Key
fun
:
F
)
-
>
Handle
<
I
>
where
F
:
FnOnce
(
)
-
>
I
:
:
InternData
{
if
let
Some
(
handle
)
=
self
.
map
.
get_mut
(
data
)
{
handle
.
epoch
=
self
.
current_epoch
;
return
*
handle
;
}
let
index
=
match
self
.
free_list
.
pop
(
)
{
Some
(
index
)
=
>
index
None
=
>
self
.
local_data
.
len
(
)
}
;
self
.
updates
.
push
(
Update
{
index
kind
:
UpdateKind
:
:
Insert
}
)
;
self
.
update_data
.
alloc
(
)
.
init
(
data
.
clone
(
)
)
;
let
handle
=
Handle
{
index
:
index
as
u32
epoch
:
self
.
current_epoch
uid
:
ItemUid
:
:
next_uid
(
)
_marker
:
PhantomData
}
;
#
[
cfg
(
debug_assertions
)
]
data
.
on_interned
(
handle
.
uid
)
;
self
.
map
.
insert
(
data
.
clone
(
)
handle
)
;
self
.
local_data
.
entry
(
index
)
.
set
(
fun
(
)
)
;
handle
}
pub
fn
end_frame_and_get_pending_updates
(
&
mut
self
)
-
>
UpdateList
<
I
:
:
Key
>
{
let
mut
updates
=
self
.
updates
.
take_and_preallocate
(
)
;
let
data
=
self
.
update_data
.
take_and_preallocate
(
)
;
let
free_list
=
&
mut
self
.
free_list
;
let
current_epoch
=
self
.
current_epoch
.
0
;
self
.
map
.
retain
(
|
_
handle
|
{
if
handle
.
epoch
.
0
+
10
<
current_epoch
{
free_list
.
push
(
handle
.
index
as
usize
)
;
updates
.
push
(
Update
{
index
:
handle
.
index
as
usize
kind
:
UpdateKind
:
:
Remove
}
)
;
return
false
;
}
true
}
)
;
let
updates
=
UpdateList
{
updates
data
}
;
self
.
current_epoch
=
Epoch
(
self
.
current_epoch
.
0
+
1
)
;
updates
}
}
impl
<
I
:
Internable
>
ops
:
:
Index
<
Handle
<
I
>
>
for
Interner
<
I
>
{
type
Output
=
I
:
:
InternData
;
fn
index
(
&
self
handle
:
Handle
<
I
>
)
-
>
&
I
:
:
InternData
{
&
self
.
local_data
[
handle
.
index
as
usize
]
}
}
mod
dummy
{
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
pub
trait
Serialize
{
}
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
impl
<
T
>
Serialize
for
T
{
}
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
pub
trait
Deserialize
<
'
a
>
{
}
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
impl
<
'
a
T
>
Deserialize
<
'
a
>
for
T
{
}
}
#
[
cfg
(
feature
=
"
capture
"
)
]
use
serde
:
:
Serialize
as
InternSerialize
;
#
[
cfg
(
not
(
feature
=
"
capture
"
)
)
]
use
self
:
:
dummy
:
:
Serialize
as
InternSerialize
;
#
[
cfg
(
feature
=
"
replay
"
)
]
use
serde
:
:
Deserialize
as
InternDeserialize
;
#
[
cfg
(
not
(
feature
=
"
replay
"
)
)
]
use
self
:
:
dummy
:
:
Deserialize
as
InternDeserialize
;
pub
trait
Internable
:
MallocSizeOf
{
type
Key
:
Eq
+
Hash
+
Clone
+
Debug
+
MallocSizeOf
+
InternDebug
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
type
StoreData
:
From
<
Self
:
:
Key
>
+
MallocSizeOf
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
type
InternData
:
MallocSizeOf
+
InternSerialize
+
for
<
'
a
>
InternDeserialize
<
'
a
>
;
}
