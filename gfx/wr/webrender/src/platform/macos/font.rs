use
api
:
:
{
ColorU
FontKey
FontRenderMode
FontSize
GlyphDimensions
}
;
use
api
:
:
{
FontInstanceFlags
FontVariation
NativeFontHandle
}
;
use
core_foundation
:
:
{
array
:
:
{
CFArray
CFArrayRef
}
data
:
:
CFData
}
;
use
core_foundation
:
:
base
:
:
TCFType
;
use
core_foundation
:
:
dictionary
:
:
CFDictionary
;
use
core_foundation
:
:
number
:
:
{
CFNumber
CFNumberRef
}
;
use
core_foundation
:
:
string
:
:
{
CFString
CFStringRef
}
;
use
core_graphics
:
:
base
:
:
{
kCGImageAlphaNoneSkipFirst
kCGImageAlphaPremultipliedFirst
}
;
use
core_graphics
:
:
base
:
:
{
kCGBitmapByteOrder32Little
}
;
use
core_graphics
:
:
color_space
:
:
CGColorSpace
;
use
core_graphics
:
:
context
:
:
CGContext
;
use
core_graphics
:
:
context
:
:
{
CGBlendMode
CGTextDrawingMode
}
;
use
core_graphics
:
:
font
:
:
CGGlyph
;
use
core_graphics
:
:
geometry
:
:
{
CGAffineTransform
CGPoint
CGSize
}
;
use
core_graphics
:
:
geometry
:
:
{
CG_AFFINE_TRANSFORM_IDENTITY
CGRect
}
;
use
core_text
:
:
{
self
font_descriptor
:
:
CTFontDescriptorCreateCopyWithAttributes
}
;
use
core_text
:
:
font
:
:
{
CTFont
CTFontRef
}
;
use
core_text
:
:
font_descriptor
:
:
CTFontDescriptor
;
use
core_text
:
:
font_descriptor
:
:
{
kCTFontDefaultOrientation
kCTFontColorGlyphsTrait
}
;
use
euclid
:
:
default
:
:
Size2D
;
use
crate
:
:
gamma_lut
:
:
{
ColorLut
GammaLut
}
;
use
crate
:
:
glyph_rasterizer
:
:
{
FontInstance
FontTransform
GlyphKey
}
;
use
crate
:
:
glyph_rasterizer
:
:
{
GlyphFormat
GlyphRasterError
GlyphRasterResult
RasterizedGlyph
}
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
ResourceCacheError
}
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
sync
:
:
Arc
;
const
INITIAL_CG_CONTEXT_SIDE_LENGTH
:
u32
=
32
;
pub
struct
FontContext
{
ct_font_descs
:
FastHashMap
<
FontKey
CTFontDescriptor
>
ct_fonts
:
FastHashMap
<
(
FontKey
FontSize
Vec
<
FontVariation
>
)
CTFont
>
#
[
allow
(
dead_code
)
]
graphics_context
:
GraphicsContext
#
[
allow
(
dead_code
)
]
gamma_lut
:
GammaLut
}
unsafe
impl
Send
for
FontContext
{
}
struct
GlyphMetrics
{
rasterized_left
:
i32
#
[
allow
(
dead_code
)
]
rasterized_descent
:
i32
rasterized_ascent
:
i32
rasterized_width
:
i32
rasterized_height
:
i32
advance
:
f32
}
fn
determine_font_smoothing_mode
(
)
-
>
Option
<
FontRenderMode
>
{
let
mut
smooth_context
=
CGContext
:
:
create_bitmap_context
(
None
12
12
8
12
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGImageAlphaNoneSkipFirst
|
kCGBitmapByteOrder32Little
)
;
smooth_context
.
set_should_smooth_fonts
(
true
)
;
smooth_context
.
set_should_antialias
(
true
)
;
smooth_context
.
set_rgb_fill_color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
let
mut
gray_context
=
CGContext
:
:
create_bitmap_context
(
None
12
12
8
12
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGImageAlphaNoneSkipFirst
|
kCGBitmapByteOrder32Little
)
;
gray_context
.
set_should_smooth_fonts
(
false
)
;
gray_context
.
set_should_antialias
(
true
)
;
gray_context
.
set_rgb_fill_color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
let
ct_font
=
core_text
:
:
font
:
:
new_from_name
(
"
Lucida
Grande
"
12
.
)
.
unwrap
(
)
;
let
point
=
CGPoint
{
x
:
0
.
y
:
0
.
}
;
let
glyph
=
'
X
'
as
CGGlyph
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
point
]
smooth_context
.
clone
(
)
)
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
point
]
gray_context
.
clone
(
)
)
;
let
mut
mode
=
None
;
for
(
smooth
gray
)
in
smooth_context
.
data
(
)
.
chunks
(
4
)
.
zip
(
gray_context
.
data
(
)
.
chunks
(
4
)
)
{
if
smooth
[
0
]
!
=
smooth
[
1
]
|
|
smooth
[
1
]
!
=
smooth
[
2
]
{
return
Some
(
FontRenderMode
:
:
Subpixel
)
;
}
if
smooth
[
0
]
!
=
gray
[
0
]
|
|
smooth
[
1
]
!
=
gray
[
1
]
|
|
smooth
[
2
]
!
=
gray
[
2
]
{
mode
=
Some
(
FontRenderMode
:
:
Alpha
)
;
}
}
return
mode
;
}
lazy_static
!
{
static
ref
FONT_SMOOTHING_MODE
:
Option
<
FontRenderMode
>
=
determine_font_smoothing_mode
(
)
;
}
fn
should_use_white_on_black
(
color
:
ColorU
)
-
>
bool
{
let
(
r
g
b
)
=
(
color
.
r
as
u32
color
.
g
as
u32
color
.
b
as
u32
)
;
r
>
=
85
&
&
g
>
=
85
&
&
b
>
=
85
&
&
r
+
g
+
b
>
=
2
*
255
}
fn
get_glyph_metrics
(
ct_font
:
&
CTFont
transform
:
Option
<
&
CGAffineTransform
>
glyph
:
CGGlyph
x_offset
:
f64
y_offset
:
f64
extra_width
:
f64
)
-
>
GlyphMetrics
{
let
mut
bounds
=
ct_font
.
get_bounding_rects_for_glyphs
(
kCTFontDefaultOrientation
&
[
glyph
]
)
;
if
bounds
.
origin
.
x
.
is_nan
(
)
|
|
bounds
.
origin
.
y
.
is_nan
(
)
|
|
bounds
.
size
.
width
.
is_nan
(
)
|
|
bounds
.
size
.
height
.
is_nan
(
)
{
return
GlyphMetrics
{
rasterized_left
:
0
rasterized_width
:
0
rasterized_height
:
0
rasterized_ascent
:
0
rasterized_descent
:
0
advance
:
0
.
0
}
;
}
let
mut
advance
=
CGSize
{
width
:
0
.
0
height
:
0
.
0
}
;
unsafe
{
ct_font
.
get_advances_for_glyphs
(
kCTFontDefaultOrientation
&
glyph
&
mut
advance
1
)
;
}
if
bounds
.
size
.
width
>
0
.
0
{
bounds
.
size
.
width
+
=
extra_width
;
}
if
advance
.
width
>
0
.
0
{
advance
.
width
+
=
extra_width
;
}
if
let
Some
(
transform
)
=
transform
{
bounds
=
bounds
.
apply_transform
(
transform
)
;
}
let
mut
left
=
bounds
.
origin
.
x
.
floor
(
)
as
i32
;
let
mut
bottom
=
bounds
.
origin
.
y
.
floor
(
)
as
i32
;
let
mut
right
=
(
bounds
.
origin
.
x
+
bounds
.
size
.
width
+
x_offset
)
.
ceil
(
)
as
i32
;
let
mut
top
=
(
bounds
.
origin
.
y
+
bounds
.
size
.
height
+
y_offset
)
.
ceil
(
)
as
i32
;
left
-
=
1
;
bottom
-
=
1
;
right
+
=
1
;
top
+
=
1
;
let
width
=
right
-
left
;
let
height
=
top
-
bottom
;
GlyphMetrics
{
rasterized_left
:
left
rasterized_width
:
width
rasterized_height
:
height
rasterized_ascent
:
top
rasterized_descent
:
-
bottom
advance
:
advance
.
width
as
f32
}
}
#
[
link
(
name
=
"
ApplicationServices
"
kind
=
"
framework
"
)
]
extern
{
static
kCTFontVariationAxisIdentifierKey
:
CFStringRef
;
static
kCTFontVariationAxisMinimumValueKey
:
CFStringRef
;
static
kCTFontVariationAxisMaximumValueKey
:
CFStringRef
;
static
kCTFontVariationAxisDefaultValueKey
:
CFStringRef
;
static
kCTFontVariationAttribute
:
CFStringRef
;
fn
CTFontCopyVariationAxes
(
font
:
CTFontRef
)
-
>
CFArrayRef
;
}
fn
new_ct_font_with_variations
(
ct_font_desc
:
&
CTFontDescriptor
size
:
f64
variations
:
&
[
FontVariation
]
)
-
>
CTFont
{
unsafe
{
let
ct_font
=
core_text
:
:
font
:
:
new_from_descriptor
(
ct_font_desc
size
)
;
if
variations
.
is_empty
(
)
{
return
ct_font
;
}
let
axes_ref
=
CTFontCopyVariationAxes
(
ct_font
.
as_concrete_TypeRef
(
)
)
;
if
axes_ref
.
is_null
(
)
{
return
ct_font
;
}
let
axes
:
CFArray
<
CFDictionary
>
=
TCFType
:
:
wrap_under_create_rule
(
axes_ref
)
;
let
mut
vals
:
Vec
<
(
CFNumber
CFNumber
)
>
=
Vec
:
:
with_capacity
(
variations
.
len
(
)
as
usize
)
;
for
axis
in
axes
.
iter
(
)
{
if
!
axis
.
instance_of
:
:
<
CFDictionary
>
(
)
{
return
ct_font
;
}
let
tag_val
=
match
axis
.
find
(
kCTFontVariationAxisIdentifierKey
as
*
const
_
)
{
Some
(
tag_ptr
)
=
>
{
let
tag
:
CFNumber
=
TCFType
:
:
wrap_under_get_rule
(
*
tag_ptr
as
CFNumberRef
)
;
if
!
tag
.
instance_of
:
:
<
CFNumber
>
(
)
{
return
ct_font
;
}
match
tag
.
to_i64
(
)
{
Some
(
val
)
=
>
val
None
=
>
return
ct_font
}
}
None
=
>
return
ct_font
}
;
let
mut
val
=
match
variations
.
iter
(
)
.
find
(
|
variation
|
(
variation
.
tag
as
i64
)
=
=
tag_val
)
{
Some
(
variation
)
=
>
variation
.
value
as
f64
None
=
>
continue
}
;
let
min_val
=
match
axis
.
find
(
kCTFontVariationAxisMinimumValueKey
as
*
const
_
)
{
Some
(
min_ptr
)
=
>
{
let
min
:
CFNumber
=
TCFType
:
:
wrap_under_get_rule
(
*
min_ptr
as
CFNumberRef
)
;
if
!
min
.
instance_of
:
:
<
CFNumber
>
(
)
{
return
ct_font
;
}
match
min
.
to_f64
(
)
{
Some
(
val
)
=
>
val
None
=
>
return
ct_font
}
}
None
=
>
return
ct_font
}
;
let
max_val
=
match
axis
.
find
(
kCTFontVariationAxisMaximumValueKey
as
*
const
_
)
{
Some
(
max_ptr
)
=
>
{
let
max
:
CFNumber
=
TCFType
:
:
wrap_under_get_rule
(
*
max_ptr
as
CFNumberRef
)
;
if
!
max
.
instance_of
:
:
<
CFNumber
>
(
)
{
return
ct_font
;
}
match
max
.
to_f64
(
)
{
Some
(
val
)
=
>
val
None
=
>
return
ct_font
}
}
None
=
>
return
ct_font
}
;
let
def_val
=
match
axis
.
find
(
kCTFontVariationAxisDefaultValueKey
as
*
const
_
)
{
Some
(
def_ptr
)
=
>
{
let
def
:
CFNumber
=
TCFType
:
:
wrap_under_get_rule
(
*
def_ptr
as
CFNumberRef
)
;
if
!
def
.
instance_of
:
:
<
CFNumber
>
(
)
{
return
ct_font
;
}
match
def
.
to_f64
(
)
{
Some
(
val
)
=
>
val
None
=
>
return
ct_font
}
}
None
=
>
return
ct_font
}
;
val
=
val
.
max
(
min_val
)
.
min
(
max_val
)
;
if
val
!
=
def_val
{
vals
.
push
(
(
CFNumber
:
:
from
(
tag_val
)
CFNumber
:
:
from
(
val
)
)
)
;
}
}
if
vals
.
is_empty
(
)
{
return
ct_font
;
}
let
vals_dict
=
CFDictionary
:
:
from_CFType_pairs
(
&
vals
)
;
let
attrs_dict
=
CFDictionary
:
:
from_CFType_pairs
(
&
[
(
CFString
:
:
wrap_under_get_rule
(
kCTFontVariationAttribute
)
vals_dict
)
]
)
;
let
ct_var_font_desc
=
create_copy_with_attributes
(
ct_font_desc
attrs_dict
.
to_untyped
(
)
)
.
unwrap
(
)
;
core_text
:
:
font
:
:
new_from_descriptor
(
&
ct_var_font_desc
size
)
}
}
fn
is_bitmap_font
(
ct_font
:
&
CTFont
)
-
>
bool
{
let
traits
=
ct_font
.
symbolic_traits
(
)
;
(
traits
&
kCTFontColorGlyphsTrait
)
!
=
0
}
impl
FontContext
{
pub
fn
new
(
)
-
>
Result
<
FontContext
ResourceCacheError
>
{
debug
!
(
"
Test
for
subpixel
AA
support
:
{
:
?
}
"
*
FONT_SMOOTHING_MODE
)
;
let
contrast
=
0
.
0
;
let
gamma
=
0
.
0
;
Ok
(
FontContext
{
ct_font_descs
:
FastHashMap
:
:
default
(
)
ct_fonts
:
FastHashMap
:
:
default
(
)
graphics_context
:
GraphicsContext
:
:
new
(
)
gamma_lut
:
GammaLut
:
:
new
(
contrast
gamma
gamma
)
}
)
}
pub
fn
has_font
(
&
self
font_key
:
&
FontKey
)
-
>
bool
{
self
.
ct_font_descs
.
contains_key
(
font_key
)
}
pub
fn
add_raw_font
(
&
mut
self
font_key
:
&
FontKey
bytes
:
Arc
<
Vec
<
u8
>
>
index
:
u32
)
{
if
self
.
ct_font_descs
.
contains_key
(
font_key
)
{
return
;
}
assert_eq
!
(
index
0
)
;
let
data
=
CFData_wrapping_arc_vec
(
bytes
)
;
let
ct_font_desc
=
match
create_font_descriptor
(
data
)
{
Err
(
_
)
=
>
return
Ok
(
cg_font
)
=
>
cg_font
}
;
self
.
ct_font_descs
.
insert
(
*
font_key
ct_font_desc
)
;
}
pub
fn
add_native_font
(
&
mut
self
font_key
:
&
FontKey
native_font_handle
:
NativeFontHandle
)
{
if
self
.
ct_font_descs
.
contains_key
(
font_key
)
{
return
;
}
let
font
=
core_text
:
:
font
:
:
new_from_CGFont
(
&
native_font_handle
.
0
0
.
)
;
fn
copy_descriptor
(
font
:
CTFont
)
-
>
CTFontDescriptor
{
use
core_text
:
:
font_descriptor
:
:
CTFontDescriptorRef
;
extern
{
fn
CTFontCopyFontDescriptor
(
font
:
CTFontRef
)
-
>
CTFontDescriptorRef
;
}
unsafe
{
let
desc
=
CTFontCopyFontDescriptor
(
font
.
as_concrete_TypeRef
(
)
)
;
CTFontDescriptor
:
:
wrap_under_create_rule
(
desc
)
}
}
let
desc
=
copy_descriptor
(
font
)
;
self
.
ct_font_descs
.
insert
(
*
font_key
desc
)
;
}
pub
fn
delete_font
(
&
mut
self
font_key
:
&
FontKey
)
{
if
let
Some
(
_
)
=
self
.
ct_font_descs
.
remove
(
font_key
)
{
self
.
ct_fonts
.
retain
(
|
k
_
|
k
.
0
!
=
*
font_key
)
;
}
}
pub
fn
delete_font_instance
(
&
mut
self
instance
:
&
FontInstance
)
{
let
size
=
FontSize
:
:
from_f64_px
(
instance
.
get_transformed_size
(
)
)
;
self
.
ct_fonts
.
remove
(
&
(
instance
.
font_key
size
instance
.
variations
.
clone
(
)
)
)
;
}
fn
get_ct_font
(
&
mut
self
font_key
:
FontKey
size
:
f64
variations
:
&
[
FontVariation
]
)
-
>
Option
<
CTFont
>
{
match
self
.
ct_fonts
.
entry
(
(
font_key
FontSize
:
:
from_f64_px
(
size
)
variations
.
to_vec
(
)
)
)
{
Entry
:
:
Occupied
(
entry
)
=
>
Some
(
(
*
entry
.
get
(
)
)
.
clone
(
)
)
Entry
:
:
Vacant
(
entry
)
=
>
{
let
cg_font
=
self
.
ct_font_descs
.
get
(
&
font_key
)
?
;
let
ct_font
=
new_ct_font_with_variations
(
cg_font
size
variations
)
;
entry
.
insert
(
ct_font
.
clone
(
)
)
;
Some
(
ct_font
)
}
}
}
pub
fn
get_glyph_index
(
&
mut
self
font_key
:
FontKey
ch
:
char
)
-
>
Option
<
u32
>
{
let
character
=
ch
as
u16
;
let
mut
glyph
=
0
;
self
.
get_ct_font
(
font_key
16
.
0
&
[
]
)
.
and_then
(
|
ref
ct_font
|
{
unsafe
{
let
result
=
ct_font
.
get_glyphs_for_characters
(
&
character
&
mut
glyph
1
)
;
if
result
{
Some
(
glyph
as
u32
)
}
else
{
None
}
}
}
)
}
pub
fn
get_glyph_dimensions
(
&
mut
self
font
:
&
FontInstance
key
:
&
GlyphKey
)
-
>
Option
<
GlyphDimensions
>
{
let
(
x_scale
y_scale
)
=
font
.
transform
.
compute_scale
(
)
.
unwrap_or
(
(
1
.
0
1
.
0
)
)
;
let
size
=
font
.
size
.
to_f64_px
(
)
*
y_scale
;
self
.
get_ct_font
(
font
.
font_key
size
&
font
.
variations
)
.
and_then
(
|
ref
ct_font
|
{
let
glyph
=
key
.
index
(
)
as
CGGlyph
;
let
bitmap
=
is_bitmap_font
(
ct_font
)
;
let
(
mut
shape
(
x_offset
y_offset
)
)
=
if
bitmap
{
(
FontTransform
:
:
identity
(
)
(
0
.
0
0
.
0
)
)
}
else
{
(
font
.
transform
.
invert_scale
(
y_scale
y_scale
)
font
.
get_subpx_offset
(
key
)
)
}
;
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_X
)
{
shape
=
shape
.
flip_x
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_Y
)
{
shape
=
shape
.
flip_y
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
TRANSPOSE
)
{
shape
=
shape
.
swap_xy
(
)
;
}
let
(
mut
tx
mut
ty
)
=
(
0
.
0
0
.
0
)
;
if
font
.
synthetic_italics
.
is_enabled
(
)
{
let
(
shape_
(
tx_
ty_
)
)
=
font
.
synthesize_italics
(
shape
size
)
;
shape
=
shape_
;
tx
=
tx_
;
ty
=
ty_
;
}
let
transform
=
if
!
shape
.
is_identity
(
)
|
|
(
tx
ty
)
!
=
(
0
.
0
0
.
0
)
{
Some
(
CGAffineTransform
{
a
:
shape
.
scale_x
as
f64
b
:
-
shape
.
skew_y
as
f64
c
:
-
shape
.
skew_x
as
f64
d
:
shape
.
scale_y
as
f64
tx
:
tx
ty
:
-
ty
}
)
}
else
{
None
}
;
let
(
strike_scale
pixel_step
)
=
if
bitmap
{
(
y_scale
1
.
0
)
}
else
{
(
x_scale
y_scale
/
x_scale
)
}
;
let
extra_strikes
=
font
.
get_extra_strikes
(
strike_scale
)
;
let
metrics
=
get_glyph_metrics
(
ct_font
transform
.
as_ref
(
)
glyph
x_offset
y_offset
extra_strikes
as
f64
*
pixel_step
)
;
if
metrics
.
rasterized_width
=
=
0
|
|
metrics
.
rasterized_height
=
=
0
{
None
}
else
{
Some
(
GlyphDimensions
{
left
:
metrics
.
rasterized_left
top
:
metrics
.
rasterized_ascent
width
:
metrics
.
rasterized_width
height
:
metrics
.
rasterized_height
advance
:
metrics
.
advance
}
)
}
}
)
}
fn
gamma_correct_pixels
(
&
self
pixels
:
&
mut
Vec
<
u8
>
render_mode
:
FontRenderMode
color
:
ColorU
)
{
match
render_mode
{
FontRenderMode
:
:
Alpha
=
>
{
self
.
gamma_lut
.
preblend_grayscale
(
pixels
color
)
;
}
FontRenderMode
:
:
Subpixel
=
>
{
self
.
gamma_lut
.
preblend
(
pixels
color
)
;
}
_
=
>
{
}
}
}
#
[
allow
(
dead_code
)
]
fn
print_glyph_data
(
&
mut
self
data
:
&
[
u8
]
width
:
usize
height
:
usize
)
{
println
!
(
"
Width
is
:
{
:
?
}
height
:
{
:
?
}
"
width
height
)
;
for
i
in
0
.
.
height
{
let
current_height
=
i
*
width
*
4
;
for
pixel
in
data
[
current_height
.
.
current_height
+
(
width
*
4
)
]
.
chunks
(
4
)
{
let
b
=
pixel
[
0
]
;
let
g
=
pixel
[
1
]
;
let
r
=
pixel
[
2
]
;
let
a
=
pixel
[
3
]
;
print
!
(
"
(
{
}
{
}
{
}
{
}
)
"
r
g
b
a
)
;
}
println
!
(
)
;
}
}
pub
fn
prepare_font
(
font
:
&
mut
FontInstance
)
{
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
|
|
font
.
render_mode
=
=
FontRenderMode
:
:
Subpixel
{
match
*
FONT_SMOOTHING_MODE
{
Some
(
mode
)
=
>
{
font
.
render_mode
=
font
.
render_mode
.
limit_by
(
mode
)
;
font
.
flags
.
insert
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
}
None
=
>
{
font
.
render_mode
=
font
.
render_mode
.
limit_by
(
FontRenderMode
:
:
Alpha
)
;
font
.
flags
.
remove
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
}
}
}
match
font
.
render_mode
{
FontRenderMode
:
:
Mono
=
>
{
font
.
color
=
ColorU
:
:
new
(
255
255
255
255
)
;
font
.
disable_subpixel_position
(
)
;
}
FontRenderMode
:
:
Alpha
=
>
{
font
.
color
=
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
{
let
ColorU
{
g
a
.
.
}
=
font
.
color
.
luminance_color
(
)
.
quantized_ceil
(
)
;
let
rb
=
if
should_use_white_on_black
(
font
.
color
)
{
255
}
else
{
0
}
;
ColorU
:
:
new
(
rb
g
rb
a
)
}
else
{
ColorU
:
:
new
(
255
255
255
255
)
}
;
}
FontRenderMode
:
:
Subpixel
=
>
{
font
.
color
=
if
should_use_white_on_black
(
font
.
color
)
{
font
.
color
.
quantized_ceil
(
)
}
else
{
font
.
color
.
quantized_floor
(
)
}
;
}
}
}
pub
fn
rasterize_glyph
(
&
mut
self
font
:
&
FontInstance
key
:
&
GlyphKey
)
-
>
GlyphRasterResult
{
let
(
x_scale
y_scale
)
=
font
.
transform
.
compute_scale
(
)
.
unwrap_or
(
(
1
.
0
1
.
0
)
)
;
let
size
=
font
.
size
.
to_f64_px
(
)
*
y_scale
;
let
ct_font
=
self
.
get_ct_font
(
font
.
font_key
size
&
font
.
variations
)
.
ok_or
(
GlyphRasterError
:
:
LoadFailed
)
?
;
let
glyph_type
=
if
is_bitmap_font
(
&
ct_font
)
{
GlyphType
:
:
Bitmap
}
else
{
GlyphType
:
:
Vector
}
;
let
(
mut
shape
(
x_offset
y_offset
)
)
=
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
(
FontTransform
:
:
identity
(
)
(
0
.
0
0
.
0
)
)
GlyphType
:
:
Vector
=
>
{
(
font
.
transform
.
invert_scale
(
y_scale
y_scale
)
font
.
get_subpx_offset
(
key
)
)
}
}
;
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_X
)
{
shape
=
shape
.
flip_x
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_Y
)
{
shape
=
shape
.
flip_y
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
TRANSPOSE
)
{
shape
=
shape
.
swap_xy
(
)
;
}
let
(
mut
tx
mut
ty
)
=
(
0
.
0
0
.
0
)
;
if
font
.
synthetic_italics
.
is_enabled
(
)
{
let
(
shape_
(
tx_
ty_
)
)
=
font
.
synthesize_italics
(
shape
size
)
;
shape
=
shape_
;
tx
=
tx_
;
ty
=
ty_
;
}
let
transform
=
if
!
shape
.
is_identity
(
)
|
|
(
tx
ty
)
!
=
(
0
.
0
0
.
0
)
{
Some
(
CGAffineTransform
{
a
:
shape
.
scale_x
as
f64
b
:
-
shape
.
skew_y
as
f64
c
:
-
shape
.
skew_x
as
f64
d
:
shape
.
scale_y
as
f64
tx
:
tx
ty
:
-
ty
}
)
}
else
{
None
}
;
let
glyph
=
key
.
index
(
)
as
CGGlyph
;
let
(
strike_scale
pixel_step
)
=
if
glyph_type
=
=
GlyphType
:
:
Bitmap
{
(
y_scale
1
.
0
)
}
else
{
(
x_scale
y_scale
/
x_scale
)
}
;
let
extra_strikes
=
font
.
get_extra_strikes
(
strike_scale
)
;
let
metrics
=
get_glyph_metrics
(
&
ct_font
transform
.
as_ref
(
)
glyph
x_offset
y_offset
extra_strikes
as
f64
*
pixel_step
)
;
if
metrics
.
rasterized_width
=
=
0
|
|
metrics
.
rasterized_height
=
=
0
{
return
Err
(
GlyphRasterError
:
:
LoadFailed
)
;
}
let
raster_size
=
Size2D
:
:
new
(
metrics
.
rasterized_width
as
u32
metrics
.
rasterized_height
as
u32
)
;
let
use_white_on_black
=
should_use_white_on_black
(
font
.
color
)
;
let
use_font_smoothing
=
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
let
(
antialias
smooth
text_color
bg_color
bg_alpha
invert
)
=
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
(
true
false
0
.
0
0
.
0
0
.
0
false
)
GlyphType
:
:
Vector
=
>
{
match
(
font
.
render_mode
use_font_smoothing
)
{
(
FontRenderMode
:
:
Subpixel
_
)
|
(
FontRenderMode
:
:
Alpha
true
)
=
>
if
use_white_on_black
{
(
true
true
1
.
0
0
.
0
1
.
0
false
)
}
else
{
(
true
true
0
.
0
1
.
0
1
.
0
true
)
}
(
FontRenderMode
:
:
Alpha
false
)
=
>
(
true
false
0
.
0
1
.
0
1
.
0
true
)
(
FontRenderMode
:
:
Mono
_
)
=
>
(
false
false
0
.
0
1
.
0
1
.
0
true
)
}
}
}
;
{
let
cg_context
=
self
.
graphics_context
.
get_context
(
&
raster_size
glyph_type
)
;
cg_context
.
set_allows_font_subpixel_positioning
(
true
)
;
cg_context
.
set_should_subpixel_position_fonts
(
true
)
;
cg_context
.
set_allows_font_subpixel_quantization
(
false
)
;
cg_context
.
set_should_subpixel_quantize_fonts
(
false
)
;
cg_context
.
set_should_smooth_fonts
(
smooth
)
;
cg_context
.
set_should_antialias
(
antialias
)
;
cg_context
.
set_rgb_fill_color
(
bg_color
bg_color
bg_color
bg_alpha
)
;
let
rect
=
CGRect
{
origin
:
CGPoint
{
x
:
0
.
0
y
:
0
.
0
}
size
:
CGSize
{
width
:
metrics
.
rasterized_width
as
f64
height
:
metrics
.
rasterized_height
as
f64
}
}
;
cg_context
.
set_blend_mode
(
CGBlendMode
:
:
Copy
)
;
cg_context
.
fill_rect
(
rect
)
;
cg_context
.
set_blend_mode
(
CGBlendMode
:
:
Normal
)
;
cg_context
.
set_rgb_fill_color
(
text_color
text_color
text_color
1
.
0
)
;
cg_context
.
set_text_drawing_mode
(
CGTextDrawingMode
:
:
CGTextFill
)
;
let
mut
draw_origin
=
CGPoint
{
x
:
-
metrics
.
rasterized_left
as
f64
+
x_offset
+
tx
y
:
metrics
.
rasterized_descent
as
f64
-
y_offset
-
ty
}
;
if
let
Some
(
transform
)
=
transform
{
cg_context
.
set_text_matrix
(
&
transform
)
;
draw_origin
=
draw_origin
.
apply_transform
(
&
transform
.
invert
(
)
)
;
}
else
{
cg_context
.
set_text_matrix
(
&
CG_AFFINE_TRANSFORM_IDENTITY
)
;
}
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
draw_origin
]
cg_context
.
clone
(
)
)
;
for
i
in
1
.
.
=
extra_strikes
{
let
origin
=
CGPoint
{
x
:
draw_origin
.
x
+
i
as
f64
*
pixel_step
y
:
draw_origin
.
y
}
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
origin
]
cg_context
.
clone
(
)
)
;
}
}
let
mut
rasterized_pixels
=
self
.
graphics_context
.
get_rasterized_pixels
(
&
raster_size
glyph_type
)
;
if
glyph_type
=
=
GlyphType
:
:
Vector
{
if
smooth
{
self
.
gamma_lut
.
coregraphics_convert_to_linear
(
&
mut
rasterized_pixels
)
;
}
for
pixel
in
rasterized_pixels
.
chunks_mut
(
4
)
{
if
invert
{
pixel
[
0
]
=
255
-
pixel
[
0
]
;
pixel
[
1
]
=
255
-
pixel
[
1
]
;
pixel
[
2
]
=
255
-
pixel
[
2
]
;
}
pixel
[
3
]
=
pixel
[
1
]
;
}
if
smooth
{
self
.
gamma_correct_pixels
(
&
mut
rasterized_pixels
font
.
render_mode
font
.
color
)
;
}
}
Ok
(
RasterizedGlyph
{
left
:
metrics
.
rasterized_left
as
f32
top
:
metrics
.
rasterized_ascent
as
f32
width
:
metrics
.
rasterized_width
height
:
metrics
.
rasterized_height
scale
:
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
y_scale
.
recip
(
)
as
f32
GlyphType
:
:
Vector
=
>
1
.
0
}
format
:
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
GlyphFormat
:
:
ColorBitmap
GlyphType
:
:
Vector
=
>
font
.
get_glyph_format
(
)
}
bytes
:
rasterized_pixels
}
)
}
}
#
[
allow
(
dead_code
)
]
struct
GraphicsContext
{
vector_context
:
CGContext
vector_context_size
:
Size2D
<
u32
>
bitmap_context
:
CGContext
bitmap_context_size
:
Size2D
<
u32
>
}
impl
GraphicsContext
{
fn
new
(
)
-
>
GraphicsContext
{
let
size
=
Size2D
:
:
new
(
INITIAL_CG_CONTEXT_SIDE_LENGTH
INITIAL_CG_CONTEXT_SIDE_LENGTH
)
;
GraphicsContext
{
vector_context
:
GraphicsContext
:
:
create_cg_context
(
&
size
GlyphType
:
:
Vector
)
vector_context_size
:
size
bitmap_context
:
GraphicsContext
:
:
create_cg_context
(
&
size
GlyphType
:
:
Bitmap
)
bitmap_context_size
:
size
}
}
#
[
allow
(
dead_code
)
]
fn
get_context
(
&
mut
self
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
&
mut
CGContext
{
let
(
cached_context
cached_size
)
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
{
(
&
mut
self
.
vector_context
&
mut
self
.
vector_context_size
)
}
GlyphType
:
:
Bitmap
=
>
{
(
&
mut
self
.
bitmap_context
&
mut
self
.
bitmap_context_size
)
}
}
;
let
rounded_size
=
Size2D
:
:
new
(
size
.
width
.
next_power_of_two
(
)
size
.
height
.
next_power_of_two
(
)
)
;
if
rounded_size
.
width
>
cached_size
.
width
|
|
rounded_size
.
height
>
cached_size
.
height
{
*
cached_size
=
Size2D
:
:
new
(
u32
:
:
max
(
cached_size
.
width
rounded_size
.
width
)
u32
:
:
max
(
cached_size
.
height
rounded_size
.
height
)
)
;
*
cached_context
=
GraphicsContext
:
:
create_cg_context
(
cached_size
glyph_type
)
;
}
cached_context
}
#
[
allow
(
dead_code
)
]
fn
get_rasterized_pixels
(
&
mut
self
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
Vec
<
u8
>
{
let
(
cached_context
cached_size
)
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
(
&
mut
self
.
vector_context
&
self
.
vector_context_size
)
GlyphType
:
:
Bitmap
=
>
(
&
mut
self
.
bitmap_context
&
self
.
bitmap_context_size
)
}
;
let
cached_data
=
cached_context
.
data
(
)
;
let
cached_stride
=
cached_size
.
width
as
usize
*
4
;
let
result_len
=
size
.
width
as
usize
*
size
.
height
as
usize
*
4
;
let
mut
result
=
Vec
:
:
with_capacity
(
result_len
)
;
for
y
in
(
cached_size
.
height
-
size
.
height
)
.
.
cached_size
.
height
{
let
cached_start
=
y
as
usize
*
cached_stride
;
let
cached_end
=
cached_start
+
size
.
width
as
usize
*
4
;
result
.
extend_from_slice
(
&
cached_data
[
cached_start
.
.
cached_end
]
)
;
}
debug_assert_eq
!
(
result
.
len
(
)
result_len
)
;
result
}
fn
create_cg_context
(
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
CGContext
{
let
color_type
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
kCGImageAlphaNoneSkipFirst
GlyphType
:
:
Bitmap
=
>
kCGImageAlphaPremultipliedFirst
}
;
CGContext
:
:
create_bitmap_context
(
None
size
.
width
as
usize
size
.
height
as
usize
8
size
.
width
as
usize
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGBitmapByteOrder32Little
|
color_type
)
}
}
#
[
derive
(
Clone
Copy
PartialEq
Debug
)
]
enum
GlyphType
{
Vector
Bitmap
}
#
[
allow
(
non_snake_case
)
]
fn
CFData_wrapping_arc_vec
(
buffer
:
Arc
<
Vec
<
u8
>
>
)
-
>
CFData
{
use
core_foundation
:
:
base
:
:
*
;
use
core_foundation
:
:
data
:
:
CFDataRef
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
extern
"
C
"
{
pub
fn
CFDataCreateWithBytesNoCopy
(
allocator
:
CFAllocatorRef
bytes
:
*
const
u8
length
:
CFIndex
allocator
:
CFAllocatorRef
)
-
>
CFDataRef
;
}
unsafe
{
let
ptr
=
(
*
buffer
)
.
as_ptr
(
)
as
*
const
_
;
let
len
=
buffer
.
len
(
)
.
to_CFIndex
(
)
;
let
info
=
Arc
:
:
into_raw
(
buffer
)
as
*
mut
c_void
;
extern
"
C
"
fn
deallocate
(
_
:
*
mut
c_void
info
:
*
mut
c_void
)
{
unsafe
{
drop
(
Arc
:
:
from_raw
(
info
as
*
mut
Vec
<
u8
>
)
)
;
}
}
let
allocator
=
CFAllocator
:
:
new
(
CFAllocatorContext
{
info
:
info
version
:
0
retain
:
None
reallocate
:
None
release
:
None
copyDescription
:
None
allocate
:
None
deallocate
:
Some
(
deallocate
)
preferredSize
:
None
}
)
;
let
data_ref
=
CFDataCreateWithBytesNoCopy
(
kCFAllocatorDefault
ptr
len
allocator
.
as_CFTypeRef
(
)
)
;
TCFType
:
:
wrap_under_create_rule
(
data_ref
)
}
}
fn
create_font_descriptor
(
cf_data
:
CFData
)
-
>
Result
<
CTFontDescriptor
(
)
>
{
use
core_text
:
:
font_descriptor
:
:
CTFontDescriptorRef
;
use
core_foundation
:
:
data
:
:
CFDataRef
;
extern
{
pub
fn
CTFontManagerCreateFontDescriptorFromData
(
data
:
CFDataRef
)
-
>
CTFontDescriptorRef
;
}
unsafe
{
let
ct_font_descriptor_ref
=
CTFontManagerCreateFontDescriptorFromData
(
cf_data
.
as_concrete_TypeRef
(
)
)
;
if
ct_font_descriptor_ref
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
CTFontDescriptor
:
:
wrap_under_create_rule
(
ct_font_descriptor_ref
)
)
}
}
fn
create_copy_with_attributes
(
desc
:
&
CTFontDescriptor
attr
:
CFDictionary
)
-
>
Result
<
CTFontDescriptor
(
)
>
{
unsafe
{
let
ct_font_descriptor_ref
=
CTFontDescriptorCreateCopyWithAttributes
(
desc
.
as_concrete_TypeRef
(
)
attr
.
as_concrete_TypeRef
(
)
)
;
if
ct_font_descriptor_ref
.
is_null
(
)
{
return
Err
(
(
)
)
;
}
Ok
(
CTFontDescriptor
:
:
wrap_under_create_rule
(
ct_font_descriptor_ref
)
)
}
}
