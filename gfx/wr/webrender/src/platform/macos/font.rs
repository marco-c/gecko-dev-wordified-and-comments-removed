use
api
:
:
{
ColorF
ColorU
FontKey
FontRenderMode
FontSize
GlyphDimensions
}
;
use
api
:
:
{
FontInstanceFlags
FontVariation
NativeFontHandle
}
;
use
core_foundation
:
:
data
:
:
CFData
;
use
core_foundation
:
:
base
:
:
TCFType
;
use
core_foundation
:
:
dictionary
:
:
CFDictionary
;
use
core_foundation
:
:
number
:
:
{
CFNumber
}
;
use
core_foundation
:
:
string
:
:
CFString
;
use
core_graphics
:
:
base
:
:
{
kCGImageAlphaNoneSkipFirst
kCGImageAlphaPremultipliedFirst
}
;
use
core_graphics
:
:
base
:
:
{
kCGBitmapByteOrder32Little
}
;
use
core_graphics
:
:
color_space
:
:
CGColorSpace
;
use
core_graphics
:
:
context
:
:
CGContext
;
use
core_graphics
:
:
context
:
:
{
CGBlendMode
CGTextDrawingMode
}
;
use
core_graphics
:
:
font
:
:
{
CGFont
CGGlyph
}
;
use
core_graphics
:
:
geometry
:
:
{
CGAffineTransform
CGPoint
CGSize
}
;
use
core_graphics
:
:
geometry
:
:
{
CG_AFFINE_TRANSFORM_IDENTITY
CGRect
}
;
use
core_text
;
use
core_text
:
:
font
:
:
CTFont
;
use
core_text
:
:
font_descriptor
:
:
{
CTFontDescriptor
kCTFontDefaultOrientation
kCTFontVariationAttribute
}
;
use
core_text
:
:
font_manager
;
use
euclid
:
:
default
:
:
Size2D
;
use
crate
:
:
gamma_lut
:
:
{
ColorLut
GammaLut
}
;
use
crate
:
:
glyph_rasterizer
:
:
{
FontInstance
FontTransform
GlyphKey
}
;
use
crate
:
:
glyph_rasterizer
:
:
{
GlyphFormat
GlyphRasterError
GlyphRasterResult
RasterizedGlyph
}
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
ResourceCacheError
}
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
sync
:
:
Arc
;
const
INITIAL_CG_CONTEXT_SIDE_LENGTH
:
u32
=
32
;
pub
struct
FontContext
{
ct_font_descs
:
FastHashMap
<
FontKey
CTFontDescriptor
>
ct_fonts
:
FastHashMap
<
(
FontKey
FontSize
Vec
<
FontVariation
>
)
CTFont
>
#
[
allow
(
dead_code
)
]
graphics_context
:
GraphicsContext
#
[
allow
(
dead_code
)
]
gamma_lut
:
GammaLut
}
unsafe
impl
Send
for
FontContext
{
}
struct
GlyphMetrics
{
rasterized_left
:
i32
#
[
allow
(
dead_code
)
]
rasterized_descent
:
i32
rasterized_ascent
:
i32
rasterized_width
:
i32
rasterized_height
:
i32
advance
:
f32
}
fn
determine_font_smoothing_mode
(
)
-
>
Option
<
FontRenderMode
>
{
let
mut
smooth_context
=
CGContext
:
:
create_bitmap_context
(
None
12
12
8
12
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGImageAlphaNoneSkipFirst
|
kCGBitmapByteOrder32Little
)
;
smooth_context
.
set_should_smooth_fonts
(
true
)
;
smooth_context
.
set_should_antialias
(
true
)
;
smooth_context
.
set_rgb_fill_color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
let
mut
gray_context
=
CGContext
:
:
create_bitmap_context
(
None
12
12
8
12
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGImageAlphaNoneSkipFirst
|
kCGBitmapByteOrder32Little
)
;
gray_context
.
set_should_smooth_fonts
(
false
)
;
gray_context
.
set_should_antialias
(
true
)
;
gray_context
.
set_rgb_fill_color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
objc
:
:
rc
:
:
autoreleasepool
(
|
|
{
let
ct_font
=
core_text
:
:
font
:
:
new_from_name
(
"
Lucida
Grande
"
12
.
)
.
unwrap
(
)
;
let
point
=
CGPoint
{
x
:
0
.
y
:
0
.
}
;
let
glyph
=
'
X
'
as
CGGlyph
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
point
]
smooth_context
.
clone
(
)
)
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
point
]
gray_context
.
clone
(
)
)
;
}
)
;
let
mut
mode
=
None
;
for
(
smooth
gray
)
in
smooth_context
.
data
(
)
.
chunks
(
4
)
.
zip
(
gray_context
.
data
(
)
.
chunks
(
4
)
)
{
if
smooth
[
0
]
!
=
smooth
[
1
]
|
|
smooth
[
1
]
!
=
smooth
[
2
]
{
return
Some
(
FontRenderMode
:
:
Subpixel
)
;
}
if
smooth
[
0
]
!
=
gray
[
0
]
|
|
smooth
[
1
]
!
=
gray
[
1
]
|
|
smooth
[
2
]
!
=
gray
[
2
]
{
mode
=
Some
(
FontRenderMode
:
:
Alpha
)
;
}
}
return
mode
;
}
lazy_static
!
{
static
ref
FONT_SMOOTHING_MODE
:
Option
<
FontRenderMode
>
=
determine_font_smoothing_mode
(
)
;
}
fn
should_use_white_on_black
(
color
:
ColorU
)
-
>
bool
{
let
(
r
g
b
)
=
(
color
.
r
as
u32
color
.
g
as
u32
color
.
b
as
u32
)
;
r
>
=
85
&
&
g
>
=
85
&
&
b
>
=
85
&
&
r
+
g
+
b
>
=
2
*
255
}
fn
get_glyph_metrics
(
ct_font
:
&
CTFont
transform
:
Option
<
&
CGAffineTransform
>
glyph
:
CGGlyph
x_offset
:
f64
y_offset
:
f64
extra_width
:
f64
)
-
>
GlyphMetrics
{
let
mut
bounds
=
ct_font
.
get_bounding_rects_for_glyphs
(
kCTFontDefaultOrientation
&
[
glyph
]
)
;
if
bounds
.
origin
.
x
.
is_nan
(
)
|
|
bounds
.
origin
.
y
.
is_nan
(
)
|
|
bounds
.
size
.
width
.
is_nan
(
)
|
|
bounds
.
size
.
height
.
is_nan
(
)
{
return
GlyphMetrics
{
rasterized_left
:
0
rasterized_width
:
0
rasterized_height
:
0
rasterized_ascent
:
0
rasterized_descent
:
0
advance
:
0
.
0
}
;
}
let
mut
advance
=
CGSize
{
width
:
0
.
0
height
:
0
.
0
}
;
unsafe
{
ct_font
.
get_advances_for_glyphs
(
kCTFontDefaultOrientation
&
glyph
&
mut
advance
1
)
;
}
if
bounds
.
size
.
width
>
0
.
0
{
bounds
.
size
.
width
+
=
extra_width
;
}
if
advance
.
width
>
0
.
0
{
advance
.
width
+
=
extra_width
;
}
if
let
Some
(
transform
)
=
transform
{
bounds
=
bounds
.
apply_transform
(
transform
)
;
}
let
mut
left
=
bounds
.
origin
.
x
.
floor
(
)
as
i32
;
let
mut
bottom
=
bounds
.
origin
.
y
.
floor
(
)
as
i32
;
let
mut
right
=
(
bounds
.
origin
.
x
+
bounds
.
size
.
width
+
x_offset
)
.
ceil
(
)
as
i32
;
let
mut
top
=
(
bounds
.
origin
.
y
+
bounds
.
size
.
height
+
y_offset
)
.
ceil
(
)
as
i32
;
left
-
=
1
;
bottom
-
=
1
;
right
+
=
1
;
top
+
=
1
;
let
width
=
right
-
left
;
let
height
=
top
-
bottom
;
GlyphMetrics
{
rasterized_left
:
left
rasterized_width
:
width
rasterized_height
:
height
rasterized_ascent
:
top
rasterized_descent
:
-
bottom
advance
:
advance
.
width
as
f32
}
}
fn
new_ct_font_with_variations
(
ct_font_desc
:
&
CTFontDescriptor
size
:
f64
variations
:
&
[
FontVariation
]
)
-
>
CTFont
{
let
ct_font
=
core_text
:
:
font
:
:
new_from_descriptor
(
ct_font_desc
size
)
;
if
variations
.
is_empty
(
)
{
return
ct_font
;
}
let
mut
vals
:
Vec
<
(
CFNumber
CFNumber
)
>
=
Vec
:
:
with_capacity
(
variations
.
len
(
)
as
usize
)
;
for
variation
in
variations
{
vals
.
push
(
(
CFNumber
:
:
from
(
variation
.
tag
as
i64
)
CFNumber
:
:
from
(
variation
.
value
as
f64
)
)
)
;
}
if
vals
.
is_empty
(
)
{
return
ct_font
;
}
let
vals_dict
=
CFDictionary
:
:
from_CFType_pairs
(
&
vals
)
;
let
variation_attribute
=
unsafe
{
CFString
:
:
wrap_under_get_rule
(
kCTFontVariationAttribute
)
}
;
let
attrs_dict
=
CFDictionary
:
:
from_CFType_pairs
(
&
[
(
variation_attribute
vals_dict
)
]
)
;
let
ct_var_font_desc
=
ct_font
.
copy_descriptor
(
)
.
create_copy_with_attributes
(
attrs_dict
.
to_untyped
(
)
)
.
unwrap
(
)
;
core_text
:
:
font
:
:
new_from_descriptor
(
&
ct_var_font_desc
size
)
}
fn
is_bitmap_font
(
font
:
&
FontInstance
)
-
>
bool
{
font
.
flags
.
contains
(
FontInstanceFlags
:
:
EMBEDDED_BITMAPS
)
}
impl
FontContext
{
pub
fn
new
(
)
-
>
Result
<
FontContext
ResourceCacheError
>
{
debug
!
(
"
Test
for
subpixel
AA
support
:
{
:
?
}
"
*
FONT_SMOOTHING_MODE
)
;
let
contrast
=
0
.
0
;
let
gamma
=
0
.
0
;
Ok
(
FontContext
{
ct_font_descs
:
FastHashMap
:
:
default
(
)
ct_fonts
:
FastHashMap
:
:
default
(
)
graphics_context
:
GraphicsContext
:
:
new
(
)
gamma_lut
:
GammaLut
:
:
new
(
contrast
gamma
gamma
)
}
)
}
pub
fn
add_raw_font
(
&
mut
self
font_key
:
&
FontKey
bytes
:
Arc
<
Vec
<
u8
>
>
index
:
u32
)
{
if
self
.
ct_font_descs
.
contains_key
(
font_key
)
{
return
;
}
assert_eq
!
(
index
0
)
;
let
data
=
CFData
:
:
from_arc
(
bytes
)
;
let
ct_font_desc
=
match
font_manager
:
:
create_font_descriptor_with_data
(
data
)
{
Err
(
_
)
=
>
return
Ok
(
cg_font
)
=
>
cg_font
}
;
self
.
ct_font_descs
.
insert
(
*
font_key
ct_font_desc
)
;
}
pub
fn
add_native_font
(
&
mut
self
font_key
:
&
FontKey
native_font_handle
:
NativeFontHandle
)
{
if
self
.
ct_font_descs
.
contains_key
(
font_key
)
{
return
;
}
let
cf_name
=
CFString
:
:
new
(
&
native_font_handle
.
name
)
;
let
desc
=
if
native_font_handle
.
name
.
starts_with
(
'
.
'
)
{
let
cg_font
=
match
CGFont
:
:
from_name
(
&
cf_name
)
{
Ok
(
cg_font
)
=
>
cg_font
Err
(
_
)
=
>
{
CGFont
:
:
from_name
(
&
CFString
:
:
from_static_string
(
"
Lucida
Grande
"
)
)
.
expect
(
"
couldn
'
t
find
font
with
postscript
name
and
couldn
'
t
load
fallback
font
"
)
}
}
;
core_text
:
:
font
:
:
new_from_CGFont
(
&
cg_font
0
.
)
.
copy_descriptor
(
)
}
else
{
core_text
:
:
font_descriptor
:
:
new_from_postscript_name
(
&
cf_name
)
}
;
self
.
ct_font_descs
.
insert
(
*
font_key
desc
)
;
}
pub
fn
delete_font
(
&
mut
self
font_key
:
&
FontKey
)
{
if
let
Some
(
_
)
=
self
.
ct_font_descs
.
remove
(
font_key
)
{
self
.
ct_fonts
.
retain
(
|
k
_
|
k
.
0
!
=
*
font_key
)
;
}
}
pub
fn
delete_font_instance
(
&
mut
self
instance
:
&
FontInstance
)
{
let
size
=
FontSize
:
:
from_f64_px
(
instance
.
get_transformed_size
(
)
)
;
self
.
ct_fonts
.
remove
(
&
(
instance
.
font_key
size
instance
.
variations
.
clone
(
)
)
)
;
}
fn
get_ct_font
(
&
mut
self
font_key
:
FontKey
size
:
f64
variations
:
&
[
FontVariation
]
)
-
>
Option
<
CTFont
>
{
objc
:
:
rc
:
:
autoreleasepool
(
|
|
{
match
self
.
ct_fonts
.
entry
(
(
font_key
FontSize
:
:
from_f64_px
(
size
)
variations
.
to_vec
(
)
)
)
{
Entry
:
:
Occupied
(
entry
)
=
>
Some
(
(
*
entry
.
get
(
)
)
.
clone
(
)
)
Entry
:
:
Vacant
(
entry
)
=
>
{
let
ct_font_desc
=
self
.
ct_font_descs
.
get
(
&
font_key
)
?
;
let
ct_font
=
new_ct_font_with_variations
(
ct_font_desc
size
variations
)
;
entry
.
insert
(
ct_font
.
clone
(
)
)
;
Some
(
ct_font
)
}
}
}
)
}
pub
fn
get_glyph_index
(
&
mut
self
font_key
:
FontKey
ch
:
char
)
-
>
Option
<
u32
>
{
let
character
=
ch
as
u16
;
let
mut
glyph
=
0
;
self
.
get_ct_font
(
font_key
16
.
0
&
[
]
)
.
and_then
(
|
ct_font
|
{
unsafe
{
let
result
=
ct_font
.
get_glyphs_for_characters
(
&
character
&
mut
glyph
1
)
;
if
result
{
Some
(
glyph
as
u32
)
}
else
{
None
}
}
}
)
}
pub
fn
get_glyph_dimensions
(
&
mut
self
font
:
&
FontInstance
key
:
&
GlyphKey
)
-
>
Option
<
GlyphDimensions
>
{
let
(
x_scale
y_scale
)
=
font
.
transform
.
compute_scale
(
)
.
unwrap_or
(
(
1
.
0
1
.
0
)
)
;
let
size
=
font
.
size
.
to_f64_px
(
)
*
y_scale
;
self
.
get_ct_font
(
font
.
font_key
size
&
font
.
variations
)
.
and_then
(
|
ct_font
|
{
let
glyph
=
key
.
index
(
)
as
CGGlyph
;
let
bitmap
=
is_bitmap_font
(
font
)
;
let
(
mut
shape
(
x_offset
y_offset
)
)
=
if
bitmap
{
(
FontTransform
:
:
identity
(
)
(
0
.
0
0
.
0
)
)
}
else
{
(
font
.
transform
.
invert_scale
(
y_scale
y_scale
)
font
.
get_subpx_offset
(
key
)
)
}
;
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_X
)
{
shape
=
shape
.
flip_x
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_Y
)
{
shape
=
shape
.
flip_y
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
TRANSPOSE
)
{
shape
=
shape
.
swap_xy
(
)
;
}
let
(
mut
tx
mut
ty
)
=
(
0
.
0
0
.
0
)
;
if
font
.
synthetic_italics
.
is_enabled
(
)
{
let
(
shape_
(
tx_
ty_
)
)
=
font
.
synthesize_italics
(
shape
size
)
;
shape
=
shape_
;
tx
=
tx_
;
ty
=
ty_
;
}
let
transform
=
if
!
shape
.
is_identity
(
)
|
|
(
tx
ty
)
!
=
(
0
.
0
0
.
0
)
{
Some
(
CGAffineTransform
{
a
:
shape
.
scale_x
as
f64
b
:
-
shape
.
skew_y
as
f64
c
:
-
shape
.
skew_x
as
f64
d
:
shape
.
scale_y
as
f64
tx
:
tx
ty
:
-
ty
}
)
}
else
{
None
}
;
let
(
strike_scale
pixel_step
)
=
if
bitmap
{
(
y_scale
1
.
0
)
}
else
{
(
x_scale
y_scale
/
x_scale
)
}
;
let
extra_strikes
=
font
.
get_extra_strikes
(
FontInstanceFlags
:
:
SYNTHETIC_BOLD
|
FontInstanceFlags
:
:
MULTISTRIKE_BOLD
strike_scale
)
;
let
metrics
=
get_glyph_metrics
(
&
ct_font
transform
.
as_ref
(
)
glyph
x_offset
y_offset
extra_strikes
as
f64
*
pixel_step
)
;
if
metrics
.
rasterized_width
=
=
0
|
|
metrics
.
rasterized_height
=
=
0
{
None
}
else
{
Some
(
GlyphDimensions
{
left
:
metrics
.
rasterized_left
top
:
metrics
.
rasterized_ascent
width
:
metrics
.
rasterized_width
height
:
metrics
.
rasterized_height
advance
:
metrics
.
advance
}
)
}
}
)
}
fn
gamma_correct_pixels
(
&
self
pixels
:
&
mut
Vec
<
u8
>
render_mode
:
FontRenderMode
color
:
ColorU
)
{
match
render_mode
{
FontRenderMode
:
:
Alpha
=
>
{
self
.
gamma_lut
.
preblend_grayscale
(
pixels
color
)
;
}
FontRenderMode
:
:
Subpixel
=
>
{
self
.
gamma_lut
.
preblend
(
pixels
color
)
;
}
_
=
>
{
}
}
}
#
[
allow
(
dead_code
)
]
fn
print_glyph_data
(
&
mut
self
data
:
&
[
u8
]
width
:
usize
height
:
usize
)
{
debug
!
(
"
Width
is
:
{
:
?
}
height
:
{
:
?
}
"
width
height
)
;
for
i
in
0
.
.
height
{
let
current_height
=
i
*
width
*
4
;
for
pixel
in
data
[
current_height
.
.
current_height
+
(
width
*
4
)
]
.
chunks
(
4
)
{
let
b
=
pixel
[
0
]
;
let
g
=
pixel
[
1
]
;
let
r
=
pixel
[
2
]
;
let
a
=
pixel
[
3
]
;
debug
!
(
"
(
{
}
{
}
{
}
{
}
)
"
r
g
b
a
)
;
}
}
}
pub
fn
prepare_font
(
font
:
&
mut
FontInstance
)
{
if
is_bitmap_font
(
font
)
{
font
.
render_mode
=
FontRenderMode
:
:
Mono
;
font
.
disable_subpixel_position
(
)
;
return
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
|
|
font
.
render_mode
=
=
FontRenderMode
:
:
Subpixel
{
match
*
FONT_SMOOTHING_MODE
{
Some
(
mode
)
=
>
{
font
.
render_mode
=
font
.
render_mode
.
limit_by
(
mode
)
;
font
.
flags
.
insert
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
}
None
=
>
{
font
.
render_mode
=
font
.
render_mode
.
limit_by
(
FontRenderMode
:
:
Alpha
)
;
font
.
flags
.
remove
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
}
}
}
match
font
.
render_mode
{
FontRenderMode
:
:
Mono
=
>
{
font
.
color
=
ColorU
:
:
new
(
255
255
255
255
)
;
font
.
disable_subpixel_position
(
)
;
}
FontRenderMode
:
:
Alpha
=
>
{
font
.
color
=
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
{
let
ColorU
{
g
a
.
.
}
=
font
.
color
.
luminance_color
(
)
.
quantized_ceil
(
)
;
let
rb
=
if
should_use_white_on_black
(
font
.
color
)
{
255
}
else
{
0
}
;
ColorU
:
:
new
(
rb
g
rb
a
)
}
else
{
ColorU
:
:
new
(
255
255
255
255
)
}
;
}
FontRenderMode
:
:
Subpixel
=
>
{
font
.
color
=
if
should_use_white_on_black
(
font
.
color
)
{
font
.
color
.
quantized_ceil
(
)
}
else
{
font
.
color
.
quantized_floor
(
)
}
;
}
}
}
pub
fn
rasterize_glyph
(
&
mut
self
font
:
&
FontInstance
key
:
&
GlyphKey
)
-
>
GlyphRasterResult
{
objc
:
:
rc
:
:
autoreleasepool
(
|
|
{
let
(
x_scale
y_scale
)
=
font
.
transform
.
compute_scale
(
)
.
unwrap_or
(
(
1
.
0
1
.
0
)
)
;
let
size
=
font
.
size
.
to_f64_px
(
)
*
y_scale
;
let
ct_font
=
self
.
get_ct_font
(
font
.
font_key
size
&
font
.
variations
)
.
ok_or
(
GlyphRasterError
:
:
LoadFailed
)
?
;
let
glyph_type
=
if
is_bitmap_font
(
font
)
{
GlyphType
:
:
Bitmap
}
else
{
GlyphType
:
:
Vector
}
;
let
(
mut
shape
(
x_offset
y_offset
)
)
=
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
(
FontTransform
:
:
identity
(
)
(
0
.
0
0
.
0
)
)
GlyphType
:
:
Vector
=
>
{
(
font
.
transform
.
invert_scale
(
y_scale
y_scale
)
font
.
get_subpx_offset
(
key
)
)
}
}
;
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_X
)
{
shape
=
shape
.
flip_x
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FLIP_Y
)
{
shape
=
shape
.
flip_y
(
)
;
}
if
font
.
flags
.
contains
(
FontInstanceFlags
:
:
TRANSPOSE
)
{
shape
=
shape
.
swap_xy
(
)
;
}
let
(
mut
tx
mut
ty
)
=
(
0
.
0
0
.
0
)
;
if
font
.
synthetic_italics
.
is_enabled
(
)
{
let
(
shape_
(
tx_
ty_
)
)
=
font
.
synthesize_italics
(
shape
size
)
;
shape
=
shape_
;
tx
=
tx_
;
ty
=
ty_
;
}
let
transform
=
if
!
shape
.
is_identity
(
)
|
|
(
tx
ty
)
!
=
(
0
.
0
0
.
0
)
{
Some
(
CGAffineTransform
{
a
:
shape
.
scale_x
as
f64
b
:
-
shape
.
skew_y
as
f64
c
:
-
shape
.
skew_x
as
f64
d
:
shape
.
scale_y
as
f64
tx
:
tx
ty
:
-
ty
}
)
}
else
{
None
}
;
let
glyph
=
key
.
index
(
)
as
CGGlyph
;
let
(
strike_scale
pixel_step
)
=
if
glyph_type
=
=
GlyphType
:
:
Bitmap
{
(
y_scale
1
.
0
)
}
else
{
(
x_scale
y_scale
/
x_scale
)
}
;
let
extra_strikes
=
font
.
get_extra_strikes
(
FontInstanceFlags
:
:
SYNTHETIC_BOLD
|
FontInstanceFlags
:
:
MULTISTRIKE_BOLD
strike_scale
)
;
let
metrics
=
get_glyph_metrics
(
&
ct_font
transform
.
as_ref
(
)
glyph
x_offset
y_offset
extra_strikes
as
f64
*
pixel_step
)
;
if
metrics
.
rasterized_width
=
=
0
|
|
metrics
.
rasterized_height
=
=
0
{
return
Err
(
GlyphRasterError
:
:
LoadFailed
)
;
}
let
raster_size
=
Size2D
:
:
new
(
metrics
.
rasterized_width
as
u32
metrics
.
rasterized_height
as
u32
)
;
let
use_white_on_black
=
should_use_white_on_black
(
font
.
color
)
;
let
use_font_smoothing
=
font
.
flags
.
contains
(
FontInstanceFlags
:
:
FONT_SMOOTHING
)
;
let
(
antialias
smooth
text_color
bg_color
invert
)
=
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
(
true
false
ColorF
:
:
from
(
font
.
color
)
ColorF
:
:
TRANSPARENT
false
)
GlyphType
:
:
Vector
=
>
{
match
(
font
.
render_mode
use_font_smoothing
)
{
(
FontRenderMode
:
:
Subpixel
_
)
|
(
FontRenderMode
:
:
Alpha
true
)
=
>
if
use_white_on_black
{
(
true
true
ColorF
:
:
WHITE
ColorF
:
:
BLACK
false
)
}
else
{
(
true
true
ColorF
:
:
BLACK
ColorF
:
:
WHITE
true
)
}
(
FontRenderMode
:
:
Alpha
false
)
=
>
(
true
false
ColorF
:
:
BLACK
ColorF
:
:
WHITE
true
)
(
FontRenderMode
:
:
Mono
_
)
=
>
(
false
false
ColorF
:
:
BLACK
ColorF
:
:
WHITE
true
)
}
}
}
;
{
let
cg_context
=
self
.
graphics_context
.
get_context
(
&
raster_size
glyph_type
)
;
cg_context
.
set_allows_font_subpixel_positioning
(
true
)
;
cg_context
.
set_should_subpixel_position_fonts
(
true
)
;
cg_context
.
set_allows_font_subpixel_quantization
(
false
)
;
cg_context
.
set_should_subpixel_quantize_fonts
(
false
)
;
cg_context
.
set_should_smooth_fonts
(
smooth
)
;
cg_context
.
set_should_antialias
(
antialias
)
;
cg_context
.
set_rgb_fill_color
(
bg_color
.
r
.
into
(
)
bg_color
.
g
.
into
(
)
bg_color
.
b
.
into
(
)
bg_color
.
a
.
into
(
)
)
;
let
rect
=
CGRect
{
origin
:
CGPoint
{
x
:
0
.
0
y
:
0
.
0
}
size
:
CGSize
{
width
:
metrics
.
rasterized_width
as
f64
height
:
metrics
.
rasterized_height
as
f64
}
}
;
cg_context
.
set_blend_mode
(
CGBlendMode
:
:
Copy
)
;
cg_context
.
fill_rect
(
rect
)
;
cg_context
.
set_blend_mode
(
CGBlendMode
:
:
Normal
)
;
cg_context
.
set_rgb_fill_color
(
text_color
.
r
.
into
(
)
text_color
.
g
.
into
(
)
text_color
.
b
.
into
(
)
1
.
0
)
;
cg_context
.
set_text_drawing_mode
(
CGTextDrawingMode
:
:
CGTextFill
)
;
let
mut
draw_origin
=
CGPoint
{
x
:
-
metrics
.
rasterized_left
as
f64
+
x_offset
+
tx
y
:
metrics
.
rasterized_descent
as
f64
-
y_offset
-
ty
}
;
if
let
Some
(
transform
)
=
transform
{
cg_context
.
set_text_matrix
(
&
transform
)
;
draw_origin
=
draw_origin
.
apply_transform
(
&
transform
.
invert
(
)
)
;
}
else
{
cg_context
.
set_text_matrix
(
&
CG_AFFINE_TRANSFORM_IDENTITY
)
;
}
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
draw_origin
]
cg_context
.
clone
(
)
)
;
for
i
in
1
.
.
=
extra_strikes
{
let
origin
=
CGPoint
{
x
:
draw_origin
.
x
+
i
as
f64
*
pixel_step
y
:
draw_origin
.
y
}
;
ct_font
.
draw_glyphs
(
&
[
glyph
]
&
[
origin
]
cg_context
.
clone
(
)
)
;
}
}
let
mut
rasterized_pixels
=
self
.
graphics_context
.
get_rasterized_pixels
(
&
raster_size
glyph_type
)
;
if
glyph_type
=
=
GlyphType
:
:
Vector
{
if
smooth
{
self
.
gamma_lut
.
coregraphics_convert_to_linear
(
&
mut
rasterized_pixels
)
;
}
for
pixel
in
rasterized_pixels
.
chunks_mut
(
4
)
{
if
invert
{
pixel
[
0
]
=
255
-
pixel
[
0
]
;
pixel
[
1
]
=
255
-
pixel
[
1
]
;
pixel
[
2
]
=
255
-
pixel
[
2
]
;
}
pixel
[
3
]
=
pixel
[
1
]
;
}
if
smooth
{
self
.
gamma_correct_pixels
(
&
mut
rasterized_pixels
font
.
render_mode
font
.
color
)
;
}
}
Ok
(
RasterizedGlyph
{
left
:
metrics
.
rasterized_left
as
f32
top
:
metrics
.
rasterized_ascent
as
f32
width
:
metrics
.
rasterized_width
height
:
metrics
.
rasterized_height
scale
:
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
y_scale
.
recip
(
)
as
f32
GlyphType
:
:
Vector
=
>
1
.
0
}
format
:
match
glyph_type
{
GlyphType
:
:
Bitmap
=
>
GlyphFormat
:
:
ColorBitmap
GlyphType
:
:
Vector
=
>
font
.
get_glyph_format
(
)
}
bytes
:
rasterized_pixels
}
)
}
)
}
}
#
[
allow
(
dead_code
)
]
struct
GraphicsContext
{
vector_context
:
CGContext
vector_context_size
:
Size2D
<
u32
>
bitmap_context
:
CGContext
bitmap_context_size
:
Size2D
<
u32
>
}
impl
GraphicsContext
{
fn
new
(
)
-
>
GraphicsContext
{
let
size
=
Size2D
:
:
new
(
INITIAL_CG_CONTEXT_SIDE_LENGTH
INITIAL_CG_CONTEXT_SIDE_LENGTH
)
;
GraphicsContext
{
vector_context
:
GraphicsContext
:
:
create_cg_context
(
&
size
GlyphType
:
:
Vector
)
vector_context_size
:
size
bitmap_context
:
GraphicsContext
:
:
create_cg_context
(
&
size
GlyphType
:
:
Bitmap
)
bitmap_context_size
:
size
}
}
#
[
allow
(
dead_code
)
]
fn
get_context
(
&
mut
self
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
&
mut
CGContext
{
let
(
cached_context
cached_size
)
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
{
(
&
mut
self
.
vector_context
&
mut
self
.
vector_context_size
)
}
GlyphType
:
:
Bitmap
=
>
{
(
&
mut
self
.
bitmap_context
&
mut
self
.
bitmap_context_size
)
}
}
;
let
rounded_size
=
Size2D
:
:
new
(
size
.
width
.
next_power_of_two
(
)
size
.
height
.
next_power_of_two
(
)
)
;
if
rounded_size
.
width
>
cached_size
.
width
|
|
rounded_size
.
height
>
cached_size
.
height
{
*
cached_size
=
Size2D
:
:
new
(
u32
:
:
max
(
cached_size
.
width
rounded_size
.
width
)
u32
:
:
max
(
cached_size
.
height
rounded_size
.
height
)
)
;
*
cached_context
=
GraphicsContext
:
:
create_cg_context
(
cached_size
glyph_type
)
;
}
cached_context
}
#
[
allow
(
dead_code
)
]
fn
get_rasterized_pixels
(
&
mut
self
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
Vec
<
u8
>
{
let
(
cached_context
cached_size
)
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
(
&
mut
self
.
vector_context
&
self
.
vector_context_size
)
GlyphType
:
:
Bitmap
=
>
(
&
mut
self
.
bitmap_context
&
self
.
bitmap_context_size
)
}
;
let
cached_data
=
cached_context
.
data
(
)
;
let
cached_stride
=
cached_size
.
width
as
usize
*
4
;
let
result_len
=
size
.
width
as
usize
*
size
.
height
as
usize
*
4
;
let
mut
result
=
Vec
:
:
with_capacity
(
result_len
)
;
for
y
in
(
cached_size
.
height
-
size
.
height
)
.
.
cached_size
.
height
{
let
cached_start
=
y
as
usize
*
cached_stride
;
let
cached_end
=
cached_start
+
size
.
width
as
usize
*
4
;
result
.
extend_from_slice
(
&
cached_data
[
cached_start
.
.
cached_end
]
)
;
}
debug_assert_eq
!
(
result
.
len
(
)
result_len
)
;
result
}
fn
create_cg_context
(
size
:
&
Size2D
<
u32
>
glyph_type
:
GlyphType
)
-
>
CGContext
{
let
color_type
=
match
glyph_type
{
GlyphType
:
:
Vector
=
>
kCGImageAlphaNoneSkipFirst
GlyphType
:
:
Bitmap
=
>
kCGImageAlphaPremultipliedFirst
}
;
CGContext
:
:
create_bitmap_context
(
None
size
.
width
as
usize
size
.
height
as
usize
8
size
.
width
as
usize
*
4
&
CGColorSpace
:
:
create_device_rgb
(
)
kCGBitmapByteOrder32Little
|
color_type
)
}
}
#
[
derive
(
Clone
Copy
PartialEq
Debug
)
]
enum
GlyphType
{
Vector
Bitmap
}
