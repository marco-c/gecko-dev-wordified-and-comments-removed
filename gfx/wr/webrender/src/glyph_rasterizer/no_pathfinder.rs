use
api
:
:
{
ImageDescriptor
ImageFormat
DirtyRect
}
;
use
crate
:
:
device
:
:
TextureFilter
;
use
euclid
:
:
size2
;
use
crate
:
:
gpu_types
:
:
UvRectKind
;
use
rayon
:
:
prelude
:
:
*
;
use
std
:
:
sync
:
:
{
Arc
MutexGuard
}
;
use
crate
:
:
platform
:
:
font
:
:
FontContext
;
use
crate
:
:
glyph_rasterizer
:
:
{
FontInstance
FontContexts
GlyphKey
}
;
use
crate
:
:
glyph_rasterizer
:
:
{
GlyphRasterizer
GlyphRasterJob
GlyphRasterJobs
}
;
use
crate
:
:
glyph_cache
:
:
{
GlyphCache
CachedGlyphInfo
GlyphCacheEntry
}
;
use
crate
:
:
resource_cache
:
:
CachedImageData
;
use
crate
:
:
texture_cache
:
:
{
TextureCache
TextureCacheHandle
Eviction
}
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
render_task
:
:
{
RenderTaskGraph
RenderTaskCache
}
;
use
crate
:
:
profiler
:
:
TextureCacheProfileCounters
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
impl
FontContexts
{
pub
fn
lock_current_context
(
&
self
)
-
>
MutexGuard
<
FontContext
>
{
let
id
=
self
.
current_worker_id
(
)
;
self
.
lock_context
(
id
)
}
pub
(
in
super
)
fn
current_worker_id
(
&
self
)
-
>
Option
<
usize
>
{
self
.
workers
.
current_thread_index
(
)
}
}
impl
GlyphRasterizer
{
pub
fn
request_glyphs
(
&
mut
self
glyph_cache
:
&
mut
GlyphCache
font
:
FontInstance
glyph_keys
:
&
[
GlyphKey
]
texture_cache
:
&
mut
TextureCache
gpu_cache
:
&
mut
GpuCache
_
:
&
mut
RenderTaskCache
_
:
&
mut
RenderTaskGraph
)
{
assert
!
(
self
.
font_contexts
.
lock_shared_context
(
)
.
has_font
(
&
font
.
font_key
)
)
;
let
mut
new_glyphs
=
Vec
:
:
new
(
)
;
let
glyph_key_cache
=
glyph_cache
.
get_glyph_key_cache_for_font_mut
(
font
.
clone
(
)
)
;
for
key
in
glyph_keys
{
match
glyph_key_cache
.
entry
(
key
.
clone
(
)
)
{
Entry
:
:
Occupied
(
entry
)
=
>
{
let
value
=
entry
.
into_mut
(
)
;
match
*
value
{
GlyphCacheEntry
:
:
Cached
(
ref
glyph
)
=
>
{
if
!
texture_cache
.
request
(
&
glyph
.
texture_cache_handle
gpu_cache
)
{
continue
;
}
}
GlyphCacheEntry
:
:
Blank
|
GlyphCacheEntry
:
:
Pending
=
>
continue
}
*
value
=
GlyphCacheEntry
:
:
Pending
;
new_glyphs
.
push
(
(
*
key
)
.
clone
(
)
)
;
}
Entry
:
:
Vacant
(
entry
)
=
>
{
entry
.
insert
(
GlyphCacheEntry
:
:
Pending
)
;
new_glyphs
.
push
(
(
*
key
)
.
clone
(
)
)
;
}
}
}
if
new_glyphs
.
is_empty
(
)
{
return
;
}
self
.
pending_glyphs
+
=
1
;
self
.
request_glyphs_from_backend
(
font
new_glyphs
)
;
}
pub
(
in
super
)
fn
request_glyphs_from_backend
(
&
mut
self
font
:
FontInstance
glyphs
:
Vec
<
GlyphKey
>
)
{
let
font_contexts
=
Arc
:
:
clone
(
&
self
.
font_contexts
)
;
let
glyph_tx
=
self
.
glyph_tx
.
clone
(
)
;
self
.
workers
.
spawn
(
move
|
|
{
let
jobs
=
glyphs
.
par_iter
(
)
.
map
(
|
key
:
&
GlyphKey
|
{
profile_scope
!
(
"
glyph
-
raster
"
)
;
let
mut
context
=
font_contexts
.
lock_current_context
(
)
;
let
mut
job
=
GlyphRasterJob
{
key
:
key
.
clone
(
)
result
:
context
.
rasterize_glyph
(
&
font
key
)
}
;
if
let
Ok
(
ref
mut
glyph
)
=
job
.
result
{
let
bpp
=
4
;
assert_eq
!
(
glyph
.
bytes
.
len
(
)
bpp
*
(
glyph
.
width
*
glyph
.
height
)
as
usize
)
;
assert_eq
!
(
(
glyph
.
left
.
fract
(
)
glyph
.
top
.
fract
(
)
)
(
0
.
0
0
.
0
)
)
;
glyph
.
downscale_bitmap_if_required
(
&
font
)
;
}
job
}
)
.
collect
(
)
;
glyph_tx
.
send
(
GlyphRasterJobs
{
font
jobs
}
)
.
unwrap
(
)
;
}
)
;
}
pub
fn
resolve_glyphs
(
&
mut
self
glyph_cache
:
&
mut
GlyphCache
texture_cache
:
&
mut
TextureCache
gpu_cache
:
&
mut
GpuCache
_
:
&
mut
RenderTaskCache
_
:
&
mut
RenderTaskGraph
_
:
&
mut
TextureCacheProfileCounters
)
{
while
self
.
pending_glyphs
>
0
{
self
.
pending_glyphs
-
=
1
;
let
GlyphRasterJobs
{
font
mut
jobs
}
=
self
.
glyph_rx
.
recv
(
)
.
expect
(
"
BUG
:
Should
be
glyphs
pending
!
"
)
;
jobs
.
sort_by
(
|
a
b
|
a
.
key
.
cmp
(
&
b
.
key
)
)
;
let
glyph_key_cache
=
glyph_cache
.
get_glyph_key_cache_for_font_mut
(
font
)
;
for
GlyphRasterJob
{
key
result
}
in
jobs
{
let
glyph_info
=
match
result
{
Err
(
_
)
=
>
GlyphCacheEntry
:
:
Blank
Ok
(
ref
glyph
)
if
glyph
.
width
=
=
0
|
|
glyph
.
height
=
=
0
=
>
{
GlyphCacheEntry
:
:
Blank
}
Ok
(
glyph
)
=
>
{
let
mut
texture_cache_handle
=
TextureCacheHandle
:
:
invalid
(
)
;
texture_cache
.
request
(
&
texture_cache_handle
gpu_cache
)
;
texture_cache
.
update
(
&
mut
texture_cache_handle
ImageDescriptor
{
size
:
size2
(
glyph
.
width
glyph
.
height
)
stride
:
None
format
:
ImageFormat
:
:
BGRA8
is_opaque
:
false
allow_mipmaps
:
false
offset
:
0
}
TextureFilter
:
:
Linear
Some
(
CachedImageData
:
:
Raw
(
Arc
:
:
new
(
glyph
.
bytes
)
)
)
[
glyph
.
left
-
glyph
.
top
glyph
.
scale
]
DirtyRect
:
:
All
gpu_cache
Some
(
glyph_key_cache
.
eviction_notice
(
)
)
UvRectKind
:
:
Rect
Eviction
:
:
Auto
)
;
GlyphCacheEntry
:
:
Cached
(
CachedGlyphInfo
{
texture_cache_handle
format
:
glyph
.
format
}
)
}
}
;
glyph_key_cache
.
insert
(
key
glyph_info
)
;
}
}
self
.
remove_dead_fonts
(
)
;
}
}
