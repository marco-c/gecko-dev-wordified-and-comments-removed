pub
mod
slice_builder
;
use
api
:
:
{
AlphaType
BorderRadius
ClipMode
ColorF
ColorDepth
DebugFlags
ImageKey
ImageRendering
}
;
use
api
:
:
{
PropertyBindingId
PrimitiveFlags
YuvFormat
YuvRangedColorSpace
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipNodeId
ClipLeafId
ClipItemKind
ClipSpaceConversion
ClipChainInstance
ClipStore
}
;
use
crate
:
:
composite
:
:
{
CompositorKind
CompositeState
CompositorSurfaceKind
ExternalSurfaceDescriptor
}
;
use
crate
:
:
composite
:
:
{
ExternalSurfaceDependency
NativeSurfaceId
NativeTileId
}
;
use
crate
:
:
composite
:
:
{
CompositorClipIndex
CompositorTransformIndex
}
;
use
crate
:
:
composite
:
:
{
CompositeTileDescriptor
CompositeTile
}
;
use
crate
:
:
gpu_types
:
:
ZBufferId
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FrameId
Filter
}
;
use
crate
:
:
invalidation
:
:
{
InvalidationReason
DirtyRegion
PrimitiveCompareResult
}
;
use
crate
:
:
invalidation
:
:
cached_surface
:
:
{
CachedSurface
TileUpdateDirtyContext
TileUpdateDirtyState
PrimitiveDependencyInfo
}
;
use
crate
:
:
invalidation
:
:
compare
:
:
{
PrimitiveDependency
ImageDependency
}
;
use
crate
:
:
invalidation
:
:
compare
:
:
{
SpatialNodeComparer
PrimitiveComparisonKey
}
;
use
crate
:
:
invalidation
:
:
compare
:
:
{
OpacityBindingInfo
ColorBindingInfo
}
;
use
crate
:
:
picture
:
:
{
SurfaceTextureDescriptor
PictureCompositeMode
SurfaceIndex
clamp
}
;
use
crate
:
:
picture
:
:
{
get_relative_scale_offset
PicturePrimitive
}
;
use
crate
:
:
picture
:
:
MAX_COMPOSITOR_SURFACES_SIZE
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
PrimitiveInstanceKind
PrimitiveScratchBuffer
PictureIndex
}
;
use
crate
:
:
prim_store
:
:
{
ColorBindingStorage
ColorBindingIndex
PrimitiveTemplateKind
}
;
use
crate
:
:
print_tree
:
:
{
PrintTreePrinter
PrintTree
}
;
use
crate
:
:
{
profiler
render_backend
:
:
DataStores
}
;
use
crate
:
:
profiler
:
:
TransactionProfile
;
use
crate
:
:
renderer
:
:
GpuBufferBuilderF
;
use
crate
:
:
resource_cache
:
:
{
ResourceCache
ImageRequest
}
;
use
crate
:
:
scene_building
:
:
SliceFlags
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
spatial_tree
:
:
{
SpatialNodeIndex
SpatialTree
}
;
use
crate
:
:
surface
:
:
{
SubpixelMode
SurfaceInfo
}
;
use
crate
:
:
util
:
:
{
ScaleOffset
MatrixHelpers
MaxRect
}
;
use
crate
:
:
visibility
:
:
{
FrameVisibilityContext
FrameVisibilityState
VisibilityState
PrimitiveVisibilityFlags
}
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
euclid
:
:
Box2D
;
use
peek_poke
:
:
{
PeekPoke
ensure_red_zone
}
;
use
std
:
:
fmt
:
:
{
Display
Error
Formatter
}
;
use
std
:
:
{
marker
mem
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
use
self
:
:
slice_builder
:
:
{
TileCacheBuilder
TileCacheConfig
PictureCacheDebugInfo
SliceDebugInfo
DirtyTileDebugInfo
TileDebugInfo
}
;
pub
use
api
:
:
units
:
:
TileOffset
;
pub
use
api
:
:
units
:
:
TileRange
as
TileRect
;
pub
const
MAX_COMPOSITOR_SURFACES
:
usize
=
4
;
pub
const
TILE_SIZE_DEFAULT
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
512
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_HORIZONTAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
32
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_VERTICAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
32
height
:
1024
_unit
:
marker
:
:
PhantomData
}
;
pub
const
MAX_SURFACE_SIZE
:
usize
=
4096
;
static
NEXT_TILE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
Ord
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileId
(
pub
usize
)
;
impl
TileId
{
pub
fn
new
(
)
-
>
TileId
{
TileId
(
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
next_tile_id
(
)
-
>
usize
{
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Hash
Eq
)
]
pub
struct
TileKey
{
pub
tile_offset
:
TileOffset
pub
sub_slice_index
:
SubSliceIndex
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
PeekPoke
)
]
pub
struct
SubSliceIndex
(
pub
u8
)
;
impl
SubSliceIndex
{
pub
const
DEFAULT
:
SubSliceIndex
=
SubSliceIndex
(
0
)
;
pub
fn
new
(
index
:
usize
)
-
>
Self
{
SubSliceIndex
(
index
as
u8
)
}
pub
fn
is_primary
(
&
self
)
-
>
bool
{
self
.
0
=
=
0
}
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
as
usize
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SliceId
(
usize
)
;
impl
SliceId
{
pub
fn
new
(
index
:
usize
)
-
>
Self
{
SliceId
(
index
)
}
}
pub
struct
TileCacheParams
{
pub
debug_flags
:
DebugFlags
pub
slice
:
usize
pub
slice_flags
:
SliceFlags
pub
spatial_node_index
:
SpatialNodeIndex
pub
visibility_node_index
:
SpatialNodeIndex
pub
background_color
:
Option
<
ColorF
>
pub
shared_clip_node_id
:
ClipNodeId
pub
shared_clip_leaf_id
:
Option
<
ClipLeafId
>
pub
virtual_surface_size
:
i32
pub
image_surface_count
:
usize
pub
yuv_image_surface_count
:
usize
}
#
[
derive
(
Debug
)
]
pub
enum
TileSurface
{
Texture
{
descriptor
:
SurfaceTextureDescriptor
}
Color
{
color
:
ColorF
}
}
impl
TileSurface
{
pub
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
TileSurface
:
:
Color
{
.
.
}
=
>
"
Color
"
TileSurface
:
:
Texture
{
.
.
}
=
>
"
Texture
"
}
}
}
pub
struct
Tile
{
pub
tile_offset
:
TileOffset
pub
world_tile_rect
:
WorldRect
pub
device_dirty_rect
:
DeviceRect
pub
world_valid_rect
:
WorldRect
pub
device_valid_rect
:
DeviceRect
pub
surface
:
Option
<
TileSurface
>
pub
is_visible
:
bool
pub
id
:
TileId
pub
is_opaque
:
bool
pub
z_id
:
ZBufferId
pub
cached_surface
:
CachedSurface
}
impl
Tile
{
fn
new
(
tile_offset
:
TileOffset
)
-
>
Self
{
let
id
=
TileId
(
crate
:
:
tile_cache
:
:
next_tile_id
(
)
)
;
Tile
{
tile_offset
world_tile_rect
:
WorldRect
:
:
zero
(
)
world_valid_rect
:
WorldRect
:
:
zero
(
)
device_valid_rect
:
DeviceRect
:
:
zero
(
)
device_dirty_rect
:
DeviceRect
:
:
zero
(
)
surface
:
None
is_visible
:
false
id
is_opaque
:
false
z_id
:
ZBufferId
:
:
invalid
(
)
cached_surface
:
CachedSurface
:
:
new
(
)
}
}
fn
print
(
&
self
pt
:
&
mut
dyn
PrintTreePrinter
)
{
pt
.
new_level
(
format
!
(
"
Tile
{
:
?
}
"
self
.
id
)
)
;
pt
.
add_item
(
format
!
(
"
local_rect
:
{
:
?
}
"
self
.
cached_surface
.
local_rect
)
)
;
self
.
cached_surface
.
print
(
pt
)
;
pt
.
end_level
(
)
;
}
fn
update_content_validity
(
&
mut
self
ctx
:
&
TileUpdateDirtyContext
state
:
&
mut
TileUpdateDirtyState
frame_context
:
&
FrameVisibilityContext
)
{
self
.
cached_surface
.
update_content_validity
(
ctx
state
frame_context
)
;
}
pub
fn
invalidate
(
&
mut
self
invalidation_rect
:
Option
<
PictureRect
>
reason
:
InvalidationReason
)
{
self
.
cached_surface
.
invalidate
(
invalidation_rect
reason
)
;
}
fn
pre_update
(
&
mut
self
ctx
:
&
TilePreUpdateContext
)
{
self
.
cached_surface
.
local_rect
=
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
self
.
tile_offset
.
x
as
f32
*
ctx
.
tile_size
.
width
self
.
tile_offset
.
y
as
f32
*
ctx
.
tile_size
.
height
)
PicturePoint
:
:
new
(
(
self
.
tile_offset
.
x
+
1
)
as
f32
*
ctx
.
tile_size
.
width
(
self
.
tile_offset
.
y
+
1
)
as
f32
*
ctx
.
tile_size
.
height
)
)
;
self
.
world_tile_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
cached_surface
.
local_rect
)
.
expect
(
"
bug
:
map
local
tile
rect
"
)
;
self
.
is_visible
=
self
.
world_tile_rect
.
intersects
(
&
ctx
.
global_screen_world_rect
)
;
self
.
cached_surface
.
pre_update
(
ctx
.
background_color
self
.
cached_surface
.
local_rect
ctx
.
frame_id
self
.
is_visible
)
;
}
fn
add_prim_dependency
(
&
mut
self
info
:
&
PrimitiveDependencyInfo
)
{
if
!
self
.
is_visible
{
return
;
}
self
.
cached_surface
.
add_prim_dependency
(
info
self
.
cached_surface
.
local_rect
)
;
}
fn
update_dirty_and_valid_rects
(
&
mut
self
ctx
:
&
TileUpdateDirtyContext
state
:
&
mut
TileUpdateDirtyState
frame_context
:
&
FrameVisibilityContext
)
{
ensure_red_zone
:
:
<
PrimitiveDependency
>
(
&
mut
self
.
cached_surface
.
current_descriptor
.
dep_data
)
;
state
.
spatial_node_comparer
.
retain_for_frame
(
self
.
cached_surface
.
current_descriptor
.
last_updated_frame_id
)
;
if
!
self
.
is_visible
{
return
;
}
self
.
cached_surface
.
current_descriptor
.
local_valid_rect
=
self
.
cached_surface
.
local_valid_rect
;
self
.
cached_surface
.
current_descriptor
.
local_valid_rect
=
self
.
cached_surface
.
local_rect
.
intersection
(
&
ctx
.
local_rect
)
.
and_then
(
|
r
|
r
.
intersection
(
&
self
.
cached_surface
.
current_descriptor
.
local_valid_rect
)
)
.
unwrap_or_else
(
PictureRect
:
:
zero
)
;
self
.
world_valid_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
cached_surface
.
current_descriptor
.
local_valid_rect
)
.
expect
(
"
bug
:
map
local
valid
rect
"
)
;
let
device_rect
=
(
self
.
world_tile_rect
*
ctx
.
global_device_pixel_scale
)
.
round
(
)
;
self
.
device_valid_rect
=
(
self
.
world_valid_rect
*
ctx
.
global_device_pixel_scale
)
.
round_out
(
)
.
intersection
(
&
device_rect
)
.
unwrap_or_else
(
DeviceRect
:
:
zero
)
;
self
.
update_content_validity
(
ctx
state
frame_context
)
;
}
fn
post_update
(
&
mut
self
ctx
:
&
TilePostUpdateContext
state
:
&
mut
TilePostUpdateState
frame_context
:
&
FrameVisibilityContext
)
{
if
!
self
.
is_visible
{
return
;
}
if
self
.
cached_surface
.
current_descriptor
.
prims
.
is_empty
(
)
|
|
self
.
device_valid_rect
.
is_empty
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
mut
id
.
.
}
.
.
}
)
=
self
.
surface
.
take
(
)
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
self
.
is_visible
=
false
;
return
;
}
let
clipped_rect
=
self
.
cached_surface
.
current_descriptor
.
local_valid_rect
.
intersection
(
&
ctx
.
local_clip_rect
)
.
unwrap_or_else
(
PictureRect
:
:
zero
)
;
let
has_opaque_bg_color
=
self
.
cached_surface
.
background_color
.
map_or
(
false
|
c
|
c
.
a
>
=
1
.
0
)
;
let
has_opaque_backdrop
=
ctx
.
backdrop
.
map_or
(
false
|
b
|
b
.
opaque_rect
.
contains_box
(
&
clipped_rect
)
)
;
let
mut
is_opaque
=
has_opaque_bg_color
|
|
has_opaque_backdrop
;
for
underlay
in
ctx
.
underlays
{
if
clipped_rect
.
intersects
(
&
underlay
.
local_rect
)
{
is_opaque
=
false
;
break
;
}
}
self
.
z_id
=
ctx
.
z_id
;
if
is_opaque
!
=
self
.
is_opaque
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
self
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
self
.
invalidate
(
None
InvalidationReason
:
:
SurfaceOpacityChanged
)
;
self
.
is_opaque
=
is_opaque
;
}
let
(
supports_dirty_rects
supports_simple_prims
)
=
match
state
.
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
|
CompositorKind
:
:
Layer
{
.
.
}
=
>
{
(
frame_context
.
config
.
gpu_supports_render_target_partial_update
true
)
}
CompositorKind
:
:
Native
{
capabilities
.
.
}
=
>
{
(
capabilities
.
max_update_rects
>
0
false
)
}
}
;
if
supports_dirty_rects
{
if
ctx
.
current_tile_size
=
=
state
.
resource_cache
.
picture_textures
.
default_tile_size
(
)
{
let
max_split_level
=
3
;
self
.
cached_surface
.
root
.
maybe_merge_or_split
(
0
&
self
.
cached_surface
.
current_descriptor
.
prims
max_split_level
)
;
}
}
if
!
self
.
cached_surface
.
is_valid
&
&
!
supports_dirty_rects
{
self
.
cached_surface
.
local_dirty_rect
=
self
.
cached_surface
.
local_rect
;
}
let
is_simple_prim
=
ctx
.
backdrop
.
map_or
(
false
|
b
|
b
.
kind
.
is_some
(
)
)
&
&
self
.
cached_surface
.
current_descriptor
.
prims
.
len
(
)
=
=
1
&
&
self
.
is_opaque
&
&
supports_simple_prims
;
let
surface
=
if
is_simple_prim
{
match
ctx
.
backdrop
.
unwrap
(
)
.
kind
{
Some
(
BackdropKind
:
:
Color
{
color
}
)
=
>
{
TileSurface
:
:
Color
{
color
}
}
None
=
>
{
unreachable
!
(
)
;
}
}
}
else
{
match
self
.
surface
.
take
(
)
{
Some
(
TileSurface
:
:
Texture
{
descriptor
}
)
=
>
{
TileSurface
:
:
Texture
{
descriptor
}
}
Some
(
TileSurface
:
:
Color
{
.
.
}
)
|
None
=
>
{
let
descriptor
=
match
state
.
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
|
CompositorKind
:
:
Layer
{
.
.
}
=
>
{
SurfaceTextureDescriptor
:
:
TextureCache
{
handle
:
None
}
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
SurfaceTextureDescriptor
:
:
Native
{
id
:
None
}
}
}
;
TileSurface
:
:
Texture
{
descriptor
}
}
}
}
;
self
.
surface
=
Some
(
surface
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
BackdropKind
{
Color
{
color
:
ColorF
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
BackdropInfo
{
pub
opaque_rect
:
PictureRect
pub
spanning_opaque_color
:
Option
<
ColorF
>
pub
kind
:
Option
<
BackdropKind
>
pub
backdrop_rect
:
PictureRect
}
impl
BackdropInfo
{
fn
empty
(
)
-
>
Self
{
BackdropInfo
{
opaque_rect
:
PictureRect
:
:
zero
(
)
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
}
}
pub
struct
NativeSurface
{
pub
opaque
:
NativeSurfaceId
pub
alpha
:
NativeSurfaceId
}
#
[
derive
(
PartialEq
Eq
Hash
)
]
pub
struct
ExternalNativeSurfaceKey
{
pub
image_keys
:
[
ImageKey
;
3
]
pub
size
:
Option
<
DeviceIntSize
>
}
pub
struct
ExternalNativeSurface
{
pub
used_this_frame
:
bool
pub
native_surface_id
:
NativeSurfaceId
pub
image_dependencies
:
[
ImageDependency
;
3
]
}
pub
struct
CompositorSurface
{
pub
descriptor
:
ExternalSurfaceDescriptor
prohibited_rect
:
PictureRect
pub
is_opaque
:
bool
}
pub
struct
BackdropSurface
{
pub
id
:
NativeSurfaceId
pub
color
:
ColorF
pub
device_rect
:
DeviceRect
}
#
[
derive
(
Debug
)
]
pub
struct
DeferredDirtyTest
{
pub
tile_rect
:
TileRect
pub
prim_rect
:
PictureRect
}
pub
struct
TileCacheInstance
{
pub
debug_flags
:
DebugFlags
pub
slice
:
usize
pub
slice_flags
:
SliceFlags
pub
current_tile_size
:
DeviceIntSize
pub
sub_slices
:
Vec
<
SubSlice
>
pub
spatial_node_index
:
SpatialNodeIndex
pub
visibility_node_index
:
SpatialNodeIndex
opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
old_opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
spatial_node_comparer
:
SpatialNodeComparer
color_bindings
:
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
old_color_bindings
:
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
pub
dirty_region
:
DirtyRegion
tile_size
:
PictureSize
tile_rect
:
TileRect
tile_bounds_p0
:
TileOffset
tile_bounds_p1
:
TileOffset
pub
local_rect
:
PictureRect
pub
local_clip_rect
:
PictureRect
pub
compositor_clip
:
Option
<
CompositorClipIndex
>
pub
screen_rect_in_pic_space
:
PictureRect
surface_index
:
SurfaceIndex
pub
background_color
:
Option
<
ColorF
>
pub
backdrop
:
BackdropInfo
pub
subpixel_mode
:
SubpixelMode
pub
shared_clip_node_id
:
ClipNodeId
pub
shared_clip_leaf_id
:
Option
<
ClipLeafId
>
frames_until_size_eval
:
usize
pub
virtual_offset
:
DeviceIntPoint
compare_cache
:
FastHashMap
<
PrimitiveComparisonKey
PrimitiveCompareResult
>
tile_size_override
:
Option
<
DeviceIntSize
>
pub
external_native_surface_cache
:
FastHashMap
<
ExternalNativeSurfaceKey
ExternalNativeSurface
>
frame_id
:
FrameId
pub
transform_index
:
CompositorTransformIndex
local_to_raster
:
ScaleOffset
raster_to_device
:
ScaleOffset
invalidate_all_tiles
:
bool
pub
current_raster_scale
:
f32
current_surface_traversal_depth
:
usize
deferred_dirty_tests
:
Vec
<
DeferredDirtyTest
>
pub
found_prims_after_backdrop
:
bool
pub
backdrop_surface
:
Option
<
BackdropSurface
>
pub
underlays
:
Vec
<
ExternalSurfaceDescriptor
>
pub
overlay_region
:
PictureRect
pub
yuv_images_count
:
usize
pub
yuv_images_remaining
:
usize
}
impl
TileCacheInstance
{
pub
fn
new
(
params
:
TileCacheParams
)
-
>
Self
{
let
sub_slice_count
=
(
params
.
image_surface_count
+
params
.
yuv_image_surface_count
)
.
min
(
MAX_COMPOSITOR_SURFACES
)
+
1
;
let
mut
sub_slices
=
Vec
:
:
with_capacity
(
sub_slice_count
)
;
for
_
in
0
.
.
sub_slice_count
{
sub_slices
.
push
(
SubSlice
:
:
new
(
)
)
;
}
TileCacheInstance
{
debug_flags
:
params
.
debug_flags
slice
:
params
.
slice
slice_flags
:
params
.
slice_flags
spatial_node_index
:
params
.
spatial_node_index
visibility_node_index
:
params
.
visibility_node_index
sub_slices
opacity_bindings
:
FastHashMap
:
:
default
(
)
old_opacity_bindings
:
FastHashMap
:
:
default
(
)
spatial_node_comparer
:
SpatialNodeComparer
:
:
new
(
)
color_bindings
:
FastHashMap
:
:
default
(
)
old_color_bindings
:
FastHashMap
:
:
default
(
)
dirty_region
:
DirtyRegion
:
:
new
(
params
.
visibility_node_index
params
.
spatial_node_index
)
tile_size
:
PictureSize
:
:
zero
(
)
tile_rect
:
TileRect
:
:
zero
(
)
tile_bounds_p0
:
TileOffset
:
:
zero
(
)
tile_bounds_p1
:
TileOffset
:
:
zero
(
)
local_rect
:
PictureRect
:
:
zero
(
)
local_clip_rect
:
PictureRect
:
:
zero
(
)
compositor_clip
:
None
screen_rect_in_pic_space
:
PictureRect
:
:
zero
(
)
surface_index
:
SurfaceIndex
(
0
)
background_color
:
params
.
background_color
backdrop
:
BackdropInfo
:
:
empty
(
)
subpixel_mode
:
SubpixelMode
:
:
Allow
shared_clip_node_id
:
params
.
shared_clip_node_id
shared_clip_leaf_id
:
params
.
shared_clip_leaf_id
current_tile_size
:
DeviceIntSize
:
:
zero
(
)
frames_until_size_eval
:
0
virtual_offset
:
DeviceIntPoint
:
:
new
(
params
.
virtual_surface_size
/
2
params
.
virtual_surface_size
/
2
)
compare_cache
:
FastHashMap
:
:
default
(
)
tile_size_override
:
None
external_native_surface_cache
:
FastHashMap
:
:
default
(
)
frame_id
:
FrameId
:
:
INVALID
transform_index
:
CompositorTransformIndex
:
:
INVALID
raster_to_device
:
ScaleOffset
:
:
identity
(
)
local_to_raster
:
ScaleOffset
:
:
identity
(
)
invalidate_all_tiles
:
true
current_raster_scale
:
1
.
0
current_surface_traversal_depth
:
0
deferred_dirty_tests
:
Vec
:
:
new
(
)
found_prims_after_backdrop
:
false
backdrop_surface
:
None
underlays
:
Vec
:
:
new
(
)
overlay_region
:
PictureRect
:
:
zero
(
)
yuv_images_count
:
params
.
yuv_image_surface_count
yuv_images_remaining
:
0
}
}
pub
fn
tile_count
(
&
self
)
-
>
usize
{
self
.
tile_rect
.
area
(
)
as
usize
*
self
.
sub_slices
.
len
(
)
}
pub
fn
memory_pressure
(
&
mut
self
resource_cache
:
&
mut
ResourceCache
)
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
}
pub
fn
prepare_for_new_scene
(
&
mut
self
params
:
TileCacheParams
resource_cache
:
&
mut
ResourceCache
)
{
assert_eq
!
(
self
.
slice
params
.
slice
)
;
let
required_sub_slice_count
=
(
params
.
image_surface_count
+
params
.
yuv_image_surface_count
)
.
min
(
MAX_COMPOSITOR_SURFACES
)
+
1
;
if
self
.
sub_slices
.
len
(
)
!
=
required_sub_slice_count
{
self
.
tile_rect
=
TileRect
:
:
zero
(
)
;
if
self
.
sub_slices
.
len
(
)
>
required_sub_slice_count
{
let
old_sub_slices
=
self
.
sub_slices
.
split_off
(
required_sub_slice_count
)
;
for
mut
sub_slice
in
old_sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
{
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
}
else
{
while
self
.
sub_slices
.
len
(
)
<
required_sub_slice_count
{
self
.
sub_slices
.
push
(
SubSlice
:
:
new
(
)
)
;
}
}
}
self
.
slice_flags
=
params
.
slice_flags
;
self
.
spatial_node_index
=
params
.
spatial_node_index
;
self
.
background_color
=
params
.
background_color
;
self
.
shared_clip_leaf_id
=
params
.
shared_clip_leaf_id
;
self
.
shared_clip_node_id
=
params
.
shared_clip_node_id
;
self
.
frames_until_size_eval
=
0
;
self
.
yuv_images_count
=
params
.
yuv_image_surface_count
;
}
pub
fn
destroy
(
self
resource_cache
:
&
mut
ResourceCache
)
{
for
sub_slice
in
self
.
sub_slices
{
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
{
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
for
(
_
external_surface
)
in
self
.
external_native_surface_cache
{
resource_cache
.
destroy_compositor_surface
(
external_surface
.
native_surface_id
)
}
if
let
Some
(
backdrop_surface
)
=
&
self
.
backdrop_surface
{
resource_cache
.
destroy_compositor_surface
(
backdrop_surface
.
id
)
;
}
}
fn
get_tile_coords_for_rect
(
&
self
rect
:
&
PictureRect
)
-
>
(
TileOffset
TileOffset
)
{
let
mut
p0
=
TileOffset
:
:
new
(
(
rect
.
min
.
x
/
self
.
tile_size
.
width
)
.
floor
(
)
as
i32
(
rect
.
min
.
y
/
self
.
tile_size
.
height
)
.
floor
(
)
as
i32
)
;
let
mut
p1
=
TileOffset
:
:
new
(
(
rect
.
max
.
x
/
self
.
tile_size
.
width
)
.
ceil
(
)
as
i32
(
rect
.
max
.
y
/
self
.
tile_size
.
height
)
.
ceil
(
)
as
i32
)
;
p0
.
x
=
clamp
(
p0
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p0
.
y
=
clamp
(
p0
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
p1
.
x
=
clamp
(
p1
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p1
.
y
=
clamp
(
p1
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
(
p0
p1
)
}
pub
fn
pre_update
(
&
mut
self
surface_index
:
SurfaceIndex
frame_context
:
&
FrameVisibilityContext
frame_state
:
&
mut
FrameVisibilityState
)
-
>
WorldRect
{
let
surface
=
&
frame_state
.
surfaces
[
surface_index
.
0
]
;
let
pic_rect
=
surface
.
unclipped_local_rect
;
self
.
surface_index
=
surface_index
;
self
.
local_rect
=
pic_rect
;
self
.
local_clip_rect
=
PictureRect
:
:
max_rect
(
)
;
self
.
deferred_dirty_tests
.
clear
(
)
;
self
.
underlays
.
clear
(
)
;
self
.
overlay_region
=
PictureRect
:
:
zero
(
)
;
self
.
yuv_images_remaining
=
self
.
yuv_images_count
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
sub_slice
.
reset
(
)
;
}
self
.
backdrop
=
BackdropInfo
:
:
empty
(
)
;
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
self
.
screen_rect_in_pic_space
=
pic_to_world_mapper
.
unmap
(
&
frame_context
.
global_screen_world_rect
)
.
expect
(
"
unable
to
unmap
screen
rect
"
)
;
let
pic_to_vis_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
surface
.
culling_rect
frame_context
.
spatial_tree
)
;
if
let
Some
(
shared_clip_leaf_id
)
=
self
.
shared_clip_leaf_id
{
let
map_local_to_picture
=
SpaceMapper
:
:
new
(
self
.
spatial_node_index
pic_rect
)
;
frame_state
.
clip_store
.
set_active_clips
(
self
.
spatial_node_index
map_local_to_picture
.
ref_spatial_node_index
surface
.
visibility_spatial_node_index
shared_clip_leaf_id
frame_context
.
spatial_tree
&
mut
frame_state
.
data_stores
.
clip
&
frame_state
.
clip_tree
)
;
let
clip_chain_instance
=
frame_state
.
clip_store
.
build_clip_chain_instance
(
pic_rect
.
cast_unit
(
)
&
map_local_to_picture
&
pic_to_vis_mapper
frame_context
.
spatial_tree
&
mut
frame_state
.
frame_gpu_data
.
f32
frame_state
.
resource_cache
frame_context
.
global_device_pixel_scale
&
surface
.
culling_rect
&
mut
frame_state
.
data_stores
.
clip
frame_state
.
rg_builder
true
)
;
self
.
local_clip_rect
=
PictureRect
:
:
zero
(
)
;
self
.
compositor_clip
=
None
;
if
let
Some
(
clip_chain
)
=
clip_chain_instance
{
self
.
local_clip_rect
=
clip_chain
.
pic_coverage_rect
;
self
.
compositor_clip
=
None
;
if
clip_chain
.
needs_mask
{
for
i
in
0
.
.
clip_chain
.
clips_range
.
count
{
let
clip_instance
=
frame_state
.
clip_store
.
get_instance_from_range
(
&
clip_chain
.
clips_range
i
)
;
let
clip_node
=
&
frame_state
.
data_stores
.
clip
[
clip_instance
.
handle
]
;
match
clip_node
.
item
.
kind
{
ClipItemKind
:
:
RoundedRectangle
{
rect
radius
mode
}
=
>
{
assert_eq
!
(
mode
ClipMode
:
:
Clip
)
;
let
map
=
ClipSpaceConversion
:
:
new
(
frame_context
.
root_spatial_node_index
clip_node
.
item
.
spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
(
rect
radius
)
=
match
map
{
ClipSpaceConversion
:
:
Local
=
>
{
(
rect
.
cast_unit
(
)
radius
)
}
ClipSpaceConversion
:
:
ScaleOffset
(
scale_offset
)
=
>
{
(
scale_offset
.
map_rect
(
&
rect
)
BorderRadius
{
top_left
:
scale_offset
.
map_size
(
&
radius
.
top_left
)
top_right
:
scale_offset
.
map_size
(
&
radius
.
top_right
)
bottom_left
:
scale_offset
.
map_size
(
&
radius
.
bottom_left
)
bottom_right
:
scale_offset
.
map_size
(
&
radius
.
bottom_right
)
}
)
}
ClipSpaceConversion
:
:
Transform
(
.
.
)
=
>
{
unreachable
!
(
)
;
}
}
;
self
.
compositor_clip
=
Some
(
frame_state
.
composite_state
.
register_clip
(
rect
radius
)
)
;
break
;
}
_
=
>
{
}
}
}
}
}
}
self
.
frame_id
.
advance
(
)
;
self
.
spatial_node_comparer
.
next_frame
(
self
.
spatial_node_index
)
;
for
external_native_surface
in
self
.
external_native_surface_cache
.
values_mut
(
)
{
external_native_surface
.
used_this_frame
=
false
;
}
if
self
.
frames_until_size_eval
=
=
0
|
|
self
.
tile_size_override
!
=
frame_context
.
config
.
tile_size_override
{
let
desired_tile_size
=
match
frame_context
.
config
.
tile_size_override
{
Some
(
tile_size_override
)
=
>
{
tile_size_override
}
None
=
>
{
if
self
.
slice_flags
.
contains
(
SliceFlags
:
:
IS_SCROLLBAR
)
{
if
pic_rect
.
width
(
)
<
=
pic_rect
.
height
(
)
{
TILE_SIZE_SCROLLBAR_VERTICAL
}
else
{
TILE_SIZE_SCROLLBAR_HORIZONTAL
}
}
else
{
frame_state
.
resource_cache
.
picture_textures
.
default_tile_size
(
)
}
}
}
;
if
desired_tile_size
!
=
self
.
current_tile_size
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
sub_slice
.
tiles
.
clear
(
)
;
}
self
.
tile_rect
=
TileRect
:
:
zero
(
)
;
self
.
current_tile_size
=
desired_tile_size
;
}
self
.
frames_until_size_eval
=
120
;
self
.
tile_size_override
=
frame_context
.
config
.
tile_size_override
;
}
let
local_to_device
=
get_relative_scale_offset
(
self
.
spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
mut
raster_to_device
=
local_to_device
;
if
frame_context
.
config
.
low_quality_pinch_zoom
{
raster_to_device
.
scale
.
x
/
=
self
.
current_raster_scale
;
raster_to_device
.
scale
.
y
/
=
self
.
current_raster_scale
;
}
else
{
raster_to_device
.
scale
.
x
=
1
.
0
;
raster_to_device
.
scale
.
y
=
1
.
0
;
}
let
local_to_raster
=
local_to_device
.
then
(
&
raster_to_device
.
inverse
(
)
)
;
const
EPSILON
:
f32
=
0
.
001
;
let
compositor_translation_changed
=
!
raster_to_device
.
offset
.
x
.
approx_eq_eps
(
&
self
.
raster_to_device
.
offset
.
x
&
EPSILON
)
|
|
!
raster_to_device
.
offset
.
y
.
approx_eq_eps
(
&
self
.
raster_to_device
.
offset
.
y
&
EPSILON
)
;
let
compositor_scale_changed
=
!
raster_to_device
.
scale
.
x
.
approx_eq_eps
(
&
self
.
raster_to_device
.
scale
.
x
&
EPSILON
)
|
|
!
raster_to_device
.
scale
.
y
.
approx_eq_eps
(
&
self
.
raster_to_device
.
scale
.
y
&
EPSILON
)
;
let
surface_scale_changed
=
!
local_to_raster
.
scale
.
x
.
approx_eq_eps
(
&
self
.
local_to_raster
.
scale
.
x
&
EPSILON
)
|
|
!
local_to_raster
.
scale
.
y
.
approx_eq_eps
(
&
self
.
local_to_raster
.
scale
.
y
&
EPSILON
)
;
if
compositor_translation_changed
|
|
compositor_scale_changed
|
|
surface_scale_changed
|
|
frame_context
.
config
.
force_invalidation
{
frame_state
.
composite_state
.
dirty_rects_are_valid
=
false
;
}
self
.
raster_to_device
=
raster_to_device
;
self
.
local_to_raster
=
local_to_raster
;
self
.
invalidate_all_tiles
=
surface_scale_changed
|
|
frame_context
.
config
.
force_invalidation
;
let
current_properties
=
frame_context
.
scene_properties
.
float_properties
(
)
;
mem
:
:
swap
(
&
mut
self
.
opacity_bindings
&
mut
self
.
old_opacity_bindings
)
;
self
.
opacity_bindings
.
clear
(
)
;
for
(
id
value
)
in
current_properties
{
let
changed
=
match
self
.
old_opacity_bindings
.
get
(
id
)
{
Some
(
old_property
)
=
>
!
old_property
.
value
.
approx_eq
(
value
)
None
=
>
true
}
;
self
.
opacity_bindings
.
insert
(
*
id
OpacityBindingInfo
{
value
:
*
value
changed
}
)
;
}
let
current_properties
=
frame_context
.
scene_properties
.
color_properties
(
)
;
mem
:
:
swap
(
&
mut
self
.
color_bindings
&
mut
self
.
old_color_bindings
)
;
self
.
color_bindings
.
clear
(
)
;
for
(
id
value
)
in
current_properties
{
let
changed
=
match
self
.
old_color_bindings
.
get
(
id
)
{
Some
(
old_property
)
=
>
old_property
.
value
!
=
(
*
value
)
.
into
(
)
None
=
>
true
}
;
self
.
color_bindings
.
insert
(
*
id
ColorBindingInfo
{
value
:
(
*
value
)
.
into
(
)
changed
}
)
;
}
let
world_tile_size
=
WorldSize
:
:
new
(
self
.
current_tile_size
.
width
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
self
.
current_tile_size
.
height
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
)
;
self
.
tile_size
=
PictureSize
:
:
new
(
world_tile_size
.
width
/
self
.
local_to_raster
.
scale
.
x
world_tile_size
.
height
/
self
.
local_to_raster
.
scale
.
y
)
;
let
desired_rect_in_pic_space
=
self
.
screen_rect_in_pic_space
.
inflate
(
0
.
0
1
.
0
*
self
.
tile_size
.
height
)
;
let
needed_rect_in_pic_space
=
desired_rect_in_pic_space
.
intersection
(
&
pic_rect
)
.
unwrap_or_else
(
Box2D
:
:
zero
)
;
let
p0
=
needed_rect_in_pic_space
.
min
;
let
p1
=
needed_rect_in_pic_space
.
max
;
let
x0
=
(
p0
.
x
/
self
.
tile_size
.
width
)
.
floor
(
)
as
i32
;
let
x1
=
(
p1
.
x
/
self
.
tile_size
.
width
)
.
ceil
(
)
as
i32
;
let
y0
=
(
p0
.
y
/
self
.
tile_size
.
height
)
.
floor
(
)
as
i32
;
let
y1
=
(
p1
.
y
/
self
.
tile_size
.
height
)
.
ceil
(
)
as
i32
;
let
new_tile_rect
=
TileRect
{
min
:
TileOffset
:
:
new
(
x0
y0
)
max
:
TileOffset
:
:
new
(
x1
y1
)
}
;
let
virtual_surface_size
=
frame_context
.
config
.
compositor_kind
.
get_virtual_surface_size
(
)
;
if
virtual_surface_size
>
0
{
let
tx0
=
self
.
virtual_offset
.
x
+
x0
*
self
.
current_tile_size
.
width
;
let
ty0
=
self
.
virtual_offset
.
y
+
y0
*
self
.
current_tile_size
.
height
;
let
tx1
=
self
.
virtual_offset
.
x
+
(
x1
+
1
)
*
self
.
current_tile_size
.
width
;
let
ty1
=
self
.
virtual_offset
.
y
+
(
y1
+
1
)
*
self
.
current_tile_size
.
height
;
let
need_new_virtual_offset
=
tx0
<
0
|
|
ty0
<
0
|
|
tx1
>
=
virtual_surface_size
|
|
ty1
>
=
virtual_surface_size
;
if
need_new_virtual_offset
{
self
.
virtual_offset
=
DeviceIntPoint
:
:
new
(
(
virtual_surface_size
/
2
)
-
(
(
x0
+
x1
)
/
2
)
*
self
.
current_tile_size
.
width
(
virtual_surface_size
/
2
)
-
(
(
y0
+
y1
)
/
2
)
*
self
.
current_tile_size
.
height
)
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
}
}
if
new_tile_rect
!
=
self
.
tile_rect
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
let
mut
old_tiles
=
sub_slice
.
resize
(
new_tile_rect
)
;
if
!
old_tiles
.
is_empty
(
)
{
frame_state
.
composite_state
.
dirty_rects_are_valid
=
false
;
}
if
let
CompositorKind
:
:
Native
{
.
.
}
=
frame_state
.
composite_state
.
compositor_kind
{
for
tile
in
old_tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
}
}
}
}
self
.
tile_bounds_p0
=
TileOffset
:
:
new
(
x0
y0
)
;
self
.
tile_bounds_p1
=
TileOffset
:
:
new
(
x1
y1
)
;
self
.
tile_rect
=
new_tile_rect
;
let
mut
world_culling_rect
=
WorldRect
:
:
zero
(
)
;
let
mut
ctx
=
TilePreUpdateContext
{
pic_to_world_mapper
background_color
:
self
.
background_color
global_screen_world_rect
:
frame_context
.
global_screen_world_rect
tile_size
:
self
.
tile_size
frame_id
:
self
.
frame_id
}
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
pre_update
(
&
ctx
)
;
if
tile
.
is_visible
{
world_culling_rect
=
world_culling_rect
.
union
(
&
tile
.
world_tile_rect
)
;
}
}
ctx
.
background_color
=
None
;
}
match
frame_context
.
config
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
|
CompositorKind
:
:
Layer
{
.
.
}
=
>
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
for
(
_
external_surface
)
in
self
.
external_native_surface_cache
.
drain
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
external_surface
.
native_surface_id
)
}
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
TextureCache
{
.
.
}
.
.
}
)
=
tile
.
surface
{
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
}
}
}
world_culling_rect
}
fn
can_promote_to_surface
(
&
mut
self
prim_clip_chain
:
&
ClipChainInstance
prim_spatial_node_index
:
SpatialNodeIndex
is_root_tile_cache
:
bool
sub_slice_index
:
usize
surface_kind
:
CompositorSurfaceKind
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
composite_state
:
&
CompositeState
force
:
bool
)
-
>
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
{
use
SurfacePromotionFailure
:
:
*
;
match
surface_kind
{
CompositorSurfaceKind
:
:
Overlay
=
>
{
if
sub_slice_index
=
=
self
.
sub_slices
.
len
(
)
-
1
{
return
Err
(
OverlaySurfaceLimit
)
;
}
if
prim_clip_chain
.
needs_mask
{
let
mut
is_supported_rounded_rect
=
false
;
if
let
CompositorKind
:
:
Layer
{
.
.
}
=
composite_state
.
compositor_kind
{
if
prim_clip_chain
.
clips_range
.
count
=
=
1
&
&
self
.
compositor_clip
.
is_none
(
)
{
let
clip_instance
=
clip_store
.
get_instance_from_range
(
&
prim_clip_chain
.
clips_range
0
)
;
let
clip_node
=
&
data_stores
.
clip
[
clip_instance
.
handle
]
;
if
let
ClipItemKind
:
:
RoundedRectangle
{
ref
radius
mode
:
ClipMode
:
:
Clip
rect
.
.
}
=
clip_node
.
item
.
kind
{
let
max_corner_width
=
radius
.
top_left
.
width
.
max
(
radius
.
bottom_left
.
width
)
.
max
(
radius
.
top_right
.
width
)
.
max
(
radius
.
bottom_right
.
width
)
;
let
max_corner_height
=
radius
.
top_left
.
height
.
max
(
radius
.
bottom_left
.
height
)
.
max
(
radius
.
top_right
.
height
)
.
max
(
radius
.
bottom_right
.
height
)
;
if
max_corner_width
<
=
0
.
5
*
rect
.
size
(
)
.
width
&
&
max_corner_height
<
=
0
.
5
*
rect
.
size
(
)
.
height
{
is_supported_rounded_rect
=
true
;
}
}
}
}
if
!
is_supported_rounded_rect
{
return
Err
(
OverlayNeedsMask
)
;
}
}
}
CompositorSurfaceKind
:
:
Underlay
=
>
{
if
prim_clip_chain
.
needs_mask
{
if
!
self
.
backdrop
.
opaque_rect
.
contains_box
(
&
pic_coverage_rect
)
{
let
result
=
Err
(
UnderlayAlphaBackdrop
)
;
if
!
force
{
return
result
;
}
self
.
report_promotion_failure
(
result
pic_coverage_rect
true
)
;
}
if
!
self
.
underlays
.
is_empty
(
)
{
return
Err
(
UnderlaySurfaceLimit
)
;
}
}
if
self
.
overlay_region
.
intersects
(
&
pic_coverage_rect
)
{
let
result
=
Err
(
UnderlayIntersectsOverlay
)
;
if
!
force
{
return
result
;
}
self
.
report_promotion_failure
(
result
pic_coverage_rect
true
)
;
}
if
frame_context
.
config
.
low_quality_pinch_zoom
&
&
frame_context
.
spatial_tree
.
get_spatial_node
(
prim_spatial_node_index
)
.
is_ancestor_or_self_zooming
{
return
Err
(
UnderlayLowQualityZoom
)
;
}
}
CompositorSurfaceKind
:
:
Blit
=
>
unreachable
!
(
)
}
if
!
is_root_tile_cache
{
return
Err
(
NotRootTileCache
)
;
}
let
mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
prim_spatial_node_index
frame_context
.
global_screen_world_rect
&
frame_context
.
spatial_tree
)
;
let
transform
=
mapper
.
get_transform
(
)
;
if
!
transform
.
is_2d_scale_translation
(
)
{
let
result
=
Err
(
ComplexTransform
)
;
return
result
;
}
if
self
.
slice_flags
.
contains
(
SliceFlags
:
:
IS_ATOMIC
)
{
return
Err
(
SliceAtomic
)
;
}
Ok
(
surface_kind
)
}
fn
setup_compositor_surfaces_yuv
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_clip_chain
:
&
ClipChainInstance
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
image_dependencies
:
&
[
ImageDependency
;
3
]
api_keys
:
&
[
ImageKey
;
3
]
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
gpu_buffer
:
&
mut
GpuBufferBuilderF
image_rendering
:
ImageRendering
color_depth
:
ColorDepth
color_space
:
YuvRangedColorSpace
format
:
YuvFormat
surface_kind
:
CompositorSurfaceKind
)
-
>
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
{
for
&
key
in
api_keys
{
if
key
!
=
ImageKey
:
:
DUMMY
{
resource_cache
.
request_image
(
ImageRequest
{
key
rendering
:
image_rendering
tile
:
None
}
gpu_buffer
)
;
}
}
self
.
setup_compositor_surfaces_impl
(
sub_slice_index
prim_info
flags
local_prim_rect
prim_clip_chain
prim_spatial_node_index
pic_coverage_rect
frame_context
data_stores
clip_store
ExternalSurfaceDependency
:
:
Yuv
{
image_dependencies
:
*
image_dependencies
color_space
format
channel_bit_depth
:
color_depth
.
bit_depth
(
)
}
api_keys
resource_cache
composite_state
image_rendering
true
surface_kind
)
}
fn
setup_compositor_surfaces_rgb
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_clip_chain
:
&
ClipChainInstance
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
image_dependency
:
ImageDependency
api_key
:
ImageKey
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
gpu_buffer
:
&
mut
GpuBufferBuilderF
image_rendering
:
ImageRendering
is_opaque
:
bool
surface_kind
:
CompositorSurfaceKind
)
-
>
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
{
let
mut
api_keys
=
[
ImageKey
:
:
DUMMY
;
3
]
;
api_keys
[
0
]
=
api_key
;
resource_cache
.
request_image
(
ImageRequest
{
key
:
api_key
rendering
:
image_rendering
tile
:
None
}
gpu_buffer
)
;
self
.
setup_compositor_surfaces_impl
(
sub_slice_index
prim_info
flags
local_prim_rect
prim_clip_chain
prim_spatial_node_index
pic_coverage_rect
frame_context
data_stores
clip_store
ExternalSurfaceDependency
:
:
Rgb
{
image_dependency
}
&
api_keys
resource_cache
composite_state
image_rendering
is_opaque
surface_kind
)
}
fn
setup_compositor_surfaces_impl
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_clip_chain
:
&
ClipChainInstance
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
dependency
:
ExternalSurfaceDependency
api_keys
:
&
[
ImageKey
;
3
]
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
image_rendering
:
ImageRendering
is_opaque
:
bool
surface_kind
:
CompositorSurfaceKind
)
-
>
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
{
use
SurfacePromotionFailure
:
:
*
;
let
map_local_to_picture
=
SpaceMapper
:
:
new_with_target
(
self
.
spatial_node_index
prim_spatial_node_index
self
.
local_rect
frame_context
.
spatial_tree
)
;
let
prim_rect
=
match
map_local_to_picture
.
map
(
&
local_prim_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
Ok
(
surface_kind
)
}
;
if
prim_rect
.
is_empty
(
)
{
return
Ok
(
surface_kind
)
;
}
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
let
world_clip_rect
=
pic_to_world_mapper
.
map
(
&
prim_info
.
prim_clip_box
)
.
expect
(
"
bug
:
unable
to
map
clip
to
world
space
"
)
;
let
is_visible
=
world_clip_rect
.
intersects
(
&
frame_context
.
global_screen_world_rect
)
;
if
!
is_visible
{
return
Ok
(
surface_kind
)
;
}
let
prim_offset
=
ScaleOffset
:
:
from_offset
(
local_prim_rect
.
min
.
to_vector
(
)
.
cast_unit
(
)
)
;
let
local_prim_to_device
=
get_relative_scale_offset
(
prim_spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
normalized_prim_to_device
=
prim_offset
.
then
(
&
local_prim_to_device
)
;
let
local_to_raster
=
ScaleOffset
:
:
identity
(
)
;
let
raster_to_device
=
normalized_prim_to_device
;
let
mut
external_image_id
=
if
flags
.
contains
(
PrimitiveFlags
:
:
SUPPORTS_EXTERNAL_COMPOSITOR_SURFACE
)
&
&
image_rendering
=
=
ImageRendering
:
:
Auto
{
resource_cache
.
get_image_properties
(
api_keys
[
0
]
)
.
and_then
(
|
properties
|
properties
.
external_image
)
.
and_then
(
|
image
|
Some
(
image
.
id
)
)
}
else
{
None
}
;
match
composite_state
.
compositor_kind
{
CompositorKind
:
:
Native
{
capabilities
.
.
}
=
>
{
if
external_image_id
.
is_some
(
)
&
&
!
capabilities
.
supports_external_compositor_surface_negative_scaling
&
&
(
raster_to_device
.
scale
.
x
<
0
.
0
|
|
raster_to_device
.
scale
.
y
<
0
.
0
)
{
external_image_id
=
None
;
}
}
CompositorKind
:
:
Layer
{
.
.
}
|
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
}
}
let
compositor_transform_index
=
composite_state
.
register_transform
(
local_to_raster
raster_to_device
)
;
let
surface_size
=
composite_state
.
get_surface_rect
(
&
local_prim_rect
&
local_prim_rect
compositor_transform_index
)
.
size
(
)
;
let
clip_rect
=
(
world_clip_rect
*
frame_context
.
global_device_pixel_scale
)
.
round
(
)
;
let
mut
compositor_clip_index
=
None
;
if
surface_kind
=
=
CompositorSurfaceKind
:
:
Overlay
&
&
prim_clip_chain
.
needs_mask
{
assert
!
(
prim_clip_chain
.
clips_range
.
count
=
=
1
)
;
assert
!
(
self
.
compositor_clip
.
is_none
(
)
)
;
let
clip_instance
=
clip_store
.
get_instance_from_range
(
&
prim_clip_chain
.
clips_range
0
)
;
let
clip_node
=
&
data_stores
.
clip
[
clip_instance
.
handle
]
;
if
let
ClipItemKind
:
:
RoundedRectangle
{
radius
mode
:
ClipMode
:
:
Clip
rect
.
.
}
=
clip_node
.
item
.
kind
{
let
map
=
ClipSpaceConversion
:
:
new
(
frame_context
.
root_spatial_node_index
clip_node
.
item
.
spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
(
rect
radius
)
=
match
map
{
ClipSpaceConversion
:
:
Local
=
>
{
(
rect
.
cast_unit
(
)
radius
)
}
ClipSpaceConversion
:
:
ScaleOffset
(
scale_offset
)
=
>
{
(
scale_offset
.
map_rect
(
&
rect
)
BorderRadius
{
top_left
:
scale_offset
.
map_size
(
&
radius
.
top_left
)
top_right
:
scale_offset
.
map_size
(
&
radius
.
top_right
)
bottom_left
:
scale_offset
.
map_size
(
&
radius
.
bottom_left
)
bottom_right
:
scale_offset
.
map_size
(
&
radius
.
bottom_right
)
}
)
}
ClipSpaceConversion
:
:
Transform
(
.
.
)
=
>
{
unreachable
!
(
)
;
}
}
;
compositor_clip_index
=
Some
(
composite_state
.
register_clip
(
rect
radius
)
)
;
}
else
{
unreachable
!
(
)
;
}
}
if
surface_size
.
width
>
=
MAX_COMPOSITOR_SURFACES_SIZE
|
|
surface_size
.
height
>
=
MAX_COMPOSITOR_SURFACES_SIZE
{
return
Err
(
SizeTooLarge
)
;
}
let
(
native_surface_id
update_params
)
=
match
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
|
CompositorKind
:
:
Layer
{
.
.
}
=
>
{
(
None
None
)
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
let
native_surface_size
=
surface_size
.
to_i32
(
)
;
let
key
=
ExternalNativeSurfaceKey
{
image_keys
:
*
api_keys
size
:
if
external_image_id
.
is_some
(
)
{
None
}
else
{
Some
(
native_surface_size
)
}
}
;
let
native_surface
=
self
.
external_native_surface_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
native_surface_id
=
match
external_image_id
{
Some
(
_external_image
)
=
>
{
resource_cache
.
create_compositor_external_surface
(
is_opaque
)
}
None
=
>
{
let
native_surface_id
=
resource_cache
.
create_compositor_surface
(
DeviceIntPoint
:
:
zero
(
)
native_surface_size
is_opaque
)
;
let
tile_id
=
NativeTileId
{
surface_id
:
native_surface_id
x
:
0
y
:
0
}
;
resource_cache
.
create_compositor_tile
(
tile_id
)
;
native_surface_id
}
}
;
ExternalNativeSurface
{
used_this_frame
:
true
native_surface_id
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
}
}
)
;
native_surface
.
used_this_frame
=
true
;
let
update_params
=
match
external_image_id
{
Some
(
external_image
)
=
>
{
resource_cache
.
attach_compositor_external_image
(
native_surface
.
native_surface_id
external_image
)
;
None
}
None
=
>
{
match
dependency
{
ExternalSurfaceDependency
:
:
Yuv
{
image_dependencies
.
.
}
=
>
{
if
image_dependencies
=
=
native_surface
.
image_dependencies
{
None
}
else
{
Some
(
native_surface_size
)
}
}
ExternalSurfaceDependency
:
:
Rgb
{
image_dependency
.
.
}
=
>
{
if
image_dependency
=
=
native_surface
.
image_dependencies
[
0
]
{
None
}
else
{
Some
(
native_surface_size
)
}
}
}
}
}
;
(
Some
(
native_surface
.
native_surface_id
)
update_params
)
}
}
;
let
descriptor
=
ExternalSurfaceDescriptor
{
local_surface_size
:
local_prim_rect
.
size
(
)
local_rect
:
prim_rect
local_clip_rect
:
prim_info
.
prim_clip_box
dependency
image_rendering
clip_rect
transform_index
:
compositor_transform_index
compositor_clip_index
:
compositor_clip_index
z_id
:
ZBufferId
:
:
invalid
(
)
native_surface_id
update_params
external_image_id
}
;
match
surface_kind
{
CompositorSurfaceKind
:
:
Underlay
=
>
{
self
.
underlays
.
push
(
descriptor
)
;
}
CompositorSurfaceKind
:
:
Overlay
=
>
{
assert
!
(
sub_slice_index
<
self
.
sub_slices
.
len
(
)
-
1
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
sub_slice
.
compositor_surfaces
.
push
(
CompositorSurface
{
prohibited_rect
:
pic_coverage_rect
is_opaque
descriptor
}
)
;
self
.
overlay_region
=
self
.
overlay_region
.
union
(
&
pic_coverage_rect
)
;
}
CompositorSurfaceKind
:
:
Blit
=
>
unreachable
!
(
)
}
Ok
(
surface_kind
)
}
pub
fn
push_surface
(
&
mut
self
estimated_local_rect
:
LayoutRect
surface_spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
{
if
self
.
current_surface_traversal_depth
=
=
0
&
&
self
.
sub_slices
.
len
(
)
>
1
{
let
map_local_to_picture
=
SpaceMapper
:
:
new_with_target
(
self
.
spatial_node_index
surface_spatial_node_index
self
.
local_rect
spatial_tree
)
;
if
let
Some
(
pic_rect
)
=
map_local_to_picture
.
map
(
&
estimated_local_rect
)
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
let
mut
intersects_prohibited_region
=
false
;
for
surface
in
&
mut
sub_slice
.
compositor_surfaces
{
if
pic_rect
.
intersects
(
&
surface
.
prohibited_rect
)
{
surface
.
prohibited_rect
=
surface
.
prohibited_rect
.
union
(
&
pic_rect
)
;
intersects_prohibited_region
=
true
;
}
}
if
!
intersects_prohibited_region
{
break
;
}
}
}
}
self
.
current_surface_traversal_depth
+
=
1
;
}
pub
fn
pop_surface
(
&
mut
self
)
{
self
.
current_surface_traversal_depth
-
=
1
;
}
fn
report_promotion_failure
(
&
self
result
:
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
rect
:
PictureRect
ignored
:
bool
)
{
if
!
self
.
debug_flags
.
contains
(
DebugFlags
:
:
SURFACE_PROMOTION_LOGGING
)
|
|
result
.
is_ok
(
)
{
return
;
}
let
outcome
=
if
ignored
{
"
failure
ignored
"
}
else
{
"
failed
"
}
;
warn
!
(
"
Surface
promotion
of
prim
at
{
:
?
}
{
outcome
}
with
:
{
}
.
"
rect
result
.
unwrap_err
(
)
)
;
}
pub
fn
update_prim_dependencies
(
&
mut
self
prim_instance
:
&
mut
PrimitiveInstance
prim_spatial_node_index
:
SpatialNodeIndex
local_prim_rect
:
LayoutRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
pictures
:
&
[
PicturePrimitive
]
resource_cache
:
&
mut
ResourceCache
color_bindings
:
&
ColorBindingStorage
surface_stack
:
&
[
(
PictureIndex
SurfaceIndex
)
]
composite_state
:
&
mut
CompositeState
gpu_buffer
:
&
mut
GpuBufferBuilderF
scratch
:
&
mut
PrimitiveScratchBuffer
is_root_tile_cache
:
bool
surfaces
:
&
mut
[
SurfaceInfo
]
profile
:
&
mut
TransactionProfile
)
-
>
VisibilityState
{
use
SurfacePromotionFailure
:
:
*
;
profile_scope
!
(
"
update_prim_dependencies
"
)
;
let
prim_surface_index
=
surface_stack
.
last
(
)
.
unwrap
(
)
.
1
;
let
prim_clip_chain
=
&
prim_instance
.
vis
.
clip_chain
;
let
on_picture_surface
=
prim_surface_index
=
=
self
.
surface_index
;
let
pic_coverage_rect
=
if
on_picture_surface
{
prim_clip_chain
.
pic_coverage_rect
}
else
{
let
mut
current_pic_coverage_rect
=
prim_clip_chain
.
pic_coverage_rect
;
let
mut
current_spatial_node_index
=
surfaces
[
prim_surface_index
.
0
]
.
surface_spatial_node_index
;
for
(
pic_index
surface_index
)
in
surface_stack
.
iter
(
)
.
rev
(
)
{
let
surface
=
&
surfaces
[
surface_index
.
0
]
;
let
pic
=
&
pictures
[
pic_index
.
0
]
;
let
map_local_to_parent
=
SpaceMapper
:
:
new_with_target
(
surface
.
surface_spatial_node_index
current_spatial_node_index
surface
.
unclipped_local_rect
frame_context
.
spatial_tree
)
;
current_pic_coverage_rect
=
match
map_local_to_parent
.
map
(
&
current_pic_coverage_rect
)
{
Some
(
rect
)
=
>
{
pic
.
composite_mode
.
as_ref
(
)
.
unwrap
(
)
.
get_coverage
(
surface
Some
(
rect
.
cast_unit
(
)
)
)
.
cast_unit
(
)
}
None
=
>
{
return
VisibilityState
:
:
Culled
;
}
}
;
current_spatial_node_index
=
surface
.
surface_spatial_node_index
;
}
current_pic_coverage_rect
}
;
let
(
p0
p1
)
=
self
.
get_tile_coords_for_rect
(
&
pic_coverage_rect
)
;
if
p0
.
x
=
=
p1
.
x
|
|
p0
.
y
=
=
p1
.
y
{
return
VisibilityState
:
:
Culled
;
}
let
mut
prim_info
=
PrimitiveDependencyInfo
:
:
new
(
prim_instance
.
uid
(
)
pic_coverage_rect
)
;
let
mut
sub_slice_index
=
self
.
sub_slices
.
len
(
)
-
1
;
if
sub_slice_index
>
0
{
for
(
i
sub_slice
)
in
self
.
sub_slices
.
iter_mut
(
)
.
enumerate
(
)
{
let
mut
intersects_prohibited_region
=
false
;
for
surface
in
&
mut
sub_slice
.
compositor_surfaces
{
if
pic_coverage_rect
.
intersects
(
&
surface
.
prohibited_rect
)
{
surface
.
prohibited_rect
=
surface
.
prohibited_rect
.
union
(
&
pic_coverage_rect
)
;
intersects_prohibited_region
=
true
;
}
}
if
!
intersects_prohibited_region
{
sub_slice_index
=
i
;
break
;
}
}
}
if
prim_spatial_node_index
!
=
self
.
spatial_node_index
{
prim_info
.
spatial_nodes
.
push
(
prim_spatial_node_index
)
;
}
let
clip_instances
=
&
clip_store
.
clip_node_instances
[
prim_clip_chain
.
clips_range
.
to_range
(
)
]
;
for
clip_instance
in
clip_instances
{
let
clip
=
&
data_stores
.
clip
[
clip_instance
.
handle
]
;
prim_info
.
clips
.
push
(
clip_instance
.
handle
.
uid
(
)
)
;
if
clip
.
item
.
spatial_node_index
!
=
self
.
spatial_node_index
&
&
!
prim_info
.
spatial_nodes
.
contains
(
&
clip
.
item
.
spatial_node_index
)
{
prim_info
.
spatial_nodes
.
push
(
clip
.
item
.
spatial_node_index
)
;
}
}
let
mut
backdrop_candidate
=
None
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
pictures
[
pic_index
.
0
]
;
if
let
Some
(
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Opacity
(
binding
_
)
)
)
=
pic
.
composite_mode
{
prim_info
.
opacity_bindings
.
push
(
binding
.
into
(
)
)
;
}
}
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
color_binding_index
.
.
}
=
>
{
let
PrimitiveTemplateKind
:
:
Rectangle
{
color
.
.
}
=
data_stores
.
prim
[
data_handle
]
.
kind
;
let
color
=
frame_context
.
scene_properties
.
resolve_color
(
&
color
)
;
if
color
.
a
>
=
1
.
0
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
Some
(
BackdropKind
:
:
Color
{
color
}
)
backdrop_rect
:
pic_coverage_rect
}
)
;
}
if
color_binding_index
!
=
ColorBindingIndex
:
:
INVALID
{
prim_info
.
color_binding
=
Some
(
color_bindings
[
color_binding_index
]
.
into
(
)
)
;
}
}
PrimitiveInstanceKind
:
:
Image
{
data_handle
ref
mut
compositor_surface_kind
.
.
}
=
>
{
let
image_key
=
&
data_stores
.
image
[
data_handle
]
;
let
image_data
=
&
image_key
.
kind
;
let
mut
is_opaque
=
false
;
if
let
Some
(
image_properties
)
=
resource_cache
.
get_image_properties
(
image_data
.
key
)
{
if
image_properties
.
descriptor
.
is_opaque
(
)
&
&
image_properties
.
tiling
.
is_none
(
)
&
&
image_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
&
&
image_data
.
color
.
a
>
=
1
.
0
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
is_opaque
=
image_properties
.
descriptor
.
is_opaque
(
)
;
}
let
mut
promotion_result
:
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
=
Ok
(
CompositorSurfaceKind
:
:
Blit
)
;
if
image_key
.
common
.
flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
if
self
.
yuv_images_remaining
>
0
{
promotion_result
=
Err
(
ImageWaitingOnYuvImage
)
;
}
else
{
promotion_result
=
self
.
can_promote_to_surface
(
prim_clip_chain
prim_spatial_node_index
is_root_tile_cache
sub_slice_index
CompositorSurfaceKind
:
:
Overlay
pic_coverage_rect
frame_context
data_stores
clip_store
composite_state
false
)
;
}
if
image_data
.
alpha_type
=
=
AlphaType
:
:
Alpha
{
promotion_result
=
Err
(
NotPremultipliedAlpha
)
;
}
if
let
Ok
(
kind
)
=
promotion_result
{
promotion_result
=
self
.
setup_compositor_surfaces_rgb
(
sub_slice_index
&
mut
prim_info
image_key
.
common
.
flags
local_prim_rect
prim_clip_chain
prim_spatial_node_index
pic_coverage_rect
frame_context
data_stores
clip_store
ImageDependency
{
key
:
image_data
.
key
generation
:
resource_cache
.
get_image_generation
(
image_data
.
key
)
}
image_data
.
key
resource_cache
composite_state
gpu_buffer
image_data
.
image_rendering
is_opaque
kind
)
;
}
}
if
let
Ok
(
kind
)
=
promotion_result
{
*
compositor_surface_kind
=
kind
;
if
kind
=
=
CompositorSurfaceKind
:
:
Overlay
{
profile
.
inc
(
profiler
:
:
COMPOSITOR_SURFACE_OVERLAYS
)
;
return
VisibilityState
:
:
Culled
;
}
assert
!
(
kind
=
=
CompositorSurfaceKind
:
:
Blit
"
Image
prims
should
either
be
overlays
or
blits
.
"
)
;
}
else
{
self
.
report_promotion_failure
(
promotion_result
pic_coverage_rect
false
)
;
*
compositor_surface_kind
=
CompositorSurfaceKind
:
:
Blit
;
}
if
image_key
.
common
.
flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
profile
.
inc
(
profiler
:
:
COMPOSITOR_SURFACE_BLITS
)
;
}
prim_info
.
images
.
push
(
ImageDependency
{
key
:
image_data
.
key
generation
:
resource_cache
.
get_image_generation
(
image_data
.
key
)
}
)
;
}
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
ref
mut
compositor_surface_kind
.
.
}
=
>
{
let
prim_data
=
&
data_stores
.
yuv_image
[
data_handle
]
;
let
mut
promotion_result
:
Result
<
CompositorSurfaceKind
SurfacePromotionFailure
>
=
Ok
(
CompositorSurfaceKind
:
:
Blit
)
;
if
prim_data
.
common
.
flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
if
is_root_tile_cache
{
self
.
yuv_images_remaining
-
=
1
;
}
let
force
=
prim_data
.
kind
.
color_depth
.
bit_depth
(
)
>
8
;
let
promotion_attempts
=
[
CompositorSurfaceKind
:
:
Overlay
CompositorSurfaceKind
:
:
Underlay
]
;
for
kind
in
promotion_attempts
{
promotion_result
=
self
.
can_promote_to_surface
(
prim_clip_chain
prim_spatial_node_index
is_root_tile_cache
sub_slice_index
kind
pic_coverage_rect
frame_context
data_stores
clip_store
composite_state
force
)
;
if
promotion_result
.
is_ok
(
)
{
break
;
}
if
let
Err
(
SliceAtomic
)
=
promotion_result
{
if
prim_data
.
kind
.
color_depth
!
=
ColorDepth
:
:
Color8
{
promotion_result
=
Ok
(
kind
)
;
break
;
}
}
}
if
let
Ok
(
kind
)
=
promotion_result
{
let
mut
image_dependencies
=
[
ImageDependency
:
:
INVALID
;
3
]
;
for
(
key
dep
)
in
prim_data
.
kind
.
yuv_key
.
iter
(
)
.
cloned
(
)
.
zip
(
image_dependencies
.
iter_mut
(
)
)
{
*
dep
=
ImageDependency
{
key
generation
:
resource_cache
.
get_image_generation
(
key
)
}
}
promotion_result
=
self
.
setup_compositor_surfaces_yuv
(
sub_slice_index
&
mut
prim_info
prim_data
.
common
.
flags
local_prim_rect
prim_clip_chain
prim_spatial_node_index
pic_coverage_rect
frame_context
data_stores
clip_store
&
image_dependencies
&
prim_data
.
kind
.
yuv_key
resource_cache
composite_state
gpu_buffer
prim_data
.
kind
.
image_rendering
prim_data
.
kind
.
color_depth
prim_data
.
kind
.
color_space
.
with_range
(
prim_data
.
kind
.
color_range
)
prim_data
.
kind
.
format
kind
)
;
}
}
if
let
Ok
(
kind
)
=
promotion_result
{
*
compositor_surface_kind
=
kind
;
if
kind
=
=
CompositorSurfaceKind
:
:
Overlay
{
profile
.
inc
(
profiler
:
:
COMPOSITOR_SURFACE_OVERLAYS
)
;
return
VisibilityState
:
:
Culled
;
}
profile
.
inc
(
profiler
:
:
COMPOSITOR_SURFACE_UNDERLAYS
)
;
}
else
{
self
.
report_promotion_failure
(
promotion_result
pic_coverage_rect
false
)
;
*
compositor_surface_kind
=
CompositorSurfaceKind
:
:
Blit
;
if
prim_data
.
common
.
flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
profile
.
inc
(
profiler
:
:
COMPOSITOR_SURFACE_BLITS
)
;
}
}
if
*
compositor_surface_kind
=
=
CompositorSurfaceKind
:
:
Blit
{
prim_info
.
images
.
extend
(
prim_data
.
kind
.
yuv_key
.
iter
(
)
.
map
(
|
key
|
{
ImageDependency
{
key
:
*
key
generation
:
resource_cache
.
get_image_generation
(
*
key
)
}
}
)
)
;
}
}
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
=
>
{
let
border_data
=
&
data_stores
.
image_border
[
data_handle
]
.
kind
;
prim_info
.
images
.
push
(
ImageDependency
{
key
:
border_data
.
request
.
key
generation
:
resource_cache
.
get_image_generation
(
border_data
.
request
.
key
)
}
)
;
}
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
CachedLinearGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
linear_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
ConicGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
conic_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
radial_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
BackdropCapture
{
.
.
}
=
>
{
}
PrimitiveInstanceKind
:
:
BackdropRender
{
pic_index
.
.
}
=
>
{
if
!
pic_coverage_rect
.
is_empty
(
)
{
scratch
.
required_sub_graphs
.
insert
(
pic_index
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
let
mut
surface_info
=
Vec
:
:
new
(
)
;
for
(
pic_index
surface_index
)
in
surface_stack
.
iter
(
)
.
rev
(
)
{
let
pic
=
&
pictures
[
pic_index
.
0
]
;
surface_info
.
push
(
(
pic
.
composite_mode
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
*
surface_index
)
)
;
}
for
y
in
p0
.
y
.
.
p1
.
y
{
for
x
in
p0
.
x
.
.
p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
cached_surface
.
sub_graphs
.
push
(
(
pic_coverage_rect
surface_info
.
clone
(
)
)
)
;
}
}
self
.
deferred_dirty_tests
.
push
(
DeferredDirtyTest
{
tile_rect
:
TileRect
:
:
new
(
p0
p1
)
prim_rect
:
pic_coverage_rect
}
)
;
}
}
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
BoxShadow
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
=
>
{
}
}
;
let
visible_local_clip_rect
=
self
.
local_clip_rect
.
intersection
(
&
self
.
screen_rect_in_pic_space
)
.
unwrap_or_default
(
)
;
if
pic_coverage_rect
.
intersects
(
&
visible_local_clip_rect
)
{
self
.
found_prims_after_backdrop
=
true
;
}
let
mut
vis_flags
=
PrimitiveVisibilityFlags
:
:
empty
(
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
if
let
Some
(
mut
backdrop_candidate
)
=
backdrop_candidate
{
match
backdrop_candidate
.
kind
{
Some
(
BackdropKind
:
:
Color
{
.
.
}
)
|
None
=
>
{
let
surface
=
&
mut
surfaces
[
prim_surface_index
.
0
]
;
let
is_same_coord_system
=
frame_context
.
spatial_tree
.
is_matching_coord_system
(
prim_spatial_node_index
surface
.
surface_spatial_node_index
)
;
if
is_same_coord_system
&
&
!
prim_clip_chain
.
needs_mask
&
&
prim_clip_chain
.
pic_coverage_rect
.
contains_box
(
&
surface
.
unclipped_local_rect
)
{
surface
.
is_opaque
=
true
;
}
}
}
let
same_coord_system
=
frame_context
.
spatial_tree
.
is_matching_coord_system
(
prim_spatial_node_index
self
.
spatial_node_index
)
;
let
is_suitable_backdrop
=
same_coord_system
&
&
on_picture_surface
;
if
sub_slice_index
=
=
0
&
&
is_suitable_backdrop
&
&
sub_slice
.
compositor_surfaces
.
is_empty
(
)
{
if
prim_clip_chain
.
needs_mask
{
backdrop_candidate
.
opaque_rect
=
clip_store
.
get_inner_rect_for_clip_chain
(
prim_clip_chain
&
data_stores
.
clip
frame_context
.
spatial_tree
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
;
}
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
self
.
backdrop
.
opaque_rect
)
{
self
.
backdrop
.
opaque_rect
=
backdrop_candidate
.
opaque_rect
;
}
if
let
Some
(
kind
)
=
backdrop_candidate
.
kind
{
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
visible_local_clip_rect
)
{
self
.
found_prims_after_backdrop
=
false
;
self
.
backdrop
.
kind
=
Some
(
kind
)
;
self
.
backdrop
.
backdrop_rect
=
backdrop_candidate
.
opaque_rect
;
let
BackdropKind
:
:
Color
{
color
}
=
kind
;
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
self
.
local_rect
)
{
vis_flags
|
=
PrimitiveVisibilityFlags
:
:
IS_BACKDROP
;
self
.
backdrop
.
spanning_opaque_color
=
Some
(
color
)
;
}
}
}
}
}
for
spatial_node_index
in
&
prim_info
.
spatial_nodes
{
self
.
spatial_node_comparer
.
register_used_transform
(
*
spatial_node_index
self
.
frame_id
frame_context
.
spatial_tree
)
;
}
for
y
in
p0
.
y
.
.
p1
.
y
{
for
x
in
p0
.
x
.
.
p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
add_prim_dependency
(
&
prim_info
)
;
}
}
VisibilityState
:
:
Visible
{
vis_flags
sub_slice_index
:
SubSliceIndex
:
:
new
(
sub_slice_index
)
}
}
pub
fn
print
(
&
self
)
{
let
mut
pt
=
PrintTree
:
:
new
(
"
Picture
Cache
"
)
;
pt
.
new_level
(
format
!
(
"
Slice
{
:
?
}
"
self
.
slice
)
)
;
pt
.
add_item
(
format
!
(
"
background_color
:
{
:
?
}
"
self
.
background_color
)
)
;
for
(
sub_slice_index
sub_slice
)
in
self
.
sub_slices
.
iter
(
)
.
enumerate
(
)
{
pt
.
new_level
(
format
!
(
"
SubSlice
{
:
?
}
"
sub_slice_index
)
)
;
for
y
in
self
.
tile_bounds_p0
.
y
.
.
self
.
tile_bounds_p1
.
y
{
for
x
in
self
.
tile_bounds_p0
.
x
.
.
self
.
tile_bounds_p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
&
sub_slice
.
tiles
[
&
key
]
;
tile
.
print
(
&
mut
pt
)
;
}
}
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
fn
calculate_subpixel_mode
(
&
self
)
-
>
SubpixelMode
{
if
self
.
underlays
.
is_empty
(
)
{
let
has_opaque_bg_color
=
self
.
background_color
.
map_or
(
false
|
c
|
c
.
a
>
=
1
.
0
)
;
if
has_opaque_bg_color
{
return
SubpixelMode
:
:
Allow
;
}
if
self
.
backdrop
.
opaque_rect
.
contains_box
(
&
self
.
local_rect
)
{
return
SubpixelMode
:
:
Allow
;
}
}
if
self
.
backdrop
.
opaque_rect
.
is_empty
(
)
{
return
SubpixelMode
:
:
Deny
;
}
let
prohibited_rect
=
self
.
underlays
.
iter
(
)
.
fold
(
PictureRect
:
:
zero
(
)
|
acc
underlay
|
{
acc
.
union
(
&
underlay
.
local_rect
)
}
)
;
SubpixelMode
:
:
Conditional
{
allowed_rect
:
self
.
backdrop
.
opaque_rect
prohibited_rect
}
}
pub
fn
post_update
(
&
mut
self
frame_context
:
&
FrameVisibilityContext
composite_state
:
&
mut
CompositeState
resource_cache
:
&
mut
ResourceCache
)
{
assert
!
(
self
.
current_surface_traversal_depth
=
=
0
)
;
let
visibility_node
=
frame_context
.
spatial_tree
.
root_reference_frame_index
(
)
;
self
.
dirty_region
.
reset
(
visibility_node
self
.
spatial_node_index
)
;
self
.
subpixel_mode
=
self
.
calculate_subpixel_mode
(
)
;
self
.
transform_index
=
composite_state
.
register_transform
(
self
.
local_to_raster
self
.
raster_to_device
)
;
let
map_pic_to_world
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
self
.
external_native_surface_cache
.
retain
(
|
_
surface
|
{
if
!
surface
.
used_this_frame
{
composite_state
.
dirty_rects_are_valid
=
false
;
resource_cache
.
destroy_compositor_surface
(
surface
.
native_surface_id
)
;
}
surface
.
used_this_frame
}
)
;
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
let
ctx
=
TileUpdateDirtyContext
{
pic_to_world_mapper
global_device_pixel_scale
:
frame_context
.
global_device_pixel_scale
opacity_bindings
:
&
self
.
opacity_bindings
color_bindings
:
&
self
.
color_bindings
local_rect
:
self
.
local_rect
invalidate_all
:
self
.
invalidate_all_tiles
}
;
let
mut
state
=
TileUpdateDirtyState
{
resource_cache
composite_state
compare_cache
:
&
mut
self
.
compare_cache
spatial_node_comparer
:
&
mut
self
.
spatial_node_comparer
}
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
update_dirty_and_valid_rects
(
&
ctx
&
mut
state
frame_context
)
;
}
}
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
dirty_test
in
self
.
deferred_dirty_tests
.
drain
(
.
.
)
{
let
mut
total_dirty_rect
=
PictureRect
:
:
zero
(
)
;
for
y
in
dirty_test
.
tile_rect
.
min
.
y
.
.
dirty_test
.
tile_rect
.
max
.
y
{
for
x
in
dirty_test
.
tile_rect
.
min
.
x
.
.
dirty_test
.
tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
total_dirty_rect
=
total_dirty_rect
.
union
(
&
tile
.
cached_surface
.
local_dirty_rect
)
;
}
}
if
total_dirty_rect
.
intersects
(
&
dirty_test
.
prim_rect
)
{
for
y
in
dirty_test
.
tile_rect
.
min
.
y
.
.
dirty_test
.
tile_rect
.
max
.
y
{
for
x
in
dirty_test
.
tile_rect
.
min
.
x
.
.
dirty_test
.
tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
invalidate
(
Some
(
dirty_test
.
prim_rect
)
InvalidationReason
:
:
SurfaceContentChanged
)
;
}
}
}
}
}
let
mut
ctx
=
TilePostUpdateContext
{
local_clip_rect
:
self
.
local_clip_rect
backdrop
:
None
current_tile_size
:
self
.
current_tile_size
z_id
:
ZBufferId
:
:
invalid
(
)
underlays
:
&
self
.
underlays
}
;
let
mut
state
=
TilePostUpdateState
{
resource_cache
composite_state
}
;
for
(
i
sub_slice
)
in
self
.
sub_slices
.
iter_mut
(
)
.
enumerate
(
)
.
rev
(
)
{
if
i
=
=
0
{
ctx
.
backdrop
=
Some
(
self
.
backdrop
)
;
}
for
compositor_surface
in
sub_slice
.
compositor_surfaces
.
iter_mut
(
)
.
rev
(
)
{
compositor_surface
.
descriptor
.
z_id
=
state
.
composite_state
.
z_generator
.
next
(
)
;
}
ctx
.
z_id
=
state
.
composite_state
.
z_generator
.
next
(
)
;
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
post_update
(
&
ctx
&
mut
state
frame_context
)
;
}
}
for
underlay
in
self
.
underlays
.
iter_mut
(
)
.
rev
(
)
{
underlay
.
z_id
=
state
.
composite_state
.
z_generator
.
next
(
)
;
}
for
underlay
in
&
self
.
underlays
{
if
let
Some
(
world_surface_rect
)
=
underlay
.
get_occluder_rect
(
&
self
.
local_clip_rect
&
map_pic_to_world
)
{
composite_state
.
register_occluder
(
underlay
.
z_id
world_surface_rect
self
.
compositor_clip
)
;
}
}
for
sub_slice
in
&
self
.
sub_slices
{
for
compositor_surface
in
&
sub_slice
.
compositor_surfaces
{
if
compositor_surface
.
is_opaque
{
if
let
Some
(
world_surface_rect
)
=
compositor_surface
.
descriptor
.
get_occluder_rect
(
&
self
.
local_clip_rect
&
map_pic_to_world
)
{
composite_state
.
register_occluder
(
compositor_surface
.
descriptor
.
z_id
world_surface_rect
self
.
compositor_clip
)
;
}
}
}
}
if
!
self
.
backdrop
.
opaque_rect
.
is_empty
(
)
{
let
z_id_backdrop
=
composite_state
.
z_generator
.
next
(
)
;
let
backdrop_rect
=
self
.
backdrop
.
opaque_rect
.
intersection
(
&
self
.
local_rect
)
.
and_then
(
|
r
|
{
r
.
intersection
(
&
self
.
local_clip_rect
)
}
)
;
if
let
Some
(
backdrop_rect
)
=
backdrop_rect
{
let
world_backdrop_rect
=
map_pic_to_world
.
map
(
&
backdrop_rect
)
.
expect
(
"
bug
:
unable
to
map
backdrop
to
world
space
"
)
;
composite_state
.
register_occluder
(
z_id_backdrop
world_backdrop_rect
self
.
compositor_clip
)
;
}
}
}
}
pub
struct
SubSlice
{
pub
tiles
:
FastHashMap
<
TileOffset
Box
<
Tile
>
>
pub
native_surface
:
Option
<
NativeSurface
>
pub
compositor_surfaces
:
Vec
<
CompositorSurface
>
pub
composite_tiles
:
Vec
<
CompositeTile
>
pub
opaque_tile_descriptors
:
Vec
<
CompositeTileDescriptor
>
pub
alpha_tile_descriptors
:
Vec
<
CompositeTileDescriptor
>
}
impl
SubSlice
{
fn
new
(
)
-
>
Self
{
SubSlice
{
tiles
:
FastHashMap
:
:
default
(
)
native_surface
:
None
compositor_surfaces
:
Vec
:
:
new
(
)
composite_tiles
:
Vec
:
:
new
(
)
opaque_tile_descriptors
:
Vec
:
:
new
(
)
alpha_tile_descriptors
:
Vec
:
:
new
(
)
}
}
fn
reset
(
&
mut
self
)
{
self
.
compositor_surfaces
.
clear
(
)
;
self
.
composite_tiles
.
clear
(
)
;
self
.
opaque_tile_descriptors
.
clear
(
)
;
self
.
alpha_tile_descriptors
.
clear
(
)
;
}
fn
resize
(
&
mut
self
new_tile_rect
:
TileRect
)
-
>
FastHashMap
<
TileOffset
Box
<
Tile
>
>
{
let
mut
old_tiles
=
mem
:
:
replace
(
&
mut
self
.
tiles
FastHashMap
:
:
default
(
)
)
;
self
.
tiles
.
reserve
(
new_tile_rect
.
area
(
)
as
usize
)
;
for
y
in
new_tile_rect
.
min
.
y
.
.
new_tile_rect
.
max
.
y
{
for
x
in
new_tile_rect
.
min
.
x
.
.
new_tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
old_tiles
.
remove
(
&
key
)
.
unwrap_or_else
(
|
|
{
Box
:
:
new
(
Tile
:
:
new
(
key
)
)
}
)
;
self
.
tiles
.
insert
(
key
tile
)
;
}
}
old_tiles
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
enum
SurfacePromotionFailure
{
ImageWaitingOnYuvImage
NotPremultipliedAlpha
OverlaySurfaceLimit
OverlayNeedsMask
UnderlayAlphaBackdrop
UnderlaySurfaceLimit
UnderlayIntersectsOverlay
UnderlayLowQualityZoom
NotRootTileCache
ComplexTransform
SliceAtomic
SizeTooLarge
}
impl
Display
for
SurfacePromotionFailure
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
Result
<
(
)
Error
>
{
write
!
(
f
"
{
}
"
match
*
self
{
SurfacePromotionFailure
:
:
ImageWaitingOnYuvImage
=
>
"
Image
prim
waiting
for
all
YuvImage
prims
to
be
considered
for
promotion
"
SurfacePromotionFailure
:
:
NotPremultipliedAlpha
=
>
"
does
not
use
premultiplied
alpha
"
SurfacePromotionFailure
:
:
OverlaySurfaceLimit
=
>
"
hit
the
overlay
surface
limit
"
SurfacePromotionFailure
:
:
OverlayNeedsMask
=
>
"
overlay
not
allowed
for
prim
with
mask
"
SurfacePromotionFailure
:
:
UnderlayAlphaBackdrop
=
>
"
underlay
requires
an
opaque
backdrop
"
SurfacePromotionFailure
:
:
UnderlaySurfaceLimit
=
>
"
hit
the
underlay
surface
limit
"
SurfacePromotionFailure
:
:
UnderlayIntersectsOverlay
=
>
"
underlay
intersects
already
-
promoted
overlay
"
SurfacePromotionFailure
:
:
UnderlayLowQualityZoom
=
>
"
underlay
not
allowed
during
low
-
quality
pinch
zoom
"
SurfacePromotionFailure
:
:
NotRootTileCache
=
>
"
is
not
on
a
root
tile
cache
"
SurfacePromotionFailure
:
:
ComplexTransform
=
>
"
has
a
complex
transform
"
SurfacePromotionFailure
:
:
SliceAtomic
=
>
"
slice
is
atomic
"
SurfacePromotionFailure
:
:
SizeTooLarge
=
>
"
surface
is
too
large
for
compositor
"
}
.
to_owned
(
)
)
}
}
struct
TilePreUpdateContext
{
pic_to_world_mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
background_color
:
Option
<
ColorF
>
global_screen_world_rect
:
WorldRect
tile_size
:
PictureSize
frame_id
:
FrameId
}
struct
TilePostUpdateContext
<
'
a
>
{
local_clip_rect
:
PictureRect
backdrop
:
Option
<
BackdropInfo
>
current_tile_size
:
DeviceIntSize
z_id
:
ZBufferId
underlays
:
&
'
a
[
ExternalSurfaceDescriptor
]
}
struct
TilePostUpdateState
<
'
a
>
{
resource_cache
:
&
'
a
mut
ResourceCache
composite_state
:
&
'
a
mut
CompositeState
}
