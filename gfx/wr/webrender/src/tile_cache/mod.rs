pub
mod
slice_builder
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
intern
:
:
ItemUid
;
use
crate
:
:
internal_types
:
:
FrameId
;
use
peek_poke
:
:
PeekPoke
;
use
std
:
:
{
marker
u32
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
pub
use
self
:
:
slice_builder
:
:
{
TileCacheBuilder
TileCacheConfig
PictureCacheDebugInfo
SliceDebugInfo
DirtyTileDebugInfo
TileDebugInfo
}
;
pub
use
api
:
:
units
:
:
TileOffset
;
pub
use
api
:
:
units
:
:
TileRange
as
TileRect
;
pub
const
MAX_COMPOSITOR_SURFACES
:
usize
=
4
;
pub
const
TILE_SIZE_DEFAULT
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
512
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_HORIZONTAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
32
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_VERTICAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
32
height
:
1024
_unit
:
marker
:
:
PhantomData
}
;
pub
const
MAX_SURFACE_SIZE
:
usize
=
4096
;
static
NEXT_TILE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
Ord
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileId
(
pub
usize
)
;
impl
TileId
{
pub
fn
new
(
)
-
>
TileId
{
TileId
(
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
}
}
#
[
doc
(
hidden
)
]
pub
fn
next_tile_id
(
)
-
>
usize
{
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Hash
Eq
)
]
pub
struct
TileKey
{
pub
tile_offset
:
TileOffset
pub
sub_slice_index
:
SubSliceIndex
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveDependencyIndex
(
pub
u32
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
PeekPoke
)
]
pub
struct
SubSliceIndex
(
pub
u8
)
;
impl
SubSliceIndex
{
pub
const
DEFAULT
:
SubSliceIndex
=
SubSliceIndex
(
0
)
;
pub
fn
new
(
index
:
usize
)
-
>
Self
{
SubSliceIndex
(
index
as
u8
)
}
pub
fn
is_primary
(
&
self
)
-
>
bool
{
self
.
0
=
=
0
}
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
as
usize
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveDescriptor
{
pub
prim_uid
:
ItemUid
pub
prim_clip_box
:
PictureBox2D
pub
dep_offset
:
u32
pub
dep_count
:
u32
}
impl
PartialEq
for
PrimitiveDescriptor
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
if
self
.
prim_uid
!
=
other
.
prim_uid
{
return
false
;
}
use
euclid
:
:
approxeq
:
:
ApproxEq
;
if
!
self
.
prim_clip_box
.
min
.
x
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
min
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
min
.
y
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
min
.
y
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
max
.
x
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
max
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
max
.
y
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
max
.
y
&
EPSILON
)
{
return
false
;
}
if
self
.
dep_count
!
=
other
.
dep_count
{
return
false
;
}
true
}
}
impl
PartialEq
<
PrimitiveDescriptor
>
for
(
&
ItemUid
&
PictureBox2D
)
{
fn
eq
(
&
self
other
:
&
PrimitiveDescriptor
)
-
>
bool
{
self
.
0
=
=
&
other
.
prim_uid
&
&
self
.
1
=
=
&
other
.
prim_clip_box
}
}
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileDescriptor
{
pub
prims
:
Vec
<
PrimitiveDescriptor
>
pub
local_valid_rect
:
PictureRect
pub
last_updated_frame_id
:
FrameId
pub
dep_data
:
Vec
<
u8
>
}
impl
TileDescriptor
{
pub
fn
new
(
)
-
>
Self
{
TileDescriptor
{
local_valid_rect
:
PictureRect
:
:
zero
(
)
dep_data
:
Vec
:
:
new
(
)
prims
:
Vec
:
:
new
(
)
last_updated_frame_id
:
FrameId
:
:
INVALID
}
}
pub
fn
print
(
&
self
pt
:
&
mut
dyn
crate
:
:
print_tree
:
:
PrintTreePrinter
)
{
pt
.
new_level
(
"
current_descriptor
"
.
to_string
(
)
)
;
pt
.
new_level
(
"
prims
"
.
to_string
(
)
)
;
for
prim
in
&
self
.
prims
{
pt
.
new_level
(
format
!
(
"
prim
uid
=
{
}
"
prim
.
prim_uid
.
get_uid
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
clip
:
p0
=
{
}
{
}
p1
=
{
}
{
}
"
prim
.
prim_clip_box
.
min
.
x
prim
.
prim_clip_box
.
min
.
y
prim
.
prim_clip_box
.
max
.
x
prim
.
prim_clip_box
.
max
.
y
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
pt
.
end_level
(
)
;
}
pub
fn
clear
(
&
mut
self
)
{
self
.
local_valid_rect
=
PictureRect
:
:
zero
(
)
;
self
.
prims
.
clear
(
)
;
self
.
dep_data
.
clear
(
)
;
}
}
