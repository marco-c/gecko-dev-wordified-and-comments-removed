use
api
:
:
units
:
:
*
;
use
crate
:
:
box_shadow
:
:
BLUR_SAMPLE_SCALE
;
use
crate
:
:
command_buffer
:
:
{
CommandBufferBuilderKind
CommandBufferList
CommandBufferBuilder
CommandBufferIndex
}
;
use
crate
:
:
gpu_types
:
:
UvRectKind
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
Filter
}
;
use
crate
:
:
picture
:
:
PictureCompositeMode
;
use
crate
:
:
svg_filter
:
:
get_coverage_source_svgfe
;
use
crate
:
:
tile_cache
:
:
{
TileKey
SubSliceIndex
MAX_COMPOSITOR_SURFACES
}
;
use
crate
:
:
prim_store
:
:
PictureIndex
;
use
crate
:
:
profiler
;
use
crate
:
:
render_task_graph
:
:
{
RenderTaskId
RenderTaskGraphBuilder
}
;
use
crate
:
:
render_target
:
:
ResolveOp
;
use
crate
:
:
render_task
:
:
{
RenderTask
RenderTaskKind
RenderTaskLocation
}
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
spatial_tree
:
:
{
SpatialTree
SpatialNodeIndex
}
;
use
crate
:
:
util
:
:
MaxRect
;
use
crate
:
:
visibility
:
:
{
VisibilityState
PrimitiveVisibility
FrameVisibilityContext
}
;
use
core
:
:
time
:
:
Duration
;
use
euclid
:
:
Scale
;
const
MAX_BLUR_RADIUS
:
f32
=
100
.
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceIndex
(
pub
usize
)
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
SubpixelMode
{
Allow
Deny
Conditional
{
allowed_rect
:
PictureRect
prohibited_rect
:
PictureRect
}
}
pub
struct
SurfaceInfo
{
pub
unclipped_local_rect
:
PictureRect
pub
clipped_local_rect
:
PictureRect
pub
clipping_rect
:
PictureRect
pub
culling_rect
:
VisRect
pub
map_local_to_picture
:
SpaceMapper
<
LayoutPixel
PicturePixel
>
pub
surface_spatial_node_index
:
SpatialNodeIndex
pub
raster_spatial_node_index
:
SpatialNodeIndex
pub
visibility_spatial_node_index
:
SpatialNodeIndex
pub
device_pixel_scale
:
DevicePixelScale
pub
world_scale_factors
:
(
f32
f32
)
pub
local_scale
:
(
f32
f32
)
pub
is_opaque
:
bool
pub
allow_snapping
:
bool
pub
force_scissor_rect
:
bool
}
impl
SurfaceInfo
{
pub
fn
new
(
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
world_rect
:
WorldRect
spatial_tree
:
&
SpatialTree
device_pixel_scale
:
DevicePixelScale
world_scale_factors
:
(
f32
f32
)
local_scale
:
(
f32
f32
)
allow_snapping
:
bool
force_scissor_rect
:
bool
)
-
>
Self
{
let
map_surface_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
surface_spatial_node_index
world_rect
spatial_tree
)
;
let
pic_bounds
=
map_surface_to_world
.
unmap
(
&
map_surface_to_world
.
bounds
)
.
unwrap_or_else
(
PictureRect
:
:
max_rect
)
;
let
map_local_to_picture
=
SpaceMapper
:
:
new
(
surface_spatial_node_index
pic_bounds
)
;
let
visibility_spatial_node_index
=
spatial_tree
.
root_reference_frame_index
(
)
;
SurfaceInfo
{
unclipped_local_rect
:
PictureRect
:
:
zero
(
)
clipped_local_rect
:
PictureRect
:
:
zero
(
)
is_opaque
:
false
clipping_rect
:
PictureRect
:
:
zero
(
)
map_local_to_picture
raster_spatial_node_index
surface_spatial_node_index
visibility_spatial_node_index
device_pixel_scale
world_scale_factors
local_scale
allow_snapping
force_scissor_rect
culling_rect
:
world_rect
.
cast_unit
(
)
}
}
pub
fn
clamp_blur_radius
(
&
self
x_blur_radius
:
f32
y_blur_radius
:
f32
)
-
>
(
f32
f32
)
{
let
sx_blur_radius
=
x_blur_radius
*
self
.
local_scale
.
0
;
let
sy_blur_radius
=
y_blur_radius
*
self
.
local_scale
.
1
;
let
largest_scaled_blur_radius
=
f32
:
:
max
(
sx_blur_radius
*
self
.
world_scale_factors
.
0
sy_blur_radius
*
self
.
world_scale_factors
.
1
)
;
if
largest_scaled_blur_radius
>
MAX_BLUR_RADIUS
{
let
sf
=
MAX_BLUR_RADIUS
/
largest_scaled_blur_radius
;
(
x_blur_radius
*
sf
y_blur_radius
*
sf
)
}
else
{
(
x_blur_radius
y_blur_radius
)
}
}
pub
fn
update_culling_rect
(
&
mut
self
parent_culling_rect
:
VisRect
composite_mode
:
&
PictureCompositeMode
frame_context
:
&
FrameVisibilityContext
)
{
self
.
culling_rect
=
parent_culling_rect
;
if
let
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
width
height
should_inflate
.
.
}
)
=
composite_mode
{
if
*
should_inflate
{
let
map_surface_to_vis
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
surface_spatial_node_index
parent_culling_rect
frame_context
.
spatial_tree
)
;
if
let
Some
(
local_parent_culling_rect
)
=
map_surface_to_vis
.
unmap
(
&
parent_culling_rect
)
{
let
(
width_factor
height_factor
)
=
self
.
clamp_blur_radius
(
*
width
*
height
)
;
let
expanded_rect
:
PictureBox2D
=
local_parent_culling_rect
.
inflate
(
width_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
height_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
)
;
if
let
Some
(
rect
)
=
map_surface_to_vis
.
map
(
&
expanded_rect
)
{
self
.
culling_rect
=
rect
;
}
}
}
}
}
pub
fn
map_to_device_rect
(
&
self
picture_rect
:
&
PictureRect
spatial_tree
:
&
SpatialTree
)
-
>
DeviceRect
{
let
raster_rect
=
if
self
.
raster_spatial_node_index
!
=
self
.
surface_spatial_node_index
{
assert_eq
!
(
self
.
device_pixel_scale
.
0
1
.
0
)
;
assert_eq
!
(
self
.
raster_spatial_node_index
spatial_tree
.
root_reference_frame_index
(
)
)
;
let
pic_to_raster
=
SpaceMapper
:
:
new_with_target
(
self
.
raster_spatial_node_index
self
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
pic_to_raster
.
map
(
&
picture_rect
)
.
unwrap
(
)
}
else
{
picture_rect
.
cast_unit
(
)
}
;
raster_rect
*
self
.
device_pixel_scale
}
pub
fn
get_surface_rect
(
&
self
local_rect
:
&
PictureRect
spatial_tree
:
&
SpatialTree
)
-
>
Option
<
DeviceIntRect
>
{
let
local_rect
=
match
local_rect
.
intersection
(
&
self
.
clipping_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
raster_rect
=
if
self
.
raster_spatial_node_index
!
=
self
.
surface_spatial_node_index
{
assert_eq
!
(
self
.
device_pixel_scale
.
0
1
.
0
)
;
let
local_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
self
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
local_to_world
.
map
(
&
local_rect
)
.
unwrap
(
)
}
else
{
assert
!
(
self
.
device_pixel_scale
.
0
>
0
.
0
)
;
local_rect
.
cast_unit
(
)
}
;
let
surface_rect
=
(
raster_rect
*
self
.
device_pixel_scale
)
.
round_out
(
)
.
to_i32
(
)
;
if
surface_rect
.
is_empty
(
)
{
return
None
;
}
Some
(
surface_rect
)
}
}
#
[
derive
(
Debug
)
]
pub
struct
SurfaceAllocInfo
{
pub
task_size
:
DeviceIntSize
pub
needs_scissor_rect
:
bool
pub
clipped
:
DeviceRect
pub
unclipped
:
DeviceRect
pub
source
:
DeviceRect
pub
clipped_notsnapped
:
DeviceRect
pub
clipped_local
:
PictureRect
pub
uv_rect_kind
:
UvRectKind
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceTileDescriptor
{
pub
current_task_id
:
RenderTaskId
pub
composite_task_id
:
Option
<
RenderTaskId
>
pub
dirty_rect
:
PictureRect
}
pub
enum
SurfaceDescriptorKind
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
}
Simple
{
render_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
}
Chained
{
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
}
}
pub
struct
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
}
impl
SurfaceDescriptor
{
pub
fn
new_tiled
(
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
}
}
pub
fn
new_chained
(
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
dirty_rect
}
}
}
pub
fn
new_simple
(
render_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
dirty_rect
}
}
}
}
struct
CommandBufferTargets
{
available_cmd_buffers
:
Vec
<
Vec
<
(
PictureRect
CommandBufferIndex
)
>
>
}
impl
CommandBufferTargets
{
fn
new
(
)
-
>
Self
{
CommandBufferTargets
{
available_cmd_buffers
:
vec
!
[
Vec
:
:
new
(
)
;
MAX_COMPOSITOR_SURFACES
+
1
]
}
}
fn
init
(
&
mut
self
cb
:
&
CommandBufferBuilder
rg_builder
:
&
RenderTaskGraphBuilder
)
{
for
available_cmd_buffers
in
&
mut
self
.
available_cmd_buffers
{
available_cmd_buffers
.
clear
(
)
;
}
match
cb
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
.
.
}
=
>
{
for
(
key
desc
)
in
tiles
{
let
task
=
rg_builder
.
get_task
(
desc
.
current_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
let
available_cmd_buffers
=
&
mut
self
.
available_cmd_buffers
[
key
.
sub_slice_index
.
as_usize
(
)
]
;
available_cmd_buffers
.
push
(
(
desc
.
dirty_rect
info
.
cmd_buffer_index
)
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
dirty_rect
.
.
}
=
>
{
let
task
=
rg_builder
.
get_task
(
render_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
for
sub_slice_buffer
in
&
mut
self
.
available_cmd_buffers
{
sub_slice_buffer
.
push
(
(
dirty_rect
info
.
cmd_buffer_index
)
)
;
}
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
}
}
;
}
fn
get_cmd_buffer_targets_for_rect
(
&
mut
self
rect
:
&
PictureRect
sub_slice_index
:
SubSliceIndex
targets
:
&
mut
Vec
<
CommandBufferIndex
>
)
-
>
bool
{
for
(
dirty_rect
cmd_buffer_index
)
in
&
self
.
available_cmd_buffers
[
sub_slice_index
.
as_usize
(
)
]
{
if
dirty_rect
.
intersects
(
rect
)
{
targets
.
push
(
*
cmd_buffer_index
)
;
}
}
!
targets
.
is_empty
(
)
}
}
pub
struct
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
builder_stack
:
Vec
<
CommandBufferBuilder
>
pub
sub_graph_output_map
:
FastHashMap
<
PictureIndex
RenderTaskId
>
}
impl
SurfaceBuilder
{
pub
fn
new
(
)
-
>
Self
{
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
:
:
new
(
)
builder_stack
:
Vec
:
:
new
(
)
sub_graph_output_map
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
register_resolve_source
(
&
mut
self
)
{
let
surface_task_id
=
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
panic
!
(
"
bug
:
only
supported
for
non
-
tiled
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
render_task_id
}
;
for
builder
in
self
.
builder_stack
.
iter_mut
(
)
.
rev
(
)
{
if
builder
.
establishes_sub_graph
{
assert_eq
!
(
builder
.
resolve_source
None
)
;
builder
.
resolve_source
=
Some
(
surface_task_id
)
;
return
;
}
}
unreachable
!
(
"
bug
:
resolve
source
with
no
sub
-
graph
"
)
;
}
pub
fn
push_surface
(
&
mut
self
surface_index
:
SurfaceIndex
is_sub_graph
:
bool
clipping_rect
:
PictureRect
descriptor
:
Option
<
SurfaceDescriptor
>
surfaces
:
&
mut
[
SurfaceInfo
]
rg_builder
:
&
RenderTaskGraphBuilder
)
{
surfaces
[
surface_index
.
0
]
.
clipping_rect
=
clipping_rect
;
let
builder
=
if
let
Some
(
descriptor
)
=
descriptor
{
match
descriptor
.
kind
{
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
=
>
{
CommandBufferBuilder
:
:
new_tiled
(
tiles
)
}
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
dirty_rect
.
.
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
None
dirty_rect
)
}
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
dirty_rect
.
.
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
Some
(
root_task_id
)
dirty_rect
)
}
}
}
else
{
CommandBufferBuilder
:
:
empty
(
)
}
;
self
.
current_cmd_buffers
.
init
(
&
builder
rg_builder
)
;
self
.
builder_stack
.
push
(
builder
)
;
}
pub
fn
add_child_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
rg_builder
:
&
mut
RenderTaskGraphBuilder
)
{
let
builder
=
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
;
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
render_task_id
child_task_id
)
;
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
}
pub
fn
add_picture_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
)
{
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
extra_dependencies
.
push
(
child_task_id
)
;
}
pub
fn
get_cmd_buffer_targets_for_prim
(
&
mut
self
vis
:
&
PrimitiveVisibility
targets
:
&
mut
Vec
<
CommandBufferIndex
>
)
-
>
bool
{
targets
.
clear
(
)
;
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Culled
=
>
{
false
}
VisibilityState
:
:
Visible
{
sub_slice_index
.
.
}
=
>
{
self
.
current_cmd_buffers
.
get_cmd_buffer_targets_for_rect
(
&
vis
.
clip_chain
.
pic_coverage_rect
sub_slice_index
targets
)
}
VisibilityState
:
:
PassThrough
=
>
{
true
}
}
}
pub
fn
pop_empty_surface
(
&
mut
self
)
{
let
builder
=
self
.
builder_stack
.
pop
(
)
.
unwrap
(
)
;
assert
!
(
!
builder
.
establishes_sub_graph
)
;
}
pub
fn
pop_surface
(
&
mut
self
pic_index
:
PictureIndex
rg_builder
:
&
mut
RenderTaskGraphBuilder
cmd_buffers
:
&
mut
CommandBufferList
)
{
let
builder
=
self
.
builder_stack
.
pop
(
)
.
unwrap
(
)
;
if
builder
.
establishes_sub_graph
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
"
bug
:
sub
-
graphs
can
only
be
simple
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_render_task_id
root_task_id
:
child_root_task_id
.
.
}
=
>
{
if
let
Some
(
resolve_task_id
)
=
builder
.
resolve_source
{
let
mut
src_task_ids
=
Vec
:
:
new
(
)
;
let
_old
=
self
.
sub_graph_output_map
.
insert
(
pic_index
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
debug_assert
!
(
_old
.
is_none
(
)
)
;
match
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
mut
tiles
}
=
>
{
let
keys
:
Vec
<
TileKey
>
=
tiles
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
for
key
in
keys
{
let
descriptor
=
tiles
.
remove
(
&
key
)
.
unwrap
(
)
;
let
parent_task_id
=
descriptor
.
current_task_id
;
let
parent_task
=
rg_builder
.
get_task_mut
(
parent_task_id
)
;
match
parent_task
.
location
{
RenderTaskLocation
:
:
Unallocated
{
.
.
}
|
RenderTaskLocation
:
:
Existing
{
.
.
}
=
>
{
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
parent_task_id
)
;
tiles
.
insert
(
key
SurfaceTileDescriptor
{
current_task_id
:
new_task_id
.
.
descriptor
}
)
;
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
tiles
.
insert
(
key
descriptor
)
;
}
_
=
>
{
panic
!
(
"
bug
:
unexpected
task
location
"
)
;
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
ref
mut
parent_task_id
.
.
}
=
>
{
let
parent_task
=
rg_builder
.
get_task_mut
(
*
parent_task_id
)
;
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
:
*
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
*
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
*
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
*
parent_task_id
)
;
*
parent_task_id
=
new_task_id
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
let
dest_task
=
rg_builder
.
get_task_mut
(
resolve_task_id
)
;
match
dest_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
dest_task_info
)
=
>
{
assert
!
(
dest_task_info
.
resolve_op
.
is_none
(
)
)
;
dest_task_info
.
resolve_op
=
Some
(
ResolveOp
{
src_task_ids
dest_task_id
:
resolve_task_id
}
)
}
_
=
>
{
unreachable
!
(
"
bug
:
not
a
picture
"
)
;
}
}
}
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
}
}
else
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
if
let
Some
(
composite_task_id
)
=
descriptor
.
composite_task_id
{
rg_builder
.
add_dependency
(
composite_task_id
descriptor
.
current_task_id
)
;
let
composite_task
=
rg_builder
.
get_task_mut
(
composite_task_id
)
;
match
composite_task
.
kind
{
RenderTaskKind
:
:
TileComposite
(
ref
mut
info
)
=
>
{
info
.
task_id
=
Some
(
descriptor
.
current_task_id
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
tile
composite
"
)
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_task_id
root_task_id
:
child_root_task_id
.
.
}
=
>
{
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
}
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
}
}
}
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
*
task_id
)
;
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
render_task_id
*
task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
self
.
current_cmd_buffers
.
init
(
self
.
builder_stack
.
last
(
)
.
unwrap_or
(
&
CommandBufferBuilder
:
:
empty
(
)
)
rg_builder
)
;
}
pub
fn
finalize
(
self
)
{
assert
!
(
self
.
builder_stack
.
is_empty
(
)
)
;
}
}
pub
fn
calculate_screen_uv
(
p
:
DevicePoint
clipped
:
DeviceRect
)
-
>
DeviceHomogeneousVector
{
DeviceHomogeneousVector
:
:
new
(
(
p
.
x
-
clipped
.
min
.
x
)
/
(
clipped
.
max
.
x
-
clipped
.
min
.
x
)
(
p
.
y
-
clipped
.
min
.
y
)
/
(
clipped
.
max
.
y
-
clipped
.
min
.
y
)
0
.
0
1
.
0
)
}
pub
fn
get_surface_rects
(
surface_index
:
SurfaceIndex
composite_mode
:
&
PictureCompositeMode
parent_surface_index
:
SurfaceIndex
surfaces
:
&
mut
[
SurfaceInfo
]
spatial_tree
:
&
SpatialTree
max_surface_size
:
f32
force_scissor_rect
:
bool
)
-
>
Option
<
SurfaceAllocInfo
>
{
let
parent_surface
=
&
surfaces
[
parent_surface_index
.
0
]
;
let
local_to_parent
=
SpaceMapper
:
:
new_with_target
(
parent_surface
.
surface_spatial_node_index
surfaces
[
surface_index
.
0
]
.
surface_spatial_node_index
parent_surface
.
clipping_rect
spatial_tree
)
;
let
local_clip_rect
=
local_to_parent
.
unmap
(
&
parent_surface
.
clipping_rect
)
.
unwrap_or
(
PictureRect
:
:
max_rect
(
)
)
.
cast_unit
(
)
;
let
surface
=
&
mut
surfaces
[
surface_index
.
0
]
;
let
(
clipped_local
unclipped_local
source_local
)
=
match
composite_mode
{
PictureCompositeMode
:
:
SVGFEGraph
(
ref
filters
)
=
>
{
let
prim_subregion
=
composite_mode
.
get_rect
(
surface
None
)
;
let
visible_subregion
:
LayoutRect
=
prim_subregion
.
cast_unit
(
)
.
intersection
(
&
local_clip_rect
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
.
cast_unit
(
)
;
if
visible_subregion
.
is_empty
(
)
{
return
None
;
}
let
source_potential_subregion
=
get_coverage_source_svgfe
(
filters
visible_subregion
.
cast_unit
(
)
)
;
let
source_subregion
=
source_potential_subregion
.
intersection
(
&
surface
.
unclipped_local_rect
.
cast_unit
(
)
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
let
coverage_subregion
=
source_subregion
.
union
(
&
visible_subregion
)
;
(
coverage_subregion
.
cast_unit
(
)
prim_subregion
.
cast_unit
(
)
source_subregion
.
cast_unit
(
)
)
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
local_prim_rect
=
surface
.
clipped_local_rect
;
let
mut
required_local_rect
=
local_prim_rect
.
intersection
(
&
local_clip_rect
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
;
for
shadow
in
shadows
{
let
(
blur_radius_x
blur_radius_y
)
=
surface
.
clamp_blur_radius
(
shadow
.
blur_radius
shadow
.
blur_radius
)
;
let
blur_inflation_x
=
blur_radius_x
*
BLUR_SAMPLE_SCALE
;
let
blur_inflation_y
=
blur_radius_y
*
BLUR_SAMPLE_SCALE
;
let
local_shadow_rect
=
local_prim_rect
.
translate
(
shadow
.
offset
.
cast_unit
(
)
)
.
inflate
(
blur_inflation_x
blur_inflation_y
)
;
if
let
Some
(
clipped_shadow_rect
)
=
local_clip_rect
.
intersection
(
&
local_shadow_rect
)
{
let
required_shadow_rect
=
clipped_shadow_rect
.
inflate
(
blur_inflation_x
blur_inflation_y
)
;
let
local_clipped_shadow_rect
=
required_shadow_rect
.
translate
(
-
shadow
.
offset
.
cast_unit
(
)
)
;
required_local_rect
=
required_local_rect
.
union
(
&
local_clipped_shadow_rect
)
;
}
}
let
unclipped
=
composite_mode
.
get_rect
(
surface
None
)
;
let
clipped
=
required_local_rect
;
let
clipped
=
match
clipped
.
intersection
(
&
unclipped
.
cast_unit
(
)
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
(
clipped
unclipped
clipped
)
}
_
=
>
{
let
surface_origin
=
surface
.
clipped_local_rect
.
min
.
to_vector
(
)
.
cast_unit
(
)
;
let
normalized_prim_rect
=
composite_mode
.
get_rect
(
surface
None
)
.
translate
(
-
surface_origin
)
;
let
normalized_clip_rect
=
local_clip_rect
.
cast_unit
(
)
.
translate
(
-
surface_origin
)
;
let
norm_clipped_rect
=
match
normalized_prim_rect
.
intersection
(
&
normalized_clip_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
norm_clipped_rect
=
composite_mode
.
get_rect
(
surface
Some
(
norm_clipped_rect
)
)
;
let
norm_clipped_rect
=
match
norm_clipped_rect
.
intersection
(
&
normalized_prim_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
unclipped
=
normalized_prim_rect
.
translate
(
surface_origin
)
;
let
clipped
=
norm_clipped_rect
.
translate
(
surface_origin
)
;
(
clipped
.
cast_unit
(
)
unclipped
.
cast_unit
(
)
clipped
.
cast_unit
(
)
)
}
}
;
let
(
mut
clipped
mut
unclipped
mut
source
)
=
if
surface
.
raster_spatial_node_index
!
=
surface
.
surface_spatial_node_index
{
assert_eq
!
(
surface
.
device_pixel_scale
.
0
1
.
0
)
;
let
local_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
surface
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
let
clipped
=
local_to_world
.
map
(
&
clipped_local
.
cast_unit
(
)
)
.
unwrap
(
)
*
surface
.
device_pixel_scale
;
let
unclipped
=
local_to_world
.
map
(
&
unclipped_local
)
.
unwrap
(
)
*
surface
.
device_pixel_scale
;
let
source
=
local_to_world
.
map
(
&
source_local
.
cast_unit
(
)
)
.
unwrap
(
)
*
surface
.
device_pixel_scale
;
(
clipped
unclipped
source
)
}
else
{
let
clipped
=
clipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
let
unclipped
=
unclipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
let
source
=
source_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
(
clipped
unclipped
source
)
}
;
let
mut
clipped_snapped
=
clipped
.
round_out
(
)
;
let
mut
source_snapped
=
source
.
round_out
(
)
;
let
max_dimension
=
clipped_snapped
.
width
(
)
.
max
(
clipped_snapped
.
height
(
)
.
max
(
source_snapped
.
width
(
)
.
max
(
source_snapped
.
height
(
)
)
)
)
.
ceil
(
)
;
if
max_dimension
>
max_surface_size
{
let
max_dimension
=
clipped_local
.
width
(
)
.
max
(
clipped_local
.
height
(
)
.
max
(
source_local
.
width
(
)
.
max
(
source_local
.
height
(
)
)
)
)
.
ceil
(
)
;
surface
.
raster_spatial_node_index
=
surface
.
surface_spatial_node_index
;
surface
.
device_pixel_scale
=
Scale
:
:
new
(
max_surface_size
/
max_dimension
)
;
surface
.
local_scale
=
(
1
.
0
1
.
0
)
;
let
add_markers
=
profiler
:
:
thread_is_being_profiled
(
)
;
if
add_markers
{
let
new_clipped
=
(
clipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
)
.
round
(
)
;
let
new_source
=
(
source_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
)
.
round
(
)
;
profiler
:
:
add_text_marker
(
"
SurfaceSizeLimited
"
format
!
(
"
Surface
for
{
:
?
}
reduced
from
raster
{
:
?
}
(
source
{
:
?
}
)
to
local
{
:
?
}
(
source
{
:
?
}
)
"
composite_mode
.
kind
(
)
clipped
.
size
(
)
source
.
size
(
)
new_clipped
new_source
)
.
as_str
(
)
Duration
:
:
from_secs_f32
(
new_clipped
.
width
(
)
*
new_clipped
.
height
(
)
/
1000000000
.
0
)
)
;
}
clipped
=
clipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
unclipped
=
unclipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
source
=
source_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
clipped_snapped
=
clipped
.
round
(
)
;
source_snapped
=
source
.
round
(
)
;
}
let
task_size
=
clipped_snapped
.
size
(
)
.
to_i32
(
)
;
let
task_size
=
task_size
.
min
(
DeviceIntSize
:
:
new
(
max_surface_size
as
i32
max_surface_size
as
i32
)
)
;
debug_assert
!
(
task_size
.
width
<
=
max_surface_size
as
i32
&
&
task_size
.
height
<
=
max_surface_size
as
i32
"
task_size
{
:
?
}
for
{
:
?
}
must
be
within
max_surface_size
{
}
"
task_size
composite_mode
.
kind
(
)
max_surface_size
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
clipped_snapped
unclipped
)
;
if
task_size
.
width
=
=
0
|
|
task_size
.
height
=
=
0
{
return
None
;
}
let
needs_scissor_rect
=
force_scissor_rect
|
|
!
clipped_local
.
contains_box
(
&
surface
.
unclipped_local_rect
)
;
Some
(
SurfaceAllocInfo
{
task_size
needs_scissor_rect
clipped
:
clipped_snapped
unclipped
source
:
source_snapped
clipped_notsnapped
:
clipped
clipped_local
uv_rect_kind
}
)
}
pub
fn
calculate_uv_rect_kind
(
clipped
:
DeviceRect
unclipped
:
DeviceRect
)
-
>
UvRectKind
{
let
top_left
=
calculate_screen_uv
(
unclipped
.
top_left
(
)
.
cast_unit
(
)
clipped
)
;
let
top_right
=
calculate_screen_uv
(
unclipped
.
top_right
(
)
.
cast_unit
(
)
clipped
)
;
let
bottom_left
=
calculate_screen_uv
(
unclipped
.
bottom_left
(
)
.
cast_unit
(
)
clipped
)
;
let
bottom_right
=
calculate_screen_uv
(
unclipped
.
bottom_right
(
)
.
cast_unit
(
)
clipped
)
;
UvRectKind
:
:
Quad
{
top_left
top_right
bottom_left
bottom_right
}
}
