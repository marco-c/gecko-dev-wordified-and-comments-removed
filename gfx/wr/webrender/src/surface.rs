use
api
:
:
units
:
:
*
;
use
crate
:
:
command_buffer
:
:
{
CommandBufferBuilderKind
CommandBufferList
CommandBufferBuilder
CommandBufferIndex
}
;
use
crate
:
:
internal_types
:
:
FastHashMap
;
use
crate
:
:
picture
:
:
{
SurfaceInfo
SurfaceIndex
TileKey
SubSliceIndex
}
;
use
crate
:
:
prim_store
:
:
{
PictureIndex
}
;
use
crate
:
:
render_task_graph
:
:
{
RenderTaskId
RenderTaskGraphBuilder
}
;
use
crate
:
:
render_target
:
:
ResolveOp
;
use
crate
:
:
render_task
:
:
{
RenderTask
RenderTaskKind
RenderTaskLocation
}
;
use
crate
:
:
visibility
:
:
{
VisibilityState
PrimitiveVisibility
}
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceTileDescriptor
{
pub
current_task_id
:
RenderTaskId
pub
composite_task_id
:
Option
<
RenderTaskId
>
pub
dirty_rect
:
PictureRect
}
pub
enum
SurfaceDescriptorKind
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
}
Simple
{
render_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
}
Chained
{
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
}
}
pub
struct
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
}
impl
SurfaceDescriptor
{
pub
fn
new_tiled
(
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
}
}
pub
fn
new_chained
(
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
dirty_rect
}
}
}
pub
fn
new_simple
(
render_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
dirty_rect
}
}
}
}
struct
CommandBufferTargets
{
available_cmd_buffers
:
Vec
<
Vec
<
(
PictureRect
CommandBufferIndex
)
>
>
}
impl
CommandBufferTargets
{
fn
new
(
)
-
>
Self
{
CommandBufferTargets
{
available_cmd_buffers
:
vec
!
[
Vec
:
:
new
(
)
;
8
]
}
}
fn
init
(
&
mut
self
cb
:
&
CommandBufferBuilder
rg_builder
:
&
RenderTaskGraphBuilder
)
{
for
available_cmd_buffers
in
&
mut
self
.
available_cmd_buffers
{
available_cmd_buffers
.
clear
(
)
;
}
match
cb
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
.
.
}
=
>
{
for
(
key
desc
)
in
tiles
{
let
task
=
rg_builder
.
get_task
(
desc
.
current_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
let
available_cmd_buffers
=
&
mut
self
.
available_cmd_buffers
[
key
.
sub_slice_index
.
as_usize
(
)
]
;
available_cmd_buffers
.
push
(
(
desc
.
dirty_rect
info
.
cmd_buffer_index
)
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
dirty_rect
.
.
}
=
>
{
let
task
=
rg_builder
.
get_task
(
render_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
let
available_cmd_buffers
=
&
mut
self
.
available_cmd_buffers
[
0
]
;
available_cmd_buffers
.
push
(
(
dirty_rect
info
.
cmd_buffer_index
)
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
}
}
;
}
fn
get_cmd_buffer_targets_for_rect
(
&
mut
self
rect
:
&
PictureRect
sub_slice_index
:
SubSliceIndex
targets
:
&
mut
Vec
<
CommandBufferIndex
>
)
-
>
bool
{
for
(
dirty_rect
cmd_buffer_index
)
in
&
self
.
available_cmd_buffers
[
sub_slice_index
.
as_usize
(
)
]
{
if
dirty_rect
.
intersects
(
rect
)
{
targets
.
push
(
*
cmd_buffer_index
)
;
}
}
!
targets
.
is_empty
(
)
}
}
pub
struct
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
builder_stack
:
Vec
<
CommandBufferBuilder
>
pub
sub_graph_output_map
:
FastHashMap
<
PictureIndex
RenderTaskId
>
}
impl
SurfaceBuilder
{
pub
fn
new
(
)
-
>
Self
{
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
:
:
new
(
)
builder_stack
:
Vec
:
:
new
(
)
sub_graph_output_map
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
register_resolve_source
(
&
mut
self
)
{
let
surface_task_id
=
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
panic
!
(
"
bug
:
only
supported
for
non
-
tiled
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
render_task_id
}
;
for
builder
in
self
.
builder_stack
.
iter_mut
(
)
.
rev
(
)
{
if
builder
.
establishes_sub_graph
{
assert_eq
!
(
builder
.
resolve_source
None
)
;
builder
.
resolve_source
=
Some
(
surface_task_id
)
;
return
;
}
}
unreachable
!
(
"
bug
:
resolve
source
with
no
sub
-
graph
"
)
;
}
pub
fn
push_surface
(
&
mut
self
surface_index
:
SurfaceIndex
is_sub_graph
:
bool
clipping_rect
:
PictureRect
descriptor
:
SurfaceDescriptor
surfaces
:
&
mut
[
SurfaceInfo
]
rg_builder
:
&
RenderTaskGraphBuilder
)
{
surfaces
[
surface_index
.
0
]
.
clipping_rect
=
clipping_rect
;
let
builder
=
match
descriptor
.
kind
{
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
=
>
{
CommandBufferBuilder
:
:
new_tiled
(
tiles
)
}
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
dirty_rect
.
.
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
None
dirty_rect
)
}
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
dirty_rect
.
.
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
Some
(
root_task_id
)
dirty_rect
)
}
}
;
self
.
current_cmd_buffers
.
init
(
&
builder
rg_builder
)
;
self
.
builder_stack
.
push
(
builder
)
;
}
pub
fn
add_child_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
rg_builder
:
&
mut
RenderTaskGraphBuilder
)
{
let
builder
=
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
;
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
render_task_id
child_task_id
)
;
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
}
pub
fn
add_picture_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
)
{
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
extra_dependencies
.
push
(
child_task_id
)
;
}
pub
fn
get_cmd_buffer_targets_for_prim
(
&
mut
self
vis
:
&
PrimitiveVisibility
targets
:
&
mut
Vec
<
CommandBufferIndex
>
)
-
>
bool
{
targets
.
clear
(
)
;
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Culled
=
>
{
false
}
VisibilityState
:
:
Visible
{
sub_slice_index
.
.
}
=
>
{
self
.
current_cmd_buffers
.
get_cmd_buffer_targets_for_rect
(
&
vis
.
clip_chain
.
pic_coverage_rect
sub_slice_index
targets
)
}
VisibilityState
:
:
PassThrough
=
>
{
true
}
}
}
pub
fn
pop_surface
(
&
mut
self
pic_index
:
PictureIndex
rg_builder
:
&
mut
RenderTaskGraphBuilder
cmd_buffers
:
&
mut
CommandBufferList
)
{
let
builder
=
self
.
builder_stack
.
pop
(
)
.
unwrap
(
)
;
if
builder
.
establishes_sub_graph
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
"
bug
:
sub
-
graphs
can
only
be
simple
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_render_task_id
root_task_id
:
child_root_task_id
.
.
}
=
>
{
if
let
Some
(
resolve_task_id
)
=
builder
.
resolve_source
{
let
mut
src_task_ids
=
Vec
:
:
new
(
)
;
let
_old
=
self
.
sub_graph_output_map
.
insert
(
pic_index
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
debug_assert
!
(
_old
.
is_none
(
)
)
;
match
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
mut
tiles
}
=
>
{
let
keys
:
Vec
<
TileKey
>
=
tiles
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
for
key
in
keys
{
let
descriptor
=
tiles
.
remove
(
&
key
)
.
unwrap
(
)
;
let
parent_task_id
=
descriptor
.
current_task_id
;
let
parent_task
=
rg_builder
.
get_task_mut
(
parent_task_id
)
;
match
parent_task
.
location
{
RenderTaskLocation
:
:
Unallocated
{
.
.
}
|
RenderTaskLocation
:
:
Existing
{
.
.
}
=
>
{
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
parent_task_id
)
;
tiles
.
insert
(
key
SurfaceTileDescriptor
{
current_task_id
:
new_task_id
.
.
descriptor
}
)
;
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
tiles
.
insert
(
key
descriptor
)
;
}
_
=
>
{
panic
!
(
"
bug
:
unexpected
task
location
"
)
;
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
ref
mut
parent_task_id
.
.
}
=
>
{
let
parent_task
=
rg_builder
.
get_task_mut
(
*
parent_task_id
)
;
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
:
*
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
*
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
*
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
*
parent_task_id
)
;
*
parent_task_id
=
new_task_id
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
let
dest_task
=
rg_builder
.
get_task_mut
(
resolve_task_id
)
;
match
dest_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
dest_task_info
)
=
>
{
assert
!
(
dest_task_info
.
resolve_op
.
is_none
(
)
)
;
dest_task_info
.
resolve_op
=
Some
(
ResolveOp
{
src_task_ids
dest_task_id
:
resolve_task_id
}
)
}
_
=
>
{
unreachable
!
(
"
bug
:
not
a
picture
"
)
;
}
}
}
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
}
}
else
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
if
let
Some
(
composite_task_id
)
=
descriptor
.
composite_task_id
{
rg_builder
.
add_dependency
(
composite_task_id
descriptor
.
current_task_id
)
;
let
composite_task
=
rg_builder
.
get_task_mut
(
composite_task_id
)
;
match
composite_task
.
kind
{
RenderTaskKind
:
:
TileComposite
(
ref
mut
info
)
=
>
{
info
.
task_id
=
Some
(
descriptor
.
current_task_id
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
tile
composite
"
)
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_task_id
root_task_id
:
child_root_task_id
.
.
}
=
>
{
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
*
task_id
)
;
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
render_task_id
*
task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
self
.
current_cmd_buffers
.
init
(
self
.
builder_stack
.
last
(
)
.
unwrap_or
(
&
CommandBufferBuilder
:
:
empty
(
)
)
rg_builder
)
;
}
pub
fn
finalize
(
self
)
{
assert
!
(
self
.
builder_stack
.
is_empty
(
)
)
;
}
}
