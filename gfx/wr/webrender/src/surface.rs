use
api
:
:
units
:
:
*
;
use
crate
:
:
batch
:
:
{
CommandBufferBuilderKind
CommandBufferList
CommandBufferBuilder
CommandBufferIndex
}
;
use
crate
:
:
internal_types
:
:
FastHashMap
;
use
crate
:
:
picture
:
:
{
SurfaceInfo
SurfaceIndex
TileKey
SubSliceIndex
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstanceIndex
}
;
use
crate
:
:
render_task
:
:
RenderTaskKind
;
use
crate
:
:
render_task_graph
:
:
{
RenderTaskId
RenderTaskGraphBuilder
}
;
use
crate
:
:
spatial_tree
:
:
SpatialNodeIndex
;
use
crate
:
:
visibility
:
:
{
VisibilityState
PrimitiveVisibility
}
;
pub
enum
SurfaceDescriptorKind
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
RenderTaskId
>
}
Simple
{
render_task_id
:
RenderTaskId
}
Chained
{
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
}
}
pub
struct
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
}
impl
SurfaceDescriptor
{
pub
fn
new_tiled
(
tiles
:
FastHashMap
<
TileKey
RenderTaskId
>
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
}
}
pub
fn
new_chained
(
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
}
}
}
pub
fn
new_simple
(
render_task_id
:
RenderTaskId
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
}
}
}
}
enum
CommandBufferTargets
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
CommandBufferIndex
>
}
Simple
{
cmd_buffer_index
:
CommandBufferIndex
}
}
impl
CommandBufferTargets
{
fn
init
(
&
mut
self
cb
:
&
CommandBufferBuilder
rg_builder
:
&
RenderTaskGraphBuilder
)
{
let
new_target
=
match
cb
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
.
.
}
=
>
{
let
mut
cb_tiles
=
FastHashMap
:
:
default
(
)
;
for
(
key
task_id
)
in
tiles
{
let
task
=
rg_builder
.
get_task
(
*
task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
cb_tiles
.
insert
(
*
key
info
.
cmd_buffer_index
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferTargets
:
:
Tiled
{
tiles
:
cb_tiles
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
let
task
=
rg_builder
.
get_task
(
render_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
CommandBufferTargets
:
:
Simple
{
cmd_buffer_index
:
info
.
cmd_buffer_index
}
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
CommandBufferTargets
:
:
Tiled
{
tiles
:
FastHashMap
:
:
default
(
)
}
}
}
;
*
self
=
new_target
;
}
fn
push_prim
(
&
mut
self
prim_instance_index
:
PrimitiveInstanceIndex
spatial_node_index
:
SpatialNodeIndex
tile_rect
:
crate
:
:
picture
:
:
TileRect
sub_slice_index
:
SubSliceIndex
gpu_address
:
Option
<
crate
:
:
gpu_cache
:
:
GpuCacheAddress
>
cmd_buffers
:
&
mut
CommandBufferList
)
{
match
self
{
CommandBufferTargets
:
:
Tiled
{
ref
mut
tiles
}
=
>
{
for
y
in
tile_rect
.
min
.
y
.
.
tile_rect
.
max
.
y
{
for
x
in
tile_rect
.
min
.
x
.
.
tile_rect
.
max
.
x
{
let
key
=
TileKey
{
tile_offset
:
crate
:
:
picture
:
:
TileOffset
:
:
new
(
x
y
)
sub_slice_index
}
;
if
let
Some
(
cmd_buffer_index
)
=
tiles
.
get
(
&
key
)
{
cmd_buffers
.
get_mut
(
*
cmd_buffer_index
)
.
add_prim
(
prim_instance_index
spatial_node_index
gpu_address
)
;
}
}
}
}
CommandBufferTargets
:
:
Simple
{
cmd_buffer_index
.
.
}
=
>
{
cmd_buffers
.
get_mut
(
*
cmd_buffer_index
)
.
add_prim
(
prim_instance_index
spatial_node_index
gpu_address
)
;
}
}
}
}
pub
struct
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
builder_stack
:
Vec
<
CommandBufferBuilder
>
dirty_rect_stack
:
Vec
<
PictureRect
>
}
impl
SurfaceBuilder
{
pub
fn
new
(
)
-
>
Self
{
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
:
:
Tiled
{
tiles
:
FastHashMap
:
:
default
(
)
}
builder_stack
:
Vec
:
:
new
(
)
dirty_rect_stack
:
Vec
:
:
new
(
)
}
}
pub
fn
push_surface
(
&
mut
self
surface_index
:
SurfaceIndex
clipping_rect
:
PictureRect
descriptor
:
SurfaceDescriptor
surfaces
:
&
mut
[
SurfaceInfo
]
rg_builder
:
&
RenderTaskGraphBuilder
)
{
surfaces
[
surface_index
.
0
]
.
clipping_rect
=
clipping_rect
;
self
.
dirty_rect_stack
.
push
(
clipping_rect
)
;
let
builder
=
match
descriptor
.
kind
{
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
=
>
{
CommandBufferBuilder
:
:
new_tiled
(
tiles
)
}
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
None
)
}
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
Some
(
root_task_id
)
)
}
}
;
self
.
current_cmd_buffers
.
init
(
&
builder
rg_builder
)
;
self
.
builder_stack
.
push
(
builder
)
;
}
pub
fn
add_child_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
rg_builder
:
&
mut
RenderTaskGraphBuilder
)
{
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
parent_task_id
)
in
tiles
{
rg_builder
.
add_dependency
(
*
parent_task_id
child_task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
render_task_id
child_task_id
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
pub
fn
is_prim_visible_and_in_dirty_region
(
&
self
vis
:
&
PrimitiveVisibility
)
-
>
bool
{
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Culled
=
>
{
false
}
VisibilityState
:
:
Visible
{
.
.
}
=
>
{
self
.
dirty_rect_stack
.
last
(
)
.
unwrap
(
)
.
intersects
(
&
vis
.
clip_chain
.
pic_coverage_rect
)
}
VisibilityState
:
:
PassThrough
=
>
{
true
}
}
}
pub
fn
push_prim
(
&
mut
self
prim_instance_index
:
PrimitiveInstanceIndex
spatial_node_index
:
SpatialNodeIndex
vis
:
&
PrimitiveVisibility
gpu_address
:
Option
<
crate
:
:
gpu_cache
:
:
GpuCacheAddress
>
cmd_buffers
:
&
mut
CommandBufferList
)
{
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Visible
{
tile_rect
sub_slice_index
.
.
}
=
>
{
self
.
current_cmd_buffers
.
push_prim
(
prim_instance_index
spatial_node_index
tile_rect
sub_slice_index
gpu_address
cmd_buffers
)
}
VisibilityState
:
:
PassThrough
|
VisibilityState
:
:
Culled
=
>
{
}
}
}
pub
fn
pop_surface
(
&
mut
self
rg_builder
:
&
mut
RenderTaskGraphBuilder
)
{
self
.
dirty_rect_stack
.
pop
(
)
.
unwrap
(
)
;
let
builder
=
self
.
builder_stack
.
pop
(
)
.
unwrap
(
)
;
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
=
>
{
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_task_id
root_task_id
:
child_root_task_id
}
=
>
{
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
parent_task_id
)
in
tiles
{
rg_builder
.
add_dependency
(
*
parent_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
self
.
current_cmd_buffers
.
init
(
self
.
builder_stack
.
last
(
)
.
unwrap_or
(
&
CommandBufferBuilder
:
:
empty
(
)
)
rg_builder
)
;
}
pub
fn
finalize
(
self
)
{
assert
!
(
self
.
builder_stack
.
is_empty
(
)
)
;
}
}
