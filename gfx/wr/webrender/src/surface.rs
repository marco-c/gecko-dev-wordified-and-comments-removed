use
api
:
:
{
LayoutPixel
PicturePixel
RasterSpace
}
;
use
clip
:
:
{
ClipChainId
ClipStore
ClipUid
}
;
use
clip_scroll_tree
:
:
{
ClipScrollTree
SpatialNodeIndex
}
;
use
euclid
:
:
TypedTransform3D
;
use
internal_types
:
:
FastHashSet
;
use
prim_store
:
:
{
CoordinateSpaceMapping
PrimitiveUid
PrimitiveInstance
PrimitiveInstanceKind
}
;
use
std
:
:
hash
;
use
util
:
:
ScaleOffset
;
const
QUANTIZE_SCALE
:
f32
=
4096
.
0
;
fn
quantize
(
value
:
f32
)
-
>
f32
{
(
value
*
QUANTIZE_SCALE
)
.
round
(
)
/
QUANTIZE_SCALE
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
struct
ScaleOffsetKey
{
scale_x
:
f32
scale_y
:
f32
offset_x
:
f32
offset_y
:
f32
}
impl
ScaleOffsetKey
{
fn
new
(
scale_offset
:
&
ScaleOffset
)
-
>
Self
{
ScaleOffsetKey
{
scale_x
:
quantize
(
scale_offset
.
scale
.
x
)
scale_y
:
quantize
(
scale_offset
.
scale
.
y
)
offset_x
:
quantize
(
scale_offset
.
offset
.
x
)
offset_y
:
quantize
(
scale_offset
.
offset
.
y
)
}
}
}
impl
Eq
for
ScaleOffsetKey
{
}
impl
hash
:
:
Hash
for
ScaleOffsetKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
scale_x
.
to_bits
(
)
.
hash
(
state
)
;
self
.
scale_y
.
to_bits
(
)
.
hash
(
state
)
;
self
.
offset_x
.
to_bits
(
)
.
hash
(
state
)
;
self
.
offset_y
.
to_bits
(
)
.
hash
(
state
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
struct
MatrixKey
{
values
:
[
f32
;
16
]
}
impl
MatrixKey
{
fn
new
<
Src
Dst
>
(
transform
:
&
TypedTransform3D
<
f32
Src
Dst
>
)
-
>
Self
{
let
mut
values
=
transform
.
to_row_major_array
(
)
;
for
value
in
&
mut
values
{
*
value
=
quantize
(
*
value
)
;
}
MatrixKey
{
values
}
}
}
impl
Eq
for
MatrixKey
{
}
impl
hash
:
:
Hash
for
MatrixKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
for
value
in
&
self
.
values
{
value
.
to_bits
(
)
.
hash
(
state
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
PartialEq
Clone
Hash
Eq
)
]
pub
enum
TransformKey
{
Local
ScaleOffset
(
ScaleOffsetKey
)
Transform
(
MatrixKey
)
}
impl
TransformKey
{
pub
fn
local
(
)
-
>
Self
{
TransformKey
:
:
Local
}
}
impl
<
F
T
>
From
<
CoordinateSpaceMapping
<
F
T
>
>
for
TransformKey
{
fn
from
(
mapping
:
CoordinateSpaceMapping
<
F
T
>
)
-
>
TransformKey
{
match
mapping
{
CoordinateSpaceMapping
:
:
Local
=
>
{
TransformKey
:
:
Local
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
TransformKey
:
:
ScaleOffset
(
ScaleOffsetKey
:
:
new
(
scale_offset
)
)
}
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
{
TransformKey
:
:
Transform
(
MatrixKey
:
:
new
(
transform
)
)
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Eq
PartialEq
Hash
Clone
)
]
pub
struct
SurfaceCacheKey
{
pub
primitive_ids
:
Vec
<
PrimitiveUid
>
pub
clip_ids
:
Vec
<
ClipUid
>
pub
transforms
:
Vec
<
TransformKey
>
pub
raster_transform
:
TransformKey
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceDescriptor
{
pub
cache_key
:
SurfaceCacheKey
pub
spatial_nodes
:
Vec
<
SpatialNodeIndex
>
}
impl
SurfaceDescriptor
{
pub
fn
new
(
prim_instances
:
&
[
PrimitiveInstance
]
pic_spatial_node_index
:
SpatialNodeIndex
clip_store
:
&
ClipStore
)
-
>
Option
<
Self
>
{
let
mut
relevant_spatial_nodes
=
FastHashSet
:
:
default
(
)
;
let
mut
primitive_ids
=
Vec
:
:
new
(
)
;
let
mut
clip_ids
=
Vec
:
:
new
(
)
;
for
prim_instance
in
prim_instances
{
if
pic_spatial_node_index
!
=
prim_instance
.
spatial_node_index
{
relevant_spatial_nodes
.
insert
(
prim_instance
.
spatial_node_index
)
;
}
let
mut
clip_chain_id
=
prim_instance
.
clip_chain_id
;
while
clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
clip_chain_id
.
0
as
usize
]
;
if
clip_chain_node
.
spatial_node_index
>
pic_spatial_node_index
{
relevant_spatial_nodes
.
insert
(
prim_instance
.
spatial_node_index
)
;
clip_ids
.
push
(
clip_chain_node
.
handle
.
uid
(
)
)
;
}
clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
.
.
}
|
PrimitiveInstanceKind
:
:
LegacyPrimitive
{
.
.
}
=
>
{
return
None
;
}
PrimitiveInstanceKind
:
:
Image
{
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
Rectangle
{
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
=
>
{
}
}
primitive_ids
.
push
(
prim_instance
.
prim_data_handle
.
uid
(
)
)
;
}
let
mut
spatial_nodes
:
Vec
<
SpatialNodeIndex
>
=
relevant_spatial_nodes
.
into_iter
(
)
.
collect
(
)
;
spatial_nodes
.
sort
(
)
;
let
transforms
=
vec
!
[
TransformKey
:
:
local
(
)
;
spatial_nodes
.
len
(
)
]
;
let
cache_key
=
SurfaceCacheKey
{
primitive_ids
clip_ids
transforms
raster_transform
:
TransformKey
:
:
local
(
)
}
;
Some
(
SurfaceDescriptor
{
cache_key
spatial_nodes
}
)
}
pub
fn
update
(
&
mut
self
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
clip_scroll_tree
:
&
ClipScrollTree
raster_space
:
RasterSpace
)
{
self
.
cache_key
.
raster_transform
=
match
raster_space
{
RasterSpace
:
:
Screen
=
>
{
let
raster_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
raster_spatial_node_index
.
0
]
;
let
surface_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
surface_spatial_node_index
.
0
]
;
let
mut
key
=
CoordinateSpaceMapping
:
:
<
LayoutPixel
PicturePixel
>
:
:
new
(
raster_spatial_node_index
surface_spatial_node_index
clip_scroll_tree
)
.
expect
(
"
bug
:
unable
to
get
coord
mapping
"
)
.
into
(
)
;
if
let
TransformKey
:
:
ScaleOffset
(
ref
mut
key
)
=
key
{
if
raster_spatial_node
.
coordinate_system_id
=
=
surface_spatial_node
.
coordinate_system_id
{
key
.
offset_x
=
0
.
0
;
key
.
offset_y
=
0
.
0
;
}
}
key
}
RasterSpace
:
:
Local
(
.
.
)
=
>
{
TransformKey
:
:
local
(
)
}
}
;
for
(
spatial_node_index
transform
)
in
self
.
spatial_nodes
.
iter
(
)
.
zip
(
self
.
cache_key
.
transforms
.
iter_mut
(
)
)
{
*
transform
=
CoordinateSpaceMapping
:
:
<
LayoutPixel
PicturePixel
>
:
:
new
(
raster_spatial_node_index
*
spatial_node_index
clip_scroll_tree
)
.
expect
(
"
bug
:
unable
to
get
coord
mapping
"
)
.
into
(
)
;
}
}
}
