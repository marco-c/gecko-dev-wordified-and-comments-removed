use
api
:
:
units
:
:
*
;
use
crate
:
:
batch
:
:
{
CommandBufferBuilderKind
CommandBufferList
CommandBufferBuilder
CommandBufferIndex
}
;
use
crate
:
:
internal_types
:
:
FastHashMap
;
use
crate
:
:
picture
:
:
{
SurfaceInfo
SurfaceIndex
TileKey
SubSliceIndex
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstanceIndex
}
;
use
crate
:
:
render_task_graph
:
:
{
RenderTaskId
RenderTaskGraphBuilder
}
;
use
crate
:
:
spatial_tree
:
:
SpatialNodeIndex
;
use
crate
:
:
render_target
:
:
ResolveOp
;
use
crate
:
:
render_task
:
:
{
RenderTask
RenderTaskKind
RenderTaskLocation
}
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
spatial_tree
:
:
{
SpatialTree
}
;
use
crate
:
:
util
:
:
MaxRect
;
use
crate
:
:
visibility
:
:
{
VisibilityState
PrimitiveVisibility
}
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceTileDescriptor
{
pub
current_task_id
:
RenderTaskId
pub
composite_task_id
:
Option
<
RenderTaskId
>
}
pub
enum
SurfaceDescriptorKind
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
}
Simple
{
render_task_id
:
RenderTaskId
}
Chained
{
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
}
}
pub
struct
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
dirty_rects
:
Vec
<
PictureRect
>
}
impl
SurfaceDescriptor
{
pub
fn
new_tiled
(
tiles
:
FastHashMap
<
TileKey
SurfaceTileDescriptor
>
dirty_rects
:
Vec
<
PictureRect
>
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
dirty_rects
}
}
pub
fn
new_chained
(
render_task_id
:
RenderTaskId
root_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
}
dirty_rects
:
vec
!
[
dirty_rect
]
}
}
pub
fn
new_simple
(
render_task_id
:
RenderTaskId
dirty_rect
:
PictureRect
)
-
>
Self
{
SurfaceDescriptor
{
kind
:
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
}
dirty_rects
:
vec
!
[
dirty_rect
]
}
}
}
enum
CommandBufferTargets
{
Tiled
{
tiles
:
FastHashMap
<
TileKey
CommandBufferIndex
>
}
Simple
{
cmd_buffer_index
:
CommandBufferIndex
}
}
impl
CommandBufferTargets
{
fn
init
(
&
mut
self
cb
:
&
CommandBufferBuilder
rg_builder
:
&
RenderTaskGraphBuilder
)
{
let
new_target
=
match
cb
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
.
.
}
=
>
{
let
mut
cb_tiles
=
FastHashMap
:
:
default
(
)
;
for
(
key
desc
)
in
tiles
{
let
task
=
rg_builder
.
get_task
(
desc
.
current_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
cb_tiles
.
insert
(
*
key
info
.
cmd_buffer_index
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferTargets
:
:
Tiled
{
tiles
:
cb_tiles
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
let
task
=
rg_builder
.
get_task
(
render_task_id
)
;
match
task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
info
)
=
>
{
CommandBufferTargets
:
:
Simple
{
cmd_buffer_index
:
info
.
cmd_buffer_index
}
}
_
=
>
unreachable
!
(
"
bug
:
not
a
picture
"
)
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
CommandBufferTargets
:
:
Tiled
{
tiles
:
FastHashMap
:
:
default
(
)
}
}
}
;
*
self
=
new_target
;
}
fn
push_prim
(
&
mut
self
prim_instance_index
:
PrimitiveInstanceIndex
spatial_node_index
:
SpatialNodeIndex
tile_rect
:
crate
:
:
picture
:
:
TileRect
sub_slice_index
:
SubSliceIndex
gpu_address
:
Option
<
crate
:
:
gpu_cache
:
:
GpuCacheAddress
>
cmd_buffers
:
&
mut
CommandBufferList
)
{
match
self
{
CommandBufferTargets
:
:
Tiled
{
ref
mut
tiles
}
=
>
{
for
y
in
tile_rect
.
min
.
y
.
.
tile_rect
.
max
.
y
{
for
x
in
tile_rect
.
min
.
x
.
.
tile_rect
.
max
.
x
{
let
key
=
TileKey
{
tile_offset
:
crate
:
:
picture
:
:
TileOffset
:
:
new
(
x
y
)
sub_slice_index
}
;
if
let
Some
(
cmd_buffer_index
)
=
tiles
.
get
(
&
key
)
{
cmd_buffers
.
get_mut
(
*
cmd_buffer_index
)
.
add_prim
(
prim_instance_index
spatial_node_index
gpu_address
)
;
}
}
}
}
CommandBufferTargets
:
:
Simple
{
cmd_buffer_index
.
.
}
=
>
{
cmd_buffers
.
get_mut
(
*
cmd_buffer_index
)
.
add_prim
(
prim_instance_index
spatial_node_index
gpu_address
)
;
}
}
}
}
pub
struct
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
builder_stack
:
Vec
<
CommandBufferBuilder
>
dirty_rect_stack
:
Vec
<
Vec
<
PictureRect
>
>
}
impl
SurfaceBuilder
{
pub
fn
new
(
)
-
>
Self
{
SurfaceBuilder
{
current_cmd_buffers
:
CommandBufferTargets
:
:
Tiled
{
tiles
:
FastHashMap
:
:
default
(
)
}
builder_stack
:
Vec
:
:
new
(
)
dirty_rect_stack
:
Vec
:
:
new
(
)
}
}
pub
fn
register_resolve_source
(
&
mut
self
)
{
let
surface_task_id
=
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
panic
!
(
"
bug
:
only
supported
for
non
-
tiled
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
render_task_id
}
;
for
builder
in
self
.
builder_stack
.
iter_mut
(
)
.
rev
(
)
{
if
builder
.
establishes_sub_graph
{
assert_eq
!
(
builder
.
resolve_source
None
)
;
builder
.
resolve_source
=
Some
(
surface_task_id
)
;
return
;
}
}
unreachable
!
(
"
bug
:
resolve
source
with
no
sub
-
graph
"
)
;
}
pub
fn
push_surface
(
&
mut
self
surface_index
:
SurfaceIndex
is_sub_graph
:
bool
clipping_rect
:
PictureRect
descriptor
:
SurfaceDescriptor
surfaces
:
&
mut
[
SurfaceInfo
]
rg_builder
:
&
RenderTaskGraphBuilder
)
{
surfaces
[
surface_index
.
0
]
.
clipping_rect
=
clipping_rect
;
self
.
dirty_rect_stack
.
push
(
descriptor
.
dirty_rects
)
;
let
builder
=
match
descriptor
.
kind
{
SurfaceDescriptorKind
:
:
Tiled
{
tiles
}
=
>
{
CommandBufferBuilder
:
:
new_tiled
(
tiles
)
}
SurfaceDescriptorKind
:
:
Simple
{
render_task_id
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
None
)
}
SurfaceDescriptorKind
:
:
Chained
{
render_task_id
root_task_id
}
=
>
{
CommandBufferBuilder
:
:
new_simple
(
render_task_id
is_sub_graph
Some
(
root_task_id
)
)
}
}
;
self
.
current_cmd_buffers
.
init
(
&
builder
rg_builder
)
;
self
.
builder_stack
.
push
(
builder
)
;
}
pub
fn
add_child_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
rg_builder
:
&
mut
RenderTaskGraphBuilder
)
{
let
builder
=
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
;
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
render_task_id
child_task_id
)
;
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
}
pub
fn
add_picture_render_task
(
&
mut
self
child_task_id
:
RenderTaskId
)
{
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
extra_dependencies
.
push
(
child_task_id
)
;
}
pub
fn
is_prim_visible_and_in_dirty_region
(
&
self
vis
:
&
PrimitiveVisibility
)
-
>
bool
{
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Culled
=
>
{
false
}
VisibilityState
:
:
Visible
{
.
.
}
=
>
{
self
.
dirty_rect_stack
.
last
(
)
.
unwrap
(
)
.
iter
(
)
.
any
(
|
dirty_rect
|
{
dirty_rect
.
intersects
(
&
vis
.
clip_chain
.
pic_coverage_rect
)
}
)
}
VisibilityState
:
:
PassThrough
=
>
{
true
}
}
}
pub
fn
push_prim
(
&
mut
self
prim_instance_index
:
PrimitiveInstanceIndex
spatial_node_index
:
SpatialNodeIndex
vis
:
&
PrimitiveVisibility
gpu_address
:
Option
<
crate
:
:
gpu_cache
:
:
GpuCacheAddress
>
cmd_buffers
:
&
mut
CommandBufferList
)
{
match
vis
.
state
{
VisibilityState
:
:
Unset
=
>
{
panic
!
(
"
bug
:
invalid
vis
state
"
)
;
}
VisibilityState
:
:
Visible
{
tile_rect
sub_slice_index
.
.
}
=
>
{
self
.
current_cmd_buffers
.
push_prim
(
prim_instance_index
spatial_node_index
tile_rect
sub_slice_index
gpu_address
cmd_buffers
)
}
VisibilityState
:
:
PassThrough
|
VisibilityState
:
:
Culled
=
>
{
}
}
}
pub
fn
pop_surface
(
&
mut
self
rg_builder
:
&
mut
RenderTaskGraphBuilder
cmd_buffers
:
&
mut
CommandBufferList
spatial_tree
:
&
SpatialTree
)
{
self
.
dirty_rect_stack
.
pop
(
)
.
unwrap
(
)
;
let
builder
=
self
.
builder_stack
.
pop
(
)
.
unwrap
(
)
;
if
builder
.
establishes_sub_graph
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
.
.
}
|
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
"
bug
:
sub
-
graphs
can
only
be
simple
surfaces
"
)
;
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_render_task_id
root_task_id
:
child_root_task_id
}
=
>
{
let
resolve_task_id
=
builder
.
resolve_source
.
expect
(
"
bug
:
no
resolve
set
"
)
;
let
mut
src_task_ids
=
Vec
:
:
new
(
)
;
match
self
.
builder_stack
.
last_mut
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
mut
tiles
}
=
>
{
let
keys
:
Vec
<
TileKey
>
=
tiles
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
for
key
in
keys
{
let
descriptor
=
tiles
.
remove
(
&
key
)
.
unwrap
(
)
;
let
parent_task_id
=
descriptor
.
current_task_id
;
let
parent_task
=
rg_builder
.
get_task_mut
(
parent_task_id
)
;
match
parent_task
.
location
{
RenderTaskLocation
:
:
Unallocated
{
.
.
}
|
RenderTaskLocation
:
:
Existing
{
.
.
}
=
>
{
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
tiles
.
insert
(
key
SurfaceTileDescriptor
{
current_task_id
:
new_task_id
.
.
descriptor
}
)
;
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
tiles
.
insert
(
key
descriptor
)
;
}
_
=
>
{
panic
!
(
"
bug
:
unexpected
task
location
"
)
;
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
ref
mut
parent_task_id
.
.
}
=
>
{
let
parent_task
=
rg_builder
.
get_task_mut
(
*
parent_task_id
)
;
let
location
=
RenderTaskLocation
:
:
Existing
{
parent_task_id
:
*
parent_task_id
size
:
parent_task
.
location
.
size
(
)
}
;
let
pic_task
=
match
parent_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
pic_task
)
=
>
{
let
cmd_buffer_index
=
cmd_buffers
.
create_cmd_buffer
(
)
;
let
new_pic_task
=
pic_task
.
duplicate
(
cmd_buffer_index
)
;
src_task_ids
.
push
(
*
parent_task_id
)
;
new_pic_task
}
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
rg_builder
.
add_dependency
(
resolve_task_id
*
parent_task_id
)
;
let
new_task_id
=
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
location
RenderTaskKind
:
:
Picture
(
pic_task
)
)
)
;
rg_builder
.
add_dependency
(
new_task_id
child_root_task_id
.
unwrap_or
(
child_render_task_id
)
)
;
*
parent_task_id
=
new_task_id
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
let
dest_task
=
rg_builder
.
get_task_mut
(
resolve_task_id
)
;
match
dest_task
.
kind
{
RenderTaskKind
:
:
Picture
(
ref
mut
dest_task_info
)
=
>
{
let
m
:
SpaceMapper
<
DevicePixel
DevicePixel
>
=
SpaceMapper
:
:
new_with_target
(
dest_task_info
.
surface_spatial_node_index
dest_task_info
.
raster_spatial_node_index
DeviceRect
:
:
max_rect
(
)
spatial_tree
)
;
let
dest_origin
=
m
.
map_point
(
dest_task_info
.
content_origin
)
.
unwrap
(
)
;
assert
!
(
dest_task_info
.
resolve_op
.
is_none
(
)
)
;
dest_task_info
.
resolve_op
=
Some
(
ResolveOp
{
dest_origin
src_task_ids
dest_task_id
:
resolve_task_id
}
)
}
_
=
>
{
unreachable
!
(
"
bug
:
not
a
picture
"
)
;
}
}
}
}
}
else
{
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
if
let
Some
(
composite_task_id
)
=
descriptor
.
composite_task_id
{
rg_builder
.
add_dependency
(
composite_task_id
descriptor
.
current_task_id
)
;
let
composite_task
=
rg_builder
.
get_task_mut
(
composite_task_id
)
;
match
composite_task
.
kind
{
RenderTaskKind
:
:
TileComposite
(
ref
mut
info
)
=
>
{
info
.
task_id
=
Some
(
descriptor
.
current_task_id
)
;
}
_
=
>
unreachable
!
(
"
bug
:
not
a
tile
composite
"
)
}
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
child_task_id
root_task_id
:
child_root_task_id
}
=
>
{
match
self
.
builder_stack
.
last
(
)
.
unwrap
(
)
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
:
parent_task_id
.
.
}
=
>
{
rg_builder
.
add_dependency
(
parent_task_id
child_root_task_id
.
unwrap_or
(
child_task_id
)
)
;
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
CommandBufferBuilderKind
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
match
builder
.
kind
{
CommandBufferBuilderKind
:
:
Tiled
{
ref
tiles
}
=
>
{
for
(
_
descriptor
)
in
tiles
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
descriptor
.
current_task_id
*
task_id
)
;
}
}
}
CommandBufferBuilderKind
:
:
Simple
{
render_task_id
.
.
}
=
>
{
for
task_id
in
&
builder
.
extra_dependencies
{
rg_builder
.
add_dependency
(
render_task_id
*
task_id
)
;
}
}
CommandBufferBuilderKind
:
:
Invalid
{
.
.
}
=
>
{
}
}
self
.
current_cmd_buffers
.
init
(
self
.
builder_stack
.
last
(
)
.
unwrap_or
(
&
CommandBufferBuilder
:
:
empty
(
)
)
rg_builder
)
;
}
pub
fn
finalize
(
self
)
{
assert
!
(
self
.
builder_stack
.
is_empty
(
)
)
;
}
}
