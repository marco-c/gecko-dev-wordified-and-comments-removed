use
api
:
:
ColorF
;
use
api
:
:
units
:
:
{
DeviceRect
DeviceIntSize
DeviceIntRect
DeviceIntPoint
WorldRect
DevicePixelScale
}
;
use
crate
:
:
gpu_types
:
:
{
ZBufferId
ZBufferIdGenerator
}
;
use
crate
:
:
picture
:
:
{
ResolvedSurfaceTexture
}
;
use
std
:
:
{
ops
u64
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
NativeSurfaceOperationDetails
{
CreateSurface
{
size
:
DeviceIntSize
is_opaque
:
bool
}
DestroySurface
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceOperation
{
pub
id
:
NativeSurfaceId
pub
details
:
NativeSurfaceOperationDetails
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompositeTileSurface
{
Texture
{
surface
:
ResolvedSurfaceTexture
}
Color
{
color
:
ColorF
}
Clear
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeTile
{
pub
surface
:
CompositeTileSurface
pub
rect
:
DeviceRect
pub
clip_rect
:
DeviceRect
pub
dirty_rect
:
DeviceRect
pub
z_id
:
ZBufferId
}
pub
enum
CompositorConfig
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
compositor
:
Box
<
dyn
Compositor
>
}
}
impl
Default
for
CompositorConfig
{
fn
default
(
)
-
>
Self
{
CompositorConfig
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositorKind
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
}
}
impl
Default
for
CompositorKind
{
fn
default
(
)
-
>
Self
{
CompositorKind
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
Occluder
{
slice
:
usize
device_rect
:
DeviceIntRect
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeState
{
pub
native_tiles
:
Vec
<
CompositeTile
>
pub
opaque_tiles
:
Vec
<
CompositeTile
>
pub
alpha_tiles
:
Vec
<
CompositeTile
>
pub
clear_tiles
:
Vec
<
CompositeTile
>
pub
z_generator
:
ZBufferIdGenerator
pub
dirty_rects_are_valid
:
bool
pub
compositor_kind
:
CompositorKind
pub
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
occluders
:
Vec
<
Occluder
>
}
impl
CompositeState
{
pub
fn
new
(
compositor_kind
:
CompositorKind
mut
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
)
-
>
Self
{
if
let
CompositorKind
:
:
Native
{
.
.
}
=
compositor_kind
{
if
!
picture_caching_is_enabled
{
warn
!
(
"
Picture
caching
cannot
be
disabled
in
native
compositor
config
"
)
;
}
picture_caching_is_enabled
=
true
;
}
CompositeState
{
native_tiles
:
Vec
:
:
new
(
)
opaque_tiles
:
Vec
:
:
new
(
)
alpha_tiles
:
Vec
:
:
new
(
)
clear_tiles
:
Vec
:
:
new
(
)
z_generator
:
ZBufferIdGenerator
:
:
new
(
0
)
dirty_rects_are_valid
:
true
compositor_kind
picture_caching_is_enabled
global_device_pixel_scale
occluders
:
Vec
:
:
new
(
)
}
}
pub
fn
register_occluder
(
&
mut
self
slice
:
usize
rect
:
WorldRect
)
{
let
device_rect
=
(
rect
*
self
.
global_device_pixel_scale
)
.
round
(
)
.
to_i32
(
)
;
self
.
occluders
.
push
(
Occluder
{
device_rect
slice
}
)
;
}
pub
fn
is_tile_occluded
(
&
self
slice
:
usize
rect
:
WorldRect
)
-
>
bool
{
let
device_rect
=
(
rect
*
self
.
global_device_pixel_scale
)
.
round
(
)
.
to_i32
(
)
;
let
ref_area
=
device_rect
.
size
.
width
*
device_rect
.
size
.
height
;
let
cover_area
=
area_of_occluders
(
&
self
.
occluders
slice
&
device_rect
)
;
debug_assert
!
(
cover_area
<
=
ref_area
)
;
ref_area
=
=
cover_area
}
pub
fn
push_tile
(
&
mut
self
tile
:
CompositeTile
is_opaque
:
bool
)
{
match
(
self
.
compositor_kind
&
tile
.
surface
)
{
(
CompositorKind
:
:
Draw
{
.
.
}
CompositeTileSurface
:
:
Color
{
.
.
}
)
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
(
CompositorKind
:
:
Draw
{
.
.
}
CompositeTileSurface
:
:
Clear
)
=
>
{
self
.
clear_tiles
.
push
(
tile
)
;
}
(
CompositorKind
:
:
Draw
{
.
.
}
CompositeTileSurface
:
:
Texture
{
.
.
}
)
=
>
{
if
is_opaque
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
else
{
self
.
alpha_tiles
.
push
(
tile
)
;
}
}
(
CompositorKind
:
:
Native
{
.
.
}
CompositeTileSurface
:
:
Color
{
.
.
}
)
=
>
{
unreachable
!
(
)
;
}
(
CompositorKind
:
:
Native
{
.
.
}
CompositeTileSurface
:
:
Clear
)
=
>
{
unreachable
!
(
)
;
}
(
CompositorKind
:
:
Native
{
.
.
}
CompositeTileSurface
:
:
Texture
{
.
.
}
)
=
>
{
self
.
native_tiles
.
push
(
tile
)
;
}
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceId
(
pub
u64
)
;
impl
NativeSurfaceId
{
pub
const
DEBUG_OVERLAY
:
NativeSurfaceId
=
NativeSurfaceId
(
u64
:
:
MAX
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
NativeSurfaceInfo
{
pub
origin
:
DeviceIntPoint
pub
fbo_id
:
u32
}
pub
trait
Compositor
{
fn
create_surface
(
&
mut
self
id
:
NativeSurfaceId
size
:
DeviceIntSize
is_opaque
:
bool
)
;
fn
destroy_surface
(
&
mut
self
id
:
NativeSurfaceId
)
;
fn
bind
(
&
mut
self
id
:
NativeSurfaceId
dirty_rect
:
DeviceIntRect
)
-
>
NativeSurfaceInfo
;
fn
unbind
(
&
mut
self
)
;
fn
begin_frame
(
&
mut
self
)
;
fn
add_surface
(
&
mut
self
id
:
NativeSurfaceId
position
:
DeviceIntPoint
clip_rect
:
DeviceIntRect
)
;
fn
end_frame
(
&
mut
self
)
;
}
fn
area_of_occluders
(
occluders
:
&
[
Occluder
]
slice
:
usize
clip_rect
:
&
DeviceIntRect
)
-
>
i32
{
let
mut
area
=
0
;
#
[
derive
(
Debug
)
]
enum
EventKind
{
Begin
End
}
#
[
derive
(
Debug
)
]
struct
Event
{
y
:
i32
x_range
:
ops
:
:
Range
<
i32
>
kind
:
EventKind
}
impl
Event
{
fn
new
(
y
:
i32
kind
:
EventKind
x0
:
i32
x1
:
i32
)
-
>
Self
{
Event
{
y
x_range
:
ops
:
:
Range
{
start
:
x0
end
:
x1
}
kind
}
}
}
let
mut
events
=
Vec
:
:
with_capacity
(
occluders
.
len
(
)
*
2
)
;
for
occluder
in
occluders
{
if
occluder
.
slice
>
slice
{
if
let
Some
(
rect
)
=
occluder
.
device_rect
.
intersection
(
clip_rect
)
{
let
x0
=
rect
.
origin
.
x
;
let
x1
=
x0
+
rect
.
size
.
width
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
EventKind
:
:
Begin
x0
x1
)
)
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
+
rect
.
size
.
height
EventKind
:
:
End
x0
x1
)
)
;
}
}
}
if
events
.
is_empty
(
)
{
return
0
;
}
events
.
sort_by_key
(
|
e
|
e
.
y
)
;
let
mut
active
:
Vec
<
ops
:
:
Range
<
i32
>
>
=
Vec
:
:
new
(
)
;
let
mut
cur_y
=
events
[
0
]
.
y
;
for
event
in
&
events
{
let
dy
=
event
.
y
-
cur_y
;
if
dy
!
=
0
&
&
!
active
.
is_empty
(
)
{
assert
!
(
dy
>
0
)
;
active
.
sort_by_key
(
|
i
|
i
.
start
)
;
let
mut
query
=
0
;
let
mut
cur
=
active
[
0
]
.
start
;
for
interval
in
&
active
{
cur
=
interval
.
start
.
max
(
cur
)
;
query
+
=
(
interval
.
end
-
cur
)
.
max
(
0
)
;
cur
=
cur
.
max
(
interval
.
end
)
;
}
area
+
=
query
*
dy
;
}
match
event
.
kind
{
EventKind
:
:
Begin
=
>
{
active
.
push
(
event
.
x_range
.
clone
(
)
)
;
}
EventKind
:
:
End
=
>
{
let
index
=
active
.
iter
(
)
.
position
(
|
i
|
*
i
=
=
event
.
x_range
)
.
unwrap
(
)
;
active
.
remove
(
index
)
;
}
}
cur_y
=
event
.
y
;
}
area
}
