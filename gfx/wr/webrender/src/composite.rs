use
api
:
:
ColorF
;
use
api
:
:
units
:
:
{
DeviceRect
DeviceIntSize
DeviceIntRect
DeviceIntPoint
WorldRect
DevicePixelScale
DevicePoint
}
;
use
crate
:
:
gpu_types
:
:
{
ZBufferId
ZBufferIdGenerator
}
;
use
crate
:
:
picture
:
:
{
ResolvedSurfaceTexture
TileCacheInstance
TileSurface
}
;
use
crate
:
:
resource_cache
:
:
ResourceCache
;
use
std
:
:
{
ops
u64
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
NativeSurfaceOperationDetails
{
CreateSurface
{
id
:
NativeSurfaceId
tile_size
:
DeviceIntSize
is_opaque
:
bool
}
DestroySurface
{
id
:
NativeSurfaceId
}
CreateTile
{
id
:
NativeTileId
}
DestroyTile
{
id
:
NativeTileId
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceOperation
{
pub
details
:
NativeSurfaceOperationDetails
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompositeTileSurface
{
Texture
{
surface
:
ResolvedSurfaceTexture
}
Color
{
color
:
ColorF
}
Clear
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeTile
{
pub
surface
:
CompositeTileSurface
pub
rect
:
DeviceRect
pub
clip_rect
:
DeviceRect
pub
dirty_rect
:
DeviceRect
pub
valid_rect
:
DeviceRect
pub
z_id
:
ZBufferId
pub
tile_id
:
Option
<
NativeTileId
>
}
pub
enum
CompositorConfig
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
compositor
:
Box
<
dyn
Compositor
>
}
}
impl
CompositorConfig
{
pub
fn
compositor
(
&
mut
self
)
-
>
Option
<
&
mut
Box
<
dyn
Compositor
>
>
{
match
self
{
CompositorConfig
:
:
Native
{
ref
mut
compositor
.
.
}
=
>
{
Some
(
compositor
)
}
CompositorConfig
:
:
Draw
{
.
.
}
=
>
{
None
}
}
}
}
impl
Default
for
CompositorConfig
{
fn
default
(
)
-
>
Self
{
CompositorConfig
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositorKind
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
}
}
impl
Default
for
CompositorKind
{
fn
default
(
)
-
>
Self
{
CompositorKind
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
Occluder
{
slice
:
usize
device_rect
:
DeviceIntRect
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeSurfaceDescriptor
{
pub
slice
:
usize
pub
surface_id
:
Option
<
NativeSurfaceId
>
pub
offset
:
DevicePoint
pub
clip_rect
:
DeviceRect
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeDescriptor
{
pub
surfaces
:
Vec
<
CompositeSurfaceDescriptor
>
}
impl
CompositeDescriptor
{
pub
fn
empty
(
)
-
>
Self
{
CompositeDescriptor
{
surfaces
:
Vec
:
:
new
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeState
{
pub
opaque_tiles
:
Vec
<
CompositeTile
>
pub
alpha_tiles
:
Vec
<
CompositeTile
>
pub
clear_tiles
:
Vec
<
CompositeTile
>
pub
z_generator
:
ZBufferIdGenerator
pub
dirty_rects_are_valid
:
bool
pub
compositor_kind
:
CompositorKind
pub
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
occluders
:
Vec
<
Occluder
>
pub
descriptor
:
CompositeDescriptor
}
impl
CompositeState
{
pub
fn
new
(
compositor_kind
:
CompositorKind
mut
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
)
-
>
Self
{
if
let
CompositorKind
:
:
Native
{
.
.
}
=
compositor_kind
{
if
!
picture_caching_is_enabled
{
warn
!
(
"
Picture
caching
cannot
be
disabled
in
native
compositor
config
"
)
;
}
picture_caching_is_enabled
=
true
;
}
CompositeState
{
opaque_tiles
:
Vec
:
:
new
(
)
alpha_tiles
:
Vec
:
:
new
(
)
clear_tiles
:
Vec
:
:
new
(
)
z_generator
:
ZBufferIdGenerator
:
:
new
(
0
)
dirty_rects_are_valid
:
true
compositor_kind
picture_caching_is_enabled
global_device_pixel_scale
occluders
:
Vec
:
:
new
(
)
descriptor
:
CompositeDescriptor
:
:
empty
(
)
}
}
pub
fn
register_occluder
(
&
mut
self
slice
:
usize
rect
:
WorldRect
)
{
let
device_rect
=
(
rect
*
self
.
global_device_pixel_scale
)
.
round
(
)
.
to_i32
(
)
;
self
.
occluders
.
push
(
Occluder
{
device_rect
slice
}
)
;
}
pub
fn
is_tile_occluded
(
&
self
slice
:
usize
device_rect
:
DeviceRect
)
-
>
bool
{
let
device_rect
=
device_rect
.
round
(
)
.
to_i32
(
)
;
let
ref_area
=
device_rect
.
size
.
width
*
device_rect
.
size
.
height
;
let
cover_area
=
area_of_occluders
(
&
self
.
occluders
slice
&
device_rect
)
;
debug_assert
!
(
cover_area
<
=
ref_area
)
;
ref_area
=
=
cover_area
}
pub
fn
push_surface
(
&
mut
self
tile_cache
:
&
TileCacheInstance
device_clip_rect
:
DeviceRect
z_id
:
ZBufferId
global_device_pixel_scale
:
DevicePixelScale
resource_cache
:
&
ResourceCache
)
{
let
mut
visible_tile_count
=
0
;
for
tile
in
tile_cache
.
tiles
.
values
(
)
{
if
!
tile
.
is_visible
{
continue
;
}
visible_tile_count
+
=
1
;
let
device_rect
=
(
tile
.
world_tile_rect
*
global_device_pixel_scale
)
.
round
(
)
;
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
let
(
surface
is_opaque
)
=
match
surface
{
TileSurface
:
:
Color
{
color
}
=
>
{
(
CompositeTileSurface
:
:
Color
{
color
:
*
color
}
true
)
}
TileSurface
:
:
Clear
=
>
{
(
CompositeTileSurface
:
:
Clear
false
)
}
TileSurface
:
:
Texture
{
descriptor
.
.
}
=
>
{
let
surface
=
descriptor
.
resolve
(
resource_cache
tile_cache
.
current_tile_size
)
;
(
CompositeTileSurface
:
:
Texture
{
surface
}
tile
.
is_opaque
|
|
tile_cache
.
is_opaque
(
)
)
}
}
;
let
tile_id
=
tile_cache
.
native_surface_id
.
map
(
|
surface_id
|
{
NativeTileId
{
surface_id
x
:
tile
.
tile_offset
.
x
y
:
tile
.
tile_offset
.
y
}
}
)
;
let
tile
=
CompositeTile
{
surface
rect
:
device_rect
valid_rect
:
tile
.
device_valid_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
dirty_rect
:
tile
.
device_dirty_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
clip_rect
:
device_clip_rect
z_id
tile_id
}
;
self
.
push_tile
(
tile
is_opaque
)
;
}
if
visible_tile_count
>
0
{
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
slice
:
tile_cache
.
slice
surface_id
:
tile_cache
.
native_surface_id
offset
:
tile_cache
.
device_position
clip_rect
:
device_clip_rect
}
)
;
}
}
fn
push_tile
(
&
mut
self
tile
:
CompositeTile
is_opaque
:
bool
)
{
match
tile
.
surface
{
CompositeTileSurface
:
:
Color
{
.
.
}
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Clear
=
>
{
self
.
clear_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Texture
{
.
.
}
=
>
{
if
is_opaque
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
else
{
self
.
alpha_tiles
.
push
(
tile
)
;
}
}
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceId
(
pub
u64
)
;
impl
NativeSurfaceId
{
pub
const
DEBUG_OVERLAY
:
NativeSurfaceId
=
NativeSurfaceId
(
u64
:
:
MAX
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeTileId
{
pub
surface_id
:
NativeSurfaceId
pub
x
:
i32
pub
y
:
i32
}
impl
NativeTileId
{
pub
const
DEBUG_OVERLAY
:
NativeTileId
=
NativeTileId
{
surface_id
:
NativeSurfaceId
:
:
DEBUG_OVERLAY
x
:
0
y
:
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
NativeSurfaceInfo
{
pub
origin
:
DeviceIntPoint
pub
fbo_id
:
u32
}
pub
trait
Compositor
{
fn
create_surface
(
&
mut
self
id
:
NativeSurfaceId
tile_size
:
DeviceIntSize
is_opaque
:
bool
)
;
fn
destroy_surface
(
&
mut
self
id
:
NativeSurfaceId
)
;
fn
create_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
destroy_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
bind
(
&
mut
self
id
:
NativeTileId
dirty_rect
:
DeviceIntRect
valid_rect
:
DeviceIntRect
)
-
>
NativeSurfaceInfo
;
fn
unbind
(
&
mut
self
)
;
fn
begin_frame
(
&
mut
self
)
;
fn
add_surface
(
&
mut
self
id
:
NativeSurfaceId
position
:
DeviceIntPoint
clip_rect
:
DeviceIntRect
)
;
fn
end_frame
(
&
mut
self
)
;
fn
enable_native_compositor
(
&
mut
self
enable
:
bool
)
;
}
fn
area_of_occluders
(
occluders
:
&
[
Occluder
]
slice
:
usize
clip_rect
:
&
DeviceIntRect
)
-
>
i32
{
let
mut
area
=
0
;
#
[
derive
(
Debug
)
]
enum
EventKind
{
Begin
End
}
#
[
derive
(
Debug
)
]
struct
Event
{
y
:
i32
x_range
:
ops
:
:
Range
<
i32
>
kind
:
EventKind
}
impl
Event
{
fn
new
(
y
:
i32
kind
:
EventKind
x0
:
i32
x1
:
i32
)
-
>
Self
{
Event
{
y
x_range
:
ops
:
:
Range
{
start
:
x0
end
:
x1
}
kind
}
}
}
let
mut
events
=
Vec
:
:
with_capacity
(
occluders
.
len
(
)
*
2
)
;
for
occluder
in
occluders
{
if
occluder
.
slice
>
slice
{
if
let
Some
(
rect
)
=
occluder
.
device_rect
.
intersection
(
clip_rect
)
{
let
x0
=
rect
.
origin
.
x
;
let
x1
=
x0
+
rect
.
size
.
width
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
EventKind
:
:
Begin
x0
x1
)
)
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
+
rect
.
size
.
height
EventKind
:
:
End
x0
x1
)
)
;
}
}
}
if
events
.
is_empty
(
)
{
return
0
;
}
events
.
sort_by_key
(
|
e
|
e
.
y
)
;
let
mut
active
:
Vec
<
ops
:
:
Range
<
i32
>
>
=
Vec
:
:
new
(
)
;
let
mut
cur_y
=
events
[
0
]
.
y
;
for
event
in
&
events
{
let
dy
=
event
.
y
-
cur_y
;
if
dy
!
=
0
&
&
!
active
.
is_empty
(
)
{
assert
!
(
dy
>
0
)
;
active
.
sort_by_key
(
|
i
|
i
.
start
)
;
let
mut
query
=
0
;
let
mut
cur
=
active
[
0
]
.
start
;
for
interval
in
&
active
{
cur
=
interval
.
start
.
max
(
cur
)
;
query
+
=
(
interval
.
end
-
cur
)
.
max
(
0
)
;
cur
=
cur
.
max
(
interval
.
end
)
;
}
area
+
=
query
*
dy
;
}
match
event
.
kind
{
EventKind
:
:
Begin
=
>
{
active
.
push
(
event
.
x_range
.
clone
(
)
)
;
}
EventKind
:
:
End
=
>
{
let
index
=
active
.
iter
(
)
.
position
(
|
i
|
*
i
=
=
event
.
x_range
)
.
unwrap
(
)
;
active
.
remove
(
index
)
;
}
}
cur_y
=
event
.
y
;
}
area
}
