use
api
:
:
{
ColorF
YuvColorSpace
YuvFormat
ImageRendering
}
;
use
api
:
:
units
:
:
{
DeviceRect
DeviceIntSize
DeviceIntRect
DeviceIntPoint
WorldRect
}
;
use
api
:
:
units
:
:
{
DevicePixelScale
DevicePoint
PictureRect
TexelRect
}
;
use
crate
:
:
batch
:
:
{
resolve_image
get_buffer_kind
}
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
gpu_types
:
:
{
ZBufferId
ZBufferIdGenerator
}
;
use
crate
:
:
internal_types
:
:
TextureSource
;
use
crate
:
:
picture
:
:
{
ImageDependency
ResolvedSurfaceTexture
TileCacheInstance
TileSurface
}
;
use
crate
:
:
prim_store
:
:
DeferredResolve
;
use
crate
:
:
renderer
:
:
ImageBufferKind
;
use
crate
:
:
resource_cache
:
:
{
ImageRequest
ResourceCache
}
;
use
std
:
:
{
ops
u64
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
NativeSurfaceOperationDetails
{
CreateSurface
{
id
:
NativeSurfaceId
virtual_offset
:
DeviceIntPoint
tile_size
:
DeviceIntSize
is_opaque
:
bool
}
DestroySurface
{
id
:
NativeSurfaceId
}
CreateTile
{
id
:
NativeTileId
}
DestroyTile
{
id
:
NativeTileId
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceOperation
{
pub
details
:
NativeSurfaceOperationDetails
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompositeTileSurface
{
Texture
{
surface
:
ResolvedSurfaceTexture
}
Color
{
color
:
ColorF
}
Clear
ExternalSurface
{
external_surface_index
:
ResolvedExternalSurfaceIndex
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositeSurfaceFormat
{
Rgba
Yuv
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeTile
{
pub
surface
:
CompositeTileSurface
pub
rect
:
DeviceRect
pub
clip_rect
:
DeviceRect
pub
dirty_rect
:
DeviceRect
pub
valid_rect
:
DeviceRect
pub
z_id
:
ZBufferId
}
pub
struct
ExternalSurfaceDescriptor
{
pub
local_rect
:
PictureRect
pub
world_rect
:
WorldRect
pub
device_rect
:
DeviceRect
pub
clip_rect
:
DeviceRect
pub
image_dependencies
:
[
ImageDependency
;
3
]
pub
image_rendering
:
ImageRendering
pub
yuv_color_space
:
YuvColorSpace
pub
yuv_format
:
YuvFormat
pub
yuv_rescale
:
f32
pub
z_id
:
ZBufferId
pub
native_surface_id
:
Option
<
NativeSurfaceId
>
pub
update_params
:
Option
<
DeviceIntSize
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
YuvPlaneDescriptor
{
pub
texture
:
TextureSource
pub
texture_layer
:
i32
pub
uv_rect
:
TexelRect
}
impl
YuvPlaneDescriptor
{
fn
invalid
(
)
-
>
Self
{
YuvPlaneDescriptor
{
texture
:
TextureSource
:
:
Invalid
texture_layer
:
0
uv_rect
:
TexelRect
:
:
invalid
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
ResolvedExternalSurfaceIndex
(
pub
usize
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ResolvedExternalSurface
{
pub
image_dependencies
:
[
ImageDependency
;
3
]
pub
yuv_planes
:
[
YuvPlaneDescriptor
;
3
]
pub
yuv_color_space
:
YuvColorSpace
pub
yuv_format
:
YuvFormat
pub
yuv_rescale
:
f32
pub
image_buffer_kind
:
ImageBufferKind
pub
update_params
:
Option
<
(
NativeSurfaceId
DeviceIntSize
)
>
}
pub
enum
CompositorConfig
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
compositor
:
Box
<
dyn
Compositor
>
}
}
impl
CompositorConfig
{
pub
fn
compositor
(
&
mut
self
)
-
>
Option
<
&
mut
Box
<
dyn
Compositor
>
>
{
match
self
{
CompositorConfig
:
:
Native
{
ref
mut
compositor
.
.
}
=
>
{
Some
(
compositor
)
}
CompositorConfig
:
:
Draw
{
.
.
}
=
>
{
None
}
}
}
}
impl
Default
for
CompositorConfig
{
fn
default
(
)
-
>
Self
{
CompositorConfig
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositorKind
{
Draw
{
max_partial_present_rects
:
usize
}
Native
{
max_update_rects
:
usize
virtual_surface_size
:
i32
}
}
impl
Default
for
CompositorKind
{
fn
default
(
)
-
>
Self
{
CompositorKind
:
:
Draw
{
max_partial_present_rects
:
0
}
}
}
impl
CompositorKind
{
pub
fn
get_virtual_surface_size
(
&
self
)
-
>
i32
{
match
self
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
0
CompositorKind
:
:
Native
{
virtual_surface_size
.
.
}
=
>
*
virtual_surface_size
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
Occluder
{
z_id
:
ZBufferId
device_rect
:
DeviceIntRect
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeSurfaceDescriptor
{
pub
surface_id
:
Option
<
NativeSurfaceId
>
pub
offset
:
DevicePoint
pub
clip_rect
:
DeviceRect
pub
image_dependencies
:
[
ImageDependency
;
3
]
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeDescriptor
{
pub
surfaces
:
Vec
<
CompositeSurfaceDescriptor
>
}
impl
CompositeDescriptor
{
pub
fn
empty
(
)
-
>
Self
{
CompositeDescriptor
{
surfaces
:
Vec
:
:
new
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeState
{
pub
opaque_tiles
:
Vec
<
CompositeTile
>
pub
alpha_tiles
:
Vec
<
CompositeTile
>
pub
clear_tiles
:
Vec
<
CompositeTile
>
pub
external_surfaces
:
Vec
<
ResolvedExternalSurface
>
pub
z_generator
:
ZBufferIdGenerator
pub
dirty_rects_are_valid
:
bool
pub
compositor_kind
:
CompositorKind
pub
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
occluders
:
Vec
<
Occluder
>
pub
descriptor
:
CompositeDescriptor
}
impl
CompositeState
{
pub
fn
new
(
compositor_kind
:
CompositorKind
mut
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
max_depth_ids
:
i32
)
-
>
Self
{
if
let
CompositorKind
:
:
Native
{
.
.
}
=
compositor_kind
{
if
!
picture_caching_is_enabled
{
warn
!
(
"
Picture
caching
cannot
be
disabled
in
native
compositor
config
"
)
;
}
picture_caching_is_enabled
=
true
;
}
CompositeState
{
opaque_tiles
:
Vec
:
:
new
(
)
alpha_tiles
:
Vec
:
:
new
(
)
clear_tiles
:
Vec
:
:
new
(
)
z_generator
:
ZBufferIdGenerator
:
:
new
(
0
max_depth_ids
)
dirty_rects_are_valid
:
true
compositor_kind
picture_caching_is_enabled
global_device_pixel_scale
occluders
:
Vec
:
:
new
(
)
descriptor
:
CompositeDescriptor
:
:
empty
(
)
external_surfaces
:
Vec
:
:
new
(
)
}
}
pub
fn
register_occluder
(
&
mut
self
z_id
:
ZBufferId
rect
:
WorldRect
)
{
let
device_rect
=
(
rect
*
self
.
global_device_pixel_scale
)
.
round
(
)
.
to_i32
(
)
;
self
.
occluders
.
push
(
Occluder
{
device_rect
z_id
}
)
;
}
pub
fn
is_tile_occluded
(
&
self
z_id
:
ZBufferId
device_rect
:
DeviceRect
)
-
>
bool
{
let
device_rect
=
device_rect
.
round
(
)
.
to_i32
(
)
;
let
ref_area
=
device_rect
.
size
.
width
*
device_rect
.
size
.
height
;
let
cover_area
=
area_of_occluders
(
&
self
.
occluders
z_id
&
device_rect
)
;
debug_assert
!
(
cover_area
<
=
ref_area
)
;
ref_area
=
=
cover_area
}
pub
fn
push_surface
(
&
mut
self
tile_cache
:
&
TileCacheInstance
device_clip_rect
:
DeviceRect
global_device_pixel_scale
:
DevicePixelScale
resource_cache
:
&
ResourceCache
gpu_cache
:
&
mut
GpuCache
deferred_resolves
:
&
mut
Vec
<
DeferredResolve
>
)
{
let
mut
visible_opaque_tile_count
=
0
;
let
mut
visible_alpha_tile_count
=
0
;
for
tile
in
tile_cache
.
tiles
.
values
(
)
{
if
!
tile
.
is_visible
{
continue
;
}
let
device_rect
=
(
tile
.
world_tile_rect
*
global_device_pixel_scale
)
.
round
(
)
;
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
let
(
surface
is_opaque
)
=
match
surface
{
TileSurface
:
:
Color
{
color
}
=
>
{
(
CompositeTileSurface
:
:
Color
{
color
:
*
color
}
true
)
}
TileSurface
:
:
Clear
=
>
{
(
CompositeTileSurface
:
:
Clear
false
)
}
TileSurface
:
:
Texture
{
descriptor
.
.
}
=
>
{
let
surface
=
descriptor
.
resolve
(
resource_cache
tile_cache
.
current_tile_size
)
;
(
CompositeTileSurface
:
:
Texture
{
surface
}
tile
.
is_opaque
|
|
tile_cache
.
is_opaque
(
)
)
}
}
;
if
is_opaque
{
visible_opaque_tile_count
+
=
1
;
}
else
{
visible_alpha_tile_count
+
=
1
;
}
let
tile
=
CompositeTile
{
surface
rect
:
device_rect
valid_rect
:
tile
.
device_valid_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
dirty_rect
:
tile
.
device_dirty_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
clip_rect
:
device_clip_rect
z_id
:
tile
.
z_id
}
;
self
.
push_tile
(
tile
is_opaque
)
;
}
if
visible_opaque_tile_count
>
0
{
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
tile_cache
.
native_surface
.
as_ref
(
)
.
map
(
|
s
|
s
.
opaque
)
offset
:
tile_cache
.
device_position
clip_rect
:
device_clip_rect
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
}
)
;
}
for
external_surface
in
&
tile_cache
.
external_surfaces
{
let
mut
yuv_planes
=
[
YuvPlaneDescriptor
:
:
invalid
(
)
YuvPlaneDescriptor
:
:
invalid
(
)
YuvPlaneDescriptor
:
:
invalid
(
)
]
;
let
required_plane_count
=
external_surface
.
yuv_format
.
get_plane_num
(
)
;
let
mut
valid_plane_count
=
0
;
for
i
in
0
.
.
required_plane_count
{
let
key
=
external_surface
.
image_dependencies
[
i
]
.
key
;
let
plane
=
&
mut
yuv_planes
[
i
]
;
let
request
=
ImageRequest
{
key
rendering
:
external_surface
.
image_rendering
tile
:
None
}
;
let
cache_item
=
resolve_image
(
request
resource_cache
gpu_cache
deferred_resolves
)
;
if
cache_item
.
texture_id
!
=
TextureSource
:
:
Invalid
{
valid_plane_count
+
=
1
;
*
plane
=
YuvPlaneDescriptor
{
texture
:
cache_item
.
texture_id
texture_layer
:
cache_item
.
texture_layer
uv_rect
:
cache_item
.
uv_rect
.
into
(
)
}
;
}
}
if
valid_plane_count
<
required_plane_count
{
warn
!
(
"
Warnings
:
skip
a
YUV
compositor
surface
found
{
}
/
{
}
valid
images
"
valid_plane_count
required_plane_count
)
;
continue
;
}
let
clip_rect
=
external_surface
.
clip_rect
.
intersection
(
&
device_clip_rect
)
.
unwrap_or_else
(
DeviceRect
:
:
zero
)
;
let
surface
=
CompositeTileSurface
:
:
ExternalSurface
{
external_surface_index
:
ResolvedExternalSurfaceIndex
(
self
.
external_surfaces
.
len
(
)
)
}
;
let
update_params
=
external_surface
.
update_params
.
map
(
|
surface_size
|
{
(
external_surface
.
native_surface_id
.
expect
(
"
bug
:
no
native
surface
!
"
)
surface_size
)
}
)
;
self
.
external_surfaces
.
push
(
ResolvedExternalSurface
{
yuv_color_space
:
external_surface
.
yuv_color_space
yuv_format
:
external_surface
.
yuv_format
yuv_rescale
:
external_surface
.
yuv_rescale
image_buffer_kind
:
get_buffer_kind
(
yuv_planes
[
0
]
.
texture
)
image_dependencies
:
external_surface
.
image_dependencies
yuv_planes
update_params
}
)
;
let
tile
=
CompositeTile
{
surface
rect
:
external_surface
.
device_rect
valid_rect
:
external_surface
.
device_rect
.
translate
(
-
external_surface
.
device_rect
.
origin
.
to_vector
(
)
)
dirty_rect
:
external_surface
.
device_rect
.
translate
(
-
external_surface
.
device_rect
.
origin
.
to_vector
(
)
)
clip_rect
z_id
:
external_surface
.
z_id
}
;
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
external_surface
.
native_surface_id
offset
:
tile
.
rect
.
origin
clip_rect
:
tile
.
clip_rect
image_dependencies
:
external_surface
.
image_dependencies
}
)
;
self
.
push_tile
(
tile
true
)
;
}
if
visible_alpha_tile_count
>
0
{
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
tile_cache
.
native_surface
.
as_ref
(
)
.
map
(
|
s
|
s
.
alpha
)
offset
:
tile_cache
.
device_position
clip_rect
:
device_clip_rect
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
}
)
;
}
}
fn
push_tile
(
&
mut
self
tile
:
CompositeTile
is_opaque
:
bool
)
{
match
tile
.
surface
{
CompositeTileSurface
:
:
Color
{
.
.
}
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Clear
=
>
{
self
.
clear_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Texture
{
.
.
}
=
>
{
if
is_opaque
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
else
{
self
.
alpha_tiles
.
push
(
tile
)
;
}
}
CompositeTileSurface
:
:
ExternalSurface
{
.
.
}
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceId
(
pub
u64
)
;
impl
NativeSurfaceId
{
pub
const
DEBUG_OVERLAY
:
NativeSurfaceId
=
NativeSurfaceId
(
u64
:
:
MAX
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeTileId
{
pub
surface_id
:
NativeSurfaceId
pub
x
:
i32
pub
y
:
i32
}
impl
NativeTileId
{
pub
const
DEBUG_OVERLAY
:
NativeTileId
=
NativeTileId
{
surface_id
:
NativeSurfaceId
:
:
DEBUG_OVERLAY
x
:
0
y
:
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
NativeSurfaceInfo
{
pub
origin
:
DeviceIntPoint
pub
fbo_id
:
u32
}
#
[
repr
(
C
)
]
pub
struct
CompositorCapabilities
{
pub
virtual_surface_size
:
i32
}
pub
trait
Compositor
{
fn
create_surface
(
&
mut
self
id
:
NativeSurfaceId
virtual_offset
:
DeviceIntPoint
tile_size
:
DeviceIntSize
is_opaque
:
bool
)
;
fn
destroy_surface
(
&
mut
self
id
:
NativeSurfaceId
)
;
fn
create_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
destroy_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
bind
(
&
mut
self
id
:
NativeTileId
dirty_rect
:
DeviceIntRect
valid_rect
:
DeviceIntRect
)
-
>
NativeSurfaceInfo
;
fn
unbind
(
&
mut
self
)
;
fn
begin_frame
(
&
mut
self
)
;
fn
add_surface
(
&
mut
self
id
:
NativeSurfaceId
position
:
DeviceIntPoint
clip_rect
:
DeviceIntRect
)
;
fn
end_frame
(
&
mut
self
)
;
fn
enable_native_compositor
(
&
mut
self
enable
:
bool
)
;
fn
deinit
(
&
mut
self
)
;
fn
get_capabilities
(
&
self
)
-
>
CompositorCapabilities
;
}
fn
area_of_occluders
(
occluders
:
&
[
Occluder
]
z_id
:
ZBufferId
clip_rect
:
&
DeviceIntRect
)
-
>
i32
{
let
mut
area
=
0
;
#
[
derive
(
Debug
)
]
enum
EventKind
{
Begin
End
}
#
[
derive
(
Debug
)
]
struct
Event
{
y
:
i32
x_range
:
ops
:
:
Range
<
i32
>
kind
:
EventKind
}
impl
Event
{
fn
new
(
y
:
i32
kind
:
EventKind
x0
:
i32
x1
:
i32
)
-
>
Self
{
Event
{
y
x_range
:
ops
:
:
Range
{
start
:
x0
end
:
x1
}
kind
}
}
}
let
mut
events
=
Vec
:
:
with_capacity
(
occluders
.
len
(
)
*
2
)
;
for
occluder
in
occluders
{
if
occluder
.
z_id
.
0
>
z_id
.
0
{
if
let
Some
(
rect
)
=
occluder
.
device_rect
.
intersection
(
clip_rect
)
{
let
x0
=
rect
.
origin
.
x
;
let
x1
=
x0
+
rect
.
size
.
width
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
EventKind
:
:
Begin
x0
x1
)
)
;
events
.
push
(
Event
:
:
new
(
rect
.
origin
.
y
+
rect
.
size
.
height
EventKind
:
:
End
x0
x1
)
)
;
}
}
}
if
events
.
is_empty
(
)
{
return
0
;
}
events
.
sort_by_key
(
|
e
|
e
.
y
)
;
let
mut
active
:
Vec
<
ops
:
:
Range
<
i32
>
>
=
Vec
:
:
new
(
)
;
let
mut
cur_y
=
events
[
0
]
.
y
;
for
event
in
&
events
{
let
dy
=
event
.
y
-
cur_y
;
if
dy
!
=
0
&
&
!
active
.
is_empty
(
)
{
assert
!
(
dy
>
0
)
;
active
.
sort_by_key
(
|
i
|
i
.
start
)
;
let
mut
query
=
0
;
let
mut
cur
=
active
[
0
]
.
start
;
for
interval
in
&
active
{
cur
=
interval
.
start
.
max
(
cur
)
;
query
+
=
(
interval
.
end
-
cur
)
.
max
(
0
)
;
cur
=
cur
.
max
(
interval
.
end
)
;
}
area
+
=
query
*
dy
;
}
match
event
.
kind
{
EventKind
:
:
Begin
=
>
{
active
.
push
(
event
.
x_range
.
clone
(
)
)
;
}
EventKind
:
:
End
=
>
{
let
index
=
active
.
iter
(
)
.
position
(
|
i
|
*
i
=
=
event
.
x_range
)
.
unwrap
(
)
;
active
.
remove
(
index
)
;
}
}
cur_y
=
event
.
y
;
}
area
}
