use
api
:
:
{
ColorF
YuvColorSpace
YuvFormat
ImageRendering
ExternalImageId
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
batch
:
:
{
resolve_image
get_buffer_kind
}
;
use
euclid
:
:
Transform3D
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
gpu_types
:
:
{
ZBufferId
ZBufferIdGenerator
}
;
use
crate
:
:
internal_types
:
:
TextureSource
;
use
crate
:
:
picture
:
:
{
ImageDependency
ResolvedSurfaceTexture
TileCacheInstance
TileId
TileSurface
}
;
use
crate
:
:
prim_store
:
:
DeferredResolve
;
use
crate
:
:
renderer
:
:
ImageBufferKind
;
use
crate
:
:
resource_cache
:
:
{
ImageRequest
ResourceCache
}
;
use
crate
:
:
util
:
:
Preallocator
;
use
std
:
:
{
ops
u64
}
;
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
NativeSurfaceOperationDetails
{
CreateSurface
{
id
:
NativeSurfaceId
virtual_offset
:
DeviceIntPoint
tile_size
:
DeviceIntSize
is_opaque
:
bool
}
CreateExternalSurface
{
id
:
NativeSurfaceId
is_opaque
:
bool
}
DestroySurface
{
id
:
NativeSurfaceId
}
CreateTile
{
id
:
NativeTileId
}
DestroyTile
{
id
:
NativeTileId
}
AttachExternalImage
{
id
:
NativeSurfaceId
external_image
:
ExternalImageId
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceOperation
{
pub
details
:
NativeSurfaceOperationDetails
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompositeTileSurface
{
Texture
{
surface
:
ResolvedSurfaceTexture
}
Color
{
color
:
ColorF
}
Clear
ExternalSurface
{
external_surface_index
:
ResolvedExternalSurfaceIndex
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositeSurfaceFormat
{
Rgba
Yuv
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeTile
{
pub
surface
:
CompositeTileSurface
pub
rect
:
DeviceRect
pub
clip_rect
:
DeviceRect
pub
dirty_rect
:
DeviceRect
pub
valid_rect
:
DeviceRect
pub
z_id
:
ZBufferId
}
pub
enum
ExternalSurfaceDependency
{
Yuv
{
image_dependencies
:
[
ImageDependency
;
3
]
color_space
:
YuvColorSpace
format
:
YuvFormat
rescale
:
f32
}
Rgb
{
image_dependency
:
ImageDependency
flip_y
:
bool
}
}
pub
struct
ExternalSurfaceDescriptor
{
pub
local_rect
:
PictureRect
pub
surface_rect
:
DeviceRect
pub
device_rect
:
DeviceRect
pub
local_clip_rect
:
PictureRect
pub
clip_rect
:
DeviceRect
pub
transform
:
CompositorSurfaceTransform
pub
image_rendering
:
ImageRendering
pub
z_id
:
ZBufferId
pub
dependency
:
ExternalSurfaceDependency
pub
native_surface_id
:
Option
<
NativeSurfaceId
>
pub
update_params
:
Option
<
DeviceIntSize
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
ExternalPlaneDescriptor
{
pub
texture
:
TextureSource
pub
texture_layer
:
i32
pub
uv_rect
:
TexelRect
}
impl
ExternalPlaneDescriptor
{
fn
invalid
(
)
-
>
Self
{
ExternalPlaneDescriptor
{
texture
:
TextureSource
:
:
Invalid
texture_layer
:
0
uv_rect
:
TexelRect
:
:
invalid
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
ResolvedExternalSurfaceIndex
(
pub
usize
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ResolvedExternalSurfaceColorData
{
Yuv
{
image_dependencies
:
[
ImageDependency
;
3
]
planes
:
[
ExternalPlaneDescriptor
;
3
]
color_space
:
YuvColorSpace
format
:
YuvFormat
rescale
:
f32
}
Rgb
{
image_dependency
:
ImageDependency
plane
:
ExternalPlaneDescriptor
flip_y
:
bool
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ResolvedExternalSurface
{
pub
color_data
:
ResolvedExternalSurfaceColorData
pub
image_buffer_kind
:
ImageBufferKind
pub
update_params
:
Option
<
(
NativeSurfaceId
DeviceIntSize
)
>
}
pub
enum
CompositorConfig
{
Draw
{
max_partial_present_rects
:
usize
draw_previous_partial_present_regions
:
bool
}
Native
{
max_update_rects
:
usize
compositor
:
Box
<
dyn
Compositor
>
}
}
impl
CompositorConfig
{
pub
fn
compositor
(
&
mut
self
)
-
>
Option
<
&
mut
Box
<
dyn
Compositor
>
>
{
match
self
{
CompositorConfig
:
:
Native
{
ref
mut
compositor
.
.
}
=
>
{
Some
(
compositor
)
}
CompositorConfig
:
:
Draw
{
.
.
}
=
>
{
None
}
}
}
}
impl
Default
for
CompositorConfig
{
fn
default
(
)
-
>
Self
{
CompositorConfig
:
:
Draw
{
max_partial_present_rects
:
0
draw_previous_partial_present_regions
:
false
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
CompositorKind
{
Draw
{
max_partial_present_rects
:
usize
draw_previous_partial_present_regions
:
bool
}
Native
{
max_update_rects
:
usize
virtual_surface_size
:
i32
}
}
impl
Default
for
CompositorKind
{
fn
default
(
)
-
>
Self
{
CompositorKind
:
:
Draw
{
max_partial_present_rects
:
0
draw_previous_partial_present_regions
:
false
}
}
}
impl
CompositorKind
{
pub
fn
get_virtual_surface_size
(
&
self
)
-
>
i32
{
match
self
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
0
CompositorKind
:
:
Native
{
virtual_surface_size
.
.
}
=
>
*
virtual_surface_size
}
}
pub
fn
supports_transforms
(
&
self
)
-
>
bool
{
match
self
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
false
CompositorKind
:
:
Native
{
.
.
}
=
>
true
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
enum
TileSurfaceKind
{
Texture
Color
{
color
:
ColorF
}
Clear
}
impl
From
<
&
TileSurface
>
for
TileSurfaceKind
{
fn
from
(
surface
:
&
TileSurface
)
-
>
Self
{
match
surface
{
TileSurface
:
:
Texture
{
.
.
}
=
>
TileSurfaceKind
:
:
Texture
TileSurface
:
:
Color
{
color
}
=
>
TileSurfaceKind
:
:
Color
{
color
:
*
color
}
TileSurface
:
:
Clear
=
>
TileSurfaceKind
:
:
Clear
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeTileDescriptor
{
pub
tile_id
:
TileId
pub
surface_kind
:
TileSurfaceKind
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeSurfaceDescriptor
{
pub
surface_id
:
Option
<
NativeSurfaceId
>
pub
offset
:
DevicePoint
pub
clip_rect
:
DeviceRect
pub
transform
:
CompositorSurfaceTransform
pub
image_dependencies
:
[
ImageDependency
;
3
]
pub
image_rendering
:
ImageRendering
pub
tile_descriptors
:
Vec
<
CompositeTileDescriptor
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
Clone
)
]
pub
struct
CompositeDescriptor
{
pub
surfaces
:
Vec
<
CompositeSurfaceDescriptor
>
}
impl
CompositeDescriptor
{
pub
fn
empty
(
)
-
>
Self
{
CompositeDescriptor
{
surfaces
:
Vec
:
:
new
(
)
}
}
}
pub
struct
CompositeStatePreallocator
{
opaque_tiles
:
Preallocator
alpha_tiles
:
Preallocator
clear_tiles
:
Preallocator
external_surfaces
:
Preallocator
occluders
:
Preallocator
occluders_events
:
Preallocator
occluders_active
:
Preallocator
descriptor_surfaces
:
Preallocator
}
impl
CompositeStatePreallocator
{
pub
fn
record
(
&
mut
self
state
:
&
CompositeState
)
{
self
.
opaque_tiles
.
record_vec
(
&
state
.
opaque_tiles
)
;
self
.
alpha_tiles
.
record_vec
(
&
state
.
alpha_tiles
)
;
self
.
clear_tiles
.
record_vec
(
&
state
.
clear_tiles
)
;
self
.
external_surfaces
.
record_vec
(
&
state
.
external_surfaces
)
;
self
.
occluders
.
record_vec
(
&
state
.
occluders
.
occluders
)
;
self
.
occluders_events
.
record_vec
(
&
state
.
occluders
.
events
)
;
self
.
occluders_active
.
record_vec
(
&
state
.
occluders
.
active
)
;
self
.
descriptor_surfaces
.
record_vec
(
&
state
.
descriptor
.
surfaces
)
;
}
pub
fn
preallocate
(
&
self
state
:
&
mut
CompositeState
)
{
self
.
opaque_tiles
.
preallocate_vec
(
&
mut
state
.
opaque_tiles
)
;
self
.
alpha_tiles
.
preallocate_vec
(
&
mut
state
.
alpha_tiles
)
;
self
.
clear_tiles
.
preallocate_vec
(
&
mut
state
.
clear_tiles
)
;
self
.
external_surfaces
.
preallocate_vec
(
&
mut
state
.
external_surfaces
)
;
self
.
occluders
.
preallocate_vec
(
&
mut
state
.
occluders
.
occluders
)
;
self
.
occluders_events
.
preallocate_vec
(
&
mut
state
.
occluders
.
events
)
;
self
.
occluders_active
.
preallocate_vec
(
&
mut
state
.
occluders
.
active
)
;
self
.
descriptor_surfaces
.
preallocate_vec
(
&
mut
state
.
descriptor
.
surfaces
)
;
}
}
impl
Default
for
CompositeStatePreallocator
{
fn
default
(
)
-
>
Self
{
CompositeStatePreallocator
{
opaque_tiles
:
Preallocator
:
:
new
(
40
)
alpha_tiles
:
Preallocator
:
:
new
(
16
)
clear_tiles
:
Preallocator
:
:
new
(
0
)
external_surfaces
:
Preallocator
:
:
new
(
0
)
occluders
:
Preallocator
:
:
new
(
16
)
occluders_events
:
Preallocator
:
:
new
(
32
)
occluders_active
:
Preallocator
:
:
new
(
16
)
descriptor_surfaces
:
Preallocator
:
:
new
(
8
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CompositeState
{
pub
opaque_tiles
:
Vec
<
CompositeTile
>
pub
alpha_tiles
:
Vec
<
CompositeTile
>
pub
clear_tiles
:
Vec
<
CompositeTile
>
pub
external_surfaces
:
Vec
<
ResolvedExternalSurface
>
pub
z_generator
:
ZBufferIdGenerator
pub
dirty_rects_are_valid
:
bool
pub
compositor_kind
:
CompositorKind
pub
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
pub
occluders
:
Occluders
pub
descriptor
:
CompositeDescriptor
}
impl
CompositeState
{
pub
fn
new
(
compositor_kind
:
CompositorKind
mut
picture_caching_is_enabled
:
bool
global_device_pixel_scale
:
DevicePixelScale
max_depth_ids
:
i32
dirty_rects_are_valid
:
bool
)
-
>
Self
{
if
let
CompositorKind
:
:
Native
{
.
.
}
=
compositor_kind
{
if
!
picture_caching_is_enabled
{
warn
!
(
"
Picture
caching
cannot
be
disabled
in
native
compositor
config
"
)
;
}
picture_caching_is_enabled
=
true
;
}
CompositeState
{
opaque_tiles
:
Vec
:
:
new
(
)
alpha_tiles
:
Vec
:
:
new
(
)
clear_tiles
:
Vec
:
:
new
(
)
z_generator
:
ZBufferIdGenerator
:
:
new
(
max_depth_ids
)
dirty_rects_are_valid
compositor_kind
picture_caching_is_enabled
global_device_pixel_scale
occluders
:
Occluders
:
:
new
(
)
descriptor
:
CompositeDescriptor
:
:
empty
(
)
external_surfaces
:
Vec
:
:
new
(
)
}
}
pub
fn
register_occluder
(
&
mut
self
z_id
:
ZBufferId
rect
:
WorldRect
)
{
let
device_rect
=
(
rect
*
self
.
global_device_pixel_scale
)
.
round
(
)
.
to_i32
(
)
;
self
.
occluders
.
push
(
device_rect
z_id
)
;
}
pub
fn
push_surface
(
&
mut
self
tile_cache
:
&
TileCacheInstance
device_clip_rect
:
DeviceRect
global_device_pixel_scale
:
DevicePixelScale
resource_cache
:
&
ResourceCache
gpu_cache
:
&
mut
GpuCache
deferred_resolves
:
&
mut
Vec
<
DeferredResolve
>
)
{
let
mut
visible_opaque_tile_count
=
0
;
let
mut
visible_alpha_tile_count
=
0
;
let
mut
opaque_tile_descriptors
=
Vec
:
:
new
(
)
;
let
mut
alpha_tile_descriptors
=
Vec
:
:
new
(
)
;
for
tile
in
tile_cache
.
tiles
.
values
(
)
{
if
!
tile
.
is_visible
{
continue
;
}
let
device_rect
=
(
tile
.
world_tile_rect
*
global_device_pixel_scale
)
.
round
(
)
;
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
let
descriptor
=
CompositeTileDescriptor
{
surface_kind
:
surface
.
into
(
)
tile_id
:
tile
.
id
}
;
let
(
surface
is_opaque
)
=
match
surface
{
TileSurface
:
:
Color
{
color
}
=
>
{
(
CompositeTileSurface
:
:
Color
{
color
:
*
color
}
true
)
}
TileSurface
:
:
Clear
=
>
{
(
CompositeTileSurface
:
:
Clear
false
)
}
TileSurface
:
:
Texture
{
descriptor
.
.
}
=
>
{
let
surface
=
descriptor
.
resolve
(
resource_cache
tile_cache
.
current_tile_size
)
;
(
CompositeTileSurface
:
:
Texture
{
surface
}
tile
.
is_opaque
|
|
(
!
tile
.
has_compositor_surface
&
&
tile_cache
.
is_opaque
(
)
)
)
}
}
;
if
is_opaque
{
opaque_tile_descriptors
.
push
(
descriptor
)
;
visible_opaque_tile_count
+
=
1
;
}
else
{
alpha_tile_descriptors
.
push
(
descriptor
)
;
visible_alpha_tile_count
+
=
1
;
}
let
tile
=
CompositeTile
{
surface
rect
:
device_rect
valid_rect
:
tile
.
device_valid_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
dirty_rect
:
tile
.
device_dirty_rect
.
translate
(
-
device_rect
.
origin
.
to_vector
(
)
)
clip_rect
:
device_clip_rect
z_id
:
tile
.
z_id
}
;
self
.
push_tile
(
tile
is_opaque
)
;
}
opaque_tile_descriptors
.
sort_by_key
(
|
desc
|
desc
.
tile_id
)
;
alpha_tile_descriptors
.
sort_by_key
(
|
desc
|
desc
.
tile_id
)
;
if
visible_opaque_tile_count
>
0
{
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
tile_cache
.
native_surface
.
as_ref
(
)
.
map
(
|
s
|
s
.
opaque
)
offset
:
tile_cache
.
device_position
clip_rect
:
device_clip_rect
transform
:
CompositorSurfaceTransform
:
:
translation
(
tile_cache
.
device_position
.
x
tile_cache
.
device_position
.
y
0
.
0
)
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
image_rendering
:
ImageRendering
:
:
CrispEdges
tile_descriptors
:
opaque_tile_descriptors
}
)
;
}
for
external_surface
in
&
tile_cache
.
external_surfaces
{
let
mut
planes
=
[
ExternalPlaneDescriptor
:
:
invalid
(
)
ExternalPlaneDescriptor
:
:
invalid
(
)
ExternalPlaneDescriptor
:
:
invalid
(
)
]
;
let
required_plane_count
=
match
external_surface
.
dependency
{
ExternalSurfaceDependency
:
:
Yuv
{
format
.
.
}
=
>
{
format
.
get_plane_num
(
)
}
ExternalSurfaceDependency
:
:
Rgb
{
.
.
}
=
>
{
1
}
}
;
let
mut
valid_plane_count
=
0
;
let
mut
image_dependencies
=
[
ImageDependency
:
:
INVALID
;
3
]
;
for
i
in
0
.
.
required_plane_count
{
let
dependency
=
match
external_surface
.
dependency
{
ExternalSurfaceDependency
:
:
Yuv
{
image_dependencies
.
.
}
=
>
{
image_dependencies
[
i
]
}
ExternalSurfaceDependency
:
:
Rgb
{
image_dependency
.
.
}
=
>
{
image_dependency
}
}
;
image_dependencies
[
i
]
=
dependency
;
let
request
=
ImageRequest
{
key
:
dependency
.
key
rendering
:
external_surface
.
image_rendering
tile
:
None
}
;
let
cache_item
=
resolve_image
(
request
resource_cache
gpu_cache
deferred_resolves
)
;
if
cache_item
.
texture_id
!
=
TextureSource
:
:
Invalid
{
valid_plane_count
+
=
1
;
let
plane
=
&
mut
planes
[
i
]
;
*
plane
=
ExternalPlaneDescriptor
{
texture
:
cache_item
.
texture_id
texture_layer
:
cache_item
.
texture_layer
uv_rect
:
cache_item
.
uv_rect
.
into
(
)
}
;
}
}
if
valid_plane_count
<
required_plane_count
{
warn
!
(
"
Warnings
:
skip
a
YUV
/
RGB
compositor
surface
found
{
}
/
{
}
valid
images
"
valid_plane_count
required_plane_count
)
;
continue
;
}
let
clip_rect
=
external_surface
.
clip_rect
.
intersection
(
&
device_clip_rect
)
.
unwrap_or_else
(
DeviceRect
:
:
zero
)
;
let
surface
=
CompositeTileSurface
:
:
ExternalSurface
{
external_surface_index
:
ResolvedExternalSurfaceIndex
(
self
.
external_surfaces
.
len
(
)
)
}
;
let
update_params
=
external_surface
.
update_params
.
map
(
|
surface_size
|
{
(
external_surface
.
native_surface_id
.
expect
(
"
bug
:
no
native
surface
!
"
)
surface_size
)
}
)
;
match
external_surface
.
dependency
{
ExternalSurfaceDependency
:
:
Yuv
{
color_space
format
rescale
.
.
}
=
>
{
let
image_buffer_kind
=
get_buffer_kind
(
planes
[
0
]
.
texture
)
;
self
.
external_surfaces
.
push
(
ResolvedExternalSurface
{
color_data
:
ResolvedExternalSurfaceColorData
:
:
Yuv
{
image_dependencies
planes
color_space
format
rescale
}
image_buffer_kind
update_params
}
)
;
}
ExternalSurfaceDependency
:
:
Rgb
{
flip_y
.
.
}
=
>
{
let
image_buffer_kind
=
get_buffer_kind
(
planes
[
0
]
.
texture
)
;
self
.
external_surfaces
.
push
(
ResolvedExternalSurface
{
color_data
:
ResolvedExternalSurfaceColorData
:
:
Rgb
{
image_dependency
:
image_dependencies
[
0
]
plane
:
planes
[
0
]
flip_y
:
flip_y
&
&
!
self
.
compositor_kind
.
supports_transforms
(
)
}
image_buffer_kind
update_params
}
)
;
}
}
let
tile
=
CompositeTile
{
surface
rect
:
external_surface
.
surface_rect
valid_rect
:
external_surface
.
device_rect
.
translate
(
-
external_surface
.
device_rect
.
origin
.
to_vector
(
)
)
dirty_rect
:
external_surface
.
device_rect
.
translate
(
-
external_surface
.
device_rect
.
origin
.
to_vector
(
)
)
clip_rect
z_id
:
external_surface
.
z_id
}
;
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
external_surface
.
native_surface_id
offset
:
tile
.
rect
.
origin
clip_rect
transform
:
external_surface
.
transform
image_dependencies
:
image_dependencies
image_rendering
:
external_surface
.
image_rendering
tile_descriptors
:
Vec
:
:
new
(
)
}
)
;
self
.
push_tile
(
tile
true
)
;
}
if
visible_alpha_tile_count
>
0
{
self
.
descriptor
.
surfaces
.
push
(
CompositeSurfaceDescriptor
{
surface_id
:
tile_cache
.
native_surface
.
as_ref
(
)
.
map
(
|
s
|
s
.
alpha
)
offset
:
tile_cache
.
device_position
clip_rect
:
device_clip_rect
transform
:
CompositorSurfaceTransform
:
:
translation
(
tile_cache
.
device_position
.
x
tile_cache
.
device_position
.
y
0
.
0
)
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
image_rendering
:
ImageRendering
:
:
CrispEdges
tile_descriptors
:
alpha_tile_descriptors
}
)
;
}
}
fn
push_tile
(
&
mut
self
tile
:
CompositeTile
is_opaque
:
bool
)
{
match
tile
.
surface
{
CompositeTileSurface
:
:
Color
{
.
.
}
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Clear
=
>
{
self
.
clear_tiles
.
push
(
tile
)
;
}
CompositeTileSurface
:
:
Texture
{
.
.
}
=
>
{
if
is_opaque
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
else
{
self
.
alpha_tiles
.
push
(
tile
)
;
}
}
CompositeTileSurface
:
:
ExternalSurface
{
.
.
}
=
>
{
self
.
opaque_tiles
.
push
(
tile
)
;
}
}
}
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeSurfaceId
(
pub
u64
)
;
impl
NativeSurfaceId
{
pub
const
DEBUG_OVERLAY
:
NativeSurfaceId
=
NativeSurfaceId
(
u64
:
:
MAX
)
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NativeTileId
{
pub
surface_id
:
NativeSurfaceId
pub
x
:
i32
pub
y
:
i32
}
impl
NativeTileId
{
pub
const
DEBUG_OVERLAY
:
NativeTileId
=
NativeTileId
{
surface_id
:
NativeSurfaceId
:
:
DEBUG_OVERLAY
x
:
0
y
:
0
}
;
}
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
)
]
pub
struct
NativeSurfaceInfo
{
pub
origin
:
DeviceIntPoint
pub
fbo_id
:
u32
}
#
[
repr
(
C
)
]
pub
struct
CompositorCapabilities
{
pub
virtual_surface_size
:
i32
}
pub
struct
CompositorSurfacePixel
;
pub
type
CompositorSurfaceTransform
=
Transform3D
<
f32
CompositorSurfacePixel
DevicePixel
>
;
pub
trait
Compositor
{
fn
create_surface
(
&
mut
self
id
:
NativeSurfaceId
virtual_offset
:
DeviceIntPoint
tile_size
:
DeviceIntSize
is_opaque
:
bool
)
;
fn
create_external_surface
(
&
mut
self
id
:
NativeSurfaceId
is_opaque
:
bool
)
;
fn
destroy_surface
(
&
mut
self
id
:
NativeSurfaceId
)
;
fn
create_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
destroy_tile
(
&
mut
self
id
:
NativeTileId
)
;
fn
attach_external_image
(
&
mut
self
id
:
NativeSurfaceId
external_image
:
ExternalImageId
)
;
fn
invalidate_tile
(
&
mut
self
_id
:
NativeTileId
)
{
}
fn
bind
(
&
mut
self
id
:
NativeTileId
dirty_rect
:
DeviceIntRect
valid_rect
:
DeviceIntRect
)
-
>
NativeSurfaceInfo
;
fn
unbind
(
&
mut
self
)
;
fn
begin_frame
(
&
mut
self
)
;
fn
add_surface
(
&
mut
self
id
:
NativeSurfaceId
transform
:
CompositorSurfaceTransform
clip_rect
:
DeviceIntRect
image_rendering
:
ImageRendering
)
;
fn
end_frame
(
&
mut
self
)
;
fn
enable_native_compositor
(
&
mut
self
enable
:
bool
)
;
fn
deinit
(
&
mut
self
)
;
fn
get_capabilities
(
&
self
)
-
>
CompositorCapabilities
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
Occluder
{
z_id
:
ZBufferId
device_rect
:
DeviceIntRect
}
#
[
derive
(
Debug
)
]
enum
OcclusionEventKind
{
Begin
End
}
#
[
derive
(
Debug
)
]
struct
OcclusionEvent
{
y
:
i32
x_range
:
ops
:
:
Range
<
i32
>
kind
:
OcclusionEventKind
}
impl
OcclusionEvent
{
fn
new
(
y
:
i32
kind
:
OcclusionEventKind
x0
:
i32
x1
:
i32
)
-
>
Self
{
OcclusionEvent
{
y
x_range
:
ops
:
:
Range
{
start
:
x0
end
:
x1
}
kind
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Occluders
{
occluders
:
Vec
<
Occluder
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
skip
)
)
]
events
:
Vec
<
OcclusionEvent
>
#
[
cfg_attr
(
feature
=
"
serde
"
serde
(
skip
)
)
]
active
:
Vec
<
ops
:
:
Range
<
i32
>
>
}
impl
Occluders
{
fn
new
(
)
-
>
Self
{
Occluders
{
occluders
:
Vec
:
:
new
(
)
events
:
Vec
:
:
new
(
)
active
:
Vec
:
:
new
(
)
}
}
fn
push
(
&
mut
self
device_rect
:
DeviceIntRect
z_id
:
ZBufferId
)
{
self
.
occluders
.
push
(
Occluder
{
device_rect
z_id
}
)
;
}
pub
fn
is_tile_occluded
(
&
mut
self
z_id
:
ZBufferId
device_rect
:
DeviceRect
)
-
>
bool
{
let
device_rect
=
device_rect
.
round
(
)
.
to_i32
(
)
;
let
ref_area
=
device_rect
.
size
.
width
*
device_rect
.
size
.
height
;
let
cover_area
=
self
.
area
(
z_id
&
device_rect
)
;
debug_assert
!
(
cover_area
<
=
ref_area
)
;
ref_area
=
=
cover_area
}
fn
area
(
&
mut
self
z_id
:
ZBufferId
clip_rect
:
&
DeviceIntRect
)
-
>
i32
{
self
.
events
.
clear
(
)
;
self
.
active
.
clear
(
)
;
let
mut
area
=
0
;
for
occluder
in
&
self
.
occluders
{
if
occluder
.
z_id
.
0
>
z_id
.
0
{
if
let
Some
(
rect
)
=
occluder
.
device_rect
.
intersection
(
clip_rect
)
{
let
x0
=
rect
.
origin
.
x
;
let
x1
=
x0
+
rect
.
size
.
width
;
self
.
events
.
push
(
OcclusionEvent
:
:
new
(
rect
.
origin
.
y
OcclusionEventKind
:
:
Begin
x0
x1
)
)
;
self
.
events
.
push
(
OcclusionEvent
:
:
new
(
rect
.
origin
.
y
+
rect
.
size
.
height
OcclusionEventKind
:
:
End
x0
x1
)
)
;
}
}
}
if
self
.
events
.
is_empty
(
)
{
return
0
;
}
self
.
events
.
sort_by_key
(
|
e
|
e
.
y
)
;
let
mut
cur_y
=
self
.
events
[
0
]
.
y
;
for
event
in
&
self
.
events
{
let
dy
=
event
.
y
-
cur_y
;
if
dy
!
=
0
&
&
!
self
.
active
.
is_empty
(
)
{
assert
!
(
dy
>
0
)
;
self
.
active
.
sort_by_key
(
|
i
|
i
.
start
)
;
let
mut
query
=
0
;
let
mut
cur
=
self
.
active
[
0
]
.
start
;
for
interval
in
&
self
.
active
{
cur
=
interval
.
start
.
max
(
cur
)
;
query
+
=
(
interval
.
end
-
cur
)
.
max
(
0
)
;
cur
=
cur
.
max
(
interval
.
end
)
;
}
area
+
=
query
*
dy
;
}
match
event
.
kind
{
OcclusionEventKind
:
:
Begin
=
>
{
self
.
active
.
push
(
event
.
x_range
.
clone
(
)
)
;
}
OcclusionEventKind
:
:
End
=
>
{
let
index
=
self
.
active
.
iter
(
)
.
position
(
|
i
|
*
i
=
=
event
.
x_range
)
.
unwrap
(
)
;
self
.
active
.
remove
(
index
)
;
}
}
cur_y
=
event
.
y
;
}
area
}
}
