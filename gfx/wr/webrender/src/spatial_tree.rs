use
api
:
:
{
ExternalScrollId
PropertyBinding
ReferenceFrameKind
TransformStyle
}
;
use
api
:
:
{
PipelineId
ScrollClamping
ScrollNodeState
ScrollSensitivity
SpatialTreeItemKey
}
;
use
api
:
:
units
:
:
*
;
use
euclid
:
:
Transform3D
;
use
crate
:
:
gpu_types
:
:
TransformPalette
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FastHashSet
}
;
use
crate
:
:
print_tree
:
:
{
PrintableTree
PrintTree
PrintTreePrinter
}
;
use
crate
:
:
scene
:
:
SceneProperties
;
use
crate
:
:
spatial_node
:
:
{
ScrollFrameInfo
SpatialNode
SpatialNodeType
StickyFrameInfo
}
;
use
crate
:
:
spatial_node
:
:
{
SpatialNodeUid
ScrollFrameKind
}
;
use
std
:
:
{
ops
u32
}
;
use
crate
:
:
util
:
:
{
FastTransform
LayoutToWorldFastTransform
MatrixHelpers
ScaleOffset
scale_factors
}
;
pub
type
ScrollStates
=
FastHashMap
<
ExternalScrollId
ScrollFrameInfo
>
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CoordinateSystemId
(
pub
u32
)
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
struct
StaticCoordinateSystemId
(
pub
u32
)
;
impl
StaticCoordinateSystemId
{
pub
const
ROOT
:
StaticCoordinateSystemId
=
StaticCoordinateSystemId
(
0
)
;
}
#
[
derive
(
Debug
)
]
pub
struct
CoordinateSystem
{
pub
transform
:
LayoutTransform
pub
world_transform
:
LayoutToWorldTransform
pub
should_flatten
:
bool
pub
parent
:
Option
<
CoordinateSystemId
>
}
impl
CoordinateSystem
{
fn
root
(
)
-
>
Self
{
CoordinateSystem
{
transform
:
LayoutTransform
:
:
identity
(
)
world_transform
:
LayoutToWorldTransform
:
:
identity
(
)
should_flatten
:
false
parent
:
None
}
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
MallocSizeOf
PartialEq
PartialOrd
Ord
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SpatialNodeIndex
(
pub
u32
)
;
impl
SpatialNodeIndex
{
pub
const
INVALID
:
SpatialNodeIndex
=
SpatialNodeIndex
(
u32
:
:
MAX
)
;
}
const
MIN_SCROLLABLE_AMOUNT
:
f32
=
0
.
01
;
const
MIN_SCROLL_ROOT_SIZE
:
f32
=
128
.
0
;
impl
SpatialNodeIndex
{
pub
fn
new
(
index
:
usize
)
-
>
Self
{
debug_assert
!
(
index
<
:
:
std
:
:
u32
:
:
MAX
as
usize
)
;
SpatialNodeIndex
(
index
as
u32
)
}
}
impl
CoordinateSystemId
{
pub
fn
root
(
)
-
>
Self
{
CoordinateSystemId
(
0
)
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
VisibleFace
{
Front
Back
}
impl
Default
for
VisibleFace
{
fn
default
(
)
-
>
Self
{
VisibleFace
:
:
Front
}
}
impl
ops
:
:
Not
for
VisibleFace
{
type
Output
=
Self
;
fn
not
(
self
)
-
>
Self
{
match
self
{
VisibleFace
:
:
Front
=
>
VisibleFace
:
:
Back
VisibleFace
:
:
Back
=
>
VisibleFace
:
:
Front
}
}
}
pub
struct
SpatialTree
{
pub
spatial_nodes
:
Vec
<
SpatialNode
>
coord_systems
:
Vec
<
CoordinateSystem
>
pub
pending_scroll_offsets
:
FastHashMap
<
ExternalScrollId
(
LayoutPoint
ScrollClamping
)
>
pub
pipelines_to_discard
:
FastHashSet
<
PipelineId
>
nodes_to_update
:
Vec
<
(
SpatialNodeIndex
TransformUpdateState
)
>
next_static_coord_system_id
:
u32
spatial_node_uids
:
FastHashSet
<
SpatialNodeUid
>
root_reference_frame_index
:
SpatialNodeIndex
}
#
[
derive
(
Clone
)
]
pub
struct
TransformUpdateState
{
pub
parent_reference_frame_transform
:
LayoutToWorldFastTransform
pub
parent_accumulated_scroll_offset
:
LayoutVector2D
pub
nearest_scrolling_ancestor_offset
:
LayoutVector2D
pub
nearest_scrolling_ancestor_viewport
:
LayoutRect
pub
current_coordinate_system_id
:
CoordinateSystemId
pub
coordinate_system_relative_scale_offset
:
ScaleOffset
pub
invertible
:
bool
pub
preserves_3d
:
bool
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
CoordinateSpaceMapping
<
Src
Dst
>
{
Local
ScaleOffset
(
ScaleOffset
)
Transform
(
Transform3D
<
f32
Src
Dst
>
)
}
impl
<
Src
Dst
>
CoordinateSpaceMapping
<
Src
Dst
>
{
pub
fn
into_transform
(
self
)
-
>
Transform3D
<
f32
Src
Dst
>
{
match
self
{
CoordinateSpaceMapping
:
:
Local
=
>
Transform3D
:
:
identity
(
)
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
=
>
scale_offset
.
to_transform
(
)
CoordinateSpaceMapping
:
:
Transform
(
transform
)
=
>
transform
}
}
pub
fn
into_fast_transform
(
self
)
-
>
FastTransform
<
Src
Dst
>
{
match
self
{
CoordinateSpaceMapping
:
:
Local
=
>
FastTransform
:
:
identity
(
)
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
=
>
FastTransform
:
:
with_scale_offset
(
scale_offset
)
CoordinateSpaceMapping
:
:
Transform
(
transform
)
=
>
FastTransform
:
:
with_transform
(
transform
)
}
}
pub
fn
is_perspective
(
&
self
)
-
>
bool
{
match
*
self
{
CoordinateSpaceMapping
:
:
Local
|
CoordinateSpaceMapping
:
:
ScaleOffset
(
_
)
=
>
false
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
transform
.
has_perspective_component
(
)
}
}
pub
fn
is_2d_axis_aligned
(
&
self
)
-
>
bool
{
match
*
self
{
CoordinateSpaceMapping
:
:
Local
|
CoordinateSpaceMapping
:
:
ScaleOffset
(
_
)
=
>
true
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
transform
.
preserves_2d_axis_alignment
(
)
}
}
pub
fn
scale_factors
(
&
self
)
-
>
(
f32
f32
)
{
match
*
self
{
CoordinateSpaceMapping
:
:
Local
=
>
(
1
.
0
1
.
0
)
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
(
scale_offset
.
scale
.
x
.
abs
(
)
scale_offset
.
scale
.
y
.
abs
(
)
)
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
scale_factors
(
transform
)
}
}
pub
fn
inverse
(
&
self
)
-
>
Option
<
CoordinateSpaceMapping
<
Dst
Src
>
>
{
match
*
self
{
CoordinateSpaceMapping
:
:
Local
=
>
Some
(
CoordinateSpaceMapping
:
:
Local
)
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
Some
(
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
.
inverse
(
)
)
)
}
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
{
transform
.
inverse
(
)
.
map
(
CoordinateSpaceMapping
:
:
Transform
)
}
}
}
}
enum
TransformScroll
{
Scrolled
Unscrolled
}
impl
SpatialTree
{
pub
fn
new
(
)
-
>
Self
{
let
node
=
SpatialNode
:
:
new_reference_frame
(
None
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
should_snap
:
true
is_2d_scale_translation
:
true
}
LayoutVector2D
:
:
zero
(
)
PipelineId
:
:
dummy
(
)
StaticCoordinateSystemId
:
:
ROOT
)
;
let
mut
tree
=
SpatialTree
{
spatial_nodes
:
Vec
:
:
new
(
)
coord_systems
:
Vec
:
:
new
(
)
pending_scroll_offsets
:
FastHashMap
:
:
default
(
)
pipelines_to_discard
:
FastHashSet
:
:
default
(
)
nodes_to_update
:
Vec
:
:
new
(
)
next_static_coord_system_id
:
1
spatial_node_uids
:
FastHashSet
:
:
default
(
)
root_reference_frame_index
:
SpatialNodeIndex
(
0
)
}
;
tree
.
add_spatial_node
(
node
SpatialNodeUid
:
:
root
(
)
)
;
tree
}
pub
fn
external_scroll_offset
(
&
self
node_index
:
SpatialNodeIndex
)
-
>
LayoutVector2D
{
let
mut
offset
=
LayoutVector2D
:
:
zero
(
)
;
let
mut
current_node
=
Some
(
node_index
)
;
while
let
Some
(
node_index
)
=
current_node
{
let
node
=
&
self
.
spatial_nodes
[
node_index
.
0
as
usize
]
;
match
node
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
ref
scrolling
)
=
>
{
offset
+
=
scrolling
.
external_scroll_offset
;
}
SpatialNodeType
:
:
StickyFrame
(
.
.
)
=
>
{
}
SpatialNodeType
:
:
ReferenceFrame
(
.
.
)
=
>
{
break
;
}
}
current_node
=
node
.
parent
;
}
offset
}
pub
fn
get_relative_transform
(
&
self
child_index
:
SpatialNodeIndex
parent_index
:
SpatialNodeIndex
)
-
>
CoordinateSpaceMapping
<
LayoutPixel
LayoutPixel
>
{
self
.
get_relative_transform_with_face
(
child_index
parent_index
None
)
}
pub
fn
get_relative_transform_with_face
(
&
self
child_index
:
SpatialNodeIndex
parent_index
:
SpatialNodeIndex
mut
visible_face
:
Option
<
&
mut
VisibleFace
>
)
-
>
CoordinateSpaceMapping
<
LayoutPixel
LayoutPixel
>
{
if
child_index
=
=
parent_index
{
return
CoordinateSpaceMapping
:
:
Local
;
}
let
child
=
&
self
.
spatial_nodes
[
child_index
.
0
as
usize
]
;
let
parent
=
&
self
.
spatial_nodes
[
parent_index
.
0
as
usize
]
;
if
child
.
coordinate_system_id
=
=
parent
.
coordinate_system_id
{
let
scale_offset
=
parent
.
content_transform
.
inverse
(
)
.
accumulate
(
&
child
.
content_transform
)
;
return
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
;
}
if
child_index
.
0
<
parent_index
.
0
{
warn
!
(
"
Unexpected
transform
queried
from
{
:
?
}
to
{
:
?
}
please
call
the
graphics
team
!
"
child_index
parent_index
)
;
let
child_cs
=
&
self
.
coord_systems
[
child
.
coordinate_system_id
.
0
as
usize
]
;
let
child_transform
=
child
.
content_transform
.
to_transform
:
:
<
LayoutPixel
LayoutPixel
>
(
)
.
then
(
&
child_cs
.
world_transform
)
;
let
parent_cs
=
&
self
.
coord_systems
[
parent
.
coordinate_system_id
.
0
as
usize
]
;
let
parent_transform
=
parent
.
content_transform
.
to_transform
(
)
.
then
(
&
parent_cs
.
world_transform
)
;
let
result
=
parent_transform
.
inverse
(
)
.
unwrap_or_default
(
)
.
then
(
&
child_transform
)
.
with_source
:
:
<
LayoutPixel
>
(
)
.
with_destination
:
:
<
LayoutPixel
>
(
)
;
if
let
Some
(
face
)
=
visible_face
{
if
result
.
is_backface_visible
(
)
{
*
face
=
VisibleFace
:
:
Back
;
}
}
return
CoordinateSpaceMapping
:
:
Transform
(
result
)
;
}
let
mut
coordinate_system_id
=
child
.
coordinate_system_id
;
let
mut
transform
=
child
.
content_transform
.
to_transform
(
)
;
while
coordinate_system_id
!
=
parent
.
coordinate_system_id
{
let
coord_system
=
&
self
.
coord_systems
[
coordinate_system_id
.
0
as
usize
]
;
if
coord_system
.
should_flatten
{
if
let
Some
(
ref
mut
face
)
=
visible_face
{
if
transform
.
is_backface_visible
(
)
{
*
*
face
=
VisibleFace
:
:
Back
;
}
}
transform
.
flatten_z_output
(
)
;
}
coordinate_system_id
=
coord_system
.
parent
.
expect
(
"
invalid
parent
!
"
)
;
transform
=
transform
.
then
(
&
coord_system
.
transform
)
;
}
transform
=
transform
.
then
(
&
parent
.
content_transform
.
inverse
(
)
.
to_transform
(
)
)
;
if
let
Some
(
face
)
=
visible_face
{
if
transform
.
is_backface_visible
(
)
{
*
face
=
VisibleFace
:
:
Back
;
}
}
CoordinateSpaceMapping
:
:
Transform
(
transform
)
}
pub
fn
is_relative_transform_complex
(
&
self
child_index
:
SpatialNodeIndex
parent_index
:
SpatialNodeIndex
)
-
>
bool
{
if
child_index
=
=
parent_index
{
return
false
;
}
let
child
=
&
self
.
spatial_nodes
[
child_index
.
0
as
usize
]
;
let
parent
=
&
self
.
spatial_nodes
[
parent_index
.
0
as
usize
]
;
child
.
coordinate_system_id
!
=
parent
.
coordinate_system_id
}
fn
get_world_transform_impl
(
&
self
index
:
SpatialNodeIndex
scroll
:
TransformScroll
)
-
>
CoordinateSpaceMapping
<
LayoutPixel
WorldPixel
>
{
let
child
=
&
self
.
spatial_nodes
[
index
.
0
as
usize
]
;
if
child
.
coordinate_system_id
.
0
=
=
0
{
if
index
=
=
self
.
root_reference_frame_index
{
CoordinateSpaceMapping
:
:
Local
}
else
{
CoordinateSpaceMapping
:
:
ScaleOffset
(
child
.
content_transform
)
}
}
else
{
let
system
=
&
self
.
coord_systems
[
child
.
coordinate_system_id
.
0
as
usize
]
;
let
scale_offset
=
match
scroll
{
TransformScroll
:
:
Scrolled
=
>
&
child
.
content_transform
TransformScroll
:
:
Unscrolled
=
>
&
child
.
viewport_transform
}
;
let
transform
=
scale_offset
.
to_transform
(
)
.
then
(
&
system
.
world_transform
)
;
CoordinateSpaceMapping
:
:
Transform
(
transform
)
}
}
pub
fn
get_world_transform
(
&
self
index
:
SpatialNodeIndex
)
-
>
CoordinateSpaceMapping
<
LayoutPixel
WorldPixel
>
{
self
.
get_world_transform_impl
(
index
TransformScroll
:
:
Scrolled
)
}
pub
fn
get_world_viewport_transform
(
&
self
index
:
SpatialNodeIndex
)
-
>
CoordinateSpaceMapping
<
LayoutPixel
WorldPixel
>
{
self
.
get_world_transform_impl
(
index
TransformScroll
:
:
Unscrolled
)
}
pub
fn
root_reference_frame_index
(
&
self
)
-
>
SpatialNodeIndex
{
self
.
root_reference_frame_index
}
pub
fn
get_scroll_node_state
(
&
self
)
-
>
Vec
<
ScrollNodeState
>
{
let
mut
result
=
vec
!
[
]
;
for
node
in
&
self
.
spatial_nodes
{
if
let
SpatialNodeType
:
:
ScrollFrame
(
info
)
=
node
.
node_type
{
result
.
push
(
ScrollNodeState
{
id
:
info
.
external_id
scroll_offset
:
info
.
offset
-
info
.
external_scroll_offset
}
)
}
}
result
}
pub
fn
drain
(
&
mut
self
)
-
>
ScrollStates
{
let
mut
scroll_states
=
FastHashMap
:
:
default
(
)
;
for
old_node
in
&
mut
self
.
spatial_nodes
.
drain
(
.
.
)
{
if
self
.
pipelines_to_discard
.
contains
(
&
old_node
.
pipeline_id
)
{
continue
;
}
match
old_node
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
info
)
=
>
{
scroll_states
.
insert
(
info
.
external_id
info
)
;
}
_
=
>
{
}
}
}
self
.
coord_systems
.
clear
(
)
;
self
.
pipelines_to_discard
.
clear
(
)
;
scroll_states
}
pub
fn
scroll_node
(
&
mut
self
origin
:
LayoutPoint
id
:
ExternalScrollId
clamp
:
ScrollClamping
)
-
>
bool
{
for
node
in
&
mut
self
.
spatial_nodes
{
if
node
.
matches_external_id
(
id
)
{
return
node
.
set_scroll_origin
(
&
origin
clamp
)
;
}
}
self
.
pending_scroll_offsets
.
insert
(
id
(
origin
clamp
)
)
;
false
}
pub
fn
update_tree
(
&
mut
self
scene_properties
:
&
SceneProperties
)
{
if
self
.
spatial_nodes
.
is_empty
(
)
{
return
;
}
profile_scope
!
(
"
update_tree
"
)
;
self
.
coord_systems
.
clear
(
)
;
self
.
coord_systems
.
push
(
CoordinateSystem
:
:
root
(
)
)
;
let
root_node_index
=
self
.
root_reference_frame_index
(
)
;
let
state
=
TransformUpdateState
{
parent_reference_frame_transform
:
LayoutVector2D
:
:
zero
(
)
.
into
(
)
parent_accumulated_scroll_offset
:
LayoutVector2D
:
:
zero
(
)
nearest_scrolling_ancestor_offset
:
LayoutVector2D
:
:
zero
(
)
nearest_scrolling_ancestor_viewport
:
LayoutRect
:
:
zero
(
)
current_coordinate_system_id
:
CoordinateSystemId
:
:
root
(
)
coordinate_system_relative_scale_offset
:
ScaleOffset
:
:
identity
(
)
invertible
:
true
preserves_3d
:
false
}
;
debug_assert
!
(
self
.
nodes_to_update
.
is_empty
(
)
)
;
self
.
nodes_to_update
.
push
(
(
root_node_index
state
)
)
;
while
let
Some
(
(
node_index
mut
state
)
)
=
self
.
nodes_to_update
.
pop
(
)
{
let
(
previous
following
)
=
self
.
spatial_nodes
.
split_at_mut
(
node_index
.
0
as
usize
)
;
let
node
=
match
following
.
get_mut
(
0
)
{
Some
(
node
)
=
>
node
None
=
>
continue
}
;
node
.
update
(
&
mut
state
&
mut
self
.
coord_systems
scene_properties
&
*
previous
)
;
if
!
node
.
children
.
is_empty
(
)
{
node
.
prepare_state_for_children
(
&
mut
state
)
;
self
.
nodes_to_update
.
extend
(
node
.
children
.
iter
(
)
.
rev
(
)
.
map
(
|
child_index
|
(
*
child_index
state
.
clone
(
)
)
)
)
;
}
}
}
pub
fn
build_transform_palette
(
&
self
)
-
>
TransformPalette
{
profile_scope
!
(
"
build_transform_palette
"
)
;
let
mut
palette
=
TransformPalette
:
:
new
(
self
.
spatial_nodes
.
len
(
)
self
.
root_reference_frame_index
(
)
)
;
for
i
in
0
.
.
self
.
spatial_nodes
.
len
(
)
{
let
index
=
SpatialNodeIndex
(
i
as
u32
)
;
let
world_transform
=
self
.
get_world_transform
(
index
)
.
into_transform
(
)
;
palette
.
set_world_transform
(
index
world_transform
)
;
}
palette
}
pub
fn
finalize_and_apply_pending_scroll_offsets
(
&
mut
self
old_states
:
ScrollStates
)
{
for
node
in
&
mut
self
.
spatial_nodes
{
let
external_id
=
match
node
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
ScrollFrameInfo
{
external_id
.
.
}
)
=
>
external_id
_
=
>
continue
}
;
if
let
Some
(
scrolling_state
)
=
old_states
.
get
(
&
external_id
)
{
node
.
apply_old_scrolling_state
(
scrolling_state
)
;
}
if
let
Some
(
(
offset
clamping
)
)
=
self
.
pending_scroll_offsets
.
remove
(
&
external_id
)
{
node
.
set_scroll_origin
(
&
offset
clamping
)
;
}
}
}
pub
fn
get_static_coordinate_system_id
(
&
self
node_index
:
SpatialNodeIndex
)
-
>
StaticCoordinateSystemId
{
self
.
spatial_nodes
[
node_index
.
0
as
usize
]
.
static_coordinate_system_id
}
pub
fn
add_scroll_frame
(
&
mut
self
parent_index
:
SpatialNodeIndex
external_id
:
ExternalScrollId
pipeline_id
:
PipelineId
frame_rect
:
&
LayoutRect
content_size
:
&
LayoutSize
scroll_sensitivity
:
ScrollSensitivity
frame_kind
:
ScrollFrameKind
external_scroll_offset
:
LayoutVector2D
uid
:
SpatialNodeUid
)
-
>
SpatialNodeIndex
{
let
static_coordinate_system_id
=
self
.
get_static_coordinate_system_id
(
parent_index
)
;
let
node
=
SpatialNode
:
:
new_scroll_frame
(
pipeline_id
parent_index
external_id
frame_rect
content_size
scroll_sensitivity
frame_kind
external_scroll_offset
static_coordinate_system_id
)
;
self
.
add_spatial_node
(
node
uid
)
}
pub
fn
add_reference_frame
(
&
mut
self
parent_index
:
SpatialNodeIndex
transform_style
:
TransformStyle
source_transform
:
PropertyBinding
<
LayoutTransform
>
kind
:
ReferenceFrameKind
origin_in_parent_reference_frame
:
LayoutVector2D
pipeline_id
:
PipelineId
uid
:
SpatialNodeUid
)
-
>
SpatialNodeIndex
{
let
new_static_coord_system
=
match
kind
{
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
.
.
}
=
>
{
false
}
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
false
.
.
}
|
ReferenceFrameKind
:
:
Perspective
{
.
.
}
=
>
{
match
source_transform
{
PropertyBinding
:
:
Value
(
m
)
=
>
{
!
m
.
is_2d_scale_translation
(
)
}
PropertyBinding
:
:
Binding
(
.
.
)
=
>
{
true
}
}
}
}
;
let
static_coordinate_system_id
=
if
new_static_coord_system
{
let
id
=
StaticCoordinateSystemId
(
self
.
next_static_coord_system_id
)
;
self
.
next_static_coord_system_id
+
=
1
;
id
}
else
{
self
.
get_static_coordinate_system_id
(
parent_index
)
}
;
let
node
=
SpatialNode
:
:
new_reference_frame
(
Some
(
parent_index
)
transform_style
source_transform
kind
origin_in_parent_reference_frame
pipeline_id
static_coordinate_system_id
)
;
self
.
add_spatial_node
(
node
uid
)
}
pub
fn
add_sticky_frame
(
&
mut
self
parent_index
:
SpatialNodeIndex
sticky_frame_info
:
StickyFrameInfo
pipeline_id
:
PipelineId
key
:
SpatialTreeItemKey
)
-
>
SpatialNodeIndex
{
let
static_coordinate_system_id
=
self
.
get_static_coordinate_system_id
(
parent_index
)
;
let
uid
=
SpatialNodeUid
:
:
external
(
key
)
;
let
node
=
SpatialNode
:
:
new_sticky_frame
(
parent_index
sticky_frame_info
pipeline_id
static_coordinate_system_id
)
;
self
.
add_spatial_node
(
node
uid
)
}
pub
fn
add_spatial_node
(
&
mut
self
mut
node
:
SpatialNode
uid
:
SpatialNodeUid
)
-
>
SpatialNodeIndex
{
let
index
=
SpatialNodeIndex
:
:
new
(
self
.
spatial_nodes
.
len
(
)
)
;
debug_assert
!
(
self
.
spatial_node_uids
.
insert
(
uid
)
)
;
if
let
Some
(
parent_index
)
=
node
.
parent
{
let
parent_node
=
&
mut
self
.
spatial_nodes
[
parent_index
.
0
as
usize
]
;
parent_node
.
add_child
(
index
)
;
node
.
update_snapping
(
Some
(
parent_node
)
)
;
}
else
{
node
.
update_snapping
(
None
)
;
}
self
.
spatial_nodes
.
push
(
node
)
;
index
}
pub
fn
discard_frame_state_for_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
pipelines_to_discard
.
insert
(
pipeline_id
)
;
}
pub
fn
is_ancestor
(
&
self
maybe_parent
:
SpatialNodeIndex
maybe_child
:
SpatialNodeIndex
)
-
>
bool
{
if
maybe_parent
=
=
maybe_child
{
return
false
;
}
let
mut
current_node
=
maybe_child
;
while
current_node
!
=
self
.
root_reference_frame_index
{
let
node
=
&
self
.
spatial_nodes
[
current_node
.
0
as
usize
]
;
current_node
=
node
.
parent
.
expect
(
"
bug
:
no
parent
"
)
;
if
current_node
=
=
maybe_parent
{
return
true
;
}
}
false
}
pub
fn
find_scroll_root
(
&
self
spatial_node_index
:
SpatialNodeIndex
)
-
>
SpatialNodeIndex
{
let
mut
real_scroll_root
=
self
.
root_reference_frame_index
;
let
mut
outermost_scroll_root
=
self
.
root_reference_frame_index
;
let
mut
node_index
=
spatial_node_index
;
while
node_index
!
=
self
.
root_reference_frame_index
{
let
node
=
&
self
.
spatial_nodes
[
node_index
.
0
as
usize
]
;
match
node
.
node_type
{
SpatialNodeType
:
:
ReferenceFrame
(
ref
info
)
=
>
{
match
info
.
kind
{
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
.
.
}
=
>
{
}
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
false
.
.
}
|
ReferenceFrameKind
:
:
Perspective
{
.
.
}
=
>
{
real_scroll_root
=
self
.
root_reference_frame_index
;
outermost_scroll_root
=
self
.
root_reference_frame_index
;
}
}
}
SpatialNodeType
:
:
StickyFrame
(
.
.
)
=
>
{
}
SpatialNodeType
:
:
ScrollFrame
(
ref
info
)
=
>
{
match
info
.
frame_kind
{
ScrollFrameKind
:
:
PipelineRoot
{
is_root_pipeline
}
=
>
{
if
is_root_pipeline
{
break
;
}
}
ScrollFrameKind
:
:
Explicit
=
>
{
outermost_scroll_root
=
node_index
;
if
info
.
scrollable_size
.
width
>
MIN_SCROLLABLE_AMOUNT
|
|
info
.
scrollable_size
.
height
>
MIN_SCROLLABLE_AMOUNT
{
if
info
.
viewport_rect
.
width
(
)
>
MIN_SCROLL_ROOT_SIZE
&
&
info
.
viewport_rect
.
height
(
)
>
MIN_SCROLL_ROOT_SIZE
{
real_scroll_root
=
node_index
;
}
}
}
}
}
}
node_index
=
node
.
parent
.
expect
(
"
unable
to
find
parent
node
"
)
;
}
if
real_scroll_root
=
=
self
.
root_reference_frame_index
{
outermost_scroll_root
}
else
{
real_scroll_root
}
}
fn
print_node
<
T
:
PrintTreePrinter
>
(
&
self
index
:
SpatialNodeIndex
pt
:
&
mut
T
)
{
let
node
=
&
self
.
spatial_nodes
[
index
.
0
as
usize
]
;
match
node
.
node_type
{
SpatialNodeType
:
:
StickyFrame
(
ref
sticky_frame_info
)
=
>
{
pt
.
new_level
(
format
!
(
"
StickyFrame
"
)
)
;
pt
.
add_item
(
format
!
(
"
sticky
info
:
{
:
?
}
"
sticky_frame_info
)
)
;
}
SpatialNodeType
:
:
ScrollFrame
(
scrolling_info
)
=
>
{
pt
.
new_level
(
format
!
(
"
ScrollFrame
"
)
)
;
pt
.
add_item
(
format
!
(
"
viewport
:
{
:
?
}
"
scrolling_info
.
viewport_rect
)
)
;
pt
.
add_item
(
format
!
(
"
scrollable_size
:
{
:
?
}
"
scrolling_info
.
scrollable_size
)
)
;
pt
.
add_item
(
format
!
(
"
scroll
offset
:
{
:
?
}
"
scrolling_info
.
offset
)
)
;
pt
.
add_item
(
format
!
(
"
external_scroll_offset
:
{
:
?
}
"
scrolling_info
.
external_scroll_offset
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
scrolling_info
.
frame_kind
)
)
;
}
SpatialNodeType
:
:
ReferenceFrame
(
ref
info
)
=
>
{
pt
.
new_level
(
format
!
(
"
ReferenceFrame
"
)
)
;
pt
.
add_item
(
format
!
(
"
kind
:
{
:
?
}
"
info
.
kind
)
)
;
pt
.
add_item
(
format
!
(
"
transform_style
:
{
:
?
}
"
info
.
transform_style
)
)
;
pt
.
add_item
(
format
!
(
"
source_transform
:
{
:
?
}
"
info
.
source_transform
)
)
;
pt
.
add_item
(
format
!
(
"
origin_in_parent_reference_frame
:
{
:
?
}
"
info
.
origin_in_parent_reference_frame
)
)
;
}
}
pt
.
add_item
(
format
!
(
"
index
:
{
:
?
}
"
index
)
)
;
pt
.
add_item
(
format
!
(
"
content_transform
:
{
:
?
}
"
node
.
content_transform
)
)
;
pt
.
add_item
(
format
!
(
"
viewport_transform
:
{
:
?
}
"
node
.
viewport_transform
)
)
;
pt
.
add_item
(
format
!
(
"
snapping_transform
:
{
:
?
}
"
node
.
snapping_transform
)
)
;
pt
.
add_item
(
format
!
(
"
coordinate_system_id
:
{
:
?
}
"
node
.
coordinate_system_id
)
)
;
pt
.
add_item
(
format
!
(
"
static_coordinate_system_id
:
{
:
?
}
"
node
.
static_coordinate_system_id
)
)
;
for
child_index
in
&
node
.
children
{
self
.
print_node
(
*
child_index
pt
)
;
}
pt
.
end_level
(
)
;
}
pub
fn
get_local_visible_face
(
&
self
node_index
:
SpatialNodeIndex
)
-
>
VisibleFace
{
let
node
=
&
self
.
spatial_nodes
[
node_index
.
0
as
usize
]
;
let
mut
face
=
VisibleFace
:
:
Front
;
if
let
Some
(
parent_index
)
=
node
.
parent
{
self
.
get_relative_transform_with_face
(
node_index
parent_index
Some
(
&
mut
face
)
)
;
}
face
}
#
[
allow
(
dead_code
)
]
pub
fn
print
(
&
self
)
{
if
!
self
.
spatial_nodes
.
is_empty
(
)
{
let
mut
buf
=
Vec
:
:
<
u8
>
:
:
new
(
)
;
{
let
mut
pt
=
PrintTree
:
:
new_with_sink
(
"
spatial
tree
"
&
mut
buf
)
;
self
.
print_with
(
&
mut
pt
)
;
}
println
!
(
"
{
}
"
std
:
:
str
:
:
from_utf8
(
&
buf
)
.
unwrap_or
(
"
(
Tree
printer
emitted
non
-
utf8
)
"
)
)
;
}
}
}
impl
PrintableTree
for
SpatialTree
{
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
)
{
if
!
self
.
spatial_nodes
.
is_empty
(
)
{
self
.
print_node
(
self
.
root_reference_frame_index
(
)
pt
)
;
}
}
}
#
[
cfg
(
test
)
]
fn
add_reference_frame
(
cst
:
&
mut
SpatialTree
parent
:
SpatialNodeIndex
transform
:
LayoutTransform
origin_in_parent_reference_frame
:
LayoutVector2D
key
:
SpatialTreeItemKey
)
-
>
SpatialNodeIndex
{
cst
.
add_reference_frame
(
parent
TransformStyle
:
:
Preserve3D
PropertyBinding
:
:
Value
(
transform
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
false
should_snap
:
false
}
origin_in_parent_reference_frame
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
key
)
)
}
#
[
cfg
(
test
)
]
fn
test_pt
(
px
:
f32
py
:
f32
cst
:
&
SpatialTree
child
:
SpatialNodeIndex
parent
:
SpatialNodeIndex
expected_x
:
f32
expected_y
:
f32
)
{
use
euclid
:
:
approxeq
:
:
ApproxEq
;
const
EPSILON
:
f32
=
0
.
0001
;
let
p
=
LayoutPoint
:
:
new
(
px
py
)
;
let
m
=
cst
.
get_relative_transform
(
child
parent
)
.
into_transform
(
)
;
let
pt
=
m
.
transform_point2d
(
p
)
.
unwrap
(
)
;
assert
!
(
pt
.
x
.
approx_eq_eps
(
&
expected_x
&
EPSILON
)
&
&
pt
.
y
.
approx_eq_eps
(
&
expected_y
&
EPSILON
)
"
p
:
{
:
?
}
-
>
{
:
?
}
\
nm
=
{
:
?
}
"
p
pt
m
)
;
}
#
[
test
]
fn
test_cst_simple_translation
(
)
{
let
mut
cst
=
SpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
cst
.
root_reference_frame_index
(
)
;
let
root
=
add_reference_frame
(
&
mut
cst
root_reference_frame_index
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
0
)
)
;
let
child1
=
add_reference_frame
(
&
mut
cst
root
LayoutTransform
:
:
translation
(
100
.
0
0
.
0
0
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
1
)
)
;
let
child2
=
add_reference_frame
(
&
mut
cst
child1
LayoutTransform
:
:
translation
(
0
.
0
50
.
0
0
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
2
)
)
;
let
child3
=
add_reference_frame
(
&
mut
cst
child2
LayoutTransform
:
:
translation
(
200
.
0
200
.
0
0
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
3
)
)
;
cst
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child1
root
200
.
0
100
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
root
200
.
0
150
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
child1
100
.
0
150
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child3
root
400
.
0
350
.
0
)
;
}
#
[
test
]
fn
test_cst_simple_scale
(
)
{
let
mut
cst
=
SpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
cst
.
root_reference_frame_index
(
)
;
let
root
=
add_reference_frame
(
&
mut
cst
root_reference_frame_index
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
0
)
)
;
let
child1
=
add_reference_frame
(
&
mut
cst
root
LayoutTransform
:
:
scale
(
4
.
0
1
.
0
1
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
1
)
)
;
let
child2
=
add_reference_frame
(
&
mut
cst
child1
LayoutTransform
:
:
scale
(
1
.
0
2
.
0
1
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
2
)
)
;
let
child3
=
add_reference_frame
(
&
mut
cst
child2
LayoutTransform
:
:
scale
(
2
.
0
2
.
0
1
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
3
)
)
;
cst
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child1
root
400
.
0
100
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
root
400
.
0
200
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child3
root
800
.
0
400
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
child1
100
.
0
200
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child3
child1
200
.
0
400
.
0
)
;
}
#
[
test
]
fn
test_cst_scale_translation
(
)
{
let
mut
cst
=
SpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
cst
.
root_reference_frame_index
(
)
;
let
root
=
add_reference_frame
(
&
mut
cst
root_reference_frame_index
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
0
)
)
;
let
child1
=
add_reference_frame
(
&
mut
cst
root
LayoutTransform
:
:
translation
(
100
.
0
50
.
0
0
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
1
)
)
;
let
child2
=
add_reference_frame
(
&
mut
cst
child1
LayoutTransform
:
:
scale
(
2
.
0
4
.
0
1
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
2
)
)
;
let
child3
=
add_reference_frame
(
&
mut
cst
child2
LayoutTransform
:
:
translation
(
200
.
0
-
100
.
0
0
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
3
)
)
;
let
child4
=
add_reference_frame
(
&
mut
cst
child3
LayoutTransform
:
:
scale
(
3
.
0
2
.
0
1
.
0
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
4
)
)
;
cst
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child1
root
200
.
0
150
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
root
300
.
0
450
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child4
root
1100
.
0
450
.
0
)
;
test_pt
(
0
.
0
0
.
0
&
cst
child4
child1
400
.
0
-
400
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child4
child1
1000
.
0
400
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child2
child1
200
.
0
400
.
0
)
;
test_pt
(
100
.
0
100
.
0
&
cst
child3
child1
600
.
0
0
.
0
)
;
}
#
[
test
]
fn
test_cst_translation_rotate
(
)
{
use
euclid
:
:
Angle
;
let
mut
cst
=
SpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
cst
.
root_reference_frame_index
(
)
;
let
root
=
add_reference_frame
(
&
mut
cst
root_reference_frame_index
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
0
)
)
;
let
child1
=
add_reference_frame
(
&
mut
cst
root
LayoutTransform
:
:
rotation
(
0
.
0
0
.
0
1
.
0
Angle
:
:
degrees
(
-
90
.
0
)
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
1
)
)
;
cst
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
test_pt
(
100
.
0
0
.
0
&
cst
child1
root
0
.
0
-
100
.
0
)
;
}
#
[
test
]
fn
test_is_ancestor1
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
st
.
root_reference_frame_index
(
)
;
let
root
=
add_reference_frame
(
&
mut
st
root_reference_frame_index
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
0
)
)
;
let
child1_0
=
add_reference_frame
(
&
mut
st
root
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
1
)
)
;
let
child1_1
=
add_reference_frame
(
&
mut
st
child1_0
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
2
)
)
;
let
child2
=
add_reference_frame
(
&
mut
st
root
LayoutTransform
:
:
identity
(
)
LayoutVector2D
:
:
zero
(
)
SpatialTreeItemKey
:
:
new
(
0
3
)
)
;
st
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
assert
!
(
!
st
.
is_ancestor
(
root
root
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_0
child1_0
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_1
child1_1
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child2
child2
)
)
;
assert
!
(
st
.
is_ancestor
(
root
child1_0
)
)
;
assert
!
(
st
.
is_ancestor
(
root
child1_1
)
)
;
assert
!
(
st
.
is_ancestor
(
child1_0
child1_1
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_0
root
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_1
root
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_1
child1_0
)
)
;
assert
!
(
st
.
is_ancestor
(
root
child2
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child2
root
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_0
child2
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child1_1
child2
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child2
child1_0
)
)
;
assert
!
(
!
st
.
is_ancestor
(
child2
child1_1
)
)
;
}
#
[
test
]
fn
test_find_scroll_root_simple
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
scroll
)
scroll
)
;
}
#
[
test
]
fn
test_find_scroll_root_sub_scroll_frame
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
root_scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
let
sub_scroll
=
st
.
add_scroll_frame
(
root_scroll
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
2
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
sub_scroll
)
root_scroll
)
;
}
#
[
test
]
fn
test_find_scroll_root_not_scrollable
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
root_scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
let
sub_scroll
=
st
.
add_scroll_frame
(
root_scroll
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
2
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
sub_scroll
)
sub_scroll
)
;
}
#
[
test
]
fn
test_find_scroll_root_too_small
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
root_scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
MIN_SCROLL_ROOT_SIZE
MIN_SCROLL_ROOT_SIZE
)
)
&
LayoutSize
:
:
new
(
1000
.
0
1000
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
let
sub_scroll
=
st
.
add_scroll_frame
(
root_scroll
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
2
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
sub_scroll
)
sub_scroll
)
;
}
#
[
test
]
fn
test_find_scroll_root_perspective
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
root_scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
let
perspective
=
st
.
add_reference_frame
(
root_scroll
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Perspective
{
scrolling_relative_to
:
None
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
2
)
)
)
;
let
sub_scroll
=
st
.
add_scroll_frame
(
perspective
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
3
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
sub_scroll
)
root_scroll
)
;
}
#
[
test
]
fn
test_find_scroll_root_2d_scale
(
)
{
let
mut
st
=
SpatialTree
:
:
new
(
)
;
let
root
=
st
.
add_reference_frame
(
st
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
)
)
;
let
root_scroll
=
st
.
add_scroll_frame
(
root
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
)
)
;
let
scale
=
st
.
add_reference_frame
(
root_scroll
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
false
}
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
PipelineId
:
:
dummy
(
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
2
)
)
)
;
let
sub_scroll
=
st
.
add_scroll_frame
(
scale
ExternalScrollId
(
1
PipelineId
:
:
dummy
(
)
)
PipelineId
:
:
dummy
(
)
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
400
.
0
400
.
0
)
)
&
LayoutSize
:
:
new
(
800
.
0
400
.
0
)
ScrollSensitivity
:
:
ScriptAndInputEvents
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
3
)
)
)
;
assert_eq
!
(
st
.
find_scroll_root
(
sub_scroll
)
sub_scroll
)
;
}
