use
api
:
:
{
MixBlendMode
PremultipliedColorF
FilterPrimitiveKind
}
;
use
api
:
:
{
PropertyBinding
PropertyBindingId
FilterPrimitive
RasterSpace
}
;
use
api
:
:
{
DebugFlags
ImageKey
ColorF
ColorU
PrimitiveFlags
}
;
use
api
:
:
{
ImageRendering
ColorDepth
YuvRangedColorSpace
YuvFormat
AlphaType
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
box_shadow
:
:
BLUR_SAMPLE_SCALE
;
use
crate
:
:
clip
:
:
{
ClipStore
ClipChainInstance
ClipLeafId
ClipNodeId
ClipTreeBuilder
}
;
use
crate
:
:
spatial_tree
:
:
{
SpatialTree
CoordinateSpaceMapping
SpatialNodeIndex
VisibleFace
}
;
use
crate
:
:
composite
:
:
{
CompositorKind
CompositeState
NativeSurfaceId
NativeTileId
CompositeTileSurface
tile_kind
}
;
use
crate
:
:
composite
:
:
{
ExternalSurfaceDescriptor
ExternalSurfaceDependency
CompositeTileDescriptor
CompositeTile
}
;
use
crate
:
:
composite
:
:
{
CompositorTransformIndex
}
;
use
crate
:
:
debug_colors
;
use
euclid
:
:
{
vec3
Point2D
Scale
Vector2D
Box2D
}
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
crate
:
:
filterdata
:
:
SFilterData
;
use
crate
:
:
intern
:
:
ItemUid
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FastHashSet
PlaneSplitter
Filter
FrameId
}
;
use
crate
:
:
internal_types
:
:
{
PlaneSplitterIndex
PlaneSplitAnchor
TextureSource
}
;
use
crate
:
:
frame_builder
:
:
{
FrameBuildingContext
FrameBuildingState
PictureState
PictureContext
}
;
use
crate
:
:
gpu_cache
:
:
{
GpuCache
GpuCacheAddress
GpuCacheHandle
}
;
use
crate
:
:
gpu_types
:
:
{
UvRectKind
ZBufferId
}
;
use
plane_split
:
:
{
Clipper
Polygon
Splitter
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveTemplateKind
PictureIndex
PrimitiveInstance
PrimitiveInstanceKind
}
;
use
crate
:
:
prim_store
:
:
{
ColorBindingStorage
ColorBindingIndex
PrimitiveScratchBuffer
}
;
use
crate
:
:
print_tree
:
:
{
PrintTree
PrintTreePrinter
}
;
use
crate
:
:
render_backend
:
:
DataStores
;
use
crate
:
:
render_task_graph
:
:
RenderTaskId
;
use
crate
:
:
render_target
:
:
RenderTargetKind
;
use
crate
:
:
render_task
:
:
{
BlurTask
RenderTask
RenderTaskLocation
BlurTaskCache
}
;
use
crate
:
:
render_task
:
:
{
StaticRenderTaskSurface
RenderTaskKind
}
;
use
crate
:
:
renderer
:
:
BlendMode
;
use
crate
:
:
resource_cache
:
:
{
ResourceCache
ImageGeneration
ImageRequest
}
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
scene
:
:
SceneProperties
;
use
crate
:
:
spatial_tree
:
:
CoordinateSystemId
;
use
crate
:
:
surface
:
:
{
SurfaceDescriptor
SurfaceTileDescriptor
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
{
mem
u8
marker
u32
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
std
:
:
collections
:
:
hash_map
:
:
Entry
;
use
std
:
:
ops
:
:
Range
;
use
crate
:
:
picture_textures
:
:
PictureCacheTextureHandle
;
use
crate
:
:
util
:
:
{
MaxRect
VecHelper
MatrixHelpers
Recycler
ScaleOffset
}
;
use
crate
:
:
filterdata
:
:
{
FilterDataHandle
}
;
use
crate
:
:
tile_cache
:
:
{
SliceDebugInfo
TileDebugInfo
DirtyTileDebugInfo
}
;
use
crate
:
:
visibility
:
:
{
PrimitiveVisibilityFlags
FrameVisibilityContext
}
;
use
crate
:
:
visibility
:
:
{
VisibilityState
FrameVisibilityState
}
;
use
crate
:
:
scene_building
:
:
{
SliceFlags
}
;
const
MAX_BLUR_RADIUS
:
f32
=
100
.
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
SubpixelMode
{
Allow
Deny
Conditional
{
allowed_rect
:
PictureRect
}
}
#
[
derive
(
Debug
Clone
)
]
struct
MatrixKey
{
m
:
[
f32
;
16
]
}
impl
PartialEq
for
MatrixKey
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
for
(
i
j
)
in
self
.
m
.
iter
(
)
.
zip
(
other
.
m
.
iter
(
)
)
{
if
!
i
.
approx_eq_eps
(
j
&
EPSILON
)
{
return
false
;
}
}
true
}
}
#
[
derive
(
Debug
Clone
)
]
struct
ScaleOffsetKey
{
sx
:
f32
sy
:
f32
tx
:
f32
ty
:
f32
}
impl
PartialEq
for
ScaleOffsetKey
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
self
.
sx
.
approx_eq_eps
(
&
other
.
sx
&
EPSILON
)
&
&
self
.
sy
.
approx_eq_eps
(
&
other
.
sy
&
EPSILON
)
&
&
self
.
tx
.
approx_eq_eps
(
&
other
.
tx
&
EPSILON
)
&
&
self
.
ty
.
approx_eq_eps
(
&
other
.
ty
&
EPSILON
)
}
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
enum
TransformKey
{
Local
ScaleOffset
{
so
:
ScaleOffsetKey
}
Transform
{
m
:
MatrixKey
}
}
impl
<
Src
Dst
>
From
<
CoordinateSpaceMapping
<
Src
Dst
>
>
for
TransformKey
{
fn
from
(
transform
:
CoordinateSpaceMapping
<
Src
Dst
>
)
-
>
TransformKey
{
match
transform
{
CoordinateSpaceMapping
:
:
Local
=
>
{
TransformKey
:
:
Local
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
TransformKey
:
:
ScaleOffset
{
so
:
ScaleOffsetKey
{
sx
:
scale_offset
.
scale
.
x
sy
:
scale_offset
.
scale
.
y
tx
:
scale_offset
.
offset
.
x
ty
:
scale_offset
.
offset
.
y
}
}
}
CoordinateSpaceMapping
:
:
Transform
(
ref
m
)
=
>
{
TransformKey
:
:
Transform
{
m
:
MatrixKey
{
m
:
m
.
to_array
(
)
}
}
}
}
}
}
#
[
derive
(
Hash
Clone
Copy
Debug
Eq
PartialEq
Ord
PartialOrd
)
]
pub
struct
TileCoordinate
;
pub
type
TileOffset
=
Point2D
<
i32
TileCoordinate
>
;
pub
type
TileRect
=
Box2D
<
i32
TileCoordinate
>
;
const
MAX_COMPOSITOR_SURFACES
:
usize
=
4
;
pub
const
TILE_SIZE_DEFAULT
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
512
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_HORIZONTAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
1024
height
:
32
_unit
:
marker
:
:
PhantomData
}
;
pub
const
TILE_SIZE_SCROLLBAR_VERTICAL
:
DeviceIntSize
=
DeviceIntSize
{
width
:
32
height
:
1024
_unit
:
marker
:
:
PhantomData
}
;
const
MAX_SURFACE_SIZE
:
usize
=
4096
;
const
MAX_COMPOSITOR_SURFACES_SIZE
:
f32
=
8192
.
0
;
const
MAX_PRIM_SUB_DEPS
:
usize
=
u8
:
:
MAX
as
usize
;
static
NEXT_TILE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
fn
clamp
(
value
:
i32
low
:
i32
high
:
i32
)
-
>
i32
{
value
.
max
(
low
)
.
min
(
high
)
}
fn
clampf
(
value
:
f32
low
:
f32
high
:
f32
)
-
>
f32
{
value
.
max
(
low
)
.
min
(
high
)
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveDependencyIndex
(
pub
u32
)
;
#
[
derive
(
Debug
)
]
pub
struct
BindingInfo
<
T
>
{
value
:
T
changed
:
bool
}
#
[
derive
(
Debug
PartialEq
Clone
Copy
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Binding
<
T
>
{
Value
(
T
)
Binding
(
PropertyBindingId
)
}
impl
<
T
>
From
<
PropertyBinding
<
T
>
>
for
Binding
<
T
>
{
fn
from
(
binding
:
PropertyBinding
<
T
>
)
-
>
Binding
<
T
>
{
match
binding
{
PropertyBinding
:
:
Binding
(
key
_
)
=
>
Binding
:
:
Binding
(
key
.
id
)
PropertyBinding
:
:
Value
(
value
)
=
>
Binding
:
:
Value
(
value
)
}
}
}
pub
type
OpacityBinding
=
Binding
<
f32
>
;
pub
type
OpacityBindingInfo
=
BindingInfo
<
f32
>
;
pub
type
ColorBinding
=
Binding
<
ColorU
>
;
pub
type
ColorBindingInfo
=
BindingInfo
<
ColorU
>
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SpatialNodeKey
{
spatial_node_index
:
SpatialNodeIndex
frame_id
:
FrameId
}
struct
SpatialNodeComparer
{
ref_spatial_node_index
:
SpatialNodeIndex
spatial_nodes
:
FastHashMap
<
SpatialNodeKey
TransformKey
>
compare_cache
:
FastHashMap
<
(
SpatialNodeKey
SpatialNodeKey
)
bool
>
referenced_frames
:
FastHashSet
<
FrameId
>
}
impl
SpatialNodeComparer
{
fn
new
(
)
-
>
Self
{
SpatialNodeComparer
{
ref_spatial_node_index
:
SpatialNodeIndex
:
:
INVALID
spatial_nodes
:
FastHashMap
:
:
default
(
)
compare_cache
:
FastHashMap
:
:
default
(
)
referenced_frames
:
FastHashSet
:
:
default
(
)
}
}
fn
next_frame
(
&
mut
self
ref_spatial_node_index
:
SpatialNodeIndex
)
{
let
referenced_frames
=
&
self
.
referenced_frames
;
self
.
spatial_nodes
.
retain
(
|
key
_
|
{
referenced_frames
.
contains
(
&
key
.
frame_id
)
}
)
;
self
.
ref_spatial_node_index
=
ref_spatial_node_index
;
self
.
compare_cache
.
clear
(
)
;
self
.
referenced_frames
.
clear
(
)
;
}
fn
register_used_transform
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
frame_id
:
FrameId
spatial_tree
:
&
SpatialTree
)
{
let
key
=
SpatialNodeKey
{
spatial_node_index
frame_id
}
;
if
let
Entry
:
:
Vacant
(
entry
)
=
self
.
spatial_nodes
.
entry
(
key
)
{
entry
.
insert
(
get_transform_key
(
spatial_node_index
self
.
ref_spatial_node_index
spatial_tree
)
)
;
}
}
fn
are_transforms_equivalent
(
&
mut
self
prev_spatial_node_key
:
&
SpatialNodeKey
curr_spatial_node_key
:
&
SpatialNodeKey
)
-
>
bool
{
let
key
=
(
*
prev_spatial_node_key
*
curr_spatial_node_key
)
;
let
spatial_nodes
=
&
self
.
spatial_nodes
;
*
self
.
compare_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
prev
=
&
spatial_nodes
[
&
prev_spatial_node_key
]
;
let
curr
=
&
spatial_nodes
[
&
curr_spatial_node_key
]
;
curr
=
=
prev
}
)
}
fn
retain_for_frame
(
&
mut
self
frame_id
:
FrameId
)
{
self
.
referenced_frames
.
insert
(
frame_id
)
;
}
}
struct
TilePreUpdateContext
{
pic_to_world_mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
background_color
:
Option
<
ColorF
>
global_screen_world_rect
:
WorldRect
tile_size
:
PictureSize
frame_id
:
FrameId
}
struct
TileUpdateDirtyContext
<
'
a
>
{
pic_to_world_mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
global_device_pixel_scale
:
DevicePixelScale
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
color_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
local_rect
:
PictureRect
invalidate_all
:
bool
}
struct
TileUpdateDirtyState
<
'
a
>
{
resource_cache
:
&
'
a
mut
ResourceCache
composite_state
:
&
'
a
mut
CompositeState
compare_cache
:
&
'
a
mut
FastHashMap
<
PrimitiveComparisonKey
PrimitiveCompareResult
>
spatial_node_comparer
:
&
'
a
mut
SpatialNodeComparer
}
struct
TilePostUpdateContext
{
local_clip_rect
:
PictureRect
backdrop
:
Option
<
BackdropInfo
>
current_tile_size
:
DeviceIntSize
z_id
:
ZBufferId
}
struct
TilePostUpdateState
<
'
a
>
{
resource_cache
:
&
'
a
mut
ResourceCache
composite_state
:
&
'
a
mut
CompositeState
}
struct
PrimitiveDependencyInfo
{
prim_uid
:
ItemUid
prim_clip_box
:
PictureBox2D
images
:
SmallVec
<
[
ImageDependency
;
8
]
>
opacity_bindings
:
SmallVec
<
[
OpacityBinding
;
4
]
>
color_binding
:
Option
<
ColorBinding
>
clips
:
SmallVec
<
[
ItemUid
;
8
]
>
spatial_nodes
:
SmallVec
<
[
SpatialNodeIndex
;
4
]
>
}
impl
PrimitiveDependencyInfo
{
fn
new
(
prim_uid
:
ItemUid
prim_clip_box
:
PictureBox2D
)
-
>
Self
{
PrimitiveDependencyInfo
{
prim_uid
images
:
SmallVec
:
:
new
(
)
opacity_bindings
:
SmallVec
:
:
new
(
)
color_binding
:
None
prim_clip_box
clips
:
SmallVec
:
:
new
(
)
spatial_nodes
:
SmallVec
:
:
new
(
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
PartialOrd
Ord
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileId
(
pub
usize
)
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Hash
Eq
)
]
pub
struct
TileKey
{
pub
tile_offset
:
TileOffset
pub
sub_slice_index
:
SubSliceIndex
}
#
[
derive
(
Debug
)
]
pub
enum
SurfaceTextureDescriptor
{
TextureCache
{
handle
:
Option
<
PictureCacheTextureHandle
>
}
Native
{
id
:
Option
<
NativeTileId
>
}
}
#
[
derive
(
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ResolvedSurfaceTexture
{
TextureCache
{
texture
:
TextureSource
}
Native
{
id
:
NativeTileId
size
:
DeviceIntSize
}
}
impl
SurfaceTextureDescriptor
{
pub
fn
resolve
(
&
self
resource_cache
:
&
ResourceCache
size
:
DeviceIntSize
)
-
>
ResolvedSurfaceTexture
{
match
self
{
SurfaceTextureDescriptor
:
:
TextureCache
{
handle
}
=
>
{
let
texture
=
resource_cache
.
picture_textures
.
get_texture_source
(
handle
.
as_ref
(
)
.
unwrap
(
)
)
;
ResolvedSurfaceTexture
:
:
TextureCache
{
texture
}
}
SurfaceTextureDescriptor
:
:
Native
{
id
}
=
>
{
ResolvedSurfaceTexture
:
:
Native
{
id
:
id
.
expect
(
"
bug
:
native
surface
not
allocated
"
)
size
}
}
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
TileSurface
{
Texture
{
descriptor
:
SurfaceTextureDescriptor
}
Color
{
color
:
ColorF
}
Clear
}
impl
TileSurface
{
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
TileSurface
:
:
Color
{
.
.
}
=
>
"
Color
"
TileSurface
:
:
Texture
{
.
.
}
=
>
"
Texture
"
TileSurface
:
:
Clear
=
>
"
Clear
"
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CompareHelperResult
<
T
>
{
Equal
Count
{
prev_count
:
u8
curr_count
:
u8
}
Sentinel
NotEqual
{
prev
:
T
curr
:
T
}
PredicateTrue
{
curr
:
T
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
repr
(
u8
)
]
pub
enum
PrimitiveCompareResult
{
Equal
Descriptor
Clip
Transform
Image
OpacityBinding
ColorBinding
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
InvalidationReason
{
BackgroundColor
SurfaceOpacityChanged
NoTexture
NoSurface
PrimCount
Content
CompositorKindChanged
ValidRectChanged
ScaleChanged
SurfaceContentChanged
}
pub
struct
Tile
{
pub
tile_offset
:
TileOffset
pub
world_tile_rect
:
WorldRect
pub
local_tile_rect
:
PictureRect
pub
local_dirty_rect
:
PictureRect
pub
device_dirty_rect
:
DeviceRect
pub
world_valid_rect
:
WorldRect
pub
device_valid_rect
:
DeviceRect
pub
current_descriptor
:
TileDescriptor
pub
prev_descriptor
:
TileDescriptor
pub
surface
:
Option
<
TileSurface
>
pub
is_valid
:
bool
pub
is_visible
:
bool
pub
id
:
TileId
pub
is_opaque
:
bool
root
:
TileNode
background_color
:
Option
<
ColorF
>
invalidation_reason
:
Option
<
InvalidationReason
>
pub
local_valid_rect
:
PictureBox2D
pub
z_id
:
ZBufferId
pub
last_updated_frame_id
:
FrameId
pub
sub_graphs
:
Vec
<
(
PictureRect
Vec
<
(
PictureCompositeMode
SurfaceIndex
)
>
)
>
}
impl
Tile
{
fn
new
(
tile_offset
:
TileOffset
)
-
>
Self
{
let
id
=
TileId
(
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
;
Tile
{
tile_offset
local_tile_rect
:
PictureRect
:
:
zero
(
)
world_tile_rect
:
WorldRect
:
:
zero
(
)
world_valid_rect
:
WorldRect
:
:
zero
(
)
device_valid_rect
:
DeviceRect
:
:
zero
(
)
local_dirty_rect
:
PictureRect
:
:
zero
(
)
device_dirty_rect
:
DeviceRect
:
:
zero
(
)
surface
:
None
current_descriptor
:
TileDescriptor
:
:
new
(
)
prev_descriptor
:
TileDescriptor
:
:
new
(
)
is_valid
:
false
is_visible
:
false
id
is_opaque
:
false
root
:
TileNode
:
:
new_leaf
(
Vec
:
:
new
(
)
)
background_color
:
None
invalidation_reason
:
None
local_valid_rect
:
PictureBox2D
:
:
zero
(
)
z_id
:
ZBufferId
:
:
invalid
(
)
last_updated_frame_id
:
FrameId
:
:
INVALID
sub_graphs
:
Vec
:
:
new
(
)
}
}
fn
print
(
&
self
pt
:
&
mut
dyn
PrintTreePrinter
)
{
pt
.
new_level
(
format
!
(
"
Tile
{
:
?
}
"
self
.
id
)
)
;
pt
.
add_item
(
format
!
(
"
local_tile_rect
:
{
:
?
}
"
self
.
local_tile_rect
)
)
;
pt
.
add_item
(
format
!
(
"
background_color
:
{
:
?
}
"
self
.
background_color
)
)
;
pt
.
add_item
(
format
!
(
"
invalidation_reason
:
{
:
?
}
"
self
.
invalidation_reason
)
)
;
self
.
current_descriptor
.
print
(
pt
)
;
pt
.
end_level
(
)
;
}
fn
update_dirty_rects
(
&
mut
self
ctx
:
&
TileUpdateDirtyContext
state
:
&
mut
TileUpdateDirtyState
invalidation_reason
:
&
mut
Option
<
InvalidationReason
>
frame_context
:
&
FrameVisibilityContext
)
-
>
PictureRect
{
let
mut
prim_comparer
=
PrimitiveComparer
:
:
new
(
&
self
.
prev_descriptor
&
self
.
current_descriptor
state
.
resource_cache
state
.
spatial_node_comparer
ctx
.
opacity_bindings
ctx
.
color_bindings
)
;
let
mut
dirty_rect
=
PictureBox2D
:
:
zero
(
)
;
self
.
root
.
update_dirty_rects
(
&
self
.
prev_descriptor
.
prims
&
self
.
current_descriptor
.
prims
&
mut
prim_comparer
&
mut
dirty_rect
state
.
compare_cache
invalidation_reason
frame_context
)
;
dirty_rect
}
fn
update_content_validity
(
&
mut
self
ctx
:
&
TileUpdateDirtyContext
state
:
&
mut
TileUpdateDirtyState
frame_context
:
&
FrameVisibilityContext
)
{
state
.
compare_cache
.
clear
(
)
;
let
mut
invalidation_reason
=
None
;
let
dirty_rect
=
self
.
update_dirty_rects
(
ctx
state
&
mut
invalidation_reason
frame_context
)
;
if
!
dirty_rect
.
is_empty
(
)
{
self
.
invalidate
(
Some
(
dirty_rect
)
invalidation_reason
.
expect
(
"
bug
:
no
invalidation_reason
"
)
)
;
}
if
ctx
.
invalidate_all
{
self
.
invalidate
(
None
InvalidationReason
:
:
ScaleChanged
)
;
}
if
self
.
current_descriptor
.
local_valid_rect
!
=
self
.
prev_descriptor
.
local_valid_rect
{
self
.
invalidate
(
None
InvalidationReason
:
:
ValidRectChanged
)
;
state
.
composite_state
.
dirty_rects_are_valid
=
false
;
}
}
fn
invalidate
(
&
mut
self
invalidation_rect
:
Option
<
PictureRect
>
reason
:
InvalidationReason
)
{
self
.
is_valid
=
false
;
match
invalidation_rect
{
Some
(
rect
)
=
>
{
self
.
local_dirty_rect
=
self
.
local_dirty_rect
.
union
(
&
rect
)
;
}
None
=
>
{
self
.
local_dirty_rect
=
self
.
local_tile_rect
;
}
}
if
self
.
invalidation_reason
.
is_none
(
)
{
self
.
invalidation_reason
=
Some
(
reason
)
;
}
}
fn
pre_update
(
&
mut
self
ctx
:
&
TilePreUpdateContext
)
{
self
.
local_tile_rect
=
PictureRect
:
:
from_origin_and_size
(
PicturePoint
:
:
new
(
self
.
tile_offset
.
x
as
f32
*
ctx
.
tile_size
.
width
self
.
tile_offset
.
y
as
f32
*
ctx
.
tile_size
.
height
)
ctx
.
tile_size
)
;
self
.
local_valid_rect
=
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
1
.
0e32
1
.
0e32
)
PicturePoint
:
:
new
(
-
1
.
0e32
-
1
.
0e32
)
)
;
self
.
invalidation_reason
=
None
;
self
.
sub_graphs
.
clear
(
)
;
self
.
world_tile_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
local_tile_rect
)
.
expect
(
"
bug
:
map
local
tile
rect
"
)
;
self
.
is_visible
=
self
.
world_tile_rect
.
intersects
(
&
ctx
.
global_screen_world_rect
)
;
if
!
self
.
is_visible
{
return
;
}
if
ctx
.
background_color
!
=
self
.
background_color
{
self
.
invalidate
(
None
InvalidationReason
:
:
BackgroundColor
)
;
self
.
background_color
=
ctx
.
background_color
;
}
mem
:
:
swap
(
&
mut
self
.
current_descriptor
&
mut
self
.
prev_descriptor
)
;
self
.
current_descriptor
.
clear
(
)
;
self
.
root
.
clear
(
self
.
local_tile_rect
)
;
self
.
last_updated_frame_id
=
ctx
.
frame_id
;
}
fn
add_prim_dependency
(
&
mut
self
info
:
&
PrimitiveDependencyInfo
)
{
if
!
self
.
is_visible
{
return
;
}
self
.
local_valid_rect
=
self
.
local_valid_rect
.
union
(
&
info
.
prim_clip_box
)
;
self
.
current_descriptor
.
images
.
extend_from_slice
(
&
info
.
images
)
;
self
.
current_descriptor
.
opacity_bindings
.
extend_from_slice
(
&
info
.
opacity_bindings
)
;
self
.
current_descriptor
.
clips
.
extend_from_slice
(
&
info
.
clips
)
;
for
spatial_node_index
in
&
info
.
spatial_nodes
{
self
.
current_descriptor
.
transforms
.
push
(
SpatialNodeKey
{
spatial_node_index
:
*
spatial_node_index
frame_id
:
self
.
last_updated_frame_id
}
)
;
}
if
info
.
color_binding
.
is_some
(
)
{
self
.
current_descriptor
.
color_bindings
.
insert
(
self
.
current_descriptor
.
color_bindings
.
len
(
)
info
.
color_binding
.
unwrap
(
)
)
;
}
let
tile_p0
=
self
.
local_tile_rect
.
min
;
let
tile_p1
=
self
.
local_tile_rect
.
max
;
let
prim_clip_box
=
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
clampf
(
info
.
prim_clip_box
.
min
.
x
tile_p0
.
x
tile_p1
.
x
)
clampf
(
info
.
prim_clip_box
.
min
.
y
tile_p0
.
y
tile_p1
.
y
)
)
PicturePoint
:
:
new
(
clampf
(
info
.
prim_clip_box
.
max
.
x
tile_p0
.
x
tile_p1
.
x
)
clampf
(
info
.
prim_clip_box
.
max
.
y
tile_p0
.
y
tile_p1
.
y
)
)
)
;
let
prim_index
=
PrimitiveDependencyIndex
(
self
.
current_descriptor
.
prims
.
len
(
)
as
u32
)
;
debug_assert
!
(
info
.
spatial_nodes
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
clips
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
images
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
opacity_bindings
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
self
.
current_descriptor
.
prims
.
push
(
PrimitiveDescriptor
{
prim_uid
:
info
.
prim_uid
prim_clip_box
transform_dep_count
:
info
.
spatial_nodes
.
len
(
)
as
u8
clip_dep_count
:
info
.
clips
.
len
(
)
as
u8
image_dep_count
:
info
.
images
.
len
(
)
as
u8
opacity_binding_dep_count
:
info
.
opacity_bindings
.
len
(
)
as
u8
color_binding_dep_count
:
if
info
.
color_binding
.
is_some
(
)
{
1
}
else
{
0
}
as
u8
}
)
;
self
.
root
.
add_prim
(
prim_index
&
info
.
prim_clip_box
)
;
}
fn
update_dirty_and_valid_rects
(
&
mut
self
ctx
:
&
TileUpdateDirtyContext
state
:
&
mut
TileUpdateDirtyState
frame_context
:
&
FrameVisibilityContext
)
{
state
.
spatial_node_comparer
.
retain_for_frame
(
self
.
last_updated_frame_id
)
;
if
!
self
.
is_visible
{
return
;
}
self
.
current_descriptor
.
local_valid_rect
=
self
.
local_valid_rect
;
self
.
current_descriptor
.
local_valid_rect
=
self
.
local_tile_rect
.
intersection
(
&
ctx
.
local_rect
)
.
and_then
(
|
r
|
r
.
intersection
(
&
self
.
current_descriptor
.
local_valid_rect
)
)
.
unwrap_or_else
(
PictureRect
:
:
zero
)
;
self
.
world_valid_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
current_descriptor
.
local_valid_rect
)
.
expect
(
"
bug
:
map
local
valid
rect
"
)
;
let
device_rect
=
(
self
.
world_tile_rect
*
ctx
.
global_device_pixel_scale
)
.
round
(
)
;
self
.
device_valid_rect
=
(
self
.
world_valid_rect
*
ctx
.
global_device_pixel_scale
)
.
round_out
(
)
.
intersection
(
&
device_rect
)
.
unwrap_or_else
(
DeviceRect
:
:
zero
)
;
self
.
update_content_validity
(
ctx
state
frame_context
)
;
}
fn
post_update
(
&
mut
self
ctx
:
&
TilePostUpdateContext
state
:
&
mut
TilePostUpdateState
frame_context
:
&
FrameVisibilityContext
)
{
if
!
self
.
is_visible
{
return
;
}
if
self
.
current_descriptor
.
prims
.
is_empty
(
)
|
|
self
.
device_valid_rect
.
is_empty
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
mut
id
.
.
}
.
.
}
)
=
self
.
surface
.
take
(
)
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
self
.
is_visible
=
false
;
return
;
}
let
clipped_rect
=
self
.
current_descriptor
.
local_valid_rect
.
intersection
(
&
ctx
.
local_clip_rect
)
.
unwrap_or_else
(
PictureRect
:
:
zero
)
;
let
has_opaque_bg_color
=
self
.
background_color
.
map_or
(
false
|
c
|
c
.
a
>
=
1
.
0
)
;
let
has_opaque_backdrop
=
ctx
.
backdrop
.
map_or
(
false
|
b
|
b
.
opaque_rect
.
contains_box
(
&
clipped_rect
)
)
;
let
is_opaque
=
has_opaque_bg_color
|
|
has_opaque_backdrop
;
self
.
z_id
=
ctx
.
z_id
;
if
is_opaque
!
=
self
.
is_opaque
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
self
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
self
.
invalidate
(
None
InvalidationReason
:
:
SurfaceOpacityChanged
)
;
self
.
is_opaque
=
is_opaque
;
}
let
(
supports_dirty_rects
supports_simple_prims
)
=
match
state
.
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
(
frame_context
.
config
.
gpu_supports_render_target_partial_update
true
)
}
CompositorKind
:
:
Native
{
capabilities
.
.
}
=
>
{
(
capabilities
.
max_update_rects
>
0
false
)
}
}
;
if
supports_dirty_rects
{
if
ctx
.
current_tile_size
=
=
state
.
resource_cache
.
picture_textures
.
default_tile_size
(
)
{
let
max_split_level
=
3
;
self
.
root
.
maybe_merge_or_split
(
0
&
self
.
current_descriptor
.
prims
max_split_level
)
;
}
}
if
!
self
.
is_valid
&
&
!
supports_dirty_rects
{
self
.
local_dirty_rect
=
self
.
local_tile_rect
;
}
let
is_simple_prim
=
ctx
.
backdrop
.
map_or
(
false
|
b
|
b
.
kind
.
is_some
(
)
)
&
&
self
.
current_descriptor
.
prims
.
len
(
)
=
=
1
&
&
self
.
is_opaque
&
&
supports_simple_prims
;
let
surface
=
if
is_simple_prim
{
match
ctx
.
backdrop
.
unwrap
(
)
.
kind
{
Some
(
BackdropKind
:
:
Color
{
color
}
)
=
>
{
TileSurface
:
:
Color
{
color
}
}
Some
(
BackdropKind
:
:
Clear
)
=
>
{
TileSurface
:
:
Clear
}
None
=
>
{
unreachable
!
(
)
;
}
}
}
else
{
match
self
.
surface
.
take
(
)
{
Some
(
TileSurface
:
:
Texture
{
descriptor
}
)
=
>
{
TileSurface
:
:
Texture
{
descriptor
}
}
Some
(
TileSurface
:
:
Color
{
.
.
}
)
|
Some
(
TileSurface
:
:
Clear
)
|
None
=
>
{
let
descriptor
=
match
state
.
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
SurfaceTextureDescriptor
:
:
TextureCache
{
handle
:
None
}
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
SurfaceTextureDescriptor
:
:
Native
{
id
:
None
}
}
}
;
TileSurface
:
:
Texture
{
descriptor
}
}
}
}
;
self
.
surface
=
Some
(
surface
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveDescriptor
{
pub
prim_uid
:
ItemUid
pub
prim_clip_box
:
PictureBox2D
transform_dep_count
:
u8
image_dep_count
:
u8
opacity_binding_dep_count
:
u8
clip_dep_count
:
u8
color_binding_dep_count
:
u8
}
impl
PartialEq
for
PrimitiveDescriptor
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
if
self
.
prim_uid
!
=
other
.
prim_uid
{
return
false
;
}
if
!
self
.
prim_clip_box
.
min
.
x
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
min
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
min
.
y
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
min
.
y
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
max
.
x
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
max
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_box
.
max
.
y
.
approx_eq_eps
(
&
other
.
prim_clip_box
.
max
.
y
&
EPSILON
)
{
return
false
;
}
true
}
}
struct
CompareHelper
<
'
a
T
>
where
T
:
Copy
{
offset_curr
:
usize
offset_prev
:
usize
curr_items
:
&
'
a
[
T
]
prev_items
:
&
'
a
[
T
]
}
impl
<
'
a
T
>
CompareHelper
<
'
a
T
>
where
T
:
Copy
+
PartialEq
{
fn
new
(
prev_items
:
&
'
a
[
T
]
curr_items
:
&
'
a
[
T
]
)
-
>
Self
{
CompareHelper
{
offset_curr
:
0
offset_prev
:
0
curr_items
prev_items
}
}
fn
reset
(
&
mut
self
)
{
self
.
offset_prev
=
0
;
self
.
offset_curr
=
0
;
}
fn
is_same
<
F
>
(
&
self
prev_count
:
u8
curr_count
:
u8
mut
f
:
F
)
-
>
bool
where
F
:
FnMut
(
&
T
&
T
)
-
>
bool
{
if
prev_count
!
=
curr_count
{
return
false
;
}
if
curr_count
=
=
0
{
return
true
;
}
if
curr_count
as
usize
=
=
MAX_PRIM_SUB_DEPS
{
return
false
;
}
let
end_prev
=
self
.
offset_prev
+
prev_count
as
usize
;
let
end_curr
=
self
.
offset_curr
+
curr_count
as
usize
;
let
curr_items
=
&
self
.
curr_items
[
self
.
offset_curr
.
.
end_curr
]
;
let
prev_items
=
&
self
.
prev_items
[
self
.
offset_prev
.
.
end_prev
]
;
for
(
curr
prev
)
in
curr_items
.
iter
(
)
.
zip
(
prev_items
.
iter
(
)
)
{
if
!
f
(
prev
curr
)
{
return
false
;
}
}
true
}
fn
advance_prev
(
&
mut
self
count
:
u8
)
{
self
.
offset_prev
+
=
count
as
usize
;
}
fn
advance_curr
(
&
mut
self
count
:
u8
)
{
self
.
offset_curr
+
=
count
as
usize
;
}
}
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileDescriptor
{
pub
prims
:
Vec
<
PrimitiveDescriptor
>
clips
:
Vec
<
ItemUid
>
images
:
Vec
<
ImageDependency
>
opacity_bindings
:
Vec
<
OpacityBinding
>
transforms
:
Vec
<
SpatialNodeKey
>
pub
local_valid_rect
:
PictureRect
color_bindings
:
Vec
<
ColorBinding
>
}
impl
TileDescriptor
{
fn
new
(
)
-
>
Self
{
TileDescriptor
{
prims
:
Vec
:
:
new
(
)
clips
:
Vec
:
:
new
(
)
opacity_bindings
:
Vec
:
:
new
(
)
images
:
Vec
:
:
new
(
)
transforms
:
Vec
:
:
new
(
)
local_valid_rect
:
PictureRect
:
:
zero
(
)
color_bindings
:
Vec
:
:
new
(
)
}
}
fn
print
(
&
self
pt
:
&
mut
dyn
PrintTreePrinter
)
{
pt
.
new_level
(
"
current_descriptor
"
.
to_string
(
)
)
;
pt
.
new_level
(
"
prims
"
.
to_string
(
)
)
;
for
prim
in
&
self
.
prims
{
pt
.
new_level
(
format
!
(
"
prim
uid
=
{
}
"
prim
.
prim_uid
.
get_uid
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
clip
:
p0
=
{
}
{
}
p1
=
{
}
{
}
"
prim
.
prim_clip_box
.
min
.
x
prim
.
prim_clip_box
.
min
.
y
prim
.
prim_clip_box
.
max
.
x
prim
.
prim_clip_box
.
max
.
y
)
)
;
pt
.
add_item
(
format
!
(
"
deps
:
t
=
{
}
i
=
{
}
o
=
{
}
c
=
{
}
color
=
{
}
"
prim
.
transform_dep_count
prim
.
image_dep_count
prim
.
opacity_binding_dep_count
prim
.
clip_dep_count
prim
.
color_binding_dep_count
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
if
!
self
.
clips
.
is_empty
(
)
{
pt
.
new_level
(
"
clips
"
.
to_string
(
)
)
;
for
clip
in
&
self
.
clips
{
pt
.
new_level
(
format
!
(
"
clip
uid
=
{
}
"
clip
.
get_uid
(
)
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
if
!
self
.
images
.
is_empty
(
)
{
pt
.
new_level
(
"
images
"
.
to_string
(
)
)
;
for
info
in
&
self
.
images
{
pt
.
new_level
(
format
!
(
"
key
=
{
:
?
}
"
info
.
key
)
)
;
pt
.
add_item
(
format
!
(
"
generation
=
{
:
?
}
"
info
.
generation
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
if
!
self
.
opacity_bindings
.
is_empty
(
)
{
pt
.
new_level
(
"
opacity_bindings
"
.
to_string
(
)
)
;
for
opacity_binding
in
&
self
.
opacity_bindings
{
pt
.
new_level
(
format
!
(
"
binding
=
{
:
?
}
"
opacity_binding
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
if
!
self
.
transforms
.
is_empty
(
)
{
pt
.
new_level
(
"
transforms
"
.
to_string
(
)
)
;
for
transform
in
&
self
.
transforms
{
pt
.
new_level
(
format
!
(
"
spatial_node
=
{
:
?
}
"
transform
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
if
!
self
.
color_bindings
.
is_empty
(
)
{
pt
.
new_level
(
"
color_bindings
"
.
to_string
(
)
)
;
for
color_binding
in
&
self
.
color_bindings
{
pt
.
new_level
(
format
!
(
"
binding
=
{
:
?
}
"
color_binding
)
)
;
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
fn
clear
(
&
mut
self
)
{
self
.
prims
.
clear
(
)
;
self
.
clips
.
clear
(
)
;
self
.
opacity_bindings
.
clear
(
)
;
self
.
images
.
clear
(
)
;
self
.
transforms
.
clear
(
)
;
self
.
local_valid_rect
=
PictureRect
:
:
zero
(
)
;
self
.
color_bindings
.
clear
(
)
;
}
}
#
[
derive
(
Clone
)
]
pub
struct
DirtyRegion
{
pub
combined
:
WorldRect
spatial_node_index
:
SpatialNodeIndex
}
impl
DirtyRegion
{
pub
fn
new
(
spatial_node_index
:
SpatialNodeIndex
)
-
>
Self
{
DirtyRegion
{
combined
:
WorldRect
:
:
zero
(
)
spatial_node_index
}
}
pub
fn
reset
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
)
{
self
.
combined
=
WorldRect
:
:
zero
(
)
;
self
.
spatial_node_index
=
spatial_node_index
;
}
pub
fn
add_dirty_region
(
&
mut
self
rect_in_pic_space
:
PictureRect
spatial_tree
:
&
SpatialTree
)
{
let
map_pic_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
self
.
spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
let
world_rect
=
map_pic_to_world
.
map
(
&
rect_in_pic_space
)
.
expect
(
"
bug
"
)
;
self
.
combined
=
self
.
combined
.
union
(
&
world_rect
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
BackdropKind
{
Color
{
color
:
ColorF
}
Clear
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
BackdropInfo
{
pub
opaque_rect
:
PictureRect
pub
spanning_opaque_color
:
Option
<
ColorF
>
pub
kind
:
Option
<
BackdropKind
>
pub
backdrop_rect
:
PictureRect
}
impl
BackdropInfo
{
fn
empty
(
)
-
>
Self
{
BackdropInfo
{
opaque_rect
:
PictureRect
:
:
zero
(
)
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
}
}
pub
struct
NativeSurface
{
pub
opaque
:
NativeSurfaceId
pub
alpha
:
NativeSurfaceId
}
#
[
derive
(
PartialEq
Eq
Hash
)
]
pub
struct
ExternalNativeSurfaceKey
{
pub
image_keys
:
[
ImageKey
;
3
]
pub
size
:
DeviceIntSize
pub
is_external_surface
:
bool
}
pub
struct
ExternalNativeSurface
{
pub
used_this_frame
:
bool
pub
native_surface_id
:
NativeSurfaceId
pub
image_dependencies
:
[
ImageDependency
;
3
]
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SliceId
(
usize
)
;
impl
SliceId
{
pub
fn
new
(
index
:
usize
)
-
>
Self
{
SliceId
(
index
)
}
}
pub
struct
TileCacheParams
{
pub
slice
:
usize
pub
slice_flags
:
SliceFlags
pub
spatial_node_index
:
SpatialNodeIndex
pub
background_color
:
Option
<
ColorF
>
pub
shared_clip_node_id
:
ClipNodeId
pub
shared_clip_leaf_id
:
Option
<
ClipLeafId
>
pub
virtual_surface_size
:
i32
pub
compositor_surface_count
:
usize
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
Hash
)
]
pub
struct
SubSliceIndex
(
u8
)
;
impl
SubSliceIndex
{
pub
const
DEFAULT
:
SubSliceIndex
=
SubSliceIndex
(
0
)
;
pub
fn
new
(
index
:
usize
)
-
>
Self
{
SubSliceIndex
(
index
as
u8
)
}
pub
fn
is_primary
(
&
self
)
-
>
bool
{
self
.
0
=
=
0
}
}
pub
struct
CompositorSurface
{
pub
descriptor
:
ExternalSurfaceDescriptor
prohibited_rect
:
PictureRect
pub
is_opaque
:
bool
}
pub
struct
SubSlice
{
pub
tiles
:
FastHashMap
<
TileOffset
Box
<
Tile
>
>
pub
native_surface
:
Option
<
NativeSurface
>
pub
compositor_surfaces
:
Vec
<
CompositorSurface
>
pub
composite_tiles
:
Vec
<
CompositeTile
>
pub
opaque_tile_descriptors
:
Vec
<
CompositeTileDescriptor
>
pub
alpha_tile_descriptors
:
Vec
<
CompositeTileDescriptor
>
}
impl
SubSlice
{
fn
new
(
)
-
>
Self
{
SubSlice
{
tiles
:
FastHashMap
:
:
default
(
)
native_surface
:
None
compositor_surfaces
:
Vec
:
:
new
(
)
composite_tiles
:
Vec
:
:
new
(
)
opaque_tile_descriptors
:
Vec
:
:
new
(
)
alpha_tile_descriptors
:
Vec
:
:
new
(
)
}
}
fn
reset
(
&
mut
self
)
{
self
.
compositor_surfaces
.
clear
(
)
;
self
.
composite_tiles
.
clear
(
)
;
self
.
opaque_tile_descriptors
.
clear
(
)
;
self
.
alpha_tile_descriptors
.
clear
(
)
;
}
fn
resize
(
&
mut
self
new_tile_rect
:
TileRect
)
-
>
FastHashMap
<
TileOffset
Box
<
Tile
>
>
{
let
mut
old_tiles
=
mem
:
:
replace
(
&
mut
self
.
tiles
FastHashMap
:
:
default
(
)
)
;
self
.
tiles
.
reserve
(
new_tile_rect
.
area
(
)
as
usize
)
;
for
y
in
new_tile_rect
.
min
.
y
.
.
new_tile_rect
.
max
.
y
{
for
x
in
new_tile_rect
.
min
.
x
.
.
new_tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
old_tiles
.
remove
(
&
key
)
.
unwrap_or_else
(
|
|
{
Box
:
:
new
(
Tile
:
:
new
(
key
)
)
}
)
;
self
.
tiles
.
insert
(
key
tile
)
;
}
}
old_tiles
}
}
pub
struct
BackdropSurface
{
pub
id
:
NativeSurfaceId
color
:
ColorF
pub
device_rect
:
DeviceRect
}
pub
struct
TileCacheInstance
{
pub
slice
:
usize
pub
slice_flags
:
SliceFlags
pub
current_tile_size
:
DeviceIntSize
pub
sub_slices
:
Vec
<
SubSlice
>
pub
spatial_node_index
:
SpatialNodeIndex
opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
old_opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
spatial_node_comparer
:
SpatialNodeComparer
color_bindings
:
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
old_color_bindings
:
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
pub
dirty_region
:
DirtyRegion
tile_size
:
PictureSize
tile_rect
:
TileRect
tile_bounds_p0
:
TileOffset
tile_bounds_p1
:
TileOffset
pub
local_rect
:
PictureRect
pub
local_clip_rect
:
PictureRect
pub
screen_rect_in_pic_space
:
PictureRect
surface_index
:
SurfaceIndex
pub
background_color
:
Option
<
ColorF
>
pub
backdrop
:
BackdropInfo
pub
subpixel_mode
:
SubpixelMode
pub
shared_clip_node_id
:
ClipNodeId
pub
shared_clip_leaf_id
:
Option
<
ClipLeafId
>
frames_until_size_eval
:
usize
virtual_offset
:
DeviceIntPoint
compare_cache
:
FastHashMap
<
PrimitiveComparisonKey
PrimitiveCompareResult
>
tile_size_override
:
Option
<
DeviceIntSize
>
pub
external_native_surface_cache
:
FastHashMap
<
ExternalNativeSurfaceKey
ExternalNativeSurface
>
frame_id
:
FrameId
pub
transform_index
:
CompositorTransformIndex
local_to_surface
:
ScaleOffset
invalidate_all_tiles
:
bool
surface_to_device
:
ScaleOffset
current_raster_scale
:
f32
current_surface_traversal_depth
:
usize
deferred_dirty_tests
:
Vec
<
DeferredDirtyTest
>
found_prims_after_backdrop
:
bool
pub
backdrop_surface
:
Option
<
BackdropSurface
>
}
enum
SurfacePromotionResult
{
Failed
Success
}
impl
TileCacheInstance
{
pub
fn
new
(
params
:
TileCacheParams
)
-
>
Self
{
let
sub_slice_count
=
params
.
compositor_surface_count
.
min
(
MAX_COMPOSITOR_SURFACES
)
+
1
;
let
mut
sub_slices
=
Vec
:
:
with_capacity
(
sub_slice_count
)
;
for
_
in
0
.
.
sub_slice_count
{
sub_slices
.
push
(
SubSlice
:
:
new
(
)
)
;
}
TileCacheInstance
{
slice
:
params
.
slice
slice_flags
:
params
.
slice_flags
spatial_node_index
:
params
.
spatial_node_index
sub_slices
opacity_bindings
:
FastHashMap
:
:
default
(
)
old_opacity_bindings
:
FastHashMap
:
:
default
(
)
spatial_node_comparer
:
SpatialNodeComparer
:
:
new
(
)
color_bindings
:
FastHashMap
:
:
default
(
)
old_color_bindings
:
FastHashMap
:
:
default
(
)
dirty_region
:
DirtyRegion
:
:
new
(
params
.
spatial_node_index
)
tile_size
:
PictureSize
:
:
zero
(
)
tile_rect
:
TileRect
:
:
zero
(
)
tile_bounds_p0
:
TileOffset
:
:
zero
(
)
tile_bounds_p1
:
TileOffset
:
:
zero
(
)
local_rect
:
PictureRect
:
:
zero
(
)
local_clip_rect
:
PictureRect
:
:
zero
(
)
screen_rect_in_pic_space
:
PictureRect
:
:
zero
(
)
surface_index
:
SurfaceIndex
(
0
)
background_color
:
params
.
background_color
backdrop
:
BackdropInfo
:
:
empty
(
)
subpixel_mode
:
SubpixelMode
:
:
Allow
shared_clip_node_id
:
params
.
shared_clip_node_id
shared_clip_leaf_id
:
params
.
shared_clip_leaf_id
current_tile_size
:
DeviceIntSize
:
:
zero
(
)
frames_until_size_eval
:
0
virtual_offset
:
DeviceIntPoint
:
:
new
(
params
.
virtual_surface_size
/
2
params
.
virtual_surface_size
/
2
)
compare_cache
:
FastHashMap
:
:
default
(
)
tile_size_override
:
None
external_native_surface_cache
:
FastHashMap
:
:
default
(
)
frame_id
:
FrameId
:
:
INVALID
transform_index
:
CompositorTransformIndex
:
:
INVALID
surface_to_device
:
ScaleOffset
:
:
identity
(
)
local_to_surface
:
ScaleOffset
:
:
identity
(
)
invalidate_all_tiles
:
true
current_raster_scale
:
1
.
0
current_surface_traversal_depth
:
0
deferred_dirty_tests
:
Vec
:
:
new
(
)
found_prims_after_backdrop
:
false
backdrop_surface
:
None
}
}
pub
fn
tile_count
(
&
self
)
-
>
usize
{
self
.
tile_rect
.
area
(
)
as
usize
*
self
.
sub_slices
.
len
(
)
}
pub
fn
prepare_for_new_scene
(
&
mut
self
params
:
TileCacheParams
resource_cache
:
&
mut
ResourceCache
)
{
assert_eq
!
(
self
.
slice
params
.
slice
)
;
let
required_sub_slice_count
=
params
.
compositor_surface_count
.
min
(
MAX_COMPOSITOR_SURFACES
)
+
1
;
if
self
.
sub_slices
.
len
(
)
!
=
required_sub_slice_count
{
self
.
tile_rect
=
TileRect
:
:
zero
(
)
;
if
self
.
sub_slices
.
len
(
)
>
required_sub_slice_count
{
let
old_sub_slices
=
self
.
sub_slices
.
split_off
(
required_sub_slice_count
)
;
for
mut
sub_slice
in
old_sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
{
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
}
else
{
while
self
.
sub_slices
.
len
(
)
<
required_sub_slice_count
{
self
.
sub_slices
.
push
(
SubSlice
:
:
new
(
)
)
;
}
}
}
self
.
slice_flags
=
params
.
slice_flags
;
self
.
spatial_node_index
=
params
.
spatial_node_index
;
self
.
background_color
=
params
.
background_color
;
self
.
shared_clip_leaf_id
=
params
.
shared_clip_leaf_id
;
self
.
shared_clip_node_id
=
params
.
shared_clip_node_id
;
self
.
frames_until_size_eval
=
0
;
}
pub
fn
destroy
(
self
resource_cache
:
&
mut
ResourceCache
)
{
for
sub_slice
in
self
.
sub_slices
{
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
{
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
for
(
_
external_surface
)
in
self
.
external_native_surface_cache
{
resource_cache
.
destroy_compositor_surface
(
external_surface
.
native_surface_id
)
}
if
let
Some
(
backdrop_surface
)
=
&
self
.
backdrop_surface
{
resource_cache
.
destroy_compositor_surface
(
backdrop_surface
.
id
)
;
}
}
fn
get_tile_coords_for_rect
(
&
self
rect
:
&
PictureRect
)
-
>
(
TileOffset
TileOffset
)
{
let
mut
p0
=
TileOffset
:
:
new
(
(
rect
.
min
.
x
/
self
.
tile_size
.
width
)
.
floor
(
)
as
i32
(
rect
.
min
.
y
/
self
.
tile_size
.
height
)
.
floor
(
)
as
i32
)
;
let
mut
p1
=
TileOffset
:
:
new
(
(
rect
.
max
.
x
/
self
.
tile_size
.
width
)
.
ceil
(
)
as
i32
(
rect
.
max
.
y
/
self
.
tile_size
.
height
)
.
ceil
(
)
as
i32
)
;
p0
.
x
=
clamp
(
p0
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p0
.
y
=
clamp
(
p0
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
p1
.
x
=
clamp
(
p1
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p1
.
y
=
clamp
(
p1
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
(
p0
p1
)
}
pub
fn
pre_update
(
&
mut
self
pic_rect
:
PictureRect
surface_index
:
SurfaceIndex
frame_context
:
&
FrameVisibilityContext
frame_state
:
&
mut
FrameVisibilityState
)
-
>
WorldRect
{
self
.
surface_index
=
surface_index
;
self
.
local_rect
=
pic_rect
;
self
.
local_clip_rect
=
PictureRect
:
:
max_rect
(
)
;
self
.
deferred_dirty_tests
.
clear
(
)
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
sub_slice
.
reset
(
)
;
}
self
.
backdrop
=
BackdropInfo
:
:
empty
(
)
;
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
self
.
screen_rect_in_pic_space
=
pic_to_world_mapper
.
unmap
(
&
frame_context
.
global_screen_world_rect
)
.
expect
(
"
unable
to
unmap
screen
rect
"
)
;
if
let
Some
(
shared_clip_leaf_id
)
=
self
.
shared_clip_leaf_id
{
let
map_local_to_surface
=
SpaceMapper
:
:
new
(
self
.
spatial_node_index
pic_rect
)
;
frame_state
.
clip_store
.
set_active_clips
(
self
.
spatial_node_index
map_local_to_surface
.
ref_spatial_node_index
shared_clip_leaf_id
frame_context
.
spatial_tree
&
mut
frame_state
.
data_stores
.
clip
&
frame_state
.
clip_tree
)
;
let
clip_chain_instance
=
frame_state
.
clip_store
.
build_clip_chain_instance
(
pic_rect
.
cast_unit
(
)
&
map_local_to_surface
&
pic_to_world_mapper
frame_context
.
spatial_tree
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_context
.
global_device_pixel_scale
&
frame_context
.
global_screen_world_rect
&
mut
frame_state
.
data_stores
.
clip
true
)
;
self
.
local_clip_rect
=
clip_chain_instance
.
map_or
(
PictureRect
:
:
zero
(
)
|
clip_chain_instance
|
{
clip_chain_instance
.
pic_coverage_rect
}
)
;
}
self
.
frame_id
.
advance
(
)
;
self
.
spatial_node_comparer
.
next_frame
(
self
.
spatial_node_index
)
;
for
external_native_surface
in
self
.
external_native_surface_cache
.
values_mut
(
)
{
external_native_surface
.
used_this_frame
=
false
;
}
if
self
.
frames_until_size_eval
=
=
0
|
|
self
.
tile_size_override
!
=
frame_context
.
config
.
tile_size_override
{
let
desired_tile_size
=
match
frame_context
.
config
.
tile_size_override
{
Some
(
tile_size_override
)
=
>
{
tile_size_override
}
None
=
>
{
if
self
.
slice_flags
.
contains
(
SliceFlags
:
:
IS_SCROLLBAR
)
{
if
pic_rect
.
width
(
)
<
=
pic_rect
.
height
(
)
{
TILE_SIZE_SCROLLBAR_VERTICAL
}
else
{
TILE_SIZE_SCROLLBAR_HORIZONTAL
}
}
else
{
frame_state
.
resource_cache
.
picture_textures
.
default_tile_size
(
)
}
}
}
;
if
desired_tile_size
!
=
self
.
current_tile_size
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
sub_slice
.
tiles
.
clear
(
)
;
}
self
.
tile_rect
=
TileRect
:
:
zero
(
)
;
self
.
current_tile_size
=
desired_tile_size
;
}
self
.
frames_until_size_eval
=
120
;
self
.
tile_size_override
=
frame_context
.
config
.
tile_size_override
;
}
let
local_to_device
=
get_relative_scale_offset
(
self
.
spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
mut
surface_to_device
=
local_to_device
;
if
frame_context
.
config
.
low_quality_pinch_zoom
{
surface_to_device
.
scale
.
x
/
=
self
.
current_raster_scale
;
surface_to_device
.
scale
.
y
/
=
self
.
current_raster_scale
;
}
else
{
surface_to_device
.
scale
.
x
=
1
.
0
;
surface_to_device
.
scale
.
y
=
1
.
0
;
}
let
local_to_surface
=
local_to_device
.
accumulate
(
&
surface_to_device
.
inverse
(
)
)
;
const
EPSILON
:
f32
=
0
.
001
;
let
compositor_translation_changed
=
!
surface_to_device
.
offset
.
x
.
approx_eq_eps
(
&
self
.
surface_to_device
.
offset
.
x
&
EPSILON
)
|
|
!
surface_to_device
.
offset
.
y
.
approx_eq_eps
(
&
self
.
surface_to_device
.
offset
.
y
&
EPSILON
)
;
let
compositor_scale_changed
=
!
surface_to_device
.
scale
.
x
.
approx_eq_eps
(
&
self
.
surface_to_device
.
scale
.
x
&
EPSILON
)
|
|
!
surface_to_device
.
scale
.
y
.
approx_eq_eps
(
&
self
.
surface_to_device
.
scale
.
y
&
EPSILON
)
;
let
surface_scale_changed
=
!
local_to_surface
.
scale
.
x
.
approx_eq_eps
(
&
self
.
local_to_surface
.
scale
.
x
&
EPSILON
)
|
|
!
local_to_surface
.
scale
.
y
.
approx_eq_eps
(
&
self
.
local_to_surface
.
scale
.
y
&
EPSILON
)
;
if
compositor_translation_changed
|
|
compositor_scale_changed
|
|
surface_scale_changed
|
|
frame_context
.
config
.
force_invalidation
{
frame_state
.
composite_state
.
dirty_rects_are_valid
=
false
;
}
self
.
surface_to_device
=
surface_to_device
;
self
.
local_to_surface
=
local_to_surface
;
self
.
invalidate_all_tiles
=
surface_scale_changed
|
|
frame_context
.
config
.
force_invalidation
;
let
current_properties
=
frame_context
.
scene_properties
.
float_properties
(
)
;
mem
:
:
swap
(
&
mut
self
.
opacity_bindings
&
mut
self
.
old_opacity_bindings
)
;
self
.
opacity_bindings
.
clear
(
)
;
for
(
id
value
)
in
current_properties
{
let
changed
=
match
self
.
old_opacity_bindings
.
get
(
id
)
{
Some
(
old_property
)
=
>
!
old_property
.
value
.
approx_eq
(
value
)
None
=
>
true
}
;
self
.
opacity_bindings
.
insert
(
*
id
OpacityBindingInfo
{
value
:
*
value
changed
}
)
;
}
let
current_properties
=
frame_context
.
scene_properties
.
color_properties
(
)
;
mem
:
:
swap
(
&
mut
self
.
color_bindings
&
mut
self
.
old_color_bindings
)
;
self
.
color_bindings
.
clear
(
)
;
for
(
id
value
)
in
current_properties
{
let
changed
=
match
self
.
old_color_bindings
.
get
(
id
)
{
Some
(
old_property
)
=
>
old_property
.
value
!
=
(
*
value
)
.
into
(
)
None
=
>
true
}
;
self
.
color_bindings
.
insert
(
*
id
ColorBindingInfo
{
value
:
(
*
value
)
.
into
(
)
changed
}
)
;
}
let
world_tile_size
=
WorldSize
:
:
new
(
self
.
current_tile_size
.
width
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
self
.
current_tile_size
.
height
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
)
;
self
.
tile_size
=
PictureSize
:
:
new
(
world_tile_size
.
width
/
self
.
local_to_surface
.
scale
.
x
world_tile_size
.
height
/
self
.
local_to_surface
.
scale
.
y
)
;
let
desired_rect_in_pic_space
=
self
.
screen_rect_in_pic_space
.
inflate
(
0
.
0
1
.
0
*
self
.
tile_size
.
height
)
;
let
needed_rect_in_pic_space
=
desired_rect_in_pic_space
.
intersection
(
&
pic_rect
)
.
unwrap_or_else
(
Box2D
:
:
zero
)
;
let
p0
=
needed_rect_in_pic_space
.
min
;
let
p1
=
needed_rect_in_pic_space
.
max
;
let
x0
=
(
p0
.
x
/
self
.
tile_size
.
width
)
.
floor
(
)
as
i32
;
let
x1
=
(
p1
.
x
/
self
.
tile_size
.
width
)
.
ceil
(
)
as
i32
;
let
y0
=
(
p0
.
y
/
self
.
tile_size
.
height
)
.
floor
(
)
as
i32
;
let
y1
=
(
p1
.
y
/
self
.
tile_size
.
height
)
.
ceil
(
)
as
i32
;
let
new_tile_rect
=
TileRect
{
min
:
TileOffset
:
:
new
(
x0
y0
)
max
:
TileOffset
:
:
new
(
x1
y1
)
}
;
let
virtual_surface_size
=
frame_context
.
config
.
compositor_kind
.
get_virtual_surface_size
(
)
;
if
virtual_surface_size
>
0
{
let
tx0
=
self
.
virtual_offset
.
x
+
x0
*
self
.
current_tile_size
.
width
;
let
ty0
=
self
.
virtual_offset
.
y
+
y0
*
self
.
current_tile_size
.
height
;
let
tx1
=
self
.
virtual_offset
.
x
+
(
x1
+
1
)
*
self
.
current_tile_size
.
width
;
let
ty1
=
self
.
virtual_offset
.
y
+
(
y1
+
1
)
*
self
.
current_tile_size
.
height
;
let
need_new_virtual_offset
=
tx0
<
0
|
|
ty0
<
0
|
|
tx1
>
=
virtual_surface_size
|
|
ty1
>
=
virtual_surface_size
;
if
need_new_virtual_offset
{
self
.
virtual_offset
=
DeviceIntPoint
:
:
new
(
(
virtual_surface_size
/
2
)
-
(
(
x0
+
x1
)
/
2
)
*
self
.
current_tile_size
.
width
(
virtual_surface_size
/
2
)
-
(
(
y0
+
y1
)
/
2
)
*
self
.
current_tile_size
.
height
)
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
}
}
if
new_tile_rect
!
=
self
.
tile_rect
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
let
mut
old_tiles
=
sub_slice
.
resize
(
new_tile_rect
)
;
if
!
old_tiles
.
is_empty
(
)
{
frame_state
.
composite_state
.
dirty_rects_are_valid
=
false
;
}
frame_state
.
composite_state
.
destroy_native_tiles
(
old_tiles
.
values_mut
(
)
frame_state
.
resource_cache
)
;
}
}
self
.
tile_bounds_p0
=
TileOffset
:
:
new
(
x0
y0
)
;
self
.
tile_bounds_p1
=
TileOffset
:
:
new
(
x1
y1
)
;
self
.
tile_rect
=
new_tile_rect
;
let
mut
world_culling_rect
=
WorldRect
:
:
zero
(
)
;
let
mut
ctx
=
TilePreUpdateContext
{
pic_to_world_mapper
background_color
:
self
.
background_color
global_screen_world_rect
:
frame_context
.
global_screen_world_rect
tile_size
:
self
.
tile_size
frame_id
:
self
.
frame_id
}
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
pre_update
(
&
ctx
)
;
if
tile
.
is_visible
{
world_culling_rect
=
world_culling_rect
.
union
(
&
tile
.
world_tile_rect
)
;
}
}
ctx
.
background_color
=
None
;
}
match
frame_context
.
config
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
if
let
Some
(
native_surface
)
=
sub_slice
.
native_surface
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
opaque
)
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
native_surface
.
alpha
)
;
}
}
for
(
_
external_surface
)
in
self
.
external_native_surface_cache
.
drain
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
external_surface
.
native_surface_id
)
}
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
TextureCache
{
.
.
}
.
.
}
)
=
tile
.
surface
{
tile
.
surface
=
None
;
tile
.
invalidate
(
None
InvalidationReason
:
:
CompositorKindChanged
)
;
}
}
}
}
}
world_culling_rect
}
fn
can_promote_to_surface
(
&
mut
self
flags
:
PrimitiveFlags
prim_clip_chain
:
&
ClipChainInstance
prim_spatial_node_index
:
SpatialNodeIndex
is_root_tile_cache
:
bool
sub_slice_index
:
usize
frame_context
:
&
FrameVisibilityContext
)
-
>
SurfacePromotionResult
{
if
!
flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
return
SurfacePromotionResult
:
:
Failed
;
}
if
sub_slice_index
=
=
MAX_COMPOSITOR_SURFACES
{
return
SurfacePromotionResult
:
:
Failed
;
}
if
prim_clip_chain
.
needs_mask
{
return
SurfacePromotionResult
:
:
Failed
;
}
if
!
is_root_tile_cache
{
return
SurfacePromotionResult
:
:
Failed
;
}
let
mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
prim_spatial_node_index
frame_context
.
global_screen_world_rect
&
frame_context
.
spatial_tree
)
;
let
transform
=
mapper
.
get_transform
(
)
;
if
!
transform
.
is_2d_scale_translation
(
)
{
return
SurfacePromotionResult
:
:
Failed
;
}
if
self
.
slice_flags
.
contains
(
SliceFlags
:
:
IS_ATOMIC
)
{
return
SurfacePromotionResult
:
:
Failed
;
}
SurfacePromotionResult
:
:
Success
}
fn
setup_compositor_surfaces_yuv
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
image_dependencies
:
&
[
ImageDependency
;
3
]
api_keys
:
&
[
ImageKey
;
3
]
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
gpu_cache
:
&
mut
GpuCache
image_rendering
:
ImageRendering
color_depth
:
ColorDepth
color_space
:
YuvRangedColorSpace
format
:
YuvFormat
)
-
>
bool
{
for
&
key
in
api_keys
{
if
key
!
=
ImageKey
:
:
DUMMY
{
resource_cache
.
request_image
(
ImageRequest
{
key
rendering
:
image_rendering
tile
:
None
}
gpu_cache
)
;
}
}
self
.
setup_compositor_surfaces_impl
(
sub_slice_index
prim_info
flags
local_prim_rect
prim_spatial_node_index
pic_coverage_rect
frame_context
ExternalSurfaceDependency
:
:
Yuv
{
image_dependencies
:
*
image_dependencies
color_space
format
channel_bit_depth
:
color_depth
.
bit_depth
(
)
}
api_keys
resource_cache
composite_state
image_rendering
true
)
}
fn
setup_compositor_surfaces_rgb
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
image_dependency
:
ImageDependency
api_key
:
ImageKey
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
gpu_cache
:
&
mut
GpuCache
image_rendering
:
ImageRendering
)
-
>
bool
{
let
mut
api_keys
=
[
ImageKey
:
:
DUMMY
;
3
]
;
api_keys
[
0
]
=
api_key
;
resource_cache
.
request_image
(
ImageRequest
{
key
:
api_key
rendering
:
image_rendering
tile
:
None
}
gpu_cache
)
;
let
is_opaque
=
resource_cache
.
get_image_properties
(
api_key
)
.
map_or
(
false
|
properties
|
properties
.
descriptor
.
is_opaque
(
)
)
;
self
.
setup_compositor_surfaces_impl
(
sub_slice_index
prim_info
flags
local_prim_rect
prim_spatial_node_index
pic_coverage_rect
frame_context
ExternalSurfaceDependency
:
:
Rgb
{
image_dependency
}
&
api_keys
resource_cache
composite_state
image_rendering
is_opaque
)
}
fn
setup_compositor_surfaces_impl
(
&
mut
self
sub_slice_index
:
usize
prim_info
:
&
mut
PrimitiveDependencyInfo
flags
:
PrimitiveFlags
local_prim_rect
:
LayoutRect
prim_spatial_node_index
:
SpatialNodeIndex
pic_coverage_rect
:
PictureRect
frame_context
:
&
FrameVisibilityContext
dependency
:
ExternalSurfaceDependency
api_keys
:
&
[
ImageKey
;
3
]
resource_cache
:
&
mut
ResourceCache
composite_state
:
&
mut
CompositeState
image_rendering
:
ImageRendering
is_opaque
:
bool
)
-
>
bool
{
let
map_local_to_surface
=
SpaceMapper
:
:
new_with_target
(
self
.
spatial_node_index
prim_spatial_node_index
self
.
local_rect
frame_context
.
spatial_tree
)
;
let
prim_rect
=
match
map_local_to_surface
.
map
(
&
local_prim_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
true
}
;
if
prim_rect
.
is_empty
(
)
{
return
true
;
}
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
let
world_clip_rect
=
pic_to_world_mapper
.
map
(
&
prim_info
.
prim_clip_box
)
.
expect
(
"
bug
:
unable
to
map
clip
to
world
space
"
)
;
let
is_visible
=
world_clip_rect
.
intersects
(
&
frame_context
.
global_screen_world_rect
)
;
if
!
is_visible
{
return
true
;
}
let
prim_offset
=
ScaleOffset
:
:
from_offset
(
local_prim_rect
.
min
.
to_vector
(
)
.
cast_unit
(
)
)
;
let
local_prim_to_device
=
get_relative_scale_offset
(
prim_spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
let
normalized_prim_to_device
=
prim_offset
.
accumulate
(
&
local_prim_to_device
)
;
let
local_to_surface
=
ScaleOffset
:
:
identity
(
)
;
let
surface_to_device
=
normalized_prim_to_device
;
let
compositor_transform_index
=
composite_state
.
register_transform
(
local_to_surface
surface_to_device
)
;
let
surface_size
=
composite_state
.
get_surface_rect
(
&
local_prim_rect
&
local_prim_rect
compositor_transform_index
)
.
size
(
)
;
let
clip_rect
=
(
world_clip_rect
*
frame_context
.
global_device_pixel_scale
)
.
round
(
)
;
if
surface_size
.
width
>
=
MAX_COMPOSITOR_SURFACES_SIZE
|
|
surface_size
.
height
>
=
MAX_COMPOSITOR_SURFACES_SIZE
{
return
false
;
}
let
external_image_id
=
if
flags
.
contains
(
PrimitiveFlags
:
:
SUPPORTS_EXTERNAL_COMPOSITOR_SURFACE
)
{
resource_cache
.
get_image_properties
(
api_keys
[
0
]
)
.
and_then
(
|
properties
|
properties
.
external_image
)
.
and_then
(
|
image
|
Some
(
image
.
id
)
)
}
else
{
None
}
;
let
(
native_surface_id
update_params
)
=
match
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
(
None
None
)
}
CompositorKind
:
:
Native
{
.
.
}
=
>
{
let
native_surface_size
=
surface_size
.
to_i32
(
)
;
let
key
=
ExternalNativeSurfaceKey
{
image_keys
:
*
api_keys
size
:
native_surface_size
is_external_surface
:
external_image_id
.
is_some
(
)
}
;
let
native_surface
=
self
.
external_native_surface_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
native_surface_id
=
match
external_image_id
{
Some
(
_external_image
)
=
>
{
resource_cache
.
create_compositor_external_surface
(
is_opaque
)
}
None
=
>
{
let
native_surface_id
=
resource_cache
.
create_compositor_surface
(
DeviceIntPoint
:
:
zero
(
)
native_surface_size
is_opaque
)
;
let
tile_id
=
NativeTileId
{
surface_id
:
native_surface_id
x
:
0
y
:
0
}
;
resource_cache
.
create_compositor_tile
(
tile_id
)
;
native_surface_id
}
}
;
ExternalNativeSurface
{
used_this_frame
:
true
native_surface_id
image_dependencies
:
[
ImageDependency
:
:
INVALID
;
3
]
}
}
)
;
native_surface
.
used_this_frame
=
true
;
let
update_params
=
match
external_image_id
{
Some
(
external_image
)
=
>
{
resource_cache
.
attach_compositor_external_image
(
native_surface
.
native_surface_id
external_image
)
;
None
}
None
=
>
{
match
dependency
{
ExternalSurfaceDependency
:
:
Yuv
{
image_dependencies
.
.
}
=
>
{
if
image_dependencies
=
=
native_surface
.
image_dependencies
{
None
}
else
{
Some
(
native_surface_size
)
}
}
ExternalSurfaceDependency
:
:
Rgb
{
image_dependency
.
.
}
=
>
{
if
image_dependency
=
=
native_surface
.
image_dependencies
[
0
]
{
None
}
else
{
Some
(
native_surface_size
)
}
}
}
}
}
;
(
Some
(
native_surface
.
native_surface_id
)
update_params
)
}
}
;
assert
!
(
sub_slice_index
<
self
.
sub_slices
.
len
(
)
-
1
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
sub_slice
.
compositor_surfaces
.
push
(
CompositorSurface
{
prohibited_rect
:
pic_coverage_rect
is_opaque
descriptor
:
ExternalSurfaceDescriptor
{
local_surface_size
:
local_prim_rect
.
size
(
)
local_rect
:
prim_rect
local_clip_rect
:
prim_info
.
prim_clip_box
dependency
image_rendering
clip_rect
transform_index
:
compositor_transform_index
z_id
:
ZBufferId
:
:
invalid
(
)
native_surface_id
update_params
}
}
)
;
true
}
pub
fn
push_surface
(
&
mut
self
estimated_local_rect
:
LayoutRect
surface_spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
{
if
self
.
current_surface_traversal_depth
=
=
0
&
&
self
.
sub_slices
.
len
(
)
>
1
{
let
map_local_to_surface
=
SpaceMapper
:
:
new_with_target
(
self
.
spatial_node_index
surface_spatial_node_index
self
.
local_rect
spatial_tree
)
;
if
let
Some
(
pic_rect
)
=
map_local_to_surface
.
map
(
&
estimated_local_rect
)
{
for
sub_slice
in
&
mut
self
.
sub_slices
{
let
mut
intersects_prohibited_region
=
false
;
for
surface
in
&
mut
sub_slice
.
compositor_surfaces
{
if
pic_rect
.
intersects
(
&
surface
.
prohibited_rect
)
{
surface
.
prohibited_rect
=
surface
.
prohibited_rect
.
union
(
&
pic_rect
)
;
intersects_prohibited_region
=
true
;
}
}
if
!
intersects_prohibited_region
{
break
;
}
}
}
}
self
.
current_surface_traversal_depth
+
=
1
;
}
pub
fn
pop_surface
(
&
mut
self
)
{
self
.
current_surface_traversal_depth
-
=
1
;
}
pub
fn
update_prim_dependencies
(
&
mut
self
prim_instance
:
&
mut
PrimitiveInstance
prim_spatial_node_index
:
SpatialNodeIndex
local_prim_rect
:
LayoutRect
frame_context
:
&
FrameVisibilityContext
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
pictures
:
&
[
PicturePrimitive
]
resource_cache
:
&
mut
ResourceCache
color_bindings
:
&
ColorBindingStorage
surface_stack
:
&
[
(
PictureIndex
SurfaceIndex
)
]
composite_state
:
&
mut
CompositeState
gpu_cache
:
&
mut
GpuCache
scratch
:
&
mut
PrimitiveScratchBuffer
is_root_tile_cache
:
bool
surfaces
:
&
mut
[
SurfaceInfo
]
)
{
profile_scope
!
(
"
update_prim_dependencies
"
)
;
let
prim_surface_index
=
surface_stack
.
last
(
)
.
unwrap
(
)
.
1
;
let
prim_clip_chain
=
&
prim_instance
.
vis
.
clip_chain
;
let
mut
surface
=
&
mut
surfaces
[
prim_surface_index
.
0
]
;
surface
.
clipped_local_rect
=
surface
.
clipped_local_rect
.
union
(
&
prim_clip_chain
.
pic_coverage_rect
)
;
let
on_picture_surface
=
prim_surface_index
=
=
self
.
surface_index
;
let
pic_coverage_rect
=
if
on_picture_surface
{
prim_clip_chain
.
pic_coverage_rect
}
else
{
let
mut
current_pic_coverage_rect
=
prim_clip_chain
.
pic_coverage_rect
;
let
mut
current_spatial_node_index
=
surfaces
[
prim_surface_index
.
0
]
.
surface_spatial_node_index
;
for
(
pic_index
surface_index
)
in
surface_stack
.
iter
(
)
.
rev
(
)
{
let
surface
=
&
surfaces
[
surface_index
.
0
]
;
let
pic
=
&
pictures
[
pic_index
.
0
]
;
let
map_local_to_surface
=
SpaceMapper
:
:
new_with_target
(
surface
.
surface_spatial_node_index
current_spatial_node_index
surface
.
unclipped_local_rect
frame_context
.
spatial_tree
)
;
current_pic_coverage_rect
=
match
map_local_to_surface
.
map
(
&
current_pic_coverage_rect
)
{
Some
(
rect
)
=
>
{
pic
.
composite_mode
.
as_ref
(
)
.
unwrap
(
)
.
get_coverage
(
surface
Some
(
rect
.
cast_unit
(
)
)
)
.
cast_unit
(
)
}
None
=
>
{
return
;
}
}
;
current_spatial_node_index
=
surface
.
surface_spatial_node_index
;
}
current_pic_coverage_rect
}
;
let
(
p0
p1
)
=
self
.
get_tile_coords_for_rect
(
&
pic_coverage_rect
)
;
if
p0
.
x
=
=
p1
.
x
|
|
p0
.
y
=
=
p1
.
y
{
return
;
}
let
mut
prim_info
=
PrimitiveDependencyInfo
:
:
new
(
prim_instance
.
uid
(
)
pic_coverage_rect
)
;
let
mut
sub_slice_index
=
self
.
sub_slices
.
len
(
)
-
1
;
if
sub_slice_index
>
0
{
for
(
i
sub_slice
)
in
self
.
sub_slices
.
iter_mut
(
)
.
enumerate
(
)
{
let
mut
intersects_prohibited_region
=
false
;
for
surface
in
&
mut
sub_slice
.
compositor_surfaces
{
if
pic_coverage_rect
.
intersects
(
&
surface
.
prohibited_rect
)
{
surface
.
prohibited_rect
=
surface
.
prohibited_rect
.
union
(
&
pic_coverage_rect
)
;
intersects_prohibited_region
=
true
;
}
}
if
!
intersects_prohibited_region
{
sub_slice_index
=
i
;
break
;
}
}
}
if
prim_spatial_node_index
!
=
self
.
spatial_node_index
{
prim_info
.
spatial_nodes
.
push
(
prim_spatial_node_index
)
;
}
let
clip_instances
=
&
clip_store
.
clip_node_instances
[
prim_clip_chain
.
clips_range
.
to_range
(
)
]
;
for
clip_instance
in
clip_instances
{
let
clip
=
&
data_stores
.
clip
[
clip_instance
.
handle
]
;
prim_info
.
clips
.
push
(
clip_instance
.
handle
.
uid
(
)
)
;
if
clip
.
item
.
spatial_node_index
!
=
self
.
spatial_node_index
&
&
!
prim_info
.
spatial_nodes
.
contains
(
&
clip
.
item
.
spatial_node_index
)
{
prim_info
.
spatial_nodes
.
push
(
clip
.
item
.
spatial_node_index
)
;
}
}
let
mut
backdrop_candidate
=
None
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
pictures
[
pic_index
.
0
]
;
if
let
Some
(
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Opacity
(
binding
_
)
)
)
=
pic
.
composite_mode
{
prim_info
.
opacity_bindings
.
push
(
binding
.
into
(
)
)
;
}
}
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
color_binding_index
.
.
}
=
>
{
let
color
=
match
data_stores
.
prim
[
data_handle
]
.
kind
{
PrimitiveTemplateKind
:
:
Rectangle
{
color
.
.
}
=
>
{
frame_context
.
scene_properties
.
resolve_color
(
&
color
)
}
_
=
>
unreachable
!
(
)
}
;
if
color
.
a
>
=
1
.
0
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
Some
(
BackdropKind
:
:
Color
{
color
}
)
backdrop_rect
:
pic_coverage_rect
}
)
;
}
if
color_binding_index
!
=
ColorBindingIndex
:
:
INVALID
{
prim_info
.
color_binding
=
Some
(
color_bindings
[
color_binding_index
]
.
into
(
)
)
;
}
}
PrimitiveInstanceKind
:
:
Image
{
data_handle
ref
mut
is_compositor_surface
.
.
}
=
>
{
let
image_key
=
&
data_stores
.
image
[
data_handle
]
;
let
image_data
=
&
image_key
.
kind
;
let
mut
promote_to_surface
=
false
;
match
self
.
can_promote_to_surface
(
image_key
.
common
.
flags
prim_clip_chain
prim_spatial_node_index
is_root_tile_cache
sub_slice_index
frame_context
)
{
SurfacePromotionResult
:
:
Failed
=
>
{
}
SurfacePromotionResult
:
:
Success
=
>
{
promote_to_surface
=
true
;
}
}
if
image_data
.
alpha_type
=
=
AlphaType
:
:
Alpha
{
promote_to_surface
=
false
;
}
if
let
Some
(
image_properties
)
=
resource_cache
.
get_image_properties
(
image_data
.
key
)
{
if
image_properties
.
descriptor
.
is_opaque
(
)
&
&
image_properties
.
tiling
.
is_none
(
)
&
&
image_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
&
&
image_data
.
color
.
a
>
=
1
.
0
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
if
promote_to_surface
{
promote_to_surface
=
self
.
setup_compositor_surfaces_rgb
(
sub_slice_index
&
mut
prim_info
image_key
.
common
.
flags
local_prim_rect
prim_spatial_node_index
pic_coverage_rect
frame_context
ImageDependency
{
key
:
image_data
.
key
generation
:
resource_cache
.
get_image_generation
(
image_data
.
key
)
}
image_data
.
key
resource_cache
composite_state
gpu_cache
image_data
.
image_rendering
)
;
}
*
is_compositor_surface
=
promote_to_surface
;
if
promote_to_surface
{
prim_instance
.
vis
.
state
=
VisibilityState
:
:
Culled
;
return
;
}
else
{
prim_info
.
images
.
push
(
ImageDependency
{
key
:
image_data
.
key
generation
:
resource_cache
.
get_image_generation
(
image_data
.
key
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
ref
mut
is_compositor_surface
.
.
}
=
>
{
let
prim_data
=
&
data_stores
.
yuv_image
[
data_handle
]
;
let
mut
promote_to_surface
=
match
self
.
can_promote_to_surface
(
prim_data
.
common
.
flags
prim_clip_chain
prim_spatial_node_index
is_root_tile_cache
sub_slice_index
frame_context
)
{
SurfacePromotionResult
:
:
Failed
=
>
false
SurfacePromotionResult
:
:
Success
=
>
true
}
;
if
promote_to_surface
{
let
mut
image_dependencies
=
[
ImageDependency
:
:
INVALID
;
3
]
;
for
(
key
dep
)
in
prim_data
.
kind
.
yuv_key
.
iter
(
)
.
cloned
(
)
.
zip
(
image_dependencies
.
iter_mut
(
)
)
{
*
dep
=
ImageDependency
{
key
generation
:
resource_cache
.
get_image_generation
(
key
)
}
}
promote_to_surface
=
self
.
setup_compositor_surfaces_yuv
(
sub_slice_index
&
mut
prim_info
prim_data
.
common
.
flags
local_prim_rect
prim_spatial_node_index
pic_coverage_rect
frame_context
&
image_dependencies
&
prim_data
.
kind
.
yuv_key
resource_cache
composite_state
gpu_cache
prim_data
.
kind
.
image_rendering
prim_data
.
kind
.
color_depth
prim_data
.
kind
.
color_space
.
with_range
(
prim_data
.
kind
.
color_range
)
prim_data
.
kind
.
format
)
;
}
*
is_compositor_surface
=
promote_to_surface
;
if
promote_to_surface
{
prim_instance
.
vis
.
state
=
VisibilityState
:
:
Culled
;
return
;
}
else
{
prim_info
.
images
.
extend
(
prim_data
.
kind
.
yuv_key
.
iter
(
)
.
map
(
|
key
|
{
ImageDependency
{
key
:
*
key
generation
:
resource_cache
.
get_image_generation
(
*
key
)
}
}
)
)
;
}
}
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
=
>
{
let
border_data
=
&
data_stores
.
image_border
[
data_handle
]
.
kind
;
prim_info
.
images
.
push
(
ImageDependency
{
key
:
border_data
.
request
.
key
generation
:
resource_cache
.
get_image_generation
(
border_data
.
request
.
key
)
}
)
;
}
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
=
>
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
Some
(
BackdropKind
:
:
Clear
)
backdrop_rect
:
pic_coverage_rect
}
)
;
}
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
CachedLinearGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
linear_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
ConicGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
conic_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
.
.
}
=
>
{
let
gradient_data
=
&
data_stores
.
radial_grad
[
data_handle
]
;
if
gradient_data
.
stops_opacity
.
is_opaque
&
&
gradient_data
.
tile_spacing
=
=
LayoutSize
:
:
zero
(
)
{
backdrop_candidate
=
Some
(
BackdropInfo
{
opaque_rect
:
pic_coverage_rect
spanning_opaque_color
:
None
kind
:
None
backdrop_rect
:
PictureRect
:
:
zero
(
)
}
)
;
}
}
PrimitiveInstanceKind
:
:
BackdropCapture
{
.
.
}
=
>
{
}
PrimitiveInstanceKind
:
:
BackdropRender
{
pic_index
.
.
}
=
>
{
if
!
pic_coverage_rect
.
is_empty
(
)
{
scratch
.
required_sub_graphs
.
insert
(
pic_index
)
;
debug_assert_eq
!
(
sub_slice_index
0
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
let
mut
surface_info
=
Vec
:
:
new
(
)
;
for
(
pic_index
surface_index
)
in
surface_stack
.
iter
(
)
.
rev
(
)
{
let
pic
=
&
pictures
[
pic_index
.
0
]
;
surface_info
.
push
(
(
pic
.
composite_mode
.
as_ref
(
)
.
unwrap
(
)
.
clone
(
)
*
surface_index
)
)
;
}
for
y
in
p0
.
y
.
.
p1
.
y
{
for
x
in
p0
.
x
.
.
p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
sub_graphs
.
push
(
(
pic_coverage_rect
surface_info
.
clone
(
)
)
)
;
}
}
self
.
deferred_dirty_tests
.
push
(
DeferredDirtyTest
{
tile_rect
:
TileRect
:
:
new
(
p0
p1
)
prim_rect
:
pic_coverage_rect
}
)
;
}
}
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
=
>
{
}
}
;
let
visible_local_rect
=
self
.
local_rect
.
intersection
(
&
self
.
screen_rect_in_pic_space
)
.
unwrap_or_default
(
)
;
if
pic_coverage_rect
.
intersects
(
&
visible_local_rect
)
{
self
.
found_prims_after_backdrop
=
true
;
}
let
mut
vis_flags
=
PrimitiveVisibilityFlags
:
:
empty
(
)
;
let
sub_slice
=
&
mut
self
.
sub_slices
[
sub_slice_index
]
;
if
let
Some
(
mut
backdrop_candidate
)
=
backdrop_candidate
{
match
backdrop_candidate
.
kind
{
Some
(
BackdropKind
:
:
Color
{
.
.
}
)
|
None
=
>
{
let
surface
=
&
mut
surfaces
[
prim_surface_index
.
0
]
;
let
is_same_coord_system
=
frame_context
.
spatial_tree
.
is_matching_coord_system
(
prim_spatial_node_index
surface
.
surface_spatial_node_index
)
;
if
is_same_coord_system
&
&
!
prim_clip_chain
.
needs_mask
&
&
prim_clip_chain
.
pic_coverage_rect
.
contains_box
(
&
surface
.
unclipped_local_rect
)
{
surface
.
is_opaque
=
true
;
}
}
Some
(
BackdropKind
:
:
Clear
)
=
>
{
}
}
let
is_suitable_backdrop
=
match
backdrop_candidate
.
kind
{
Some
(
BackdropKind
:
:
Clear
)
=
>
{
true
}
Some
(
BackdropKind
:
:
Color
{
.
.
}
)
|
None
=
>
{
let
same_coord_system
=
frame_context
.
spatial_tree
.
is_matching_coord_system
(
prim_spatial_node_index
self
.
spatial_node_index
)
;
same_coord_system
&
&
on_picture_surface
}
}
;
if
sub_slice_index
=
=
0
&
&
is_suitable_backdrop
&
&
sub_slice
.
compositor_surfaces
.
is_empty
(
)
{
if
prim_clip_chain
.
needs_mask
{
backdrop_candidate
.
opaque_rect
=
clip_store
.
get_inner_rect_for_clip_chain
(
prim_clip_chain
&
data_stores
.
clip
frame_context
.
spatial_tree
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
;
}
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
self
.
backdrop
.
opaque_rect
)
{
self
.
backdrop
.
opaque_rect
=
backdrop_candidate
.
opaque_rect
;
}
if
let
Some
(
kind
)
=
backdrop_candidate
.
kind
{
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
visible_local_rect
)
{
self
.
found_prims_after_backdrop
=
false
;
self
.
backdrop
.
kind
=
Some
(
kind
)
;
self
.
backdrop
.
backdrop_rect
=
backdrop_candidate
.
opaque_rect
;
if
let
BackdropKind
:
:
Color
{
color
}
=
kind
{
if
backdrop_candidate
.
opaque_rect
.
contains_box
(
&
self
.
local_rect
)
{
vis_flags
|
=
PrimitiveVisibilityFlags
:
:
IS_BACKDROP
;
self
.
backdrop
.
spanning_opaque_color
=
Some
(
color
)
;
}
}
}
}
}
}
for
spatial_node_index
in
&
prim_info
.
spatial_nodes
{
self
.
spatial_node_comparer
.
register_used_transform
(
*
spatial_node_index
self
.
frame_id
frame_context
.
spatial_tree
)
;
}
prim_info
.
clips
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
opacity_bindings
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
spatial_nodes
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
images
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
for
y
in
p0
.
y
.
.
p1
.
y
{
for
x
in
p0
.
x
.
.
p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
add_prim_dependency
(
&
prim_info
)
;
}
}
prim_instance
.
vis
.
state
=
VisibilityState
:
:
Visible
{
vis_flags
tile_rect
:
TileRect
:
:
new
(
p0
p1
)
sub_slice_index
:
SubSliceIndex
:
:
new
(
sub_slice_index
)
}
;
}
fn
print
(
&
self
)
{
let
mut
pt
=
PrintTree
:
:
new
(
"
Picture
Cache
"
)
;
pt
.
new_level
(
format
!
(
"
Slice
{
:
?
}
"
self
.
slice
)
)
;
pt
.
add_item
(
format
!
(
"
background_color
:
{
:
?
}
"
self
.
background_color
)
)
;
for
(
sub_slice_index
sub_slice
)
in
self
.
sub_slices
.
iter
(
)
.
enumerate
(
)
{
pt
.
new_level
(
format
!
(
"
SubSlice
{
:
?
}
"
sub_slice_index
)
)
;
for
y
in
self
.
tile_bounds_p0
.
y
.
.
self
.
tile_bounds_p1
.
y
{
for
x
in
self
.
tile_bounds_p0
.
x
.
.
self
.
tile_bounds_p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
&
sub_slice
.
tiles
[
&
key
]
;
tile
.
print
(
&
mut
pt
)
;
}
}
pt
.
end_level
(
)
;
}
pt
.
end_level
(
)
;
}
fn
calculate_subpixel_mode
(
&
self
)
-
>
SubpixelMode
{
let
has_opaque_bg_color
=
self
.
background_color
.
map_or
(
false
|
c
|
c
.
a
>
=
1
.
0
)
;
if
has_opaque_bg_color
{
return
SubpixelMode
:
:
Allow
;
}
if
self
.
backdrop
.
opaque_rect
.
is_empty
(
)
{
return
SubpixelMode
:
:
Deny
;
}
if
self
.
backdrop
.
opaque_rect
.
contains_box
(
&
self
.
local_rect
)
{
return
SubpixelMode
:
:
Allow
;
}
SubpixelMode
:
:
Conditional
{
allowed_rect
:
self
.
backdrop
.
opaque_rect
}
}
pub
fn
post_update
(
&
mut
self
frame_context
:
&
FrameVisibilityContext
frame_state
:
&
mut
FrameVisibilityState
)
{
assert
!
(
self
.
current_surface_traversal_depth
=
=
0
)
;
self
.
dirty_region
.
reset
(
self
.
spatial_node_index
)
;
self
.
subpixel_mode
=
self
.
calculate_subpixel_mode
(
)
;
self
.
transform_index
=
frame_state
.
composite_state
.
register_transform
(
self
.
local_to_surface
self
.
surface_to_device
)
;
let
map_pic_to_world
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
self
.
external_native_surface_cache
.
retain
(
|
_
surface
|
{
if
!
surface
.
used_this_frame
{
frame_state
.
composite_state
.
dirty_rects_are_valid
=
false
;
frame_state
.
resource_cache
.
destroy_compositor_surface
(
surface
.
native_surface_id
)
;
}
surface
.
used_this_frame
}
)
;
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
let
ctx
=
TileUpdateDirtyContext
{
pic_to_world_mapper
global_device_pixel_scale
:
frame_context
.
global_device_pixel_scale
opacity_bindings
:
&
self
.
opacity_bindings
color_bindings
:
&
self
.
color_bindings
local_rect
:
self
.
local_rect
invalidate_all
:
self
.
invalidate_all_tiles
}
;
let
mut
state
=
TileUpdateDirtyState
{
resource_cache
:
frame_state
.
resource_cache
composite_state
:
frame_state
.
composite_state
compare_cache
:
&
mut
self
.
compare_cache
spatial_node_comparer
:
&
mut
self
.
spatial_node_comparer
}
;
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
update_dirty_and_valid_rects
(
&
ctx
&
mut
state
frame_context
)
;
}
}
for
sub_slice
in
&
mut
self
.
sub_slices
{
for
dirty_test
in
self
.
deferred_dirty_tests
.
drain
(
.
.
)
{
let
mut
total_dirty_rect
=
PictureRect
:
:
zero
(
)
;
for
y
in
dirty_test
.
tile_rect
.
min
.
y
.
.
dirty_test
.
tile_rect
.
max
.
y
{
for
x
in
dirty_test
.
tile_rect
.
min
.
x
.
.
dirty_test
.
tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
total_dirty_rect
=
total_dirty_rect
.
union
(
&
tile
.
local_dirty_rect
)
;
}
}
if
total_dirty_rect
.
intersects
(
&
dirty_test
.
prim_rect
)
{
for
y
in
dirty_test
.
tile_rect
.
min
.
y
.
.
dirty_test
.
tile_rect
.
max
.
y
{
for
x
in
dirty_test
.
tile_rect
.
min
.
x
.
.
dirty_test
.
tile_rect
.
max
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
sub_slice
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
invalidate
(
Some
(
dirty_test
.
prim_rect
)
InvalidationReason
:
:
SurfaceContentChanged
)
;
}
}
}
}
}
let
mut
ctx
=
TilePostUpdateContext
{
local_clip_rect
:
self
.
local_clip_rect
backdrop
:
None
current_tile_size
:
self
.
current_tile_size
z_id
:
ZBufferId
:
:
invalid
(
)
}
;
let
mut
state
=
TilePostUpdateState
{
resource_cache
:
frame_state
.
resource_cache
composite_state
:
frame_state
.
composite_state
}
;
for
(
i
sub_slice
)
in
self
.
sub_slices
.
iter_mut
(
)
.
enumerate
(
)
.
rev
(
)
{
if
i
=
=
0
{
ctx
.
backdrop
=
Some
(
self
.
backdrop
)
;
}
for
compositor_surface
in
sub_slice
.
compositor_surfaces
.
iter_mut
(
)
.
rev
(
)
{
compositor_surface
.
descriptor
.
z_id
=
state
.
composite_state
.
z_generator
.
next
(
)
;
}
ctx
.
z_id
=
state
.
composite_state
.
z_generator
.
next
(
)
;
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
post_update
(
&
ctx
&
mut
state
frame_context
)
;
}
}
for
sub_slice
in
&
self
.
sub_slices
{
for
compositor_surface
in
&
sub_slice
.
compositor_surfaces
{
if
compositor_surface
.
is_opaque
{
let
local_surface_rect
=
compositor_surface
.
descriptor
.
local_rect
.
intersection
(
&
compositor_surface
.
descriptor
.
local_clip_rect
)
.
and_then
(
|
r
|
{
r
.
intersection
(
&
self
.
local_clip_rect
)
}
)
;
if
let
Some
(
local_surface_rect
)
=
local_surface_rect
{
let
world_surface_rect
=
map_pic_to_world
.
map
(
&
local_surface_rect
)
.
expect
(
"
bug
:
unable
to
map
external
surface
to
world
space
"
)
;
frame_state
.
composite_state
.
register_occluder
(
compositor_surface
.
descriptor
.
z_id
world_surface_rect
)
;
}
}
}
}
if
!
self
.
backdrop
.
opaque_rect
.
is_empty
(
)
{
let
z_id_backdrop
=
frame_state
.
composite_state
.
z_generator
.
next
(
)
;
let
backdrop_rect
=
self
.
backdrop
.
opaque_rect
.
intersection
(
&
self
.
local_rect
)
.
and_then
(
|
r
|
{
r
.
intersection
(
&
self
.
local_clip_rect
)
}
)
;
if
let
Some
(
backdrop_rect
)
=
backdrop_rect
{
let
world_backdrop_rect
=
map_pic_to_world
.
map
(
&
backdrop_rect
)
.
expect
(
"
bug
:
unable
to
map
backdrop
to
world
space
"
)
;
frame_state
.
composite_state
.
register_occluder
(
z_id_backdrop
world_backdrop_rect
)
;
}
}
}
}
pub
struct
PictureScratchBuffer
{
surface_stack
:
Vec
<
SurfaceIndex
>
}
impl
Default
for
PictureScratchBuffer
{
fn
default
(
)
-
>
Self
{
PictureScratchBuffer
{
surface_stack
:
Vec
:
:
new
(
)
}
}
}
impl
PictureScratchBuffer
{
pub
fn
begin_frame
(
&
mut
self
)
{
self
.
surface_stack
.
clear
(
)
;
}
pub
fn
recycle
(
&
mut
self
recycler
:
&
mut
Recycler
)
{
recycler
.
recycle_vec
(
&
mut
self
.
surface_stack
)
;
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SurfaceIndex
(
pub
usize
)
;
pub
struct
SurfaceInfo
{
pub
unclipped_local_rect
:
PictureRect
pub
clipped_local_rect
:
PictureRect
pub
is_opaque
:
bool
pub
clipping_rect
:
PictureRect
pub
map_local_to_surface
:
SpaceMapper
<
LayoutPixel
PicturePixel
>
pub
raster_spatial_node_index
:
SpatialNodeIndex
pub
surface_spatial_node_index
:
SpatialNodeIndex
pub
device_pixel_scale
:
DevicePixelScale
pub
world_scale_factors
:
(
f32
f32
)
pub
local_scale
:
(
f32
f32
)
pub
allow_snapping
:
bool
}
impl
SurfaceInfo
{
pub
fn
new
(
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
world_rect
:
WorldRect
spatial_tree
:
&
SpatialTree
device_pixel_scale
:
DevicePixelScale
world_scale_factors
:
(
f32
f32
)
local_scale
:
(
f32
f32
)
allow_snapping
:
bool
)
-
>
Self
{
let
map_surface_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
surface_spatial_node_index
world_rect
spatial_tree
)
;
let
pic_bounds
=
map_surface_to_world
.
unmap
(
&
map_surface_to_world
.
bounds
)
.
unwrap_or_else
(
PictureRect
:
:
max_rect
)
;
let
map_local_to_surface
=
SpaceMapper
:
:
new
(
surface_spatial_node_index
pic_bounds
)
;
SurfaceInfo
{
unclipped_local_rect
:
PictureRect
:
:
zero
(
)
clipped_local_rect
:
PictureRect
:
:
zero
(
)
is_opaque
:
false
clipping_rect
:
PictureRect
:
:
zero
(
)
map_local_to_surface
raster_spatial_node_index
surface_spatial_node_index
device_pixel_scale
world_scale_factors
local_scale
allow_snapping
}
}
pub
fn
clamp_blur_radius
(
&
self
x_blur_radius
:
f32
y_blur_radius
:
f32
)
-
>
(
f32
f32
)
{
let
sx_blur_radius
=
x_blur_radius
*
self
.
local_scale
.
0
;
let
sy_blur_radius
=
y_blur_radius
*
self
.
local_scale
.
1
;
let
largest_scaled_blur_radius
=
f32
:
:
max
(
sx_blur_radius
*
self
.
world_scale_factors
.
0
sy_blur_radius
*
self
.
world_scale_factors
.
1
)
;
if
largest_scaled_blur_radius
>
MAX_BLUR_RADIUS
{
let
sf
=
MAX_BLUR_RADIUS
/
largest_scaled_blur_radius
;
(
x_blur_radius
*
sf
y_blur_radius
*
sf
)
}
else
{
(
x_blur_radius
y_blur_radius
)
}
}
pub
fn
map_to_device_rect
(
&
self
local_rect
:
&
PictureRect
spatial_tree
:
&
SpatialTree
)
-
>
DeviceRect
{
let
raster_rect
=
if
self
.
raster_spatial_node_index
!
=
self
.
surface_spatial_node_index
{
assert_eq
!
(
self
.
device_pixel_scale
.
0
1
.
0
)
;
let
local_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
self
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
local_to_world
.
map
(
&
local_rect
)
.
unwrap
(
)
}
else
{
local_rect
.
cast_unit
(
)
}
;
raster_rect
*
self
.
device_pixel_scale
}
pub
fn
get_surface_rect
(
&
self
local_rect
:
&
PictureRect
spatial_tree
:
&
SpatialTree
)
-
>
Option
<
DeviceRect
>
{
let
local_rect
=
match
local_rect
.
intersection
(
&
self
.
clipping_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
raster_rect
=
if
self
.
raster_spatial_node_index
!
=
self
.
surface_spatial_node_index
{
assert_eq
!
(
self
.
device_pixel_scale
.
0
1
.
0
)
;
let
local_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
self
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
local_to_world
.
map
(
&
local_rect
)
.
unwrap
(
)
}
else
{
local_rect
.
cast_unit
(
)
}
;
Some
(
(
raster_rect
*
self
.
device_pixel_scale
)
.
round_out
(
)
)
}
}
struct
SurfaceAllocInfo
{
task_size
:
DeviceIntSize
needs_scissor_rect
:
bool
clipped
:
DeviceRect
unclipped
:
DeviceRect
clipped_local
:
PictureRect
uv_rect_kind
:
UvRectKind
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
RasterConfig
{
pub
composite_mode
:
PictureCompositeMode
pub
surface_index
:
SurfaceIndex
}
bitflags
!
{
/
/
/
A
set
of
flags
describing
why
a
picture
may
need
a
backing
surface
.
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
BlitReason
:
u32
{
/
/
/
Mix
-
blend
-
mode
on
a
child
that
requires
isolation
.
const
ISOLATE
=
1
;
/
/
/
Clip
node
that
_might_
require
a
surface
.
const
CLIP
=
2
;
/
/
/
Preserve
-
3D
requires
a
surface
for
plane
-
splitting
.
const
PRESERVE3D
=
4
;
/
/
/
A
backdrop
that
is
reused
which
requires
a
surface
.
const
BACKDROP
=
8
;
}
}
#
[
allow
(
dead_code
)
]
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
enum
PictureCompositeMode
{
MixBlend
(
MixBlendMode
)
Filter
(
Filter
)
ComponentTransferFilter
(
FilterDataHandle
)
Blit
(
BlitReason
)
TileCache
{
slice_id
:
SliceId
}
SvgFilter
(
Vec
<
FilterPrimitive
>
Vec
<
SFilterData
>
)
IntermediateSurface
}
impl
PictureCompositeMode
{
pub
fn
get_rect
(
&
self
surface
:
&
SurfaceInfo
sub_rect
:
Option
<
LayoutRect
>
)
-
>
LayoutRect
{
let
surface_rect
=
match
sub_rect
{
Some
(
sub_rect
)
=
>
sub_rect
None
=
>
surface
.
clipped_local_rect
.
cast_unit
(
)
}
;
match
self
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
width
height
should_inflate
}
)
=
>
{
if
*
should_inflate
{
let
(
width_factor
height_factor
)
=
surface
.
clamp_blur_radius
(
*
width
*
height
)
;
surface_rect
.
inflate
(
width_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
height_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
)
}
else
{
surface_rect
}
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
mut
max_blur_radius
=
0
.
0
;
for
shadow
in
shadows
{
max_blur_radius
=
f32
:
:
max
(
max_blur_radius
shadow
.
blur_radius
)
;
}
let
(
max_blur_radius_x
max_blur_radius_y
)
=
surface
.
clamp_blur_radius
(
max_blur_radius
max_blur_radius
)
;
let
blur_inflation_x
=
max_blur_radius_x
*
BLUR_SAMPLE_SCALE
;
let
blur_inflation_y
=
max_blur_radius_y
*
BLUR_SAMPLE_SCALE
;
surface_rect
.
inflate
(
blur_inflation_x
blur_inflation_y
)
}
PictureCompositeMode
:
:
SvgFilter
(
primitives
_
)
=
>
{
let
mut
result_rect
=
surface_rect
;
let
mut
output_rects
=
Vec
:
:
with_capacity
(
primitives
.
len
(
)
)
;
for
(
cur_index
primitive
)
in
primitives
.
iter
(
)
.
enumerate
(
)
{
let
output_rect
=
match
primitive
.
kind
{
FilterPrimitiveKind
:
:
Blur
(
ref
primitive
)
=
>
{
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
let
width_factor
=
primitive
.
width
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
let
height_factor
=
primitive
.
height
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
input
.
inflate
(
width_factor
height_factor
)
}
FilterPrimitiveKind
:
:
DropShadow
(
ref
primitive
)
=
>
{
let
inflation_factor
=
primitive
.
shadow
.
blur_radius
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
;
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
let
shadow_rect
=
input
.
inflate
(
inflation_factor
inflation_factor
)
;
input
.
union
(
&
shadow_rect
.
translate
(
primitive
.
shadow
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
)
}
FilterPrimitiveKind
:
:
Blend
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
)
}
FilterPrimitiveKind
:
:
Composite
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
)
}
FilterPrimitiveKind
:
:
Identity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
Opacity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
ColorMatrix
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
ComponentTransfer
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
Offset
(
ref
primitive
)
=
>
{
let
input_rect
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
input_rect
.
translate
(
primitive
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
}
FilterPrimitiveKind
:
:
Flood
(
.
.
)
=
>
surface_rect
}
;
output_rects
.
push
(
output_rect
)
;
result_rect
=
result_rect
.
union
(
&
output_rect
)
;
}
result_rect
}
_
=
>
{
surface_rect
}
}
}
pub
fn
get_coverage
(
&
self
surface
:
&
SurfaceInfo
sub_rect
:
Option
<
LayoutRect
>
)
-
>
LayoutRect
{
let
surface_rect
=
match
sub_rect
{
Some
(
sub_rect
)
=
>
sub_rect
None
=
>
surface
.
clipped_local_rect
.
cast_unit
(
)
}
;
match
self
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
width
height
should_inflate
}
)
=
>
{
if
*
should_inflate
{
let
(
width_factor
height_factor
)
=
surface
.
clamp_blur_radius
(
*
width
*
height
)
;
surface_rect
.
inflate
(
width_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
height_factor
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
)
}
else
{
surface_rect
}
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
mut
rect
=
surface_rect
;
for
shadow
in
shadows
{
let
(
blur_radius_x
blur_radius_y
)
=
surface
.
clamp_blur_radius
(
shadow
.
blur_radius
shadow
.
blur_radius
)
;
let
blur_inflation_x
=
blur_radius_x
*
BLUR_SAMPLE_SCALE
;
let
blur_inflation_y
=
blur_radius_y
*
BLUR_SAMPLE_SCALE
;
let
shadow_rect
=
surface_rect
.
translate
(
shadow
.
offset
)
.
inflate
(
blur_inflation_x
blur_inflation_y
)
;
rect
=
rect
.
union
(
&
shadow_rect
)
;
}
rect
}
PictureCompositeMode
:
:
SvgFilter
(
primitives
_
)
=
>
{
let
mut
result_rect
=
surface_rect
;
let
mut
output_rects
=
Vec
:
:
with_capacity
(
primitives
.
len
(
)
)
;
for
(
cur_index
primitive
)
in
primitives
.
iter
(
)
.
enumerate
(
)
{
let
output_rect
=
match
primitive
.
kind
{
FilterPrimitiveKind
:
:
Blur
(
ref
primitive
)
=
>
{
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
let
width_factor
=
primitive
.
width
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
let
height_factor
=
primitive
.
height
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
input
.
inflate
(
width_factor
height_factor
)
}
FilterPrimitiveKind
:
:
DropShadow
(
ref
primitive
)
=
>
{
let
inflation_factor
=
primitive
.
shadow
.
blur_radius
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
;
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
let
shadow_rect
=
input
.
inflate
(
inflation_factor
inflation_factor
)
;
input
.
union
(
&
shadow_rect
.
translate
(
primitive
.
shadow
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
)
}
FilterPrimitiveKind
:
:
Blend
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
)
}
FilterPrimitiveKind
:
:
Composite
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
)
}
FilterPrimitiveKind
:
:
Identity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
Opacity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
ColorMatrix
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
ComponentTransfer
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
FilterPrimitiveKind
:
:
Offset
(
ref
primitive
)
=
>
{
let
input_rect
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
surface_rect
)
;
input_rect
.
translate
(
primitive
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
}
FilterPrimitiveKind
:
:
Flood
(
.
.
)
=
>
surface_rect
}
;
output_rects
.
push
(
output_rect
)
;
result_rect
=
result_rect
.
union
(
&
output_rect
)
;
}
result_rect
}
_
=
>
{
surface_rect
}
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
enum
Picture3DContext
<
C
>
{
Out
In
{
root_data
:
Option
<
Vec
<
C
>
>
ancestor_index
:
SpatialNodeIndex
plane_splitter_index
:
PlaneSplitterIndex
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
OrderedPictureChild
{
pub
anchor
:
PlaneSplitAnchor
pub
gpu_address
:
GpuCacheAddress
}
bitflags
!
{
/
/
/
A
set
of
flags
describing
why
a
picture
may
need
a
backing
surface
.
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
ClusterFlags
:
u32
{
/
/
/
Whether
this
cluster
is
visible
when
the
position
node
is
a
backface
.
const
IS_BACKFACE_VISIBLE
=
1
;
/
/
/
This
flag
is
set
during
the
first
pass
picture
traversal
depending
on
whether
/
/
/
the
cluster
is
visible
or
not
.
It
'
s
read
during
the
second
pass
when
primitives
/
/
/
consult
their
owning
clusters
to
see
if
the
primitive
itself
is
visible
.
const
IS_VISIBLE
=
2
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PrimitiveCluster
{
pub
spatial_node_index
:
SpatialNodeIndex
bounding_rect
:
LayoutRect
pub
opaque_rect
:
LayoutRect
pub
prim_range
:
Range
<
usize
>
pub
flags
:
ClusterFlags
}
impl
PrimitiveCluster
{
fn
new
(
spatial_node_index
:
SpatialNodeIndex
flags
:
ClusterFlags
first_instance_index
:
usize
)
-
>
Self
{
PrimitiveCluster
{
bounding_rect
:
LayoutRect
:
:
zero
(
)
opaque_rect
:
LayoutRect
:
:
zero
(
)
spatial_node_index
flags
prim_range
:
first_instance_index
.
.
first_instance_index
}
}
pub
fn
is_compatible
(
&
self
spatial_node_index
:
SpatialNodeIndex
flags
:
ClusterFlags
instance_index
:
usize
)
-
>
bool
{
self
.
flags
=
=
flags
&
&
self
.
spatial_node_index
=
=
spatial_node_index
&
&
instance_index
=
=
self
.
prim_range
.
end
}
pub
fn
prim_range
(
&
self
)
-
>
Range
<
usize
>
{
self
.
prim_range
.
clone
(
)
}
fn
add_instance
(
&
mut
self
culling_rect
:
&
LayoutRect
instance_index
:
usize
)
{
debug_assert_eq
!
(
instance_index
self
.
prim_range
.
end
)
;
self
.
bounding_rect
=
self
.
bounding_rect
.
union
(
culling_rect
)
;
self
.
prim_range
.
end
+
=
1
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PrimitiveList
{
pub
clusters
:
Vec
<
PrimitiveCluster
>
pub
child_pictures
:
Vec
<
PictureIndex
>
pub
compositor_surface_count
:
usize
}
impl
PrimitiveList
{
pub
fn
empty
(
)
-
>
Self
{
PrimitiveList
{
clusters
:
Vec
:
:
new
(
)
child_pictures
:
Vec
:
:
new
(
)
compositor_surface_count
:
0
}
}
pub
fn
merge
(
&
mut
self
other
:
PrimitiveList
)
{
self
.
clusters
.
extend
(
other
.
clusters
)
;
self
.
child_pictures
.
extend
(
other
.
child_pictures
)
;
self
.
compositor_surface_count
+
=
other
.
compositor_surface_count
;
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
prim_instances
:
&
mut
Vec
<
PrimitiveInstance
>
clip_tree_builder
:
&
ClipTreeBuilder
)
{
let
mut
flags
=
ClusterFlags
:
:
empty
(
)
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
self
.
child_pictures
.
push
(
pic_index
)
;
}
_
=
>
{
}
}
if
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
{
flags
.
insert
(
ClusterFlags
:
:
IS_BACKFACE_VISIBLE
)
;
}
if
prim_flags
.
contains
(
PrimitiveFlags
:
:
PREFER_COMPOSITOR_SURFACE
)
{
self
.
compositor_surface_count
+
=
1
;
}
let
clip_leaf
=
clip_tree_builder
.
get_leaf
(
prim_instance
.
clip_leaf_id
)
;
let
culling_rect
=
clip_leaf
.
local_clip_rect
.
intersection
(
&
prim_rect
)
.
unwrap_or_else
(
LayoutRect
:
:
zero
)
;
let
instance_index
=
prim_instances
.
len
(
)
;
prim_instances
.
push
(
prim_instance
)
;
if
let
Some
(
cluster
)
=
self
.
clusters
.
last_mut
(
)
{
if
cluster
.
is_compatible
(
spatial_node_index
flags
instance_index
)
{
cluster
.
add_instance
(
&
culling_rect
instance_index
)
;
return
;
}
}
let
clusters_len
=
self
.
clusters
.
len
(
)
;
if
clusters_len
=
=
self
.
clusters
.
capacity
(
)
{
let
next_alloc
=
match
clusters_len
{
1
.
.
=
15
=
>
16
-
clusters_len
16
.
.
=
127
=
>
128
-
clusters_len
_
=
>
clusters_len
*
2
}
;
self
.
clusters
.
reserve
(
next_alloc
)
;
}
let
mut
cluster
=
PrimitiveCluster
:
:
new
(
spatial_node_index
flags
instance_index
)
;
cluster
.
add_instance
(
&
culling_rect
instance_index
)
;
self
.
clusters
.
push
(
cluster
)
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
clusters
.
is_empty
(
)
}
}
bitflags
!
{
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
/
/
/
Flags
describing
properties
for
a
given
PicturePrimitive
pub
struct
PictureFlags
:
u8
{
/
/
/
This
picture
is
a
resolve
target
(
doesn
'
t
actually
render
content
itself
/
/
/
will
have
content
copied
in
to
it
)
const
IS_RESOLVE_TARGET
=
1
<
<
0
;
/
/
/
This
picture
establishes
a
sub
-
graph
which
affects
how
SurfaceBuilder
will
/
/
/
set
up
dependencies
in
the
render
task
graph
const
IS_SUB_GRAPH
=
1
<
<
1
;
/
/
/
If
set
this
picture
should
not
apply
snapping
via
changing
the
raster
root
const
DISABLE_SNAPPING
=
1
<
<
2
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PicturePrimitive
{
pub
prim_list
:
PrimitiveList
pub
is_backface_visible
:
bool
pub
primary_render_task_id
:
Option
<
RenderTaskId
>
pub
secondary_render_task_id
:
Option
<
RenderTaskId
>
pub
composite_mode
:
Option
<
PictureCompositeMode
>
pub
raster_config
:
Option
<
RasterConfig
>
pub
context_3d
:
Picture3DContext
<
OrderedPictureChild
>
pub
extra_gpu_data_handles
:
SmallVec
<
[
GpuCacheHandle
;
1
]
>
pub
spatial_node_index
:
SpatialNodeIndex
pub
prev_local_rect
:
LayoutRect
pub
segments_are_valid
:
bool
pub
is_opaque
:
bool
pub
raster_space
:
RasterSpace
pub
flags
:
PictureFlags
}
impl
PicturePrimitive
{
pub
fn
print
<
T
:
PrintTreePrinter
>
(
&
self
pictures
:
&
[
Self
]
self_index
:
PictureIndex
pt
:
&
mut
T
)
{
pt
.
new_level
(
format
!
(
"
{
:
?
}
"
self_index
)
)
;
pt
.
add_item
(
format
!
(
"
cluster_count
:
{
:
?
}
"
self
.
prim_list
.
clusters
.
len
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
spatial_node_index
:
{
:
?
}
"
self
.
spatial_node_index
)
)
;
pt
.
add_item
(
format
!
(
"
raster_config
:
{
:
?
}
"
self
.
raster_config
)
)
;
pt
.
add_item
(
format
!
(
"
composite_mode
:
{
:
?
}
"
self
.
composite_mode
)
)
;
pt
.
add_item
(
format
!
(
"
flags
:
{
:
?
}
"
self
.
flags
)
)
;
for
child_pic_index
in
&
self
.
prim_list
.
child_pictures
{
pictures
[
child_pic_index
.
0
]
.
print
(
pictures
*
child_pic_index
pt
)
;
}
pt
.
end_level
(
)
;
}
pub
fn
can_use_segments
(
&
self
)
-
>
bool
{
match
self
.
raster_config
{
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
MixBlend
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Filter
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
TileCache
{
.
.
}
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
IntermediateSurface
.
.
}
)
|
None
=
>
{
false
}
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Blit
(
reason
)
.
.
}
)
=
>
{
reason
=
=
BlitReason
:
:
CLIP
}
}
}
fn
resolve_scene_properties
(
&
mut
self
properties
:
&
SceneProperties
)
{
match
self
.
composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
ref
mut
filter
)
)
=
>
{
match
*
filter
{
Filter
:
:
Opacity
(
ref
binding
ref
mut
value
)
=
>
{
*
value
=
properties
.
resolve_float
(
binding
)
;
}
_
=
>
{
}
}
}
_
=
>
{
}
}
}
pub
fn
is_visible
(
&
self
spatial_tree
:
&
SpatialTree
)
-
>
bool
{
if
let
Some
(
PictureCompositeMode
:
:
Filter
(
ref
filter
)
)
=
self
.
composite_mode
{
if
!
filter
.
is_visible
(
)
{
return
false
;
}
}
if
!
self
.
is_backface_visible
{
if
let
Picture3DContext
:
:
Out
=
self
.
context_3d
{
match
spatial_tree
.
get_local_visible_face
(
self
.
spatial_node_index
)
{
VisibleFace
:
:
Front
=
>
{
}
VisibleFace
:
:
Back
=
>
return
false
}
}
}
true
}
pub
fn
new_image
(
composite_mode
:
Option
<
PictureCompositeMode
>
context_3d
:
Picture3DContext
<
OrderedPictureChild
>
prim_flags
:
PrimitiveFlags
prim_list
:
PrimitiveList
spatial_node_index
:
SpatialNodeIndex
raster_space
:
RasterSpace
flags
:
PictureFlags
)
-
>
Self
{
PicturePrimitive
{
prim_list
primary_render_task_id
:
None
secondary_render_task_id
:
None
composite_mode
raster_config
:
None
context_3d
extra_gpu_data_handles
:
SmallVec
:
:
new
(
)
is_backface_visible
:
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
spatial_node_index
prev_local_rect
:
LayoutRect
:
:
zero
(
)
segments_are_valid
:
false
is_opaque
:
false
raster_space
flags
}
}
pub
fn
take_context
(
&
mut
self
pic_index
:
PictureIndex
parent_surface_index
:
Option
<
SurfaceIndex
>
parent_subpixel_mode
:
SubpixelMode
frame_state
:
&
mut
FrameBuildingState
frame_context
:
&
FrameBuildingContext
scratch
:
&
mut
PrimitiveScratchBuffer
tile_caches
:
&
mut
FastHashMap
<
SliceId
Box
<
TileCacheInstance
>
>
)
-
>
Option
<
(
PictureContext
PictureState
PrimitiveList
)
>
{
self
.
primary_render_task_id
=
None
;
self
.
secondary_render_task_id
=
None
;
if
!
self
.
is_visible
(
frame_context
.
spatial_tree
)
{
return
None
;
}
profile_scope
!
(
"
take_context
"
)
;
let
surface_index
=
match
self
.
raster_config
{
Some
(
ref
raster_config
)
=
>
raster_config
.
surface_index
None
=
>
parent_surface_index
.
expect
(
"
bug
:
no
parent
"
)
}
;
let
surface_spatial_node_index
=
frame_state
.
surfaces
[
surface_index
.
0
]
.
surface_spatial_node_index
;
let
map_pic_to_world
=
SpaceMapper
:
:
new_with_target
(
frame_context
.
root_spatial_node_index
surface_spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
spatial_tree
)
;
let
pic_bounds
=
map_pic_to_world
.
unmap
(
&
map_pic_to_world
.
bounds
)
.
unwrap_or_else
(
PictureRect
:
:
max_rect
)
;
let
map_local_to_pic
=
SpaceMapper
:
:
new
(
surface_spatial_node_index
pic_bounds
)
;
match
self
.
raster_config
{
Some
(
RasterConfig
{
surface_index
composite_mode
:
PictureCompositeMode
:
:
TileCache
{
slice_id
}
.
.
}
)
=
>
{
let
tile_cache
=
tile_caches
.
get_mut
(
&
slice_id
)
.
unwrap
(
)
;
let
mut
debug_info
=
SliceDebugInfo
:
:
new
(
)
;
let
mut
surface_render_tasks
=
FastHashMap
:
:
default
(
)
;
let
mut
surface_dirty_rects
=
Vec
:
:
new
(
)
;
let
mut
surface_local_dirty_rect
=
PictureRect
:
:
zero
(
)
;
let
device_pixel_scale
=
frame_state
.
surfaces
[
surface_index
.
0
]
.
device_pixel_scale
;
let
mut
at_least_one_tile_visible
=
false
;
let
world_clip_rect
=
map_pic_to_world
.
map
(
&
tile_cache
.
local_clip_rect
)
.
expect
(
"
bug
:
unable
to
map
clip
rect
"
)
.
round
(
)
;
let
device_clip_rect
=
(
world_clip_rect
*
frame_context
.
global_device_pixel_scale
)
.
round
(
)
;
for
(
sub_slice_index
sub_slice
)
in
tile_cache
.
sub_slices
.
iter_mut
(
)
.
enumerate
(
)
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
if
tile
.
is_visible
{
let
world_draw_rect
=
world_clip_rect
.
intersection
(
&
tile
.
world_valid_rect
)
;
match
world_draw_rect
{
Some
(
world_draw_rect
)
=
>
{
if
tile_cache
.
spatial_node_index
=
=
frame_context
.
root_spatial_node_index
&
&
frame_state
.
composite_state
.
occluders
.
is_tile_occluded
(
tile
.
z_id
world_draw_rect
)
{
let
surface
=
tile
.
surface
.
as_mut
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
if
let
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
id
.
.
}
.
.
}
=
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
frame_state
.
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
tile
.
is_visible
=
false
;
if
frame_context
.
fb_config
.
testing
{
debug_info
.
tiles
.
insert
(
tile
.
tile_offset
TileDebugInfo
:
:
Occluded
)
;
}
continue
;
}
}
None
=
>
{
tile
.
is_visible
=
false
;
}
}
}
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
.
.
}
)
=
tile
.
surface
.
as_ref
(
)
{
if
let
SurfaceTextureDescriptor
:
:
TextureCache
{
handle
:
Some
(
handle
)
.
.
}
=
descriptor
{
frame_state
.
resource_cache
.
picture_textures
.
request
(
handle
frame_state
.
gpu_cache
)
;
}
}
if
!
tile
.
is_visible
{
if
frame_context
.
fb_config
.
testing
{
debug_info
.
tiles
.
insert
(
tile
.
tile_offset
TileDebugInfo
:
:
Culled
)
;
}
continue
;
}
at_least_one_tile_visible
=
true
;
if
frame_context
.
debug_flags
.
contains
(
DebugFlags
:
:
PICTURE_CACHING_DBG
)
{
tile
.
root
.
draw_debug_rects
(
&
map_pic_to_world
tile
.
is_opaque
tile
.
current_descriptor
.
local_valid_rect
scratch
frame_context
.
global_device_pixel_scale
)
;
let
label_offset
=
DeviceVector2D
:
:
new
(
20
.
0
+
sub_slice_index
as
f32
*
20
.
0
30
.
0
+
sub_slice_index
as
f32
*
20
.
0
)
;
let
tile_device_rect
=
tile
.
world_tile_rect
*
frame_context
.
global_device_pixel_scale
;
if
tile_device_rect
.
height
(
)
>
=
label_offset
.
y
{
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
scratch
.
push_debug_string
(
tile_device_rect
.
min
+
label_offset
debug_colors
:
:
RED
format
!
(
"
{
:
?
}
:
s
=
{
}
is_opaque
=
{
}
surface
=
{
}
sub
=
{
}
"
tile
.
id
tile_cache
.
slice
tile
.
is_opaque
surface
.
kind
(
)
sub_slice_index
)
)
;
}
}
if
let
TileSurface
:
:
Texture
{
descriptor
.
.
}
=
tile
.
surface
.
as_mut
(
)
.
unwrap
(
)
{
match
descriptor
{
SurfaceTextureDescriptor
:
:
TextureCache
{
ref
handle
.
.
}
=
>
{
let
exists
=
handle
.
as_ref
(
)
.
map_or
(
false
|
handle
|
frame_state
.
resource_cache
.
picture_textures
.
entry_exists
(
handle
)
)
;
if
exists
{
frame_state
.
resource_cache
.
picture_textures
.
request
(
handle
.
as_ref
(
)
.
unwrap
(
)
frame_state
.
gpu_cache
)
;
}
else
{
tile
.
invalidate
(
None
InvalidationReason
:
:
NoTexture
)
;
}
}
SurfaceTextureDescriptor
:
:
Native
{
id
.
.
}
=
>
{
if
id
.
is_none
(
)
{
tile
.
invalidate
(
None
InvalidationReason
:
:
NoSurface
)
;
}
}
}
}
tile
.
local_dirty_rect
=
tile
.
local_dirty_rect
.
intersection
(
&
tile
.
current_descriptor
.
local_valid_rect
)
.
unwrap_or_else
(
PictureRect
:
:
zero
)
;
surface_local_dirty_rect
=
surface_local_dirty_rect
.
union
(
&
tile
.
local_dirty_rect
)
;
let
world_dirty_rect
=
map_pic_to_world
.
map
(
&
tile
.
local_dirty_rect
)
.
expect
(
"
bug
"
)
;
let
device_rect
=
(
tile
.
world_tile_rect
*
frame_context
.
global_device_pixel_scale
)
.
round
(
)
;
tile
.
device_dirty_rect
=
(
world_dirty_rect
*
frame_context
.
global_device_pixel_scale
)
.
round_out
(
)
.
intersection
(
&
device_rect
)
.
unwrap_or_else
(
DeviceRect
:
:
zero
)
;
if
tile
.
is_valid
{
if
frame_context
.
fb_config
.
testing
{
debug_info
.
tiles
.
insert
(
tile
.
tile_offset
TileDebugInfo
:
:
Valid
)
;
}
}
else
{
tile_cache
.
dirty_region
.
add_dirty_region
(
tile
.
local_dirty_rect
frame_context
.
spatial_tree
)
;
if
let
TileSurface
:
:
Texture
{
ref
mut
descriptor
}
=
tile
.
surface
.
as_mut
(
)
.
unwrap
(
)
{
match
descriptor
{
SurfaceTextureDescriptor
:
:
TextureCache
{
ref
mut
handle
}
=
>
{
frame_state
.
resource_cache
.
picture_textures
.
update
(
tile_cache
.
current_tile_size
handle
frame_state
.
gpu_cache
&
mut
frame_state
.
resource_cache
.
texture_cache
.
next_id
&
mut
frame_state
.
resource_cache
.
texture_cache
.
pending_updates
)
;
}
SurfaceTextureDescriptor
:
:
Native
{
id
}
=
>
{
if
id
.
is_none
(
)
{
if
sub_slice
.
native_surface
.
is_none
(
)
{
let
opaque
=
frame_state
.
resource_cache
.
create_compositor_surface
(
tile_cache
.
virtual_offset
tile_cache
.
current_tile_size
true
)
;
let
alpha
=
frame_state
.
resource_cache
.
create_compositor_surface
(
tile_cache
.
virtual_offset
tile_cache
.
current_tile_size
false
)
;
sub_slice
.
native_surface
=
Some
(
NativeSurface
{
opaque
alpha
}
)
;
}
let
surface_id
=
if
tile
.
is_opaque
{
sub_slice
.
native_surface
.
as_ref
(
)
.
unwrap
(
)
.
opaque
}
else
{
sub_slice
.
native_surface
.
as_ref
(
)
.
unwrap
(
)
.
alpha
}
;
let
tile_id
=
NativeTileId
{
surface_id
x
:
tile
.
tile_offset
.
x
y
:
tile
.
tile_offset
.
y
}
;
frame_state
.
resource_cache
.
create_compositor_tile
(
tile_id
)
;
*
id
=
Some
(
tile_id
)
;
}
}
}
let
content_origin_f
=
tile
.
local_tile_rect
.
min
.
cast_unit
(
)
*
device_pixel_scale
;
let
content_origin
=
content_origin_f
.
round
(
)
;
debug_assert
!
(
(
content_origin_f
.
x
-
content_origin
.
x
)
.
abs
(
)
<
0
.
15
)
;
debug_assert
!
(
(
content_origin_f
.
y
-
content_origin
.
y
)
.
abs
(
)
<
0
.
15
)
;
let
surface
=
descriptor
.
resolve
(
frame_state
.
resource_cache
tile_cache
.
current_tile_size
)
;
let
scissor_rect
=
frame_state
.
composite_state
.
get_surface_rect
(
&
tile
.
local_dirty_rect
&
tile
.
local_tile_rect
tile_cache
.
transform_index
)
.
to_i32
(
)
;
let
valid_rect
=
frame_state
.
composite_state
.
get_surface_rect
(
&
tile
.
current_descriptor
.
local_valid_rect
&
tile
.
local_tile_rect
tile_cache
.
transform_index
)
.
to_i32
(
)
;
let
composite_task_size
=
tile_cache
.
current_tile_size
;
let
tile_key
=
TileKey
{
sub_slice_index
:
SubSliceIndex
:
:
new
(
sub_slice_index
)
tile_offset
:
tile
.
tile_offset
}
;
let
mut
clear_color
=
ColorF
:
:
TRANSPARENT
;
if
SubSliceIndex
:
:
new
(
sub_slice_index
)
.
is_primary
(
)
{
if
let
Some
(
background_color
)
=
tile_cache
.
background_color
{
clear_color
=
background_color
;
}
if
let
Some
(
color
)
=
tile_cache
.
backdrop
.
spanning_opaque_color
{
clear_color
=
color
;
}
}
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
use_tile_composite
=
!
tile
.
sub_graphs
.
is_empty
(
)
;
if
use_tile_composite
{
let
mut
local_content_rect
=
tile
.
local_dirty_rect
;
for
(
sub_graph_rect
surface_stack
)
in
&
tile
.
sub_graphs
{
if
let
Some
(
dirty_sub_graph_rect
)
=
sub_graph_rect
.
intersection
(
&
tile
.
local_dirty_rect
)
{
for
(
composite_mode
surface_index
)
in
surface_stack
{
let
surface
=
&
frame_state
.
surfaces
[
surface_index
.
0
]
;
let
rect
=
composite_mode
.
get_coverage
(
surface
Some
(
dirty_sub_graph_rect
.
cast_unit
(
)
)
)
.
cast_unit
(
)
;
local_content_rect
=
local_content_rect
.
union
(
&
rect
)
;
}
}
}
let
max_content_rect
=
(
tile
.
local_dirty_rect
.
cast_unit
(
)
*
device_pixel_scale
)
.
inflate
(
MAX_BLUR_RADIUS
*
BLUR_SAMPLE_SCALE
MAX_BLUR_RADIUS
*
BLUR_SAMPLE_SCALE
)
.
round_out
(
)
.
to_i32
(
)
;
let
content_device_rect
=
(
local_content_rect
.
cast_unit
(
)
*
device_pixel_scale
)
.
round_out
(
)
.
to_i32
(
)
;
let
content_device_rect
=
content_device_rect
.
intersection
(
&
max_content_rect
)
.
expect
(
"
bug
:
no
intersection
with
tile
dirty
rect
"
)
;
let
content_task_size
=
content_device_rect
.
size
(
)
;
let
normalized_content_rect
=
content_task_size
.
into
(
)
;
let
inner_offset
=
content_origin
+
scissor_rect
.
min
.
to_vector
(
)
.
to_f32
(
)
;
let
outer_offset
=
content_device_rect
.
min
.
to_f32
(
)
;
let
sub_rect_offset
=
(
inner_offset
-
outer_offset
)
.
round
(
)
.
to_i32
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
content_task_size
RenderTaskKind
:
:
new_picture
(
content_task_size
true
content_device_rect
.
min
.
to_f32
(
)
surface_spatial_node_index
surface_spatial_node_index
device_pixel_scale
Some
(
normalized_content_rect
)
None
Some
(
clear_color
)
cmd_buffer_index
false
)
)
)
;
let
composite_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
RenderTaskLocation
:
:
Static
{
surface
:
StaticRenderTaskSurface
:
:
PictureCache
{
surface
}
rect
:
composite_task_size
.
into
(
)
}
RenderTaskKind
:
:
new_tile_composite
(
sub_rect_offset
scissor_rect
valid_rect
clear_color
)
)
)
;
surface_render_tasks
.
insert
(
tile_key
SurfaceTileDescriptor
{
current_task_id
:
render_task_id
composite_task_id
:
Some
(
composite_task_id
)
}
)
;
}
else
{
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new
(
RenderTaskLocation
:
:
Static
{
surface
:
StaticRenderTaskSurface
:
:
PictureCache
{
surface
}
rect
:
composite_task_size
.
into
(
)
}
RenderTaskKind
:
:
new_picture
(
composite_task_size
true
content_origin
surface_spatial_node_index
surface_spatial_node_index
device_pixel_scale
Some
(
scissor_rect
)
Some
(
valid_rect
)
Some
(
clear_color
)
cmd_buffer_index
false
)
)
)
;
surface_render_tasks
.
insert
(
tile_key
SurfaceTileDescriptor
{
current_task_id
:
render_task_id
composite_task_id
:
None
}
)
;
}
surface_dirty_rects
.
push
(
tile
.
local_dirty_rect
)
;
}
if
frame_context
.
fb_config
.
testing
{
debug_info
.
tiles
.
insert
(
tile
.
tile_offset
TileDebugInfo
:
:
Dirty
(
DirtyTileDebugInfo
{
local_valid_rect
:
tile
.
current_descriptor
.
local_valid_rect
local_dirty_rect
:
tile
.
local_dirty_rect
}
)
)
;
}
}
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
let
descriptor
=
CompositeTileDescriptor
{
surface_kind
:
surface
.
into
(
)
tile_id
:
tile
.
id
}
;
let
(
surface
is_opaque
)
=
match
surface
{
TileSurface
:
:
Color
{
color
}
=
>
{
(
CompositeTileSurface
:
:
Color
{
color
:
*
color
}
true
)
}
TileSurface
:
:
Clear
=
>
{
(
CompositeTileSurface
:
:
Clear
false
)
}
TileSurface
:
:
Texture
{
descriptor
.
.
}
=
>
{
let
surface
=
descriptor
.
resolve
(
frame_state
.
resource_cache
tile_cache
.
current_tile_size
)
;
(
CompositeTileSurface
:
:
Texture
{
surface
}
tile
.
is_opaque
)
}
}
;
if
is_opaque
{
sub_slice
.
opaque_tile_descriptors
.
push
(
descriptor
)
;
}
else
{
sub_slice
.
alpha_tile_descriptors
.
push
(
descriptor
)
;
}
let
composite_tile
=
CompositeTile
{
kind
:
tile_kind
(
&
surface
is_opaque
)
surface
local_rect
:
tile
.
local_tile_rect
local_valid_rect
:
tile
.
current_descriptor
.
local_valid_rect
local_dirty_rect
:
tile
.
local_dirty_rect
device_clip_rect
z_id
:
tile
.
z_id
transform_index
:
tile_cache
.
transform_index
}
;
sub_slice
.
composite_tiles
.
push
(
composite_tile
)
;
tile
.
local_dirty_rect
=
PictureRect
:
:
zero
(
)
;
tile
.
is_valid
=
true
;
}
sub_slice
.
opaque_tile_descriptors
.
sort_by_key
(
|
desc
|
desc
.
tile_id
)
;
sub_slice
.
alpha_tile_descriptors
.
sort_by_key
(
|
desc
|
desc
.
tile_id
)
;
}
let
backdrop_rect
=
tile_cache
.
backdrop
.
backdrop_rect
.
intersection
(
&
tile_cache
.
local_rect
)
.
and_then
(
|
r
|
{
r
.
intersection
(
&
tile_cache
.
local_clip_rect
)
}
)
;
let
mut
backdrop_in_use_and_visible
=
false
;
if
let
Some
(
backdrop_rect
)
=
backdrop_rect
{
let
supports_surface_for_backdrop
=
match
frame_state
.
composite_state
.
compositor_kind
{
CompositorKind
:
:
Draw
{
.
.
}
=
>
{
false
}
CompositorKind
:
:
Native
{
capabilities
.
.
}
=
>
{
capabilities
.
supports_surface_for_backdrop
}
}
;
if
supports_surface_for_backdrop
&
&
!
tile_cache
.
found_prims_after_backdrop
&
&
at_least_one_tile_visible
{
if
let
Some
(
BackdropKind
:
:
Color
{
color
}
)
=
tile_cache
.
backdrop
.
kind
{
backdrop_in_use_and_visible
=
true
;
for
sub_slice
in
&
mut
tile_cache
.
sub_slices
{
for
tile
in
sub_slice
.
tiles
.
values_mut
(
)
{
tile
.
is_visible
=
false
;
}
}
if
let
Some
(
backdrop_surface
)
=
&
tile_cache
.
backdrop_surface
{
if
backdrop_surface
.
color
!
=
color
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
backdrop_surface
.
id
)
;
tile_cache
.
backdrop_surface
=
None
;
}
}
let
world_backdrop_rect
=
map_pic_to_world
.
map
(
&
backdrop_rect
)
.
expect
(
"
bug
:
unable
to
map
backdrop
rect
"
)
;
let
device_rect
=
(
world_backdrop_rect
*
frame_context
.
global_device_pixel_scale
)
.
round
(
)
;
if
let
Some
(
backdrop_surface
)
=
&
mut
tile_cache
.
backdrop_surface
{
backdrop_surface
.
device_rect
=
device_rect
;
}
else
{
tile_cache
.
backdrop_surface
=
Some
(
BackdropSurface
{
id
:
frame_state
.
resource_cache
.
create_compositor_backdrop_surface
(
color
)
color
device_rect
}
)
;
}
}
}
}
if
!
backdrop_in_use_and_visible
{
if
let
Some
(
backdrop_surface
)
=
&
tile_cache
.
backdrop_surface
{
frame_state
.
resource_cache
.
destroy_compositor_surface
(
backdrop_surface
.
id
)
;
tile_cache
.
backdrop_surface
=
None
;
}
}
if
frame_context
.
debug_flags
.
contains
(
DebugFlags
:
:
INVALIDATION_DBG
)
{
tile_cache
.
print
(
)
;
}
if
frame_context
.
fb_config
.
testing
{
frame_state
.
composite_state
.
picture_cache_debug
.
slices
.
insert
(
tile_cache
.
slice
debug_info
)
;
}
let
descriptor
=
SurfaceDescriptor
:
:
new_tiled
(
surface_render_tasks
surface_dirty_rects
)
;
frame_state
.
surface_builder
.
push_surface
(
surface_index
false
surface_local_dirty_rect
descriptor
frame_state
.
surfaces
frame_state
.
rg_builder
)
;
}
Some
(
ref
mut
raster_config
)
=
>
{
let
pic_rect
=
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
.
clipped_local_rect
;
let
parent_surface_index
=
parent_surface_index
.
expect
(
"
bug
:
no
parent
for
child
surface
"
)
;
let
local_rect
=
pic_rect
*
Scale
:
:
new
(
1
.
0
)
;
if
local_rect
!
=
self
.
prev_local_rect
{
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
.
.
)
)
=
>
{
for
handle
in
&
self
.
extra_gpu_data_handles
{
frame_state
.
gpu_cache
.
invalidate
(
handle
)
;
}
}
_
=
>
{
}
}
self
.
segments_are_valid
=
false
;
self
.
prev_local_rect
=
local_rect
;
}
let
max_surface_size
=
frame_context
.
fb_config
.
max_surface_override
.
unwrap_or
(
MAX_SURFACE_SIZE
)
as
f32
;
let
surface_rects
=
match
get_surface_rects
(
raster_config
.
surface_index
&
raster_config
.
composite_mode
parent_surface_index
&
mut
frame_state
.
surfaces
frame_context
.
spatial_tree
max_surface_size
)
{
Some
(
rects
)
=
>
rects
None
=
>
return
None
}
;
let
(
raster_spatial_node_index
device_pixel_scale
)
=
{
let
surface
=
&
frame_state
.
surfaces
[
surface_index
.
0
]
;
(
surface
.
raster_spatial_node_index
surface
.
device_pixel_scale
)
}
;
let
can_use_shared_surface
=
!
self
.
flags
.
contains
(
PictureFlags
:
:
IS_RESOLVE_TARGET
)
;
let
primary_render_task_id
;
let
surface_descriptor
;
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
.
.
}
=
>
{
unreachable
!
(
"
handled
above
"
)
;
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
width
height
.
.
}
)
=
>
{
let
surface
=
&
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
;
let
(
width
height
)
=
surface
.
clamp_blur_radius
(
width
height
)
;
let
width_std_deviation
=
width
*
surface
.
local_scale
.
0
*
device_pixel_scale
.
0
;
let
height_std_deviation
=
height
*
surface
.
local_scale
.
1
*
device_pixel_scale
.
0
;
let
blur_std_deviation
=
DeviceSize
:
:
new
(
width_std_deviation
height_std_deviation
)
;
let
original_size
=
surface_rects
.
clipped
.
size
(
)
;
let
adjusted_size
=
BlurTask
:
:
adjusted_blur_source_size
(
original_size
blur_std_deviation
)
;
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
DeviceRect
:
:
from_origin_and_size
(
surface_rects
.
clipped
.
min
adjusted_size
.
to_f32
(
)
)
surface_rects
.
unclipped
)
;
let
picture_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
adjusted_size
RenderTaskKind
:
:
new_picture
(
adjusted_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
uv_rect_kind
)
)
;
let
blur_render_task_id
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
frame_state
.
rg_builder
RenderTargetKind
:
:
Color
None
original_size
.
to_i32
(
)
)
;
primary_render_task_id
=
blur_render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_chained
(
picture_task_id
blur_render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
surface
=
&
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
;
let
device_rect
=
surface_rects
.
clipped
;
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
picture_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
device_rect
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
let
mut
blur_tasks
=
BlurTaskCache
:
:
default
(
)
;
self
.
extra_gpu_data_handles
.
resize
(
shadows
.
len
(
)
GpuCacheHandle
:
:
new
(
)
)
;
let
mut
blur_render_task_id
=
picture_task_id
;
for
shadow
in
shadows
{
let
(
blur_radius_x
blur_radius_y
)
=
surface
.
clamp_blur_radius
(
shadow
.
blur_radius
shadow
.
blur_radius
)
;
blur_render_task_id
=
RenderTask
:
:
new_blur
(
DeviceSize
:
:
new
(
blur_radius_x
*
surface
.
local_scale
.
0
*
device_pixel_scale
.
0
blur_radius_y
*
surface
.
local_scale
.
1
*
device_pixel_scale
.
0
)
picture_task_id
frame_state
.
rg_builder
RenderTargetKind
:
:
Color
Some
(
&
mut
blur_tasks
)
device_rect
.
size
(
)
.
to_i32
(
)
)
;
}
frame_state
.
surface_builder
.
add_picture_render_task
(
picture_task_id
)
;
primary_render_task_id
=
blur_render_task_id
;
self
.
secondary_render_task_id
=
Some
(
picture_task_id
)
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_chained
(
picture_task_id
blur_render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
MixBlend
(
mode
)
if
BlendMode
:
:
from_mix_blend_mode
(
mode
frame_context
.
fb_config
.
gpu_supports_advanced_blend
frame_context
.
fb_config
.
advanced_blend_is_coherent
frame_context
.
fb_config
.
dual_source_blending_is_enabled
&
&
frame_context
.
fb_config
.
dual_source_blending_is_supported
)
.
is_none
(
)
=
>
{
let
parent_surface
=
&
frame_state
.
surfaces
[
parent_surface_index
.
0
]
;
let
map_pic_to_parent
=
SpaceMapper
:
:
new_with_target
(
parent_surface
.
surface_spatial_node_index
surface_spatial_node_index
parent_surface
.
clipping_rect
frame_context
.
spatial_tree
)
;
let
pic_in_raster_space
=
map_pic_to_parent
.
map
(
&
pic_rect
)
.
expect
(
"
bug
:
unable
to
map
mix
-
blend
content
into
parent
"
)
;
let
backdrop_rect
=
pic_in_raster_space
;
let
parent_surface_rect
=
parent_surface
.
clipping_rect
;
let
readback_task_id
=
match
backdrop_rect
.
intersection
(
&
parent_surface_rect
)
{
Some
(
available_rect
)
=
>
{
let
backdrop_rect
=
parent_surface
.
map_to_device_rect
(
&
backdrop_rect
frame_context
.
spatial_tree
)
;
let
available_rect
=
parent_surface
.
map_to_device_rect
(
&
available_rect
frame_context
.
spatial_tree
)
.
round_out
(
)
;
let
backdrop_uv
=
calculate_uv_rect_kind
(
available_rect
backdrop_rect
)
;
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
available_rect
.
size
(
)
.
to_i32
(
)
RenderTaskKind
:
:
new_readback
(
Some
(
available_rect
.
min
)
)
)
.
with_uv_rect_kind
(
backdrop_uv
)
)
}
None
=
>
{
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
DeviceIntSize
:
:
new
(
16
16
)
RenderTaskKind
:
:
new_readback
(
None
)
)
)
}
}
;
frame_state
.
surface_builder
.
add_child_render_task
(
readback_task_id
frame_state
.
rg_builder
)
;
self
.
secondary_render_task_id
=
Some
(
readback_task_id
)
;
let
task_size
=
surface_rects
.
clipped
.
size
(
)
.
to_i32
(
)
;
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
task_size
RenderTaskKind
:
:
new_picture
(
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
primary_render_task_id
=
render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_simple
(
render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
Filter
(
.
.
)
=
>
{
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
primary_render_task_id
=
render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_simple
(
render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
=
>
{
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
primary_render_task_id
=
render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_simple
(
render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
Blit
(
_
)
=
>
{
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
primary_render_task_id
=
render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_simple
(
render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
IntermediateSurface
=
>
{
if
!
scratch
.
required_sub_graphs
.
contains
(
&
pic_index
)
{
return
None
;
}
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
render_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
primary_render_task_id
=
render_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_simple
(
render_task_id
surface_rects
.
clipped_local
)
;
}
PictureCompositeMode
:
:
SvgFilter
(
ref
primitives
ref
filter_datas
)
=
>
{
let
cmd_buffer_index
=
frame_state
.
cmd_buffers
.
create_cmd_buffer
(
)
;
let
picture_task_id
=
frame_state
.
rg_builder
.
add
(
)
.
init
(
RenderTask
:
:
new_dynamic
(
surface_rects
.
task_size
RenderTaskKind
:
:
new_picture
(
surface_rects
.
task_size
surface_rects
.
needs_scissor_rect
surface_rects
.
clipped
.
min
surface_spatial_node_index
raster_spatial_node_index
device_pixel_scale
None
None
None
cmd_buffer_index
can_use_shared_surface
)
)
.
with_uv_rect_kind
(
surface_rects
.
uv_rect_kind
)
)
;
let
filter_task_id
=
RenderTask
:
:
new_svg_filter
(
primitives
filter_datas
frame_state
.
rg_builder
surface_rects
.
clipped
.
size
(
)
.
to_i32
(
)
surface_rects
.
uv_rect_kind
picture_task_id
device_pixel_scale
)
;
primary_render_task_id
=
filter_task_id
;
surface_descriptor
=
SurfaceDescriptor
:
:
new_chained
(
picture_task_id
filter_task_id
surface_rects
.
clipped_local
)
;
}
}
let
is_sub_graph
=
self
.
flags
.
contains
(
PictureFlags
:
:
IS_SUB_GRAPH
)
;
frame_state
.
surface_builder
.
push_surface
(
raster_config
.
surface_index
is_sub_graph
surface_rects
.
clipped_local
surface_descriptor
frame_state
.
surfaces
frame_state
.
rg_builder
)
;
self
.
primary_render_task_id
=
Some
(
primary_render_task_id
)
;
}
None
=
>
{
}
}
;
let
state
=
PictureState
{
map_local_to_pic
map_pic_to_world
}
;
let
mut
dirty_region_count
=
0
;
if
let
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
TileCache
{
slice_id
}
.
.
}
)
=
self
.
raster_config
{
let
dirty_region
=
tile_caches
[
&
slice_id
]
.
dirty_region
.
clone
(
)
;
frame_state
.
push_dirty_region
(
dirty_region
)
;
dirty_region_count
+
=
1
;
}
let
subpixel_mode
=
match
self
.
raster_config
{
Some
(
RasterConfig
{
ref
composite_mode
.
.
}
)
=
>
{
let
subpixel_mode
=
match
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
slice_id
}
=
>
{
tile_caches
[
&
slice_id
]
.
subpixel_mode
}
PictureCompositeMode
:
:
Blit
(
.
.
)
|
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
|
PictureCompositeMode
:
:
Filter
(
.
.
)
|
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
IntermediateSurface
|
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
=
>
{
SubpixelMode
:
:
Deny
}
}
;
subpixel_mode
}
None
=
>
{
SubpixelMode
:
:
Allow
}
}
;
let
subpixel_mode
=
match
(
parent_subpixel_mode
subpixel_mode
)
{
(
SubpixelMode
:
:
Allow
SubpixelMode
:
:
Allow
)
=
>
{
SubpixelMode
:
:
Allow
}
(
SubpixelMode
:
:
Allow
SubpixelMode
:
:
Conditional
{
allowed_rect
}
)
=
>
{
SubpixelMode
:
:
Conditional
{
allowed_rect
}
}
(
SubpixelMode
:
:
Conditional
{
allowed_rect
}
SubpixelMode
:
:
Allow
)
=
>
{
SubpixelMode
:
:
Conditional
{
allowed_rect
}
}
(
SubpixelMode
:
:
Conditional
{
.
.
}
SubpixelMode
:
:
Conditional
{
.
.
}
)
=
>
{
unreachable
!
(
"
bug
:
only
top
level
picture
caches
have
conditional
subpixel
"
)
;
}
(
SubpixelMode
:
:
Deny
_
)
|
(
_
SubpixelMode
:
:
Deny
)
=
>
{
SubpixelMode
:
:
Deny
}
}
;
let
context
=
PictureContext
{
pic_index
raster_spatial_node_index
:
frame_state
.
surfaces
[
surface_index
.
0
]
.
raster_spatial_node_index
surface_spatial_node_index
surface_index
dirty_region_count
subpixel_mode
}
;
let
prim_list
=
mem
:
:
replace
(
&
mut
self
.
prim_list
PrimitiveList
:
:
empty
(
)
)
;
Some
(
(
context
state
prim_list
)
)
}
pub
fn
restore_context
(
&
mut
self
pic_index
:
PictureIndex
prim_list
:
PrimitiveList
context
:
PictureContext
prim_instances
:
&
[
PrimitiveInstance
]
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
)
{
for
_
in
0
.
.
context
.
dirty_region_count
{
frame_state
.
pop_dirty_region
(
)
;
}
if
self
.
raster_config
.
is_some
(
)
{
frame_state
.
surface_builder
.
pop_surface
(
pic_index
frame_state
.
rg_builder
frame_state
.
cmd_buffers
)
;
}
if
let
Picture3DContext
:
:
In
{
root_data
:
Some
(
ref
mut
list
)
plane_splitter_index
.
.
}
=
self
.
context_3d
{
let
splitter
=
&
mut
frame_state
.
plane_splitters
[
plane_splitter_index
.
0
]
;
PicturePrimitive
:
:
resolve_split_planes
(
splitter
list
&
mut
frame_state
.
gpu_cache
&
frame_context
.
spatial_tree
)
;
for
child
in
list
{
let
child_prim_instance
=
&
prim_instances
[
child
.
anchor
.
instance_index
.
0
as
usize
]
;
frame_state
.
surface_builder
.
push_prim
(
child
.
anchor
.
instance_index
child
.
anchor
.
spatial_node_index
&
child_prim_instance
.
vis
Some
(
child
.
gpu_address
)
frame_state
.
cmd_buffers
)
;
}
}
self
.
prim_list
=
prim_list
;
}
pub
fn
add_split_plane
(
splitter
:
&
mut
PlaneSplitter
spatial_tree
:
&
SpatialTree
prim_spatial_node_index
:
SpatialNodeIndex
original_local_rect
:
LayoutRect
combined_local_clip_rect
:
&
LayoutRect
world_rect
:
WorldRect
plane_split_anchor
:
PlaneSplitAnchor
)
-
>
bool
{
let
transform
=
spatial_tree
.
get_world_transform
(
prim_spatial_node_index
)
;
let
matrix
=
transform
.
clone
(
)
.
into_transform
(
)
.
cast
(
)
;
let
local_rect
=
match
original_local_rect
.
intersection
(
combined_local_clip_rect
)
{
Some
(
rect
)
=
>
rect
.
cast
(
)
None
=
>
return
false
}
;
let
world_rect
=
world_rect
.
cast
(
)
;
match
transform
{
CoordinateSpaceMapping
:
:
Local
=
>
{
let
polygon
=
Polygon
:
:
from_rect
(
local_rect
.
to_rect
(
)
*
Scale
:
:
new
(
1
.
0
)
plane_split_anchor
)
;
splitter
.
add
(
polygon
)
;
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
if
scale_offset
.
scale
=
=
Vector2D
:
:
new
(
1
.
0
1
.
0
)
=
>
{
let
inv_matrix
=
scale_offset
.
inverse
(
)
.
to_transform
(
)
.
cast
(
)
;
let
polygon
=
Polygon
:
:
from_transformed_rect_with_inverse
(
local_rect
.
to_rect
(
)
&
matrix
&
inv_matrix
plane_split_anchor
)
.
unwrap
(
)
;
splitter
.
add
(
polygon
)
;
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
_
)
|
CoordinateSpaceMapping
:
:
Transform
(
_
)
=
>
{
let
mut
clipper
=
Clipper
:
:
new
(
)
;
let
results
=
clipper
.
clip_transformed
(
Polygon
:
:
from_rect
(
local_rect
.
to_rect
(
)
plane_split_anchor
)
&
matrix
Some
(
world_rect
.
to_rect
(
)
)
)
;
if
let
Ok
(
results
)
=
results
{
for
poly
in
results
{
splitter
.
add
(
poly
)
;
}
}
}
}
true
}
fn
resolve_split_planes
(
splitter
:
&
mut
PlaneSplitter
ordered
:
&
mut
Vec
<
OrderedPictureChild
>
gpu_cache
:
&
mut
GpuCache
spatial_tree
:
&
SpatialTree
)
{
ordered
.
clear
(
)
;
let
sorted
=
splitter
.
sort
(
vec3
(
0
.
0
0
.
0
1
.
0
)
)
;
ordered
.
reserve
(
sorted
.
len
(
)
)
;
for
poly
in
sorted
{
let
transform
=
match
spatial_tree
.
get_world_transform
(
poly
.
anchor
.
spatial_node_index
)
.
inverse
(
)
{
Some
(
transform
)
=
>
transform
.
into_transform
(
)
None
=
>
continue
}
;
let
local_points
=
[
transform
.
transform_point3d
(
poly
.
points
[
0
]
.
cast
(
)
)
transform
.
transform_point3d
(
poly
.
points
[
1
]
.
cast
(
)
)
transform
.
transform_point3d
(
poly
.
points
[
2
]
.
cast
(
)
)
transform
.
transform_point3d
(
poly
.
points
[
3
]
.
cast
(
)
)
]
;
if
local_points
.
iter
(
)
.
any
(
|
p
|
p
.
is_none
(
)
)
{
continue
;
}
let
p0
=
local_points
[
0
]
.
unwrap
(
)
;
let
p1
=
local_points
[
1
]
.
unwrap
(
)
;
let
p2
=
local_points
[
2
]
.
unwrap
(
)
;
let
p3
=
local_points
[
3
]
.
unwrap
(
)
;
let
gpu_blocks
=
[
[
p0
.
x
p0
.
y
p1
.
x
p1
.
y
]
.
into
(
)
[
p2
.
x
p2
.
y
p3
.
x
p3
.
y
]
.
into
(
)
]
;
let
gpu_handle
=
gpu_cache
.
push_per_frame_blocks
(
&
gpu_blocks
)
;
let
gpu_address
=
gpu_cache
.
get_address
(
&
gpu_handle
)
;
ordered
.
push
(
OrderedPictureChild
{
anchor
:
poly
.
anchor
gpu_address
}
)
;
}
}
pub
fn
pre_update
(
&
mut
self
frame_context
:
&
FrameBuildingContext
)
{
self
.
resolve_scene_properties
(
frame_context
.
scene_properties
)
;
}
pub
fn
assign_surface
(
&
mut
self
frame_context
:
&
FrameBuildingContext
parent_surface_index
:
Option
<
SurfaceIndex
>
tile_caches
:
&
mut
FastHashMap
<
SliceId
Box
<
TileCacheInstance
>
>
surfaces
:
&
mut
Vec
<
SurfaceInfo
>
)
-
>
Option
<
SurfaceIndex
>
{
self
.
raster_config
=
None
;
match
self
.
composite_mode
{
Some
(
ref
composite_mode
)
=
>
{
let
surface_spatial_node_index
=
self
.
spatial_node_index
;
let
mut
min_scale
;
let
mut
max_scale
=
1
.
0e32
;
let
world_scale_factors
=
match
parent_surface_index
{
Some
(
parent_surface_index
)
=
>
{
let
parent_surface
=
&
surfaces
[
parent_surface_index
.
0
]
;
let
local_to_surface
=
frame_context
.
spatial_tree
.
get_relative_transform
(
surface_spatial_node_index
parent_surface
.
surface_spatial_node_index
)
;
let
scale_factors
=
if
local_to_surface
.
is_perspective
(
)
{
(
1
.
0
1
.
0
)
}
else
{
local_to_surface
.
scale_factors
(
)
}
;
let
scale_factors
=
(
scale_factors
.
0
*
parent_surface
.
world_scale_factors
.
0
scale_factors
.
1
*
parent_surface
.
world_scale_factors
.
1
)
;
scale_factors
}
None
=
>
{
let
local_to_surface_scale_factors
=
frame_context
.
spatial_tree
.
get_relative_transform
(
surface_spatial_node_index
frame_context
.
spatial_tree
.
root_reference_frame_index
(
)
)
.
scale_factors
(
)
;
let
scale_factors
=
(
local_to_surface_scale_factors
.
0
local_to_surface_scale_factors
.
1
)
;
scale_factors
}
}
;
let
allow_snapping
=
!
self
.
flags
.
contains
(
PictureFlags
:
:
DISABLE_SNAPPING
)
;
let
(
device_pixel_scale
raster_spatial_node_index
local_scale
world_scale_factors
)
=
match
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
slice_id
}
=
>
{
let
tile_cache
=
tile_caches
.
get_mut
(
&
slice_id
)
.
unwrap
(
)
;
let
update_raster_scale
=
!
frame_context
.
fb_config
.
low_quality_pinch_zoom
|
|
!
frame_context
.
spatial_tree
.
get_spatial_node
(
tile_cache
.
spatial_node_index
)
.
is_ancestor_or_self_zooming
;
if
update_raster_scale
{
let
local_to_device
=
get_relative_scale_offset
(
tile_cache
.
spatial_node_index
frame_context
.
root_spatial_node_index
frame_context
.
spatial_tree
)
;
tile_cache
.
current_raster_scale
=
local_to_device
.
scale
.
x
;
}
min_scale
=
0
.
0
;
if
frame_context
.
fb_config
.
low_quality_pinch_zoom
{
min_scale
=
tile_cache
.
current_raster_scale
;
max_scale
=
tile_cache
.
current_raster_scale
;
}
let
scaling_factor
=
world_scale_factors
.
0
.
max
(
world_scale_factors
.
1
)
.
max
(
min_scale
)
.
min
(
max_scale
)
;
let
device_pixel_scale
=
Scale
:
:
new
(
scaling_factor
)
;
(
device_pixel_scale
surface_spatial_node_index
(
1
.
0
1
.
0
)
world_scale_factors
)
}
_
=
>
{
let
surface_spatial_node
=
frame_context
.
spatial_tree
.
get_spatial_node
(
surface_spatial_node_index
)
;
let
enable_snapping
=
allow_snapping
&
&
surface_spatial_node
.
coordinate_system_id
=
=
CoordinateSystemId
:
:
root
(
)
&
&
surface_spatial_node
.
snapping_transform
.
is_some
(
)
;
if
enable_snapping
{
let
raster_spatial_node_index
=
frame_context
.
spatial_tree
.
root_reference_frame_index
(
)
;
let
local_to_raster_transform
=
frame_context
.
spatial_tree
.
get_relative_transform
(
self
.
spatial_node_index
raster_spatial_node_index
)
;
let
local_scale
=
local_to_raster_transform
.
scale_factors
(
)
;
(
Scale
:
:
new
(
1
.
0
)
raster_spatial_node_index
local_scale
(
1
.
0
1
.
0
)
)
}
else
{
let
world_scale_factors
=
match
self
.
raster_space
{
RasterSpace
:
:
Screen
=
>
world_scale_factors
RasterSpace
:
:
Local
(
scale
)
=
>
(
scale
scale
)
}
;
let
device_pixel_scale
=
Scale
:
:
new
(
world_scale_factors
.
0
.
max
(
world_scale_factors
.
1
)
)
;
(
device_pixel_scale
surface_spatial_node_index
(
1
.
0
1
.
0
)
world_scale_factors
)
}
}
}
;
let
surface
=
SurfaceInfo
:
:
new
(
surface_spatial_node_index
raster_spatial_node_index
frame_context
.
global_screen_world_rect
&
frame_context
.
spatial_tree
device_pixel_scale
world_scale_factors
local_scale
allow_snapping
)
;
let
surface_index
=
SurfaceIndex
(
surfaces
.
len
(
)
)
;
surfaces
.
push
(
surface
)
;
self
.
raster_config
=
Some
(
RasterConfig
{
composite_mode
:
composite_mode
.
clone
(
)
surface_index
}
)
;
Some
(
surface_index
)
}
None
=
>
{
None
}
}
}
pub
fn
propagate_bounding_rect
(
&
mut
self
surface_index
:
SurfaceIndex
parent_surface_index
:
Option
<
SurfaceIndex
>
surfaces
:
&
mut
[
SurfaceInfo
]
frame_context
:
&
FrameBuildingContext
)
{
let
surface
=
&
mut
surfaces
[
surface_index
.
0
]
;
for
cluster
in
&
mut
self
.
prim_list
.
clusters
{
cluster
.
flags
.
remove
(
ClusterFlags
:
:
IS_VISIBLE
)
;
if
!
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_BACKFACE_VISIBLE
)
{
if
let
Picture3DContext
:
:
In
{
ancestor_index
.
.
}
=
self
.
context_3d
{
let
mut
face
=
VisibleFace
:
:
Front
;
frame_context
.
spatial_tree
.
get_relative_transform_with_face
(
cluster
.
spatial_node_index
ancestor_index
Some
(
&
mut
face
)
)
;
if
face
=
=
VisibleFace
:
:
Back
{
continue
}
}
}
let
spatial_node
=
&
frame_context
.
spatial_tree
.
get_spatial_node
(
cluster
.
spatial_node_index
)
;
if
!
spatial_node
.
invertible
{
continue
;
}
surface
.
map_local_to_surface
.
set_target_spatial_node
(
cluster
.
spatial_node_index
frame_context
.
spatial_tree
)
;
cluster
.
flags
.
insert
(
ClusterFlags
:
:
IS_VISIBLE
)
;
if
let
Some
(
cluster_rect
)
=
surface
.
map_local_to_surface
.
map
(
&
cluster
.
bounding_rect
)
{
surface
.
unclipped_local_rect
=
surface
.
unclipped_local_rect
.
union
(
&
cluster_rect
)
;
}
}
if
let
Some
(
ref
mut
raster_config
)
=
self
.
raster_config
{
if
let
Some
(
parent_surface_index
)
=
parent_surface_index
{
let
surface_rect
=
raster_config
.
composite_mode
.
get_coverage
(
surface
Some
(
surface
.
unclipped_local_rect
.
cast_unit
(
)
)
)
;
let
parent_surface
=
&
mut
surfaces
[
parent_surface_index
.
0
]
;
parent_surface
.
map_local_to_surface
.
set_target_spatial_node
(
self
.
spatial_node_index
frame_context
.
spatial_tree
)
;
if
let
Some
(
parent_surface_rect
)
=
parent_surface
.
map_local_to_surface
.
map
(
&
surface_rect
)
{
parent_surface
.
unclipped_local_rect
=
parent_surface
.
unclipped_local_rect
.
union
(
&
parent_surface_rect
)
;
}
}
}
}
pub
fn
prepare_for_render
(
&
mut
self
frame_state
:
&
mut
FrameBuildingState
data_stores
:
&
mut
DataStores
)
-
>
bool
{
let
raster_config
=
match
self
.
raster_config
{
Some
(
ref
mut
raster_config
)
=
>
raster_config
None
=
>
{
return
true
}
}
;
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
.
.
}
=
>
{
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
.
.
}
)
=
>
{
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
self
.
extra_gpu_data_handles
.
resize
(
shadows
.
len
(
)
GpuCacheHandle
:
:
new
(
)
)
;
for
(
shadow
extra_handle
)
in
shadows
.
iter
(
)
.
zip
(
self
.
extra_gpu_data_handles
.
iter_mut
(
)
)
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
extra_handle
)
{
let
surface
=
&
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
;
let
prim_rect
=
surface
.
clipped_local_rect
.
cast_unit
(
)
;
let
(
blur_inflation_x
blur_inflation_y
)
=
surface
.
clamp_blur_radius
(
shadow
.
blur_radius
shadow
.
blur_radius
)
;
let
shadow_rect
=
prim_rect
.
inflate
(
blur_inflation_x
*
BLUR_SAMPLE_SCALE
blur_inflation_y
*
BLUR_SAMPLE_SCALE
)
.
translate
(
shadow
.
offset
)
;
request
.
push
(
shadow
.
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
shadow_rect
.
width
(
)
shadow_rect
.
height
(
)
0
.
0
0
.
0
]
)
;
request
.
push
(
shadow_rect
)
;
request
.
push
(
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
}
}
PictureCompositeMode
:
:
Filter
(
ref
filter
)
=
>
{
match
*
filter
{
Filter
:
:
ColorMatrix
(
ref
m
)
=
>
{
if
self
.
extra_gpu_data_handles
.
is_empty
(
)
{
self
.
extra_gpu_data_handles
.
push
(
GpuCacheHandle
:
:
new
(
)
)
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handles
[
0
]
)
{
for
i
in
0
.
.
5
{
request
.
push
(
[
m
[
i
*
4
]
m
[
i
*
4
+
1
]
m
[
i
*
4
+
2
]
m
[
i
*
4
+
3
]
]
)
;
}
}
}
Filter
:
:
Flood
(
ref
color
)
=
>
{
if
self
.
extra_gpu_data_handles
.
is_empty
(
)
{
self
.
extra_gpu_data_handles
.
push
(
GpuCacheHandle
:
:
new
(
)
)
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handles
[
0
]
)
{
request
.
push
(
color
.
to_array
(
)
)
;
}
}
_
=
>
{
}
}
}
PictureCompositeMode
:
:
ComponentTransferFilter
(
handle
)
=
>
{
let
filter_data
=
&
mut
data_stores
.
filter_data
[
handle
]
;
filter_data
.
update
(
frame_state
)
;
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
Blit
(
_
)
|
PictureCompositeMode
:
:
IntermediateSurface
|
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
=
>
{
}
}
true
}
}
fn
get_transform_key
(
spatial_node_index
:
SpatialNodeIndex
cache_spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
-
>
TransformKey
{
spatial_tree
.
get_relative_transform
(
spatial_node_index
cache_spatial_node_index
)
.
into
(
)
}
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
PartialEq
)
]
struct
PrimitiveComparisonKey
{
prev_index
:
PrimitiveDependencyIndex
curr_index
:
PrimitiveDependencyIndex
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ImageDependency
{
pub
key
:
ImageKey
pub
generation
:
ImageGeneration
}
impl
ImageDependency
{
pub
const
INVALID
:
ImageDependency
=
ImageDependency
{
key
:
ImageKey
:
:
DUMMY
generation
:
ImageGeneration
:
:
INVALID
}
;
}
#
[
derive
(
Debug
)
]
struct
DeferredDirtyTest
{
tile_rect
:
TileRect
prim_rect
:
PictureRect
}
struct
PrimitiveComparer
<
'
a
>
{
clip_comparer
:
CompareHelper
<
'
a
ItemUid
>
transform_comparer
:
CompareHelper
<
'
a
SpatialNodeKey
>
image_comparer
:
CompareHelper
<
'
a
ImageDependency
>
opacity_comparer
:
CompareHelper
<
'
a
OpacityBinding
>
color_comparer
:
CompareHelper
<
'
a
ColorBinding
>
resource_cache
:
&
'
a
ResourceCache
spatial_node_comparer
:
&
'
a
mut
SpatialNodeComparer
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
color_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
}
impl
<
'
a
>
PrimitiveComparer
<
'
a
>
{
fn
new
(
prev
:
&
'
a
TileDescriptor
curr
:
&
'
a
TileDescriptor
resource_cache
:
&
'
a
ResourceCache
spatial_node_comparer
:
&
'
a
mut
SpatialNodeComparer
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
color_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
ColorBindingInfo
>
)
-
>
Self
{
let
clip_comparer
=
CompareHelper
:
:
new
(
&
prev
.
clips
&
curr
.
clips
)
;
let
transform_comparer
=
CompareHelper
:
:
new
(
&
prev
.
transforms
&
curr
.
transforms
)
;
let
image_comparer
=
CompareHelper
:
:
new
(
&
prev
.
images
&
curr
.
images
)
;
let
opacity_comparer
=
CompareHelper
:
:
new
(
&
prev
.
opacity_bindings
&
curr
.
opacity_bindings
)
;
let
color_comparer
=
CompareHelper
:
:
new
(
&
prev
.
color_bindings
&
curr
.
color_bindings
)
;
PrimitiveComparer
{
clip_comparer
transform_comparer
image_comparer
opacity_comparer
color_comparer
resource_cache
spatial_node_comparer
opacity_bindings
color_bindings
}
}
fn
reset
(
&
mut
self
)
{
self
.
clip_comparer
.
reset
(
)
;
self
.
transform_comparer
.
reset
(
)
;
self
.
image_comparer
.
reset
(
)
;
self
.
opacity_comparer
.
reset
(
)
;
self
.
color_comparer
.
reset
(
)
;
}
fn
advance_prev
(
&
mut
self
prim
:
&
PrimitiveDescriptor
)
{
self
.
clip_comparer
.
advance_prev
(
prim
.
clip_dep_count
)
;
self
.
transform_comparer
.
advance_prev
(
prim
.
transform_dep_count
)
;
self
.
image_comparer
.
advance_prev
(
prim
.
image_dep_count
)
;
self
.
opacity_comparer
.
advance_prev
(
prim
.
opacity_binding_dep_count
)
;
self
.
color_comparer
.
advance_prev
(
prim
.
color_binding_dep_count
)
;
}
fn
advance_curr
(
&
mut
self
prim
:
&
PrimitiveDescriptor
)
{
self
.
clip_comparer
.
advance_curr
(
prim
.
clip_dep_count
)
;
self
.
transform_comparer
.
advance_curr
(
prim
.
transform_dep_count
)
;
self
.
image_comparer
.
advance_curr
(
prim
.
image_dep_count
)
;
self
.
opacity_comparer
.
advance_curr
(
prim
.
opacity_binding_dep_count
)
;
self
.
color_comparer
.
advance_curr
(
prim
.
color_binding_dep_count
)
;
}
fn
compare_prim
(
&
mut
self
prev
:
&
PrimitiveDescriptor
curr
:
&
PrimitiveDescriptor
)
-
>
PrimitiveCompareResult
{
let
resource_cache
=
self
.
resource_cache
;
let
spatial_node_comparer
=
&
mut
self
.
spatial_node_comparer
;
let
opacity_bindings
=
self
.
opacity_bindings
;
let
color_bindings
=
self
.
color_bindings
;
if
prev
!
=
curr
{
return
PrimitiveCompareResult
:
:
Descriptor
;
}
if
!
self
.
clip_comparer
.
is_same
(
prev
.
clip_dep_count
curr
.
clip_dep_count
|
prev
curr
|
{
prev
=
=
curr
}
)
{
return
PrimitiveCompareResult
:
:
Clip
;
}
if
!
self
.
transform_comparer
.
is_same
(
prev
.
transform_dep_count
curr
.
transform_dep_count
|
prev
curr
|
{
spatial_node_comparer
.
are_transforms_equivalent
(
prev
curr
)
}
)
{
return
PrimitiveCompareResult
:
:
Transform
;
}
if
!
self
.
image_comparer
.
is_same
(
prev
.
image_dep_count
curr
.
image_dep_count
|
prev
curr
|
{
prev
=
=
curr
&
&
resource_cache
.
get_image_generation
(
curr
.
key
)
=
=
curr
.
generation
}
)
{
return
PrimitiveCompareResult
:
:
Image
;
}
if
!
self
.
opacity_comparer
.
is_same
(
prev
.
opacity_binding_dep_count
curr
.
opacity_binding_dep_count
|
prev
curr
|
{
if
prev
!
=
curr
{
return
false
;
}
if
let
OpacityBinding
:
:
Binding
(
id
)
=
curr
{
if
opacity_bindings
.
get
(
id
)
.
map_or
(
true
|
info
|
info
.
changed
)
{
return
false
;
}
}
true
}
)
{
return
PrimitiveCompareResult
:
:
OpacityBinding
;
}
if
!
self
.
color_comparer
.
is_same
(
prev
.
color_binding_dep_count
curr
.
color_binding_dep_count
|
prev
curr
|
{
if
prev
!
=
curr
{
return
false
;
}
if
let
ColorBinding
:
:
Binding
(
id
)
=
curr
{
if
color_bindings
.
get
(
id
)
.
map_or
(
true
|
info
|
info
.
changed
)
{
return
false
;
}
}
true
}
)
{
return
PrimitiveCompareResult
:
:
ColorBinding
;
}
PrimitiveCompareResult
:
:
Equal
}
}
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TileNodeKind
{
Leaf
{
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
prev_indices
:
Vec
<
PrimitiveDependencyIndex
>
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
dirty_tracker
:
u64
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
frames_since_modified
:
usize
}
Node
{
children
:
Vec
<
TileNode
>
}
}
#
[
derive
(
Copy
Clone
PartialEq
Debug
)
]
enum
TileModification
{
Split
Merge
}
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileNode
{
pub
kind
:
TileNodeKind
pub
rect
:
PictureBox2D
}
impl
TileNode
{
fn
new_leaf
(
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
)
-
>
Self
{
TileNode
{
kind
:
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
rect
:
PictureBox2D
:
:
zero
(
)
}
}
fn
draw_debug_rects
(
&
self
pic_to_world_mapper
:
&
SpaceMapper
<
PicturePixel
WorldPixel
>
is_opaque
:
bool
local_valid_rect
:
PictureRect
scratch
:
&
mut
PrimitiveScratchBuffer
global_device_pixel_scale
:
DevicePixelScale
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
.
.
}
=
>
{
let
color
=
if
(
dirty_tracker
&
1
)
!
=
0
{
debug_colors
:
:
RED
}
else
if
is_opaque
{
debug_colors
:
:
GREEN
}
else
{
debug_colors
:
:
YELLOW
}
;
if
let
Some
(
local_rect
)
=
local_valid_rect
.
intersection
(
&
self
.
rect
)
{
let
world_rect
=
pic_to_world_mapper
.
map
(
&
local_rect
)
.
unwrap
(
)
;
let
device_rect
=
world_rect
*
global_device_pixel_scale
;
let
outer_color
=
color
.
scale_alpha
(
0
.
3
)
;
let
inner_color
=
outer_color
.
scale_alpha
(
0
.
5
)
;
scratch
.
push_debug_rect
(
device_rect
.
inflate
(
-
3
.
0
-
3
.
0
)
outer_color
inner_color
)
;
}
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
for
child
in
children
.
iter
(
)
{
child
.
draw_debug_rects
(
pic_to_world_mapper
is_opaque
local_valid_rect
scratch
global_device_pixel_scale
)
;
}
}
}
}
fn
get_child_rects
(
rect
:
&
PictureBox2D
result
:
&
mut
[
PictureBox2D
;
4
]
)
{
let
p0
=
rect
.
min
;
let
p1
=
rect
.
max
;
let
pc
=
p0
+
rect
.
size
(
)
*
0
.
5
;
*
result
=
[
PictureBox2D
:
:
new
(
p0
pc
)
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
pc
.
x
p0
.
y
)
PicturePoint
:
:
new
(
p1
.
x
pc
.
y
)
)
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
pc
.
y
)
PicturePoint
:
:
new
(
pc
.
x
p1
.
y
)
)
PictureBox2D
:
:
new
(
pc
p1
)
]
;
}
fn
clear
(
&
mut
self
rect
:
PictureBox2D
)
{
self
.
rect
=
rect
;
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
prev_indices
ref
mut
curr_indices
ref
mut
dirty_tracker
ref
mut
frames_since_modified
}
=
>
{
mem
:
:
swap
(
prev_indices
curr_indices
)
;
curr_indices
.
clear
(
)
;
*
dirty_tracker
=
*
dirty_tracker
<
<
1
;
*
frames_since_modified
+
=
1
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
mut
child_rects
=
[
PictureBox2D
:
:
zero
(
)
;
4
]
;
TileNode
:
:
get_child_rects
(
&
rect
&
mut
child_rects
)
;
assert_eq
!
(
child_rects
.
len
(
)
children
.
len
(
)
)
;
for
(
child
rect
)
in
children
.
iter_mut
(
)
.
zip
(
child_rects
.
iter
(
)
)
{
child
.
clear
(
*
rect
)
;
}
}
}
}
fn
add_prim
(
&
mut
self
index
:
PrimitiveDependencyIndex
prim_rect
:
&
PictureBox2D
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
curr_indices
.
push
(
index
)
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
if
child
.
rect
.
intersects
(
prim_rect
)
{
child
.
add_prim
(
index
prim_rect
)
;
}
}
}
}
}
fn
maybe_merge_or_split
(
&
mut
self
level
:
i32
curr_prims
:
&
[
PrimitiveDescriptor
]
max_split_levels
:
i32
)
{
let
mut
tile_mod
=
None
;
fn
get_dirty_frames
(
dirty_tracker
:
u64
frames_since_modified
:
usize
)
-
>
Option
<
u32
>
{
if
frames_since_modified
>
64
{
Some
(
dirty_tracker
.
count_ones
(
)
)
}
else
{
None
}
}
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
frames_since_modified
.
.
}
=
>
{
if
level
<
max_split_levels
{
if
let
Some
(
dirty_frames
)
=
get_dirty_frames
(
dirty_tracker
frames_since_modified
)
{
if
dirty_frames
>
32
{
tile_mod
=
Some
(
TileModification
:
:
Split
)
;
}
}
}
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
let
mut
static_count
=
0
;
let
mut
changing_count
=
0
;
for
child
in
children
{
if
let
TileNodeKind
:
:
Leaf
{
dirty_tracker
frames_since_modified
.
.
}
=
child
.
kind
{
if
let
Some
(
dirty_frames
)
=
get_dirty_frames
(
dirty_tracker
frames_since_modified
)
{
if
dirty_frames
=
=
0
{
static_count
+
=
1
;
}
else
if
dirty_frames
=
=
64
{
changing_count
+
=
1
;
}
}
}
if
static_count
=
=
4
|
|
changing_count
=
=
4
{
tile_mod
=
Some
(
TileModification
:
:
Merge
)
;
}
}
}
}
match
tile_mod
{
Some
(
TileModification
:
:
Split
)
=
>
{
let
curr_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
only
leaves
can
split
"
)
;
}
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
curr_indices
.
take
(
)
}
}
;
let
mut
child_rects
=
[
PictureBox2D
:
:
zero
(
)
;
4
]
;
TileNode
:
:
get_child_rects
(
&
self
.
rect
&
mut
child_rects
)
;
let
mut
child_indices
=
[
Vec
:
:
new
(
)
Vec
:
:
new
(
)
Vec
:
:
new
(
)
Vec
:
:
new
(
)
]
;
for
index
in
curr_indices
{
let
prim
=
&
curr_prims
[
index
.
0
as
usize
]
;
for
(
child_rect
indices
)
in
child_rects
.
iter
(
)
.
zip
(
child_indices
.
iter_mut
(
)
)
{
if
prim
.
prim_clip_box
.
intersects
(
child_rect
)
{
indices
.
push
(
index
)
;
}
}
}
let
children
=
child_indices
.
iter_mut
(
)
.
map
(
|
i
|
TileNode
:
:
new_leaf
(
mem
:
:
replace
(
i
Vec
:
:
new
(
)
)
)
)
.
collect
(
)
;
self
.
kind
=
TileNodeKind
:
:
Node
{
children
}
;
}
Some
(
TileModification
:
:
Merge
)
=
>
{
let
merged_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
mut
merged_indices
=
Vec
:
:
new
(
)
;
for
child
in
children
.
iter
(
)
{
let
child_indices
=
match
child
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
curr_indices
.
.
}
=
>
{
curr_indices
}
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
:
child
is
not
a
leaf
"
)
;
}
}
;
merged_indices
.
extend_from_slice
(
child_indices
)
;
}
merged_indices
.
sort
(
)
;
merged_indices
.
dedup
(
)
;
merged_indices
}
TileNodeKind
:
:
Leaf
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
trying
to
merge
a
leaf
"
)
;
}
}
;
self
.
kind
=
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
:
merged_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
;
}
None
=
>
{
if
let
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
self
.
kind
{
for
child
in
children
.
iter_mut
(
)
{
child
.
maybe_merge_or_split
(
level
+
1
curr_prims
max_split_levels
)
;
}
}
}
}
}
fn
update_dirty_rects
(
&
mut
self
prev_prims
:
&
[
PrimitiveDescriptor
]
curr_prims
:
&
[
PrimitiveDescriptor
]
prim_comparer
:
&
mut
PrimitiveComparer
dirty_rect
:
&
mut
PictureBox2D
compare_cache
:
&
mut
FastHashMap
<
PrimitiveComparisonKey
PrimitiveCompareResult
>
invalidation_reason
:
&
mut
Option
<
InvalidationReason
>
frame_context
:
&
FrameVisibilityContext
)
{
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
child
.
update_dirty_rects
(
prev_prims
curr_prims
prim_comparer
dirty_rect
compare_cache
invalidation_reason
frame_context
)
;
}
}
TileNodeKind
:
:
Leaf
{
ref
prev_indices
ref
curr_indices
ref
mut
dirty_tracker
.
.
}
=
>
{
if
prev_indices
.
len
(
)
=
=
curr_indices
.
len
(
)
{
let
mut
prev_i0
=
0
;
let
mut
prev_i1
=
0
;
prim_comparer
.
reset
(
)
;
for
(
prev_index
curr_index
)
in
prev_indices
.
iter
(
)
.
zip
(
curr_indices
.
iter
(
)
)
{
let
i0
=
prev_index
.
0
as
usize
;
let
i1
=
curr_index
.
0
as
usize
;
for
i
in
prev_i0
.
.
i0
{
prim_comparer
.
advance_prev
(
&
prev_prims
[
i
]
)
;
}
for
i
in
prev_i1
.
.
i1
{
prim_comparer
.
advance_curr
(
&
curr_prims
[
i
]
)
;
}
let
key
=
PrimitiveComparisonKey
{
prev_index
:
*
prev_index
curr_index
:
*
curr_index
}
;
let
prim_compare_result
=
*
compare_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
prev
=
&
prev_prims
[
i0
]
;
let
curr
=
&
curr_prims
[
i1
]
;
prim_comparer
.
compare_prim
(
prev
curr
)
}
)
;
if
prim_compare_result
!
=
PrimitiveCompareResult
:
:
Equal
{
if
invalidation_reason
.
is_none
(
)
{
*
invalidation_reason
=
Some
(
InvalidationReason
:
:
Content
)
;
}
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
break
;
}
prev_i0
=
i0
;
prev_i1
=
i1
;
}
}
else
{
if
invalidation_reason
.
is_none
(
)
{
*
invalidation_reason
=
Some
(
InvalidationReason
:
:
PrimCount
)
;
}
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
}
}
}
}
}
impl
CompositeState
{
pub
fn
destroy_native_tiles
<
'
a
I
:
Iterator
<
Item
=
&
'
a
mut
Box
<
Tile
>
>
>
(
&
mut
self
tiles_iter
:
I
resource_cache
:
&
mut
ResourceCache
)
{
if
let
CompositorKind
:
:
Native
{
.
.
}
=
self
.
compositor_kind
{
for
tile
in
tiles_iter
{
if
let
Some
(
TileSurface
:
:
Texture
{
descriptor
:
SurfaceTextureDescriptor
:
:
Native
{
ref
mut
id
.
.
}
.
.
}
)
=
tile
.
surface
{
if
let
Some
(
id
)
=
id
.
take
(
)
{
resource_cache
.
destroy_compositor_tile
(
id
)
;
}
}
}
}
}
}
fn
get_relative_scale_offset
(
child_spatial_node_index
:
SpatialNodeIndex
parent_spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
-
>
ScaleOffset
{
let
transform
=
spatial_tree
.
get_relative_transform
(
child_spatial_node_index
parent_spatial_node_index
)
;
let
mut
scale_offset
=
match
transform
{
CoordinateSpaceMapping
:
:
Local
=
>
ScaleOffset
:
:
identity
(
)
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
=
>
scale_offset
CoordinateSpaceMapping
:
:
Transform
(
m
)
=
>
{
ScaleOffset
:
:
from_transform
(
&
m
)
.
expect
(
"
bug
:
pictures
caches
don
'
t
support
complex
transforms
"
)
}
}
;
scale_offset
.
offset
=
scale_offset
.
offset
.
round
(
)
;
scale_offset
}
pub
fn
calculate_screen_uv
(
p
:
DevicePoint
clipped
:
DeviceRect
)
-
>
DeviceHomogeneousVector
{
DeviceHomogeneousVector
:
:
new
(
(
p
.
x
-
clipped
.
min
.
x
)
/
(
clipped
.
max
.
x
-
clipped
.
min
.
x
)
(
p
.
y
-
clipped
.
min
.
y
)
/
(
clipped
.
max
.
y
-
clipped
.
min
.
y
)
0
.
0
1
.
0
)
}
fn
get_surface_rects
(
surface_index
:
SurfaceIndex
composite_mode
:
&
PictureCompositeMode
parent_surface_index
:
SurfaceIndex
surfaces
:
&
mut
[
SurfaceInfo
]
spatial_tree
:
&
SpatialTree
max_surface_size
:
f32
)
-
>
Option
<
SurfaceAllocInfo
>
{
let
parent_surface
=
&
surfaces
[
parent_surface_index
.
0
]
;
let
local_to_parent
=
SpaceMapper
:
:
new_with_target
(
parent_surface
.
surface_spatial_node_index
surfaces
[
surface_index
.
0
]
.
surface_spatial_node_index
parent_surface
.
clipping_rect
spatial_tree
)
;
let
local_clip_rect
=
local_to_parent
.
unmap
(
&
parent_surface
.
clipping_rect
)
.
unwrap_or
(
PictureRect
:
:
max_rect
(
)
)
.
cast_unit
(
)
;
let
surface
=
&
mut
surfaces
[
surface_index
.
0
]
;
let
(
clipped_local
unclipped_local
)
=
match
composite_mode
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
local_prim_rect
=
surface
.
clipped_local_rect
;
let
mut
required_local_rect
=
match
local_prim_rect
.
intersection
(
&
local_clip_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
for
shadow
in
shadows
{
let
(
blur_radius_x
blur_radius_y
)
=
surface
.
clamp_blur_radius
(
shadow
.
blur_radius
shadow
.
blur_radius
)
;
let
blur_inflation_x
=
blur_radius_x
*
BLUR_SAMPLE_SCALE
;
let
blur_inflation_y
=
blur_radius_y
*
BLUR_SAMPLE_SCALE
;
let
local_shadow_rect
=
local_prim_rect
.
translate
(
shadow
.
offset
.
cast_unit
(
)
)
;
if
let
Some
(
clipped_shadow_rect
)
=
local_clip_rect
.
intersection
(
&
local_shadow_rect
)
{
let
required_shadow_rect
=
clipped_shadow_rect
.
inflate
(
blur_inflation_x
blur_inflation_y
)
;
let
local_clipped_shadow_rect
=
required_shadow_rect
.
translate
(
-
shadow
.
offset
.
cast_unit
(
)
)
;
required_local_rect
=
required_local_rect
.
union
(
&
local_clipped_shadow_rect
)
;
}
}
let
unclipped
=
composite_mode
.
get_rect
(
surface
None
)
;
let
clipped
=
required_local_rect
;
let
clipped
=
match
clipped
.
intersection
(
&
unclipped
.
cast_unit
(
)
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
(
clipped
unclipped
)
}
_
=
>
{
let
surface_origin
=
surface
.
clipped_local_rect
.
min
.
to_vector
(
)
.
cast_unit
(
)
;
let
normalized_prim_rect
=
composite_mode
.
get_rect
(
surface
None
)
.
translate
(
-
surface_origin
)
;
let
normalized_clip_rect
=
local_clip_rect
.
cast_unit
(
)
.
translate
(
-
surface_origin
)
;
let
norm_clipped_rect
=
match
normalized_prim_rect
.
intersection
(
&
normalized_clip_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
norm_clipped_rect
=
composite_mode
.
get_rect
(
surface
Some
(
norm_clipped_rect
)
)
;
let
norm_clipped_rect
=
match
norm_clipped_rect
.
intersection
(
&
normalized_prim_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
None
}
;
let
unclipped
=
normalized_prim_rect
.
translate
(
surface_origin
)
;
let
clipped
=
norm_clipped_rect
.
translate
(
surface_origin
)
;
(
clipped
.
cast_unit
(
)
unclipped
.
cast_unit
(
)
)
}
}
;
let
(
mut
clipped
mut
unclipped
)
=
if
surface
.
raster_spatial_node_index
!
=
surface
.
surface_spatial_node_index
{
assert_eq
!
(
surface
.
device_pixel_scale
.
0
1
.
0
)
;
let
local_to_world
=
SpaceMapper
:
:
new_with_target
(
spatial_tree
.
root_reference_frame_index
(
)
surface
.
surface_spatial_node_index
WorldRect
:
:
max_rect
(
)
spatial_tree
)
;
let
clipped
=
(
local_to_world
.
map
(
&
clipped_local
.
cast_unit
(
)
)
.
unwrap
(
)
*
surface
.
device_pixel_scale
)
.
round_out
(
)
;
let
unclipped
=
local_to_world
.
map
(
&
unclipped_local
)
.
unwrap
(
)
*
surface
.
device_pixel_scale
;
(
clipped
unclipped
)
}
else
{
let
clipped
=
(
clipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
)
.
round_out
(
)
;
let
unclipped
=
unclipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
(
clipped
unclipped
)
}
;
let
task_size_f
=
clipped
.
size
(
)
;
if
task_size_f
.
width
>
max_surface_size
|
|
task_size_f
.
height
>
max_surface_size
{
let
max_dimension
=
clipped_local
.
width
(
)
.
max
(
clipped_local
.
height
(
)
)
.
ceil
(
)
;
surface
.
raster_spatial_node_index
=
surface
.
surface_spatial_node_index
;
surface
.
device_pixel_scale
=
Scale
:
:
new
(
max_surface_size
/
max_dimension
)
;
clipped
=
(
clipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
)
.
round
(
)
;
unclipped
=
unclipped_local
.
cast_unit
(
)
*
surface
.
device_pixel_scale
;
}
let
task_size
=
clipped
.
size
(
)
.
to_i32
(
)
;
debug_assert
!
(
task_size
.
width
<
=
max_surface_size
as
i32
)
;
debug_assert
!
(
task_size
.
height
<
=
max_surface_size
as
i32
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
clipped
unclipped
)
;
if
task_size
.
width
=
=
0
|
|
task_size
.
height
=
=
0
{
return
None
;
}
let
needs_scissor_rect
=
!
clipped_local
.
contains_box
(
&
surface
.
unclipped_local_rect
)
;
Some
(
SurfaceAllocInfo
{
task_size
needs_scissor_rect
clipped
unclipped
clipped_local
uv_rect_kind
}
)
}
fn
calculate_uv_rect_kind
(
clipped
:
DeviceRect
unclipped
:
DeviceRect
)
-
>
UvRectKind
{
let
top_left
=
calculate_screen_uv
(
unclipped
.
top_left
(
)
.
cast_unit
(
)
clipped
)
;
let
top_right
=
calculate_screen_uv
(
unclipped
.
top_right
(
)
.
cast_unit
(
)
clipped
)
;
let
bottom_left
=
calculate_screen_uv
(
unclipped
.
bottom_left
(
)
.
cast_unit
(
)
clipped
)
;
let
bottom_right
=
calculate_screen_uv
(
unclipped
.
bottom_right
(
)
.
cast_unit
(
)
clipped
)
;
UvRectKind
:
:
Quad
{
top_left
top_right
bottom_left
bottom_right
}
}
#
[
test
]
fn
test_large_surface_scale_1
(
)
{
use
crate
:
:
spatial_tree
:
:
{
SceneSpatialTree
SpatialTree
}
;
let
mut
cst
=
SceneSpatialTree
:
:
new
(
)
;
let
root_reference_frame_index
=
cst
.
root_reference_frame_index
(
)
;
let
mut
spatial_tree
=
SpatialTree
:
:
new
(
)
;
spatial_tree
.
apply_updates
(
cst
.
end_frame_and_get_pending_updates
(
)
)
;
spatial_tree
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
let
map_local_to_surface
=
SpaceMapper
:
:
new_with_target
(
root_reference_frame_index
root_reference_frame_index
PictureRect
:
:
max_rect
(
)
&
spatial_tree
)
;
let
mut
surfaces
=
vec
!
[
SurfaceInfo
{
unclipped_local_rect
:
PictureRect
:
:
max_rect
(
)
clipped_local_rect
:
PictureRect
:
:
max_rect
(
)
is_opaque
:
true
clipping_rect
:
PictureRect
:
:
max_rect
(
)
map_local_to_surface
:
map_local_to_surface
.
clone
(
)
raster_spatial_node_index
:
root_reference_frame_index
surface_spatial_node_index
:
root_reference_frame_index
device_pixel_scale
:
DevicePixelScale
:
:
new
(
1
.
0
)
world_scale_factors
:
(
1
.
0
1
.
0
)
local_scale
:
(
1
.
0
1
.
0
)
allow_snapping
:
true
}
SurfaceInfo
{
unclipped_local_rect
:
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
52
.
76350021362305
0
.
0
)
PicturePoint
:
:
new
(
159
.
6738739013672
35
.
0
)
)
clipped_local_rect
:
PictureRect
:
:
max_rect
(
)
is_opaque
:
true
clipping_rect
:
PictureRect
:
:
max_rect
(
)
map_local_to_surface
raster_spatial_node_index
:
root_reference_frame_index
surface_spatial_node_index
:
root_reference_frame_index
device_pixel_scale
:
DevicePixelScale
:
:
new
(
43
.
82798767089844
)
world_scale_factors
:
(
1
.
0
1
.
0
)
local_scale
:
(
1
.
0
1
.
0
)
allow_snapping
:
true
}
]
;
get_surface_rects
(
SurfaceIndex
(
1
)
&
PictureCompositeMode
:
:
Blit
(
BlitReason
:
:
ISOLATE
)
SurfaceIndex
(
0
)
&
mut
surfaces
&
spatial_tree
MAX_SURFACE_SIZE
as
f32
)
;
}
