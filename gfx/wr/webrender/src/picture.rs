use
api
:
:
{
MixBlendMode
PipelineId
PremultipliedColorF
FilterPrimitiveKind
}
;
use
api
:
:
{
PropertyBinding
PropertyBindingId
FilterPrimitive
FontRenderMode
}
;
use
api
:
:
{
DebugFlags
RasterSpace
ImageKey
ColorF
PrimitiveFlags
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
box_shadow
:
:
{
BLUR_SAMPLE_SCALE
}
;
use
crate
:
:
clip
:
:
{
ClipStore
ClipChainInstance
ClipDataHandle
ClipChainId
}
;
use
crate
:
:
clip_scroll_tree
:
:
{
ROOT_SPATIAL_NODE_INDEX
ClipScrollTree
CoordinateSpaceMapping
SpatialNodeIndex
VisibleFace
CoordinateSystemId
}
;
use
crate
:
:
debug_colors
;
use
euclid
:
:
{
vec3
Point2D
Scale
Size2D
Vector2D
Rect
}
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
crate
:
:
filterdata
:
:
SFilterData
;
use
crate
:
:
frame_builder
:
:
{
FrameVisibilityContext
FrameVisibilityState
}
;
use
crate
:
:
intern
:
:
ItemUid
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FastHashSet
PlaneSplitter
Filter
PlaneSplitAnchor
}
;
use
crate
:
:
frame_builder
:
:
{
FrameBuildingContext
FrameBuildingState
PictureState
PictureContext
}
;
use
crate
:
:
gpu_cache
:
:
{
GpuCache
GpuCacheAddress
GpuCacheHandle
}
;
use
crate
:
:
gpu_types
:
:
UvRectKind
;
use
plane_split
:
:
{
Clipper
Polygon
Splitter
}
;
use
crate
:
:
prim_store
:
:
{
SpaceMapper
PrimitiveVisibilityMask
PointKey
PrimitiveTemplateKind
}
;
use
crate
:
:
prim_store
:
:
{
SpaceSnapper
PictureIndex
PrimitiveInstance
PrimitiveInstanceKind
}
;
use
crate
:
:
prim_store
:
:
{
get_raster_rects
PrimitiveScratchBuffer
RectangleKey
}
;
use
crate
:
:
prim_store
:
:
{
OpacityBindingStorage
ImageInstanceStorage
OpacityBindingIndex
}
;
use
crate
:
:
print_tree
:
:
PrintTreePrinter
;
use
crate
:
:
render_backend
:
:
DataStores
;
use
crate
:
:
render_task_graph
:
:
RenderTaskId
;
use
crate
:
:
render_target
:
:
RenderTargetKind
;
use
crate
:
:
render_task
:
:
{
RenderTask
RenderTaskLocation
BlurTaskCache
ClearMode
}
;
use
crate
:
:
resource_cache
:
:
ResourceCache
;
use
crate
:
:
scene
:
:
SceneProperties
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
{
mem
u8
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
crate
:
:
texture_cache
:
:
TextureCacheHandle
;
use
crate
:
:
util
:
:
{
TransformedRectKind
MatrixHelpers
MaxRect
scale_factors
VecHelper
subtract_rect
}
;
use
crate
:
:
filterdata
:
:
{
FilterDataHandle
}
;
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
enum
SubpixelMode
{
Allow
Deny
}
#
[
derive
(
Debug
Clone
)
]
struct
MatrixKey
{
m
:
[
f32
;
16
]
}
impl
PartialEq
for
MatrixKey
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
for
(
i
j
)
in
self
.
m
.
iter
(
)
.
zip
(
other
.
m
.
iter
(
)
)
{
if
!
i
.
approx_eq_eps
(
j
&
EPSILON
)
{
return
false
;
}
}
true
}
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
enum
TransformKey
{
Local
ScaleOffset
{
scale_x
:
f32
scale_y
:
f32
offset_x
:
f32
offset_y
:
f32
}
Transform
{
m
:
MatrixKey
}
}
impl
<
Src
Dst
>
From
<
CoordinateSpaceMapping
<
Src
Dst
>
>
for
TransformKey
{
fn
from
(
transform
:
CoordinateSpaceMapping
<
Src
Dst
>
)
-
>
TransformKey
{
match
transform
{
CoordinateSpaceMapping
:
:
Local
=
>
{
TransformKey
:
:
Local
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
TransformKey
:
:
ScaleOffset
{
scale_x
:
scale_offset
.
scale
.
x
scale_y
:
scale_offset
.
scale
.
y
offset_x
:
scale_offset
.
offset
.
x
offset_y
:
scale_offset
.
offset
.
y
}
}
CoordinateSpaceMapping
:
:
Transform
(
ref
m
)
=
>
{
TransformKey
:
:
Transform
{
m
:
MatrixKey
{
m
:
m
.
to_row_major_array
(
)
}
}
}
}
}
}
struct
PictureInfo
{
_spatial_node_index
:
SpatialNodeIndex
}
pub
struct
PictureCacheState
{
pub
tiles
:
FastHashMap
<
TileOffset
Tile
>
fract_offset
:
PictureVector2D
spatial_nodes
:
FastHashMap
<
SpatialNodeIndex
SpatialNodeDependency
>
opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
root_transform
:
TransformKey
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
RetainedTiles
{
#
[
cfg_attr
(
feature
=
"
capture
"
serde
(
skip
)
)
]
pub
caches
:
FastHashMap
<
usize
PictureCacheState
>
}
impl
RetainedTiles
{
pub
fn
new
(
)
-
>
Self
{
RetainedTiles
{
caches
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
merge
(
&
mut
self
other
:
RetainedTiles
)
{
assert
!
(
self
.
caches
.
is_empty
(
)
|
|
other
.
caches
.
is_empty
(
)
)
;
if
self
.
caches
.
is_empty
(
)
{
self
.
caches
=
other
.
caches
;
}
}
}
#
[
derive
(
Hash
Clone
Copy
Debug
Eq
PartialEq
Ord
PartialOrd
)
]
pub
struct
TileCoordinate
;
pub
type
TileOffset
=
Point2D
<
i32
TileCoordinate
>
;
pub
type
TileSize
=
Size2D
<
i32
TileCoordinate
>
;
pub
type
TileRect
=
Rect
<
i32
TileCoordinate
>
;
pub
const
TILE_SIZE_WIDTH
:
i32
=
2048
;
pub
const
TILE_SIZE_HEIGHT
:
i32
=
512
;
const
MAX_SURFACE_SIZE
:
f32
=
4096
.
0
;
const
MAX_PRIM_SUB_DEPS
:
usize
=
u8
:
:
MAX
as
usize
;
static
NEXT_TILE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
fn
clamp
(
value
:
i32
low
:
i32
high
:
i32
)
-
>
i32
{
value
.
max
(
low
)
.
min
(
high
)
}
fn
clampf
(
value
:
f32
low
:
f32
high
:
f32
)
-
>
f32
{
value
.
max
(
low
)
.
min
(
high
)
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
Eq
PartialOrd
Ord
Hash
)
]
struct
PrimitiveDependencyIndex
(
u32
)
;
#
[
derive
(
Debug
)
]
pub
struct
OpacityBindingInfo
{
value
:
f32
changed
:
bool
}
#
[
derive
(
Debug
PartialEq
Clone
)
]
pub
enum
OpacityBinding
{
Value
(
f32
)
Binding
(
PropertyBindingId
)
}
impl
From
<
PropertyBinding
<
f32
>
>
for
OpacityBinding
{
fn
from
(
binding
:
PropertyBinding
<
f32
>
)
-
>
OpacityBinding
{
match
binding
{
PropertyBinding
:
:
Binding
(
key
_
)
=
>
OpacityBinding
:
:
Binding
(
key
.
id
)
PropertyBinding
:
:
Value
(
value
)
=
>
OpacityBinding
:
:
Value
(
value
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
SpatialNodeDependency
{
value
:
TransformKey
changed
:
bool
}
struct
TilePreUpdateContext
{
local_rect
:
PictureRect
local_clip_rect
:
PictureRect
pic_to_world_mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
fract_changed
:
bool
background_color
:
Option
<
ColorF
>
}
struct
TilePostUpdateContext
<
'
a
>
{
debug_flags
:
DebugFlags
global_device_pixel_scale
:
DevicePixelScale
global_screen_world_rect
:
WorldRect
backdrop
:
BackdropInfo
spatial_nodes
:
&
'
a
FastHashMap
<
SpatialNodeIndex
SpatialNodeDependency
>
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
pic_to_world_mapper
:
SpaceMapper
<
PicturePixel
WorldPixel
>
}
struct
TilePostUpdateState
<
'
a
>
{
scratch
:
&
'
a
mut
PrimitiveScratchBuffer
dirty_region
:
&
'
a
mut
DirtyRegion
resource_cache
:
&
'
a
mut
ResourceCache
gpu_cache
:
&
'
a
mut
GpuCache
}
struct
PrimitiveDependencyInfo
{
is_cacheable
:
bool
clip_by_tile
:
bool
prim_uid
:
ItemUid
prim_rect
:
PictureRect
prim_clip_rect
:
PictureRect
image_keys
:
SmallVec
<
[
ImageKey
;
8
]
>
opacity_bindings
:
SmallVec
<
[
OpacityBinding
;
4
]
>
clips
:
SmallVec
<
[
ItemUid
;
8
]
>
spatial_nodes
:
SmallVec
<
[
SpatialNodeIndex
;
4
]
>
}
impl
PrimitiveDependencyInfo
{
fn
new
(
prim_uid
:
ItemUid
prim_rect
:
PictureRect
is_cacheable
:
bool
)
-
>
Self
{
PrimitiveDependencyInfo
{
prim_uid
prim_rect
is_cacheable
image_keys
:
SmallVec
:
:
new
(
)
opacity_bindings
:
SmallVec
:
:
new
(
)
clip_by_tile
:
false
prim_clip_rect
:
PictureRect
:
:
zero
(
)
clips
:
SmallVec
:
:
new
(
)
spatial_nodes
:
SmallVec
:
:
new
(
)
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
struct
TileId
(
usize
)
;
#
[
derive
(
Debug
)
]
pub
enum
TileSurface
{
Texture
{
handle
:
TextureCacheHandle
visibility_mask
:
PrimitiveVisibilityMask
}
Color
{
color
:
ColorF
}
}
impl
TileSurface
{
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
TileSurface
:
:
Color
{
.
.
}
=
>
"
Color
"
TileSurface
:
:
Texture
{
.
.
}
=
>
"
Texture
"
}
}
}
pub
struct
Tile
{
pub
world_rect
:
WorldRect
pub
rect
:
PictureRect
clipped_rect
:
PictureRect
pub
current_descriptor
:
TileDescriptor
pub
prev_descriptor
:
TileDescriptor
pub
surface
:
Option
<
TileSurface
>
pub
is_valid
:
bool
is_same_content
:
bool
pub
id
:
TileId
pub
is_opaque
:
bool
root
:
TileNode
dirty_rect
:
PictureRect
world_dirty_rect
:
WorldRect
background_color
:
Option
<
ColorF
>
}
impl
Tile
{
fn
new
(
id
:
TileId
)
-
>
Self
{
Tile
{
rect
:
PictureRect
:
:
zero
(
)
clipped_rect
:
PictureRect
:
:
zero
(
)
world_rect
:
WorldRect
:
:
zero
(
)
surface
:
None
current_descriptor
:
TileDescriptor
:
:
new
(
)
prev_descriptor
:
TileDescriptor
:
:
new
(
)
is_same_content
:
false
is_valid
:
false
id
is_opaque
:
false
root
:
TileNode
:
:
new_leaf
(
Vec
:
:
new
(
)
)
dirty_rect
:
PictureRect
:
:
zero
(
)
world_dirty_rect
:
WorldRect
:
:
zero
(
)
background_color
:
None
}
}
fn
update_dirty_rects
(
&
mut
self
ctx
:
&
TilePostUpdateContext
state
:
&
TilePostUpdateState
compare_cache
:
&
mut
FastHashMap
<
PrimitiveComparisonKey
bool
>
)
{
let
mut
prim_comparer
=
PrimitiveComparer
:
:
new
(
&
self
.
prev_descriptor
&
self
.
current_descriptor
state
.
resource_cache
ctx
.
spatial_nodes
ctx
.
opacity_bindings
)
;
self
.
root
.
update_dirty_rects
(
&
self
.
prev_descriptor
.
prims
&
self
.
current_descriptor
.
prims
&
mut
prim_comparer
&
mut
self
.
dirty_rect
compare_cache
)
;
}
fn
update_content_validity
(
&
mut
self
ctx
:
&
TilePostUpdateContext
state
:
&
TilePostUpdateState
)
{
let
mut
compare_cache
=
FastHashMap
:
:
default
(
)
;
self
.
update_dirty_rects
(
ctx
state
&
mut
compare_cache
)
;
self
.
is_same_content
&
=
self
.
dirty_rect
.
is_empty
(
)
;
self
.
is_valid
&
=
self
.
is_same_content
;
}
fn
pre_update
(
&
mut
self
rect
:
PictureRect
ctx
:
&
TilePreUpdateContext
)
{
self
.
rect
=
rect
;
self
.
clipped_rect
=
self
.
rect
.
intersection
(
&
ctx
.
local_rect
)
.
and_then
(
|
r
|
r
.
intersection
(
&
ctx
.
local_clip_rect
)
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
;
self
.
world_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
rect
)
.
expect
(
"
bug
:
map
local
tile
rect
"
)
;
self
.
is_same_content
=
true
;
if
ctx
.
fract_changed
|
|
ctx
.
background_color
!
=
self
.
background_color
{
self
.
background_color
=
ctx
.
background_color
;
self
.
is_same_content
=
false
;
self
.
dirty_rect
=
rect
;
}
mem
:
:
swap
(
&
mut
self
.
current_descriptor
&
mut
self
.
prev_descriptor
)
;
self
.
current_descriptor
.
clear
(
)
;
self
.
root
.
clear
(
rect
)
;
}
fn
add_prim_dependency
(
&
mut
self
info
:
&
PrimitiveDependencyInfo
)
{
if
!
info
.
is_cacheable
{
self
.
is_same_content
=
false
;
self
.
dirty_rect
=
self
.
dirty_rect
.
union
(
&
info
.
prim_rect
)
;
}
self
.
current_descriptor
.
image_keys
.
extend_from_slice
(
&
info
.
image_keys
)
;
self
.
current_descriptor
.
opacity_bindings
.
extend_from_slice
(
&
info
.
opacity_bindings
)
;
self
.
current_descriptor
.
clips
.
extend_from_slice
(
&
info
.
clips
)
;
self
.
current_descriptor
.
transforms
.
extend_from_slice
(
&
info
.
spatial_nodes
)
;
let
(
prim_origin
prim_clip_rect
)
=
if
info
.
clip_by_tile
{
let
tile_p0
=
self
.
rect
.
origin
;
let
tile_p1
=
self
.
rect
.
bottom_right
(
)
;
let
clip_p0
=
PicturePoint
:
:
new
(
clampf
(
info
.
prim_clip_rect
.
origin
.
x
tile_p0
.
x
tile_p1
.
x
)
clampf
(
info
.
prim_clip_rect
.
origin
.
y
tile_p0
.
y
tile_p1
.
y
)
)
;
let
clip_p1
=
PicturePoint
:
:
new
(
clampf
(
info
.
prim_clip_rect
.
origin
.
x
+
info
.
prim_clip_rect
.
size
.
width
tile_p0
.
x
tile_p1
.
x
)
clampf
(
info
.
prim_clip_rect
.
origin
.
y
+
info
.
prim_clip_rect
.
size
.
height
tile_p0
.
y
tile_p1
.
y
)
)
;
(
PicturePoint
:
:
new
(
clampf
(
info
.
prim_rect
.
origin
.
x
tile_p0
.
x
tile_p1
.
x
)
clampf
(
info
.
prim_rect
.
origin
.
y
tile_p0
.
y
tile_p1
.
y
)
)
PictureRect
:
:
new
(
clip_p0
PictureSize
:
:
new
(
clip_p1
.
x
-
clip_p0
.
x
clip_p1
.
y
-
clip_p0
.
y
)
)
)
}
else
{
(
info
.
prim_rect
.
origin
info
.
prim_clip_rect
)
}
;
let
prim_index
=
PrimitiveDependencyIndex
(
self
.
current_descriptor
.
prims
.
len
(
)
as
u32
)
;
debug_assert
!
(
info
.
spatial_nodes
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
clips
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
image_keys
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
debug_assert
!
(
info
.
opacity_bindings
.
len
(
)
<
=
MAX_PRIM_SUB_DEPS
)
;
self
.
current_descriptor
.
prims
.
push
(
PrimitiveDescriptor
{
prim_uid
:
info
.
prim_uid
origin
:
prim_origin
.
into
(
)
prim_clip_rect
:
prim_clip_rect
.
into
(
)
transform_dep_count
:
info
.
spatial_nodes
.
len
(
)
as
u8
clip_dep_count
:
info
.
clips
.
len
(
)
as
u8
image_dep_count
:
info
.
image_keys
.
len
(
)
as
u8
opacity_binding_dep_count
:
info
.
opacity_bindings
.
len
(
)
as
u8
}
)
;
self
.
root
.
add_prim
(
prim_index
&
info
.
prim_rect
)
;
}
fn
post_update
(
&
mut
self
ctx
:
&
TilePostUpdateContext
state
:
&
mut
TilePostUpdateState
)
-
>
bool
{
self
.
is_opaque
=
ctx
.
backdrop
.
rect
.
contains_rect
(
&
self
.
clipped_rect
)
;
self
.
update_content_validity
(
ctx
state
)
;
if
self
.
current_descriptor
.
prims
.
is_empty
(
)
{
return
false
;
}
if
!
self
.
world_rect
.
intersects
(
&
ctx
.
global_screen_world_rect
)
{
return
false
;
}
self
.
root
.
maybe_merge_or_split
(
0
&
self
.
current_descriptor
.
prims
)
;
let
is_solid_color
=
self
.
current_descriptor
.
prims
.
len
(
)
=
=
1
&
&
self
.
is_opaque
;
let
mut
surface
=
if
is_solid_color
{
TileSurface
:
:
Color
{
color
:
ctx
.
backdrop
.
color
}
}
else
{
match
self
.
surface
.
take
(
)
{
Some
(
old_surface
TileSurface
:
:
Texture
{
.
.
}
)
=
>
{
old_surface
}
Some
(
TileSurface
:
:
Color
{
.
.
}
)
|
None
=
>
{
TileSurface
:
:
Texture
{
handle
:
TextureCacheHandle
:
:
invalid
(
)
visibility_mask
:
PrimitiveVisibilityMask
:
:
empty
(
)
}
}
}
}
;
if
let
TileSurface
:
:
Texture
{
ref
handle
.
.
}
=
surface
{
if
state
.
resource_cache
.
texture_cache
.
is_allocated
(
handle
)
{
state
.
resource_cache
.
texture_cache
.
request
(
handle
state
.
gpu_cache
)
;
}
else
{
self
.
is_valid
=
false
;
self
.
dirty_rect
=
self
.
rect
;
}
}
self
.
world_dirty_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
dirty_rect
)
.
expect
(
"
bug
"
)
;
if
ctx
.
debug_flags
.
contains
(
DebugFlags
:
:
PICTURE_CACHING_DBG
)
{
self
.
root
.
draw_debug_rects
(
&
ctx
.
pic_to_world_mapper
self
.
is_opaque
state
.
scratch
ctx
.
global_device_pixel_scale
)
;
let
label_offset
=
DeviceVector2D
:
:
new
(
20
.
0
30
.
0
)
;
let
tile_device_rect
=
self
.
world_rect
*
ctx
.
global_device_pixel_scale
;
if
tile_device_rect
.
size
.
height
>
=
label_offset
.
y
{
state
.
scratch
.
push_debug_string
(
tile_device_rect
.
origin
+
label_offset
debug_colors
:
:
RED
format
!
(
"
{
:
?
}
:
is_opaque
=
{
}
surface
=
{
}
"
self
.
id
self
.
is_opaque
surface
.
kind
(
)
)
)
;
}
}
if
!
self
.
is_valid
{
if
let
TileSurface
:
:
Texture
{
ref
mut
handle
ref
mut
visibility_mask
}
=
surface
{
if
!
state
.
resource_cache
.
texture_cache
.
is_allocated
(
handle
)
{
let
tile_size
=
DeviceIntSize
:
:
new
(
TILE_SIZE_WIDTH
TILE_SIZE_HEIGHT
)
;
state
.
resource_cache
.
texture_cache
.
update_picture_cache
(
tile_size
handle
state
.
gpu_cache
)
;
}
*
visibility_mask
=
PrimitiveVisibilityMask
:
:
empty
(
)
;
let
dirty_region_index
=
state
.
dirty_region
.
dirty_rects
.
len
(
)
;
if
dirty_region_index
<
PrimitiveVisibilityMask
:
:
MAX_DIRTY_REGIONS
{
visibility_mask
.
set_visible
(
dirty_region_index
)
;
state
.
dirty_region
.
push
(
self
.
world_dirty_rect
*
visibility_mask
)
;
}
else
{
visibility_mask
.
set_visible
(
PrimitiveVisibilityMask
:
:
MAX_DIRTY_REGIONS
-
1
)
;
state
.
dirty_region
.
include_rect
(
PrimitiveVisibilityMask
:
:
MAX_DIRTY_REGIONS
-
1
self
.
world_dirty_rect
)
;
}
}
}
self
.
surface
=
Some
(
surface
)
;
true
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
PrimitiveDescriptor
{
prim_uid
:
ItemUid
origin
:
PointKey
prim_clip_rect
:
RectangleKey
transform_dep_count
:
u8
image_dep_count
:
u8
opacity_binding_dep_count
:
u8
clip_dep_count
:
u8
}
impl
PartialEq
for
PrimitiveDescriptor
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
const
EPSILON
:
f32
=
0
.
001
;
if
self
.
prim_uid
!
=
other
.
prim_uid
{
return
false
;
}
if
!
self
.
origin
.
x
.
approx_eq_eps
(
&
other
.
origin
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
origin
.
y
.
approx_eq_eps
(
&
other
.
origin
.
y
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_rect
.
x
.
approx_eq_eps
(
&
other
.
prim_clip_rect
.
x
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_rect
.
y
.
approx_eq_eps
(
&
other
.
prim_clip_rect
.
y
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_rect
.
w
.
approx_eq_eps
(
&
other
.
prim_clip_rect
.
w
&
EPSILON
)
{
return
false
;
}
if
!
self
.
prim_clip_rect
.
h
.
approx_eq_eps
(
&
other
.
prim_clip_rect
.
h
&
EPSILON
)
{
return
false
;
}
true
}
}
struct
CompareHelper
<
'
a
T
>
{
offset_curr
:
usize
offset_prev
:
usize
curr_items
:
&
'
a
[
T
]
prev_items
:
&
'
a
[
T
]
}
impl
<
'
a
T
>
CompareHelper
<
'
a
T
>
where
T
:
PartialEq
{
fn
new
(
prev_items
:
&
'
a
[
T
]
curr_items
:
&
'
a
[
T
]
)
-
>
Self
{
CompareHelper
{
offset_curr
:
0
offset_prev
:
0
curr_items
prev_items
}
}
fn
reset
(
&
mut
self
)
{
self
.
offset_prev
=
0
;
self
.
offset_curr
=
0
;
}
fn
is_same
<
F
>
(
&
self
prev_count
:
u8
curr_count
:
u8
f
:
F
)
-
>
bool
where
F
:
Fn
(
&
T
)
-
>
bool
{
if
prev_count
!
=
curr_count
{
return
false
;
}
if
curr_count
=
=
0
{
return
true
;
}
if
curr_count
as
usize
=
=
MAX_PRIM_SUB_DEPS
{
return
false
;
}
let
end_prev
=
self
.
offset_prev
+
prev_count
as
usize
;
let
end_curr
=
self
.
offset_curr
+
curr_count
as
usize
;
let
curr_items
=
&
self
.
curr_items
[
self
.
offset_curr
.
.
end_curr
]
;
let
prev_items
=
&
self
.
prev_items
[
self
.
offset_prev
.
.
end_prev
]
;
for
(
curr
prev
)
in
curr_items
.
iter
(
)
.
zip
(
prev_items
.
iter
(
)
)
{
if
prev
!
=
curr
{
return
false
;
}
if
f
(
curr
)
{
return
false
;
}
}
true
}
fn
advance_prev
(
&
mut
self
count
:
u8
)
{
self
.
offset_prev
+
=
count
as
usize
;
}
fn
advance_curr
(
&
mut
self
count
:
u8
)
{
self
.
offset_curr
+
=
count
as
usize
;
}
}
pub
struct
TileDescriptor
{
pub
prims
:
Vec
<
PrimitiveDescriptor
>
clips
:
Vec
<
ItemUid
>
image_keys
:
Vec
<
ImageKey
>
opacity_bindings
:
Vec
<
OpacityBinding
>
transforms
:
Vec
<
SpatialNodeIndex
>
}
impl
TileDescriptor
{
fn
new
(
)
-
>
Self
{
TileDescriptor
{
prims
:
Vec
:
:
new
(
)
clips
:
Vec
:
:
new
(
)
opacity_bindings
:
Vec
:
:
new
(
)
image_keys
:
Vec
:
:
new
(
)
transforms
:
Vec
:
:
new
(
)
}
}
fn
clear
(
&
mut
self
)
{
self
.
prims
.
clear
(
)
;
self
.
clips
.
clear
(
)
;
self
.
opacity_bindings
.
clear
(
)
;
self
.
image_keys
.
clear
(
)
;
self
.
transforms
.
clear
(
)
;
}
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
DirtyRegionRect
{
pub
world_rect
:
WorldRect
pub
visibility_mask
:
PrimitiveVisibilityMask
}
#
[
derive
(
Debug
Clone
)
]
pub
struct
DirtyRegion
{
pub
dirty_rects
:
Vec
<
DirtyRegionRect
>
pub
combined
:
WorldRect
}
impl
DirtyRegion
{
pub
fn
new
(
)
-
>
Self
{
DirtyRegion
{
dirty_rects
:
Vec
:
:
with_capacity
(
PrimitiveVisibilityMask
:
:
MAX_DIRTY_REGIONS
)
combined
:
WorldRect
:
:
zero
(
)
}
}
pub
fn
clear
(
&
mut
self
)
{
self
.
dirty_rects
.
clear
(
)
;
self
.
combined
=
WorldRect
:
:
zero
(
)
;
}
pub
fn
push
(
&
mut
self
rect
:
WorldRect
visibility_mask
:
PrimitiveVisibilityMask
)
{
self
.
combined
=
self
.
combined
.
union
(
&
rect
)
;
self
.
dirty_rects
.
push
(
DirtyRegionRect
{
world_rect
:
rect
visibility_mask
}
)
;
}
pub
fn
include_rect
(
&
mut
self
region_index
:
usize
rect
:
WorldRect
)
{
self
.
combined
=
self
.
combined
.
union
(
&
rect
)
;
let
region
=
&
mut
self
.
dirty_rects
[
region_index
]
;
region
.
world_rect
=
region
.
world_rect
.
union
(
&
rect
)
;
}
pub
fn
inflate
(
&
self
inflate_amount
:
f32
)
-
>
DirtyRegion
{
let
mut
dirty_rects
=
Vec
:
:
with_capacity
(
self
.
dirty_rects
.
len
(
)
)
;
let
mut
combined
=
WorldRect
:
:
zero
(
)
;
for
rect
in
&
self
.
dirty_rects
{
let
world_rect
=
rect
.
world_rect
.
inflate
(
inflate_amount
inflate_amount
)
;
combined
=
combined
.
union
(
&
world_rect
)
;
dirty_rects
.
push
(
DirtyRegionRect
{
world_rect
visibility_mask
:
rect
.
visibility_mask
}
)
;
}
DirtyRegion
{
dirty_rects
combined
}
}
pub
fn
record
(
&
self
)
-
>
RecordedDirtyRegion
{
let
mut
rects
:
Vec
<
WorldRect
>
=
self
.
dirty_rects
.
iter
(
)
.
map
(
|
r
|
r
.
world_rect
.
clone
(
)
)
.
collect
(
)
;
rects
.
sort_unstable_by_key
(
|
r
|
(
r
.
origin
.
y
as
usize
r
.
origin
.
x
as
usize
)
)
;
RecordedDirtyRegion
{
rects
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
RecordedDirtyRegion
{
pub
rects
:
Vec
<
WorldRect
>
}
impl
:
:
std
:
:
fmt
:
:
Display
for
RecordedDirtyRegion
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
for
r
in
self
.
rects
.
iter
(
)
{
let
(
x
y
w
h
)
=
(
r
.
origin
.
x
r
.
origin
.
y
r
.
size
.
width
r
.
size
.
height
)
;
write
!
(
f
"
[
(
{
}
{
}
)
:
{
}
x
{
}
]
"
x
y
w
h
)
?
;
}
Ok
(
(
)
)
}
}
impl
:
:
std
:
:
fmt
:
:
Debug
for
RecordedDirtyRegion
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
:
:
std
:
:
fmt
:
:
Display
:
:
fmt
(
self
f
)
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
struct
BackdropInfo
{
rect
:
PictureRect
color
:
ColorF
}
impl
BackdropInfo
{
fn
empty
(
)
-
>
Self
{
BackdropInfo
{
rect
:
PictureRect
:
:
zero
(
)
color
:
ColorF
:
:
BLACK
}
}
}
pub
struct
TileCacheInstance
{
pub
slice
:
usize
pub
spatial_node_index
:
SpatialNodeIndex
pub
tiles
:
FastHashMap
<
TileOffset
Tile
>
map_local_to_surface
:
SpaceMapper
<
LayoutPixel
PicturePixel
>
opacity_bindings
:
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
spatial_nodes
:
FastHashMap
<
SpatialNodeIndex
SpatialNodeDependency
>
used_spatial_nodes
:
FastHashSet
<
SpatialNodeIndex
>
pub
dirty_region
:
DirtyRegion
tile_size
:
PictureSize
tile_rect
:
TileRect
tile_bounds_p0
:
TileOffset
tile_bounds_p1
:
TileOffset
pub
local_rect
:
PictureRect
local_clip_rect
:
PictureRect
pub
tiles_to_draw
:
Vec
<
TileOffset
>
surface_index
:
SurfaceIndex
pub
background_color
:
Option
<
ColorF
>
backdrop
:
BackdropInfo
pub
subpixel_mode
:
SubpixelMode
fract_offset
:
PictureVector2D
pub
shared_clips
:
Vec
<
ClipDataHandle
>
shared_clip_chain
:
ClipChainId
root_transform
:
TransformKey
}
impl
TileCacheInstance
{
pub
fn
new
(
slice
:
usize
spatial_node_index
:
SpatialNodeIndex
background_color
:
Option
<
ColorF
>
shared_clips
:
Vec
<
ClipDataHandle
>
shared_clip_chain
:
ClipChainId
)
-
>
Self
{
TileCacheInstance
{
slice
spatial_node_index
tiles
:
FastHashMap
:
:
default
(
)
map_local_to_surface
:
SpaceMapper
:
:
new
(
ROOT_SPATIAL_NODE_INDEX
PictureRect
:
:
zero
(
)
)
opacity_bindings
:
FastHashMap
:
:
default
(
)
spatial_nodes
:
FastHashMap
:
:
default
(
)
used_spatial_nodes
:
FastHashSet
:
:
default
(
)
dirty_region
:
DirtyRegion
:
:
new
(
)
tile_size
:
PictureSize
:
:
zero
(
)
tile_rect
:
TileRect
:
:
zero
(
)
tile_bounds_p0
:
TileOffset
:
:
zero
(
)
tile_bounds_p1
:
TileOffset
:
:
zero
(
)
local_rect
:
PictureRect
:
:
zero
(
)
local_clip_rect
:
PictureRect
:
:
zero
(
)
tiles_to_draw
:
Vec
:
:
new
(
)
surface_index
:
SurfaceIndex
(
0
)
background_color
backdrop
:
BackdropInfo
:
:
empty
(
)
subpixel_mode
:
SubpixelMode
:
:
Allow
fract_offset
:
PictureVector2D
:
:
zero
(
)
root_transform
:
TransformKey
:
:
Local
shared_clips
shared_clip_chain
}
}
pub
fn
is_opaque
(
&
self
)
-
>
bool
{
match
self
.
background_color
{
Some
(
color
)
=
>
color
.
a
>
=
1
.
0
None
=
>
false
}
}
fn
get_tile_coords_for_rect
(
&
self
rect
:
&
PictureRect
)
-
>
(
TileOffset
TileOffset
)
{
let
mut
p0
=
TileOffset
:
:
new
(
(
rect
.
origin
.
x
/
self
.
tile_size
.
width
)
.
floor
(
)
as
i32
(
rect
.
origin
.
y
/
self
.
tile_size
.
height
)
.
floor
(
)
as
i32
)
;
let
mut
p1
=
TileOffset
:
:
new
(
(
(
rect
.
origin
.
x
+
rect
.
size
.
width
)
/
self
.
tile_size
.
width
)
.
ceil
(
)
as
i32
(
(
rect
.
origin
.
y
+
rect
.
size
.
height
)
/
self
.
tile_size
.
height
)
.
ceil
(
)
as
i32
)
;
p0
.
x
=
clamp
(
p0
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p0
.
y
=
clamp
(
p0
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
p1
.
x
=
clamp
(
p1
.
x
self
.
tile_bounds_p0
.
x
self
.
tile_bounds_p1
.
x
)
;
p1
.
y
=
clamp
(
p1
.
y
self
.
tile_bounds_p0
.
y
self
.
tile_bounds_p1
.
y
)
;
(
p0
p1
)
}
pub
fn
pre_update
(
&
mut
self
pic_rect
:
PictureRect
surface_index
:
SurfaceIndex
frame_context
:
&
FrameVisibilityContext
frame_state
:
&
mut
FrameVisibilityState
)
-
>
WorldRect
{
let
tile_width
=
TILE_SIZE_WIDTH
;
let
tile_height
=
TILE_SIZE_HEIGHT
;
self
.
surface_index
=
surface_index
;
self
.
local_rect
=
pic_rect
;
self
.
local_clip_rect
=
PictureRect
:
:
max_rect
(
)
;
self
.
backdrop
=
BackdropInfo
:
:
empty
(
)
;
self
.
subpixel_mode
=
SubpixelMode
:
:
Allow
;
self
.
map_local_to_surface
=
SpaceMapper
:
:
new
(
self
.
spatial_node_index
PictureRect
:
:
from_untyped
(
&
pic_rect
.
to_untyped
(
)
)
)
;
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
clip_scroll_tree
)
;
if
self
.
shared_clip_chain
!
=
ClipChainId
:
:
NONE
{
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
let
mut
current_clip_chain_id
=
self
.
shared_clip_chain
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
shared_clips
.
push
(
current_clip_chain_id
)
;
let
clip_chain_node
=
&
frame_state
.
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
frame_state
.
clip_store
.
set_active_clips
(
LayoutRect
:
:
max_rect
(
)
self
.
spatial_node_index
&
shared_clips
frame_context
.
clip_scroll_tree
&
mut
frame_state
.
data_stores
.
clip
)
;
let
clip_chain_instance
=
frame_state
.
clip_store
.
build_clip_chain_instance
(
LayoutRect
:
:
from_untyped
(
&
pic_rect
.
to_untyped
(
)
)
&
self
.
map_local_to_surface
&
pic_to_world_mapper
frame_context
.
clip_scroll_tree
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_context
.
global_device_pixel_scale
&
frame_context
.
global_screen_world_rect
&
mut
frame_state
.
data_stores
.
clip
true
false
)
;
if
let
Some
(
clip_chain_instance
)
=
clip_chain_instance
{
self
.
local_clip_rect
=
clip_chain_instance
.
pic_clip_rect
;
}
}
if
let
Some
(
prev_state
)
=
frame_state
.
retained_tiles
.
caches
.
remove
(
&
self
.
slice
)
{
self
.
tiles
.
extend
(
prev_state
.
tiles
)
;
self
.
fract_offset
=
prev_state
.
fract_offset
;
self
.
root_transform
=
prev_state
.
root_transform
;
self
.
spatial_nodes
=
prev_state
.
spatial_nodes
;
self
.
opacity_bindings
=
prev_state
.
opacity_bindings
;
}
let
world_origin
=
pic_to_world_mapper
.
map
(
&
PictureRect
:
:
new
(
PicturePoint
:
:
zero
(
)
PictureSize
:
:
new
(
1
.
0
1
.
0
)
)
)
.
expect
(
"
bug
:
unable
to
map
origin
to
world
space
"
)
.
origin
;
let
device_origin
=
world_origin
*
frame_context
.
global_device_pixel_scale
;
let
desired_device_origin
=
device_origin
.
round
(
)
;
let
ref_world_rect
=
WorldRect
:
:
new
(
desired_device_origin
/
frame_context
.
global_device_pixel_scale
WorldSize
:
:
new
(
1
.
0
1
.
0
)
)
;
let
ref_point
=
pic_to_world_mapper
.
unmap
(
&
ref_world_rect
)
.
expect
(
"
bug
:
unable
to
unmap
ref
world
rect
"
)
.
origin
;
let
fract_offset
=
PictureVector2D
:
:
new
(
ref_point
.
x
.
fract
(
)
ref_point
.
y
.
fract
(
)
)
;
let
fract_changed
=
(
self
.
fract_offset
.
x
-
fract_offset
.
x
)
.
abs
(
)
>
0
.
001
|
|
(
self
.
fract_offset
.
y
-
fract_offset
.
y
)
.
abs
(
)
>
0
.
001
;
if
fract_changed
{
self
.
fract_offset
=
fract_offset
;
}
let
current_properties
=
frame_context
.
scene_properties
.
float_properties
(
)
;
let
old_properties
=
mem
:
:
replace
(
&
mut
self
.
opacity_bindings
FastHashMap
:
:
default
(
)
)
;
for
(
id
value
)
in
current_properties
{
let
changed
=
match
old_properties
.
get
(
id
)
{
Some
(
old_property
)
=
>
!
old_property
.
value
.
approx_eq
(
value
)
None
=
>
true
}
;
self
.
opacity_bindings
.
insert
(
*
id
OpacityBindingInfo
{
value
:
*
value
changed
}
)
;
}
let
world_tile_size
=
WorldSize
:
:
new
(
tile_width
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
tile_height
as
f32
/
frame_context
.
global_device_pixel_scale
.
0
)
;
let
local_tile_rect
=
pic_to_world_mapper
.
unmap
(
&
WorldRect
:
:
new
(
WorldPoint
:
:
zero
(
)
world_tile_size
)
)
.
expect
(
"
bug
:
unable
to
get
local
tile
rect
"
)
;
self
.
tile_size
=
local_tile_rect
.
size
;
let
screen_rect_in_pic_space
=
pic_to_world_mapper
.
unmap
(
&
frame_context
.
global_screen_world_rect
)
.
expect
(
"
unable
to
unmap
screen
rect
"
)
;
let
desired_rect_in_pic_space
=
screen_rect_in_pic_space
.
inflate
(
0
.
0
3
.
0
*
self
.
tile_size
.
height
)
;
let
needed_rect_in_pic_space
=
desired_rect_in_pic_space
.
intersection
(
&
pic_rect
)
.
unwrap_or
(
PictureRect
:
:
zero
(
)
)
;
let
p0
=
needed_rect_in_pic_space
.
origin
;
let
p1
=
needed_rect_in_pic_space
.
bottom_right
(
)
;
let
x0
=
(
p0
.
x
/
local_tile_rect
.
size
.
width
)
.
floor
(
)
as
i32
;
let
x1
=
(
p1
.
x
/
local_tile_rect
.
size
.
width
)
.
ceil
(
)
as
i32
;
let
y0
=
(
p0
.
y
/
local_tile_rect
.
size
.
height
)
.
floor
(
)
as
i32
;
let
y1
=
(
p1
.
y
/
local_tile_rect
.
size
.
height
)
.
ceil
(
)
as
i32
;
let
x_tiles
=
x1
-
x0
;
let
y_tiles
=
y1
-
y0
;
self
.
tile_rect
=
TileRect
:
:
new
(
TileOffset
:
:
new
(
x0
y0
)
TileSize
:
:
new
(
x_tiles
y_tiles
)
)
;
self
.
tile_bounds_p0
=
TileOffset
:
:
new
(
x0
y0
)
;
self
.
tile_bounds_p1
=
TileOffset
:
:
new
(
x1
y1
)
;
let
mut
world_culling_rect
=
WorldRect
:
:
zero
(
)
;
let
mut
old_tiles
=
mem
:
:
replace
(
&
mut
self
.
tiles
FastHashMap
:
:
default
(
)
)
;
let
ctx
=
TilePreUpdateContext
{
local_rect
:
self
.
local_rect
local_clip_rect
:
self
.
local_clip_rect
pic_to_world_mapper
fract_changed
background_color
:
self
.
background_color
}
;
for
y
in
y0
.
.
y1
{
for
x
in
x0
.
.
x1
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
mut
tile
=
old_tiles
.
remove
(
&
key
)
.
unwrap_or_else
(
|
|
{
let
next_id
=
TileId
(
NEXT_TILE_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
;
Tile
:
:
new
(
next_id
)
}
)
;
let
rect
=
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
x
as
f32
*
self
.
tile_size
.
width
+
fract_offset
.
x
y
as
f32
*
self
.
tile_size
.
height
+
fract_offset
.
y
)
self
.
tile_size
)
;
tile
.
pre_update
(
rect
&
ctx
)
;
world_culling_rect
=
world_culling_rect
.
union
(
&
tile
.
world_rect
)
;
self
.
tiles
.
insert
(
key
tile
)
;
}
}
world_culling_rect
}
pub
fn
update_prim_dependencies
(
&
mut
self
prim_instance
:
&
PrimitiveInstance
prim_spatial_node_index
:
SpatialNodeIndex
prim_clip_chain
:
Option
<
&
ClipChainInstance
>
local_prim_rect
:
LayoutRect
clip_scroll_tree
:
&
ClipScrollTree
data_stores
:
&
DataStores
clip_store
:
&
ClipStore
pictures
:
&
[
PicturePrimitive
]
resource_cache
:
&
ResourceCache
opacity_binding_store
:
&
OpacityBindingStorage
image_instances
:
&
ImageInstanceStorage
surface_index
:
SurfaceIndex
)
-
>
bool
{
self
.
map_local_to_surface
.
set_target_spatial_node
(
prim_spatial_node_index
clip_scroll_tree
)
;
let
prim_rect
=
match
self
.
map_local_to_surface
.
map
(
&
local_prim_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
false
}
;
if
prim_rect
.
size
.
is_empty_or_negative
(
)
{
return
false
;
}
let
(
p0
p1
)
=
self
.
get_tile_coords_for_rect
(
&
prim_rect
)
;
if
p0
.
x
=
=
p1
.
x
|
|
p0
.
y
=
=
p1
.
y
{
return
false
;
}
let
is_cacheable
=
prim_instance
.
is_cacheable
(
&
data_stores
resource_cache
)
;
let
mut
prim_info
=
PrimitiveDependencyInfo
:
:
new
(
prim_instance
.
uid
(
)
prim_rect
is_cacheable
)
;
if
prim_spatial_node_index
!
=
self
.
spatial_node_index
{
prim_info
.
spatial_nodes
.
push
(
prim_spatial_node_index
)
;
}
if
let
Some
(
prim_clip_chain
)
=
prim_clip_chain
{
prim_info
.
prim_clip_rect
=
prim_clip_chain
.
pic_clip_rect
;
let
clip_instances
=
&
clip_store
.
clip_node_instances
[
prim_clip_chain
.
clips_range
.
to_range
(
)
]
;
for
clip_instance
in
clip_instances
{
prim_info
.
clips
.
push
(
clip_instance
.
handle
.
uid
(
)
)
;
let
clip_node
=
&
data_stores
.
clip
[
clip_instance
.
handle
]
;
if
clip_node
.
item
.
spatial_node_index
!
=
self
.
spatial_node_index
{
if
!
prim_info
.
spatial_nodes
.
contains
(
&
clip_node
.
item
.
spatial_node_index
)
{
prim_info
.
spatial_nodes
.
push
(
clip_node
.
item
.
spatial_node_index
)
;
}
}
}
}
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
pictures
[
pic_index
.
0
]
;
if
let
Some
(
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Opacity
(
binding
_
)
)
)
=
pic
.
requested_composite_mode
{
prim_info
.
opacity_bindings
.
push
(
binding
.
into
(
)
)
;
}
}
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
opacity_binding_index
.
.
}
=
>
{
if
opacity_binding_index
=
=
OpacityBindingIndex
:
:
INVALID
{
let
on_picture_surface
=
surface_index
=
=
self
.
surface_index
;
let
color
=
match
data_stores
.
prim
[
data_handle
]
.
kind
{
PrimitiveTemplateKind
:
:
Rectangle
{
color
.
.
}
=
>
color
_
=
>
unreachable
!
(
)
}
;
let
prim_is_opaque
=
color
.
a
>
=
1
.
0
;
let
same_coord_system
=
{
let
prim_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
prim_spatial_node_index
.
0
as
usize
]
;
let
surface_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
self
.
spatial_node_index
.
0
as
usize
]
;
prim_spatial_node
.
coordinate_system_id
=
=
surface_spatial_node
.
coordinate_system_id
}
;
if
let
Some
(
ref
clip_chain
)
=
prim_clip_chain
{
if
prim_is_opaque
&
&
same_coord_system
&
&
!
clip_chain
.
needs_mask
&
&
on_picture_surface
{
if
clip_chain
.
pic_clip_rect
.
contains_rect
(
&
self
.
backdrop
.
rect
)
{
self
.
backdrop
=
BackdropInfo
{
rect
:
clip_chain
.
pic_clip_rect
color
}
;
}
}
}
;
}
else
{
let
opacity_binding
=
&
opacity_binding_store
[
opacity_binding_index
]
;
for
binding
in
&
opacity_binding
.
bindings
{
prim_info
.
opacity_bindings
.
push
(
OpacityBinding
:
:
from
(
*
binding
)
)
;
}
}
prim_info
.
clip_by_tile
=
true
;
}
PrimitiveInstanceKind
:
:
Image
{
data_handle
image_instance_index
.
.
}
=
>
{
let
image_data
=
&
data_stores
.
image
[
data_handle
]
.
kind
;
let
image_instance
=
&
image_instances
[
image_instance_index
]
;
let
opacity_binding_index
=
image_instance
.
opacity_binding_index
;
if
opacity_binding_index
!
=
OpacityBindingIndex
:
:
INVALID
{
let
opacity_binding
=
&
opacity_binding_store
[
opacity_binding_index
]
;
for
binding
in
&
opacity_binding
.
bindings
{
prim_info
.
opacity_bindings
.
push
(
OpacityBinding
:
:
from
(
*
binding
)
)
;
}
}
prim_info
.
image_keys
.
push
(
image_data
.
key
)
;
}
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
.
.
}
=
>
{
let
yuv_image_data
=
&
data_stores
.
yuv_image
[
data_handle
]
.
kind
;
prim_info
.
image_keys
.
extend_from_slice
(
&
yuv_image_data
.
yuv_key
)
;
}
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
=
>
{
let
border_data
=
&
data_stores
.
image_border
[
data_handle
]
.
kind
;
prim_info
.
image_keys
.
push
(
border_data
.
request
.
key
)
;
}
PrimitiveInstanceKind
:
:
PushClipChain
|
PrimitiveInstanceKind
:
:
PopClipChain
=
>
{
return
false
;
}
PrimitiveInstanceKind
:
:
TextRun
{
data_handle
.
.
}
=
>
{
if
self
.
subpixel_mode
=
=
SubpixelMode
:
:
Allow
&
&
!
self
.
is_opaque
(
)
{
let
run_data
=
&
data_stores
.
text_run
[
data_handle
]
;
let
on_picture_surface
=
surface_index
=
=
self
.
surface_index
;
let
subpx_requested
=
match
run_data
.
font
.
render_mode
{
FontRenderMode
:
:
Subpixel
=
>
true
FontRenderMode
:
:
Alpha
|
FontRenderMode
:
:
Mono
=
>
false
}
;
if
on_picture_surface
&
&
subpx_requested
{
if
!
self
.
backdrop
.
rect
.
contains_rect
(
&
prim_info
.
prim_clip_rect
)
{
self
.
subpixel_mode
=
SubpixelMode
:
:
Deny
;
}
}
}
}
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
Backdrop
{
.
.
}
=
>
{
}
}
;
self
.
used_spatial_nodes
.
extend
(
&
prim_info
.
spatial_nodes
)
;
prim_info
.
clips
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
opacity_bindings
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
spatial_nodes
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
prim_info
.
image_keys
.
truncate
(
MAX_PRIM_SUB_DEPS
)
;
for
y
in
p0
.
y
.
.
p1
.
y
{
for
x
in
p0
.
x
.
.
p1
.
x
{
let
key
=
TileOffset
:
:
new
(
x
y
)
;
let
tile
=
self
.
tiles
.
get_mut
(
&
key
)
.
expect
(
"
bug
:
no
tile
"
)
;
tile
.
add_prim_dependency
(
&
prim_info
)
;
}
}
true
}
pub
fn
post_update
(
&
mut
self
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
frame_context
:
&
FrameVisibilityContext
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
self
.
tiles_to_draw
.
clear
(
)
;
self
.
dirty_region
.
clear
(
)
;
let
root_transform
=
frame_context
.
clip_scroll_tree
.
get_relative_transform
(
self
.
spatial_node_index
ROOT_SPATIAL_NODE_INDEX
)
.
into
(
)
;
let
root_transform_changed
=
root_transform
!
=
self
.
root_transform
;
if
root_transform_changed
{
self
.
root_transform
=
root_transform
;
}
let
mut
old_spatial_nodes
=
mem
:
:
replace
(
&
mut
self
.
spatial_nodes
FastHashMap
:
:
default
(
)
)
;
for
spatial_node_index
in
self
.
used_spatial_nodes
.
drain
(
)
{
let
mut
value
=
get_transform_key
(
spatial_node_index
self
.
spatial_node_index
frame_context
.
clip_scroll_tree
)
;
let
mut
changed
=
true
;
if
let
Some
(
old_info
)
=
old_spatial_nodes
.
remove
(
&
spatial_node_index
)
{
if
old_info
.
value
=
=
value
{
value
=
old_info
.
value
;
changed
=
false
;
}
}
self
.
spatial_nodes
.
insert
(
spatial_node_index
SpatialNodeDependency
{
changed
value
}
)
;
}
let
pic_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
self
.
spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
clip_scroll_tree
)
;
let
ctx
=
TilePostUpdateContext
{
debug_flags
:
frame_context
.
debug_flags
global_device_pixel_scale
:
frame_context
.
global_device_pixel_scale
global_screen_world_rect
:
frame_context
.
global_screen_world_rect
backdrop
:
self
.
backdrop
spatial_nodes
:
&
self
.
spatial_nodes
opacity_bindings
:
&
self
.
opacity_bindings
pic_to_world_mapper
}
;
let
mut
state
=
TilePostUpdateState
{
resource_cache
gpu_cache
scratch
dirty_region
:
&
mut
self
.
dirty_region
}
;
for
(
key
tile
)
in
self
.
tiles
.
iter_mut
(
)
{
if
tile
.
post_update
(
&
ctx
&
mut
state
)
{
if
!
root_transform_changed
&
&
!
tile
.
dirty_rect
.
is_empty
(
)
{
state
.
scratch
.
dirty_rects
.
push
(
(
tile
.
world_dirty_rect
*
frame_context
.
global_device_pixel_scale
)
.
to_i32
(
)
)
;
}
self
.
tiles_to_draw
.
push
(
*
key
)
;
}
}
if
root_transform_changed
{
scratch
.
dirty_rects
.
push
(
(
frame_context
.
global_screen_world_rect
*
frame_context
.
global_device_pixel_scale
)
.
to_i32
(
)
)
;
}
else
{
let
world_clip_rect
=
ctx
.
pic_to_world_mapper
.
map
(
&
self
.
local_clip_rect
)
.
expect
(
"
bug
-
unable
to
map
picture
clip
rect
to
world
"
)
;
let
mut
non_cached_rects
=
Vec
:
:
new
(
)
;
subtract_rect
(
&
ctx
.
global_screen_world_rect
&
world_clip_rect
&
mut
non_cached_rects
)
;
for
rect
in
non_cached_rects
{
scratch
.
dirty_rects
.
push
(
(
rect
*
frame_context
.
global_device_pixel_scale
)
.
to_i32
(
)
)
;
}
}
if
frame_context
.
config
.
testing
{
scratch
.
recorded_dirty_regions
.
push
(
self
.
dirty_region
.
record
(
)
)
;
}
}
}
pub
struct
PictureUpdateState
<
'
a
>
{
surfaces
:
&
'
a
mut
Vec
<
SurfaceInfo
>
surface_stack
:
Vec
<
SurfaceIndex
>
picture_stack
:
Vec
<
PictureInfo
>
are_raster_roots_assigned
:
bool
}
impl
<
'
a
>
PictureUpdateState
<
'
a
>
{
pub
fn
update_all
(
surfaces
:
&
'
a
mut
Vec
<
SurfaceInfo
>
pic_index
:
PictureIndex
picture_primitives
:
&
mut
[
PicturePrimitive
]
frame_context
:
&
FrameBuildingContext
gpu_cache
:
&
mut
GpuCache
clip_store
:
&
ClipStore
data_stores
:
&
mut
DataStores
)
{
profile_marker
!
(
"
UpdatePictures
"
)
;
let
mut
state
=
PictureUpdateState
{
surfaces
surface_stack
:
vec
!
[
SurfaceIndex
(
0
)
]
picture_stack
:
Vec
:
:
new
(
)
are_raster_roots_assigned
:
true
}
;
state
.
update
(
pic_index
picture_primitives
frame_context
gpu_cache
clip_store
data_stores
)
;
if
!
state
.
are_raster_roots_assigned
{
state
.
assign_raster_roots
(
pic_index
picture_primitives
ROOT_SPATIAL_NODE_INDEX
)
;
}
}
fn
current_surface
(
&
self
)
-
>
&
SurfaceInfo
{
&
self
.
surfaces
[
self
.
surface_stack
.
last
(
)
.
unwrap
(
)
.
0
]
}
fn
current_surface_mut
(
&
mut
self
)
-
>
&
mut
SurfaceInfo
{
&
mut
self
.
surfaces
[
self
.
surface_stack
.
last
(
)
.
unwrap
(
)
.
0
]
}
fn
push_surface
(
&
mut
self
surface
:
SurfaceInfo
)
-
>
SurfaceIndex
{
let
surface_index
=
SurfaceIndex
(
self
.
surfaces
.
len
(
)
)
;
self
.
surfaces
.
push
(
surface
)
;
self
.
surface_stack
.
push
(
surface_index
)
;
surface_index
}
fn
pop_surface
(
&
mut
self
)
-
>
SurfaceIndex
{
self
.
surface_stack
.
pop
(
)
.
unwrap
(
)
}
fn
push_picture
(
&
mut
self
info
:
PictureInfo
)
{
self
.
picture_stack
.
push
(
info
)
;
}
fn
pop_picture
(
&
mut
self
)
-
>
PictureInfo
{
self
.
picture_stack
.
pop
(
)
.
unwrap
(
)
}
fn
update
(
&
mut
self
pic_index
:
PictureIndex
picture_primitives
:
&
mut
[
PicturePrimitive
]
frame_context
:
&
FrameBuildingContext
gpu_cache
:
&
mut
GpuCache
clip_store
:
&
ClipStore
data_stores
:
&
mut
DataStores
)
{
if
let
Some
(
prim_list
)
=
picture_primitives
[
pic_index
.
0
]
.
pre_update
(
self
frame_context
)
{
for
cluster
in
&
prim_list
.
clusters
{
if
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_PICTURE
)
{
for
prim_instance
in
&
cluster
.
prim_instances
{
let
child_pic_index
=
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
pic_index
_
=
>
unreachable
!
(
)
}
;
self
.
update
(
child_pic_index
picture_primitives
frame_context
gpu_cache
clip_store
data_stores
)
;
}
}
}
picture_primitives
[
pic_index
.
0
]
.
post_update
(
prim_list
self
frame_context
data_stores
)
;
}
}
fn
assign_raster_roots
(
&
mut
self
pic_index
:
PictureIndex
picture_primitives
:
&
[
PicturePrimitive
]
fallback_raster_spatial_node
:
SpatialNodeIndex
)
{
let
picture
=
&
picture_primitives
[
pic_index
.
0
]
;
if
!
picture
.
is_visible
(
)
{
return
}
let
new_fallback
=
match
picture
.
raster_config
{
Some
(
ref
config
)
=
>
{
let
surface
=
&
mut
self
.
surfaces
[
config
.
surface_index
.
0
]
;
if
!
config
.
establishes_raster_root
{
surface
.
raster_spatial_node_index
=
fallback_raster_spatial_node
;
}
surface
.
raster_spatial_node_index
}
None
=
>
fallback_raster_spatial_node
}
;
for
cluster
in
&
picture
.
prim_list
.
clusters
{
if
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_PICTURE
)
{
for
instance
in
&
cluster
.
prim_instances
{
let
child_pic_index
=
match
instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
pic_index
_
=
>
unreachable
!
(
)
}
;
self
.
assign_raster_roots
(
child_pic_index
picture_primitives
new_fallback
)
;
}
}
}
}
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
SurfaceIndex
(
pub
usize
)
;
pub
const
ROOT_SURFACE_INDEX
:
SurfaceIndex
=
SurfaceIndex
(
0
)
;
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
SurfaceRenderTasks
{
pub
root
:
RenderTaskId
pub
port
:
RenderTaskId
}
#
[
derive
(
Debug
)
]
pub
struct
SurfaceInfo
{
pub
rect
:
PictureRect
pub
map_local_to_surface
:
SpaceMapper
<
LayoutPixel
PicturePixel
>
pub
raster_spatial_node_index
:
SpatialNodeIndex
pub
surface_spatial_node_index
:
SpatialNodeIndex
pub
render_tasks
:
Option
<
SurfaceRenderTasks
>
pub
inflation_factor
:
f32
pub
device_pixel_scale
:
DevicePixelScale
}
impl
SurfaceInfo
{
pub
fn
new
(
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
inflation_factor
:
f32
world_rect
:
WorldRect
clip_scroll_tree
:
&
ClipScrollTree
device_pixel_scale
:
DevicePixelScale
)
-
>
Self
{
let
map_surface_to_world
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
surface_spatial_node_index
world_rect
clip_scroll_tree
)
;
let
pic_bounds
=
map_surface_to_world
.
unmap
(
&
map_surface_to_world
.
bounds
)
.
unwrap_or_else
(
PictureRect
:
:
max_rect
)
;
let
map_local_to_surface
=
SpaceMapper
:
:
new
(
surface_spatial_node_index
pic_bounds
)
;
SurfaceInfo
{
rect
:
PictureRect
:
:
zero
(
)
map_local_to_surface
render_tasks
:
None
raster_spatial_node_index
surface_spatial_node_index
inflation_factor
device_pixel_scale
}
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
RasterConfig
{
pub
composite_mode
:
PictureCompositeMode
pub
surface_index
:
SurfaceIndex
pub
establishes_raster_root
:
bool
}
bitflags
!
{
/
/
/
A
set
of
flags
describing
why
a
picture
may
need
a
backing
surface
.
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
BlitReason
:
u32
{
/
/
/
Mix
-
blend
-
mode
on
a
child
that
requires
isolation
.
const
ISOLATE
=
1
;
/
/
/
Clip
node
that
_might_
require
a
surface
.
const
CLIP
=
2
;
/
/
/
Preserve
-
3D
requires
a
surface
for
plane
-
splitting
.
const
PRESERVE3D
=
4
;
/
/
/
A
backdrop
that
is
reused
which
requires
a
surface
.
const
BACKDROP
=
8
;
}
}
#
[
allow
(
dead_code
)
]
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
enum
PictureCompositeMode
{
MixBlend
(
MixBlendMode
)
Filter
(
Filter
)
ComponentTransferFilter
(
FilterDataHandle
)
Blit
(
BlitReason
)
TileCache
{
}
SvgFilter
(
Vec
<
FilterPrimitive
>
Vec
<
SFilterData
>
)
}
impl
PictureCompositeMode
{
pub
fn
inflate_picture_rect
(
&
self
picture_rect
:
PictureRect
inflation_factor
:
f32
)
-
>
PictureRect
{
let
mut
result_rect
=
picture_rect
;
match
self
{
PictureCompositeMode
:
:
Filter
(
filter
)
=
>
match
filter
{
Filter
:
:
Blur
(
_
)
=
>
{
result_rect
=
picture_rect
.
inflate
(
inflation_factor
inflation_factor
)
;
}
Filter
:
:
DropShadows
(
shadows
)
=
>
{
let
mut
max_inflation
:
f32
=
0
.
0
;
for
shadow
in
shadows
{
let
inflation_factor
=
shadow
.
blur_radius
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
max_inflation
=
max_inflation
.
max
(
inflation_factor
)
;
}
result_rect
=
picture_rect
.
inflate
(
max_inflation
max_inflation
)
;
}
_
=
>
{
}
}
PictureCompositeMode
:
:
SvgFilter
(
primitives
_
)
=
>
{
let
mut
output_rects
=
Vec
:
:
with_capacity
(
primitives
.
len
(
)
)
;
for
(
cur_index
primitive
)
in
primitives
.
iter
(
)
.
enumerate
(
)
{
let
output_rect
=
match
primitive
.
kind
{
FilterPrimitiveKind
:
:
Blur
(
ref
primitive
)
=
>
{
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
;
let
inflation_factor
=
primitive
.
radius
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
input
.
inflate
(
inflation_factor
inflation_factor
)
}
FilterPrimitiveKind
:
:
DropShadow
(
ref
primitive
)
=
>
{
let
inflation_factor
=
primitive
.
shadow
.
blur_radius
.
round
(
)
*
BLUR_SAMPLE_SCALE
;
let
input
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
;
let
shadow_rect
=
input
.
inflate
(
inflation_factor
inflation_factor
)
;
input
.
union
(
&
shadow_rect
.
translate
(
primitive
.
shadow
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
)
}
FilterPrimitiveKind
:
:
Blend
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
)
}
FilterPrimitiveKind
:
:
Composite
(
ref
primitive
)
=
>
{
primitive
.
input1
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
.
union
(
&
primitive
.
input2
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
)
}
FilterPrimitiveKind
:
:
Identity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
FilterPrimitiveKind
:
:
Opacity
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
FilterPrimitiveKind
:
:
ColorMatrix
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
FilterPrimitiveKind
:
:
ComponentTransfer
(
ref
primitive
)
=
>
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
FilterPrimitiveKind
:
:
Offset
(
ref
primitive
)
=
>
{
let
input_rect
=
primitive
.
input
.
to_index
(
cur_index
)
.
map
(
|
index
|
output_rects
[
index
]
)
.
unwrap_or
(
picture_rect
)
;
input_rect
.
translate
(
primitive
.
offset
*
Scale
:
:
new
(
1
.
0
)
)
}
FilterPrimitiveKind
:
:
Flood
(
.
.
)
=
>
picture_rect
}
;
output_rects
.
push
(
output_rect
)
;
result_rect
=
result_rect
.
union
(
&
output_rect
)
;
}
}
_
=
>
{
}
}
result_rect
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
enum
Picture3DContext
<
C
>
{
Out
In
{
root_data
:
Option
<
Vec
<
C
>
>
ancestor_index
:
SpatialNodeIndex
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
OrderedPictureChild
{
pub
anchor
:
PlaneSplitAnchor
pub
spatial_node_index
:
SpatialNodeIndex
pub
gpu_address
:
GpuCacheAddress
}
bitflags
!
{
/
/
/
A
set
of
flags
describing
why
a
picture
may
need
a
backing
surface
.
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
ClusterFlags
:
u32
{
/
/
/
This
cluster
is
a
picture
const
IS_PICTURE
=
1
;
/
/
/
Whether
this
cluster
is
visible
when
the
position
node
is
a
backface
.
const
IS_BACKFACE_VISIBLE
=
2
;
/
/
/
This
flag
is
set
during
the
first
pass
picture
traversal
depending
on
whether
/
/
/
the
cluster
is
visible
or
not
.
It
'
s
read
during
the
second
pass
when
primitives
/
/
/
consult
their
owning
clusters
to
see
if
the
primitive
itself
is
visible
.
const
IS_VISIBLE
=
4
;
/
/
/
Is
a
backdrop
-
filter
cluster
that
requires
special
handling
during
post_update
.
const
IS_BACKDROP_FILTER
=
8
;
/
/
/
Force
creation
of
a
picture
caching
slice
before
this
cluster
.
const
CREATE_PICTURE_CACHE_PRE
=
16
;
/
/
/
Force
creation
of
a
picture
caching
slice
after
this
cluster
.
const
CREATE_PICTURE_CACHE_POST
=
32
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PrimitiveCluster
{
pub
spatial_node_index
:
SpatialNodeIndex
bounding_rect
:
LayoutRect
pub
prim_instances
:
Vec
<
PrimitiveInstance
>
pub
flags
:
ClusterFlags
}
#
[
derive
(
Debug
Copy
Clone
)
]
enum
PrimitiveListPosition
{
Begin
End
}
impl
PrimitiveCluster
{
fn
new
(
spatial_node_index
:
SpatialNodeIndex
flags
:
ClusterFlags
)
-
>
Self
{
PrimitiveCluster
{
bounding_rect
:
LayoutRect
:
:
zero
(
)
spatial_node_index
flags
prim_instances
:
Vec
:
:
new
(
)
}
}
pub
fn
is_compatible
(
&
self
spatial_node_index
:
SpatialNodeIndex
flags
:
ClusterFlags
)
-
>
bool
{
self
.
flags
=
=
flags
&
&
self
.
spatial_node_index
=
=
spatial_node_index
}
fn
push
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_size
:
LayoutSize
)
{
let
prim_rect
=
LayoutRect
:
:
new
(
prim_instance
.
prim_origin
prim_size
)
;
let
culling_rect
=
prim_instance
.
local_clip_rect
.
intersection
(
&
prim_rect
)
.
unwrap_or_else
(
LayoutRect
:
:
zero
)
;
self
.
bounding_rect
=
self
.
bounding_rect
.
union
(
&
culling_rect
)
;
self
.
prim_instances
.
push
(
prim_instance
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PrimitiveList
{
pub
clusters
:
Vec
<
PrimitiveCluster
>
}
impl
PrimitiveList
{
pub
fn
empty
(
)
-
>
Self
{
PrimitiveList
{
clusters
:
Vec
:
:
new
(
)
}
}
fn
push
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_size
:
LayoutSize
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
insert_position
:
PrimitiveListPosition
)
{
let
mut
flags
=
ClusterFlags
:
:
empty
(
)
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
.
.
}
=
>
{
flags
.
insert
(
ClusterFlags
:
:
IS_PICTURE
)
;
}
PrimitiveInstanceKind
:
:
Backdrop
{
.
.
}
=
>
{
flags
.
insert
(
ClusterFlags
:
:
IS_BACKDROP_FILTER
)
;
}
_
=
>
{
}
}
if
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
{
flags
.
insert
(
ClusterFlags
:
:
IS_BACKFACE_VISIBLE
)
;
}
match
insert_position
{
PrimitiveListPosition
:
:
Begin
=
>
{
let
mut
cluster
=
PrimitiveCluster
:
:
new
(
spatial_node_index
flags
)
;
cluster
.
push
(
prim_instance
prim_size
)
;
self
.
clusters
.
insert
(
0
cluster
)
;
}
PrimitiveListPosition
:
:
End
=
>
{
if
let
Some
(
cluster
)
=
self
.
clusters
.
last_mut
(
)
{
if
cluster
.
is_compatible
(
spatial_node_index
flags
)
{
cluster
.
push
(
prim_instance
prim_size
)
;
return
;
}
}
let
mut
cluster
=
PrimitiveCluster
:
:
new
(
spatial_node_index
flags
)
;
cluster
.
push
(
prim_instance
prim_size
)
;
self
.
clusters
.
push
(
cluster
)
;
}
}
}
pub
fn
add_prim_to_start
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_size
:
LayoutSize
spatial_node_index
:
SpatialNodeIndex
flags
:
PrimitiveFlags
)
{
self
.
push
(
prim_instance
prim_size
spatial_node_index
flags
PrimitiveListPosition
:
:
Begin
)
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_size
:
LayoutSize
spatial_node_index
:
SpatialNodeIndex
flags
:
PrimitiveFlags
)
{
self
.
push
(
prim_instance
prim_size
spatial_node_index
flags
PrimitiveListPosition
:
:
End
)
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
clusters
.
is_empty
(
)
}
pub
fn
add_cluster
(
&
mut
self
cluster
:
PrimitiveCluster
)
{
self
.
clusters
.
push
(
cluster
)
;
}
pub
fn
extend
(
&
mut
self
prim_list
:
PrimitiveList
)
{
self
.
clusters
.
extend
(
prim_list
.
clusters
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PictureOptions
{
pub
inflate_if_required
:
bool
}
impl
Default
for
PictureOptions
{
fn
default
(
)
-
>
Self
{
PictureOptions
{
inflate_if_required
:
true
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PicturePrimitive
{
pub
prim_list
:
PrimitiveList
#
[
cfg_attr
(
feature
=
"
capture
"
serde
(
skip
)
)
]
pub
state
:
Option
<
PictureState
>
pub
apply_local_clip_rect
:
bool
pub
is_backface_visible
:
bool
pub
secondary_render_task_id
:
Option
<
RenderTaskId
>
pub
requested_composite_mode
:
Option
<
PictureCompositeMode
>
pub
requested_raster_space
:
RasterSpace
pub
raster_config
:
Option
<
RasterConfig
>
pub
context_3d
:
Picture3DContext
<
OrderedPictureChild
>
pub
frame_output_pipeline_id
:
Option
<
PipelineId
>
pub
extra_gpu_data_handles
:
SmallVec
<
[
GpuCacheHandle
;
1
]
>
pub
spatial_node_index
:
SpatialNodeIndex
pub
local_rect
:
LayoutRect
pub
segments_are_valid
:
bool
#
[
cfg_attr
(
feature
=
"
capture
"
serde
(
skip
)
)
]
pub
tile_cache
:
Option
<
Box
<
TileCacheInstance
>
>
pub
options
:
PictureOptions
}
impl
PicturePrimitive
{
pub
fn
print
<
T
:
PrintTreePrinter
>
(
&
self
pictures
:
&
[
Self
]
self_index
:
PictureIndex
pt
:
&
mut
T
)
{
pt
.
new_level
(
format
!
(
"
{
:
?
}
"
self_index
)
)
;
pt
.
add_item
(
format
!
(
"
cluster_count
:
{
:
?
}
"
self
.
prim_list
.
clusters
.
len
(
)
)
)
;
pt
.
add_item
(
format
!
(
"
local_rect
:
{
:
?
}
"
self
.
local_rect
)
)
;
pt
.
add_item
(
format
!
(
"
spatial_node_index
:
{
:
?
}
"
self
.
spatial_node_index
)
)
;
pt
.
add_item
(
format
!
(
"
raster_config
:
{
:
?
}
"
self
.
raster_config
)
)
;
pt
.
add_item
(
format
!
(
"
requested_composite_mode
:
{
:
?
}
"
self
.
requested_composite_mode
)
)
;
for
cluster
in
&
self
.
prim_list
.
clusters
{
if
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_PICTURE
)
{
for
instance
in
&
cluster
.
prim_instances
{
let
index
=
match
instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
pic_index
_
=
>
unreachable
!
(
)
}
;
pictures
[
index
.
0
]
.
print
(
pictures
index
pt
)
;
}
}
}
pt
.
end_level
(
)
;
}
pub
fn
can_use_segments
(
&
self
)
-
>
bool
{
match
self
.
raster_config
{
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
MixBlend
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Filter
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
TileCache
{
.
.
}
.
.
}
)
|
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
.
.
}
)
|
None
=
>
{
false
}
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
Blit
(
reason
)
.
.
}
)
=
>
{
reason
=
=
BlitReason
:
:
CLIP
}
}
}
fn
resolve_scene_properties
(
&
mut
self
properties
:
&
SceneProperties
)
-
>
bool
{
match
self
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
ref
mut
filter
)
)
=
>
{
match
*
filter
{
Filter
:
:
Opacity
(
ref
binding
ref
mut
value
)
=
>
{
*
value
=
properties
.
resolve_float
(
binding
)
;
}
_
=
>
{
}
}
filter
.
is_visible
(
)
}
_
=
>
true
}
}
pub
fn
is_visible
(
&
self
)
-
>
bool
{
match
self
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
ref
filter
)
)
=
>
{
filter
.
is_visible
(
)
}
_
=
>
true
}
}
pub
fn
destroy
(
&
mut
self
retained_tiles
:
&
mut
RetainedTiles
)
{
if
let
Some
(
tile_cache
)
=
self
.
tile_cache
.
take
(
)
{
if
!
tile_cache
.
tiles
.
is_empty
(
)
{
retained_tiles
.
caches
.
insert
(
tile_cache
.
slice
PictureCacheState
{
tiles
:
tile_cache
.
tiles
spatial_nodes
:
tile_cache
.
spatial_nodes
opacity_bindings
:
tile_cache
.
opacity_bindings
fract_offset
:
tile_cache
.
fract_offset
root_transform
:
tile_cache
.
root_transform
}
)
;
}
}
}
pub
fn
new_image
(
requested_composite_mode
:
Option
<
PictureCompositeMode
>
context_3d
:
Picture3DContext
<
OrderedPictureChild
>
frame_output_pipeline_id
:
Option
<
PipelineId
>
apply_local_clip_rect
:
bool
flags
:
PrimitiveFlags
requested_raster_space
:
RasterSpace
prim_list
:
PrimitiveList
spatial_node_index
:
SpatialNodeIndex
tile_cache
:
Option
<
Box
<
TileCacheInstance
>
>
options
:
PictureOptions
)
-
>
Self
{
PicturePrimitive
{
prim_list
state
:
None
secondary_render_task_id
:
None
requested_composite_mode
raster_config
:
None
context_3d
frame_output_pipeline_id
extra_gpu_data_handles
:
SmallVec
:
:
new
(
)
apply_local_clip_rect
is_backface_visible
:
flags
.
contains
(
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
requested_raster_space
spatial_node_index
local_rect
:
LayoutRect
:
:
zero
(
)
tile_cache
options
segments_are_valid
:
false
}
}
pub
fn
get_raster_space
(
&
self
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
RasterSpace
{
let
spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
self
.
spatial_node_index
.
0
as
usize
]
;
if
spatial_node
.
is_ancestor_or_self_zooming
{
let
scale_factors
=
clip_scroll_tree
.
get_relative_transform
(
self
.
spatial_node_index
ROOT_SPATIAL_NODE_INDEX
)
.
scale_factors
(
)
;
let
scale
=
scale_factors
.
0
.
max
(
scale_factors
.
1
)
.
min
(
8
.
0
)
;
let
rounded_up
=
1
<
<
scale
.
log2
(
)
.
ceil
(
)
as
u32
;
RasterSpace
:
:
Local
(
rounded_up
as
f32
)
}
else
{
self
.
requested_raster_space
}
}
pub
fn
take_context
(
&
mut
self
pic_index
:
PictureIndex
clipped_prim_bounding_rect
:
WorldRect
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
parent_surface_index
:
SurfaceIndex
parent_subpixel_mode
:
SubpixelMode
frame_state
:
&
mut
FrameBuildingState
frame_context
:
&
FrameBuildingContext
)
-
>
Option
<
(
PictureContext
PictureState
PrimitiveList
)
>
{
if
!
self
.
is_visible
(
)
{
return
None
;
}
let
(
raster_spatial_node_index
surface_spatial_node_index
surface_index
inflation_factor
)
=
match
self
.
raster_config
{
Some
(
ref
raster_config
)
=
>
{
let
surface
=
&
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
;
(
surface
.
raster_spatial_node_index
self
.
spatial_node_index
raster_config
.
surface_index
surface
.
inflation_factor
)
}
None
=
>
{
(
raster_spatial_node_index
surface_spatial_node_index
parent_surface_index
0
.
0
)
}
}
;
let
map_pic_to_world
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
surface_spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
clip_scroll_tree
)
;
let
pic_bounds
=
map_pic_to_world
.
unmap
(
&
map_pic_to_world
.
bounds
)
.
unwrap_or_else
(
PictureRect
:
:
max_rect
)
;
let
map_local_to_pic
=
SpaceMapper
:
:
new
(
surface_spatial_node_index
pic_bounds
)
;
let
(
map_raster_to_world
map_pic_to_raster
)
=
create_raster_mappers
(
surface_spatial_node_index
raster_spatial_node_index
frame_context
.
global_screen_world_rect
frame_context
.
clip_scroll_tree
)
;
let
plane_splitter
=
match
self
.
context_3d
{
Picture3DContext
:
:
Out
=
>
{
None
}
Picture3DContext
:
:
In
{
root_data
:
Some
(
_
)
.
.
}
=
>
{
Some
(
PlaneSplitter
:
:
new
(
)
)
}
Picture3DContext
:
:
In
{
root_data
:
None
.
.
}
=
>
{
None
}
}
;
match
self
.
raster_config
{
Some
(
ref
raster_config
)
=
>
{
let
pic_rect
=
PictureRect
:
:
from_untyped
(
&
self
.
local_rect
.
to_untyped
(
)
)
;
let
device_pixel_scale
=
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
.
device_pixel_scale
;
let
(
clipped
unclipped
)
=
match
get_raster_rects
(
pic_rect
&
map_pic_to_raster
&
map_raster_to_world
clipped_prim_bounding_rect
device_pixel_scale
)
{
Some
(
info
)
=
>
info
None
=
>
{
return
None
}
}
;
let
transform
=
map_pic_to_raster
.
get_transform
(
)
;
let
dep_info
=
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
(
blur_radius
)
)
=
>
{
let
blur_std_deviation
=
blur_radius
*
device_pixel_scale
.
0
;
let
scale_factors
=
scale_factors
(
&
transform
)
;
let
blur_std_deviation
=
DeviceSize
:
:
new
(
blur_std_deviation
*
scale_factors
.
0
blur_std_deviation
*
scale_factors
.
1
)
;
let
mut
device_rect
=
if
self
.
options
.
inflate_if_required
{
let
inflation_factor
=
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
.
inflation_factor
;
let
inflation_factor
=
(
inflation_factor
*
device_pixel_scale
.
0
)
.
ceil
(
)
;
let
device_rect
=
clipped
.
to_f32
(
)
.
inflate
(
inflation_factor
inflation_factor
)
.
intersection
(
&
unclipped
)
.
unwrap
(
)
;
match
device_rect
.
try_cast
:
:
<
i32
>
(
)
{
Some
(
rect
)
=
>
rect
None
=
>
{
return
None
}
}
}
else
{
clipped
}
;
let
original_size
=
device_rect
.
size
;
device_rect
.
size
=
RenderTask
:
:
adjusted_blur_source_size
(
device_rect
.
size
blur_std_deviation
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
device_rect
device_pixel_scale
true
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
device_rect
.
size
)
unclipped
.
size
pic_index
device_rect
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
blur_render_task_id
=
RenderTask
:
:
new_blur
(
blur_std_deviation
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
None
original_size
)
;
Some
(
(
blur_render_task_id
picture_task_id
)
)
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
let
mut
max_std_deviation
=
0
.
0
;
for
shadow
in
shadows
{
max_std_deviation
=
f32
:
:
max
(
max_std_deviation
shadow
.
blur_radius
*
device_pixel_scale
.
0
)
;
}
max_std_deviation
=
max_std_deviation
.
round
(
)
;
let
max_blur_range
=
(
max_std_deviation
*
BLUR_SAMPLE_SCALE
)
.
ceil
(
)
;
let
device_rect
=
clipped
.
to_f32
(
)
.
inflate
(
max_blur_range
max_blur_range
)
.
intersection
(
&
unclipped
)
.
unwrap
(
)
;
let
mut
device_rect
=
match
device_rect
.
try_cast
:
:
<
i32
>
(
)
{
Some
(
rect
)
=
>
rect
None
=
>
{
return
None
}
}
;
device_rect
.
size
=
RenderTask
:
:
adjusted_blur_source_size
(
device_rect
.
size
DeviceSize
:
:
new
(
max_std_deviation
max_std_deviation
)
)
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
device_rect
device_pixel_scale
true
)
;
let
mut
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
device_rect
.
size
)
unclipped
.
size
pic_index
device_rect
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
picture_task
.
mark_for_saving
(
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
self
.
secondary_render_task_id
=
Some
(
picture_task_id
)
;
let
mut
blur_tasks
=
BlurTaskCache
:
:
default
(
)
;
self
.
extra_gpu_data_handles
.
resize
(
shadows
.
len
(
)
GpuCacheHandle
:
:
new
(
)
)
;
let
mut
blur_render_task_id
=
picture_task_id
;
for
shadow
in
shadows
{
let
std_dev
=
f32
:
:
round
(
shadow
.
blur_radius
*
device_pixel_scale
.
0
)
;
blur_render_task_id
=
RenderTask
:
:
new_blur
(
DeviceSize
:
:
new
(
std_dev
std_dev
)
picture_task_id
frame_state
.
render_tasks
RenderTargetKind
:
:
Color
ClearMode
:
:
Transparent
Some
(
&
mut
blur_tasks
)
device_rect
.
size
)
;
}
Some
(
(
blur_render_task_id
picture_task_id
)
)
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
if
!
frame_context
.
fb_config
.
gpu_supports_advanced_blend
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
clipped
device_pixel_scale
true
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
pic_index
clipped
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
readback_task_id
=
frame_state
.
render_tasks
.
add
(
RenderTask
:
:
new_readback
(
clipped
)
)
;
frame_state
.
render_tasks
.
add_dependency
(
frame_state
.
surfaces
[
parent_surface_index
.
0
]
.
render_tasks
.
unwrap
(
)
.
port
readback_task_id
)
;
self
.
secondary_render_task_id
=
Some
(
readback_task_id
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
Some
(
(
render_task_id
render_task_id
)
)
}
PictureCompositeMode
:
:
Filter
(
.
.
)
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
clipped
device_pixel_scale
true
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
pic_index
clipped
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
Some
(
(
render_task_id
render_task_id
)
)
}
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
clipped
device_pixel_scale
true
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
pic_index
clipped
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
Some
(
(
render_task_id
render_task_id
)
)
}
PictureCompositeMode
:
:
TileCache
{
.
.
}
=
>
{
let
tile_cache
=
self
.
tile_cache
.
as_mut
(
)
.
unwrap
(
)
;
let
mut
first
=
true
;
let
tile_size
=
DeviceSize
:
:
new
(
TILE_SIZE_WIDTH
as
f32
TILE_SIZE_HEIGHT
as
f32
)
;
for
key
in
&
tile_cache
.
tiles_to_draw
{
let
tile
=
tile_cache
.
tiles
.
get_mut
(
key
)
.
expect
(
"
bug
:
no
tile
found
!
"
)
;
for
image_key
in
&
tile
.
current_descriptor
.
image_keys
{
frame_state
.
resource_cache
.
set_image_active
(
*
image_key
)
;
}
if
tile
.
is_valid
{
continue
;
}
let
surface
=
tile
.
surface
.
as_ref
(
)
.
expect
(
"
no
tile
surface
set
!
"
)
;
if
let
TileSurface
:
:
Texture
{
ref
handle
visibility_mask
}
=
surface
{
let
content_origin_f
=
tile
.
world_rect
.
origin
*
device_pixel_scale
;
let
content_origin
=
content_origin_f
.
round
(
)
;
debug_assert
!
(
(
content_origin_f
.
x
-
content_origin
.
x
)
.
abs
(
)
<
0
.
01
)
;
debug_assert
!
(
(
content_origin_f
.
y
-
content_origin
.
y
)
.
abs
(
)
<
0
.
01
)
;
let
scissor_rect
=
tile
.
world_dirty_rect
.
translate
(
-
tile
.
world_rect
.
origin
.
to_vector
(
)
)
*
device_pixel_scale
;
let
cache_item
=
frame_state
.
resource_cache
.
texture_cache
.
get
(
handle
)
;
let
task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
PictureCache
{
texture
:
cache_item
.
texture_id
layer
:
cache_item
.
texture_layer
size
:
tile_size
.
to_i32
(
)
}
tile_size
pic_index
content_origin
.
to_i32
(
)
UvRectKind
:
:
Rect
surface_spatial_node_index
device_pixel_scale
*
visibility_mask
Some
(
scissor_rect
.
to_i32
(
)
)
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
task
)
;
frame_state
.
render_tasks
.
add_dependency
(
frame_state
.
surfaces
[
parent_surface_index
.
0
]
.
render_tasks
.
unwrap
(
)
.
port
render_task_id
)
;
if
first
{
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
.
render_tasks
=
Some
(
SurfaceRenderTasks
{
root
:
render_task_id
port
:
render_task_id
}
)
;
first
=
false
;
}
}
tile
.
dirty_rect
=
PictureRect
:
:
zero
(
)
;
tile
.
is_valid
=
true
;
}
None
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
Blit
(
_
)
=
>
{
let
supports_snapping
=
match
self
.
context_3d
{
Picture3DContext
:
:
In
{
.
.
}
=
>
false
_
=
>
true
}
;
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
clipped
device_pixel_scale
supports_snapping
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
pic_index
clipped
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
render_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
Some
(
(
render_task_id
render_task_id
)
)
}
PictureCompositeMode
:
:
SvgFilter
(
ref
primitives
ref
filter_datas
)
=
>
{
let
uv_rect_kind
=
calculate_uv_rect_kind
(
&
pic_rect
&
transform
&
clipped
device_pixel_scale
true
)
;
let
picture_task
=
RenderTask
:
:
new_picture
(
RenderTaskLocation
:
:
Dynamic
(
None
clipped
.
size
)
unclipped
.
size
pic_index
clipped
.
origin
uv_rect_kind
surface_spatial_node_index
device_pixel_scale
PrimitiveVisibilityMask
:
:
all
(
)
None
)
;
let
picture_task_id
=
frame_state
.
render_tasks
.
add
(
picture_task
)
;
let
filter_task_id
=
RenderTask
:
:
new_svg_filter
(
primitives
filter_datas
&
mut
frame_state
.
render_tasks
clipped
.
size
uv_rect_kind
picture_task_id
device_pixel_scale
)
;
Some
(
(
filter_task_id
picture_task_id
)
)
}
}
;
if
let
Some
(
(
root
port
)
)
=
dep_info
{
frame_state
.
surfaces
[
raster_config
.
surface_index
.
0
]
.
render_tasks
=
Some
(
SurfaceRenderTasks
{
root
port
}
)
;
frame_state
.
render_tasks
.
add_dependency
(
frame_state
.
surfaces
[
parent_surface_index
.
0
]
.
render_tasks
.
unwrap
(
)
.
port
root
)
;
}
}
None
=
>
{
}
}
;
let
state
=
PictureState
{
map_local_to_pic
map_pic_to_world
map_pic_to_raster
map_raster_to_world
plane_splitter
}
;
let
mut
dirty_region_count
=
0
;
if
let
Some
(
RasterConfig
{
composite_mode
:
PictureCompositeMode
:
:
TileCache
{
.
.
}
.
.
}
)
=
self
.
raster_config
{
let
dirty_region
=
self
.
tile_cache
.
as_ref
(
)
.
unwrap
(
)
.
dirty_region
.
clone
(
)
;
frame_state
.
push_dirty_region
(
dirty_region
)
;
dirty_region_count
+
=
1
;
}
if
inflation_factor
>
0
.
0
{
let
inflated_region
=
frame_state
.
current_dirty_region
(
)
.
inflate
(
inflation_factor
)
;
frame_state
.
push_dirty_region
(
inflated_region
)
;
dirty_region_count
+
=
1
;
}
let
(
is_passthrough
subpixel_mode
)
=
match
self
.
raster_config
{
Some
(
RasterConfig
{
ref
composite_mode
.
.
}
)
=
>
{
let
subpixel_mode
=
match
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
.
.
}
=
>
{
self
.
tile_cache
.
as_ref
(
)
.
unwrap
(
)
.
subpixel_mode
}
PictureCompositeMode
:
:
Blit
(
.
.
)
|
PictureCompositeMode
:
:
ComponentTransferFilter
(
.
.
)
|
PictureCompositeMode
:
:
Filter
(
.
.
)
|
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
=
>
{
SubpixelMode
:
:
Deny
}
}
;
(
false
subpixel_mode
)
}
None
=
>
{
(
true
SubpixelMode
:
:
Allow
)
}
}
;
let
subpixel_mode
=
match
(
parent_subpixel_mode
subpixel_mode
)
{
(
SubpixelMode
:
:
Allow
SubpixelMode
:
:
Allow
)
=
>
SubpixelMode
:
:
Allow
_
=
>
SubpixelMode
:
:
Deny
}
;
let
context
=
PictureContext
{
pic_index
apply_local_clip_rect
:
self
.
apply_local_clip_rect
is_passthrough
raster_spatial_node_index
surface_spatial_node_index
surface_index
dirty_region_count
subpixel_mode
}
;
let
prim_list
=
mem
:
:
replace
(
&
mut
self
.
prim_list
PrimitiveList
:
:
empty
(
)
)
;
Some
(
(
context
state
prim_list
)
)
}
pub
fn
restore_context
(
&
mut
self
prim_list
:
PrimitiveList
context
:
PictureContext
state
:
PictureState
frame_state
:
&
mut
FrameBuildingState
)
{
for
_
in
0
.
.
context
.
dirty_region_count
{
frame_state
.
pop_dirty_region
(
)
;
}
self
.
prim_list
=
prim_list
;
self
.
state
=
Some
(
state
)
;
}
pub
fn
take_state
(
&
mut
self
)
-
>
PictureState
{
self
.
state
.
take
(
)
.
expect
(
"
bug
:
no
state
present
!
"
)
}
pub
fn
add_split_plane
(
splitter
:
&
mut
PlaneSplitter
clip_scroll_tree
:
&
ClipScrollTree
prim_spatial_node_index
:
SpatialNodeIndex
original_local_rect
:
LayoutRect
combined_local_clip_rect
:
&
LayoutRect
world_rect
:
WorldRect
plane_split_anchor
:
PlaneSplitAnchor
)
-
>
bool
{
let
transform
=
clip_scroll_tree
.
get_world_transform
(
prim_spatial_node_index
)
;
let
matrix
=
transform
.
clone
(
)
.
into_transform
(
)
.
cast
(
)
;
let
local_rect
=
match
original_local_rect
.
intersection
(
combined_local_clip_rect
)
{
Some
(
rect
)
=
>
rect
.
cast
(
)
None
=
>
return
false
}
;
let
world_rect
=
world_rect
.
cast
(
)
;
match
transform
{
CoordinateSpaceMapping
:
:
Local
=
>
{
let
polygon
=
Polygon
:
:
from_rect
(
local_rect
*
Scale
:
:
new
(
1
.
0
)
plane_split_anchor
)
;
splitter
.
add
(
polygon
)
;
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
scale_offset
)
if
scale_offset
.
scale
=
=
Vector2D
:
:
new
(
1
.
0
1
.
0
)
=
>
{
let
inv_matrix
=
scale_offset
.
inverse
(
)
.
to_transform
(
)
.
cast
(
)
;
let
polygon
=
Polygon
:
:
from_transformed_rect_with_inverse
(
local_rect
&
matrix
&
inv_matrix
plane_split_anchor
)
.
unwrap
(
)
;
splitter
.
add
(
polygon
)
;
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
_
)
|
CoordinateSpaceMapping
:
:
Transform
(
_
)
=
>
{
let
mut
clipper
=
Clipper
:
:
new
(
)
;
let
results
=
clipper
.
clip_transformed
(
Polygon
:
:
from_rect
(
local_rect
plane_split_anchor
)
&
matrix
Some
(
world_rect
)
)
;
if
let
Ok
(
results
)
=
results
{
for
poly
in
results
{
splitter
.
add
(
poly
)
;
}
}
}
}
true
}
pub
fn
resolve_split_planes
(
&
mut
self
splitter
:
&
mut
PlaneSplitter
gpu_cache
:
&
mut
GpuCache
clip_scroll_tree
:
&
ClipScrollTree
)
{
let
ordered
=
match
self
.
context_3d
{
Picture3DContext
:
:
In
{
root_data
:
Some
(
ref
mut
list
)
.
.
}
=
>
list
_
=
>
panic
!
(
"
Expected
to
find
3D
context
root
"
)
}
;
ordered
.
clear
(
)
;
for
poly
in
splitter
.
sort
(
vec3
(
0
.
0
0
.
0
1
.
0
)
)
{
let
cluster
=
&
self
.
prim_list
.
clusters
[
poly
.
anchor
.
cluster_index
]
;
let
spatial_node_index
=
cluster
.
spatial_node_index
;
let
transform
=
match
clip_scroll_tree
.
get_world_transform
(
spatial_node_index
)
.
inverse
(
)
{
Some
(
transform
)
=
>
transform
.
into_transform
(
)
None
=
>
continue
}
;
let
local_points
=
[
transform
.
transform_point3d
(
poly
.
points
[
0
]
.
cast
(
)
)
.
unwrap
(
)
transform
.
transform_point3d
(
poly
.
points
[
1
]
.
cast
(
)
)
.
unwrap
(
)
transform
.
transform_point3d
(
poly
.
points
[
2
]
.
cast
(
)
)
.
unwrap
(
)
transform
.
transform_point3d
(
poly
.
points
[
3
]
.
cast
(
)
)
.
unwrap
(
)
]
;
let
gpu_blocks
=
[
[
local_points
[
0
]
.
x
local_points
[
0
]
.
y
local_points
[
1
]
.
x
local_points
[
1
]
.
y
]
.
into
(
)
[
local_points
[
2
]
.
x
local_points
[
2
]
.
y
local_points
[
3
]
.
x
local_points
[
3
]
.
y
]
.
into
(
)
]
;
let
gpu_handle
=
gpu_cache
.
push_per_frame_blocks
(
&
gpu_blocks
)
;
let
gpu_address
=
gpu_cache
.
get_address
(
&
gpu_handle
)
;
ordered
.
push
(
OrderedPictureChild
{
anchor
:
poly
.
anchor
spatial_node_index
gpu_address
}
)
;
}
}
fn
pre_update
(
&
mut
self
state
:
&
mut
PictureUpdateState
frame_context
:
&
FrameBuildingContext
)
-
>
Option
<
PrimitiveList
>
{
self
.
raster_config
=
None
;
if
!
self
.
resolve_scene_properties
(
frame_context
.
scene_properties
)
{
return
None
;
}
if
!
self
.
is_backface_visible
{
if
let
Picture3DContext
:
:
Out
=
self
.
context_3d
{
match
frame_context
.
clip_scroll_tree
.
get_local_visible_face
(
self
.
spatial_node_index
)
{
VisibleFace
:
:
Front
=
>
{
}
VisibleFace
:
:
Back
=
>
return
None
}
}
}
state
.
push_picture
(
PictureInfo
{
_spatial_node_index
:
self
.
spatial_node_index
}
)
;
let
actual_composite_mode
=
match
self
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
ref
filter
)
)
if
filter
.
is_noop
(
)
=
>
None
Some
(
PictureCompositeMode
:
:
TileCache
{
.
.
}
)
=
>
{
let
spatial_node
=
&
frame_context
.
clip_scroll_tree
.
spatial_nodes
[
self
.
spatial_node_index
.
0
as
usize
]
;
if
spatial_node
.
coordinate_system_id
=
=
CoordinateSystemId
:
:
root
(
)
{
Some
(
PictureCompositeMode
:
:
TileCache
{
}
)
}
else
{
None
}
}
ref
mode
=
>
mode
.
clone
(
)
}
;
if
let
Some
(
composite_mode
)
=
actual_composite_mode
{
let
parent_raster_node_index
=
state
.
current_surface
(
)
.
raster_spatial_node_index
;
let
surface_spatial_node_index
=
self
.
spatial_node_index
;
let
inflation_factor
=
match
composite_mode
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
(
blur_radius
)
)
=
>
{
if
self
.
options
.
inflate_if_required
{
BLUR_SAMPLE_SCALE
*
blur_radius
}
else
{
0
.
0
}
}
PictureCompositeMode
:
:
SvgFilter
(
ref
primitives
_
)
if
self
.
options
.
inflate_if_required
=
>
{
let
mut
max
=
0
.
0
;
for
primitive
in
primitives
{
if
let
FilterPrimitiveKind
:
:
Blur
(
ref
blur
)
=
primitive
.
kind
{
max
=
f32
:
:
max
(
max
blur
.
radius
*
BLUR_SAMPLE_SCALE
)
;
}
}
max
}
_
=
>
{
0
.
0
}
}
;
let
has_svg_filter
=
if
let
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
=
composite_mode
{
true
}
else
{
false
}
;
let
establishes_raster_root
=
has_svg_filter
|
|
frame_context
.
clip_scroll_tree
.
get_relative_transform
(
surface_spatial_node_index
parent_raster_node_index
)
.
is_perspective
(
)
;
let
surface
=
SurfaceInfo
:
:
new
(
surface_spatial_node_index
if
establishes_raster_root
{
surface_spatial_node_index
}
else
{
parent_raster_node_index
}
inflation_factor
frame_context
.
global_screen_world_rect
&
frame_context
.
clip_scroll_tree
frame_context
.
global_device_pixel_scale
)
;
self
.
raster_config
=
Some
(
RasterConfig
{
composite_mode
establishes_raster_root
surface_index
:
state
.
push_surface
(
surface
)
}
)
;
}
Some
(
mem
:
:
replace
(
&
mut
self
.
prim_list
PrimitiveList
:
:
empty
(
)
)
)
}
fn
post_update
(
&
mut
self
prim_list
:
PrimitiveList
state
:
&
mut
PictureUpdateState
frame_context
:
&
FrameBuildingContext
data_stores
:
&
mut
DataStores
)
{
self
.
prim_list
=
prim_list
;
state
.
pop_picture
(
)
;
for
cluster
in
&
mut
self
.
prim_list
.
clusters
{
cluster
.
flags
.
remove
(
ClusterFlags
:
:
IS_VISIBLE
)
;
if
!
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_BACKFACE_VISIBLE
)
{
if
let
Picture3DContext
:
:
In
{
ancestor_index
.
.
}
=
self
.
context_3d
{
match
frame_context
.
clip_scroll_tree
.
get_relative_transform
(
cluster
.
spatial_node_index
ancestor_index
)
.
visible_face
(
)
{
VisibleFace
:
:
Back
=
>
continue
VisibleFace
:
:
Front
=
>
(
)
}
}
}
let
spatial_node
=
&
frame_context
.
clip_scroll_tree
.
spatial_nodes
[
cluster
.
spatial_node_index
.
0
as
usize
]
;
if
!
spatial_node
.
invertible
{
continue
;
}
if
cluster
.
flags
.
contains
(
ClusterFlags
:
:
IS_BACKDROP_FILTER
)
{
let
backdrop_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
cluster
.
spatial_node_index
LayoutRect
:
:
max_rect
(
)
frame_context
.
clip_scroll_tree
)
;
for
prim_instance
in
&
mut
cluster
.
prim_instances
{
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Backdrop
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
mut
data_stores
.
backdrop
[
data_handle
]
;
let
spatial_node_index
=
prim_data
.
kind
.
spatial_node_index
;
let
prim_to_world_mapper
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
spatial_node_index
LayoutRect
:
:
max_rect
(
)
frame_context
.
clip_scroll_tree
)
;
let
prim_rect
=
prim_to_world_mapper
.
map
(
&
prim_data
.
kind
.
border_rect
)
.
unwrap_or_else
(
LayoutRect
:
:
zero
)
;
let
prim_rect
=
backdrop_to_world_mapper
.
unmap
(
&
prim_rect
)
.
unwrap_or_else
(
LayoutRect
:
:
zero
)
;
prim_instance
.
prim_origin
=
prim_rect
.
origin
;
prim_data
.
common
.
prim_size
=
prim_rect
.
size
;
prim_instance
.
local_clip_rect
=
prim_rect
;
cluster
.
bounding_rect
=
cluster
.
bounding_rect
.
union
(
&
prim_rect
)
;
}
_
=
>
{
panic
!
(
"
BUG
:
unexpected
deferred
primitive
kind
for
cluster
updates
"
)
;
}
}
}
}
let
surface
=
state
.
current_surface_mut
(
)
;
surface
.
map_local_to_surface
.
set_target_spatial_node
(
cluster
.
spatial_node_index
frame_context
.
clip_scroll_tree
)
;
cluster
.
flags
.
insert
(
ClusterFlags
:
:
IS_VISIBLE
)
;
if
let
Some
(
cluster_rect
)
=
surface
.
map_local_to_surface
.
map
(
&
cluster
.
bounding_rect
)
{
surface
.
rect
=
surface
.
rect
.
union
(
&
cluster_rect
)
;
}
}
if
let
Some
(
ref
mut
raster_config
)
=
self
.
raster_config
{
let
surface
=
state
.
current_surface_mut
(
)
;
if
self
.
options
.
inflate_if_required
{
surface
.
rect
=
raster_config
.
composite_mode
.
inflate_picture_rect
(
surface
.
rect
surface
.
inflation_factor
)
;
let
snap_surface_to_raster
=
SpaceSnapper
:
:
new_with_target
(
surface
.
raster_spatial_node_index
self
.
spatial_node_index
surface
.
device_pixel_scale
frame_context
.
clip_scroll_tree
)
;
surface
.
rect
=
snap_surface_to_raster
.
snap_rect
(
&
surface
.
rect
)
;
}
let
mut
surface_rect
=
surface
.
rect
*
Scale
:
:
new
(
1
.
0
)
;
let
surface_index
=
state
.
pop_surface
(
)
;
debug_assert_eq
!
(
surface_index
raster_config
.
surface_index
)
;
if
raster_config
.
establishes_raster_root
{
if
surface_rect
.
size
.
width
>
MAX_SURFACE_SIZE
|
|
surface_rect
.
size
.
height
>
MAX_SURFACE_SIZE
{
raster_config
.
establishes_raster_root
=
false
;
state
.
are_raster_roots_assigned
=
false
;
}
}
self
.
local_rect
=
surface_rect
;
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
for
shadow
in
shadows
{
let
content_rect
=
surface_rect
;
let
shadow_rect
=
surface_rect
.
translate
(
shadow
.
offset
)
;
surface_rect
=
content_rect
.
union
(
&
shadow_rect
)
;
}
}
_
=
>
{
}
}
let
parent_surface
=
state
.
current_surface_mut
(
)
;
parent_surface
.
map_local_to_surface
.
set_target_spatial_node
(
self
.
spatial_node_index
frame_context
.
clip_scroll_tree
)
;
if
let
Some
(
parent_surface_rect
)
=
parent_surface
.
map_local_to_surface
.
map
(
&
surface_rect
)
{
parent_surface
.
rect
=
parent_surface
.
rect
.
union
(
&
parent_surface_rect
)
;
}
}
}
pub
fn
prepare_for_render
(
&
mut
self
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
data_stores
:
&
mut
DataStores
)
-
>
bool
{
let
mut
pic_state_for_children
=
self
.
take_state
(
)
;
if
let
Some
(
ref
mut
splitter
)
=
pic_state_for_children
.
plane_splitter
{
self
.
resolve_split_planes
(
splitter
&
mut
frame_state
.
gpu_cache
&
frame_context
.
clip_scroll_tree
)
;
}
let
raster_config
=
match
self
.
raster_config
{
Some
(
ref
mut
raster_config
)
=
>
raster_config
None
=
>
{
return
true
}
}
;
match
raster_config
.
composite_mode
{
PictureCompositeMode
:
:
TileCache
{
.
.
}
=
>
{
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
(
.
.
)
)
=
>
{
}
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
(
ref
shadows
)
)
=
>
{
self
.
extra_gpu_data_handles
.
resize
(
shadows
.
len
(
)
GpuCacheHandle
:
:
new
(
)
)
;
for
(
shadow
extra_handle
)
in
shadows
.
iter
(
)
.
zip
(
self
.
extra_gpu_data_handles
.
iter_mut
(
)
)
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
extra_handle
)
{
let
shadow_rect
=
self
.
local_rect
.
translate
(
shadow
.
offset
)
;
request
.
push
(
shadow
.
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
self
.
local_rect
.
size
.
width
self
.
local_rect
.
size
.
height
0
.
0
0
.
0
]
)
;
request
.
push
(
shadow_rect
)
;
request
.
push
(
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
}
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
if
!
frame_context
.
fb_config
.
gpu_supports_advanced_blend
=
>
{
}
PictureCompositeMode
:
:
Filter
(
ref
filter
)
=
>
{
match
*
filter
{
Filter
:
:
ColorMatrix
(
ref
m
)
=
>
{
if
self
.
extra_gpu_data_handles
.
is_empty
(
)
{
self
.
extra_gpu_data_handles
.
push
(
GpuCacheHandle
:
:
new
(
)
)
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handles
[
0
]
)
{
for
i
in
0
.
.
5
{
request
.
push
(
[
m
[
i
*
4
]
m
[
i
*
4
+
1
]
m
[
i
*
4
+
2
]
m
[
i
*
4
+
3
]
]
)
;
}
}
}
Filter
:
:
Flood
(
ref
color
)
=
>
{
if
self
.
extra_gpu_data_handles
.
is_empty
(
)
{
self
.
extra_gpu_data_handles
.
push
(
GpuCacheHandle
:
:
new
(
)
)
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
extra_gpu_data_handles
[
0
]
)
{
request
.
push
(
color
.
to_array
(
)
)
;
}
}
_
=
>
{
}
}
}
PictureCompositeMode
:
:
ComponentTransferFilter
(
handle
)
=
>
{
let
filter_data
=
&
mut
data_stores
.
filter_data
[
handle
]
;
filter_data
.
update
(
frame_state
)
;
}
PictureCompositeMode
:
:
MixBlend
(
.
.
)
|
PictureCompositeMode
:
:
Blit
(
_
)
|
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
=
>
{
}
}
true
}
}
fn
calculate_screen_uv
(
local_pos
:
&
PicturePoint
transform
:
&
PictureToRasterTransform
rendered_rect
:
&
DeviceRect
device_pixel_scale
:
DevicePixelScale
supports_snapping
:
bool
)
-
>
DeviceHomogeneousVector
{
let
raster_pos
=
transform
.
transform_point2d_homogeneous
(
*
local_pos
)
;
let
mut
device_vec
=
DeviceHomogeneousVector
:
:
new
(
raster_pos
.
x
*
device_pixel_scale
.
0
raster_pos
.
y
*
device_pixel_scale
.
0
0
.
0
raster_pos
.
w
)
;
if
transform
.
transform_kind
(
)
=
=
TransformedRectKind
:
:
AxisAligned
&
&
supports_snapping
{
device_vec
=
DeviceHomogeneousVector
:
:
new
(
(
device_vec
.
x
/
device_vec
.
w
+
0
.
5
)
.
floor
(
)
(
device_vec
.
y
/
device_vec
.
w
+
0
.
5
)
.
floor
(
)
0
.
0
1
.
0
)
;
}
DeviceHomogeneousVector
:
:
new
(
(
device_vec
.
x
-
rendered_rect
.
origin
.
x
*
device_vec
.
w
)
/
rendered_rect
.
size
.
width
(
device_vec
.
y
-
rendered_rect
.
origin
.
y
*
device_vec
.
w
)
/
rendered_rect
.
size
.
height
0
.
0
device_vec
.
w
)
}
fn
calculate_uv_rect_kind
(
pic_rect
:
&
PictureRect
transform
:
&
PictureToRasterTransform
rendered_rect
:
&
DeviceIntRect
device_pixel_scale
:
DevicePixelScale
supports_snapping
:
bool
)
-
>
UvRectKind
{
let
rendered_rect
=
rendered_rect
.
to_f32
(
)
;
let
top_left
=
calculate_screen_uv
(
&
pic_rect
.
origin
transform
&
rendered_rect
device_pixel_scale
supports_snapping
)
;
let
top_right
=
calculate_screen_uv
(
&
pic_rect
.
top_right
(
)
transform
&
rendered_rect
device_pixel_scale
supports_snapping
)
;
let
bottom_left
=
calculate_screen_uv
(
&
pic_rect
.
bottom_left
(
)
transform
&
rendered_rect
device_pixel_scale
supports_snapping
)
;
let
bottom_right
=
calculate_screen_uv
(
&
pic_rect
.
bottom_right
(
)
transform
&
rendered_rect
device_pixel_scale
supports_snapping
)
;
UvRectKind
:
:
Quad
{
top_left
top_right
bottom_left
bottom_right
}
}
fn
create_raster_mappers
(
surface_spatial_node_index
:
SpatialNodeIndex
raster_spatial_node_index
:
SpatialNodeIndex
world_rect
:
WorldRect
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
(
SpaceMapper
<
RasterPixel
WorldPixel
>
SpaceMapper
<
PicturePixel
RasterPixel
>
)
{
let
map_raster_to_world
=
SpaceMapper
:
:
new_with_target
(
ROOT_SPATIAL_NODE_INDEX
raster_spatial_node_index
world_rect
clip_scroll_tree
)
;
let
raster_bounds
=
map_raster_to_world
.
unmap
(
&
world_rect
)
.
unwrap_or_else
(
RasterRect
:
:
max_rect
)
;
let
map_pic_to_raster
=
SpaceMapper
:
:
new_with_target
(
raster_spatial_node_index
surface_spatial_node_index
raster_bounds
clip_scroll_tree
)
;
(
map_raster_to_world
map_pic_to_raster
)
}
fn
get_transform_key
(
spatial_node_index
:
SpatialNodeIndex
cache_spatial_node_index
:
SpatialNodeIndex
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
TransformKey
{
let
transform
=
if
cache_spatial_node_index
>
=
spatial_node_index
{
clip_scroll_tree
.
get_relative_transform
(
cache_spatial_node_index
spatial_node_index
)
}
else
{
clip_scroll_tree
.
get_relative_transform
(
spatial_node_index
cache_spatial_node_index
)
}
;
transform
.
into
(
)
}
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
PartialEq
)
]
struct
PrimitiveComparisonKey
{
prev_index
:
PrimitiveDependencyIndex
curr_index
:
PrimitiveDependencyIndex
}
struct
PrimitiveComparer
<
'
a
>
{
clip_comparer
:
CompareHelper
<
'
a
ItemUid
>
transform_comparer
:
CompareHelper
<
'
a
SpatialNodeIndex
>
image_comparer
:
CompareHelper
<
'
a
ImageKey
>
opacity_comparer
:
CompareHelper
<
'
a
OpacityBinding
>
resource_cache
:
&
'
a
ResourceCache
spatial_nodes
:
&
'
a
FastHashMap
<
SpatialNodeIndex
SpatialNodeDependency
>
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
}
impl
<
'
a
>
PrimitiveComparer
<
'
a
>
{
fn
new
(
prev
:
&
'
a
TileDescriptor
curr
:
&
'
a
TileDescriptor
resource_cache
:
&
'
a
ResourceCache
spatial_nodes
:
&
'
a
FastHashMap
<
SpatialNodeIndex
SpatialNodeDependency
>
opacity_bindings
:
&
'
a
FastHashMap
<
PropertyBindingId
OpacityBindingInfo
>
)
-
>
Self
{
let
clip_comparer
=
CompareHelper
:
:
new
(
&
prev
.
clips
&
curr
.
clips
)
;
let
transform_comparer
=
CompareHelper
:
:
new
(
&
prev
.
transforms
&
curr
.
transforms
)
;
let
image_comparer
=
CompareHelper
:
:
new
(
&
prev
.
image_keys
&
curr
.
image_keys
)
;
let
opacity_comparer
=
CompareHelper
:
:
new
(
&
prev
.
opacity_bindings
&
curr
.
opacity_bindings
)
;
PrimitiveComparer
{
clip_comparer
transform_comparer
image_comparer
opacity_comparer
resource_cache
spatial_nodes
opacity_bindings
}
}
fn
reset
(
&
mut
self
)
{
self
.
clip_comparer
.
reset
(
)
;
self
.
transform_comparer
.
reset
(
)
;
self
.
image_comparer
.
reset
(
)
;
self
.
opacity_comparer
.
reset
(
)
;
}
fn
advance_prev
(
&
mut
self
prim
:
&
PrimitiveDescriptor
)
{
self
.
clip_comparer
.
advance_prev
(
prim
.
clip_dep_count
)
;
self
.
transform_comparer
.
advance_prev
(
prim
.
transform_dep_count
)
;
self
.
image_comparer
.
advance_prev
(
prim
.
image_dep_count
)
;
self
.
opacity_comparer
.
advance_prev
(
prim
.
opacity_binding_dep_count
)
;
}
fn
advance_curr
(
&
mut
self
prim
:
&
PrimitiveDescriptor
)
{
self
.
clip_comparer
.
advance_curr
(
prim
.
clip_dep_count
)
;
self
.
transform_comparer
.
advance_curr
(
prim
.
transform_dep_count
)
;
self
.
image_comparer
.
advance_curr
(
prim
.
image_dep_count
)
;
self
.
opacity_comparer
.
advance_curr
(
prim
.
opacity_binding_dep_count
)
;
}
fn
is_prim_same
(
&
mut
self
prev
:
&
PrimitiveDescriptor
curr
:
&
PrimitiveDescriptor
)
-
>
bool
{
let
resource_cache
=
self
.
resource_cache
;
let
spatial_nodes
=
self
.
spatial_nodes
;
let
opacity_bindings
=
self
.
opacity_bindings
;
if
prev
!
=
curr
{
return
false
;
}
if
!
self
.
clip_comparer
.
is_same
(
prev
.
clip_dep_count
curr
.
clip_dep_count
|
_
|
{
false
}
)
{
return
false
;
}
if
!
self
.
transform_comparer
.
is_same
(
prev
.
transform_dep_count
curr
.
transform_dep_count
|
curr
|
{
spatial_nodes
[
curr
]
.
changed
}
)
{
return
false
;
}
if
!
self
.
image_comparer
.
is_same
(
prev
.
image_dep_count
curr
.
image_dep_count
|
curr
|
{
resource_cache
.
is_image_dirty
(
*
curr
)
}
)
{
return
false
;
}
if
!
self
.
opacity_comparer
.
is_same
(
prev
.
opacity_binding_dep_count
curr
.
opacity_binding_dep_count
|
curr
|
{
if
let
OpacityBinding
:
:
Binding
(
id
)
=
curr
{
if
opacity_bindings
.
get
(
id
)
.
map_or
(
true
|
info
|
info
.
changed
)
{
return
true
;
}
}
false
}
)
{
return
false
;
}
true
}
}
enum
TileNodeKind
{
Leaf
{
prev_indices
:
Vec
<
PrimitiveDependencyIndex
>
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
dirty_tracker
:
u64
frames_since_modified
:
usize
}
Node
{
children
:
Vec
<
TileNode
>
}
}
#
[
derive
(
Copy
Clone
PartialEq
Debug
)
]
enum
TileModification
{
Split
Merge
}
struct
TileNode
{
kind
:
TileNodeKind
rect
:
PictureRect
}
impl
TileNode
{
fn
new_leaf
(
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
)
-
>
Self
{
TileNode
{
kind
:
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
rect
:
PictureRect
:
:
zero
(
)
}
}
fn
draw_debug_rects
(
&
self
pic_to_world_mapper
:
&
SpaceMapper
<
PicturePixel
WorldPixel
>
is_opaque
:
bool
scratch
:
&
mut
PrimitiveScratchBuffer
global_device_pixel_scale
:
DevicePixelScale
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
.
.
}
=
>
{
let
color
=
if
(
dirty_tracker
&
1
)
!
=
0
{
debug_colors
:
:
RED
}
else
if
is_opaque
{
debug_colors
:
:
GREEN
}
else
{
debug_colors
:
:
YELLOW
}
;
let
world_rect
=
pic_to_world_mapper
.
map
(
&
self
.
rect
)
.
unwrap
(
)
;
let
device_rect
=
world_rect
*
global_device_pixel_scale
;
scratch
.
push_debug_rect
(
device_rect
.
inflate
(
-
3
.
0
-
3
.
0
)
color
.
scale_alpha
(
0
.
6
)
)
;
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
for
child
in
children
.
iter
(
)
{
child
.
draw_debug_rects
(
pic_to_world_mapper
is_opaque
scratch
global_device_pixel_scale
)
;
}
}
}
}
fn
get_child_rects
(
rect
:
&
PictureRect
)
-
>
Vec
<
PictureRect
>
{
let
p0
=
rect
.
origin
;
let
half_size
=
PictureSize
:
:
new
(
rect
.
size
.
width
*
0
.
5
rect
.
size
.
height
*
0
.
5
)
;
[
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
p0
.
y
)
half_size
)
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
+
half_size
.
width
p0
.
y
)
half_size
)
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
p0
.
y
+
half_size
.
height
)
half_size
)
PictureRect
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
+
half_size
.
width
p0
.
y
+
half_size
.
height
)
half_size
)
]
.
to_vec
(
)
}
fn
clear
(
&
mut
self
rect
:
PictureRect
)
{
self
.
rect
=
rect
;
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
prev_indices
ref
mut
curr_indices
ref
mut
dirty_tracker
ref
mut
frames_since_modified
}
=
>
{
mem
:
:
swap
(
prev_indices
curr_indices
)
;
curr_indices
.
clear
(
)
;
*
dirty_tracker
=
*
dirty_tracker
<
<
1
;
*
frames_since_modified
+
=
1
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
child_rects
=
TileNode
:
:
get_child_rects
(
&
rect
)
;
assert_eq
!
(
child_rects
.
len
(
)
children
.
len
(
)
)
;
for
(
child
rect
)
in
children
.
iter_mut
(
)
.
zip
(
child_rects
.
iter
(
)
)
{
child
.
clear
(
*
rect
)
;
}
}
}
}
fn
add_prim
(
&
mut
self
index
:
PrimitiveDependencyIndex
prim_rect
:
&
PictureRect
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
curr_indices
.
push
(
index
)
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
if
child
.
rect
.
intersects
(
prim_rect
)
{
child
.
add_prim
(
index
prim_rect
)
;
}
}
}
}
}
fn
get_preference
(
&
self
level
:
i32
can_merge
:
bool
)
-
>
Option
<
TileModification
>
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
frames_since_modified
.
.
}
=
>
{
if
frames_since_modified
>
64
{
let
dirty_frames
=
dirty_tracker
.
count_ones
(
)
;
if
level
<
3
&
&
dirty_frames
>
32
{
Some
(
TileModification
:
:
Split
)
}
else
if
can_merge
&
&
(
dirty_tracker
=
=
0
|
|
dirty_frames
=
=
64
)
&
&
level
>
0
{
Some
(
TileModification
:
:
Merge
)
}
else
{
None
}
}
else
{
None
}
}
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
None
}
}
}
fn
maybe_merge_or_split
(
&
mut
self
level
:
i32
curr_prims
:
&
[
PrimitiveDescriptor
]
)
{
let
tile_mod
=
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
.
.
}
=
>
{
self
.
get_preference
(
level
false
)
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
if
children
.
iter
(
)
.
all
(
|
c
|
c
.
get_preference
(
level
+
1
true
)
=
=
Some
(
TileModification
:
:
Merge
)
)
{
Some
(
TileModification
:
:
Merge
)
}
else
{
None
}
}
}
;
match
tile_mod
{
Some
(
TileModification
:
:
Split
)
=
>
{
let
curr_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
only
leaves
can
split
"
)
;
}
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
curr_indices
.
take
(
)
}
}
;
let
child_rects
=
TileNode
:
:
get_child_rects
(
&
self
.
rect
)
;
let
child_rects
:
Vec
<
RectangleKey
>
=
child_rects
.
iter
(
)
.
map
(
|
r
|
(
*
r
)
.
into
(
)
)
.
collect
(
)
;
let
mut
child_indices
=
vec
!
[
Vec
:
:
new
(
)
;
child_rects
.
len
(
)
]
;
for
index
in
curr_indices
{
let
prim
=
&
curr_prims
[
index
.
0
as
usize
]
;
for
(
child_rect
indices
)
in
child_rects
.
iter
(
)
.
zip
(
child_indices
.
iter_mut
(
)
)
{
if
prim
.
prim_clip_rect
.
intersects
(
child_rect
)
{
indices
.
push
(
index
)
;
}
}
}
let
children
=
child_indices
.
into_iter
(
)
.
map
(
|
i
|
TileNode
:
:
new_leaf
(
i
)
)
.
collect
(
)
;
self
.
kind
=
TileNodeKind
:
:
Node
{
children
:
children
}
;
}
Some
(
TileModification
:
:
Merge
)
=
>
{
let
merged_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
mut
merged_indices
=
Vec
:
:
new
(
)
;
for
child
in
children
.
iter
(
)
{
let
child_indices
=
match
child
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
curr_indices
.
.
}
=
>
{
curr_indices
}
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
:
child
is
not
a
leaf
"
)
;
}
}
;
merged_indices
.
extend_from_slice
(
child_indices
)
;
}
merged_indices
.
sort
(
)
;
merged_indices
.
dedup
(
)
;
merged_indices
}
TileNodeKind
:
:
Leaf
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
trying
to
merge
a
leaf
"
)
;
}
}
;
self
.
kind
=
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
:
merged_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
;
}
None
=
>
{
if
let
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
self
.
kind
{
for
child
in
children
.
iter_mut
(
)
{
child
.
maybe_merge_or_split
(
level
+
1
curr_prims
)
;
}
}
}
}
}
fn
update_dirty_rects
(
&
mut
self
prev_prims
:
&
[
PrimitiveDescriptor
]
curr_prims
:
&
[
PrimitiveDescriptor
]
prim_comparer
:
&
mut
PrimitiveComparer
dirty_rect
:
&
mut
PictureRect
compare_cache
:
&
mut
FastHashMap
<
PrimitiveComparisonKey
bool
>
)
{
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
child
.
update_dirty_rects
(
prev_prims
curr_prims
prim_comparer
dirty_rect
compare_cache
)
;
}
}
TileNodeKind
:
:
Leaf
{
ref
prev_indices
ref
curr_indices
ref
mut
dirty_tracker
.
.
}
=
>
{
if
prev_indices
.
len
(
)
=
=
curr_indices
.
len
(
)
{
let
mut
prev_i0
=
0
;
let
mut
prev_i1
=
0
;
prim_comparer
.
reset
(
)
;
for
(
prev_index
curr_index
)
in
prev_indices
.
iter
(
)
.
zip
(
curr_indices
.
iter
(
)
)
{
let
i0
=
prev_index
.
0
as
usize
;
let
i1
=
curr_index
.
0
as
usize
;
for
i
in
prev_i0
.
.
i0
{
prim_comparer
.
advance_prev
(
&
prev_prims
[
i
]
)
;
}
for
i
in
prev_i1
.
.
i1
{
prim_comparer
.
advance_curr
(
&
curr_prims
[
i
]
)
;
}
let
key
=
PrimitiveComparisonKey
{
prev_index
:
*
prev_index
curr_index
:
*
curr_index
}
;
let
is_prim_same
=
*
compare_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
prev
=
&
prev_prims
[
i0
]
;
let
curr
=
&
curr_prims
[
i1
]
;
prim_comparer
.
is_prim_same
(
prev
curr
)
}
)
;
if
!
is_prim_same
{
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
break
;
}
prev_i0
=
i0
;
prev_i1
=
i1
;
}
}
else
{
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
}
}
}
}
}
