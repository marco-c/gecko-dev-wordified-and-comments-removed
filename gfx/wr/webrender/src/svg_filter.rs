use
api
:
:
{
FilterOpGraphPictureReference
FilterOpGraphNode
ColorF
ColorU
PropertyBinding
PropertyBindingId
}
;
use
api
:
:
SVGFE_GRAPH_MAX
;
use
api
:
:
units
:
:
*
;
use
api
:
:
FilterOpGraphPictureBufferId
;
use
crate
:
:
profiler
:
:
add_text_marker
;
use
crate
:
:
filterdata
:
:
FilterDataHandle
;
use
crate
:
:
intern
:
:
ItemUid
;
use
core
:
:
time
:
:
Duration
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Copy
Default
MallocSizeOf
PartialEq
Hash
Eq
)
]
pub
enum
FilterGraphPictureBufferIdKey
{
#
[
default
]
None
BufferId
(
i16
)
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Copy
Default
MallocSizeOf
PartialEq
Hash
Eq
)
]
pub
struct
FilterGraphPictureReferenceKey
{
pub
buffer_id
:
FilterGraphPictureBufferIdKey
pub
subregion
:
[
Au
;
4
]
pub
offset
:
[
Au
;
2
]
}
impl
From
<
FilterGraphPictureReference
>
for
FilterGraphPictureReferenceKey
{
fn
from
(
pic
:
FilterGraphPictureReference
)
-
>
Self
{
FilterGraphPictureReferenceKey
{
buffer_id
:
match
pic
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
None
=
>
FilterGraphPictureBufferIdKey
:
:
None
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
FilterGraphPictureBufferIdKey
:
:
BufferId
(
id
)
}
subregion
:
[
Au
:
:
from_f32_px
(
pic
.
subregion
.
min
.
x
)
Au
:
:
from_f32_px
(
pic
.
subregion
.
min
.
y
)
Au
:
:
from_f32_px
(
pic
.
subregion
.
max
.
x
)
Au
:
:
from_f32_px
(
pic
.
subregion
.
max
.
y
)
]
offset
:
[
Au
:
:
from_f32_px
(
pic
.
offset
.
x
)
Au
:
:
from_f32_px
(
pic
.
offset
.
y
)
]
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
MallocSizeOf
PartialEq
Hash
Eq
)
]
pub
enum
FilterGraphOpKey
{
SVGFEBlendDarken
SVGFEBlendLighten
SVGFEBlendMultiply
SVGFEBlendNormal
SVGFEBlendScreen
SVGFEBlendOverlay
SVGFEBlendColorDodge
SVGFEBlendColorBurn
SVGFEBlendHardLight
SVGFEBlendSoftLight
SVGFEBlendDifference
SVGFEBlendExclusion
SVGFEBlendHue
SVGFEBlendSaturation
SVGFEBlendColor
SVGFEBlendLuminosity
SVGFEColorMatrix
{
values
:
[
Au
;
20
]
}
SVGFEComponentTransferInterned
{
handle
:
ItemUid
creates_pixels
:
bool
}
SVGFECompositeArithmetic
{
k1
:
Au
k2
:
Au
k3
:
Au
k4
:
Au
}
SVGFECompositeATop
SVGFECompositeIn
SVGFECompositeLighter
SVGFECompositeOut
SVGFECompositeOver
SVGFECompositeXOR
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
:
i32
order_y
:
i32
kernel
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
Au
bias
:
Au
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeNone
{
order_x
:
i32
order_y
:
i32
kernel
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
Au
bias
:
Au
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
:
i32
order_y
:
i32
kernel
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
Au
bias
:
Au
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
preserve_alpha
:
i32
}
SVGFEDiffuseLightingDistant
{
surface_scale
:
Au
diffuse_constant
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
azimuth
:
Au
elevation
:
Au
}
SVGFEDiffuseLightingPoint
{
surface_scale
:
Au
diffuse_constant
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
x
:
Au
y
:
Au
z
:
Au
}
SVGFEDiffuseLightingSpot
{
surface_scale
:
Au
diffuse_constant
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
x
:
Au
y
:
Au
z
:
Au
points_at_x
:
Au
points_at_y
:
Au
points_at_z
:
Au
cone_exponent
:
Au
limiting_cone_angle
:
Au
}
SVGFEDisplacementMap
{
scale
:
Au
x_channel_selector
:
u32
y_channel_selector
:
u32
}
SVGFEDropShadow
{
color
:
ColorU
dx
:
Au
dy
:
Au
std_deviation_x
:
Au
std_deviation_y
:
Au
}
SVGFEFlood
{
color
:
ColorU
}
SVGFEGaussianBlur
{
std_deviation_x
:
Au
std_deviation_y
:
Au
}
SVGFEIdentity
SVGFEImage
{
sampling_filter
:
u32
matrix
:
[
Au
;
6
]
}
SVGFEMorphologyDilate
{
radius_x
:
Au
radius_y
:
Au
}
SVGFEMorphologyErode
{
radius_x
:
Au
radius_y
:
Au
}
SVGFEOpacity
{
value
:
Au
}
SVGFEOpacityBinding
{
valuebindingid
:
PropertyBindingId
value
:
Au
}
SVGFESourceGraphic
SVGFESourceAlpha
SVGFESpecularLightingDistant
{
surface_scale
:
Au
specular_constant
:
Au
specular_exponent
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
azimuth
:
Au
elevation
:
Au
}
SVGFESpecularLightingPoint
{
surface_scale
:
Au
specular_constant
:
Au
specular_exponent
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
x
:
Au
y
:
Au
z
:
Au
}
SVGFESpecularLightingSpot
{
surface_scale
:
Au
specular_constant
:
Au
specular_exponent
:
Au
kernel_unit_length_x
:
Au
kernel_unit_length_y
:
Au
x
:
Au
y
:
Au
z
:
Au
points_at_x
:
Au
points_at_y
:
Au
points_at_z
:
Au
cone_exponent
:
Au
limiting_cone_angle
:
Au
}
SVGFETile
SVGFEToAlpha
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
:
Au
base_frequency_y
:
Au
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
:
Au
base_frequency_y
:
Au
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
:
Au
base_frequency_y
:
Au
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
:
Au
base_frequency_y
:
Au
num_octaves
:
u32
seed
:
u32
}
}
impl
From
<
FilterGraphOp
>
for
FilterGraphOpKey
{
fn
from
(
op
:
FilterGraphOp
)
-
>
Self
{
match
op
{
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
FilterGraphOpKey
:
:
SVGFEBlendDarken
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
FilterGraphOpKey
:
:
SVGFEBlendLighten
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
FilterGraphOpKey
:
:
SVGFEBlendMultiply
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
FilterGraphOpKey
:
:
SVGFEBlendNormal
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
FilterGraphOpKey
:
:
SVGFEBlendScreen
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
FilterGraphOpKey
:
:
SVGFEBlendOverlay
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
FilterGraphOpKey
:
:
SVGFEBlendColorDodge
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
FilterGraphOpKey
:
:
SVGFEBlendColorBurn
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
FilterGraphOpKey
:
:
SVGFEBlendHardLight
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
FilterGraphOpKey
:
:
SVGFEBlendSoftLight
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
FilterGraphOpKey
:
:
SVGFEBlendDifference
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
FilterGraphOpKey
:
:
SVGFEBlendExclusion
FilterGraphOp
:
:
SVGFEBlendHue
=
>
FilterGraphOpKey
:
:
SVGFEBlendHue
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
FilterGraphOpKey
:
:
SVGFEBlendSaturation
FilterGraphOp
:
:
SVGFEBlendColor
=
>
FilterGraphOpKey
:
:
SVGFEBlendColor
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
FilterGraphOpKey
:
:
SVGFEBlendLuminosity
FilterGraphOp
:
:
SVGFEColorMatrix
{
values
:
color_matrix
}
=
>
{
let
mut
quantized_values
:
[
Au
;
20
]
=
[
Au
(
0
)
;
20
]
;
for
(
value
result
)
in
color_matrix
.
iter
(
)
.
zip
(
quantized_values
.
iter_mut
(
)
)
{
*
result
=
Au
:
:
from_f32_px
(
*
value
)
;
}
FilterGraphOpKey
:
:
SVGFEColorMatrix
{
values
:
quantized_values
}
}
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
unreachable
!
(
)
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
handle
creates_pixels
}
=
>
FilterGraphOpKey
:
:
SVGFEComponentTransferInterned
{
handle
:
handle
.
uid
(
)
creates_pixels
}
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
k1
k2
k3
k4
}
=
>
{
FilterGraphOpKey
:
:
SVGFECompositeArithmetic
{
k1
:
Au
:
:
from_f32_px
(
k1
)
k2
:
Au
:
:
from_f32_px
(
k2
)
k3
:
Au
:
:
from_f32_px
(
k3
)
k4
:
Au
:
:
from_f32_px
(
k4
)
}
}
FilterGraphOp
:
:
SVGFECompositeATop
=
>
FilterGraphOpKey
:
:
SVGFECompositeATop
FilterGraphOp
:
:
SVGFECompositeIn
=
>
FilterGraphOpKey
:
:
SVGFECompositeIn
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
FilterGraphOpKey
:
:
SVGFECompositeLighter
FilterGraphOp
:
:
SVGFECompositeOut
=
>
FilterGraphOpKey
:
:
SVGFECompositeOut
FilterGraphOp
:
:
SVGFECompositeOver
=
>
FilterGraphOpKey
:
:
SVGFECompositeOver
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
FilterGraphOpKey
:
:
SVGFECompositeXOR
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
{
let
mut
values
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
=
[
Au
(
0
)
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
;
for
(
value
result
)
in
kernel
.
iter
(
)
.
zip
(
values
.
iter_mut
(
)
)
{
*
result
=
Au
:
:
from_f32_px
(
*
value
)
}
FilterGraphOpKey
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
order_y
kernel
:
values
divisor
:
Au
:
:
from_f32_px
(
divisor
)
bias
:
Au
:
:
from_f32_px
(
bias
)
target_x
target_y
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
preserve_alpha
}
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
{
let
mut
values
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
=
[
Au
(
0
)
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
;
for
(
value
result
)
in
kernel
.
iter
(
)
.
zip
(
values
.
iter_mut
(
)
)
{
*
result
=
Au
:
:
from_f32_px
(
*
value
)
}
FilterGraphOpKey
:
:
SVGFEConvolveMatrixEdgeModeNone
{
order_x
order_y
kernel
:
values
divisor
:
Au
:
:
from_f32_px
(
divisor
)
bias
:
Au
:
:
from_f32_px
(
bias
)
target_x
target_y
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
preserve_alpha
}
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
{
let
mut
values
:
[
Au
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
=
[
Au
(
0
)
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
;
for
(
value
result
)
in
kernel
.
iter
(
)
.
zip
(
values
.
iter_mut
(
)
)
{
*
result
=
Au
:
:
from_f32_px
(
*
value
)
}
FilterGraphOpKey
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
order_y
kernel
:
values
divisor
:
Au
:
:
from_f32_px
(
divisor
)
bias
:
Au
:
:
from_f32_px
(
bias
)
target_x
target_y
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
preserve_alpha
}
}
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
=
>
{
FilterGraphOpKey
:
:
SVGFEDiffuseLightingDistant
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
diffuse_constant
:
Au
:
:
from_f32_px
(
diffuse_constant
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
azimuth
:
Au
:
:
from_f32_px
(
azimuth
)
elevation
:
Au
:
:
from_f32_px
(
elevation
)
}
}
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
=
>
{
FilterGraphOpKey
:
:
SVGFEDiffuseLightingPoint
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
diffuse_constant
:
Au
:
:
from_f32_px
(
diffuse_constant
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
x
:
Au
:
:
from_f32_px
(
x
)
y
:
Au
:
:
from_f32_px
(
y
)
z
:
Au
:
:
from_f32_px
(
z
)
}
}
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
=
>
{
FilterGraphOpKey
:
:
SVGFEDiffuseLightingSpot
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
diffuse_constant
:
Au
:
:
from_f32_px
(
diffuse_constant
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
x
:
Au
:
:
from_f32_px
(
x
)
y
:
Au
:
:
from_f32_px
(
y
)
z
:
Au
:
:
from_f32_px
(
z
)
points_at_x
:
Au
:
:
from_f32_px
(
points_at_x
)
points_at_y
:
Au
:
:
from_f32_px
(
points_at_y
)
points_at_z
:
Au
:
:
from_f32_px
(
points_at_z
)
cone_exponent
:
Au
:
:
from_f32_px
(
cone_exponent
)
limiting_cone_angle
:
Au
:
:
from_f32_px
(
limiting_cone_angle
)
}
}
FilterGraphOp
:
:
SVGFEDisplacementMap
{
scale
x_channel_selector
y_channel_selector
}
=
>
{
FilterGraphOpKey
:
:
SVGFEDisplacementMap
{
scale
:
Au
:
:
from_f32_px
(
scale
)
x_channel_selector
y_channel_selector
}
}
FilterGraphOp
:
:
SVGFEDropShadow
{
color
dx
dy
std_deviation_x
std_deviation_y
}
=
>
{
FilterGraphOpKey
:
:
SVGFEDropShadow
{
color
:
color
.
into
(
)
dx
:
Au
:
:
from_f32_px
(
dx
)
dy
:
Au
:
:
from_f32_px
(
dy
)
std_deviation_x
:
Au
:
:
from_f32_px
(
std_deviation_x
)
std_deviation_y
:
Au
:
:
from_f32_px
(
std_deviation_y
)
}
}
FilterGraphOp
:
:
SVGFEFlood
{
color
}
=
>
FilterGraphOpKey
:
:
SVGFEFlood
{
color
:
color
.
into
(
)
}
FilterGraphOp
:
:
SVGFEGaussianBlur
{
std_deviation_x
std_deviation_y
}
=
>
{
FilterGraphOpKey
:
:
SVGFEGaussianBlur
{
std_deviation_x
:
Au
:
:
from_f32_px
(
std_deviation_x
)
std_deviation_y
:
Au
:
:
from_f32_px
(
std_deviation_y
)
}
}
FilterGraphOp
:
:
SVGFEIdentity
=
>
FilterGraphOpKey
:
:
SVGFEIdentity
FilterGraphOp
:
:
SVGFEImage
{
sampling_filter
matrix
}
=
>
{
let
mut
values
:
[
Au
;
6
]
=
[
Au
(
0
)
;
6
]
;
for
(
value
result
)
in
matrix
.
iter
(
)
.
zip
(
values
.
iter_mut
(
)
)
{
*
result
=
Au
:
:
from_f32_px
(
*
value
)
}
FilterGraphOpKey
:
:
SVGFEImage
{
sampling_filter
matrix
:
values
}
}
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
radius_x
radius_y
}
=
>
{
FilterGraphOpKey
:
:
SVGFEMorphologyDilate
{
radius_x
:
Au
:
:
from_f32_px
(
radius_x
)
radius_y
:
Au
:
:
from_f32_px
(
radius_y
)
}
}
FilterGraphOp
:
:
SVGFEMorphologyErode
{
radius_x
radius_y
}
=
>
{
FilterGraphOpKey
:
:
SVGFEMorphologyErode
{
radius_x
:
Au
:
:
from_f32_px
(
radius_x
)
radius_y
:
Au
:
:
from_f32_px
(
radius_y
)
}
}
FilterGraphOp
:
:
SVGFEOpacity
{
valuebinding
:
binding
value
:
_
}
=
>
{
match
binding
{
PropertyBinding
:
:
Value
(
value
)
=
>
{
FilterGraphOpKey
:
:
SVGFEOpacity
{
value
:
Au
:
:
from_f32_px
(
value
)
}
}
PropertyBinding
:
:
Binding
(
key
default
)
=
>
{
FilterGraphOpKey
:
:
SVGFEOpacityBinding
{
valuebindingid
:
key
.
id
value
:
Au
:
:
from_f32_px
(
default
)
}
}
}
}
FilterGraphOp
:
:
SVGFESourceAlpha
=
>
FilterGraphOpKey
:
:
SVGFESourceAlpha
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
FilterGraphOpKey
:
:
SVGFESourceGraphic
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
=
>
{
FilterGraphOpKey
:
:
SVGFESpecularLightingDistant
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
specular_constant
:
Au
:
:
from_f32_px
(
specular_constant
)
specular_exponent
:
Au
:
:
from_f32_px
(
specular_exponent
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
azimuth
:
Au
:
:
from_f32_px
(
azimuth
)
elevation
:
Au
:
:
from_f32_px
(
elevation
)
}
}
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
=
>
{
FilterGraphOpKey
:
:
SVGFESpecularLightingPoint
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
specular_constant
:
Au
:
:
from_f32_px
(
specular_constant
)
specular_exponent
:
Au
:
:
from_f32_px
(
specular_exponent
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
x
:
Au
:
:
from_f32_px
(
x
)
y
:
Au
:
:
from_f32_px
(
y
)
z
:
Au
:
:
from_f32_px
(
z
)
}
}
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
=
>
{
FilterGraphOpKey
:
:
SVGFESpecularLightingSpot
{
surface_scale
:
Au
:
:
from_f32_px
(
surface_scale
)
specular_constant
:
Au
:
:
from_f32_px
(
specular_constant
)
specular_exponent
:
Au
:
:
from_f32_px
(
specular_exponent
)
kernel_unit_length_x
:
Au
:
:
from_f32_px
(
kernel_unit_length_x
)
kernel_unit_length_y
:
Au
:
:
from_f32_px
(
kernel_unit_length_y
)
x
:
Au
:
:
from_f32_px
(
x
)
y
:
Au
:
:
from_f32_px
(
y
)
z
:
Au
:
:
from_f32_px
(
z
)
points_at_x
:
Au
:
:
from_f32_px
(
points_at_x
)
points_at_y
:
Au
:
:
from_f32_px
(
points_at_y
)
points_at_z
:
Au
:
:
from_f32_px
(
points_at_z
)
cone_exponent
:
Au
:
:
from_f32_px
(
cone_exponent
)
limiting_cone_angle
:
Au
:
:
from_f32_px
(
limiting_cone_angle
)
}
}
FilterGraphOp
:
:
SVGFETile
=
>
FilterGraphOpKey
:
:
SVGFETile
FilterGraphOp
:
:
SVGFEToAlpha
=
>
FilterGraphOpKey
:
:
SVGFEToAlpha
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
{
FilterGraphOpKey
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
:
Au
:
:
from_f32_px
(
base_frequency_x
)
base_frequency_y
:
Au
:
:
from_f32_px
(
base_frequency_y
)
num_octaves
seed
}
}
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
{
FilterGraphOpKey
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
:
Au
:
:
from_f32_px
(
base_frequency_x
)
base_frequency_y
:
Au
:
:
from_f32_px
(
base_frequency_y
)
num_octaves
seed
}
}
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
{
FilterGraphOpKey
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
:
Au
:
:
from_f32_px
(
base_frequency_x
)
base_frequency_y
:
Au
:
:
from_f32_px
(
base_frequency_y
)
num_octaves
seed
}
}
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
{
FilterGraphOpKey
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
:
Au
:
:
from_f32_px
(
base_frequency_x
)
base_frequency_y
:
Au
:
:
from_f32_px
(
base_frequency_y
)
num_octaves
seed
}
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
MallocSizeOf
PartialEq
Hash
Eq
)
]
pub
struct
FilterGraphNodeKey
{
pub
kept_by_optimizer
:
bool
pub
linear
:
bool
pub
inputs
:
Vec
<
FilterGraphPictureReferenceKey
>
pub
subregion
:
[
Au
;
4
]
}
impl
From
<
FilterGraphNode
>
for
FilterGraphNodeKey
{
fn
from
(
node
:
FilterGraphNode
)
-
>
Self
{
FilterGraphNodeKey
{
kept_by_optimizer
:
node
.
kept_by_optimizer
linear
:
node
.
linear
inputs
:
node
.
inputs
.
into_iter
(
)
.
map
(
|
node
|
{
node
.
into
(
)
}
)
.
collect
(
)
subregion
:
[
Au
:
:
from_f32_px
(
node
.
subregion
.
min
.
x
)
Au
:
:
from_f32_px
(
node
.
subregion
.
min
.
y
)
Au
:
:
from_f32_px
(
node
.
subregion
.
max
.
x
)
Au
:
:
from_f32_px
(
node
.
subregion
.
max
.
y
)
]
}
}
}
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphPictureReference
{
pub
buffer_id
:
FilterOpGraphPictureBufferId
pub
subregion
:
LayoutRect
pub
offset
:
LayoutVector2D
pub
inflate
:
i16
pub
source_padding
:
LayoutRect
pub
target_padding
:
LayoutRect
}
impl
From
<
FilterOpGraphPictureReference
>
for
FilterGraphPictureReference
{
fn
from
(
pic
:
FilterOpGraphPictureReference
)
-
>
Self
{
FilterGraphPictureReference
{
buffer_id
:
pic
.
buffer_id
subregion
:
LayoutRect
:
:
zero
(
)
offset
:
LayoutVector2D
:
:
zero
(
)
inflate
:
0
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
}
}
pub
const
SVGFE_CONVOLVE_DIAMETER_LIMIT
:
usize
=
5
;
pub
const
SVGFE_CONVOLVE_VALUES_LIMIT
:
usize
=
SVGFE_CONVOLVE_DIAMETER_LIMIT
*
SVGFE_CONVOLVE_DIAMETER_LIMIT
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
FilterGraphOp
{
SVGFESourceGraphic
SVGFESourceAlpha
SVGFEIdentity
SVGFEOpacity
{
valuebinding
:
api
:
:
PropertyBinding
<
f32
>
value
:
f32
}
SVGFEToAlpha
SVGFEBlendDarken
SVGFEBlendLighten
SVGFEBlendMultiply
SVGFEBlendNormal
SVGFEBlendScreen
SVGFEBlendOverlay
SVGFEBlendColorDodge
SVGFEBlendColorBurn
SVGFEBlendHardLight
SVGFEBlendSoftLight
SVGFEBlendDifference
SVGFEBlendExclusion
SVGFEBlendHue
SVGFEBlendSaturation
SVGFEBlendColor
SVGFEBlendLuminosity
SVGFEColorMatrix
{
values
:
[
f32
;
20
]
}
SVGFEComponentTransfer
SVGFEComponentTransferInterned
{
handle
:
FilterDataHandle
creates_pixels
:
bool
}
SVGFECompositeArithmetic
{
k1
:
f32
k2
:
f32
k3
:
f32
k4
:
f32
}
SVGFECompositeATop
SVGFECompositeIn
SVGFECompositeLighter
SVGFECompositeOut
SVGFECompositeOver
SVGFECompositeXOR
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeNone
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEDiffuseLightingDistant
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFEDiffuseLightingPoint
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFEDiffuseLightingSpot
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFEDisplacementMap
{
scale
:
f32
x_channel_selector
:
u32
y_channel_selector
:
u32
}
SVGFEDropShadow
{
color
:
ColorF
dx
:
f32
dy
:
f32
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEFlood
{
color
:
ColorF
}
SVGFEGaussianBlur
{
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEImage
{
sampling_filter
:
u32
matrix
:
[
f32
;
6
]
}
SVGFEMorphologyDilate
{
radius_x
:
f32
radius_y
:
f32
}
SVGFEMorphologyErode
{
radius_x
:
f32
radius_y
:
f32
}
SVGFESpecularLightingDistant
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFESpecularLightingPoint
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFESpecularLightingSpot
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFETile
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
}
impl
FilterGraphOp
{
pub
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FilterGraphOp
:
:
SVGFEBlendColor
=
>
"
SVGFEBlendColor
"
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
"
SVGFEBlendColorBurn
"
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
"
SVGFEBlendColorDodge
"
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
"
SVGFEBlendDarken
"
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
"
SVGFEBlendDifference
"
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
"
SVGFEBlendExclusion
"
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
"
SVGFEBlendHardLight
"
FilterGraphOp
:
:
SVGFEBlendHue
=
>
"
SVGFEBlendHue
"
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
"
SVGFEBlendLighten
"
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
"
SVGFEBlendLuminosity
"
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
"
SVGFEBlendMultiply
"
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
"
SVGFEBlendNormal
"
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
"
SVGFEBlendOverlay
"
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
"
SVGFEBlendSaturation
"
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
"
SVGFEBlendScreen
"
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
"
SVGFEBlendSoftLight
"
FilterGraphOp
:
:
SVGFEColorMatrix
{
.
.
}
=
>
"
SVGFEColorMatrix
"
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
"
SVGFEComponentTransfer
"
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
.
.
}
=
>
"
SVGFEComponentTransferInterned
"
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
.
.
}
=
>
"
SVGFECompositeArithmetic
"
FilterGraphOp
:
:
SVGFECompositeATop
=
>
"
SVGFECompositeATop
"
FilterGraphOp
:
:
SVGFECompositeIn
=
>
"
SVGFECompositeIn
"
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
"
SVGFECompositeLighter
"
FilterGraphOp
:
:
SVGFECompositeOut
=
>
"
SVGFECompositeOut
"
FilterGraphOp
:
:
SVGFECompositeOver
=
>
"
SVGFECompositeOver
"
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
"
SVGFECompositeXOR
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeDuplicate
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeNone
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeWrap
"
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
.
.
}
=
>
"
SVGFEDiffuseLightingDistant
"
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
.
.
}
=
>
"
SVGFEDiffuseLightingPoint
"
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
.
.
}
=
>
"
SVGFEDiffuseLightingSpot
"
FilterGraphOp
:
:
SVGFEDisplacementMap
{
.
.
}
=
>
"
SVGFEDisplacementMap
"
FilterGraphOp
:
:
SVGFEDropShadow
{
.
.
}
=
>
"
SVGFEDropShadow
"
FilterGraphOp
:
:
SVGFEFlood
{
.
.
}
=
>
"
SVGFEFlood
"
FilterGraphOp
:
:
SVGFEGaussianBlur
{
.
.
}
=
>
"
SVGFEGaussianBlur
"
FilterGraphOp
:
:
SVGFEIdentity
=
>
"
SVGFEIdentity
"
FilterGraphOp
:
:
SVGFEImage
{
.
.
}
=
>
"
SVGFEImage
"
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
.
.
}
=
>
"
SVGFEMorphologyDilate
"
FilterGraphOp
:
:
SVGFEMorphologyErode
{
.
.
}
=
>
"
SVGFEMorphologyErode
"
FilterGraphOp
:
:
SVGFEOpacity
{
.
.
}
=
>
"
SVGFEOpacity
"
FilterGraphOp
:
:
SVGFESourceAlpha
=
>
"
SVGFESourceAlpha
"
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
"
SVGFESourceGraphic
"
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
.
.
}
=
>
"
SVGFESpecularLightingDistant
"
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
.
.
}
=
>
"
SVGFESpecularLightingPoint
"
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
.
.
}
=
>
"
SVGFESpecularLightingSpot
"
FilterGraphOp
:
:
SVGFETile
=
>
"
SVGFETile
"
FilterGraphOp
:
:
SVGFEToAlpha
=
>
"
SVGFEToAlpha
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithStitching
"
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphNode
{
pub
kept_by_optimizer
:
bool
pub
linear
:
bool
pub
inflate
:
i16
pub
inputs
:
Vec
<
FilterGraphPictureReference
>
pub
subregion
:
LayoutRect
}
impl
From
<
FilterOpGraphNode
>
for
FilterGraphNode
{
fn
from
(
node
:
FilterOpGraphNode
)
-
>
Self
{
let
mut
inputs
:
Vec
<
FilterGraphPictureReference
>
=
Vec
:
:
new
(
)
;
if
node
.
input
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input
.
into
(
)
)
;
}
if
node
.
input2
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input2
.
into
(
)
)
;
}
FilterGraphNode
{
linear
:
node
.
linear
inputs
subregion
:
node
.
subregion
kept_by_optimizer
:
true
inflate
:
0
}
}
}
pub
fn
get_coverage_target_svgfe
(
filters
:
&
[
(
FilterGraphNode
FilterGraphOp
)
]
surface_rect
:
LayoutRect
)
-
>
LayoutRect
{
const
BUFFER_LIMIT
:
usize
=
SVGFE_GRAPH_MAX
;
let
mut
subregion_by_buffer_id
:
[
LayoutRect
;
BUFFER_LIMIT
]
=
[
LayoutRect
:
:
zero
(
)
;
BUFFER_LIMIT
]
;
for
(
id
(
node
op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
{
let
full_subregion
=
node
.
subregion
;
let
mut
used_subregion
=
LayoutRect
:
:
zero
(
)
;
for
input
in
&
node
.
inputs
{
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
{
assert
!
(
(
id
as
usize
)
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
let
input_subregion
=
subregion_by_buffer_id
[
id
as
usize
]
;
let
input_subregion
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
input_subregion
.
min
.
x
+
input
.
target_padding
.
min
.
x
input_subregion
.
min
.
y
+
input
.
target_padding
.
min
.
y
)
LayoutPoint
:
:
new
(
input_subregion
.
max
.
x
+
input
.
target_padding
.
max
.
x
input_subregion
.
max
.
y
+
input
.
target_padding
.
max
.
y
)
)
;
used_subregion
=
used_subregion
.
union
(
&
input_subregion
)
;
}
FilterOpGraphPictureBufferId
:
:
None
=
>
{
panic
!
(
"
Unsupported
BufferId
type
"
)
;
}
}
}
used_subregion
=
used_subregion
.
intersection
(
&
full_subregion
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
match
op
{
FilterGraphOp
:
:
SVGFEBlendColor
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendHue
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
{
}
FilterGraphOp
:
:
SVGFEColorMatrix
{
values
}
=
>
{
if
values
[
19
]
>
0
.
0
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFEColorMatrix
"
"
SVGFEColorMatrix
with
non
-
zero
alpha
offset
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
unreachable
!
(
)
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
handle
:
_
creates_pixels
}
=
>
{
if
*
creates_pixels
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFEComponentTransfer
"
"
SVGFEComponentTransfer
with
non
-
zero
minimum
alpha
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
k1
k2
k3
k4
}
=
>
{
if
*
k1
<
=
0
.
0
&
&
*
k2
<
=
0
.
0
&
&
*
k3
<
=
0
.
0
{
used_subregion
=
LayoutRect
:
:
zero
(
)
;
}
if
*
k4
>
0
.
0
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFECompositeArithmetic
"
"
SVGFECompositeArithmetic
with
non
-
zero
offset
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFECompositeATop
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeIn
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeOut
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeOver
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDisplacementMap
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDropShadow
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEFlood
{
color
}
=
>
{
if
color
.
a
>
0
.
0
{
used_subregion
=
full_subregion
;
}
}
FilterGraphOp
:
:
SVGFEGaussianBlur
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEIdentity
=
>
{
}
FilterGraphOp
:
:
SVGFEImage
{
sampling_filter
:
_sampling_filter
matrix
:
_matrix
}
=
>
{
used_subregion
=
full_subregion
;
}
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEMorphologyErode
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEOpacity
{
valuebinding
:
_valuebinding
value
}
=
>
{
if
*
value
<
=
0
.
0
{
used_subregion
=
LayoutRect
:
:
zero
(
)
;
}
}
FilterGraphOp
:
:
SVGFESourceAlpha
|
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
{
used_subregion
=
surface_rect
;
}
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFETile
=
>
{
used_subregion
=
full_subregion
;
}
FilterGraphOp
:
:
SVGFEToAlpha
=
>
{
}
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
{
used_subregion
=
full_subregion
;
}
}
assert
!
(
(
id
as
usize
)
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
subregion_by_buffer_id
[
id
]
=
used_subregion
;
}
subregion_by_buffer_id
[
filters
.
len
(
)
-
1
]
}
pub
fn
get_coverage_source_svgfe
(
filters
:
&
[
(
FilterGraphNode
FilterGraphOp
)
]
surface_rect
:
LayoutRect
)
-
>
LayoutRect
{
const
BUFFER_LIMIT
:
usize
=
SVGFE_GRAPH_MAX
;
let
mut
source_subregion
=
LayoutRect
:
:
zero
(
)
;
let
mut
subregion_by_buffer_id
:
[
LayoutRect
;
BUFFER_LIMIT
]
=
[
LayoutRect
:
:
zero
(
)
;
BUFFER_LIMIT
]
;
let
final_buffer_id
=
filters
.
len
(
)
-
1
;
assert
!
(
final_buffer_id
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
subregion_by_buffer_id
[
final_buffer_id
]
=
surface_rect
;
for
(
node_buffer_id
(
node
op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
assert
!
(
node_buffer_id
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
let
full_subregion
=
node
.
subregion
;
let
mut
used_subregion
=
subregion_by_buffer_id
[
node_buffer_id
]
;
used_subregion
=
used_subregion
.
intersection
(
&
full_subregion
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
if
!
used_subregion
.
is_empty
(
)
{
for
input
in
&
node
.
inputs
{
let
input_subregion
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
used_subregion
.
min
.
x
+
input
.
source_padding
.
min
.
x
used_subregion
.
min
.
y
+
input
.
source_padding
.
min
.
y
)
LayoutPoint
:
:
new
(
used_subregion
.
max
.
x
+
input
.
source_padding
.
max
.
x
used_subregion
.
max
.
y
+
input
.
source_padding
.
max
.
y
)
)
;
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
{
subregion_by_buffer_id
[
id
as
usize
]
=
subregion_by_buffer_id
[
id
as
usize
]
.
union
(
&
input_subregion
)
;
}
FilterOpGraphPictureBufferId
:
:
None
=
>
{
}
}
}
}
match
op
{
FilterGraphOp
:
:
SVGFESourceAlpha
|
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
{
source_subregion
=
source_subregion
.
union
(
&
used_subregion
)
;
}
_
=
>
{
}
}
}
source_subregion
}
