use
api
:
:
{
FilterOpGraphPictureReference
FilterOpGraphNode
ColorF
}
;
use
api
:
:
SVGFE_GRAPH_MAX
;
use
api
:
:
units
:
:
*
;
use
api
:
:
FilterOpGraphPictureBufferId
;
use
crate
:
:
profiler
:
:
add_text_marker
;
use
crate
:
:
filterdata
:
:
FilterDataHandle
;
use
core
:
:
time
:
:
Duration
;
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphPictureReference
{
pub
buffer_id
:
FilterOpGraphPictureBufferId
pub
subregion
:
LayoutRect
pub
offset
:
LayoutVector2D
pub
inflate
:
i16
pub
source_padding
:
LayoutRect
pub
target_padding
:
LayoutRect
}
impl
From
<
FilterOpGraphPictureReference
>
for
FilterGraphPictureReference
{
fn
from
(
pic
:
FilterOpGraphPictureReference
)
-
>
Self
{
FilterGraphPictureReference
{
buffer_id
:
pic
.
buffer_id
subregion
:
LayoutRect
:
:
zero
(
)
offset
:
LayoutVector2D
:
:
zero
(
)
inflate
:
0
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
}
}
pub
const
SVGFE_CONVOLVE_DIAMETER_LIMIT
:
usize
=
5
;
pub
const
SVGFE_CONVOLVE_VALUES_LIMIT
:
usize
=
SVGFE_CONVOLVE_DIAMETER_LIMIT
*
SVGFE_CONVOLVE_DIAMETER_LIMIT
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
FilterGraphOp
{
SVGFESourceGraphic
SVGFESourceAlpha
SVGFEIdentity
SVGFEOpacity
{
valuebinding
:
api
:
:
PropertyBinding
<
f32
>
value
:
f32
}
SVGFEToAlpha
SVGFEBlendDarken
SVGFEBlendLighten
SVGFEBlendMultiply
SVGFEBlendNormal
SVGFEBlendScreen
SVGFEBlendOverlay
SVGFEBlendColorDodge
SVGFEBlendColorBurn
SVGFEBlendHardLight
SVGFEBlendSoftLight
SVGFEBlendDifference
SVGFEBlendExclusion
SVGFEBlendHue
SVGFEBlendSaturation
SVGFEBlendColor
SVGFEBlendLuminosity
SVGFEColorMatrix
{
values
:
[
f32
;
20
]
}
SVGFEComponentTransfer
SVGFEComponentTransferInterned
{
handle
:
FilterDataHandle
creates_pixels
:
bool
}
SVGFECompositeArithmetic
{
k1
:
f32
k2
:
f32
k3
:
f32
k4
:
f32
}
SVGFECompositeATop
SVGFECompositeIn
SVGFECompositeLighter
SVGFECompositeOut
SVGFECompositeOver
SVGFECompositeXOR
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeNone
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEDiffuseLightingDistant
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFEDiffuseLightingPoint
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFEDiffuseLightingSpot
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFEDisplacementMap
{
scale
:
f32
x_channel_selector
:
u32
y_channel_selector
:
u32
}
SVGFEDropShadow
{
color
:
ColorF
dx
:
f32
dy
:
f32
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEFlood
{
color
:
ColorF
}
SVGFEGaussianBlur
{
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEImage
{
sampling_filter
:
u32
matrix
:
[
f32
;
6
]
}
SVGFEMorphologyDilate
{
radius_x
:
f32
radius_y
:
f32
}
SVGFEMorphologyErode
{
radius_x
:
f32
radius_y
:
f32
}
SVGFESpecularLightingDistant
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFESpecularLightingPoint
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFESpecularLightingSpot
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFETile
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
}
impl
FilterGraphOp
{
pub
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FilterGraphOp
:
:
SVGFEBlendColor
=
>
"
SVGFEBlendColor
"
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
"
SVGFEBlendColorBurn
"
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
"
SVGFEBlendColorDodge
"
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
"
SVGFEBlendDarken
"
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
"
SVGFEBlendDifference
"
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
"
SVGFEBlendExclusion
"
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
"
SVGFEBlendHardLight
"
FilterGraphOp
:
:
SVGFEBlendHue
=
>
"
SVGFEBlendHue
"
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
"
SVGFEBlendLighten
"
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
"
SVGFEBlendLuminosity
"
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
"
SVGFEBlendMultiply
"
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
"
SVGFEBlendNormal
"
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
"
SVGFEBlendOverlay
"
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
"
SVGFEBlendSaturation
"
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
"
SVGFEBlendScreen
"
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
"
SVGFEBlendSoftLight
"
FilterGraphOp
:
:
SVGFEColorMatrix
{
.
.
}
=
>
"
SVGFEColorMatrix
"
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
"
SVGFEComponentTransfer
"
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
.
.
}
=
>
"
SVGFEComponentTransferInterned
"
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
.
.
}
=
>
"
SVGFECompositeArithmetic
"
FilterGraphOp
:
:
SVGFECompositeATop
=
>
"
SVGFECompositeATop
"
FilterGraphOp
:
:
SVGFECompositeIn
=
>
"
SVGFECompositeIn
"
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
"
SVGFECompositeLighter
"
FilterGraphOp
:
:
SVGFECompositeOut
=
>
"
SVGFECompositeOut
"
FilterGraphOp
:
:
SVGFECompositeOver
=
>
"
SVGFECompositeOver
"
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
"
SVGFECompositeXOR
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeDuplicate
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeNone
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeWrap
"
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
.
.
}
=
>
"
SVGFEDiffuseLightingDistant
"
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
.
.
}
=
>
"
SVGFEDiffuseLightingPoint
"
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
.
.
}
=
>
"
SVGFEDiffuseLightingSpot
"
FilterGraphOp
:
:
SVGFEDisplacementMap
{
.
.
}
=
>
"
SVGFEDisplacementMap
"
FilterGraphOp
:
:
SVGFEDropShadow
{
.
.
}
=
>
"
SVGFEDropShadow
"
FilterGraphOp
:
:
SVGFEFlood
{
.
.
}
=
>
"
SVGFEFlood
"
FilterGraphOp
:
:
SVGFEGaussianBlur
{
.
.
}
=
>
"
SVGFEGaussianBlur
"
FilterGraphOp
:
:
SVGFEIdentity
=
>
"
SVGFEIdentity
"
FilterGraphOp
:
:
SVGFEImage
{
.
.
}
=
>
"
SVGFEImage
"
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
.
.
}
=
>
"
SVGFEMorphologyDilate
"
FilterGraphOp
:
:
SVGFEMorphologyErode
{
.
.
}
=
>
"
SVGFEMorphologyErode
"
FilterGraphOp
:
:
SVGFEOpacity
{
.
.
}
=
>
"
SVGFEOpacity
"
FilterGraphOp
:
:
SVGFESourceAlpha
=
>
"
SVGFESourceAlpha
"
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
"
SVGFESourceGraphic
"
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
.
.
}
=
>
"
SVGFESpecularLightingDistant
"
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
.
.
}
=
>
"
SVGFESpecularLightingPoint
"
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
.
.
}
=
>
"
SVGFESpecularLightingSpot
"
FilterGraphOp
:
:
SVGFETile
=
>
"
SVGFETile
"
FilterGraphOp
:
:
SVGFEToAlpha
=
>
"
SVGFEToAlpha
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithStitching
"
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphNode
{
pub
kept_by_optimizer
:
bool
pub
linear
:
bool
pub
inflate
:
i16
pub
inputs
:
Vec
<
FilterGraphPictureReference
>
pub
subregion
:
LayoutRect
}
impl
From
<
FilterOpGraphNode
>
for
FilterGraphNode
{
fn
from
(
node
:
FilterOpGraphNode
)
-
>
Self
{
let
mut
inputs
:
Vec
<
FilterGraphPictureReference
>
=
Vec
:
:
new
(
)
;
if
node
.
input
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input
.
into
(
)
)
;
}
if
node
.
input2
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input2
.
into
(
)
)
;
}
FilterGraphNode
{
linear
:
node
.
linear
inputs
subregion
:
node
.
subregion
kept_by_optimizer
:
true
inflate
:
0
}
}
}
pub
fn
get_coverage_target_svgfe
(
filters
:
&
[
(
FilterGraphNode
FilterGraphOp
)
]
surface_rect
:
LayoutRect
)
-
>
LayoutRect
{
const
BUFFER_LIMIT
:
usize
=
SVGFE_GRAPH_MAX
;
let
mut
subregion_by_buffer_id
:
[
LayoutRect
;
BUFFER_LIMIT
]
=
[
LayoutRect
:
:
zero
(
)
;
BUFFER_LIMIT
]
;
for
(
id
(
node
op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
{
let
full_subregion
=
node
.
subregion
;
let
mut
used_subregion
=
LayoutRect
:
:
zero
(
)
;
for
input
in
&
node
.
inputs
{
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
{
assert
!
(
(
id
as
usize
)
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
let
input_subregion
=
subregion_by_buffer_id
[
id
as
usize
]
;
let
input_subregion
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
input_subregion
.
min
.
x
+
input
.
target_padding
.
min
.
x
input_subregion
.
min
.
y
+
input
.
target_padding
.
min
.
y
)
LayoutPoint
:
:
new
(
input_subregion
.
max
.
x
+
input
.
target_padding
.
max
.
x
input_subregion
.
max
.
y
+
input
.
target_padding
.
max
.
y
)
)
;
used_subregion
=
used_subregion
.
union
(
&
input_subregion
)
;
}
FilterOpGraphPictureBufferId
:
:
None
=
>
{
panic
!
(
"
Unsupported
BufferId
type
"
)
;
}
}
}
used_subregion
=
used_subregion
.
intersection
(
&
full_subregion
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
match
op
{
FilterGraphOp
:
:
SVGFEBlendColor
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendHue
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
{
}
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
{
}
FilterGraphOp
:
:
SVGFEColorMatrix
{
values
}
=
>
{
if
values
[
19
]
>
0
.
0
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFEColorMatrix
"
"
SVGFEColorMatrix
with
non
-
zero
alpha
offset
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
unreachable
!
(
)
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
handle
:
_
creates_pixels
}
=
>
{
if
*
creates_pixels
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFEComponentTransfer
"
"
SVGFEComponentTransfer
with
non
-
zero
minimum
alpha
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
k1
k2
k3
k4
}
=
>
{
if
*
k1
<
=
0
.
0
&
&
*
k2
<
=
0
.
0
&
&
*
k3
<
=
0
.
0
{
used_subregion
=
LayoutRect
:
:
zero
(
)
;
}
if
*
k4
>
0
.
0
{
used_subregion
=
full_subregion
;
add_text_marker
(
"
SVGFECompositeArithmetic
"
"
SVGFECompositeArithmetic
with
non
-
zero
offset
using
full
subregion
"
Duration
:
:
from_millis
(
1
)
)
;
}
}
FilterGraphOp
:
:
SVGFECompositeATop
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeIn
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeOut
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeOver
=
>
{
}
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDisplacementMap
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEDropShadow
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEFlood
{
color
}
=
>
{
if
color
.
a
>
0
.
0
{
used_subregion
=
full_subregion
;
}
}
FilterGraphOp
:
:
SVGFEGaussianBlur
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEIdentity
=
>
{
}
FilterGraphOp
:
:
SVGFEImage
{
sampling_filter
:
_sampling_filter
matrix
:
_matrix
}
=
>
{
used_subregion
=
full_subregion
;
}
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEMorphologyErode
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFEOpacity
{
valuebinding
:
_valuebinding
value
}
=
>
{
if
*
value
<
=
0
.
0
{
used_subregion
=
LayoutRect
:
:
zero
(
)
;
}
}
FilterGraphOp
:
:
SVGFESourceAlpha
|
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
{
used_subregion
=
surface_rect
;
}
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
.
.
}
=
>
{
}
FilterGraphOp
:
:
SVGFETile
=
>
{
used_subregion
=
full_subregion
;
}
FilterGraphOp
:
:
SVGFEToAlpha
=
>
{
}
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
{
used_subregion
=
full_subregion
;
}
}
assert
!
(
(
id
as
usize
)
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
subregion_by_buffer_id
[
id
]
=
used_subregion
;
}
subregion_by_buffer_id
[
filters
.
len
(
)
-
1
]
}
pub
fn
get_coverage_source_svgfe
(
filters
:
&
[
(
FilterGraphNode
FilterGraphOp
)
]
surface_rect
:
LayoutRect
)
-
>
LayoutRect
{
const
BUFFER_LIMIT
:
usize
=
SVGFE_GRAPH_MAX
;
let
mut
source_subregion
=
LayoutRect
:
:
zero
(
)
;
let
mut
subregion_by_buffer_id
:
[
LayoutRect
;
BUFFER_LIMIT
]
=
[
LayoutRect
:
:
zero
(
)
;
BUFFER_LIMIT
]
;
let
final_buffer_id
=
filters
.
len
(
)
-
1
;
assert
!
(
final_buffer_id
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
subregion_by_buffer_id
[
final_buffer_id
]
=
surface_rect
;
for
(
node_buffer_id
(
node
op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
.
rev
(
)
{
assert
!
(
node_buffer_id
<
BUFFER_LIMIT
"
BUFFER_LIMIT
must
be
the
same
in
frame
building
and
scene
building
"
)
;
let
full_subregion
=
node
.
subregion
;
let
mut
used_subregion
=
subregion_by_buffer_id
[
node_buffer_id
]
;
used_subregion
=
used_subregion
.
intersection
(
&
full_subregion
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
if
!
used_subregion
.
is_empty
(
)
{
for
input
in
&
node
.
inputs
{
let
input_subregion
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
used_subregion
.
min
.
x
+
input
.
source_padding
.
min
.
x
used_subregion
.
min
.
y
+
input
.
source_padding
.
min
.
y
)
LayoutPoint
:
:
new
(
used_subregion
.
max
.
x
+
input
.
source_padding
.
max
.
x
used_subregion
.
max
.
y
+
input
.
source_padding
.
max
.
y
)
)
;
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
{
subregion_by_buffer_id
[
id
as
usize
]
=
subregion_by_buffer_id
[
id
as
usize
]
.
union
(
&
input_subregion
)
;
}
FilterOpGraphPictureBufferId
:
:
None
=
>
{
}
}
}
}
match
op
{
FilterGraphOp
:
:
SVGFESourceAlpha
|
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
{
source_subregion
=
source_subregion
.
union
(
&
used_subregion
)
;
}
_
=
>
{
}
}
}
source_subregion
}
