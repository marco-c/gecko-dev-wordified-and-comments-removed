use
api
:
:
{
ExternalScrollId
PipelineId
PropertyBinding
PropertyBindingId
ReferenceFrameKind
}
;
use
api
:
:
{
APZScrollGeneration
HasScrollLinkedEffect
SampledScrollOffset
}
;
use
api
:
:
{
TransformStyle
StickyOffsetBounds
SpatialTreeItemKey
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
internal_types
:
:
PipelineInstanceId
;
use
crate
:
:
spatial_tree
:
:
{
CoordinateSystem
SpatialNodeIndex
TransformUpdateState
}
;
use
crate
:
:
spatial_tree
:
:
CoordinateSystemId
;
use
euclid
:
:
{
Vector2D
SideOffsets2D
}
;
use
crate
:
:
scene
:
:
SceneProperties
;
use
crate
:
:
util
:
:
{
LayoutFastTransform
MatrixHelpers
ScaleOffset
TransformedRectKind
}
;
use
crate
:
:
util
:
:
{
PointHelpers
VectorHelpers
}
;
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
SpatialNodeUidKind
{
Root
InternalScrollFrame
InternalReferenceFrame
External
{
key
:
SpatialTreeItemKey
}
}
#
[
derive
(
Copy
Clone
Eq
PartialEq
Hash
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SpatialNodeUid
{
pub
kind
:
SpatialNodeUidKind
pub
pipeline_id
:
PipelineId
pub
instance_id
:
PipelineInstanceId
}
impl
SpatialNodeUid
{
pub
fn
root
(
)
-
>
Self
{
SpatialNodeUid
{
kind
:
SpatialNodeUidKind
:
:
Root
pipeline_id
:
PipelineId
:
:
dummy
(
)
instance_id
:
PipelineInstanceId
:
:
new
(
0
)
}
}
pub
fn
root_scroll_frame
(
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
-
>
Self
{
SpatialNodeUid
{
kind
:
SpatialNodeUidKind
:
:
InternalScrollFrame
pipeline_id
instance_id
}
}
pub
fn
root_reference_frame
(
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
-
>
Self
{
SpatialNodeUid
{
kind
:
SpatialNodeUidKind
:
:
InternalReferenceFrame
pipeline_id
instance_id
}
}
pub
fn
external
(
key
:
SpatialTreeItemKey
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
-
>
Self
{
SpatialNodeUid
{
kind
:
SpatialNodeUidKind
:
:
External
{
key
}
pipeline_id
instance_id
}
}
}
#
[
derive
(
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SpatialNodeDescriptor
{
pub
node_type
:
SpatialNodeType
pub
pipeline_id
:
PipelineId
}
#
[
derive
(
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
SpatialNodeType
{
StickyFrame
(
StickyFrameInfo
)
ScrollFrame
(
ScrollFrameInfo
)
ReferenceFrame
(
ReferenceFrameInfo
)
}
pub
struct
SpatialNodeInfo
<
'
a
>
{
pub
node_type
:
&
'
a
SpatialNodeType
pub
parent
:
Option
<
SpatialNodeIndex
>
pub
snapping_transform
:
Option
<
ScaleOffset
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
PartialEq
)
]
pub
struct
SceneSpatialNode
{
pub
snapping_transform
:
Option
<
ScaleOffset
>
pub
parent
:
Option
<
SpatialNodeIndex
>
pub
descriptor
:
SpatialNodeDescriptor
pub
is_root_coord_system
:
bool
}
impl
SceneSpatialNode
{
pub
fn
new_reference_frame
(
parent_index
:
Option
<
SpatialNodeIndex
>
transform_style
:
TransformStyle
source_transform
:
PropertyBinding
<
LayoutTransform
>
kind
:
ReferenceFrameKind
origin_in_parent_reference_frame
:
LayoutVector2D
pipeline_id
:
PipelineId
is_root_coord_system
:
bool
is_pipeline_root
:
bool
)
-
>
Self
{
let
info
=
ReferenceFrameInfo
{
transform_style
source_transform
kind
origin_in_parent_reference_frame
is_pipeline_root
}
;
Self
:
:
new
(
pipeline_id
parent_index
SpatialNodeType
:
:
ReferenceFrame
(
info
)
is_root_coord_system
)
}
pub
fn
new_scroll_frame
(
pipeline_id
:
PipelineId
parent_index
:
SpatialNodeIndex
external_id
:
ExternalScrollId
frame_rect
:
&
LayoutRect
content_size
:
&
LayoutSize
frame_kind
:
ScrollFrameKind
external_scroll_offset
:
LayoutVector2D
offset_generation
:
APZScrollGeneration
has_scroll_linked_effect
:
HasScrollLinkedEffect
is_root_coord_system
:
bool
)
-
>
Self
{
let
node_type
=
SpatialNodeType
:
:
ScrollFrame
(
ScrollFrameInfo
:
:
new
(
*
frame_rect
LayoutSize
:
:
new
(
(
content_size
.
width
-
frame_rect
.
width
(
)
)
.
max
(
0
.
0
)
(
content_size
.
height
-
frame_rect
.
height
(
)
)
.
max
(
0
.
0
)
)
external_id
frame_kind
external_scroll_offset
offset_generation
has_scroll_linked_effect
)
)
;
Self
:
:
new
(
pipeline_id
Some
(
parent_index
)
node_type
is_root_coord_system
)
}
pub
fn
new_sticky_frame
(
parent_index
:
SpatialNodeIndex
sticky_frame_info
:
StickyFrameInfo
pipeline_id
:
PipelineId
is_root_coord_system
:
bool
)
-
>
Self
{
Self
:
:
new
(
pipeline_id
Some
(
parent_index
)
SpatialNodeType
:
:
StickyFrame
(
sticky_frame_info
)
is_root_coord_system
)
}
fn
new
(
pipeline_id
:
PipelineId
parent_index
:
Option
<
SpatialNodeIndex
>
node_type
:
SpatialNodeType
is_root_coord_system
:
bool
)
-
>
Self
{
SceneSpatialNode
{
parent
:
parent_index
descriptor
:
SpatialNodeDescriptor
{
pipeline_id
node_type
}
snapping_transform
:
None
is_root_coord_system
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SpatialNode
{
pub
viewport_transform
:
ScaleOffset
pub
content_transform
:
ScaleOffset
pub
snapping_transform
:
Option
<
ScaleOffset
>
pub
coordinate_system_id
:
CoordinateSystemId
pub
transform_kind
:
TransformedRectKind
pub
pipeline_id
:
PipelineId
pub
parent
:
Option
<
SpatialNodeIndex
>
pub
children
:
Vec
<
SpatialNodeIndex
>
pub
node_type
:
SpatialNodeType
pub
invertible
:
bool
pub
is_async_zooming
:
bool
pub
is_ancestor_or_self_zooming
:
bool
}
fn
snap_offset
<
OffsetUnits
ScaleUnits
>
(
offset
:
Vector2D
<
f32
OffsetUnits
>
scale
:
Vector2D
<
f32
ScaleUnits
>
)
-
>
Vector2D
<
f32
OffsetUnits
>
{
let
world_offset
=
WorldPoint
:
:
new
(
offset
.
x
*
scale
.
x
offset
.
y
*
scale
.
y
)
;
let
snapped_world_offset
=
world_offset
.
snap
(
)
;
Vector2D
:
:
new
(
if
scale
.
x
!
=
0
.
0
{
snapped_world_offset
.
x
/
scale
.
x
}
else
{
offset
.
x
}
if
scale
.
y
!
=
0
.
0
{
snapped_world_offset
.
y
/
scale
.
y
}
else
{
offset
.
y
}
)
}
impl
SpatialNode
{
pub
fn
add_child
(
&
mut
self
child
:
SpatialNodeIndex
)
{
self
.
children
.
push
(
child
)
;
}
pub
fn
set_scroll_offsets
(
&
mut
self
mut
offsets
:
Vec
<
SampledScrollOffset
>
)
-
>
bool
{
debug_assert
!
(
offsets
.
len
(
)
>
0
)
;
let
scrolling
=
match
self
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
ref
mut
scrolling
)
=
>
scrolling
_
=
>
{
warn
!
(
"
Tried
to
scroll
a
non
-
scroll
node
.
"
)
;
return
false
;
}
}
;
for
element
in
offsets
.
iter_mut
(
)
{
element
.
offset
=
-
element
.
offset
-
scrolling
.
external_scroll_offset
;
element
.
offset
=
element
.
offset
.
snap
(
)
;
}
if
scrolling
.
offsets
=
=
offsets
{
return
false
;
}
scrolling
.
offsets
=
offsets
;
true
}
pub
fn
mark_uninvertible
(
&
mut
self
state
:
&
TransformUpdateState
)
{
self
.
invertible
=
false
;
self
.
viewport_transform
=
ScaleOffset
:
:
identity
(
)
;
self
.
content_transform
=
ScaleOffset
:
:
identity
(
)
;
self
.
coordinate_system_id
=
state
.
current_coordinate_system_id
;
}
pub
fn
update
(
&
mut
self
state_stack
:
&
[
TransformUpdateState
]
coord_systems
:
&
mut
Vec
<
CoordinateSystem
>
scene_properties
:
&
SceneProperties
)
{
let
state
=
state_stack
.
last
(
)
.
unwrap
(
)
;
self
.
is_ancestor_or_self_zooming
=
self
.
is_async_zooming
|
state
.
is_ancestor_or_self_zooming
;
if
!
state
.
invertible
{
self
.
mark_uninvertible
(
state
)
;
return
;
}
self
.
update_transform
(
state_stack
coord_systems
scene_properties
)
;
if
!
self
.
invertible
{
self
.
mark_uninvertible
(
state
)
;
}
}
pub
fn
update_transform
(
&
mut
self
state_stack
:
&
[
TransformUpdateState
]
coord_systems
:
&
mut
Vec
<
CoordinateSystem
>
scene_properties
:
&
SceneProperties
)
{
let
state
=
state_stack
.
last
(
)
.
unwrap
(
)
;
self
.
invertible
=
true
;
match
self
.
node_type
{
SpatialNodeType
:
:
ReferenceFrame
(
ref
mut
info
)
=
>
{
let
mut
cs_scale_offset
=
ScaleOffset
:
:
identity
(
)
;
let
mut
coordinate_system_id
=
state
.
current_coordinate_system_id
;
let
source_transform
=
{
let
source_transform
=
scene_properties
.
resolve_layout_transform
(
&
info
.
source_transform
)
;
if
let
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
.
.
}
=
info
.
kind
{
assert
!
(
source_transform
.
is_2d_scale_translation
(
)
"
Reference
frame
was
marked
as
only
having
2d
scale
or
translation
"
)
;
}
LayoutFastTransform
:
:
from
(
source_transform
)
}
;
let
source_transform
=
match
info
.
kind
{
ReferenceFrameKind
:
:
Perspective
{
scrolling_relative_to
:
Some
(
external_id
)
}
=
>
{
let
mut
scroll_offset
=
LayoutVector2D
:
:
zero
(
)
;
for
parent_state
in
state_stack
.
iter
(
)
.
rev
(
)
{
if
let
Some
(
parent_external_id
)
=
parent_state
.
external_id
{
if
parent_external_id
=
=
external_id
{
break
;
}
}
scroll_offset
+
=
parent_state
.
scroll_offset
;
}
source_transform
.
pre_translate
(
scroll_offset
)
.
then_translate
(
-
scroll_offset
)
}
ReferenceFrameKind
:
:
Perspective
{
scrolling_relative_to
:
None
}
|
ReferenceFrameKind
:
:
Transform
{
.
.
}
=
>
source_transform
}
;
let
resolved_transform
=
LayoutFastTransform
:
:
with_vector
(
info
.
origin_in_parent_reference_frame
)
.
pre_transform
(
&
source_transform
)
;
let
relative_transform
=
resolved_transform
.
then_translate
(
snap_offset
(
state
.
parent_accumulated_scroll_offset
state
.
coordinate_system_relative_scale_offset
.
scale
)
)
.
to_transform
(
)
.
with_destination
:
:
<
LayoutPixel
>
(
)
;
let
mut
reset_cs_id
=
match
info
.
transform_style
{
TransformStyle
:
:
Preserve3D
=
>
!
state
.
preserves_3d
TransformStyle
:
:
Flat
=
>
state
.
preserves_3d
}
;
if
!
reset_cs_id
{
match
ScaleOffset
:
:
from_transform
(
&
relative_transform
)
{
Some
(
ref
scale_offset
)
=
>
{
let
mut
maybe_snapped
=
scale_offset
.
clone
(
)
;
if
let
ReferenceFrameKind
:
:
Transform
{
should_snap
:
true
.
.
}
=
info
.
kind
{
maybe_snapped
.
offset
=
snap_offset
(
scale_offset
.
offset
state
.
coordinate_system_relative_scale_offset
.
scale
)
;
}
cs_scale_offset
=
maybe_snapped
.
then
(
&
state
.
coordinate_system_relative_scale_offset
)
;
}
None
=
>
reset_cs_id
=
true
}
}
if
reset_cs_id
{
let
transform
=
relative_transform
.
then
(
&
state
.
coordinate_system_relative_scale_offset
.
to_transform
(
)
)
;
let
coord_system
=
{
let
parent_system
=
&
coord_systems
[
state
.
current_coordinate_system_id
.
0
as
usize
]
;
let
mut
cur_transform
=
transform
;
if
parent_system
.
should_flatten
{
cur_transform
.
flatten_z_output
(
)
;
}
let
world_transform
=
cur_transform
.
then
(
&
parent_system
.
world_transform
)
;
let
determinant
=
world_transform
.
determinant
(
)
;
self
.
invertible
=
determinant
!
=
0
.
0
&
&
!
determinant
.
is_nan
(
)
;
CoordinateSystem
{
transform
world_transform
should_flatten
:
match
(
info
.
transform_style
info
.
kind
)
{
(
TransformStyle
:
:
Flat
ReferenceFrameKind
:
:
Transform
{
.
.
}
)
=
>
true
(
_
_
)
=
>
false
}
parent
:
Some
(
state
.
current_coordinate_system_id
)
}
}
;
coordinate_system_id
=
CoordinateSystemId
(
coord_systems
.
len
(
)
as
u32
)
;
coord_systems
.
push
(
coord_system
)
;
}
self
.
coordinate_system_id
=
coordinate_system_id
;
self
.
viewport_transform
=
cs_scale_offset
;
self
.
content_transform
=
cs_scale_offset
;
}
SpatialNodeType
:
:
StickyFrame
(
ref
mut
info
)
=
>
{
let
animated_offset
=
if
let
Some
(
transform_binding
)
=
info
.
transform
{
let
transform
=
scene_properties
.
resolve_layout_transform
(
&
transform_binding
)
;
match
ScaleOffset
:
:
from_transform
(
&
transform
)
{
Some
(
ref
scale_offset
)
=
>
{
debug_assert
!
(
scale_offset
.
scale
=
=
Vector2D
:
:
new
(
1
.
0
1
.
0
)
"
Can
only
animate
a
translation
on
sticky
elements
"
)
;
LayoutVector2D
:
:
from_untyped
(
scale_offset
.
offset
)
}
None
=
>
{
debug_assert
!
(
false
"
Can
only
animate
a
translation
on
sticky
elements
"
)
;
LayoutVector2D
:
:
zero
(
)
}
}
}
else
{
LayoutVector2D
:
:
zero
(
)
}
;
let
sticky_offset
=
Self
:
:
calculate_sticky_offset
(
&
state
.
nearest_scrolling_ancestor_offset
&
state
.
nearest_scrolling_ancestor_viewport
info
)
;
let
accumulated_offset
=
state
.
parent_accumulated_scroll_offset
+
sticky_offset
+
animated_offset
;
self
.
viewport_transform
=
state
.
coordinate_system_relative_scale_offset
.
pre_offset
(
snap_offset
(
accumulated_offset
state
.
coordinate_system_relative_scale_offset
.
scale
)
.
to_untyped
(
)
)
;
self
.
content_transform
=
self
.
viewport_transform
;
info
.
current_offset
=
sticky_offset
+
animated_offset
;
self
.
coordinate_system_id
=
state
.
current_coordinate_system_id
;
}
SpatialNodeType
:
:
ScrollFrame
(
_
)
=
>
{
let
accumulated_offset
=
state
.
parent_accumulated_scroll_offset
;
self
.
viewport_transform
=
state
.
coordinate_system_relative_scale_offset
.
pre_offset
(
snap_offset
(
accumulated_offset
state
.
coordinate_system_relative_scale_offset
.
scale
)
.
to_untyped
(
)
)
;
let
added_offset
=
accumulated_offset
+
self
.
scroll_offset
(
)
;
self
.
content_transform
=
state
.
coordinate_system_relative_scale_offset
.
pre_offset
(
snap_offset
(
added_offset
state
.
coordinate_system_relative_scale_offset
.
scale
)
.
to_untyped
(
)
)
;
self
.
coordinate_system_id
=
state
.
current_coordinate_system_id
;
}
}
self
.
transform_kind
=
if
self
.
coordinate_system_id
.
0
=
=
0
{
TransformedRectKind
:
:
AxisAligned
}
else
{
TransformedRectKind
:
:
Complex
}
;
}
fn
calculate_sticky_offset
(
viewport_scroll_offset
:
&
LayoutVector2D
viewport_rect
:
&
LayoutRect
info
:
&
StickyFrameInfo
)
-
>
LayoutVector2D
{
if
info
.
margins
.
top
.
is_none
(
)
&
&
info
.
margins
.
bottom
.
is_none
(
)
&
&
info
.
margins
.
left
.
is_none
(
)
&
&
info
.
margins
.
right
.
is_none
(
)
{
return
LayoutVector2D
:
:
zero
(
)
;
}
let
mut
sticky_rect
=
info
.
frame_rect
.
translate
(
*
viewport_scroll_offset
)
;
let
mut
sticky_offset
=
LayoutVector2D
:
:
zero
(
)
;
if
let
Some
(
margin
)
=
info
.
margins
.
top
{
let
top_viewport_edge
=
viewport_rect
.
min
.
y
+
margin
;
if
sticky_rect
.
min
.
y
<
top_viewport_edge
{
sticky_offset
.
y
=
top_viewport_edge
-
sticky_rect
.
min
.
y
;
}
else
if
info
.
previously_applied_offset
.
y
>
0
.
0
&
&
sticky_rect
.
min
.
y
>
top_viewport_edge
{
sticky_offset
.
y
=
top_viewport_edge
-
sticky_rect
.
min
.
y
;
sticky_offset
.
y
=
sticky_offset
.
y
.
max
(
-
info
.
previously_applied_offset
.
y
)
;
}
}
if
sticky_offset
.
y
+
info
.
previously_applied_offset
.
y
<
=
0
.
0
{
if
let
Some
(
margin
)
=
info
.
margins
.
bottom
{
sticky_rect
.
min
.
y
+
=
sticky_offset
.
y
;
sticky_rect
.
max
.
y
+
=
sticky_offset
.
y
;
let
bottom_viewport_edge
=
viewport_rect
.
max
.
y
-
margin
;
if
sticky_rect
.
max
.
y
>
bottom_viewport_edge
{
sticky_offset
.
y
+
=
bottom_viewport_edge
-
sticky_rect
.
max
.
y
;
}
else
if
info
.
previously_applied_offset
.
y
<
0
.
0
&
&
sticky_rect
.
max
.
y
<
bottom_viewport_edge
{
sticky_offset
.
y
+
=
bottom_viewport_edge
-
sticky_rect
.
max
.
y
;
sticky_offset
.
y
=
sticky_offset
.
y
.
min
(
-
info
.
previously_applied_offset
.
y
)
;
}
}
}
if
let
Some
(
margin
)
=
info
.
margins
.
left
{
let
left_viewport_edge
=
viewport_rect
.
min
.
x
+
margin
;
if
sticky_rect
.
min
.
x
<
left_viewport_edge
{
sticky_offset
.
x
=
left_viewport_edge
-
sticky_rect
.
min
.
x
;
}
else
if
info
.
previously_applied_offset
.
x
>
0
.
0
&
&
sticky_rect
.
min
.
x
>
left_viewport_edge
{
sticky_offset
.
x
=
left_viewport_edge
-
sticky_rect
.
min
.
x
;
sticky_offset
.
x
=
sticky_offset
.
x
.
max
(
-
info
.
previously_applied_offset
.
x
)
;
}
}
if
sticky_offset
.
x
+
info
.
previously_applied_offset
.
x
<
=
0
.
0
{
if
let
Some
(
margin
)
=
info
.
margins
.
right
{
sticky_rect
.
min
.
x
+
=
sticky_offset
.
x
;
sticky_rect
.
max
.
x
+
=
sticky_offset
.
x
;
let
right_viewport_edge
=
viewport_rect
.
max
.
x
-
margin
;
if
sticky_rect
.
max
.
x
>
right_viewport_edge
{
sticky_offset
.
x
+
=
right_viewport_edge
-
sticky_rect
.
max
.
x
;
}
else
if
info
.
previously_applied_offset
.
x
<
0
.
0
&
&
sticky_rect
.
max
.
x
<
right_viewport_edge
{
sticky_offset
.
x
+
=
right_viewport_edge
-
sticky_rect
.
max
.
x
;
sticky_offset
.
x
=
sticky_offset
.
x
.
min
(
-
info
.
previously_applied_offset
.
x
)
;
}
}
}
let
clamp_adjusted
=
|
value
:
f32
adjust
:
f32
bounds
:
&
StickyOffsetBounds
|
{
(
value
+
adjust
)
.
max
(
bounds
.
min
)
.
min
(
bounds
.
max
)
-
adjust
}
;
sticky_offset
.
y
=
clamp_adjusted
(
sticky_offset
.
y
info
.
previously_applied_offset
.
y
&
info
.
vertical_offset_bounds
)
;
sticky_offset
.
x
=
clamp_adjusted
(
sticky_offset
.
x
info
.
previously_applied_offset
.
x
&
info
.
horizontal_offset_bounds
)
;
sticky_offset
+
info
.
previously_applied_offset
}
pub
fn
prepare_state_for_children
(
&
self
state
:
&
mut
TransformUpdateState
)
{
state
.
current_coordinate_system_id
=
self
.
coordinate_system_id
;
state
.
is_ancestor_or_self_zooming
=
self
.
is_ancestor_or_self_zooming
;
state
.
invertible
&
=
self
.
invertible
;
match
self
.
node_type
{
SpatialNodeType
:
:
StickyFrame
(
ref
info
)
=
>
{
state
.
parent_accumulated_scroll_offset
+
=
info
.
current_offset
;
state
.
nearest_scrolling_ancestor_offset
+
=
info
.
current_offset
;
state
.
preserves_3d
=
false
;
state
.
external_id
=
None
;
state
.
scroll_offset
=
info
.
current_offset
;
}
SpatialNodeType
:
:
ScrollFrame
(
ref
scrolling
)
=
>
{
state
.
parent_accumulated_scroll_offset
+
=
scrolling
.
offset
(
)
;
state
.
nearest_scrolling_ancestor_offset
=
scrolling
.
offset
(
)
;
state
.
nearest_scrolling_ancestor_viewport
=
scrolling
.
viewport_rect
;
state
.
preserves_3d
=
false
;
state
.
external_id
=
Some
(
scrolling
.
external_id
)
;
state
.
scroll_offset
=
scrolling
.
offset
(
)
+
scrolling
.
external_scroll_offset
;
}
SpatialNodeType
:
:
ReferenceFrame
(
ref
info
)
=
>
{
state
.
external_id
=
None
;
state
.
scroll_offset
=
LayoutVector2D
:
:
zero
(
)
;
state
.
preserves_3d
=
info
.
transform_style
=
=
TransformStyle
:
:
Preserve3D
;
state
.
parent_accumulated_scroll_offset
=
LayoutVector2D
:
:
zero
(
)
;
state
.
coordinate_system_relative_scale_offset
=
self
.
content_transform
;
let
translation
=
-
info
.
origin_in_parent_reference_frame
;
state
.
nearest_scrolling_ancestor_viewport
=
state
.
nearest_scrolling_ancestor_viewport
.
translate
(
translation
)
;
}
}
}
pub
fn
scroll_offset
(
&
self
)
-
>
LayoutVector2D
{
match
self
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
ref
scrolling
)
=
>
scrolling
.
offset
(
)
_
=
>
LayoutVector2D
:
:
zero
(
)
}
}
pub
fn
matches_external_id
(
&
self
external_id
:
ExternalScrollId
)
-
>
bool
{
match
self
.
node_type
{
SpatialNodeType
:
:
ScrollFrame
(
ref
info
)
if
info
.
external_id
=
=
external_id
=
>
true
_
=
>
false
}
}
pub
fn
is_transform_bound_to_property
(
&
self
id
:
PropertyBindingId
)
-
>
bool
{
if
let
SpatialNodeType
:
:
ReferenceFrame
(
ref
info
)
=
self
.
node_type
{
if
let
PropertyBinding
:
:
Binding
(
key
_
)
=
info
.
source_transform
{
id
=
=
key
.
id
}
else
{
false
}
}
else
{
false
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ScrollFrameKind
{
PipelineRoot
{
is_root_pipeline
:
bool
}
Explicit
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ScrollFrameInfo
{
pub
viewport_rect
:
LayoutRect
pub
scrollable_size
:
LayoutSize
pub
external_id
:
ExternalScrollId
pub
frame_kind
:
ScrollFrameKind
pub
external_scroll_offset
:
LayoutVector2D
pub
offsets
:
Vec
<
SampledScrollOffset
>
pub
offset_generation
:
APZScrollGeneration
pub
has_scroll_linked_effect
:
HasScrollLinkedEffect
}
impl
ScrollFrameInfo
{
pub
fn
new
(
viewport_rect
:
LayoutRect
scrollable_size
:
LayoutSize
external_id
:
ExternalScrollId
frame_kind
:
ScrollFrameKind
external_scroll_offset
:
LayoutVector2D
offset_generation
:
APZScrollGeneration
has_scroll_linked_effect
:
HasScrollLinkedEffect
)
-
>
ScrollFrameInfo
{
ScrollFrameInfo
{
viewport_rect
scrollable_size
external_id
frame_kind
external_scroll_offset
offsets
:
vec
!
[
SampledScrollOffset
{
/
/
If
this
scroll
frame
is
a
newly
created
one
using
/
/
external_scroll_offset
and
offset_generation
is
correct
.
/
/
If
this
scroll
frame
is
a
result
of
updating
an
existing
/
/
scroll
frame
and
if
there
have
already
been
sampled
async
/
/
scroll
offsets
by
APZ
then
these
offsets
will
be
replaced
in
/
/
SpatialTree
:
:
set_scroll_offsets
via
a
/
/
RenderBackend
:
:
update_document
call
.
offset
:
-
external_scroll_offset
generation
:
offset_generation
.
clone
(
)
}
]
offset_generation
has_scroll_linked_effect
}
}
pub
fn
offset
(
&
self
)
-
>
LayoutVector2D
{
debug_assert
!
(
self
.
offsets
.
len
(
)
>
0
"
There
should
be
at
least
one
sampled
offset
!
"
)
;
if
self
.
has_scroll_linked_effect
=
=
HasScrollLinkedEffect
:
:
No
{
return
self
.
offsets
.
first
(
)
.
map_or
(
LayoutVector2D
:
:
zero
(
)
|
sampled
|
sampled
.
offset
)
;
}
match
self
.
offsets
.
iter
(
)
.
find
(
|
sampled
|
sampled
.
generation
=
=
self
.
offset_generation
)
{
Some
(
sampled
)
=
>
sampled
.
offset
_
=
>
self
.
offsets
.
first
(
)
.
map_or
(
LayoutVector2D
:
:
zero
(
)
|
sampled
|
sampled
.
offset
)
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ReferenceFrameInfo
{
pub
source_transform
:
PropertyBinding
<
LayoutTransform
>
pub
transform_style
:
TransformStyle
pub
kind
:
ReferenceFrameKind
pub
origin_in_parent_reference_frame
:
LayoutVector2D
pub
is_pipeline_root
:
bool
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
StickyFrameInfo
{
pub
margins
:
SideOffsets2D
<
Option
<
f32
>
LayoutPixel
>
pub
frame_rect
:
LayoutRect
pub
vertical_offset_bounds
:
StickyOffsetBounds
pub
horizontal_offset_bounds
:
StickyOffsetBounds
pub
previously_applied_offset
:
LayoutVector2D
pub
current_offset
:
LayoutVector2D
pub
transform
:
Option
<
PropertyBinding
<
LayoutTransform
>
>
}
impl
StickyFrameInfo
{
pub
fn
new
(
frame_rect
:
LayoutRect
margins
:
SideOffsets2D
<
Option
<
f32
>
LayoutPixel
>
vertical_offset_bounds
:
StickyOffsetBounds
horizontal_offset_bounds
:
StickyOffsetBounds
previously_applied_offset
:
LayoutVector2D
transform
:
Option
<
PropertyBinding
<
LayoutTransform
>
>
)
-
>
StickyFrameInfo
{
StickyFrameInfo
{
frame_rect
margins
vertical_offset_bounds
horizontal_offset_bounds
previously_applied_offset
current_offset
:
LayoutVector2D
:
:
zero
(
)
transform
}
}
}
#
[
test
]
fn
test_cst_perspective_relative_scroll
(
)
{
use
crate
:
:
spatial_tree
:
:
{
SceneSpatialTree
SpatialTree
}
;
use
euclid
:
:
Angle
;
let
mut
cst
=
SceneSpatialTree
:
:
new
(
)
;
let
pipeline_id
=
PipelineId
:
:
dummy
(
)
;
let
ext_scroll_id
=
ExternalScrollId
(
1
pipeline_id
)
;
let
transform
=
LayoutTransform
:
:
rotation
(
0
.
0
0
.
0
1
.
0
Angle
:
:
degrees
(
45
.
0
)
)
;
let
pid
=
PipelineInstanceId
:
:
new
(
0
)
;
let
root
=
cst
.
add_reference_frame
(
cst
.
root_reference_frame_index
(
)
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
false
should_snap
:
false
paired_with_perspective
:
false
}
LayoutVector2D
:
:
zero
(
)
pipeline_id
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
0
)
PipelineId
:
:
dummy
(
)
pid
)
)
;
let
scroll_frame_1
=
cst
.
add_scroll_frame
(
root
ext_scroll_id
pipeline_id
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
100
.
0
100
.
0
)
)
&
LayoutSize
:
:
new
(
100
.
0
500
.
0
)
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
zero
(
)
APZScrollGeneration
:
:
default
(
)
HasScrollLinkedEffect
:
:
No
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
1
)
PipelineId
:
:
dummy
(
)
pid
)
)
;
let
scroll_frame_2
=
cst
.
add_scroll_frame
(
scroll_frame_1
ExternalScrollId
(
2
pipeline_id
)
pipeline_id
&
LayoutRect
:
:
from_size
(
LayoutSize
:
:
new
(
100
.
0
100
.
0
)
)
&
LayoutSize
:
:
new
(
100
.
0
500
.
0
)
ScrollFrameKind
:
:
Explicit
LayoutVector2D
:
:
new
(
0
.
0
50
.
0
)
APZScrollGeneration
:
:
default
(
)
HasScrollLinkedEffect
:
:
No
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
3
)
PipelineId
:
:
dummy
(
)
pid
)
)
;
let
ref_frame
=
cst
.
add_reference_frame
(
scroll_frame_2
TransformStyle
:
:
Preserve3D
PropertyBinding
:
:
Value
(
transform
)
ReferenceFrameKind
:
:
Perspective
{
scrolling_relative_to
:
Some
(
ext_scroll_id
)
}
LayoutVector2D
:
:
zero
(
)
pipeline_id
SpatialNodeUid
:
:
external
(
SpatialTreeItemKey
:
:
new
(
0
4
)
PipelineId
:
:
dummy
(
)
pid
)
)
;
let
mut
st
=
SpatialTree
:
:
new
(
)
;
st
.
apply_updates
(
cst
.
end_frame_and_get_pending_updates
(
)
)
;
st
.
update_tree
(
&
SceneProperties
:
:
new
(
)
)
;
let
world_transform
=
st
.
get_world_transform
(
ref_frame
)
.
into_transform
(
)
.
cast_unit
(
)
;
let
ref_transform
=
transform
.
then_translate
(
LayoutVector3D
:
:
new
(
0
.
0
-
50
.
0
0
.
0
)
)
;
assert
!
(
world_transform
.
approx_eq
(
&
ref_transform
)
)
;
}
