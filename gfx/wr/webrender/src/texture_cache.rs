use
api
:
:
{
DirtyRect
ExternalImageType
ImageFormat
ImageBufferKind
}
;
use
api
:
:
{
DebugFlags
ImageDescriptor
}
;
use
api
:
:
units
:
:
*
;
#
[
cfg
(
test
)
]
use
api
:
:
{
DocumentId
IdNamespace
}
;
use
crate
:
:
device
:
:
{
TextureFilter
TextureFormatPair
}
;
use
crate
:
:
freelist
:
:
{
FreeList
FreeListHandle
WeakFreeListHandle
}
;
use
crate
:
:
gpu_cache
:
:
{
GpuCache
GpuCacheHandle
}
;
use
crate
:
:
gpu_types
:
:
{
ImageSource
UvRectKind
}
;
use
crate
:
:
internal_types
:
:
{
CacheTextureId
Swizzle
SwizzleSettings
FrameStamp
FrameId
TextureUpdateList
TextureUpdateSource
TextureSource
TextureCacheAllocInfo
TextureCacheUpdate
TextureCacheCategory
}
;
use
crate
:
:
lru_cache
:
:
LRUCache
;
use
crate
:
:
profiler
:
:
{
self
TransactionProfile
}
;
use
crate
:
:
resource_cache
:
:
{
CacheItem
CachedImageData
}
;
use
crate
:
:
texture_pack
:
:
{
AllocatorList
AllocId
AtlasAllocatorList
ShelfAllocator
ShelfAllocatorOptions
}
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
use
euclid
:
:
size2
;
use
malloc_size_of
:
:
{
MallocSizeOf
MallocSizeOfOps
}
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TargetShader
{
Default
Text
}
pub
const
TEXTURE_REGION_DIMENSIONS
:
i32
=
512
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
EntryDetails
{
Standalone
{
size_in_bytes
:
usize
}
Cache
{
origin
:
DeviceIntPoint
alloc_id
:
AllocId
allocated_size_in_bytes
:
usize
}
}
impl
EntryDetails
{
fn
describe
(
&
self
)
-
>
DeviceIntPoint
{
match
*
self
{
EntryDetails
:
:
Standalone
{
.
.
}
=
>
DeviceIntPoint
:
:
zero
(
)
EntryDetails
:
:
Cache
{
origin
.
.
}
=
>
origin
}
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
AutoCacheEntryMarker
{
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ManualCacheEntryMarker
{
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheEntry
{
pub
size
:
DeviceIntSize
pub
details
:
EntryDetails
pub
user_data
:
[
f32
;
4
]
pub
last_access
:
FrameStamp
pub
uv_rect_handle
:
GpuCacheHandle
pub
input_format
:
ImageFormat
pub
filter
:
TextureFilter
pub
swizzle
:
Swizzle
pub
texture_id
:
CacheTextureId
pub
eviction_notice
:
Option
<
EvictionNotice
>
pub
uv_rect_kind
:
UvRectKind
pub
shader
:
TargetShader
}
malloc_size_of
:
:
malloc_size_of_is_0
!
(
CacheEntry
AutoCacheEntryMarker
ManualCacheEntryMarker
)
;
impl
CacheEntry
{
fn
new_standalone
(
texture_id
:
CacheTextureId
last_access
:
FrameStamp
params
:
&
CacheAllocParams
swizzle
:
Swizzle
size_in_bytes
:
usize
)
-
>
Self
{
CacheEntry
{
size
:
params
.
descriptor
.
size
user_data
:
params
.
user_data
last_access
details
:
EntryDetails
:
:
Standalone
{
size_in_bytes
}
texture_id
input_format
:
params
.
descriptor
.
format
filter
:
params
.
filter
swizzle
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
eviction_notice
:
None
uv_rect_kind
:
params
.
uv_rect_kind
shader
:
TargetShader
:
:
Default
}
}
fn
update_gpu_cache
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
)
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
uv_rect_handle
)
{
let
origin
=
self
.
details
.
describe
(
)
;
let
image_source
=
ImageSource
{
p0
:
origin
.
to_f32
(
)
p1
:
(
origin
+
self
.
size
)
.
to_f32
(
)
user_data
:
self
.
user_data
uv_rect_kind
:
self
.
uv_rect_kind
}
;
image_source
.
write_gpu_blocks
(
&
mut
request
)
;
}
}
fn
evict
(
&
self
)
{
if
let
Some
(
eviction_notice
)
=
self
.
eviction_notice
.
as_ref
(
)
{
eviction_notice
.
notify
(
)
;
}
}
fn
alternative_input_format
(
&
self
)
-
>
ImageFormat
{
match
self
.
input_format
{
ImageFormat
:
:
RGBA8
=
>
ImageFormat
:
:
BGRA8
ImageFormat
:
:
BGRA8
=
>
ImageFormat
:
:
RGBA8
other
=
>
other
}
}
}
#
[
derive
(
MallocSizeOf
Clone
PartialEq
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureCacheHandle
{
Empty
Auto
(
WeakFreeListHandle
<
AutoCacheEntryMarker
>
)
Manual
(
WeakFreeListHandle
<
ManualCacheEntryMarker
>
)
}
impl
TextureCacheHandle
{
pub
fn
invalid
(
)
-
>
Self
{
TextureCacheHandle
:
:
Empty
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Eviction
{
Auto
Manual
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
EvictionNotice
{
evicted
:
Rc
<
Cell
<
bool
>
>
}
impl
EvictionNotice
{
fn
notify
(
&
self
)
{
self
.
evicted
.
set
(
true
)
;
}
pub
fn
check
(
&
self
)
-
>
bool
{
if
self
.
evicted
.
get
(
)
{
self
.
evicted
.
set
(
false
)
;
true
}
else
{
false
}
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
repr
(
u8
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
enum
BudgetType
{
SharedColor8Linear
SharedColor8Nearest
SharedColor8Glyphs
SharedAlpha8
SharedAlpha8Glyphs
SharedAlpha16
Standalone
}
impl
BudgetType
{
pub
const
COUNT
:
usize
=
7
;
pub
const
VALUES
:
[
BudgetType
;
BudgetType
:
:
COUNT
]
=
[
BudgetType
:
:
SharedColor8Linear
BudgetType
:
:
SharedColor8Nearest
BudgetType
:
:
SharedColor8Glyphs
BudgetType
:
:
SharedAlpha8
BudgetType
:
:
SharedAlpha8Glyphs
BudgetType
:
:
SharedAlpha16
BudgetType
:
:
Standalone
]
;
pub
const
PRESSURE_COUNTERS
:
[
usize
;
BudgetType
:
:
COUNT
]
=
[
profiler
:
:
ATLAS_COLOR8_LINEAR_PRESSURE
profiler
:
:
ATLAS_COLOR8_NEAREST_PRESSURE
profiler
:
:
ATLAS_COLOR8_GLYPHS_PRESSURE
profiler
:
:
ATLAS_ALPHA8_PRESSURE
profiler
:
:
ATLAS_ALPHA8_GLYPHS_PRESSURE
profiler
:
:
ATLAS_ALPHA16_PRESSURE
profiler
:
:
ATLAS_STANDALONE_PRESSURE
]
;
pub
fn
iter
(
)
-
>
impl
Iterator
<
Item
=
BudgetType
>
{
BudgetType
:
:
VALUES
.
iter
(
)
.
cloned
(
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
SharedTextures
{
color8_nearest
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
alpha8_linear
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
alpha8_glyphs
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
alpha16_linear
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
color8_linear
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
color8_glyphs
:
AllocatorList
<
ShelfAllocator
TextureParameters
>
bytes_per_texture_of_type
:
[
i32
;
BudgetType
:
:
COUNT
]
next_compaction_idx
:
usize
}
impl
SharedTextures
{
fn
new
(
color_formats
:
TextureFormatPair
<
ImageFormat
>
config
:
&
TextureCacheConfig
)
-
>
Self
{
let
mut
bytes_per_texture_of_type
=
[
0
;
BudgetType
:
:
COUNT
]
;
let
alpha8_linear
=
AllocatorList
:
:
new
(
config
.
alpha8_texture_size
ShelfAllocatorOptions
{
num_columns
:
1
alignment
:
size2
(
8
8
)
.
.
ShelfAllocatorOptions
:
:
default
(
)
}
TextureParameters
{
formats
:
TextureFormatPair
:
:
from
(
ImageFormat
:
:
R8
)
filter
:
TextureFilter
:
:
Linear
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedAlpha8
as
usize
]
=
config
.
alpha8_texture_size
*
config
.
alpha8_texture_size
;
let
alpha8_glyphs
=
AllocatorList
:
:
new
(
config
.
alpha8_glyph_texture_size
ShelfAllocatorOptions
{
num_columns
:
if
config
.
alpha8_glyph_texture_size
>
=
1024
{
2
}
else
{
1
}
alignment
:
size2
(
4
8
)
.
.
ShelfAllocatorOptions
:
:
default
(
)
}
TextureParameters
{
formats
:
TextureFormatPair
:
:
from
(
ImageFormat
:
:
R8
)
filter
:
TextureFilter
:
:
Linear
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedAlpha8Glyphs
as
usize
]
=
config
.
alpha8_glyph_texture_size
*
config
.
alpha8_glyph_texture_size
;
let
alpha16_linear
=
AllocatorList
:
:
new
(
config
.
alpha16_texture_size
ShelfAllocatorOptions
{
num_columns
:
if
config
.
alpha16_texture_size
>
=
1024
{
2
}
else
{
1
}
alignment
:
size2
(
8
8
)
.
.
ShelfAllocatorOptions
:
:
default
(
)
}
TextureParameters
{
formats
:
TextureFormatPair
:
:
from
(
ImageFormat
:
:
R16
)
filter
:
TextureFilter
:
:
Linear
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedAlpha16
as
usize
]
=
ImageFormat
:
:
R16
.
bytes_per_pixel
(
)
*
config
.
alpha16_texture_size
*
config
.
alpha16_texture_size
;
let
color8_linear
=
AllocatorList
:
:
new
(
config
.
color8_linear_texture_size
ShelfAllocatorOptions
{
num_columns
:
if
config
.
color8_linear_texture_size
>
=
1024
{
2
}
else
{
1
}
alignment
:
size2
(
16
16
)
.
.
ShelfAllocatorOptions
:
:
default
(
)
}
TextureParameters
{
formats
:
color_formats
.
clone
(
)
filter
:
TextureFilter
:
:
Linear
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedColor8Linear
as
usize
]
=
color_formats
.
internal
.
bytes_per_pixel
(
)
*
config
.
color8_linear_texture_size
*
config
.
color8_linear_texture_size
;
let
color8_glyphs
=
AllocatorList
:
:
new
(
config
.
color8_glyph_texture_size
ShelfAllocatorOptions
{
num_columns
:
if
config
.
color8_glyph_texture_size
>
=
1024
{
2
}
else
{
1
}
alignment
:
size2
(
4
8
)
.
.
ShelfAllocatorOptions
:
:
default
(
)
}
TextureParameters
{
formats
:
color_formats
.
clone
(
)
filter
:
TextureFilter
:
:
Linear
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedColor8Glyphs
as
usize
]
=
color_formats
.
internal
.
bytes_per_pixel
(
)
*
config
.
color8_glyph_texture_size
*
config
.
color8_glyph_texture_size
;
let
color8_nearest
=
AllocatorList
:
:
new
(
config
.
color8_nearest_texture_size
ShelfAllocatorOptions
:
:
default
(
)
TextureParameters
{
formats
:
color_formats
.
clone
(
)
filter
:
TextureFilter
:
:
Nearest
}
)
;
bytes_per_texture_of_type
[
BudgetType
:
:
SharedColor8Nearest
as
usize
]
=
color_formats
.
internal
.
bytes_per_pixel
(
)
*
config
.
color8_nearest_texture_size
*
config
.
color8_nearest_texture_size
;
Self
{
alpha8_linear
alpha8_glyphs
alpha16_linear
color8_linear
color8_glyphs
color8_nearest
bytes_per_texture_of_type
next_compaction_idx
:
0
}
}
fn
clear
(
&
mut
self
updates
:
&
mut
TextureUpdateList
)
{
let
texture_dealloc_cb
=
&
mut
|
texture_id
|
{
updates
.
push_free
(
texture_id
)
;
}
;
self
.
alpha8_linear
.
clear
(
texture_dealloc_cb
)
;
self
.
alpha8_glyphs
.
clear
(
texture_dealloc_cb
)
;
self
.
alpha16_linear
.
clear
(
texture_dealloc_cb
)
;
self
.
color8_linear
.
clear
(
texture_dealloc_cb
)
;
self
.
color8_nearest
.
clear
(
texture_dealloc_cb
)
;
self
.
color8_glyphs
.
clear
(
texture_dealloc_cb
)
;
}
fn
select
(
&
mut
self
external_format
:
ImageFormat
filter
:
TextureFilter
shader
:
TargetShader
)
-
>
(
&
mut
dyn
AtlasAllocatorList
<
TextureParameters
>
BudgetType
)
{
match
external_format
{
ImageFormat
:
:
R8
=
>
{
assert_eq
!
(
filter
TextureFilter
:
:
Linear
)
;
match
shader
{
TargetShader
:
:
Text
=
>
{
(
&
mut
self
.
alpha8_glyphs
BudgetType
:
:
SharedAlpha8Glyphs
)
}
_
=
>
(
&
mut
self
.
alpha8_linear
BudgetType
:
:
SharedAlpha8
)
}
}
ImageFormat
:
:
R16
=
>
{
assert_eq
!
(
filter
TextureFilter
:
:
Linear
)
;
(
&
mut
self
.
alpha16_linear
BudgetType
:
:
SharedAlpha16
)
}
ImageFormat
:
:
RGBA8
|
ImageFormat
:
:
BGRA8
=
>
{
match
(
filter
shader
)
{
(
TextureFilter
:
:
Linear
TargetShader
:
:
Text
)
=
>
{
(
&
mut
self
.
color8_glyphs
BudgetType
:
:
SharedColor8Glyphs
)
}
(
TextureFilter
:
:
Linear
_
)
=
>
{
(
&
mut
self
.
color8_linear
BudgetType
:
:
SharedColor8Linear
)
}
(
TextureFilter
:
:
Nearest
_
)
=
>
{
(
&
mut
self
.
color8_nearest
BudgetType
:
:
SharedColor8Nearest
)
}
_
=
>
panic
!
(
"
Unexpected
filter
{
:
?
}
"
filter
)
}
}
_
=
>
panic
!
(
"
Unexpected
format
{
:
?
}
"
external_format
)
}
}
fn
bytes_per_shared_texture
(
&
self
budget_type
:
BudgetType
)
-
>
usize
{
self
.
bytes_per_texture_of_type
[
budget_type
as
usize
]
as
usize
}
fn
has_multiple_textures
(
&
self
budget_type
:
BudgetType
)
-
>
bool
{
match
budget_type
{
BudgetType
:
:
SharedColor8Linear
=
>
self
.
color8_linear
.
allocated_textures
(
)
>
1
BudgetType
:
:
SharedColor8Nearest
=
>
self
.
color8_nearest
.
allocated_textures
(
)
>
1
BudgetType
:
:
SharedColor8Glyphs
=
>
self
.
color8_glyphs
.
allocated_textures
(
)
>
1
BudgetType
:
:
SharedAlpha8
=
>
self
.
alpha8_linear
.
allocated_textures
(
)
>
1
BudgetType
:
:
SharedAlpha8Glyphs
=
>
self
.
alpha8_glyphs
.
allocated_textures
(
)
>
1
BudgetType
:
:
SharedAlpha16
=
>
self
.
alpha16_linear
.
allocated_textures
(
)
>
1
BudgetType
:
:
Standalone
=
>
false
}
}
}
struct
CacheAllocParams
{
descriptor
:
ImageDescriptor
filter
:
TextureFilter
user_data
:
[
f32
;
4
]
uv_rect_kind
:
UvRectKind
shader
:
TargetShader
}
#
[
derive
(
Clone
)
]
pub
struct
TextureCacheConfig
{
pub
color8_linear_texture_size
:
i32
pub
color8_nearest_texture_size
:
i32
pub
color8_glyph_texture_size
:
i32
pub
alpha8_texture_size
:
i32
pub
alpha8_glyph_texture_size
:
i32
pub
alpha16_texture_size
:
i32
}
impl
TextureCacheConfig
{
pub
const
DEFAULT
:
Self
=
TextureCacheConfig
{
color8_linear_texture_size
:
2048
color8_nearest_texture_size
:
512
color8_glyph_texture_size
:
2048
alpha8_texture_size
:
1024
alpha8_glyph_texture_size
:
2048
alpha16_texture_size
:
512
}
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureCache
{
shared_textures
:
SharedTextures
max_texture_size
:
i32
tiling_threshold
:
i32
swizzle
:
Option
<
SwizzleSettings
>
debug_flags
:
DebugFlags
pub
next_id
:
CacheTextureId
#
[
cfg_attr
(
all
(
feature
=
"
serde
"
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
)
serde
(
skip
)
)
]
pub
pending_updates
:
TextureUpdateList
now
:
FrameStamp
lru_cache
:
LRUCache
<
CacheEntry
AutoCacheEntryMarker
>
manual_entries
:
FreeList
<
CacheEntry
ManualCacheEntryMarker
>
manual_handles
:
Vec
<
FreeListHandle
<
ManualCacheEntryMarker
>
>
bytes_allocated
:
[
usize
;
BudgetType
:
:
COUNT
]
}
impl
TextureCache
{
const
MAX_EVICTIONS_PER_FRAME
:
usize
=
32
;
pub
fn
new
(
max_texture_size
:
i32
tiling_threshold
:
i32
color_formats
:
TextureFormatPair
<
ImageFormat
>
swizzle
:
Option
<
SwizzleSettings
>
config
:
&
TextureCacheConfig
)
-
>
Self
{
let
pending_updates
=
TextureUpdateList
:
:
new
(
)
;
assert
!
(
color_formats
.
internal
!
=
ImageFormat
:
:
BGRA8
|
|
swizzle
.
map_or
(
true
|
s
|
s
.
bgra8_sampling_swizzle
=
=
Swizzle
:
:
default
(
)
)
)
;
let
next_texture_id
=
CacheTextureId
(
1
)
;
TextureCache
{
shared_textures
:
SharedTextures
:
:
new
(
color_formats
config
)
max_texture_size
tiling_threshold
swizzle
debug_flags
:
DebugFlags
:
:
empty
(
)
next_id
:
next_texture_id
pending_updates
now
:
FrameStamp
:
:
INVALID
lru_cache
:
LRUCache
:
:
new
(
BudgetType
:
:
COUNT
)
manual_entries
:
FreeList
:
:
new
(
)
manual_handles
:
Vec
:
:
new
(
)
bytes_allocated
:
[
0
;
BudgetType
:
:
COUNT
]
}
}
#
[
cfg
(
test
)
]
pub
fn
new_for_testing
(
max_texture_size
:
i32
image_format
:
ImageFormat
)
-
>
Self
{
let
mut
cache
=
Self
:
:
new
(
max_texture_size
max_texture_size
TextureFormatPair
:
:
from
(
image_format
)
None
&
TextureCacheConfig
:
:
DEFAULT
)
;
let
mut
now
=
FrameStamp
:
:
first
(
DocumentId
:
:
new
(
IdNamespace
(
1
)
1
)
)
;
now
.
advance
(
)
;
cache
.
begin_frame
(
now
&
mut
TransactionProfile
:
:
new
(
)
)
;
cache
}
pub
fn
set_debug_flags
(
&
mut
self
flags
:
DebugFlags
)
{
self
.
debug_flags
=
flags
;
}
pub
fn
clear_all
(
&
mut
self
)
{
let
manual_handles
=
mem
:
:
replace
(
&
mut
self
.
manual_handles
Vec
:
:
new
(
)
)
;
for
handle
in
manual_handles
{
let
entry
=
self
.
manual_entries
.
free
(
handle
)
;
self
.
evict_impl
(
entry
)
;
}
for
budget_type
in
BudgetType
:
:
iter
(
)
{
while
let
Some
(
entry
)
=
self
.
lru_cache
.
pop_oldest
(
budget_type
as
u8
)
{
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
}
}
self
.
shared_textures
.
clear
(
&
mut
self
.
pending_updates
)
;
self
.
pending_updates
.
note_clear
(
)
;
}
pub
fn
begin_frame
(
&
mut
self
stamp
:
FrameStamp
profile
:
&
mut
TransactionProfile
)
{
debug_assert
!
(
!
self
.
now
.
is_valid
(
)
)
;
profile_scope
!
(
"
begin_frame
"
)
;
self
.
now
=
stamp
;
self
.
evict_items_from_cache_if_required
(
profile
)
;
}
pub
fn
end_frame
(
&
mut
self
profile
:
&
mut
TransactionProfile
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
let
updates
=
&
mut
self
.
pending_updates
;
let
callback
=
&
mut
|
texture_id
|
{
updates
.
push_free
(
texture_id
)
;
}
;
self
.
shared_textures
.
alpha8_linear
.
release_empty_textures
(
callback
)
;
self
.
shared_textures
.
alpha8_glyphs
.
release_empty_textures
(
callback
)
;
self
.
shared_textures
.
alpha16_linear
.
release_empty_textures
(
callback
)
;
self
.
shared_textures
.
color8_linear
.
release_empty_textures
(
callback
)
;
self
.
shared_textures
.
color8_nearest
.
release_empty_textures
(
callback
)
;
self
.
shared_textures
.
color8_glyphs
.
release_empty_textures
(
callback
)
;
for
budget
in
BudgetType
:
:
iter
(
)
{
let
threshold
=
self
.
get_eviction_threshold
(
budget
)
;
let
pressure
=
self
.
bytes_allocated
[
budget
as
usize
]
as
f32
/
threshold
as
f32
;
profile
.
set
(
BudgetType
:
:
PRESSURE_COUNTERS
[
budget
as
usize
]
pressure
)
;
}
profile
.
set
(
profiler
:
:
ATLAS_A8_PIXELS
self
.
shared_textures
.
alpha8_linear
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_A8_TEXTURES
self
.
shared_textures
.
alpha8_linear
.
allocated_textures
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_A8_GLYPHS_PIXELS
self
.
shared_textures
.
alpha8_glyphs
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_A8_GLYPHS_TEXTURES
self
.
shared_textures
.
alpha8_glyphs
.
allocated_textures
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_A16_PIXELS
self
.
shared_textures
.
alpha16_linear
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_A16_TEXTURES
self
.
shared_textures
.
alpha16_linear
.
allocated_textures
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_LINEAR_PIXELS
self
.
shared_textures
.
color8_linear
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_LINEAR_TEXTURES
self
.
shared_textures
.
color8_linear
.
allocated_textures
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_NEAREST_PIXELS
self
.
shared_textures
.
color8_nearest
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_NEAREST_TEXTURES
self
.
shared_textures
.
color8_nearest
.
allocated_textures
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_GLYPHS_PIXELS
self
.
shared_textures
.
color8_glyphs
.
allocated_space
(
)
)
;
profile
.
set
(
profiler
:
:
ATLAS_RGBA8_GLYPHS_TEXTURES
self
.
shared_textures
.
color8_glyphs
.
allocated_textures
(
)
)
;
let
shared_bytes
=
[
BudgetType
:
:
SharedColor8Linear
BudgetType
:
:
SharedColor8Nearest
BudgetType
:
:
SharedColor8Glyphs
BudgetType
:
:
SharedAlpha8
BudgetType
:
:
SharedAlpha8Glyphs
BudgetType
:
:
SharedAlpha16
]
.
iter
(
)
.
map
(
|
b
|
self
.
bytes_allocated
[
*
b
as
usize
]
)
.
sum
(
)
;
profile
.
set
(
profiler
:
:
ATLAS_ITEMS_MEM
profiler
:
:
bytes_to_mb
(
shared_bytes
)
)
;
self
.
now
=
FrameStamp
:
:
INVALID
;
}
pub
fn
run_compaction
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
)
{
let
allocator_lists
=
[
&
mut
self
.
shared_textures
.
color8_linear
&
mut
self
.
shared_textures
.
color8_nearest
&
mut
self
.
shared_textures
.
color8_glyphs
&
mut
self
.
shared_textures
.
alpha8_linear
&
mut
self
.
shared_textures
.
alpha8_glyphs
&
mut
self
.
shared_textures
.
alpha16_linear
]
;
let
idx
=
self
.
shared_textures
.
next_compaction_idx
;
let
area_threshold
=
512
*
512
;
let
mut
changes
=
Vec
:
:
new
(
)
;
allocator_lists
[
idx
]
.
try_compaction
(
area_threshold
&
mut
changes
)
;
if
changes
.
is_empty
(
)
{
self
.
shared_textures
.
next_compaction_idx
=
(
self
.
shared_textures
.
next_compaction_idx
+
1
)
%
allocator_lists
.
len
(
)
;
}
for
change
in
changes
{
let
bpp
=
allocator_lists
[
idx
]
.
texture_parameters
(
)
.
formats
.
internal
.
bytes_per_pixel
(
)
;
let
old_bytes
=
(
change
.
old_rect
.
area
(
)
*
bpp
)
as
usize
;
let
new_bytes
=
(
change
.
new_rect
.
area
(
)
*
bpp
)
as
usize
;
self
.
bytes_allocated
[
idx
]
-
=
old_bytes
;
self
.
bytes_allocated
[
idx
]
+
=
new_bytes
;
let
entry
=
match
change
.
handle
{
TextureCacheHandle
:
:
Auto
(
handle
)
=
>
self
.
lru_cache
.
get_opt_mut
(
&
handle
)
.
unwrap
(
)
TextureCacheHandle
:
:
Manual
(
handle
)
=
>
self
.
manual_entries
.
get_opt_mut
(
&
handle
)
.
unwrap
(
)
TextureCacheHandle
:
:
Empty
=
>
{
panic
!
(
"
invalid
handle
"
)
;
}
}
;
entry
.
texture_id
=
change
.
new_tex
;
entry
.
details
=
EntryDetails
:
:
Cache
{
origin
:
change
.
new_rect
.
min
alloc_id
:
change
.
new_id
allocated_size_in_bytes
:
new_bytes
}
;
gpu_cache
.
invalidate
(
&
entry
.
uv_rect_handle
)
;
entry
.
uv_rect_handle
=
GpuCacheHandle
:
:
new
(
)
;
let
src_rect
=
DeviceIntRect
:
:
from_origin_and_size
(
change
.
old_rect
.
min
entry
.
size
)
;
let
dst_rect
=
DeviceIntRect
:
:
from_origin_and_size
(
change
.
new_rect
.
min
entry
.
size
)
;
self
.
pending_updates
.
push_copy
(
change
.
old_tex
&
src_rect
change
.
new_tex
&
dst_rect
)
;
if
self
.
debug_flags
.
contains
(
DebugFlags
:
:
TEXTURE_CACHE_DBG
|
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
{
self
.
pending_updates
.
push_debug_clear
(
change
.
old_tex
src_rect
.
min
src_rect
.
width
(
)
src_rect
.
height
(
)
)
;
}
}
}
pub
fn
request
(
&
mut
self
handle
:
&
TextureCacheHandle
gpu_cache
:
&
mut
GpuCache
)
-
>
bool
{
let
now
=
self
.
now
;
let
entry
=
match
handle
{
TextureCacheHandle
:
:
Empty
=
>
None
TextureCacheHandle
:
:
Auto
(
handle
)
=
>
{
self
.
lru_cache
.
touch
(
handle
)
}
TextureCacheHandle
:
:
Manual
(
handle
)
=
>
{
self
.
manual_entries
.
get_opt_mut
(
handle
)
}
}
;
entry
.
map_or
(
true
|
entry
|
{
entry
.
last_access
=
now
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
false
}
)
}
fn
get_entry_opt
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
&
CacheEntry
>
{
match
handle
{
TextureCacheHandle
:
:
Empty
=
>
None
TextureCacheHandle
:
:
Auto
(
handle
)
=
>
self
.
lru_cache
.
get_opt
(
handle
)
TextureCacheHandle
:
:
Manual
(
handle
)
=
>
self
.
manual_entries
.
get_opt
(
handle
)
}
}
fn
get_entry_opt_mut
(
&
mut
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
&
mut
CacheEntry
>
{
match
handle
{
TextureCacheHandle
:
:
Empty
=
>
None
TextureCacheHandle
:
:
Auto
(
handle
)
=
>
self
.
lru_cache
.
get_opt_mut
(
handle
)
TextureCacheHandle
:
:
Manual
(
handle
)
=
>
self
.
manual_entries
.
get_opt_mut
(
handle
)
}
}
pub
fn
needs_upload
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
bool
{
!
self
.
is_allocated
(
handle
)
}
pub
fn
max_texture_size
(
&
self
)
-
>
i32
{
self
.
max_texture_size
}
pub
fn
tiling_threshold
(
&
self
)
-
>
i32
{
self
.
tiling_threshold
}
#
[
cfg
(
feature
=
"
replay
"
)
]
pub
fn
color_formats
(
&
self
)
-
>
TextureFormatPair
<
ImageFormat
>
{
self
.
shared_textures
.
color8_linear
.
texture_parameters
(
)
.
formats
.
clone
(
)
}
#
[
cfg
(
feature
=
"
replay
"
)
]
pub
fn
swizzle_settings
(
&
self
)
-
>
Option
<
SwizzleSettings
>
{
self
.
swizzle
}
pub
fn
pending_updates
(
&
mut
self
)
-
>
TextureUpdateList
{
mem
:
:
replace
(
&
mut
self
.
pending_updates
TextureUpdateList
:
:
new
(
)
)
}
pub
fn
update
(
&
mut
self
handle
:
&
mut
TextureCacheHandle
descriptor
:
ImageDescriptor
filter
:
TextureFilter
data
:
Option
<
CachedImageData
>
user_data
:
[
f32
;
4
]
mut
dirty_rect
:
ImageDirtyRect
gpu_cache
:
&
mut
GpuCache
eviction_notice
:
Option
<
&
EvictionNotice
>
uv_rect_kind
:
UvRectKind
eviction
:
Eviction
shader
:
TargetShader
force_standalone_texture
:
bool
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
let
realloc
=
match
self
.
get_entry_opt
(
handle
)
{
Some
(
entry
)
=
>
{
entry
.
size
!
=
descriptor
.
size
|
|
(
entry
.
input_format
!
=
descriptor
.
format
&
&
entry
.
alternative_input_format
(
)
!
=
descriptor
.
format
)
}
None
=
>
{
true
}
}
;
if
realloc
{
let
params
=
CacheAllocParams
{
descriptor
filter
user_data
uv_rect_kind
shader
}
;
self
.
allocate
(
&
params
handle
eviction
force_standalone_texture
)
;
dirty_rect
=
DirtyRect
:
:
All
;
}
let
entry
=
self
.
get_entry_opt_mut
(
handle
)
.
expect
(
"
BUG
:
There
must
be
an
entry
at
this
handle
now
"
)
;
entry
.
eviction_notice
=
eviction_notice
.
cloned
(
)
;
entry
.
uv_rect_kind
=
uv_rect_kind
;
gpu_cache
.
invalidate
(
&
entry
.
uv_rect_handle
)
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
if
let
Some
(
data
)
=
data
{
let
origin
=
entry
.
details
.
describe
(
)
;
let
texture_id
=
entry
.
texture_id
;
let
size
=
entry
.
size
;
let
use_upload_format
=
self
.
swizzle
.
is_none
(
)
;
let
op
=
TextureCacheUpdate
:
:
new_update
(
data
&
descriptor
origin
size
use_upload_format
&
dirty_rect
)
;
self
.
pending_updates
.
push_update
(
texture_id
op
)
;
}
}
pub
fn
is_allocated
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
bool
{
self
.
get_entry_opt
(
handle
)
.
is_some
(
)
}
pub
fn
get_allocated_size
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
usize
>
{
self
.
get_entry_opt
(
handle
)
.
map
(
|
entry
|
{
(
entry
.
input_format
.
bytes_per_pixel
(
)
*
entry
.
size
.
area
(
)
)
as
usize
}
)
}
pub
fn
get
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
CacheItem
{
let
(
texture_id
uv_rect
swizzle
uv_rect_handle
user_data
)
=
self
.
get_cache_location
(
handle
)
;
CacheItem
{
uv_rect_handle
texture_id
:
TextureSource
:
:
TextureCache
(
texture_id
swizzle
)
uv_rect
user_data
}
}
pub
fn
try_get
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
CacheItem
>
{
let
(
texture_id
uv_rect
swizzle
uv_rect_handle
user_data
)
=
self
.
try_get_cache_location
(
handle
)
?
;
Some
(
CacheItem
{
uv_rect_handle
texture_id
:
TextureSource
:
:
TextureCache
(
texture_id
swizzle
)
uv_rect
user_data
}
)
}
pub
fn
try_get_cache_location
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
(
CacheTextureId
DeviceIntRect
Swizzle
GpuCacheHandle
[
f32
;
4
]
)
>
{
let
entry
=
self
.
get_entry_opt
(
handle
)
?
;
let
origin
=
entry
.
details
.
describe
(
)
;
Some
(
(
entry
.
texture_id
DeviceIntRect
:
:
from_origin_and_size
(
origin
entry
.
size
)
entry
.
swizzle
entry
.
uv_rect_handle
entry
.
user_data
)
)
}
pub
fn
get_cache_location
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
(
CacheTextureId
DeviceIntRect
Swizzle
GpuCacheHandle
[
f32
;
4
]
)
{
self
.
try_get_cache_location
(
handle
)
.
expect
(
"
BUG
:
was
dropped
from
cache
or
not
updated
!
"
)
}
fn
evict_impl
(
&
mut
self
entry
:
CacheEntry
)
{
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
}
pub
fn
evict_handle
(
&
mut
self
handle
:
&
TextureCacheHandle
)
{
match
handle
{
TextureCacheHandle
:
:
Manual
(
handle
)
=
>
{
let
index
=
self
.
manual_handles
.
iter
(
)
.
position
(
|
strong_handle
|
{
strong_handle
.
matches
(
handle
)
}
)
;
if
let
Some
(
index
)
=
index
{
let
handle
=
self
.
manual_handles
.
swap_remove
(
index
)
;
let
entry
=
self
.
manual_entries
.
free
(
handle
)
;
self
.
evict_impl
(
entry
)
;
}
}
TextureCacheHandle
:
:
Auto
(
handle
)
=
>
{
if
let
Some
(
entry
)
=
self
.
lru_cache
.
remove
(
handle
)
{
self
.
evict_impl
(
entry
)
;
}
}
_
=
>
{
}
}
}
pub
fn
dump_color8_linear_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
color8_linear
.
dump_as_svg
(
output
)
}
pub
fn
dump_color8_glyphs_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
color8_glyphs
.
dump_as_svg
(
output
)
}
pub
fn
dump_alpha8_glyphs_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
alpha8_glyphs
.
dump_as_svg
(
output
)
}
pub
fn
dump_alpha8_linear_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
alpha8_linear
.
dump_as_svg
(
output
)
}
fn
get_eviction_threshold
(
&
self
budget_type
:
BudgetType
)
-
>
usize
{
if
budget_type
=
=
BudgetType
:
:
Standalone
{
return
8
*
1024
*
1024
;
}
let
bytes_per_texture
=
self
.
shared_textures
.
bytes_per_shared_texture
(
budget_type
)
;
let
ideal_utilization
=
match
budget_type
{
BudgetType
:
:
SharedAlpha8Glyphs
|
BudgetType
:
:
SharedColor8Glyphs
=
>
{
bytes_per_texture
*
2
/
3
}
_
=
>
{
bytes_per_texture
/
3
}
}
;
ideal_utilization
}
fn
should_continue_evicting
(
&
self
budget_type
:
BudgetType
eviction_count
:
usize
)
-
>
Option
<
u64
>
{
let
threshold
=
self
.
get_eviction_threshold
(
budget_type
)
;
let
bytes_allocated
=
self
.
bytes_allocated
[
budget_type
as
usize
]
;
let
uses_multiple_atlases
=
self
.
shared_textures
.
has_multiple_textures
(
budget_type
)
;
if
bytes_allocated
<
threshold
&
&
!
uses_multiple_atlases
{
return
None
;
}
let
age_theshold
=
match
bytes_allocated
/
threshold
{
0
=
>
400
1
=
>
200
2
=
>
100
3
=
>
50
4
=
>
25
5
=
>
10
6
=
>
5
_
=
>
1
}
;
if
bytes_allocated
>
4
*
threshold
{
return
Some
(
age_theshold
)
;
}
if
eviction_count
<
Self
:
:
MAX_EVICTIONS_PER_FRAME
{
return
Some
(
age_theshold
)
}
None
}
fn
evict_items_from_cache_if_required
(
&
mut
self
profile
:
&
mut
TransactionProfile
)
{
let
previous_frame_id
=
self
.
now
.
frame_id
(
)
-
1
;
let
mut
eviction_count
=
0
;
let
mut
youngest_evicted
=
FrameId
:
:
first
(
)
;
for
budget
in
BudgetType
:
:
iter
(
)
{
while
let
Some
(
age_threshold
)
=
self
.
should_continue_evicting
(
budget
eviction_count
)
{
if
let
Some
(
entry
)
=
self
.
lru_cache
.
peek_oldest
(
budget
as
u8
)
{
if
entry
.
last_access
.
frame_id
(
)
+
age_threshold
>
previous_frame_id
{
break
;
}
if
entry
.
last_access
.
frame_id
(
)
>
youngest_evicted
{
youngest_evicted
=
entry
.
last_access
.
frame_id
(
)
;
}
let
entry
=
self
.
lru_cache
.
pop_oldest
(
budget
as
u8
)
.
unwrap
(
)
;
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
eviction_count
+
=
1
;
}
else
{
break
;
}
}
}
if
eviction_count
>
0
{
profile
.
set
(
profiler
:
:
TEXTURE_CACHE_EVICTION_COUNT
eviction_count
)
;
profile
.
set
(
profiler
:
:
TEXTURE_CACHE_YOUNGEST_EVICTION
self
.
now
.
frame_id
(
)
.
as_u64
(
)
-
youngest_evicted
.
as_u64
(
)
)
;
}
}
fn
free
(
&
mut
self
entry
:
&
CacheEntry
)
{
match
entry
.
details
{
EntryDetails
:
:
Standalone
{
size_in_bytes
.
.
}
=
>
{
self
.
bytes_allocated
[
BudgetType
:
:
Standalone
as
usize
]
-
=
size_in_bytes
;
self
.
pending_updates
.
push_free
(
entry
.
texture_id
)
;
}
EntryDetails
:
:
Cache
{
origin
alloc_id
allocated_size_in_bytes
}
=
>
{
let
(
allocator_list
budget_type
)
=
self
.
shared_textures
.
select
(
entry
.
input_format
entry
.
filter
entry
.
shader
)
;
allocator_list
.
deallocate
(
entry
.
texture_id
alloc_id
)
;
self
.
bytes_allocated
[
budget_type
as
usize
]
-
=
allocated_size_in_bytes
;
if
self
.
debug_flags
.
contains
(
DebugFlags
:
:
TEXTURE_CACHE_DBG
|
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
{
self
.
pending_updates
.
push_debug_clear
(
entry
.
texture_id
origin
entry
.
size
.
width
entry
.
size
.
height
)
;
}
}
}
}
fn
allocate_from_shared_cache
(
&
mut
self
params
:
&
CacheAllocParams
)
-
>
(
CacheEntry
BudgetType
)
{
let
(
allocator_list
budget_type
)
=
self
.
shared_textures
.
select
(
params
.
descriptor
.
format
params
.
filter
params
.
shader
)
;
let
next_id
=
&
mut
self
.
next_id
;
let
pending_updates
=
&
mut
self
.
pending_updates
;
let
(
texture_id
alloc_id
allocated_rect
)
=
allocator_list
.
allocate
(
params
.
descriptor
.
size
&
mut
|
size
parameters
|
{
let
texture_id
=
*
next_id
;
next_id
.
0
+
=
1
;
pending_updates
.
push_alloc
(
texture_id
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
size
.
width
height
:
size
.
height
format
:
parameters
.
formats
.
internal
filter
:
parameters
.
filter
is_shared_cache
:
true
has_depth
:
false
category
:
TextureCacheCategory
:
:
Atlas
}
)
;
texture_id
}
)
;
let
formats
=
&
allocator_list
.
texture_parameters
(
)
.
formats
;
let
swizzle
=
if
formats
.
external
=
=
params
.
descriptor
.
format
{
Swizzle
:
:
default
(
)
}
else
{
match
self
.
swizzle
{
Some
(
_
)
=
>
Swizzle
:
:
Bgra
None
=
>
Swizzle
:
:
default
(
)
}
}
;
let
bpp
=
formats
.
internal
.
bytes_per_pixel
(
)
;
let
allocated_size_in_bytes
=
(
allocated_rect
.
area
(
)
*
bpp
)
as
usize
;
self
.
bytes_allocated
[
budget_type
as
usize
]
+
=
allocated_size_in_bytes
;
(
CacheEntry
{
size
:
params
.
descriptor
.
size
user_data
:
params
.
user_data
last_access
:
self
.
now
details
:
EntryDetails
:
:
Cache
{
origin
:
allocated_rect
.
min
alloc_id
allocated_size_in_bytes
}
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
input_format
:
params
.
descriptor
.
format
filter
:
params
.
filter
swizzle
texture_id
eviction_notice
:
None
uv_rect_kind
:
params
.
uv_rect_kind
shader
:
params
.
shader
}
budget_type
)
}
pub
fn
is_allowed_in_shared_cache
(
&
self
filter
:
TextureFilter
descriptor
:
&
ImageDescriptor
)
-
>
bool
{
let
mut
allowed_in_shared_cache
=
true
;
if
matches
!
(
descriptor
.
format
ImageFormat
:
:
RGBA8
|
ImageFormat
:
:
BGRA8
)
&
&
filter
=
=
TextureFilter
:
:
Linear
{
let
max
=
self
.
shared_textures
.
color8_linear
.
size
(
)
/
2
;
allowed_in_shared_cache
=
descriptor
.
size
.
width
.
max
(
descriptor
.
size
.
height
)
<
=
max
;
}
else
if
descriptor
.
size
.
width
>
TEXTURE_REGION_DIMENSIONS
{
allowed_in_shared_cache
=
false
;
}
if
descriptor
.
size
.
height
>
TEXTURE_REGION_DIMENSIONS
{
allowed_in_shared_cache
=
false
;
}
if
filter
=
=
TextureFilter
:
:
Nearest
&
&
descriptor
.
format
.
bytes_per_pixel
(
)
<
=
2
{
allowed_in_shared_cache
=
false
;
}
allowed_in_shared_cache
}
pub
fn
alloc_render_target
(
&
mut
self
size
:
DeviceIntSize
format
:
ImageFormat
)
-
>
CacheTextureId
{
let
texture_id
=
self
.
next_id
;
self
.
next_id
.
0
+
=
1
;
let
info
=
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
size
.
width
height
:
size
.
height
format
filter
:
TextureFilter
:
:
Linear
is_shared_cache
:
false
has_depth
:
false
category
:
TextureCacheCategory
:
:
RenderTarget
}
;
self
.
pending_updates
.
push_alloc
(
texture_id
info
)
;
texture_id
}
pub
fn
free_render_target
(
&
mut
self
id
:
CacheTextureId
)
{
self
.
pending_updates
.
push_free
(
id
)
;
}
fn
allocate_standalone_entry
(
&
mut
self
params
:
&
CacheAllocParams
)
-
>
(
CacheEntry
BudgetType
)
{
let
texture_id
=
self
.
next_id
;
self
.
next_id
.
0
+
=
1
;
let
info
=
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
params
.
descriptor
.
size
.
width
height
:
params
.
descriptor
.
size
.
height
format
:
params
.
descriptor
.
format
filter
:
params
.
filter
is_shared_cache
:
false
has_depth
:
false
category
:
TextureCacheCategory
:
:
Standalone
}
;
let
size_in_bytes
=
(
info
.
width
*
info
.
height
*
info
.
format
.
bytes_per_pixel
(
)
)
as
usize
;
self
.
bytes_allocated
[
BudgetType
:
:
Standalone
as
usize
]
+
=
size_in_bytes
;
self
.
pending_updates
.
push_alloc
(
texture_id
info
)
;
let
swizzle
=
if
params
.
descriptor
.
format
=
=
ImageFormat
:
:
BGRA8
{
self
.
swizzle
.
map
(
|
s
|
s
.
bgra8_sampling_swizzle
)
}
else
{
None
}
;
(
CacheEntry
:
:
new_standalone
(
texture_id
self
.
now
params
swizzle
.
unwrap_or_default
(
)
size_in_bytes
)
BudgetType
:
:
Standalone
)
}
fn
allocate
(
&
mut
self
params
:
&
CacheAllocParams
handle
:
&
mut
TextureCacheHandle
eviction
:
Eviction
force_standalone_texture
:
bool
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
assert
!
(
!
params
.
descriptor
.
size
.
is_empty
(
)
)
;
let
use_shared_cache
=
!
force_standalone_texture
&
&
self
.
is_allowed_in_shared_cache
(
params
.
filter
&
params
.
descriptor
)
;
let
(
new_cache_entry
budget_type
)
=
if
use_shared_cache
{
self
.
allocate_from_shared_cache
(
params
)
}
else
{
self
.
allocate_standalone_entry
(
params
)
}
;
let
details
=
new_cache_entry
.
details
.
clone
(
)
;
let
texture_id
=
new_cache_entry
.
texture_id
;
let
old_entry
=
match
(
&
mut
*
handle
eviction
)
{
(
TextureCacheHandle
:
:
Auto
(
handle
)
Eviction
:
:
Auto
)
=
>
{
self
.
lru_cache
.
replace_or_insert
(
handle
budget_type
as
u8
new_cache_entry
)
}
(
TextureCacheHandle
:
:
Manual
(
handle
)
Eviction
:
:
Manual
)
=
>
{
let
entry
=
self
.
manual_entries
.
get_opt_mut
(
handle
)
.
expect
(
"
Don
'
t
call
this
after
evicting
"
)
;
Some
(
mem
:
:
replace
(
entry
new_cache_entry
)
)
}
(
TextureCacheHandle
:
:
Manual
(
_
)
Eviction
:
:
Auto
)
|
(
TextureCacheHandle
:
:
Auto
(
_
)
Eviction
:
:
Manual
)
=
>
{
panic
!
(
"
Can
'
t
change
eviction
policy
after
initial
allocation
"
)
;
}
(
TextureCacheHandle
:
:
Empty
Eviction
:
:
Auto
)
=
>
{
let
new_handle
=
self
.
lru_cache
.
push_new
(
budget_type
as
u8
new_cache_entry
)
;
*
handle
=
TextureCacheHandle
:
:
Auto
(
new_handle
)
;
None
}
(
TextureCacheHandle
:
:
Empty
Eviction
:
:
Manual
)
=
>
{
let
manual_handle
=
self
.
manual_entries
.
insert
(
new_cache_entry
)
;
let
new_handle
=
manual_handle
.
weak
(
)
;
self
.
manual_handles
.
push
(
manual_handle
)
;
*
handle
=
TextureCacheHandle
:
:
Manual
(
new_handle
)
;
None
}
}
;
if
let
Some
(
old_entry
)
=
old_entry
{
old_entry
.
evict
(
)
;
self
.
free
(
&
old_entry
)
;
}
if
let
EntryDetails
:
:
Cache
{
alloc_id
.
.
}
=
details
{
let
allocator_list
=
self
.
shared_textures
.
select
(
params
.
descriptor
.
format
params
.
filter
params
.
shader
)
.
0
;
allocator_list
.
set_handle
(
texture_id
alloc_id
handle
)
;
}
}
pub
fn
shared_alpha_expected_format
(
&
self
)
-
>
ImageFormat
{
self
.
shared_textures
.
alpha8_linear
.
texture_parameters
(
)
.
formats
.
external
}
pub
fn
shared_color_expected_format
(
&
self
)
-
>
ImageFormat
{
self
.
shared_textures
.
color8_linear
.
texture_parameters
(
)
.
formats
.
external
}
#
[
cfg
(
test
)
]
pub
fn
total_allocated_bytes_for_testing
(
&
self
)
-
>
usize
{
BudgetType
:
:
iter
(
)
.
map
(
|
b
|
self
.
bytes_allocated
[
b
as
usize
]
)
.
sum
(
)
}
pub
fn
report_memory
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
lru_cache
.
size_of
(
ops
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureParameters
{
pub
formats
:
TextureFormatPair
<
ImageFormat
>
pub
filter
:
TextureFilter
}
impl
TextureCacheUpdate
{
fn
new_update
(
data
:
CachedImageData
descriptor
:
&
ImageDescriptor
origin
:
DeviceIntPoint
size
:
DeviceIntSize
use_upload_format
:
bool
dirty_rect
:
&
ImageDirtyRect
)
-
>
TextureCacheUpdate
{
let
source
=
match
data
{
CachedImageData
:
:
Snapshot
=
>
{
panic
!
(
"
Snapshots
should
not
do
texture
uploads
"
)
;
}
CachedImageData
:
:
Blob
=
>
{
panic
!
(
"
The
vector
image
should
have
been
rasterized
.
"
)
;
}
CachedImageData
:
:
External
(
ext_image
)
=
>
match
ext_image
.
image_type
{
ExternalImageType
:
:
TextureHandle
(
_
)
=
>
{
panic
!
(
"
External
texture
handle
should
not
go
through
texture_cache
.
"
)
;
}
ExternalImageType
:
:
Buffer
=
>
TextureUpdateSource
:
:
External
{
id
:
ext_image
.
id
channel_index
:
ext_image
.
channel_index
}
}
CachedImageData
:
:
Raw
(
bytes
)
=
>
{
let
finish
=
descriptor
.
offset
+
descriptor
.
size
.
width
*
descriptor
.
format
.
bytes_per_pixel
(
)
+
(
descriptor
.
size
.
height
-
1
)
*
descriptor
.
compute_stride
(
)
;
assert
!
(
bytes
.
len
(
)
>
=
finish
as
usize
)
;
TextureUpdateSource
:
:
Bytes
{
data
:
bytes
}
}
}
;
let
format_override
=
if
use_upload_format
{
Some
(
descriptor
.
format
)
}
else
{
None
}
;
match
*
dirty_rect
{
DirtyRect
:
:
Partial
(
dirty
)
=
>
{
let
stride
=
descriptor
.
compute_stride
(
)
;
let
offset
=
descriptor
.
offset
+
dirty
.
min
.
y
*
stride
+
dirty
.
min
.
x
*
descriptor
.
format
.
bytes_per_pixel
(
)
;
TextureCacheUpdate
{
rect
:
DeviceIntRect
:
:
from_origin_and_size
(
DeviceIntPoint
:
:
new
(
origin
.
x
+
dirty
.
min
.
x
origin
.
y
+
dirty
.
min
.
y
)
DeviceIntSize
:
:
new
(
dirty
.
width
(
)
.
min
(
size
.
width
-
dirty
.
min
.
x
)
dirty
.
height
(
)
.
min
(
size
.
height
-
dirty
.
min
.
y
)
)
)
source
stride
:
Some
(
stride
)
offset
format_override
}
}
DirtyRect
:
:
All
=
>
{
TextureCacheUpdate
{
rect
:
DeviceIntRect
:
:
from_origin_and_size
(
origin
size
)
source
stride
:
descriptor
.
stride
offset
:
descriptor
.
offset
format_override
}
}
}
}
}
#
[
cfg
(
test
)
]
mod
test_texture_cache
{
#
[
test
]
fn
check_allocation_size_balance
(
)
{
use
crate
:
:
texture_cache
:
:
{
TextureCache
TextureCacheHandle
Eviction
TargetShader
}
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
device
:
:
TextureFilter
;
use
crate
:
:
gpu_types
:
:
UvRectKind
;
use
api
:
:
{
ImageDescriptor
ImageDescriptorFlags
ImageFormat
DirtyRect
}
;
use
api
:
:
units
:
:
*
;
use
euclid
:
:
size2
;
let
mut
texture_cache
=
TextureCache
:
:
new_for_testing
(
2048
ImageFormat
:
:
BGRA8
)
;
let
mut
gpu_cache
=
GpuCache
:
:
new_for_testing
(
)
;
let
sizes
:
&
[
DeviceIntSize
]
=
&
[
size2
(
23
27
)
size2
(
15
22
)
size2
(
11
5
)
size2
(
20
25
)
size2
(
38
41
)
size2
(
11
19
)
size2
(
13
21
)
size2
(
37
40
)
size2
(
13
15
)
size2
(
14
16
)
size2
(
10
9
)
size2
(
25
28
)
]
;
let
bytes_at_start
=
texture_cache
.
total_allocated_bytes_for_testing
(
)
;
let
handles
:
Vec
<
TextureCacheHandle
>
=
sizes
.
iter
(
)
.
map
(
|
size
|
{
let
mut
texture_cache_handle
=
TextureCacheHandle
:
:
invalid
(
)
;
texture_cache
.
request
(
&
texture_cache_handle
&
mut
gpu_cache
)
;
texture_cache
.
update
(
&
mut
texture_cache_handle
ImageDescriptor
{
size
:
*
size
stride
:
None
format
:
ImageFormat
:
:
BGRA8
flags
:
ImageDescriptorFlags
:
:
empty
(
)
offset
:
0
}
TextureFilter
:
:
Linear
None
[
0
.
0
;
4
]
DirtyRect
:
:
All
&
mut
gpu_cache
None
UvRectKind
:
:
Rect
Eviction
:
:
Manual
TargetShader
:
:
Text
false
)
;
texture_cache_handle
}
)
.
collect
(
)
;
let
bytes_after_allocating
=
texture_cache
.
total_allocated_bytes_for_testing
(
)
;
assert
!
(
bytes_after_allocating
>
bytes_at_start
)
;
for
handle
in
handles
{
texture_cache
.
evict_handle
(
&
handle
)
;
}
let
bytes_at_end
=
texture_cache
.
total_allocated_bytes_for_testing
(
)
;
assert_eq
!
(
bytes_at_end
bytes_at_start
)
;
}
}
