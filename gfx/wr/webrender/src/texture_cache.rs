use
api
:
:
{
DirtyRect
ExternalImageType
ImageFormat
ImageBufferKind
}
;
use
api
:
:
{
DebugFlags
ImageDescriptor
}
;
use
api
:
:
units
:
:
*
;
#
[
cfg
(
test
)
]
use
api
:
:
{
DocumentId
IdNamespace
}
;
use
euclid
:
:
{
point2
size2
}
;
use
crate
:
:
device
:
:
{
TextureFilter
TextureFormatPair
}
;
use
crate
:
:
freelist
:
:
{
FreeListHandle
WeakFreeListHandle
}
;
use
crate
:
:
gpu_cache
:
:
{
GpuCache
GpuCacheHandle
}
;
use
crate
:
:
gpu_types
:
:
{
ImageSource
UvRectKind
}
;
use
crate
:
:
internal_types
:
:
{
CacheTextureId
LayerIndex
Swizzle
SwizzleSettings
TextureUpdateList
TextureUpdateSource
TextureSource
TextureCacheAllocInfo
TextureCacheUpdate
}
;
use
crate
:
:
lru_cache
:
:
LRUCache
;
use
crate
:
:
profiler
:
:
{
self
TransactionProfile
}
;
use
crate
:
:
render_backend
:
:
FrameStamp
;
use
crate
:
:
resource_cache
:
:
{
CacheItem
CachedImageData
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
cmp
;
use
std
:
:
mem
;
use
std
:
:
rc
:
:
Rc
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TargetShader
{
Default
Text
}
pub
const
TEXTURE_REGION_DIMENSIONS
:
i32
=
512
;
pub
const
GLYPH_TEXTURE_REGION_DIMENSIONS
:
i32
=
128
;
const
PICTURE_TEXTURE_SLICE_COUNT
:
usize
=
8
;
const
PICTURE_TILE_FORMAT
:
ImageFormat
=
ImageFormat
:
:
RGBA8
;
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
enum
EntryDetails
{
Standalone
{
size_in_bytes
:
usize
}
Picture
{
texture_index
:
usize
layer_index
:
usize
}
Cache
{
origin
:
DeviceIntPoint
region_index
:
usize
}
}
impl
EntryDetails
{
fn
describe
(
&
self
)
-
>
(
LayerIndex
DeviceIntPoint
)
{
match
*
self
{
EntryDetails
:
:
Standalone
{
.
.
}
=
>
(
0
DeviceIntPoint
:
:
zero
(
)
)
EntryDetails
:
:
Picture
{
layer_index
.
.
}
=
>
(
layer_index
DeviceIntPoint
:
:
zero
(
)
)
EntryDetails
:
:
Cache
{
origin
.
.
}
=
>
(
0
origin
)
}
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
CacheEntryMarker
{
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
CacheEntry
{
size
:
DeviceIntSize
details
:
EntryDetails
user_data
:
[
f32
;
3
]
last_access
:
FrameStamp
uv_rect_handle
:
GpuCacheHandle
input_format
:
ImageFormat
filter
:
TextureFilter
swizzle
:
Swizzle
texture_id
:
CacheTextureId
eviction_notice
:
Option
<
EvictionNotice
>
uv_rect_kind
:
UvRectKind
shader
:
TargetShader
}
impl
CacheEntry
{
fn
new_standalone
(
texture_id
:
CacheTextureId
last_access
:
FrameStamp
params
:
&
CacheAllocParams
swizzle
:
Swizzle
size_in_bytes
:
usize
)
-
>
Self
{
CacheEntry
{
size
:
params
.
descriptor
.
size
user_data
:
params
.
user_data
last_access
details
:
EntryDetails
:
:
Standalone
{
size_in_bytes
}
texture_id
input_format
:
params
.
descriptor
.
format
filter
:
params
.
filter
swizzle
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
eviction_notice
:
None
uv_rect_kind
:
params
.
uv_rect_kind
shader
:
TargetShader
:
:
Default
}
}
fn
update_gpu_cache
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
)
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
uv_rect_handle
)
{
let
(
layer_index
origin
)
=
self
.
details
.
describe
(
)
;
let
image_source
=
ImageSource
{
p0
:
origin
.
to_f32
(
)
p1
:
(
origin
+
self
.
size
)
.
to_f32
(
)
texture_layer
:
layer_index
as
f32
user_data
:
self
.
user_data
uv_rect_kind
:
self
.
uv_rect_kind
}
;
image_source
.
write_gpu_blocks
(
&
mut
request
)
;
}
}
fn
evict
(
&
self
)
{
if
let
Some
(
eviction_notice
)
=
self
.
eviction_notice
.
as_ref
(
)
{
eviction_notice
.
notify
(
)
;
}
}
fn
alternative_input_format
(
&
self
)
-
>
ImageFormat
{
match
self
.
input_format
{
ImageFormat
:
:
RGBA8
=
>
ImageFormat
:
:
BGRA8
ImageFormat
:
:
BGRA8
=
>
ImageFormat
:
:
RGBA8
other
=
>
other
}
}
}
pub
type
TextureCacheHandle
=
WeakFreeListHandle
<
CacheEntryMarker
>
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Eviction
{
Auto
Manual
}
#
[
derive
(
Clone
Debug
Default
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
EvictionNotice
{
evicted
:
Rc
<
Cell
<
bool
>
>
}
impl
EvictionNotice
{
fn
notify
(
&
self
)
{
self
.
evicted
.
set
(
true
)
;
}
pub
fn
check
(
&
self
)
-
>
bool
{
if
self
.
evicted
.
get
(
)
{
self
.
evicted
.
set
(
false
)
;
true
}
else
{
false
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
SharedTextures
{
color8_nearest
:
TextureUnits
alpha8_linear
:
TextureUnits
alpha16_linear
:
TextureUnits
color8_linear
:
TextureUnits
color8_glyphs
:
TextureUnits
}
impl
SharedTextures
{
fn
new
(
color_formats
:
TextureFormatPair
<
ImageFormat
>
)
-
>
Self
{
Self
{
alpha8_linear
:
TextureUnits
:
:
new
(
TextureFormatPair
:
:
from
(
ImageFormat
:
:
R8
)
TextureFilter
:
:
Linear
1024
TEXTURE_REGION_DIMENSIONS
SlabSizes
:
:
Default
)
alpha16_linear
:
TextureUnits
:
:
new
(
TextureFormatPair
:
:
from
(
ImageFormat
:
:
R16
)
TextureFilter
:
:
Linear
TEXTURE_REGION_DIMENSIONS
TEXTURE_REGION_DIMENSIONS
SlabSizes
:
:
Default
)
color8_linear
:
TextureUnits
:
:
new
(
color_formats
.
clone
(
)
TextureFilter
:
:
Linear
2048
TEXTURE_REGION_DIMENSIONS
SlabSizes
:
:
Default
)
color8_glyphs
:
TextureUnits
:
:
new
(
color_formats
.
clone
(
)
TextureFilter
:
:
Linear
2048
GLYPH_TEXTURE_REGION_DIMENSIONS
SlabSizes
:
:
Glyphs
)
color8_nearest
:
TextureUnits
:
:
new
(
color_formats
TextureFilter
:
:
Nearest
TEXTURE_REGION_DIMENSIONS
TEXTURE_REGION_DIMENSIONS
SlabSizes
:
:
Default
)
}
}
fn
clear
(
&
mut
self
updates
:
&
mut
TextureUpdateList
)
{
self
.
alpha8_linear
.
clear
(
updates
)
;
self
.
alpha16_linear
.
clear
(
updates
)
;
self
.
color8_linear
.
clear
(
updates
)
;
self
.
color8_nearest
.
clear
(
updates
)
;
self
.
color8_glyphs
.
clear
(
updates
)
;
}
fn
select
(
&
mut
self
size
:
DeviceIntSize
external_format
:
ImageFormat
filter
:
TextureFilter
shader
:
TargetShader
)
-
>
&
mut
TextureUnits
{
match
external_format
{
ImageFormat
:
:
R8
=
>
{
assert_eq
!
(
filter
TextureFilter
:
:
Linear
)
;
&
mut
self
.
alpha8_linear
}
ImageFormat
:
:
R16
=
>
{
assert_eq
!
(
filter
TextureFilter
:
:
Linear
)
;
&
mut
self
.
alpha16_linear
}
ImageFormat
:
:
RGBA8
|
ImageFormat
:
:
BGRA8
=
>
{
let
max
=
size
.
width
.
max
(
size
.
height
)
;
match
(
filter
shader
)
{
(
TextureFilter
:
:
Linear
TargetShader
:
:
Text
)
if
max
<
=
GLYPH_TEXTURE_REGION_DIMENSIONS
=
>
{
&
mut
self
.
color8_glyphs
}
(
TextureFilter
:
:
Linear
_
)
=
>
&
mut
self
.
color8_linear
(
TextureFilter
:
:
Nearest
_
)
=
>
&
mut
self
.
color8_nearest
_
=
>
panic
!
(
"
Unexpexcted
filter
{
:
?
}
"
filter
)
}
}
_
=
>
panic
!
(
"
Unexpected
format
{
:
?
}
"
external_format
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
PictureTextures
{
textures
:
Vec
<
WholeTextureArray
>
default_tile_size
:
DeviceIntSize
}
impl
PictureTextures
{
fn
new
(
default_tile_size
:
DeviceIntSize
)
-
>
Self
{
PictureTextures
{
textures
:
Vec
:
:
new
(
)
default_tile_size
}
}
fn
get_or_allocate_tile
(
&
mut
self
tile_size
:
DeviceIntSize
now
:
FrameStamp
next_texture_id
:
&
mut
CacheTextureId
pending_updates
:
&
mut
TextureUpdateList
)
-
>
CacheEntry
{
for
(
i
texture
)
in
self
.
textures
.
iter_mut
(
)
.
enumerate
(
)
{
if
texture
.
size
=
=
tile_size
{
if
let
Some
(
layer_index
)
=
texture
.
find_free
(
)
{
return
texture
.
occupy
(
i
layer_index
now
)
;
}
}
}
let
mut
slices
=
Vec
:
:
new
(
)
;
for
_
in
0
.
.
PICTURE_TEXTURE_SLICE_COUNT
{
slices
.
push
(
WholeTextureSlice
{
uv_rect_handle
:
None
}
)
;
}
let
mut
texture
=
WholeTextureArray
{
size
:
tile_size
filter
:
TextureFilter
:
:
Nearest
format
:
PICTURE_TILE_FORMAT
texture_id
:
*
next_texture_id
slices
has_depth
:
true
}
;
next_texture_id
.
0
+
=
1
;
let
entry
=
texture
.
occupy
(
self
.
textures
.
len
(
)
0
now
)
;
let
info
=
texture
.
to_info
(
)
;
pending_updates
.
push_alloc
(
texture
.
texture_id
info
)
;
self
.
textures
.
push
(
texture
)
;
entry
}
fn
get
(
&
mut
self
index
:
usize
)
-
>
&
mut
WholeTextureArray
{
&
mut
self
.
textures
[
index
]
}
fn
clear
(
&
mut
self
pending_updates
:
&
mut
TextureUpdateList
)
{
for
texture
in
self
.
textures
.
drain
(
.
.
)
{
pending_updates
.
push_free
(
texture
.
texture_id
)
;
}
}
fn
update_profile
(
&
self
profile
:
&
mut
TransactionProfile
)
{
let
mut
picture_slices
=
0
;
let
mut
picture_bytes
=
0
;
for
texture
in
&
self
.
textures
{
picture_slices
+
=
texture
.
slices
.
len
(
)
;
picture_bytes
+
=
texture
.
size_in_bytes
(
)
;
}
profile
.
set
(
profiler
:
:
PICTURE_TILES
picture_slices
)
;
profile
.
set
(
profiler
:
:
PICTURE_TILES_MEM
profiler
:
:
bytes_to_mb
(
picture_bytes
)
)
;
}
}
struct
CacheAllocParams
{
descriptor
:
ImageDescriptor
filter
:
TextureFilter
user_data
:
[
f32
;
3
]
uv_rect_kind
:
UvRectKind
shader
:
TargetShader
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureCache
{
shared_textures
:
SharedTextures
picture_textures
:
PictureTextures
max_texture_size
:
i32
swizzle
:
Option
<
SwizzleSettings
>
debug_flags
:
DebugFlags
next_id
:
CacheTextureId
#
[
cfg_attr
(
all
(
feature
=
"
serde
"
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
)
serde
(
skip
)
)
]
pending_updates
:
TextureUpdateList
now
:
FrameStamp
picture_cache_handles
:
Vec
<
FreeListHandle
<
CacheEntryMarker
>
>
lru_cache
:
LRUCache
<
CacheEntry
CacheEntryMarker
>
manual_handles
:
Vec
<
FreeListHandle
<
CacheEntryMarker
>
>
shared_bytes_allocated
:
usize
standalone_bytes_allocated
:
usize
}
impl
TextureCache
{
const
EVICTION_THRESHOLD_SIZE
:
usize
=
64
*
1024
*
1024
;
const
MAX_EVICTIONS_PER_FRAME
:
usize
=
32
;
pub
fn
new
(
max_texture_size
:
i32
default_picture_tile_size
:
DeviceIntSize
color_formats
:
TextureFormatPair
<
ImageFormat
>
swizzle
:
Option
<
SwizzleSettings
>
)
-
>
Self
{
let
pending_updates
=
TextureUpdateList
:
:
new
(
)
;
assert
!
(
color_formats
.
internal
!
=
ImageFormat
:
:
BGRA8
|
|
swizzle
.
map_or
(
true
|
s
|
s
.
bgra8_sampling_swizzle
=
=
Swizzle
:
:
default
(
)
)
)
;
let
next_texture_id
=
CacheTextureId
(
1
)
;
TextureCache
{
shared_textures
:
SharedTextures
:
:
new
(
color_formats
)
picture_textures
:
PictureTextures
:
:
new
(
default_picture_tile_size
)
max_texture_size
swizzle
debug_flags
:
DebugFlags
:
:
empty
(
)
next_id
:
next_texture_id
pending_updates
now
:
FrameStamp
:
:
INVALID
lru_cache
:
LRUCache
:
:
new
(
)
shared_bytes_allocated
:
0
standalone_bytes_allocated
:
0
picture_cache_handles
:
Vec
:
:
new
(
)
manual_handles
:
Vec
:
:
new
(
)
}
}
#
[
cfg
(
test
)
]
pub
fn
new_for_testing
(
max_texture_size
:
i32
image_format
:
ImageFormat
)
-
>
Self
{
let
mut
cache
=
Self
:
:
new
(
max_texture_size
crate
:
:
picture
:
:
TILE_SIZE_DEFAULT
TextureFormatPair
:
:
from
(
image_format
)
None
)
;
let
mut
now
=
FrameStamp
:
:
first
(
DocumentId
:
:
new
(
IdNamespace
(
1
)
1
)
)
;
now
.
advance
(
)
;
cache
.
begin_frame
(
now
)
;
cache
}
pub
fn
set_debug_flags
(
&
mut
self
flags
:
DebugFlags
)
{
self
.
debug_flags
=
flags
;
}
pub
fn
clear_all
(
&
mut
self
)
{
let
manual_handles
=
mem
:
:
replace
(
&
mut
self
.
manual_handles
Vec
:
:
new
(
)
)
;
for
handle
in
manual_handles
{
self
.
evict_impl
(
handle
)
;
}
let
picture_handles
=
mem
:
:
replace
(
&
mut
self
.
picture_cache_handles
Vec
:
:
new
(
)
)
;
for
handle
in
picture_handles
{
self
.
evict_impl
(
handle
)
;
}
while
let
Some
(
entry
)
=
self
.
lru_cache
.
pop_oldest
(
)
{
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
}
self
.
picture_textures
.
clear
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
clear
(
&
mut
self
.
pending_updates
)
;
self
.
pending_updates
.
note_clear
(
)
;
}
pub
fn
begin_frame
(
&
mut
self
stamp
:
FrameStamp
)
{
debug_assert
!
(
!
self
.
now
.
is_valid
(
)
)
;
profile_scope
!
(
"
begin_frame
"
)
;
self
.
now
=
stamp
;
self
.
evict_items_from_cache_if_required
(
)
;
}
pub
fn
end_frame
(
&
mut
self
profile
:
&
mut
TransactionProfile
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
self
.
expire_old_picture_cache_tiles
(
)
;
self
.
shared_textures
.
alpha8_linear
.
release_empty_textures
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
alpha16_linear
.
release_empty_textures
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
color8_linear
.
release_empty_textures
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
color8_nearest
.
release_empty_textures
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
color8_glyphs
.
release_empty_textures
(
&
mut
self
.
pending_updates
)
;
self
.
shared_textures
.
alpha8_linear
.
update_profile
(
profiler
:
:
TEXTURE_CACHE_A8_REGIONS
profiler
:
:
TEXTURE_CACHE_A8_MEM
profile
)
;
self
.
shared_textures
.
alpha16_linear
.
update_profile
(
profiler
:
:
TEXTURE_CACHE_A16_REGIONS
profiler
:
:
TEXTURE_CACHE_A16_MEM
profile
)
;
self
.
shared_textures
.
color8_linear
.
update_profile
(
profiler
:
:
TEXTURE_CACHE_RGBA8_LINEAR_REGIONS
profiler
:
:
TEXTURE_CACHE_RGBA8_LINEAR_MEM
profile
)
;
self
.
shared_textures
.
color8_nearest
.
update_profile
(
profiler
:
:
TEXTURE_CACHE_RGBA8_NEAREST_REGIONS
profiler
:
:
TEXTURE_CACHE_RGBA8_NEAREST_MEM
profile
)
;
self
.
shared_textures
.
color8_glyphs
.
update_profile
(
profiler
:
:
TEXTURE_CACHE_RGBA8_GLYPHS_REGIONS
profiler
:
:
TEXTURE_CACHE_RGBA8_GLYPHS_MEM
profile
)
;
self
.
picture_textures
.
update_profile
(
profile
)
;
profile
.
set
(
profiler
:
:
TEXTURE_CACHE_SHARED_MEM
self
.
shared_bytes_allocated
)
;
profile
.
set
(
profiler
:
:
TEXTURE_CACHE_STANDALONE_MEM
self
.
standalone_bytes_allocated
)
;
self
.
now
=
FrameStamp
:
:
INVALID
;
}
pub
fn
request
(
&
mut
self
handle
:
&
TextureCacheHandle
gpu_cache
:
&
mut
GpuCache
)
-
>
bool
{
match
self
.
lru_cache
.
touch
(
handle
)
{
Some
(
entry
)
=
>
{
entry
.
last_access
=
self
.
now
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
false
}
None
=
>
true
}
}
pub
fn
needs_upload
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
bool
{
self
.
lru_cache
.
get_opt
(
handle
)
.
is_none
(
)
}
pub
fn
max_texture_size
(
&
self
)
-
>
i32
{
self
.
max_texture_size
}
#
[
cfg
(
feature
=
"
replay
"
)
]
pub
fn
color_formats
(
&
self
)
-
>
TextureFormatPair
<
ImageFormat
>
{
self
.
shared_textures
.
color8_linear
.
formats
.
clone
(
)
}
#
[
cfg
(
feature
=
"
replay
"
)
]
pub
fn
swizzle_settings
(
&
self
)
-
>
Option
<
SwizzleSettings
>
{
self
.
swizzle
}
pub
fn
pending_updates
(
&
mut
self
)
-
>
TextureUpdateList
{
mem
:
:
replace
(
&
mut
self
.
pending_updates
TextureUpdateList
:
:
new
(
)
)
}
pub
fn
update
(
&
mut
self
handle
:
&
mut
TextureCacheHandle
descriptor
:
ImageDescriptor
filter
:
TextureFilter
data
:
Option
<
CachedImageData
>
user_data
:
[
f32
;
3
]
mut
dirty_rect
:
ImageDirtyRect
gpu_cache
:
&
mut
GpuCache
eviction_notice
:
Option
<
&
EvictionNotice
>
uv_rect_kind
:
UvRectKind
eviction
:
Eviction
shader
:
TargetShader
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
let
realloc
=
match
self
.
lru_cache
.
get_opt
(
handle
)
{
Some
(
entry
)
=
>
{
entry
.
size
!
=
descriptor
.
size
|
|
(
entry
.
input_format
!
=
descriptor
.
format
&
&
entry
.
alternative_input_format
(
)
!
=
descriptor
.
format
)
}
None
=
>
{
true
}
}
;
if
realloc
{
let
params
=
CacheAllocParams
{
descriptor
filter
user_data
uv_rect_kind
shader
}
;
self
.
allocate
(
&
params
handle
)
;
dirty_rect
=
DirtyRect
:
:
All
;
}
if
eviction
=
=
Eviction
:
:
Manual
{
if
let
Some
(
manual_handle
)
=
self
.
lru_cache
.
set_manual_eviction
(
handle
)
{
self
.
manual_handles
.
push
(
manual_handle
)
;
}
}
let
entry
=
self
.
lru_cache
.
get_opt_mut
(
handle
)
.
expect
(
"
BUG
:
handle
must
be
valid
now
"
)
;
entry
.
eviction_notice
=
eviction_notice
.
cloned
(
)
;
entry
.
uv_rect_kind
=
uv_rect_kind
;
gpu_cache
.
invalidate
(
&
entry
.
uv_rect_handle
)
;
entry
.
update_gpu_cache
(
gpu_cache
)
;
if
let
Some
(
data
)
=
data
{
let
use_upload_format
=
self
.
swizzle
.
is_none
(
)
;
let
(
_
origin
)
=
entry
.
details
.
describe
(
)
;
let
op
=
TextureCacheUpdate
:
:
new_update
(
data
&
descriptor
origin
entry
.
size
use_upload_format
&
dirty_rect
)
;
self
.
pending_updates
.
push_update
(
entry
.
texture_id
op
)
;
}
}
pub
fn
is_allocated
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
bool
{
self
.
lru_cache
.
get_opt
(
handle
)
.
is_some
(
)
}
pub
fn
is_recently_used
(
&
self
handle
:
&
TextureCacheHandle
margin
:
usize
)
-
>
bool
{
self
.
lru_cache
.
get_opt
(
handle
)
.
map_or
(
false
|
entry
|
{
entry
.
last_access
.
frame_id
(
)
+
margin
>
=
self
.
now
.
frame_id
(
)
}
)
}
pub
fn
get_allocated_size
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
Option
<
usize
>
{
self
.
lru_cache
.
get_opt
(
handle
)
.
map
(
|
entry
|
{
(
entry
.
input_format
.
bytes_per_pixel
(
)
*
entry
.
size
.
area
(
)
)
as
usize
}
)
}
pub
fn
get
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
CacheItem
{
let
(
texture_id
layer_index
uv_rect
swizzle
uv_rect_handle
user_data
)
=
self
.
get_cache_location
(
handle
)
;
CacheItem
{
uv_rect_handle
texture_id
:
TextureSource
:
:
TextureCache
(
texture_id
swizzle
)
uv_rect
texture_layer
:
layer_index
as
i32
user_data
}
}
pub
fn
get_cache_location
(
&
self
handle
:
&
TextureCacheHandle
)
-
>
(
CacheTextureId
LayerIndex
DeviceIntRect
Swizzle
GpuCacheHandle
[
f32
;
3
]
)
{
let
entry
=
self
.
lru_cache
.
get_opt
(
handle
)
.
expect
(
"
BUG
:
was
dropped
from
cache
or
not
updated
!
"
)
;
debug_assert_eq
!
(
entry
.
last_access
self
.
now
)
;
let
(
layer_index
origin
)
=
entry
.
details
.
describe
(
)
;
(
entry
.
texture_id
layer_index
as
usize
DeviceIntRect
:
:
new
(
origin
entry
.
size
)
entry
.
swizzle
entry
.
uv_rect_handle
entry
.
user_data
)
}
fn
evict_impl
(
&
mut
self
handle
:
FreeListHandle
<
CacheEntryMarker
>
)
{
let
entry
=
self
.
lru_cache
.
remove_manual_handle
(
handle
)
;
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
}
pub
fn
evict_manual_handle
(
&
mut
self
handle
:
&
TextureCacheHandle
)
{
let
index
=
self
.
manual_handles
.
iter
(
)
.
position
(
|
strong_handle
|
{
strong_handle
.
matches
(
handle
)
}
)
;
if
let
Some
(
index
)
=
index
{
let
handle
=
self
.
manual_handles
.
swap_remove
(
index
)
;
self
.
evict_impl
(
handle
)
;
}
}
pub
fn
dump_color8_linear_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
color8_linear
.
dump_as_svg
(
output
)
}
pub
fn
dump_glyphs_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
self
.
shared_textures
.
color8_glyphs
.
dump_as_svg
(
output
)
}
fn
expire_old_picture_cache_tiles
(
&
mut
self
)
{
for
i
in
(
0
.
.
self
.
picture_cache_handles
.
len
(
)
)
.
rev
(
)
{
let
evict
=
{
let
entry
=
self
.
lru_cache
.
get
(
&
self
.
picture_cache_handles
[
i
]
)
;
let
mut
entry_frame_id
=
entry
.
last_access
.
frame_id
(
)
;
entry_frame_id
.
advance
(
)
;
entry_frame_id
<
self
.
now
.
frame_id
(
)
}
;
if
evict
{
let
handle
=
self
.
picture_cache_handles
.
swap_remove
(
i
)
;
self
.
evict_impl
(
handle
)
;
}
}
}
fn
evict_items_from_cache_if_required
(
&
mut
self
)
{
let
mut
eviction_count
=
0
;
while
self
.
should_continue_evicting
(
eviction_count
)
{
match
self
.
lru_cache
.
pop_oldest
(
)
{
Some
(
entry
)
=
>
{
entry
.
evict
(
)
;
self
.
free
(
&
entry
)
;
eviction_count
+
=
1
;
}
None
=
>
{
break
;
}
}
}
}
fn
should_continue_evicting
(
&
self
eviction_count
:
usize
)
-
>
bool
{
let
current_memory_estimate
=
self
.
standalone_bytes_allocated
+
self
.
shared_bytes_allocated
;
if
current_memory_estimate
<
Self
:
:
EVICTION_THRESHOLD_SIZE
{
return
false
;
}
if
current_memory_estimate
>
4
*
Self
:
:
EVICTION_THRESHOLD_SIZE
{
return
true
;
}
eviction_count
<
Self
:
:
MAX_EVICTIONS_PER_FRAME
}
fn
free
(
&
mut
self
entry
:
&
CacheEntry
)
{
match
entry
.
details
{
EntryDetails
:
:
Picture
{
texture_index
layer_index
}
=
>
{
let
picture_texture
=
self
.
picture_textures
.
get
(
texture_index
)
;
picture_texture
.
slices
[
layer_index
]
.
uv_rect_handle
=
None
;
if
self
.
debug_flags
.
contains
(
DebugFlags
:
:
TEXTURE_CACHE_DBG
|
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
{
self
.
pending_updates
.
push_debug_clear
(
entry
.
texture_id
DeviceIntPoint
:
:
zero
(
)
picture_texture
.
size
.
width
picture_texture
.
size
.
height
layer_index
)
;
}
}
EntryDetails
:
:
Standalone
{
size_in_bytes
.
.
}
=
>
{
self
.
standalone_bytes_allocated
-
=
size_in_bytes
;
self
.
pending_updates
.
push_free
(
entry
.
texture_id
)
;
}
EntryDetails
:
:
Cache
{
origin
region_index
.
.
}
=
>
{
let
texture_array
=
self
.
shared_textures
.
select
(
entry
.
size
entry
.
input_format
entry
.
filter
entry
.
shader
)
;
let
unit
=
texture_array
.
units
.
iter_mut
(
)
.
find
(
|
unit
|
unit
.
texture_id
=
=
entry
.
texture_id
)
.
expect
(
"
Unable
to
find
the
associated
texture
array
unit
"
)
;
let
region
=
&
mut
unit
.
regions
[
region_index
]
;
self
.
shared_bytes_allocated
-
=
region
.
slab_size
.
size_in_bytes
(
texture_array
.
formats
.
internal
)
;
if
self
.
debug_flags
.
contains
(
DebugFlags
:
:
TEXTURE_CACHE_DBG
|
DebugFlags
:
:
TEXTURE_CACHE_DBG_CLEAR_EVICTED
)
{
self
.
pending_updates
.
push_debug_clear
(
entry
.
texture_id
origin
region
.
slab_size
.
width
region
.
slab_size
.
height
0
)
;
}
region
.
free
(
origin
&
mut
unit
.
empty_regions
)
;
}
}
}
fn
allocate_from_shared_cache
(
&
mut
self
params
:
&
CacheAllocParams
)
-
>
CacheEntry
{
let
units
=
self
.
shared_textures
.
select
(
params
.
descriptor
.
size
params
.
descriptor
.
format
params
.
filter
params
.
shader
)
;
let
(
texture_id
region_index
allocated_rect
)
=
units
.
allocate
(
params
.
descriptor
.
size
&
mut
self
.
pending_updates
&
mut
self
.
next_id
)
;
let
swizzle
=
if
units
.
formats
.
external
=
=
params
.
descriptor
.
format
{
Swizzle
:
:
default
(
)
}
else
{
match
self
.
swizzle
{
Some
(
_
)
=
>
Swizzle
:
:
Bgra
None
=
>
Swizzle
:
:
default
(
)
}
}
;
let
bpp
=
units
.
formats
.
internal
.
bytes_per_pixel
(
)
;
self
.
shared_bytes_allocated
+
=
(
allocated_rect
.
size
.
area
(
)
*
bpp
)
as
usize
;
CacheEntry
{
size
:
params
.
descriptor
.
size
user_data
:
params
.
user_data
last_access
:
self
.
now
details
:
EntryDetails
:
:
Cache
{
origin
:
allocated_rect
.
origin
region_index
:
region_index
}
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
input_format
:
params
.
descriptor
.
format
filter
:
params
.
filter
swizzle
texture_id
eviction_notice
:
None
uv_rect_kind
:
params
.
uv_rect_kind
shader
:
params
.
shader
}
}
pub
fn
is_allowed_in_shared_cache
(
&
self
filter
:
TextureFilter
descriptor
:
&
ImageDescriptor
)
-
>
bool
{
let
mut
allowed_in_shared_cache
=
true
;
if
descriptor
.
size
.
width
>
TEXTURE_REGION_DIMENSIONS
|
|
descriptor
.
size
.
height
>
TEXTURE_REGION_DIMENSIONS
{
allowed_in_shared_cache
=
false
;
}
if
filter
=
=
TextureFilter
:
:
Nearest
&
&
descriptor
.
format
.
bytes_per_pixel
(
)
<
=
2
{
allowed_in_shared_cache
=
false
;
}
allowed_in_shared_cache
}
fn
allocate_standalone_entry
(
&
mut
self
params
:
&
CacheAllocParams
)
-
>
CacheEntry
{
let
texture_id
=
self
.
next_id
;
self
.
next_id
.
0
+
=
1
;
let
info
=
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
params
.
descriptor
.
size
.
width
height
:
params
.
descriptor
.
size
.
height
format
:
params
.
descriptor
.
format
filter
:
params
.
filter
layer_count
:
1
is_shared_cache
:
false
has_depth
:
false
}
;
let
size_in_bytes
=
(
info
.
width
*
info
.
height
*
info
.
format
.
bytes_per_pixel
(
)
)
as
usize
;
self
.
standalone_bytes_allocated
+
=
size_in_bytes
;
self
.
pending_updates
.
push_alloc
(
texture_id
info
)
;
let
swizzle
=
if
params
.
descriptor
.
format
=
=
ImageFormat
:
:
BGRA8
{
self
.
swizzle
.
map
(
|
s
|
s
.
bgra8_sampling_swizzle
)
}
else
{
None
}
;
CacheEntry
:
:
new_standalone
(
texture_id
self
.
now
params
swizzle
.
unwrap_or_default
(
)
size_in_bytes
)
}
fn
allocate_cache_entry
(
&
mut
self
params
:
&
CacheAllocParams
)
-
>
CacheEntry
{
assert
!
(
!
params
.
descriptor
.
size
.
is_empty
(
)
)
;
if
self
.
is_allowed_in_shared_cache
(
params
.
filter
&
params
.
descriptor
)
{
self
.
allocate_from_shared_cache
(
params
)
}
else
{
self
.
allocate_standalone_entry
(
params
)
}
}
fn
allocate
(
&
mut
self
params
:
&
CacheAllocParams
handle
:
&
mut
TextureCacheHandle
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
let
new_cache_entry
=
self
.
allocate_cache_entry
(
params
)
;
if
let
Some
(
old_entry
)
=
self
.
lru_cache
.
replace_or_insert
(
handle
new_cache_entry
)
{
old_entry
.
evict
(
)
;
self
.
free
(
&
old_entry
)
;
}
}
pub
fn
update_picture_cache
(
&
mut
self
tile_size
:
DeviceIntSize
handle
:
&
mut
TextureCacheHandle
gpu_cache
:
&
mut
GpuCache
)
{
debug_assert
!
(
self
.
now
.
is_valid
(
)
)
;
debug_assert
!
(
tile_size
.
width
>
0
&
&
tile_size
.
height
>
0
)
;
if
self
.
lru_cache
.
get_opt
(
handle
)
.
is_none
(
)
{
let
cache_entry
=
self
.
picture_textures
.
get_or_allocate_tile
(
tile_size
self
.
now
&
mut
self
.
next_id
&
mut
self
.
pending_updates
)
;
*
handle
=
self
.
lru_cache
.
push_new
(
cache_entry
)
;
let
strong_handle
=
self
.
lru_cache
.
set_manual_eviction
(
handle
)
.
expect
(
"
bug
:
handle
must
be
valid
here
"
)
;
self
.
picture_cache_handles
.
push
(
strong_handle
)
;
}
self
.
lru_cache
.
get_opt_mut
(
handle
)
.
expect
(
"
BUG
:
handle
must
be
valid
now
"
)
.
update_gpu_cache
(
gpu_cache
)
;
}
pub
fn
shared_alpha_expected_format
(
&
self
)
-
>
ImageFormat
{
self
.
shared_textures
.
alpha8_linear
.
formats
.
external
}
pub
fn
shared_color_expected_format
(
&
self
)
-
>
ImageFormat
{
self
.
shared_textures
.
color8_linear
.
formats
.
external
}
pub
fn
default_picture_tile_size
(
&
self
)
-
>
DeviceIntSize
{
self
.
picture_textures
.
default_tile_size
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
enum
SlabSizes
{
Default
Glyphs
}
impl
SlabSizes
{
fn
get
(
&
self
requested_size
:
DeviceIntSize
)
-
>
SlabSize
{
match
*
self
{
SlabSizes
:
:
Default
=
>
Self
:
:
default_slab_size
(
requested_size
)
SlabSizes
:
:
Glyphs
=
>
Self
:
:
glyphs_slab_size
(
requested_size
)
}
}
fn
default_slab_size
(
size
:
DeviceIntSize
)
-
>
SlabSize
{
fn
quantize_dimension
(
size
:
i32
)
-
>
i32
{
match
size
{
0
=
>
unreachable
!
(
)
1
.
.
=
16
=
>
16
17
.
.
=
32
=
>
32
33
.
.
=
64
=
>
64
65
.
.
=
128
=
>
128
129
.
.
=
256
=
>
256
257
.
.
=
512
=
>
512
_
=
>
panic
!
(
"
Invalid
dimensions
for
cache
!
"
)
}
}
let
x_size
=
quantize_dimension
(
size
.
width
)
;
let
y_size
=
quantize_dimension
(
size
.
height
)
;
let
(
width
height
)
=
match
(
x_size
y_size
)
{
(
512
0
.
.
=
64
)
=
>
(
512
64
)
(
512
128
)
=
>
(
512
128
)
(
512
256
)
=
>
(
512
256
)
(
0
.
.
=
64
512
)
=
>
(
64
512
)
(
128
512
)
=
>
(
128
512
)
(
256
512
)
=
>
(
256
512
)
(
x_size
y_size
)
=
>
{
let
square_size
=
cmp
:
:
max
(
x_size
y_size
)
;
(
square_size
square_size
)
}
}
;
SlabSize
{
width
height
}
}
fn
glyphs_slab_size
(
size
:
DeviceIntSize
)
-
>
SlabSize
{
fn
quantize_dimension
(
size
:
i32
)
-
>
i32
{
match
size
{
0
=
>
unreachable
!
(
)
1
.
.
=
8
=
>
8
9
.
.
=
16
=
>
16
17
.
.
=
32
=
>
32
33
.
.
=
64
=
>
64
65
.
.
=
128
=
>
128
_
=
>
panic
!
(
"
Invalid
dimensions
for
cache
!
"
)
}
}
let
x_size
=
quantize_dimension
(
size
.
width
)
;
let
y_size
=
quantize_dimension
(
size
.
height
)
;
let
(
width
height
)
=
match
(
x_size
y_size
)
{
(
8
16
)
=
>
(
8
16
)
(
16
32
)
=
>
(
16
32
)
(
x_size
y_size
)
=
>
{
let
square_size
=
cmp
:
:
max
(
x_size
y_size
)
;
(
square_size
square_size
)
}
}
;
SlabSize
{
width
height
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Copy
Clone
PartialEq
)
]
struct
SlabSize
{
width
:
i32
height
:
i32
}
impl
SlabSize
{
fn
size_in_bytes
(
&
self
format
:
ImageFormat
)
-
>
usize
{
let
bpp
=
format
.
bytes_per_pixel
(
)
;
(
self
.
width
*
self
.
height
*
bpp
)
as
usize
}
fn
invalid
(
)
-
>
SlabSize
{
SlabSize
{
width
:
0
height
:
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureLocation
(
u8
u8
)
;
impl
TextureLocation
{
fn
new
(
x
:
i32
y
:
i32
)
-
>
Self
{
debug_assert
!
(
x
>
=
0
&
&
y
>
=
0
&
&
x
<
0x100
&
&
y
<
0x100
)
;
TextureLocation
(
x
as
u8
y
as
u8
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureRegion
{
index
:
usize
slab_size
:
SlabSize
offset
:
DeviceIntPoint
free_slots
:
Vec
<
TextureLocation
>
total_slot_count
:
usize
}
impl
TextureRegion
{
fn
new
(
index
:
usize
offset
:
DeviceIntPoint
)
-
>
Self
{
TextureRegion
{
index
slab_size
:
SlabSize
:
:
invalid
(
)
offset
free_slots
:
Vec
:
:
new
(
)
total_slot_count
:
0
}
}
fn
init
(
&
mut
self
slab_size
:
SlabSize
region_size
:
i32
empty_regions
:
&
mut
usize
)
{
debug_assert
!
(
self
.
slab_size
=
=
SlabSize
:
:
invalid
(
)
)
;
debug_assert
!
(
self
.
free_slots
.
is_empty
(
)
)
;
self
.
slab_size
=
slab_size
;
let
slots_per_x_axis
=
region_size
/
self
.
slab_size
.
width
;
let
slots_per_y_axis
=
region_size
/
self
.
slab_size
.
height
;
for
y
in
0
.
.
slots_per_y_axis
{
for
x
in
0
.
.
slots_per_x_axis
{
self
.
free_slots
.
push
(
TextureLocation
:
:
new
(
x
y
)
)
;
}
}
self
.
total_slot_count
=
self
.
free_slots
.
len
(
)
;
*
empty_regions
-
=
1
;
}
fn
deinit
(
&
mut
self
empty_regions
:
&
mut
usize
)
{
self
.
slab_size
=
SlabSize
:
:
invalid
(
)
;
self
.
free_slots
.
clear
(
)
;
self
.
total_slot_count
=
0
;
*
empty_regions
+
=
1
;
}
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
slab_size
=
=
SlabSize
:
:
invalid
(
)
}
fn
alloc
(
&
mut
self
)
-
>
Option
<
DeviceIntPoint
>
{
debug_assert
!
(
self
.
slab_size
!
=
SlabSize
:
:
invalid
(
)
)
;
self
.
free_slots
.
pop
(
)
.
map
(
|
location
|
{
point2
(
self
.
offset
.
x
+
self
.
slab_size
.
width
*
location
.
0
as
i32
self
.
offset
.
y
+
self
.
slab_size
.
height
*
location
.
1
as
i32
)
}
)
}
fn
free
(
&
mut
self
point
:
DeviceIntPoint
empty_regions
:
&
mut
usize
)
{
let
x
=
(
point
.
x
-
self
.
offset
.
x
)
/
self
.
slab_size
.
width
;
let
y
=
(
point
.
y
-
self
.
offset
.
y
)
/
self
.
slab_size
.
height
;
self
.
free_slots
.
push
(
TextureLocation
:
:
new
(
x
y
)
)
;
if
self
.
free_slots
.
len
(
)
=
=
self
.
total_slot_count
{
self
.
deinit
(
empty_regions
)
;
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureUnit
{
texture_id
:
CacheTextureId
regions
:
Vec
<
TextureRegion
>
region_size
:
i32
empty_regions
:
usize
}
impl
TextureUnit
{
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
empty_regions
=
=
self
.
regions
.
len
(
)
}
fn
allocate
(
&
mut
self
slab_size
:
SlabSize
)
-
>
Option
<
(
usize
DeviceIntRect
)
>
{
let
mut
empty_region_index
=
None
;
let
allocated_size
=
size2
(
slab_size
.
width
slab_size
.
height
)
;
for
(
i
region
)
in
self
.
regions
.
iter_mut
(
)
.
enumerate
(
)
{
if
region
.
is_empty
(
)
{
empty_region_index
=
Some
(
i
)
;
}
else
if
region
.
slab_size
=
=
slab_size
{
if
let
Some
(
location
)
=
region
.
alloc
(
)
{
return
Some
(
(
region
.
index
DeviceIntRect
{
origin
:
location
size
:
allocated_size
}
)
)
;
}
}
}
if
let
Some
(
empty_region_index
)
=
empty_region_index
{
let
region
=
&
mut
self
.
regions
[
empty_region_index
]
;
region
.
init
(
slab_size
self
.
region_size
&
mut
self
.
empty_regions
)
;
return
Some
(
(
region
.
index
DeviceIntRect
{
origin
:
region
.
alloc
(
)
.
unwrap
(
)
size
:
allocated_size
}
)
)
}
None
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
TextureUnits
{
filter
:
TextureFilter
formats
:
TextureFormatPair
<
ImageFormat
>
units
:
SmallVec
<
[
TextureUnit
;
1
]
>
size
:
i32
region_size
:
i32
slab_sizes
:
SlabSizes
}
impl
TextureUnits
{
fn
new
(
formats
:
TextureFormatPair
<
ImageFormat
>
filter
:
TextureFilter
size
:
i32
region_size
:
i32
slab_sizes
:
SlabSizes
)
-
>
Self
{
TextureUnits
{
formats
filter
units
:
SmallVec
:
:
new
(
)
size
region_size
slab_sizes
}
}
fn
size_in_bytes
(
&
self
)
-
>
usize
{
let
bpp
=
self
.
formats
.
internal
.
bytes_per_pixel
(
)
as
usize
;
let
num_regions
:
usize
=
self
.
units
.
iter
(
)
.
map
(
|
u
|
u
.
regions
.
len
(
)
)
.
sum
(
)
;
num_regions
*
(
self
.
region_size
*
self
.
region_size
)
as
usize
*
bpp
}
fn
add_texture
(
&
mut
self
texture_id
:
CacheTextureId
)
-
>
usize
{
let
regions_per_row
=
self
.
size
/
self
.
region_size
;
let
num_regions
=
(
regions_per_row
*
regions_per_row
)
as
usize
;
let
mut
texture
=
TextureUnit
{
texture_id
regions
:
Vec
:
:
with_capacity
(
num_regions
)
region_size
:
self
.
region_size
empty_regions
:
num_regions
}
;
for
index
in
0
.
.
num_regions
{
let
offset
=
point2
(
(
index
as
i32
%
regions_per_row
)
*
self
.
region_size
(
index
as
i32
/
regions_per_row
)
*
self
.
region_size
)
;
texture
.
regions
.
push
(
TextureRegion
:
:
new
(
index
offset
)
)
;
}
let
unit_index
=
self
.
units
.
len
(
)
;
self
.
units
.
push
(
texture
)
;
unit_index
}
fn
allocate
(
&
mut
self
requested_size
:
DeviceIntSize
pending_updates
:
&
mut
TextureUpdateList
next_id
:
&
mut
CacheTextureId
)
-
>
(
CacheTextureId
usize
DeviceIntRect
)
{
let
mut
allocation
=
None
;
let
slab_size
=
self
.
slab_sizes
.
get
(
requested_size
)
;
for
unit
in
&
mut
self
.
units
{
if
let
Some
(
(
region
rect
)
)
=
unit
.
allocate
(
slab_size
)
{
allocation
=
Some
(
(
unit
.
texture_id
region
rect
)
)
;
}
}
allocation
.
unwrap_or_else
(
|
|
{
let
texture_id
=
*
next_id
;
next_id
.
0
+
=
1
;
pending_updates
.
push_alloc
(
texture_id
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
self
.
size
height
:
self
.
size
format
:
self
.
formats
.
internal
filter
:
self
.
filter
layer_count
:
1
is_shared_cache
:
true
has_depth
:
false
}
)
;
let
unit_index
=
self
.
add_texture
(
texture_id
)
;
let
(
region_index
rect
)
=
self
.
units
[
unit_index
]
.
allocate
(
slab_size
)
.
unwrap
(
)
;
(
texture_id
region_index
rect
)
}
)
}
fn
clear
(
&
mut
self
updates
:
&
mut
TextureUpdateList
)
{
for
unit
in
self
.
units
.
drain
(
.
.
)
{
updates
.
push_free
(
unit
.
texture_id
)
;
}
}
fn
release_empty_textures
(
&
mut
self
updates
:
&
mut
TextureUpdateList
)
{
self
.
units
.
retain
(
|
unit
|
{
if
unit
.
is_empty
(
)
{
updates
.
push_free
(
unit
.
texture_id
)
;
false
}
else
{
true
}
}
)
;
}
fn
update_profile
(
&
self
count_idx
:
usize
mem_idx
:
usize
profile
:
&
mut
TransactionProfile
)
{
let
num_regions
:
usize
=
self
.
units
.
iter
(
)
.
map
(
|
u
|
u
.
regions
.
len
(
)
)
.
sum
(
)
;
profile
.
set
(
count_idx
num_regions
)
;
profile
.
set
(
mem_idx
profiler
:
:
bytes_to_mb
(
self
.
size_in_bytes
(
)
)
)
;
}
#
[
allow
(
dead_code
)
]
pub
fn
dump_as_svg
(
&
self
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
use
svg_fmt
:
:
*
;
let
num_arrays
=
self
.
units
.
len
(
)
as
f32
;
let
region_size
=
self
.
region_size
as
f32
;
let
text_spacing
=
15
.
0
;
let
array_spacing
=
30
.
0
;
let
unit_spacing
=
5
.
0
;
let
unit_size
=
200
.
0
*
(
self
.
region_size
as
f32
/
512
.
0
)
;
let
regions_per_row
=
(
self
.
size
/
self
.
region_size
)
as
usize
;
let
texture_size
=
text_spacing
+
array_spacing
+
(
unit_size
+
unit_spacing
)
*
regions_per_row
as
f32
;
let
svg_w
=
array_spacing
*
2
.
0
+
regions_per_row
as
f32
*
(
unit_size
+
unit_spacing
)
;
let
svg_h
=
array_spacing
+
num_arrays
*
(
texture_size
+
array_spacing
)
;
writeln
!
(
output
"
{
}
"
BeginSvg
{
w
:
svg_w
h
:
svg_h
}
)
?
;
writeln
!
(
output
"
{
}
"
rectangle
(
0
.
0
0
.
0
svg_w
svg_h
)
.
inflate
(
1
.
0
1
.
0
)
.
fill
(
rgb
(
50
50
50
)
)
)
?
;
let
mut
y
=
array_spacing
;
for
unit
in
&
self
.
units
{
writeln
!
(
output
"
{
}
"
text
(
array_spacing
y
format
!
(
"
{
:
?
}
"
unit
.
texture_id
)
)
.
color
(
rgb
(
230
230
230
)
)
)
?
;
for
(
idx
region
)
in
unit
.
regions
.
iter
(
)
.
enumerate
(
)
{
let
slab_size
=
region
.
slab_size
;
let
x
=
array_spacing
+
(
idx
%
regions_per_row
)
as
f32
*
(
unit_size
+
unit_spacing
)
;
let
y
=
y
+
text_spacing
+
(
idx
/
regions_per_row
)
as
f32
*
(
unit_size
+
unit_spacing
)
;
let
texture_background
=
if
region
.
is_empty
(
)
{
rgb
(
30
30
30
)
}
else
{
rgb
(
40
40
130
)
}
;
writeln
!
(
output
"
{
}
"
rectangle
(
x
y
unit_size
unit_size
)
.
inflate
(
1
.
0
1
.
0
)
.
fill
(
rgb
(
10
10
10
)
)
)
?
;
writeln
!
(
output
"
{
}
"
rectangle
(
x
y
unit_size
unit_size
)
.
fill
(
texture_background
)
)
?
;
let
sw
=
(
slab_size
.
width
as
f32
/
region_size
)
*
unit_size
;
let
sh
=
(
slab_size
.
height
as
f32
/
region_size
)
*
unit_size
;
for
slot
in
&
region
.
free_slots
{
let
sx
=
x
+
slot
.
0
as
f32
*
sw
;
let
sy
=
y
+
slot
.
1
as
f32
*
sh
;
writeln
!
(
output
"
{
}
"
rectangle
(
sx
sy
sw
sh
)
.
inflate
(
-
0
.
5
-
0
.
5
)
.
fill
(
rgb
(
30
30
30
)
)
)
?
;
}
if
slab_size
.
width
!
=
0
{
let
region_text
=
format
!
(
"
{
}
x
{
}
"
slab_size
.
width
slab_size
.
height
)
;
let
tx
=
x
+
1
.
0
;
let
ty
=
y
+
unit_size
-
1
.
0
;
writeln
!
(
output
"
{
}
"
text
(
tx
ty
region_text
)
.
color
(
rgb
(
230
230
230
)
)
)
?
;
}
}
y
+
=
array_spacing
+
texture_size
;
}
writeln
!
(
output
"
{
}
"
EndSvg
)
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
struct
WholeTextureSlice
{
uv_rect_handle
:
Option
<
GpuCacheHandle
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
WholeTextureArray
{
size
:
DeviceIntSize
filter
:
TextureFilter
format
:
ImageFormat
texture_id
:
CacheTextureId
slices
:
Vec
<
WholeTextureSlice
>
has_depth
:
bool
}
impl
WholeTextureArray
{
fn
to_info
(
&
self
)
-
>
TextureCacheAllocInfo
{
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2DArray
width
:
self
.
size
.
width
height
:
self
.
size
.
height
format
:
self
.
format
filter
:
self
.
filter
layer_count
:
self
.
slices
.
len
(
)
as
i32
is_shared_cache
:
true
has_depth
:
self
.
has_depth
}
}
fn
size_in_bytes
(
&
self
)
-
>
usize
{
let
bpp
=
self
.
format
.
bytes_per_pixel
(
)
as
usize
;
self
.
slices
.
len
(
)
*
(
self
.
size
.
width
*
self
.
size
.
height
)
as
usize
*
bpp
}
fn
find_free
(
&
self
)
-
>
Option
<
LayerIndex
>
{
self
.
slices
.
iter
(
)
.
position
(
|
slice
|
slice
.
uv_rect_handle
.
is_none
(
)
)
}
fn
cache_entry_impl
(
&
self
texture_index
:
usize
layer_index
:
usize
now
:
FrameStamp
uv_rect_handle
:
GpuCacheHandle
texture_id
:
CacheTextureId
)
-
>
CacheEntry
{
CacheEntry
{
size
:
self
.
size
user_data
:
[
0
.
0
;
3
]
last_access
:
now
details
:
EntryDetails
:
:
Picture
{
texture_index
layer_index
}
uv_rect_handle
input_format
:
self
.
format
filter
:
self
.
filter
swizzle
:
Swizzle
:
:
default
(
)
texture_id
eviction_notice
:
None
uv_rect_kind
:
UvRectKind
:
:
Rect
shader
:
TargetShader
:
:
Default
}
}
fn
occupy
(
&
mut
self
texture_index
:
usize
layer_index
:
usize
now
:
FrameStamp
)
-
>
CacheEntry
{
let
uv_rect_handle
=
GpuCacheHandle
:
:
new
(
)
;
assert
!
(
self
.
slices
[
layer_index
]
.
uv_rect_handle
.
is_none
(
)
)
;
self
.
slices
[
layer_index
]
.
uv_rect_handle
=
Some
(
uv_rect_handle
)
;
self
.
cache_entry_impl
(
texture_index
layer_index
now
uv_rect_handle
self
.
texture_id
)
}
}
impl
TextureCacheUpdate
{
fn
new_update
(
data
:
CachedImageData
descriptor
:
&
ImageDescriptor
origin
:
DeviceIntPoint
size
:
DeviceIntSize
use_upload_format
:
bool
dirty_rect
:
&
ImageDirtyRect
)
-
>
TextureCacheUpdate
{
let
source
=
match
data
{
CachedImageData
:
:
Blob
=
>
{
panic
!
(
"
The
vector
image
should
have
been
rasterized
.
"
)
;
}
CachedImageData
:
:
External
(
ext_image
)
=
>
match
ext_image
.
image_type
{
ExternalImageType
:
:
TextureHandle
(
_
)
=
>
{
panic
!
(
"
External
texture
handle
should
not
go
through
texture_cache
.
"
)
;
}
ExternalImageType
:
:
Buffer
=
>
TextureUpdateSource
:
:
External
{
id
:
ext_image
.
id
channel_index
:
ext_image
.
channel_index
}
}
CachedImageData
:
:
Raw
(
bytes
)
=
>
{
let
finish
=
descriptor
.
offset
+
descriptor
.
size
.
width
*
descriptor
.
format
.
bytes_per_pixel
(
)
+
(
descriptor
.
size
.
height
-
1
)
*
descriptor
.
compute_stride
(
)
;
assert
!
(
bytes
.
len
(
)
>
=
finish
as
usize
)
;
TextureUpdateSource
:
:
Bytes
{
data
:
bytes
}
}
}
;
let
format_override
=
if
use_upload_format
{
Some
(
descriptor
.
format
)
}
else
{
None
}
;
match
*
dirty_rect
{
DirtyRect
:
:
Partial
(
dirty
)
=
>
{
let
stride
=
descriptor
.
compute_stride
(
)
;
let
offset
=
descriptor
.
offset
+
dirty
.
origin
.
y
*
stride
+
dirty
.
origin
.
x
*
descriptor
.
format
.
bytes_per_pixel
(
)
;
TextureCacheUpdate
{
rect
:
DeviceIntRect
:
:
new
(
DeviceIntPoint
:
:
new
(
origin
.
x
+
dirty
.
origin
.
x
origin
.
y
+
dirty
.
origin
.
y
)
DeviceIntSize
:
:
new
(
dirty
.
size
.
width
.
min
(
size
.
width
-
dirty
.
origin
.
x
)
dirty
.
size
.
height
.
min
(
size
.
height
-
dirty
.
origin
.
y
)
)
)
source
stride
:
Some
(
stride
)
offset
format_override
layer_index
:
0
}
}
DirtyRect
:
:
All
=
>
{
TextureCacheUpdate
{
rect
:
DeviceIntRect
:
:
new
(
origin
size
)
source
stride
:
descriptor
.
stride
offset
:
descriptor
.
offset
format_override
layer_index
:
0
}
}
}
}
}
