use
api
:
:
units
:
:
*
;
use
api
:
:
ImageFormat
;
use
crate
:
:
gpu_cache
:
:
{
GpuCache
GpuCacheAddress
}
;
use
crate
:
:
internal_types
:
:
{
TextureSource
CacheTextureId
FastHashMap
FastHashSet
FrameId
}
;
use
crate
:
:
internal_types
:
:
size_of_frame_vec
;
use
crate
:
:
render_task
:
:
{
StaticRenderTaskSurface
RenderTaskLocation
RenderTask
}
;
use
crate
:
:
render_target
:
:
RenderTargetKind
;
use
crate
:
:
render_task
:
:
{
RenderTaskData
RenderTaskKind
}
;
use
crate
:
:
resource_cache
:
:
ResourceCache
;
use
crate
:
:
texture_pack
:
:
GuillotineAllocator
;
use
crate
:
:
prim_store
:
:
DeferredResolve
;
use
crate
:
:
image_source
:
:
{
resolve_image
resolve_cached_render_task
}
;
use
smallvec
:
:
SmallVec
;
use
topological_sort
:
:
TopologicalSort
;
use
crate
:
:
render_target
:
:
{
RenderTargetList
ColorRenderTarget
}
;
use
crate
:
:
render_target
:
:
{
PictureCacheTarget
TextureCacheRenderTarget
}
;
use
crate
:
:
util
:
:
{
Allocation
VecHelper
}
;
use
std
:
:
{
usize
f32
}
;
use
crate
:
:
internal_types
:
:
{
FrameVec
FrameMemory
}
;
#
[
cfg
(
test
)
]
use
crate
:
:
frame_allocator
:
:
FrameAllocator
;
const
TEXTURE_DIMENSION_MASK
:
i32
=
0xFF
;
pub
struct
RenderTaskAllocation
<
'
a
>
{
pub
alloc
:
Allocation
<
'
a
RenderTask
>
}
impl
<
'
l
>
RenderTaskAllocation
<
'
l
>
{
#
[
inline
(
always
)
]
pub
fn
init
(
self
value
:
RenderTask
)
-
>
RenderTaskId
{
RenderTaskId
{
index
:
self
.
alloc
.
init
(
value
)
as
u32
}
}
}
#
[
derive
(
Copy
Clone
PartialEq
Eq
Hash
Debug
)
]
#
[
derive
(
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskId
{
pub
index
:
u32
}
impl
RenderTaskId
{
pub
const
INVALID
:
RenderTaskId
=
RenderTaskId
{
index
:
u32
:
:
MAX
}
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
Hash
Eq
PartialEq
PartialOrd
Ord
)
]
pub
struct
PassId
(
usize
)
;
impl
PassId
{
pub
const
MIN
:
PassId
=
PassId
(
0
)
;
pub
const
MAX
:
PassId
=
PassId
(
!
0
-
1
)
;
pub
const
INVALID
:
PassId
=
PassId
(
!
0
-
2
)
;
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
Surface
{
kind
:
RenderTargetKind
allocator
:
GuillotineAllocator
is_shared
:
bool
free_after
:
PassId
}
impl
Surface
{
fn
alloc_rect
(
&
mut
self
size
:
DeviceIntSize
kind
:
RenderTargetKind
is_shared
:
bool
free_after
:
PassId
)
-
>
Option
<
DeviceIntPoint
>
{
if
self
.
kind
=
=
kind
&
&
self
.
is_shared
=
=
is_shared
&
&
self
.
free_after
=
=
free_after
{
self
.
allocator
.
allocate
(
&
size
)
.
map
(
|
(
_slice
origin
)
|
origin
)
}
else
{
None
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
)
]
pub
enum
SubPassSurface
{
Dynamic
{
texture_id
:
CacheTextureId
target_kind
:
RenderTargetKind
used_rect
:
DeviceIntRect
}
Persistent
{
surface
:
StaticRenderTaskSurface
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SubPass
{
pub
surface
:
SubPassSurface
pub
task_ids
:
FrameVec
<
RenderTaskId
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
Pass
{
pub
task_ids
:
FrameVec
<
RenderTaskId
>
pub
sub_passes
:
FrameVec
<
SubPass
>
pub
textures_to_invalidate
:
FrameVec
<
CacheTextureId
>
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTaskGraph
{
pub
tasks
:
FrameVec
<
RenderTask
>
pub
passes
:
FrameVec
<
Pass
>
frame_id
:
FrameId
pub
task_data
:
FrameVec
<
RenderTaskData
>
#
[
cfg
(
test
)
]
surface_count
:
usize
#
[
cfg
(
test
)
]
unique_surfaces
:
FastHashSet
<
CacheTextureId
>
}
pub
struct
RenderTaskGraphBuilder
{
tasks
:
Vec
<
RenderTask
>
roots
:
FastHashSet
<
RenderTaskId
>
frame_id
:
FrameId
textures_to_free
:
FastHashSet
<
CacheTextureId
>
active_surfaces
:
FastHashMap
<
CacheTextureId
Surface
>
}
impl
RenderTaskGraphBuilder
{
pub
fn
new
(
)
-
>
Self
{
RenderTaskGraphBuilder
{
tasks
:
Vec
:
:
new
(
)
roots
:
FastHashSet
:
:
default
(
)
frame_id
:
FrameId
:
:
INVALID
textures_to_free
:
FastHashSet
:
:
default
(
)
active_surfaces
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
frame_id
(
&
self
)
-
>
FrameId
{
self
.
frame_id
}
pub
fn
begin_frame
(
&
mut
self
frame_id
:
FrameId
)
{
self
.
frame_id
=
frame_id
;
self
.
roots
.
clear
(
)
;
}
pub
fn
get_task
(
&
self
task_id
:
RenderTaskId
)
-
>
&
RenderTask
{
&
self
.
tasks
[
task_id
.
index
as
usize
]
}
pub
fn
get_task_mut
(
&
mut
self
task_id
:
RenderTaskId
)
-
>
&
mut
RenderTask
{
&
mut
self
.
tasks
[
task_id
.
index
as
usize
]
}
pub
fn
add
(
&
mut
self
)
-
>
RenderTaskAllocation
{
self
.
roots
.
insert
(
RenderTaskId
{
index
:
self
.
tasks
.
len
(
)
as
u32
}
)
;
RenderTaskAllocation
{
alloc
:
self
.
tasks
.
alloc
(
)
}
}
pub
fn
add_dependency
(
&
mut
self
task_id
:
RenderTaskId
input
:
RenderTaskId
)
{
self
.
tasks
[
task_id
.
index
as
usize
]
.
children
.
push
(
input
)
;
self
.
roots
.
remove
(
&
input
)
;
}
pub
fn
end_frame
(
&
mut
self
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
deferred_resolves
:
&
mut
FrameVec
<
DeferredResolve
>
max_shared_surface_size
:
i32
memory
:
&
FrameMemory
)
-
>
RenderTaskGraph
{
let
task_count
=
self
.
tasks
.
len
(
)
;
let
mut
tasks
=
memory
.
new_vec_with_capacity
(
task_count
)
;
for
task
in
self
.
tasks
.
drain
(
.
.
)
{
tasks
.
push
(
task
)
}
let
mut
graph
=
RenderTaskGraph
{
tasks
passes
:
memory
.
new_vec
(
)
task_data
:
memory
.
new_vec_with_capacity
(
task_count
)
frame_id
:
self
.
frame_id
#
[
cfg
(
test
)
]
surface_count
:
0
#
[
cfg
(
test
)
]
unique_surfaces
:
FastHashSet
:
:
default
(
)
}
;
let
mut
pass_count
=
0
;
let
mut
passes
=
memory
.
new_vec
(
)
;
let
mut
task_sorter
=
TopologicalSort
:
:
<
RenderTaskId
>
:
:
new
(
)
;
for
(
parent_id
task
)
in
graph
.
tasks
.
iter
(
)
.
enumerate
(
)
{
let
parent_id
=
RenderTaskId
{
index
:
parent_id
as
u32
}
;
for
child_id
in
&
task
.
children
{
task_sorter
.
add_dependency
(
parent_id
*
child_id
)
;
}
}
loop
{
let
tasks
=
task_sorter
.
pop_all
(
)
;
if
tasks
.
is_empty
(
)
{
assert
!
(
task_sorter
.
is_empty
(
)
)
;
break
;
}
else
{
for
task_id
in
&
tasks
{
graph
.
tasks
[
task_id
.
index
as
usize
]
.
render_on
=
PassId
(
pass_count
)
;
}
passes
.
push
(
tasks
)
;
pass_count
+
=
1
;
}
}
pass_count
=
pass_count
.
max
(
1
)
;
for
pass
in
passes
{
for
task_id
in
pass
{
assign_free_pass
(
task_id
&
mut
graph
)
;
}
}
for
_
in
0
.
.
pass_count
{
graph
.
passes
.
push
(
Pass
{
task_ids
:
memory
.
new_vec
(
)
sub_passes
:
memory
.
new_vec
(
)
textures_to_invalidate
:
memory
.
new_vec
(
)
}
)
;
}
for
(
index
task
)
in
graph
.
tasks
.
iter
(
)
.
enumerate
(
)
{
if
task
.
kind
.
is_a_rendering_operation
(
)
{
let
id
=
RenderTaskId
{
index
:
index
as
u32
}
;
graph
.
passes
[
task
.
render_on
.
0
]
.
task_ids
.
push
(
id
)
;
}
}
assert
!
(
self
.
active_surfaces
.
is_empty
(
)
)
;
for
(
pass_id
pass
)
in
graph
.
passes
.
iter_mut
(
)
.
enumerate
(
)
.
rev
(
)
{
assert
!
(
self
.
textures_to_free
.
is_empty
(
)
)
;
for
task_id
in
&
pass
.
task_ids
{
let
task_location
=
graph
.
tasks
[
task_id
.
index
as
usize
]
.
location
.
clone
(
)
;
match
task_location
{
RenderTaskLocation
:
:
Unallocated
{
size
}
=
>
{
let
task
=
&
mut
graph
.
tasks
[
task_id
.
index
as
usize
]
;
let
mut
location
=
None
;
let
kind
=
task
.
kind
.
target_kind
(
)
;
let
can_use_shared_surface
=
task
.
kind
.
can_use_shared_surface
(
)
&
&
task
.
free_after
!
=
PassId
:
:
INVALID
;
if
can_use_shared_surface
{
for
sub_pass
in
&
mut
pass
.
sub_passes
{
if
let
SubPassSurface
:
:
Dynamic
{
texture_id
ref
mut
used_rect
.
.
}
=
sub_pass
.
surface
{
let
surface
=
self
.
active_surfaces
.
get_mut
(
&
texture_id
)
.
unwrap
(
)
;
if
let
Some
(
p
)
=
surface
.
alloc_rect
(
size
kind
true
task
.
free_after
)
{
location
=
Some
(
(
texture_id
p
)
)
;
*
used_rect
=
used_rect
.
union
(
&
DeviceIntRect
:
:
from_origin_and_size
(
p
size
)
)
;
sub_pass
.
task_ids
.
push
(
*
task_id
)
;
break
;
}
}
}
}
if
location
.
is_none
(
)
{
let
can_use_shared_surface
=
can_use_shared_surface
&
&
size
.
width
<
=
max_shared_surface_size
&
&
size
.
height
<
=
max_shared_surface_size
;
let
surface_size
=
if
can_use_shared_surface
{
DeviceIntSize
:
:
new
(
max_shared_surface_size
max_shared_surface_size
)
}
else
{
DeviceIntSize
:
:
new
(
(
size
.
width
+
TEXTURE_DIMENSION_MASK
)
&
!
TEXTURE_DIMENSION_MASK
(
size
.
height
+
TEXTURE_DIMENSION_MASK
)
&
!
TEXTURE_DIMENSION_MASK
)
}
;
if
surface_size
.
is_empty
(
)
{
let
task_name
=
graph
.
tasks
[
task_id
.
index
as
usize
]
.
kind
.
as_str
(
)
;
panic
!
(
"
{
}
render
task
has
invalid
size
{
:
?
}
"
task_name
surface_size
)
;
}
let
format
=
match
kind
{
RenderTargetKind
:
:
Color
=
>
ImageFormat
:
:
RGBA8
RenderTargetKind
:
:
Alpha
=
>
ImageFormat
:
:
R8
}
;
let
texture_id
=
resource_cache
.
get_or_create_render_target_from_pool
(
surface_size
format
)
;
let
mut
surface
=
Surface
{
kind
allocator
:
GuillotineAllocator
:
:
new
(
Some
(
surface_size
)
)
is_shared
:
can_use_shared_surface
free_after
:
task
.
free_after
}
;
let
p
=
surface
.
alloc_rect
(
size
kind
can_use_shared_surface
task
.
free_after
)
.
expect
(
"
bug
:
alloc
must
succeed
!
"
)
;
location
=
Some
(
(
texture_id
p
)
)
;
let
_prev_surface
=
self
.
active_surfaces
.
insert
(
texture_id
surface
)
;
assert
!
(
_prev_surface
.
is_none
(
)
)
;
#
[
cfg
(
test
)
]
{
graph
.
surface_count
+
=
1
;
graph
.
unique_surfaces
.
insert
(
texture_id
)
;
}
let
mut
task_ids
=
memory
.
new_vec
(
)
;
task_ids
.
push
(
*
task_id
)
;
pass
.
sub_passes
.
push
(
SubPass
{
surface
:
SubPassSurface
:
:
Dynamic
{
texture_id
target_kind
:
kind
used_rect
:
DeviceIntRect
:
:
from_origin_and_size
(
p
size
)
}
task_ids
}
)
;
}
assert
!
(
location
.
is_some
(
)
)
;
task
.
location
=
RenderTaskLocation
:
:
Dynamic
{
texture_id
:
location
.
unwrap
(
)
.
0
rect
:
DeviceIntRect
:
:
from_origin_and_size
(
location
.
unwrap
(
)
.
1
size
)
}
;
}
RenderTaskLocation
:
:
Existing
{
parent_task_id
size
:
existing_size
.
.
}
=
>
{
let
parent_task_location
=
graph
.
tasks
[
parent_task_id
.
index
as
usize
]
.
location
.
clone
(
)
;
match
parent_task_location
{
RenderTaskLocation
:
:
Unallocated
{
.
.
}
|
RenderTaskLocation
:
:
CacheRequest
{
.
.
}
|
RenderTaskLocation
:
:
Existing
{
.
.
}
=
>
{
panic
!
(
"
bug
:
reference
to
existing
task
must
be
allocated
by
now
"
)
;
}
RenderTaskLocation
:
:
Dynamic
{
texture_id
rect
.
.
}
=
>
{
assert_eq
!
(
existing_size
rect
.
size
(
)
)
;
let
kind
=
graph
.
tasks
[
parent_task_id
.
index
as
usize
]
.
kind
.
target_kind
(
)
;
let
mut
task_ids
=
memory
.
new_vec
(
)
;
task_ids
.
push
(
*
task_id
)
;
pass
.
sub_passes
.
push
(
SubPass
{
surface
:
SubPassSurface
:
:
Dynamic
{
texture_id
target_kind
:
kind
used_rect
:
rect
}
task_ids
}
)
;
let
task
=
&
mut
graph
.
tasks
[
task_id
.
index
as
usize
]
;
task
.
location
=
parent_task_location
;
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
unreachable
!
(
"
bug
:
not
possible
since
we
don
'
t
dup
static
locations
"
)
;
}
}
}
RenderTaskLocation
:
:
Static
{
ref
surface
.
.
}
=
>
{
let
mut
task_ids
=
memory
.
new_vec
(
)
;
task_ids
.
push
(
*
task_id
)
;
pass
.
sub_passes
.
push
(
SubPass
{
surface
:
SubPassSurface
:
:
Persistent
{
surface
:
surface
.
clone
(
)
}
task_ids
}
)
;
}
RenderTaskLocation
:
:
CacheRequest
{
.
.
}
=
>
{
}
RenderTaskLocation
:
:
Dynamic
{
.
.
}
=
>
{
panic
!
(
"
bug
:
encountered
an
already
allocated
task
"
)
;
}
}
let
task
=
&
graph
.
tasks
[
task_id
.
index
as
usize
]
;
for
child_id
in
&
task
.
children
{
let
child_task
=
&
graph
.
tasks
[
child_id
.
index
as
usize
]
;
match
child_task
.
location
{
RenderTaskLocation
:
:
Unallocated
{
.
.
}
|
RenderTaskLocation
:
:
Existing
{
.
.
}
=
>
panic
!
(
"
bug
:
must
be
allocated
"
)
RenderTaskLocation
:
:
Dynamic
{
texture_id
.
.
}
=
>
{
if
child_task
.
free_after
=
=
PassId
(
pass_id
)
{
self
.
textures_to_free
.
insert
(
texture_id
)
;
}
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
}
RenderTaskLocation
:
:
CacheRequest
{
.
.
}
=
>
{
}
}
}
}
for
texture_id
in
self
.
textures_to_free
.
drain
(
)
{
resource_cache
.
return_render_target_to_pool
(
texture_id
)
;
self
.
active_surfaces
.
remove
(
&
texture_id
)
.
unwrap
(
)
;
pass
.
textures_to_invalidate
.
push
(
texture_id
)
;
}
}
if
!
self
.
active_surfaces
.
is_empty
(
)
{
graph
.
print
(
)
;
assert
!
(
self
.
active_surfaces
.
is_empty
(
)
)
;
}
for
task
in
&
mut
graph
.
tasks
{
let
cache_item
=
if
let
Some
(
ref
cache_handle
)
=
task
.
cache_handle
{
Some
(
resolve_cached_render_task
(
cache_handle
resource_cache
)
)
}
else
if
let
RenderTaskKind
:
:
Image
(
request
)
=
&
task
.
kind
{
Some
(
resolve_image
(
*
request
resource_cache
gpu_cache
deferred_resolves
)
)
}
else
{
None
}
;
if
let
Some
(
cache_item
)
=
cache_item
{
let
source
=
cache_item
.
texture_id
;
task
.
uv_rect_handle
=
cache_item
.
uv_rect_handle
;
task
.
location
=
RenderTaskLocation
:
:
Static
{
surface
:
StaticRenderTaskSurface
:
:
ReadOnly
{
source
}
rect
:
cache_item
.
uv_rect
}
;
}
let
target_rect
=
task
.
get_target_rect
(
)
;
task
.
write_gpu_blocks
(
target_rect
gpu_cache
)
;
graph
.
task_data
.
push
(
task
.
kind
.
write_task_data
(
target_rect
)
)
;
}
graph
}
}
impl
RenderTaskGraph
{
#
[
allow
(
dead_code
)
]
pub
fn
print
(
&
self
)
{
print
!
(
"
-
-
RenderTaskGraph
-
-
\
n
"
)
;
for
(
i
task
)
in
self
.
tasks
.
iter
(
)
.
enumerate
(
)
{
print
!
(
"
Task
{
}
[
{
}
]
:
render_on
=
{
}
free_after
=
{
}
children
=
{
:
?
}
target_size
=
{
:
?
}
\
n
"
i
task
.
kind
.
as_str
(
)
task
.
render_on
.
0
task
.
free_after
.
0
task
.
children
task
.
get_target_size
(
)
)
;
}
for
(
p
pass
)
in
self
.
passes
.
iter
(
)
.
enumerate
(
)
{
print
!
(
"
Pass
{
}
:
\
n
"
p
)
;
for
(
s
sub_pass
)
in
pass
.
sub_passes
.
iter
(
)
.
enumerate
(
)
{
print
!
(
"
\
tSubPass
{
}
:
{
:
?
}
\
n
"
s
sub_pass
.
surface
)
;
for
task_id
in
&
sub_pass
.
task_ids
{
print
!
(
"
\
t
\
tTask
{
:
?
}
\
n
"
task_id
.
index
)
;
}
}
}
}
pub
fn
resolve_texture
(
&
self
task_id
:
impl
Into
<
Option
<
RenderTaskId
>
>
)
-
>
Option
<
TextureSource
>
{
let
task_id
=
task_id
.
into
(
)
?
;
let
task
=
&
self
[
task_id
]
;
match
task
.
get_texture_source
(
)
{
TextureSource
:
:
Invalid
=
>
None
source
=
>
Some
(
source
)
}
}
pub
fn
resolve_location
(
&
self
task_id
:
impl
Into
<
Option
<
RenderTaskId
>
>
gpu_cache
:
&
GpuCache
)
-
>
Option
<
(
GpuCacheAddress
TextureSource
)
>
{
self
.
resolve_impl
(
task_id
.
into
(
)
?
gpu_cache
)
}
fn
resolve_impl
(
&
self
task_id
:
RenderTaskId
gpu_cache
:
&
GpuCache
)
-
>
Option
<
(
GpuCacheAddress
TextureSource
)
>
{
let
task
=
&
self
[
task_id
]
;
let
texture_source
=
task
.
get_texture_source
(
)
;
if
let
TextureSource
:
:
Invalid
=
texture_source
{
return
None
;
}
let
uv_address
=
task
.
get_texture_address
(
gpu_cache
)
;
Some
(
(
uv_address
texture_source
)
)
}
pub
fn
report_memory
(
&
self
)
-
>
usize
{
let
mut
mem
=
size_of_frame_vec
(
&
self
.
tasks
)
+
size_of_frame_vec
(
&
self
.
task_data
)
+
size_of_frame_vec
(
&
self
.
passes
)
;
for
pass
in
&
self
.
passes
{
mem
+
=
size_of_frame_vec
(
&
pass
.
task_ids
)
+
size_of_frame_vec
(
&
pass
.
sub_passes
)
+
size_of_frame_vec
(
&
pass
.
textures_to_invalidate
)
;
for
sub_pass
in
&
pass
.
sub_passes
{
mem
+
=
size_of_frame_vec
(
&
sub_pass
.
task_ids
)
;
}
}
mem
}
#
[
cfg
(
test
)
]
pub
fn
new_for_testing
(
)
-
>
Self
{
let
allocator
=
FrameAllocator
:
:
fallback
(
)
;
RenderTaskGraph
{
tasks
:
allocator
.
clone
(
)
.
new_vec
(
)
passes
:
allocator
.
clone
(
)
.
new_vec
(
)
frame_id
:
FrameId
:
:
INVALID
task_data
:
allocator
.
clone
(
)
.
new_vec
(
)
surface_count
:
0
unique_surfaces
:
FastHashSet
:
:
default
(
)
}
}
#
[
cfg
(
test
)
]
pub
fn
surface_counts
(
&
self
)
-
>
(
usize
usize
)
{
(
self
.
surface_count
self
.
unique_surfaces
.
len
(
)
)
}
#
[
cfg
(
debug_assertions
)
]
pub
fn
frame_id
(
&
self
)
-
>
FrameId
{
self
.
frame_id
}
}
impl
std
:
:
ops
:
:
Index
<
RenderTaskId
>
for
RenderTaskGraph
{
type
Output
=
RenderTask
;
fn
index
(
&
self
id
:
RenderTaskId
)
-
>
&
RenderTask
{
&
self
.
tasks
[
id
.
index
as
usize
]
}
}
fn
assign_free_pass
(
id
:
RenderTaskId
graph
:
&
mut
RenderTaskGraph
)
{
let
task
=
&
mut
graph
.
tasks
[
id
.
index
as
usize
]
;
let
render_on
=
task
.
render_on
;
let
mut
child_task_ids
:
SmallVec
<
[
RenderTaskId
;
8
]
>
=
SmallVec
:
:
new
(
)
;
child_task_ids
.
extend_from_slice
(
&
task
.
children
)
;
for
child_id
in
child_task_ids
{
let
child_location
=
graph
.
tasks
[
child_id
.
index
as
usize
]
.
location
.
clone
(
)
;
match
child_location
{
RenderTaskLocation
:
:
CacheRequest
{
.
.
}
=
>
{
}
RenderTaskLocation
:
:
Static
{
.
.
}
=
>
{
}
RenderTaskLocation
:
:
Dynamic
{
.
.
}
=
>
{
panic
!
(
"
bug
:
should
not
be
allocated
yet
"
)
;
}
RenderTaskLocation
:
:
Unallocated
{
.
.
}
=
>
{
let
child_task
=
&
mut
graph
.
tasks
[
child_id
.
index
as
usize
]
;
if
child_task
.
free_after
!
=
PassId
:
:
INVALID
{
child_task
.
free_after
=
child_task
.
free_after
.
min
(
render_on
)
;
}
}
RenderTaskLocation
:
:
Existing
{
parent_task_id
.
.
}
=
>
{
let
parent_task
=
&
mut
graph
.
tasks
[
parent_task_id
.
index
as
usize
]
;
parent_task
.
free_after
=
PassId
:
:
INVALID
;
let
child_task
=
&
mut
graph
.
tasks
[
child_id
.
index
as
usize
]
;
if
child_task
.
free_after
!
=
PassId
:
:
INVALID
{
child_task
.
free_after
=
child_task
.
free_after
.
min
(
render_on
)
;
}
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderPass
{
pub
alpha
:
RenderTargetList
<
ColorRenderTarget
>
pub
color
:
RenderTargetList
<
ColorRenderTarget
>
pub
texture_cache
:
FastHashMap
<
CacheTextureId
TextureCacheRenderTarget
>
pub
picture_cache
:
FrameVec
<
PictureCacheTarget
>
pub
textures_to_invalidate
:
FrameVec
<
CacheTextureId
>
}
impl
RenderPass
{
pub
fn
new
(
src
:
&
Pass
memory
:
&
mut
FrameMemory
)
-
>
Self
{
RenderPass
{
color
:
RenderTargetList
:
:
new
(
memory
.
allocator
(
)
)
alpha
:
RenderTargetList
:
:
new
(
memory
.
allocator
(
)
)
texture_cache
:
FastHashMap
:
:
default
(
)
picture_cache
:
memory
.
allocator
(
)
.
new_vec
(
)
textures_to_invalidate
:
src
.
textures_to_invalidate
.
clone
(
)
}
}
}
#
[
cfg
(
feature
=
"
capture
"
)
]
pub
fn
dump_render_tasks_as_svg
(
render_tasks
:
&
RenderTaskGraph
output
:
&
mut
dyn
std
:
:
io
:
:
Write
)
-
>
std
:
:
io
:
:
Result
<
(
)
>
{
use
svg_fmt
:
:
*
;
let
node_width
=
80
.
0
;
let
node_height
=
30
.
0
;
let
vertical_spacing
=
8
.
0
;
let
horizontal_spacing
=
20
.
0
;
let
margin
=
10
.
0
;
let
text_size
=
10
.
0
;
let
mut
pass_rects
=
Vec
:
:
new
(
)
;
let
mut
nodes
=
vec
!
[
None
;
render_tasks
.
tasks
.
len
(
)
]
;
let
mut
x
=
margin
;
let
mut
max_y
:
f32
=
0
.
0
;
#
[
derive
(
Clone
)
]
struct
Node
{
rect
:
Rectangle
label
:
Text
size
:
Text
}
for
pass
in
render_tasks
.
passes
.
iter
(
)
.
rev
(
)
{
let
mut
layout
=
VerticalLayout
:
:
new
(
x
margin
node_width
)
;
for
task_id
in
&
pass
.
task_ids
{
let
task_index
=
task_id
.
index
as
usize
;
let
task
=
&
render_tasks
.
tasks
[
task_index
]
;
let
rect
=
layout
.
push_rectangle
(
node_height
)
;
let
tx
=
rect
.
x
+
rect
.
w
/
2
.
0
;
let
ty
=
rect
.
y
+
10
.
0
;
let
label
=
text
(
tx
ty
format
!
(
"
{
}
"
task
.
kind
.
as_str
(
)
)
)
;
let
size
=
text
(
tx
ty
+
12
.
0
format
!
(
"
{
:
?
}
"
task
.
location
.
size
(
)
)
)
;
nodes
[
task_index
]
=
Some
(
Node
{
rect
label
size
}
)
;
layout
.
advance
(
vertical_spacing
)
;
}
pass_rects
.
push
(
layout
.
total_rectangle
(
)
)
;
x
+
=
node_width
+
horizontal_spacing
;
max_y
=
max_y
.
max
(
layout
.
y
+
margin
)
;
}
let
mut
links
=
Vec
:
:
new
(
)
;
for
node_index
in
0
.
.
nodes
.
len
(
)
{
if
nodes
[
node_index
]
.
is_none
(
)
{
continue
;
}
let
task
=
&
render_tasks
.
tasks
[
node_index
]
;
for
dep
in
&
task
.
children
{
let
dep_index
=
dep
.
index
as
usize
;
if
let
(
&
Some
(
ref
node
)
&
Some
(
ref
dep_node
)
)
=
(
&
nodes
[
node_index
]
&
nodes
[
dep_index
]
)
{
links
.
push
(
(
dep_node
.
rect
.
x
+
dep_node
.
rect
.
w
dep_node
.
rect
.
y
+
dep_node
.
rect
.
h
/
2
.
0
node
.
rect
.
x
node
.
rect
.
y
+
node
.
rect
.
h
/
2
.
0
)
)
;
}
}
}
let
svg_w
=
x
+
margin
;
let
svg_h
=
max_y
+
margin
;
writeln
!
(
output
"
{
}
"
BeginSvg
{
w
:
svg_w
h
:
svg_h
}
)
?
;
writeln
!
(
output
"
{
}
"
rectangle
(
0
.
0
0
.
0
svg_w
svg_h
)
.
inflate
(
1
.
0
1
.
0
)
.
fill
(
rgb
(
50
50
50
)
)
)
?
;
for
rect
in
pass_rects
{
writeln
!
(
output
"
{
}
"
rect
.
inflate
(
3
.
0
3
.
0
)
.
border_radius
(
4
.
0
)
.
opacity
(
0
.
4
)
.
fill
(
black
(
)
)
)
?
;
}
for
(
x1
y1
x2
y2
)
in
links
{
dump_task_dependency_link
(
output
x1
y1
x2
y2
)
;
}
for
node
in
&
nodes
{
if
let
Some
(
node
)
=
node
{
writeln
!
(
output
"
{
}
"
node
.
rect
.
clone
(
)
.
fill
(
black
(
)
)
.
border_radius
(
3
.
0
)
.
opacity
(
0
.
5
)
.
offset
(
0
.
0
2
.
0
)
)
?
;
writeln
!
(
output
"
{
}
"
node
.
rect
.
clone
(
)
.
fill
(
rgb
(
200
200
200
)
)
.
border_radius
(
3
.
0
)
.
opacity
(
0
.
8
)
)
?
;
writeln
!
(
output
"
{
}
"
node
.
label
.
clone
(
)
.
size
(
text_size
)
.
align
(
Align
:
:
Center
)
.
color
(
rgb
(
50
50
50
)
)
)
?
;
writeln
!
(
output
"
{
}
"
node
.
size
.
clone
(
)
.
size
(
text_size
*
0
.
7
)
.
align
(
Align
:
:
Center
)
.
color
(
rgb
(
50
50
50
)
)
)
?
;
}
}
writeln
!
(
output
"
{
}
"
EndSvg
)
}
#
[
allow
(
dead_code
)
]
fn
dump_task_dependency_link
(
output
:
&
mut
dyn
std
:
:
io
:
:
Write
x1
:
f32
y1
:
f32
x2
:
f32
y2
:
f32
)
{
use
svg_fmt
:
:
*
;
let
simple_path
=
(
y1
-
y2
)
.
abs
(
)
>
1
.
0
|
|
(
x2
-
x1
)
<
45
.
0
;
let
mid_x
=
(
x1
+
x2
)
/
2
.
0
;
if
simple_path
{
write
!
(
output
"
{
}
"
path
(
)
.
move_to
(
x1
y1
)
.
cubic_bezier_to
(
mid_x
y1
mid_x
y2
x2
y2
)
.
fill
(
Fill
:
:
None
)
.
stroke
(
Stroke
:
:
Color
(
rgb
(
100
100
100
)
3
.
0
)
)
)
.
unwrap
(
)
;
}
else
{
let
ctrl1_x
=
(
mid_x
+
x1
)
/
2
.
0
;
let
ctrl2_x
=
(
mid_x
+
x2
)
/
2
.
0
;
let
ctrl_y
=
y1
-
25
.
0
;
write
!
(
output
"
{
}
"
path
(
)
.
move_to
(
x1
y1
)
.
cubic_bezier_to
(
ctrl1_x
y1
ctrl1_x
ctrl_y
mid_x
ctrl_y
)
.
cubic_bezier_to
(
ctrl2_x
ctrl_y
ctrl2_x
y2
x2
y2
)
.
fill
(
Fill
:
:
None
)
.
stroke
(
Stroke
:
:
Color
(
rgb
(
100
100
100
)
3
.
0
)
)
)
.
unwrap
(
)
;
}
}
#
[
cfg
(
test
)
]
fn
pc_target
(
surface_id
:
u64
tile_x
:
i32
tile_y
:
i32
)
-
>
RenderTaskLocation
{
use
crate
:
:
{
composite
:
:
{
NativeSurfaceId
NativeTileId
}
picture
:
:
ResolvedSurfaceTexture
}
;
let
width
=
512
;
let
height
=
512
;
RenderTaskLocation
:
:
Static
{
surface
:
StaticRenderTaskSurface
:
:
PictureCache
{
surface
:
ResolvedSurfaceTexture
:
:
Native
{
id
:
NativeTileId
{
surface_id
:
NativeSurfaceId
(
surface_id
)
x
:
tile_x
y
:
tile_y
}
size
:
DeviceIntSize
:
:
new
(
width
height
)
}
}
rect
:
DeviceIntSize
:
:
new
(
width
height
)
.
into
(
)
}
}
#
[
cfg
(
test
)
]
impl
RenderTaskGraphBuilder
{
fn
test_expect
(
mut
self
pass_count
:
usize
total_surface_count
:
usize
unique_surfaces
:
&
[
(
i32
i32
ImageFormat
)
]
)
{
use
crate
:
:
internal_types
:
:
FrameStamp
;
use
api
:
:
{
DocumentId
IdNamespace
}
;
let
mut
rc
=
ResourceCache
:
:
new_for_testing
(
)
;
let
mut
gc
=
GpuCache
:
:
new
(
)
;
let
mut
frame_stamp
=
FrameStamp
:
:
first
(
DocumentId
:
:
new
(
IdNamespace
(
1
)
1
)
)
;
frame_stamp
.
advance
(
)
;
gc
.
prepare_for_frames
(
)
;
gc
.
begin_frame
(
frame_stamp
)
;
let
frame_memory
=
FrameMemory
:
:
fallback
(
)
;
let
g
=
self
.
end_frame
(
&
mut
rc
&
mut
gc
&
mut
frame_memory
.
new_vec
(
)
2048
&
frame_memory
)
;
g
.
print
(
)
;
assert_eq
!
(
g
.
passes
.
len
(
)
pass_count
)
;
assert_eq
!
(
g
.
surface_counts
(
)
(
total_surface_count
unique_surfaces
.
len
(
)
)
)
;
rc
.
validate_surfaces
(
unique_surfaces
)
;
}
}
#
[
cfg
(
test
)
]
fn
task_location
(
location
:
RenderTaskLocation
)
-
>
RenderTask
{
RenderTask
:
:
new_test
(
location
RenderTargetKind
:
:
Color
)
}
#
[
cfg
(
test
)
]
fn
task_dynamic
(
size
:
i32
)
-
>
RenderTask
{
RenderTask
:
:
new_test
(
RenderTaskLocation
:
:
Unallocated
{
size
:
DeviceIntSize
:
:
new
(
size
size
)
}
RenderTargetKind
:
:
Color
)
}
#
[
test
]
fn
fg_test_1
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
root_target
=
pc_target
(
0
0
0
)
;
let
root
=
gb
.
add
(
)
.
init
(
task_location
(
root_target
.
clone
(
)
)
)
;
let
readback
=
gb
.
add
(
)
.
init
(
task_dynamic
(
100
)
)
;
gb
.
add_dependency
(
readback
root
)
;
let
mix_blend_content
=
gb
.
add
(
)
.
init
(
task_dynamic
(
50
)
)
;
let
content
=
gb
.
add
(
)
.
init
(
task_location
(
root_target
)
)
;
gb
.
add_dependency
(
content
readback
)
;
gb
.
add_dependency
(
content
mix_blend_content
)
;
gb
.
test_expect
(
3
1
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
]
)
;
}
#
[
test
]
fn
fg_test_3
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
pc_root
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
0
0
)
)
)
;
let
child_pic_0
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
let
child_pic_1
=
gb
.
add
(
)
.
init
(
task_dynamic
(
3000
)
)
;
gb
.
add_dependency
(
pc_root
child_pic_0
)
;
gb
.
add_dependency
(
pc_root
child_pic_1
)
;
gb
.
test_expect
(
2
2
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
3072
3072
ImageFormat
:
:
RGBA8
)
]
)
;
}
#
[
test
]
fn
fg_test_4
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
pc_root
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
0
0
)
)
)
;
let
child_pic_0
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
let
child_pic_1
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
let
child_pic_2
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
gb
.
add_dependency
(
pc_root
child_pic_0
)
;
gb
.
add_dependency
(
child_pic_0
child_pic_1
)
;
gb
.
add_dependency
(
child_pic_1
child_pic_2
)
;
gb
.
test_expect
(
4
3
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
2048
2048
ImageFormat
:
:
RGBA8
)
]
)
;
}
#
[
test
]
fn
fg_test_5
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
pc_root
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
0
0
)
)
)
;
let
child_pic_0
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
let
child_pic_1
=
gb
.
add
(
)
.
init
(
task_dynamic
(
64
)
)
;
let
child_pic_2
=
gb
.
add
(
)
.
init
(
task_dynamic
(
32
)
)
;
let
child_pic_3
=
gb
.
add
(
)
.
init
(
task_dynamic
(
16
)
)
;
gb
.
add_dependency
(
pc_root
child_pic_0
)
;
gb
.
add_dependency
(
child_pic_0
child_pic_1
)
;
gb
.
add_dependency
(
child_pic_1
child_pic_2
)
;
gb
.
add_dependency
(
child_pic_2
child_pic_3
)
;
gb
.
add_dependency
(
pc_root
child_pic_3
)
;
gb
.
test_expect
(
5
4
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
2048
2048
ImageFormat
:
:
RGBA8
)
]
)
;
}
#
[
test
]
fn
fg_test_6
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
pc_root_1
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
0
0
)
)
)
;
let
pc_root_2
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
1
0
)
)
)
;
let
child_pic
=
gb
.
add
(
)
.
init
(
task_dynamic
(
128
)
)
;
gb
.
add_dependency
(
pc_root_1
child_pic
)
;
gb
.
add_dependency
(
pc_root_2
child_pic
)
;
gb
.
test_expect
(
2
1
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
]
)
;
}
#
[
test
]
fn
fg_test_7
(
)
{
let
mut
gb
=
RenderTaskGraphBuilder
:
:
new
(
)
;
let
pc_root
=
gb
.
add
(
)
.
init
(
task_location
(
pc_target
(
0
0
0
)
)
)
;
let
child0
=
gb
.
add
(
)
.
init
(
task_dynamic
(
16
)
)
;
let
child1
=
gb
.
add
(
)
.
init
(
task_dynamic
(
16
)
)
;
let
child2
=
gb
.
add
(
)
.
init
(
task_dynamic
(
16
)
)
;
let
child3
=
gb
.
add
(
)
.
init
(
task_dynamic
(
16
)
)
;
gb
.
add_dependency
(
pc_root
child0
)
;
gb
.
add_dependency
(
child0
child1
)
;
gb
.
add_dependency
(
pc_root
child1
)
;
gb
.
add_dependency
(
pc_root
child2
)
;
gb
.
add_dependency
(
child2
child3
)
;
gb
.
test_expect
(
3
3
&
[
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
2048
2048
ImageFormat
:
:
RGBA8
)
(
2048
2048
ImageFormat
:
:
RGBA8
)
]
)
;
}
