use
api
:
:
{
ColorF
PrimitiveFlags
QualitySettings
RasterSpace
ClipId
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipNodeKind
ClipLeafId
ClipNodeId
ClipTreeBuilder
}
;
use
crate
:
:
frame_builder
:
:
FrameBuilderConfig
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
}
;
use
crate
:
:
picture
:
:
{
PrimitiveList
PictureCompositeMode
PicturePrimitive
SliceId
}
;
use
crate
:
:
picture
:
:
{
Picture3DContext
TileCacheParams
TileOffset
PictureFlags
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
PrimitiveStore
PictureIndex
}
;
use
crate
:
:
scene_building
:
:
SliceFlags
;
use
crate
:
:
scene_builder_thread
:
:
Interners
;
use
crate
:
:
spatial_tree
:
:
{
SpatialNodeIndex
SceneSpatialTree
}
;
use
crate
:
:
util
:
:
VecHelper
;
use
std
:
:
mem
;
const
MAX_CACHE_SLICES
:
usize
=
12
;
struct
SliceDescriptor
{
prim_list
:
PrimitiveList
scroll_root
:
SpatialNodeIndex
shared_clip_node_id
:
ClipNodeId
}
enum
SliceKind
{
Default
{
secondary_slices
:
Vec
<
SliceDescriptor
>
}
Atomic
{
prim_list
:
PrimitiveList
}
}
impl
SliceKind
{
fn
default
(
)
-
>
Self
{
SliceKind
:
:
Default
{
secondary_slices
:
Vec
:
:
new
(
)
}
}
}
struct
PrimarySlice
{
kind
:
SliceKind
background_color
:
Option
<
ColorF
>
iframe_clip
:
Option
<
ClipId
>
slice_flags
:
SliceFlags
}
impl
PrimarySlice
{
fn
new
(
slice_flags
:
SliceFlags
iframe_clip
:
Option
<
ClipId
>
background_color
:
Option
<
ColorF
>
)
-
>
Self
{
PrimarySlice
{
kind
:
SliceKind
:
:
default
(
)
background_color
iframe_clip
slice_flags
}
}
fn
has_too_many_slices
(
&
self
)
-
>
bool
{
match
self
.
kind
{
SliceKind
:
:
Atomic
{
.
.
}
=
>
false
SliceKind
:
:
Default
{
ref
secondary_slices
}
=
>
secondary_slices
.
len
(
)
>
MAX_CACHE_SLICES
}
}
fn
merge
(
&
mut
self
)
{
self
.
slice_flags
|
=
SliceFlags
:
:
IS_ATOMIC
;
let
old
=
mem
:
:
replace
(
&
mut
self
.
kind
SliceKind
:
:
Default
{
secondary_slices
:
Vec
:
:
new
(
)
}
)
;
self
.
kind
=
match
old
{
SliceKind
:
:
Default
{
mut
secondary_slices
}
=
>
{
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
for
descriptor
in
secondary_slices
.
drain
(
.
.
)
{
prim_list
.
merge
(
descriptor
.
prim_list
)
;
}
SliceKind
:
:
Atomic
{
prim_list
}
}
atomic
=
>
atomic
}
}
}
pub
struct
TileCacheBuilder
{
primary_slices
:
Vec
<
PrimarySlice
>
prev_scroll_root_cache
:
(
SpatialNodeIndex
SpatialNodeIndex
)
root_spatial_node_index
:
SpatialNodeIndex
}
pub
struct
TileCacheConfig
{
pub
tile_caches
:
FastHashMap
<
SliceId
TileCacheParams
>
pub
picture_cache_slice_count
:
usize
}
impl
TileCacheConfig
{
pub
fn
new
(
picture_cache_slice_count
:
usize
)
-
>
Self
{
TileCacheConfig
{
tile_caches
:
FastHashMap
:
:
default
(
)
picture_cache_slice_count
}
}
}
impl
TileCacheBuilder
{
pub
fn
new
(
root_spatial_node_index
:
SpatialNodeIndex
background_color
:
Option
<
ColorF
>
)
-
>
Self
{
TileCacheBuilder
{
primary_slices
:
vec
!
[
PrimarySlice
:
:
new
(
SliceFlags
:
:
empty
(
)
None
background_color
)
]
prev_scroll_root_cache
:
(
SpatialNodeIndex
:
:
INVALID
SpatialNodeIndex
:
:
INVALID
)
root_spatial_node_index
}
}
pub
fn
make_current_slice_atomic
(
&
mut
self
)
{
self
.
primary_slices
.
last_mut
(
)
.
unwrap
(
)
.
merge
(
)
;
}
pub
fn
is_current_slice_empty
(
&
self
)
-
>
bool
{
match
self
.
primary_slices
.
last
(
)
{
Some
(
slice
)
=
>
{
match
slice
.
kind
{
SliceKind
:
:
Default
{
ref
secondary_slices
}
=
>
{
secondary_slices
.
is_empty
(
)
}
SliceKind
:
:
Atomic
{
ref
prim_list
}
=
>
{
prim_list
.
is_empty
(
)
}
}
}
None
=
>
{
true
}
}
}
pub
fn
add_tile_cache_barrier
(
&
mut
self
slice_flags
:
SliceFlags
iframe_clip
:
Option
<
ClipId
>
)
{
let
new_slice
=
PrimarySlice
:
:
new
(
slice_flags
iframe_clip
None
)
;
self
.
primary_slices
.
push
(
new_slice
)
;
}
fn
build_tile_cache
(
&
mut
self
prim_list
:
PrimitiveList
spatial_tree
:
&
SceneSpatialTree
prim_instances
:
&
[
PrimitiveInstance
]
clip_tree_builder
:
&
ClipTreeBuilder
)
-
>
Option
<
SliceDescriptor
>
{
if
prim_list
.
is_empty
(
)
{
return
None
;
}
let
mut
scroll_root_occurrences
=
FastHashMap
:
:
default
(
)
;
for
cluster
in
&
prim_list
.
clusters
{
if
cluster
.
spatial_node_index
=
=
SpatialNodeIndex
:
:
UNKNOWN
{
continue
;
}
let
scroll_root
=
find_scroll_root
(
cluster
.
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
*
scroll_root_occurrences
.
entry
(
scroll_root
)
.
or_insert
(
0
)
+
=
1
;
}
let
scroll_roots
:
Vec
<
SpatialNodeIndex
>
=
scroll_root_occurrences
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
scroll_root_occurrences
.
retain
(
|
parent_spatial_node_index
_
|
{
scroll_roots
.
iter
(
)
.
all
(
|
child_spatial_node_index
|
{
parent_spatial_node_index
=
=
child_spatial_node_index
|
|
spatial_tree
.
is_ancestor
(
*
parent_spatial_node_index
*
child_spatial_node_index
)
}
)
}
)
;
let
scroll_root
=
scroll_root_occurrences
.
iter
(
)
.
max_by_key
(
|
entry
|
entry
.
1
)
.
map
(
|
(
spatial_node_index
_
)
|
*
spatial_node_index
)
.
unwrap_or
(
self
.
root_spatial_node_index
)
;
let
mut
shared_clip_node_id
=
None
;
for
cluster
in
&
prim_list
.
clusters
{
for
prim_instance
in
&
prim_instances
[
cluster
.
prim_range
(
)
]
{
let
leaf
=
clip_tree_builder
.
get_leaf
(
prim_instance
.
clip_leaf_id
)
;
shared_clip_node_id
=
match
shared_clip_node_id
{
Some
(
current
)
=
>
{
Some
(
clip_tree_builder
.
find_lowest_common_ancestor
(
current
leaf
.
node_id
)
)
}
None
=
>
{
Some
(
leaf
.
node_id
)
}
}
}
}
let
shared_clip_node_id
=
shared_clip_node_id
.
expect
(
"
bug
:
no
shared
clip
root
"
)
;
Some
(
SliceDescriptor
{
scroll_root
shared_clip_node_id
prim_list
}
)
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
spatial_tree
:
&
SceneSpatialTree
interners
:
&
Interners
quality_settings
:
&
QualitySettings
prim_instances
:
&
mut
Vec
<
PrimitiveInstance
>
clip_tree_builder
:
&
ClipTreeBuilder
)
{
let
primary_slice
=
self
.
primary_slices
.
last_mut
(
)
.
unwrap
(
)
;
match
primary_slice
.
kind
{
SliceKind
:
:
Atomic
{
ref
mut
prim_list
}
=
>
{
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
prim_instances
clip_tree_builder
)
;
}
SliceKind
:
:
Default
{
ref
mut
secondary_slices
}
=
>
{
assert_ne
!
(
spatial_node_index
SpatialNodeIndex
:
:
UNKNOWN
)
;
let
scroll_root
=
find_scroll_root
(
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
let
current_scroll_root
=
secondary_slices
.
last
(
)
.
map
(
|
p
|
p
.
scroll_root
)
;
let
mut
want_new_tile_cache
=
secondary_slices
.
is_empty
(
)
;
if
let
Some
(
current_scroll_root
)
=
current_scroll_root
{
want_new_tile_cache
|
=
match
(
current_scroll_root
scroll_root
)
{
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
&
&
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
false
}
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
true
}
(
_
_
)
if
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
if
quality_settings
.
force_subpixel_aa_where_possible
{
false
}
else
{
let
mut
create_slice
=
true
;
let
leaf
=
clip_tree_builder
.
get_leaf
(
prim_instance
.
clip_leaf_id
)
;
let
mut
current_node_id
=
leaf
.
node_id
;
while
current_node_id
!
=
ClipNodeId
:
:
NONE
{
let
node
=
clip_tree_builder
.
get_node
(
current_node_id
)
;
let
clip_node_data
=
&
interners
.
clip
[
node
.
handle
]
;
let
spatial_root
=
find_scroll_root
(
clip_node_data
.
key
.
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
if
spatial_root
!
=
self
.
root_spatial_node_index
{
create_slice
=
false
;
break
;
}
current_node_id
=
node
.
parent
;
}
create_slice
}
}
(
curr_scroll_root
scroll_root
)
=
>
{
curr_scroll_root
!
=
scroll_root
}
}
;
let
shared_clip_node_id
=
find_shared_clip_root
(
current_scroll_root
prim_instance
.
clip_leaf_id
spatial_tree
clip_tree_builder
interners
)
;
let
current_shared_clip_node_id
=
secondary_slices
.
last
(
)
.
unwrap
(
)
.
shared_clip_node_id
;
want_new_tile_cache
|
=
shared_clip_node_id
!
=
current_shared_clip_node_id
;
}
if
want_new_tile_cache
{
let
shared_clip_node_id
=
find_shared_clip_root
(
scroll_root
prim_instance
.
clip_leaf_id
spatial_tree
clip_tree_builder
interners
)
;
secondary_slices
.
push
(
SliceDescriptor
{
prim_list
:
PrimitiveList
:
:
empty
(
)
scroll_root
shared_clip_node_id
}
)
;
}
secondary_slices
.
last_mut
(
)
.
unwrap
(
)
.
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
prim_instances
clip_tree_builder
)
;
}
}
}
pub
fn
build
(
mut
self
config
:
&
FrameBuilderConfig
prim_store
:
&
mut
PrimitiveStore
spatial_tree
:
&
SceneSpatialTree
prim_instances
:
&
[
PrimitiveInstance
]
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
-
>
(
TileCacheConfig
Vec
<
PictureIndex
>
)
{
let
mut
result
=
TileCacheConfig
:
:
new
(
self
.
primary_slices
.
len
(
)
)
;
let
mut
tile_cache_pictures
=
Vec
:
:
new
(
)
;
let
primary_slices
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
primary_slices
Vec
:
:
new
(
)
)
;
for
mut
primary_slice
in
primary_slices
{
if
primary_slice
.
has_too_many_slices
(
)
{
primary_slice
.
merge
(
)
;
}
match
primary_slice
.
kind
{
SliceKind
:
:
Atomic
{
prim_list
}
=
>
{
if
let
Some
(
descriptor
)
=
self
.
build_tile_cache
(
prim_list
spatial_tree
prim_instances
clip_tree_builder
)
{
create_tile_cache
(
primary_slice
.
slice_flags
descriptor
.
scroll_root
primary_slice
.
iframe_clip
descriptor
.
prim_list
primary_slice
.
background_color
descriptor
.
shared_clip_node_id
prim_store
config
&
mut
result
.
tile_caches
&
mut
tile_cache_pictures
clip_tree_builder
)
;
}
}
SliceKind
:
:
Default
{
secondary_slices
}
=
>
{
for
descriptor
in
secondary_slices
{
create_tile_cache
(
primary_slice
.
slice_flags
descriptor
.
scroll_root
primary_slice
.
iframe_clip
descriptor
.
prim_list
primary_slice
.
background_color
descriptor
.
shared_clip_node_id
prim_store
config
&
mut
result
.
tile_caches
&
mut
tile_cache_pictures
clip_tree_builder
)
;
}
}
}
}
(
result
tile_cache_pictures
)
}
}
fn
find_scroll_root
(
spatial_node_index
:
SpatialNodeIndex
prev_scroll_root_cache
:
&
mut
(
SpatialNodeIndex
SpatialNodeIndex
)
spatial_tree
:
&
SceneSpatialTree
)
-
>
SpatialNodeIndex
{
if
prev_scroll_root_cache
.
0
=
=
spatial_node_index
{
return
prev_scroll_root_cache
.
1
;
}
let
scroll_root
=
spatial_tree
.
find_scroll_root
(
spatial_node_index
)
;
*
prev_scroll_root_cache
=
(
spatial_node_index
scroll_root
)
;
scroll_root
}
fn
find_shared_clip_root
(
scroll_root
:
SpatialNodeIndex
clip_leaf_id
:
ClipLeafId
spatial_tree
:
&
SceneSpatialTree
clip_tree_builder
:
&
ClipTreeBuilder
interners
:
&
Interners
)
-
>
ClipNodeId
{
let
leaf
=
clip_tree_builder
.
get_leaf
(
clip_leaf_id
)
;
let
mut
current_node_id
=
leaf
.
node_id
;
while
current_node_id
!
=
ClipNodeId
:
:
NONE
{
let
node
=
clip_tree_builder
.
get_node
(
current_node_id
)
;
let
clip_node_data
=
&
interners
.
clip
[
node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
key
.
kind
.
node_kind
(
)
{
let
is_ancestor
=
spatial_tree
.
is_ancestor
(
clip_node_data
.
key
.
spatial_node_index
scroll_root
)
;
let
has_complex_clips
=
clip_tree_builder
.
clip_node_has_complex_clips
(
current_node_id
interners
)
;
if
is_ancestor
&
&
!
has_complex_clips
{
break
;
}
}
current_node_id
=
node
.
parent
;
}
current_node_id
}
fn
create_tile_cache
(
slice_flags
:
SliceFlags
scroll_root
:
SpatialNodeIndex
iframe_clip
:
Option
<
ClipId
>
prim_list
:
PrimitiveList
background_color
:
Option
<
ColorF
>
shared_clip_node_id
:
ClipNodeId
prim_store
:
&
mut
PrimitiveStore
frame_builder_config
:
&
FrameBuilderConfig
tile_caches
:
&
mut
FastHashMap
<
SliceId
TileCacheParams
>
tile_cache_pictures
:
&
mut
Vec
<
PictureIndex
>
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
{
let
mut
additional_clips
=
Vec
:
:
new
(
)
;
if
let
Some
(
clip_id
)
=
iframe_clip
{
additional_clips
.
push
(
clip_id
)
;
}
let
shared_clip_leaf_id
=
Some
(
clip_tree_builder
.
build_for_tile_cache
(
shared_clip_node_id
&
additional_clips
)
)
;
let
slice
=
tile_cache_pictures
.
len
(
)
;
let
background_color
=
if
slice
=
=
0
{
background_color
}
else
{
None
}
;
let
slice_id
=
SliceId
:
:
new
(
slice
)
;
let
overlay_surface_count
=
if
prim_list
.
has_opaque_compositor_surface
{
0
}
else
{
prim_list
.
overlay_surface_count
}
;
tile_caches
.
insert
(
slice_id
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clip_node_id
shared_clip_leaf_id
virtual_surface_size
:
frame_builder_config
.
compositor_kind
.
get_virtual_surface_size
(
)
overlay_surface_count
}
)
;
let
pic_index
=
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
TileCache
{
slice_id
}
)
Picture3DContext
:
:
Out
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
prim_list
scroll_root
RasterSpace
:
:
Screen
PictureFlags
:
:
empty
(
)
)
)
;
tile_cache_pictures
.
push
(
PictureIndex
(
pic_index
)
)
;
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureCacheDebugInfo
{
pub
slices
:
FastHashMap
<
usize
SliceDebugInfo
>
}
impl
PictureCacheDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
PictureCacheDebugInfo
{
slices
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
slice
(
&
self
slice
:
usize
)
-
>
&
SliceDebugInfo
{
&
self
.
slices
[
&
slice
]
}
}
impl
Default
for
PictureCacheDebugInfo
{
fn
default
(
)
-
>
PictureCacheDebugInfo
{
PictureCacheDebugInfo
:
:
new
(
)
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SliceDebugInfo
{
pub
tiles
:
FastHashMap
<
TileOffset
TileDebugInfo
>
}
impl
SliceDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
SliceDebugInfo
{
tiles
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
tile
(
&
self
x
:
i32
y
:
i32
)
-
>
&
TileDebugInfo
{
&
self
.
tiles
[
&
TileOffset
:
:
new
(
x
y
)
]
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DirtyTileDebugInfo
{
pub
local_valid_rect
:
PictureRect
pub
local_dirty_rect
:
PictureRect
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TileDebugInfo
{
Occluded
Culled
Valid
Dirty
(
DirtyTileDebugInfo
)
}
impl
TileDebugInfo
{
pub
fn
is_occluded
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Occluded
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Valid
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_culled
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Culled
=
>
true
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
as_dirty
(
&
self
)
-
>
&
DirtyTileDebugInfo
{
match
self
{
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
=
>
{
panic
!
(
"
not
a
dirty
tile
!
"
)
;
}
TileDebugInfo
:
:
Dirty
(
ref
info
)
=
>
{
info
}
}
}
}
