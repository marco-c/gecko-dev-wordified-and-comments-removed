use
api
:
:
{
ColorF
PrimitiveFlags
RasterSpace
QualitySettings
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipChainId
ClipNodeKind
ClipStore
ClipInstance
}
;
use
crate
:
:
frame_builder
:
:
FrameBuilderConfig
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FastHashSet
}
;
use
crate
:
:
picture
:
:
{
PrimitiveList
PictureCompositeMode
PictureOptions
PicturePrimitive
SliceId
}
;
use
crate
:
:
picture
:
:
{
Picture3DContext
TileCacheParams
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
PrimitiveInstanceKind
PrimitiveStore
PictureIndex
SegmentInstanceIndex
}
;
use
crate
:
:
prim_store
:
:
picture
:
:
{
Picture
PictureKey
PictureCompositeKey
}
;
use
crate
:
:
scene_building
:
:
SliceFlags
;
use
crate
:
:
scene_builder_thread
:
:
Interners
;
use
crate
:
:
spatial_tree
:
:
{
ROOT_SPATIAL_NODE_INDEX
SpatialNodeIndex
SpatialTree
}
;
use
crate
:
:
util
:
:
{
MaxRect
VecHelper
}
;
pub
struct
PendingTileCache
{
pub
prim_list
:
PrimitiveList
pub
params
:
TileCacheParams
}
pub
struct
TileCacheBuilder
{
need_new_tile_cache
:
bool
pending_tile_caches
:
Vec
<
PendingTileCache
>
prev_scroll_root_cache
:
(
SpatialNodeIndex
SpatialNodeIndex
)
prim_clips_buffer
:
Vec
<
ClipInstance
>
last_checked_clip_chain
:
ClipChainId
}
pub
struct
TileCacheConfig
{
pub
tile_caches
:
FastHashMap
<
SliceId
TileCacheParams
>
pub
picture_cache_spatial_nodes
:
FastHashSet
<
SpatialNodeIndex
>
pub
picture_cache_slice_count
:
usize
}
impl
TileCacheConfig
{
pub
fn
new
(
picture_cache_slice_count
:
usize
)
-
>
Self
{
TileCacheConfig
{
tile_caches
:
FastHashMap
:
:
default
(
)
picture_cache_spatial_nodes
:
FastHashSet
:
:
default
(
)
picture_cache_slice_count
}
}
}
impl
TileCacheBuilder
{
pub
fn
new
(
)
-
>
Self
{
TileCacheBuilder
{
need_new_tile_cache
:
true
pending_tile_caches
:
Vec
:
:
new
(
)
prev_scroll_root_cache
:
(
ROOT_SPATIAL_NODE_INDEX
ROOT_SPATIAL_NODE_INDEX
)
prim_clips_buffer
:
Vec
:
:
new
(
)
last_checked_clip_chain
:
ClipChainId
:
:
INVALID
}
}
pub
fn
add_tile_cache_barrier
(
&
mut
self
)
{
self
.
need_new_tile_cache
=
true
;
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
spatial_tree
:
&
SpatialTree
clip_store
:
&
ClipStore
interners
:
&
Interners
config
:
&
FrameBuilderConfig
quality_settings
:
&
QualitySettings
)
{
let
is_scrollbar_container
=
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_SCROLLBAR_CONTAINER
)
;
let
is_clear_prim
=
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
=
>
true
_
=
>
false
}
;
let
requires_own_slice
=
is_scrollbar_container
|
|
is_clear_prim
;
let
mut
new_tile_cache
=
self
.
need_new_tile_cache
|
|
requires_own_slice
;
let
scroll_root
=
self
.
find_scroll_root
(
spatial_node_index
spatial_tree
)
;
let
current_scroll_root
=
self
.
pending_tile_caches
.
last
(
)
.
map
(
|
p
|
p
.
params
.
spatial_node_index
)
.
unwrap_or
(
ROOT_SPATIAL_NODE_INDEX
)
;
new_tile_cache
|
=
match
(
current_scroll_root
scroll_root
)
{
(
ROOT_SPATIAL_NODE_INDEX
ROOT_SPATIAL_NODE_INDEX
)
=
>
{
false
}
(
ROOT_SPATIAL_NODE_INDEX
_
)
=
>
{
true
}
(
_
ROOT_SPATIAL_NODE_INDEX
)
=
>
{
if
quality_settings
.
force_subpixel_aa_where_possible
{
false
}
else
{
let
mut
create_slice
=
true
;
let
mut
current_clip_chain_id
=
prim_instance
.
clip_set
.
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
spatial_root
=
self
.
find_scroll_root
(
clip_chain_node
.
spatial_node_index
spatial_tree
)
;
if
spatial_root
!
=
ROOT_SPATIAL_NODE_INDEX
{
create_slice
=
false
;
break
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
create_slice
}
}
(
curr_scroll_root
scroll_root
)
=
>
{
curr_scroll_root
!
=
scroll_root
}
}
;
if
new_tile_cache
{
let
slice
=
self
.
pending_tile_caches
.
len
(
)
;
let
slice_flags
=
if
is_scrollbar_container
{
SliceFlags
:
:
IS_SCROLLBAR
}
else
{
SliceFlags
:
:
empty
(
)
}
;
let
background_color
=
if
slice
=
=
0
{
config
.
background_color
}
else
{
None
}
;
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
add_clips
(
prim_instance
.
clip_set
.
clip_chain_id
&
mut
shared_clips
clip_store
interners
)
;
self
.
pending_tile_caches
.
push
(
PendingTileCache
{
prim_list
:
PrimitiveList
:
:
empty
(
)
params
:
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clips
shared_clip_chain
:
ClipChainId
:
:
NONE
virtual_surface_size
:
config
.
compositor_kind
.
get_virtual_surface_size
(
)
}
}
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
self
.
need_new_tile_cache
=
requires_own_slice
;
}
let
pending_tile_cache
=
self
.
pending_tile_caches
.
last_mut
(
)
.
unwrap
(
)
;
if
self
.
last_checked_clip_chain
!
=
prim_instance
.
clip_set
.
clip_chain_id
{
let
prim_clips_buffer
=
&
mut
self
.
prim_clips_buffer
;
prim_clips_buffer
.
clear
(
)
;
add_clips
(
prim_instance
.
clip_set
.
clip_chain_id
prim_clips_buffer
clip_store
interners
)
;
pending_tile_cache
.
params
.
shared_clips
.
retain
(
|
h1
:
&
ClipInstance
|
{
let
uid
=
h1
.
handle
.
uid
(
)
;
prim_clips_buffer
.
iter
(
)
.
any
(
|
h2
|
{
uid
=
=
h2
.
handle
.
uid
(
)
&
&
h1
.
spatial_node_index
=
=
h2
.
spatial_node_index
}
)
}
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
}
pending_tile_cache
.
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
)
;
}
pub
fn
build
(
self
config
:
&
FrameBuilderConfig
interners
:
&
mut
Interners
clip_store
:
&
mut
ClipStore
prim_store
:
&
mut
PrimitiveStore
)
-
>
(
TileCacheConfig
PrimitiveList
)
{
let
mut
result
=
TileCacheConfig
:
:
new
(
self
.
pending_tile_caches
.
len
(
)
)
;
let
mut
root_prim_list
=
PrimitiveList
:
:
empty
(
)
;
const
MAX_CACHE_SLICES
:
usize
=
10
;
if
self
.
pending_tile_caches
.
len
(
)
>
MAX_CACHE_SLICES
{
let
mut
combined_prim_list
=
PrimitiveList
:
:
empty
(
)
;
for
pending_tile_cache
in
self
.
pending_tile_caches
{
combined_prim_list
.
extend
(
pending_tile_cache
.
prim_list
)
;
}
let
prim_instance
=
create_tile_cache
(
0
SliceFlags
:
:
empty
(
)
ROOT_SPATIAL_NODE_INDEX
combined_prim_list
config
.
background_color
Vec
:
:
new
(
)
interners
prim_store
clip_store
&
mut
result
.
picture_cache_spatial_nodes
config
&
mut
result
.
tile_caches
)
;
root_prim_list
.
add_prim
(
prim_instance
LayoutRect
:
:
zero
(
)
ROOT_SPATIAL_NODE_INDEX
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
;
}
else
{
for
pending_tile_cache
in
self
.
pending_tile_caches
{
let
prim_instance
=
create_tile_cache
(
pending_tile_cache
.
params
.
slice
pending_tile_cache
.
params
.
slice_flags
pending_tile_cache
.
params
.
spatial_node_index
pending_tile_cache
.
prim_list
pending_tile_cache
.
params
.
background_color
pending_tile_cache
.
params
.
shared_clips
interners
prim_store
clip_store
&
mut
result
.
picture_cache_spatial_nodes
config
&
mut
result
.
tile_caches
)
;
root_prim_list
.
add_prim
(
prim_instance
LayoutRect
:
:
zero
(
)
pending_tile_cache
.
params
.
spatial_node_index
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
;
}
}
(
result
root_prim_list
)
}
fn
find_scroll_root
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
-
>
SpatialNodeIndex
{
if
self
.
prev_scroll_root_cache
.
0
=
=
spatial_node_index
{
return
self
.
prev_scroll_root_cache
.
1
;
}
let
scroll_root
=
spatial_tree
.
find_scroll_root
(
spatial_node_index
)
;
self
.
prev_scroll_root_cache
=
(
spatial_node_index
scroll_root
)
;
scroll_root
}
}
fn
add_clips
(
clip_chain_id
:
ClipChainId
prim_clips
:
&
mut
Vec
<
ClipInstance
>
clip_store
:
&
ClipStore
interners
:
&
Interners
)
{
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
prim_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
clip_chain_node
.
spatial_node_index
)
)
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
fn
create_tile_cache
(
slice
:
usize
slice_flags
:
SliceFlags
scroll_root
:
SpatialNodeIndex
prim_list
:
PrimitiveList
background_color
:
Option
<
ColorF
>
shared_clips
:
Vec
<
ClipInstance
>
interners
:
&
mut
Interners
prim_store
:
&
mut
PrimitiveStore
clip_store
:
&
mut
ClipStore
picture_cache_spatial_nodes
:
&
mut
FastHashSet
<
SpatialNodeIndex
>
frame_builder_config
:
&
FrameBuilderConfig
tile_caches
:
&
mut
FastHashMap
<
SliceId
TileCacheParams
>
)
-
>
PrimitiveInstance
{
picture_cache_spatial_nodes
.
insert
(
scroll_root
)
;
let
pic_key
=
PictureKey
:
:
new
(
Picture
{
composite_mode_key
:
PictureCompositeKey
:
:
Identity
}
)
;
let
pic_data_handle
=
interners
.
picture
.
intern
(
&
pic_key
|
|
(
)
)
;
let
mut
parent_clip_chain_id
=
ClipChainId
:
:
NONE
;
for
clip_instance
in
&
shared_clips
{
picture_cache_spatial_nodes
.
insert
(
clip_instance
.
spatial_node_index
)
;
parent_clip_chain_id
=
clip_store
.
add_clip_chain_node
(
clip_instance
.
handle
clip_instance
.
spatial_node_index
parent_clip_chain_id
)
;
}
let
slice_id
=
SliceId
:
:
new
(
slice
)
;
tile_caches
.
insert
(
slice_id
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clips
shared_clip_chain
:
parent_clip_chain_id
virtual_surface_size
:
frame_builder_config
.
compositor_kind
.
get_virtual_surface_size
(
)
}
)
;
let
pic_index
=
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
TileCache
{
slice_id
}
)
Picture3DContext
:
:
Out
None
true
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
RasterSpace
:
:
Screen
prim_list
scroll_root
PictureOptions
:
:
default
(
)
)
)
;
PrimitiveInstance
:
:
new
(
LayoutRect
:
:
max_rect
(
)
PrimitiveInstanceKind
:
:
Picture
{
data_handle
:
pic_data_handle
pic_index
:
PictureIndex
(
pic_index
)
segment_instance_index
:
SegmentInstanceIndex
:
:
INVALID
}
parent_clip_chain_id
)
}
