use
api
:
:
{
ColorF
PrimitiveFlags
QualitySettings
RasterSpace
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipChainId
ClipNodeKind
ClipStore
ClipInstance
}
;
use
crate
:
:
frame_builder
:
:
FrameBuilderConfig
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
}
;
use
crate
:
:
picture
:
:
{
PrimitiveList
PictureCompositeMode
PicturePrimitive
SliceId
}
;
use
crate
:
:
picture
:
:
{
Picture3DContext
TileCacheParams
TileOffset
PictureFlags
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
PrimitiveStore
PictureIndex
}
;
use
crate
:
:
scene_building
:
:
SliceFlags
;
use
crate
:
:
scene_builder_thread
:
:
Interners
;
use
crate
:
:
spatial_tree
:
:
{
SpatialNodeIndex
SceneSpatialTree
}
;
use
crate
:
:
util
:
:
VecHelper
;
use
std
:
:
mem
;
const
MAX_CACHE_SLICES
:
usize
=
12
;
struct
SliceDescriptor
{
prim_list
:
PrimitiveList
scroll_root
:
SpatialNodeIndex
shared_clips
:
Vec
<
ClipInstance
>
}
enum
SliceKind
{
Default
{
secondary_slices
:
Vec
<
SliceDescriptor
>
}
Atomic
{
prim_list
:
PrimitiveList
}
}
impl
SliceKind
{
fn
default
(
)
-
>
Self
{
SliceKind
:
:
Default
{
secondary_slices
:
Vec
:
:
new
(
)
}
}
}
struct
PrimarySlice
{
kind
:
SliceKind
background_color
:
Option
<
ColorF
>
iframe_clip
:
Option
<
ClipChainId
>
slice_flags
:
SliceFlags
clip_chain_id
:
ClipChainId
}
impl
PrimarySlice
{
fn
new
(
slice_flags
:
SliceFlags
iframe_clip
:
Option
<
ClipChainId
>
background_color
:
Option
<
ColorF
>
)
-
>
Self
{
PrimarySlice
{
kind
:
SliceKind
:
:
default
(
)
background_color
iframe_clip
slice_flags
clip_chain_id
:
ClipChainId
:
:
NONE
}
}
fn
atomic
(
prim_list
:
PrimitiveList
iframe_clip
:
Option
<
ClipChainId
>
clip_chain_id
:
ClipChainId
)
-
>
Self
{
PrimarySlice
{
kind
:
SliceKind
:
:
Atomic
{
prim_list
}
background_color
:
None
iframe_clip
slice_flags
:
SliceFlags
:
:
IS_ATOMIC
clip_chain_id
}
}
fn
has_too_many_slices
(
&
self
)
-
>
bool
{
match
self
.
kind
{
SliceKind
:
:
Atomic
{
.
.
}
=
>
false
SliceKind
:
:
Default
{
ref
secondary_slices
}
=
>
secondary_slices
.
len
(
)
>
MAX_CACHE_SLICES
}
}
fn
merge
(
&
mut
self
)
{
self
.
slice_flags
|
=
SliceFlags
:
:
IS_ATOMIC
;
let
old
=
mem
:
:
replace
(
&
mut
self
.
kind
SliceKind
:
:
Default
{
secondary_slices
:
Vec
:
:
new
(
)
}
)
;
self
.
kind
=
match
old
{
SliceKind
:
:
Default
{
mut
secondary_slices
}
=
>
{
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
for
descriptor
in
secondary_slices
.
drain
(
.
.
)
{
prim_list
.
merge
(
descriptor
.
prim_list
)
;
}
SliceKind
:
:
Atomic
{
prim_list
}
}
atomic
=
>
atomic
}
}
}
pub
struct
TileCacheBuilder
{
primary_slices
:
Vec
<
PrimarySlice
>
prev_scroll_root_cache
:
(
SpatialNodeIndex
SpatialNodeIndex
)
prim_clips_buffer
:
Vec
<
ClipInstance
>
last_checked_clip_chain
:
ClipChainId
root_spatial_node_index
:
SpatialNodeIndex
}
pub
struct
TileCacheConfig
{
pub
tile_caches
:
FastHashMap
<
SliceId
TileCacheParams
>
pub
picture_cache_slice_count
:
usize
}
impl
TileCacheConfig
{
pub
fn
new
(
picture_cache_slice_count
:
usize
)
-
>
Self
{
TileCacheConfig
{
tile_caches
:
FastHashMap
:
:
default
(
)
picture_cache_slice_count
}
}
}
impl
TileCacheBuilder
{
pub
fn
new
(
root_spatial_node_index
:
SpatialNodeIndex
background_color
:
Option
<
ColorF
>
)
-
>
Self
{
TileCacheBuilder
{
primary_slices
:
vec
!
[
PrimarySlice
:
:
new
(
SliceFlags
:
:
empty
(
)
None
background_color
)
]
prev_scroll_root_cache
:
(
SpatialNodeIndex
:
:
INVALID
SpatialNodeIndex
:
:
INVALID
)
prim_clips_buffer
:
Vec
:
:
new
(
)
last_checked_clip_chain
:
ClipChainId
:
:
INVALID
root_spatial_node_index
}
}
pub
fn
make_current_slice_atomic
(
&
mut
self
)
{
self
.
primary_slices
.
last_mut
(
)
.
unwrap
(
)
.
merge
(
)
;
}
pub
fn
add_tile_cache_barrier
(
&
mut
self
slice_flags
:
SliceFlags
iframe_clip
:
Option
<
ClipChainId
>
)
{
let
new_slice
=
PrimarySlice
:
:
new
(
slice_flags
iframe_clip
None
)
;
self
.
primary_slices
.
push
(
new_slice
)
;
}
pub
fn
add_tile_cache
(
&
mut
self
prim_list
:
PrimitiveList
clip_chain_id
:
ClipChainId
iframe_clip
:
Option
<
ClipChainId
>
)
{
let
atomic_slice
=
PrimarySlice
:
:
atomic
(
prim_list
iframe_clip
clip_chain_id
)
;
let
next_slice
=
PrimarySlice
:
:
new
(
SliceFlags
:
:
empty
(
)
iframe_clip
None
)
;
self
.
primary_slices
.
push
(
atomic_slice
)
;
self
.
primary_slices
.
push
(
next_slice
)
;
}
fn
build_tile_cache
(
&
mut
self
prim_list
:
PrimitiveList
clip_chain_id
:
ClipChainId
spatial_tree
:
&
SceneSpatialTree
clip_store
:
&
ClipStore
interners
:
&
Interners
prim_instances
:
&
[
PrimitiveInstance
]
)
-
>
Option
<
SliceDescriptor
>
{
if
prim_list
.
is_empty
(
)
{
return
None
;
}
let
mut
scroll_root_occurrences
=
FastHashMap
:
:
default
(
)
;
for
cluster
in
&
prim_list
.
clusters
{
if
cluster
.
spatial_node_index
=
=
SpatialNodeIndex
:
:
UNKNOWN
{
continue
;
}
let
scroll_root
=
find_scroll_root
(
cluster
.
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
*
scroll_root_occurrences
.
entry
(
scroll_root
)
.
or_insert
(
0
)
+
=
1
;
}
let
scroll_roots
:
Vec
<
SpatialNodeIndex
>
=
scroll_root_occurrences
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
scroll_root_occurrences
.
retain
(
|
parent_spatial_node_index
_
|
{
let
parent_is_root
=
spatial_tree
.
is_root_coord_system
(
*
parent_spatial_node_index
)
;
scroll_roots
.
iter
(
)
.
all
(
|
child_spatial_node_index
|
{
let
child_is_root
=
spatial_tree
.
is_root_coord_system
(
*
child_spatial_node_index
)
;
(
parent_is_root
&
&
child_is_root
)
|
|
parent_spatial_node_index
=
=
child_spatial_node_index
|
|
spatial_tree
.
is_ancestor
(
*
parent_spatial_node_index
*
child_spatial_node_index
)
}
)
}
)
;
let
scroll_root
=
scroll_root_occurrences
.
iter
(
)
.
max_by_key
(
|
entry
|
entry
.
1
)
.
map
(
|
(
spatial_node_index
_
)
|
*
spatial_node_index
)
.
unwrap_or
(
self
.
root_spatial_node_index
)
;
let
mut
first
=
true
;
let
prim_clips_buffer
=
&
mut
self
.
prim_clips_buffer
;
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
for
cluster
in
&
prim_list
.
clusters
{
for
prim_instance
in
&
prim_instances
[
cluster
.
prim_range
(
)
]
{
if
first
{
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
&
mut
shared_clips
clip_store
interners
spatial_tree
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
first
=
false
;
}
else
{
if
self
.
last_checked_clip_chain
!
=
prim_instance
.
clip_set
.
clip_chain_id
{
prim_clips_buffer
.
clear
(
)
;
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
prim_clips_buffer
clip_store
interners
spatial_tree
)
;
shared_clips
.
retain
(
|
h1
:
&
ClipInstance
|
{
let
uid
=
h1
.
handle
.
uid
(
)
;
prim_clips_buffer
.
iter
(
)
.
any
(
|
h2
|
{
uid
=
=
h2
.
handle
.
uid
(
)
}
)
}
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
}
}
}
}
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
shared_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
)
)
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
Some
(
SliceDescriptor
{
scroll_root
shared_clips
prim_list
}
)
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
spatial_tree
:
&
SceneSpatialTree
clip_store
:
&
ClipStore
interners
:
&
Interners
quality_settings
:
&
QualitySettings
prim_instances
:
&
mut
Vec
<
PrimitiveInstance
>
)
{
let
primary_slice
=
self
.
primary_slices
.
last_mut
(
)
.
unwrap
(
)
;
match
primary_slice
.
kind
{
SliceKind
:
:
Atomic
{
ref
mut
prim_list
}
=
>
{
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
prim_instances
)
;
}
SliceKind
:
:
Default
{
ref
mut
secondary_slices
}
=
>
{
assert_ne
!
(
spatial_node_index
SpatialNodeIndex
:
:
UNKNOWN
)
;
let
scroll_root
=
find_scroll_root
(
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
let
current_scroll_root
=
secondary_slices
.
last
(
)
.
map
(
|
p
|
p
.
scroll_root
)
;
let
mut
want_new_tile_cache
=
secondary_slices
.
is_empty
(
)
;
if
let
Some
(
current_scroll_root
)
=
current_scroll_root
{
want_new_tile_cache
|
=
match
(
current_scroll_root
scroll_root
)
{
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
&
&
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
false
}
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
true
}
(
_
_
)
if
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
if
quality_settings
.
force_subpixel_aa_where_possible
{
false
}
else
{
let
mut
create_slice
=
true
;
let
mut
current_clip_chain_id
=
prim_instance
.
clip_set
.
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
let
spatial_root
=
find_scroll_root
(
clip_node_data
.
spatial_node_index
&
mut
self
.
prev_scroll_root_cache
spatial_tree
)
;
if
spatial_root
!
=
self
.
root_spatial_node_index
{
create_slice
=
false
;
break
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
create_slice
}
}
(
curr_scroll_root
scroll_root
)
=
>
{
curr_scroll_root
!
=
scroll_root
}
}
;
if
self
.
last_checked_clip_chain
!
=
prim_instance
.
clip_set
.
clip_chain_id
{
let
prim_clips_buffer
=
&
mut
self
.
prim_clips_buffer
;
prim_clips_buffer
.
clear
(
)
;
add_clips
(
current_scroll_root
prim_instance
.
clip_set
.
clip_chain_id
prim_clips_buffer
clip_store
interners
spatial_tree
)
;
let
current_shared_clips
=
&
secondary_slices
.
last
(
)
.
unwrap
(
)
.
shared_clips
;
want_new_tile_cache
|
=
current_shared_clips
!
=
prim_clips_buffer
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
}
}
if
want_new_tile_cache
{
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
&
mut
shared_clips
clip_store
interners
spatial_tree
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
secondary_slices
.
push
(
SliceDescriptor
{
prim_list
:
PrimitiveList
:
:
empty
(
)
scroll_root
shared_clips
}
)
;
}
secondary_slices
.
last_mut
(
)
.
unwrap
(
)
.
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
prim_instances
)
;
}
}
}
pub
fn
build
(
mut
self
config
:
&
FrameBuilderConfig
clip_store
:
&
mut
ClipStore
prim_store
:
&
mut
PrimitiveStore
interners
:
&
Interners
spatial_tree
:
&
SceneSpatialTree
prim_instances
:
&
[
PrimitiveInstance
]
)
-
>
(
TileCacheConfig
Vec
<
PictureIndex
>
)
{
let
mut
result
=
TileCacheConfig
:
:
new
(
self
.
primary_slices
.
len
(
)
)
;
let
mut
tile_cache_pictures
=
Vec
:
:
new
(
)
;
let
primary_slices
=
std
:
:
mem
:
:
replace
(
&
mut
self
.
primary_slices
Vec
:
:
new
(
)
)
;
for
mut
primary_slice
in
primary_slices
{
if
primary_slice
.
has_too_many_slices
(
)
{
primary_slice
.
merge
(
)
;
}
match
primary_slice
.
kind
{
SliceKind
:
:
Atomic
{
prim_list
}
=
>
{
if
let
Some
(
descriptor
)
=
self
.
build_tile_cache
(
prim_list
primary_slice
.
clip_chain_id
spatial_tree
clip_store
interners
prim_instances
)
{
create_tile_cache
(
primary_slice
.
slice_flags
descriptor
.
scroll_root
primary_slice
.
iframe_clip
descriptor
.
prim_list
primary_slice
.
background_color
descriptor
.
shared_clips
prim_store
clip_store
config
&
mut
result
.
tile_caches
&
mut
tile_cache_pictures
interners
)
;
}
}
SliceKind
:
:
Default
{
secondary_slices
}
=
>
{
for
descriptor
in
secondary_slices
{
create_tile_cache
(
primary_slice
.
slice_flags
descriptor
.
scroll_root
primary_slice
.
iframe_clip
descriptor
.
prim_list
primary_slice
.
background_color
descriptor
.
shared_clips
prim_store
clip_store
config
&
mut
result
.
tile_caches
&
mut
tile_cache_pictures
interners
)
;
}
}
}
}
(
result
tile_cache_pictures
)
}
}
fn
find_scroll_root
(
spatial_node_index
:
SpatialNodeIndex
prev_scroll_root_cache
:
&
mut
(
SpatialNodeIndex
SpatialNodeIndex
)
spatial_tree
:
&
SceneSpatialTree
)
-
>
SpatialNodeIndex
{
if
prev_scroll_root_cache
.
0
=
=
spatial_node_index
{
return
prev_scroll_root_cache
.
1
;
}
let
scroll_root
=
spatial_tree
.
find_scroll_root
(
spatial_node_index
)
;
*
prev_scroll_root_cache
=
(
spatial_node_index
scroll_root
)
;
scroll_root
}
fn
add_clips
(
scroll_root
:
SpatialNodeIndex
clip_chain_id
:
ClipChainId
prim_clips
:
&
mut
Vec
<
ClipInstance
>
clip_store
:
&
ClipStore
interners
:
&
Interners
spatial_tree
:
&
SceneSpatialTree
)
{
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
if
spatial_tree
.
is_ancestor
(
clip_node_data
.
spatial_node_index
scroll_root
)
{
prim_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
)
)
;
}
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
fn
add_all_rect_clips
(
clip_chain_id
:
ClipChainId
prim_clips
:
&
mut
Vec
<
ClipInstance
>
clip_store
:
&
ClipStore
interners
:
&
Interners
)
{
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
prim_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
)
)
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
fn
create_tile_cache
(
slice_flags
:
SliceFlags
scroll_root
:
SpatialNodeIndex
iframe_clip
:
Option
<
ClipChainId
>
prim_list
:
PrimitiveList
background_color
:
Option
<
ColorF
>
mut
shared_clips
:
Vec
<
ClipInstance
>
prim_store
:
&
mut
PrimitiveStore
clip_store
:
&
mut
ClipStore
frame_builder_config
:
&
FrameBuilderConfig
tile_caches
:
&
mut
FastHashMap
<
SliceId
TileCacheParams
>
tile_cache_pictures
:
&
mut
Vec
<
PictureIndex
>
interners
:
&
Interners
)
{
if
let
Some
(
clip_chain_id
)
=
iframe_clip
{
add_all_rect_clips
(
clip_chain_id
&
mut
shared_clips
clip_store
interners
)
;
}
let
slice
=
tile_cache_pictures
.
len
(
)
;
let
background_color
=
if
slice
=
=
0
{
background_color
}
else
{
None
}
;
let
mut
parent_clip_chain_id
=
ClipChainId
:
:
NONE
;
for
clip_instance
in
&
shared_clips
{
parent_clip_chain_id
=
clip_store
.
add_clip_chain_node
(
clip_instance
.
handle
parent_clip_chain_id
)
;
}
let
slice_id
=
SliceId
:
:
new
(
slice
)
;
tile_caches
.
insert
(
slice_id
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clips
shared_clip_chain
:
parent_clip_chain_id
virtual_surface_size
:
frame_builder_config
.
compositor_kind
.
get_virtual_surface_size
(
)
compositor_surface_count
:
prim_list
.
compositor_surface_count
}
)
;
let
pic_index
=
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
TileCache
{
slice_id
}
)
Picture3DContext
:
:
Out
true
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
prim_list
scroll_root
RasterSpace
:
:
Screen
PictureFlags
:
:
empty
(
)
)
)
;
tile_cache_pictures
.
push
(
PictureIndex
(
pic_index
)
)
;
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureCacheDebugInfo
{
pub
slices
:
FastHashMap
<
usize
SliceDebugInfo
>
}
impl
PictureCacheDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
PictureCacheDebugInfo
{
slices
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
slice
(
&
self
slice
:
usize
)
-
>
&
SliceDebugInfo
{
&
self
.
slices
[
&
slice
]
}
}
impl
Default
for
PictureCacheDebugInfo
{
fn
default
(
)
-
>
PictureCacheDebugInfo
{
PictureCacheDebugInfo
:
:
new
(
)
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SliceDebugInfo
{
pub
tiles
:
FastHashMap
<
TileOffset
TileDebugInfo
>
}
impl
SliceDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
SliceDebugInfo
{
tiles
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
tile
(
&
self
x
:
i32
y
:
i32
)
-
>
&
TileDebugInfo
{
&
self
.
tiles
[
&
TileOffset
:
:
new
(
x
y
)
]
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DirtyTileDebugInfo
{
pub
local_valid_rect
:
PictureRect
pub
local_dirty_rect
:
PictureRect
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TileDebugInfo
{
Occluded
Culled
Valid
Dirty
(
DirtyTileDebugInfo
)
}
impl
TileDebugInfo
{
pub
fn
is_occluded
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Occluded
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Valid
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_culled
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Culled
=
>
true
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
as_dirty
(
&
self
)
-
>
&
DirtyTileDebugInfo
{
match
self
{
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
=
>
{
panic
!
(
"
not
a
dirty
tile
!
"
)
;
}
TileDebugInfo
:
:
Dirty
(
ref
info
)
=
>
{
info
}
}
}
}
