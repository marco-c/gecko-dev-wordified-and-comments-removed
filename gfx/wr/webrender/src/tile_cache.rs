use
api
:
:
{
ColorF
PrimitiveFlags
QualitySettings
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipChainId
ClipNodeKind
ClipStore
ClipInstance
}
;
use
crate
:
:
frame_builder
:
:
FrameBuilderConfig
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
FastHashSet
}
;
use
crate
:
:
picture
:
:
{
PrimitiveList
PictureCompositeMode
PictureOptions
PicturePrimitive
SliceId
}
;
use
crate
:
:
picture
:
:
{
Picture3DContext
TileCacheParams
TileOffset
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
PrimitiveStore
PictureIndex
}
;
use
crate
:
:
scene_building
:
:
SliceFlags
;
use
crate
:
:
scene_builder_thread
:
:
Interners
;
use
crate
:
:
spatial_tree
:
:
{
SpatialNodeIndex
SpatialTree
}
;
use
crate
:
:
util
:
:
VecHelper
;
const
MAX_CACHE_SLICES
:
usize
=
12
;
pub
struct
PendingTileCache
{
pub
prim_list
:
PrimitiveList
pub
params
:
TileCacheParams
pub
iframe_clip
:
Option
<
ClipChainId
>
}
pub
struct
TileCacheBuilder
{
force_new_tile_cache
:
Option
<
SliceFlags
>
pending_tile_caches
:
Vec
<
PendingTileCache
>
prev_scroll_root_cache
:
(
SpatialNodeIndex
SpatialNodeIndex
)
prim_clips_buffer
:
Vec
<
ClipInstance
>
last_checked_clip_chain
:
ClipChainId
root_spatial_node_index
:
SpatialNodeIndex
}
pub
struct
TileCacheConfig
{
pub
tile_caches
:
FastHashMap
<
SliceId
TileCacheParams
>
pub
picture_cache_spatial_nodes
:
FastHashSet
<
SpatialNodeIndex
>
pub
picture_cache_slice_count
:
usize
}
impl
TileCacheConfig
{
pub
fn
new
(
picture_cache_slice_count
:
usize
)
-
>
Self
{
TileCacheConfig
{
tile_caches
:
FastHashMap
:
:
default
(
)
picture_cache_spatial_nodes
:
FastHashSet
:
:
default
(
)
picture_cache_slice_count
}
}
}
impl
TileCacheBuilder
{
pub
fn
new
(
root_spatial_node_index
:
SpatialNodeIndex
)
-
>
Self
{
TileCacheBuilder
{
force_new_tile_cache
:
None
pending_tile_caches
:
Vec
:
:
new
(
)
prev_scroll_root_cache
:
(
SpatialNodeIndex
:
:
INVALID
SpatialNodeIndex
:
:
INVALID
)
prim_clips_buffer
:
Vec
:
:
new
(
)
last_checked_clip_chain
:
ClipChainId
:
:
INVALID
root_spatial_node_index
}
}
pub
fn
add_tile_cache_barrier
(
&
mut
self
slice_flags
:
SliceFlags
)
{
self
.
force_new_tile_cache
=
Some
(
slice_flags
)
;
}
pub
fn
can_add_container_tile_cache
(
&
self
)
-
>
bool
{
self
.
pending_tile_caches
.
len
(
)
<
MAX_CACHE_SLICES
-
1
}
pub
fn
add_tile_cache
(
&
mut
self
prim_list
:
PrimitiveList
clip_chain_id
:
ClipChainId
spatial_tree
:
&
SpatialTree
clip_store
:
&
ClipStore
interners
:
&
Interners
config
:
&
FrameBuilderConfig
iframe_clip
:
Option
<
ClipChainId
>
slice_flags
:
SliceFlags
)
{
assert
!
(
self
.
can_add_container_tile_cache
(
)
)
;
if
prim_list
.
is_empty
(
)
{
return
;
}
let
mut
scroll_root_occurrences
=
FastHashMap
:
:
default
(
)
;
for
cluster
in
&
prim_list
.
clusters
{
let
scroll_root
=
self
.
find_scroll_root
(
cluster
.
spatial_node_index
spatial_tree
)
;
*
scroll_root_occurrences
.
entry
(
scroll_root
)
.
or_insert
(
0
)
+
=
1
;
}
let
scroll_roots
:
Vec
<
SpatialNodeIndex
>
=
scroll_root_occurrences
.
keys
(
)
.
cloned
(
)
.
collect
(
)
;
scroll_root_occurrences
.
retain
(
|
parent_spatial_node_index
_
|
{
scroll_roots
.
iter
(
)
.
all
(
|
child_spatial_node_index
|
{
parent_spatial_node_index
=
=
child_spatial_node_index
|
|
spatial_tree
.
is_ancestor
(
*
parent_spatial_node_index
*
child_spatial_node_index
)
}
)
}
)
;
let
scroll_root
=
scroll_root_occurrences
.
iter
(
)
.
max_by_key
(
|
entry
|
entry
.
1
)
.
map
(
|
(
spatial_node_index
_
)
|
*
spatial_node_index
)
.
unwrap_or
(
self
.
root_spatial_node_index
)
;
let
mut
first
=
true
;
let
prim_clips_buffer
=
&
mut
self
.
prim_clips_buffer
;
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
for
cluster
in
&
prim_list
.
clusters
{
for
prim_instance
in
&
prim_list
.
prim_instances
[
cluster
.
prim_range
(
)
]
{
if
first
{
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
&
mut
shared_clips
clip_store
interners
spatial_tree
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
first
=
false
;
}
else
{
if
self
.
last_checked_clip_chain
!
=
prim_instance
.
clip_set
.
clip_chain_id
{
prim_clips_buffer
.
clear
(
)
;
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
prim_clips_buffer
clip_store
interners
spatial_tree
)
;
shared_clips
.
retain
(
|
h1
:
&
ClipInstance
|
{
let
uid
=
h1
.
handle
.
uid
(
)
;
prim_clips_buffer
.
iter
(
)
.
any
(
|
h2
|
{
uid
=
=
h2
.
handle
.
uid
(
)
&
&
h1
.
spatial_node_index
=
=
h2
.
spatial_node_index
}
)
}
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
}
}
}
}
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
shared_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
clip_chain_node
.
spatial_node_index
)
)
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
let
slice
=
self
.
pending_tile_caches
.
len
(
)
;
let
params
=
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
:
None
shared_clips
shared_clip_chain
:
ClipChainId
:
:
NONE
virtual_surface_size
:
config
.
compositor_kind
.
get_virtual_surface_size
(
)
compositor_surface_count
:
prim_list
.
compositor_surface_count
}
;
self
.
pending_tile_caches
.
push
(
PendingTileCache
{
prim_list
params
iframe_clip
}
)
;
self
.
force_new_tile_cache
=
Some
(
SliceFlags
:
:
empty
(
)
)
;
}
pub
fn
add_prim
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_flags
:
PrimitiveFlags
spatial_tree
:
&
SpatialTree
clip_store
:
&
ClipStore
interners
:
&
Interners
config
:
&
FrameBuilderConfig
quality_settings
:
&
QualitySettings
iframe_clip
:
Option
<
ClipChainId
>
)
{
let
scroll_root
=
self
.
find_scroll_root
(
spatial_node_index
spatial_tree
)
;
let
mut
want_new_tile_cache
=
self
.
force_new_tile_cache
.
is_some
(
)
|
|
self
.
pending_tile_caches
.
is_empty
(
)
;
let
current_scroll_root
=
self
.
pending_tile_caches
.
last
(
)
.
map
(
|
p
|
p
.
params
.
spatial_node_index
)
;
if
let
Some
(
current_scroll_root
)
=
current_scroll_root
{
want_new_tile_cache
|
=
match
(
current_scroll_root
scroll_root
)
{
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
&
&
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
false
}
(
_
_
)
if
current_scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
true
}
(
_
_
)
if
scroll_root
=
=
self
.
root_spatial_node_index
=
>
{
if
quality_settings
.
force_subpixel_aa_where_possible
{
false
}
else
{
let
mut
create_slice
=
true
;
let
mut
current_clip_chain_id
=
prim_instance
.
clip_set
.
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
spatial_root
=
self
.
find_scroll_root
(
clip_chain_node
.
spatial_node_index
spatial_tree
)
;
if
spatial_root
!
=
self
.
root_spatial_node_index
{
create_slice
=
false
;
break
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
create_slice
}
}
(
curr_scroll_root
scroll_root
)
=
>
{
curr_scroll_root
!
=
scroll_root
}
}
;
if
self
.
last_checked_clip_chain
!
=
prim_instance
.
clip_set
.
clip_chain_id
{
let
prim_clips_buffer
=
&
mut
self
.
prim_clips_buffer
;
prim_clips_buffer
.
clear
(
)
;
add_clips
(
current_scroll_root
prim_instance
.
clip_set
.
clip_chain_id
prim_clips_buffer
clip_store
interners
spatial_tree
)
;
let
current_shared_clips
=
&
self
.
pending_tile_caches
.
last
(
)
.
unwrap
(
)
.
params
.
shared_clips
;
want_new_tile_cache
|
=
current_shared_clips
!
=
prim_clips_buffer
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
}
}
if
want_new_tile_cache
{
let
slice
=
self
.
pending_tile_caches
.
len
(
)
;
if
slice
<
MAX_CACHE_SLICES
{
let
(
params
iframe_clip
)
=
if
slice
=
=
MAX_CACHE_SLICES
-
1
{
let
params
=
TileCacheParams
{
slice
slice_flags
:
SliceFlags
:
:
empty
(
)
spatial_node_index
:
self
.
root_spatial_node_index
background_color
:
None
shared_clips
:
Vec
:
:
new
(
)
shared_clip_chain
:
ClipChainId
:
:
NONE
virtual_surface_size
:
config
.
compositor_kind
.
get_virtual_surface_size
(
)
compositor_surface_count
:
0
}
;
(
params
None
)
}
else
{
let
slice_flags
=
self
.
force_new_tile_cache
.
unwrap_or
(
SliceFlags
:
:
empty
(
)
)
;
let
background_color
=
if
slice
=
=
0
{
config
.
background_color
}
else
{
None
}
;
let
mut
shared_clips
=
Vec
:
:
new
(
)
;
add_clips
(
scroll_root
prim_instance
.
clip_set
.
clip_chain_id
&
mut
shared_clips
clip_store
interners
spatial_tree
)
;
self
.
last_checked_clip_chain
=
prim_instance
.
clip_set
.
clip_chain_id
;
let
params
=
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clips
shared_clip_chain
:
ClipChainId
:
:
NONE
virtual_surface_size
:
config
.
compositor_kind
.
get_virtual_surface_size
(
)
compositor_surface_count
:
0
}
;
(
params
iframe_clip
)
}
;
self
.
pending_tile_caches
.
push
(
PendingTileCache
{
prim_list
:
PrimitiveList
:
:
empty
(
)
params
iframe_clip
}
)
;
self
.
force_new_tile_cache
=
None
;
}
}
self
.
pending_tile_caches
.
last_mut
(
)
.
unwrap
(
)
.
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
prim_flags
)
;
}
pub
fn
build
(
self
config
:
&
FrameBuilderConfig
clip_store
:
&
mut
ClipStore
prim_store
:
&
mut
PrimitiveStore
interners
:
&
Interners
)
-
>
(
TileCacheConfig
Vec
<
PictureIndex
>
)
{
let
mut
result
=
TileCacheConfig
:
:
new
(
self
.
pending_tile_caches
.
len
(
)
)
;
let
mut
tile_cache_pictures
=
Vec
:
:
new
(
)
;
for
mut
pending_tile_cache
in
self
.
pending_tile_caches
{
if
let
Some
(
clip_chain_id
)
=
pending_tile_cache
.
iframe_clip
{
add_all_rect_clips
(
clip_chain_id
&
mut
pending_tile_cache
.
params
.
shared_clips
clip_store
interners
)
;
}
let
pic_index
=
create_tile_cache
(
pending_tile_cache
.
params
.
slice
pending_tile_cache
.
params
.
slice_flags
pending_tile_cache
.
params
.
spatial_node_index
pending_tile_cache
.
prim_list
pending_tile_cache
.
params
.
background_color
pending_tile_cache
.
params
.
shared_clips
prim_store
clip_store
&
mut
result
.
picture_cache_spatial_nodes
config
&
mut
result
.
tile_caches
)
;
tile_cache_pictures
.
push
(
pic_index
)
;
}
(
result
tile_cache_pictures
)
}
fn
find_scroll_root
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SpatialTree
)
-
>
SpatialNodeIndex
{
if
self
.
prev_scroll_root_cache
.
0
=
=
spatial_node_index
{
return
self
.
prev_scroll_root_cache
.
1
;
}
let
scroll_root
=
spatial_tree
.
find_scroll_root
(
spatial_node_index
)
;
self
.
prev_scroll_root_cache
=
(
spatial_node_index
scroll_root
)
;
scroll_root
}
}
fn
add_clips
(
scroll_root
:
SpatialNodeIndex
clip_chain_id
:
ClipChainId
prim_clips
:
&
mut
Vec
<
ClipInstance
>
clip_store
:
&
ClipStore
interners
:
&
Interners
spatial_tree
:
&
SpatialTree
)
{
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
if
spatial_tree
.
is_ancestor
(
clip_chain_node
.
spatial_node_index
scroll_root
)
{
prim_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
clip_chain_node
.
spatial_node_index
)
)
;
}
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
fn
add_all_rect_clips
(
clip_chain_id
:
ClipChainId
prim_clips
:
&
mut
Vec
<
ClipInstance
>
clip_store
:
&
ClipStore
interners
:
&
Interners
)
{
let
mut
current_clip_chain_id
=
clip_chain_id
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
clip_store
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
let
clip_node_data
=
&
interners
.
clip
[
clip_chain_node
.
handle
]
;
if
let
ClipNodeKind
:
:
Rectangle
=
clip_node_data
.
clip_node_kind
{
prim_clips
.
push
(
ClipInstance
:
:
new
(
clip_chain_node
.
handle
clip_chain_node
.
spatial_node_index
)
)
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
fn
create_tile_cache
(
slice
:
usize
slice_flags
:
SliceFlags
scroll_root
:
SpatialNodeIndex
prim_list
:
PrimitiveList
background_color
:
Option
<
ColorF
>
shared_clips
:
Vec
<
ClipInstance
>
prim_store
:
&
mut
PrimitiveStore
clip_store
:
&
mut
ClipStore
picture_cache_spatial_nodes
:
&
mut
FastHashSet
<
SpatialNodeIndex
>
frame_builder_config
:
&
FrameBuilderConfig
tile_caches
:
&
mut
FastHashMap
<
SliceId
TileCacheParams
>
)
-
>
PictureIndex
{
picture_cache_spatial_nodes
.
insert
(
scroll_root
)
;
let
mut
parent_clip_chain_id
=
ClipChainId
:
:
NONE
;
for
clip_instance
in
&
shared_clips
{
picture_cache_spatial_nodes
.
insert
(
clip_instance
.
spatial_node_index
)
;
parent_clip_chain_id
=
clip_store
.
add_clip_chain_node
(
clip_instance
.
handle
clip_instance
.
spatial_node_index
parent_clip_chain_id
)
;
}
let
slice_id
=
SliceId
:
:
new
(
slice
)
;
tile_caches
.
insert
(
slice_id
TileCacheParams
{
slice
slice_flags
spatial_node_index
:
scroll_root
background_color
shared_clips
shared_clip_chain
:
parent_clip_chain_id
virtual_surface_size
:
frame_builder_config
.
compositor_kind
.
get_virtual_surface_size
(
)
compositor_surface_count
:
prim_list
.
compositor_surface_count
}
)
;
let
pic_index
=
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
Some
(
PictureCompositeMode
:
:
TileCache
{
slice_id
}
)
Picture3DContext
:
:
Out
true
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
prim_list
scroll_root
PictureOptions
:
:
default
(
)
)
)
;
PictureIndex
(
pic_index
)
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureCacheDebugInfo
{
pub
slices
:
FastHashMap
<
usize
SliceDebugInfo
>
}
impl
PictureCacheDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
PictureCacheDebugInfo
{
slices
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
slice
(
&
self
slice
:
usize
)
-
>
&
SliceDebugInfo
{
&
self
.
slices
[
&
slice
]
}
}
impl
Default
for
PictureCacheDebugInfo
{
fn
default
(
)
-
>
PictureCacheDebugInfo
{
PictureCacheDebugInfo
:
:
new
(
)
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SliceDebugInfo
{
pub
tiles
:
FastHashMap
<
TileOffset
TileDebugInfo
>
}
impl
SliceDebugInfo
{
pub
fn
new
(
)
-
>
Self
{
SliceDebugInfo
{
tiles
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
tile
(
&
self
x
:
i32
y
:
i32
)
-
>
&
TileDebugInfo
{
&
self
.
tiles
[
&
TileOffset
:
:
new
(
x
y
)
]
}
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DirtyTileDebugInfo
{
pub
local_valid_rect
:
PictureRect
pub
local_dirty_rect
:
PictureRect
}
#
[
derive
(
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TileDebugInfo
{
Occluded
Culled
Valid
Dirty
(
DirtyTileDebugInfo
)
}
impl
TileDebugInfo
{
pub
fn
is_occluded
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Occluded
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Valid
=
>
true
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
is_culled
(
&
self
)
-
>
bool
{
match
self
{
TileDebugInfo
:
:
Culled
=
>
true
TileDebugInfo
:
:
Valid
|
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Dirty
(
.
.
)
=
>
false
}
}
pub
fn
as_dirty
(
&
self
)
-
>
&
DirtyTileDebugInfo
{
match
self
{
TileDebugInfo
:
:
Occluded
|
TileDebugInfo
:
:
Culled
|
TileDebugInfo
:
:
Valid
=
>
{
panic
!
(
"
not
a
dirty
tile
!
"
)
;
}
TileDebugInfo
:
:
Dirty
(
ref
info
)
=
>
{
info
}
}
}
}
