use
allocator_api2
:
:
alloc
:
:
{
Allocator
AllocError
Layout
Global
}
;
use
std
:
:
{
cell
:
:
UnsafeCell
ptr
:
:
NonNull
sync
:
:
{
atomic
:
:
{
AtomicI32
Ordering
}
Arc
}
}
;
use
crate
:
:
{
bump_allocator
:
:
{
BumpAllocator
ChunkPool
Stats
}
internal_types
:
:
{
FrameId
FrameVec
}
}
;
pub
struct
FrameAllocator
{
inner
:
*
mut
FrameInnerAllocator
#
[
cfg
(
debug_assertions
)
]
frame_id
:
Option
<
FrameId
>
}
impl
FrameAllocator
{
pub
fn
fallback
(
)
-
>
Self
{
FrameAllocator
{
inner
:
std
:
:
ptr
:
:
null_mut
(
)
#
[
cfg
(
debug_assertions
)
]
frame_id
:
None
}
}
#
[
inline
]
pub
fn
new_vec
<
T
>
(
self
)
-
>
FrameVec
<
T
>
{
FrameVec
:
:
new_in
(
self
)
}
#
[
inline
]
pub
fn
new_vec_with_capacity
<
T
>
(
self
cap
:
usize
)
-
>
FrameVec
<
T
>
{
FrameVec
:
:
with_capacity_in
(
cap
self
)
}
#
[
inline
]
fn
allocate_impl
(
mem
:
*
mut
FrameInnerAllocator
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
unsafe
{
(
*
mem
)
.
live_alloc_count
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
(
*
mem
)
.
bump
.
allocate_item
(
layout
)
}
}
#
[
inline
]
unsafe
fn
deallocate_impl
(
mem
:
*
mut
FrameInnerAllocator
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
{
(
*
mem
)
.
live_alloc_count
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
;
(
*
mem
)
.
bump
.
deallocate_item
(
ptr
layout
)
}
#
[
inline
]
unsafe
fn
grow_impl
(
mem
:
*
mut
FrameInnerAllocator
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
(
*
mem
)
.
bump
.
grow_item
(
ptr
old_layout
new_layout
)
}
#
[
inline
]
unsafe
fn
shrink_impl
(
mem
:
*
mut
FrameInnerAllocator
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
(
*
mem
)
.
bump
.
shrink_item
(
ptr
old_layout
new_layout
)
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
allocate_fallback
(
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
Global
.
allocate
(
layout
)
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
deallocate_fallback
(
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
{
unsafe
{
Global
.
deallocate
(
ptr
layout
)
}
}
#
[
cold
]
#
[
inline
(
never
)
]
fn
grow_fallback
(
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
unsafe
{
Global
.
grow
(
ptr
old_layout
new_layout
)
}
}
#
[
cfg
(
not
(
debug_assertions
)
)
]
fn
check_frame_id
(
&
self
)
{
}
#
[
cfg
(
debug_assertions
)
]
fn
check_frame_id
(
&
self
)
{
if
self
.
inner
.
is_null
(
)
{
return
;
}
unsafe
{
assert_eq
!
(
self
.
frame_id
(
*
self
.
inner
)
.
frame_id
)
;
}
}
}
impl
Clone
for
FrameAllocator
{
fn
clone
(
&
self
)
-
>
Self
{
unsafe
{
if
let
Some
(
inner
)
=
self
.
inner
.
as_mut
(
)
{
inner
.
references_dropped
.
fetch_sub
(
1
Ordering
:
:
Relaxed
)
;
}
}
FrameAllocator
{
inner
:
self
.
inner
#
[
cfg
(
debug_assertions
)
]
frame_id
:
self
.
frame_id
}
}
}
impl
Drop
for
FrameAllocator
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
let
Some
(
inner
)
=
self
.
inner
.
as_mut
(
)
{
inner
.
references_dropped
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
;
}
}
}
}
unsafe
impl
Send
for
FrameAllocator
{
}
unsafe
impl
Allocator
for
FrameAllocator
{
#
[
inline
(
never
)
]
fn
allocate
(
&
self
layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
if
self
.
inner
.
is_null
(
)
{
return
FrameAllocator
:
:
allocate_fallback
(
layout
)
;
}
self
.
check_frame_id
(
)
;
FrameAllocator
:
:
allocate_impl
(
self
.
inner
layout
)
}
#
[
inline
(
never
)
]
unsafe
fn
deallocate
(
&
self
ptr
:
NonNull
<
u8
>
layout
:
Layout
)
{
if
self
.
inner
.
is_null
(
)
{
return
FrameAllocator
:
:
deallocate_fallback
(
ptr
layout
)
;
}
self
.
check_frame_id
(
)
;
FrameAllocator
:
:
deallocate_impl
(
self
.
inner
ptr
layout
)
}
#
[
inline
(
never
)
]
unsafe
fn
grow
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
if
self
.
inner
.
is_null
(
)
{
return
FrameAllocator
:
:
grow_fallback
(
ptr
old_layout
new_layout
)
;
}
self
.
check_frame_id
(
)
;
FrameAllocator
:
:
grow_impl
(
self
.
inner
ptr
old_layout
new_layout
)
}
#
[
inline
(
never
)
]
unsafe
fn
shrink
(
&
self
ptr
:
NonNull
<
u8
>
old_layout
:
Layout
new_layout
:
Layout
)
-
>
Result
<
NonNull
<
[
u8
]
>
AllocError
>
{
if
self
.
inner
.
is_null
(
)
{
return
FrameAllocator
:
:
grow_fallback
(
ptr
old_layout
new_layout
)
;
}
self
.
check_frame_id
(
)
;
FrameAllocator
:
:
shrink_impl
(
self
.
inner
ptr
old_layout
new_layout
)
}
}
#
[
cfg
(
feature
=
"
capture
"
)
]
impl
serde
:
:
Serialize
for
FrameAllocator
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
(
)
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
replay
"
)
]
impl
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
for
FrameAllocator
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
let
_
=
<
(
)
as
serde
:
:
Deserialize
>
:
:
deserialize
(
deserializer
)
?
;
Ok
(
FrameAllocator
:
:
fallback
(
)
)
}
}
#
[
cfg
(
feature
=
"
replay
"
)
]
impl
Default
for
FrameAllocator
{
fn
default
(
)
-
>
Self
{
Self
:
:
fallback
(
)
}
}
pub
struct
FrameMemory
{
allocator
:
Option
<
NonNull
<
FrameInnerAllocator
>
>
references_created
:
UnsafeCell
<
i32
>
}
impl
FrameMemory
{
#
[
allow
(
unused
)
]
pub
fn
fallback
(
)
-
>
Self
{
FrameMemory
{
allocator
:
None
references_created
:
UnsafeCell
:
:
new
(
0
)
}
}
pub
fn
new
(
pool
:
Arc
<
ChunkPool
>
)
-
>
Self
{
let
layout
=
Layout
:
:
from_size_align
(
std
:
:
mem
:
:
size_of
:
:
<
FrameInnerAllocator
>
(
)
std
:
:
mem
:
:
align_of
:
:
<
FrameInnerAllocator
>
(
)
)
.
unwrap
(
)
;
let
uninit_u8
=
Global
.
allocate
(
layout
)
.
unwrap
(
)
;
unsafe
{
let
allocator
:
NonNull
<
FrameInnerAllocator
>
=
uninit_u8
.
cast
(
)
;
allocator
.
as_ptr
(
)
.
write
(
FrameInnerAllocator
{
bump
:
BumpAllocator
:
:
new
(
pool
)
live_alloc_count
:
AtomicI32
:
:
new
(
0
)
references_dropped
:
AtomicI32
:
:
new
(
0
)
#
[
cfg
(
debug_assertions
)
]
frame_id
:
None
}
)
;
FrameMemory
{
allocator
:
Some
(
allocator
)
references_created
:
UnsafeCell
:
:
new
(
0
)
}
}
}
pub
fn
allocator
(
&
self
)
-
>
FrameAllocator
{
if
let
Some
(
alloc
)
=
&
self
.
allocator
{
unsafe
{
*
self
.
references_created
.
get
(
)
+
=
1
}
;
return
FrameAllocator
{
inner
:
alloc
.
as_ptr
(
)
#
[
cfg
(
debug_assertions
)
]
frame_id
:
unsafe
{
alloc
.
as_ref
(
)
.
frame_id
}
}
;
}
FrameAllocator
:
:
fallback
(
)
}
#
[
inline
]
pub
fn
new_vec
<
T
>
(
&
self
)
-
>
FrameVec
<
T
>
{
FrameVec
:
:
new_in
(
self
.
allocator
(
)
)
}
#
[
inline
]
pub
fn
new_vec_with_capacity
<
T
>
(
&
self
cap
:
usize
)
-
>
FrameVec
<
T
>
{
FrameVec
:
:
with_capacity_in
(
cap
self
.
allocator
(
)
)
}
pub
fn
assert_memory_reusable
(
&
self
)
{
if
let
Some
(
ptr
)
=
self
.
allocator
{
unsafe
{
assert_eq
!
(
ptr
.
as_ref
(
)
.
live_alloc_count
.
load
(
Ordering
:
:
Acquire
)
0
)
;
let
references_created
=
*
self
.
references_created
.
get
(
)
;
assert_eq
!
(
ptr
.
as_ref
(
)
.
references_dropped
.
load
(
Ordering
:
:
Acquire
)
references_created
)
;
}
}
}
pub
fn
begin_frame
(
&
mut
self
id
:
FrameId
)
{
self
.
assert_memory_reusable
(
)
;
if
let
Some
(
mut
ptr
)
=
self
.
allocator
{
unsafe
{
let
allocator
=
ptr
.
as_mut
(
)
;
allocator
.
references_dropped
.
store
(
0
Ordering
:
:
Release
)
;
self
.
references_created
=
UnsafeCell
:
:
new
(
0
)
;
allocator
.
bump
.
reset_stats
(
)
;
allocator
.
set_frame_id
(
id
)
;
}
}
}
#
[
allow
(
unused
)
]
pub
fn
get_stats
(
&
self
)
-
>
Stats
{
unsafe
{
self
.
allocator
.
map
(
|
ptr
|
(
*
ptr
.
as_ptr
(
)
)
.
bump
.
get_stats
(
)
)
.
unwrap_or_else
(
Stats
:
:
default
)
}
}
}
impl
Drop
for
FrameMemory
{
fn
drop
(
&
mut
self
)
{
self
.
assert_memory_reusable
(
)
;
let
layout
=
Layout
:
:
new
:
:
<
FrameInnerAllocator
>
(
)
;
unsafe
{
if
let
Some
(
ptr
)
=
&
mut
self
.
allocator
{
std
:
:
ptr
:
:
drop_in_place
(
ptr
.
as_ptr
(
)
)
;
Global
.
deallocate
(
ptr
.
cast
(
)
layout
)
;
}
}
}
}
unsafe
impl
Send
for
FrameMemory
{
}
#
[
cfg
(
feature
=
"
capture
"
)
]
impl
serde
:
:
Serialize
for
FrameMemory
{
fn
serialize
<
S
>
(
&
self
serializer
:
S
)
-
>
Result
<
S
:
:
Ok
S
:
:
Error
>
where
S
:
serde
:
:
Serializer
{
(
)
.
serialize
(
serializer
)
}
}
#
[
cfg
(
feature
=
"
replay
"
)
]
impl
<
'
de
>
serde
:
:
Deserialize
<
'
de
>
for
FrameMemory
{
fn
deserialize
<
D
>
(
deserializer
:
D
)
-
>
Result
<
Self
D
:
:
Error
>
where
D
:
serde
:
:
Deserializer
<
'
de
>
{
let
_
=
<
(
)
as
serde
:
:
Deserialize
>
:
:
deserialize
(
deserializer
)
?
;
Ok
(
FrameMemory
:
:
fallback
(
)
)
}
}
struct
FrameInnerAllocator
{
bump
:
BumpAllocator
live_alloc_count
:
AtomicI32
references_dropped
:
AtomicI32
#
[
cfg
(
debug_assertions
)
]
frame_id
:
Option
<
FrameId
>
}
impl
FrameInnerAllocator
{
#
[
cfg
(
not
(
debug_assertions
)
)
]
fn
set_frame_id
(
&
mut
self
_
:
FrameId
)
{
}
#
[
cfg
(
debug_assertions
)
]
fn
set_frame_id
(
&
mut
self
id
:
FrameId
)
{
self
.
frame_id
=
Some
(
id
)
;
}
}
#
[
test
]
fn
frame_memory_simple
(
)
{
use
std
:
:
sync
:
:
mpsc
:
:
channel
;
let
chunk_pool
=
Arc
:
:
new
(
ChunkPool
:
:
new
(
)
)
;
let
mut
memory
=
FrameMemory
:
:
new
(
chunk_pool
)
;
memory
.
begin_frame
(
FrameId
:
:
first
(
)
)
;
let
alloc
=
memory
.
allocator
(
)
;
let
a2
=
memory
.
allocator
(
)
;
let
a3
=
memory
.
allocator
(
)
;
let
v1
:
FrameVec
<
u32
>
=
memory
.
new_vec_with_capacity
(
10
)
;
let
v2
:
FrameVec
<
u32
>
=
memory
.
new_vec_with_capacity
(
256
)
;
let
v3
:
FrameVec
<
u32
>
=
memory
.
new_vec_with_capacity
(
1024
*
128
)
;
let
v4
:
FrameVec
<
u32
>
=
memory
.
new_vec_with_capacity
(
128
)
;
let
mut
v5
=
alloc
.
clone
(
)
.
new_vec
(
)
;
for
i
in
0
.
.
256u32
{
v5
.
push
(
i
)
;
}
let
v6
=
v2
.
clone
(
)
.
clone
(
)
.
clone
(
)
.
clone
(
)
;
let
mut
frame
=
alloc
.
new_vec
(
)
;
frame
.
push
(
v1
)
;
frame
.
push
(
v2
)
;
frame
.
push
(
v3
)
;
frame
.
push
(
v4
)
;
frame
.
push
(
v5
)
;
frame
.
push
(
v6
)
;
let
(
tx
rx
)
=
channel
(
)
;
tx
.
send
(
frame
)
.
unwrap
(
)
;
let
handle
=
std
:
:
thread
:
:
spawn
(
move
|
|
{
let
mut
frame
=
rx
.
recv
(
)
.
unwrap
(
)
;
frame
.
push
(
memory
.
new_vec_with_capacity
(
10
)
)
;
std
:
:
mem
:
:
drop
(
a3
)
;
std
:
:
mem
:
:
drop
(
a2
)
;
std
:
:
mem
:
:
drop
(
frame
)
;
memory
.
assert_memory_reusable
(
)
;
}
)
;
handle
.
join
(
)
.
unwrap
(
)
;
}
