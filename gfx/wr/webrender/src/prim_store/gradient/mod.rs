use
api
:
:
{
ColorF
ColorU
GradientStop
PremultipliedColorF
}
;
use
api
:
:
units
:
:
{
LayoutRect
LayoutSize
LayoutVector2D
}
;
use
crate
:
:
gpu_cache
:
:
GpuDataRequest
;
use
std
:
:
hash
;
mod
linear
;
mod
radial
;
mod
conic
;
pub
use
linear
:
:
*
;
pub
use
radial
:
:
*
;
pub
use
conic
:
:
*
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
MallocSizeOf
PartialEq
)
]
pub
struct
GradientStopKey
{
pub
offset
:
f32
pub
color
:
ColorU
}
impl
GradientStopKey
{
pub
fn
empty
(
)
-
>
Self
{
GradientStopKey
{
offset
:
0
.
0
color
:
ColorU
:
:
new
(
0
0
0
0
)
}
}
}
impl
Into
<
GradientStopKey
>
for
GradientStop
{
fn
into
(
self
)
-
>
GradientStopKey
{
GradientStopKey
{
offset
:
self
.
offset
color
:
self
.
color
.
into
(
)
}
}
}
fn
stops_and_min_alpha
(
stop_keys
:
&
[
GradientStopKey
]
)
-
>
(
Vec
<
GradientStop
>
f32
)
{
let
mut
min_alpha
:
f32
=
1
.
0
;
let
stops
=
stop_keys
.
iter
(
)
.
map
(
|
stop_key
|
{
let
color
:
ColorF
=
stop_key
.
color
.
into
(
)
;
min_alpha
=
min_alpha
.
min
(
color
.
a
)
;
GradientStop
{
offset
:
stop_key
.
offset
color
}
}
)
.
collect
(
)
;
(
stops
min_alpha
)
}
impl
Eq
for
GradientStopKey
{
}
impl
hash
:
:
Hash
for
GradientStopKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
offset
.
to_bits
(
)
.
hash
(
state
)
;
self
.
color
.
hash
(
state
)
;
}
}
pub
const
GRADIENT_DATA_FIRST_STOP
:
usize
=
0
;
pub
const
GRADIENT_DATA_LAST_STOP
:
usize
=
GRADIENT_DATA_SIZE
-
1
;
pub
const
GRADIENT_DATA_TABLE_BEGIN
:
usize
=
GRADIENT_DATA_FIRST_STOP
+
1
;
pub
const
GRADIENT_DATA_TABLE_END
:
usize
=
GRADIENT_DATA_LAST_STOP
;
pub
const
GRADIENT_DATA_TABLE_SIZE
:
usize
=
128
;
pub
const
GRADIENT_DATA_SIZE
:
usize
=
GRADIENT_DATA_TABLE_SIZE
+
2
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
repr
(
C
)
]
struct
GradientDataEntry
{
start_color
:
PremultipliedColorF
end_step
:
PremultipliedColorF
}
impl
GradientDataEntry
{
fn
white
(
)
-
>
Self
{
Self
{
start_color
:
PremultipliedColorF
:
:
WHITE
end_step
:
PremultipliedColorF
:
:
TRANSPARENT
}
}
}
struct
GradientGpuBlockBuilder
{
}
impl
GradientGpuBlockBuilder
{
fn
fill_colors
(
start_idx
:
usize
end_idx
:
usize
start_color
:
&
PremultipliedColorF
end_color
:
&
PremultipliedColorF
entries
:
&
mut
[
GradientDataEntry
;
GRADIENT_DATA_SIZE
]
prev_step
:
&
PremultipliedColorF
)
-
>
PremultipliedColorF
{
let
inv_steps
=
1
.
0
/
(
end_idx
-
start_idx
)
as
f32
;
let
mut
step
=
PremultipliedColorF
{
r
:
(
end_color
.
r
-
start_color
.
r
)
*
inv_steps
g
:
(
end_color
.
g
-
start_color
.
g
)
*
inv_steps
b
:
(
end_color
.
b
-
start_color
.
b
)
*
inv_steps
a
:
(
end_color
.
a
-
start_color
.
a
)
*
inv_steps
}
;
if
step
=
=
*
prev_step
{
step
.
a
=
f32
:
:
from_bits
(
if
step
.
a
=
=
0
.
0
{
1
}
else
{
step
.
a
.
to_bits
(
)
+
1
}
)
;
}
let
mut
cur_color
=
*
start_color
;
for
index
in
start_idx
.
.
end_idx
{
let
entry
=
&
mut
entries
[
index
]
;
entry
.
start_color
=
cur_color
;
cur_color
.
r
+
=
step
.
r
;
cur_color
.
g
+
=
step
.
g
;
cur_color
.
b
+
=
step
.
b
;
cur_color
.
a
+
=
step
.
a
;
entry
.
end_step
=
step
;
}
step
}
#
[
inline
]
fn
get_index
(
offset
:
f32
)
-
>
usize
{
(
offset
.
max
(
0
.
0
)
.
min
(
1
.
0
)
*
GRADIENT_DATA_TABLE_SIZE
as
f32
+
GRADIENT_DATA_TABLE_BEGIN
as
f32
)
.
round
(
)
as
usize
}
fn
build
(
reverse_stops
:
bool
request
:
&
mut
GpuDataRequest
src_stops
:
&
[
GradientStop
]
)
{
let
mut
src_stops
=
src_stops
.
into_iter
(
)
;
let
mut
cur_color
=
match
src_stops
.
next
(
)
{
Some
(
stop
)
=
>
{
debug_assert_eq
!
(
stop
.
offset
0
.
0
)
;
stop
.
color
.
premultiplied
(
)
}
None
=
>
{
error
!
(
"
Zero
gradient
stops
found
!
"
)
;
PremultipliedColorF
:
:
BLACK
}
}
;
let
mut
entries
=
[
GradientDataEntry
:
:
white
(
)
;
GRADIENT_DATA_SIZE
]
;
let
mut
prev_step
=
cur_color
;
if
reverse_stops
{
prev_step
=
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_LAST_STOP
GRADIENT_DATA_LAST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
&
prev_step
)
;
let
mut
cur_idx
=
GRADIENT_DATA_TABLE_END
;
for
next
in
src_stops
{
let
next_color
=
next
.
color
.
premultiplied
(
)
;
let
next_idx
=
Self
:
:
get_index
(
1
.
0
-
next
.
offset
)
;
if
next_idx
<
cur_idx
{
prev_step
=
GradientGpuBlockBuilder
:
:
fill_colors
(
next_idx
cur_idx
&
next_color
&
cur_color
&
mut
entries
&
prev_step
)
;
cur_idx
=
next_idx
;
}
cur_color
=
next_color
;
}
if
cur_idx
!
=
GRADIENT_DATA_TABLE_BEGIN
{
error
!
(
"
Gradient
stops
abruptly
at
{
}
auto
-
completing
to
white
"
cur_idx
)
;
}
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_FIRST_STOP
GRADIENT_DATA_FIRST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
&
prev_step
)
;
}
else
{
prev_step
=
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_FIRST_STOP
GRADIENT_DATA_FIRST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
&
prev_step
)
;
let
mut
cur_idx
=
GRADIENT_DATA_TABLE_BEGIN
;
for
next
in
src_stops
{
let
next_color
=
next
.
color
.
premultiplied
(
)
;
let
next_idx
=
Self
:
:
get_index
(
next
.
offset
)
;
if
next_idx
>
cur_idx
{
prev_step
=
GradientGpuBlockBuilder
:
:
fill_colors
(
cur_idx
next_idx
&
cur_color
&
next_color
&
mut
entries
&
prev_step
)
;
cur_idx
=
next_idx
;
}
cur_color
=
next_color
;
}
if
cur_idx
!
=
GRADIENT_DATA_TABLE_END
{
error
!
(
"
Gradient
stops
abruptly
at
{
}
auto
-
completing
to
white
"
cur_idx
)
;
}
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_LAST_STOP
GRADIENT_DATA_LAST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
&
prev_step
)
;
}
for
entry
in
entries
.
iter
(
)
{
request
.
push
(
entry
.
start_color
)
;
request
.
push
(
entry
.
end_step
)
;
}
}
}
pub
fn
apply_gradient_local_clip
(
prim_rect
:
&
mut
LayoutRect
stretch_size
:
&
LayoutSize
tile_spacing
:
&
LayoutSize
clip_rect
:
&
LayoutRect
)
-
>
LayoutVector2D
{
let
w
=
prim_rect
.
max_x
(
)
.
min
(
clip_rect
.
max_x
(
)
)
-
prim_rect
.
min_x
(
)
;
let
h
=
prim_rect
.
max_y
(
)
.
min
(
clip_rect
.
max_y
(
)
)
-
prim_rect
.
min_y
(
)
;
let
is_tiled_x
=
w
>
stretch_size
.
width
+
tile_spacing
.
width
;
let
is_tiled_y
=
h
>
stretch_size
.
height
+
tile_spacing
.
height
;
let
mut
offset
=
LayoutVector2D
:
:
new
(
0
.
0
0
.
0
)
;
if
!
is_tiled_x
{
let
diff
=
(
clip_rect
.
min_x
(
)
-
prim_rect
.
min_x
(
)
)
.
min
(
prim_rect
.
size
.
width
)
;
if
diff
>
0
.
0
{
prim_rect
.
origin
.
x
+
=
diff
;
prim_rect
.
size
.
width
-
=
diff
;
offset
.
x
=
-
diff
;
}
let
diff
=
prim_rect
.
max_x
(
)
-
clip_rect
.
max_x
(
)
;
if
diff
>
0
.
0
{
prim_rect
.
size
.
width
-
=
diff
;
}
}
if
!
is_tiled_y
{
let
diff
=
(
clip_rect
.
min_y
(
)
-
prim_rect
.
min_y
(
)
)
.
min
(
prim_rect
.
size
.
height
)
;
if
diff
>
0
.
0
{
prim_rect
.
origin
.
y
+
=
diff
;
prim_rect
.
size
.
height
-
=
diff
;
offset
.
y
=
-
diff
;
}
let
diff
=
prim_rect
.
max_y
(
)
-
clip_rect
.
max_y
(
)
;
if
diff
>
0
.
0
{
prim_rect
.
size
.
height
-
=
diff
;
}
}
offset
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
test_struct_sizes
(
)
{
use
std
:
:
mem
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LinearGradient
>
(
)
72
"
LinearGradient
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LinearGradientTemplate
>
(
)
152
"
LinearGradientTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LinearGradientKey
>
(
)
88
"
LinearGradientKey
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
RadialGradient
>
(
)
72
"
RadialGradient
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
RadialGradientTemplate
>
(
)
152
"
RadialGradientTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
RadialGradientKey
>
(
)
96
"
RadialGradientKey
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
ConicGradient
>
(
)
72
"
ConicGradient
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
ConicGradientTemplate
>
(
)
152
"
ConicGradientTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
ConicGradientKey
>
(
)
96
"
ConicGradientKey
size
changed
"
)
;
}
