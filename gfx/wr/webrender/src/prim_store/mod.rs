use
api
:
:
{
AlphaType
BorderRadius
ClipMode
ColorF
PictureRect
ColorU
LayoutVector2D
}
;
use
api
:
:
{
DeviceIntRect
DeviceIntSize
DevicePixelScale
ExtendMode
DeviceRect
LayoutSideOffsetsAu
}
;
use
api
:
:
{
FilterOp
GradientStop
ImageKey
ImageRendering
TileOffset
RepeatMode
}
;
use
api
:
:
{
LayoutPoint
LayoutRect
LayoutSideOffsets
LayoutSize
}
;
use
api
:
:
{
PremultipliedColorF
PropertyBinding
Shadow
YuvColorSpace
YuvFormat
}
;
use
api
:
:
{
DeviceIntSideOffsets
WorldPixel
BoxShadowClipMode
NormalBorder
WorldRect
LayoutToWorldScale
}
;
use
api
:
:
{
PicturePixel
RasterPixel
ColorDepth
LineStyle
LineOrientation
LayoutSizeAu
AuHelpers
}
;
use
api
:
:
LayoutPrimitiveInfo
;
use
app_units
:
:
Au
;
use
border
:
:
{
get_max_scale_for_border
build_border_instances
create_border_segments
}
;
use
border
:
:
{
BorderSegmentCacheKey
NormalBorderAu
}
;
use
clip
:
:
{
ClipStore
}
;
use
clip_scroll_tree
:
:
{
ClipScrollTree
SpatialNodeIndex
}
;
use
clip
:
:
{
ClipDataStore
ClipNodeFlags
ClipChainId
ClipChainInstance
ClipItem
ClipNodeCollector
}
;
use
display_list_flattener
:
:
{
AsInstanceKind
CreateShadow
IsVisible
}
;
use
euclid
:
:
{
SideOffsets2D
TypedTransform3D
TypedRect
TypedScale
TypedSize2D
}
;
use
frame_builder
:
:
{
FrameBuildingContext
FrameBuildingState
PictureContext
PictureState
}
;
use
frame_builder
:
:
PrimitiveContext
;
use
glyph_rasterizer
:
:
GlyphKey
;
use
gpu_cache
:
:
{
GpuCache
GpuCacheAddress
GpuCacheHandle
GpuDataRequest
ToGpuBlocks
}
;
use
gpu_types
:
:
BrushFlags
;
use
image
:
:
{
self
Repetition
}
;
use
intern
;
use
internal_types
:
:
FastHashMap
;
use
picture
:
:
{
PictureCompositeMode
PicturePrimitive
PictureUpdateState
}
;
use
picture
:
:
{
ClusterRange
PrimitiveList
SurfaceIndex
TileDescriptor
}
;
use
prim_store
:
:
text_run
:
:
{
TextRunDataHandle
TextRunPrimitive
}
;
#
[
cfg
(
debug_assertions
)
]
use
render_backend
:
:
{
FrameId
}
;
use
render_backend
:
:
FrameResources
;
use
render_task
:
:
{
BlitSource
RenderTask
RenderTaskCacheKey
to_cache_size
}
;
use
render_task
:
:
{
RenderTaskCacheKeyKind
RenderTaskId
RenderTaskCacheEntryHandle
}
;
use
renderer
:
:
{
MAX_VERTEX_TEXTURE_WIDTH
}
;
use
resource_cache
:
:
{
ImageProperties
ImageRequest
ResourceCache
}
;
use
scene
:
:
SceneProperties
;
use
segment
:
:
SegmentBuilder
;
use
std
:
:
{
cmp
fmt
hash
mem
ops
u32
usize
}
;
#
[
cfg
(
debug_assertions
)
]
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicUsize
Ordering
}
;
use
storage
;
use
texture_cache
:
:
TextureCacheHandle
;
use
util
:
:
{
ScaleOffset
MatrixHelpers
MaxRect
recycle_vec
}
;
use
util
:
:
{
pack_as_float
project_rect
raster_rect_to_device_pixels
}
;
use
smallvec
:
:
SmallVec
;
pub
mod
text_run
;
#
[
cfg
(
debug_assertions
)
]
static
NEXT_PRIM_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
0
)
;
#
[
cfg
(
debug_assertions
)
]
static
PRIM_CHASE_ID
:
AtomicUsize
=
AtomicUsize
:
:
new
(
usize
:
:
MAX
)
;
#
[
cfg
(
debug_assertions
)
]
pub
fn
register_prim_chase_id
(
id
:
PrimitiveDebugId
)
{
PRIM_CHASE_ID
.
store
(
id
.
0
Ordering
:
:
SeqCst
)
;
}
#
[
cfg
(
not
(
debug_assertions
)
)
]
pub
fn
register_prim_chase_id
(
_
:
PrimitiveDebugId
)
{
}
const
MIN_BRUSH_SPLIT_AREA
:
f32
=
256
.
0
*
256
.
0
;
pub
const
VECS_PER_SEGMENT
:
usize
=
2
;
#
[
derive
(
Clone
Copy
Debug
Eq
PartialEq
)
]
pub
struct
ScrollNodeAndClipChain
{
pub
spatial_node_index
:
SpatialNodeIndex
pub
clip_chain_id
:
ClipChainId
}
impl
ScrollNodeAndClipChain
{
pub
fn
new
(
spatial_node_index
:
SpatialNodeIndex
clip_chain_id
:
ClipChainId
)
-
>
Self
{
ScrollNodeAndClipChain
{
spatial_node_index
clip_chain_id
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Copy
Clone
)
]
pub
struct
PrimitiveOpacity
{
pub
is_opaque
:
bool
}
impl
PrimitiveOpacity
{
pub
fn
opaque
(
)
-
>
PrimitiveOpacity
{
PrimitiveOpacity
{
is_opaque
:
true
}
}
pub
fn
translucent
(
)
-
>
PrimitiveOpacity
{
PrimitiveOpacity
{
is_opaque
:
false
}
}
pub
fn
from_alpha
(
alpha
:
f32
)
-
>
PrimitiveOpacity
{
PrimitiveOpacity
{
is_opaque
:
alpha
>
=
1
.
0
}
}
pub
fn
combine
(
&
self
other
:
PrimitiveOpacity
)
-
>
PrimitiveOpacity
{
PrimitiveOpacity
{
is_opaque
:
self
.
is_opaque
&
&
other
.
is_opaque
}
}
}
#
[
derive
(
Debug
Copy
Clone
)
]
pub
enum
VisibleFace
{
Front
Back
}
impl
ops
:
:
Not
for
VisibleFace
{
type
Output
=
Self
;
fn
not
(
self
)
-
>
Self
{
match
self
{
VisibleFace
:
:
Front
=
>
VisibleFace
:
:
Back
VisibleFace
:
:
Back
=
>
VisibleFace
:
:
Front
}
}
}
#
[
derive
(
Debug
)
]
pub
enum
CoordinateSpaceMapping
<
F
T
>
{
Local
ScaleOffset
(
ScaleOffset
)
Transform
(
TypedTransform3D
<
f32
F
T
>
)
}
impl
<
F
T
>
CoordinateSpaceMapping
<
F
T
>
{
pub
fn
new
(
ref_spatial_node_index
:
SpatialNodeIndex
target_node_index
:
SpatialNodeIndex
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
Option
<
Self
>
{
let
spatial_nodes
=
&
clip_scroll_tree
.
spatial_nodes
;
let
ref_spatial_node
=
&
spatial_nodes
[
ref_spatial_node_index
.
0
]
;
let
target_spatial_node
=
&
spatial_nodes
[
target_node_index
.
0
]
;
if
ref_spatial_node_index
=
=
target_node_index
{
Some
(
CoordinateSpaceMapping
:
:
Local
)
}
else
if
ref_spatial_node
.
coordinate_system_id
=
=
target_spatial_node
.
coordinate_system_id
{
Some
(
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref_spatial_node
.
coordinate_system_relative_scale_offset
.
inverse
(
)
.
accumulate
(
&
target_spatial_node
.
coordinate_system_relative_scale_offset
)
)
)
}
else
{
let
transform
=
clip_scroll_tree
.
get_relative_transform
(
target_node_index
ref_spatial_node_index
)
;
transform
.
map
(
|
transform
|
{
CoordinateSpaceMapping
:
:
Transform
(
transform
.
with_source
:
:
<
F
>
(
)
.
with_destination
:
:
<
T
>
(
)
)
}
)
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
SpaceMapper
<
F
T
>
{
kind
:
CoordinateSpaceMapping
<
F
T
>
pub
ref_spatial_node_index
:
SpatialNodeIndex
pub
current_target_spatial_node_index
:
SpatialNodeIndex
pub
bounds
:
TypedRect
<
f32
T
>
}
impl
<
F
T
>
SpaceMapper
<
F
T
>
where
F
:
fmt
:
:
Debug
{
pub
fn
new
(
ref_spatial_node_index
:
SpatialNodeIndex
bounds
:
TypedRect
<
f32
T
>
)
-
>
Self
{
SpaceMapper
{
kind
:
CoordinateSpaceMapping
:
:
Local
ref_spatial_node_index
current_target_spatial_node_index
:
ref_spatial_node_index
bounds
}
}
pub
fn
new_with_target
(
ref_spatial_node_index
:
SpatialNodeIndex
target_node_index
:
SpatialNodeIndex
bounds
:
TypedRect
<
f32
T
>
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
Self
{
let
mut
mapper
=
SpaceMapper
:
:
new
(
ref_spatial_node_index
bounds
)
;
mapper
.
set_target_spatial_node
(
target_node_index
clip_scroll_tree
)
;
mapper
}
pub
fn
set_target_spatial_node
(
&
mut
self
target_node_index
:
SpatialNodeIndex
clip_scroll_tree
:
&
ClipScrollTree
)
{
if
target_node_index
!
=
self
.
current_target_spatial_node_index
{
self
.
current_target_spatial_node_index
=
target_node_index
;
self
.
kind
=
CoordinateSpaceMapping
:
:
new
(
self
.
ref_spatial_node_index
target_node_index
clip_scroll_tree
)
.
expect
(
"
bug
:
should
have
been
culled
by
invalid
node
"
)
;
}
}
pub
fn
get_transform
(
&
self
)
-
>
TypedTransform3D
<
f32
F
T
>
{
match
self
.
kind
{
CoordinateSpaceMapping
:
:
Local
=
>
{
TypedTransform3D
:
:
identity
(
)
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
scale_offset
.
to_transform
(
)
}
CoordinateSpaceMapping
:
:
Transform
(
transform
)
=
>
{
transform
}
}
}
pub
fn
unmap
(
&
self
rect
:
&
TypedRect
<
f32
T
>
)
-
>
Option
<
TypedRect
<
f32
F
>
>
{
match
self
.
kind
{
CoordinateSpaceMapping
:
:
Local
=
>
{
Some
(
TypedRect
:
:
from_untyped
(
&
rect
.
to_untyped
(
)
)
)
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
Some
(
scale_offset
.
unmap_rect
(
rect
)
)
}
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
{
transform
.
inverse_rect_footprint
(
rect
)
}
}
}
pub
fn
map
(
&
self
rect
:
&
TypedRect
<
f32
F
>
)
-
>
Option
<
TypedRect
<
f32
T
>
>
{
match
self
.
kind
{
CoordinateSpaceMapping
:
:
Local
=
>
{
Some
(
TypedRect
:
:
from_untyped
(
&
rect
.
to_untyped
(
)
)
)
}
CoordinateSpaceMapping
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
Some
(
scale_offset
.
map_rect
(
rect
)
)
}
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
{
match
project_rect
(
transform
rect
&
self
.
bounds
)
{
Some
(
bounds
)
=
>
{
Some
(
bounds
)
}
None
=
>
{
warn
!
(
"
parent
relative
transform
can
'
t
transform
the
primitive
rect
for
{
:
?
}
"
rect
)
;
None
}
}
}
}
}
pub
fn
visible_face
(
&
self
)
-
>
VisibleFace
{
match
self
.
kind
{
CoordinateSpaceMapping
:
:
Local
=
>
VisibleFace
:
:
Front
CoordinateSpaceMapping
:
:
ScaleOffset
(
_
)
=
>
VisibleFace
:
:
Front
CoordinateSpaceMapping
:
:
Transform
(
ref
transform
)
=
>
{
if
transform
.
is_backface_visible
(
)
{
VisibleFace
:
:
Back
}
else
{
VisibleFace
:
:
Front
}
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeferredResolve
{
pub
address
:
GpuCacheAddress
pub
image_properties
:
ImageProperties
pub
rendering
:
ImageRendering
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
pub
struct
ClipTaskIndex
(
pub
u32
)
;
impl
ClipTaskIndex
{
pub
const
INVALID
:
ClipTaskIndex
=
ClipTaskIndex
(
0
)
;
}
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
Ord
PartialOrd
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureIndex
(
pub
usize
)
;
impl
GpuCacheHandle
{
pub
fn
as_int
(
&
self
gpu_cache
:
&
GpuCache
)
-
>
i32
{
gpu_cache
.
get_address
(
self
)
.
as_int
(
)
}
}
impl
GpuCacheAddress
{
pub
fn
as_int
(
&
self
)
-
>
i32
{
self
.
v
as
i32
*
MAX_VERTEX_TEXTURE_WIDTH
as
i32
+
self
.
u
as
i32
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveSceneData
{
pub
culling_rect
:
LayoutRect
pub
is_backface_visible
:
bool
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
enum
PrimitiveKeyKind
{
Unused
LineDecoration
{
cache_key
:
Option
<
LineDecorationCacheKey
>
color
:
ColorU
}
Clear
NormalBorder
{
border
:
NormalBorderAu
widths
:
LayoutSideOffsetsAu
}
ImageBorder
{
request
:
ImageRequest
nine_patch
:
NinePatchDescriptor
}
Rectangle
{
color
:
ColorU
}
YuvImage
{
color_depth
:
ColorDepth
yuv_key
:
[
ImageKey
;
3
]
format
:
YuvFormat
color_space
:
YuvColorSpace
image_rendering
:
ImageRendering
}
Image
{
key
:
ImageKey
stretch_size
:
SizeKey
tile_spacing
:
SizeKey
color
:
ColorU
sub_rect
:
Option
<
DeviceIntRect
>
image_rendering
:
ImageRendering
alpha_type
:
AlphaType
}
LinearGradient
{
extend_mode
:
ExtendMode
start_point
:
PointKey
end_point
:
PointKey
stretch_size
:
SizeKey
tile_spacing
:
SizeKey
stops
:
Vec
<
GradientStopKey
>
reverse_stops
:
bool
nine_patch
:
Option
<
Box
<
NinePatchDescriptor
>
>
}
RadialGradient
{
extend_mode
:
ExtendMode
center
:
PointKey
params
:
RadialGradientParams
stretch_size
:
SizeKey
stops
:
Vec
<
GradientStopKey
>
tile_spacing
:
SizeKey
nine_patch
:
Option
<
Box
<
NinePatchDescriptor
>
>
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
GradientStopKey
{
pub
offset
:
f32
pub
color
:
ColorU
}
impl
Eq
for
GradientStopKey
{
}
impl
hash
:
:
Hash
for
GradientStopKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
offset
.
to_bits
(
)
.
hash
(
state
)
;
self
.
color
.
hash
(
state
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
RectangleKey
{
x
:
f32
y
:
f32
w
:
f32
h
:
f32
}
impl
Eq
for
RectangleKey
{
}
impl
hash
:
:
Hash
for
RectangleKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
x
.
to_bits
(
)
.
hash
(
state
)
;
self
.
y
.
to_bits
(
)
.
hash
(
state
)
;
self
.
w
.
to_bits
(
)
.
hash
(
state
)
;
self
.
h
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
From
<
RectangleKey
>
for
LayoutRect
{
fn
from
(
key
:
RectangleKey
)
-
>
LayoutRect
{
LayoutRect
{
origin
:
LayoutPoint
:
:
new
(
key
.
x
key
.
y
)
size
:
LayoutSize
:
:
new
(
key
.
w
key
.
h
)
}
}
}
impl
From
<
LayoutRect
>
for
RectangleKey
{
fn
from
(
rect
:
LayoutRect
)
-
>
RectangleKey
{
RectangleKey
{
x
:
rect
.
origin
.
x
y
:
rect
.
origin
.
y
w
:
rect
.
size
.
width
h
:
rect
.
size
.
height
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
SideOffsetsKey
{
pub
top
:
f32
pub
right
:
f32
pub
bottom
:
f32
pub
left
:
f32
}
impl
Eq
for
SideOffsetsKey
{
}
impl
hash
:
:
Hash
for
SideOffsetsKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
top
.
to_bits
(
)
.
hash
(
state
)
;
self
.
right
.
to_bits
(
)
.
hash
(
state
)
;
self
.
bottom
.
to_bits
(
)
.
hash
(
state
)
;
self
.
left
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
From
<
SideOffsetsKey
>
for
LayoutSideOffsets
{
fn
from
(
key
:
SideOffsetsKey
)
-
>
LayoutSideOffsets
{
LayoutSideOffsets
:
:
new
(
key
.
top
key
.
right
key
.
bottom
key
.
left
)
}
}
impl
From
<
LayoutSideOffsets
>
for
SideOffsetsKey
{
fn
from
(
offsets
:
LayoutSideOffsets
)
-
>
SideOffsetsKey
{
SideOffsetsKey
{
top
:
offsets
.
top
right
:
offsets
.
right
bottom
:
offsets
.
bottom
left
:
offsets
.
left
}
}
}
impl
From
<
SideOffsets2D
<
f32
>
>
for
SideOffsetsKey
{
fn
from
(
offsets
:
SideOffsets2D
<
f32
>
)
-
>
SideOffsetsKey
{
SideOffsetsKey
{
top
:
offsets
.
top
right
:
offsets
.
right
bottom
:
offsets
.
bottom
left
:
offsets
.
left
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Copy
Debug
Clone
PartialEq
)
]
pub
struct
SizeKey
{
w
:
f32
h
:
f32
}
impl
Eq
for
SizeKey
{
}
impl
hash
:
:
Hash
for
SizeKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
w
.
to_bits
(
)
.
hash
(
state
)
;
self
.
h
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
From
<
SizeKey
>
for
LayoutSize
{
fn
from
(
key
:
SizeKey
)
-
>
LayoutSize
{
LayoutSize
:
:
new
(
key
.
w
key
.
h
)
}
}
impl
<
U
>
From
<
TypedSize2D
<
f32
U
>
>
for
SizeKey
{
fn
from
(
size
:
TypedSize2D
<
f32
U
>
)
-
>
SizeKey
{
SizeKey
{
w
:
size
.
width
h
:
size
.
height
}
}
}
impl
SizeKey
{
pub
fn
zero
(
)
-
>
SizeKey
{
SizeKey
{
w
:
0
.
0
h
:
0
.
0
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
RadialGradientParams
{
pub
start_radius
:
f32
pub
end_radius
:
f32
pub
ratio_xy
:
f32
}
impl
Eq
for
RadialGradientParams
{
}
impl
hash
:
:
Hash
for
RadialGradientParams
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
start_radius
.
to_bits
(
)
.
hash
(
state
)
;
self
.
end_radius
.
to_bits
(
)
.
hash
(
state
)
;
self
.
ratio_xy
.
to_bits
(
)
.
hash
(
state
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
PartialEq
)
]
pub
struct
PointKey
{
x
:
f32
y
:
f32
}
impl
Eq
for
PointKey
{
}
impl
hash
:
:
Hash
for
PointKey
{
fn
hash
<
H
:
hash
:
:
Hasher
>
(
&
self
state
:
&
mut
H
)
{
self
.
x
.
to_bits
(
)
.
hash
(
state
)
;
self
.
y
.
to_bits
(
)
.
hash
(
state
)
;
}
}
impl
From
<
PointKey
>
for
LayoutPoint
{
fn
from
(
key
:
PointKey
)
-
>
LayoutPoint
{
LayoutPoint
:
:
new
(
key
.
x
key
.
y
)
}
}
impl
From
<
LayoutPoint
>
for
PointKey
{
fn
from
(
p
:
LayoutPoint
)
-
>
PointKey
{
PointKey
{
x
:
p
.
x
y
:
p
.
y
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
PrimKeyCommonData
{
pub
is_backface_visible
:
bool
pub
prim_rect
:
RectangleKey
pub
clip_rect
:
RectangleKey
}
impl
PrimKeyCommonData
{
pub
fn
with_info
(
info
:
&
LayoutPrimitiveInfo
)
-
>
Self
{
PrimKeyCommonData
{
is_backface_visible
:
info
.
is_backface_visible
prim_rect
:
info
.
rect
.
into
(
)
clip_rect
:
info
.
clip_rect
.
into
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Eq
PartialEq
Hash
)
]
pub
struct
PrimitiveKey
{
pub
common
:
PrimKeyCommonData
pub
kind
:
PrimitiveKeyKind
}
impl
PrimitiveKey
{
pub
fn
new
(
is_backface_visible
:
bool
prim_rect
:
LayoutRect
clip_rect
:
LayoutRect
kind
:
PrimitiveKeyKind
)
-
>
Self
{
PrimitiveKey
{
common
:
PrimKeyCommonData
{
is_backface_visible
prim_rect
:
prim_rect
.
into
(
)
clip_rect
:
clip_rect
.
into
(
)
}
kind
}
}
}
impl
AsInstanceKind
<
PrimitiveDataHandle
>
for
PrimitiveKey
{
fn
as_instance_kind
(
&
self
data_handle
:
PrimitiveDataHandle
prim_store
:
&
mut
PrimitiveStore
)
-
>
PrimitiveInstanceKind
{
match
self
.
kind
{
PrimitiveKeyKind
:
:
LineDecoration
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
LineDecoration
{
data_handle
cache_handle
:
None
}
}
PrimitiveKeyKind
:
:
Clear
=
>
{
PrimitiveInstanceKind
:
:
Clear
{
data_handle
}
}
PrimitiveKeyKind
:
:
NormalBorder
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
NormalBorder
{
data_handle
cache_handles
:
storage
:
:
Range
:
:
empty
(
)
}
}
PrimitiveKeyKind
:
:
ImageBorder
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
}
}
PrimitiveKeyKind
:
:
Rectangle
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
opacity_binding_index
:
OpacityBindingIndex
:
:
INVALID
segment_instance_index
:
SegmentInstanceIndex
:
:
INVALID
}
}
PrimitiveKeyKind
:
:
YuvImage
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
segment_instance_index
:
SegmentInstanceIndex
:
:
INVALID
}
}
PrimitiveKeyKind
:
:
Image
{
.
.
}
=
>
{
let
image_instance_index
=
prim_store
.
images
.
push
(
ImageInstance
{
opacity_binding_index
:
OpacityBindingIndex
:
:
INVALID
segment_instance_index
:
SegmentInstanceIndex
:
:
INVALID
visible_tiles
:
Vec
:
:
new
(
)
}
)
;
PrimitiveInstanceKind
:
:
Image
{
data_handle
image_instance_index
}
}
PrimitiveKeyKind
:
:
LinearGradient
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
visible_tiles_range
:
GradientTileRange
:
:
empty
(
)
}
}
PrimitiveKeyKind
:
:
RadialGradient
{
.
.
}
=
>
{
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
visible_tiles_range
:
GradientTileRange
:
:
empty
(
)
}
}
PrimitiveKeyKind
:
:
Unused
=
>
{
unreachable
!
(
)
;
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NormalBorderTemplate
{
pub
brush_segments
:
Vec
<
BrushSegment
>
pub
border_segments
:
Vec
<
BorderSegmentInfo
>
pub
border
:
NormalBorder
pub
widths
:
LayoutSideOffsets
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
PrimitiveTemplateKind
{
LineDecoration
{
cache_key
:
Option
<
LineDecorationCacheKey
>
color
:
ColorF
}
NormalBorder
{
template
:
Box
<
NormalBorderTemplate
>
}
ImageBorder
{
request
:
ImageRequest
brush_segments
:
Vec
<
BrushSegment
>
}
Rectangle
{
color
:
ColorF
}
YuvImage
{
color_depth
:
ColorDepth
yuv_key
:
[
ImageKey
;
3
]
format
:
YuvFormat
color_space
:
YuvColorSpace
image_rendering
:
ImageRendering
}
Image
{
key
:
ImageKey
stretch_size
:
LayoutSize
tile_spacing
:
LayoutSize
color
:
ColorF
source
:
ImageSource
image_rendering
:
ImageRendering
sub_rect
:
Option
<
DeviceIntRect
>
alpha_type
:
AlphaType
}
LinearGradient
{
extend_mode
:
ExtendMode
start_point
:
LayoutPoint
end_point
:
LayoutPoint
stretch_size
:
LayoutSize
tile_spacing
:
LayoutSize
stops_opacity
:
PrimitiveOpacity
stops
:
Vec
<
GradientStop
>
brush_segments
:
Vec
<
BrushSegment
>
reverse_stops
:
bool
stops_handle
:
GpuCacheHandle
}
RadialGradient
{
extend_mode
:
ExtendMode
center
:
LayoutPoint
params
:
RadialGradientParams
stretch_size
:
LayoutSize
tile_spacing
:
LayoutSize
brush_segments
:
Vec
<
BrushSegment
>
stops
:
Vec
<
GradientStop
>
stops_handle
:
GpuCacheHandle
}
Clear
Unused
}
impl
PrimitiveKeyKind
{
fn
into_template
(
self
rect
:
&
LayoutRect
)
-
>
PrimitiveTemplateKind
{
match
self
{
PrimitiveKeyKind
:
:
Unused
=
>
PrimitiveTemplateKind
:
:
Unused
PrimitiveKeyKind
:
:
Clear
=
>
{
PrimitiveTemplateKind
:
:
Clear
}
PrimitiveKeyKind
:
:
NormalBorder
{
widths
border
.
.
}
=
>
{
let
mut
border
:
NormalBorder
=
border
.
into
(
)
;
let
widths
=
LayoutSideOffsets
:
:
from_au
(
widths
)
;
border
.
normalize
(
&
widths
)
;
let
mut
brush_segments
=
Vec
:
:
new
(
)
;
let
mut
border_segments
=
Vec
:
:
new
(
)
;
create_border_segments
(
rect
.
size
&
border
&
widths
&
mut
border_segments
&
mut
brush_segments
)
;
PrimitiveTemplateKind
:
:
NormalBorder
{
template
:
Box
:
:
new
(
NormalBorderTemplate
{
border
widths
border_segments
brush_segments
}
)
}
}
PrimitiveKeyKind
:
:
ImageBorder
{
request
ref
nine_patch
.
.
}
=
>
{
let
brush_segments
=
nine_patch
.
create_segments
(
rect
.
size
)
;
PrimitiveTemplateKind
:
:
ImageBorder
{
request
brush_segments
}
}
PrimitiveKeyKind
:
:
Rectangle
{
color
.
.
}
=
>
{
PrimitiveTemplateKind
:
:
Rectangle
{
color
:
color
.
into
(
)
}
}
PrimitiveKeyKind
:
:
YuvImage
{
color_depth
yuv_key
format
color_space
image_rendering
.
.
}
=
>
{
PrimitiveTemplateKind
:
:
YuvImage
{
color_depth
yuv_key
format
color_space
image_rendering
}
}
PrimitiveKeyKind
:
:
Image
{
alpha_type
key
color
stretch_size
tile_spacing
image_rendering
sub_rect
.
.
}
=
>
{
PrimitiveTemplateKind
:
:
Image
{
key
color
:
color
.
into
(
)
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
source
:
ImageSource
:
:
Default
sub_rect
image_rendering
alpha_type
}
}
PrimitiveKeyKind
:
:
LineDecoration
{
cache_key
color
}
=
>
{
PrimitiveTemplateKind
:
:
LineDecoration
{
cache_key
color
:
color
.
into
(
)
}
}
PrimitiveKeyKind
:
:
LinearGradient
{
extend_mode
tile_spacing
start_point
end_point
stretch_size
stops
reverse_stops
nine_patch
.
.
}
=
>
{
let
mut
min_alpha
:
f32
=
1
.
0
;
let
stops
=
stops
.
iter
(
)
.
map
(
|
stop
|
{
let
color
:
ColorF
=
stop
.
color
.
into
(
)
;
min_alpha
=
min_alpha
.
min
(
color
.
a
)
;
GradientStop
{
offset
:
stop
.
offset
color
}
}
)
.
collect
(
)
;
let
mut
brush_segments
=
Vec
:
:
new
(
)
;
if
let
Some
(
ref
nine_patch
)
=
nine_patch
{
brush_segments
=
nine_patch
.
create_segments
(
rect
.
size
)
;
}
let
stops_opacity
=
PrimitiveOpacity
:
:
from_alpha
(
min_alpha
)
;
PrimitiveTemplateKind
:
:
LinearGradient
{
extend_mode
start_point
:
start_point
.
into
(
)
end_point
:
end_point
.
into
(
)
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
stops_opacity
stops
brush_segments
reverse_stops
stops_handle
:
GpuCacheHandle
:
:
new
(
)
}
}
PrimitiveKeyKind
:
:
RadialGradient
{
extend_mode
params
stretch_size
tile_spacing
nine_patch
center
stops
.
.
}
=
>
{
let
mut
brush_segments
=
Vec
:
:
new
(
)
;
if
let
Some
(
ref
nine_patch
)
=
nine_patch
{
brush_segments
=
nine_patch
.
create_segments
(
rect
.
size
)
;
}
let
stops
=
stops
.
iter
(
)
.
map
(
|
stop
|
{
GradientStop
{
offset
:
stop
.
offset
color
:
stop
.
color
.
into
(
)
}
}
)
.
collect
(
)
;
PrimitiveTemplateKind
:
:
RadialGradient
{
center
:
center
.
into
(
)
extend_mode
params
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
brush_segments
stops_handle
:
GpuCacheHandle
:
:
new
(
)
stops
}
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimTemplateCommonData
{
pub
is_backface_visible
:
bool
pub
prim_rect
:
LayoutRect
pub
clip_rect
:
LayoutRect
pub
opacity
:
PrimitiveOpacity
pub
gpu_cache_handle
:
GpuCacheHandle
}
impl
PrimTemplateCommonData
{
pub
fn
with_key_common
(
common
:
PrimKeyCommonData
)
-
>
Self
{
PrimTemplateCommonData
{
is_backface_visible
:
common
.
is_backface_visible
prim_rect
:
common
.
prim_rect
.
into
(
)
clip_rect
:
common
.
clip_rect
.
into
(
)
gpu_cache_handle
:
GpuCacheHandle
:
:
new
(
)
opacity
:
PrimitiveOpacity
:
:
translucent
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveTemplate
{
pub
common
:
PrimTemplateCommonData
pub
kind
:
PrimitiveTemplateKind
}
impl
ops
:
:
Deref
for
PrimitiveTemplate
{
type
Target
=
PrimTemplateCommonData
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
common
}
}
impl
ops
:
:
DerefMut
for
PrimitiveTemplate
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
common
}
}
impl
From
<
PrimitiveKey
>
for
PrimitiveTemplate
{
fn
from
(
item
:
PrimitiveKey
)
-
>
Self
{
let
common
=
PrimTemplateCommonData
:
:
with_key_common
(
item
.
common
)
;
let
kind
=
item
.
kind
.
into_template
(
&
common
.
prim_rect
)
;
PrimitiveTemplate
{
common
kind
}
}
}
impl
PrimitiveTemplateKind
{
fn
write_prim_gpu_blocks
(
&
self
request
:
&
mut
GpuDataRequest
prim_size
:
LayoutSize
)
{
match
*
self
{
PrimitiveTemplateKind
:
:
Clear
=
>
{
request
.
push
(
PremultipliedColorF
:
:
BLACK
)
;
}
PrimitiveTemplateKind
:
:
Rectangle
{
ref
color
.
.
}
=
>
{
request
.
push
(
color
.
premultiplied
(
)
)
;
}
PrimitiveTemplateKind
:
:
NormalBorder
{
.
.
}
=
>
{
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
prim_size
.
width
prim_size
.
height
0
.
0
0
.
0
]
)
;
}
PrimitiveTemplateKind
:
:
ImageBorder
{
.
.
}
=
>
{
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
prim_size
.
width
prim_size
.
height
0
.
0
0
.
0
]
)
;
}
PrimitiveTemplateKind
:
:
LineDecoration
{
ref
cache_key
ref
color
}
=
>
{
match
cache_key
{
Some
(
cache_key
)
=
>
{
request
.
push
(
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
cache_key
.
size
.
width
.
to_f32_px
(
)
cache_key
.
size
.
height
.
to_f32_px
(
)
0
.
0
0
.
0
]
)
;
}
None
=
>
{
request
.
push
(
color
.
premultiplied
(
)
)
;
}
}
}
PrimitiveTemplateKind
:
:
YuvImage
{
color_depth
.
.
}
=
>
{
request
.
push
(
[
color_depth
.
rescaling_factor
(
)
0
.
0
0
.
0
0
.
0
]
)
;
}
PrimitiveTemplateKind
:
:
Image
{
stretch_size
tile_spacing
color
.
.
}
=
>
{
request
.
push
(
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
stretch_size
.
width
+
tile_spacing
.
width
stretch_size
.
height
+
tile_spacing
.
height
0
.
0
0
.
0
]
)
;
}
PrimitiveTemplateKind
:
:
LinearGradient
{
stretch_size
start_point
end_point
extend_mode
.
.
}
=
>
{
request
.
push
(
[
start_point
.
x
start_point
.
y
end_point
.
x
end_point
.
y
]
)
;
request
.
push
(
[
pack_as_float
(
extend_mode
as
u32
)
stretch_size
.
width
stretch_size
.
height
0
.
0
]
)
;
}
PrimitiveTemplateKind
:
:
RadialGradient
{
center
ref
params
extend_mode
stretch_size
.
.
}
=
>
{
request
.
push
(
[
center
.
x
center
.
y
params
.
start_radius
params
.
end_radius
]
)
;
request
.
push
(
[
params
.
ratio_xy
pack_as_float
(
extend_mode
as
u32
)
stretch_size
.
width
stretch_size
.
height
]
)
;
}
PrimitiveTemplateKind
:
:
Unused
=
>
{
}
}
}
fn
write_segment_gpu_blocks
(
&
self
request
:
&
mut
GpuDataRequest
)
{
match
*
self
{
PrimitiveTemplateKind
:
:
NormalBorder
{
ref
template
.
.
}
=
>
{
for
segment
in
&
template
.
brush_segments
{
request
.
write_segment
(
segment
.
local_rect
segment
.
extra_data
)
;
}
}
PrimitiveTemplateKind
:
:
ImageBorder
{
ref
brush_segments
.
.
}
=
>
{
for
segment
in
brush_segments
{
request
.
write_segment
(
segment
.
local_rect
segment
.
extra_data
)
;
}
}
PrimitiveTemplateKind
:
:
LinearGradient
{
ref
brush_segments
.
.
}
|
PrimitiveTemplateKind
:
:
RadialGradient
{
ref
brush_segments
.
.
}
=
>
{
for
segment
in
brush_segments
{
request
.
write_segment
(
segment
.
local_rect
segment
.
extra_data
)
;
}
}
PrimitiveTemplateKind
:
:
Clear
|
PrimitiveTemplateKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveTemplateKind
:
:
Image
{
.
.
}
|
PrimitiveTemplateKind
:
:
Rectangle
{
.
.
}
|
PrimitiveTemplateKind
:
:
YuvImage
{
.
.
}
|
PrimitiveTemplateKind
:
:
Unused
=
>
{
}
}
}
}
impl
PrimitiveTemplate
{
pub
fn
update
(
&
mut
self
surface_index
:
SurfaceIndex
frame_state
:
&
mut
FrameBuildingState
)
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
common
.
gpu_cache_handle
)
{
self
.
kind
.
write_prim_gpu_blocks
(
&
mut
request
self
.
common
.
prim_rect
.
size
)
;
self
.
kind
.
write_segment_gpu_blocks
(
&
mut
request
)
;
}
self
.
opacity
=
match
self
.
kind
{
PrimitiveTemplateKind
:
:
Clear
=
>
{
PrimitiveOpacity
:
:
translucent
(
)
}
PrimitiveTemplateKind
:
:
Rectangle
{
ref
color
.
.
}
=
>
{
PrimitiveOpacity
:
:
from_alpha
(
color
.
a
)
}
PrimitiveTemplateKind
:
:
NormalBorder
{
.
.
}
=
>
{
PrimitiveOpacity
:
:
translucent
(
)
}
PrimitiveTemplateKind
:
:
LinearGradient
{
stretch_size
tile_spacing
stops_opacity
ref
mut
stops_handle
reverse_stops
ref
stops
.
.
}
=
>
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
stops_handle
)
{
GradientGpuBlockBuilder
:
:
build
(
reverse_stops
&
mut
request
stops
)
;
}
let
stride
=
stretch_size
+
tile_spacing
;
if
stride
.
width
>
=
self
.
common
.
prim_rect
.
size
.
width
&
&
stride
.
height
>
=
self
.
common
.
prim_rect
.
size
.
height
{
stops_opacity
}
else
{
PrimitiveOpacity
:
:
translucent
(
)
}
}
PrimitiveTemplateKind
:
:
RadialGradient
{
ref
mut
stops_handle
ref
stops
.
.
}
=
>
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
stops_handle
)
{
GradientGpuBlockBuilder
:
:
build
(
false
&
mut
request
stops
)
;
}
PrimitiveOpacity
:
:
translucent
(
)
}
PrimitiveTemplateKind
:
:
ImageBorder
{
request
.
.
}
=
>
{
let
image_properties
=
frame_state
.
resource_cache
.
get_image_properties
(
request
.
key
)
;
if
let
Some
(
image_properties
)
=
image_properties
{
frame_state
.
resource_cache
.
request_image
(
request
frame_state
.
gpu_cache
)
;
PrimitiveOpacity
{
is_opaque
:
image_properties
.
descriptor
.
is_opaque
}
}
else
{
PrimitiveOpacity
:
:
opaque
(
)
}
}
PrimitiveTemplateKind
:
:
LineDecoration
{
ref
cache_key
ref
color
}
=
>
{
match
cache_key
{
Some
(
.
.
)
=
>
PrimitiveOpacity
:
:
translucent
(
)
None
=
>
PrimitiveOpacity
:
:
from_alpha
(
color
.
a
)
}
}
PrimitiveTemplateKind
:
:
YuvImage
{
format
yuv_key
image_rendering
.
.
}
=
>
{
let
channel_num
=
format
.
get_plane_num
(
)
;
debug_assert
!
(
channel_num
<
=
3
)
;
for
channel
in
0
.
.
channel_num
{
frame_state
.
resource_cache
.
request_image
(
ImageRequest
{
key
:
yuv_key
[
channel
]
rendering
:
image_rendering
tile
:
None
}
frame_state
.
gpu_cache
)
;
}
PrimitiveOpacity
:
:
translucent
(
)
}
PrimitiveTemplateKind
:
:
Image
{
key
stretch_size
ref
color
tile_spacing
ref
mut
source
sub_rect
image_rendering
.
.
}
=
>
{
let
image_properties
=
frame_state
.
resource_cache
.
get_image_properties
(
key
)
;
match
image_properties
{
Some
(
image_properties
)
=
>
{
let
is_tiled
=
image_properties
.
tiling
.
is_some
(
)
;
if
tile_spacing
!
=
LayoutSize
:
:
zero
(
)
&
&
!
is_tiled
{
*
source
=
ImageSource
:
:
Cache
{
size
:
image_properties
.
descriptor
.
size
.
to_i32
(
)
handle
:
None
}
;
}
if
let
Some
(
rect
)
=
sub_rect
{
debug_assert
!
(
!
is_tiled
)
;
*
source
=
ImageSource
:
:
Cache
{
size
:
rect
.
size
handle
:
None
}
;
}
let
mut
request_source_image
=
false
;
let
mut
is_opaque
=
image_properties
.
descriptor
.
is_opaque
;
let
request
=
ImageRequest
{
key
rendering
:
image_rendering
tile
:
None
}
;
match
*
source
{
ImageSource
:
:
Cache
{
ref
mut
size
ref
mut
handle
}
=
>
{
let
padding
=
DeviceIntSideOffsets
:
:
new
(
0
(
tile_spacing
.
width
*
size
.
width
as
f32
/
stretch_size
.
width
)
as
i32
(
tile_spacing
.
height
*
size
.
height
as
f32
/
stretch_size
.
height
)
as
i32
0
)
;
let
inner_size
=
*
size
;
size
.
width
+
=
padding
.
horizontal
(
)
;
size
.
height
+
=
padding
.
vertical
(
)
;
is_opaque
&
=
padding
=
=
DeviceIntSideOffsets
:
:
zero
(
)
;
let
image_cache_key
=
ImageCacheKey
{
request
texel_rect
:
sub_rect
}
;
let
surfaces
=
&
mut
frame_state
.
surfaces
;
*
handle
=
Some
(
frame_state
.
resource_cache
.
request_render_task
(
RenderTaskCacheKey
{
size
:
*
size
kind
:
RenderTaskCacheKeyKind
:
:
Image
(
image_cache_key
)
}
frame_state
.
gpu_cache
frame_state
.
render_tasks
None
image_properties
.
descriptor
.
is_opaque
|
render_tasks
|
{
request_source_image
=
true
;
let
cache_to_target_task
=
RenderTask
:
:
new_blit_with_padding
(
inner_size
&
padding
BlitSource
:
:
Image
{
key
:
image_cache_key
}
)
;
let
cache_to_target_task_id
=
render_tasks
.
add
(
cache_to_target_task
)
;
let
target_to_cache_task
=
RenderTask
:
:
new_blit
(
*
size
BlitSource
:
:
RenderTask
{
task_id
:
cache_to_target_task_id
}
)
;
let
target_to_cache_task_id
=
render_tasks
.
add
(
target_to_cache_task
)
;
surfaces
[
surface_index
.
0
]
.
tasks
.
push
(
target_to_cache_task_id
)
;
target_to_cache_task_id
}
)
)
;
}
ImageSource
:
:
Default
=
>
{
request_source_image
=
true
;
}
}
if
request_source_image
&
&
!
is_tiled
{
frame_state
.
resource_cache
.
request_image
(
request
frame_state
.
gpu_cache
)
;
}
if
is_opaque
{
PrimitiveOpacity
:
:
from_alpha
(
color
.
a
)
}
else
{
PrimitiveOpacity
:
:
translucent
(
)
}
}
None
=
>
{
PrimitiveOpacity
:
:
opaque
(
)
}
}
}
PrimitiveTemplateKind
:
:
Unused
=
>
{
PrimitiveOpacity
:
:
translucent
(
)
}
}
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
PartialEq
)
]
pub
struct
PrimitiveDataMarker
;
impl
intern
:
:
Internable
for
PrimitiveKeyKind
{
type
Marker
=
PrimitiveDataMarker
;
type
Source
=
PrimitiveKey
;
type
StoreData
=
PrimitiveTemplate
;
type
InternData
=
PrimitiveSceneData
;
fn
build_key
(
self
info
:
&
LayoutPrimitiveInfo
)
-
>
PrimitiveKey
{
PrimitiveKey
:
:
new
(
info
.
is_backface_visible
info
.
rect
info
.
clip_rect
self
)
}
}
pub
type
PrimitiveDataStore
=
intern
:
:
DataStore
<
PrimitiveKey
PrimitiveTemplate
PrimitiveDataMarker
>
;
pub
type
PrimitiveDataHandle
=
intern
:
:
Handle
<
PrimitiveDataMarker
>
;
pub
type
PrimitiveDataUpdateList
=
intern
:
:
UpdateList
<
PrimitiveKey
>
;
pub
type
PrimitiveDataInterner
=
intern
:
:
Interner
<
PrimitiveKey
PrimitiveSceneData
PrimitiveDataMarker
>
;
#
[
derive
(
Debug
)
]
pub
struct
OpacityBinding
{
pub
bindings
:
Vec
<
PropertyBinding
<
f32
>
>
pub
current
:
f32
}
impl
OpacityBinding
{
pub
fn
new
(
)
-
>
OpacityBinding
{
OpacityBinding
{
bindings
:
Vec
:
:
new
(
)
current
:
1
.
0
}
}
pub
fn
push
(
&
mut
self
binding
:
PropertyBinding
<
f32
>
)
{
self
.
bindings
.
push
(
binding
)
;
}
pub
fn
update
(
&
mut
self
scene_properties
:
&
SceneProperties
)
{
let
mut
new_opacity
=
1
.
0
;
for
binding
in
&
self
.
bindings
{
let
opacity
=
scene_properties
.
resolve_float
(
binding
)
;
new_opacity
=
new_opacity
*
opacity
;
}
self
.
current
=
new_opacity
;
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
VisibleImageTile
{
pub
tile_offset
:
TileOffset
pub
handle
:
GpuCacheHandle
pub
edge_flags
:
EdgeAaSegmentMask
pub
local_rect
:
LayoutRect
pub
local_clip_rect
:
LayoutRect
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
VisibleMaskImageTile
{
pub
tile_offset
:
TileOffset
pub
tile_rect
:
LayoutRect
}
#
[
derive
(
Debug
)
]
pub
struct
VisibleGradientTile
{
pub
handle
:
GpuCacheHandle
pub
local_rect
:
LayoutRect
pub
local_clip_rect
:
LayoutRect
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
)
]
pub
struct
BorderSegmentInfo
{
pub
local_task_size
:
LayoutSize
pub
cache_key
:
BorderSegmentCacheKey
}
bitflags
!
{
/
/
/
Each
bit
of
the
edge
AA
mask
is
:
/
/
/
0
when
the
edge
of
the
primitive
needs
to
be
considered
for
AA
/
/
/
1
when
the
edge
of
the
segment
needs
to
be
considered
for
AA
/
/
/
/
/
/
*
Note
*
:
the
bit
values
have
to
match
the
shader
logic
in
/
/
/
write_transform_vertex
(
)
function
.
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
EdgeAaSegmentMask
:
u8
{
const
LEFT
=
0x1
;
const
TOP
=
0x2
;
const
RIGHT
=
0x4
;
const
BOTTOM
=
0x8
;
}
}
#
[
derive
(
Debug
Clone
)
]
pub
enum
ClipMaskKind
{
Mask
(
RenderTaskId
)
None
Clipped
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
)
]
pub
struct
BrushSegment
{
pub
local_rect
:
LayoutRect
pub
may_need_clip_mask
:
bool
pub
edge_flags
:
EdgeAaSegmentMask
pub
extra_data
:
[
f32
;
4
]
pub
brush_flags
:
BrushFlags
}
impl
BrushSegment
{
pub
fn
new
(
local_rect
:
LayoutRect
may_need_clip_mask
:
bool
edge_flags
:
EdgeAaSegmentMask
extra_data
:
[
f32
;
4
]
brush_flags
:
BrushFlags
)
-
>
Self
{
Self
{
local_rect
may_need_clip_mask
edge_flags
extra_data
brush_flags
}
}
pub
fn
update_clip_task
(
&
self
clip_chain
:
Option
<
&
ClipChainInstance
>
prim_bounding_rect
:
WorldRect
root_spatial_node_index
:
SpatialNodeIndex
surface_index
:
SurfaceIndex
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
clip_data_store
:
&
mut
ClipDataStore
)
-
>
ClipMaskKind
{
match
clip_chain
{
Some
(
clip_chain
)
=
>
{
if
!
clip_chain
.
needs_mask
|
|
(
!
self
.
may_need_clip_mask
&
&
!
clip_chain
.
has_non_local_clips
)
{
return
ClipMaskKind
:
:
None
;
}
let
(
device_rect
_
)
=
match
get_raster_rects
(
clip_chain
.
pic_clip_rect
&
pic_state
.
map_pic_to_raster
&
pic_state
.
map_raster_to_world
prim_bounding_rect
frame_context
.
device_pixel_scale
)
{
Some
(
info
)
=
>
info
None
=
>
{
return
ClipMaskKind
:
:
Clipped
;
}
}
;
let
clip_task
=
RenderTask
:
:
new_mask
(
device_rect
.
to_i32
(
)
clip_chain
.
clips_range
root_spatial_node_index
frame_state
.
clip_store
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_state
.
render_tasks
clip_data_store
)
;
let
clip_task_id
=
frame_state
.
render_tasks
.
add
(
clip_task
)
;
frame_state
.
surfaces
[
surface_index
.
0
]
.
tasks
.
push
(
clip_task_id
)
;
ClipMaskKind
:
:
Mask
(
clip_task_id
)
}
None
=
>
{
ClipMaskKind
:
:
Clipped
}
}
}
}
#
[
derive
(
Debug
Copy
Clone
Eq
Hash
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ImageCacheKey
{
pub
request
:
ImageRequest
pub
texel_rect
:
Option
<
DeviceIntRect
>
}
#
[
derive
(
Clone
Debug
Hash
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
LineDecorationCacheKey
{
pub
style
:
LineStyle
pub
orientation
:
LineOrientation
pub
wavy_line_thickness
:
Au
pub
size
:
LayoutSizeAu
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
)
]
pub
enum
ImageSource
{
Default
Cache
{
size
:
DeviceIntSize
handle
:
Option
<
RenderTaskCacheEntryHandle
>
}
}
pub
const
GRADIENT_DATA_FIRST_STOP
:
usize
=
0
;
pub
const
GRADIENT_DATA_LAST_STOP
:
usize
=
GRADIENT_DATA_SIZE
-
1
;
pub
const
GRADIENT_DATA_TABLE_BEGIN
:
usize
=
GRADIENT_DATA_FIRST_STOP
+
1
;
pub
const
GRADIENT_DATA_TABLE_END
:
usize
=
GRADIENT_DATA_LAST_STOP
;
pub
const
GRADIENT_DATA_TABLE_SIZE
:
usize
=
128
;
pub
const
GRADIENT_DATA_SIZE
:
usize
=
GRADIENT_DATA_TABLE_SIZE
+
2
;
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
pub
struct
GradientDataEntry
{
pub
start_color
:
PremultipliedColorF
pub
end_color
:
PremultipliedColorF
}
struct
GradientGpuBlockBuilder
{
}
impl
GradientGpuBlockBuilder
{
fn
fill_colors
(
start_idx
:
usize
end_idx
:
usize
start_color
:
&
PremultipliedColorF
end_color
:
&
PremultipliedColorF
entries
:
&
mut
[
GradientDataEntry
;
GRADIENT_DATA_SIZE
]
)
{
let
inv_steps
=
1
.
0
/
(
end_idx
-
start_idx
)
as
f32
;
let
step_r
=
(
end_color
.
r
-
start_color
.
r
)
*
inv_steps
;
let
step_g
=
(
end_color
.
g
-
start_color
.
g
)
*
inv_steps
;
let
step_b
=
(
end_color
.
b
-
start_color
.
b
)
*
inv_steps
;
let
step_a
=
(
end_color
.
a
-
start_color
.
a
)
*
inv_steps
;
let
mut
cur_color
=
*
start_color
;
for
index
in
start_idx
.
.
end_idx
{
let
entry
=
&
mut
entries
[
index
]
;
entry
.
start_color
=
cur_color
;
cur_color
.
r
+
=
step_r
;
cur_color
.
g
+
=
step_g
;
cur_color
.
b
+
=
step_b
;
cur_color
.
a
+
=
step_a
;
entry
.
end_color
=
cur_color
;
}
}
#
[
inline
]
fn
get_index
(
offset
:
f32
)
-
>
usize
{
(
offset
.
max
(
0
.
0
)
.
min
(
1
.
0
)
*
GRADIENT_DATA_TABLE_SIZE
as
f32
+
GRADIENT_DATA_TABLE_BEGIN
as
f32
)
.
round
(
)
as
usize
}
fn
build
(
reverse_stops
:
bool
request
:
&
mut
GpuDataRequest
src_stops
:
&
[
GradientStop
]
)
{
let
mut
src_stops
=
src_stops
.
into_iter
(
)
;
let
mut
cur_color
=
match
src_stops
.
next
(
)
{
Some
(
stop
)
=
>
{
debug_assert_eq
!
(
stop
.
offset
0
.
0
)
;
stop
.
color
.
premultiplied
(
)
}
None
=
>
{
error
!
(
"
Zero
gradient
stops
found
!
"
)
;
PremultipliedColorF
:
:
BLACK
}
}
;
let
mut
entries
:
[
GradientDataEntry
;
GRADIENT_DATA_SIZE
]
=
unsafe
{
mem
:
:
uninitialized
(
)
}
;
if
reverse_stops
{
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_LAST_STOP
GRADIENT_DATA_LAST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
)
;
let
mut
cur_idx
=
GRADIENT_DATA_TABLE_END
;
for
next
in
src_stops
{
let
next_color
=
next
.
color
.
premultiplied
(
)
;
let
next_idx
=
Self
:
:
get_index
(
1
.
0
-
next
.
offset
)
;
if
next_idx
<
cur_idx
{
GradientGpuBlockBuilder
:
:
fill_colors
(
next_idx
cur_idx
&
next_color
&
cur_color
&
mut
entries
)
;
cur_idx
=
next_idx
;
}
cur_color
=
next_color
;
}
if
cur_idx
!
=
GRADIENT_DATA_TABLE_BEGIN
{
error
!
(
"
Gradient
stops
abruptly
at
{
}
auto
-
completing
to
white
"
cur_idx
)
;
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_TABLE_BEGIN
cur_idx
&
PremultipliedColorF
:
:
WHITE
&
cur_color
&
mut
entries
)
;
}
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_FIRST_STOP
GRADIENT_DATA_FIRST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
)
;
}
else
{
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_FIRST_STOP
GRADIENT_DATA_FIRST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
)
;
let
mut
cur_idx
=
GRADIENT_DATA_TABLE_BEGIN
;
for
next
in
src_stops
{
let
next_color
=
next
.
color
.
premultiplied
(
)
;
let
next_idx
=
Self
:
:
get_index
(
next
.
offset
)
;
if
next_idx
>
cur_idx
{
GradientGpuBlockBuilder
:
:
fill_colors
(
cur_idx
next_idx
&
cur_color
&
next_color
&
mut
entries
)
;
cur_idx
=
next_idx
;
}
cur_color
=
next_color
;
}
if
cur_idx
!
=
GRADIENT_DATA_TABLE_END
{
error
!
(
"
Gradient
stops
abruptly
at
{
}
auto
-
completing
to
white
"
cur_idx
)
;
GradientGpuBlockBuilder
:
:
fill_colors
(
cur_idx
GRADIENT_DATA_TABLE_END
&
PremultipliedColorF
:
:
WHITE
&
cur_color
&
mut
entries
)
;
}
GradientGpuBlockBuilder
:
:
fill_colors
(
GRADIENT_DATA_LAST_STOP
GRADIENT_DATA_LAST_STOP
+
1
&
cur_color
&
cur_color
&
mut
entries
)
;
}
for
entry
in
entries
.
iter
(
)
{
request
.
push
(
entry
.
start_color
)
;
request
.
push
(
entry
.
end_color
)
;
}
}
}
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
struct
ClipRect
{
rect
:
LayoutRect
mode
:
f32
}
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
struct
ClipCorner
{
rect
:
LayoutRect
outer_radius_x
:
f32
outer_radius_y
:
f32
inner_radius_x
:
f32
inner_radius_y
:
f32
}
impl
ToGpuBlocks
for
ClipCorner
{
fn
write_gpu_blocks
(
&
self
mut
request
:
GpuDataRequest
)
{
self
.
write
(
&
mut
request
)
}
}
impl
ClipCorner
{
fn
write
(
&
self
request
:
&
mut
GpuDataRequest
)
{
request
.
push
(
self
.
rect
)
;
request
.
push
(
[
self
.
outer_radius_x
self
.
outer_radius_y
self
.
inner_radius_x
self
.
inner_radius_y
]
)
;
}
fn
uniform
(
rect
:
LayoutRect
outer_radius
:
f32
inner_radius
:
f32
)
-
>
ClipCorner
{
ClipCorner
{
rect
outer_radius_x
:
outer_radius
outer_radius_y
:
outer_radius
inner_radius_x
:
inner_radius
inner_radius_y
:
inner_radius
}
}
}
#
[
derive
(
Debug
)
]
#
[
repr
(
C
)
]
pub
struct
ImageMaskData
{
pub
local_mask_size
:
LayoutSize
}
impl
ToGpuBlocks
for
ImageMaskData
{
fn
write_gpu_blocks
(
&
self
mut
request
:
GpuDataRequest
)
{
request
.
push
(
[
self
.
local_mask_size
.
width
self
.
local_mask_size
.
height
0
.
0
0
.
0
]
)
;
}
}
#
[
derive
(
Debug
)
]
pub
struct
ClipData
{
rect
:
ClipRect
top_left
:
ClipCorner
top_right
:
ClipCorner
bottom_left
:
ClipCorner
bottom_right
:
ClipCorner
}
impl
ClipData
{
pub
fn
rounded_rect
(
size
:
LayoutSize
radii
:
&
BorderRadius
mode
:
ClipMode
)
-
>
ClipData
{
let
rect
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
zero
(
)
size
)
;
ClipData
{
rect
:
ClipRect
{
rect
mode
:
mode
as
u32
as
f32
}
top_left
:
ClipCorner
{
rect
:
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
LayoutSize
:
:
new
(
radii
.
top_left
.
width
radii
.
top_left
.
height
)
)
outer_radius_x
:
radii
.
top_left
.
width
outer_radius_y
:
radii
.
top_left
.
height
inner_radius_x
:
0
.
0
inner_radius_y
:
0
.
0
}
top_right
:
ClipCorner
{
rect
:
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
-
radii
.
top_right
.
width
rect
.
origin
.
y
)
LayoutSize
:
:
new
(
radii
.
top_right
.
width
radii
.
top_right
.
height
)
)
outer_radius_x
:
radii
.
top_right
.
width
outer_radius_y
:
radii
.
top_right
.
height
inner_radius_x
:
0
.
0
inner_radius_y
:
0
.
0
}
bottom_left
:
ClipCorner
{
rect
:
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
-
radii
.
bottom_left
.
height
)
LayoutSize
:
:
new
(
radii
.
bottom_left
.
width
radii
.
bottom_left
.
height
)
)
outer_radius_x
:
radii
.
bottom_left
.
width
outer_radius_y
:
radii
.
bottom_left
.
height
inner_radius_x
:
0
.
0
inner_radius_y
:
0
.
0
}
bottom_right
:
ClipCorner
{
rect
:
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
-
radii
.
bottom_right
.
width
rect
.
origin
.
y
+
rect
.
size
.
height
-
radii
.
bottom_right
.
height
)
LayoutSize
:
:
new
(
radii
.
bottom_right
.
width
radii
.
bottom_right
.
height
)
)
outer_radius_x
:
radii
.
bottom_right
.
width
outer_radius_y
:
radii
.
bottom_right
.
height
inner_radius_x
:
0
.
0
inner_radius_y
:
0
.
0
}
}
}
pub
fn
uniform
(
size
:
LayoutSize
radius
:
f32
mode
:
ClipMode
)
-
>
ClipData
{
let
rect
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
zero
(
)
size
)
;
ClipData
{
rect
:
ClipRect
{
rect
mode
:
mode
as
u32
as
f32
}
top_left
:
ClipCorner
:
:
uniform
(
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
)
LayoutSize
:
:
new
(
radius
radius
)
)
radius
0
.
0
)
top_right
:
ClipCorner
:
:
uniform
(
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
-
radius
rect
.
origin
.
y
)
LayoutSize
:
:
new
(
radius
radius
)
)
radius
0
.
0
)
bottom_left
:
ClipCorner
:
:
uniform
(
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
rect
.
origin
.
y
+
rect
.
size
.
height
-
radius
)
LayoutSize
:
:
new
(
radius
radius
)
)
radius
0
.
0
)
bottom_right
:
ClipCorner
:
:
uniform
(
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
rect
.
origin
.
x
+
rect
.
size
.
width
-
radius
rect
.
origin
.
y
+
rect
.
size
.
height
-
radius
)
LayoutSize
:
:
new
(
radius
radius
)
)
radius
0
.
0
)
}
}
pub
fn
write
(
&
self
request
:
&
mut
GpuDataRequest
)
{
request
.
push
(
self
.
rect
.
rect
)
;
request
.
push
(
[
self
.
rect
.
mode
0
.
0
0
.
0
0
.
0
]
)
;
for
corner
in
&
[
&
self
.
top_left
&
self
.
top_right
&
self
.
bottom_left
&
self
.
bottom_right
]
{
corner
.
write
(
request
)
;
}
}
}
#
[
derive
(
Debug
Clone
PartialEq
Eq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
NinePatchDescriptor
{
pub
width
:
i32
pub
height
:
i32
pub
slice
:
SideOffsets2D
<
i32
>
pub
fill
:
bool
pub
repeat_horizontal
:
RepeatMode
pub
repeat_vertical
:
RepeatMode
pub
outset
:
SideOffsetsKey
pub
widths
:
SideOffsetsKey
}
impl
IsVisible
for
PrimitiveKeyKind
{
fn
is_visible
(
&
self
)
-
>
bool
{
match
*
self
{
PrimitiveKeyKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveKeyKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveKeyKind
:
:
YuvImage
{
.
.
}
|
PrimitiveKeyKind
:
:
Image
{
.
.
}
|
PrimitiveKeyKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveKeyKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveKeyKind
:
:
Clear
|
PrimitiveKeyKind
:
:
Unused
=
>
{
true
}
PrimitiveKeyKind
:
:
Rectangle
{
ref
color
.
.
}
|
PrimitiveKeyKind
:
:
LineDecoration
{
ref
color
.
.
}
=
>
{
color
.
a
>
0
}
}
}
}
impl
CreateShadow
for
PrimitiveKeyKind
{
fn
create_shadow
(
&
self
shadow
:
&
Shadow
)
-
>
PrimitiveKeyKind
{
match
*
self
{
PrimitiveKeyKind
:
:
LineDecoration
{
ref
cache_key
.
.
}
=
>
{
PrimitiveKeyKind
:
:
LineDecoration
{
color
:
shadow
.
color
.
into
(
)
cache_key
:
cache_key
.
clone
(
)
}
}
PrimitiveKeyKind
:
:
Rectangle
{
.
.
}
=
>
{
PrimitiveKeyKind
:
:
Rectangle
{
color
:
shadow
.
color
.
into
(
)
}
}
PrimitiveKeyKind
:
:
NormalBorder
{
ref
border
widths
.
.
}
=
>
{
let
border
=
border
.
with_color
(
shadow
.
color
.
into
(
)
)
;
PrimitiveKeyKind
:
:
NormalBorder
{
border
widths
}
}
PrimitiveKeyKind
:
:
Image
{
alpha_type
image_rendering
tile_spacing
stretch_size
key
sub_rect
.
.
}
=
>
{
PrimitiveKeyKind
:
:
Image
{
tile_spacing
stretch_size
key
sub_rect
image_rendering
alpha_type
color
:
shadow
.
color
.
into
(
)
}
}
PrimitiveKeyKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveKeyKind
:
:
YuvImage
{
.
.
}
|
PrimitiveKeyKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveKeyKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveKeyKind
:
:
Unused
|
PrimitiveKeyKind
:
:
Clear
=
>
{
panic
!
(
"
bug
:
this
prim
is
not
supported
in
shadow
contexts
"
)
;
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
ImageInstance
{
pub
opacity_binding_index
:
OpacityBindingIndex
pub
segment_instance_index
:
SegmentInstanceIndex
pub
visible_tiles
:
Vec
<
VisibleImageTile
>
}
#
[
derive
(
Clone
Copy
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PrimitiveDebugId
(
pub
usize
)
;
#
[
derive
(
Clone
Debug
)
]
pub
enum
PrimitiveInstanceKind
{
Picture
{
data_handle
:
PrimitiveDataHandle
pic_index
:
PictureIndex
}
TextRun
{
data_handle
:
TextRunDataHandle
run_index
:
TextRunIndex
}
LineDecoration
{
data_handle
:
PrimitiveDataHandle
cache_handle
:
Option
<
RenderTaskCacheEntryHandle
>
}
NormalBorder
{
data_handle
:
PrimitiveDataHandle
cache_handles
:
storage
:
:
Range
<
RenderTaskCacheEntryHandle
>
}
ImageBorder
{
data_handle
:
PrimitiveDataHandle
}
Rectangle
{
data_handle
:
PrimitiveDataHandle
opacity_binding_index
:
OpacityBindingIndex
segment_instance_index
:
SegmentInstanceIndex
}
YuvImage
{
data_handle
:
PrimitiveDataHandle
segment_instance_index
:
SegmentInstanceIndex
}
Image
{
data_handle
:
PrimitiveDataHandle
image_instance_index
:
ImageInstanceIndex
}
LinearGradient
{
data_handle
:
PrimitiveDataHandle
visible_tiles_range
:
GradientTileRange
}
RadialGradient
{
data_handle
:
PrimitiveDataHandle
visible_tiles_range
:
GradientTileRange
}
Clear
{
data_handle
:
PrimitiveDataHandle
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
PrimitiveInstance
{
pub
kind
:
PrimitiveInstanceKind
pub
combined_local_clip_rect
:
LayoutRect
#
[
cfg
(
debug_assertions
)
]
pub
id
:
PrimitiveDebugId
#
[
cfg
(
debug_assertions
)
]
pub
prepared_frame_id
:
FrameId
pub
bounding_rect
:
Option
<
PictureRect
>
pub
clip_task_index
:
ClipTaskIndex
pub
clip_chain_id
:
ClipChainId
pub
spatial_node_index
:
SpatialNodeIndex
pub
cluster_range
:
ClusterRange
}
impl
PrimitiveInstance
{
pub
fn
new
(
kind
:
PrimitiveInstanceKind
clip_chain_id
:
ClipChainId
spatial_node_index
:
SpatialNodeIndex
)
-
>
Self
{
PrimitiveInstance
{
kind
combined_local_clip_rect
:
LayoutRect
:
:
zero
(
)
bounding_rect
:
None
#
[
cfg
(
debug_assertions
)
]
prepared_frame_id
:
FrameId
:
:
INVALID
#
[
cfg
(
debug_assertions
)
]
id
:
PrimitiveDebugId
(
NEXT_PRIM_ID
.
fetch_add
(
1
Ordering
:
:
Relaxed
)
)
clip_task_index
:
ClipTaskIndex
:
:
INVALID
clip_chain_id
spatial_node_index
cluster_range
:
ClusterRange
{
start
:
0
end
:
0
}
}
}
#
[
cfg
(
debug_assertions
)
]
pub
fn
is_chased
(
&
self
)
-
>
bool
{
PRIM_CHASE_ID
.
load
(
Ordering
:
:
SeqCst
)
=
=
self
.
id
.
0
}
#
[
cfg
(
not
(
debug_assertions
)
)
]
pub
fn
is_chased
(
&
self
)
-
>
bool
{
false
}
pub
fn
uid
(
&
self
)
-
>
intern
:
:
ItemUid
{
match
&
self
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
Image
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
.
.
}
=
>
{
data_handle
.
uid
(
)
}
PrimitiveInstanceKind
:
:
TextRun
{
data_handle
.
.
}
=
>
{
data_handle
.
uid
(
)
}
}
}
}
#
[
derive
(
Debug
)
]
pub
struct
SegmentedInstance
{
pub
gpu_cache_handle
:
GpuCacheHandle
pub
segments_range
:
SegmentsRange
}
pub
type
GlyphKeyStorage
=
storage
:
:
Storage
<
GlyphKey
>
;
pub
type
TextRunIndex
=
storage
:
:
Index
<
TextRunPrimitive
>
;
pub
type
TextRunStorage
=
storage
:
:
Storage
<
TextRunPrimitive
>
;
pub
type
OpacityBindingIndex
=
storage
:
:
Index
<
OpacityBinding
>
;
pub
type
OpacityBindingStorage
=
storage
:
:
Storage
<
OpacityBinding
>
;
pub
type
BorderHandleStorage
=
storage
:
:
Storage
<
RenderTaskCacheEntryHandle
>
;
pub
type
SegmentStorage
=
storage
:
:
Storage
<
BrushSegment
>
;
pub
type
SegmentsRange
=
storage
:
:
Range
<
BrushSegment
>
;
pub
type
SegmentInstanceStorage
=
storage
:
:
Storage
<
SegmentedInstance
>
;
pub
type
SegmentInstanceIndex
=
storage
:
:
Index
<
SegmentedInstance
>
;
pub
type
ImageInstanceStorage
=
storage
:
:
Storage
<
ImageInstance
>
;
pub
type
ImageInstanceIndex
=
storage
:
:
Index
<
ImageInstance
>
;
pub
type
GradientTileStorage
=
storage
:
:
Storage
<
VisibleGradientTile
>
;
pub
type
GradientTileRange
=
storage
:
:
Range
<
VisibleGradientTile
>
;
pub
struct
PrimitiveScratchBuffer
{
pub
clip_mask_instances
:
Vec
<
ClipMaskKind
>
pub
glyph_keys
:
GlyphKeyStorage
pub
border_cache_handles
:
BorderHandleStorage
pub
segments
:
SegmentStorage
pub
segment_instances
:
SegmentInstanceStorage
pub
gradient_tiles
:
GradientTileStorage
}
impl
PrimitiveScratchBuffer
{
pub
fn
new
(
)
-
>
Self
{
PrimitiveScratchBuffer
{
clip_mask_instances
:
Vec
:
:
new
(
)
glyph_keys
:
GlyphKeyStorage
:
:
new
(
0
)
border_cache_handles
:
BorderHandleStorage
:
:
new
(
0
)
segments
:
SegmentStorage
:
:
new
(
0
)
segment_instances
:
SegmentInstanceStorage
:
:
new
(
0
)
gradient_tiles
:
GradientTileStorage
:
:
new
(
0
)
}
}
pub
fn
recycle
(
&
mut
self
)
{
recycle_vec
(
&
mut
self
.
clip_mask_instances
)
;
self
.
glyph_keys
.
recycle
(
)
;
self
.
border_cache_handles
.
recycle
(
)
;
self
.
segments
.
recycle
(
)
;
self
.
segment_instances
.
recycle
(
)
;
self
.
gradient_tiles
.
recycle
(
)
;
}
pub
fn
begin_frame
(
&
mut
self
)
{
self
.
clip_mask_instances
.
clear
(
)
;
self
.
clip_mask_instances
.
push
(
ClipMaskKind
:
:
None
)
;
self
.
border_cache_handles
.
clear
(
)
;
self
.
gradient_tiles
.
clear
(
)
;
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Debug
)
]
pub
struct
PrimitiveStoreStats
{
picture_count
:
usize
text_run_count
:
usize
opacity_binding_count
:
usize
image_count
:
usize
}
impl
PrimitiveStoreStats
{
pub
fn
empty
(
)
-
>
Self
{
PrimitiveStoreStats
{
picture_count
:
0
text_run_count
:
0
opacity_binding_count
:
0
image_count
:
0
}
}
}
pub
struct
PrimitiveStore
{
pub
pictures
:
Vec
<
PicturePrimitive
>
pub
text_runs
:
TextRunStorage
pub
images
:
ImageInstanceStorage
pub
opacity_bindings
:
OpacityBindingStorage
}
impl
PrimitiveStore
{
pub
fn
new
(
stats
:
&
PrimitiveStoreStats
)
-
>
PrimitiveStore
{
PrimitiveStore
{
pictures
:
Vec
:
:
with_capacity
(
stats
.
picture_count
)
text_runs
:
TextRunStorage
:
:
new
(
stats
.
text_run_count
)
images
:
ImageInstanceStorage
:
:
new
(
stats
.
image_count
)
opacity_bindings
:
OpacityBindingStorage
:
:
new
(
stats
.
opacity_binding_count
)
}
}
pub
fn
get_stats
(
&
self
)
-
>
PrimitiveStoreStats
{
PrimitiveStoreStats
{
picture_count
:
self
.
pictures
.
len
(
)
text_run_count
:
self
.
text_runs
.
len
(
)
image_count
:
self
.
images
.
len
(
)
opacity_binding_count
:
self
.
opacity_bindings
.
len
(
)
}
}
pub
fn
destroy
(
self
retained_tiles
:
&
mut
FastHashMap
<
TileDescriptor
TextureCacheHandle
>
)
{
for
pic
in
self
.
pictures
{
pic
.
destroy
(
retained_tiles
)
;
}
}
pub
fn
prim_count
(
&
self
)
-
>
usize
{
self
.
pictures
.
iter
(
)
.
map
(
|
p
|
p
.
prim_list
.
prim_instances
.
len
(
)
)
.
sum
(
)
}
pub
fn
update_picture
(
&
mut
self
pic_index
:
PictureIndex
state
:
&
mut
PictureUpdateState
frame_context
:
&
FrameBuildingContext
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
resources
:
&
FrameResources
clip_store
:
&
ClipStore
retained_tiles
:
&
mut
FastHashMap
<
TileDescriptor
TextureCacheHandle
>
)
{
if
let
Some
(
children
)
=
self
.
pictures
[
pic_index
.
0
]
.
pre_update
(
state
frame_context
)
{
for
child_pic_index
in
&
children
{
self
.
update_picture
(
*
child_pic_index
state
frame_context
resource_cache
gpu_cache
resources
clip_store
retained_tiles
)
;
}
self
.
pictures
[
pic_index
.
0
]
.
update_prim_dependencies
(
state
frame_context
resource_cache
resources
&
self
.
pictures
clip_store
&
self
.
opacity_bindings
&
self
.
images
)
;
self
.
pictures
[
pic_index
.
0
]
.
post_update
(
children
state
frame_context
resource_cache
gpu_cache
retained_tiles
)
;
}
}
pub
fn
get_opacity_binding
(
&
self
opacity_binding_index
:
OpacityBindingIndex
)
-
>
f32
{
if
opacity_binding_index
=
=
OpacityBindingIndex
:
:
INVALID
{
1
.
0
}
else
{
self
.
opacity_bindings
[
opacity_binding_index
]
.
current
}
}
fn
get_opacity_collapse_prim
(
&
self
pic_index
:
PictureIndex
)
-
>
Option
<
PictureIndex
>
{
let
pic
=
&
self
.
pictures
[
pic_index
.
0
]
;
if
pic
.
prim_list
.
prim_instances
.
len
(
)
!
=
1
{
return
None
;
}
let
prim_instance
=
&
pic
.
prim_list
.
prim_instances
[
0
]
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Rectangle
{
.
.
}
|
PrimitiveInstanceKind
:
:
Image
{
.
.
}
=
>
{
return
Some
(
pic_index
)
;
}
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
=
>
{
}
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
self
.
pictures
[
pic_index
.
0
]
;
if
pic
.
requested_composite_mode
.
is_none
(
)
{
return
self
.
get_opacity_collapse_prim
(
pic_index
)
;
}
}
}
None
}
pub
fn
optimize_picture_if_possible
(
&
mut
self
pic_index
:
PictureIndex
)
{
let
binding
=
match
self
.
pictures
[
pic_index
.
0
]
.
requested_composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
FilterOp
:
:
Opacity
(
binding
_
)
)
)
=
>
{
binding
}
_
=
>
{
return
;
}
}
;
match
self
.
get_opacity_collapse_prim
(
pic_index
)
{
Some
(
pic_index
)
=
>
{
let
pic
=
&
mut
self
.
pictures
[
pic_index
.
0
]
;
let
prim_instance
=
&
mut
pic
.
prim_list
.
prim_instances
[
0
]
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Image
{
image_instance_index
.
.
}
=
>
{
let
image_instance
=
&
mut
self
.
images
[
image_instance_index
]
;
if
image_instance
.
opacity_binding_index
=
=
OpacityBindingIndex
:
:
INVALID
{
image_instance
.
opacity_binding_index
=
self
.
opacity_bindings
.
push
(
OpacityBinding
:
:
new
(
)
)
;
}
let
opacity_binding
=
&
mut
self
.
opacity_bindings
[
image_instance
.
opacity_binding_index
]
;
opacity_binding
.
push
(
binding
)
;
}
PrimitiveInstanceKind
:
:
Rectangle
{
ref
mut
opacity_binding_index
.
.
}
=
>
{
if
*
opacity_binding_index
=
=
OpacityBindingIndex
:
:
INVALID
{
*
opacity_binding_index
=
self
.
opacity_bindings
.
push
(
OpacityBinding
:
:
new
(
)
)
;
}
let
opacity_binding
=
&
mut
self
.
opacity_bindings
[
*
opacity_binding_index
]
;
opacity_binding
.
push
(
binding
)
;
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
None
=
>
{
return
;
}
}
self
.
pictures
[
pic_index
.
0
]
.
requested_composite_mode
=
None
;
}
pub
fn
prepare_prim_for_render
(
&
mut
self
prim_instance
:
&
mut
PrimitiveInstance
prim_context
:
&
PrimitiveContext
pic_context
:
&
PictureContext
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
plane_split_anchor
:
usize
resources
:
&
mut
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
-
>
bool
{
let
pic_info
=
{
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
mut
self
.
pictures
[
pic_index
.
0
]
;
match
pic
.
take_context
(
pic_index
pic_context
.
surface_spatial_node_index
pic_context
.
raster_spatial_node_index
pic_context
.
surface_index
pic_context
.
allow_subpixel_aa
frame_state
frame_context
)
{
Some
(
info
)
=
>
Some
(
info
)
None
=
>
{
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
tculled
for
carrying
an
invisible
composite
filter
"
)
;
}
return
false
;
}
}
}
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
Rectangle
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
.
.
}
|
PrimitiveInstanceKind
:
:
Image
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
=
>
{
None
}
}
}
;
let
(
is_passthrough
clip_node_collector
)
=
match
pic_info
{
Some
(
(
pic_context_for_children
mut
pic_state_for_children
mut
prim_list
)
)
=
>
{
let
is_passthrough
=
pic_context_for_children
.
is_passthrough
;
self
.
prepare_primitives
(
&
mut
prim_list
&
pic_context_for_children
&
mut
pic_state_for_children
frame_context
frame_state
resources
scratch
)
;
if
!
pic_state_for_children
.
is_cacheable
{
pic_state
.
is_cacheable
=
false
;
}
let
clip_node_collector
=
self
.
pictures
[
pic_context_for_children
.
pic_index
.
0
]
.
restore_context
(
prim_list
pic_context_for_children
pic_state_for_children
frame_state
)
;
(
is_passthrough
clip_node_collector
)
}
None
=
>
{
(
false
None
)
}
}
;
let
(
prim_local_rect
prim_local_clip_rect
)
=
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
self
.
pictures
[
pic_index
.
0
]
;
(
pic
.
local_rect
LayoutRect
:
:
max_rect
(
)
)
}
_
=
>
{
let
prim_data
=
&
resources
.
as_common_data
(
&
prim_instance
)
;
(
prim_data
.
prim_rect
prim_data
.
clip_rect
)
}
}
;
let
mut
clipped_world_rect
=
WorldRect
:
:
zero
(
)
;
if
is_passthrough
{
prim_instance
.
bounding_rect
=
Some
(
pic_state
.
map_local_to_pic
.
bounds
)
;
}
else
{
if
prim_local_rect
.
size
.
width
<
=
0
.
0
|
|
prim_local_rect
.
size
.
height
<
=
0
.
0
{
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
tculled
for
zero
local
rectangle
"
)
;
}
return
false
;
}
let
inflation_factor
=
frame_state
.
surfaces
[
pic_context
.
surface_index
.
0
]
.
inflation_factor
;
let
local_rect
=
prim_local_rect
.
inflate
(
inflation_factor
inflation_factor
)
.
intersection
(
&
prim_local_clip_rect
)
;
let
local_rect
=
match
local_rect
{
Some
(
local_rect
)
=
>
local_rect
None
=
>
{
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
tculled
for
being
out
of
the
local
clip
rectangle
:
{
:
?
}
"
prim_local_clip_rect
)
;
}
return
false
;
}
}
;
let
clip_chain
=
frame_state
.
clip_store
.
build_clip_chain_instance
(
prim_instance
.
clip_chain_id
local_rect
prim_local_clip_rect
prim_context
.
spatial_node_index
&
pic_state
.
map_local_to_pic
&
pic_state
.
map_pic_to_world
&
frame_context
.
clip_scroll_tree
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_context
.
device_pixel_scale
&
pic_context
.
dirty_world_rect
&
clip_node_collector
&
mut
resources
.
clip_data_store
)
;
let
clip_chain
=
match
clip_chain
{
Some
(
clip_chain
)
=
>
clip_chain
None
=
>
{
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
tunable
to
build
the
clip
chain
skipping
"
)
;
}
prim_instance
.
bounding_rect
=
None
;
return
false
;
}
}
;
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
teffective
clip
chain
from
{
:
?
}
{
}
"
clip_chain
.
clips_range
if
pic_context
.
apply_local_clip_rect
{
"
(
applied
)
"
}
else
{
"
"
}
)
;
}
prim_instance
.
combined_local_clip_rect
=
if
pic_context
.
apply_local_clip_rect
{
clip_chain
.
local_clip_rect
}
else
{
prim_local_clip_rect
}
;
let
world_rect
=
match
pic_state
.
map_pic_to_world
.
map
(
&
clip_chain
.
pic_clip_rect
)
{
Some
(
world_rect
)
=
>
world_rect
None
=
>
{
return
false
;
}
}
;
clipped_world_rect
=
match
world_rect
.
intersection
(
&
pic_context
.
dirty_world_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
{
return
false
;
}
}
;
prim_instance
.
bounding_rect
=
Some
(
clip_chain
.
pic_clip_rect
)
;
prim_instance
.
update_clip_task
(
prim_local_rect
prim_local_clip_rect
prim_context
clipped_world_rect
pic_context
.
raster_spatial_node_index
&
clip_chain
pic_context
pic_state
frame_context
frame_state
&
clip_node_collector
self
resources
scratch
)
;
if
prim_instance
.
is_chased
(
)
{
println
!
(
"
\
tconsidered
visible
and
ready
with
local
rect
{
:
?
}
"
local_rect
)
;
}
}
#
[
cfg
(
debug_assertions
)
]
{
prim_instance
.
prepared_frame_id
=
frame_state
.
render_tasks
.
frame_id
(
)
;
}
pic_state
.
is_cacheable
&
=
prim_instance
.
is_cacheable
(
&
resources
.
prim_data_store
frame_state
.
resource_cache
)
;
match
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
{
let
pic
=
&
mut
self
.
pictures
[
pic_index
.
0
]
;
if
pic
.
prepare_for_render
(
pic_index
prim_instance
&
prim_local_rect
clipped_world_rect
pic_context
.
surface_index
frame_context
frame_state
)
{
if
let
Some
(
ref
mut
splitter
)
=
pic_state
.
plane_splitter
{
PicturePrimitive
:
:
add_split_plane
(
splitter
frame_state
.
transforms
prim_instance
prim_local_rect
pic_context
.
dirty_world_rect
plane_split_anchor
)
;
}
}
else
{
prim_instance
.
bounding_rect
=
None
;
}
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
pic
.
gpu_location
)
{
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
}
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
|
PrimitiveInstanceKind
:
:
Rectangle
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
.
.
}
|
PrimitiveInstanceKind
:
:
Image
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
=
>
{
self
.
prepare_interned_prim_for_render
(
prim_instance
prim_context
pic_context
frame_context
frame_state
resources
scratch
)
;
}
}
true
}
pub
fn
prepare_primitives
(
&
mut
self
prim_list
:
&
mut
PrimitiveList
pic_context
:
&
PictureContext
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
resources
:
&
mut
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
for
(
plane_split_anchor
prim_instance
)
in
prim_list
.
prim_instances
.
iter_mut
(
)
.
enumerate
(
)
{
prim_instance
.
bounding_rect
=
None
;
if
prim_instance
.
is_chased
(
)
{
#
[
cfg
(
debug_assertions
)
]
println
!
(
"
\
tpreparing
{
:
?
}
in
{
:
?
}
"
prim_instance
.
id
pic_context
.
pipeline_id
)
;
}
let
mut
in_visible_cluster
=
false
;
for
ci
in
prim_instance
.
cluster_range
.
start
.
.
prim_instance
.
cluster_range
.
end
{
let
cluster_index
=
prim_list
.
prim_cluster_map
[
ci
as
usize
]
;
let
cluster
=
&
prim_list
.
clusters
[
cluster_index
.
0
as
usize
]
;
in_visible_cluster
|
=
cluster
.
is_visible
;
if
cluster
.
is_visible
{
break
;
}
}
if
!
in_visible_cluster
{
continue
;
}
let
spatial_node
=
&
frame_context
.
clip_scroll_tree
.
spatial_nodes
[
prim_instance
.
spatial_node_index
.
0
]
;
let
prim_context
=
PrimitiveContext
:
:
new
(
spatial_node
prim_instance
.
spatial_node_index
)
;
pic_state
.
map_local_to_pic
.
set_target_spatial_node
(
prim_instance
.
spatial_node_index
frame_context
.
clip_scroll_tree
)
;
if
self
.
prepare_prim_for_render
(
prim_instance
&
prim_context
pic_context
pic_state
frame_context
frame_state
plane_split_anchor
resources
scratch
)
{
frame_state
.
profile_counters
.
visible_primitives
.
inc
(
)
;
}
}
}
fn
prepare_interned_prim_for_render
(
&
mut
self
prim_instance
:
&
mut
PrimitiveInstance
prim_context
:
&
PrimitiveContext
pic_context
:
&
PictureContext
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
resources
:
&
mut
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
let
is_chased
=
prim_instance
.
is_chased
(
)
;
match
&
mut
prim_instance
.
kind
{
PrimitiveInstanceKind
:
:
LineDecoration
{
data_handle
ref
mut
cache_handle
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
match
&
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
LineDecoration
{
ref
cache_key
.
.
}
=
>
{
if
is_chased
{
println
!
(
"
\
tline
decoration
key
=
{
:
?
}
"
cache_key
)
;
}
if
let
Some
(
cache_key
)
=
cache_key
{
let
scale_factor
=
TypedScale
:
:
new
(
1
.
0
)
*
frame_context
.
device_pixel_scale
;
let
task_size
=
(
LayoutSize
:
:
from_au
(
cache_key
.
size
)
*
scale_factor
)
.
ceil
(
)
.
to_i32
(
)
;
let
surfaces
=
&
mut
frame_state
.
surfaces
;
*
cache_handle
=
Some
(
frame_state
.
resource_cache
.
request_render_task
(
RenderTaskCacheKey
{
size
:
task_size
kind
:
RenderTaskCacheKeyKind
:
:
LineDecoration
(
cache_key
.
clone
(
)
)
}
frame_state
.
gpu_cache
frame_state
.
render_tasks
None
false
|
render_tasks
|
{
let
task
=
RenderTask
:
:
new_line_decoration
(
task_size
cache_key
.
style
cache_key
.
orientation
cache_key
.
wavy_line_thickness
.
to_f32_px
(
)
LayoutSize
:
:
from_au
(
cache_key
.
size
)
)
;
let
task_id
=
render_tasks
.
add
(
task
)
;
surfaces
[
pic_context
.
surface_index
.
0
]
.
tasks
.
push
(
task_id
)
;
task_id
}
)
)
;
}
}
_
=
>
unreachable
!
(
)
}
}
PrimitiveInstanceKind
:
:
TextRun
{
data_handle
run_index
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
text_run_data_store
[
*
data_handle
]
;
prim_data
.
update
(
frame_state
)
;
let
transform
=
prim_context
.
spatial_node
.
world_content_transform
.
to_transform
(
)
;
let
run
=
&
mut
self
.
text_runs
[
*
run_index
]
;
run
.
prepare_for_render
(
&
prim_data
.
font
&
prim_data
.
glyphs
frame_context
.
device_pixel_scale
&
transform
pic_context
frame_state
.
resource_cache
frame_state
.
gpu_cache
frame_state
.
render_tasks
frame_state
.
special_render_passes
scratch
)
;
}
PrimitiveInstanceKind
:
:
Clear
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
}
PrimitiveInstanceKind
:
:
NormalBorder
{
data_handle
ref
mut
cache_handles
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
let
template
=
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
NormalBorder
{
ref
template
.
.
}
=
>
template
_
=
>
unreachable
!
(
)
}
;
let
world_scale
=
LayoutToWorldScale
:
:
new
(
1
.
0
)
;
let
mut
scale
=
world_scale
*
frame_context
.
device_pixel_scale
;
let
max_scale
=
get_max_scale_for_border
(
&
template
.
border
.
radius
&
template
.
widths
)
;
scale
.
0
=
scale
.
0
.
min
(
max_scale
.
0
)
;
let
mut
handles
:
SmallVec
<
[
RenderTaskCacheEntryHandle
;
8
]
>
=
SmallVec
:
:
new
(
)
;
let
surfaces
=
&
mut
frame_state
.
surfaces
;
for
segment
in
&
template
.
border_segments
{
let
cache_size
=
to_cache_size
(
segment
.
local_task_size
*
scale
)
;
let
cache_key
=
RenderTaskCacheKey
{
kind
:
RenderTaskCacheKeyKind
:
:
BorderSegment
(
segment
.
cache_key
.
clone
(
)
)
size
:
cache_size
}
;
handles
.
push
(
frame_state
.
resource_cache
.
request_render_task
(
cache_key
frame_state
.
gpu_cache
frame_state
.
render_tasks
None
false
|
render_tasks
|
{
let
task
=
RenderTask
:
:
new_border_segment
(
cache_size
build_border_instances
(
&
segment
.
cache_key
cache_size
&
template
.
border
scale
)
)
;
let
task_id
=
render_tasks
.
add
(
task
)
;
surfaces
[
pic_context
.
surface_index
.
0
]
.
tasks
.
push
(
task_id
)
;
task_id
}
)
)
;
}
*
cache_handles
=
scratch
.
border_cache_handles
.
extend
(
handles
)
;
}
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
}
PrimitiveInstanceKind
:
:
Rectangle
{
data_handle
segment_instance_index
opacity_binding_index
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
update_opacity_binding
(
&
mut
self
.
opacity_bindings
*
opacity_binding_index
frame_context
.
scene_properties
)
;
write_segment
(
prim_data
*
segment_instance_index
frame_state
scratch
)
;
}
PrimitiveInstanceKind
:
:
YuvImage
{
data_handle
segment_instance_index
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
write_segment
(
prim_data
*
segment_instance_index
frame_state
scratch
)
;
}
PrimitiveInstanceKind
:
:
Image
{
data_handle
image_instance_index
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
let
(
key
stretch_size
tile_spacing
image_rendering
)
=
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
Image
{
ref
key
ref
stretch_size
ref
tile_spacing
ref
image_rendering
.
.
}
=
>
{
(
key
stretch_size
tile_spacing
image_rendering
)
}
_
=
>
unreachable
!
(
)
}
;
let
image_instance
=
&
mut
self
.
images
[
*
image_instance_index
]
;
update_opacity_binding
(
&
mut
self
.
opacity_bindings
image_instance
.
opacity_binding_index
frame_context
.
scene_properties
)
;
image_instance
.
visible_tiles
.
clear
(
)
;
let
image_properties
=
frame_state
.
resource_cache
.
get_image_properties
(
*
key
)
;
if
let
Some
(
image_properties
)
=
image_properties
{
if
let
Some
(
tile_size
)
=
image_properties
.
tiling
{
let
device_image_size
=
image_properties
.
descriptor
.
size
;
let
tight_clip_rect
=
prim_instance
.
combined_local_clip_rect
.
intersection
(
&
prim_data
.
prim_rect
)
.
unwrap
(
)
;
let
visible_rect
=
compute_conservative_visible_rect
(
prim_context
&
pic_context
.
dirty_world_rect
&
tight_clip_rect
)
;
let
base_edge_flags
=
edge_flags_for_tile_spacing
(
tile_spacing
)
;
let
stride
=
*
stretch_size
+
*
tile_spacing
;
let
repetitions
=
image
:
:
repetitions
(
&
prim_data
.
prim_rect
&
visible_rect
stride
)
;
let
request
=
ImageRequest
{
key
:
*
key
rendering
:
*
image_rendering
tile
:
None
}
;
for
Repetition
{
origin
edge_flags
}
in
repetitions
{
let
edge_flags
=
base_edge_flags
|
edge_flags
;
let
image_rect
=
LayoutRect
{
origin
size
:
*
stretch_size
}
;
let
tiles
=
image
:
:
tiles
(
&
image_rect
&
visible_rect
&
device_image_size
tile_size
as
i32
)
;
for
tile
in
tiles
{
frame_state
.
resource_cache
.
request_image
(
request
.
with_tile
(
tile
.
offset
)
frame_state
.
gpu_cache
)
;
let
mut
handle
=
GpuCacheHandle
:
:
new
(
)
;
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
handle
)
{
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
tile
.
rect
.
size
.
width
tile
.
rect
.
size
.
height
0
.
0
0
.
0
]
)
;
}
image_instance
.
visible_tiles
.
push
(
VisibleImageTile
{
tile_offset
:
tile
.
offset
handle
edge_flags
:
tile
.
edge_flags
&
edge_flags
local_rect
:
tile
.
rect
local_clip_rect
:
tight_clip_rect
}
)
;
}
}
if
image_instance
.
visible_tiles
.
is_empty
(
)
{
prim_instance
.
bounding_rect
=
None
;
}
}
}
write_segment
(
prim_data
image_instance
.
segment_instance_index
frame_state
scratch
)
;
}
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
ref
mut
visible_tiles_range
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
let
(
extend_mode
stretch_size
start_point
end_point
tile_spacing
)
=
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
LinearGradient
{
ref
extend_mode
ref
stretch_size
ref
start_point
ref
end_point
ref
tile_spacing
.
.
}
=
>
{
(
extend_mode
stretch_size
start_point
end_point
tile_spacing
)
}
_
=
>
unreachable
!
(
)
}
;
if
*
tile_spacing
!
=
LayoutSize
:
:
zero
(
)
{
*
visible_tiles_range
=
decompose_repeated_primitive
(
&
prim_instance
.
combined_local_clip_rect
&
prim_data
.
prim_rect
&
stretch_size
&
tile_spacing
prim_context
frame_state
&
pic_context
.
dirty_world_rect
&
mut
scratch
.
gradient_tiles
&
mut
|
_
mut
request
|
{
request
.
push
(
[
start_point
.
x
start_point
.
y
end_point
.
x
end_point
.
y
]
)
;
request
.
push
(
[
pack_as_float
(
*
extend_mode
as
u32
)
stretch_size
.
width
stretch_size
.
height
0
.
0
]
)
;
}
)
;
if
visible_tiles_range
.
is_empty
(
)
{
prim_instance
.
bounding_rect
=
None
;
}
}
}
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
ref
mut
visible_tiles_range
.
.
}
=
>
{
let
prim_data
=
&
mut
resources
.
prim_data_store
[
*
data_handle
]
;
prim_data
.
update
(
pic_context
.
surface_index
frame_state
)
;
let
(
params
extend_mode
stretch_size
tile_spacing
center
)
=
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
RadialGradient
{
ref
params
ref
extend_mode
stretch_size
ref
tile_spacing
center
.
.
}
=
>
{
(
params
extend_mode
stretch_size
tile_spacing
center
)
}
_
=
>
unreachable
!
(
)
}
;
if
*
tile_spacing
!
=
LayoutSize
:
:
zero
(
)
{
*
visible_tiles_range
=
decompose_repeated_primitive
(
&
prim_instance
.
combined_local_clip_rect
&
prim_data
.
prim_rect
&
stretch_size
&
tile_spacing
prim_context
frame_state
&
pic_context
.
dirty_world_rect
&
mut
scratch
.
gradient_tiles
&
mut
|
_
mut
request
|
{
request
.
push
(
[
center
.
x
center
.
y
params
.
start_radius
params
.
end_radius
]
)
;
request
.
push
(
[
params
.
ratio_xy
pack_as_float
(
*
extend_mode
as
u32
)
stretch_size
.
width
stretch_size
.
height
]
)
;
}
)
;
if
visible_tiles_range
.
is_empty
(
)
{
prim_instance
.
bounding_rect
=
None
;
}
}
}
_
=
>
{
unreachable
!
(
)
;
}
}
;
}
}
fn
write_segment
(
prim_data
:
&
PrimitiveTemplate
segment_instance_index
:
SegmentInstanceIndex
frame_state
:
&
mut
FrameBuildingState
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
debug_assert
!
(
segment_instance_index
!
=
SegmentInstanceIndex
:
:
INVALID
)
;
if
segment_instance_index
!
=
SegmentInstanceIndex
:
:
UNUSED
{
let
segment_instance
=
&
mut
scratch
.
segment_instances
[
segment_instance_index
]
;
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
segment_instance
.
gpu_cache_handle
)
{
let
segments
=
&
scratch
.
segments
[
segment_instance
.
segments_range
]
;
prim_data
.
kind
.
write_prim_gpu_blocks
(
&
mut
request
prim_data
.
prim_rect
.
size
)
;
for
segment
in
segments
{
request
.
write_segment
(
segment
.
local_rect
[
0
.
0
;
4
]
)
;
}
}
}
}
fn
decompose_repeated_primitive
(
combined_local_clip_rect
:
&
LayoutRect
prim_local_rect
:
&
LayoutRect
stretch_size
:
&
LayoutSize
tile_spacing
:
&
LayoutSize
prim_context
:
&
PrimitiveContext
frame_state
:
&
mut
FrameBuildingState
world_rect
:
&
WorldRect
gradient_tiles
:
&
mut
GradientTileStorage
callback
:
&
mut
FnMut
(
&
LayoutRect
GpuDataRequest
)
)
-
>
GradientTileRange
{
let
mut
visible_tiles
=
Vec
:
:
new
(
)
;
let
tight_clip_rect
=
combined_local_clip_rect
.
intersection
(
prim_local_rect
)
.
unwrap
(
)
;
let
visible_rect
=
compute_conservative_visible_rect
(
prim_context
world_rect
&
tight_clip_rect
)
;
let
stride
=
*
stretch_size
+
*
tile_spacing
;
let
repetitions
=
image
:
:
repetitions
(
prim_local_rect
&
visible_rect
stride
)
;
for
Repetition
{
origin
.
.
}
in
repetitions
{
let
mut
handle
=
GpuCacheHandle
:
:
new
(
)
;
let
rect
=
LayoutRect
{
origin
:
origin
size
:
*
stretch_size
}
;
if
let
Some
(
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
handle
)
{
callback
(
&
rect
request
)
;
}
visible_tiles
.
push
(
VisibleGradientTile
{
local_rect
:
rect
local_clip_rect
:
tight_clip_rect
handle
}
)
;
}
if
visible_tiles
.
is_empty
(
)
{
GradientTileRange
:
:
empty
(
)
}
else
{
gradient_tiles
.
extend
(
visible_tiles
)
}
}
fn
compute_conservative_visible_rect
(
prim_context
:
&
PrimitiveContext
world_rect
:
&
WorldRect
local_clip_rect
:
&
LayoutRect
)
-
>
LayoutRect
{
if
let
Some
(
layer_screen_rect
)
=
prim_context
.
spatial_node
.
world_content_transform
.
unapply
(
world_rect
)
{
return
local_clip_rect
.
intersection
(
&
layer_screen_rect
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
;
}
*
local_clip_rect
}
fn
edge_flags_for_tile_spacing
(
tile_spacing
:
&
LayoutSize
)
-
>
EdgeAaSegmentMask
{
let
mut
flags
=
EdgeAaSegmentMask
:
:
empty
(
)
;
if
tile_spacing
.
width
>
0
.
0
{
flags
|
=
EdgeAaSegmentMask
:
:
LEFT
|
EdgeAaSegmentMask
:
:
RIGHT
;
}
if
tile_spacing
.
height
>
0
.
0
{
flags
|
=
EdgeAaSegmentMask
:
:
TOP
|
EdgeAaSegmentMask
:
:
BOTTOM
;
}
flags
}
impl
<
'
a
>
GpuDataRequest
<
'
a
>
{
fn
write_segment
(
&
mut
self
local_rect
:
LayoutRect
extra_data
:
[
f32
;
4
]
)
{
let
_
=
VECS_PER_SEGMENT
;
self
.
push
(
local_rect
)
;
self
.
push
(
extra_data
)
;
}
}
fn
write_brush_segment_description
(
prim_local_rect
:
LayoutRect
prim_local_clip_rect
:
LayoutRect
clip_chain
:
&
ClipChainInstance
segment_builder
:
&
mut
SegmentBuilder
clip_store
:
&
ClipStore
resources
:
&
FrameResources
)
-
>
bool
{
let
is_large
=
prim_local_rect
.
size
.
area
(
)
>
MIN_BRUSH_SPLIT_AREA
;
let
mut
rect_clips_only
=
true
;
segment_builder
.
initialize
(
prim_local_rect
None
prim_local_clip_rect
)
;
let
mut
local_clip_count
=
0
;
for
i
in
0
.
.
clip_chain
.
clips_range
.
count
{
let
clip_instance
=
clip_store
.
get_instance_from_range
(
&
clip_chain
.
clips_range
i
)
;
let
clip_node
=
&
resources
.
clip_data_store
[
clip_instance
.
handle
]
;
if
!
clip_instance
.
flags
.
contains
(
ClipNodeFlags
:
:
SAME_SPATIAL_NODE
)
{
continue
;
}
local_clip_count
+
=
1
;
let
(
local_clip_rect
radius
mode
)
=
match
clip_node
.
item
{
ClipItem
:
:
RoundedRectangle
(
size
radii
clip_mode
)
=
>
{
rect_clips_only
=
false
;
(
LayoutRect
:
:
new
(
clip_instance
.
local_pos
size
)
Some
(
radii
)
clip_mode
)
}
ClipItem
:
:
Rectangle
(
size
mode
)
=
>
{
(
LayoutRect
:
:
new
(
clip_instance
.
local_pos
size
)
None
mode
)
}
ClipItem
:
:
BoxShadow
(
ref
info
)
=
>
{
rect_clips_only
=
false
;
let
inner_clip_mode
=
match
info
.
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
None
BoxShadowClipMode
:
:
Inset
=
>
Some
(
ClipMode
:
:
ClipOut
)
}
;
let
prim_shadow_rect
=
info
.
prim_shadow_rect
.
translate
(
&
LayoutVector2D
:
:
new
(
clip_instance
.
local_pos
.
x
clip_instance
.
local_pos
.
y
)
)
;
segment_builder
.
push_mask_region
(
prim_shadow_rect
prim_shadow_rect
.
inflate
(
-
0
.
5
*
info
.
original_alloc_size
.
width
-
0
.
5
*
info
.
original_alloc_size
.
height
)
inner_clip_mode
)
;
continue
;
}
ClipItem
:
:
Image
{
.
.
}
=
>
{
rect_clips_only
=
false
;
continue
;
}
}
;
segment_builder
.
push_clip_rect
(
local_clip_rect
radius
mode
)
;
}
if
is_large
|
|
rect_clips_only
{
if
local_clip_count
=
=
0
&
&
clip_chain
.
clips_range
.
count
>
0
{
let
x_clip_count
=
cmp
:
:
min
(
8
(
prim_local_rect
.
size
.
width
/
128
.
0
)
.
ceil
(
)
as
i32
)
;
let
y_clip_count
=
cmp
:
:
min
(
8
(
prim_local_rect
.
size
.
height
/
128
.
0
)
.
ceil
(
)
as
i32
)
;
for
y
in
0
.
.
y_clip_count
{
let
y0
=
prim_local_rect
.
size
.
height
*
y
as
f32
/
y_clip_count
as
f32
;
let
y1
=
prim_local_rect
.
size
.
height
*
(
y
+
1
)
as
f32
/
y_clip_count
as
f32
;
for
x
in
0
.
.
x_clip_count
{
let
x0
=
prim_local_rect
.
size
.
width
*
x
as
f32
/
x_clip_count
as
f32
;
let
x1
=
prim_local_rect
.
size
.
width
*
(
x
+
1
)
as
f32
/
x_clip_count
as
f32
;
let
rect
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
x0
+
prim_local_rect
.
origin
.
x
y0
+
prim_local_rect
.
origin
.
y
)
LayoutSize
:
:
new
(
x1
-
x0
y1
-
y0
)
)
;
segment_builder
.
push_mask_region
(
rect
LayoutRect
:
:
zero
(
)
None
)
;
}
}
}
return
true
}
false
}
impl
PrimitiveInstance
{
fn
build_segments_if_needed
(
&
mut
self
prim_local_rect
:
LayoutRect
prim_local_clip_rect
:
LayoutRect
prim_clip_chain
:
&
ClipChainInstance
frame_state
:
&
mut
FrameBuildingState
prim_store
:
&
mut
PrimitiveStore
resources
:
&
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
let
segment_instance_index
=
match
self
.
kind
{
PrimitiveInstanceKind
:
:
Rectangle
{
ref
mut
segment_instance_index
.
.
}
|
PrimitiveInstanceKind
:
:
YuvImage
{
ref
mut
segment_instance_index
.
.
}
=
>
{
segment_instance_index
}
PrimitiveInstanceKind
:
:
Image
{
data_handle
image_instance_index
.
.
}
=
>
{
let
prim_data
=
&
resources
.
prim_data_store
[
data_handle
]
;
let
image_instance
=
&
mut
prim_store
.
images
[
image_instance_index
]
;
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
Image
{
key
.
.
}
=
>
{
if
frame_state
.
resource_cache
.
get_image_properties
(
key
)
.
and_then
(
|
properties
|
properties
.
tiling
)
.
is_some
(
)
{
image_instance
.
segment_instance_index
=
SegmentInstanceIndex
:
:
UNUSED
;
return
;
}
}
_
=
>
unreachable
!
(
)
}
&
mut
image_instance
.
segment_instance_index
}
PrimitiveInstanceKind
:
:
Picture
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
NormalBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
ImageBorder
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
|
PrimitiveInstanceKind
:
:
LinearGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
RadialGradient
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
=
>
{
return
;
}
}
;
if
*
segment_instance_index
=
=
SegmentInstanceIndex
:
:
INVALID
{
let
mut
segments
:
SmallVec
<
[
BrushSegment
;
8
]
>
=
SmallVec
:
:
new
(
)
;
if
write_brush_segment_description
(
prim_local_rect
prim_local_clip_rect
prim_clip_chain
&
mut
frame_state
.
segment_builder
frame_state
.
clip_store
resources
)
{
frame_state
.
segment_builder
.
build
(
|
segment
|
{
segments
.
push
(
BrushSegment
:
:
new
(
segment
.
rect
.
translate
(
&
LayoutVector2D
:
:
new
(
-
prim_local_rect
.
origin
.
x
-
prim_local_rect
.
origin
.
y
)
)
segment
.
has_mask
segment
.
edge_flags
[
0
.
0
;
4
]
BrushFlags
:
:
empty
(
)
)
)
;
}
)
;
}
if
segments
.
is_empty
(
)
{
*
segment_instance_index
=
SegmentInstanceIndex
:
:
UNUSED
;
}
else
{
let
segments_range
=
scratch
.
segments
.
extend
(
segments
)
;
let
instance
=
SegmentedInstance
{
segments_range
gpu_cache_handle
:
GpuCacheHandle
:
:
new
(
)
}
;
*
segment_instance_index
=
scratch
.
segment_instances
.
push
(
instance
)
;
}
;
}
}
fn
update_clip_task_for_brush
(
&
mut
self
prim_origin
:
LayoutPoint
prim_local_clip_rect
:
LayoutRect
root_spatial_node_index
:
SpatialNodeIndex
prim_bounding_rect
:
WorldRect
prim_context
:
&
PrimitiveContext
prim_clip_chain
:
&
ClipChainInstance
pic_context
:
&
PictureContext
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
clip_node_collector
:
&
Option
<
ClipNodeCollector
>
prim_store
:
&
PrimitiveStore
resources
:
&
mut
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
-
>
bool
{
let
segments
=
match
self
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
.
.
}
|
PrimitiveInstanceKind
:
:
TextRun
{
.
.
}
|
PrimitiveInstanceKind
:
:
Clear
{
.
.
}
|
PrimitiveInstanceKind
:
:
LineDecoration
{
.
.
}
=
>
{
return
false
;
}
PrimitiveInstanceKind
:
:
Image
{
image_instance_index
.
.
}
=
>
{
let
segment_instance_index
=
prim_store
.
images
[
image_instance_index
]
.
segment_instance_index
;
if
segment_instance_index
=
=
SegmentInstanceIndex
:
:
UNUSED
{
return
false
;
}
let
segment_instance
=
&
scratch
.
segment_instances
[
segment_instance_index
]
;
&
scratch
.
segments
[
segment_instance
.
segments_range
]
}
PrimitiveInstanceKind
:
:
YuvImage
{
segment_instance_index
.
.
}
|
PrimitiveInstanceKind
:
:
Rectangle
{
segment_instance_index
.
.
}
=
>
{
debug_assert
!
(
segment_instance_index
!
=
SegmentInstanceIndex
:
:
INVALID
)
;
if
segment_instance_index
=
=
SegmentInstanceIndex
:
:
UNUSED
{
return
false
;
}
let
segment_instance
=
&
scratch
.
segment_instances
[
segment_instance_index
]
;
&
scratch
.
segments
[
segment_instance
.
segments_range
]
}
PrimitiveInstanceKind
:
:
ImageBorder
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
resources
.
prim_data_store
[
data_handle
]
;
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
ImageBorder
{
ref
brush_segments
.
.
}
=
>
{
brush_segments
.
as_slice
(
)
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
PrimitiveInstanceKind
:
:
NormalBorder
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
resources
.
prim_data_store
[
data_handle
]
;
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
NormalBorder
{
ref
template
.
.
}
=
>
{
template
.
brush_segments
.
as_slice
(
)
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
PrimitiveInstanceKind
:
:
LinearGradient
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
resources
.
prim_data_store
[
data_handle
]
;
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
LinearGradient
{
ref
brush_segments
.
.
}
=
>
{
if
brush_segments
.
is_empty
(
)
{
return
false
;
}
brush_segments
.
as_slice
(
)
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
PrimitiveInstanceKind
:
:
RadialGradient
{
data_handle
.
.
}
=
>
{
let
prim_data
=
&
resources
.
prim_data_store
[
data_handle
]
;
match
prim_data
.
kind
{
PrimitiveTemplateKind
:
:
RadialGradient
{
ref
brush_segments
.
.
}
=
>
{
if
brush_segments
.
is_empty
(
)
{
return
false
;
}
brush_segments
.
as_slice
(
)
}
_
=
>
{
unreachable
!
(
)
;
}
}
}
}
;
if
segments
.
is_empty
(
)
{
return
true
;
}
self
.
clip_task_index
=
ClipTaskIndex
(
scratch
.
clip_mask_instances
.
len
(
)
as
_
)
;
if
segments
.
len
(
)
=
=
1
{
let
clip_mask_kind
=
segments
[
0
]
.
update_clip_task
(
Some
(
prim_clip_chain
)
prim_bounding_rect
root_spatial_node_index
pic_context
.
surface_index
pic_state
frame_context
frame_state
&
mut
resources
.
clip_data_store
)
;
scratch
.
clip_mask_instances
.
push
(
clip_mask_kind
)
;
}
else
{
for
segment
in
segments
{
let
segment_clip_chain
=
frame_state
.
clip_store
.
build_clip_chain_instance
(
self
.
clip_chain_id
segment
.
local_rect
.
translate
(
&
LayoutVector2D
:
:
new
(
prim_origin
.
x
prim_origin
.
y
)
)
prim_local_clip_rect
prim_context
.
spatial_node_index
&
pic_state
.
map_local_to_pic
&
pic_state
.
map_pic_to_world
&
frame_context
.
clip_scroll_tree
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_context
.
device_pixel_scale
&
pic_context
.
dirty_world_rect
clip_node_collector
&
mut
resources
.
clip_data_store
)
;
let
clip_mask_kind
=
segment
.
update_clip_task
(
segment_clip_chain
.
as_ref
(
)
prim_bounding_rect
root_spatial_node_index
pic_context
.
surface_index
pic_state
frame_context
frame_state
&
mut
resources
.
clip_data_store
)
;
scratch
.
clip_mask_instances
.
push
(
clip_mask_kind
)
;
}
}
true
}
fn
update_clip_task
(
&
mut
self
prim_local_rect
:
LayoutRect
prim_local_clip_rect
:
LayoutRect
prim_context
:
&
PrimitiveContext
prim_bounding_rect
:
WorldRect
root_spatial_node_index
:
SpatialNodeIndex
clip_chain
:
&
ClipChainInstance
pic_context
:
&
PictureContext
pic_state
:
&
mut
PictureState
frame_context
:
&
FrameBuildingContext
frame_state
:
&
mut
FrameBuildingState
clip_node_collector
:
&
Option
<
ClipNodeCollector
>
prim_store
:
&
mut
PrimitiveStore
resources
:
&
mut
FrameResources
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
if
self
.
is_chased
(
)
{
println
!
(
"
\
tupdating
clip
task
with
pic
rect
{
:
?
}
"
clip_chain
.
pic_clip_rect
)
;
}
self
.
clip_task_index
=
ClipTaskIndex
:
:
INVALID
;
self
.
build_segments_if_needed
(
prim_local_rect
prim_local_clip_rect
clip_chain
frame_state
prim_store
resources
scratch
)
;
if
self
.
update_clip_task_for_brush
(
prim_local_rect
.
origin
prim_local_clip_rect
root_spatial_node_index
prim_bounding_rect
prim_context
&
clip_chain
pic_context
pic_state
frame_context
frame_state
clip_node_collector
prim_store
resources
scratch
)
{
if
self
.
is_chased
(
)
{
println
!
(
"
\
tsegment
tasks
have
been
created
for
clipping
"
)
;
}
return
;
}
if
clip_chain
.
needs_mask
{
if
let
Some
(
(
device_rect
_
)
)
=
get_raster_rects
(
clip_chain
.
pic_clip_rect
&
pic_state
.
map_pic_to_raster
&
pic_state
.
map_raster_to_world
prim_bounding_rect
frame_context
.
device_pixel_scale
)
{
let
clip_task
=
RenderTask
:
:
new_mask
(
device_rect
clip_chain
.
clips_range
root_spatial_node_index
frame_state
.
clip_store
frame_state
.
gpu_cache
frame_state
.
resource_cache
frame_state
.
render_tasks
&
mut
resources
.
clip_data_store
)
;
let
clip_task_id
=
frame_state
.
render_tasks
.
add
(
clip_task
)
;
if
self
.
is_chased
(
)
{
println
!
(
"
\
tcreated
task
{
:
?
}
with
device
rect
{
:
?
}
"
clip_task_id
device_rect
)
;
}
let
clip_task_index
=
ClipTaskIndex
(
scratch
.
clip_mask_instances
.
len
(
)
as
_
)
;
scratch
.
clip_mask_instances
.
push
(
ClipMaskKind
:
:
Mask
(
clip_task_id
)
)
;
self
.
clip_task_index
=
clip_task_index
;
frame_state
.
surfaces
[
pic_context
.
surface_index
.
0
]
.
tasks
.
push
(
clip_task_id
)
;
}
}
}
}
pub
fn
get_raster_rects
(
pic_rect
:
PictureRect
map_to_raster
:
&
SpaceMapper
<
PicturePixel
RasterPixel
>
map_to_world
:
&
SpaceMapper
<
RasterPixel
WorldPixel
>
prim_bounding_rect
:
WorldRect
device_pixel_scale
:
DevicePixelScale
)
-
>
Option
<
(
DeviceIntRect
DeviceRect
)
>
{
let
unclipped_raster_rect
=
map_to_raster
.
map
(
&
pic_rect
)
?
;
let
unclipped
=
raster_rect_to_device_pixels
(
unclipped_raster_rect
device_pixel_scale
)
;
let
unclipped_world_rect
=
map_to_world
.
map
(
&
unclipped_raster_rect
)
?
;
let
clipped_world_rect
=
unclipped_world_rect
.
intersection
(
&
prim_bounding_rect
)
?
;
let
clipped_raster_rect
=
map_to_world
.
unmap
(
&
clipped_world_rect
)
?
;
let
clipped_raster_rect
=
clipped_raster_rect
.
intersection
(
&
unclipped_raster_rect
)
?
;
let
clipped
=
raster_rect_to_device_pixels
(
clipped_raster_rect
device_pixel_scale
)
;
Some
(
(
clipped
.
to_i32
(
)
unclipped
)
)
}
pub
fn
get_line_decoration_sizes
(
rect_size
:
&
LayoutSize
orientation
:
LineOrientation
style
:
LineStyle
wavy_line_thickness
:
f32
)
-
>
Option
<
(
f32
f32
)
>
{
let
h
=
match
orientation
{
LineOrientation
:
:
Horizontal
=
>
rect_size
.
height
LineOrientation
:
:
Vertical
=
>
rect_size
.
width
}
;
match
style
{
LineStyle
:
:
Solid
=
>
{
None
}
LineStyle
:
:
Dashed
=
>
{
let
dash_length
=
(
3
.
0
*
h
)
.
min
(
64
.
0
)
.
max
(
1
.
0
)
;
Some
(
(
2
.
0
*
dash_length
4
.
0
)
)
}
LineStyle
:
:
Dotted
=
>
{
let
diameter
=
h
.
min
(
64
.
0
)
.
max
(
1
.
0
)
;
let
period
=
2
.
0
*
diameter
;
Some
(
(
period
diameter
)
)
}
LineStyle
:
:
Wavy
=
>
{
let
line_thickness
=
wavy_line_thickness
.
max
(
1
.
0
)
;
let
slope_length
=
h
-
line_thickness
;
let
flat_length
=
(
(
line_thickness
-
1
.
0
)
*
2
.
0
)
.
max
(
1
.
0
)
;
let
approx_period
=
2
.
0
*
(
slope_length
+
flat_length
)
;
Some
(
(
approx_period
h
)
)
}
}
}
fn
update_opacity_binding
(
opacity_bindings
:
&
mut
OpacityBindingStorage
opacity_binding_index
:
OpacityBindingIndex
scene_properties
:
&
SceneProperties
)
-
>
f32
{
if
opacity_binding_index
=
=
OpacityBindingIndex
:
:
INVALID
{
1
.
0
}
else
{
let
binding
=
&
mut
opacity_bindings
[
opacity_binding_index
]
;
binding
.
update
(
scene_properties
)
;
binding
.
current
}
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
test_struct_sizes
(
)
{
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveInstance
>
(
)
120
"
PrimitiveInstance
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveInstanceKind
>
(
)
40
"
PrimitiveInstanceKind
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveTemplate
>
(
)
176
"
PrimitiveTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveTemplateKind
>
(
)
112
"
PrimitiveTemplateKind
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveKey
>
(
)
136
"
PrimitiveKey
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
PrimitiveKeyKind
>
(
)
96
"
PrimitiveKeyKind
size
changed
"
)
;
}
