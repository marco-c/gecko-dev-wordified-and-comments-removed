use
api
:
:
{
ColorF
ColorU
LayoutPrimitiveInfo
LayoutRect
LayoutSizeAu
LineOrientation
LineStyle
PremultipliedColorF
Shadow
}
;
use
app_units
:
:
Au
;
use
display_list_flattener
:
:
{
AsInstanceKind
CreateShadow
IsVisible
}
;
use
frame_builder
:
:
{
FrameBuildingState
}
;
use
gpu_cache
:
:
GpuDataRequest
;
use
intern
;
use
prim_store
:
:
{
PrimKey
PrimKeyCommonData
PrimTemplate
PrimTemplateCommonData
PrimitiveSceneData
PrimitiveStore
}
;
use
prim_store
:
:
PrimitiveInstanceKind
;
#
[
derive
(
Clone
Debug
Hash
MallocSizeOf
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
LineDecorationCacheKey
{
pub
style
:
LineStyle
pub
orientation
:
LineOrientation
pub
wavy_line_thickness
:
Au
pub
size
:
LayoutSizeAu
}
#
[
derive
(
Clone
Debug
Hash
MallocSizeOf
PartialEq
Eq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
LineDecoration
{
pub
cache_key
:
Option
<
LineDecorationCacheKey
>
pub
color
:
ColorU
}
pub
type
LineDecorationKey
=
PrimKey
<
LineDecoration
>
;
impl
LineDecorationKey
{
pub
fn
new
(
info
:
&
LayoutPrimitiveInfo
prim_relative_clip_rect
:
LayoutRect
line_dec
:
LineDecoration
)
-
>
Self
{
LineDecorationKey
{
common
:
PrimKeyCommonData
:
:
with_info
(
info
prim_relative_clip_rect
)
kind
:
line_dec
}
}
}
impl
intern
:
:
InternDebug
for
LineDecorationKey
{
}
impl
AsInstanceKind
<
LineDecorationDataHandle
>
for
LineDecorationKey
{
fn
as_instance_kind
(
&
self
data_handle
:
LineDecorationDataHandle
_
:
&
mut
PrimitiveStore
)
-
>
PrimitiveInstanceKind
{
PrimitiveInstanceKind
:
:
LineDecoration
{
data_handle
cache_handle
:
None
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
LineDecorationData
{
pub
cache_key
:
Option
<
LineDecorationCacheKey
>
pub
color
:
ColorF
}
impl
LineDecorationData
{
pub
fn
update
(
&
mut
self
common
:
&
mut
PrimTemplateCommonData
frame_state
:
&
mut
FrameBuildingState
)
{
if
let
Some
(
ref
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
common
.
gpu_cache_handle
)
{
self
.
write_prim_gpu_blocks
(
request
)
;
}
}
fn
write_prim_gpu_blocks
(
&
self
request
:
&
mut
GpuDataRequest
)
{
match
self
.
cache_key
.
as_ref
(
)
{
Some
(
cache_key
)
=
>
{
request
.
push
(
self
.
color
.
premultiplied
(
)
)
;
request
.
push
(
PremultipliedColorF
:
:
WHITE
)
;
request
.
push
(
[
cache_key
.
size
.
width
.
to_f32_px
(
)
cache_key
.
size
.
height
.
to_f32_px
(
)
0
.
0
0
.
0
]
)
;
}
None
=
>
{
request
.
push
(
self
.
color
.
premultiplied
(
)
)
;
}
}
}
}
pub
type
LineDecorationTemplate
=
PrimTemplate
<
LineDecorationData
>
;
impl
From
<
LineDecorationKey
>
for
LineDecorationTemplate
{
fn
from
(
line_dec
:
LineDecorationKey
)
-
>
Self
{
let
common
=
PrimTemplateCommonData
:
:
with_key_common
(
line_dec
.
common
)
;
LineDecorationTemplate
{
common
kind
:
LineDecorationData
{
cache_key
:
line_dec
.
kind
.
cache_key
color
:
line_dec
.
kind
.
color
.
into
(
)
}
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Hash
Eq
MallocSizeOf
PartialEq
)
]
pub
struct
LineDecorationDataMarker
;
pub
type
LineDecorationDataStore
=
intern
:
:
DataStore
<
LineDecorationKey
LineDecorationTemplate
LineDecorationDataMarker
>
;
pub
type
LineDecorationDataHandle
=
intern
:
:
Handle
<
LineDecorationDataMarker
>
;
pub
type
LineDecorationDataUpdateList
=
intern
:
:
UpdateList
<
LineDecorationKey
>
;
pub
type
LineDecorationDataInterner
=
intern
:
:
Interner
<
LineDecorationKey
PrimitiveSceneData
LineDecorationDataMarker
>
;
impl
intern
:
:
Internable
for
LineDecoration
{
type
Marker
=
LineDecorationDataMarker
;
type
Source
=
LineDecorationKey
;
type
StoreData
=
LineDecorationTemplate
;
type
InternData
=
PrimitiveSceneData
;
fn
build_key
(
self
info
:
&
LayoutPrimitiveInfo
prim_relative_clip_rect
:
LayoutRect
)
-
>
LineDecorationKey
{
LineDecorationKey
:
:
new
(
info
prim_relative_clip_rect
self
)
}
}
impl
CreateShadow
for
LineDecoration
{
fn
create_shadow
(
&
self
shadow
:
&
Shadow
)
-
>
Self
{
LineDecoration
{
color
:
shadow
.
color
.
into
(
)
cache_key
:
self
.
cache_key
.
clone
(
)
}
}
}
impl
IsVisible
for
LineDecoration
{
fn
is_visible
(
&
self
)
-
>
bool
{
self
.
color
.
a
>
0
}
}
#
[
test
]
#
[
cfg
(
target_pointer_width
=
"
64
"
)
]
fn
test_struct_sizes
(
)
{
use
std
:
:
mem
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LineDecoration
>
(
)
20
"
LineDecoration
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LineDecorationTemplate
>
(
)
68
"
LineDecorationTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
LineDecorationKey
>
(
)
48
"
LineDecorationKey
size
changed
"
)
;
}
