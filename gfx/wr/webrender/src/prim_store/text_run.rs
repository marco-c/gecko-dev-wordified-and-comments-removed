use
api
:
:
{
ColorF
DevicePixelScale
GlyphInstance
LayoutPrimitiveInfo
}
;
use
api
:
:
{
LayoutToWorldTransform
RasterSpace
}
;
use
api
:
:
{
LayoutVector2D
Shadow
}
;
use
display_list_flattener
:
:
{
AsInstanceKind
CreateShadow
IsVisible
}
;
use
frame_builder
:
:
{
FrameBuildingState
PictureContext
}
;
use
glyph_rasterizer
:
:
{
FontInstance
FontTransform
GlyphKey
FONT_SIZE_LIMIT
}
;
use
gpu_cache
:
:
GpuCache
;
use
intern
;
use
intern_types
;
use
prim_store
:
:
{
PrimitiveOpacity
PrimitiveSceneData
PrimitiveScratchBuffer
}
;
use
prim_store
:
:
{
PrimitiveStore
PrimKeyCommonData
PrimTemplateCommonData
}
;
use
render_task
:
:
{
RenderTaskTree
}
;
use
renderer
:
:
{
MAX_VERTEX_TEXTURE_WIDTH
}
;
use
resource_cache
:
:
{
ResourceCache
}
;
use
util
:
:
{
MatrixHelpers
}
;
use
prim_store
:
:
PrimitiveInstanceKind
;
use
std
:
:
ops
;
use
std
:
:
sync
:
:
Arc
;
use
storage
;
use
util
:
:
PrimaryArc
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Eq
MallocSizeOf
PartialEq
Hash
)
]
pub
struct
TextRunKey
{
pub
common
:
PrimKeyCommonData
pub
font
:
FontInstance
pub
glyphs
:
PrimaryArc
<
Vec
<
GlyphInstance
>
>
pub
shadow
:
bool
}
impl
TextRunKey
{
pub
fn
new
(
info
:
&
LayoutPrimitiveInfo
text_run
:
TextRun
)
-
>
Self
{
TextRunKey
{
common
:
PrimKeyCommonData
:
:
with_info
(
info
)
font
:
text_run
.
font
glyphs
:
PrimaryArc
(
text_run
.
glyphs
)
shadow
:
text_run
.
shadow
}
}
}
impl
intern
:
:
InternDebug
for
TextRunKey
{
}
impl
AsInstanceKind
<
TextRunDataHandle
>
for
TextRunKey
{
fn
as_instance_kind
(
&
self
data_handle
:
TextRunDataHandle
prim_store
:
&
mut
PrimitiveStore
reference_frame_relative_offset
:
LayoutVector2D
)
-
>
PrimitiveInstanceKind
{
let
run_index
=
prim_store
.
text_runs
.
push
(
TextRunPrimitive
{
used_font
:
self
.
font
.
clone
(
)
glyph_keys_range
:
storage
:
:
Range
:
:
empty
(
)
shadow
:
self
.
shadow
reference_frame_relative_offset
}
)
;
PrimitiveInstanceKind
:
:
TextRun
{
data_handle
run_index
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
TextRunTemplate
{
pub
common
:
PrimTemplateCommonData
pub
font
:
FontInstance
#
[
ignore_malloc_size_of
=
"
Measured
via
PrimaryArc
"
]
pub
glyphs
:
Arc
<
Vec
<
GlyphInstance
>
>
}
impl
ops
:
:
Deref
for
TextRunTemplate
{
type
Target
=
PrimTemplateCommonData
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
common
}
}
impl
ops
:
:
DerefMut
for
TextRunTemplate
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
common
}
}
impl
From
<
TextRunKey
>
for
TextRunTemplate
{
fn
from
(
item
:
TextRunKey
)
-
>
Self
{
let
common
=
PrimTemplateCommonData
:
:
with_key_common
(
item
.
common
)
;
TextRunTemplate
{
common
font
:
item
.
font
glyphs
:
item
.
glyphs
.
0
}
}
}
impl
TextRunTemplate
{
pub
fn
update
(
&
mut
self
frame_state
:
&
mut
FrameBuildingState
)
{
self
.
write_prim_gpu_blocks
(
frame_state
)
;
self
.
opacity
=
PrimitiveOpacity
:
:
translucent
(
)
;
}
fn
write_prim_gpu_blocks
(
&
mut
self
frame_state
:
&
mut
FrameBuildingState
)
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
common
.
gpu_cache_handle
)
{
request
.
push
(
ColorF
:
:
from
(
self
.
font
.
color
)
.
premultiplied
(
)
)
;
let
bg_color
=
ColorF
:
:
from
(
self
.
font
.
bg_color
)
;
request
.
push
(
[
bg_color
.
r
bg_color
.
g
bg_color
.
b
1
.
0
]
)
;
let
mut
gpu_block
=
[
0
.
0
;
4
]
;
for
(
i
src
)
in
self
.
glyphs
.
iter
(
)
.
enumerate
(
)
{
if
(
i
&
1
)
=
=
0
{
gpu_block
[
0
]
=
src
.
point
.
x
;
gpu_block
[
1
]
=
src
.
point
.
y
;
}
else
{
gpu_block
[
2
]
=
src
.
point
.
x
;
gpu_block
[
3
]
=
src
.
point
.
y
;
request
.
push
(
gpu_block
)
;
}
}
if
(
self
.
glyphs
.
len
(
)
&
1
)
!
=
0
{
request
.
push
(
gpu_block
)
;
}
assert
!
(
request
.
current_used_block_num
(
)
<
=
MAX_VERTEX_TEXTURE_WIDTH
)
;
}
}
}
pub
use
intern_types
:
:
text_run
:
:
Handle
as
TextRunDataHandle
;
pub
struct
TextRun
{
pub
font
:
FontInstance
pub
glyphs
:
Arc
<
Vec
<
GlyphInstance
>
>
pub
shadow
:
bool
}
impl
intern
:
:
Internable
for
TextRun
{
type
Marker
=
intern_types
:
:
text_run
:
:
Marker
;
type
Source
=
TextRunKey
;
type
StoreData
=
TextRunTemplate
;
type
InternData
=
PrimitiveSceneData
;
fn
build_key
(
self
info
:
&
LayoutPrimitiveInfo
)
-
>
TextRunKey
{
TextRunKey
:
:
new
(
info
self
)
}
}
impl
CreateShadow
for
TextRun
{
fn
create_shadow
(
&
self
shadow
:
&
Shadow
)
-
>
Self
{
let
mut
font
=
FontInstance
{
color
:
shadow
.
color
.
into
(
)
.
.
self
.
font
.
clone
(
)
}
;
if
shadow
.
blur_radius
>
0
.
0
{
font
.
disable_subpixel_aa
(
)
;
}
TextRun
{
font
glyphs
:
self
.
glyphs
.
clone
(
)
shadow
:
true
}
}
}
impl
IsVisible
for
TextRun
{
fn
is_visible
(
&
self
)
-
>
bool
{
self
.
font
.
color
.
a
>
0
}
}
#
[
derive
(
Debug
)
]
pub
struct
TextRunPrimitive
{
pub
used_font
:
FontInstance
pub
glyph_keys_range
:
storage
:
:
Range
<
GlyphKey
>
pub
reference_frame_relative_offset
:
LayoutVector2D
pub
shadow
:
bool
}
impl
TextRunPrimitive
{
pub
fn
update_font_instance
(
&
mut
self
specified_font
:
&
FontInstance
device_pixel_scale
:
DevicePixelScale
transform
:
&
LayoutToWorldTransform
allow_subpixel_aa
:
bool
raster_space
:
RasterSpace
)
-
>
bool
{
let
device_font_size
=
specified_font
.
size
.
scale_by
(
device_pixel_scale
.
0
)
;
let
transform_glyphs
=
if
transform
.
has_perspective_component
(
)
|
|
!
transform
.
has_2d_inverse
(
)
|
|
transform
.
exceeds_2d_scale
(
FONT_SIZE_LIMIT
/
device_font_size
.
to_f64_px
(
)
)
|
|
raster_space
!
=
RasterSpace
:
:
Screen
{
false
}
else
{
true
}
;
let
font_transform
=
if
transform_glyphs
{
FontTransform
:
:
from
(
transform
)
.
quantize
(
)
}
else
{
FontTransform
:
:
identity
(
)
}
;
let
cache_dirty
=
self
.
used_font
.
transform
!
=
font_transform
|
|
self
.
used_font
.
size
!
=
device_font_size
;
self
.
used_font
=
FontInstance
{
transform
:
font_transform
size
:
device_font_size
.
.
specified_font
.
clone
(
)
}
;
if
(
!
allow_subpixel_aa
&
&
self
.
used_font
.
bg_color
.
a
=
=
0
)
|
|
!
transform_glyphs
{
self
.
used_font
.
disable_subpixel_aa
(
)
;
}
cache_dirty
}
pub
fn
prepare_for_render
(
&
mut
self
prim_offset
:
LayoutVector2D
specified_font
:
&
FontInstance
glyphs
:
&
[
GlyphInstance
]
device_pixel_scale
:
DevicePixelScale
transform
:
&
LayoutToWorldTransform
pic_context
:
&
PictureContext
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
render_tasks
:
&
mut
RenderTaskTree
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
let
cache_dirty
=
self
.
update_font_instance
(
specified_font
device_pixel_scale
transform
pic_context
.
allow_subpixel_aa
pic_context
.
raster_space
)
;
if
self
.
glyph_keys_range
.
is_empty
(
)
|
|
cache_dirty
{
let
subpx_dir
=
self
.
used_font
.
get_subpx_dir
(
)
;
self
.
glyph_keys_range
=
scratch
.
glyph_keys
.
extend
(
glyphs
.
iter
(
)
.
map
(
|
src
|
{
let
src_point
=
src
.
point
+
prim_offset
;
let
world_offset
=
self
.
used_font
.
transform
.
transform
(
&
src_point
)
;
let
device_offset
=
device_pixel_scale
.
transform_point
(
&
world_offset
)
;
GlyphKey
:
:
new
(
src
.
index
device_offset
subpx_dir
)
}
)
)
;
}
resource_cache
.
request_glyphs
(
self
.
used_font
.
clone
(
)
&
scratch
.
glyph_keys
[
self
.
glyph_keys_range
]
gpu_cache
render_tasks
)
;
}
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
test_struct_sizes
(
)
{
use
std
:
:
mem
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRun
>
(
)
96
"
TextRun
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunTemplate
>
(
)
112
"
TextRunTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunKey
>
(
)
104
"
TextRunKey
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunPrimitive
>
(
)
88
"
TextRunPrimitive
size
changed
"
)
;
}
