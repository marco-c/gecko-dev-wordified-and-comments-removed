use
api
:
:
{
ColorF
GlyphInstance
RasterSpace
Shadow
}
;
use
api
:
:
units
:
:
{
LayoutToWorldTransform
LayoutVector2D
}
;
use
crate
:
:
scene_building
:
:
{
CreateShadow
IsVisible
}
;
use
crate
:
:
frame_builder
:
:
FrameBuildingState
;
use
crate
:
:
glyph_rasterizer
:
:
{
FontInstance
FontTransform
GlyphKey
FONT_SIZE_LIMIT
}
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
intern
;
use
crate
:
:
internal_types
:
:
LayoutPrimitiveInfo
;
use
crate
:
:
picture
:
:
{
SubpixelMode
SurfaceInfo
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveOpacity
PrimitiveSceneData
PrimitiveScratchBuffer
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveStore
PrimKeyCommonData
PrimTemplateCommonData
}
;
use
crate
:
:
render_task_graph
:
:
RenderTaskGraph
;
use
crate
:
:
renderer
:
:
{
MAX_VERTEX_TEXTURE_WIDTH
}
;
use
crate
:
:
resource_cache
:
:
{
ResourceCache
}
;
use
crate
:
:
util
:
:
{
MatrixHelpers
}
;
use
crate
:
:
prim_store
:
:
{
InternablePrimitive
PrimitiveInstanceKind
SpaceSnapper
}
;
use
crate
:
:
spatial_tree
:
:
{
SpatialTree
SpatialNodeIndex
}
;
use
std
:
:
ops
;
use
std
:
:
sync
:
:
Arc
;
use
crate
:
:
storage
;
use
crate
:
:
util
:
:
PrimaryArc
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Debug
Clone
Eq
MallocSizeOf
PartialEq
Hash
)
]
pub
struct
TextRunKey
{
pub
common
:
PrimKeyCommonData
pub
font
:
FontInstance
pub
glyphs
:
PrimaryArc
<
Vec
<
GlyphInstance
>
>
pub
shadow
:
bool
}
impl
TextRunKey
{
pub
fn
new
(
info
:
&
LayoutPrimitiveInfo
text_run
:
TextRun
)
-
>
Self
{
TextRunKey
{
common
:
PrimKeyCommonData
:
:
with_info
(
info
)
font
:
text_run
.
font
glyphs
:
PrimaryArc
(
text_run
.
glyphs
)
shadow
:
text_run
.
shadow
}
}
}
impl
intern
:
:
InternDebug
for
TextRunKey
{
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
TextRunTemplate
{
pub
common
:
PrimTemplateCommonData
pub
font
:
FontInstance
#
[
ignore_malloc_size_of
=
"
Measured
via
PrimaryArc
"
]
pub
glyphs
:
Arc
<
Vec
<
GlyphInstance
>
>
}
impl
ops
:
:
Deref
for
TextRunTemplate
{
type
Target
=
PrimTemplateCommonData
;
fn
deref
(
&
self
)
-
>
&
Self
:
:
Target
{
&
self
.
common
}
}
impl
ops
:
:
DerefMut
for
TextRunTemplate
{
fn
deref_mut
(
&
mut
self
)
-
>
&
mut
Self
:
:
Target
{
&
mut
self
.
common
}
}
impl
From
<
TextRunKey
>
for
TextRunTemplate
{
fn
from
(
item
:
TextRunKey
)
-
>
Self
{
let
common
=
PrimTemplateCommonData
:
:
with_key_common
(
item
.
common
)
;
TextRunTemplate
{
common
font
:
item
.
font
glyphs
:
item
.
glyphs
.
0
}
}
}
impl
TextRunTemplate
{
pub
fn
update
(
&
mut
self
frame_state
:
&
mut
FrameBuildingState
)
{
self
.
write_prim_gpu_blocks
(
frame_state
)
;
self
.
opacity
=
PrimitiveOpacity
:
:
translucent
(
)
;
}
fn
write_prim_gpu_blocks
(
&
mut
self
frame_state
:
&
mut
FrameBuildingState
)
{
if
let
Some
(
mut
request
)
=
frame_state
.
gpu_cache
.
request
(
&
mut
self
.
common
.
gpu_cache_handle
)
{
request
.
push
(
ColorF
:
:
from
(
self
.
font
.
color
)
.
premultiplied
(
)
)
;
let
bg_color
=
ColorF
:
:
from
(
self
.
font
.
bg_color
)
;
request
.
push
(
[
bg_color
.
r
bg_color
.
g
bg_color
.
b
1
.
0
]
)
;
let
mut
gpu_block
=
[
0
.
0
;
4
]
;
for
(
i
src
)
in
self
.
glyphs
.
iter
(
)
.
enumerate
(
)
{
if
(
i
&
1
)
=
=
0
{
gpu_block
[
0
]
=
src
.
point
.
x
;
gpu_block
[
1
]
=
src
.
point
.
y
;
}
else
{
gpu_block
[
2
]
=
src
.
point
.
x
;
gpu_block
[
3
]
=
src
.
point
.
y
;
request
.
push
(
gpu_block
)
;
}
}
if
(
self
.
glyphs
.
len
(
)
&
1
)
!
=
0
{
request
.
push
(
gpu_block
)
;
}
assert
!
(
request
.
current_used_block_num
(
)
<
=
MAX_VERTEX_TEXTURE_WIDTH
)
;
}
}
}
pub
type
TextRunDataHandle
=
intern
:
:
Handle
<
TextRun
>
;
#
[
derive
(
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextRun
{
pub
font
:
FontInstance
#
[
ignore_malloc_size_of
=
"
Measured
via
PrimaryArc
"
]
pub
glyphs
:
Arc
<
Vec
<
GlyphInstance
>
>
pub
shadow
:
bool
}
impl
intern
:
:
Internable
for
TextRun
{
type
Key
=
TextRunKey
;
type
StoreData
=
TextRunTemplate
;
type
InternData
=
PrimitiveSceneData
;
}
impl
InternablePrimitive
for
TextRun
{
fn
into_key
(
self
info
:
&
LayoutPrimitiveInfo
)
-
>
TextRunKey
{
TextRunKey
:
:
new
(
info
self
)
}
fn
make_instance_kind
(
key
:
TextRunKey
data_handle
:
TextRunDataHandle
prim_store
:
&
mut
PrimitiveStore
reference_frame_relative_offset
:
LayoutVector2D
)
-
>
PrimitiveInstanceKind
{
let
run_index
=
prim_store
.
text_runs
.
push
(
TextRunPrimitive
{
used_font
:
key
.
font
.
clone
(
)
glyph_keys_range
:
storage
:
:
Range
:
:
empty
(
)
reference_frame_relative_offset
snapped_reference_frame_relative_offset
:
reference_frame_relative_offset
shadow
:
key
.
shadow
raster_space
:
RasterSpace
:
:
Screen
}
)
;
PrimitiveInstanceKind
:
:
TextRun
{
data_handle
run_index
}
}
}
impl
CreateShadow
for
TextRun
{
fn
create_shadow
(
&
self
shadow
:
&
Shadow
)
-
>
Self
{
let
mut
font
=
FontInstance
{
color
:
shadow
.
color
.
into
(
)
.
.
self
.
font
.
clone
(
)
}
;
if
shadow
.
blur_radius
>
0
.
0
{
font
.
disable_subpixel_aa
(
)
;
}
TextRun
{
font
glyphs
:
self
.
glyphs
.
clone
(
)
shadow
:
true
}
}
}
impl
IsVisible
for
TextRun
{
fn
is_visible
(
&
self
)
-
>
bool
{
self
.
font
.
color
.
a
>
0
}
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
TextRunPrimitive
{
pub
used_font
:
FontInstance
pub
glyph_keys_range
:
storage
:
:
Range
<
GlyphKey
>
pub
reference_frame_relative_offset
:
LayoutVector2D
pub
snapped_reference_frame_relative_offset
:
LayoutVector2D
pub
shadow
:
bool
pub
raster_space
:
RasterSpace
}
impl
TextRunPrimitive
{
pub
fn
update_font_instance
(
&
mut
self
specified_font
:
&
FontInstance
surface
:
&
SurfaceInfo
spatial_node_index
:
SpatialNodeIndex
transform
:
&
LayoutToWorldTransform
subpixel_mode
:
SubpixelMode
raster_space
:
RasterSpace
spatial_tree
:
&
SpatialTree
)
-
>
bool
{
let
mut
raster_space
=
raster_space
;
let
raster_scale
=
raster_space
.
local_scale
(
)
.
unwrap_or
(
1
.
0
)
.
max
(
0
.
001
)
;
let
mut
device_font_size
=
specified_font
.
size
.
scale_by
(
surface
.
device_pixel_scale
.
0
*
raster_scale
)
;
let
(
transform_glyphs
oversized
)
=
if
raster_space
!
=
RasterSpace
:
:
Screen
|
|
transform
.
has_perspective_component
(
)
|
|
!
transform
.
has_2d_inverse
(
)
{
(
false
device_font_size
.
to_f64_px
(
)
>
FONT_SIZE_LIMIT
)
}
else
if
transform
.
exceeds_2d_scale
(
FONT_SIZE_LIMIT
/
device_font_size
.
to_f64_px
(
)
)
{
(
false
true
)
}
else
{
(
true
false
)
}
;
if
oversized
{
let
max_scale
=
(
FONT_SIZE_LIMIT
/
device_font_size
.
to_f64_px
(
)
)
as
f32
;
raster_space
=
RasterSpace
:
:
Local
(
max_scale
*
raster_scale
)
;
device_font_size
=
device_font_size
.
scale_by
(
max_scale
)
;
}
let
font_transform
=
if
transform_glyphs
{
FontTransform
:
:
from
(
transform
)
}
else
{
FontTransform
:
:
identity
(
)
}
;
self
.
raster_space
=
raster_space
;
self
.
snapped_reference_frame_relative_offset
=
if
!
font_transform
.
is_identity
(
)
{
self
.
reference_frame_relative_offset
}
else
{
let
snap_to_device
=
SpaceSnapper
:
:
new_with_target
(
surface
.
raster_spatial_node_index
spatial_node_index
surface
.
device_pixel_scale
spatial_tree
)
;
snap_to_device
.
snap_vector
(
&
self
.
reference_frame_relative_offset
)
}
;
let
cache_dirty
=
self
.
used_font
.
transform
!
=
font_transform
|
|
self
.
used_font
.
size
!
=
device_font_size
;
self
.
used_font
=
FontInstance
{
transform
:
font_transform
size
:
device_font_size
.
.
specified_font
.
clone
(
)
}
;
if
(
subpixel_mode
=
=
SubpixelMode
:
:
Deny
&
&
self
.
used_font
.
bg_color
.
a
=
=
0
)
|
|
!
transform_glyphs
{
self
.
used_font
.
disable_subpixel_aa
(
)
;
if
oversized
{
self
.
used_font
.
disable_subpixel_position
(
)
;
}
}
cache_dirty
}
pub
fn
request_resources
(
&
mut
self
prim_offset
:
LayoutVector2D
specified_font
:
&
FontInstance
glyphs
:
&
[
GlyphInstance
]
transform
:
&
LayoutToWorldTransform
surface
:
&
SurfaceInfo
spatial_node_index
:
SpatialNodeIndex
raster_space
:
RasterSpace
subpixel_mode
:
SubpixelMode
resource_cache
:
&
mut
ResourceCache
gpu_cache
:
&
mut
GpuCache
render_tasks
:
&
mut
RenderTaskGraph
spatial_tree
:
&
SpatialTree
scratch
:
&
mut
PrimitiveScratchBuffer
)
{
let
cache_dirty
=
self
.
update_font_instance
(
specified_font
surface
spatial_node_index
transform
subpixel_mode
raster_space
spatial_tree
)
;
if
self
.
glyph_keys_range
.
is_empty
(
)
|
|
cache_dirty
{
let
subpx_dir
=
self
.
used_font
.
get_subpx_dir
(
)
;
let
transform
=
match
self
.
raster_space
{
RasterSpace
:
:
Local
(
scale
)
=
>
FontTransform
:
:
new
(
scale
0
.
0
0
.
0
scale
)
RasterSpace
:
:
Screen
=
>
self
.
used_font
.
transform
}
;
self
.
glyph_keys_range
=
scratch
.
glyph_keys
.
extend
(
glyphs
.
iter
(
)
.
map
(
|
src
|
{
let
src_point
=
src
.
point
+
prim_offset
;
let
world_offset
=
transform
.
transform
(
&
src_point
)
;
let
device_offset
=
surface
.
device_pixel_scale
.
transform_point
(
world_offset
)
;
GlyphKey
:
:
new
(
src
.
index
device_offset
subpx_dir
)
}
)
)
;
}
resource_cache
.
request_glyphs
(
self
.
used_font
.
clone
(
)
&
scratch
.
glyph_keys
[
self
.
glyph_keys_range
]
gpu_cache
render_tasks
)
;
}
}
#
[
test
]
#
[
cfg
(
target_os
=
"
linux
"
)
]
fn
test_struct_sizes
(
)
{
use
std
:
:
mem
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRun
>
(
)
56
"
TextRun
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunTemplate
>
(
)
72
"
TextRunTemplate
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunKey
>
(
)
64
"
TextRunKey
size
changed
"
)
;
assert_eq
!
(
mem
:
:
size_of
:
:
<
TextRunPrimitive
>
(
)
80
"
TextRunPrimitive
size
changed
"
)
;
}
