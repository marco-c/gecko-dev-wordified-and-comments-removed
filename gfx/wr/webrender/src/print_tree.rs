use
std
:
:
io
:
:
{
stdout
Stdout
Write
}
;
pub
struct
PrintTree
<
W
>
where
W
:
Write
{
level
:
u32
queued_item
:
Option
<
String
>
sink
:
W
}
pub
trait
PrintTreePrinter
{
fn
new_level
(
&
mut
self
title
:
String
)
;
fn
end_level
(
&
mut
self
)
;
fn
add_item
(
&
mut
self
text
:
String
)
;
}
impl
PrintTree
<
Stdout
>
{
pub
fn
new
(
title
:
&
str
)
-
>
Self
{
PrintTree
:
:
new_with_sink
(
title
stdout
(
)
)
}
}
impl
<
W
>
PrintTree
<
W
>
where
W
:
Write
{
pub
fn
new_with_sink
(
title
:
&
str
mut
sink
:
W
)
-
>
Self
{
writeln
!
(
sink
"
\
u
{
250c
}
{
}
"
title
)
.
unwrap
(
)
;
PrintTree
{
level
:
1
queued_item
:
None
sink
}
}
fn
print_level_prefix
(
&
mut
self
)
{
for
_
in
0
.
.
self
.
level
{
write
!
(
self
.
sink
"
\
u
{
2502
}
"
)
.
unwrap
(
)
;
}
}
fn
flush_queued_item
(
&
mut
self
prefix
:
&
str
)
{
if
let
Some
(
queued_item
)
=
self
.
queued_item
.
take
(
)
{
self
.
print_level_prefix
(
)
;
writeln
!
(
self
.
sink
"
{
}
{
}
"
prefix
queued_item
)
.
unwrap
(
)
;
}
}
}
impl
<
W
>
PrintTreePrinter
for
PrintTree
<
W
>
where
W
:
Write
{
fn
new_level
(
&
mut
self
title
:
String
)
{
self
.
flush_queued_item
(
"
\
u
{
251C
}
\
u
{
2500
}
"
)
;
self
.
print_level_prefix
(
)
;
writeln
!
(
self
.
sink
"
\
u
{
251C
}
\
u
{
2500
}
{
}
"
title
)
.
unwrap
(
)
;
self
.
level
=
self
.
level
+
1
;
}
fn
end_level
(
&
mut
self
)
{
self
.
flush_queued_item
(
"
\
u
{
2514
}
\
u
{
2500
}
"
)
;
self
.
level
=
self
.
level
-
1
;
}
fn
add_item
(
&
mut
self
text
:
String
)
{
self
.
flush_queued_item
(
"
\
u
{
251C
}
\
u
{
2500
}
"
)
;
self
.
queued_item
=
Some
(
text
)
;
}
}
impl
<
W
>
Drop
for
PrintTree
<
W
>
where
W
:
Write
{
fn
drop
(
&
mut
self
)
{
self
.
flush_queued_item
(
"
\
u
{
9492
}
\
u
{
9472
}
"
)
;
}
}
pub
trait
PrintableTree
{
fn
print_with
<
T
:
PrintTreePrinter
>
(
&
self
pt
:
&
mut
T
)
;
}
