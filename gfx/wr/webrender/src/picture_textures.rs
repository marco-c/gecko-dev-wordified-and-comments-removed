use
smallvec
:
:
SmallVec
;
use
api
:
:
{
ImageFormat
ImageBufferKind
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
device
:
:
TextureFilter
;
use
crate
:
:
internal_types
:
:
{
CacheTextureId
TextureUpdateList
Swizzle
TextureCacheAllocInfo
TextureCacheCategory
}
;
use
crate
:
:
texture_cache
:
:
{
CacheEntry
EntryDetails
TargetShader
}
;
use
crate
:
:
render_backend
:
:
{
FrameStamp
FrameId
}
;
use
crate
:
:
profiler
:
:
{
self
TransactionProfile
}
;
use
crate
:
:
gpu_types
:
:
UvRectKind
;
use
crate
:
:
gpu_cache
:
:
GpuCacheHandle
;
use
std
:
:
cmp
;
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
struct
PictureTexture
{
texture_id
:
CacheTextureId
size
:
DeviceIntSize
is_allocated
:
bool
last_frame_used
:
FrameId
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
PictureTextures
{
textures
:
Vec
<
PictureTexture
>
default_tile_size
:
DeviceIntSize
allocated_texture_count
:
usize
filter
:
TextureFilter
}
impl
PictureTextures
{
pub
fn
new
(
default_tile_size
:
DeviceIntSize
filter
:
TextureFilter
)
-
>
Self
{
PictureTextures
{
textures
:
Vec
:
:
new
(
)
default_tile_size
allocated_texture_count
:
0
filter
}
}
pub
fn
default_tile_size
(
&
self
)
-
>
DeviceIntSize
{
self
.
default_tile_size
}
pub
fn
get_or_allocate_tile
(
&
mut
self
tile_size
:
DeviceIntSize
now
:
FrameStamp
next_texture_id
:
&
mut
CacheTextureId
pending_updates
:
&
mut
TextureUpdateList
)
-
>
CacheEntry
{
let
mut
texture_id
=
None
;
self
.
allocated_texture_count
+
=
1
;
for
texture
in
&
mut
self
.
textures
{
if
texture
.
size
=
=
tile_size
&
&
!
texture
.
is_allocated
{
texture
.
is_allocated
=
true
;
texture
.
last_frame_used
=
FrameId
:
:
INVALID
;
texture_id
=
Some
(
texture
.
texture_id
)
;
break
;
}
}
let
texture_id
=
texture_id
.
unwrap_or_else
(
|
|
{
let
texture_id
=
*
next_texture_id
;
next_texture_id
.
0
+
=
1
;
let
info
=
TextureCacheAllocInfo
{
target
:
ImageBufferKind
:
:
Texture2D
width
:
tile_size
.
width
height
:
tile_size
.
height
format
:
ImageFormat
:
:
RGBA8
filter
:
self
.
filter
is_shared_cache
:
false
has_depth
:
true
category
:
TextureCacheCategory
:
:
PictureTile
}
;
pending_updates
.
push_alloc
(
texture_id
info
)
;
self
.
textures
.
push
(
PictureTexture
{
texture_id
is_allocated
:
true
size
:
tile_size
last_frame_used
:
FrameId
:
:
INVALID
}
)
;
texture_id
}
)
;
CacheEntry
{
size
:
tile_size
user_data
:
[
0
.
0
;
4
]
last_access
:
now
details
:
EntryDetails
:
:
Picture
{
size
:
tile_size
}
uv_rect_handle
:
GpuCacheHandle
:
:
new
(
)
input_format
:
ImageFormat
:
:
RGBA8
filter
:
self
.
filter
swizzle
:
Swizzle
:
:
default
(
)
texture_id
eviction_notice
:
None
uv_rect_kind
:
UvRectKind
:
:
Rect
shader
:
TargetShader
:
:
Default
}
}
pub
fn
free_tile
(
&
mut
self
id
:
CacheTextureId
current_frame_id
:
FrameId
)
{
self
.
allocated_texture_count
-
=
1
;
let
texture
=
self
.
textures
.
iter_mut
(
)
.
find
(
|
t
|
t
.
texture_id
=
=
id
)
.
expect
(
"
bug
:
invalid
texture
id
"
)
;
assert
!
(
texture
.
is_allocated
)
;
texture
.
is_allocated
=
false
;
assert_eq
!
(
texture
.
last_frame_used
FrameId
:
:
INVALID
)
;
texture
.
last_frame_used
=
current_frame_id
;
}
pub
fn
clear
(
&
mut
self
pending_updates
:
&
mut
TextureUpdateList
)
{
for
texture
in
self
.
textures
.
drain
(
.
.
)
{
pending_updates
.
push_free
(
texture
.
texture_id
)
;
}
}
pub
fn
update_profile
(
&
self
profile
:
&
mut
TransactionProfile
)
{
profile
.
set
(
profiler
:
:
PICTURE_TILES
self
.
textures
.
len
(
)
)
;
}
pub
fn
gc
(
&
mut
self
pending_updates
:
&
mut
TextureUpdateList
)
{
let
free_texture_count
=
self
.
textures
.
len
(
)
-
self
.
allocated_texture_count
;
let
allowed_retained_count
=
(
self
.
allocated_texture_count
as
f32
*
0
.
25
)
.
ceil
(
)
as
usize
;
let
do_gc
=
free_texture_count
>
allowed_retained_count
;
if
do_gc
{
self
.
textures
.
sort_unstable_by_key
(
|
t
|
cmp
:
:
Reverse
(
t
.
last_frame_used
)
)
;
let
mut
allocated_targets
=
SmallVec
:
:
<
[
PictureTexture
;
32
]
>
:
:
new
(
)
;
let
mut
retained_targets
=
SmallVec
:
:
<
[
PictureTexture
;
32
]
>
:
:
new
(
)
;
for
target
in
self
.
textures
.
drain
(
.
.
)
{
if
target
.
is_allocated
{
allocated_targets
.
push
(
target
)
;
}
else
if
retained_targets
.
len
(
)
<
allowed_retained_count
{
retained_targets
.
push
(
target
)
;
}
else
{
assert_ne
!
(
target
.
last_frame_used
FrameId
:
:
INVALID
)
;
pending_updates
.
push_free
(
target
.
texture_id
)
;
}
}
self
.
textures
.
extend
(
retained_targets
)
;
self
.
textures
.
extend
(
allocated_targets
)
;
}
}
#
[
cfg
(
feature
=
"
replay
"
)
]
pub
fn
filter
(
&
self
)
-
>
TextureFilter
{
self
.
filter
}
}
