use
crate
:
:
api
:
:
ExternalImageType
;
use
crate
:
:
api
:
:
units
:
:
*
;
use
crate
:
:
gpu_cache
:
:
GpuCache
;
use
crate
:
:
prim_store
:
:
DeferredResolve
;
use
crate
:
:
renderer
:
:
BLOCKS_PER_UV_RECT
;
use
crate
:
:
render_task_cache
:
:
RenderTaskCacheEntryHandle
;
use
crate
:
:
resource_cache
:
:
{
ResourceCache
ImageRequest
CacheItem
}
;
use
crate
:
:
internal_types
:
:
{
TextureSource
TextureSourceExternal
DeferredResolveIndex
FrameVec
}
;
pub
fn
resolve_image
(
request
:
ImageRequest
resource_cache
:
&
ResourceCache
gpu_cache
:
&
mut
GpuCache
deferred_resolves
:
&
mut
FrameVec
<
DeferredResolve
>
)
-
>
CacheItem
{
match
resource_cache
.
get_image_properties
(
request
.
key
)
{
Some
(
image_properties
)
=
>
{
match
image_properties
.
external_image
{
Some
(
external_image
)
=
>
{
let
cache_handle
=
gpu_cache
.
push_deferred_per_frame_blocks
(
BLOCKS_PER_UV_RECT
)
;
let
deferred_resolve_index
=
DeferredResolveIndex
(
deferred_resolves
.
len
(
)
as
u32
)
;
let
image_buffer_kind
=
match
external_image
.
image_type
{
ExternalImageType
:
:
TextureHandle
(
target
)
=
>
{
target
}
ExternalImageType
:
:
Buffer
=
>
{
panic
!
(
"
Unexpected
non
-
texture
handle
type
"
)
;
}
}
;
let
cache_item
=
CacheItem
{
texture_id
:
TextureSource
:
:
External
(
TextureSourceExternal
{
index
:
deferred_resolve_index
kind
:
image_buffer_kind
normalized_uvs
:
external_image
.
normalized_uvs
}
)
uv_rect_handle
:
cache_handle
uv_rect
:
DeviceIntRect
:
:
from_size
(
image_properties
.
descriptor
.
size
)
user_data
:
[
0
.
0
;
4
]
}
;
deferred_resolves
.
push
(
DeferredResolve
{
image_properties
address
:
gpu_cache
.
get_address
(
&
cache_handle
)
rendering
:
request
.
rendering
}
)
;
cache_item
}
None
=
>
{
if
let
Ok
(
cache_item
)
=
resource_cache
.
get_cached_image
(
request
)
{
cache_item
}
else
{
CacheItem
:
:
invalid
(
)
}
}
}
}
None
=
>
{
CacheItem
:
:
invalid
(
)
}
}
}
pub
fn
resolve_cached_render_task
(
handle
:
&
RenderTaskCacheEntryHandle
resource_cache
:
&
ResourceCache
)
-
>
CacheItem
{
let
rt_cache_entry
=
resource_cache
.
get_cached_render_task
(
&
handle
)
;
resource_cache
.
get_texture_cache_item
(
&
rt_cache_entry
.
handle
)
}
