use
api
:
:
units
:
:
*
;
use
crate
:
:
debug_colors
;
use
crate
:
:
internal_types
:
:
FastHashMap
;
use
crate
:
:
prim_store
:
:
PrimitiveScratchBuffer
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
invalidation
:
:
{
InvalidationReason
PrimitiveCompareResult
}
;
use
crate
:
:
invalidation
:
:
cached_surface
:
:
{
PrimitiveDescriptor
PrimitiveDependencyIndex
}
;
use
crate
:
:
invalidation
:
:
compare
:
:
{
PrimitiveComparer
PrimitiveComparisonKey
}
;
use
crate
:
:
visibility
:
:
FrameVisibilityContext
;
use
std
:
:
mem
;
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TileNodeKind
{
Leaf
{
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
prev_indices
:
Vec
<
PrimitiveDependencyIndex
>
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
dirty_tracker
:
u64
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
serde
(
skip
)
)
]
frames_since_modified
:
usize
}
Node
{
children
:
Vec
<
TileNode
>
}
}
#
[
derive
(
Copy
Clone
PartialEq
Debug
)
]
enum
TileModification
{
Split
Merge
}
#
[
cfg_attr
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
derive
(
Clone
)
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TileNode
{
pub
kind
:
TileNodeKind
pub
rect
:
PictureBox2D
}
impl
TileNode
{
pub
fn
new_leaf
(
curr_indices
:
Vec
<
PrimitiveDependencyIndex
>
)
-
>
Self
{
TileNode
{
kind
:
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
rect
:
PictureBox2D
:
:
zero
(
)
}
}
pub
fn
draw_debug_rects
(
&
self
pic_to_world_mapper
:
&
SpaceMapper
<
PicturePixel
WorldPixel
>
is_opaque
:
bool
local_valid_rect
:
PictureRect
scratch
:
&
mut
PrimitiveScratchBuffer
global_device_pixel_scale
:
DevicePixelScale
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
.
.
}
=
>
{
let
color
=
if
(
dirty_tracker
&
1
)
!
=
0
{
debug_colors
:
:
RED
}
else
if
is_opaque
{
debug_colors
:
:
GREEN
}
else
{
debug_colors
:
:
YELLOW
}
;
if
let
Some
(
local_rect
)
=
local_valid_rect
.
intersection
(
&
self
.
rect
)
{
let
world_rect
=
pic_to_world_mapper
.
map
(
&
local_rect
)
.
unwrap
(
)
;
let
device_rect
=
world_rect
*
global_device_pixel_scale
;
let
outer_color
=
color
.
scale_alpha
(
0
.
3
)
;
let
inner_color
=
outer_color
.
scale_alpha
(
0
.
5
)
;
scratch
.
push_debug_rect
(
device_rect
.
inflate
(
-
3
.
0
-
3
.
0
)
1
outer_color
inner_color
)
;
}
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
for
child
in
children
.
iter
(
)
{
child
.
draw_debug_rects
(
pic_to_world_mapper
is_opaque
local_valid_rect
scratch
global_device_pixel_scale
)
;
}
}
}
}
fn
get_child_rects
(
rect
:
&
PictureBox2D
result
:
&
mut
[
PictureBox2D
;
4
]
)
{
let
p0
=
rect
.
min
;
let
p1
=
rect
.
max
;
let
pc
=
p0
+
rect
.
size
(
)
*
0
.
5
;
*
result
=
[
PictureBox2D
:
:
new
(
p0
pc
)
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
pc
.
x
p0
.
y
)
PicturePoint
:
:
new
(
p1
.
x
pc
.
y
)
)
PictureBox2D
:
:
new
(
PicturePoint
:
:
new
(
p0
.
x
pc
.
y
)
PicturePoint
:
:
new
(
pc
.
x
p1
.
y
)
)
PictureBox2D
:
:
new
(
pc
p1
)
]
;
}
pub
fn
clear
(
&
mut
self
rect
:
PictureBox2D
)
{
self
.
rect
=
rect
;
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
prev_indices
ref
mut
curr_indices
ref
mut
dirty_tracker
ref
mut
frames_since_modified
}
=
>
{
mem
:
:
swap
(
prev_indices
curr_indices
)
;
curr_indices
.
clear
(
)
;
*
dirty_tracker
=
*
dirty_tracker
<
<
1
;
*
frames_since_modified
+
=
1
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
mut
child_rects
=
[
PictureBox2D
:
:
zero
(
)
;
4
]
;
TileNode
:
:
get_child_rects
(
&
rect
&
mut
child_rects
)
;
assert_eq
!
(
child_rects
.
len
(
)
children
.
len
(
)
)
;
for
(
child
rect
)
in
children
.
iter_mut
(
)
.
zip
(
child_rects
.
iter
(
)
)
{
child
.
clear
(
*
rect
)
;
}
}
}
}
pub
fn
add_prim
(
&
mut
self
index
:
PrimitiveDependencyIndex
prim_rect
:
&
PictureBox2D
)
{
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
curr_indices
.
push
(
index
)
;
}
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
if
child
.
rect
.
intersects
(
prim_rect
)
{
child
.
add_prim
(
index
prim_rect
)
;
}
}
}
}
}
pub
fn
maybe_merge_or_split
(
&
mut
self
level
:
i32
curr_prims
:
&
[
PrimitiveDescriptor
]
max_split_levels
:
i32
)
{
let
mut
tile_mod
=
None
;
fn
get_dirty_frames
(
dirty_tracker
:
u64
frames_since_modified
:
usize
)
-
>
Option
<
u32
>
{
if
frames_since_modified
>
64
{
Some
(
dirty_tracker
.
count_ones
(
)
)
}
else
{
None
}
}
match
self
.
kind
{
TileNodeKind
:
:
Leaf
{
dirty_tracker
frames_since_modified
.
.
}
=
>
{
if
level
<
max_split_levels
{
if
let
Some
(
dirty_frames
)
=
get_dirty_frames
(
dirty_tracker
frames_since_modified
)
{
if
dirty_frames
>
32
{
tile_mod
=
Some
(
TileModification
:
:
Split
)
;
}
}
}
}
TileNodeKind
:
:
Node
{
ref
children
.
.
}
=
>
{
let
mut
static_count
=
0
;
let
mut
changing_count
=
0
;
for
child
in
children
{
if
let
TileNodeKind
:
:
Leaf
{
dirty_tracker
frames_since_modified
.
.
}
=
child
.
kind
{
if
let
Some
(
dirty_frames
)
=
get_dirty_frames
(
dirty_tracker
frames_since_modified
)
{
if
dirty_frames
=
=
0
{
static_count
+
=
1
;
}
else
if
dirty_frames
=
=
64
{
changing_count
+
=
1
;
}
}
}
if
static_count
=
=
4
|
|
changing_count
=
=
4
{
tile_mod
=
Some
(
TileModification
:
:
Merge
)
;
}
}
}
}
match
tile_mod
{
Some
(
TileModification
:
:
Split
)
=
>
{
let
curr_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
only
leaves
can
split
"
)
;
}
TileNodeKind
:
:
Leaf
{
ref
mut
curr_indices
.
.
}
=
>
{
mem
:
:
take
(
curr_indices
)
}
}
;
let
mut
child_rects
=
[
PictureBox2D
:
:
zero
(
)
;
4
]
;
TileNode
:
:
get_child_rects
(
&
self
.
rect
&
mut
child_rects
)
;
let
mut
child_indices
=
[
Vec
:
:
new
(
)
Vec
:
:
new
(
)
Vec
:
:
new
(
)
Vec
:
:
new
(
)
]
;
for
index
in
curr_indices
{
let
prim
=
&
curr_prims
[
index
.
0
as
usize
]
;
for
(
child_rect
indices
)
in
child_rects
.
iter
(
)
.
zip
(
child_indices
.
iter_mut
(
)
)
{
if
prim
.
prim_clip_box
.
intersects
(
child_rect
)
{
indices
.
push
(
index
)
;
}
}
}
let
children
=
child_indices
.
iter_mut
(
)
.
map
(
|
i
|
TileNode
:
:
new_leaf
(
mem
:
:
replace
(
i
Vec
:
:
new
(
)
)
)
)
.
collect
(
)
;
self
.
kind
=
TileNodeKind
:
:
Node
{
children
}
;
}
Some
(
TileModification
:
:
Merge
)
=
>
{
let
merged_indices
=
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
let
mut
merged_indices
=
Vec
:
:
new
(
)
;
for
child
in
children
.
iter
(
)
{
let
child_indices
=
match
child
.
kind
{
TileNodeKind
:
:
Leaf
{
ref
curr_indices
.
.
}
=
>
{
curr_indices
}
TileNodeKind
:
:
Node
{
.
.
}
=
>
{
unreachable
!
(
"
bug
:
child
is
not
a
leaf
"
)
;
}
}
;
merged_indices
.
extend_from_slice
(
child_indices
)
;
}
merged_indices
.
sort
(
)
;
merged_indices
.
dedup
(
)
;
merged_indices
}
TileNodeKind
:
:
Leaf
{
.
.
}
=
>
{
unreachable
!
(
"
bug
-
trying
to
merge
a
leaf
"
)
;
}
}
;
self
.
kind
=
TileNodeKind
:
:
Leaf
{
prev_indices
:
Vec
:
:
new
(
)
curr_indices
:
merged_indices
dirty_tracker
:
0
frames_since_modified
:
0
}
;
}
None
=
>
{
if
let
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
self
.
kind
{
for
child
in
children
.
iter_mut
(
)
{
child
.
maybe_merge_or_split
(
level
+
1
curr_prims
max_split_levels
)
;
}
}
}
}
}
pub
fn
update_dirty_rects
(
&
mut
self
prev_prims
:
&
[
PrimitiveDescriptor
]
curr_prims
:
&
[
PrimitiveDescriptor
]
prim_comparer
:
&
mut
PrimitiveComparer
dirty_rect
:
&
mut
PictureBox2D
compare_cache
:
&
mut
FastHashMap
<
PrimitiveComparisonKey
PrimitiveCompareResult
>
invalidation_reason
:
&
mut
Option
<
InvalidationReason
>
frame_context
:
&
FrameVisibilityContext
)
{
match
self
.
kind
{
TileNodeKind
:
:
Node
{
ref
mut
children
.
.
}
=
>
{
for
child
in
children
.
iter_mut
(
)
{
child
.
update_dirty_rects
(
prev_prims
curr_prims
prim_comparer
dirty_rect
compare_cache
invalidation_reason
frame_context
)
;
}
}
TileNodeKind
:
:
Leaf
{
ref
prev_indices
ref
curr_indices
ref
mut
dirty_tracker
.
.
}
=
>
{
if
prev_indices
.
len
(
)
=
=
curr_indices
.
len
(
)
{
for
(
prev_index
curr_index
)
in
prev_indices
.
iter
(
)
.
zip
(
curr_indices
.
iter
(
)
)
{
let
i0
=
prev_index
.
0
as
usize
;
let
i1
=
curr_index
.
0
as
usize
;
let
key
=
PrimitiveComparisonKey
{
prev_index
:
*
prev_index
curr_index
:
*
curr_index
}
;
let
prim_compare_result
=
*
compare_cache
.
entry
(
key
)
.
or_insert_with
(
|
|
{
let
prev
=
&
prev_prims
[
i0
]
;
let
curr
=
&
curr_prims
[
i1
]
;
prim_comparer
.
compare_prim
(
prev
curr
)
}
)
;
if
prim_compare_result
!
=
PrimitiveCompareResult
:
:
Equal
{
if
invalidation_reason
.
is_none
(
)
{
*
invalidation_reason
=
Some
(
InvalidationReason
:
:
Content
)
;
}
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
break
;
}
}
}
else
{
if
invalidation_reason
.
is_none
(
)
{
*
invalidation_reason
=
Some
(
InvalidationReason
:
:
PrimCount
)
;
}
*
dirty_rect
=
self
.
rect
.
union
(
dirty_rect
)
;
*
dirty_tracker
=
*
dirty_tracker
|
1
;
}
}
}
}
}
