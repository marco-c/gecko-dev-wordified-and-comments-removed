pub
mod
compare
;
pub
mod
quadtree
;
pub
mod
cached_surface
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
spatial_tree
:
:
{
SpatialTree
SpatialNodeIndex
}
;
use
crate
:
:
space
:
:
SpaceMapper
;
use
crate
:
:
util
:
:
MaxRect
;
#
[
derive
(
Clone
)
]
pub
struct
DirtyRegion
{
pub
combined
:
VisRect
pub
visibility_spatial_node
:
SpatialNodeIndex
local_spatial_node
:
SpatialNodeIndex
}
impl
DirtyRegion
{
pub
fn
new
(
visibility_spatial_node
:
SpatialNodeIndex
local_spatial_node
:
SpatialNodeIndex
)
-
>
Self
{
DirtyRegion
{
combined
:
VisRect
:
:
zero
(
)
visibility_spatial_node
local_spatial_node
}
}
pub
fn
reset
(
&
mut
self
visibility_spatial_node
:
SpatialNodeIndex
local_spatial_node
:
SpatialNodeIndex
)
{
self
.
combined
=
VisRect
:
:
zero
(
)
;
self
.
visibility_spatial_node
=
visibility_spatial_node
;
self
.
local_spatial_node
=
local_spatial_node
;
}
pub
fn
add_dirty_region
(
&
mut
self
rect_in_pic_space
:
PictureRect
spatial_tree
:
&
SpatialTree
)
{
let
map_pic_to_raster
=
SpaceMapper
:
:
new_with_target
(
self
.
visibility_spatial_node
self
.
local_spatial_node
VisRect
:
:
max_rect
(
)
spatial_tree
)
;
let
raster_rect
=
map_pic_to_raster
.
map
(
&
rect_in_pic_space
)
.
expect
(
"
bug
"
)
;
self
.
combined
=
self
.
combined
.
union
(
&
raster_rect
)
;
}
}
#
[
derive
(
Debug
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
InvalidationReason
{
BackgroundColor
SurfaceOpacityChanged
NoTexture
NoSurface
PrimCount
Content
CompositorKindChanged
ValidRectChanged
ScaleChanged
SurfaceContentChanged
}
#
[
derive
(
Debug
Copy
Clone
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
repr
(
u8
)
]
pub
enum
PrimitiveCompareResult
{
Equal
Descriptor
Clip
Transform
Image
OpacityBinding
ColorBinding
}
