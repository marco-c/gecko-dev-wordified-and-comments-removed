use
api
:
:
{
BorderRadius
ClipMode
ComplexClipRegion
DeviceIntRect
DevicePixelScale
ImageMask
}
;
use
api
:
:
{
ImageRendering
LayoutRect
LayoutSize
LayoutPoint
LayoutVector2D
}
;
use
api
:
:
{
BoxShadowClipMode
LayoutToWorldScale
PicturePixel
WorldPixel
}
;
use
api
:
:
{
PictureRect
LayoutPixel
WorldPoint
WorldSize
WorldRect
LayoutToWorldTransform
}
;
use
api
:
:
{
ImageKey
}
;
use
app_units
:
:
Au
;
use
border
:
:
{
ensure_no_corner_overlap
BorderRadiusAu
}
;
use
box_shadow
:
:
{
BLUR_SAMPLE_SCALE
BoxShadowClipSource
BoxShadowCacheKey
}
;
use
clip_scroll_tree
:
:
{
ClipScrollTree
ROOT_SPATIAL_NODE_INDEX
SpatialNodeIndex
}
;
use
ellipse
:
:
Ellipse
;
use
gpu_cache
:
:
{
GpuCache
GpuCacheHandle
ToGpuBlocks
}
;
use
gpu_types
:
:
{
BoxShadowStretchMode
}
;
use
image
:
:
{
self
Repetition
}
;
use
intern
;
use
prim_store
:
:
{
ClipData
ImageMaskData
SpaceMapper
VisibleMaskImageTile
}
;
use
prim_store
:
:
{
PointKey
SizeKey
RectangleKey
}
;
use
render_task
:
:
to_cache_size
;
use
resource_cache
:
:
{
ImageRequest
ResourceCache
}
;
use
std
:
:
{
cmp
u32
}
;
use
util
:
:
{
extract_inner_rect_safe
project_rect
ScaleOffset
}
;
pub
use
intern_types
:
:
clip
:
:
Store
as
ClipDataStore
;
use
intern_types
:
:
clip
:
:
Handle
as
ClipDataHandle
;
#
[
derive
(
Debug
)
]
enum
ClipResult
{
Accept
Reject
Partial
}
#
[
derive
(
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
ClipNode
{
pub
item
:
ClipItem
pub
gpu_cache_handle
:
GpuCacheHandle
}
impl
From
<
ClipItemKey
>
for
ClipNode
{
fn
from
(
item
:
ClipItemKey
)
-
>
Self
{
let
item
=
match
item
{
ClipItemKey
:
:
Rectangle
(
size
mode
)
=
>
{
ClipItem
:
:
Rectangle
(
size
.
into
(
)
mode
)
}
ClipItemKey
:
:
RoundedRectangle
(
size
radius
mode
)
=
>
{
ClipItem
:
:
RoundedRectangle
(
size
.
into
(
)
radius
.
into
(
)
mode
)
}
ClipItemKey
:
:
ImageMask
(
size
image
repeat
)
=
>
{
ClipItem
:
:
Image
{
image
size
:
size
.
into
(
)
repeat
}
}
ClipItemKey
:
:
BoxShadow
(
shadow_rect_fract_offset
shadow_rect_size
shadow_radius
prim_shadow_rect
blur_radius
clip_mode
)
=
>
{
ClipItem
:
:
new_box_shadow
(
shadow_rect_fract_offset
.
into
(
)
shadow_rect_size
.
into
(
)
shadow_radius
.
into
(
)
prim_shadow_rect
.
into
(
)
blur_radius
.
to_f32_px
(
)
clip_mode
)
}
}
;
ClipNode
{
item
gpu_cache_handle
:
GpuCacheHandle
:
:
new
(
)
}
}
}
bitflags
!
{
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
MallocSizeOf
)
]
pub
struct
ClipNodeFlags
:
u8
{
const
SAME_SPATIAL_NODE
=
0x1
;
const
SAME_COORD_SYSTEM
=
0x2
;
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
MallocSizeOf
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
ClipChainId
(
pub
u32
)
;
impl
ClipChainId
{
pub
const
NONE
:
Self
=
ClipChainId
(
u32
:
:
MAX
)
;
pub
const
INVALID
:
Self
=
ClipChainId
(
0xDEADBEEF
)
;
}
#
[
derive
(
Clone
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
ClipChainNode
{
pub
handle
:
ClipDataHandle
pub
local_pos
:
LayoutPoint
pub
spatial_node_index
:
SpatialNodeIndex
pub
parent_clip_chain_id
:
ClipChainId
}
#
[
derive
(
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ClipNodeInstance
{
pub
handle
:
ClipDataHandle
pub
flags
:
ClipNodeFlags
pub
spatial_node_index
:
SpatialNodeIndex
pub
local_pos
:
LayoutPoint
pub
visible_tiles
:
Option
<
Vec
<
VisibleMaskImageTile
>
>
}
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
ClipNodeRange
{
pub
first
:
u32
pub
count
:
u32
}
#
[
derive
(
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
enum
ClipSpaceConversion
{
Local
ScaleOffset
(
ScaleOffset
)
Transform
(
LayoutToWorldTransform
)
}
#
[
derive
(
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
struct
ClipNodeInfo
{
conversion
:
ClipSpaceConversion
handle
:
ClipDataHandle
local_pos
:
LayoutPoint
spatial_node_index
:
SpatialNodeIndex
}
impl
ClipNodeInfo
{
fn
create_instance
(
&
self
node
:
&
ClipNode
clipped_rect
:
&
LayoutRect
gpu_cache
:
&
mut
GpuCache
resource_cache
:
&
mut
ResourceCache
)
-
>
ClipNodeInstance
{
let
flags
=
match
self
.
conversion
{
ClipSpaceConversion
:
:
Local
=
>
{
ClipNodeFlags
:
:
SAME_SPATIAL_NODE
|
ClipNodeFlags
:
:
SAME_COORD_SYSTEM
}
ClipSpaceConversion
:
:
ScaleOffset
(
.
.
)
=
>
{
ClipNodeFlags
:
:
SAME_COORD_SYSTEM
}
ClipSpaceConversion
:
:
Transform
(
.
.
)
=
>
{
ClipNodeFlags
:
:
empty
(
)
}
}
;
let
mut
visible_tiles
=
None
;
if
let
ClipItem
:
:
Image
{
size
image
repeat
}
=
node
.
item
{
let
request
=
ImageRequest
{
key
:
image
rendering
:
ImageRendering
:
:
Auto
tile
:
None
}
;
if
let
Some
(
props
)
=
resource_cache
.
get_image_properties
(
image
)
{
if
let
Some
(
tile_size
)
=
props
.
tiling
{
let
mut
mask_tiles
=
Vec
:
:
new
(
)
;
let
mask_rect
=
LayoutRect
:
:
new
(
self
.
local_pos
size
)
;
let
device_image_size
=
props
.
descriptor
.
size
;
let
visible_rect
=
if
repeat
{
*
clipped_rect
}
else
{
clipped_rect
.
intersection
(
&
mask_rect
)
.
unwrap
(
)
}
;
let
repetitions
=
image
:
:
repetitions
(
&
mask_rect
&
visible_rect
size
)
;
for
Repetition
{
origin
.
.
}
in
repetitions
{
let
image_rect
=
LayoutRect
{
origin
size
}
;
let
tiles
=
image
:
:
tiles
(
&
image_rect
&
visible_rect
&
device_image_size
tile_size
as
i32
)
;
for
tile
in
tiles
{
resource_cache
.
request_image
(
request
.
with_tile
(
tile
.
offset
)
gpu_cache
)
;
mask_tiles
.
push
(
VisibleMaskImageTile
{
tile_offset
:
tile
.
offset
tile_rect
:
tile
.
rect
}
)
;
}
}
visible_tiles
=
Some
(
mask_tiles
)
;
}
else
{
resource_cache
.
request_image
(
request
gpu_cache
)
;
}
}
}
ClipNodeInstance
{
handle
:
self
.
handle
flags
spatial_node_index
:
self
.
spatial_node_index
local_pos
:
self
.
local_pos
visible_tiles
}
}
}
impl
ClipNode
{
pub
fn
update
(
&
mut
self
gpu_cache
:
&
mut
GpuCache
device_pixel_scale
:
DevicePixelScale
)
{
match
self
.
item
{
ClipItem
:
:
Image
{
size
.
.
}
=
>
{
if
let
Some
(
request
)
=
gpu_cache
.
request
(
&
mut
self
.
gpu_cache_handle
)
{
let
data
=
ImageMaskData
{
local_mask_size
:
size
}
;
data
.
write_gpu_blocks
(
request
)
;
}
}
ClipItem
:
:
BoxShadow
(
ref
mut
info
)
=
>
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
gpu_cache_handle
)
{
request
.
push
(
[
info
.
original_alloc_size
.
width
info
.
original_alloc_size
.
height
info
.
clip_mode
as
i32
as
f32
0
.
0
]
)
;
request
.
push
(
[
info
.
stretch_mode_x
as
i32
as
f32
info
.
stretch_mode_y
as
i32
as
f32
0
.
0
0
.
0
]
)
;
request
.
push
(
info
.
prim_shadow_rect
)
;
}
let
blur_radius_dp
=
info
.
blur_radius
*
0
.
5
;
let
content_scale
=
LayoutToWorldScale
:
:
new
(
1
.
0
)
*
device_pixel_scale
;
let
cache_size
=
to_cache_size
(
info
.
shadow_rect_alloc_size
*
content_scale
)
;
let
bs_cache_key
=
BoxShadowCacheKey
{
blur_radius_dp
:
(
blur_radius_dp
*
content_scale
.
0
)
.
round
(
)
as
i32
clip_mode
:
info
.
clip_mode
original_alloc_size
:
(
info
.
original_alloc_size
*
content_scale
)
.
round
(
)
.
to_i32
(
)
br_top_left
:
(
info
.
shadow_radius
.
top_left
*
content_scale
)
.
round
(
)
.
to_i32
(
)
br_top_right
:
(
info
.
shadow_radius
.
top_right
*
content_scale
)
.
round
(
)
.
to_i32
(
)
br_bottom_right
:
(
info
.
shadow_radius
.
bottom_right
*
content_scale
)
.
round
(
)
.
to_i32
(
)
br_bottom_left
:
(
info
.
shadow_radius
.
bottom_left
*
content_scale
)
.
round
(
)
.
to_i32
(
)
}
;
info
.
cache_key
=
Some
(
(
cache_size
bs_cache_key
)
)
;
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
info
.
clip_data_handle
)
{
let
data
=
ClipData
:
:
rounded_rect
(
info
.
minimal_shadow_rect
.
size
&
info
.
shadow_radius
ClipMode
:
:
Clip
)
;
data
.
write
(
&
mut
request
)
;
}
}
ClipItem
:
:
Rectangle
(
size
mode
)
=
>
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
gpu_cache_handle
)
{
let
data
=
ClipData
:
:
uniform
(
size
0
.
0
mode
)
;
data
.
write
(
&
mut
request
)
;
}
}
ClipItem
:
:
RoundedRectangle
(
size
ref
radius
mode
)
=
>
{
if
let
Some
(
mut
request
)
=
gpu_cache
.
request
(
&
mut
self
.
gpu_cache_handle
)
{
let
data
=
ClipData
:
:
rounded_rect
(
size
radius
mode
)
;
data
.
write
(
&
mut
request
)
;
}
}
}
}
}
#
[
derive
(
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
ClipStore
{
pub
clip_chain_nodes
:
Vec
<
ClipChainNode
>
clip_node_instances
:
Vec
<
ClipNodeInstance
>
clip_node_info
:
Vec
<
ClipNodeInfo
>
}
#
[
derive
(
Debug
)
]
pub
struct
ClipChainInstance
{
pub
clips_range
:
ClipNodeRange
pub
local_clip_rect
:
LayoutRect
pub
has_non_local_clips
:
bool
pub
needs_mask
:
bool
pub
pic_clip_rect
:
PictureRect
}
impl
ClipChainInstance
{
pub
fn
empty
(
)
-
>
Self
{
ClipChainInstance
{
clips_range
:
ClipNodeRange
{
first
:
0
count
:
0
}
local_clip_rect
:
LayoutRect
:
:
zero
(
)
has_non_local_clips
:
false
needs_mask
:
false
pic_clip_rect
:
PictureRect
:
:
zero
(
)
}
}
}
pub
struct
ClipChainStack
{
pub
stack
:
Vec
<
Vec
<
ClipChainId
>
>
}
impl
ClipChainStack
{
pub
fn
new
(
)
-
>
Self
{
ClipChainStack
{
stack
:
vec
!
[
vec
!
[
]
]
}
}
pub
fn
push_clip
(
&
mut
self
clip_chain_id
:
ClipChainId
)
{
self
.
stack
.
last_mut
(
)
.
unwrap
(
)
.
push
(
clip_chain_id
)
;
}
pub
fn
pop_clip
(
&
mut
self
)
{
self
.
stack
.
last_mut
(
)
.
unwrap
(
)
.
pop
(
)
.
unwrap
(
)
;
}
pub
fn
push_surface
(
&
mut
self
)
{
self
.
stack
.
push
(
Vec
:
:
new
(
)
)
;
}
pub
fn
pop_surface
(
&
mut
self
)
{
self
.
stack
.
pop
(
)
.
unwrap
(
)
;
}
pub
fn
current_clips
(
&
self
)
-
>
&
[
ClipChainId
]
{
self
.
stack
.
last
(
)
.
unwrap
(
)
}
}
impl
ClipStore
{
pub
fn
new
(
)
-
>
Self
{
ClipStore
{
clip_chain_nodes
:
Vec
:
:
new
(
)
clip_node_instances
:
Vec
:
:
new
(
)
clip_node_info
:
Vec
:
:
new
(
)
}
}
pub
fn
get_clip_chain
(
&
self
clip_chain_id
:
ClipChainId
)
-
>
&
ClipChainNode
{
&
self
.
clip_chain_nodes
[
clip_chain_id
.
0
as
usize
]
}
pub
fn
add_clip_chain_node
(
&
mut
self
handle
:
ClipDataHandle
local_pos
:
LayoutPoint
spatial_node_index
:
SpatialNodeIndex
parent_clip_chain_id
:
ClipChainId
)
-
>
ClipChainId
{
let
id
=
ClipChainId
(
self
.
clip_chain_nodes
.
len
(
)
as
u32
)
;
self
.
clip_chain_nodes
.
push
(
ClipChainNode
{
handle
spatial_node_index
local_pos
parent_clip_chain_id
}
)
;
id
}
pub
fn
get_instance_from_range
(
&
self
node_range
:
&
ClipNodeRange
index
:
u32
)
-
>
&
ClipNodeInstance
{
&
self
.
clip_node_instances
[
(
node_range
.
first
+
index
)
as
usize
]
}
pub
fn
build_clip_chain_instance
(
&
mut
self
clip_chains
:
&
[
ClipChainId
]
local_prim_rect
:
LayoutRect
local_prim_clip_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
prim_to_pic_mapper
:
&
SpaceMapper
<
LayoutPixel
PicturePixel
>
pic_to_world_mapper
:
&
SpaceMapper
<
PicturePixel
WorldPixel
>
clip_scroll_tree
:
&
ClipScrollTree
gpu_cache
:
&
mut
GpuCache
resource_cache
:
&
mut
ResourceCache
device_pixel_scale
:
DevicePixelScale
world_rect
:
&
WorldRect
clip_data_store
:
&
mut
ClipDataStore
)
-
>
Option
<
ClipChainInstance
>
{
let
mut
local_clip_rect
=
local_prim_clip_rect
;
self
.
clip_node_info
.
clear
(
)
;
for
clip_chain_root
in
clip_chains
{
let
mut
current_clip_chain_id
=
*
clip_chain_root
;
while
current_clip_chain_id
!
=
ClipChainId
:
:
NONE
{
let
clip_chain_node
=
&
self
.
clip_chain_nodes
[
current_clip_chain_id
.
0
as
usize
]
;
if
!
add_clip_node_to_current_chain
(
clip_chain_node
spatial_node_index
&
mut
local_clip_rect
&
mut
self
.
clip_node_info
clip_data_store
clip_scroll_tree
)
{
return
None
;
}
current_clip_chain_id
=
clip_chain_node
.
parent_clip_chain_id
;
}
}
let
local_bounding_rect
=
local_prim_rect
.
intersection
(
&
local_clip_rect
)
?
;
let
pic_clip_rect
=
prim_to_pic_mapper
.
map
(
&
local_bounding_rect
)
?
;
let
world_clip_rect
=
pic_to_world_mapper
.
map
(
&
pic_clip_rect
)
?
;
let
first_clip_node_index
=
self
.
clip_node_instances
.
len
(
)
as
u32
;
let
mut
has_non_local_clips
=
false
;
let
mut
needs_mask
=
false
;
for
node_info
in
self
.
clip_node_info
.
drain
(
.
.
)
{
let
node
=
&
mut
clip_data_store
[
node_info
.
handle
]
;
let
clip_result
=
match
node_info
.
conversion
{
ClipSpaceConversion
:
:
Local
=
>
{
node
.
item
.
get_clip_result
(
node_info
.
local_pos
&
local_bounding_rect
)
}
ClipSpaceConversion
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
has_non_local_clips
=
true
;
node
.
item
.
get_clip_result
(
node_info
.
local_pos
&
scale_offset
.
unmap_rect
(
&
local_bounding_rect
)
)
}
ClipSpaceConversion
:
:
Transform
(
ref
transform
)
=
>
{
has_non_local_clips
=
true
;
node
.
item
.
get_clip_result_complex
(
node_info
.
local_pos
transform
&
world_clip_rect
world_rect
)
}
}
;
match
clip_result
{
ClipResult
:
:
Accept
=
>
{
}
ClipResult
:
:
Reject
=
>
{
return
None
;
}
ClipResult
:
:
Partial
=
>
{
node
.
update
(
gpu_cache
device_pixel_scale
)
;
let
instance
=
node_info
.
create_instance
(
node
&
local_bounding_rect
gpu_cache
resource_cache
)
;
needs_mask
|
=
match
node
.
item
{
ClipItem
:
:
Rectangle
(
_
ClipMode
:
:
ClipOut
)
|
ClipItem
:
:
RoundedRectangle
(
.
.
)
|
ClipItem
:
:
Image
{
.
.
}
|
ClipItem
:
:
BoxShadow
(
.
.
)
=
>
{
true
}
ClipItem
:
:
Rectangle
(
_
ClipMode
:
:
Clip
)
=
>
{
!
instance
.
flags
.
contains
(
ClipNodeFlags
:
:
SAME_COORD_SYSTEM
)
}
}
;
self
.
clip_node_instances
.
push
(
instance
)
;
}
}
}
let
clips_range
=
ClipNodeRange
{
first
:
first_clip_node_index
count
:
self
.
clip_node_instances
.
len
(
)
as
u32
-
first_clip_node_index
}
;
Some
(
ClipChainInstance
{
clips_range
has_non_local_clips
local_clip_rect
pic_clip_rect
needs_mask
}
)
}
pub
fn
clear_old_instances
(
&
mut
self
)
{
self
.
clip_node_instances
.
clear
(
)
;
}
}
pub
struct
ComplexTranslateIter
<
I
>
{
source
:
I
offset
:
LayoutVector2D
}
impl
<
I
:
Iterator
<
Item
=
ComplexClipRegion
>
>
Iterator
for
ComplexTranslateIter
<
I
>
{
type
Item
=
ComplexClipRegion
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
self
.
source
.
next
(
)
.
map
(
|
mut
complex
|
{
complex
.
rect
=
complex
.
rect
.
translate
(
&
self
.
offset
)
;
complex
}
)
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ClipRegion
<
I
>
{
pub
main
:
LayoutRect
pub
image_mask
:
Option
<
ImageMask
>
pub
complex_clips
:
I
}
impl
<
J
>
ClipRegion
<
ComplexTranslateIter
<
J
>
>
{
pub
fn
create_for_clip_node
(
rect
:
LayoutRect
complex_clips
:
J
mut
image_mask
:
Option
<
ImageMask
>
reference_frame_relative_offset
:
&
LayoutVector2D
)
-
>
Self
where
J
:
Iterator
<
Item
=
ComplexClipRegion
>
{
if
let
Some
(
ref
mut
image_mask
)
=
image_mask
{
image_mask
.
rect
=
image_mask
.
rect
.
translate
(
reference_frame_relative_offset
)
;
}
ClipRegion
{
main
:
rect
.
translate
(
reference_frame_relative_offset
)
image_mask
complex_clips
:
ComplexTranslateIter
{
source
:
complex_clips
offset
:
*
reference_frame_relative_offset
}
}
}
}
impl
ClipRegion
<
Option
<
ComplexClipRegion
>
>
{
pub
fn
create_for_clip_node_with_local_clip
(
local_clip
:
&
LayoutRect
reference_frame_relative_offset
:
&
LayoutVector2D
)
-
>
Self
{
ClipRegion
{
main
:
local_clip
.
translate
(
reference_frame_relative_offset
)
image_mask
:
None
complex_clips
:
None
}
}
}
#
[
derive
(
Debug
Clone
Eq
MallocSizeOf
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ClipItemKey
{
Rectangle
(
SizeKey
ClipMode
)
RoundedRectangle
(
SizeKey
BorderRadiusAu
ClipMode
)
ImageMask
(
SizeKey
ImageKey
bool
)
BoxShadow
(
PointKey
SizeKey
BorderRadiusAu
RectangleKey
Au
BoxShadowClipMode
)
}
impl
ClipItemKey
{
pub
fn
rectangle
(
size
:
LayoutSize
mode
:
ClipMode
)
-
>
Self
{
ClipItemKey
:
:
Rectangle
(
size
.
into
(
)
mode
)
}
pub
fn
rounded_rect
(
size
:
LayoutSize
mut
radii
:
BorderRadius
mode
:
ClipMode
)
-
>
Self
{
if
radii
.
is_zero
(
)
{
ClipItemKey
:
:
rectangle
(
size
mode
)
}
else
{
ensure_no_corner_overlap
(
&
mut
radii
size
)
;
ClipItemKey
:
:
RoundedRectangle
(
size
.
into
(
)
radii
.
into
(
)
mode
)
}
}
pub
fn
image_mask
(
image_mask
:
&
ImageMask
)
-
>
Self
{
ClipItemKey
:
:
ImageMask
(
image_mask
.
rect
.
size
.
into
(
)
image_mask
.
image
image_mask
.
repeat
)
}
pub
fn
box_shadow
(
shadow_rect
:
LayoutRect
shadow_radius
:
BorderRadius
prim_shadow_rect
:
LayoutRect
blur_radius
:
f32
clip_mode
:
BoxShadowClipMode
)
-
>
Self
{
let
fract_offset
=
LayoutPoint
:
:
new
(
shadow_rect
.
origin
.
x
.
fract
(
)
.
abs
(
)
shadow_rect
.
origin
.
y
.
fract
(
)
.
abs
(
)
)
;
ClipItemKey
:
:
BoxShadow
(
fract_offset
.
into
(
)
shadow_rect
.
size
.
into
(
)
shadow_radius
.
into
(
)
prim_shadow_rect
.
into
(
)
Au
:
:
from_f32_px
(
blur_radius
)
clip_mode
)
}
}
impl
intern
:
:
InternDebug
for
ClipItemKey
{
}
#
[
derive
(
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
ClipItem
{
Rectangle
(
LayoutSize
ClipMode
)
RoundedRectangle
(
LayoutSize
BorderRadius
ClipMode
)
Image
{
image
:
ImageKey
size
:
LayoutSize
repeat
:
bool
}
BoxShadow
(
BoxShadowClipSource
)
}
fn
compute_box_shadow_parameters
(
shadow_rect_fract_offset
:
LayoutPoint
shadow_rect_size
:
LayoutSize
mut
shadow_radius
:
BorderRadius
prim_shadow_rect
:
LayoutRect
blur_radius
:
f32
clip_mode
:
BoxShadowClipMode
)
-
>
BoxShadowClipSource
{
ensure_no_corner_overlap
(
&
mut
shadow_radius
shadow_rect_size
)
;
let
fract_size
=
LayoutSize
:
:
new
(
shadow_rect_size
.
width
.
fract
(
)
.
abs
(
)
shadow_rect_size
.
height
.
fract
(
)
.
abs
(
)
)
;
let
max_corner_width
=
shadow_radius
.
top_left
.
width
.
max
(
shadow_radius
.
bottom_left
.
width
)
.
max
(
shadow_radius
.
top_right
.
width
)
.
max
(
shadow_radius
.
bottom_right
.
width
)
;
let
max_corner_height
=
shadow_radius
.
top_left
.
height
.
max
(
shadow_radius
.
bottom_left
.
height
)
.
max
(
shadow_radius
.
top_right
.
height
)
.
max
(
shadow_radius
.
bottom_right
.
height
)
;
let
blur_region
=
(
BLUR_SAMPLE_SCALE
*
blur_radius
)
.
ceil
(
)
;
let
used_corner_width
=
max_corner_width
.
max
(
blur_region
)
;
let
used_corner_height
=
max_corner_height
.
max
(
blur_region
)
;
let
min_shadow_rect_size
=
LayoutSize
:
:
new
(
2
.
0
*
used_corner_width
+
blur_region
2
.
0
*
used_corner_height
+
blur_region
)
;
let
mut
minimal_shadow_rect
=
LayoutRect
:
:
new
(
LayoutPoint
:
:
new
(
blur_region
+
shadow_rect_fract_offset
.
x
blur_region
+
shadow_rect_fract_offset
.
y
)
LayoutSize
:
:
new
(
min_shadow_rect_size
.
width
+
fract_size
.
width
min_shadow_rect_size
.
height
+
fract_size
.
height
)
)
;
let
mut
stretch_mode_x
=
BoxShadowStretchMode
:
:
Stretch
;
if
shadow_rect_size
.
width
<
minimal_shadow_rect
.
size
.
width
{
minimal_shadow_rect
.
size
.
width
=
shadow_rect_size
.
width
;
stretch_mode_x
=
BoxShadowStretchMode
:
:
Simple
;
}
let
mut
stretch_mode_y
=
BoxShadowStretchMode
:
:
Stretch
;
if
shadow_rect_size
.
height
<
minimal_shadow_rect
.
size
.
height
{
minimal_shadow_rect
.
size
.
height
=
shadow_rect_size
.
height
;
stretch_mode_y
=
BoxShadowStretchMode
:
:
Simple
;
}
let
shadow_rect_alloc_size
=
LayoutSize
:
:
new
(
2
.
0
*
blur_region
+
minimal_shadow_rect
.
size
.
width
.
ceil
(
)
2
.
0
*
blur_region
+
minimal_shadow_rect
.
size
.
height
.
ceil
(
)
)
;
BoxShadowClipSource
{
original_alloc_size
:
shadow_rect_alloc_size
shadow_rect_alloc_size
shadow_radius
prim_shadow_rect
blur_radius
clip_mode
stretch_mode_x
stretch_mode_y
cache_handle
:
None
cache_key
:
None
clip_data_handle
:
GpuCacheHandle
:
:
new
(
)
minimal_shadow_rect
}
}
impl
ClipItem
{
pub
fn
new_box_shadow
(
shadow_rect_fract_offset
:
LayoutPoint
shadow_rect_size
:
LayoutSize
mut
shadow_radius
:
BorderRadius
prim_shadow_rect
:
LayoutRect
blur_radius
:
f32
clip_mode
:
BoxShadowClipMode
)
-
>
Self
{
let
mut
source
=
compute_box_shadow_parameters
(
shadow_rect_fract_offset
shadow_rect_size
shadow_radius
prim_shadow_rect
blur_radius
clip_mode
)
;
fn
needed_downscaling
(
source
:
&
BoxShadowClipSource
)
-
>
Option
<
f32
>
{
const
MAX_SIZE
:
f32
=
2048
.
;
let
max_dimension
=
source
.
shadow_rect_alloc_size
.
width
.
max
(
source
.
shadow_rect_alloc_size
.
height
)
;
if
max_dimension
>
MAX_SIZE
{
Some
(
MAX_SIZE
/
max_dimension
)
}
else
{
None
}
}
if
let
Some
(
downscale
)
=
needed_downscaling
(
&
source
)
{
shadow_radius
.
bottom_left
.
height
*
=
downscale
;
shadow_radius
.
bottom_left
.
width
*
=
downscale
;
shadow_radius
.
bottom_right
.
height
*
=
downscale
;
shadow_radius
.
bottom_right
.
width
*
=
downscale
;
shadow_radius
.
top_left
.
height
*
=
downscale
;
shadow_radius
.
top_left
.
width
*
=
downscale
;
shadow_radius
.
top_right
.
height
*
=
downscale
;
shadow_radius
.
top_right
.
width
*
=
downscale
;
let
original_alloc_size
=
source
.
shadow_rect_alloc_size
;
source
=
compute_box_shadow_parameters
(
shadow_rect_fract_offset
*
downscale
shadow_rect_size
*
downscale
shadow_radius
prim_shadow_rect
blur_radius
*
downscale
clip_mode
)
;
source
.
original_alloc_size
=
original_alloc_size
;
}
ClipItem
:
:
BoxShadow
(
source
)
}
pub
fn
get_local_clip_rect
(
&
self
local_pos
:
LayoutPoint
)
-
>
Option
<
LayoutRect
>
{
let
size
=
match
*
self
{
ClipItem
:
:
Rectangle
(
size
ClipMode
:
:
Clip
)
=
>
Some
(
size
)
ClipItem
:
:
Rectangle
(
_
ClipMode
:
:
ClipOut
)
=
>
None
ClipItem
:
:
RoundedRectangle
(
size
_
ClipMode
:
:
Clip
)
=
>
Some
(
size
)
ClipItem
:
:
RoundedRectangle
(
_
_
ClipMode
:
:
ClipOut
)
=
>
None
ClipItem
:
:
Image
{
repeat
size
.
.
}
=
>
{
if
repeat
{
None
}
else
{
Some
(
size
)
}
}
ClipItem
:
:
BoxShadow
(
.
.
)
=
>
None
}
;
size
.
map
(
|
size
|
{
LayoutRect
:
:
new
(
local_pos
size
)
}
)
}
fn
get_clip_result_complex
(
&
self
local_pos
:
LayoutPoint
transform
:
&
LayoutToWorldTransform
prim_world_rect
:
&
WorldRect
world_rect
:
&
WorldRect
)
-
>
ClipResult
{
let
(
clip_rect
inner_rect
)
=
match
*
self
{
ClipItem
:
:
Rectangle
(
size
ClipMode
:
:
Clip
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
(
clip_rect
Some
(
clip_rect
)
)
}
ClipItem
:
:
RoundedRectangle
(
size
ref
radius
ClipMode
:
:
Clip
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
let
inner_clip_rect
=
extract_inner_rect_safe
(
&
clip_rect
radius
)
;
(
clip_rect
inner_clip_rect
)
}
ClipItem
:
:
Rectangle
(
_
ClipMode
:
:
ClipOut
)
|
ClipItem
:
:
RoundedRectangle
(
_
_
ClipMode
:
:
ClipOut
)
|
ClipItem
:
:
Image
{
.
.
}
|
ClipItem
:
:
BoxShadow
(
.
.
)
=
>
{
return
ClipResult
:
:
Partial
}
}
;
let
inner_clip_rect
=
inner_rect
.
and_then
(
|
ref
inner_rect
|
{
project_inner_rect
(
transform
inner_rect
)
}
)
;
if
let
Some
(
inner_clip_rect
)
=
inner_clip_rect
{
if
inner_clip_rect
.
contains_rect
(
prim_world_rect
)
{
return
ClipResult
:
:
Accept
;
}
}
let
outer_clip_rect
=
match
project_rect
(
transform
&
clip_rect
world_rect
)
{
Some
(
outer_clip_rect
)
=
>
outer_clip_rect
None
=
>
return
ClipResult
:
:
Partial
}
;
match
outer_clip_rect
.
intersection
(
prim_world_rect
)
{
Some
(
.
.
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Reject
}
}
}
fn
get_clip_result
(
&
self
local_pos
:
LayoutPoint
prim_rect
:
&
LayoutRect
)
-
>
ClipResult
{
match
*
self
{
ClipItem
:
:
Rectangle
(
size
ClipMode
:
:
Clip
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
if
clip_rect
.
contains_rect
(
prim_rect
)
{
return
ClipResult
:
:
Accept
;
}
match
clip_rect
.
intersection
(
prim_rect
)
{
Some
(
.
.
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Reject
}
}
}
ClipItem
:
:
Rectangle
(
size
ClipMode
:
:
ClipOut
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
if
clip_rect
.
contains_rect
(
prim_rect
)
{
return
ClipResult
:
:
Reject
;
}
match
clip_rect
.
intersection
(
prim_rect
)
{
Some
(
_
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Accept
}
}
}
ClipItem
:
:
RoundedRectangle
(
size
ref
radius
ClipMode
:
:
Clip
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
let
inner_clip_rect
=
extract_inner_rect_safe
(
&
clip_rect
radius
)
;
if
let
Some
(
inner_clip_rect
)
=
inner_clip_rect
{
if
inner_clip_rect
.
contains_rect
(
prim_rect
)
{
return
ClipResult
:
:
Accept
;
}
}
match
clip_rect
.
intersection
(
prim_rect
)
{
Some
(
.
.
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Reject
}
}
}
ClipItem
:
:
RoundedRectangle
(
size
ref
radius
ClipMode
:
:
ClipOut
)
=
>
{
let
clip_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
let
inner_clip_rect
=
extract_inner_rect_safe
(
&
clip_rect
radius
)
;
if
let
Some
(
inner_clip_rect
)
=
inner_clip_rect
{
if
inner_clip_rect
.
contains_rect
(
prim_rect
)
{
return
ClipResult
:
:
Reject
;
}
}
match
clip_rect
.
intersection
(
prim_rect
)
{
Some
(
_
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Accept
}
}
}
ClipItem
:
:
Image
{
size
repeat
.
.
}
=
>
{
if
repeat
{
ClipResult
:
:
Partial
}
else
{
let
mask_rect
=
LayoutRect
:
:
new
(
local_pos
size
)
;
match
mask_rect
.
intersection
(
prim_rect
)
{
Some
(
.
.
)
=
>
{
ClipResult
:
:
Partial
}
None
=
>
{
ClipResult
:
:
Reject
}
}
}
}
ClipItem
:
:
BoxShadow
(
.
.
)
=
>
{
ClipResult
:
:
Partial
}
}
}
}
#
[
derive
(
Clone
Debug
PartialEq
)
]
pub
struct
Geometry
{
pub
local_rect
:
LayoutRect
pub
device_rect
:
DeviceIntRect
}
impl
From
<
LayoutRect
>
for
Geometry
{
fn
from
(
local_rect
:
LayoutRect
)
-
>
Self
{
Geometry
{
local_rect
device_rect
:
DeviceIntRect
:
:
zero
(
)
}
}
}
pub
fn
rounded_rectangle_contains_point
(
point
:
&
LayoutPoint
rect
:
&
LayoutRect
radii
:
&
BorderRadius
)
-
>
bool
{
if
!
rect
.
contains
(
point
)
{
return
false
;
}
let
top_left_center
=
rect
.
origin
+
radii
.
top_left
.
to_vector
(
)
;
if
top_left_center
.
x
>
point
.
x
&
&
top_left_center
.
y
>
point
.
y
&
&
!
Ellipse
:
:
new
(
radii
.
top_left
)
.
contains
(
*
point
-
top_left_center
.
to_vector
(
)
)
{
return
false
;
}
let
bottom_right_center
=
rect
.
bottom_right
(
)
-
radii
.
bottom_right
.
to_vector
(
)
;
if
bottom_right_center
.
x
<
point
.
x
&
&
bottom_right_center
.
y
<
point
.
y
&
&
!
Ellipse
:
:
new
(
radii
.
bottom_right
)
.
contains
(
*
point
-
bottom_right_center
.
to_vector
(
)
)
{
return
false
;
}
let
top_right_center
=
rect
.
top_right
(
)
+
LayoutVector2D
:
:
new
(
-
radii
.
top_right
.
width
radii
.
top_right
.
height
)
;
if
top_right_center
.
x
<
point
.
x
&
&
top_right_center
.
y
>
point
.
y
&
&
!
Ellipse
:
:
new
(
radii
.
top_right
)
.
contains
(
*
point
-
top_right_center
.
to_vector
(
)
)
{
return
false
;
}
let
bottom_left_center
=
rect
.
bottom_left
(
)
+
LayoutVector2D
:
:
new
(
radii
.
bottom_left
.
width
-
radii
.
bottom_left
.
height
)
;
if
bottom_left_center
.
x
>
point
.
x
&
&
bottom_left_center
.
y
<
point
.
y
&
&
!
Ellipse
:
:
new
(
radii
.
bottom_left
)
.
contains
(
*
point
-
bottom_left_center
.
to_vector
(
)
)
{
return
false
;
}
true
}
pub
fn
project_inner_rect
(
transform
:
&
LayoutToWorldTransform
rect
:
&
LayoutRect
)
-
>
Option
<
WorldRect
>
{
let
points
=
[
transform
.
transform_point2d
(
&
rect
.
origin
)
?
transform
.
transform_point2d
(
&
rect
.
top_right
(
)
)
?
transform
.
transform_point2d
(
&
rect
.
bottom_left
(
)
)
?
transform
.
transform_point2d
(
&
rect
.
bottom_right
(
)
)
?
]
;
let
mut
xs
=
[
points
[
0
]
.
x
points
[
1
]
.
x
points
[
2
]
.
x
points
[
3
]
.
x
]
;
let
mut
ys
=
[
points
[
0
]
.
y
points
[
1
]
.
y
points
[
2
]
.
y
points
[
3
]
.
y
]
;
xs
.
sort_by
(
|
a
b
|
a
.
partial_cmp
(
b
)
.
unwrap_or
(
cmp
:
:
Ordering
:
:
Equal
)
)
;
ys
.
sort_by
(
|
a
b
|
a
.
partial_cmp
(
b
)
.
unwrap_or
(
cmp
:
:
Ordering
:
:
Equal
)
)
;
Some
(
WorldRect
:
:
new
(
WorldPoint
:
:
new
(
xs
[
1
]
ys
[
1
]
)
WorldSize
:
:
new
(
xs
[
2
]
-
xs
[
1
]
ys
[
2
]
-
ys
[
1
]
)
)
)
}
fn
add_clip_node_to_current_chain
(
node
:
&
ClipChainNode
spatial_node_index
:
SpatialNodeIndex
local_clip_rect
:
&
mut
LayoutRect
clip_node_info
:
&
mut
Vec
<
ClipNodeInfo
>
clip_data_store
:
&
ClipDataStore
clip_scroll_tree
:
&
ClipScrollTree
)
-
>
bool
{
let
clip_node
=
&
clip_data_store
[
node
.
handle
]
;
let
clip_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
node
.
spatial_node_index
.
0
as
usize
]
;
let
ref_spatial_node
=
&
clip_scroll_tree
.
spatial_nodes
[
spatial_node_index
.
0
as
usize
]
;
let
conversion
=
if
spatial_node_index
=
=
node
.
spatial_node_index
{
ClipSpaceConversion
:
:
Local
}
else
if
ref_spatial_node
.
coordinate_system_id
=
=
clip_spatial_node
.
coordinate_system_id
{
let
scale_offset
=
ref_spatial_node
.
coordinate_system_relative_scale_offset
.
inverse
(
)
.
accumulate
(
&
clip_spatial_node
.
coordinate_system_relative_scale_offset
)
;
ClipSpaceConversion
:
:
ScaleOffset
(
scale_offset
)
}
else
{
match
clip_scroll_tree
.
get_relative_transform
(
node
.
spatial_node_index
ROOT_SPATIAL_NODE_INDEX
)
{
None
=
>
return
true
Some
(
xf
)
=
>
ClipSpaceConversion
:
:
Transform
(
xf
.
with_destination
:
:
<
WorldPixel
>
(
)
)
}
}
;
if
let
Some
(
clip_rect
)
=
clip_node
.
item
.
get_local_clip_rect
(
node
.
local_pos
)
{
match
conversion
{
ClipSpaceConversion
:
:
Local
=
>
{
*
local_clip_rect
=
match
local_clip_rect
.
intersection
(
&
clip_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
false
}
;
}
ClipSpaceConversion
:
:
ScaleOffset
(
ref
scale_offset
)
=
>
{
let
clip_rect
=
scale_offset
.
map_rect
(
&
clip_rect
)
;
*
local_clip_rect
=
match
local_clip_rect
.
intersection
(
&
clip_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
return
false
}
;
}
ClipSpaceConversion
:
:
Transform
(
.
.
)
=
>
{
}
}
}
clip_node_info
.
push
(
ClipNodeInfo
{
conversion
local_pos
:
node
.
local_pos
handle
:
node
.
handle
spatial_node_index
:
node
.
spatial_node_index
}
)
;
true
}
