#
!
[
deny
(
missing_docs
)
]
use
std
:
:
cell
:
:
Cell
;
use
std
:
:
fmt
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
u32
;
use
time
:
:
precise_time_ns
;
use
crate
:
:
api
:
:
channel
:
:
{
Sender
single_msg_channel
unbounded_channel
}
;
use
crate
:
:
api
:
:
{
ColorF
BuiltDisplayList
IdNamespace
ExternalScrollId
Parameter
BoolParameter
}
;
use
crate
:
:
api
:
:
{
SharedFontInstanceMap
FontKey
FontInstanceKey
NativeFontHandle
}
;
use
crate
:
:
api
:
:
{
BlobImageData
BlobImageKey
ImageData
ImageDescriptor
ImageKey
Epoch
QualitySettings
}
;
use
crate
:
:
api
:
:
{
BlobImageParams
BlobImageRequest
BlobImageResult
AsyncBlobImageRasterizer
BlobImageHandler
}
;
use
crate
:
:
api
:
:
{
DocumentId
PipelineId
PropertyBindingId
PropertyBindingKey
ExternalEvent
}
;
use
crate
:
:
api
:
:
{
HitTestResult
HitTesterRequest
ApiHitTester
PropertyValue
DynamicProperties
}
;
use
crate
:
:
api
:
:
{
ScrollClamping
TileSize
NotificationRequest
DebugFlags
}
;
use
crate
:
:
api
:
:
{
GlyphDimensionRequest
GlyphIndexRequest
GlyphIndex
GlyphDimensions
}
;
use
crate
:
:
api
:
:
{
FontInstanceOptions
FontInstancePlatformOptions
FontVariation
RenderReasons
}
;
use
crate
:
:
api
:
:
DEFAULT_TILE_SIZE
;
use
crate
:
:
api
:
:
units
:
:
*
;
use
crate
:
:
api_resources
:
:
ApiResources
;
use
crate
:
:
scene_builder_thread
:
:
{
SceneBuilderRequest
SceneBuilderResult
}
;
use
crate
:
:
intern
:
:
InterningMemoryReport
;
use
crate
:
:
profiler
:
:
{
self
TransactionProfile
}
;
#
[
repr
(
C
)
]
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
struct
ResourceId
(
pub
u32
)
;
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
enum
ResourceUpdate
{
AddImage
(
AddImage
)
UpdateImage
(
UpdateImage
)
DeleteImage
(
ImageKey
)
AddBlobImage
(
AddBlobImage
)
UpdateBlobImage
(
UpdateBlobImage
)
DeleteBlobImage
(
BlobImageKey
)
SetBlobImageVisibleArea
(
BlobImageKey
DeviceIntRect
)
AddFont
(
AddFont
)
DeleteFont
(
FontKey
)
AddFontInstance
(
AddFontInstance
)
DeleteFontInstance
(
FontInstanceKey
)
}
impl
fmt
:
:
Debug
for
ResourceUpdate
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
match
self
{
ResourceUpdate
:
:
AddImage
(
ref
i
)
=
>
f
.
write_fmt
(
format_args
!
(
"
ResourceUpdate
:
:
AddImage
size
(
{
:
?
}
)
"
&
i
.
descriptor
.
size
)
)
ResourceUpdate
:
:
UpdateImage
(
ref
i
)
=
>
f
.
write_fmt
(
format_args
!
(
"
ResourceUpdate
:
:
UpdateImage
size
(
{
:
?
}
)
"
&
i
.
descriptor
.
size
)
)
ResourceUpdate
:
:
AddBlobImage
(
ref
i
)
=
>
f
.
write_fmt
(
format_args
!
(
"
ResourceUFpdate
:
:
AddBlobImage
size
(
{
:
?
}
)
"
&
i
.
descriptor
.
size
)
)
ResourceUpdate
:
:
UpdateBlobImage
(
i
)
=
>
f
.
write_fmt
(
format_args
!
(
"
ResourceUpdate
:
:
UpdateBlobImage
size
(
{
:
?
}
)
"
&
i
.
descriptor
.
size
)
)
ResourceUpdate
:
:
DeleteImage
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
DeleteImage
"
)
ResourceUpdate
:
:
DeleteBlobImage
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
DeleteBlobImage
"
)
ResourceUpdate
:
:
SetBlobImageVisibleArea
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
SetBlobImageVisibleArea
"
)
ResourceUpdate
:
:
AddFont
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
AddFont
"
)
ResourceUpdate
:
:
DeleteFont
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
DeleteFont
"
)
ResourceUpdate
:
:
AddFontInstance
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
AddFontInstance
"
)
ResourceUpdate
:
:
DeleteFontInstance
(
.
.
)
=
>
f
.
write_str
(
"
ResourceUpdate
:
:
DeleteFontInstance
"
)
}
}
}
#
[
derive
(
Clone
Debug
)
]
pub
enum
GenerateFrame
{
Yes
{
id
:
u64
}
No
}
impl
GenerateFrame
{
pub
fn
as_bool
(
&
self
)
-
>
bool
{
match
self
{
GenerateFrame
:
:
Yes
{
.
.
}
=
>
true
GenerateFrame
:
:
No
=
>
false
}
}
pub
fn
id
(
&
self
)
-
>
Option
<
u64
>
{
match
self
{
GenerateFrame
:
:
Yes
{
id
}
=
>
Some
(
*
id
)
GenerateFrame
:
:
No
=
>
None
}
}
}
pub
struct
Transaction
{
scene_ops
:
Vec
<
SceneMsg
>
frame_ops
:
Vec
<
FrameMsg
>
notifications
:
Vec
<
NotificationRequest
>
pub
resource_updates
:
Vec
<
ResourceUpdate
>
use_scene_builder_thread
:
bool
generate_frame
:
GenerateFrame
pub
invalidate_rendered_frame
:
bool
low_priority
:
bool
pub
render_reasons
:
RenderReasons
}
impl
Transaction
{
pub
fn
new
(
)
-
>
Self
{
Transaction
{
scene_ops
:
Vec
:
:
new
(
)
frame_ops
:
Vec
:
:
new
(
)
resource_updates
:
Vec
:
:
new
(
)
notifications
:
Vec
:
:
new
(
)
use_scene_builder_thread
:
true
generate_frame
:
GenerateFrame
:
:
No
invalidate_rendered_frame
:
false
low_priority
:
false
render_reasons
:
RenderReasons
:
:
empty
(
)
}
}
pub
fn
skip_scene_builder
(
&
mut
self
)
{
self
.
use_scene_builder_thread
=
false
;
}
pub
fn
use_scene_builder_thread
(
&
mut
self
)
{
self
.
use_scene_builder_thread
=
true
;
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
!
self
.
generate_frame
.
as_bool
(
)
&
&
!
self
.
invalidate_rendered_frame
&
&
self
.
scene_ops
.
is_empty
(
)
&
&
self
.
frame_ops
.
is_empty
(
)
&
&
self
.
resource_updates
.
is_empty
(
)
&
&
self
.
notifications
.
is_empty
(
)
}
pub
fn
update_epoch
(
&
mut
self
pipeline_id
:
PipelineId
epoch
:
Epoch
)
{
self
.
scene_ops
.
push
(
SceneMsg
:
:
UpdateEpoch
(
pipeline_id
epoch
)
)
;
self
.
frame_ops
.
push
(
FrameMsg
:
:
UpdateEpoch
(
pipeline_id
epoch
)
)
;
}
pub
fn
set_root_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
scene_ops
.
push
(
SceneMsg
:
:
SetRootPipeline
(
pipeline_id
)
)
;
}
pub
fn
remove_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
scene_ops
.
push
(
SceneMsg
:
:
RemovePipeline
(
pipeline_id
)
)
;
}
pub
fn
set_display_list
(
&
mut
self
epoch
:
Epoch
background
:
Option
<
ColorF
>
viewport_size
:
LayoutSize
(
pipeline_id
mut
display_list
)
:
(
PipelineId
BuiltDisplayList
)
)
{
display_list
.
set_send_time_ns
(
precise_time_ns
(
)
)
;
self
.
scene_ops
.
push
(
SceneMsg
:
:
SetDisplayList
{
display_list
epoch
pipeline_id
background
viewport_size
}
)
;
}
pub
fn
update_resources
(
&
mut
self
mut
resources
:
Vec
<
ResourceUpdate
>
)
{
self
.
resource_updates
.
append
(
&
mut
resources
)
;
}
pub
fn
notify
(
&
mut
self
event
:
NotificationRequest
)
{
self
.
notifications
.
push
(
event
)
;
}
pub
fn
set_document_view
(
&
mut
self
device_rect
:
DeviceIntRect
)
{
window_size_sanity_check
(
device_rect
.
size
(
)
)
;
self
.
scene_ops
.
push
(
SceneMsg
:
:
SetDocumentView
{
device_rect
}
)
;
}
pub
fn
scroll_node_with_id
(
&
mut
self
origin
:
LayoutPoint
id
:
ExternalScrollId
clamp
:
ScrollClamping
)
{
self
.
frame_ops
.
push
(
FrameMsg
:
:
ScrollNodeWithId
(
origin
id
clamp
)
)
;
}
pub
fn
set_quality_settings
(
&
mut
self
settings
:
QualitySettings
)
{
self
.
scene_ops
.
push
(
SceneMsg
:
:
SetQualitySettings
{
settings
}
)
;
}
pub
fn
set_is_transform_async_zooming
(
&
mut
self
is_zooming
:
bool
animation_id
:
PropertyBindingId
)
{
self
.
frame_ops
.
push
(
FrameMsg
:
:
SetIsTransformAsyncZooming
(
is_zooming
animation_id
)
)
;
}
pub
fn
generate_frame
(
&
mut
self
id
:
u64
reasons
:
RenderReasons
)
{
self
.
generate_frame
=
GenerateFrame
:
:
Yes
{
id
}
;
self
.
render_reasons
|
=
reasons
;
}
pub
fn
invalidate_rendered_frame
(
&
mut
self
reasons
:
RenderReasons
)
{
self
.
invalidate_rendered_frame
=
true
;
self
.
render_reasons
|
=
reasons
}
pub
fn
reset_dynamic_properties
(
&
mut
self
)
{
self
.
frame_ops
.
push
(
FrameMsg
:
:
ResetDynamicProperties
)
;
}
pub
fn
append_dynamic_properties
(
&
mut
self
properties
:
DynamicProperties
)
{
self
.
frame_ops
.
push
(
FrameMsg
:
:
AppendDynamicProperties
(
properties
)
)
;
}
pub
fn
append_dynamic_transform_properties
(
&
mut
self
transforms
:
Vec
<
PropertyValue
<
LayoutTransform
>
>
)
{
self
.
frame_ops
.
push
(
FrameMsg
:
:
AppendDynamicTransformProperties
(
transforms
)
)
;
}
pub
fn
get_frame_ops
(
self
)
-
>
Vec
<
FrameMsg
>
{
self
.
frame_ops
}
fn
finalize
(
self
document_id
:
DocumentId
)
-
>
Box
<
TransactionMsg
>
{
Box
:
:
new
(
TransactionMsg
{
document_id
scene_ops
:
self
.
scene_ops
frame_ops
:
self
.
frame_ops
resource_updates
:
self
.
resource_updates
notifications
:
self
.
notifications
use_scene_builder_thread
:
self
.
use_scene_builder_thread
generate_frame
:
self
.
generate_frame
invalidate_rendered_frame
:
self
.
invalidate_rendered_frame
low_priority
:
self
.
low_priority
blob_rasterizer
:
None
blob_requests
:
Vec
:
:
new
(
)
rasterized_blobs
:
Vec
:
:
new
(
)
profile
:
TransactionProfile
:
:
new
(
)
render_reasons
:
self
.
render_reasons
}
)
}
pub
fn
add_image
(
&
mut
self
key
:
ImageKey
descriptor
:
ImageDescriptor
data
:
ImageData
tiling
:
Option
<
TileSize
>
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
AddImage
(
AddImage
{
key
descriptor
data
tiling
}
)
)
;
}
pub
fn
update_image
(
&
mut
self
key
:
ImageKey
descriptor
:
ImageDescriptor
data
:
ImageData
dirty_rect
:
&
ImageDirtyRect
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
UpdateImage
(
UpdateImage
{
key
descriptor
data
dirty_rect
:
*
dirty_rect
}
)
)
;
}
pub
fn
delete_image
(
&
mut
self
key
:
ImageKey
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
DeleteImage
(
key
)
)
;
}
pub
fn
add_blob_image
(
&
mut
self
key
:
BlobImageKey
descriptor
:
ImageDescriptor
data
:
Arc
<
BlobImageData
>
visible_rect
:
DeviceIntRect
tile_size
:
Option
<
TileSize
>
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
AddBlobImage
(
AddBlobImage
{
key
descriptor
data
visible_rect
tile_size
:
tile_size
.
unwrap_or
(
DEFAULT_TILE_SIZE
)
}
)
)
;
}
pub
fn
update_blob_image
(
&
mut
self
key
:
BlobImageKey
descriptor
:
ImageDescriptor
data
:
Arc
<
BlobImageData
>
visible_rect
:
DeviceIntRect
dirty_rect
:
&
BlobDirtyRect
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
UpdateBlobImage
(
UpdateBlobImage
{
key
descriptor
data
visible_rect
dirty_rect
:
*
dirty_rect
}
)
)
;
}
pub
fn
delete_blob_image
(
&
mut
self
key
:
BlobImageKey
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
DeleteBlobImage
(
key
)
)
;
}
pub
fn
set_blob_image_visible_area
(
&
mut
self
key
:
BlobImageKey
area
:
DeviceIntRect
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
SetBlobImageVisibleArea
(
key
area
)
)
;
}
pub
fn
add_raw_font
(
&
mut
self
key
:
FontKey
bytes
:
Vec
<
u8
>
index
:
u32
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
AddFont
(
AddFont
:
:
Raw
(
key
Arc
:
:
new
(
bytes
)
index
)
)
)
;
}
pub
fn
add_native_font
(
&
mut
self
key
:
FontKey
native_handle
:
NativeFontHandle
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
AddFont
(
AddFont
:
:
Native
(
key
native_handle
)
)
)
;
}
pub
fn
delete_font
(
&
mut
self
key
:
FontKey
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
DeleteFont
(
key
)
)
;
}
pub
fn
add_font_instance
(
&
mut
self
key
:
FontInstanceKey
font_key
:
FontKey
glyph_size
:
f32
options
:
Option
<
FontInstanceOptions
>
platform_options
:
Option
<
FontInstancePlatformOptions
>
variations
:
Vec
<
FontVariation
>
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
AddFontInstance
(
AddFontInstance
{
key
font_key
glyph_size
options
platform_options
variations
}
)
)
;
}
pub
fn
delete_font_instance
(
&
mut
self
key
:
FontInstanceKey
)
{
self
.
resource_updates
.
push
(
ResourceUpdate
:
:
DeleteFontInstance
(
key
)
)
;
}
pub
fn
set_low_priority
(
&
mut
self
low_priority
:
bool
)
{
self
.
low_priority
=
low_priority
;
}
pub
fn
is_low_priority
(
&
self
)
-
>
bool
{
self
.
low_priority
}
}
pub
struct
DocumentTransaction
{
pub
document_id
:
DocumentId
pub
transaction
:
Transaction
}
pub
struct
TransactionMsg
{
pub
document_id
:
DocumentId
pub
scene_ops
:
Vec
<
SceneMsg
>
pub
frame_ops
:
Vec
<
FrameMsg
>
pub
resource_updates
:
Vec
<
ResourceUpdate
>
pub
generate_frame
:
GenerateFrame
pub
invalidate_rendered_frame
:
bool
pub
use_scene_builder_thread
:
bool
pub
low_priority
:
bool
pub
notifications
:
Vec
<
NotificationRequest
>
pub
blob_rasterizer
:
Option
<
Box
<
dyn
AsyncBlobImageRasterizer
>
>
pub
blob_requests
:
Vec
<
BlobImageParams
>
pub
rasterized_blobs
:
Vec
<
(
BlobImageRequest
BlobImageResult
)
>
pub
profile
:
TransactionProfile
pub
render_reasons
:
RenderReasons
}
impl
fmt
:
:
Debug
for
TransactionMsg
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
writeln
!
(
f
"
threaded
=
{
}
genframe
=
{
:
?
}
invalidate
=
{
}
low_priority
=
{
}
"
self
.
use_scene_builder_thread
self
.
generate_frame
self
.
invalidate_rendered_frame
self
.
low_priority
)
.
unwrap
(
)
;
for
scene_op
in
&
self
.
scene_ops
{
writeln
!
(
f
"
\
t
\
t
{
:
?
}
"
scene_op
)
.
unwrap
(
)
;
}
for
frame_op
in
&
self
.
frame_ops
{
writeln
!
(
f
"
\
t
\
t
{
:
?
}
"
frame_op
)
.
unwrap
(
)
;
}
for
resource_update
in
&
self
.
resource_updates
{
writeln
!
(
f
"
\
t
\
t
{
:
?
}
"
resource_update
)
.
unwrap
(
)
;
}
Ok
(
(
)
)
}
}
impl
TransactionMsg
{
pub
fn
is_empty
(
&
self
)
-
>
bool
{
!
self
.
generate_frame
.
as_bool
(
)
&
&
!
self
.
invalidate_rendered_frame
&
&
self
.
scene_ops
.
is_empty
(
)
&
&
self
.
frame_ops
.
is_empty
(
)
&
&
self
.
resource_updates
.
is_empty
(
)
&
&
self
.
notifications
.
is_empty
(
)
}
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
struct
AddImage
{
pub
key
:
ImageKey
pub
descriptor
:
ImageDescriptor
pub
data
:
ImageData
pub
tiling
:
Option
<
TileSize
>
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
struct
UpdateImage
{
pub
key
:
ImageKey
pub
descriptor
:
ImageDescriptor
pub
data
:
ImageData
pub
dirty_rect
:
ImageDirtyRect
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
struct
AddBlobImage
{
pub
key
:
BlobImageKey
pub
descriptor
:
ImageDescriptor
pub
data
:
Arc
<
BlobImageData
>
pub
visible_rect
:
DeviceIntRect
pub
tile_size
:
TileSize
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
struct
UpdateBlobImage
{
pub
key
:
BlobImageKey
pub
descriptor
:
ImageDescriptor
pub
data
:
Arc
<
BlobImageData
>
pub
visible_rect
:
DeviceIntRect
pub
dirty_rect
:
BlobDirtyRect
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
enum
AddFont
{
Raw
(
FontKey
Arc
<
Vec
<
u8
>
>
u32
)
Native
(
FontKey
NativeFontHandle
)
}
#
[
derive
(
Clone
)
]
#
[
cfg_attr
(
any
(
feature
=
"
serde
"
)
derive
(
Deserialize
Serialize
)
)
]
pub
struct
AddFontInstance
{
pub
key
:
FontInstanceKey
pub
font_key
:
FontKey
pub
glyph_size
:
f32
pub
options
:
Option
<
FontInstanceOptions
>
pub
platform_options
:
Option
<
FontInstancePlatformOptions
>
pub
variations
:
Vec
<
FontVariation
>
}
pub
enum
SceneMsg
{
UpdateEpoch
(
PipelineId
Epoch
)
SetRootPipeline
(
PipelineId
)
RemovePipeline
(
PipelineId
)
SetDisplayList
{
display_list
:
BuiltDisplayList
epoch
:
Epoch
pipeline_id
:
PipelineId
background
:
Option
<
ColorF
>
viewport_size
:
LayoutSize
}
SetDocumentView
{
device_rect
:
DeviceIntRect
}
SetQualitySettings
{
settings
:
QualitySettings
}
}
pub
enum
FrameMsg
{
UpdateEpoch
(
PipelineId
Epoch
)
HitTest
(
Option
<
PipelineId
>
WorldPoint
Sender
<
HitTestResult
>
)
RequestHitTester
(
Sender
<
Arc
<
dyn
ApiHitTester
>
>
)
ScrollNodeWithId
(
LayoutPoint
ExternalScrollId
ScrollClamping
)
ResetDynamicProperties
AppendDynamicProperties
(
DynamicProperties
)
AppendDynamicTransformProperties
(
Vec
<
PropertyValue
<
LayoutTransform
>
>
)
SetIsTransformAsyncZooming
(
bool
PropertyBindingId
)
}
impl
fmt
:
:
Debug
for
SceneMsg
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
*
self
{
SceneMsg
:
:
UpdateEpoch
(
.
.
)
=
>
"
SceneMsg
:
:
UpdateEpoch
"
SceneMsg
:
:
SetDisplayList
{
.
.
}
=
>
"
SceneMsg
:
:
SetDisplayList
"
SceneMsg
:
:
RemovePipeline
(
.
.
)
=
>
"
SceneMsg
:
:
RemovePipeline
"
SceneMsg
:
:
SetDocumentView
{
.
.
}
=
>
"
SceneMsg
:
:
SetDocumentView
"
SceneMsg
:
:
SetRootPipeline
(
.
.
)
=
>
"
SceneMsg
:
:
SetRootPipeline
"
SceneMsg
:
:
SetQualitySettings
{
.
.
}
=
>
"
SceneMsg
:
:
SetQualitySettings
"
}
)
}
}
impl
fmt
:
:
Debug
for
FrameMsg
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
*
self
{
FrameMsg
:
:
UpdateEpoch
(
.
.
)
=
>
"
FrameMsg
:
:
UpdateEpoch
"
FrameMsg
:
:
HitTest
(
.
.
)
=
>
"
FrameMsg
:
:
HitTest
"
FrameMsg
:
:
RequestHitTester
(
.
.
)
=
>
"
FrameMsg
:
:
RequestHitTester
"
FrameMsg
:
:
ScrollNodeWithId
(
.
.
)
=
>
"
FrameMsg
:
:
ScrollNodeWithId
"
FrameMsg
:
:
ResetDynamicProperties
=
>
"
FrameMsg
:
:
ResetDynamicProperties
"
FrameMsg
:
:
AppendDynamicProperties
(
.
.
)
=
>
"
FrameMsg
:
:
AppendDynamicProperties
"
FrameMsg
:
:
AppendDynamicTransformProperties
(
.
.
)
=
>
"
FrameMsg
:
:
AppendDynamicTransformProperties
"
FrameMsg
:
:
SetIsTransformAsyncZooming
(
.
.
)
=
>
"
FrameMsg
:
:
SetIsTransformAsyncZooming
"
}
)
}
}
bitflags
!
{
/
/
/
Bit
flags
for
WR
stages
to
store
in
a
capture
.
/
/
Note
:
capturing
FRAME
without
SCENE
is
not
currently
supported
.
pub
struct
CaptureBits
:
u8
{
/
/
/
const
SCENE
=
0x1
;
/
/
/
const
FRAME
=
0x2
;
/
/
/
const
TILE_CACHE
=
0x4
;
/
/
/
const
EXTERNAL_RESOURCES
=
0x8
;
}
}
bitflags
!
{
/
/
/
Mask
for
clearing
caches
in
debug
commands
.
pub
struct
ClearCache
:
u8
{
/
/
/
const
IMAGES
=
0b1
;
/
/
/
const
GLYPHS
=
0b10
;
/
/
/
const
GLYPH_DIMENSIONS
=
0b100
;
/
/
/
const
RENDER_TASKS
=
0b1000
;
/
/
/
const
TEXTURE_CACHE
=
0b10000
;
/
/
/
Clear
render
target
pool
const
RENDER_TARGETS
=
0b100000
;
}
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
CapturedDocument
{
pub
document_id
:
DocumentId
pub
root_pipeline_id
:
Option
<
PipelineId
>
}
#
[
derive
(
Clone
)
]
pub
enum
DebugCommand
{
SetFlags
(
DebugFlags
)
EnableDualSourceBlending
(
bool
)
SaveCapture
(
PathBuf
CaptureBits
)
LoadCapture
(
PathBuf
Option
<
(
u32
u32
)
>
Sender
<
CapturedDocument
>
)
StartCaptureSequence
(
PathBuf
CaptureBits
)
StopCaptureSequence
ClearCaches
(
ClearCache
)
EnableNativeCompositor
(
bool
)
SetBatchingLookback
(
u32
)
InvalidateGpuCache
SimulateLongSceneBuild
(
u32
)
SetPictureTileSize
(
Option
<
DeviceIntSize
>
)
}
pub
enum
ApiMsg
{
CloneApi
(
Sender
<
IdNamespace
>
)
CloneApiByClient
(
IdNamespace
)
AddDocument
(
DocumentId
DeviceIntSize
)
UpdateDocuments
(
Vec
<
Box
<
TransactionMsg
>
>
)
MemoryPressure
ReportMemory
(
Sender
<
Box
<
MemoryReport
>
>
)
DebugCommand
(
DebugCommand
)
SceneBuilderResult
(
SceneBuilderResult
)
}
impl
fmt
:
:
Debug
for
ApiMsg
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
f
.
write_str
(
match
*
self
{
ApiMsg
:
:
CloneApi
(
.
.
)
=
>
"
ApiMsg
:
:
CloneApi
"
ApiMsg
:
:
CloneApiByClient
(
.
.
)
=
>
"
ApiMsg
:
:
CloneApiByClient
"
ApiMsg
:
:
AddDocument
(
.
.
)
=
>
"
ApiMsg
:
:
AddDocument
"
ApiMsg
:
:
UpdateDocuments
(
.
.
)
=
>
"
ApiMsg
:
:
UpdateDocuments
"
ApiMsg
:
:
MemoryPressure
=
>
"
ApiMsg
:
:
MemoryPressure
"
ApiMsg
:
:
ReportMemory
(
.
.
)
=
>
"
ApiMsg
:
:
ReportMemory
"
ApiMsg
:
:
DebugCommand
(
.
.
)
=
>
"
ApiMsg
:
:
DebugCommand
"
ApiMsg
:
:
SceneBuilderResult
(
.
.
)
=
>
"
ApiMsg
:
:
SceneBuilderResult
"
}
)
}
}
pub
struct
RenderApiSender
{
api_sender
:
Sender
<
ApiMsg
>
scene_sender
:
Sender
<
SceneBuilderRequest
>
low_priority_scene_sender
:
Sender
<
SceneBuilderRequest
>
blob_image_handler
:
Option
<
Box
<
dyn
BlobImageHandler
>
>
shared_font_instances
:
SharedFontInstanceMap
}
impl
RenderApiSender
{
pub
fn
new
(
api_sender
:
Sender
<
ApiMsg
>
scene_sender
:
Sender
<
SceneBuilderRequest
>
low_priority_scene_sender
:
Sender
<
SceneBuilderRequest
>
blob_image_handler
:
Option
<
Box
<
dyn
BlobImageHandler
>
>
shared_font_instances
:
SharedFontInstanceMap
)
-
>
Self
{
RenderApiSender
{
api_sender
scene_sender
low_priority_scene_sender
blob_image_handler
shared_font_instances
}
}
pub
fn
create_api
(
&
self
)
-
>
RenderApi
{
let
(
sync_tx
sync_rx
)
=
single_msg_channel
(
)
;
let
msg
=
ApiMsg
:
:
CloneApi
(
sync_tx
)
;
self
.
api_sender
.
send
(
msg
)
.
expect
(
"
Failed
to
send
CloneApi
message
"
)
;
let
namespace_id
=
sync_rx
.
recv
(
)
.
expect
(
"
Failed
to
receive
CloneApi
reply
"
)
;
RenderApi
{
api_sender
:
self
.
api_sender
.
clone
(
)
scene_sender
:
self
.
scene_sender
.
clone
(
)
low_priority_scene_sender
:
self
.
low_priority_scene_sender
.
clone
(
)
namespace_id
next_id
:
Cell
:
:
new
(
ResourceId
(
0
)
)
resources
:
ApiResources
:
:
new
(
self
.
blob_image_handler
.
as_ref
(
)
.
map
(
|
handler
|
handler
.
create_similar
(
)
)
self
.
shared_font_instances
.
clone
(
)
)
}
}
pub
fn
create_api_by_client
(
&
self
namespace_id
:
IdNamespace
)
-
>
RenderApi
{
let
msg
=
ApiMsg
:
:
CloneApiByClient
(
namespace_id
)
;
self
.
api_sender
.
send
(
msg
)
.
expect
(
"
Failed
to
send
CloneApiByClient
message
"
)
;
RenderApi
{
api_sender
:
self
.
api_sender
.
clone
(
)
scene_sender
:
self
.
scene_sender
.
clone
(
)
low_priority_scene_sender
:
self
.
low_priority_scene_sender
.
clone
(
)
namespace_id
next_id
:
Cell
:
:
new
(
ResourceId
(
0
)
)
resources
:
ApiResources
:
:
new
(
self
.
blob_image_handler
.
as_ref
(
)
.
map
(
|
handler
|
handler
.
create_similar
(
)
)
self
.
shared_font_instances
.
clone
(
)
)
}
}
}
pub
struct
RenderApi
{
api_sender
:
Sender
<
ApiMsg
>
scene_sender
:
Sender
<
SceneBuilderRequest
>
low_priority_scene_sender
:
Sender
<
SceneBuilderRequest
>
namespace_id
:
IdNamespace
next_id
:
Cell
<
ResourceId
>
resources
:
ApiResources
}
impl
RenderApi
{
pub
fn
get_namespace_id
(
&
self
)
-
>
IdNamespace
{
self
.
namespace_id
}
pub
fn
create_sender
(
&
self
)
-
>
RenderApiSender
{
RenderApiSender
:
:
new
(
self
.
api_sender
.
clone
(
)
self
.
scene_sender
.
clone
(
)
self
.
low_priority_scene_sender
.
clone
(
)
self
.
resources
.
blob_image_handler
.
as_ref
(
)
.
map
(
|
handler
|
handler
.
create_similar
(
)
)
self
.
resources
.
get_shared_font_instances
(
)
)
}
pub
fn
add_document
(
&
self
initial_size
:
DeviceIntSize
)
-
>
DocumentId
{
let
new_id
=
self
.
next_unique_id
(
)
;
self
.
add_document_with_id
(
initial_size
new_id
)
}
pub
fn
add_document_with_id
(
&
self
initial_size
:
DeviceIntSize
id
:
u32
)
-
>
DocumentId
{
window_size_sanity_check
(
initial_size
)
;
let
document_id
=
DocumentId
:
:
new
(
self
.
namespace_id
id
)
;
self
.
api_sender
.
send
(
ApiMsg
:
:
AddDocument
(
document_id
initial_size
)
)
.
unwrap
(
)
;
self
.
scene_sender
.
send
(
SceneBuilderRequest
:
:
AddDocument
(
document_id
initial_size
)
)
.
unwrap
(
)
;
document_id
}
pub
fn
delete_document
(
&
self
document_id
:
DocumentId
)
{
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
DeleteDocument
(
document_id
)
)
.
unwrap
(
)
;
}
pub
fn
generate_font_key
(
&
self
)
-
>
FontKey
{
let
new_id
=
self
.
next_unique_id
(
)
;
FontKey
:
:
new
(
self
.
namespace_id
new_id
)
}
pub
fn
generate_font_instance_key
(
&
self
)
-
>
FontInstanceKey
{
let
new_id
=
self
.
next_unique_id
(
)
;
FontInstanceKey
:
:
new
(
self
.
namespace_id
new_id
)
}
pub
fn
get_glyph_dimensions
(
&
self
key
:
FontInstanceKey
glyph_indices
:
Vec
<
GlyphIndex
>
)
-
>
Vec
<
Option
<
GlyphDimensions
>
>
{
let
(
sender
rx
)
=
single_msg_channel
(
)
;
let
msg
=
SceneBuilderRequest
:
:
GetGlyphDimensions
(
GlyphDimensionRequest
{
key
glyph_indices
sender
}
)
;
self
.
low_priority_scene_sender
.
send
(
msg
)
.
unwrap
(
)
;
rx
.
recv
(
)
.
unwrap
(
)
}
pub
fn
get_glyph_indices
(
&
self
key
:
FontKey
text
:
&
str
)
-
>
Vec
<
Option
<
u32
>
>
{
let
(
sender
rx
)
=
single_msg_channel
(
)
;
let
msg
=
SceneBuilderRequest
:
:
GetGlyphIndices
(
GlyphIndexRequest
{
key
text
:
text
.
to_string
(
)
sender
}
)
;
self
.
low_priority_scene_sender
.
send
(
msg
)
.
unwrap
(
)
;
rx
.
recv
(
)
.
unwrap
(
)
}
pub
fn
generate_image_key
(
&
self
)
-
>
ImageKey
{
let
new_id
=
self
.
next_unique_id
(
)
;
ImageKey
:
:
new
(
self
.
namespace_id
new_id
)
}
pub
fn
generate_blob_image_key
(
&
self
)
-
>
BlobImageKey
{
BlobImageKey
(
self
.
generate_image_key
(
)
)
}
pub
fn
send_external_event
(
&
self
evt
:
ExternalEvent
)
{
let
msg
=
SceneBuilderRequest
:
:
ExternalEvent
(
evt
)
;
self
.
low_priority_scene_sender
.
send
(
msg
)
.
unwrap
(
)
;
}
pub
fn
notify_memory_pressure
(
&
self
)
{
self
.
api_sender
.
send
(
ApiMsg
:
:
MemoryPressure
)
.
unwrap
(
)
;
}
pub
fn
report_memory
(
&
self
_ops
:
malloc_size_of
:
:
MallocSizeOfOps
)
-
>
MemoryReport
{
let
(
tx
rx
)
=
single_msg_channel
(
)
;
self
.
api_sender
.
send
(
ApiMsg
:
:
ReportMemory
(
tx
)
)
.
unwrap
(
)
;
*
rx
.
recv
(
)
.
unwrap
(
)
}
pub
fn
set_debug_flags
(
&
self
flags
:
DebugFlags
)
{
let
cmd
=
DebugCommand
:
:
SetFlags
(
flags
)
;
self
.
api_sender
.
send
(
ApiMsg
:
:
DebugCommand
(
cmd
)
)
.
unwrap
(
)
;
}
pub
fn
stop_render_backend
(
&
self
)
{
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
StopRenderBackend
)
.
unwrap
(
)
;
}
pub
fn
shut_down
(
&
self
synchronously
:
bool
)
{
if
synchronously
{
let
(
tx
rx
)
=
single_msg_channel
(
)
;
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
ShutDown
(
Some
(
tx
)
)
)
.
unwrap
(
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
}
else
{
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
ShutDown
(
None
)
)
.
unwrap
(
)
;
}
}
pub
fn
generate_property_binding_key
<
T
:
Copy
>
(
&
self
)
-
>
PropertyBindingKey
<
T
>
{
let
new_id
=
self
.
next_unique_id
(
)
;
PropertyBindingKey
{
id
:
PropertyBindingId
{
namespace
:
self
.
namespace_id
uid
:
new_id
}
_phantom
:
PhantomData
}
}
#
[
inline
]
fn
next_unique_id
(
&
self
)
-
>
u32
{
let
ResourceId
(
id
)
=
self
.
next_id
.
get
(
)
;
self
.
next_id
.
set
(
ResourceId
(
id
+
1
)
)
;
id
}
#
[
doc
(
hidden
)
]
pub
fn
send_message
(
&
self
msg
:
ApiMsg
)
{
self
.
api_sender
.
send
(
msg
)
.
unwrap
(
)
;
}
fn
frame_message
(
&
self
msg
:
FrameMsg
document_id
:
DocumentId
)
-
>
Box
<
TransactionMsg
>
{
Box
:
:
new
(
TransactionMsg
{
document_id
scene_ops
:
Vec
:
:
new
(
)
frame_ops
:
vec
!
[
msg
]
resource_updates
:
Vec
:
:
new
(
)
notifications
:
Vec
:
:
new
(
)
generate_frame
:
GenerateFrame
:
:
No
invalidate_rendered_frame
:
false
use_scene_builder_thread
:
false
low_priority
:
false
blob_rasterizer
:
None
blob_requests
:
Vec
:
:
new
(
)
rasterized_blobs
:
Vec
:
:
new
(
)
profile
:
TransactionProfile
:
:
new
(
)
render_reasons
:
RenderReasons
:
:
empty
(
)
}
)
}
fn
send_frame_msg
(
&
self
document_id
:
DocumentId
msg
:
FrameMsg
)
{
self
.
api_sender
.
send
(
ApiMsg
:
:
UpdateDocuments
(
vec
!
[
self
.
frame_message
(
msg
document_id
)
]
)
)
.
unwrap
(
)
}
pub
fn
send_transaction
(
&
mut
self
document_id
:
DocumentId
transaction
:
Transaction
)
{
let
mut
transaction
=
transaction
.
finalize
(
document_id
)
;
self
.
resources
.
update
(
&
mut
transaction
)
;
if
transaction
.
generate_frame
.
as_bool
(
)
{
transaction
.
profile
.
start_time
(
profiler
:
:
API_SEND_TIME
)
;
transaction
.
profile
.
start_time
(
profiler
:
:
TOTAL_FRAME_CPU_TIME
)
;
}
if
transaction
.
use_scene_builder_thread
{
let
sender
=
if
transaction
.
low_priority
{
&
mut
self
.
low_priority_scene_sender
}
else
{
&
mut
self
.
scene_sender
}
;
sender
.
send
(
SceneBuilderRequest
:
:
Transactions
(
vec
!
[
transaction
]
)
)
.
unwrap
(
)
;
}
else
{
self
.
api_sender
.
send
(
ApiMsg
:
:
UpdateDocuments
(
vec
!
[
transaction
]
)
)
.
unwrap
(
)
;
}
}
pub
fn
hit_test
(
&
self
document_id
:
DocumentId
pipeline_id
:
Option
<
PipelineId
>
point
:
WorldPoint
)
-
>
HitTestResult
{
let
(
tx
rx
)
=
single_msg_channel
(
)
;
self
.
send_frame_msg
(
document_id
FrameMsg
:
:
HitTest
(
pipeline_id
point
tx
)
)
;
rx
.
recv
(
)
.
unwrap
(
)
}
pub
fn
request_hit_tester
(
&
self
document_id
:
DocumentId
)
-
>
HitTesterRequest
{
let
(
tx
rx
)
=
single_msg_channel
(
)
;
self
.
send_frame_msg
(
document_id
FrameMsg
:
:
RequestHitTester
(
tx
)
)
;
HitTesterRequest
{
rx
}
}
#
[
doc
(
hidden
)
]
pub
fn
wake_scene_builder
(
&
self
)
{
self
.
scene_sender
.
send
(
SceneBuilderRequest
:
:
WakeUp
)
.
unwrap
(
)
;
}
pub
fn
flush_scene_builder
(
&
self
)
{
let
(
tx
rx
)
=
single_msg_channel
(
)
;
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
Flush
(
tx
)
)
.
unwrap
(
)
;
rx
.
recv
(
)
.
unwrap
(
)
;
}
pub
fn
save_capture
(
&
self
path
:
PathBuf
bits
:
CaptureBits
)
{
let
msg
=
ApiMsg
:
:
DebugCommand
(
DebugCommand
:
:
SaveCapture
(
path
bits
)
)
;
self
.
send_message
(
msg
)
;
}
pub
fn
load_capture
(
&
self
path
:
PathBuf
ids
:
Option
<
(
u32
u32
)
>
)
-
>
Vec
<
CapturedDocument
>
{
self
.
flush_scene_builder
(
)
;
let
(
tx
rx
)
=
unbounded_channel
(
)
;
let
msg
=
ApiMsg
:
:
DebugCommand
(
DebugCommand
:
:
LoadCapture
(
path
ids
tx
)
)
;
self
.
send_message
(
msg
)
;
let
mut
documents
=
Vec
:
:
new
(
)
;
while
let
Ok
(
captured_doc
)
=
rx
.
recv
(
)
{
documents
.
push
(
captured_doc
)
;
}
documents
}
pub
fn
start_capture_sequence
(
&
self
path
:
PathBuf
bits
:
CaptureBits
)
{
let
msg
=
ApiMsg
:
:
DebugCommand
(
DebugCommand
:
:
StartCaptureSequence
(
path
bits
)
)
;
self
.
send_message
(
msg
)
;
}
pub
fn
stop_capture_sequence
(
&
self
)
{
let
msg
=
ApiMsg
:
:
DebugCommand
(
DebugCommand
:
:
StopCaptureSequence
)
;
self
.
send_message
(
msg
)
;
}
pub
fn
send_debug_cmd
(
&
self
cmd
:
DebugCommand
)
{
let
msg
=
ApiMsg
:
:
DebugCommand
(
cmd
)
;
self
.
send_message
(
msg
)
;
}
pub
fn
set_parameter
(
&
mut
self
parameter
:
Parameter
)
{
if
let
Parameter
:
:
Bool
(
BoolParameter
:
:
Multithreading
enabled
)
=
parameter
{
self
.
resources
.
enable_multithreading
(
enabled
)
;
}
let
_
=
self
.
low_priority_scene_sender
.
send
(
SceneBuilderRequest
:
:
SetParameter
(
parameter
)
)
;
}
}
impl
Drop
for
RenderApi
{
fn
drop
(
&
mut
self
)
{
let
msg
=
SceneBuilderRequest
:
:
ClearNamespace
(
self
.
namespace_id
)
;
let
_
=
self
.
low_priority_scene_sender
.
send
(
msg
)
;
}
}
fn
window_size_sanity_check
(
size
:
DeviceIntSize
)
{
use
crate
:
:
api
:
:
MAX_RENDER_TASK_SIZE
;
if
size
.
width
>
MAX_RENDER_TASK_SIZE
|
|
size
.
height
>
MAX_RENDER_TASK_SIZE
{
panic
!
(
"
Attempting
to
create
a
{
}
x
{
}
window
/
document
"
size
.
width
size
.
height
)
;
}
}
/
/
/
cbindgen
:
derive
-
eq
=
false
/
/
/
cbindgen
:
derive
-
ostream
=
false
#
[
repr
(
C
)
]
#
[
allow
(
missing_docs
)
]
#
[
derive
(
AddAssign
Clone
Debug
Default
)
]
pub
struct
MemoryReport
{
pub
clip_stores
:
usize
pub
gpu_cache_metadata
:
usize
pub
gpu_cache_cpu_mirror
:
usize
pub
render_tasks
:
usize
pub
hit_testers
:
usize
pub
fonts
:
usize
pub
weak_fonts
:
usize
pub
images
:
usize
pub
rasterized_blobs
:
usize
pub
shader_cache
:
usize
pub
interning
:
InterningMemoryReport
pub
display_list
:
usize
pub
upload_staging_memory
:
usize
pub
swgl
:
usize
pub
gpu_cache_textures
:
usize
pub
vertex_data_textures
:
usize
pub
render_target_textures
:
usize
pub
picture_tile_textures
:
usize
pub
atlas_textures
:
usize
pub
standalone_textures
:
usize
pub
texture_cache_structures
:
usize
pub
depth_target_textures
:
usize
pub
texture_upload_pbos
:
usize
pub
swap_chain
:
usize
pub
render_texture_hosts
:
usize
pub
upload_staging_textures
:
usize
}
