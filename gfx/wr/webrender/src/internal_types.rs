use
api
:
:
{
ColorF
DocumentId
ExternalImageId
PrimitiveFlags
Parameter
RenderReasons
}
;
use
api
:
:
{
ImageFormat
NotificationRequest
Shadow
FilterOpGraphPictureBufferId
FilterOpGraphPictureReference
FilterOpGraphNode
FilterOp
ImageBufferKind
}
;
use
api
:
:
FramePublishId
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
render_api
:
:
DebugCommand
;
use
crate
:
:
composite
:
:
NativeSurfaceOperation
;
use
crate
:
:
device
:
:
TextureFilter
;
use
crate
:
:
renderer
:
:
{
FullFrameStats
PipelineInfo
}
;
use
crate
:
:
gpu_cache
:
:
GpuCacheUpdateList
;
use
crate
:
:
gpu_types
:
:
BlurEdgeMode
;
use
crate
:
:
frame_builder
:
:
Frame
;
use
crate
:
:
profiler
:
:
TransactionProfile
;
use
crate
:
:
spatial_tree
:
:
SpatialNodeIndex
;
use
crate
:
:
prim_store
:
:
PrimitiveInstanceIndex
;
use
crate
:
:
filterdata
:
:
FilterDataHandle
;
use
fxhash
:
:
FxHasher
;
use
plane_split
:
:
BspSplitter
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
{
usize
i32
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
f32
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
time
:
:
{
UNIX_EPOCH
SystemTime
}
;
use
peek_poke
:
:
PeekPoke
;
#
[
cfg
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
)
]
use
crate
:
:
capture
:
:
CaptureConfig
;
#
[
cfg
(
feature
=
"
capture
"
)
]
use
crate
:
:
capture
:
:
ExternalCaptureImage
;
#
[
cfg
(
feature
=
"
replay
"
)
]
use
crate
:
:
capture
:
:
PlainExternalImage
;
pub
use
crate
:
:
frame_allocator
:
:
{
FrameAllocator
FrameMemory
}
;
pub
type
FrameVec
<
T
>
=
allocator_api2
:
:
vec
:
:
Vec
<
T
FrameAllocator
>
;
pub
fn
size_of_frame_vec
<
T
>
(
vec
:
&
FrameVec
<
T
>
)
-
>
usize
{
vec
.
capacity
(
)
*
std
:
:
mem
:
:
size_of
:
:
<
T
>
(
)
}
pub
type
FastHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
FxHasher
>
>
;
pub
type
FastHashSet
<
K
>
=
HashSet
<
K
BuildHasherDefault
<
FxHasher
>
>
;
#
[
derive
(
Copy
Clone
Hash
MallocSizeOf
PartialEq
PartialOrd
Debug
Eq
Ord
PeekPoke
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FrameId
(
u64
)
;
impl
FrameId
{
pub
fn
first
(
)
-
>
Self
{
FrameId
(
0
)
}
pub
fn
as_u64
(
&
self
)
-
>
u64
{
self
.
0
}
pub
fn
advance
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
pub
const
INVALID
:
FrameId
=
FrameId
(
0
)
;
}
impl
Default
for
FrameId
{
fn
default
(
)
-
>
Self
{
FrameId
:
:
INVALID
}
}
impl
:
:
std
:
:
ops
:
:
Add
<
u64
>
for
FrameId
{
type
Output
=
Self
;
fn
add
(
self
other
:
u64
)
-
>
FrameId
{
FrameId
(
self
.
0
+
other
)
}
}
impl
:
:
std
:
:
ops
:
:
Sub
<
u64
>
for
FrameId
{
type
Output
=
Self
;
fn
sub
(
self
other
:
u64
)
-
>
FrameId
{
assert
!
(
self
.
0
>
=
other
"
Underflow
subtracting
FrameIds
"
)
;
FrameId
(
self
.
0
-
other
)
}
}
#
[
derive
(
Copy
Clone
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FrameStamp
{
id
:
FrameId
time
:
SystemTime
document_id
:
DocumentId
}
impl
Eq
for
FrameStamp
{
}
impl
PartialEq
for
FrameStamp
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
debug_assert_eq
!
(
self
.
document_id
other
.
document_id
)
;
self
.
id
=
=
other
.
id
}
}
impl
PartialOrd
for
FrameStamp
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
:
:
std
:
:
cmp
:
:
Ordering
>
{
self
.
id
.
partial_cmp
(
&
other
.
id
)
}
}
impl
FrameStamp
{
pub
fn
frame_id
(
&
self
)
-
>
FrameId
{
self
.
id
}
pub
fn
time
(
&
self
)
-
>
SystemTime
{
self
.
time
}
pub
fn
document_id
(
&
self
)
-
>
DocumentId
{
self
.
document_id
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
debug_assert
!
(
(
self
.
time
!
=
UNIX_EPOCH
&
&
self
.
id
!
=
FrameId
(
0
)
&
&
self
.
document_id
!
=
DocumentId
:
:
INVALID
)
|
|
*
self
=
=
Self
:
:
INVALID
)
;
self
.
document_id
!
=
DocumentId
:
:
INVALID
}
pub
fn
first
(
document_id
:
DocumentId
)
-
>
Self
{
FrameStamp
{
id
:
FrameId
:
:
first
(
)
time
:
SystemTime
:
:
now
(
)
document_id
}
}
pub
fn
advance
(
&
mut
self
)
{
self
.
id
.
advance
(
)
;
self
.
time
=
SystemTime
:
:
now
(
)
;
}
pub
const
INVALID
:
FrameStamp
=
FrameStamp
{
id
:
FrameId
(
0
)
time
:
UNIX_EPOCH
document_id
:
DocumentId
:
:
INVALID
}
;
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PlaneSplitAnchor
{
pub
spatial_node_index
:
SpatialNodeIndex
pub
instance_index
:
PrimitiveInstanceIndex
}
impl
PlaneSplitAnchor
{
pub
fn
new
(
spatial_node_index
:
SpatialNodeIndex
instance_index
:
PrimitiveInstanceIndex
)
-
>
Self
{
PlaneSplitAnchor
{
spatial_node_index
instance_index
}
}
}
impl
Default
for
PlaneSplitAnchor
{
fn
default
(
)
-
>
Self
{
PlaneSplitAnchor
{
spatial_node_index
:
SpatialNodeIndex
:
:
INVALID
instance_index
:
PrimitiveInstanceIndex
(
!
0
)
}
}
}
pub
type
PlaneSplitter
=
BspSplitter
<
PlaneSplitAnchor
>
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PlaneSplitterIndex
(
pub
usize
)
;
const
OPACITY_EPSILON
:
f32
=
0
.
001
;
#
[
derive
(
Clone
Copy
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphPictureReference
{
pub
buffer_id
:
FilterOpGraphPictureBufferId
pub
subregion
:
LayoutRect
pub
offset
:
LayoutVector2D
pub
inflate
:
i16
pub
source_padding
:
LayoutRect
pub
target_padding
:
LayoutRect
}
impl
From
<
FilterOpGraphPictureReference
>
for
FilterGraphPictureReference
{
fn
from
(
pic
:
FilterOpGraphPictureReference
)
-
>
Self
{
FilterGraphPictureReference
{
buffer_id
:
pic
.
buffer_id
subregion
:
LayoutRect
:
:
zero
(
)
offset
:
LayoutVector2D
:
:
zero
(
)
inflate
:
0
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
}
}
pub
const
SVGFE_CONVOLVE_DIAMETER_LIMIT
:
usize
=
5
;
pub
const
SVGFE_CONVOLVE_VALUES_LIMIT
:
usize
=
SVGFE_CONVOLVE_DIAMETER_LIMIT
*
SVGFE_CONVOLVE_DIAMETER_LIMIT
;
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
FilterGraphOp
{
SVGFESourceGraphic
SVGFESourceAlpha
SVGFEIdentity
SVGFEOpacity
{
valuebinding
:
api
:
:
PropertyBinding
<
f32
>
value
:
f32
}
SVGFEToAlpha
SVGFEBlendDarken
SVGFEBlendLighten
SVGFEBlendMultiply
SVGFEBlendNormal
SVGFEBlendScreen
SVGFEBlendOverlay
SVGFEBlendColorDodge
SVGFEBlendColorBurn
SVGFEBlendHardLight
SVGFEBlendSoftLight
SVGFEBlendDifference
SVGFEBlendExclusion
SVGFEBlendHue
SVGFEBlendSaturation
SVGFEBlendColor
SVGFEBlendLuminosity
SVGFEColorMatrix
{
values
:
[
f32
;
20
]
}
SVGFEComponentTransfer
SVGFEComponentTransferInterned
{
handle
:
FilterDataHandle
creates_pixels
:
bool
}
SVGFECompositeArithmetic
{
k1
:
f32
k2
:
f32
k3
:
f32
k4
:
f32
}
SVGFECompositeATop
SVGFECompositeIn
SVGFECompositeLighter
SVGFECompositeOut
SVGFECompositeOver
SVGFECompositeXOR
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeNone
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
:
i32
order_y
:
i32
kernel
:
[
f32
;
SVGFE_CONVOLVE_VALUES_LIMIT
]
divisor
:
f32
bias
:
f32
target_x
:
i32
target_y
:
i32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
preserve_alpha
:
i32
}
SVGFEDiffuseLightingDistant
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFEDiffuseLightingPoint
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFEDiffuseLightingSpot
{
surface_scale
:
f32
diffuse_constant
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFEDisplacementMap
{
scale
:
f32
x_channel_selector
:
u32
y_channel_selector
:
u32
}
SVGFEDropShadow
{
color
:
ColorF
dx
:
f32
dy
:
f32
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEFlood
{
color
:
ColorF
}
SVGFEGaussianBlur
{
std_deviation_x
:
f32
std_deviation_y
:
f32
}
SVGFEImage
{
sampling_filter
:
u32
matrix
:
[
f32
;
6
]
}
SVGFEMorphologyDilate
{
radius_x
:
f32
radius_y
:
f32
}
SVGFEMorphologyErode
{
radius_x
:
f32
radius_y
:
f32
}
SVGFESpecularLightingDistant
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
azimuth
:
f32
elevation
:
f32
}
SVGFESpecularLightingPoint
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
}
SVGFESpecularLightingSpot
{
surface_scale
:
f32
specular_constant
:
f32
specular_exponent
:
f32
kernel_unit_length_x
:
f32
kernel_unit_length_y
:
f32
x
:
f32
y
:
f32
z
:
f32
points_at_x
:
f32
points_at_y
:
f32
points_at_z
:
f32
cone_exponent
:
f32
limiting_cone_angle
:
f32
}
SVGFETile
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
:
f32
base_frequency_y
:
f32
num_octaves
:
u32
seed
:
u32
}
}
impl
FilterGraphOp
{
pub
fn
kind
(
&
self
)
-
>
&
'
static
str
{
match
*
self
{
FilterGraphOp
:
:
SVGFEBlendColor
=
>
"
SVGFEBlendColor
"
FilterGraphOp
:
:
SVGFEBlendColorBurn
=
>
"
SVGFEBlendColorBurn
"
FilterGraphOp
:
:
SVGFEBlendColorDodge
=
>
"
SVGFEBlendColorDodge
"
FilterGraphOp
:
:
SVGFEBlendDarken
=
>
"
SVGFEBlendDarken
"
FilterGraphOp
:
:
SVGFEBlendDifference
=
>
"
SVGFEBlendDifference
"
FilterGraphOp
:
:
SVGFEBlendExclusion
=
>
"
SVGFEBlendExclusion
"
FilterGraphOp
:
:
SVGFEBlendHardLight
=
>
"
SVGFEBlendHardLight
"
FilterGraphOp
:
:
SVGFEBlendHue
=
>
"
SVGFEBlendHue
"
FilterGraphOp
:
:
SVGFEBlendLighten
=
>
"
SVGFEBlendLighten
"
FilterGraphOp
:
:
SVGFEBlendLuminosity
=
>
"
SVGFEBlendLuminosity
"
FilterGraphOp
:
:
SVGFEBlendMultiply
=
>
"
SVGFEBlendMultiply
"
FilterGraphOp
:
:
SVGFEBlendNormal
=
>
"
SVGFEBlendNormal
"
FilterGraphOp
:
:
SVGFEBlendOverlay
=
>
"
SVGFEBlendOverlay
"
FilterGraphOp
:
:
SVGFEBlendSaturation
=
>
"
SVGFEBlendSaturation
"
FilterGraphOp
:
:
SVGFEBlendScreen
=
>
"
SVGFEBlendScreen
"
FilterGraphOp
:
:
SVGFEBlendSoftLight
=
>
"
SVGFEBlendSoftLight
"
FilterGraphOp
:
:
SVGFEColorMatrix
{
.
.
}
=
>
"
SVGFEColorMatrix
"
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
"
SVGFEComponentTransfer
"
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
.
.
}
=
>
"
SVGFEComponentTransferInterned
"
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
.
.
}
=
>
"
SVGFECompositeArithmetic
"
FilterGraphOp
:
:
SVGFECompositeATop
=
>
"
SVGFECompositeATop
"
FilterGraphOp
:
:
SVGFECompositeIn
=
>
"
SVGFECompositeIn
"
FilterGraphOp
:
:
SVGFECompositeLighter
=
>
"
SVGFECompositeLighter
"
FilterGraphOp
:
:
SVGFECompositeOut
=
>
"
SVGFECompositeOut
"
FilterGraphOp
:
:
SVGFECompositeOver
=
>
"
SVGFECompositeOver
"
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
"
SVGFECompositeXOR
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeDuplicate
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeNone
"
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
.
.
}
=
>
"
SVGFEConvolveMatrixEdgeModeWrap
"
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
.
.
}
=
>
"
SVGFEDiffuseLightingDistant
"
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
.
.
}
=
>
"
SVGFEDiffuseLightingPoint
"
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
.
.
}
=
>
"
SVGFEDiffuseLightingSpot
"
FilterGraphOp
:
:
SVGFEDisplacementMap
{
.
.
}
=
>
"
SVGFEDisplacementMap
"
FilterGraphOp
:
:
SVGFEDropShadow
{
.
.
}
=
>
"
SVGFEDropShadow
"
FilterGraphOp
:
:
SVGFEFlood
{
.
.
}
=
>
"
SVGFEFlood
"
FilterGraphOp
:
:
SVGFEGaussianBlur
{
.
.
}
=
>
"
SVGFEGaussianBlur
"
FilterGraphOp
:
:
SVGFEIdentity
=
>
"
SVGFEIdentity
"
FilterGraphOp
:
:
SVGFEImage
{
.
.
}
=
>
"
SVGFEImage
"
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
.
.
}
=
>
"
SVGFEMorphologyDilate
"
FilterGraphOp
:
:
SVGFEMorphologyErode
{
.
.
}
=
>
"
SVGFEMorphologyErode
"
FilterGraphOp
:
:
SVGFEOpacity
{
.
.
}
=
>
"
SVGFEOpacity
"
FilterGraphOp
:
:
SVGFESourceAlpha
=
>
"
SVGFESourceAlpha
"
FilterGraphOp
:
:
SVGFESourceGraphic
=
>
"
SVGFESourceGraphic
"
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
.
.
}
=
>
"
SVGFESpecularLightingDistant
"
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
.
.
}
=
>
"
SVGFESpecularLightingPoint
"
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
.
.
}
=
>
"
SVGFESpecularLightingSpot
"
FilterGraphOp
:
:
SVGFETile
=
>
"
SVGFETile
"
FilterGraphOp
:
:
SVGFEToAlpha
=
>
"
SVGFEToAlpha
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithFractalNoiseWithStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
"
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
"
SVGFETurbulenceWithTurbulenceNoiseWithStitching
"
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FilterGraphNode
{
pub
kept_by_optimizer
:
bool
pub
linear
:
bool
pub
inflate
:
i16
pub
inputs
:
Vec
<
FilterGraphPictureReference
>
pub
subregion
:
LayoutRect
}
impl
From
<
FilterOpGraphNode
>
for
FilterGraphNode
{
fn
from
(
node
:
FilterOpGraphNode
)
-
>
Self
{
let
mut
inputs
:
Vec
<
FilterGraphPictureReference
>
=
Vec
:
:
new
(
)
;
if
node
.
input
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input
.
into
(
)
)
;
}
if
node
.
input2
.
buffer_id
!
=
FilterOpGraphPictureBufferId
:
:
None
{
inputs
.
push
(
node
.
input2
.
into
(
)
)
;
}
FilterGraphNode
{
linear
:
node
.
linear
inputs
subregion
:
node
.
subregion
kept_by_optimizer
:
true
inflate
:
0
}
}
}
#
[
derive
(
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Filter
{
Identity
Blur
{
width
:
f32
height
:
f32
should_inflate
:
bool
edge_mode
:
BlurEdgeMode
}
Brightness
(
f32
)
Contrast
(
f32
)
Grayscale
(
f32
)
HueRotate
(
f32
)
Invert
(
f32
)
Opacity
(
api
:
:
PropertyBinding
<
f32
>
f32
)
Saturate
(
f32
)
Sepia
(
f32
)
DropShadows
(
SmallVec
<
[
Shadow
;
1
]
>
)
ColorMatrix
(
Box
<
[
f32
;
20
]
>
)
SrgbToLinear
LinearToSrgb
ComponentTransfer
Flood
(
ColorF
)
SVGGraphNode
(
FilterGraphNode
FilterGraphOp
)
}
impl
Filter
{
pub
fn
is_visible
(
&
self
)
-
>
bool
{
match
*
self
{
Filter
:
:
Identity
|
Filter
:
:
Blur
{
.
.
}
|
Filter
:
:
Brightness
(
.
.
)
|
Filter
:
:
Contrast
(
.
.
)
|
Filter
:
:
Grayscale
(
.
.
)
|
Filter
:
:
HueRotate
(
.
.
)
|
Filter
:
:
Invert
(
.
.
)
|
Filter
:
:
Saturate
(
.
.
)
|
Filter
:
:
Sepia
(
.
.
)
|
Filter
:
:
DropShadows
(
.
.
)
|
Filter
:
:
ColorMatrix
(
.
.
)
|
Filter
:
:
SrgbToLinear
|
Filter
:
:
LinearToSrgb
|
Filter
:
:
ComponentTransfer
=
>
true
Filter
:
:
Opacity
(
_
amount
)
=
>
{
amount
>
OPACITY_EPSILON
}
Filter
:
:
Flood
(
color
)
=
>
{
color
.
a
>
OPACITY_EPSILON
}
Filter
:
:
SVGGraphNode
(
.
.
)
=
>
true
}
}
pub
fn
is_noop
(
&
self
)
-
>
bool
{
match
*
self
{
Filter
:
:
Identity
=
>
false
Filter
:
:
Blur
{
width
height
.
.
}
=
>
width
=
=
0
.
0
&
&
height
=
=
0
.
0
Filter
:
:
Brightness
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Contrast
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Grayscale
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
HueRotate
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
Invert
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
Opacity
(
api
:
:
PropertyBinding
:
:
Value
(
amount
)
_
)
=
>
amount
>
=
1
.
0
Filter
:
:
Saturate
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Sepia
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
DropShadows
(
ref
shadows
)
=
>
{
for
shadow
in
shadows
{
if
shadow
.
offset
.
x
!
=
0
.
0
|
|
shadow
.
offset
.
y
!
=
0
.
0
|
|
shadow
.
blur_radius
!
=
0
.
0
{
return
false
;
}
}
true
}
Filter
:
:
ColorMatrix
(
ref
matrix
)
=
>
{
*
*
matrix
=
=
[
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
]
}
Filter
:
:
Opacity
(
api
:
:
PropertyBinding
:
:
Binding
(
.
.
)
_
)
|
Filter
:
:
SrgbToLinear
|
Filter
:
:
LinearToSrgb
|
Filter
:
:
ComponentTransfer
|
Filter
:
:
Flood
(
.
.
)
=
>
false
Filter
:
:
SVGGraphNode
(
.
.
)
=
>
false
}
}
pub
fn
as_int
(
&
self
)
-
>
i32
{
match
*
self
{
Filter
:
:
Identity
=
>
0
Filter
:
:
Contrast
(
.
.
)
=
>
0
Filter
:
:
Grayscale
(
.
.
)
=
>
1
Filter
:
:
HueRotate
(
.
.
)
=
>
2
Filter
:
:
Invert
(
.
.
)
=
>
3
Filter
:
:
Saturate
(
.
.
)
=
>
4
Filter
:
:
Sepia
(
.
.
)
=
>
5
Filter
:
:
Brightness
(
.
.
)
=
>
6
Filter
:
:
ColorMatrix
(
.
.
)
=
>
7
Filter
:
:
SrgbToLinear
=
>
8
Filter
:
:
LinearToSrgb
=
>
9
Filter
:
:
Flood
(
.
.
)
=
>
10
Filter
:
:
ComponentTransfer
=
>
11
Filter
:
:
Blur
{
.
.
}
=
>
12
Filter
:
:
DropShadows
(
.
.
)
=
>
13
Filter
:
:
Opacity
(
.
.
)
=
>
14
Filter
:
:
SVGGraphNode
(
.
.
)
=
>
unreachable
!
(
"
SVGGraphNode
handled
elsewhere
"
)
}
}
}
impl
From
<
FilterOp
>
for
Filter
{
fn
from
(
op
:
FilterOp
)
-
>
Self
{
match
op
{
FilterOp
:
:
Identity
=
>
Filter
:
:
Identity
FilterOp
:
:
Blur
(
width
height
)
=
>
Filter
:
:
Blur
{
width
height
should_inflate
:
true
edge_mode
:
BlurEdgeMode
:
:
Duplicate
}
FilterOp
:
:
Brightness
(
b
)
=
>
Filter
:
:
Brightness
(
b
)
FilterOp
:
:
Contrast
(
c
)
=
>
Filter
:
:
Contrast
(
c
)
FilterOp
:
:
Grayscale
(
g
)
=
>
Filter
:
:
Grayscale
(
g
)
FilterOp
:
:
HueRotate
(
h
)
=
>
Filter
:
:
HueRotate
(
h
)
FilterOp
:
:
Invert
(
i
)
=
>
Filter
:
:
Invert
(
i
)
FilterOp
:
:
Opacity
(
binding
opacity
)
=
>
Filter
:
:
Opacity
(
binding
opacity
)
FilterOp
:
:
Saturate
(
s
)
=
>
Filter
:
:
Saturate
(
s
)
FilterOp
:
:
Sepia
(
s
)
=
>
Filter
:
:
Sepia
(
s
)
FilterOp
:
:
ColorMatrix
(
mat
)
=
>
Filter
:
:
ColorMatrix
(
Box
:
:
new
(
mat
)
)
FilterOp
:
:
SrgbToLinear
=
>
Filter
:
:
SrgbToLinear
FilterOp
:
:
LinearToSrgb
=
>
Filter
:
:
LinearToSrgb
FilterOp
:
:
ComponentTransfer
=
>
Filter
:
:
ComponentTransfer
FilterOp
:
:
DropShadow
(
shadow
)
=
>
Filter
:
:
DropShadows
(
smallvec
!
[
shadow
]
)
FilterOp
:
:
Flood
(
color
)
=
>
Filter
:
:
Flood
(
color
)
FilterOp
:
:
SVGFEBlendColor
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendColor
)
FilterOp
:
:
SVGFEBlendColorBurn
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendColorBurn
)
FilterOp
:
:
SVGFEBlendColorDodge
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendColorDodge
)
FilterOp
:
:
SVGFEBlendDarken
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendDarken
)
FilterOp
:
:
SVGFEBlendDifference
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendDifference
)
FilterOp
:
:
SVGFEBlendExclusion
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendExclusion
)
FilterOp
:
:
SVGFEBlendHardLight
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendHardLight
)
FilterOp
:
:
SVGFEBlendHue
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendHue
)
FilterOp
:
:
SVGFEBlendLighten
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendLighten
)
FilterOp
:
:
SVGFEBlendLuminosity
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendLuminosity
)
FilterOp
:
:
SVGFEBlendMultiply
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendMultiply
)
FilterOp
:
:
SVGFEBlendNormal
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendNormal
)
FilterOp
:
:
SVGFEBlendOverlay
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendOverlay
)
FilterOp
:
:
SVGFEBlendSaturation
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendSaturation
)
FilterOp
:
:
SVGFEBlendScreen
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendScreen
)
FilterOp
:
:
SVGFEBlendSoftLight
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEBlendSoftLight
)
FilterOp
:
:
SVGFEColorMatrix
{
node
values
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEColorMatrix
{
values
}
)
FilterOp
:
:
SVGFEComponentTransfer
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEComponentTransfer
)
FilterOp
:
:
SVGFECompositeArithmetic
{
node
k1
k2
k3
k4
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
k1
k2
k3
k4
}
)
FilterOp
:
:
SVGFECompositeATop
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeATop
)
FilterOp
:
:
SVGFECompositeIn
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeIn
)
FilterOp
:
:
SVGFECompositeLighter
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeLighter
)
FilterOp
:
:
SVGFECompositeOut
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeOut
)
FilterOp
:
:
SVGFECompositeOver
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeOver
)
FilterOp
:
:
SVGFECompositeXOR
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFECompositeXOR
)
FilterOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
node
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
)
FilterOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
node
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
)
FilterOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
node
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
order_x
order_y
kernel
divisor
bias
target_x
target_y
kernel_unit_length_x
kernel_unit_length_y
preserve_alpha
}
)
FilterOp
:
:
SVGFEDiffuseLightingDistant
{
node
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
)
FilterOp
:
:
SVGFEDiffuseLightingPoint
{
node
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
)
FilterOp
:
:
SVGFEDiffuseLightingSpot
{
node
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
surface_scale
diffuse_constant
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
)
FilterOp
:
:
SVGFEDisplacementMap
{
node
scale
x_channel_selector
y_channel_selector
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEDisplacementMap
{
scale
x_channel_selector
y_channel_selector
}
)
FilterOp
:
:
SVGFEDropShadow
{
node
color
dx
dy
std_deviation_x
std_deviation_y
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEDropShadow
{
color
dx
dy
std_deviation_x
std_deviation_y
}
)
FilterOp
:
:
SVGFEFlood
{
node
color
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEFlood
{
color
}
)
FilterOp
:
:
SVGFEGaussianBlur
{
node
std_deviation_x
std_deviation_y
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEGaussianBlur
{
std_deviation_x
std_deviation_y
}
)
FilterOp
:
:
SVGFEIdentity
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEIdentity
)
FilterOp
:
:
SVGFEImage
{
node
sampling_filter
matrix
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEImage
{
sampling_filter
matrix
}
)
FilterOp
:
:
SVGFEMorphologyDilate
{
node
radius_x
radius_y
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
radius_x
radius_y
}
)
FilterOp
:
:
SVGFEMorphologyErode
{
node
radius_x
radius_y
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEMorphologyErode
{
radius_x
radius_y
}
)
FilterOp
:
:
SVGFEOffset
{
node
offset_x
offset_y
}
=
>
{
Filter
:
:
SVGGraphNode
(
FilterGraphNode
{
kept_by_optimizer
:
true
linear
:
node
.
linear
inflate
:
0
inputs
:
[
FilterGraphPictureReference
{
buffer_id
:
node
.
input
.
buffer_id
offset
:
LayoutVector2D
:
:
new
(
offset_x
offset_y
)
subregion
:
LayoutRect
:
:
zero
(
)
inflate
:
0
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
]
.
to_vec
(
)
subregion
:
node
.
subregion
}
FilterGraphOp
:
:
SVGFEIdentity
)
}
FilterOp
:
:
SVGFEOpacity
{
node
valuebinding
value
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEOpacity
{
valuebinding
value
}
)
FilterOp
:
:
SVGFESourceAlpha
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFESourceAlpha
)
FilterOp
:
:
SVGFESourceGraphic
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFESourceGraphic
)
FilterOp
:
:
SVGFESpecularLightingDistant
{
node
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
azimuth
elevation
}
)
FilterOp
:
:
SVGFESpecularLightingPoint
{
node
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
}
)
FilterOp
:
:
SVGFESpecularLightingSpot
{
node
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
surface_scale
specular_constant
specular_exponent
kernel_unit_length_x
kernel_unit_length_y
x
y
z
points_at_x
points_at_y
points_at_z
cone_exponent
limiting_cone_angle
}
)
FilterOp
:
:
SVGFETile
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFETile
)
FilterOp
:
:
SVGFEToAlpha
{
node
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFEToAlpha
)
FilterOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
node
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
)
FilterOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
node
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
)
FilterOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
node
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
)
FilterOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
node
base_frequency_x
base_frequency_y
num_octaves
seed
}
=
>
Filter
:
:
SVGGraphNode
(
node
.
into
(
)
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
base_frequency_x
base_frequency_y
num_octaves
seed
}
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
enum
Swizzle
{
Rgba
Bgra
}
impl
Default
for
Swizzle
{
fn
default
(
)
-
>
Self
{
Swizzle
:
:
Rgba
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
SwizzleSettings
{
pub
bgra8_sampling_swizzle
:
Swizzle
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheTextureId
(
pub
u32
)
;
impl
CacheTextureId
{
pub
const
INVALID
:
CacheTextureId
=
CacheTextureId
(
!
0
)
;
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeferredResolveIndex
(
pub
u32
)
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
TextureSourceExternal
{
pub
index
:
DeferredResolveIndex
pub
kind
:
ImageBufferKind
pub
normalized_uvs
:
bool
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureSource
{
Invalid
TextureCache
(
CacheTextureId
Swizzle
)
External
(
TextureSourceExternal
)
Dummy
}
impl
TextureSource
{
pub
fn
image_buffer_kind
(
&
self
)
-
>
ImageBufferKind
{
match
*
self
{
TextureSource
:
:
TextureCache
(
.
.
)
=
>
ImageBufferKind
:
:
Texture2D
TextureSource
:
:
External
(
TextureSourceExternal
{
kind
.
.
}
)
=
>
kind
TextureSource
:
:
Dummy
=
>
ImageBufferKind
:
:
Texture2D
TextureSource
:
:
Invalid
=
>
ImageBufferKind
:
:
Texture2D
}
}
pub
fn
uses_normalized_uvs
(
&
self
)
-
>
bool
{
match
*
self
{
TextureSource
:
:
External
(
TextureSourceExternal
{
normalized_uvs
.
.
}
)
=
>
normalized_uvs
_
=
>
false
}
}
#
[
inline
]
pub
fn
is_compatible
(
&
self
other
:
&
TextureSource
)
-
>
bool
{
*
self
=
=
TextureSource
:
:
Invalid
|
|
*
other
=
=
TextureSource
:
:
Invalid
|
|
self
=
=
other
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTargetInfo
{
pub
has_depth
:
bool
}
#
[
derive
(
Debug
)
]
pub
enum
TextureUpdateSource
{
External
{
id
:
ExternalImageId
channel_index
:
u8
}
Bytes
{
data
:
Arc
<
Vec
<
u8
>
>
}
DebugClear
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheAllocation
{
pub
id
:
CacheTextureId
pub
kind
:
TextureCacheAllocationKind
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureCacheCategory
{
Atlas
Standalone
PictureTile
RenderTarget
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
struct
TextureCacheAllocInfo
{
pub
width
:
i32
pub
height
:
i32
pub
format
:
ImageFormat
pub
filter
:
TextureFilter
pub
target
:
ImageBufferKind
pub
is_shared_cache
:
bool
pub
has_depth
:
bool
pub
category
:
TextureCacheCategory
}
#
[
derive
(
Debug
)
]
pub
enum
TextureCacheAllocationKind
{
Alloc
(
TextureCacheAllocInfo
)
Reset
(
TextureCacheAllocInfo
)
Free
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheUpdate
{
pub
rect
:
DeviceIntRect
pub
stride
:
Option
<
i32
>
pub
offset
:
i32
pub
format_override
:
Option
<
ImageFormat
>
pub
source
:
TextureUpdateSource
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheCopy
{
pub
src_rect
:
DeviceIntRect
pub
dst_rect
:
DeviceIntRect
}
#
[
derive
(
Default
)
]
pub
struct
TextureUpdateList
{
pub
clears_shared_cache
:
bool
pub
allocations
:
Vec
<
TextureCacheAllocation
>
pub
updates
:
FastHashMap
<
CacheTextureId
Vec
<
TextureCacheUpdate
>
>
pub
copies
:
FastHashMap
<
(
CacheTextureId
CacheTextureId
)
Vec
<
TextureCacheCopy
>
>
}
impl
TextureUpdateList
{
pub
fn
new
(
)
-
>
Self
{
TextureUpdateList
{
clears_shared_cache
:
false
allocations
:
Vec
:
:
new
(
)
updates
:
FastHashMap
:
:
default
(
)
copies
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
is_nop
(
&
self
)
-
>
bool
{
self
.
allocations
.
is_empty
(
)
&
&
self
.
updates
.
is_empty
(
)
}
#
[
inline
]
pub
fn
note_clear
(
&
mut
self
)
{
self
.
clears_shared_cache
=
true
;
}
#
[
inline
]
pub
fn
push_update
(
&
mut
self
id
:
CacheTextureId
update
:
TextureCacheUpdate
)
{
self
.
updates
.
entry
(
id
)
.
or_default
(
)
.
push
(
update
)
;
}
#
[
cold
]
pub
fn
push_debug_clear
(
&
mut
self
id
:
CacheTextureId
origin
:
DeviceIntPoint
width
:
i32
height
:
i32
)
{
let
size
=
DeviceIntSize
:
:
new
(
width
height
)
;
let
rect
=
DeviceIntRect
:
:
from_origin_and_size
(
origin
size
)
;
self
.
push_update
(
id
TextureCacheUpdate
{
rect
stride
:
None
offset
:
0
format_override
:
None
source
:
TextureUpdateSource
:
:
DebugClear
}
)
;
}
pub
fn
push_alloc
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
debug_assert
!
(
!
self
.
allocations
.
iter
(
)
.
any
(
|
x
|
x
.
id
=
=
id
)
)
;
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Alloc
(
info
)
}
)
;
}
pub
fn
push_reset
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
self
.
debug_assert_coalesced
(
id
)
;
self
.
updates
.
remove
(
&
id
)
;
if
let
Some
(
cur
)
=
self
.
allocations
.
iter_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
id
)
{
match
cur
.
kind
{
TextureCacheAllocationKind
:
:
Alloc
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Reset
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Free
=
>
panic
!
(
"
Resetting
freed
texture
"
)
}
return
}
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Reset
(
info
)
}
)
;
}
pub
fn
push_free
(
&
mut
self
id
:
CacheTextureId
)
{
self
.
debug_assert_coalesced
(
id
)
;
self
.
updates
.
remove
(
&
id
)
;
let
idx
=
self
.
allocations
.
iter
(
)
.
position
(
|
x
|
x
.
id
=
=
id
)
;
let
removed_kind
=
idx
.
map
(
|
i
|
self
.
allocations
.
remove
(
i
)
.
kind
)
;
match
removed_kind
{
Some
(
TextureCacheAllocationKind
:
:
Alloc
(
.
.
)
)
=
>
{
}
Some
(
TextureCacheAllocationKind
:
:
Free
)
=
>
panic
!
(
"
Double
free
"
)
Some
(
TextureCacheAllocationKind
:
:
Reset
(
.
.
)
)
|
None
=
>
{
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Free
}
)
;
}
}
;
}
pub
fn
push_copy
(
&
mut
self
src_id
:
CacheTextureId
src_rect
:
&
DeviceIntRect
dst_id
:
CacheTextureId
dst_rect
:
&
DeviceIntRect
)
{
debug_assert_eq
!
(
src_rect
.
size
(
)
dst_rect
.
size
(
)
)
;
self
.
copies
.
entry
(
(
src_id
dst_id
)
)
.
or_insert_with
(
Vec
:
:
new
)
.
push
(
TextureCacheCopy
{
src_rect
:
*
src_rect
dst_rect
:
*
dst_rect
}
)
;
}
fn
debug_assert_coalesced
(
&
self
id
:
CacheTextureId
)
{
debug_assert
!
(
self
.
allocations
.
iter
(
)
.
filter
(
|
x
|
x
.
id
=
=
id
)
.
count
(
)
<
=
1
"
Allocations
should
have
been
coalesced
"
)
;
}
}
pub
struct
ResourceUpdateList
{
pub
native_surface_updates
:
Vec
<
NativeSurfaceOperation
>
pub
texture_updates
:
TextureUpdateList
}
impl
ResourceUpdateList
{
pub
fn
is_nop
(
&
self
)
-
>
bool
{
self
.
texture_updates
.
is_nop
(
)
&
&
self
.
native_surface_updates
.
is_empty
(
)
}
}
pub
struct
RenderedDocument
{
pub
frame
:
Frame
pub
profile
:
TransactionProfile
pub
render_reasons
:
RenderReasons
pub
frame_stats
:
Option
<
FullFrameStats
>
}
pub
enum
DebugOutput
{
#
[
cfg
(
feature
=
"
capture
"
)
]
SaveCapture
(
CaptureConfig
Vec
<
ExternalCaptureImage
>
)
#
[
cfg
(
feature
=
"
replay
"
)
]
LoadCapture
(
CaptureConfig
Vec
<
PlainExternalImage
>
)
}
#
[
allow
(
dead_code
)
]
pub
enum
ResultMsg
{
DebugCommand
(
DebugCommand
)
DebugOutput
(
DebugOutput
)
RefreshShader
(
PathBuf
)
UpdateGpuCache
(
GpuCacheUpdateList
)
UpdateResources
{
resource_updates
:
ResourceUpdateList
memory_pressure
:
bool
}
PublishPipelineInfo
(
PipelineInfo
)
PublishDocument
(
FramePublishId
DocumentId
RenderedDocument
ResourceUpdateList
)
RenderDocumentOffscreen
(
DocumentId
RenderedDocument
ResourceUpdateList
)
AppendNotificationRequests
(
Vec
<
NotificationRequest
>
)
SetParameter
(
Parameter
)
ForceRedraw
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
LayoutPrimitiveInfo
{
pub
rect
:
LayoutRect
pub
clip_rect
:
LayoutRect
pub
flags
:
PrimitiveFlags
}
impl
LayoutPrimitiveInfo
{
pub
fn
with_clip_rect
(
rect
:
LayoutRect
clip_rect
:
LayoutRect
)
-
>
Self
{
Self
{
rect
clip_rect
flags
:
PrimitiveFlags
:
:
default
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Copy
Clone
PartialEq
Debug
Eq
Hash
)
]
pub
struct
PipelineInstanceId
(
u32
)
;
impl
PipelineInstanceId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
PipelineInstanceId
(
id
)
}
}
