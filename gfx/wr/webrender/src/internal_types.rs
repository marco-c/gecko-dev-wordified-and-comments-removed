use
api
:
:
{
DebugCommand
DocumentId
ExternalImageData
ExternalImageId
}
;
use
api
:
:
{
ImageFormat
ItemTag
NotificationRequest
}
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
device
:
:
TextureFilter
;
use
crate
:
:
renderer
:
:
PipelineInfo
;
use
crate
:
:
gpu_cache
:
:
GpuCacheUpdateList
;
use
fxhash
:
:
FxHasher
;
use
plane_split
:
:
BspSplitter
;
use
crate
:
:
profiler
:
:
BackendProfileCounters
;
use
std
:
:
{
usize
i32
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
f32
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
Arc
;
#
[
cfg
(
feature
=
"
capture
"
)
]
use
crate
:
:
capture
:
:
{
CaptureConfig
ExternalCaptureImage
}
;
#
[
cfg
(
feature
=
"
replay
"
)
]
use
crate
:
:
capture
:
:
PlainExternalImage
;
use
crate
:
:
tiling
;
pub
type
FastHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
FxHasher
>
>
;
pub
type
FastHashSet
<
K
>
=
HashSet
<
K
BuildHasherDefault
<
FxHasher
>
>
;
pub
type
PlaneSplitter
=
BspSplitter
<
f64
WorldPixel
>
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheTextureId
(
pub
u64
)
;
pub
type
LayerIndex
=
usize
;
#
[
derive
(
Debug
Copy
Clone
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
SavedTargetIndex
(
pub
usize
)
;
impl
SavedTargetIndex
{
pub
const
PENDING
:
Self
=
SavedTargetIndex
(
!
0
)
;
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureSource
{
Invalid
TextureCache
(
CacheTextureId
)
External
(
ExternalImageData
)
PrevPassAlpha
PrevPassColor
RenderTaskCache
(
SavedTargetIndex
)
}
pub
const
ORTHO_NEAR_PLANE
:
f32
=
-
(
1
<
<
22
)
as
f32
;
pub
const
ORTHO_FAR_PLANE
:
f32
=
(
(
1
<
<
22
)
-
1
)
as
f32
;
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTargetInfo
{
pub
has_depth
:
bool
}
#
[
derive
(
Debug
)
]
pub
enum
TextureUpdateSource
{
External
{
id
:
ExternalImageId
channel_index
:
u8
}
Bytes
{
data
:
Arc
<
Vec
<
u8
>
>
}
DebugClear
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheAllocation
{
pub
id
:
CacheTextureId
pub
kind
:
TextureCacheAllocationKind
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheAllocInfo
{
pub
width
:
i32
pub
height
:
i32
pub
layer_count
:
i32
pub
format
:
ImageFormat
pub
filter
:
TextureFilter
pub
is_shared_cache
:
bool
}
#
[
derive
(
Debug
)
]
pub
enum
TextureCacheAllocationKind
{
Alloc
(
TextureCacheAllocInfo
)
Realloc
(
TextureCacheAllocInfo
)
Reset
(
TextureCacheAllocInfo
)
Free
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheUpdate
{
pub
id
:
CacheTextureId
pub
rect
:
DeviceIntRect
pub
stride
:
Option
<
i32
>
pub
offset
:
i32
pub
layer_index
:
i32
pub
source
:
TextureUpdateSource
}
#
[
derive
(
Default
)
]
pub
struct
TextureUpdateList
{
pub
clears_shared_cache
:
bool
pub
allocations
:
Vec
<
TextureCacheAllocation
>
pub
updates
:
Vec
<
TextureCacheUpdate
>
}
impl
TextureUpdateList
{
pub
fn
new
(
)
-
>
Self
{
TextureUpdateList
{
clears_shared_cache
:
false
allocations
:
Vec
:
:
new
(
)
updates
:
Vec
:
:
new
(
)
}
}
#
[
inline
]
pub
fn
note_clear
(
&
mut
self
)
{
self
.
clears_shared_cache
=
true
;
}
#
[
inline
]
pub
fn
push_update
(
&
mut
self
update
:
TextureCacheUpdate
)
{
self
.
updates
.
push
(
update
)
;
}
#
[
cold
]
pub
fn
push_debug_clear
(
&
mut
self
id
:
CacheTextureId
origin
:
DeviceIntPoint
width
:
i32
height
:
i32
layer_index
:
usize
)
{
let
size
=
DeviceIntSize
:
:
new
(
width
height
)
;
let
rect
=
DeviceIntRect
:
:
new
(
origin
size
)
;
self
.
push_update
(
TextureCacheUpdate
{
id
rect
source
:
TextureUpdateSource
:
:
DebugClear
stride
:
None
offset
:
0
layer_index
:
layer_index
as
i32
}
)
;
}
pub
fn
push_alloc
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
debug_assert
!
(
!
self
.
allocations
.
iter
(
)
.
any
(
|
x
|
x
.
id
=
=
id
)
)
;
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Alloc
(
info
)
}
)
;
}
pub
fn
push_realloc
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
self
.
debug_assert_coalesced
(
id
)
;
if
let
Some
(
cur
)
=
self
.
allocations
.
iter_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
id
)
{
match
cur
.
kind
{
TextureCacheAllocationKind
:
:
Alloc
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Realloc
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Reset
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Free
=
>
panic
!
(
"
Reallocating
freed
texture
"
)
}
return
}
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Realloc
(
info
)
}
)
;
}
pub
fn
push_reset
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
self
.
debug_assert_coalesced
(
id
)
;
if
let
Some
(
cur
)
=
self
.
allocations
.
iter_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
id
)
{
match
cur
.
kind
{
TextureCacheAllocationKind
:
:
Alloc
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Reset
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Free
=
>
panic
!
(
"
Resetting
freed
texture
"
)
TextureCacheAllocationKind
:
:
Realloc
(
_
)
=
>
{
cur
.
kind
=
TextureCacheAllocationKind
:
:
Reset
(
info
)
;
}
}
return
}
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Reset
(
info
)
}
)
;
}
pub
fn
push_free
(
&
mut
self
id
:
CacheTextureId
)
{
self
.
debug_assert_coalesced
(
id
)
;
self
.
updates
.
retain
(
|
x
|
x
.
id
!
=
id
)
;
let
idx
=
self
.
allocations
.
iter
(
)
.
position
(
|
x
|
x
.
id
=
=
id
)
;
let
removed_kind
=
idx
.
map
(
|
i
|
self
.
allocations
.
remove
(
i
)
.
kind
)
;
match
removed_kind
{
Some
(
TextureCacheAllocationKind
:
:
Alloc
(
.
.
)
)
=
>
{
}
Some
(
TextureCacheAllocationKind
:
:
Free
)
=
>
panic
!
(
"
Double
free
"
)
Some
(
TextureCacheAllocationKind
:
:
Realloc
(
.
.
)
)
|
Some
(
TextureCacheAllocationKind
:
:
Reset
(
.
.
)
)
|
None
=
>
{
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Free
}
)
;
}
}
;
}
fn
debug_assert_coalesced
(
&
self
id
:
CacheTextureId
)
{
debug_assert
!
(
self
.
allocations
.
iter
(
)
.
filter
(
|
x
|
x
.
id
=
=
id
)
.
count
(
)
<
=
1
"
Allocations
should
have
been
coalesced
"
)
;
}
}
pub
struct
RenderedDocument
{
pub
frame
:
tiling
:
:
Frame
pub
is_new_scene
:
bool
}
pub
enum
DebugOutput
{
FetchDocuments
(
String
)
FetchClipScrollTree
(
String
)
#
[
cfg
(
feature
=
"
capture
"
)
]
SaveCapture
(
CaptureConfig
Vec
<
ExternalCaptureImage
>
)
#
[
cfg
(
feature
=
"
replay
"
)
]
LoadCapture
(
PathBuf
Vec
<
PlainExternalImage
>
)
}
#
[
allow
(
dead_code
)
]
pub
enum
ResultMsg
{
DebugCommand
(
DebugCommand
)
DebugOutput
(
DebugOutput
)
RefreshShader
(
PathBuf
)
UpdateGpuCache
(
GpuCacheUpdateList
)
UpdateResources
{
updates
:
TextureUpdateList
memory_pressure
:
bool
}
PublishPipelineInfo
(
PipelineInfo
)
PublishDocument
(
DocumentId
RenderedDocument
TextureUpdateList
BackendProfileCounters
)
AppendNotificationRequests
(
Vec
<
NotificationRequest
>
)
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ResourceCacheError
{
description
:
String
}
impl
ResourceCacheError
{
pub
fn
new
(
description
:
String
)
-
>
ResourceCacheError
{
ResourceCacheError
{
description
}
}
}
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
LayoutPrimitiveInfo
{
pub
rect
:
LayoutRect
pub
clip_rect
:
LayoutRect
pub
is_backface_visible
:
bool
pub
hit_info
:
Option
<
ItemTag
>
}
impl
LayoutPrimitiveInfo
{
pub
fn
with_clip_rect
(
rect
:
LayoutRect
clip_rect
:
LayoutRect
)
-
>
Self
{
Self
{
rect
clip_rect
is_backface_visible
:
true
hit_info
:
None
}
}
}
