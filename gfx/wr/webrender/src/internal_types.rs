use
api
:
:
{
ColorF
DocumentId
ExternalImageId
PrimitiveFlags
Parameter
RenderReasons
}
;
use
api
:
:
{
ImageFormat
NotificationRequest
Shadow
FilterOp
ImageBufferKind
}
;
use
api
:
:
units
:
:
*
;
use
api
;
use
crate
:
:
render_api
:
:
DebugCommand
;
use
crate
:
:
composite
:
:
NativeSurfaceOperation
;
use
crate
:
:
device
:
:
TextureFilter
;
use
crate
:
:
renderer
:
:
{
FullFrameStats
PipelineInfo
}
;
use
crate
:
:
gpu_cache
:
:
GpuCacheUpdateList
;
use
crate
:
:
frame_builder
:
:
Frame
;
use
crate
:
:
profiler
:
:
TransactionProfile
;
use
fxhash
:
:
FxHasher
;
use
plane_split
:
:
BspSplitter
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
{
usize
i32
}
;
use
std
:
:
collections
:
:
{
HashMap
HashSet
}
;
use
std
:
:
f32
;
use
std
:
:
hash
:
:
BuildHasherDefault
;
use
std
:
:
path
:
:
PathBuf
;
use
std
:
:
sync
:
:
Arc
;
use
std
:
:
time
:
:
{
UNIX_EPOCH
SystemTime
}
;
#
[
cfg
(
any
(
feature
=
"
capture
"
feature
=
"
replay
"
)
)
]
use
crate
:
:
capture
:
:
CaptureConfig
;
#
[
cfg
(
feature
=
"
capture
"
)
]
use
crate
:
:
capture
:
:
ExternalCaptureImage
;
#
[
cfg
(
feature
=
"
replay
"
)
]
use
crate
:
:
capture
:
:
PlainExternalImage
;
pub
type
FastHashMap
<
K
V
>
=
HashMap
<
K
V
BuildHasherDefault
<
FxHasher
>
>
;
pub
type
FastHashSet
<
K
>
=
HashSet
<
K
BuildHasherDefault
<
FxHasher
>
>
;
#
[
derive
(
Copy
Clone
Hash
MallocSizeOf
PartialEq
PartialOrd
Debug
Eq
Ord
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FrameId
(
usize
)
;
impl
FrameId
{
pub
fn
first
(
)
-
>
Self
{
FrameId
(
0
)
}
pub
fn
as_usize
(
&
self
)
-
>
usize
{
self
.
0
}
pub
fn
advance
(
&
mut
self
)
{
self
.
0
+
=
1
;
}
pub
const
INVALID
:
FrameId
=
FrameId
(
0
)
;
}
impl
Default
for
FrameId
{
fn
default
(
)
-
>
Self
{
FrameId
:
:
INVALID
}
}
impl
:
:
std
:
:
ops
:
:
Add
<
usize
>
for
FrameId
{
type
Output
=
Self
;
fn
add
(
self
other
:
usize
)
-
>
FrameId
{
FrameId
(
self
.
0
+
other
)
}
}
impl
:
:
std
:
:
ops
:
:
Sub
<
usize
>
for
FrameId
{
type
Output
=
Self
;
fn
sub
(
self
other
:
usize
)
-
>
FrameId
{
assert
!
(
self
.
0
>
=
other
"
Underflow
subtracting
FrameIds
"
)
;
FrameId
(
self
.
0
-
other
)
}
}
#
[
derive
(
Copy
Clone
Debug
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
FrameStamp
{
id
:
FrameId
time
:
SystemTime
document_id
:
DocumentId
}
impl
Eq
for
FrameStamp
{
}
impl
PartialEq
for
FrameStamp
{
fn
eq
(
&
self
other
:
&
Self
)
-
>
bool
{
debug_assert
!
(
self
.
document_id
=
=
other
.
document_id
)
;
self
.
id
=
=
other
.
id
}
}
impl
PartialOrd
for
FrameStamp
{
fn
partial_cmp
(
&
self
other
:
&
Self
)
-
>
Option
<
:
:
std
:
:
cmp
:
:
Ordering
>
{
self
.
id
.
partial_cmp
(
&
other
.
id
)
}
}
impl
FrameStamp
{
pub
fn
frame_id
(
&
self
)
-
>
FrameId
{
self
.
id
}
pub
fn
time
(
&
self
)
-
>
SystemTime
{
self
.
time
}
pub
fn
document_id
(
&
self
)
-
>
DocumentId
{
self
.
document_id
}
pub
fn
is_valid
(
&
self
)
-
>
bool
{
debug_assert
!
(
(
self
.
time
!
=
UNIX_EPOCH
&
&
self
.
id
!
=
FrameId
(
0
)
&
&
self
.
document_id
!
=
DocumentId
:
:
INVALID
)
|
|
*
self
=
=
Self
:
:
INVALID
)
;
self
.
document_id
!
=
DocumentId
:
:
INVALID
}
pub
fn
first
(
document_id
:
DocumentId
)
-
>
Self
{
FrameStamp
{
id
:
FrameId
:
:
first
(
)
time
:
SystemTime
:
:
now
(
)
document_id
}
}
pub
fn
advance
(
&
mut
self
)
{
self
.
id
.
advance
(
)
;
self
.
time
=
SystemTime
:
:
now
(
)
;
}
pub
const
INVALID
:
FrameStamp
=
FrameStamp
{
id
:
FrameId
(
0
)
time
:
UNIX_EPOCH
document_id
:
DocumentId
:
:
INVALID
}
;
}
#
[
derive
(
Copy
Clone
Debug
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PlaneSplitAnchor
{
pub
cluster_index
:
usize
pub
instance_index
:
usize
}
impl
PlaneSplitAnchor
{
pub
fn
new
(
cluster_index
:
usize
instance_index
:
usize
)
-
>
Self
{
PlaneSplitAnchor
{
cluster_index
instance_index
}
}
}
impl
Default
for
PlaneSplitAnchor
{
fn
default
(
)
-
>
Self
{
PlaneSplitAnchor
{
cluster_index
:
0
instance_index
:
0
}
}
}
pub
type
PlaneSplitter
=
BspSplitter
<
f64
WorldPixel
PlaneSplitAnchor
>
;
#
[
derive
(
Debug
Copy
Clone
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
pub
struct
PlaneSplitterIndex
(
pub
usize
)
;
const
OPACITY_EPSILON
:
f32
=
0
.
001
;
#
[
derive
(
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
Filter
{
Identity
Blur
(
f32
f32
)
Brightness
(
f32
)
Contrast
(
f32
)
Grayscale
(
f32
)
HueRotate
(
f32
)
Invert
(
f32
)
Opacity
(
api
:
:
PropertyBinding
<
f32
>
f32
)
Saturate
(
f32
)
Sepia
(
f32
)
DropShadows
(
SmallVec
<
[
Shadow
;
1
]
>
)
ColorMatrix
(
Box
<
[
f32
;
20
]
>
)
SrgbToLinear
LinearToSrgb
ComponentTransfer
Flood
(
ColorF
)
}
impl
Filter
{
pub
fn
is_visible
(
&
self
)
-
>
bool
{
match
*
self
{
Filter
:
:
Identity
|
Filter
:
:
Blur
(
.
.
)
|
Filter
:
:
Brightness
(
.
.
)
|
Filter
:
:
Contrast
(
.
.
)
|
Filter
:
:
Grayscale
(
.
.
)
|
Filter
:
:
HueRotate
(
.
.
)
|
Filter
:
:
Invert
(
.
.
)
|
Filter
:
:
Saturate
(
.
.
)
|
Filter
:
:
Sepia
(
.
.
)
|
Filter
:
:
DropShadows
(
.
.
)
|
Filter
:
:
ColorMatrix
(
.
.
)
|
Filter
:
:
SrgbToLinear
|
Filter
:
:
LinearToSrgb
|
Filter
:
:
ComponentTransfer
=
>
true
Filter
:
:
Opacity
(
_
amount
)
=
>
{
amount
>
OPACITY_EPSILON
}
Filter
:
:
Flood
(
color
)
=
>
{
color
.
a
>
OPACITY_EPSILON
}
}
}
pub
fn
is_noop
(
&
self
)
-
>
bool
{
match
*
self
{
Filter
:
:
Identity
=
>
false
Filter
:
:
Blur
(
width
height
)
=
>
width
=
=
0
.
0
&
&
height
=
=
0
.
0
Filter
:
:
Brightness
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Contrast
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Grayscale
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
HueRotate
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
Invert
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
Opacity
(
api
:
:
PropertyBinding
:
:
Value
(
amount
)
_
)
=
>
amount
>
=
1
.
0
Filter
:
:
Saturate
(
amount
)
=
>
amount
=
=
1
.
0
Filter
:
:
Sepia
(
amount
)
=
>
amount
=
=
0
.
0
Filter
:
:
DropShadows
(
ref
shadows
)
=
>
{
for
shadow
in
shadows
{
if
shadow
.
offset
.
x
!
=
0
.
0
|
|
shadow
.
offset
.
y
!
=
0
.
0
|
|
shadow
.
blur_radius
!
=
0
.
0
{
return
false
;
}
}
true
}
Filter
:
:
ColorMatrix
(
ref
matrix
)
=
>
{
*
*
matrix
=
=
[
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
0
.
0
0
.
0
]
}
Filter
:
:
Opacity
(
api
:
:
PropertyBinding
:
:
Binding
(
.
.
)
_
)
|
Filter
:
:
SrgbToLinear
|
Filter
:
:
LinearToSrgb
|
Filter
:
:
ComponentTransfer
|
Filter
:
:
Flood
(
.
.
)
=
>
false
}
}
pub
fn
as_int
(
&
self
)
-
>
i32
{
match
*
self
{
Filter
:
:
Identity
=
>
0
Filter
:
:
Contrast
(
.
.
)
=
>
0
Filter
:
:
Grayscale
(
.
.
)
=
>
1
Filter
:
:
HueRotate
(
.
.
)
=
>
2
Filter
:
:
Invert
(
.
.
)
=
>
3
Filter
:
:
Saturate
(
.
.
)
=
>
4
Filter
:
:
Sepia
(
.
.
)
=
>
5
Filter
:
:
Brightness
(
.
.
)
=
>
6
Filter
:
:
ColorMatrix
(
.
.
)
=
>
7
Filter
:
:
SrgbToLinear
=
>
8
Filter
:
:
LinearToSrgb
=
>
9
Filter
:
:
Flood
(
.
.
)
=
>
10
Filter
:
:
ComponentTransfer
=
>
11
Filter
:
:
Blur
(
.
.
)
=
>
12
Filter
:
:
DropShadows
(
.
.
)
=
>
13
Filter
:
:
Opacity
(
.
.
)
=
>
14
}
}
}
impl
From
<
FilterOp
>
for
Filter
{
fn
from
(
op
:
FilterOp
)
-
>
Self
{
match
op
{
FilterOp
:
:
Identity
=
>
Filter
:
:
Identity
FilterOp
:
:
Blur
(
w
h
)
=
>
Filter
:
:
Blur
(
w
h
)
FilterOp
:
:
Brightness
(
b
)
=
>
Filter
:
:
Brightness
(
b
)
FilterOp
:
:
Contrast
(
c
)
=
>
Filter
:
:
Contrast
(
c
)
FilterOp
:
:
Grayscale
(
g
)
=
>
Filter
:
:
Grayscale
(
g
)
FilterOp
:
:
HueRotate
(
h
)
=
>
Filter
:
:
HueRotate
(
h
)
FilterOp
:
:
Invert
(
i
)
=
>
Filter
:
:
Invert
(
i
)
FilterOp
:
:
Opacity
(
binding
opacity
)
=
>
Filter
:
:
Opacity
(
binding
opacity
)
FilterOp
:
:
Saturate
(
s
)
=
>
Filter
:
:
Saturate
(
s
)
FilterOp
:
:
Sepia
(
s
)
=
>
Filter
:
:
Sepia
(
s
)
FilterOp
:
:
ColorMatrix
(
mat
)
=
>
Filter
:
:
ColorMatrix
(
Box
:
:
new
(
mat
)
)
FilterOp
:
:
SrgbToLinear
=
>
Filter
:
:
SrgbToLinear
FilterOp
:
:
LinearToSrgb
=
>
Filter
:
:
LinearToSrgb
FilterOp
:
:
ComponentTransfer
=
>
Filter
:
:
ComponentTransfer
FilterOp
:
:
DropShadow
(
shadow
)
=
>
Filter
:
:
DropShadows
(
smallvec
!
[
shadow
]
)
FilterOp
:
:
Flood
(
color
)
=
>
Filter
:
:
Flood
(
color
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
enum
Swizzle
{
Rgba
Bgra
}
impl
Default
for
Swizzle
{
fn
default
(
)
-
>
Self
{
Swizzle
:
:
Rgba
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
MallocSizeOf
PartialEq
)
]
pub
struct
SwizzleSettings
{
pub
bgra8_sampling_swizzle
:
Swizzle
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
CacheTextureId
(
pub
u32
)
;
impl
CacheTextureId
{
pub
const
INVALID
:
CacheTextureId
=
CacheTextureId
(
!
0
)
;
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
DeferredResolveIndex
(
pub
u32
)
;
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
Hash
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureSource
{
Invalid
TextureCache
(
CacheTextureId
Swizzle
)
External
(
DeferredResolveIndex
ImageBufferKind
)
Dummy
}
impl
TextureSource
{
pub
fn
image_buffer_kind
(
&
self
)
-
>
ImageBufferKind
{
match
*
self
{
TextureSource
:
:
TextureCache
(
.
.
)
=
>
ImageBufferKind
:
:
Texture2D
TextureSource
:
:
External
(
_
image_buffer_kind
)
=
>
image_buffer_kind
TextureSource
:
:
Dummy
=
>
ImageBufferKind
:
:
Texture2D
TextureSource
:
:
Invalid
=
>
ImageBufferKind
:
:
Texture2D
}
}
#
[
inline
]
pub
fn
is_compatible
(
&
self
other
:
&
TextureSource
)
-
>
bool
{
*
self
=
=
TextureSource
:
:
Invalid
|
|
*
other
=
=
TextureSource
:
:
Invalid
|
|
self
=
=
other
}
}
#
[
derive
(
Copy
Clone
Debug
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
RenderTargetInfo
{
pub
has_depth
:
bool
}
#
[
derive
(
Debug
)
]
pub
enum
TextureUpdateSource
{
External
{
id
:
ExternalImageId
channel_index
:
u8
}
Bytes
{
data
:
Arc
<
Vec
<
u8
>
>
}
DebugClear
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheAllocation
{
pub
id
:
CacheTextureId
pub
kind
:
TextureCacheAllocationKind
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
enum
TextureCacheCategory
{
Atlas
Standalone
PictureTile
RenderTarget
}
#
[
derive
(
Copy
Clone
Debug
Eq
PartialEq
)
]
pub
struct
TextureCacheAllocInfo
{
pub
width
:
i32
pub
height
:
i32
pub
format
:
ImageFormat
pub
filter
:
TextureFilter
pub
target
:
ImageBufferKind
pub
is_shared_cache
:
bool
pub
has_depth
:
bool
pub
category
:
TextureCacheCategory
}
#
[
derive
(
Debug
)
]
pub
enum
TextureCacheAllocationKind
{
Alloc
(
TextureCacheAllocInfo
)
Reset
(
TextureCacheAllocInfo
)
Free
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheUpdate
{
pub
rect
:
DeviceIntRect
pub
stride
:
Option
<
i32
>
pub
offset
:
i32
pub
format_override
:
Option
<
ImageFormat
>
pub
source
:
TextureUpdateSource
}
#
[
derive
(
Debug
)
]
pub
struct
TextureCacheCopy
{
pub
src_rect
:
DeviceIntRect
pub
dst_rect
:
DeviceIntRect
}
#
[
derive
(
Default
)
]
pub
struct
TextureUpdateList
{
pub
clears_shared_cache
:
bool
pub
allocations
:
Vec
<
TextureCacheAllocation
>
pub
updates
:
FastHashMap
<
CacheTextureId
Vec
<
TextureCacheUpdate
>
>
pub
copies
:
FastHashMap
<
(
CacheTextureId
CacheTextureId
)
Vec
<
TextureCacheCopy
>
>
}
impl
TextureUpdateList
{
pub
fn
new
(
)
-
>
Self
{
TextureUpdateList
{
clears_shared_cache
:
false
allocations
:
Vec
:
:
new
(
)
updates
:
FastHashMap
:
:
default
(
)
copies
:
FastHashMap
:
:
default
(
)
}
}
pub
fn
is_nop
(
&
self
)
-
>
bool
{
self
.
allocations
.
is_empty
(
)
&
&
self
.
updates
.
is_empty
(
)
}
#
[
inline
]
pub
fn
note_clear
(
&
mut
self
)
{
self
.
clears_shared_cache
=
true
;
}
#
[
inline
]
pub
fn
push_update
(
&
mut
self
id
:
CacheTextureId
update
:
TextureCacheUpdate
)
{
self
.
updates
.
entry
(
id
)
.
or_default
(
)
.
push
(
update
)
;
}
#
[
cold
]
pub
fn
push_debug_clear
(
&
mut
self
id
:
CacheTextureId
origin
:
DeviceIntPoint
width
:
i32
height
:
i32
)
{
let
size
=
DeviceIntSize
:
:
new
(
width
height
)
;
let
rect
=
DeviceIntRect
:
:
from_origin_and_size
(
origin
size
)
;
self
.
push_update
(
id
TextureCacheUpdate
{
rect
stride
:
None
offset
:
0
format_override
:
None
source
:
TextureUpdateSource
:
:
DebugClear
}
)
;
}
pub
fn
push_alloc
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
debug_assert
!
(
!
self
.
allocations
.
iter
(
)
.
any
(
|
x
|
x
.
id
=
=
id
)
)
;
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Alloc
(
info
)
}
)
;
}
pub
fn
push_reset
(
&
mut
self
id
:
CacheTextureId
info
:
TextureCacheAllocInfo
)
{
self
.
debug_assert_coalesced
(
id
)
;
self
.
updates
.
remove
(
&
id
)
;
if
let
Some
(
cur
)
=
self
.
allocations
.
iter_mut
(
)
.
find
(
|
x
|
x
.
id
=
=
id
)
{
match
cur
.
kind
{
TextureCacheAllocationKind
:
:
Alloc
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Reset
(
ref
mut
i
)
=
>
*
i
=
info
TextureCacheAllocationKind
:
:
Free
=
>
panic
!
(
"
Resetting
freed
texture
"
)
}
return
}
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Reset
(
info
)
}
)
;
}
pub
fn
push_free
(
&
mut
self
id
:
CacheTextureId
)
{
self
.
debug_assert_coalesced
(
id
)
;
self
.
updates
.
remove
(
&
id
)
;
let
idx
=
self
.
allocations
.
iter
(
)
.
position
(
|
x
|
x
.
id
=
=
id
)
;
let
removed_kind
=
idx
.
map
(
|
i
|
self
.
allocations
.
remove
(
i
)
.
kind
)
;
match
removed_kind
{
Some
(
TextureCacheAllocationKind
:
:
Alloc
(
.
.
)
)
=
>
{
}
Some
(
TextureCacheAllocationKind
:
:
Free
)
=
>
panic
!
(
"
Double
free
"
)
Some
(
TextureCacheAllocationKind
:
:
Reset
(
.
.
)
)
|
None
=
>
{
self
.
allocations
.
push
(
TextureCacheAllocation
{
id
kind
:
TextureCacheAllocationKind
:
:
Free
}
)
;
}
}
;
}
pub
fn
push_copy
(
&
mut
self
src_id
:
CacheTextureId
src_rect
:
&
DeviceIntRect
dst_id
:
CacheTextureId
dst_rect
:
&
DeviceIntRect
)
{
debug_assert_eq
!
(
src_rect
.
size
(
)
dst_rect
.
size
(
)
)
;
self
.
copies
.
entry
(
(
src_id
dst_id
)
)
.
or_insert_with
(
Vec
:
:
new
)
.
push
(
TextureCacheCopy
{
src_rect
:
*
src_rect
dst_rect
:
*
dst_rect
}
)
;
}
fn
debug_assert_coalesced
(
&
self
id
:
CacheTextureId
)
{
debug_assert
!
(
self
.
allocations
.
iter
(
)
.
filter
(
|
x
|
x
.
id
=
=
id
)
.
count
(
)
<
=
1
"
Allocations
should
have
been
coalesced
"
)
;
}
}
pub
struct
ResourceUpdateList
{
pub
native_surface_updates
:
Vec
<
NativeSurfaceOperation
>
pub
texture_updates
:
TextureUpdateList
}
impl
ResourceUpdateList
{
pub
fn
is_nop
(
&
self
)
-
>
bool
{
self
.
texture_updates
.
is_nop
(
)
&
&
self
.
native_surface_updates
.
is_empty
(
)
}
}
pub
struct
RenderedDocument
{
pub
frame
:
Frame
pub
is_new_scene
:
bool
pub
profile
:
TransactionProfile
pub
render_reasons
:
RenderReasons
pub
frame_stats
:
Option
<
FullFrameStats
>
}
pub
enum
DebugOutput
{
#
[
cfg
(
feature
=
"
capture
"
)
]
SaveCapture
(
CaptureConfig
Vec
<
ExternalCaptureImage
>
)
#
[
cfg
(
feature
=
"
replay
"
)
]
LoadCapture
(
CaptureConfig
Vec
<
PlainExternalImage
>
)
}
#
[
allow
(
dead_code
)
]
pub
enum
ResultMsg
{
DebugCommand
(
DebugCommand
)
DebugOutput
(
DebugOutput
)
RefreshShader
(
PathBuf
)
UpdateGpuCache
(
GpuCacheUpdateList
)
UpdateResources
{
resource_updates
:
ResourceUpdateList
memory_pressure
:
bool
}
PublishPipelineInfo
(
PipelineInfo
)
PublishDocument
(
DocumentId
RenderedDocument
ResourceUpdateList
)
AppendNotificationRequests
(
Vec
<
NotificationRequest
>
)
SetParameter
(
Parameter
)
ForceRedraw
}
#
[
derive
(
Clone
Debug
)
]
pub
struct
ResourceCacheError
;
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
LayoutPrimitiveInfo
{
pub
rect
:
LayoutRect
pub
clip_rect
:
LayoutRect
pub
flags
:
PrimitiveFlags
}
impl
LayoutPrimitiveInfo
{
pub
fn
with_clip_rect
(
rect
:
LayoutRect
clip_rect
:
LayoutRect
)
-
>
Self
{
Self
{
rect
clip_rect
flags
:
PrimitiveFlags
:
:
default
(
)
}
}
}
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
#
[
derive
(
Copy
Clone
PartialEq
Debug
Eq
Hash
)
]
pub
struct
PipelineInstanceId
(
u32
)
;
impl
PipelineInstanceId
{
pub
fn
new
(
id
:
u32
)
-
>
Self
{
PipelineInstanceId
(
id
)
}
}
