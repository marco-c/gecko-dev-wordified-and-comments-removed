use
api
:
:
{
BorderRadius
BoxShadowClipMode
ClipMode
ColorF
PrimitiveKeyKind
}
;
use
api
:
:
PropertyBinding
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
clip
:
:
{
ClipItemKey
ClipItemKeyKind
ClipChainId
}
;
use
crate
:
:
scene_building
:
:
SceneBuilder
;
use
crate
:
:
spatial_tree
:
:
SpatialNodeIndex
;
use
crate
:
:
gpu_types
:
:
BoxShadowStretchMode
;
use
crate
:
:
render_task_graph
:
:
RenderTaskId
;
use
crate
:
:
internal_types
:
:
LayoutPrimitiveInfo
;
#
[
derive
(
Debug
Clone
MallocSizeOf
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BoxShadowClipSource
{
pub
shadow_radius
:
BorderRadius
pub
blur_radius
:
f32
pub
clip_mode
:
BoxShadowClipMode
pub
stretch_mode_x
:
BoxShadowStretchMode
pub
stretch_mode_y
:
BoxShadowStretchMode
pub
cache_key
:
Option
<
(
DeviceIntSize
BoxShadowCacheKey
)
>
pub
render_task
:
Option
<
RenderTaskId
>
pub
shadow_rect_alloc_size
:
LayoutSize
pub
original_alloc_size
:
LayoutSize
pub
minimal_shadow_rect
:
LayoutRect
pub
prim_shadow_rect
:
LayoutRect
}
pub
const
BLUR_SAMPLE_SCALE
:
f32
=
3
.
0
;
pub
const
MAX_BLUR_RADIUS
:
f32
=
300
.
;
#
[
derive
(
Debug
Clone
Eq
Hash
MallocSizeOf
PartialEq
)
]
#
[
cfg_attr
(
feature
=
"
capture
"
derive
(
Serialize
)
)
]
#
[
cfg_attr
(
feature
=
"
replay
"
derive
(
Deserialize
)
)
]
pub
struct
BoxShadowCacheKey
{
pub
blur_radius_dp
:
i32
pub
clip_mode
:
BoxShadowClipMode
pub
original_alloc_size
:
DeviceIntSize
pub
br_top_left
:
DeviceIntSize
pub
br_top_right
:
DeviceIntSize
pub
br_bottom_right
:
DeviceIntSize
pub
br_bottom_left
:
DeviceIntSize
pub
device_pixel_scale
:
Au
}
impl
<
'
a
>
SceneBuilder
<
'
a
>
{
pub
fn
add_box_shadow
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_chain_id
:
ClipChainId
prim_info
:
&
LayoutPrimitiveInfo
box_offset
:
&
LayoutVector2D
color
:
ColorF
mut
blur_radius
:
f32
spread_radius
:
f32
border_radius
:
BorderRadius
clip_mode
:
BoxShadowClipMode
)
{
if
color
.
a
=
=
0
.
0
{
return
;
}
let
(
spread_amount
prim_clip_mode
)
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
(
spread_radius
ClipMode
:
:
ClipOut
)
BoxShadowClipMode
:
:
Inset
=
>
(
-
spread_radius
ClipMode
:
:
Clip
)
}
;
blur_radius
=
f32
:
:
min
(
blur_radius
MAX_BLUR_RADIUS
)
;
let
shadow_radius
=
adjust_border_radius_for_box_shadow
(
border_radius
spread_amount
)
;
let
shadow_rect
=
self
.
snap_rect
(
&
prim_info
.
rect
.
translate
(
*
box_offset
)
.
inflate
(
spread_amount
spread_amount
)
spatial_node_index
)
;
if
blur_radius
=
=
0
.
0
{
if
box_offset
.
x
=
=
0
.
0
&
&
box_offset
.
y
=
=
0
.
0
&
&
spread_amount
=
=
0
.
0
{
return
;
}
let
mut
clips
=
Vec
:
:
with_capacity
(
2
)
;
let
(
final_prim_rect
clip_radius
)
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
if
shadow_rect
.
is_empty
(
)
{
return
;
}
clips
.
push
(
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rounded_rect
(
prim_info
.
rect
border_radius
ClipMode
:
:
ClipOut
)
}
)
;
(
shadow_rect
shadow_radius
)
}
BoxShadowClipMode
:
:
Inset
=
>
{
if
!
shadow_rect
.
is_empty
(
)
{
clips
.
push
(
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rounded_rect
(
shadow_rect
shadow_radius
ClipMode
:
:
ClipOut
)
}
)
;
}
(
prim_info
.
rect
border_radius
)
}
}
;
clips
.
push
(
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rounded_rect
(
final_prim_rect
clip_radius
ClipMode
:
:
Clip
)
}
)
;
self
.
add_primitive
(
spatial_node_index
clip_chain_id
&
LayoutPrimitiveInfo
:
:
with_clip_rect
(
final_prim_rect
prim_info
.
clip_rect
)
clips
PrimitiveKeyKind
:
:
Rectangle
{
color
:
PropertyBinding
:
:
Value
(
color
.
into
(
)
)
}
)
;
}
else
{
let
blur_offset
=
(
BLUR_SAMPLE_SCALE
*
blur_radius
)
.
ceil
(
)
;
let
mut
extra_clips
=
vec
!
[
]
;
extra_clips
.
push
(
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rounded_rect
(
prim_info
.
rect
border_radius
prim_clip_mode
)
}
)
;
let
dest_rect
=
shadow_rect
.
inflate
(
blur_offset
blur_offset
)
;
let
prim
=
PrimitiveKeyKind
:
:
Rectangle
{
color
:
PropertyBinding
:
:
Value
(
color
.
into
(
)
)
}
;
let
shadow_clip_source
=
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
box_shadow
(
shadow_rect
shadow_radius
dest_rect
blur_radius
clip_mode
)
}
;
let
prim_info
=
match
clip_mode
{
BoxShadowClipMode
:
:
Outset
=
>
{
if
shadow_rect
.
is_empty
(
)
{
return
;
}
extra_clips
.
push
(
shadow_clip_source
)
;
LayoutPrimitiveInfo
:
:
with_clip_rect
(
dest_rect
prim_info
.
clip_rect
)
}
BoxShadowClipMode
:
:
Inset
=
>
{
if
border_radius
.
is_zero
(
)
&
&
shadow_rect
.
inflate
(
-
blur_radius
-
blur_radius
)
.
contains_box
(
&
prim_info
.
rect
)
{
return
;
}
if
!
shadow_rect
.
is_empty
(
)
{
extra_clips
.
push
(
shadow_clip_source
)
;
}
prim_info
.
clone
(
)
}
}
;
self
.
add_primitive
(
spatial_node_index
clip_chain_id
&
prim_info
extra_clips
prim
)
;
}
}
}
fn
adjust_border_radius_for_box_shadow
(
radius
:
BorderRadius
spread_amount
:
f32
)
-
>
BorderRadius
{
BorderRadius
{
top_left
:
adjust_corner_for_box_shadow
(
radius
.
top_left
spread_amount
)
top_right
:
adjust_corner_for_box_shadow
(
radius
.
top_right
spread_amount
)
bottom_right
:
adjust_corner_for_box_shadow
(
radius
.
bottom_right
spread_amount
)
bottom_left
:
adjust_corner_for_box_shadow
(
radius
.
bottom_left
spread_amount
)
}
}
fn
adjust_corner_for_box_shadow
(
corner
:
LayoutSize
spread_amount
:
f32
)
-
>
LayoutSize
{
LayoutSize
:
:
new
(
adjust_radius_for_box_shadow
(
corner
.
width
spread_amount
)
adjust_radius_for_box_shadow
(
corner
.
height
spread_amount
)
)
}
fn
adjust_radius_for_box_shadow
(
border_radius
:
f32
spread_amount
:
f32
)
-
>
f32
{
if
border_radius
>
0
.
0
{
(
border_radius
+
spread_amount
)
.
max
(
0
.
0
)
}
else
{
0
.
0
}
}
