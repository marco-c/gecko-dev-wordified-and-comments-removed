use
api
:
:
{
AlphaType
BorderDetails
BorderDisplayItem
BuiltDisplayListIter
BuiltDisplayList
PrimitiveFlags
}
;
use
api
:
:
{
ClipId
ColorF
CommonItemProperties
ComplexClipRegion
ComponentTransferFuncType
RasterSpace
}
;
use
api
:
:
{
DisplayItem
DisplayItemRef
ExtendMode
ExternalScrollId
FilterData
}
;
use
api
:
:
{
FilterOp
FilterPrimitive
FontInstanceKey
FontSize
GlyphInstance
GlyphOptions
GradientStop
}
;
use
api
:
:
{
IframeDisplayItem
ImageKey
ImageRendering
ItemRange
ColorDepth
QualitySettings
}
;
use
api
:
:
{
LineOrientation
LineStyle
NinePatchBorderSource
PipelineId
MixBlendMode
StackingContextFlags
}
;
use
api
:
:
{
PropertyBinding
ReferenceFrameKind
ScrollFrameDescriptor
}
;
use
api
:
:
{
APZScrollGeneration
HasScrollLinkedEffect
Shadow
SpatialId
StickyFrameDescriptor
ImageMask
ItemTag
}
;
use
api
:
:
{
ClipMode
PrimitiveKeyKind
TransformStyle
YuvColorSpace
ColorRange
YuvData
TempFilterData
}
;
use
api
:
:
{
ReferenceTransformBinding
Rotation
FillRule
SpatialTreeItem
ReferenceFrameDescriptor
}
;
use
api
:
:
FilterOpGraphPictureBufferId
;
use
api
:
:
units
:
:
*
;
use
crate
:
:
image_tiling
:
:
simplify_repeated_primitive
;
use
crate
:
:
box_shadow
:
:
BLUR_SAMPLE_SCALE
;
use
crate
:
:
clip
:
:
{
ClipItemKey
ClipStore
ClipItemKeyKind
ClipIntern
}
;
use
crate
:
:
clip
:
:
{
ClipInternData
ClipNodeId
ClipLeafId
}
;
use
crate
:
:
clip
:
:
{
PolygonDataHandle
ClipTreeBuilder
}
;
use
crate
:
:
segment
:
:
EdgeAaSegmentMask
;
use
crate
:
:
spatial_tree
:
:
{
SceneSpatialTree
SpatialNodeContainer
SpatialNodeIndex
get_external_scroll_offset
}
;
use
crate
:
:
frame_builder
:
:
{
FrameBuilderConfig
}
;
use
glyph_rasterizer
:
:
{
FontInstance
SharedFontResources
}
;
use
crate
:
:
hit_test
:
:
HitTestingScene
;
use
crate
:
:
intern
:
:
Interner
;
use
crate
:
:
internal_types
:
:
{
FastHashMap
LayoutPrimitiveInfo
Filter
FilterGraphNode
FilterGraphOp
FilterGraphPictureReference
PlaneSplitterIndex
PipelineInstanceId
}
;
use
crate
:
:
picture
:
:
{
Picture3DContext
PictureCompositeMode
PicturePrimitive
}
;
use
crate
:
:
picture
:
:
{
BlitReason
OrderedPictureChild
PrimitiveList
SurfaceInfo
PictureFlags
}
;
use
crate
:
:
picture_graph
:
:
PictureGraph
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstance
}
;
use
crate
:
:
prim_store
:
:
{
PrimitiveInstanceKind
NinePatchDescriptor
PrimitiveStore
}
;
use
crate
:
:
prim_store
:
:
{
InternablePrimitive
PictureIndex
}
;
use
crate
:
:
prim_store
:
:
{
PolygonKey
}
;
use
crate
:
:
prim_store
:
:
backdrop
:
:
{
BackdropCapture
BackdropRender
}
;
use
crate
:
:
prim_store
:
:
borders
:
:
{
ImageBorder
NormalBorderPrim
}
;
use
crate
:
:
prim_store
:
:
gradient
:
:
{
GradientStopKey
LinearGradient
RadialGradient
RadialGradientParams
ConicGradient
ConicGradientParams
optimize_radial_gradient
apply_gradient_local_clip
optimize_linear_gradient
self
}
;
use
crate
:
:
prim_store
:
:
image
:
:
{
Image
YuvImage
}
;
use
crate
:
:
prim_store
:
:
line_dec
:
:
{
LineDecoration
LineDecorationCacheKey
get_line_decoration_size
}
;
use
crate
:
:
prim_store
:
:
picture
:
:
{
Picture
PictureCompositeKey
PictureKey
}
;
use
crate
:
:
prim_store
:
:
text_run
:
:
TextRun
;
use
crate
:
:
render_backend
:
:
SceneView
;
use
crate
:
:
resource_cache
:
:
ImageRequest
;
use
crate
:
:
scene
:
:
{
Scene
ScenePipeline
BuiltScene
SceneStats
StackingContextHelpers
}
;
use
crate
:
:
scene_builder_thread
:
:
Interners
;
use
crate
:
:
space
:
:
SpaceSnapper
;
use
crate
:
:
spatial_node
:
:
{
ReferenceFrameInfo
StickyFrameInfo
ScrollFrameKind
SpatialNodeUid
SpatialNodeType
}
;
use
crate
:
:
tile_cache
:
:
TileCacheBuilder
;
use
euclid
:
:
approxeq
:
:
ApproxEq
;
use
std
:
:
{
f32
mem
usize
}
;
use
std
:
:
collections
:
:
vec_deque
:
:
VecDeque
;
use
std
:
:
sync
:
:
Arc
;
use
crate
:
:
util
:
:
{
VecHelper
MaxRect
}
;
use
crate
:
:
filterdata
:
:
{
SFilterDataComponent
SFilterData
SFilterDataKey
}
;
use
log
:
:
Level
;
pub
struct
ScrollOffsetMapper
{
pub
current_spatial_node
:
SpatialNodeIndex
pub
current_offset
:
LayoutVector2D
}
impl
ScrollOffsetMapper
{
fn
new
(
)
-
>
Self
{
ScrollOffsetMapper
{
current_spatial_node
:
SpatialNodeIndex
:
:
INVALID
current_offset
:
LayoutVector2D
:
:
zero
(
)
}
}
fn
external_scroll_offset
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
spatial_tree
:
&
SceneSpatialTree
)
-
>
LayoutVector2D
{
if
spatial_node_index
!
=
self
.
current_spatial_node
{
self
.
current_spatial_node
=
spatial_node_index
;
self
.
current_offset
=
get_external_scroll_offset
(
spatial_tree
spatial_node_index
)
;
}
self
.
current_offset
}
}
#
[
derive
(
Default
)
]
pub
struct
NodeIdToIndexMapper
{
spatial_node_map
:
FastHashMap
<
SpatialId
SpatialNodeIndex
>
}
impl
NodeIdToIndexMapper
{
fn
add_spatial_node
(
&
mut
self
id
:
SpatialId
index
:
SpatialNodeIndex
)
{
let
_old_value
=
self
.
spatial_node_map
.
insert
(
id
index
)
;
assert
!
(
_old_value
.
is_none
(
)
)
;
}
fn
get_spatial_node_index
(
&
self
id
:
SpatialId
)
-
>
SpatialNodeIndex
{
self
.
spatial_node_map
[
&
id
]
}
}
#
[
derive
(
Debug
Clone
Default
)
]
pub
struct
CompositeOps
{
pub
filters
:
Vec
<
Filter
>
pub
filter_datas
:
Vec
<
FilterData
>
pub
filter_primitives
:
Vec
<
FilterPrimitive
>
pub
mix_blend_mode
:
Option
<
MixBlendMode
>
}
impl
CompositeOps
{
pub
fn
new
(
filters
:
Vec
<
Filter
>
filter_datas
:
Vec
<
FilterData
>
filter_primitives
:
Vec
<
FilterPrimitive
>
mix_blend_mode
:
Option
<
MixBlendMode
>
)
-
>
Self
{
CompositeOps
{
filters
filter_datas
filter_primitives
mix_blend_mode
}
}
pub
fn
is_empty
(
&
self
)
-
>
bool
{
self
.
filters
.
is_empty
(
)
&
&
self
.
filter_primitives
.
is_empty
(
)
&
&
self
.
mix_blend_mode
.
is_none
(
)
}
fn
has_valid_filters
(
&
self
)
-
>
bool
{
let
mut
current_filter_data_index
=
0
;
for
filter
in
&
self
.
filters
{
match
filter
{
Filter
:
:
ComponentTransfer
=
>
{
let
filter_data
=
&
self
.
filter_datas
[
current_filter_data_index
]
;
let
filter_data
=
filter_data
.
sanitize
(
)
;
current_filter_data_index
=
current_filter_data_index
+
1
;
if
filter_data
.
is_identity
(
)
{
continue
}
else
{
return
true
;
}
}
Filter
:
:
SVGGraphNode
(
.
.
)
=
>
{
return
true
;
}
_
=
>
{
if
filter
.
is_noop
(
)
{
continue
;
}
else
{
return
true
;
}
}
}
}
if
!
self
.
filter_primitives
.
is_empty
(
)
{
return
true
;
}
false
}
}
enum
PictureSource
{
PrimitiveList
{
prim_list
:
PrimitiveList
}
WrappedPicture
{
instance
:
PrimitiveInstance
}
}
struct
PictureChainBuilder
{
current
:
PictureSource
spatial_node_index
:
SpatialNodeIndex
flags
:
PrimitiveFlags
raster_space
:
RasterSpace
set_resolve_target
:
bool
establishes_sub_graph
:
bool
}
impl
PictureChainBuilder
{
fn
from_prim_list
(
prim_list
:
PrimitiveList
flags
:
PrimitiveFlags
spatial_node_index
:
SpatialNodeIndex
raster_space
:
RasterSpace
is_sub_graph
:
bool
)
-
>
Self
{
PictureChainBuilder
{
current
:
PictureSource
:
:
PrimitiveList
{
prim_list
}
spatial_node_index
flags
raster_space
establishes_sub_graph
:
is_sub_graph
set_resolve_target
:
is_sub_graph
}
}
fn
from_instance
(
instance
:
PrimitiveInstance
flags
:
PrimitiveFlags
spatial_node_index
:
SpatialNodeIndex
raster_space
:
RasterSpace
)
-
>
Self
{
PictureChainBuilder
{
current
:
PictureSource
:
:
WrappedPicture
{
instance
}
flags
spatial_node_index
raster_space
establishes_sub_graph
:
false
set_resolve_target
:
false
}
}
#
[
must_use
]
fn
add_picture
(
self
composite_mode
:
PictureCompositeMode
clip_node_id
:
ClipNodeId
context_3d
:
Picture3DContext
<
OrderedPictureChild
>
interners
:
&
mut
Interners
prim_store
:
&
mut
PrimitiveStore
prim_instances
:
&
mut
Vec
<
PrimitiveInstance
>
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
-
>
PictureChainBuilder
{
let
prim_list
=
match
self
.
current
{
PictureSource
:
:
PrimitiveList
{
prim_list
}
=
>
{
prim_list
}
PictureSource
:
:
WrappedPicture
{
instance
}
=
>
{
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
prim_list
.
add_prim
(
instance
LayoutRect
:
:
zero
(
)
self
.
spatial_node_index
self
.
flags
prim_instances
clip_tree_builder
)
;
prim_list
}
}
;
let
flags
=
if
self
.
set_resolve_target
{
PictureFlags
:
:
IS_RESOLVE_TARGET
}
else
{
PictureFlags
:
:
empty
(
)
}
;
let
pic_index
=
PictureIndex
(
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
Some
(
composite_mode
.
clone
(
)
)
context_3d
self
.
flags
prim_list
self
.
spatial_node_index
self
.
raster_space
flags
)
)
)
;
let
instance
=
create_prim_instance
(
pic_index
Some
(
composite_mode
)
.
into
(
)
self
.
raster_space
clip_node_id
interners
clip_tree_builder
)
;
PictureChainBuilder
{
current
:
PictureSource
:
:
WrappedPicture
{
instance
}
spatial_node_index
:
self
.
spatial_node_index
flags
:
self
.
flags
raster_space
:
self
.
raster_space
set_resolve_target
:
false
establishes_sub_graph
:
self
.
establishes_sub_graph
}
}
fn
finalize
(
self
clip_node_id
:
ClipNodeId
interners
:
&
mut
Interners
prim_store
:
&
mut
PrimitiveStore
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
-
>
PrimitiveInstance
{
let
mut
flags
=
PictureFlags
:
:
empty
(
)
;
if
self
.
establishes_sub_graph
{
flags
|
=
PictureFlags
:
:
IS_SUB_GRAPH
;
}
match
self
.
current
{
PictureSource
:
:
WrappedPicture
{
instance
}
=
>
{
let
pic_index
=
instance
.
kind
.
as_pic
(
)
;
prim_store
.
pictures
[
pic_index
.
0
]
.
flags
|
=
flags
;
instance
}
PictureSource
:
:
PrimitiveList
{
prim_list
}
=
>
{
if
self
.
set_resolve_target
{
flags
|
=
PictureFlags
:
:
IS_RESOLVE_TARGET
;
}
let
pic_index
=
PictureIndex
(
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
None
Picture3DContext
:
:
Out
self
.
flags
prim_list
self
.
spatial_node_index
self
.
raster_space
flags
)
)
)
;
create_prim_instance
(
pic_index
None
.
into
(
)
self
.
raster_space
clip_node_id
interners
clip_tree_builder
)
}
}
}
#
[
allow
(
dead_code
)
]
fn
has_picture
(
&
self
)
-
>
bool
{
match
self
.
current
{
PictureSource
:
:
WrappedPicture
{
.
.
}
=
>
true
PictureSource
:
:
PrimitiveList
{
.
.
}
=
>
false
}
}
}
bitflags
!
{
/
/
/
Slice
flags
#
[
derive
(
Debug
Copy
PartialEq
Eq
Clone
PartialOrd
Ord
Hash
)
]
pub
struct
SliceFlags
:
u8
{
/
/
/
Slice
created
by
a
prim
that
has
PrimitiveFlags
:
:
IS_SCROLLBAR_CONTAINER
const
IS_SCROLLBAR
=
1
;
/
/
/
Represents
an
atomic
container
(
can
'
t
split
out
compositor
surfaces
in
this
slice
)
const
IS_ATOMIC
=
2
;
}
}
pub
struct
SceneBuilder
<
'
a
>
{
scene
:
&
'
a
Scene
fonts
:
SharedFontResources
id_to_index_mapper_stack
:
Vec
<
NodeIdToIndexMapper
>
sc_stack
:
Vec
<
FlattenedStackingContext
>
containing_block_stack
:
Vec
<
SpatialNodeIndex
>
raster_space_stack
:
Vec
<
RasterSpace
>
pending_shadow_items
:
VecDeque
<
ShadowItem
>
pub
spatial_tree
:
&
'
a
mut
SceneSpatialTree
pub
prim_store
:
PrimitiveStore
pub
hit_testing_scene
:
HitTestingScene
pub
clip_store
:
ClipStore
pub
config
:
FrameBuilderConfig
interners
:
&
'
a
mut
Interners
external_scroll_mapper
:
ScrollOffsetMapper
iframe_size
:
Vec
<
LayoutSize
>
root_iframe_clip
:
Option
<
ClipId
>
quality_settings
:
QualitySettings
tile_cache_builder
:
TileCacheBuilder
snap_to_device
:
SpaceSnapper
picture_graph
:
PictureGraph
next_plane_splitter_index
:
usize
prim_instances
:
Vec
<
PrimitiveInstance
>
pipeline_instance_ids
:
FastHashMap
<
PipelineId
u32
>
surfaces
:
Vec
<
SurfaceInfo
>
clip_tree_builder
:
ClipTreeBuilder
}
impl
<
'
a
>
SceneBuilder
<
'
a
>
{
pub
fn
build
(
scene
:
&
Scene
fonts
:
SharedFontResources
view
:
&
SceneView
frame_builder_config
:
&
FrameBuilderConfig
interners
:
&
mut
Interners
spatial_tree
:
&
mut
SceneSpatialTree
stats
:
&
SceneStats
)
-
>
BuiltScene
{
profile_scope
!
(
"
build_scene
"
)
;
let
root_pipeline_id
=
scene
.
root_pipeline_id
.
unwrap
(
)
;
let
root_pipeline
=
scene
.
pipelines
.
get
(
&
root_pipeline_id
)
.
unwrap
(
)
;
let
root_reference_frame_index
=
spatial_tree
.
root_reference_frame_index
(
)
;
let
snap_to_device
=
SpaceSnapper
:
:
new
(
root_reference_frame_index
RasterPixelScale
:
:
new
(
1
.
0
)
)
;
let
mut
builder
=
SceneBuilder
{
scene
spatial_tree
fonts
config
:
*
frame_builder_config
id_to_index_mapper_stack
:
Vec
:
:
new
(
)
hit_testing_scene
:
HitTestingScene
:
:
new
(
&
stats
.
hit_test_stats
)
pending_shadow_items
:
VecDeque
:
:
new
(
)
sc_stack
:
Vec
:
:
new
(
)
containing_block_stack
:
Vec
:
:
new
(
)
raster_space_stack
:
vec
!
[
RasterSpace
:
:
Screen
]
prim_store
:
PrimitiveStore
:
:
new
(
&
stats
.
prim_store_stats
)
clip_store
:
ClipStore
:
:
new
(
)
interners
external_scroll_mapper
:
ScrollOffsetMapper
:
:
new
(
)
iframe_size
:
Vec
:
:
new
(
)
root_iframe_clip
:
None
quality_settings
:
view
.
quality_settings
tile_cache_builder
:
TileCacheBuilder
:
:
new
(
root_reference_frame_index
frame_builder_config
.
background_color
)
snap_to_device
picture_graph
:
PictureGraph
:
:
new
(
)
next_plane_splitter_index
:
0
prim_instances
:
Vec
:
:
new
(
)
pipeline_instance_ids
:
FastHashMap
:
:
default
(
)
surfaces
:
Vec
:
:
new
(
)
clip_tree_builder
:
ClipTreeBuilder
:
:
new
(
)
}
;
builder
.
build_all
(
root_pipeline_id
&
root_pipeline
)
;
let
(
tile_cache_config
tile_cache_pictures
)
=
builder
.
tile_cache_builder
.
build
(
&
builder
.
config
&
mut
builder
.
prim_store
&
builder
.
spatial_tree
&
builder
.
prim_instances
&
mut
builder
.
clip_tree_builder
)
;
for
pic_index
in
&
tile_cache_pictures
{
builder
.
picture_graph
.
add_root
(
*
pic_index
)
;
SceneBuilder
:
:
finalize_picture
(
*
pic_index
None
&
mut
builder
.
prim_store
.
pictures
None
&
builder
.
clip_tree_builder
&
builder
.
prim_instances
&
builder
.
interners
.
clip
)
;
}
let
clip_tree
=
builder
.
clip_tree_builder
.
finalize
(
)
;
BuiltScene
{
has_root_pipeline
:
scene
.
has_root_pipeline
(
)
pipeline_epochs
:
scene
.
pipeline_epochs
.
clone
(
)
output_rect
:
view
.
device_rect
.
size
(
)
.
into
(
)
hit_testing_scene
:
Arc
:
:
new
(
builder
.
hit_testing_scene
)
prim_store
:
builder
.
prim_store
clip_store
:
builder
.
clip_store
config
:
builder
.
config
tile_cache_config
tile_cache_pictures
picture_graph
:
builder
.
picture_graph
num_plane_splitters
:
builder
.
next_plane_splitter_index
prim_instances
:
builder
.
prim_instances
surfaces
:
builder
.
surfaces
clip_tree
}
}
fn
finalize_picture
(
pic_index
:
PictureIndex
prim_index
:
Option
<
usize
>
pictures
:
&
mut
[
PicturePrimitive
]
parent_spatial_node_index
:
Option
<
SpatialNodeIndex
>
clip_tree_builder
:
&
ClipTreeBuilder
prim_instances
:
&
[
PrimitiveInstance
]
clip_interner
:
&
Interner
<
ClipIntern
>
)
{
let
(
mut
prim_list
spatial_node_index
)
=
{
let
pic
=
&
mut
pictures
[
pic_index
.
0
]
;
assert_ne
!
(
pic
.
spatial_node_index
SpatialNodeIndex
:
:
UNKNOWN
)
;
if
pic
.
flags
.
contains
(
PictureFlags
:
:
IS_RESOLVE_TARGET
)
{
pic
.
flags
|
=
PictureFlags
:
:
DISABLE_SNAPPING
;
}
let
spatial_node_index
=
match
pic
.
composite_mode
{
Some
(
_
)
=
>
pic
.
spatial_node_index
None
=
>
parent_spatial_node_index
.
expect
(
"
bug
:
no
parent
"
)
}
;
(
mem
:
:
replace
(
&
mut
pic
.
prim_list
PrimitiveList
:
:
empty
(
)
)
spatial_node_index
)
}
;
for
cluster
in
&
mut
prim_list
.
clusters
{
if
cluster
.
spatial_node_index
=
=
SpatialNodeIndex
:
:
UNKNOWN
{
cluster
.
spatial_node_index
=
spatial_node_index
;
}
}
let
mut
shared_clip_node_id
=
None
;
for
cluster
in
&
prim_list
.
clusters
{
for
prim_instance
in
&
prim_instances
[
cluster
.
prim_range
(
)
]
{
let
leaf
=
clip_tree_builder
.
get_leaf
(
prim_instance
.
clip_leaf_id
)
;
shared_clip_node_id
=
match
shared_clip_node_id
{
Some
(
current
)
=
>
{
Some
(
clip_tree_builder
.
find_lowest_common_ancestor
(
current
leaf
.
node_id
)
)
}
None
=
>
Some
(
leaf
.
node_id
)
}
;
}
}
let
lca_tree_node
=
shared_clip_node_id
.
and_then
(
|
node_id
|
(
node_id
!
=
ClipNodeId
:
:
NONE
)
.
then_some
(
node_id
)
)
.
map
(
|
node_id
|
clip_tree_builder
.
get_node
(
node_id
)
)
;
let
lca_node
=
lca_tree_node
.
map
(
|
tree_node
|
&
clip_interner
[
tree_node
.
handle
]
)
;
let
pic_node_id
=
prim_index
.
map
(
|
prim_index
|
clip_tree_builder
.
get_leaf
(
prim_instances
[
prim_index
]
.
clip_leaf_id
)
.
node_id
)
.
and_then
(
|
node_id
|
(
node_id
!
=
ClipNodeId
:
:
NONE
)
.
then_some
(
node_id
)
)
;
let
pic_node
=
pic_node_id
.
map
(
|
node_id
|
clip_tree_builder
.
get_node
(
node_id
)
)
.
map
(
|
tree_node
|
&
clip_interner
[
tree_node
.
handle
]
)
;
let
has_blur
=
match
&
pictures
[
pic_index
.
0
]
.
composite_mode
{
Some
(
PictureCompositeMode
:
:
Filter
(
Filter
:
:
Blur
{
.
.
}
)
)
=
>
true
Some
(
PictureCompositeMode
:
:
Filter
(
Filter
:
:
DropShadows
{
.
.
}
)
)
=
>
true
Some
(
PictureCompositeMode
:
:
SvgFilter
(
.
.
)
)
=
>
true
Some
(
PictureCompositeMode
:
:
SVGFEGraph
(
.
.
)
)
=
>
true
_
=
>
false
}
;
let
direct_parent
=
lca_tree_node
.
zip
(
pic_node_id
)
.
map
(
|
(
lca_tree_node
pic_node_id
)
|
lca_tree_node
.
parent
=
=
pic_node_id
)
.
unwrap_or
(
false
)
;
if
let
Some
(
(
lca_node
pic_node
)
)
=
lca_node
.
zip
(
pic_node
)
{
if
lca_node
.
key
=
=
pic_node
.
key
&
&
!
has_blur
&
&
direct_parent
{
pictures
[
pic_index
.
0
]
.
clip_root
=
shared_clip_node_id
;
}
}
for
cluster
in
&
prim_list
.
clusters
{
for
prim_instance_index
in
cluster
.
prim_range
(
)
{
if
let
PrimitiveInstanceKind
:
:
Picture
{
pic_index
:
child_pic_index
.
.
}
=
prim_instances
[
prim_instance_index
]
.
kind
{
let
child_pic
=
&
mut
pictures
[
child_pic_index
.
0
]
;
if
child_pic
.
spatial_node_index
=
=
SpatialNodeIndex
:
:
UNKNOWN
{
child_pic
.
spatial_node_index
=
spatial_node_index
;
}
SceneBuilder
:
:
finalize_picture
(
child_pic_index
Some
(
prim_instance_index
)
pictures
Some
(
spatial_node_index
)
clip_tree_builder
prim_instances
clip_interner
)
;
if
pictures
[
child_pic_index
.
0
]
.
flags
.
contains
(
PictureFlags
:
:
DISABLE_SNAPPING
)
{
pictures
[
pic_index
.
0
]
.
flags
|
=
PictureFlags
:
:
DISABLE_SNAPPING
;
}
}
}
}
pictures
[
pic_index
.
0
]
.
prim_list
=
prim_list
;
}
fn
current_external_scroll_offset
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
)
-
>
LayoutVector2D
{
self
.
external_scroll_mapper
.
external_scroll_offset
(
spatial_node_index
self
.
spatial_tree
)
}
fn
build_spatial_tree_for_display_list
(
&
mut
self
dl
:
&
BuiltDisplayList
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
{
dl
.
iter_spatial_tree
(
|
item
|
{
match
item
{
SpatialTreeItem
:
:
ScrollFrame
(
descriptor
)
=
>
{
let
parent_space
=
self
.
get_space
(
descriptor
.
parent_space
)
;
self
.
build_scroll_frame
(
descriptor
parent_space
pipeline_id
instance_id
)
;
}
SpatialTreeItem
:
:
ReferenceFrame
(
descriptor
)
=
>
{
let
parent_space
=
self
.
get_space
(
descriptor
.
parent_spatial_id
)
;
self
.
build_reference_frame
(
descriptor
parent_space
pipeline_id
instance_id
)
;
}
SpatialTreeItem
:
:
StickyFrame
(
descriptor
)
=
>
{
let
parent_space
=
self
.
get_space
(
descriptor
.
parent_spatial_id
)
;
self
.
build_sticky_frame
(
descriptor
parent_space
instance_id
)
;
}
SpatialTreeItem
:
:
Invalid
=
>
{
unreachable
!
(
)
;
}
}
}
)
;
}
fn
build_all
(
&
mut
self
root_pipeline_id
:
PipelineId
root_pipeline
:
&
ScenePipeline
)
{
enum
ContextKind
<
'
a
>
{
Root
StackingContext
{
sc_info
:
StackingContextInfo
}
ReferenceFrame
Iframe
{
parent_traversal
:
BuiltDisplayListIter
<
'
a
>
}
}
struct
BuildContext
<
'
a
>
{
pipeline_id
:
PipelineId
kind
:
ContextKind
<
'
a
>
}
self
.
id_to_index_mapper_stack
.
push
(
NodeIdToIndexMapper
:
:
default
(
)
)
;
let
instance_id
=
self
.
get_next_instance_id_for_pipeline
(
root_pipeline_id
)
;
self
.
push_root
(
root_pipeline_id
instance_id
)
;
self
.
build_spatial_tree_for_display_list
(
&
root_pipeline
.
display_list
.
display_list
root_pipeline_id
instance_id
)
;
let
mut
stack
=
vec
!
[
BuildContext
{
pipeline_id
:
root_pipeline_id
kind
:
ContextKind
:
:
Root
}
]
;
let
mut
traversal
=
root_pipeline
.
display_list
.
iter
(
)
;
'
outer
:
while
let
Some
(
bc
)
=
stack
.
pop
(
)
{
loop
{
let
item
=
match
traversal
.
next
(
)
{
Some
(
item
)
=
>
item
None
=
>
break
}
;
match
item
.
item
(
)
{
DisplayItem
:
:
PushStackingContext
(
ref
info
)
=
>
{
profile_scope
!
(
"
build_stacking_context
"
)
;
let
spatial_node_index
=
self
.
get_space
(
info
.
spatial_id
)
;
let
mut
subtraversal
=
item
.
sub_iter
(
)
;
if
subtraversal
.
current_stacking_context_empty
(
)
&
&
item
.
filters
(
)
.
is_empty
(
)
{
subtraversal
.
skip_current_stacking_context
(
)
;
traversal
=
subtraversal
;
continue
;
}
let
composition_operations
=
CompositeOps
:
:
new
(
filter_ops_for_compositing
(
item
.
filters
(
)
)
filter_datas_for_compositing
(
item
.
filter_datas
(
)
)
filter_primitives_for_compositing
(
item
.
filter_primitives
(
)
)
info
.
stacking_context
.
mix_blend_mode_for_compositing
(
)
)
;
let
sc_info
=
self
.
push_stacking_context
(
composition_operations
info
.
stacking_context
.
transform_style
info
.
prim_flags
spatial_node_index
info
.
stacking_context
.
clip_chain_id
info
.
stacking_context
.
raster_space
info
.
stacking_context
.
flags
info
.
ref_frame_offset
+
info
.
origin
.
to_vector
(
)
)
;
let
new_context
=
BuildContext
{
pipeline_id
:
bc
.
pipeline_id
kind
:
ContextKind
:
:
StackingContext
{
sc_info
}
}
;
stack
.
push
(
bc
)
;
stack
.
push
(
new_context
)
;
subtraversal
.
merge_debug_stats_from
(
&
mut
traversal
)
;
traversal
=
subtraversal
;
continue
'
outer
;
}
DisplayItem
:
:
PushReferenceFrame
(
.
.
)
=
>
{
profile_scope
!
(
"
build_reference_frame
"
)
;
let
mut
subtraversal
=
item
.
sub_iter
(
)
;
let
new_context
=
BuildContext
{
pipeline_id
:
bc
.
pipeline_id
kind
:
ContextKind
:
:
ReferenceFrame
}
;
stack
.
push
(
bc
)
;
stack
.
push
(
new_context
)
;
subtraversal
.
merge_debug_stats_from
(
&
mut
traversal
)
;
traversal
=
subtraversal
;
continue
'
outer
;
}
DisplayItem
:
:
PopReferenceFrame
|
DisplayItem
:
:
PopStackingContext
=
>
break
DisplayItem
:
:
Iframe
(
ref
info
)
=
>
{
profile_scope
!
(
"
iframe
"
)
;
let
space
=
self
.
get_space
(
info
.
space_and_clip
.
spatial_id
)
;
let
subtraversal
=
match
self
.
push_iframe
(
info
space
)
{
Some
(
pair
)
=
>
pair
None
=
>
continue
}
;
let
new_context
=
BuildContext
{
pipeline_id
:
info
.
pipeline_id
kind
:
ContextKind
:
:
Iframe
{
parent_traversal
:
mem
:
:
replace
(
&
mut
traversal
subtraversal
)
}
}
;
stack
.
push
(
bc
)
;
stack
.
push
(
new_context
)
;
continue
'
outer
;
}
_
=
>
{
self
.
build_item
(
item
)
;
}
}
;
}
match
bc
.
kind
{
ContextKind
:
:
Root
=
>
{
}
ContextKind
:
:
StackingContext
{
sc_info
}
=
>
{
self
.
pop_stacking_context
(
sc_info
)
;
}
ContextKind
:
:
ReferenceFrame
=
>
{
}
ContextKind
:
:
Iframe
{
parent_traversal
}
=
>
{
self
.
iframe_size
.
pop
(
)
;
self
.
clip_tree_builder
.
pop_clip
(
)
;
self
.
clip_tree_builder
.
pop_clip
(
)
;
if
self
.
iframe_size
.
is_empty
(
)
{
assert
!
(
self
.
root_iframe_clip
.
is_some
(
)
)
;
self
.
root_iframe_clip
=
None
;
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
}
self
.
id_to_index_mapper_stack
.
pop
(
)
.
unwrap
(
)
;
traversal
=
parent_traversal
;
}
}
if
cfg
!
(
feature
=
"
display_list_stats
"
)
{
let
stats
=
traversal
.
debug_stats
(
)
;
let
total_bytes
:
usize
=
stats
.
iter
(
)
.
map
(
|
(
_
stats
)
|
stats
.
num_bytes
)
.
sum
(
)
;
debug
!
(
"
item
total
count
total
bytes
%
of
DL
bytes
bytes
per
item
"
)
;
for
(
label
stats
)
in
stats
{
debug
!
(
"
{
}
{
}
{
}
kb
{
}
%
{
}
"
label
stats
.
total_count
stats
.
num_bytes
/
1000
(
(
stats
.
num_bytes
as
f32
/
total_bytes
.
max
(
1
)
as
f32
)
*
100
.
0
)
as
usize
stats
.
num_bytes
/
stats
.
total_count
.
max
(
1
)
)
;
}
debug
!
(
"
"
)
;
}
}
debug_assert
!
(
self
.
sc_stack
.
is_empty
(
)
)
;
self
.
id_to_index_mapper_stack
.
pop
(
)
.
unwrap
(
)
;
assert
!
(
self
.
id_to_index_mapper_stack
.
is_empty
(
)
)
;
}
fn
build_sticky_frame
(
&
mut
self
info
:
&
StickyFrameDescriptor
parent_node_index
:
SpatialNodeIndex
instance_id
:
PipelineInstanceId
)
{
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
parent_node_index
)
;
let
sticky_frame_info
=
StickyFrameInfo
:
:
new
(
info
.
bounds
.
translate
(
external_scroll_offset
)
info
.
margins
info
.
vertical_offset_bounds
info
.
horizontal_offset_bounds
info
.
previously_applied_offset
info
.
transform
)
;
let
index
=
self
.
spatial_tree
.
add_sticky_frame
(
parent_node_index
sticky_frame_info
info
.
id
.
pipeline_id
(
)
info
.
key
instance_id
)
;
self
.
id_to_index_mapper_stack
.
last_mut
(
)
.
unwrap
(
)
.
add_spatial_node
(
info
.
id
index
)
;
}
fn
build_reference_frame
(
&
mut
self
info
:
&
ReferenceFrameDescriptor
parent_space
:
SpatialNodeIndex
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
{
let
transform
=
match
info
.
reference_frame
.
transform
{
ReferenceTransformBinding
:
:
Static
{
binding
}
=
>
binding
ReferenceTransformBinding
:
:
Computed
{
scale_from
vertical_flip
rotation
}
=
>
{
let
content_size
=
&
self
.
iframe_size
.
last
(
)
.
unwrap
(
)
;
let
mut
transform
=
if
let
Some
(
scale_from
)
=
scale_from
{
match
rotation
{
Rotation
:
:
Degree0
|
Rotation
:
:
Degree180
=
>
{
LayoutTransform
:
:
scale
(
content_size
.
width
/
scale_from
.
width
content_size
.
height
/
scale_from
.
height
1
.
0
)
}
Rotation
:
:
Degree90
|
Rotation
:
:
Degree270
=
>
{
LayoutTransform
:
:
scale
(
content_size
.
height
/
scale_from
.
width
content_size
.
width
/
scale_from
.
height
1
.
0
)
}
}
}
else
{
LayoutTransform
:
:
identity
(
)
}
;
if
vertical_flip
{
let
content_size
=
&
self
.
iframe_size
.
last
(
)
.
unwrap
(
)
;
let
content_height
=
match
rotation
{
Rotation
:
:
Degree0
|
Rotation
:
:
Degree180
=
>
content_size
.
height
Rotation
:
:
Degree90
|
Rotation
:
:
Degree270
=
>
content_size
.
width
}
;
transform
=
transform
.
then_translate
(
LayoutVector3D
:
:
new
(
0
.
0
content_height
0
.
0
)
)
.
pre_scale
(
1
.
0
-
1
.
0
1
.
0
)
;
}
let
rotate
=
rotation
.
to_matrix
(
*
*
content_size
)
;
let
transform
=
transform
.
then
(
&
rotate
)
;
PropertyBinding
:
:
Value
(
transform
)
}
}
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
parent_space
)
;
self
.
push_reference_frame
(
info
.
reference_frame
.
id
parent_space
pipeline_id
info
.
reference_frame
.
transform_style
transform
info
.
reference_frame
.
kind
(
info
.
origin
+
external_scroll_offset
)
.
to_vector
(
)
SpatialNodeUid
:
:
external
(
info
.
reference_frame
.
key
pipeline_id
instance_id
)
)
;
}
fn
build_scroll_frame
(
&
mut
self
info
:
&
ScrollFrameDescriptor
parent_node_index
:
SpatialNodeIndex
pipeline_id
:
PipelineId
instance_id
:
PipelineInstanceId
)
{
let
content_size
=
info
.
content_rect
.
size
(
)
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
parent_node_index
)
;
self
.
add_scroll_frame
(
info
.
scroll_frame_id
parent_node_index
info
.
external_id
pipeline_id
&
info
.
frame_rect
.
translate
(
external_scroll_offset
)
&
content_size
ScrollFrameKind
:
:
Explicit
info
.
external_scroll_offset
info
.
scroll_offset_generation
info
.
has_scroll_linked_effect
SpatialNodeUid
:
:
external
(
info
.
key
pipeline_id
instance_id
)
)
;
}
fn
get_next_instance_id_for_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
PipelineInstanceId
{
let
next_instance
=
self
.
pipeline_instance_ids
.
entry
(
pipeline_id
)
.
or_insert
(
0
)
;
let
instance_id
=
PipelineInstanceId
:
:
new
(
*
next_instance
)
;
*
next_instance
+
=
1
;
instance_id
}
fn
push_iframe
(
&
mut
self
info
:
&
IframeDisplayItem
spatial_node_index
:
SpatialNodeIndex
)
-
>
Option
<
BuiltDisplayListIter
<
'
a
>
>
{
let
iframe_pipeline_id
=
info
.
pipeline_id
;
let
pipeline
=
match
self
.
scene
.
pipelines
.
get
(
&
iframe_pipeline_id
)
{
Some
(
pipeline
)
=
>
pipeline
None
=
>
{
debug_assert
!
(
info
.
ignore_missing_pipeline
)
;
return
None
}
}
;
self
.
clip_tree_builder
.
push_clip_chain
(
Some
(
info
.
space_and_clip
.
clip_chain_id
)
false
)
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
self
.
add_rect_clip_node
(
ClipId
:
:
root
(
iframe_pipeline_id
)
info
.
space_and_clip
.
spatial_id
&
info
.
clip_rect
)
;
self
.
clip_tree_builder
.
push_clip_id
(
ClipId
:
:
root
(
iframe_pipeline_id
)
)
;
let
instance_id
=
self
.
get_next_instance_id_for_pipeline
(
iframe_pipeline_id
)
;
self
.
id_to_index_mapper_stack
.
push
(
NodeIdToIndexMapper
:
:
default
(
)
)
;
let
mut
bounds
=
self
.
snap_rect
(
&
info
.
bounds
spatial_node_index
)
;
bounds
=
bounds
.
translate
(
external_scroll_offset
)
;
let
spatial_node_index
=
self
.
push_reference_frame
(
SpatialId
:
:
root_reference_frame
(
iframe_pipeline_id
)
spatial_node_index
iframe_pipeline_id
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
paired_with_perspective
:
false
}
bounds
.
min
.
to_vector
(
)
SpatialNodeUid
:
:
root_reference_frame
(
iframe_pipeline_id
instance_id
)
)
;
let
iframe_rect
=
LayoutRect
:
:
from_size
(
bounds
.
size
(
)
)
;
let
is_root_pipeline
=
self
.
iframe_size
.
is_empty
(
)
;
self
.
add_scroll_frame
(
SpatialId
:
:
root_scroll_node
(
iframe_pipeline_id
)
spatial_node_index
ExternalScrollId
(
0
iframe_pipeline_id
)
iframe_pipeline_id
&
iframe_rect
&
bounds
.
size
(
)
ScrollFrameKind
:
:
PipelineRoot
{
is_root_pipeline
}
LayoutVector2D
:
:
zero
(
)
APZScrollGeneration
:
:
default
(
)
HasScrollLinkedEffect
:
:
No
SpatialNodeUid
:
:
root_scroll_frame
(
iframe_pipeline_id
instance_id
)
)
;
if
self
.
iframe_size
.
is_empty
(
)
{
assert
!
(
self
.
root_iframe_clip
.
is_none
(
)
)
;
self
.
root_iframe_clip
=
Some
(
ClipId
:
:
root
(
iframe_pipeline_id
)
)
;
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
}
self
.
iframe_size
.
push
(
bounds
.
size
(
)
)
;
self
.
build_spatial_tree_for_display_list
(
&
pipeline
.
display_list
.
display_list
iframe_pipeline_id
instance_id
)
;
Some
(
pipeline
.
display_list
.
iter
(
)
)
}
fn
get_space
(
&
self
spatial_id
:
SpatialId
)
-
>
SpatialNodeIndex
{
self
.
id_to_index_mapper_stack
.
last
(
)
.
unwrap
(
)
.
get_spatial_node_index
(
spatial_id
)
}
fn
get_clip_node
(
&
mut
self
clip_chain_id
:
api
:
:
ClipChainId
)
-
>
ClipNodeId
{
self
.
clip_tree_builder
.
build_clip_set
(
clip_chain_id
)
}
fn
process_common_properties
(
&
mut
self
common
:
&
CommonItemProperties
bounds
:
Option
<
&
LayoutRect
>
)
-
>
(
LayoutPrimitiveInfo
LayoutRect
SpatialNodeIndex
ClipNodeId
)
{
let
spatial_node_index
=
self
.
get_space
(
common
.
spatial_id
)
;
let
current_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
let
unsnapped_clip_rect
=
common
.
clip_rect
.
translate
(
current_offset
)
;
let
unsnapped_rect
=
bounds
.
map
(
|
bounds
|
{
bounds
.
translate
(
current_offset
)
}
)
;
let
(
rect
clip_rect
)
=
if
common
.
flags
.
contains
(
PrimitiveFlags
:
:
ANTIALISED
)
{
(
unsnapped_rect
.
unwrap_or
(
unsnapped_clip_rect
)
unsnapped_clip_rect
)
}
else
{
let
clip_rect
=
self
.
snap_rect
(
&
unsnapped_clip_rect
spatial_node_index
)
;
let
rect
=
unsnapped_rect
.
map_or
(
clip_rect
|
bounds
|
{
self
.
snap_rect
(
&
bounds
spatial_node_index
)
}
)
;
(
rect
clip_rect
)
}
;
let
clip_node_id
=
self
.
get_clip_node
(
common
.
clip_chain_id
)
;
let
layout
=
LayoutPrimitiveInfo
{
rect
clip_rect
flags
:
common
.
flags
}
;
(
layout
unsnapped_rect
.
unwrap_or
(
unsnapped_clip_rect
)
spatial_node_index
clip_node_id
)
}
fn
process_common_properties_with_bounds
(
&
mut
self
common
:
&
CommonItemProperties
bounds
:
&
LayoutRect
)
-
>
(
LayoutPrimitiveInfo
LayoutRect
SpatialNodeIndex
ClipNodeId
)
{
self
.
process_common_properties
(
common
Some
(
bounds
)
)
}
pub
fn
snap_rect
(
&
mut
self
rect
:
&
LayoutRect
target_spatial_node
:
SpatialNodeIndex
)
-
>
LayoutRect
{
self
.
snap_to_device
.
set_target_spatial_node
(
target_spatial_node
self
.
spatial_tree
)
;
self
.
snap_to_device
.
snap_rect
(
&
rect
)
}
fn
build_item
<
'
b
>
(
&
'
b
mut
self
item
:
DisplayItemRef
)
{
match
*
item
.
item
(
)
{
DisplayItem
:
:
Image
(
ref
info
)
=
>
{
profile_scope
!
(
"
image
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_image
(
spatial_node_index
clip_node_id
&
layout
layout
.
rect
.
size
(
)
LayoutSize
:
:
zero
(
)
info
.
image_key
info
.
image_rendering
info
.
alpha_type
info
.
color
)
;
}
DisplayItem
:
:
RepeatingImage
(
ref
info
)
=
>
{
profile_scope
!
(
"
repeating_image
"
)
;
let
(
layout
unsnapped_rect
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
let
stretch_size
=
process_repeat_size
(
&
layout
.
rect
&
unsnapped_rect
info
.
stretch_size
)
;
self
.
add_image
(
spatial_node_index
clip_node_id
&
layout
stretch_size
info
.
tile_spacing
info
.
image_key
info
.
image_rendering
info
.
alpha_type
info
.
color
)
;
}
DisplayItem
:
:
YuvImage
(
ref
info
)
=
>
{
profile_scope
!
(
"
yuv_image
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_yuv_image
(
spatial_node_index
clip_node_id
&
layout
info
.
yuv_data
info
.
color_depth
info
.
color_space
info
.
color_range
info
.
image_rendering
)
;
}
DisplayItem
:
:
Text
(
ref
info
)
=
>
{
profile_scope
!
(
"
text
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_text
(
spatial_node_index
clip_node_id
&
layout
&
info
.
font_key
&
info
.
color
item
.
glyphs
(
)
info
.
glyph_options
info
.
ref_frame_offset
)
;
}
DisplayItem
:
:
Rectangle
(
ref
info
)
=
>
{
profile_scope
!
(
"
rect
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_primitive
(
spatial_node_index
clip_node_id
&
layout
Vec
:
:
new
(
)
PrimitiveKeyKind
:
:
Rectangle
{
color
:
info
.
color
.
into
(
)
}
)
;
if
info
.
common
.
flags
.
contains
(
PrimitiveFlags
:
:
CHECKERBOARD_BACKGROUND
)
{
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
}
}
DisplayItem
:
:
HitTest
(
ref
info
)
=
>
{
profile_scope
!
(
"
hit_test
"
)
;
let
spatial_node_index
=
self
.
get_space
(
info
.
spatial_id
)
;
let
current_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
let
mut
rect
=
self
.
snap_rect
(
&
info
.
rect
spatial_node_index
)
;
rect
=
rect
.
translate
(
current_offset
)
;
let
layout
=
LayoutPrimitiveInfo
{
rect
clip_rect
:
rect
flags
:
info
.
flags
}
;
let
spatial_node
=
self
.
spatial_tree
.
get_node_info
(
spatial_node_index
)
;
let
anim_id
:
u64
=
match
spatial_node
.
node_type
{
SpatialNodeType
:
:
ReferenceFrame
(
ReferenceFrameInfo
{
source_transform
:
PropertyBinding
:
:
Binding
(
key
_
)
.
.
}
)
=
>
key
.
clone
(
)
.
into
(
)
_
=
>
0
}
;
let
clip_node_id
=
self
.
get_clip_node
(
info
.
clip_chain_id
)
;
self
.
add_primitive_to_hit_testing_list
(
&
layout
spatial_node_index
clip_node_id
info
.
tag
anim_id
)
;
}
DisplayItem
:
:
ClearRectangle
(
ref
info
)
=
>
{
profile_scope
!
(
"
clear
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_clear_rectangle
(
spatial_node_index
clip_node_id
&
layout
)
;
}
DisplayItem
:
:
Line
(
ref
info
)
=
>
{
profile_scope
!
(
"
line
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
area
)
;
self
.
add_line
(
spatial_node_index
clip_node_id
&
layout
info
.
wavy_line_thickness
info
.
orientation
info
.
color
info
.
style
)
;
}
DisplayItem
:
:
Gradient
(
ref
info
)
=
>
{
profile_scope
!
(
"
gradient
"
)
;
if
!
info
.
gradient
.
is_valid
(
)
{
return
;
}
let
(
mut
layout
unsnapped_rect
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
let
mut
tile_size
=
process_repeat_size
(
&
layout
.
rect
&
unsnapped_rect
info
.
tile_size
)
;
let
mut
stops
=
read_gradient_stops
(
item
.
gradient_stops
(
)
)
;
let
mut
start
=
info
.
gradient
.
start_point
;
let
mut
end
=
info
.
gradient
.
end_point
;
let
flags
=
layout
.
flags
;
let
optimized
=
optimize_linear_gradient
(
&
mut
layout
.
rect
&
mut
tile_size
info
.
tile_spacing
&
layout
.
clip_rect
&
mut
start
&
mut
end
info
.
gradient
.
extend_mode
&
mut
stops
&
mut
|
rect
start
end
stops
edge_aa_mask
|
{
let
layout
=
LayoutPrimitiveInfo
{
rect
:
*
rect
clip_rect
:
*
rect
flags
}
;
if
let
Some
(
prim_key_kind
)
=
self
.
create_linear_gradient_prim
(
&
layout
start
end
stops
.
to_vec
(
)
ExtendMode
:
:
Clamp
rect
.
size
(
)
LayoutSize
:
:
zero
(
)
None
edge_aa_mask
)
{
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
&
layout
Vec
:
:
new
(
)
prim_key_kind
)
;
}
}
)
;
if
!
optimized
&
&
!
tile_size
.
ceil
(
)
.
is_empty
(
)
{
if
let
Some
(
prim_key_kind
)
=
self
.
create_linear_gradient_prim
(
&
layout
start
end
stops
info
.
gradient
.
extend_mode
tile_size
info
.
tile_spacing
None
EdgeAaSegmentMask
:
:
all
(
)
)
{
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
&
layout
Vec
:
:
new
(
)
prim_key_kind
)
;
}
}
}
DisplayItem
:
:
RadialGradient
(
ref
info
)
=
>
{
profile_scope
!
(
"
radial
"
)
;
if
!
info
.
gradient
.
is_valid
(
)
{
return
;
}
let
(
mut
layout
unsnapped_rect
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
let
mut
center
=
info
.
gradient
.
center
;
let
stops
=
read_gradient_stops
(
item
.
gradient_stops
(
)
)
;
let
mut
tile_size
=
process_repeat_size
(
&
layout
.
rect
&
unsnapped_rect
info
.
tile_size
)
;
let
mut
prim_rect
=
layout
.
rect
;
let
mut
tile_spacing
=
info
.
tile_spacing
;
optimize_radial_gradient
(
&
mut
prim_rect
&
mut
tile_size
&
mut
center
&
mut
tile_spacing
&
layout
.
clip_rect
info
.
gradient
.
radius
info
.
gradient
.
end_offset
info
.
gradient
.
extend_mode
&
stops
&
mut
|
solid_rect
color
|
{
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
&
LayoutPrimitiveInfo
{
rect
:
*
solid_rect
.
.
layout
}
Vec
:
:
new
(
)
PrimitiveKeyKind
:
:
Rectangle
{
color
:
PropertyBinding
:
:
Value
(
color
)
}
)
;
}
)
;
simplify_repeated_primitive
(
&
tile_size
&
mut
tile_spacing
&
mut
prim_rect
)
;
if
!
tile_size
.
ceil
(
)
.
is_empty
(
)
{
layout
.
rect
=
prim_rect
;
let
prim_key_kind
=
self
.
create_radial_gradient_prim
(
&
layout
center
info
.
gradient
.
start_offset
*
info
.
gradient
.
radius
.
width
info
.
gradient
.
end_offset
*
info
.
gradient
.
radius
.
width
info
.
gradient
.
radius
.
width
/
info
.
gradient
.
radius
.
height
stops
info
.
gradient
.
extend_mode
tile_size
tile_spacing
None
)
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
&
layout
Vec
:
:
new
(
)
prim_key_kind
)
;
}
}
DisplayItem
:
:
ConicGradient
(
ref
info
)
=
>
{
profile_scope
!
(
"
conic
"
)
;
if
!
info
.
gradient
.
is_valid
(
)
{
return
;
}
let
(
mut
layout
unsnapped_rect
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
let
tile_size
=
process_repeat_size
(
&
layout
.
rect
&
unsnapped_rect
info
.
tile_size
)
;
let
offset
=
apply_gradient_local_clip
(
&
mut
layout
.
rect
&
tile_size
&
info
.
tile_spacing
&
layout
.
clip_rect
)
;
let
center
=
info
.
gradient
.
center
+
offset
;
if
!
tile_size
.
ceil
(
)
.
is_empty
(
)
{
let
prim_key_kind
=
self
.
create_conic_gradient_prim
(
&
layout
center
info
.
gradient
.
angle
info
.
gradient
.
start_offset
info
.
gradient
.
end_offset
item
.
gradient_stops
(
)
info
.
gradient
.
extend_mode
tile_size
info
.
tile_spacing
None
)
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
&
layout
Vec
:
:
new
(
)
prim_key_kind
)
;
}
}
DisplayItem
:
:
BoxShadow
(
ref
info
)
=
>
{
profile_scope
!
(
"
box_shadow
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
box_bounds
)
;
self
.
add_box_shadow
(
spatial_node_index
clip_node_id
&
layout
&
info
.
offset
info
.
color
info
.
blur_radius
info
.
spread_radius
info
.
border_radius
info
.
clip_mode
)
;
}
DisplayItem
:
:
Border
(
ref
info
)
=
>
{
profile_scope
!
(
"
border
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties_with_bounds
(
&
info
.
common
&
info
.
bounds
)
;
self
.
add_border
(
spatial_node_index
clip_node_id
&
layout
info
item
.
gradient_stops
(
)
)
;
}
DisplayItem
:
:
ImageMaskClip
(
ref
info
)
=
>
{
profile_scope
!
(
"
image_clip
"
)
;
self
.
add_image_mask_clip_node
(
info
.
id
info
.
spatial_id
&
info
.
image_mask
info
.
fill_rule
item
.
points
(
)
)
;
}
DisplayItem
:
:
RoundedRectClip
(
ref
info
)
=
>
{
profile_scope
!
(
"
rounded_clip
"
)
;
self
.
add_rounded_rect_clip_node
(
info
.
id
info
.
spatial_id
&
info
.
clip
)
;
}
DisplayItem
:
:
RectClip
(
ref
info
)
=
>
{
profile_scope
!
(
"
rect_clip
"
)
;
self
.
add_rect_clip_node
(
info
.
id
info
.
spatial_id
&
info
.
clip_rect
)
;
}
DisplayItem
:
:
ClipChain
(
ref
info
)
=
>
{
profile_scope
!
(
"
clip_chain
"
)
;
self
.
clip_tree_builder
.
define_clip_chain
(
info
.
id
info
.
parent
item
.
clip_chain_items
(
)
.
into_iter
(
)
)
;
}
DisplayItem
:
:
BackdropFilter
(
ref
info
)
=
>
{
profile_scope
!
(
"
backdrop
"
)
;
let
(
layout
_
spatial_node_index
clip_node_id
)
=
self
.
process_common_properties
(
&
info
.
common
None
)
;
let
filters
=
filter_ops_for_compositing
(
item
.
filters
(
)
)
;
let
filter_datas
=
filter_datas_for_compositing
(
item
.
filter_datas
(
)
)
;
let
filter_primitives
=
filter_primitives_for_compositing
(
item
.
filter_primitives
(
)
)
;
self
.
add_backdrop_filter
(
spatial_node_index
clip_node_id
&
layout
filters
filter_datas
filter_primitives
)
;
}
DisplayItem
:
:
SetGradientStops
|
DisplayItem
:
:
SetFilterOps
|
DisplayItem
:
:
SetFilterData
|
DisplayItem
:
:
SetFilterPrimitives
|
DisplayItem
:
:
SetPoints
=
>
{
}
DisplayItem
:
:
PushStackingContext
(
.
.
)
|
DisplayItem
:
:
PushReferenceFrame
(
.
.
)
|
DisplayItem
:
:
PopReferenceFrame
|
DisplayItem
:
:
PopStackingContext
|
DisplayItem
:
:
Iframe
(
_
)
=
>
{
unreachable
!
(
"
Handled
in
build_all
"
)
}
DisplayItem
:
:
ReuseItems
(
key
)
|
DisplayItem
:
:
RetainedItems
(
key
)
=
>
{
unreachable
!
(
"
Iterator
logic
error
:
{
:
?
}
"
key
)
;
}
DisplayItem
:
:
PushShadow
(
info
)
=
>
{
profile_scope
!
(
"
push_shadow
"
)
;
let
spatial_node_index
=
self
.
get_space
(
info
.
space_and_clip
.
spatial_id
)
;
self
.
push_shadow
(
info
.
shadow
spatial_node_index
info
.
space_and_clip
.
clip_chain_id
info
.
should_inflate
)
;
}
DisplayItem
:
:
PopAllShadows
=
>
{
profile_scope
!
(
"
pop_all_shadows
"
)
;
self
.
pop_all_shadows
(
)
;
}
}
}
fn
create_primitive
<
P
>
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
clip_leaf_id
:
ClipLeafId
prim
:
P
)
-
>
PrimitiveInstance
where
P
:
InternablePrimitive
Interners
:
AsMut
<
Interner
<
P
>
>
{
let
prim_key
=
prim
.
into_key
(
info
)
;
let
interner
=
self
.
interners
.
as_mut
(
)
;
let
prim_data_handle
=
interner
.
intern
(
&
prim_key
|
|
(
)
)
;
let
instance_kind
=
P
:
:
make_instance_kind
(
prim_key
prim_data_handle
&
mut
self
.
prim_store
)
;
PrimitiveInstance
:
:
new
(
instance_kind
clip_leaf_id
)
}
fn
add_primitive_to_hit_testing_list
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
tag
:
ItemTag
anim_id
:
u64
)
{
self
.
hit_testing_scene
.
add_item
(
tag
anim_id
info
spatial_node_index
clip_node_id
&
self
.
clip_tree_builder
self
.
interners
)
;
}
pub
fn
add_primitive_to_draw_list
(
&
mut
self
prim_instance
:
PrimitiveInstance
prim_rect
:
LayoutRect
spatial_node_index
:
SpatialNodeIndex
flags
:
PrimitiveFlags
)
{
match
self
.
sc_stack
.
last_mut
(
)
{
Some
(
stacking_context
)
=
>
{
stacking_context
.
prim_list
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
None
=
>
{
self
.
tile_cache_builder
.
add_prim
(
prim_instance
prim_rect
spatial_node_index
flags
self
.
spatial_tree
self
.
interners
&
self
.
quality_settings
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
}
}
fn
add_nonshadowable_primitive
<
P
>
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
clip_items
:
Vec
<
ClipItemKey
>
prim
:
P
)
where
P
:
InternablePrimitive
+
IsVisible
Interners
:
AsMut
<
Interner
<
P
>
>
{
if
prim
.
is_visible
(
)
{
let
clip_leaf_id
=
self
.
clip_tree_builder
.
build_for_prim
(
clip_node_id
info
&
clip_items
&
mut
self
.
interners
)
;
self
.
add_prim_to_draw_list
(
info
spatial_node_index
clip_leaf_id
prim
)
;
}
}
pub
fn
add_primitive
<
P
>
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
clip_items
:
Vec
<
ClipItemKey
>
prim
:
P
)
where
P
:
InternablePrimitive
+
IsVisible
Interners
:
AsMut
<
Interner
<
P
>
>
ShadowItem
:
From
<
PendingPrimitive
<
P
>
>
{
if
self
.
pending_shadow_items
.
is_empty
(
)
{
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
clip_items
prim
)
;
}
else
{
debug_assert
!
(
clip_items
.
is_empty
(
)
"
No
per
-
prim
clips
expected
for
shadowed
primitives
"
)
;
self
.
pending_shadow_items
.
push_back
(
PendingPrimitive
{
spatial_node_index
clip_node_id
info
:
*
info
prim
}
.
into
(
)
)
;
}
}
fn
add_prim_to_draw_list
<
P
>
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
spatial_node_index
:
SpatialNodeIndex
clip_leaf_id
:
ClipLeafId
prim
:
P
)
where
P
:
InternablePrimitive
Interners
:
AsMut
<
Interner
<
P
>
>
{
let
prim_instance
=
self
.
create_primitive
(
info
clip_leaf_id
prim
)
;
self
.
add_primitive_to_draw_list
(
prim_instance
info
.
rect
spatial_node_index
info
.
flags
)
;
}
fn
make_current_slice_atomic_if_required
(
&
mut
self
)
{
let
has_non_wrapping_sc
=
self
.
sc_stack
.
iter
(
)
.
position
(
|
sc
|
{
!
sc
.
flags
.
contains
(
StackingContextFlags
:
:
WRAPS_BACKDROP_FILTER
)
}
)
.
is_some
(
)
;
if
has_non_wrapping_sc
{
return
;
}
assert
!
(
self
.
pending_shadow_items
.
is_empty
(
)
)
;
self
.
tile_cache_builder
.
make_current_slice_atomic
(
)
;
}
fn
add_tile_cache_barrier_if_needed
(
&
mut
self
slice_flags
:
SliceFlags
)
{
if
self
.
sc_stack
.
is_empty
(
)
{
assert
!
(
self
.
pending_shadow_items
.
is_empty
(
)
)
;
self
.
tile_cache_builder
.
add_tile_cache_barrier
(
slice_flags
self
.
root_iframe_clip
)
;
}
}
fn
push_stacking_context
(
&
mut
self
composite_ops
:
CompositeOps
transform_style
:
TransformStyle
prim_flags
:
PrimitiveFlags
spatial_node_index
:
SpatialNodeIndex
clip_chain_id
:
Option
<
api
:
:
ClipChainId
>
requested_raster_space
:
RasterSpace
flags
:
StackingContextFlags
subregion_offset
:
LayoutVector2D
)
-
>
StackingContextInfo
{
profile_scope
!
(
"
push_stacking_context
"
)
;
let
clip_node_id
=
match
clip_chain_id
{
Some
(
id
)
=
>
{
self
.
clip_tree_builder
.
build_clip_set
(
id
)
}
None
=
>
{
self
.
clip_tree_builder
.
build_clip_set
(
api
:
:
ClipChainId
:
:
INVALID
)
}
}
;
self
.
clip_tree_builder
.
push_clip_chain
(
clip_chain_id
!
composite_ops
.
is_empty
(
)
)
;
let
new_space
=
match
(
self
.
raster_space_stack
.
last
(
)
requested_raster_space
)
{
(
None
_
)
=
>
requested_raster_space
(
Some
(
parent_space
)
RasterSpace
:
:
Screen
)
=
>
*
parent_space
(
Some
(
RasterSpace
:
:
Screen
)
space
)
=
>
space
(
Some
(
RasterSpace
:
:
Local
(
parent_scale
)
)
RasterSpace
:
:
Local
(
scale
)
)
=
>
RasterSpace
:
:
Local
(
parent_scale
.
max
(
scale
)
)
}
;
self
.
raster_space_stack
.
push
(
new_space
)
;
let
(
parent_is_3d
extra_3d_instance
plane_splitter_index
)
=
match
self
.
sc_stack
.
last_mut
(
)
{
Some
(
ref
mut
sc
)
if
sc
.
is_3d
(
)
=
>
{
let
(
flat_items_context_3d
plane_splitter_index
)
=
match
sc
.
context_3d
{
Picture3DContext
:
:
In
{
ancestor_index
plane_splitter_index
.
.
}
=
>
{
(
Picture3DContext
:
:
In
{
root_data
:
None
ancestor_index
plane_splitter_index
}
plane_splitter_index
)
}
Picture3DContext
:
:
Out
=
>
panic
!
(
"
Unexpected
out
of
3D
context
"
)
}
;
let
extra_instance
=
sc
.
cut_item_sequence
(
&
mut
self
.
prim_store
&
mut
self
.
interners
Some
(
PictureCompositeMode
:
:
Blit
(
BlitReason
:
:
PRESERVE3D
)
)
flat_items_context_3d
&
mut
self
.
clip_tree_builder
)
;
let
extra_instance
=
extra_instance
.
map
(
|
(
_
instance
)
|
{
ExtendedPrimitiveInstance
{
instance
spatial_node_index
:
sc
.
spatial_node_index
flags
:
sc
.
prim_flags
}
}
)
;
(
true
extra_instance
Some
(
plane_splitter_index
)
)
}
_
=
>
(
false
None
None
)
}
;
if
let
Some
(
instance
)
=
extra_3d_instance
{
self
.
add_primitive_instance_to_3d_root
(
instance
)
;
}
let
participating_in_3d_context
=
composite_ops
.
is_empty
(
)
&
&
(
parent_is_3d
|
|
transform_style
=
=
TransformStyle
:
:
Preserve3D
)
;
let
context_3d
=
if
participating_in_3d_context
{
let
ancestor_index
=
self
.
containing_block_stack
.
last
(
)
.
cloned
(
)
.
unwrap_or
(
self
.
spatial_tree
.
root_reference_frame_index
(
)
)
;
let
plane_splitter_index
=
plane_splitter_index
.
unwrap_or_else
(
|
|
{
let
index
=
self
.
next_plane_splitter_index
;
self
.
next_plane_splitter_index
+
=
1
;
PlaneSplitterIndex
(
index
)
}
)
;
Picture3DContext
:
:
In
{
root_data
:
if
parent_is_3d
{
None
}
else
{
Some
(
Vec
:
:
new
(
)
)
}
plane_splitter_index
ancestor_index
}
}
else
{
Picture3DContext
:
:
Out
}
;
let
mut
blit_reason
=
BlitReason
:
:
empty
(
)
;
if
let
Some
(
clip_chain_id
)
=
clip_chain_id
{
if
self
.
clip_tree_builder
.
clip_chain_has_complex_clips
(
clip_chain_id
&
self
.
interners
)
{
blit_reason
|
=
BlitReason
:
:
CLIP
;
}
}
let
mut
is_redundant
=
FlattenedStackingContext
:
:
is_redundant
(
&
context_3d
&
composite_ops
blit_reason
self
.
sc_stack
.
last
(
)
prim_flags
)
;
if
flags
.
contains
(
StackingContextFlags
:
:
IS_BLEND_CONTAINER
)
{
match
self
.
sc_stack
.
last
(
)
{
Some
(
_
)
=
>
{
blit_reason
|
=
BlitReason
:
:
ISOLATE
;
is_redundant
=
false
;
}
None
=
>
{
if
self
.
tile_cache_builder
.
is_current_slice_empty
(
)
&
&
self
.
spatial_tree
.
is_root_coord_system
(
spatial_node_index
)
&
&
!
self
.
clip_tree_builder
.
clip_node_has_complex_clips
(
clip_node_id
&
self
.
interners
)
{
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
IS_ATOMIC
)
;
self
.
tile_cache_builder
.
make_current_slice_atomic
(
)
;
}
else
{
blit_reason
|
=
BlitReason
:
:
ISOLATE
;
is_redundant
=
false
;
}
}
}
}
let
set_tile_cache_barrier
=
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_SCROLLBAR_CONTAINER
)
;
if
set_tile_cache_barrier
{
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
IS_SCROLLBAR
)
;
}
let
mut
sc_info
=
StackingContextInfo
{
pop_stacking_context
:
false
pop_containing_block
:
false
set_tile_cache_barrier
}
;
if
!
participating_in_3d_context
{
sc_info
.
pop_containing_block
=
true
;
self
.
containing_block_stack
.
push
(
spatial_node_index
)
;
}
if
!
is_redundant
{
sc_info
.
pop_stacking_context
=
true
;
self
.
sc_stack
.
push
(
FlattenedStackingContext
{
prim_list
:
PrimitiveList
:
:
empty
(
)
prim_flags
spatial_node_index
clip_node_id
composite_ops
blit_reason
transform_style
context_3d
flags
raster_space
:
new_space
subregion_offset
}
)
;
}
sc_info
}
fn
pop_stacking_context
(
&
mut
self
info
:
StackingContextInfo
)
{
profile_scope
!
(
"
pop_stacking_context
"
)
;
self
.
clip_tree_builder
.
pop_clip
(
)
;
self
.
raster_space_stack
.
pop
(
)
.
unwrap
(
)
;
if
info
.
pop_containing_block
{
self
.
containing_block_stack
.
pop
(
)
.
unwrap
(
)
;
}
if
info
.
set_tile_cache_barrier
{
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
}
if
!
info
.
pop_stacking_context
{
return
;
}
let
stacking_context
=
self
.
sc_stack
.
pop
(
)
.
unwrap
(
)
;
let
mut
source
=
match
stacking_context
.
context_3d
{
Picture3DContext
:
:
In
{
ancestor_index
plane_splitter_index
.
.
}
=
>
{
let
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
(
BlitReason
:
:
PRESERVE3D
|
stacking_context
.
blit_reason
)
)
;
let
pic_index
=
PictureIndex
(
self
.
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
composite_mode
.
clone
(
)
Picture3DContext
:
:
In
{
root_data
:
None
ancestor_index
plane_splitter_index
}
stacking_context
.
prim_flags
stacking_context
.
prim_list
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
PictureFlags
:
:
empty
(
)
)
)
)
;
let
instance
=
create_prim_instance
(
pic_index
composite_mode
.
into
(
)
stacking_context
.
raster_space
stacking_context
.
clip_node_id
&
mut
self
.
interners
&
mut
self
.
clip_tree_builder
)
;
PictureChainBuilder
:
:
from_instance
(
instance
stacking_context
.
prim_flags
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
)
}
Picture3DContext
:
:
Out
=
>
{
if
stacking_context
.
blit_reason
.
is_empty
(
)
{
PictureChainBuilder
:
:
from_prim_list
(
stacking_context
.
prim_list
stacking_context
.
prim_flags
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
false
)
}
else
{
let
composite_mode
=
Some
(
PictureCompositeMode
:
:
Blit
(
stacking_context
.
blit_reason
)
)
;
let
pic_index
=
PictureIndex
(
self
.
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
composite_mode
.
clone
(
)
Picture3DContext
:
:
Out
stacking_context
.
prim_flags
stacking_context
.
prim_list
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
PictureFlags
:
:
empty
(
)
)
)
)
;
let
instance
=
create_prim_instance
(
pic_index
composite_mode
.
into
(
)
stacking_context
.
raster_space
stacking_context
.
clip_node_id
&
mut
self
.
interners
&
mut
self
.
clip_tree_builder
)
;
PictureChainBuilder
:
:
from_instance
(
instance
stacking_context
.
prim_flags
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
)
}
}
}
;
if
let
Picture3DContext
:
:
In
{
root_data
:
Some
(
mut
prims
)
ancestor_index
plane_splitter_index
}
=
stacking_context
.
context_3d
{
let
instance
=
source
.
finalize
(
ClipNodeId
:
:
NONE
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
clip_tree_builder
)
;
prims
.
push
(
ExtendedPrimitiveInstance
{
instance
spatial_node_index
:
stacking_context
.
spatial_node_index
flags
:
stacking_context
.
prim_flags
}
)
;
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
let
mut
needs_3d_context
=
false
;
for
ext_prim
in
prims
.
drain
(
.
.
)
{
if
!
self
.
spatial_tree
.
is_root_coord_system
(
ext_prim
.
spatial_node_index
)
{
needs_3d_context
=
true
;
}
prim_list
.
add_prim
(
ext_prim
.
instance
LayoutRect
:
:
zero
(
)
ext_prim
.
spatial_node_index
ext_prim
.
flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
let
context_3d
=
if
needs_3d_context
{
Picture3DContext
:
:
In
{
root_data
:
Some
(
Vec
:
:
new
(
)
)
ancestor_index
plane_splitter_index
}
}
else
{
for
child_pic_index
in
&
prim_list
.
child_pictures
{
let
child_pic
=
&
mut
self
.
prim_store
.
pictures
[
child_pic_index
.
0
]
;
child_pic
.
composite_mode
=
None
;
child_pic
.
context_3d
=
Picture3DContext
:
:
Out
;
}
Picture3DContext
:
:
Out
}
;
let
pic_index
=
PictureIndex
(
self
.
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
None
context_3d
stacking_context
.
prim_flags
prim_list
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
PictureFlags
:
:
empty
(
)
)
)
)
;
let
instance
=
create_prim_instance
(
pic_index
PictureCompositeKey
:
:
Identity
stacking_context
.
raster_space
stacking_context
.
clip_node_id
&
mut
self
.
interners
&
mut
self
.
clip_tree_builder
)
;
source
=
PictureChainBuilder
:
:
from_instance
(
instance
stacking_context
.
prim_flags
stacking_context
.
spatial_node_index
stacking_context
.
raster_space
)
;
}
let
has_filters
=
stacking_context
.
composite_ops
.
has_valid_filters
(
)
;
let
spatial_node_context_offset
=
stacking_context
.
subregion_offset
+
self
.
current_external_scroll_offset
(
stacking_context
.
spatial_node_index
)
;
source
=
self
.
wrap_prim_with_filters
(
source
stacking_context
.
clip_node_id
stacking_context
.
composite_ops
.
filters
stacking_context
.
composite_ops
.
filter_primitives
stacking_context
.
composite_ops
.
filter_datas
None
spatial_node_context_offset
)
;
if
let
Some
(
mix_blend_mode
)
=
stacking_context
.
composite_ops
.
mix_blend_mode
{
let
composite_mode
=
PictureCompositeMode
:
:
MixBlend
(
mix_blend_mode
)
;
source
=
source
.
add_picture
(
composite_mode
stacking_context
.
clip_node_id
Picture3DContext
:
:
Out
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
prim_instances
&
mut
self
.
clip_tree_builder
)
;
}
let
cur_instance
=
source
.
finalize
(
stacking_context
.
clip_node_id
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
clip_tree_builder
)
;
let
trailing_children_instance
=
match
self
.
sc_stack
.
last_mut
(
)
{
Some
(
ref
parent_sc
)
if
!
has_filters
&
&
parent_sc
.
is_3d
(
)
=
>
{
Some
(
cur_instance
)
}
Some
(
ref
mut
parent_sc
)
=
>
{
parent_sc
.
prim_list
.
add_prim
(
cur_instance
LayoutRect
:
:
zero
(
)
stacking_context
.
spatial_node_index
stacking_context
.
prim_flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
None
}
None
=
>
{
self
.
add_primitive_to_draw_list
(
cur_instance
LayoutRect
:
:
zero
(
)
stacking_context
.
spatial_node_index
stacking_context
.
prim_flags
)
;
None
}
}
;
if
let
Some
(
instance
)
=
trailing_children_instance
{
self
.
add_primitive_instance_to_3d_root
(
ExtendedPrimitiveInstance
{
instance
spatial_node_index
:
stacking_context
.
spatial_node_index
flags
:
stacking_context
.
prim_flags
}
)
;
}
assert
!
(
self
.
pending_shadow_items
.
is_empty
(
)
"
Found
unpopped
shadows
when
popping
stacking
context
!
"
)
;
}
pub
fn
push_reference_frame
(
&
mut
self
reference_frame_id
:
SpatialId
parent_index
:
SpatialNodeIndex
pipeline_id
:
PipelineId
transform_style
:
TransformStyle
source_transform
:
PropertyBinding
<
LayoutTransform
>
kind
:
ReferenceFrameKind
origin_in_parent_reference_frame
:
LayoutVector2D
uid
:
SpatialNodeUid
)
-
>
SpatialNodeIndex
{
let
index
=
self
.
spatial_tree
.
add_reference_frame
(
parent_index
transform_style
source_transform
kind
origin_in_parent_reference_frame
pipeline_id
uid
)
;
self
.
id_to_index_mapper_stack
.
last_mut
(
)
.
unwrap
(
)
.
add_spatial_node
(
reference_frame_id
index
)
;
index
}
fn
push_root
(
&
mut
self
pipeline_id
:
PipelineId
instance
:
PipelineInstanceId
)
{
let
spatial_node_index
=
self
.
push_reference_frame
(
SpatialId
:
:
root_reference_frame
(
pipeline_id
)
self
.
spatial_tree
.
root_reference_frame_index
(
)
pipeline_id
TransformStyle
:
:
Flat
PropertyBinding
:
:
Value
(
LayoutTransform
:
:
identity
(
)
)
ReferenceFrameKind
:
:
Transform
{
is_2d_scale_translation
:
true
should_snap
:
true
paired_with_perspective
:
false
}
LayoutVector2D
:
:
zero
(
)
SpatialNodeUid
:
:
root_reference_frame
(
pipeline_id
instance
)
)
;
let
viewport_rect
=
LayoutRect
:
:
max_rect
(
)
;
self
.
add_scroll_frame
(
SpatialId
:
:
root_scroll_node
(
pipeline_id
)
spatial_node_index
ExternalScrollId
(
0
pipeline_id
)
pipeline_id
&
viewport_rect
&
viewport_rect
.
size
(
)
ScrollFrameKind
:
:
PipelineRoot
{
is_root_pipeline
:
true
}
LayoutVector2D
:
:
zero
(
)
APZScrollGeneration
:
:
default
(
)
HasScrollLinkedEffect
:
:
No
SpatialNodeUid
:
:
root_scroll_frame
(
pipeline_id
instance
)
)
;
}
fn
add_image_mask_clip_node
(
&
mut
self
new_node_id
:
ClipId
spatial_id
:
SpatialId
image_mask
:
&
ImageMask
fill_rule
:
FillRule
points_range
:
ItemRange
<
LayoutPoint
>
)
{
let
spatial_node_index
=
self
.
get_space
(
spatial_id
)
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
let
mut
snapped_mask_rect
=
self
.
snap_rect
(
&
image_mask
.
rect
spatial_node_index
)
;
snapped_mask_rect
=
snapped_mask_rect
.
translate
(
external_scroll_offset
)
;
let
points
:
Vec
<
LayoutPoint
>
=
points_range
.
iter
(
)
.
collect
(
)
;
let
mut
polygon_handle
:
Option
<
PolygonDataHandle
>
=
None
;
if
points
.
len
(
)
>
0
{
let
item
=
PolygonKey
:
:
new
(
&
points
fill_rule
)
;
let
handle
=
self
.
interners
.
polygon
.
intern
(
&
item
|
|
item
)
;
polygon_handle
=
Some
(
handle
)
;
}
let
item
=
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
image_mask
(
image_mask
snapped_mask_rect
polygon_handle
)
spatial_node_index
}
;
let
handle
=
self
.
interners
.
clip
.
intern
(
&
item
|
|
{
ClipInternData
{
key
:
item
}
}
)
;
self
.
clip_tree_builder
.
define_image_mask_clip
(
new_node_id
handle
)
;
}
fn
add_rect_clip_node
(
&
mut
self
new_node_id
:
ClipId
spatial_id
:
SpatialId
clip_rect
:
&
LayoutRect
)
{
let
spatial_node_index
=
self
.
get_space
(
spatial_id
)
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
let
mut
snapped_clip_rect
=
self
.
snap_rect
(
clip_rect
spatial_node_index
)
;
snapped_clip_rect
=
snapped_clip_rect
.
translate
(
external_scroll_offset
)
;
let
item
=
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rectangle
(
snapped_clip_rect
ClipMode
:
:
Clip
)
spatial_node_index
}
;
let
handle
=
self
.
interners
.
clip
.
intern
(
&
item
|
|
{
ClipInternData
{
key
:
item
}
}
)
;
self
.
clip_tree_builder
.
define_rect_clip
(
new_node_id
handle
)
;
}
fn
add_rounded_rect_clip_node
(
&
mut
self
new_node_id
:
ClipId
spatial_id
:
SpatialId
clip
:
&
ComplexClipRegion
)
{
let
spatial_node_index
=
self
.
get_space
(
spatial_id
)
;
let
external_scroll_offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
;
let
mut
snapped_region_rect
=
self
.
snap_rect
(
&
clip
.
rect
spatial_node_index
)
;
snapped_region_rect
=
snapped_region_rect
.
translate
(
external_scroll_offset
)
;
let
item
=
ClipItemKey
{
kind
:
ClipItemKeyKind
:
:
rounded_rect
(
snapped_region_rect
clip
.
radii
clip
.
mode
)
spatial_node_index
}
;
let
handle
=
self
.
interners
.
clip
.
intern
(
&
item
|
|
{
ClipInternData
{
key
:
item
}
}
)
;
self
.
clip_tree_builder
.
define_rounded_rect_clip
(
new_node_id
handle
)
;
}
pub
fn
add_scroll_frame
(
&
mut
self
new_node_id
:
SpatialId
parent_node_index
:
SpatialNodeIndex
external_id
:
ExternalScrollId
pipeline_id
:
PipelineId
frame_rect
:
&
LayoutRect
content_size
:
&
LayoutSize
frame_kind
:
ScrollFrameKind
external_scroll_offset
:
LayoutVector2D
scroll_offset_generation
:
APZScrollGeneration
has_scroll_linked_effect
:
HasScrollLinkedEffect
uid
:
SpatialNodeUid
)
-
>
SpatialNodeIndex
{
let
node_index
=
self
.
spatial_tree
.
add_scroll_frame
(
parent_node_index
external_id
pipeline_id
frame_rect
content_size
frame_kind
external_scroll_offset
scroll_offset_generation
has_scroll_linked_effect
uid
)
;
self
.
id_to_index_mapper_stack
.
last_mut
(
)
.
unwrap
(
)
.
add_spatial_node
(
new_node_id
node_index
)
;
node_index
}
pub
fn
push_shadow
(
&
mut
self
shadow
:
Shadow
spatial_node_index
:
SpatialNodeIndex
clip_chain_id
:
api
:
:
ClipChainId
should_inflate
:
bool
)
{
self
.
clip_tree_builder
.
push_clip_chain
(
Some
(
clip_chain_id
)
false
)
;
self
.
pending_shadow_items
.
push_back
(
ShadowItem
:
:
Shadow
(
PendingShadow
{
shadow
spatial_node_index
should_inflate
}
)
)
;
}
pub
fn
pop_all_shadows
(
&
mut
self
)
{
assert
!
(
!
self
.
pending_shadow_items
.
is_empty
(
)
"
popped
shadows
but
none
were
present
"
)
;
let
mut
items
=
mem
:
:
replace
(
&
mut
self
.
pending_shadow_items
VecDeque
:
:
new
(
)
)
;
while
let
Some
(
item
)
=
items
.
pop_front
(
)
{
match
item
{
ShadowItem
:
:
Shadow
(
pending_shadow
)
=
>
{
let
std_deviation
=
pending_shadow
.
shadow
.
blur_radius
*
0
.
5
;
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
let
blur_filter
=
Filter
:
:
Blur
{
width
:
std_deviation
height
:
std_deviation
should_inflate
:
pending_shadow
.
should_inflate
}
;
let
blur_is_noop
=
blur_filter
.
is_noop
(
)
;
for
item
in
&
items
{
let
(
instance
info
spatial_node_index
)
=
match
item
{
ShadowItem
:
:
Image
(
ref
pending_image
)
=
>
{
self
.
create_shadow_prim
(
&
pending_shadow
pending_image
blur_is_noop
)
}
ShadowItem
:
:
LineDecoration
(
ref
pending_line_dec
)
=
>
{
self
.
create_shadow_prim
(
&
pending_shadow
pending_line_dec
blur_is_noop
)
}
ShadowItem
:
:
NormalBorder
(
ref
pending_border
)
=
>
{
self
.
create_shadow_prim
(
&
pending_shadow
pending_border
blur_is_noop
)
}
ShadowItem
:
:
Primitive
(
ref
pending_primitive
)
=
>
{
self
.
create_shadow_prim
(
&
pending_shadow
pending_primitive
blur_is_noop
)
}
ShadowItem
:
:
TextRun
(
ref
pending_text_run
)
=
>
{
self
.
create_shadow_prim
(
&
pending_shadow
pending_text_run
blur_is_noop
)
}
_
=
>
{
continue
;
}
}
;
if
blur_is_noop
{
self
.
add_primitive_to_draw_list
(
instance
info
.
rect
spatial_node_index
info
.
flags
)
;
}
else
{
prim_list
.
add_prim
(
instance
info
.
rect
spatial_node_index
info
.
flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
}
if
!
prim_list
.
is_empty
(
)
{
assert
!
(
!
blur_filter
.
is_noop
(
)
)
;
let
composite_mode
=
Some
(
PictureCompositeMode
:
:
Filter
(
blur_filter
)
)
;
let
composite_mode_key
=
composite_mode
.
clone
(
)
.
into
(
)
;
let
raster_space
=
RasterSpace
:
:
Screen
;
let
shadow_pic_index
=
PictureIndex
(
self
.
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
composite_mode
Picture3DContext
:
:
Out
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
prim_list
pending_shadow
.
spatial_node_index
raster_space
PictureFlags
:
:
empty
(
)
)
)
)
;
let
shadow_pic_key
=
PictureKey
:
:
new
(
Picture
{
composite_mode_key
raster_space
}
)
;
let
shadow_prim_data_handle
=
self
.
interners
.
picture
.
intern
(
&
shadow_pic_key
|
|
(
)
)
;
let
clip_node_id
=
self
.
clip_tree_builder
.
build_clip_set
(
api
:
:
ClipChainId
:
:
INVALID
)
;
let
shadow_prim_instance
=
PrimitiveInstance
:
:
new
(
PrimitiveInstanceKind
:
:
Picture
{
data_handle
:
shadow_prim_data_handle
pic_index
:
shadow_pic_index
}
self
.
clip_tree_builder
.
build_for_picture
(
clip_node_id
)
)
;
self
.
add_primitive_to_draw_list
(
shadow_prim_instance
LayoutRect
:
:
zero
(
)
pending_shadow
.
spatial_node_index
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
;
}
self
.
clip_tree_builder
.
pop_clip
(
)
;
}
ShadowItem
:
:
Image
(
pending_image
)
=
>
{
self
.
add_shadow_prim_to_draw_list
(
pending_image
)
}
ShadowItem
:
:
LineDecoration
(
pending_line_dec
)
=
>
{
self
.
add_shadow_prim_to_draw_list
(
pending_line_dec
)
}
ShadowItem
:
:
NormalBorder
(
pending_border
)
=
>
{
self
.
add_shadow_prim_to_draw_list
(
pending_border
)
}
ShadowItem
:
:
Primitive
(
pending_primitive
)
=
>
{
self
.
add_shadow_prim_to_draw_list
(
pending_primitive
)
}
ShadowItem
:
:
TextRun
(
pending_text_run
)
=
>
{
self
.
add_shadow_prim_to_draw_list
(
pending_text_run
)
}
}
}
debug_assert
!
(
items
.
is_empty
(
)
)
;
self
.
pending_shadow_items
=
items
;
}
fn
create_shadow_prim
<
P
>
(
&
mut
self
pending_shadow
:
&
PendingShadow
pending_primitive
:
&
PendingPrimitive
<
P
>
blur_is_noop
:
bool
)
-
>
(
PrimitiveInstance
LayoutPrimitiveInfo
SpatialNodeIndex
)
where
P
:
InternablePrimitive
+
CreateShadow
Interners
:
AsMut
<
Interner
<
P
>
>
{
let
mut
info
=
pending_primitive
.
info
.
clone
(
)
;
info
.
rect
=
info
.
rect
.
translate
(
pending_shadow
.
shadow
.
offset
)
;
info
.
clip_rect
=
info
.
clip_rect
.
translate
(
pending_shadow
.
shadow
.
offset
)
;
let
clip_set
=
self
.
clip_tree_builder
.
build_for_prim
(
pending_primitive
.
clip_node_id
&
info
&
[
]
&
mut
self
.
interners
)
;
let
shadow_prim_instance
=
self
.
create_primitive
(
&
info
clip_set
pending_primitive
.
prim
.
create_shadow
(
&
pending_shadow
.
shadow
blur_is_noop
self
.
raster_space_stack
.
last
(
)
.
cloned
(
)
.
unwrap
(
)
)
)
;
(
shadow_prim_instance
info
pending_primitive
.
spatial_node_index
)
}
fn
add_shadow_prim_to_draw_list
<
P
>
(
&
mut
self
pending_primitive
:
PendingPrimitive
<
P
>
)
where
P
:
InternablePrimitive
+
IsVisible
Interners
:
AsMut
<
Interner
<
P
>
>
{
if
pending_primitive
.
prim
.
is_visible
(
)
{
let
clip_set
=
self
.
clip_tree_builder
.
build_for_prim
(
pending_primitive
.
clip_node_id
&
pending_primitive
.
info
&
[
]
&
mut
self
.
interners
)
;
self
.
add_prim_to_draw_list
(
&
pending_primitive
.
info
pending_primitive
.
spatial_node_index
clip_set
pending_primitive
.
prim
)
;
}
}
pub
fn
add_clear_rectangle
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
)
{
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
self
.
add_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
PrimitiveKeyKind
:
:
Clear
)
;
self
.
add_tile_cache_barrier_if_needed
(
SliceFlags
:
:
empty
(
)
)
;
}
pub
fn
add_line
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
wavy_line_thickness
:
f32
orientation
:
LineOrientation
color
:
ColorF
style
:
LineStyle
)
{
let
size
=
get_line_decoration_size
(
&
info
.
rect
.
size
(
)
orientation
style
wavy_line_thickness
)
;
let
cache_key
=
size
.
map
(
|
size
|
{
LineDecorationCacheKey
{
style
orientation
wavy_line_thickness
:
Au
:
:
from_f32_px
(
wavy_line_thickness
)
size
:
size
.
to_au
(
)
}
}
)
;
self
.
add_primitive
(
spatial_node_index
clip_node_id
&
info
Vec
:
:
new
(
)
LineDecoration
{
cache_key
color
:
color
.
into
(
)
}
)
;
}
pub
fn
add_border
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
border_item
:
&
BorderDisplayItem
gradient_stops
:
ItemRange
<
GradientStop
>
)
{
match
border_item
.
details
{
BorderDetails
:
:
NinePatch
(
ref
border
)
=
>
{
let
nine_patch
=
NinePatchDescriptor
{
width
:
border
.
width
height
:
border
.
height
slice
:
border
.
slice
fill
:
border
.
fill
repeat_horizontal
:
border
.
repeat_horizontal
repeat_vertical
:
border
.
repeat_vertical
widths
:
border_item
.
widths
.
into
(
)
}
;
match
border
.
source
{
NinePatchBorderSource
:
:
Image
(
key
rendering
)
=
>
{
let
prim
=
ImageBorder
{
request
:
ImageRequest
{
key
rendering
tile
:
None
}
nine_patch
}
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
prim
)
;
}
NinePatchBorderSource
:
:
Gradient
(
gradient
)
=
>
{
let
prim
=
match
self
.
create_linear_gradient_prim
(
&
info
gradient
.
start_point
gradient
.
end_point
read_gradient_stops
(
gradient_stops
)
gradient
.
extend_mode
LayoutSize
:
:
new
(
border
.
height
as
f32
border
.
width
as
f32
)
LayoutSize
:
:
zero
(
)
Some
(
Box
:
:
new
(
nine_patch
)
)
EdgeAaSegmentMask
:
:
all
(
)
)
{
Some
(
prim
)
=
>
prim
None
=
>
return
}
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
prim
)
;
}
NinePatchBorderSource
:
:
RadialGradient
(
gradient
)
=
>
{
let
prim
=
self
.
create_radial_gradient_prim
(
&
info
gradient
.
center
gradient
.
start_offset
*
gradient
.
radius
.
width
gradient
.
end_offset
*
gradient
.
radius
.
width
gradient
.
radius
.
width
/
gradient
.
radius
.
height
read_gradient_stops
(
gradient_stops
)
gradient
.
extend_mode
LayoutSize
:
:
new
(
border
.
height
as
f32
border
.
width
as
f32
)
LayoutSize
:
:
zero
(
)
Some
(
Box
:
:
new
(
nine_patch
)
)
)
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
prim
)
;
}
NinePatchBorderSource
:
:
ConicGradient
(
gradient
)
=
>
{
let
prim
=
self
.
create_conic_gradient_prim
(
&
info
gradient
.
center
gradient
.
angle
gradient
.
start_offset
gradient
.
end_offset
gradient_stops
gradient
.
extend_mode
LayoutSize
:
:
new
(
border
.
height
as
f32
border
.
width
as
f32
)
LayoutSize
:
:
zero
(
)
Some
(
Box
:
:
new
(
nine_patch
)
)
)
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
prim
)
;
}
}
;
}
BorderDetails
:
:
Normal
(
ref
border
)
=
>
{
self
.
add_normal_border
(
info
border
border_item
.
widths
spatial_node_index
clip_node_id
)
;
}
}
}
pub
fn
create_linear_gradient_prim
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
start_point
:
LayoutPoint
end_point
:
LayoutPoint
stops
:
Vec
<
GradientStopKey
>
extend_mode
:
ExtendMode
stretch_size
:
LayoutSize
mut
tile_spacing
:
LayoutSize
nine_patch
:
Option
<
Box
<
NinePatchDescriptor
>
>
edge_aa_mask
:
EdgeAaSegmentMask
)
-
>
Option
<
LinearGradient
>
{
let
mut
prim_rect
=
info
.
rect
;
simplify_repeated_primitive
(
&
stretch_size
&
mut
tile_spacing
&
mut
prim_rect
)
;
let
mut
has_hard_stops
=
false
;
let
mut
is_entirely_transparent
=
true
;
let
mut
prev_stop
=
None
;
for
stop
in
&
stops
{
if
Some
(
stop
.
offset
)
=
=
prev_stop
{
has_hard_stops
=
true
;
}
prev_stop
=
Some
(
stop
.
offset
)
;
if
stop
.
color
.
a
>
0
{
is_entirely_transparent
=
false
;
}
}
if
is_entirely_transparent
{
return
None
;
}
let
reverse_stops
=
start_point
.
x
>
end_point
.
x
|
|
(
start_point
.
x
=
=
end_point
.
x
&
&
start_point
.
y
>
end_point
.
y
)
;
let
(
sp
ep
)
=
if
reverse_stops
{
(
end_point
start_point
)
}
else
{
(
start_point
end_point
)
}
;
let
max
=
gradient
:
:
LINEAR_MAX_CACHED_SIZE
;
let
caching_causes_artifacts
=
has_hard_stops
&
&
(
stretch_size
.
width
>
max
|
|
stretch_size
.
height
>
max
)
;
let
is_tiled
=
prim_rect
.
width
(
)
>
stretch_size
.
width
|
|
prim_rect
.
height
(
)
>
stretch_size
.
height
;
let
cached
=
(
!
self
.
config
.
is_software
|
|
is_tiled
)
&
&
!
caching_causes_artifacts
;
Some
(
LinearGradient
{
extend_mode
start_point
:
sp
.
into
(
)
end_point
:
ep
.
into
(
)
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
stops
reverse_stops
nine_patch
cached
edge_aa_mask
}
)
}
pub
fn
create_radial_gradient_prim
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
center
:
LayoutPoint
start_radius
:
f32
end_radius
:
f32
ratio_xy
:
f32
stops
:
Vec
<
GradientStopKey
>
extend_mode
:
ExtendMode
stretch_size
:
LayoutSize
mut
tile_spacing
:
LayoutSize
nine_patch
:
Option
<
Box
<
NinePatchDescriptor
>
>
)
-
>
RadialGradient
{
let
mut
prim_rect
=
info
.
rect
;
simplify_repeated_primitive
(
&
stretch_size
&
mut
tile_spacing
&
mut
prim_rect
)
;
let
params
=
RadialGradientParams
{
start_radius
end_radius
ratio_xy
}
;
RadialGradient
{
extend_mode
center
:
center
.
into
(
)
params
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
nine_patch
stops
}
}
pub
fn
create_conic_gradient_prim
(
&
mut
self
info
:
&
LayoutPrimitiveInfo
center
:
LayoutPoint
angle
:
f32
start_offset
:
f32
end_offset
:
f32
stops
:
ItemRange
<
GradientStop
>
extend_mode
:
ExtendMode
stretch_size
:
LayoutSize
mut
tile_spacing
:
LayoutSize
nine_patch
:
Option
<
Box
<
NinePatchDescriptor
>
>
)
-
>
ConicGradient
{
let
mut
prim_rect
=
info
.
rect
;
simplify_repeated_primitive
(
&
stretch_size
&
mut
tile_spacing
&
mut
prim_rect
)
;
let
stops
=
stops
.
iter
(
)
.
map
(
|
stop
|
{
GradientStopKey
{
offset
:
stop
.
offset
color
:
stop
.
color
.
into
(
)
}
}
)
.
collect
(
)
;
ConicGradient
{
extend_mode
center
:
center
.
into
(
)
params
:
ConicGradientParams
{
angle
start_offset
end_offset
}
stretch_size
:
stretch_size
.
into
(
)
tile_spacing
:
tile_spacing
.
into
(
)
nine_patch
stops
}
}
pub
fn
add_text
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
prim_info
:
&
LayoutPrimitiveInfo
font_instance_key
:
&
FontInstanceKey
text_color
:
&
ColorF
glyph_range
:
ItemRange
<
GlyphInstance
>
glyph_options
:
Option
<
GlyphOptions
>
ref_frame_offset
:
LayoutVector2D
)
{
let
offset
=
self
.
current_external_scroll_offset
(
spatial_node_index
)
+
ref_frame_offset
;
let
text_run
=
{
let
shared_key
=
self
.
fonts
.
instance_keys
.
map_key
(
font_instance_key
)
;
let
font_instance
=
match
self
.
fonts
.
instances
.
get_font_instance
(
shared_key
)
{
Some
(
instance
)
=
>
instance
None
=
>
{
warn
!
(
"
Unknown
font
instance
key
"
)
;
debug
!
(
"
key
=
{
:
?
}
shared
=
{
:
?
}
"
font_instance_key
shared_key
)
;
return
;
}
}
;
if
font_instance
.
size
<
=
FontSize
:
:
zero
(
)
{
return
;
}
let
mut
render_mode
=
self
.
config
.
default_font_render_mode
.
limit_by
(
font_instance
.
render_mode
)
;
let
mut
flags
=
font_instance
.
flags
;
if
let
Some
(
options
)
=
glyph_options
{
render_mode
=
render_mode
.
limit_by
(
options
.
render_mode
)
;
flags
|
=
options
.
flags
;
}
let
font
=
FontInstance
:
:
new
(
font_instance
(
*
text_color
)
.
into
(
)
render_mode
flags
)
;
let
prim_offset
=
prim_info
.
rect
.
min
.
to_vector
(
)
-
offset
;
let
glyphs
=
glyph_range
.
iter
(
)
.
map
(
|
glyph
|
{
GlyphInstance
{
index
:
glyph
.
index
point
:
glyph
.
point
-
prim_offset
}
}
)
.
collect
(
)
;
let
requested_raster_space
=
self
.
raster_space_stack
.
last
(
)
.
cloned
(
)
.
unwrap
(
)
;
TextRun
{
glyphs
:
Arc
:
:
new
(
glyphs
)
font
shadow
:
false
requested_raster_space
reference_frame_offset
:
ref_frame_offset
}
}
;
self
.
add_primitive
(
spatial_node_index
clip_node_id
prim_info
Vec
:
:
new
(
)
text_run
)
;
}
pub
fn
add_image
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
stretch_size
:
LayoutSize
mut
tile_spacing
:
LayoutSize
image_key
:
ImageKey
image_rendering
:
ImageRendering
alpha_type
:
AlphaType
color
:
ColorF
)
{
let
mut
prim_rect
=
info
.
rect
;
simplify_repeated_primitive
(
&
stretch_size
&
mut
tile_spacing
&
mut
prim_rect
)
;
let
info
=
LayoutPrimitiveInfo
{
rect
:
prim_rect
.
.
*
info
}
;
self
.
add_primitive
(
spatial_node_index
clip_node_id
&
info
Vec
:
:
new
(
)
Image
{
key
:
image_key
tile_spacing
:
tile_spacing
.
into
(
)
stretch_size
:
stretch_size
.
into
(
)
color
:
color
.
into
(
)
image_rendering
alpha_type
}
)
;
}
pub
fn
add_yuv_image
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
yuv_data
:
YuvData
color_depth
:
ColorDepth
color_space
:
YuvColorSpace
color_range
:
ColorRange
image_rendering
:
ImageRendering
)
{
let
format
=
yuv_data
.
get_format
(
)
;
let
yuv_key
=
match
yuv_data
{
YuvData
:
:
NV12
(
plane_0
plane_1
)
=
>
[
plane_0
plane_1
ImageKey
:
:
DUMMY
]
YuvData
:
:
P010
(
plane_0
plane_1
)
=
>
[
plane_0
plane_1
ImageKey
:
:
DUMMY
]
YuvData
:
:
PlanarYCbCr
(
plane_0
plane_1
plane_2
)
=
>
[
plane_0
plane_1
plane_2
]
YuvData
:
:
InterleavedYCbCr
(
plane_0
)
=
>
[
plane_0
ImageKey
:
:
DUMMY
ImageKey
:
:
DUMMY
]
}
;
self
.
add_nonshadowable_primitive
(
spatial_node_index
clip_node_id
info
Vec
:
:
new
(
)
YuvImage
{
color_depth
yuv_key
format
color_space
color_range
image_rendering
}
)
;
}
fn
add_primitive_instance_to_3d_root
(
&
mut
self
prim
:
ExtendedPrimitiveInstance
)
{
for
sc
in
self
.
sc_stack
.
iter_mut
(
)
.
rev
(
)
{
match
sc
.
context_3d
{
Picture3DContext
:
:
In
{
root_data
:
Some
(
ref
mut
prims
)
.
.
}
=
>
{
prims
.
push
(
prim
)
;
break
;
}
Picture3DContext
:
:
In
{
.
.
}
=
>
{
}
Picture3DContext
:
:
Out
=
>
panic
!
(
"
Unable
to
find
3D
root
"
)
}
}
}
#
[
allow
(
dead_code
)
]
pub
fn
add_backdrop_filter
(
&
mut
self
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
&
LayoutPrimitiveInfo
filters
:
Vec
<
Filter
>
filter_datas
:
Vec
<
FilterData
>
filter_primitives
:
Vec
<
FilterPrimitive
>
)
{
let
filter_spatial_node_index
=
SpatialNodeIndex
:
:
UNKNOWN
;
self
.
make_current_slice_atomic_if_required
(
)
;
let
clip_leaf_id
=
self
.
clip_tree_builder
.
build_for_prim
(
clip_node_id
info
&
[
]
&
mut
self
.
interners
)
;
let
backdrop_capture_instance
=
self
.
create_primitive
(
info
clip_leaf_id
BackdropCapture
{
}
)
;
let
mut
prim_list
=
PrimitiveList
:
:
empty
(
)
;
prim_list
.
add_prim
(
backdrop_capture_instance
info
.
rect
spatial_node_index
info
.
flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
let
mut
source
=
PictureChainBuilder
:
:
from_prim_list
(
prim_list
info
.
flags
filter_spatial_node_index
RasterSpace
:
:
Screen
true
)
;
source
=
self
.
wrap_prim_with_filters
(
source
clip_node_id
filters
filter_primitives
filter_datas
Some
(
false
)
LayoutVector2D
:
:
zero
(
)
)
;
if
source
.
has_picture
(
)
{
source
=
source
.
add_picture
(
PictureCompositeMode
:
:
IntermediateSurface
clip_node_id
Picture3DContext
:
:
Out
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
prim_instances
&
mut
self
.
clip_tree_builder
)
;
let
filtered_instance
=
source
.
finalize
(
clip_node_id
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
clip_tree_builder
)
;
let
output_pic_index
=
match
filtered_instance
.
kind
{
PrimitiveInstanceKind
:
:
Picture
{
pic_index
.
.
}
=
>
pic_index
_
=
>
panic
!
(
"
bug
:
not
a
picture
"
)
}
;
let
sc_index
=
self
.
sc_stack
.
iter
(
)
.
rposition
(
|
sc
|
{
!
sc
.
flags
.
contains
(
StackingContextFlags
:
:
WRAPS_BACKDROP_FILTER
)
}
)
;
match
sc_index
{
Some
(
sc_index
)
=
>
{
self
.
sc_stack
[
sc_index
]
.
prim_list
.
add_prim
(
filtered_instance
info
.
rect
filter_spatial_node_index
info
.
flags
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
None
=
>
{
self
.
tile_cache_builder
.
add_prim
(
filtered_instance
info
.
rect
filter_spatial_node_index
info
.
flags
self
.
spatial_tree
self
.
interners
&
self
.
quality_settings
&
mut
self
.
prim_instances
&
self
.
clip_tree_builder
)
;
}
}
let
mut
backdrop_render_instance
=
self
.
create_primitive
(
info
clip_leaf_id
BackdropRender
{
}
)
;
match
backdrop_render_instance
.
kind
{
PrimitiveInstanceKind
:
:
BackdropRender
{
ref
mut
pic_index
.
.
}
=
>
{
assert_eq
!
(
*
pic_index
PictureIndex
:
:
INVALID
)
;
*
pic_index
=
output_pic_index
;
}
_
=
>
panic
!
(
"
bug
:
unexpected
prim
kind
"
)
}
self
.
add_primitive_to_draw_list
(
backdrop_render_instance
info
.
rect
spatial_node_index
info
.
flags
)
;
}
}
#
[
must_use
]
fn
wrap_prim_with_filters
(
&
mut
self
mut
source
:
PictureChainBuilder
clip_node_id
:
ClipNodeId
mut
filter_ops
:
Vec
<
Filter
>
mut
filter_primitives
:
Vec
<
FilterPrimitive
>
filter_datas
:
Vec
<
FilterData
>
should_inflate_override
:
Option
<
bool
>
context_offset
:
LayoutVector2D
)
-
>
PictureChainBuilder
{
assert
!
(
filter_ops
.
is_empty
(
)
|
|
filter_primitives
.
is_empty
(
)
"
Filter
ops
and
filter
primitives
are
not
allowed
on
the
same
stacking
context
.
"
)
;
let
mut
current_filter_data_index
=
0
;
if
let
Some
(
Filter
:
:
SVGGraphNode
(
.
.
)
)
=
filter_ops
.
first
(
)
{
const
BUFFER_LIMIT
:
usize
=
256
;
const
SVGFE_INFLATE
:
i16
=
1
;
const
SVGFE_INFLATE_OUTPUT
:
i16
=
0
;
let
mut
reference_for_buffer_id
:
[
FilterGraphPictureReference
;
BUFFER_LIMIT
]
=
[
FilterGraphPictureReference
{
buffer_id
:
FilterOpGraphPictureBufferId
:
:
BufferId
(
-
1
)
subregion
:
LayoutRect
:
:
zero
(
)
offset
:
LayoutVector2D
:
:
zero
(
)
inflate
:
0
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
;
BUFFER_LIMIT
]
;
let
mut
filters
:
Vec
<
(
FilterGraphNode
FilterGraphOp
)
>
=
Vec
:
:
new
(
)
;
filters
.
reserve
(
BUFFER_LIMIT
)
;
for
(
original_id
parsefilter
)
in
filter_ops
.
iter
(
)
.
enumerate
(
)
{
match
parsefilter
{
Filter
:
:
SVGGraphNode
(
parsenode
op
)
=
>
{
if
filters
.
len
(
)
>
=
BUFFER_LIMIT
{
return
source
;
}
let
clip_region
=
parsenode
.
subregion
.
translate
(
context_offset
)
;
let
mut
newnode
=
FilterGraphNode
{
kept_by_optimizer
:
false
linear
:
parsenode
.
linear
inflate
:
SVGFE_INFLATE
inputs
:
Vec
:
:
new
(
)
subregion
:
clip_region
}
;
let
mut
remapped_inputs
:
Vec
<
FilterGraphPictureReference
>
=
Vec
:
:
new
(
)
;
remapped_inputs
.
reserve_exact
(
parsenode
.
inputs
.
len
(
)
)
;
for
input
in
&
parsenode
.
inputs
{
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
buffer_id
)
=
>
{
let
pic
=
*
reference_for_buffer_id
.
get
(
buffer_id
as
usize
)
.
expect
(
"
BufferId
not
valid
?
"
)
;
let
offset
=
input
.
offset
;
let
subregion
=
pic
.
subregion
.
translate
(
offset
)
;
let
source_padding
=
LayoutRect
:
:
zero
(
)
.
translate
(
-
offset
)
;
let
target_padding
=
LayoutRect
:
:
zero
(
)
.
translate
(
offset
)
;
remapped_inputs
.
push
(
FilterGraphPictureReference
{
buffer_id
:
pic
.
buffer_id
subregion
offset
inflate
:
pic
.
inflate
source_padding
target_padding
}
)
;
}
FilterOpGraphPictureBufferId
:
:
None
=
>
panic
!
(
"
Unsupported
FilterOpGraphPictureBufferId
"
)
}
}
fn
union_unchecked
(
a
:
LayoutRect
b
:
LayoutRect
)
-
>
LayoutRect
{
let
mut
r
=
a
;
if
r
.
min
.
x
>
b
.
min
.
x
{
r
.
min
.
x
=
b
.
min
.
x
}
if
r
.
min
.
y
>
b
.
min
.
y
{
r
.
min
.
y
=
b
.
min
.
y
}
if
r
.
max
.
x
<
b
.
max
.
x
{
r
.
max
.
x
=
b
.
max
.
x
}
if
r
.
max
.
y
<
b
.
max
.
y
{
r
.
max
.
y
=
b
.
max
.
y
}
r
}
match
op
{
FilterGraphOp
:
:
SVGFEFlood
{
.
.
}
|
FilterGraphOp
:
:
SVGFESourceAlpha
|
FilterGraphOp
:
:
SVGFESourceGraphic
|
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithFractalNoiseWithStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithNoStitching
{
.
.
}
|
FilterGraphOp
:
:
SVGFETurbulenceWithTurbulenceNoiseWithStitching
{
.
.
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
0
)
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEColorMatrix
{
.
.
}
|
FilterGraphOp
:
:
SVGFEIdentity
|
FilterGraphOp
:
:
SVGFEImage
{
.
.
}
|
FilterGraphOp
:
:
SVGFEOpacity
{
.
.
}
|
FilterGraphOp
:
:
SVGFEToAlpha
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEComponentTransfer
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
let
filter_data
=
&
filter_datas
[
current_filter_data_index
]
;
let
filter_data
=
filter_data
.
sanitize
(
)
;
current_filter_data_index
=
current_filter_data_index
+
1
;
let
creates_pixels
=
if
let
Some
(
a
)
=
filter_data
.
r_values
.
get
(
3
)
{
*
a
!
=
0
.
0
}
else
{
false
}
;
let
filter_data_key
=
SFilterDataKey
{
data
:
SFilterData
{
r_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_r_type
&
filter_data
.
r_values
)
g_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_g_type
&
filter_data
.
g_values
)
b_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_b_type
&
filter_data
.
b_values
)
a_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_a_type
&
filter_data
.
a_values
)
}
}
;
let
handle
=
self
.
interners
.
filter_data
.
intern
(
&
filter_data_key
|
|
(
)
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
handle
creates_pixels
}
)
)
;
}
FilterGraphOp
:
:
SVGFEComponentTransferInterned
{
.
.
}
=
>
unreachable
!
(
)
FilterGraphOp
:
:
SVGFETile
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
remapped_inputs
[
0
]
.
source_padding
=
LayoutRect
:
:
max_rect
(
)
;
remapped_inputs
[
0
]
.
target_padding
=
LayoutRect
:
:
max_rect
(
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeDuplicate
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeNone
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEConvolveMatrixEdgeModeWrap
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEMorphologyDilate
{
radius_x
:
kernel_unit_length_x
radius_y
:
kernel_unit_length_y
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
let
padding
=
LayoutSize
:
:
new
(
kernel_unit_length_x
.
ceil
(
)
kernel_unit_length_y
.
ceil
(
)
)
;
remapped_inputs
[
0
]
.
source_padding
=
remapped_inputs
[
0
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
0
]
.
target_padding
=
remapped_inputs
[
0
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEDiffuseLightingDistant
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEDiffuseLightingPoint
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEDiffuseLightingSpot
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFESpecularLightingDistant
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFESpecularLightingPoint
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFESpecularLightingSpot
{
kernel_unit_length_x
kernel_unit_length_y
.
.
}
|
FilterGraphOp
:
:
SVGFEMorphologyErode
{
radius_x
:
kernel_unit_length_x
radius_y
:
kernel_unit_length_y
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
let
padding
=
LayoutSize
:
:
new
(
kernel_unit_length_x
.
ceil
(
)
kernel_unit_length_y
.
ceil
(
)
)
;
remapped_inputs
[
0
]
.
source_padding
=
remapped_inputs
[
0
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
0
]
.
target_padding
=
remapped_inputs
[
0
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEDisplacementMap
{
scale
.
.
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
2
)
;
let
padding
=
LayoutSize
:
:
new
(
scale
.
ceil
(
)
scale
.
ceil
(
)
)
;
remapped_inputs
[
0
]
.
source_padding
=
remapped_inputs
[
0
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
1
]
.
source_padding
=
remapped_inputs
[
1
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
0
]
.
target_padding
=
remapped_inputs
[
0
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
1
]
.
target_padding
=
remapped_inputs
[
1
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEDropShadow
{
dx
dy
std_deviation_x
std_deviation_y
.
.
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
let
padding
=
LayoutSize
:
:
new
(
std_deviation_x
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
std_deviation_y
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
)
;
remapped_inputs
[
0
]
.
source_padding
=
union_unchecked
(
remapped_inputs
[
0
]
.
source_padding
remapped_inputs
[
0
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
.
translate
(
LayoutVector2D
:
:
new
(
-
dx
-
dy
)
)
)
;
remapped_inputs
[
0
]
.
target_padding
=
union_unchecked
(
remapped_inputs
[
0
]
.
target_padding
remapped_inputs
[
0
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
.
translate
(
LayoutVector2D
:
:
new
(
*
dx
*
dy
)
)
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEGaussianBlur
{
std_deviation_x
std_deviation_y
}
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
1
)
;
let
padding
=
LayoutSize
:
:
new
(
std_deviation_x
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
std_deviation_y
.
ceil
(
)
*
BLUR_SAMPLE_SCALE
)
;
remapped_inputs
[
0
]
.
source_padding
=
remapped_inputs
[
0
]
.
source_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
remapped_inputs
[
0
]
.
target_padding
=
remapped_inputs
[
0
]
.
target_padding
.
inflate
(
padding
.
width
padding
.
height
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
FilterGraphOp
:
:
SVGFEBlendColor
|
FilterGraphOp
:
:
SVGFEBlendColorBurn
|
FilterGraphOp
:
:
SVGFEBlendColorDodge
|
FilterGraphOp
:
:
SVGFEBlendDarken
|
FilterGraphOp
:
:
SVGFEBlendDifference
|
FilterGraphOp
:
:
SVGFEBlendExclusion
|
FilterGraphOp
:
:
SVGFEBlendHardLight
|
FilterGraphOp
:
:
SVGFEBlendHue
|
FilterGraphOp
:
:
SVGFEBlendLighten
|
FilterGraphOp
:
:
SVGFEBlendLuminosity
|
FilterGraphOp
:
:
SVGFEBlendMultiply
|
FilterGraphOp
:
:
SVGFEBlendNormal
|
FilterGraphOp
:
:
SVGFEBlendOverlay
|
FilterGraphOp
:
:
SVGFEBlendSaturation
|
FilterGraphOp
:
:
SVGFEBlendScreen
|
FilterGraphOp
:
:
SVGFEBlendSoftLight
|
FilterGraphOp
:
:
SVGFECompositeArithmetic
{
.
.
}
|
FilterGraphOp
:
:
SVGFECompositeATop
|
FilterGraphOp
:
:
SVGFECompositeIn
|
FilterGraphOp
:
:
SVGFECompositeLighter
|
FilterGraphOp
:
:
SVGFECompositeOut
|
FilterGraphOp
:
:
SVGFECompositeOver
|
FilterGraphOp
:
:
SVGFECompositeXOR
=
>
{
assert
!
(
remapped_inputs
.
len
(
)
=
=
2
)
;
newnode
.
inputs
=
remapped_inputs
;
filters
.
push
(
(
newnode
.
clone
(
)
op
.
clone
(
)
)
)
;
}
}
let
id
=
(
filters
.
len
(
)
-
1
)
as
i16
;
if
let
Some
(
pic
)
=
reference_for_buffer_id
.
get_mut
(
original_id
as
usize
)
{
*
pic
=
FilterGraphPictureReference
{
buffer_id
:
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
subregion
:
newnode
.
subregion
offset
:
LayoutVector2D
:
:
zero
(
)
inflate
:
newnode
.
inflate
source_padding
:
LayoutRect
:
:
zero
(
)
target_padding
:
LayoutRect
:
:
zero
(
)
}
;
}
}
_
=
>
{
panic
!
(
"
wrap_prim_with_filters
:
Mixed
SVG
and
CSS
filters
?
"
)
}
}
}
if
filters
.
len
(
)
>
=
BUFFER_LIMIT
{
return
source
;
}
let
mut
outputnode
=
FilterGraphNode
{
kept_by_optimizer
:
true
linear
:
false
inflate
:
SVGFE_INFLATE_OUTPUT
inputs
:
Vec
:
:
new
(
)
subregion
:
LayoutRect
:
:
max_rect
(
)
}
;
outputnode
.
inputs
.
push
(
reference_for_buffer_id
[
filter_ops
.
len
(
)
-
1
]
)
;
filters
.
push
(
(
outputnode
FilterGraphOp
:
:
SVGFEIdentity
)
)
;
let
mut
kept_node_by_buffer_id
=
[
false
;
BUFFER_LIMIT
]
;
kept_node_by_buffer_id
[
filters
.
len
(
)
-
1
]
=
true
;
for
(
index
(
node
_op
)
)
in
filters
.
iter_mut
(
)
.
enumerate
(
)
.
rev
(
)
{
let
mut
keep
=
false
;
if
let
Some
(
k
)
=
kept_node_by_buffer_id
.
get
(
index
)
{
if
*
k
{
keep
=
true
;
}
}
if
keep
{
node
.
kept_by_optimizer
=
true
;
for
input
in
&
node
.
inputs
{
if
let
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
input
.
buffer_id
{
if
let
Some
(
k
)
=
kept_node_by_buffer_id
.
get_mut
(
id
as
usize
)
{
*
k
=
true
;
}
}
}
}
}
let
mut
invalid_dag
=
false
;
for
(
id
(
node
_op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
{
for
input
in
&
node
.
inputs
{
if
let
FilterOpGraphPictureBufferId
:
:
BufferId
(
buffer_id
)
=
input
.
buffer_id
{
if
buffer_id
<
0
|
|
buffer_id
as
usize
>
=
id
{
invalid_dag
=
true
;
}
}
}
}
if
invalid_dag
{
log
!
(
Level
:
:
Warn
"
List
of
FilterOp
:
:
SVGGraphNode
filter
primitives
appears
to
be
invalid
!
"
)
;
for
(
id
(
node
op
)
)
in
filters
.
iter
(
)
.
enumerate
(
)
{
log
!
(
Level
:
:
Warn
"
node
:
buffer
=
BufferId
(
{
}
)
op
=
{
}
inflate
=
{
}
subregion
{
:
?
}
linear
=
{
}
kept
=
{
}
"
id
op
.
kind
(
)
node
.
inflate
node
.
subregion
node
.
linear
node
.
kept_by_optimizer
)
;
for
input
in
&
node
.
inputs
{
log
!
(
Level
:
:
Warn
"
input
:
buffer
=
{
}
inflate
=
{
}
subregion
{
:
?
}
offset
{
:
?
}
target_padding
=
{
:
?
}
source_padding
=
{
:
?
}
"
match
input
.
buffer_id
{
FilterOpGraphPictureBufferId
:
:
BufferId
(
id
)
=
>
format
!
(
"
BufferId
(
{
}
)
"
id
)
FilterOpGraphPictureBufferId
:
:
None
=
>
"
None
"
.
into
(
)
}
input
.
inflate
input
.
subregion
input
.
offset
input
.
target_padding
input
.
source_padding
)
;
}
}
}
if
invalid_dag
{
return
source
;
}
let
composite_mode
=
PictureCompositeMode
:
:
SVGFEGraph
(
filters
)
;
source
=
source
.
add_picture
(
composite_mode
clip_node_id
Picture3DContext
:
:
Out
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
prim_instances
&
mut
self
.
clip_tree_builder
)
;
return
source
;
}
for
filter
in
&
mut
filter_ops
{
let
composite_mode
=
match
filter
{
Filter
:
:
ComponentTransfer
=
>
{
let
filter_data
=
&
filter_datas
[
current_filter_data_index
]
;
let
filter_data
=
filter_data
.
sanitize
(
)
;
current_filter_data_index
=
current_filter_data_index
+
1
;
if
filter_data
.
is_identity
(
)
{
continue
}
else
{
let
filter_data_key
=
SFilterDataKey
{
data
:
SFilterData
{
r_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_r_type
&
filter_data
.
r_values
)
g_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_g_type
&
filter_data
.
g_values
)
b_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_b_type
&
filter_data
.
b_values
)
a_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_a_type
&
filter_data
.
a_values
)
}
}
;
let
handle
=
self
.
interners
.
filter_data
.
intern
(
&
filter_data_key
|
|
(
)
)
;
PictureCompositeMode
:
:
ComponentTransferFilter
(
handle
)
}
}
Filter
:
:
SVGGraphNode
(
_
_
)
=
>
{
panic
!
(
"
SVGGraphNode
encountered
in
regular
CSS
filter
chain
?
"
)
;
}
_
=
>
{
if
filter
.
is_noop
(
)
{
continue
;
}
else
{
let
mut
filter
=
filter
.
clone
(
)
;
if
let
Some
(
should_inflate_override
)
=
should_inflate_override
{
if
let
Filter
:
:
Blur
{
ref
mut
should_inflate
.
.
}
=
filter
{
*
should_inflate
=
should_inflate_override
;
}
}
PictureCompositeMode
:
:
Filter
(
filter
)
}
}
}
;
source
=
source
.
add_picture
(
composite_mode
clip_node_id
Picture3DContext
:
:
Out
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
prim_instances
&
mut
self
.
clip_tree_builder
)
;
}
if
!
filter_primitives
.
is_empty
(
)
{
let
filter_datas
=
filter_datas
.
iter
(
)
.
map
(
|
filter_data
|
filter_data
.
sanitize
(
)
)
.
map
(
|
filter_data
|
{
SFilterData
{
r_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_r_type
&
filter_data
.
r_values
)
g_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_g_type
&
filter_data
.
g_values
)
b_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_b_type
&
filter_data
.
b_values
)
a_func
:
SFilterDataComponent
:
:
from_functype_values
(
filter_data
.
func_a_type
&
filter_data
.
a_values
)
}
}
)
.
collect
(
)
;
for
primitive
in
&
mut
filter_primitives
{
primitive
.
sanitize
(
)
;
}
let
composite_mode
=
PictureCompositeMode
:
:
SvgFilter
(
filter_primitives
filter_datas
)
;
source
=
source
.
add_picture
(
composite_mode
clip_node_id
Picture3DContext
:
:
Out
&
mut
self
.
interners
&
mut
self
.
prim_store
&
mut
self
.
prim_instances
&
mut
self
.
clip_tree_builder
)
;
}
source
}
}
pub
trait
CreateShadow
{
fn
create_shadow
(
&
self
shadow
:
&
Shadow
blur_is_noop
:
bool
current_raster_space
:
RasterSpace
)
-
>
Self
;
}
pub
trait
IsVisible
{
fn
is_visible
(
&
self
)
-
>
bool
;
}
struct
ExtendedPrimitiveInstance
{
instance
:
PrimitiveInstance
spatial_node_index
:
SpatialNodeIndex
flags
:
PrimitiveFlags
}
struct
StackingContextInfo
{
pop_containing_block
:
bool
pop_stacking_context
:
bool
set_tile_cache_barrier
:
bool
}
struct
FlattenedStackingContext
{
prim_list
:
PrimitiveList
prim_flags
:
PrimitiveFlags
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
composite_ops
:
CompositeOps
blit_reason
:
BlitReason
transform_style
:
TransformStyle
context_3d
:
Picture3DContext
<
ExtendedPrimitiveInstance
>
flags
:
StackingContextFlags
raster_space
:
RasterSpace
subregion_offset
:
LayoutVector2D
}
impl
FlattenedStackingContext
{
pub
fn
is_3d
(
&
self
)
-
>
bool
{
self
.
transform_style
=
=
TransformStyle
:
:
Preserve3D
&
&
self
.
composite_ops
.
is_empty
(
)
}
pub
fn
is_redundant
(
context_3d
:
&
Picture3DContext
<
ExtendedPrimitiveInstance
>
composite_ops
:
&
CompositeOps
blit_reason
:
BlitReason
parent
:
Option
<
&
FlattenedStackingContext
>
prim_flags
:
PrimitiveFlags
)
-
>
bool
{
if
let
Picture3DContext
:
:
In
{
.
.
}
=
context_3d
{
return
false
;
}
if
composite_ops
.
has_valid_filters
(
)
{
return
false
;
}
if
composite_ops
.
mix_blend_mode
.
is_some
(
)
{
match
parent
{
Some
(
ref
parent
)
=
>
{
if
!
parent
.
prim_list
.
is_empty
(
)
{
return
false
;
}
}
None
=
>
{
return
false
;
}
}
}
if
!
blit_reason
.
is_empty
(
)
{
return
false
;
}
if
!
prim_flags
.
contains
(
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
)
{
return
false
;
}
true
}
pub
fn
cut_item_sequence
(
&
mut
self
prim_store
:
&
mut
PrimitiveStore
interners
:
&
mut
Interners
composite_mode
:
Option
<
PictureCompositeMode
>
flat_items_context_3d
:
Picture3DContext
<
OrderedPictureChild
>
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
-
>
Option
<
(
PictureIndex
PrimitiveInstance
)
>
{
if
self
.
prim_list
.
is_empty
(
)
{
return
None
}
let
pic_index
=
PictureIndex
(
prim_store
.
pictures
.
alloc
(
)
.
init
(
PicturePrimitive
:
:
new_image
(
composite_mode
.
clone
(
)
flat_items_context_3d
self
.
prim_flags
mem
:
:
replace
(
&
mut
self
.
prim_list
PrimitiveList
:
:
empty
(
)
)
self
.
spatial_node_index
self
.
raster_space
PictureFlags
:
:
empty
(
)
)
)
)
;
let
prim_instance
=
create_prim_instance
(
pic_index
composite_mode
.
into
(
)
self
.
raster_space
self
.
clip_node_id
interners
clip_tree_builder
)
;
Some
(
(
pic_index
prim_instance
)
)
}
}
pub
struct
PendingPrimitive
<
T
>
{
spatial_node_index
:
SpatialNodeIndex
clip_node_id
:
ClipNodeId
info
:
LayoutPrimitiveInfo
prim
:
T
}
pub
struct
PendingShadow
{
shadow
:
Shadow
should_inflate
:
bool
spatial_node_index
:
SpatialNodeIndex
}
pub
enum
ShadowItem
{
Shadow
(
PendingShadow
)
Image
(
PendingPrimitive
<
Image
>
)
LineDecoration
(
PendingPrimitive
<
LineDecoration
>
)
NormalBorder
(
PendingPrimitive
<
NormalBorderPrim
>
)
Primitive
(
PendingPrimitive
<
PrimitiveKeyKind
>
)
TextRun
(
PendingPrimitive
<
TextRun
>
)
}
impl
From
<
PendingPrimitive
<
Image
>
>
for
ShadowItem
{
fn
from
(
image
:
PendingPrimitive
<
Image
>
)
-
>
Self
{
ShadowItem
:
:
Image
(
image
)
}
}
impl
From
<
PendingPrimitive
<
LineDecoration
>
>
for
ShadowItem
{
fn
from
(
line_dec
:
PendingPrimitive
<
LineDecoration
>
)
-
>
Self
{
ShadowItem
:
:
LineDecoration
(
line_dec
)
}
}
impl
From
<
PendingPrimitive
<
NormalBorderPrim
>
>
for
ShadowItem
{
fn
from
(
border
:
PendingPrimitive
<
NormalBorderPrim
>
)
-
>
Self
{
ShadowItem
:
:
NormalBorder
(
border
)
}
}
impl
From
<
PendingPrimitive
<
PrimitiveKeyKind
>
>
for
ShadowItem
{
fn
from
(
container
:
PendingPrimitive
<
PrimitiveKeyKind
>
)
-
>
Self
{
ShadowItem
:
:
Primitive
(
container
)
}
}
impl
From
<
PendingPrimitive
<
TextRun
>
>
for
ShadowItem
{
fn
from
(
text_run
:
PendingPrimitive
<
TextRun
>
)
-
>
Self
{
ShadowItem
:
:
TextRun
(
text_run
)
}
}
fn
create_prim_instance
(
pic_index
:
PictureIndex
composite_mode_key
:
PictureCompositeKey
raster_space
:
RasterSpace
clip_node_id
:
ClipNodeId
interners
:
&
mut
Interners
clip_tree_builder
:
&
mut
ClipTreeBuilder
)
-
>
PrimitiveInstance
{
let
pic_key
=
PictureKey
:
:
new
(
Picture
{
composite_mode_key
raster_space
}
)
;
let
data_handle
=
interners
.
picture
.
intern
(
&
pic_key
|
|
(
)
)
;
PrimitiveInstance
:
:
new
(
PrimitiveInstanceKind
:
:
Picture
{
data_handle
pic_index
}
clip_tree_builder
.
build_for_picture
(
clip_node_id
)
)
}
fn
filter_ops_for_compositing
(
input_filters
:
ItemRange
<
FilterOp
>
)
-
>
Vec
<
Filter
>
{
input_filters
.
iter
(
)
.
map
(
|
filter
|
filter
.
into
(
)
)
.
collect
(
)
}
fn
filter_datas_for_compositing
(
input_filter_datas
:
&
[
TempFilterData
]
)
-
>
Vec
<
FilterData
>
{
let
mut
filter_datas
=
vec
!
[
]
;
for
temp_filter_data
in
input_filter_datas
{
let
func_types
:
Vec
<
ComponentTransferFuncType
>
=
temp_filter_data
.
func_types
.
iter
(
)
.
collect
(
)
;
debug_assert
!
(
func_types
.
len
(
)
=
=
4
)
;
filter_datas
.
push
(
FilterData
{
func_r_type
:
func_types
[
0
]
r_values
:
temp_filter_data
.
r_values
.
iter
(
)
.
collect
(
)
func_g_type
:
func_types
[
1
]
g_values
:
temp_filter_data
.
g_values
.
iter
(
)
.
collect
(
)
func_b_type
:
func_types
[
2
]
b_values
:
temp_filter_data
.
b_values
.
iter
(
)
.
collect
(
)
func_a_type
:
func_types
[
3
]
a_values
:
temp_filter_data
.
a_values
.
iter
(
)
.
collect
(
)
}
)
;
}
filter_datas
}
fn
filter_primitives_for_compositing
(
input_filter_primitives
:
ItemRange
<
FilterPrimitive
>
)
-
>
Vec
<
FilterPrimitive
>
{
input_filter_primitives
.
iter
(
)
.
map
(
|
primitive
|
primitive
)
.
collect
(
)
}
fn
process_repeat_size
(
snapped_rect
:
&
LayoutRect
unsnapped_rect
:
&
LayoutRect
repeat_size
:
LayoutSize
)
-
>
LayoutSize
{
const
EPSILON
:
f32
=
0
.
001
;
LayoutSize
:
:
new
(
if
repeat_size
.
width
.
approx_eq_eps
(
&
unsnapped_rect
.
width
(
)
&
EPSILON
)
{
snapped_rect
.
width
(
)
}
else
{
repeat_size
.
width
}
if
repeat_size
.
height
.
approx_eq_eps
(
&
unsnapped_rect
.
height
(
)
&
EPSILON
)
{
snapped_rect
.
height
(
)
}
else
{
repeat_size
.
height
}
)
}
fn
read_gradient_stops
(
stops
:
ItemRange
<
GradientStop
>
)
-
>
Vec
<
GradientStopKey
>
{
stops
.
iter
(
)
.
map
(
|
stop
|
{
GradientStopKey
{
offset
:
stop
.
offset
color
:
stop
.
color
.
into
(
)
}
}
)
.
collect
(
)
}
