use
api
:
:
{
TileOffset
TileRange
LayoutRect
LayoutSize
LayoutPoint
}
;
use
api
:
:
{
DeviceIntSize
DeviceIntRect
TileSize
}
;
use
euclid
:
:
{
point2
size2
}
;
use
prim_store
:
:
EdgeAaSegmentMask
;
use
std
:
:
i32
;
use
std
:
:
ops
:
:
Range
;
pub
fn
simplify_repeated_primitive
(
stretch_size
:
&
LayoutSize
tile_spacing
:
&
mut
LayoutSize
prim_rect
:
&
mut
LayoutRect
)
{
let
stride
=
*
stretch_size
+
*
tile_spacing
;
if
stride
.
width
>
=
prim_rect
.
size
.
width
{
tile_spacing
.
width
=
0
.
0
;
prim_rect
.
size
.
width
=
f32
:
:
min
(
prim_rect
.
size
.
width
stretch_size
.
width
)
;
}
if
stride
.
height
>
=
prim_rect
.
size
.
height
{
tile_spacing
.
height
=
0
.
0
;
prim_rect
.
size
.
height
=
f32
:
:
min
(
prim_rect
.
size
.
height
stretch_size
.
height
)
;
}
}
pub
struct
Repetition
{
pub
origin
:
LayoutPoint
pub
edge_flags
:
EdgeAaSegmentMask
}
pub
struct
RepetitionIterator
{
current_x
:
i32
x_count
:
i32
current_y
:
i32
y_count
:
i32
row_flags
:
EdgeAaSegmentMask
current_origin
:
LayoutPoint
initial_origin
:
LayoutPoint
stride
:
LayoutSize
}
impl
Iterator
for
RepetitionIterator
{
type
Item
=
Repetition
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
current_x
=
=
self
.
x_count
{
self
.
current_y
+
=
1
;
if
self
.
current_y
>
=
self
.
y_count
{
return
None
;
}
self
.
current_x
=
0
;
self
.
row_flags
=
EdgeAaSegmentMask
:
:
empty
(
)
;
if
self
.
current_y
=
=
self
.
y_count
-
1
{
self
.
row_flags
|
=
EdgeAaSegmentMask
:
:
BOTTOM
;
}
self
.
current_origin
.
x
=
self
.
initial_origin
.
x
;
self
.
current_origin
.
y
+
=
self
.
stride
.
height
;
}
let
mut
edge_flags
=
self
.
row_flags
;
if
self
.
current_x
=
=
0
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
LEFT
;
}
if
self
.
current_x
=
=
self
.
x_count
-
1
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
RIGHT
;
}
let
repetition
=
Repetition
{
origin
:
self
.
current_origin
edge_flags
:
edge_flags
}
;
self
.
current_origin
.
x
+
=
self
.
stride
.
width
;
self
.
current_x
+
=
1
;
Some
(
repetition
)
}
}
pub
fn
repetitions
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
stride
:
LayoutSize
)
-
>
RepetitionIterator
{
assert
!
(
stride
.
width
>
0
.
0
)
;
assert
!
(
stride
.
height
>
0
.
0
)
;
let
visible_rect
=
match
prim_rect
.
intersection
(
&
visible_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
{
return
RepetitionIterator
{
current_origin
:
LayoutPoint
:
:
zero
(
)
initial_origin
:
LayoutPoint
:
:
zero
(
)
current_x
:
0
current_y
:
0
x_count
:
0
y_count
:
0
stride
row_flags
:
EdgeAaSegmentMask
:
:
empty
(
)
}
}
}
;
let
nx
=
if
visible_rect
.
origin
.
x
>
prim_rect
.
origin
.
x
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
x
-
prim_rect
.
origin
.
x
)
/
stride
.
width
)
}
else
{
0
.
0
}
;
let
ny
=
if
visible_rect
.
origin
.
y
>
prim_rect
.
origin
.
y
{
f32
:
:
floor
(
(
visible_rect
.
origin
.
y
-
prim_rect
.
origin
.
y
)
/
stride
.
height
)
}
else
{
0
.
0
}
;
let
x0
=
prim_rect
.
origin
.
x
+
nx
*
stride
.
width
;
let
y0
=
prim_rect
.
origin
.
y
+
ny
*
stride
.
height
;
let
x_most
=
visible_rect
.
max_x
(
)
;
let
y_most
=
visible_rect
.
max_y
(
)
;
let
x_count
=
f32
:
:
ceil
(
(
x_most
-
x0
)
/
stride
.
width
)
as
i32
;
let
y_count
=
f32
:
:
ceil
(
(
y_most
-
y0
)
/
stride
.
height
)
as
i32
;
let
mut
row_flags
=
EdgeAaSegmentMask
:
:
TOP
;
if
y_count
=
=
1
{
row_flags
|
=
EdgeAaSegmentMask
:
:
BOTTOM
;
}
RepetitionIterator
{
current_origin
:
LayoutPoint
:
:
new
(
x0
y0
)
initial_origin
:
LayoutPoint
:
:
new
(
x0
y0
)
current_x
:
0
current_y
:
0
x_count
y_count
row_flags
stride
}
}
#
[
derive
(
Debug
)
]
pub
struct
Tile
{
pub
rect
:
LayoutRect
pub
offset
:
TileOffset
pub
edge_flags
:
EdgeAaSegmentMask
}
#
[
derive
(
Debug
)
]
pub
struct
TileIteratorExtent
{
tile_range
:
Range
<
i32
>
first_tile_layout_size
:
f32
last_tile_layout_size
:
f32
}
#
[
derive
(
Debug
)
]
pub
struct
TileIterator
{
current_tile
:
TileOffset
x
:
TileIteratorExtent
y
:
TileIteratorExtent
regular_tile_size
:
LayoutSize
local_origin
:
LayoutPoint
}
impl
Iterator
for
TileIterator
{
type
Item
=
Tile
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
current_tile
.
x
>
=
self
.
x
.
tile_range
.
end
{
self
.
current_tile
.
y
+
=
1
;
if
self
.
current_tile
.
y
>
=
self
.
y
.
tile_range
.
end
{
return
None
;
}
self
.
current_tile
.
x
=
self
.
x
.
tile_range
.
start
;
}
let
tile_offset
=
self
.
current_tile
;
let
mut
segment_rect
=
LayoutRect
{
origin
:
LayoutPoint
:
:
new
(
self
.
local_origin
.
x
+
tile_offset
.
x
as
f32
*
self
.
regular_tile_size
.
width
self
.
local_origin
.
y
+
tile_offset
.
y
as
f32
*
self
.
regular_tile_size
.
height
)
size
:
self
.
regular_tile_size
}
;
let
mut
edge_flags
=
EdgeAaSegmentMask
:
:
empty
(
)
;
if
tile_offset
.
x
=
=
self
.
x
.
tile_range
.
start
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
LEFT
;
segment_rect
.
size
.
width
=
self
.
x
.
first_tile_layout_size
;
segment_rect
.
origin
.
x
+
=
self
.
regular_tile_size
.
width
-
self
.
x
.
first_tile_layout_size
;
}
if
tile_offset
.
x
=
=
self
.
x
.
tile_range
.
end
-
1
{
edge_flags
|
=
EdgeAaSegmentMask
:
:
RIGHT
;
segment_rect
.
size
.
width
=
self
.
x
.
last_tile_layout_size
;
}
if
tile_offset
.
y
=
=
self
.
y
.
tile_range
.
start
{
segment_rect
.
size
.
height
=
self
.
y
.
first_tile_layout_size
;
segment_rect
.
origin
.
y
+
=
self
.
regular_tile_size
.
height
-
self
.
y
.
first_tile_layout_size
;
edge_flags
|
=
EdgeAaSegmentMask
:
:
TOP
;
}
if
tile_offset
.
y
=
=
self
.
y
.
tile_range
.
end
-
1
{
segment_rect
.
size
.
height
=
self
.
y
.
last_tile_layout_size
;
edge_flags
|
=
EdgeAaSegmentMask
:
:
BOTTOM
;
}
assert
!
(
tile_offset
.
y
<
self
.
y
.
tile_range
.
end
)
;
let
tile
=
Tile
{
rect
:
segment_rect
offset
:
tile_offset
edge_flags
}
;
self
.
current_tile
.
x
+
=
1
;
Some
(
tile
)
}
}
pub
fn
tiles
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
device_image_size
:
&
DeviceIntSize
device_tile_size
:
i32
)
-
>
TileIterator
{
let
visible_rect
=
match
prim_rect
.
intersection
(
&
visible_rect
)
{
Some
(
rect
)
=
>
rect
None
=
>
{
return
TileIterator
{
current_tile
:
TileOffset
:
:
zero
(
)
x
:
TileIteratorExtent
{
tile_range
:
0
.
.
0
first_tile_layout_size
:
0
.
0
last_tile_layout_size
:
0
.
0
}
y
:
TileIteratorExtent
{
tile_range
:
0
.
.
0
first_tile_layout_size
:
0
.
0
last_tile_layout_size
:
0
.
0
}
regular_tile_size
:
LayoutSize
:
:
zero
(
)
local_origin
:
LayoutPoint
:
:
zero
(
)
}
}
}
;
let
layout_tiling_origin
=
prim_rect
.
origin
;
let
device_image_range_x
=
0
.
.
device_image_size
.
width
;
let
device_image_range_y
=
0
.
.
device_image_size
.
height
;
let
x_device_tile_size
=
i32
:
:
min
(
device_tile_size
device_image_size
.
width
)
;
let
y_device_tile_size
=
i32
:
:
min
(
device_tile_size
device_image_size
.
height
)
;
let
layout_tile_size
=
LayoutSize
:
:
new
(
x_device_tile_size
as
f32
/
device_image_size
.
width
as
f32
*
prim_rect
.
size
.
width
y_device_tile_size
as
f32
/
device_image_size
.
height
as
f32
*
prim_rect
.
size
.
height
)
;
let
x_extent
=
tiles_1d
(
layout_tile_size
.
width
visible_rect
.
min_x
(
)
.
.
visible_rect
.
max_x
(
)
device_image_range_x
x_device_tile_size
layout_tiling_origin
.
x
)
;
let
y_extent
=
tiles_1d
(
layout_tile_size
.
height
visible_rect
.
min_y
(
)
.
.
visible_rect
.
max_y
(
)
device_image_range_y
y_device_tile_size
layout_tiling_origin
.
y
)
;
TileIterator
{
current_tile
:
point2
(
x_extent
.
tile_range
.
start
y_extent
.
tile_range
.
start
)
x
:
x_extent
y
:
y_extent
regular_tile_size
:
layout_tile_size
local_origin
:
prim_rect
.
origin
}
}
fn
tiles_1d
(
layout_tile_size
:
f32
layout_visible_range
:
Range
<
f32
>
device_image_range
:
Range
<
i32
>
device_tile_size
:
i32
layout_tiling_origin
:
f32
)
-
>
TileIteratorExtent
{
debug_assert
!
(
layout_tile_size
>
0
.
0
)
;
debug_assert
!
(
layout_visible_range
.
end
>
=
layout_visible_range
.
start
)
;
debug_assert
!
(
device_image_range
.
end
>
device_image_range
.
start
)
;
debug_assert
!
(
device_tile_size
>
0
)
;
let
first_tile_device_size
=
first_tile_size_1d
(
&
device_image_range
device_tile_size
)
;
let
last_tile_device_size
=
last_tile_size_1d
(
&
device_image_range
device_tile_size
)
;
let
image_tiles
=
tile_range_1d
(
&
device_image_range
device_tile_size
)
;
let
visible_tiles_start
=
f32
:
:
floor
(
(
layout_visible_range
.
start
-
layout_tiling_origin
)
/
layout_tile_size
)
as
i32
;
let
visible_tiles_end
=
f32
:
:
ceil
(
(
layout_visible_range
.
end
-
layout_tiling_origin
)
/
layout_tile_size
)
as
i32
;
let
tiles_start
=
i32
:
:
max
(
image_tiles
.
start
visible_tiles_start
)
;
let
tiles_end
=
i32
:
:
min
(
image_tiles
.
end
visible_tiles_end
)
;
let
first_tile_layout_size
=
if
tiles_start
=
=
image_tiles
.
start
{
first_tile_device_size
as
f32
*
layout_tile_size
/
device_tile_size
as
f32
}
else
{
layout_tile_size
}
;
let
last_tile_layout_size
=
if
tiles_end
=
=
image_tiles
.
end
{
last_tile_device_size
as
f32
*
layout_tile_size
/
device_tile_size
as
f32
}
else
{
layout_tile_size
}
;
TileIteratorExtent
{
tile_range
:
tiles_start
.
.
tiles_end
first_tile_layout_size
last_tile_layout_size
}
}
fn
tile_range_1d
(
image_range
:
&
Range
<
i32
>
regular_tile_size
:
i32
)
-
>
Range
<
i32
>
{
let
mut
start
=
image_range
.
start
/
regular_tile_size
;
if
image_range
.
start
%
regular_tile_size
<
0
{
start
-
=
1
;
}
let
mut
end
=
image_range
.
end
/
regular_tile_size
;
if
image_range
.
end
%
regular_tile_size
>
0
{
end
+
=
1
;
}
start
.
.
end
}
fn
first_tile_size_1d
(
image_range
:
&
Range
<
i32
>
regular_tile_size
:
i32
)
-
>
i32
{
let
image_size
=
image_range
.
end
-
image_range
.
start
;
i32
:
:
min
(
match
image_range
.
start
%
regular_tile_size
{
0
=
>
regular_tile_size
m
if
m
>
0
=
>
regular_tile_size
-
m
m
=
>
-
m
}
image_size
)
}
fn
last_tile_size_1d
(
image_range
:
&
Range
<
i32
>
regular_tile_size
:
i32
)
-
>
i32
{
let
image_size
=
image_range
.
end
-
image_range
.
start
;
i32
:
:
min
(
match
image_range
.
end
%
regular_tile_size
{
0
=
>
regular_tile_size
m
if
m
<
0
=
>
regular_tile_size
+
m
m
=
>
m
}
image_size
)
}
pub
fn
compute_tile_size
(
image_rect
:
&
DeviceIntRect
regular_tile_size
:
TileSize
tile
:
TileOffset
)
-
>
DeviceIntSize
{
let
regular_tile_size
=
regular_tile_size
as
i32
;
size2
(
compute_tile_size_1d
(
image_rect
.
min_x
(
)
.
.
image_rect
.
max_x
(
)
regular_tile_size
tile
.
x
as
i32
)
compute_tile_size_1d
(
image_rect
.
min_y
(
)
.
.
image_rect
.
max_y
(
)
regular_tile_size
tile
.
y
as
i32
)
)
}
fn
compute_tile_size_1d
(
img_range
:
Range
<
i32
>
regular_tile_size
:
i32
tile_offset
:
i32
)
-
>
i32
{
let
tile_range
=
tile_range_1d
(
&
img_range
regular_tile_size
)
;
let
actual_size
=
if
tile_offset
=
=
tile_range
.
start
{
first_tile_size_1d
(
&
img_range
regular_tile_size
)
}
else
if
tile_offset
=
=
tile_range
.
end
-
1
{
last_tile_size_1d
(
&
img_range
regular_tile_size
)
}
else
{
regular_tile_size
}
;
assert
!
(
actual_size
>
0
)
;
actual_size
}
pub
fn
compute_tile_range
(
visible_area
:
&
DeviceIntRect
tile_size
:
u16
)
-
>
TileRange
{
let
tw
=
1
.
/
(
tile_size
as
f32
)
;
let
th
=
1
.
/
(
tile_size
as
f32
)
;
let
t0
=
point2
(
f32
:
:
floor
(
visible_area
.
origin
.
x
as
f32
*
tw
)
f32
:
:
floor
(
visible_area
.
origin
.
y
as
f32
*
th
)
)
.
try_cast
:
:
<
i32
>
(
)
.
unwrap_or_else
(
|
|
panic
!
(
"
compute_tile_range
bad
values
{
:
?
}
{
:
?
}
"
visible_area
tile_size
)
)
;
let
t1
=
point2
(
f32
:
:
ceil
(
visible_area
.
max_x
(
)
as
f32
*
tw
)
f32
:
:
ceil
(
visible_area
.
max_y
(
)
as
f32
*
th
)
)
.
try_cast
:
:
<
i32
>
(
)
.
unwrap_or_else
(
|
|
panic
!
(
"
compute_tile_range
bad
values
{
:
?
}
{
:
?
}
"
visible_area
tile_size
)
)
;
TileRange
{
origin
:
t0
size
:
(
t1
-
t0
)
.
to_size
(
)
}
}
pub
fn
for_each_tile_in_range
(
range
:
&
TileRange
mut
callback
:
impl
FnMut
(
TileOffset
)
)
{
for
y
in
range
.
min_y
(
)
.
.
range
.
max_y
(
)
{
for
x
in
range
.
min_x
(
)
.
.
range
.
max_x
(
)
{
callback
(
point2
(
x
y
)
)
;
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
use
std
:
:
collections
:
:
HashSet
;
use
api
:
:
{
LayoutRect
DeviceIntSize
}
;
use
euclid
:
:
{
rect
size2
}
;
fn
checked_for_each_tile
(
prim_rect
:
&
LayoutRect
visible_rect
:
&
LayoutRect
device_image_size
:
&
DeviceIntSize
device_tile_size
:
i32
callback
:
&
mut
FnMut
(
&
LayoutRect
TileOffset
EdgeAaSegmentMask
)
)
{
let
mut
coverage
=
LayoutRect
:
:
zero
(
)
;
let
mut
seen_tiles
=
HashSet
:
:
new
(
)
;
for
tile
in
tiles
(
prim_rect
visible_rect
device_image_size
device_tile_size
)
{
assert
!
(
!
seen_tiles
.
contains
(
&
tile
.
offset
)
)
;
seen_tiles
.
insert
(
tile
.
offset
)
;
coverage
=
coverage
.
union
(
&
tile
.
rect
)
;
assert
!
(
prim_rect
.
contains_rect
(
&
tile
.
rect
)
)
;
callback
(
&
tile
.
rect
tile
.
offset
tile
.
edge_flags
)
;
}
assert
!
(
prim_rect
.
contains_rect
(
&
coverage
)
)
;
assert
!
(
coverage
.
contains_rect
(
&
visible_rect
.
intersection
(
&
prim_rect
)
.
unwrap_or
(
LayoutRect
:
:
zero
(
)
)
)
)
;
}
#
[
test
]
fn
basic
(
)
{
let
mut
count
=
0
;
checked_for_each_tile
(
&
rect
(
0
.
0
.
1000
.
1000
.
)
&
rect
(
75
.
75
.
400
.
400
.
)
&
size2
(
400
400
)
36
&
mut
|
_tile_rect
_tile_offset
_tile_flags
|
{
count
+
=
1
;
}
)
;
assert_eq
!
(
count
36
)
;
}
#
[
test
]
fn
empty
(
)
{
let
mut
count
=
0
;
checked_for_each_tile
(
&
rect
(
0
.
0
.
74
.
74
.
)
&
rect
(
75
.
75
.
400
.
400
.
)
&
size2
(
400
400
)
36
&
mut
|
_tile_rect
_tile_offset
_tile_flags
|
{
count
+
=
1
;
}
)
;
assert_eq
!
(
count
0
)
;
}
#
[
test
]
fn
test_tiles_1d
(
)
{
let
result
=
tiles_1d
(
64
.
0
-
10000
.
0
.
.
10000
.
0
0
.
.
64
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
0
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
64
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
64
.
0
-
10000
.
0
.
.
10000
.
0
-
64
.
.
0
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
-
1
)
;
assert_eq
!
(
result
.
tile_range
.
end
0
)
;
assert_eq
!
(
result
.
first_tile_layout_size
64
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
64
.
0
-
10000
.
0
.
.
10000
.
0
-
64
.
.
64
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
-
1
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
64
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
64
.
0
-
100
.
0
.
.
10
.
0
64
.
.
310
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
result
.
tile_range
.
end
)
;
let
result
=
tiles_1d
(
64
.
0
10
.
0
.
.
10000
.
0
-
64
.
.
64
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
0
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
64
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
64
.
0
-
10000
.
0
.
.
-
10
.
0
-
64
.
.
64
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
-
1
)
;
assert_eq
!
(
result
.
tile_range
.
end
0
)
;
assert_eq
!
(
result
.
first_tile_layout_size
64
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
128
.
0
-
10000
.
0
.
.
10000
.
0
-
64
.
.
32
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
-
1
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
128
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
64
.
0
)
;
let
result
=
tiles_1d
(
10
.
0
0
.
0
.
.
20
.
0
0
.
.
64
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
0
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
10
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
10
.
0
)
;
let
result
=
tiles_1d
(
10
.
0
-
20
.
0
.
.
0
.
0
0
.
.
64
64
-
20
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
0
)
;
assert_eq
!
(
result
.
tile_range
.
end
1
)
;
assert_eq
!
(
result
.
first_tile_layout_size
10
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
10
.
0
)
;
}
#
[
test
]
fn
test_tile_range_1d
(
)
{
assert_eq
!
(
tile_range_1d
(
&
(
0
.
.
256
)
256
)
0
.
.
1
)
;
assert_eq
!
(
tile_range_1d
(
&
(
0
.
.
257
)
256
)
0
.
.
2
)
;
assert_eq
!
(
tile_range_1d
(
&
(
-
1
.
.
257
)
256
)
-
1
.
.
2
)
;
assert_eq
!
(
tile_range_1d
(
&
(
-
256
.
.
256
)
256
)
-
1
.
.
1
)
;
assert_eq
!
(
tile_range_1d
(
&
(
-
20
.
.
-
10
)
6
)
-
4
.
.
-
1
)
;
}
#
[
test
]
fn
test_first_last_tile_size_1d
(
)
{
assert_eq
!
(
first_tile_size_1d
(
&
(
0
.
.
10
)
64
)
10
)
;
assert_eq
!
(
first_tile_size_1d
(
&
(
-
20
.
.
0
)
64
)
20
)
;
assert_eq
!
(
last_tile_size_1d
(
&
(
0
.
.
10
)
64
)
10
)
;
assert_eq
!
(
last_tile_size_1d
(
&
(
-
20
.
.
0
)
64
)
20
)
;
}
#
[
test
]
fn
doubly_partial_tiles
(
)
{
assert_eq
!
(
first_tile_size_1d
(
&
(
300
.
.
310
)
64
)
10
)
;
assert_eq
!
(
first_tile_size_1d
(
&
(
-
20
.
.
-
10
)
64
)
10
)
;
assert_eq
!
(
last_tile_size_1d
(
&
(
300
.
.
310
)
64
)
10
)
;
assert_eq
!
(
last_tile_size_1d
(
&
(
-
20
.
.
-
10
)
64
)
10
)
;
let
result
=
tiles_1d
(
64
.
0
-
10000
.
0
.
.
10000
.
0
300
.
.
310
64
0
.
0
)
;
assert_eq
!
(
result
.
tile_range
.
start
4
)
;
assert_eq
!
(
result
.
tile_range
.
end
5
)
;
assert_eq
!
(
result
.
first_tile_layout_size
10
.
0
)
;
assert_eq
!
(
result
.
last_tile_layout_size
10
.
0
)
;
}
}
