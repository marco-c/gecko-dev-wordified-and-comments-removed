extern
crate
app_units
;
extern
crate
euclid
;
use
std
:
:
hash
:
:
{
BuildHasher
Hash
}
;
use
std
:
:
mem
:
:
size_of
;
use
std
:
:
ops
:
:
Range
;
use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
path
:
:
PathBuf
;
type
VoidPtrToSizeFn
=
unsafe
extern
"
C
"
fn
(
ptr
:
*
const
c_void
)
-
>
usize
;
pub
struct
MallocSizeOfOps
{
pub
size_of_op
:
VoidPtrToSizeFn
pub
enclosing_size_of_op
:
Option
<
VoidPtrToSizeFn
>
}
impl
MallocSizeOfOps
{
pub
fn
new
(
size_of
:
VoidPtrToSizeFn
malloc_enclosing_size_of
:
Option
<
VoidPtrToSizeFn
>
)
-
>
Self
{
MallocSizeOfOps
{
size_of_op
:
size_of
enclosing_size_of_op
:
malloc_enclosing_size_of
}
}
fn
is_empty
<
T
:
?
Sized
>
(
ptr
:
*
const
T
)
-
>
bool
{
ptr
as
*
const
usize
as
usize
<
=
256
}
pub
unsafe
fn
malloc_size_of
<
T
:
?
Sized
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
if
MallocSizeOfOps
:
:
is_empty
(
ptr
)
{
0
}
else
{
(
self
.
size_of_op
)
(
ptr
as
*
const
c_void
)
}
}
pub
fn
has_malloc_enclosing_size_of
(
&
self
)
-
>
bool
{
self
.
enclosing_size_of_op
.
is_some
(
)
}
pub
unsafe
fn
malloc_enclosing_size_of
<
T
>
(
&
self
ptr
:
*
const
T
)
-
>
usize
{
assert
!
(
!
MallocSizeOfOps
:
:
is_empty
(
ptr
)
)
;
(
self
.
enclosing_size_of_op
.
unwrap
(
)
)
(
ptr
as
*
const
c_void
)
}
}
pub
trait
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
pub
trait
MallocShallowSizeOf
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
;
}
impl
MallocSizeOf
for
String
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
}
impl
<
T
:
?
Sized
>
MallocShallowSizeOf
for
Box
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
&
*
*
self
)
}
}
}
impl
<
T
:
MallocSizeOf
+
?
Sized
>
MallocSizeOf
for
Box
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
shallow_size_of
(
ops
)
+
(
*
*
self
)
.
size_of
(
ops
)
}
}
impl
MallocSizeOf
for
(
)
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
impl
<
T1
T2
>
MallocSizeOf
for
(
T1
T2
)
where
T1
:
MallocSizeOf
T2
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
+
self
.
1
.
size_of
(
ops
)
}
}
impl
<
T1
T2
T3
>
MallocSizeOf
for
(
T1
T2
T3
)
where
T1
:
MallocSizeOf
T2
:
MallocSizeOf
T3
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
+
self
.
1
.
size_of
(
ops
)
+
self
.
2
.
size_of
(
ops
)
}
}
impl
<
T1
T2
T3
T4
>
MallocSizeOf
for
(
T1
T2
T3
T4
)
where
T1
:
MallocSizeOf
T2
:
MallocSizeOf
T3
:
MallocSizeOf
T4
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
+
self
.
1
.
size_of
(
ops
)
+
self
.
2
.
size_of
(
ops
)
+
self
.
3
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Option
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
let
Some
(
val
)
=
self
.
as_ref
(
)
{
val
.
size_of
(
ops
)
}
else
{
0
}
}
}
impl
<
T
:
MallocSizeOf
E
:
MallocSizeOf
>
MallocSizeOf
for
Result
<
T
E
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
match
*
self
{
Ok
(
ref
x
)
=
>
x
.
size_of
(
ops
)
Err
(
ref
e
)
=
>
e
.
size_of
(
ops
)
}
}
}
impl
<
T
:
MallocSizeOf
+
Copy
>
MallocSizeOf
for
std
:
:
cell
:
:
Cell
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
get
(
)
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
std
:
:
cell
:
:
RefCell
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
borrow
(
)
.
size_of
(
ops
)
}
}
impl
<
'
a
B
:
?
Sized
+
ToOwned
>
MallocSizeOf
for
std
:
:
borrow
:
:
Cow
<
'
a
B
>
where
B
:
:
Owned
:
MallocSizeOf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
match
*
self
{
std
:
:
borrow
:
:
Cow
:
:
Borrowed
(
_
)
=
>
0
std
:
:
borrow
:
:
Cow
:
:
Owned
(
ref
b
)
=
>
b
.
size_of
(
ops
)
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
[
T
]
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
0
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
impl
<
T
>
MallocShallowSizeOf
for
Vec
<
T
>
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
unsafe
{
ops
.
malloc_size_of
(
self
.
as_ptr
(
)
)
}
}
}
impl
<
T
:
MallocSizeOf
>
MallocSizeOf
for
Vec
<
T
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
elem
in
self
.
iter
(
)
{
n
+
=
elem
.
size_of
(
ops
)
;
}
n
}
}
macro_rules
!
malloc_size_of_hash_set
{
(
ty
:
ty
)
=
>
{
impl
<
T
S
>
MallocShallowSizeOf
for
ty
where
T
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
if
ops
.
has_malloc_enclosing_size_of
(
)
{
/
/
The
first
value
from
the
iterator
gives
us
an
interior
pointer
.
/
/
ops
.
malloc_enclosing_size_of
(
)
then
gives
us
the
storage
size
.
/
/
This
assumes
that
the
HashSet
'
s
contents
(
values
and
hashes
)
/
/
are
all
stored
in
a
single
contiguous
heap
allocation
.
self
.
iter
(
)
.
next
(
)
.
map_or
(
0
|
t
|
unsafe
{
ops
.
malloc_enclosing_size_of
(
t
)
}
)
}
else
{
/
/
An
estimate
.
self
.
capacity
(
)
*
(
size_of
:
:
<
T
>
(
)
+
size_of
:
:
<
usize
>
(
)
)
}
}
}
impl
<
T
S
>
MallocSizeOf
for
ty
where
T
:
Eq
+
Hash
+
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
t
in
self
.
iter
(
)
{
n
+
=
t
.
size_of
(
ops
)
;
}
n
}
}
}
;
}
malloc_size_of_hash_set
!
(
std
:
:
collections
:
:
HashSet
<
T
S
>
)
;
macro_rules
!
malloc_size_of_hash_map
{
(
ty
:
ty
)
=
>
{
impl
<
K
V
S
>
MallocShallowSizeOf
for
ty
where
K
:
Eq
+
Hash
S
:
BuildHasher
{
fn
shallow_size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
/
/
See
the
implementation
for
std
:
:
collections
:
:
HashSet
for
details
.
if
ops
.
has_malloc_enclosing_size_of
(
)
{
self
.
values
(
)
.
next
(
)
.
map_or
(
0
|
v
|
unsafe
{
ops
.
malloc_enclosing_size_of
(
v
)
}
)
}
else
{
self
.
capacity
(
)
*
(
size_of
:
:
<
V
>
(
)
+
size_of
:
:
<
K
>
(
)
+
size_of
:
:
<
usize
>
(
)
)
}
}
}
impl
<
K
V
S
>
MallocSizeOf
for
ty
where
K
:
Eq
+
Hash
+
MallocSizeOf
V
:
MallocSizeOf
S
:
BuildHasher
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
let
mut
n
=
self
.
shallow_size_of
(
ops
)
;
for
(
k
v
)
in
self
.
iter
(
)
{
n
+
=
k
.
size_of
(
ops
)
;
n
+
=
v
.
size_of
(
ops
)
;
}
n
}
}
}
;
}
malloc_size_of_hash_map
!
(
std
:
:
collections
:
:
HashMap
<
K
V
S
>
)
;
impl
<
T
>
MallocSizeOf
for
std
:
:
marker
:
:
PhantomData
<
T
>
{
fn
size_of
(
&
self
_ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
0
}
}
impl
MallocSizeOf
for
PathBuf
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
match
self
.
to_str
(
)
{
Some
(
s
)
=
>
unsafe
{
ops
.
malloc_size_of
(
s
.
as_ptr
(
)
)
}
None
=
>
self
.
as_os_str
(
)
.
len
(
)
}
}
}
impl
<
T
:
MallocSizeOf
Unit
>
MallocSizeOf
for
euclid
:
:
Length
<
T
Unit
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
Src
Dst
>
MallocSizeOf
for
euclid
:
:
Scale
<
T
Src
Dst
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
0
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
Point2D
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
x
.
size_of
(
ops
)
+
self
.
y
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
Rect
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
origin
.
size_of
(
ops
)
+
self
.
size
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
SideOffsets2D
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
top
.
size_of
(
ops
)
+
self
.
right
.
size_of
(
ops
)
+
self
.
bottom
.
size_of
(
ops
)
+
self
.
left
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
Size2D
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
width
.
size_of
(
ops
)
+
self
.
height
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
Src
Dst
>
MallocSizeOf
for
euclid
:
:
Transform2D
<
T
Src
Dst
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
m11
.
size_of
(
ops
)
+
self
.
m12
.
size_of
(
ops
)
+
self
.
m21
.
size_of
(
ops
)
+
self
.
m22
.
size_of
(
ops
)
+
self
.
m31
.
size_of
(
ops
)
+
self
.
m32
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
Src
Dst
>
MallocSizeOf
for
euclid
:
:
Transform3D
<
T
Src
Dst
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
m11
.
size_of
(
ops
)
+
self
.
m12
.
size_of
(
ops
)
+
self
.
m13
.
size_of
(
ops
)
+
self
.
m14
.
size_of
(
ops
)
+
self
.
m21
.
size_of
(
ops
)
+
self
.
m22
.
size_of
(
ops
)
+
self
.
m23
.
size_of
(
ops
)
+
self
.
m24
.
size_of
(
ops
)
+
self
.
m31
.
size_of
(
ops
)
+
self
.
m32
.
size_of
(
ops
)
+
self
.
m33
.
size_of
(
ops
)
+
self
.
m34
.
size_of
(
ops
)
+
self
.
m41
.
size_of
(
ops
)
+
self
.
m42
.
size_of
(
ops
)
+
self
.
m43
.
size_of
(
ops
)
+
self
.
m44
.
size_of
(
ops
)
}
}
impl
<
T
:
MallocSizeOf
U
>
MallocSizeOf
for
euclid
:
:
Vector2D
<
T
U
>
{
fn
size_of
(
&
self
ops
:
&
mut
MallocSizeOfOps
)
-
>
usize
{
self
.
x
.
size_of
(
ops
)
+
self
.
y
.
size_of
(
ops
)
}
}
#
[
macro_export
]
macro_rules
!
malloc_size_of_is_0
(
(
(
ty
:
ty
)
+
)
=
>
(
(
impl
crate
:
:
MallocSizeOf
for
ty
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
(
(
ty
:
ident
<
(
gen
:
ident
)
+
>
)
+
)
=
>
(
(
impl
<
(
gen
:
crate
:
:
MallocSizeOf
)
+
>
crate
:
:
MallocSizeOf
for
ty
<
(
gen
)
+
>
{
#
[
inline
(
always
)
]
fn
size_of
(
&
self
_
:
&
mut
crate
:
:
MallocSizeOfOps
)
-
>
usize
{
0
}
}
)
+
)
;
)
;
malloc_size_of_is_0
!
(
bool
char
str
)
;
malloc_size_of_is_0
!
(
u8
u16
u32
u64
u128
usize
)
;
malloc_size_of_is_0
!
(
i8
i16
i32
i64
i128
isize
)
;
malloc_size_of_is_0
!
(
f32
f64
)
;
malloc_size_of_is_0
!
(
std
:
:
sync
:
:
atomic
:
:
AtomicBool
)
;
malloc_size_of_is_0
!
(
std
:
:
sync
:
:
atomic
:
:
AtomicIsize
)
;
malloc_size_of_is_0
!
(
std
:
:
sync
:
:
atomic
:
:
AtomicUsize
)
;
malloc_size_of_is_0
!
(
std
:
:
num
:
:
NonZeroUsize
)
;
malloc_size_of_is_0
!
(
std
:
:
num
:
:
NonZeroU32
)
;
malloc_size_of_is_0
!
(
std
:
:
time
:
:
Duration
)
;
malloc_size_of_is_0
!
(
std
:
:
time
:
:
Instant
)
;
malloc_size_of_is_0
!
(
std
:
:
time
:
:
SystemTime
)
;
malloc_size_of_is_0
!
(
Range
<
u8
>
Range
<
u16
>
Range
<
u32
>
Range
<
u64
>
Range
<
usize
>
)
;
malloc_size_of_is_0
!
(
Range
<
i8
>
Range
<
i16
>
Range
<
i32
>
Range
<
i64
>
Range
<
isize
>
)
;
malloc_size_of_is_0
!
(
Range
<
f32
>
Range
<
f64
>
)
;
malloc_size_of_is_0
!
(
app_units
:
:
Au
)
;
