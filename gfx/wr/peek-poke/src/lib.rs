#
[
cfg
(
feature
=
"
derive
"
)
]
pub
use
peek_poke_derive
:
:
*
;
use
core
:
:
{
marker
:
:
PhantomData
mem
:
:
size_of
slice
}
;
use
crate
:
:
{
slice_ext
:
:
*
vec_ext
:
:
*
}
;
mod
slice_ext
;
mod
vec_ext
;
union
MaybeUninitShim
<
T
:
Copy
>
{
uninit
:
(
)
init
:
T
}
pub
unsafe
fn
peek_from_uninit
<
T
:
Copy
+
Peek
>
(
bytes
:
*
const
u8
)
-
>
(
T
*
const
u8
)
{
let
mut
val
=
MaybeUninitShim
{
uninit
:
(
)
}
;
let
bytes
=
<
T
>
:
:
peek_from
(
bytes
&
mut
val
.
init
)
;
(
val
.
init
bytes
)
}
pub
unsafe
fn
peek_from_default
<
T
:
Default
+
Peek
>
(
bytes
:
*
const
u8
)
-
>
(
T
*
const
u8
)
{
let
mut
val
=
T
:
:
default
(
)
;
let
bytes
=
<
T
>
:
:
peek_from
(
bytes
&
mut
val
)
;
(
val
bytes
)
}
pub
fn
peek_from_slice
<
'
a
T
:
Peek
>
(
src
:
&
'
a
[
u8
]
dst
:
&
mut
T
)
-
>
&
'
a
[
u8
]
{
unsafe
{
assert
!
(
T
:
:
max_size
(
)
<
src
.
len
(
)
"
WRDL
:
unexpected
end
of
display
list
"
)
;
let
end_ptr
=
T
:
:
peek_from
(
src
.
as_ptr
(
)
dst
)
;
let
len
=
end_ptr
as
usize
-
src
.
as_ptr
(
)
as
usize
;
assert
!
(
len
<
=
src
.
len
(
)
"
WRDL
:
Peek
:
:
max_size
was
wrong
"
)
;
slice
:
:
from_raw_parts
(
end_ptr
src
.
len
(
)
-
len
)
}
}
pub
fn
poke_inplace_slice
<
T
:
Poke
>
(
src
:
&
T
dst
:
&
mut
[
u8
]
)
{
assert
!
(
T
:
:
max_size
(
)
<
=
dst
.
len
(
)
"
WRDL
:
buffer
too
small
to
write
into
"
)
;
unsafe
{
src
.
poke_into
(
dst
.
as_mut_ptr
(
)
)
;
}
}
pub
fn
poke_into_vec
<
T
:
Poke
>
(
src
:
&
T
dst
:
&
mut
Vec
<
u8
>
)
{
dst
.
reserve
(
T
:
:
max_size
(
)
)
;
unsafe
{
let
ptr
=
dst
.
as_end_mut_ptr
(
)
;
let
end_ptr
=
src
.
poke_into
(
ptr
)
;
dst
.
set_end_ptr
(
end_ptr
)
;
}
}
pub
fn
poke_extend_vec
<
I
>
(
src
:
I
dst
:
&
mut
Vec
<
u8
>
)
-
>
usize
where
I
:
ExactSizeIterator
I
:
:
Item
:
Poke
{
let
len
=
src
.
len
(
)
;
let
max_size
=
len
*
I
:
:
Item
:
:
max_size
(
)
;
dst
.
reserve
(
max_size
)
;
unsafe
{
let
ptr
=
dst
.
as_end_mut_ptr
(
)
;
let
end_ptr
=
src
.
take
(
len
)
.
fold
(
ptr
|
ptr
item
|
item
.
poke_into
(
ptr
)
)
;
dst
.
set_end_ptr
(
end_ptr
)
;
}
len
}
pub
fn
ensure_red_zone
<
T
:
Poke
>
(
bytes
:
&
mut
Vec
<
u8
>
)
{
bytes
.
reserve
(
T
:
:
max_size
(
)
)
;
unsafe
{
let
end_ptr
=
bytes
.
as_end_mut_ptr
(
)
;
end_ptr
.
write_bytes
(
0
T
:
:
max_size
(
)
)
;
bytes
.
set_end_ptr
(
end_ptr
.
add
(
T
:
:
max_size
(
)
)
)
;
}
}
pub
fn
strip_red_zone
<
T
:
Poke
>
(
bytes
:
&
mut
Vec
<
u8
>
)
{
assert
!
(
bytes
.
len
(
)
>
=
T
:
:
max_size
(
)
)
;
unsafe
{
let
end_ptr
=
bytes
.
as_end_mut_ptr
(
)
;
bytes
.
set_end_ptr
(
end_ptr
.
sub
(
T
:
:
max_size
(
)
)
)
;
}
}
#
[
inline
]
unsafe
fn
read_verbatim
<
T
>
(
src
:
*
const
u8
dst
:
*
mut
T
)
-
>
*
const
u8
{
*
dst
=
(
src
as
*
const
T
)
.
read_unaligned
(
)
;
src
.
add
(
size_of
:
:
<
T
>
(
)
)
}
#
[
inline
]
unsafe
fn
write_verbatim
<
T
>
(
src
:
T
dst
:
*
mut
u8
)
-
>
*
mut
u8
{
(
dst
as
*
mut
T
)
.
write_unaligned
(
src
)
;
dst
.
add
(
size_of
:
:
<
T
>
(
)
)
}
#
[
cfg
(
feature
=
"
extras
"
)
]
mod
euclid
;
pub
unsafe
trait
Poke
{
fn
max_size
(
)
-
>
usize
;
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
;
}
pub
trait
Peek
:
Poke
{
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
;
}
macro_rules
!
impl_poke_for_deref
{
(
<
(
desc
:
tt
)
+
)
=
>
{
unsafe
impl
<
(
desc
)
+
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
<
T
>
:
:
max_size
(
)
}
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
(
*
*
self
)
.
poke_into
(
bytes
)
}
}
}
}
impl_poke_for_deref
!
(
<
'
a
T
:
Poke
>
Poke
for
&
'
a
T
)
;
impl_poke_for_deref
!
(
<
'
a
T
:
Poke
>
Poke
for
&
'
a
mut
T
)
;
macro_rules
!
impl_for_primitive
{
(
(
ty
:
ty
)
+
)
=
>
{
(
unsafe
impl
Poke
for
ty
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
size_of
:
:
<
Self
>
(
)
}
#
[
inline
(
always
)
]
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
write_verbatim
(
*
self
bytes
)
}
}
impl
Peek
for
ty
{
#
[
inline
(
always
)
]
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
read_verbatim
(
bytes
output
)
}
}
)
+
}
;
}
impl_for_primitive
!
{
i8
i16
i32
i64
isize
u8
u16
u32
u64
usize
f32
f64
}
unsafe
impl
Poke
for
bool
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
u8
:
:
max_size
(
)
}
#
[
inline
]
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
(
*
self
as
u8
)
.
poke_into
(
bytes
)
}
}
impl
Peek
for
bool
{
#
[
inline
]
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
let
mut
int_bool
=
0u8
;
let
ptr
=
<
u8
>
:
:
peek_from
(
bytes
&
mut
int_bool
)
;
*
output
=
int_bool
!
=
0
;
ptr
}
}
unsafe
impl
<
T
>
Poke
for
PhantomData
<
T
>
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
0
}
#
[
inline
(
always
)
]
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
bytes
}
}
impl
<
T
>
Peek
for
PhantomData
<
T
>
{
#
[
inline
(
always
)
]
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
*
output
=
PhantomData
;
bytes
}
}
unsafe
impl
<
T
:
Poke
>
Poke
for
Option
<
T
>
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
u8
:
:
max_size
(
)
+
T
:
:
max_size
(
)
}
#
[
inline
]
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
match
self
{
None
=
>
0u8
.
poke_into
(
bytes
)
Some
(
ref
v
)
=
>
{
let
bytes
=
1u8
.
poke_into
(
bytes
)
;
let
bytes
=
v
.
poke_into
(
bytes
)
;
bytes
}
}
}
}
impl
<
T
:
Default
+
Peek
>
Peek
for
Option
<
T
>
{
#
[
inline
]
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
let
(
variant
bytes
)
=
peek_from_default
:
:
<
u8
>
(
bytes
)
;
match
variant
{
0
=
>
{
*
output
=
None
;
bytes
}
1
=
>
{
let
(
val
bytes
)
=
peek_from_default
(
bytes
)
;
*
output
=
Some
(
val
)
;
bytes
}
_
=
>
unreachable
!
(
)
}
}
}
macro_rules
!
impl_for_arrays
{
(
(
len
:
tt
)
+
)
=
>
{
(
unsafe
impl
<
T
:
Poke
>
Poke
for
[
T
;
len
]
{
fn
max_size
(
)
-
>
usize
{
len
*
T
:
:
max_size
(
)
}
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
self
.
iter
(
)
.
fold
(
bytes
|
bytes
e
|
e
.
poke_into
(
bytes
)
)
}
}
impl
<
T
:
Peek
>
Peek
for
[
T
;
len
]
{
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
(
&
mut
*
output
)
.
iter_mut
(
)
.
fold
(
bytes
|
bytes
e
|
<
T
>
:
:
peek_from
(
bytes
e
)
)
}
}
)
+
}
}
impl_for_arrays
!
{
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
}
unsafe
impl
Poke
for
(
)
{
fn
max_size
(
)
-
>
usize
{
0
}
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
bytes
}
}
impl
Peek
for
(
)
{
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
*
output
=
(
)
;
bytes
}
}
macro_rules
!
impl_for_tuple
{
(
(
n
:
tt
:
ty
:
ident
)
+
)
=
>
{
unsafe
impl
<
(
ty
:
Poke
)
+
>
Poke
for
(
(
ty
)
+
)
{
#
[
inline
(
always
)
]
fn
max_size
(
)
-
>
usize
{
0
(
+
<
ty
>
:
:
max_size
(
)
)
+
}
unsafe
fn
poke_into
(
&
self
bytes
:
*
mut
u8
)
-
>
*
mut
u8
{
(
let
bytes
=
self
.
n
.
poke_into
(
bytes
)
;
)
+
bytes
}
}
impl
<
(
ty
:
Peek
)
+
>
Peek
for
(
(
ty
)
+
)
{
unsafe
fn
peek_from
(
bytes
:
*
const
u8
output
:
*
mut
Self
)
-
>
*
const
u8
{
(
let
bytes
=
ty
:
:
peek_from
(
bytes
&
mut
(
*
output
)
.
n
)
;
)
+
bytes
}
}
}
}
impl_for_tuple
!
(
0
:
A
)
;
impl_for_tuple
!
(
0
:
A
1
:
B
)
;
impl_for_tuple
!
(
0
:
A
1
:
B
2
:
C
)
;
impl_for_tuple
!
(
0
:
A
1
:
B
2
:
C
3
:
D
)
;
impl_for_tuple
!
(
0
:
A
1
:
B
2
:
C
3
:
D
4
:
E
)
;
