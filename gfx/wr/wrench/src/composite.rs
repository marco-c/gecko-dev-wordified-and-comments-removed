use
std
:
:
os
:
:
raw
:
:
c_void
;
use
std
:
:
ptr
;
use
glutin
:
:
platform
:
:
windows
:
:
EGLContext
;
use
webrender
:
:
{
CompositorInputConfig
CompositorSurfaceTransform
LayerCompositor
}
;
use
winit
:
:
platform
:
:
windows
:
:
WindowExtWindows
;
use
crate
:
:
WindowWrapper
;
use
mozangle
:
:
egl
:
:
ffi
:
:
types
:
:
{
EGLDisplay
EGLSurface
EGLint
}
;
use
mozangle
:
:
egl
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
Debug
)
]
pub
struct
CompositorHandle
(
usize
)
;
#
[
repr
(
C
)
]
#
[
derive
(
Copy
Clone
PartialEq
Debug
)
]
struct
LayerId
(
usize
)
;
impl
LayerId
{
const
INVALID
:
LayerId
=
LayerId
(
0
)
;
}
#
[
link
(
name
=
"
wr_composite
"
kind
=
"
static
"
)
]
extern
"
C
"
{
fn
wrc_new
(
d3d11_device
:
*
const
c_void
hwnd
:
*
const
c_void
)
-
>
CompositorHandle
;
fn
wrc_delete
(
compositor
:
CompositorHandle
)
;
fn
wrc_create_layer
(
compositor
:
CompositorHandle
width
:
i32
height
:
i32
is_opaque
:
bool
)
-
>
LayerId
;
fn
wrc_get_layer_backbuffer
(
layer_id
:
LayerId
)
-
>
*
mut
c_void
;
fn
wrc_set_layer_position
(
layer_id
:
LayerId
x
:
f32
y
:
f32
)
;
fn
wrc_present_layer
(
layer_id
:
LayerId
)
;
fn
wrc_add_layer
(
compositor
:
CompositorHandle
layer_id
:
LayerId
)
;
fn
wrc_begin_frame
(
compositor
:
CompositorHandle
)
;
fn
wrc_end_frame
(
compositor
:
CompositorHandle
)
;
}
struct
WrLayer
{
width
:
i32
height
:
i32
surface
:
EGLSurface
layer_id
:
LayerId
}
impl
WrLayer
{
fn
empty
(
)
-
>
Self
{
WrLayer
{
width
:
0
height
:
0
layer_id
:
LayerId
:
:
INVALID
surface
:
ptr
:
:
null
(
)
}
}
}
pub
struct
WrCompositor
{
context
:
EGLContext
display
:
EGLDisplay
compositor
:
CompositorHandle
layers
:
Vec
<
WrLayer
>
}
impl
WrCompositor
{
pub
fn
new
(
window
:
&
WindowWrapper
)
-
>
Self
{
let
d3d11_device
=
window
.
get_d3d11_device
(
)
;
let
(
hwnd
display
context
)
=
match
window
{
WindowWrapper
:
:
Angle
(
window
angle
_
_
)
=
>
{
(
window
.
hwnd
(
)
angle
.
get_display
(
)
angle
.
get_context
(
)
)
}
_
=
>
unreachable
!
(
)
}
;
let
compositor
=
unsafe
{
wrc_new
(
d3d11_device
hwnd
)
}
;
WrCompositor
{
display
context
compositor
layers
:
Vec
:
:
new
(
)
}
}
}
impl
Drop
for
WrCompositor
{
fn
drop
(
&
mut
self
)
{
unsafe
{
wrc_delete
(
self
.
compositor
)
;
}
}
}
impl
LayerCompositor
for
WrCompositor
{
fn
begin_frame
(
&
mut
self
input
:
&
CompositorInputConfig
)
-
>
bool
{
unsafe
{
wrc_begin_frame
(
self
.
compositor
)
;
}
let
prev_layer_count
=
self
.
layers
.
len
(
)
;
let
curr_layer_count
=
input
.
layers
.
len
(
)
;
if
prev_layer_count
>
curr_layer_count
{
todo
!
(
)
;
}
else
if
curr_layer_count
>
prev_layer_count
{
for
_
in
0
.
.
curr_layer_count
-
prev_layer_count
{
self
.
layers
.
push
(
WrLayer
:
:
empty
(
)
)
;
}
}
assert_eq
!
(
self
.
layers
.
len
(
)
input
.
layers
.
len
(
)
)
;
for
(
input
layer
)
in
input
.
layers
.
iter
(
)
.
zip
(
self
.
layers
.
iter_mut
(
)
)
{
let
input_size
=
input
.
clip_rect
.
size
(
)
;
if
input_size
.
width
!
=
layer
.
width
|
|
input_size
.
height
!
=
layer
.
height
{
assert_eq
!
(
layer
.
layer_id
LayerId
:
:
INVALID
)
;
layer
.
width
=
input_size
.
width
;
layer
.
height
=
input_size
.
height
;
layer
.
layer_id
=
unsafe
{
wrc_create_layer
(
self
.
compositor
layer
.
width
layer
.
height
input
.
is_opaque
)
}
;
let
pbuffer_attribs
:
[
EGLint
;
5
]
=
[
egl
:
:
ffi
:
:
WIDTH
as
EGLint
layer
.
width
egl
:
:
ffi
:
:
HEIGHT
as
EGLint
layer
.
height
egl
:
:
ffi
:
:
NONE
as
EGLint
]
;
let
attribs
:
[
EGLint
;
18
]
=
[
egl
:
:
ffi
:
:
SURFACE_TYPE
as
EGLint
egl
:
:
ffi
:
:
WINDOW_BIT
as
EGLint
egl
:
:
ffi
:
:
RED_SIZE
as
EGLint
8
egl
:
:
ffi
:
:
GREEN_SIZE
as
EGLint
8
egl
:
:
ffi
:
:
BLUE_SIZE
as
EGLint
8
egl
:
:
ffi
:
:
ALPHA_SIZE
as
EGLint
8
egl
:
:
ffi
:
:
RENDERABLE_TYPE
as
EGLint
egl
:
:
ffi
:
:
OPENGL_ES2_BIT
as
EGLint
egl
:
:
ffi
:
:
DEPTH_SIZE
as
EGLint
24
egl
:
:
ffi
:
:
STENCIL_SIZE
as
EGLint
8
egl
:
:
ffi
:
:
NONE
as
EGLint
egl
:
:
ffi
:
:
NONE
as
EGLint
]
;
let
back_buffer
=
unsafe
{
wrc_get_layer_backbuffer
(
layer
.
layer_id
)
}
;
let
mut
egl_config
=
ptr
:
:
null
(
)
;
let
mut
cfg_count
=
0
;
let
ok
=
unsafe
{
egl
:
:
ffi
:
:
ChooseConfig
(
self
.
display
attribs
.
as_ptr
(
)
&
mut
egl_config
1
&
mut
cfg_count
)
}
;
assert_ne
!
(
ok
0
)
;
assert_eq
!
(
cfg_count
1
)
;
assert_ne
!
(
egl_config
ptr
:
:
null
(
)
)
;
let
surface
=
unsafe
{
egl
:
:
ffi
:
:
CreatePbufferFromClientBuffer
(
self
.
display
egl
:
:
ffi
:
:
D3D_TEXTURE_ANGLE
back_buffer
egl_config
pbuffer_attribs
.
as_ptr
(
)
)
}
;
assert_ne
!
(
surface
ptr
:
:
null
(
)
)
;
layer
.
surface
=
surface
;
}
unsafe
{
wrc_set_layer_position
(
layer
.
layer_id
input
.
offset
.
x
as
f32
input
.
offset
.
y
as
f32
)
;
}
}
true
}
fn
bind_layer
(
&
mut
self
index
:
usize
_dirty_rects
:
&
[
crate
:
:
DeviceIntRect
]
)
{
let
layer
=
&
self
.
layers
[
index
]
;
let
ok
=
unsafe
{
egl
:
:
ffi
:
:
MakeCurrent
(
self
.
display
layer
.
surface
layer
.
surface
self
.
context
)
}
;
assert
!
(
ok
!
=
0
)
;
}
fn
present_layer
(
&
mut
self
index
:
usize
_dirty_rects
:
&
[
crate
:
:
DeviceIntRect
]
)
{
let
layer
=
&
self
.
layers
[
index
]
;
unsafe
{
wrc_present_layer
(
layer
.
layer_id
)
;
}
}
fn
add_surface
(
&
mut
self
index
:
usize
_transform
:
CompositorSurfaceTransform
_clip_rect
:
webrender
:
:
api
:
:
units
:
:
DeviceIntRect
_image_rendering
:
webrender
:
:
api
:
:
ImageRendering
_rounded_clip_rect
:
webrender
:
:
api
:
:
units
:
:
DeviceIntRect
_rounded_clip_radii
:
webrender
:
:
ClipRadius
)
{
let
layer
=
&
self
.
layers
[
index
]
;
unsafe
{
wrc_add_layer
(
self
.
compositor
layer
.
layer_id
)
;
}
}
fn
end_frame
(
&
mut
self
)
{
unsafe
{
wrc_end_frame
(
self
.
compositor
)
;
}
}
fn
get_window_properties
(
&
self
)
-
>
webrender
:
:
WindowProperties
{
webrender
:
:
WindowProperties
{
is_opaque
:
true
enable_screenshot
:
false
}
}
}
