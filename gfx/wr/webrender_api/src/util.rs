use
euclid
:
:
{
Point2D
Box2D
Size2D
Vector2D
}
;
use
euclid
:
:
{
default
Transform3D
}
;
const
NEARLY_ZERO
:
f32
=
1
.
0
/
4096
.
0
;
#
[
derive
(
Debug
Clone
Copy
MallocSizeOf
)
]
#
[
derive
(
Serialize
Deserialize
)
]
pub
struct
ScaleOffset
{
pub
scale
:
default
:
:
Vector2D
<
f32
>
pub
offset
:
default
:
:
Vector2D
<
f32
>
}
impl
ScaleOffset
{
pub
fn
identity
(
)
-
>
Self
{
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
1
.
0
1
.
0
)
offset
:
Vector2D
:
:
zero
(
)
}
}
pub
fn
from_transform
<
F
T
>
(
m
:
&
Transform3D
<
f32
F
T
>
)
-
>
Option
<
ScaleOffset
>
{
if
m
.
m12
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m13
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m14
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m21
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m23
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m24
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m31
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m32
.
abs
(
)
>
NEARLY_ZERO
|
|
(
m
.
m33
-
1
.
0
)
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m34
.
abs
(
)
>
NEARLY_ZERO
|
|
m
.
m43
.
abs
(
)
>
NEARLY_ZERO
|
|
(
m
.
m44
-
1
.
0
)
.
abs
(
)
>
NEARLY_ZERO
{
return
None
;
}
Some
(
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
m
.
m11
m
.
m22
)
offset
:
Vector2D
:
:
new
(
m
.
m41
m
.
m42
)
}
)
}
pub
fn
from_offset
(
offset
:
default
:
:
Vector2D
<
f32
>
)
-
>
Self
{
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
1
.
0
1
.
0
)
offset
}
}
pub
fn
from_scale
(
scale
:
default
:
:
Vector2D
<
f32
>
)
-
>
Self
{
ScaleOffset
{
scale
offset
:
Vector2D
:
:
new
(
0
.
0
0
.
0
)
}
}
pub
fn
inverse
(
&
self
)
-
>
Self
{
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
1
.
0
/
self
.
scale
.
x
1
.
0
/
self
.
scale
.
y
)
offset
:
Vector2D
:
:
new
(
-
self
.
offset
.
x
/
self
.
scale
.
x
-
self
.
offset
.
y
/
self
.
scale
.
y
)
}
}
pub
fn
offset
(
&
self
offset
:
default
:
:
Vector2D
<
f32
>
)
-
>
Self
{
self
.
accumulate
(
&
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
1
.
0
1
.
0
)
offset
}
)
}
pub
fn
scale
(
&
self
scale
:
f32
)
-
>
Self
{
self
.
accumulate
(
&
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
scale
scale
)
offset
:
Vector2D
:
:
zero
(
)
}
)
}
pub
fn
accumulate
(
&
self
other
:
&
ScaleOffset
)
-
>
Self
{
ScaleOffset
{
scale
:
Vector2D
:
:
new
(
self
.
scale
.
x
*
other
.
scale
.
x
self
.
scale
.
y
*
other
.
scale
.
y
)
offset
:
Vector2D
:
:
new
(
self
.
offset
.
x
+
self
.
scale
.
x
*
other
.
offset
.
x
self
.
offset
.
y
+
self
.
scale
.
y
*
other
.
offset
.
y
)
}
}
pub
fn
map_rect
<
F
T
>
(
&
self
rect
:
&
Box2D
<
f32
F
>
)
-
>
Box2D
<
f32
T
>
{
let
w
=
rect
.
width
(
)
.
max
(
0
.
0
)
;
let
h
=
rect
.
height
(
)
.
max
(
0
.
0
)
;
let
mut
x0
=
rect
.
min
.
x
*
self
.
scale
.
x
+
self
.
offset
.
x
;
let
mut
y0
=
rect
.
min
.
y
*
self
.
scale
.
y
+
self
.
offset
.
y
;
let
mut
sx
=
w
*
self
.
scale
.
x
;
let
mut
sy
=
h
*
self
.
scale
.
y
;
if
self
.
scale
.
x
<
0
.
0
{
x0
+
=
sx
;
sx
=
-
sx
;
}
if
self
.
scale
.
y
<
0
.
0
{
y0
+
=
sy
;
sy
=
-
sy
;
}
Box2D
:
:
from_origin_and_size
(
Point2D
:
:
new
(
x0
y0
)
Size2D
:
:
new
(
sx
sy
)
)
}
pub
fn
unmap_rect
<
F
T
>
(
&
self
rect
:
&
Box2D
<
f32
F
>
)
-
>
Box2D
<
f32
T
>
{
let
w
=
rect
.
width
(
)
.
max
(
0
.
0
)
;
let
h
=
rect
.
height
(
)
.
max
(
0
.
0
)
;
let
mut
x0
=
(
rect
.
min
.
x
-
self
.
offset
.
x
)
/
self
.
scale
.
x
;
let
mut
y0
=
(
rect
.
min
.
y
-
self
.
offset
.
y
)
/
self
.
scale
.
y
;
let
mut
sx
=
w
/
self
.
scale
.
x
;
let
mut
sy
=
h
/
self
.
scale
.
y
;
if
self
.
scale
.
x
<
0
.
0
{
x0
+
=
sx
;
sx
=
-
sx
;
}
if
self
.
scale
.
y
<
0
.
0
{
y0
+
=
sy
;
sy
=
-
sy
;
}
Box2D
:
:
from_origin_and_size
(
Point2D
:
:
new
(
x0
y0
)
Size2D
:
:
new
(
sx
sy
)
)
}
pub
fn
map_vector
<
F
T
>
(
&
self
vector
:
&
Vector2D
<
f32
F
>
)
-
>
Vector2D
<
f32
T
>
{
Vector2D
:
:
new
(
vector
.
x
*
self
.
scale
.
x
vector
.
y
*
self
.
scale
.
y
)
}
pub
fn
unmap_vector
<
F
T
>
(
&
self
vector
:
&
Vector2D
<
f32
F
>
)
-
>
Vector2D
<
f32
T
>
{
Vector2D
:
:
new
(
vector
.
x
/
self
.
scale
.
x
vector
.
y
/
self
.
scale
.
y
)
}
pub
fn
map_point
<
F
T
>
(
&
self
point
:
&
Point2D
<
f32
F
>
)
-
>
Point2D
<
f32
T
>
{
Point2D
:
:
new
(
point
.
x
*
self
.
scale
.
x
+
self
.
offset
.
x
point
.
y
*
self
.
scale
.
y
+
self
.
offset
.
y
)
}
pub
fn
unmap_point
<
F
T
>
(
&
self
point
:
&
Point2D
<
f32
F
>
)
-
>
Point2D
<
f32
T
>
{
Point2D
:
:
new
(
(
point
.
x
-
self
.
offset
.
x
)
/
self
.
scale
.
x
(
point
.
y
-
self
.
offset
.
y
)
/
self
.
scale
.
y
)
}
pub
fn
to_transform
<
F
T
>
(
&
self
)
-
>
Transform3D
<
f32
F
T
>
{
Transform3D
:
:
new
(
self
.
scale
.
x
0
.
0
0
.
0
0
.
0
0
.
0
self
.
scale
.
y
0
.
0
0
.
0
0
.
0
0
.
0
1
.
0
0
.
0
self
.
offset
.
x
self
.
offset
.
y
0
.
0
1
.
0
)
}
}
pub
trait
RectHelpers
<
U
>
where
Self
:
Sized
{
fn
snap
(
&
self
)
-
>
Self
;
}
impl
<
U
>
RectHelpers
<
U
>
for
Box2D
<
f32
U
>
{
fn
snap
(
&
self
)
-
>
Self
{
self
.
round
(
)
}
}
