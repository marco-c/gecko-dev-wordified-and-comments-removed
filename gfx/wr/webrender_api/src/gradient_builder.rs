use
crate
:
:
display_item
as
di
;
use
crate
:
:
units
:
:
*
;
pub
struct
GradientBuilder
{
stops
:
Vec
<
di
:
:
GradientStop
>
}
impl
GradientBuilder
{
pub
fn
new
(
)
-
>
Self
{
GradientBuilder
{
stops
:
Vec
:
:
new
(
)
}
}
pub
fn
with_stops
(
stops
:
Vec
<
di
:
:
GradientStop
>
)
-
>
GradientBuilder
{
GradientBuilder
{
stops
}
}
pub
fn
push
(
&
mut
self
stop
:
di
:
:
GradientStop
)
{
self
.
stops
.
push
(
stop
)
;
}
pub
fn
stops
(
&
self
)
-
>
&
[
di
:
:
GradientStop
]
{
self
.
stops
.
as_ref
(
)
}
pub
fn
into_stops
(
self
)
-
>
Vec
<
di
:
:
GradientStop
>
{
self
.
stops
}
pub
fn
gradient
(
&
mut
self
start_point
:
LayoutPoint
end_point
:
LayoutPoint
extend_mode
:
di
:
:
ExtendMode
)
-
>
di
:
:
Gradient
{
let
(
start_offset
end_offset
)
=
self
.
normalize
(
extend_mode
)
;
let
start_to_end
=
end_point
-
start_point
;
di
:
:
Gradient
{
start_point
:
start_point
+
start_to_end
*
start_offset
end_point
:
start_point
+
start_to_end
*
end_offset
extend_mode
}
}
pub
fn
radial_gradient
(
&
mut
self
center
:
LayoutPoint
radius
:
LayoutSize
extend_mode
:
di
:
:
ExtendMode
)
-
>
di
:
:
RadialGradient
{
if
radius
.
width
<
=
0
.
0
|
|
radius
.
height
<
=
0
.
0
{
let
last_color
=
self
.
stops
.
last
(
)
.
unwrap
(
)
.
color
;
self
.
stops
.
clear
(
)
;
self
.
stops
.
push
(
di
:
:
GradientStop
{
offset
:
0
.
0
color
:
last_color
}
)
;
self
.
stops
.
push
(
di
:
:
GradientStop
{
offset
:
1
.
0
color
:
last_color
}
)
;
return
di
:
:
RadialGradient
{
center
radius
:
LayoutSize
:
:
new
(
1
.
0
1
.
0
)
start_offset
:
0
.
0
end_offset
:
1
.
0
extend_mode
}
;
}
let
(
start_offset
end_offset
)
=
self
.
normalize
(
extend_mode
)
;
di
:
:
RadialGradient
{
center
radius
start_offset
end_offset
extend_mode
}
}
pub
fn
conic_gradient
(
&
mut
self
center
:
LayoutPoint
angle
:
f32
extend_mode
:
di
:
:
ExtendMode
)
-
>
di
:
:
ConicGradient
{
let
(
start_offset
end_offset
)
=
self
.
normalize
(
extend_mode
)
;
di
:
:
ConicGradient
{
center
angle
start_offset
end_offset
extend_mode
}
}
fn
normalize
(
&
mut
self
extend_mode
:
di
:
:
ExtendMode
)
-
>
(
f32
f32
)
{
let
stops
=
&
mut
self
.
stops
;
assert
!
(
stops
.
len
(
)
>
=
2
)
;
let
first
=
*
stops
.
first
(
)
.
unwrap
(
)
;
let
last
=
*
stops
.
last
(
)
.
unwrap
(
)
;
let
stops_delta
=
last
.
offset
-
first
.
offset
;
if
stops_delta
>
0
.
000001
{
for
stop
in
stops
{
stop
.
offset
=
(
stop
.
offset
-
first
.
offset
)
/
stops_delta
;
}
(
first
.
offset
last
.
offset
)
}
else
if
stops_delta
.
is_nan
(
)
{
stops
.
clear
(
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
0
.
0
}
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
1
.
0
}
)
;
(
0
.
0
1
.
0
)
}
else
{
stops
.
clear
(
)
;
match
extend_mode
{
di
:
:
ExtendMode
:
:
Clamp
=
>
{
stops
.
push
(
di
:
:
GradientStop
{
color
:
first
.
color
offset
:
0
.
0
}
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
first
.
color
offset
:
0
.
5
}
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
0
.
5
}
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
1
.
0
}
)
;
let
offset
=
last
.
offset
;
(
offset
-
0
.
5
offset
+
0
.
5
)
}
di
:
:
ExtendMode
:
:
Repeat
=
>
{
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
0
.
0
}
)
;
stops
.
push
(
di
:
:
GradientStop
{
color
:
last
.
color
offset
:
1
.
0
}
)
;
(
0
.
0
1
.
0
)
}
}
}
}
}
