pub
use
sha2
:
:
{
Digest
Sha256
}
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
path
:
:
Path
;
use
std
:
:
collections
:
:
HashSet
;
#
[
derive
(
PartialEq
Eq
Hash
Debug
Clone
Default
)
]
#
[
cfg_attr
(
feature
=
"
serialize_program
"
derive
(
Deserialize
Serialize
)
)
]
pub
struct
ProgramSourceDigest
(
[
u8
;
32
]
)
;
impl
:
:
std
:
:
fmt
:
:
Display
for
ProgramSourceDigest
{
fn
fmt
(
&
self
f
:
&
mut
:
:
std
:
:
fmt
:
:
Formatter
)
-
>
:
:
std
:
:
fmt
:
:
Result
{
for
byte
in
self
.
0
.
iter
(
)
{
f
.
write_fmt
(
format_args
!
(
"
{
:
02x
}
"
byte
)
)
?
;
}
Ok
(
(
)
)
}
}
impl
From
<
Sha256
>
for
ProgramSourceDigest
{
fn
from
(
hasher
:
Sha256
)
-
>
Self
{
let
mut
digest
=
Self
:
:
default
(
)
;
digest
.
0
.
copy_from_slice
(
hasher
.
result
(
)
.
as_slice
(
)
)
;
digest
}
}
const
SHADER_IMPORT
:
&
str
=
"
#
include
"
;
pub
struct
ShaderSourceParser
{
included
:
HashSet
<
String
>
}
impl
ShaderSourceParser
{
pub
fn
new
(
)
-
>
Self
{
ShaderSourceParser
{
included
:
HashSet
:
:
new
(
)
}
}
pub
fn
parse
<
F
:
FnMut
(
&
str
)
G
:
Fn
(
&
str
)
-
>
Cow
<
'
static
str
>
>
(
&
mut
self
source
:
Cow
<
'
static
str
>
get_source
:
&
G
output
:
&
mut
F
)
{
for
line
in
source
.
lines
(
)
{
if
line
.
starts_with
(
SHADER_IMPORT
)
{
let
imports
=
line
[
SHADER_IMPORT
.
len
(
)
.
.
]
.
split
(
'
'
)
;
for
import
in
imports
{
if
self
.
included
.
insert
(
import
.
into
(
)
)
{
let
include
=
get_source
(
import
)
;
self
.
parse
(
include
get_source
output
)
;
}
else
{
output
(
&
format
!
(
"
/
/
{
}
is
already
included
\
n
"
import
)
)
;
}
}
}
else
{
output
(
line
)
;
output
(
"
\
n
"
)
;
}
}
}
}
pub
fn
shader_source_from_file
(
shader_path
:
&
Path
)
-
>
String
{
assert
!
(
shader_path
.
exists
(
)
"
Shader
not
found
"
)
;
let
mut
source
=
String
:
:
new
(
)
;
File
:
:
open
(
&
shader_path
)
.
expect
(
"
Shader
not
found
"
)
.
read_to_string
(
&
mut
source
)
.
unwrap
(
)
;
source
}
