#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPService
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
IdleTaskRunner
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsHtml5AutoPauseUpdate
.
h
"
#
include
"
nsHtml5Parser
.
h
"
#
include
"
nsHtml5StreamParser
.
h
"
#
include
"
nsHtml5Tokenizer
.
h
"
#
include
"
nsHtml5TreeBuilder
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIViewSourceChannel
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
nsHtml5TreeOpExecutor
nsHtml5DocumentBuilder
nsIContentSink
)
class
nsHtml5ExecutorReflusher
:
public
Runnable
{
private
:
RefPtr
<
nsHtml5TreeOpExecutor
>
mExecutor
;
public
:
explicit
nsHtml5ExecutorReflusher
(
nsHtml5TreeOpExecutor
*
aExecutor
)
:
mozilla
:
:
Runnable
(
"
nsHtml5ExecutorReflusher
"
)
mExecutor
(
aExecutor
)
{
}
NS_IMETHOD
Run
(
)
override
{
mExecutor
-
>
RunFlushLoop
(
)
;
return
NS_OK
;
}
}
;
class
MOZ_RAII
nsHtml5AutoFlush
final
{
private
:
RefPtr
<
nsHtml5TreeOpExecutor
>
mExecutor
;
size_t
mOpsToRemove
;
public
:
explicit
nsHtml5AutoFlush
(
nsHtml5TreeOpExecutor
*
aExecutor
)
:
mExecutor
(
aExecutor
)
mOpsToRemove
(
aExecutor
-
>
OpQueueLength
(
)
)
{
mExecutor
-
>
BeginFlush
(
)
;
mExecutor
-
>
BeginDocUpdate
(
)
;
}
~
nsHtml5AutoFlush
(
)
{
if
(
mExecutor
-
>
IsInDocUpdate
(
)
)
{
mExecutor
-
>
EndDocUpdate
(
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
mExecutor
-
>
IsComplete
(
)
"
How
do
we
have
mParser
but
the
doc
update
isn
'
t
open
?
"
)
;
}
mExecutor
-
>
EndFlush
(
)
;
mExecutor
-
>
RemoveFromStartOfOpQueue
(
mOpsToRemove
)
;
}
void
SetNumberOfOpsToRemove
(
size_t
aOpsToRemove
)
{
MOZ_ASSERT
(
aOpsToRemove
<
mOpsToRemove
"
Requested
partial
clearing
of
op
queue
but
the
number
to
clear
"
"
wasn
'
t
less
than
the
length
of
the
queue
.
"
)
;
mOpsToRemove
=
aOpsToRemove
;
}
}
;
static
mozilla
:
:
LinkedList
<
nsHtml5TreeOpExecutor
>
*
gBackgroundFlushList
=
nullptr
;
StaticRefPtr
<
IdleTaskRunner
>
gBackgroundFlushRunner
;
nsHtml5TreeOpExecutor
:
:
nsHtml5TreeOpExecutor
(
)
:
nsHtml5DocumentBuilder
(
false
)
mSuppressEOF
(
false
)
mReadingFromStage
(
false
)
mStreamParser
(
nullptr
)
mPreloadedURLs
(
23
)
mSpeculationReferrerPolicy
(
mozilla
:
:
net
:
:
RP_Unset
)
mStarted
(
false
)
mRunFlushLoopOnStack
(
false
)
mCallContinueInterruptedParsingIfEnabled
(
false
)
mAlreadyComplainedAboutCharset
(
false
)
mAlreadyComplainedAboutDeepTree
(
false
)
{
}
nsHtml5TreeOpExecutor
:
:
~
nsHtml5TreeOpExecutor
(
)
{
if
(
gBackgroundFlushList
&
&
isInList
(
)
)
{
ClearOpQueue
(
)
;
removeFrom
(
*
gBackgroundFlushList
)
;
if
(
gBackgroundFlushList
-
>
isEmpty
(
)
)
{
delete
gBackgroundFlushList
;
gBackgroundFlushList
=
nullptr
;
if
(
gBackgroundFlushRunner
)
{
gBackgroundFlushRunner
-
>
Cancel
(
)
;
gBackgroundFlushRunner
=
nullptr
;
}
}
}
NS_ASSERTION
(
mOpQueue
.
IsEmpty
(
)
"
Somehow
there
'
s
stuff
in
the
op
queue
.
"
)
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
WillParse
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
one
should
call
this
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
WillBuildModel
(
nsDTDMode
aDTDMode
)
{
mDocument
-
>
AddObserver
(
this
)
;
WillBuildModelImpl
(
)
;
GetDocument
(
)
-
>
BeginLoad
(
)
;
if
(
mDocShell
&
&
!
GetDocument
(
)
-
>
GetWindow
(
)
&
&
!
IsExternalViewSource
(
)
)
{
return
MarkAsBroken
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
DidBuildModel
(
bool
aTerminated
)
{
if
(
mRunsToCompletion
)
{
return
NS_OK
;
}
MOZ_RELEASE_ASSERT
(
!
IsInDocUpdate
(
)
"
DidBuildModel
from
inside
a
doc
update
.
"
)
;
DidBuildModelImpl
(
aTerminated
|
|
NS_FAILED
(
IsBroken
(
)
)
)
;
if
(
!
mLayoutStarted
)
{
bool
destroying
=
true
;
if
(
mDocShell
)
{
mDocShell
-
>
IsBeingDestroyed
(
&
destroying
)
;
}
if
(
!
destroying
)
{
mDocument
-
>
TriggerInitialDocumentTranslation
(
)
;
nsContentSink
:
:
StartLayout
(
false
)
;
}
}
ScrollToRef
(
)
;
mDocument
-
>
RemoveObserver
(
this
)
;
if
(
!
mParser
)
{
return
NS_OK
;
}
if
(
mStarted
)
{
mDocument
-
>
EndLoad
(
)
;
}
GetParser
(
)
-
>
DropStreamParser
(
)
;
DropParserAndPerfHint
(
)
;
#
ifdef
GATHER_DOCWRITE_STATISTICS
printf
(
"
UNSAFE
SCRIPTS
:
%
d
\
n
"
sUnsafeDocWrites
)
;
printf
(
"
TOKENIZER
-
SAFE
SCRIPTS
:
%
d
\
n
"
sTokenSafeDocWrites
)
;
printf
(
"
TREEBUILDER
-
SAFE
SCRIPTS
:
%
d
\
n
"
sTreeSafeDocWrites
)
;
#
endif
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
printf
(
"
MAX
NOTIFICATION
BATCH
LEN
:
%
d
\
n
"
sAppendBatchMaxSize
)
;
if
(
sAppendBatchExaminations
!
=
0
)
{
printf
(
"
AVERAGE
SLOTS
EXAMINED
:
%
d
\
n
"
sAppendBatchSlotsExamined
/
sAppendBatchExaminations
)
;
}
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
WillInterrupt
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Don
'
t
call
.
For
interface
compat
only
.
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
WillResume
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Don
'
t
call
.
For
interface
compat
only
.
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsHtml5TreeOpExecutor
:
:
SetParser
(
nsParserBase
*
aParser
)
{
mParser
=
aParser
;
return
NS_OK
;
}
void
nsHtml5TreeOpExecutor
:
:
InitialDocumentTranslationCompleted
(
)
{
nsContentSink
:
:
StartLayout
(
false
)
;
}
void
nsHtml5TreeOpExecutor
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
if
(
aType
>
=
FlushType
:
:
EnsurePresShellInitAndFrames
)
{
nsContentSink
:
:
StartLayout
(
true
)
;
}
}
nsISupports
*
nsHtml5TreeOpExecutor
:
:
GetTarget
(
)
{
return
ToSupports
(
mDocument
)
;
}
nsresult
nsHtml5TreeOpExecutor
:
:
MarkAsBroken
(
nsresult
aReason
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mBroken
=
aReason
;
if
(
mStreamParser
)
{
mStreamParser
-
>
Terminate
(
)
;
}
if
(
mParser
&
&
mDocument
)
{
nsCOMPtr
<
nsIRunnable
>
terminator
=
NewRunnableMethod
(
"
nsHtml5Parser
:
:
Terminate
"
GetParser
(
)
&
nsHtml5Parser
:
:
Terminate
)
;
if
(
NS_FAILED
(
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Network
terminator
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
return
aReason
;
}
static
bool
BackgroundFlushCallback
(
TimeStamp
)
{
RefPtr
<
nsHtml5TreeOpExecutor
>
ex
=
gBackgroundFlushList
-
>
popFirst
(
)
;
if
(
ex
)
{
ex
-
>
RunFlushLoop
(
)
;
}
if
(
gBackgroundFlushList
&
&
gBackgroundFlushList
-
>
isEmpty
(
)
)
{
delete
gBackgroundFlushList
;
gBackgroundFlushList
=
nullptr
;
gBackgroundFlushRunner
-
>
Cancel
(
)
;
gBackgroundFlushRunner
=
nullptr
;
return
true
;
}
return
true
;
}
void
nsHtml5TreeOpExecutor
:
:
ContinueInterruptedParsingAsync
(
)
{
if
(
!
mDocument
|
|
!
mDocument
-
>
IsInBackgroundWindow
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
flusher
=
new
nsHtml5ExecutorReflusher
(
this
)
;
if
(
NS_FAILED
(
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Network
flusher
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
else
{
if
(
!
gBackgroundFlushList
)
{
gBackgroundFlushList
=
new
mozilla
:
:
LinkedList
<
nsHtml5TreeOpExecutor
>
(
)
;
}
if
(
!
isInList
(
)
)
{
gBackgroundFlushList
-
>
insertBack
(
this
)
;
}
if
(
gBackgroundFlushRunner
)
{
return
;
}
gBackgroundFlushRunner
=
IdleTaskRunner
:
:
Create
(
&
BackgroundFlushCallback
"
nsHtml5TreeOpExecutor
:
:
BackgroundFlushCallback
"
250
nsContentSink
:
:
sInteractiveParseTime
/
1000
true
[
]
{
return
false
;
}
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
FlushSpeculativeLoads
(
)
{
nsTArray
<
nsHtml5SpeculativeLoad
>
speculativeLoadQueue
;
mStage
.
MoveSpeculativeLoadsTo
(
speculativeLoadQueue
)
;
nsHtml5SpeculativeLoad
*
start
=
speculativeLoadQueue
.
Elements
(
)
;
nsHtml5SpeculativeLoad
*
end
=
start
+
speculativeLoadQueue
.
Length
(
)
;
for
(
nsHtml5SpeculativeLoad
*
iter
=
start
;
iter
<
end
;
+
+
iter
)
{
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
iter
-
>
Perform
(
this
)
;
}
}
class
nsHtml5FlushLoopGuard
{
private
:
RefPtr
<
nsHtml5TreeOpExecutor
>
mExecutor
;
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
uint32_t
mStartTime
;
#
endif
public
:
explicit
nsHtml5FlushLoopGuard
(
nsHtml5TreeOpExecutor
*
aExecutor
)
:
mExecutor
(
aExecutor
)
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
mStartTime
(
PR_IntervalToMilliseconds
(
PR_IntervalNow
(
)
)
)
#
endif
{
mExecutor
-
>
mRunFlushLoopOnStack
=
true
;
}
~
nsHtml5FlushLoopGuard
(
)
{
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
uint32_t
timeOffTheEventLoop
=
PR_IntervalToMilliseconds
(
PR_IntervalNow
(
)
)
-
mStartTime
;
if
(
timeOffTheEventLoop
>
nsHtml5TreeOpExecutor
:
:
sLongestTimeOffTheEventLoop
)
{
nsHtml5TreeOpExecutor
:
:
sLongestTimeOffTheEventLoop
=
timeOffTheEventLoop
;
}
printf
(
"
Longest
time
off
the
event
loop
:
%
d
\
n
"
nsHtml5TreeOpExecutor
:
:
sLongestTimeOffTheEventLoop
)
;
#
endif
mExecutor
-
>
mRunFlushLoopOnStack
=
false
;
}
}
;
void
nsHtml5TreeOpExecutor
:
:
RunFlushLoop
(
)
{
AUTO_PROFILER_LABEL
(
"
nsHtml5TreeOpExecutor
:
:
RunFlushLoop
"
OTHER
)
;
if
(
mRunFlushLoopOnStack
)
{
return
;
}
nsHtml5FlushLoopGuard
guard
(
this
)
;
RefPtr
<
nsParserBase
>
parserKungFuDeathGrip
(
mParser
)
;
RefPtr
<
nsHtml5StreamParser
>
streamParserGrip
;
if
(
mParser
)
{
streamParserGrip
=
GetParser
(
)
-
>
GetStreamParser
(
)
;
}
mozilla
:
:
Unused
<
<
streamParserGrip
;
(
void
)
nsContentSink
:
:
WillParseImpl
(
)
;
for
(
;
;
)
{
if
(
!
mParser
)
{
ClearOpQueue
(
)
;
return
;
}
if
(
NS_FAILED
(
IsBroken
(
)
)
)
{
return
;
}
if
(
!
parserKungFuDeathGrip
-
>
IsParserEnabled
(
)
)
{
return
;
}
if
(
mFlushState
!
=
eNotFlushing
)
{
return
;
}
if
(
IsScriptExecuting
(
)
)
{
return
;
}
if
(
mReadingFromStage
)
{
nsTArray
<
nsHtml5SpeculativeLoad
>
speculativeLoadQueue
;
MOZ_RELEASE_ASSERT
(
mFlushState
=
=
eNotFlushing
"
mOpQueue
modified
during
flush
.
"
)
;
mStage
.
MoveOpsAndSpeculativeLoadsTo
(
mOpQueue
speculativeLoadQueue
)
;
nsHtml5SpeculativeLoad
*
start
=
speculativeLoadQueue
.
Elements
(
)
;
nsHtml5SpeculativeLoad
*
end
=
start
+
speculativeLoadQueue
.
Length
(
)
;
for
(
nsHtml5SpeculativeLoad
*
iter
=
start
;
iter
<
end
;
+
+
iter
)
{
iter
-
>
Perform
(
this
)
;
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
ClearOpQueue
(
)
;
return
;
}
}
}
else
{
FlushSpeculativeLoads
(
)
;
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
ClearOpQueue
(
)
;
return
;
}
nsresult
rv
=
GetParser
(
)
-
>
ParseUntilBlocked
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MarkAsBroken
(
rv
)
;
return
;
}
}
if
(
mOpQueue
.
IsEmpty
(
)
)
{
return
;
}
nsIContent
*
scriptElement
=
nullptr
;
bool
interrupted
=
false
;
bool
streamEnded
=
false
;
{
nsHtml5AutoFlush
autoFlush
(
this
)
;
nsHtml5TreeOperation
*
first
=
mOpQueue
.
Elements
(
)
;
nsHtml5TreeOperation
*
last
=
first
+
mOpQueue
.
Length
(
)
-
1
;
for
(
nsHtml5TreeOperation
*
iter
=
first
;
;
+
+
iter
)
{
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
MOZ_ASSERT
(
IsInDocUpdate
(
)
"
Tried
to
perform
tree
op
outside
update
batch
.
"
)
;
nsresult
rv
=
iter
-
>
Perform
(
this
&
scriptElement
&
interrupted
&
streamEnded
)
;
if
(
NS_FAILED
(
rv
)
)
{
MarkAsBroken
(
rv
)
;
break
;
}
if
(
MOZ_UNLIKELY
(
iter
=
=
last
)
)
{
break
;
}
else
if
(
MOZ_UNLIKELY
(
interrupted
)
|
|
MOZ_UNLIKELY
(
nsContentSink
:
:
DidProcessATokenImpl
(
)
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
)
{
autoFlush
.
SetNumberOfOpsToRemove
(
(
iter
-
first
)
+
1
)
;
nsHtml5TreeOpExecutor
:
:
ContinueInterruptedParsingAsync
(
)
;
return
;
}
}
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
if
(
streamEnded
)
{
GetParser
(
)
-
>
PermanentlyUndefineInsertionPoint
(
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
if
(
streamEnded
)
{
DidBuildModel
(
false
)
;
#
ifdef
DEBUG
if
(
scriptElement
)
{
nsCOMPtr
<
nsIScriptElement
>
sele
=
do_QueryInterface
(
scriptElement
)
;
if
(
!
sele
)
{
MOZ_ASSERT
(
nsNameSpaceManager
:
:
GetInstance
(
)
-
>
mSVGDisabled
"
Node
didn
'
t
QI
to
script
but
SVG
wasn
'
t
disabled
.
"
)
;
}
MOZ_ASSERT
(
sele
-
>
IsMalformed
(
)
"
Script
wasn
'
t
marked
as
malformed
.
"
)
;
}
#
endif
}
else
if
(
scriptElement
)
{
RunScript
(
scriptElement
)
;
StopDeflecting
(
)
;
if
(
nsContentSink
:
:
DidProcessATokenImpl
(
)
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
{
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
printf
(
"
REFLUSH
SCHEDULED
(
after
script
)
:
%
d
\
n
"
+
+
sTimesFlushLoopInterrupted
)
;
#
endif
nsHtml5TreeOpExecutor
:
:
ContinueInterruptedParsingAsync
(
)
;
return
;
}
}
}
}
nsresult
nsHtml5TreeOpExecutor
:
:
FlushDocumentWrite
(
)
{
nsresult
rv
=
IsBroken
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
FlushSpeculativeLoads
(
)
;
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
ClearOpQueue
(
)
;
return
rv
;
}
if
(
mFlushState
!
=
eNotFlushing
)
{
return
rv
;
}
RefPtr
<
nsHtml5TreeOpExecutor
>
kungFuDeathGrip
(
this
)
;
RefPtr
<
nsParserBase
>
parserKungFuDeathGrip
(
mParser
)
;
mozilla
:
:
Unused
<
<
parserKungFuDeathGrip
;
RefPtr
<
nsHtml5StreamParser
>
streamParserGrip
;
if
(
mParser
)
{
streamParserGrip
=
GetParser
(
)
-
>
GetStreamParser
(
)
;
}
mozilla
:
:
Unused
<
<
streamParserGrip
;
MOZ_RELEASE_ASSERT
(
!
mReadingFromStage
"
Got
doc
write
flush
when
reading
from
stage
"
)
;
#
ifdef
DEBUG
mStage
.
AssertEmpty
(
)
;
#
endif
nsIContent
*
scriptElement
=
nullptr
;
bool
interrupted
=
false
;
bool
streamEnded
=
false
;
{
nsHtml5AutoFlush
autoFlush
(
this
)
;
nsHtml5TreeOperation
*
start
=
mOpQueue
.
Elements
(
)
;
nsHtml5TreeOperation
*
end
=
start
+
mOpQueue
.
Length
(
)
;
for
(
nsHtml5TreeOperation
*
iter
=
start
;
iter
<
end
;
+
+
iter
)
{
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
rv
;
}
NS_ASSERTION
(
IsInDocUpdate
(
)
"
Tried
to
perform
tree
op
outside
update
batch
.
"
)
;
rv
=
iter
-
>
Perform
(
this
&
scriptElement
&
interrupted
&
streamEnded
)
;
if
(
NS_FAILED
(
rv
)
)
{
MarkAsBroken
(
rv
)
;
break
;
}
}
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
rv
;
}
if
(
streamEnded
)
{
GetParser
(
)
-
>
PermanentlyUndefineInsertionPoint
(
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
rv
;
}
if
(
streamEnded
)
{
DidBuildModel
(
false
)
;
#
ifdef
DEBUG
if
(
scriptElement
)
{
nsCOMPtr
<
nsIScriptElement
>
sele
=
do_QueryInterface
(
scriptElement
)
;
if
(
!
sele
)
{
MOZ_ASSERT
(
nsNameSpaceManager
:
:
GetInstance
(
)
-
>
mSVGDisabled
"
Node
didn
'
t
QI
to
script
but
SVG
wasn
'
t
disabled
.
"
)
;
}
MOZ_ASSERT
(
sele
-
>
IsMalformed
(
)
"
Script
wasn
'
t
marked
as
malformed
.
"
)
;
}
#
endif
}
else
if
(
scriptElement
)
{
RunScript
(
scriptElement
)
;
}
return
rv
;
}
bool
nsHtml5TreeOpExecutor
:
:
IsScriptEnabled
(
)
{
if
(
!
mDocument
|
|
!
mDocShell
)
{
return
true
;
}
return
mDocument
-
>
IsScriptEnabled
(
)
;
}
void
nsHtml5TreeOpExecutor
:
:
StartLayout
(
bool
*
aInterrupted
)
{
if
(
mLayoutStarted
|
|
!
mDocument
)
{
return
;
}
nsHtml5AutoPauseUpdate
autoPause
(
this
)
;
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
nsContentSink
:
:
StartLayout
(
false
)
;
if
(
mParser
)
{
*
aInterrupted
=
!
GetParser
(
)
-
>
IsParserEnabled
(
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
PauseDocUpdate
(
bool
*
aInterrupted
)
{
nsHtml5AutoPauseUpdate
autoPause
(
this
)
;
if
(
MOZ_LIKELY
(
mParser
)
)
{
*
aInterrupted
=
!
GetParser
(
)
-
>
IsParserEnabled
(
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
RunScript
(
nsIContent
*
aScriptElement
)
{
if
(
mRunsToCompletion
)
{
return
;
}
MOZ_ASSERT
(
mParser
"
Trying
to
run
script
with
a
terminated
parser
.
"
)
;
MOZ_ASSERT
(
aScriptElement
"
No
script
to
run
"
)
;
nsCOMPtr
<
nsIScriptElement
>
sele
=
do_QueryInterface
(
aScriptElement
)
;
if
(
!
sele
)
{
MOZ_ASSERT
(
nsNameSpaceManager
:
:
GetInstance
(
)
-
>
mSVGDisabled
"
Node
didn
'
t
QI
to
script
but
SVG
wasn
'
t
disabled
.
"
)
;
return
;
}
if
(
sele
-
>
GetScriptDeferred
(
)
|
|
sele
-
>
GetScriptAsync
(
)
)
{
DebugOnly
<
bool
>
block
=
sele
-
>
AttemptToExecute
(
)
;
NS_ASSERTION
(
!
block
"
Defer
or
async
script
tried
to
block
.
"
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
mFlushState
=
=
eNotFlushing
"
Tried
to
run
script
while
flushing
.
"
)
;
mReadingFromStage
=
false
;
sele
-
>
SetCreatorParser
(
GetParser
(
)
)
;
bool
block
=
sele
-
>
AttemptToExecute
(
)
;
if
(
block
)
{
if
(
mParser
)
{
GetParser
(
)
-
>
BlockParser
(
)
;
}
}
else
{
nsHtml5TreeOpExecutor
:
:
ContinueInterruptedParsingAsync
(
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
Start
(
)
{
MOZ_ASSERT
(
!
mStarted
"
Tried
to
start
when
already
started
.
"
)
;
mStarted
=
true
;
}
void
nsHtml5TreeOpExecutor
:
:
NeedsCharsetSwitchTo
(
NotNull
<
const
Encoding
*
>
aEncoding
int32_t
aSource
uint32_t
aLineNumber
)
{
nsHtml5AutoPauseUpdate
autoPause
(
this
)
;
if
(
MOZ_UNLIKELY
(
!
mParser
)
)
{
return
;
}
if
(
!
mDocShell
)
{
return
;
}
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
mDocShell
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
docShell
-
>
CharsetChangeStopDocumentLoad
(
)
)
)
{
nsAutoCString
charset
;
aEncoding
-
>
Name
(
charset
)
;
docShell
-
>
CharsetChangeReloadDocument
(
charset
.
get
(
)
aSource
)
;
}
if
(
!
mParser
)
{
if
(
aSource
=
=
kCharsetFromMetaTag
)
{
MaybeComplainAboutCharset
(
"
EncLateMetaReload
"
false
aLineNumber
)
;
}
return
;
}
if
(
aSource
=
=
kCharsetFromMetaTag
)
{
MaybeComplainAboutCharset
(
"
EncLateMetaTooLate
"
true
aLineNumber
)
;
}
GetParser
(
)
-
>
ContinueAfterFailedCharsetSwitch
(
)
;
}
void
nsHtml5TreeOpExecutor
:
:
MaybeComplainAboutCharset
(
const
char
*
aMsgId
bool
aError
uint32_t
aLineNumber
)
{
if
(
mAlreadyComplainedAboutCharset
)
{
return
;
}
if
(
!
strcmp
(
aMsgId
"
EncNoDeclaration
"
)
&
&
mDocShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
mDocShell
-
>
GetSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
if
(
parent
)
{
return
;
}
}
mAlreadyComplainedAboutCharset
=
true
;
nsContentUtils
:
:
ReportToConsole
(
aError
?
nsIScriptError
:
:
errorFlag
:
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
HTML
parser
"
)
mDocument
nsContentUtils
:
:
eHTMLPARSER_PROPERTIES
aMsgId
nullptr
0
nullptr
EmptyString
(
)
aLineNumber
)
;
}
void
nsHtml5TreeOpExecutor
:
:
ComplainAboutBogusProtocolCharset
(
Document
*
aDoc
)
{
NS_ASSERTION
(
!
mAlreadyComplainedAboutCharset
"
How
come
we
already
managed
to
complain
?
"
)
;
mAlreadyComplainedAboutCharset
=
true
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
HTML
parser
"
)
aDoc
nsContentUtils
:
:
eHTMLPARSER_PROPERTIES
"
EncProtocolUnsupported
"
)
;
}
void
nsHtml5TreeOpExecutor
:
:
MaybeComplainAboutDeepTree
(
uint32_t
aLineNumber
)
{
if
(
mAlreadyComplainedAboutDeepTree
)
{
return
;
}
mAlreadyComplainedAboutDeepTree
=
true
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
HTML
parser
"
)
mDocument
nsContentUtils
:
:
eHTMLPARSER_PROPERTIES
"
errDeepTree
"
nullptr
0
nullptr
EmptyString
(
)
aLineNumber
)
;
}
nsHtml5Parser
*
nsHtml5TreeOpExecutor
:
:
GetParser
(
)
{
MOZ_ASSERT
(
!
mRunsToCompletion
)
;
return
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
;
}
void
nsHtml5TreeOpExecutor
:
:
MoveOpsFrom
(
nsTArray
<
nsHtml5TreeOperation
>
&
aOpQueue
)
{
MOZ_RELEASE_ASSERT
(
mFlushState
=
=
eNotFlushing
"
Ops
added
to
mOpQueue
during
tree
op
execution
.
"
)
;
mOpQueue
.
AppendElements
(
std
:
:
move
(
aOpQueue
)
)
;
}
void
nsHtml5TreeOpExecutor
:
:
ClearOpQueue
(
)
{
MOZ_RELEASE_ASSERT
(
mFlushState
=
=
eNotFlushing
"
mOpQueue
cleared
during
tree
op
execution
.
"
)
;
mOpQueue
.
Clear
(
)
;
}
void
nsHtml5TreeOpExecutor
:
:
RemoveFromStartOfOpQueue
(
size_t
aNumberOfOpsToRemove
)
{
MOZ_RELEASE_ASSERT
(
mFlushState
=
=
eNotFlushing
"
Ops
removed
from
mOpQueue
during
tree
op
execution
.
"
)
;
mOpQueue
.
RemoveElementsAt
(
0
aNumberOfOpsToRemove
)
;
}
void
nsHtml5TreeOpExecutor
:
:
InitializeDocWriteParserState
(
nsAHtml5TreeBuilderState
*
aState
int32_t
aLine
)
{
GetParser
(
)
-
>
InitializeDocWriteParserState
(
aState
aLine
)
;
}
nsIURI
*
nsHtml5TreeOpExecutor
:
:
GetViewSourceBaseURI
(
)
{
if
(
!
mViewSourceBaseURI
)
{
nsCOMPtr
<
nsIViewSourceChannel
>
vsc
=
do_QueryInterface
(
mDocument
-
>
GetChannel
(
)
)
;
if
(
vsc
)
{
nsresult
rv
=
vsc
-
>
GetBaseURI
(
getter_AddRefs
(
mViewSourceBaseURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mViewSourceBaseURI
)
{
return
mViewSourceBaseURI
;
}
}
nsCOMPtr
<
nsIURI
>
orig
=
mDocument
-
>
GetOriginalURI
(
)
;
bool
isViewSource
;
orig
-
>
SchemeIs
(
"
view
-
source
"
&
isViewSource
)
;
if
(
isViewSource
)
{
nsCOMPtr
<
nsINestedURI
>
nested
=
do_QueryInterface
(
orig
)
;
NS_ASSERTION
(
nested
"
URI
with
scheme
view
-
source
didn
'
t
QI
to
nested
!
"
)
;
nested
-
>
GetInnerURI
(
getter_AddRefs
(
mViewSourceBaseURI
)
)
;
}
else
{
mViewSourceBaseURI
=
orig
;
}
}
return
mViewSourceBaseURI
;
}
bool
nsHtml5TreeOpExecutor
:
:
IsExternalViewSource
(
)
{
if
(
!
StaticPrefs
:
:
view_source_editor_external
(
)
)
{
return
false
;
}
bool
isViewSource
=
false
;
if
(
mDocumentURI
)
{
mDocumentURI
-
>
SchemeIs
(
"
view
-
source
"
&
isViewSource
)
;
}
return
isViewSource
;
}
nsIURI
*
nsHtml5TreeOpExecutor
:
:
BaseURIForPreload
(
)
{
nsIURI
*
documentURI
=
mDocument
-
>
GetDocumentURI
(
)
;
nsIURI
*
documentBaseURI
=
mDocument
-
>
GetDocBaseURI
(
)
;
return
(
documentURI
=
=
documentBaseURI
)
?
(
mSpeculationBaseURI
?
mSpeculationBaseURI
.
get
(
)
:
documentURI
)
:
documentBaseURI
;
}
already_AddRefed
<
nsIURI
>
nsHtml5TreeOpExecutor
:
:
ConvertIfNotPreloadedYet
(
const
nsAString
&
aURL
)
{
if
(
aURL
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIURI
*
base
=
BaseURIForPreload
(
)
;
auto
encoding
=
mDocument
-
>
GetDocumentCharacterSet
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aURL
encoding
base
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
a
URI
"
)
;
return
nullptr
;
}
if
(
ShouldPreloadURI
(
uri
)
)
{
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
bool
nsHtml5TreeOpExecutor
:
:
ShouldPreloadURI
(
nsIURI
*
aURI
)
{
nsAutoCString
spec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
mPreloadedURLs
.
EnsureInserted
(
spec
)
;
}
net
:
:
ReferrerPolicy
nsHtml5TreeOpExecutor
:
:
GetPreloadReferrerPolicy
(
const
nsAString
&
aReferrerPolicy
)
{
net
:
:
ReferrerPolicy
referrerPolicy
=
net
:
:
AttributeReferrerPolicyFromString
(
aReferrerPolicy
)
;
return
referrerPolicy
!
=
net
:
:
RP_Unset
?
referrerPolicy
:
mSpeculationReferrerPolicy
;
}
void
nsHtml5TreeOpExecutor
:
:
PreloadScript
(
const
nsAString
&
aURL
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aIntegrity
net
:
:
ReferrerPolicy
aReferrerPolicy
bool
aScriptFromHead
bool
aAsync
bool
aDefer
bool
aNoModule
)
{
nsCOMPtr
<
nsIURI
>
uri
=
ConvertIfNotPreloadedYet
(
aURL
)
;
if
(
!
uri
)
{
return
;
}
net
:
:
ReferrerPolicy
referrerPolicy
=
aReferrerPolicy
!
=
net
:
:
RP_Unset
?
aReferrerPolicy
:
mSpeculationReferrerPolicy
;
mDocument
-
>
ScriptLoader
(
)
-
>
PreloadURI
(
uri
aCharset
aType
aCrossOrigin
aIntegrity
aScriptFromHead
aAsync
aDefer
aNoModule
referrerPolicy
)
;
}
void
nsHtml5TreeOpExecutor
:
:
PreloadStyle
(
const
nsAString
&
aURL
const
nsAString
&
aCharset
const
nsAString
&
aCrossOrigin
const
nsAString
&
aReferrerPolicy
const
nsAString
&
aIntegrity
)
{
nsCOMPtr
<
nsIURI
>
uri
=
ConvertIfNotPreloadedYet
(
aURL
)
;
if
(
!
uri
)
{
return
;
}
mDocument
-
>
PreloadStyle
(
uri
Encoding
:
:
ForLabel
(
aCharset
)
aCrossOrigin
GetPreloadReferrerPolicy
(
aReferrerPolicy
)
aIntegrity
)
;
}
void
nsHtml5TreeOpExecutor
:
:
PreloadImage
(
const
nsAString
&
aURL
const
nsAString
&
aCrossOrigin
const
nsAString
&
aSrcset
const
nsAString
&
aSizes
const
nsAString
&
aImageReferrerPolicy
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
BaseURIForPreload
(
)
;
bool
isImgSet
=
false
;
nsCOMPtr
<
nsIURI
>
uri
=
mDocument
-
>
ResolvePreloadImage
(
baseURI
aURL
aSrcset
aSizes
&
isImgSet
)
;
if
(
uri
&
&
ShouldPreloadURI
(
uri
)
)
{
mDocument
-
>
MaybePreLoadImage
(
uri
aCrossOrigin
GetPreloadReferrerPolicy
(
aImageReferrerPolicy
)
isImgSet
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
PreloadPictureSource
(
const
nsAString
&
aSrcset
const
nsAString
&
aSizes
const
nsAString
&
aType
const
nsAString
&
aMedia
)
{
mDocument
-
>
PreloadPictureImageSource
(
aSrcset
aSizes
aType
aMedia
)
;
}
void
nsHtml5TreeOpExecutor
:
:
PreloadOpenPicture
(
)
{
mDocument
-
>
PreloadPictureOpened
(
)
;
}
void
nsHtml5TreeOpExecutor
:
:
PreloadEndPicture
(
)
{
mDocument
-
>
PreloadPictureClosed
(
)
;
}
void
nsHtml5TreeOpExecutor
:
:
AddBase
(
const
nsAString
&
aURL
)
{
auto
encoding
=
mDocument
-
>
GetDocumentCharacterSet
(
)
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
mViewSourceBaseURI
)
aURL
encoding
GetViewSourceBaseURI
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mViewSourceBaseURI
=
nullptr
;
}
}
void
nsHtml5TreeOpExecutor
:
:
SetSpeculationBase
(
const
nsAString
&
aURL
)
{
if
(
mSpeculationBaseURI
)
{
return
;
}
auto
encoding
=
mDocument
-
>
GetDocumentCharacterSet
(
)
;
DebugOnly
<
nsresult
>
rv
=
NS_NewURI
(
getter_AddRefs
(
mSpeculationBaseURI
)
aURL
encoding
mDocument
-
>
GetDocumentURI
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
create
a
URI
"
)
;
}
void
nsHtml5TreeOpExecutor
:
:
SetSpeculationReferrerPolicy
(
const
nsAString
&
aReferrerPolicy
)
{
if
(
aReferrerPolicy
.
IsEmpty
(
)
)
{
return
;
}
ReferrerPolicy
policy
=
mozilla
:
:
net
:
:
ReferrerPolicyFromString
(
aReferrerPolicy
)
;
if
(
policy
!
=
mozilla
:
:
net
:
:
RP_Unset
)
{
SetSpeculationReferrerPolicy
(
policy
)
;
}
}
void
nsHtml5TreeOpExecutor
:
:
AddSpeculationCSP
(
const
nsAString
&
aCSP
)
{
if
(
!
StaticPrefs
:
:
security_csp_enable
(
)
)
{
return
;
}
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
nsIPrincipal
*
principal
=
mDocument
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
preloadCsp
;
nsresult
rv
=
principal
-
>
EnsurePreloadCSP
(
mDocument
getter_AddRefs
(
preloadCsp
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
preloadCsp
-
>
AppendPolicy
(
aCSP
false
true
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mDocument
-
>
ApplySettingsFromCSP
(
true
)
;
}
void
nsHtml5TreeOpExecutor
:
:
SetSpeculationReferrerPolicy
(
ReferrerPolicy
aReferrerPolicy
)
{
mSpeculationReferrerPolicy
=
aReferrerPolicy
;
}
#
ifdef
DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
uint32_t
nsHtml5TreeOpExecutor
:
:
sAppendBatchMaxSize
=
0
;
uint32_t
nsHtml5TreeOpExecutor
:
:
sAppendBatchSlotsExamined
=
0
;
uint32_t
nsHtml5TreeOpExecutor
:
:
sAppendBatchExaminations
=
0
;
uint32_t
nsHtml5TreeOpExecutor
:
:
sLongestTimeOffTheEventLoop
=
0
;
uint32_t
nsHtml5TreeOpExecutor
:
:
sTimesFlushLoopInterrupted
=
0
;
#
endif
