#
include
"
nsHtml5StreamParser
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHtml5Tokenizer
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsHtml5Parser
.
h
"
#
include
"
nsHtml5TreeBuilder
.
h
"
#
include
"
nsHtml5AtomTable
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
nsHtml5StreamParserPtr
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_intl
.
h
"
#
include
"
mozilla
/
StaticPrefs_html5
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsHtml5Highlighter
.
h
"
#
include
"
expat_config
.
h
"
#
include
"
expat
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DebuggerUtilsBinding
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsHtml5StreamParser
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsHtml5StreamParser
)
NS_INTERFACE_TABLE_HEAD
(
nsHtml5StreamParser
)
NS_INTERFACE_TABLE
(
nsHtml5StreamParser
nsISupports
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
nsHtml5StreamParser
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsHtml5StreamParser
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsHtml5StreamParser
)
tmp
-
>
DropTimer
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOwner
)
tmp
-
>
mExecutorFlusher
=
nullptr
;
tmp
-
>
mLoadFlusher
=
nullptr
;
tmp
-
>
mExecutor
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsHtml5StreamParser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRequest
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOwner
)
if
(
tmp
-
>
mExecutorFlusher
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mExecutorFlusher
-
>
mExecutor
"
)
;
cb
.
NoteXPCOMChild
(
static_cast
<
nsIContentSink
*
>
(
tmp
-
>
mExecutor
)
)
;
}
if
(
tmp
-
>
mLoadFlusher
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mLoadFlusher
-
>
mExecutor
"
)
;
cb
.
NoteXPCOMChild
(
static_cast
<
nsIContentSink
*
>
(
tmp
-
>
mExecutor
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
class
nsHtml5ExecutorFlusher
:
public
Runnable
{
private
:
RefPtr
<
nsHtml5TreeOpExecutor
>
mExecutor
;
public
:
explicit
nsHtml5ExecutorFlusher
(
nsHtml5TreeOpExecutor
*
aExecutor
)
:
Runnable
(
"
nsHtml5ExecutorFlusher
"
)
mExecutor
(
aExecutor
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
mExecutor
-
>
isInList
(
)
)
{
Document
*
doc
=
mExecutor
-
>
GetDocument
(
)
;
if
(
XRE_IsContentProcess
(
)
&
&
nsContentUtils
:
:
HighPriorityEventPendingForTopLevelDocumentBeforeContentfulPaint
(
doc
)
)
{
nsCOMPtr
<
nsIRunnable
>
flusher
=
this
;
if
(
NS_SUCCEEDED
(
doc
-
>
Dispatch
(
TaskCategory
:
:
Network
flusher
.
forget
(
)
)
)
)
{
PROFILER_ADD_MARKER
(
"
HighPrio
blocking
parser
flushing
(
1
)
"
DOM
)
;
return
NS_OK
;
}
}
mExecutor
-
>
RunFlushLoop
(
)
;
}
return
NS_OK
;
}
}
;
class
nsHtml5LoadFlusher
:
public
Runnable
{
private
:
RefPtr
<
nsHtml5TreeOpExecutor
>
mExecutor
;
public
:
explicit
nsHtml5LoadFlusher
(
nsHtml5TreeOpExecutor
*
aExecutor
)
:
Runnable
(
"
nsHtml5LoadFlusher
"
)
mExecutor
(
aExecutor
)
{
}
NS_IMETHOD
Run
(
)
override
{
mExecutor
-
>
FlushSpeculativeLoads
(
)
;
return
NS_OK
;
}
}
;
nsHtml5StreamParser
:
:
nsHtml5StreamParser
(
nsHtml5TreeOpExecutor
*
aExecutor
nsHtml5Parser
*
aOwner
eParserMode
aMode
)
:
mSniffingLength
(
0
)
mBomState
(
eBomState
:
:
BOM_SNIFFING_NOT_STARTED
)
mCharsetSource
(
kCharsetUninitialized
)
mEncoding
(
WINDOWS_1252_ENCODING
)
mFeedChardet
(
true
)
mGuessEncoding
(
true
)
mReparseForbidden
(
false
)
mLastBuffer
(
nullptr
)
mExecutor
(
aExecutor
)
mTreeBuilder
(
new
nsHtml5TreeBuilder
(
(
aMode
=
=
VIEW_SOURCE_HTML
|
|
aMode
=
=
VIEW_SOURCE_XML
)
?
nullptr
:
mExecutor
-
>
GetStage
(
)
aMode
=
=
NORMAL
?
mExecutor
-
>
GetStage
(
)
:
nullptr
)
)
mTokenizer
(
new
nsHtml5Tokenizer
(
mTreeBuilder
aMode
=
=
VIEW_SOURCE_XML
)
)
mTokenizerMutex
(
"
nsHtml5StreamParser
mTokenizerMutex
"
)
mOwner
(
aOwner
)
mLastWasCR
(
false
)
mStreamState
(
eHtml5StreamState
:
:
STREAM_NOT_STARTED
)
mSpeculating
(
false
)
mAtEOF
(
false
)
mSpeculationMutex
(
"
nsHtml5StreamParser
mSpeculationMutex
"
)
mSpeculationFailureCount
(
0
)
mLocalFileBytesBuffered
(
0
)
mTerminated
(
false
)
mInterrupted
(
false
)
mTerminatedMutex
(
"
nsHtml5StreamParser
mTerminatedMutex
"
)
mEventTarget
(
nsHtml5Module
:
:
GetStreamParserThread
(
)
-
>
SerialEventTarget
(
)
)
mExecutorFlusher
(
new
nsHtml5ExecutorFlusher
(
aExecutor
)
)
mLoadFlusher
(
new
nsHtml5LoadFlusher
(
aExecutor
)
)
mJapaneseDetector
(
mozilla
:
:
JapaneseDetector
:
:
Create
(
StaticPrefs
:
:
intl_charset_detector_iso2022jp_allowed
(
)
)
)
mUseJapaneseDetector
(
false
)
mInitialEncodingWasFromParentFrame
(
false
)
mHasHadErrors
(
false
)
mDecodingLocalFileWithoutTokenizing
(
false
)
mFlushTimer
(
NS_NewTimer
(
mEventTarget
)
)
mFlushTimerMutex
(
"
nsHtml5StreamParser
mFlushTimerMutex
"
)
mFlushTimerArmed
(
false
)
mFlushTimerEverFired
(
false
)
mMode
(
aMode
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
#
ifdef
DEBUG
mAtomTable
.
SetPermittedLookupEventTarget
(
mEventTarget
)
;
#
endif
mTokenizer
-
>
setInterner
(
&
mAtomTable
)
;
mTokenizer
-
>
setEncodingDeclarationHandler
(
this
)
;
if
(
aMode
=
=
VIEW_SOURCE_HTML
|
|
aMode
=
=
VIEW_SOURCE_XML
)
{
nsHtml5Highlighter
*
highlighter
=
new
nsHtml5Highlighter
(
mExecutor
-
>
GetStage
(
)
)
;
mTokenizer
-
>
EnableViewSource
(
highlighter
)
;
mTreeBuilder
-
>
EnableViewSource
(
highlighter
)
;
}
}
nsHtml5StreamParser
:
:
~
nsHtml5StreamParser
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mTokenizer
-
>
end
(
)
;
#
ifdef
DEBUG
{
mozilla
:
:
MutexAutoLock
flushTimerLock
(
mFlushTimerMutex
)
;
MOZ_ASSERT
(
!
mFlushTimer
"
Flush
timer
was
not
dropped
before
dtor
!
"
)
;
}
mRequest
=
nullptr
;
mObserver
=
nullptr
;
mUnicodeDecoder
=
nullptr
;
mSniffingBuffer
=
nullptr
;
mMetaScanner
=
nullptr
;
mFirstBuffer
=
nullptr
;
mExecutor
=
nullptr
;
mTreeBuilder
=
nullptr
;
mTokenizer
=
nullptr
;
mOwner
=
nullptr
;
#
endif
}
nsresult
nsHtml5StreamParser
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
return
mRequest
?
CallQueryInterface
(
mRequest
aChannel
)
:
NS_ERROR_NOT_AVAILABLE
;
}
void
nsHtml5StreamParser
:
:
GuessEncoding
(
bool
aEof
bool
aInitial
)
{
if
(
mUseJapaneseDetector
)
{
return
;
}
if
(
!
aInitial
)
{
mGuessEncoding
=
false
;
}
auto
encoding
=
mDetector
-
>
Guess
(
mTLD
mDecodingLocalFileWithoutTokenizing
)
;
if
(
HasDecoder
(
)
&
&
!
mDecodingLocalFileWithoutTokenizing
)
{
if
(
mEncoding
=
=
encoding
)
{
auto
source
=
aInitial
?
kCharsetFromInitialAutoDetection
:
kCharsetFromFinalAutoDetection
;
MOZ_ASSERT
(
mCharsetSource
<
source
"
Why
are
we
running
chardet
at
all
?
"
)
;
mCharsetSource
=
source
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
else
{
MOZ_ASSERT
(
mCharsetSource
<
kCharsetFromFinalAutoDetection
)
;
mTreeBuilder
-
>
NeedsCharsetSwitchTo
(
encoding
kCharsetFromFinalAutoDetection
0
)
;
FlushTreeOpsAndDisarmTimer
(
)
;
Interrupt
(
)
;
}
}
else
{
mEncoding
=
encoding
;
mCharsetSource
=
aInitial
?
kCharsetFromInitialAutoDetection
:
kCharsetFromFinalAutoDetection
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
}
void
nsHtml5StreamParser
:
:
FeedJapaneseDetector
(
Span
<
const
uint8_t
>
aBuffer
bool
aLast
)
{
MOZ_ASSERT
(
!
mDecodingLocalFileWithoutTokenizing
)
;
const
Encoding
*
detected
=
mJapaneseDetector
-
>
Feed
(
aBuffer
aLast
)
;
if
(
!
detected
)
{
return
;
}
DontGuessEncoding
(
)
;
int32_t
source
=
kCharsetFromFinalAutoDetection
;
if
(
mCharsetSource
=
=
kCharsetFromParentForced
|
|
mCharsetSource
=
=
kCharsetFromUserForced
)
{
source
=
kCharsetFromUserForcedAutoDetection
;
}
if
(
detected
=
=
mEncoding
)
{
MOZ_ASSERT
(
mCharsetSource
<
source
"
Why
are
we
running
chardet
at
all
?
"
)
;
mCharsetSource
=
source
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
else
if
(
HasDecoder
(
)
)
{
mTreeBuilder
-
>
NeedsCharsetSwitchTo
(
WrapNotNull
(
detected
)
source
0
)
;
FlushTreeOpsAndDisarmTimer
(
)
;
Interrupt
(
)
;
}
else
{
mEncoding
=
WrapNotNull
(
detected
)
;
mCharsetSource
=
source
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
}
void
nsHtml5StreamParser
:
:
FeedDetector
(
Span
<
const
uint8_t
>
aBuffer
bool
aLast
)
{
if
(
mUseJapaneseDetector
)
{
FeedJapaneseDetector
(
aBuffer
aLast
)
;
}
else
{
Unused
<
<
mDetector
-
>
Feed
(
aBuffer
aLast
)
;
}
}
void
nsHtml5StreamParser
:
:
SetViewSourceTitle
(
nsIURI
*
aURL
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsIDocShell
*
docshell
=
mExecutor
-
>
GetDocument
(
)
-
>
GetDocShell
(
)
;
if
(
docshell
&
&
docshell
-
>
GetWatchedByDevtools
(
)
)
{
mURIToSendToDevtools
=
aURL
;
nsID
uuid
;
nsresult
rv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
!
NS_FAILED
(
rv
)
)
{
char
buffer
[
NSID_LENGTH
]
;
uuid
.
ToProvidedString
(
buffer
)
;
mUUIDForDevtools
=
NS_ConvertASCIItoUTF16
(
buffer
)
;
}
}
if
(
aURL
)
{
nsCOMPtr
<
nsIURI
>
temp
;
if
(
aURL
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
nsCOMPtr
<
nsINestedURI
>
nested
=
do_QueryInterface
(
aURL
)
;
nested
-
>
GetInnerURI
(
getter_AddRefs
(
temp
)
)
;
}
else
{
temp
=
aURL
;
}
if
(
temp
-
>
SchemeIs
(
"
data
"
)
)
{
mViewSourceTitle
.
AssignLiteral
(
"
data
:
\
xE2
\
x80
\
xA6
"
)
;
}
else
{
nsresult
rv
=
temp
-
>
GetSpec
(
mViewSourceTitle
)
;
if
(
NS_FAILED
(
rv
)
)
{
mViewSourceTitle
.
AssignLiteral
(
"
\
xE2
\
x80
\
xA6
"
)
;
}
}
}
}
nsresult
nsHtml5StreamParser
:
:
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
Span
<
const
uint8_t
>
aFromSegment
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mDecodingLocalFileWithoutTokenizing
&
&
mCharsetSource
<
=
kCharsetFromFileURLGuess
)
{
MOZ_ASSERT
(
mEncoding
!
=
UTF_8_ENCODING
)
;
mUnicodeDecoder
=
UTF_8_ENCODING
-
>
NewDecoderWithBOMRemoval
(
)
;
}
else
{
if
(
mCharsetSource
>
=
kCharsetFromFinalAutoDetection
)
{
if
(
!
(
mCharsetSource
=
=
kCharsetFromUserForced
|
|
mCharsetSource
=
=
kCharsetFromParentForced
)
)
{
DontGuessEncoding
(
)
;
}
mDecodingLocalFileWithoutTokenizing
=
false
;
}
mUnicodeDecoder
=
mEncoding
-
>
NewDecoderWithBOMRemoval
(
)
;
}
if
(
mSniffingBuffer
)
{
rv
=
WriteStreamBytes
(
MakeSpan
(
mSniffingBuffer
.
get
(
)
mSniffingLength
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSniffingBuffer
=
nullptr
;
}
mMetaScanner
=
nullptr
;
return
WriteStreamBytes
(
aFromSegment
)
;
}
nsresult
nsHtml5StreamParser
:
:
SetupDecodingFromBom
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mEncoding
=
aEncoding
;
mDecodingLocalFileWithoutTokenizing
=
false
;
mUnicodeDecoder
=
mEncoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
mCharsetSource
=
kCharsetFromByteOrderMark
;
DontGuessEncoding
(
)
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
mSniffingBuffer
=
nullptr
;
mMetaScanner
=
nullptr
;
mBomState
=
BOM_SNIFFING_OVER
;
return
NS_OK
;
}
void
nsHtml5StreamParser
:
:
SniffBOMlessUTF16BasicLatin
(
Span
<
const
uint8_t
>
aFromSegment
)
{
if
(
mMode
=
=
LOAD_AS_DATA
)
{
return
;
}
if
(
mSniffingLength
+
aFromSegment
.
Length
(
)
<
30
)
{
return
;
}
bool
byteZero
[
2
]
=
{
false
false
}
;
bool
byteNonZero
[
2
]
=
{
false
false
}
;
uint32_t
i
=
0
;
if
(
mSniffingBuffer
)
{
for
(
;
i
<
mSniffingLength
;
+
+
i
)
{
if
(
mSniffingBuffer
[
i
]
)
{
if
(
byteNonZero
[
1
-
(
i
%
2
)
]
)
{
return
;
}
byteNonZero
[
i
%
2
]
=
true
;
}
else
{
if
(
byteZero
[
1
-
(
i
%
2
)
]
)
{
return
;
}
byteZero
[
i
%
2
]
=
true
;
}
}
}
for
(
size_t
j
=
0
;
j
<
aFromSegment
.
Length
(
)
;
+
+
j
)
{
if
(
aFromSegment
[
j
]
)
{
if
(
byteNonZero
[
1
-
(
(
i
+
j
)
%
2
)
]
)
{
return
;
}
byteNonZero
[
(
i
+
j
)
%
2
]
=
true
;
}
else
{
if
(
byteZero
[
1
-
(
(
i
+
j
)
%
2
)
]
)
{
return
;
}
byteZero
[
(
i
+
j
)
%
2
]
=
true
;
}
}
if
(
byteNonZero
[
0
]
)
{
mEncoding
=
UTF_16LE_ENCODING
;
}
else
{
mEncoding
=
UTF_16BE_ENCODING
;
}
mCharsetSource
=
kCharsetFromIrreversibleAutoDetection
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
DontGuessEncoding
(
)
;
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncBomlessUtf16
"
true
0
)
;
}
void
nsHtml5StreamParser
:
:
SetEncodingFromExpat
(
const
char16_t
*
aEncoding
)
{
if
(
aEncoding
)
{
nsDependentString
utf16
(
aEncoding
)
;
nsAutoCString
utf8
;
CopyUTF16toUTF8
(
utf16
utf8
)
;
auto
encoding
=
PreferredForInternalEncodingDecl
(
utf8
)
;
if
(
encoding
)
{
mEncoding
=
WrapNotNull
(
encoding
)
;
mCharsetSource
=
kCharsetFromMetaTag
;
return
;
}
}
mEncoding
=
UTF_8_ENCODING
;
mCharsetSource
=
kCharsetFromMetaTag
;
}
struct
UserData
{
XML_Parser
mExpat
;
nsHtml5StreamParser
*
mStreamParser
;
}
;
static
void
HandleXMLDeclaration
(
void
*
aUserData
const
XML_Char
*
aVersion
const
XML_Char
*
aEncoding
int
aStandalone
)
{
UserData
*
ud
=
static_cast
<
UserData
*
>
(
aUserData
)
;
ud
-
>
mStreamParser
-
>
SetEncodingFromExpat
(
reinterpret_cast
<
const
char16_t
*
>
(
aEncoding
)
)
;
XML_StopParser
(
ud
-
>
mExpat
false
)
;
}
static
void
HandleStartElement
(
void
*
aUserData
const
XML_Char
*
aName
const
XML_Char
*
*
aAtts
)
{
UserData
*
ud
=
static_cast
<
UserData
*
>
(
aUserData
)
;
XML_StopParser
(
ud
-
>
mExpat
false
)
;
}
static
void
HandleEndElement
(
void
*
aUserData
const
XML_Char
*
aName
)
{
UserData
*
ud
=
static_cast
<
UserData
*
>
(
aUserData
)
;
XML_StopParser
(
ud
-
>
mExpat
false
)
;
}
static
void
HandleComment
(
void
*
aUserData
const
XML_Char
*
aName
)
{
UserData
*
ud
=
static_cast
<
UserData
*
>
(
aUserData
)
;
XML_StopParser
(
ud
-
>
mExpat
false
)
;
}
static
void
HandleProcessingInstruction
(
void
*
aUserData
const
XML_Char
*
aTarget
const
XML_Char
*
aData
)
{
UserData
*
ud
=
static_cast
<
UserData
*
>
(
aUserData
)
;
XML_StopParser
(
ud
-
>
mExpat
false
)
;
}
void
nsHtml5StreamParser
:
:
FinalizeSniffingWithDetector
(
Span
<
const
uint8_t
>
aFromSegment
uint32_t
aCountToSniffingLimit
bool
aEof
)
{
if
(
mSniffingBuffer
)
{
FeedDetector
(
MakeSpan
(
mSniffingBuffer
.
get
(
)
mSniffingLength
)
false
)
;
}
if
(
mFeedChardet
&
&
!
aFromSegment
.
IsEmpty
(
)
)
{
FeedDetector
(
aFromSegment
.
To
(
aCountToSniffingLimit
)
false
)
;
}
bool
guess
=
mFeedChardet
;
if
(
mFeedChardet
&
&
aEof
&
&
aCountToSniffingLimit
<
=
aFromSegment
.
Length
(
)
)
{
FeedDetector
(
Span
<
const
uint8_t
>
(
)
true
)
;
mFeedChardet
=
false
;
}
if
(
guess
)
{
GuessEncoding
(
aEof
(
guess
=
=
mFeedChardet
)
)
;
}
if
(
mReparseForbidden
)
{
DontGuessEncoding
(
)
;
}
if
(
mFeedChardet
&
&
!
aEof
&
&
aCountToSniffingLimit
<
aFromSegment
.
Length
(
)
)
{
FeedDetector
(
aFromSegment
.
From
(
aCountToSniffingLimit
)
false
)
;
}
}
nsresult
nsHtml5StreamParser
:
:
FinalizeSniffing
(
Span
<
const
uint8_t
>
aFromSegment
uint32_t
aCountToSniffingLimit
bool
aEof
)
{
MOZ_ASSERT
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
MOZ_ASSERT
(
mCharsetSource
<
kCharsetFromUserForcedAutoDetection
"
Should
not
finalize
sniffing
with
strong
decision
already
made
.
"
)
;
if
(
mMode
=
=
VIEW_SOURCE_XML
)
{
static
const
XML_Memory_Handling_Suite
memsuite
=
{
(
void
*
(
*
)
(
size_t
)
)
moz_xmalloc
(
void
*
(
*
)
(
void
*
size_t
)
)
moz_xrealloc
free
}
;
static
const
char16_t
kExpatSeparator
[
]
=
{
0xFFFF
'
\
0
'
}
;
static
const
char16_t
kISO88591
[
]
=
{
'
I
'
'
S
'
'
O
'
'
-
'
'
8
'
'
8
'
'
5
'
'
9
'
'
-
'
'
1
'
'
\
0
'
}
;
UserData
ud
;
ud
.
mStreamParser
=
this
;
ud
.
mExpat
=
XML_ParserCreate_MM
(
kISO88591
&
memsuite
kExpatSeparator
)
;
XML_SetXmlDeclHandler
(
ud
.
mExpat
HandleXMLDeclaration
)
;
XML_SetElementHandler
(
ud
.
mExpat
HandleStartElement
HandleEndElement
)
;
XML_SetCommentHandler
(
ud
.
mExpat
HandleComment
)
;
XML_SetProcessingInstructionHandler
(
ud
.
mExpat
HandleProcessingInstruction
)
;
XML_SetUserData
(
ud
.
mExpat
static_cast
<
void
*
>
(
&
ud
)
)
;
XML_Status
status
=
XML_STATUS_OK
;
if
(
mSniffingBuffer
)
{
status
=
XML_Parse
(
ud
.
mExpat
reinterpret_cast
<
const
char
*
>
(
mSniffingBuffer
.
get
(
)
)
mSniffingLength
false
)
;
}
if
(
status
=
=
XML_STATUS_OK
&
&
mCharsetSource
<
kCharsetFromMetaTag
)
{
mozilla
:
:
Unused
<
<
XML_Parse
(
ud
.
mExpat
reinterpret_cast
<
const
char
*
>
(
aFromSegment
.
Elements
(
)
)
aCountToSniffingLimit
false
)
;
}
XML_ParserFree
(
ud
.
mExpat
)
;
if
(
mCharsetSource
<
kCharsetFromMetaTag
)
{
mEncoding
=
UTF_8_ENCODING
;
mCharsetSource
=
kCharsetFromMetaTag
;
}
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
if
(
mCharsetSource
<
kCharsetFromMetaPrescan
)
{
SniffBOMlessUTF16BasicLatin
(
aFromSegment
.
To
(
aCountToSniffingLimit
)
)
;
}
if
(
mFeedChardet
)
{
FinalizeSniffingWithDetector
(
aFromSegment
aCountToSniffingLimit
aEof
)
;
}
if
(
mCharsetSource
=
=
kCharsetUninitialized
)
{
mEncoding
=
WINDOWS_1252_ENCODING
;
mCharsetSource
=
kCharsetFromFallback
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
else
if
(
mMode
=
=
LOAD_AS_DATA
&
&
mCharsetSource
=
=
kCharsetFromFallback
)
{
NS_ASSERTION
(
mReparseForbidden
"
Reparse
should
be
forbidden
for
XHR
"
)
;
NS_ASSERTION
(
!
mFeedChardet
"
Should
not
feed
chardet
for
XHR
"
)
;
NS_ASSERTION
(
mEncoding
=
=
UTF_8_ENCODING
"
XHR
should
default
to
UTF
-
8
"
)
;
mCharsetSource
=
kCharsetFromDocTypeDefault
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
}
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
nsresult
nsHtml5StreamParser
:
:
SniffStreamBytes
(
Span
<
const
uint8_t
>
aFromSegment
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
nsresult
rv
=
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
aFromSegment
.
Length
(
)
&
&
mBomState
!
=
BOM_SNIFFING_OVER
;
i
+
+
)
{
switch
(
mBomState
)
{
case
BOM_SNIFFING_NOT_STARTED
:
NS_ASSERTION
(
i
=
=
0
"
Bad
BOM
sniffing
state
.
"
)
;
switch
(
aFromSegment
[
0
]
)
{
case
0xEF
:
mBomState
=
SEEN_UTF_8_FIRST_BYTE
;
break
;
case
0xFF
:
mBomState
=
SEEN_UTF_16_LE_FIRST_BYTE
;
break
;
case
0xFE
:
mBomState
=
SEEN_UTF_16_BE_FIRST_BYTE
;
break
;
default
:
mBomState
=
BOM_SNIFFING_OVER
;
break
;
}
break
;
case
SEEN_UTF_16_LE_FIRST_BYTE
:
if
(
aFromSegment
[
i
]
=
=
0xFE
)
{
rv
=
SetupDecodingFromBom
(
UTF_16LE_ENCODING
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WriteStreamBytes
(
aFromSegment
.
From
(
i
+
1
)
)
;
}
mBomState
=
BOM_SNIFFING_OVER
;
break
;
case
SEEN_UTF_16_BE_FIRST_BYTE
:
if
(
aFromSegment
[
i
]
=
=
0xFF
)
{
rv
=
SetupDecodingFromBom
(
UTF_16BE_ENCODING
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WriteStreamBytes
(
aFromSegment
.
From
(
i
+
1
)
)
;
}
mBomState
=
BOM_SNIFFING_OVER
;
break
;
case
SEEN_UTF_8_FIRST_BYTE
:
if
(
aFromSegment
[
i
]
=
=
0xBB
)
{
mBomState
=
SEEN_UTF_8_SECOND_BYTE
;
}
else
{
mBomState
=
BOM_SNIFFING_OVER
;
}
break
;
case
SEEN_UTF_8_SECOND_BYTE
:
if
(
aFromSegment
[
i
]
=
=
0xBF
)
{
rv
=
SetupDecodingFromBom
(
UTF_8_ENCODING
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WriteStreamBytes
(
aFromSegment
.
From
(
i
+
1
)
)
;
}
mBomState
=
BOM_SNIFFING_OVER
;
break
;
default
:
mBomState
=
BOM_SNIFFING_OVER
;
break
;
}
}
MOZ_ASSERT
(
mCharsetSource
!
=
kCharsetFromByteOrderMark
"
Should
not
come
here
if
BOM
was
found
.
"
)
;
MOZ_ASSERT
(
mCharsetSource
!
=
kCharsetFromOtherComponent
"
kCharsetFromOtherComponent
is
for
XSLT
.
"
)
;
if
(
mBomState
=
=
BOM_SNIFFING_OVER
&
&
mCharsetSource
=
=
kCharsetFromChannel
)
{
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
if
(
!
mMetaScanner
&
&
(
mMode
=
=
NORMAL
|
|
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
LOAD_AS_DATA
)
)
{
mMetaScanner
=
new
nsHtml5MetaScanner
(
mTreeBuilder
)
;
}
if
(
mSniffingLength
+
aFromSegment
.
Length
(
)
>
=
SNIFFING_BUFFER_SIZE
)
{
uint32_t
countToSniffingLimit
=
SNIFFING_BUFFER_SIZE
-
mSniffingLength
;
if
(
mMode
=
=
NORMAL
|
|
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
LOAD_AS_DATA
)
{
nsHtml5ByteReadable
readable
(
aFromSegment
.
Elements
(
)
aFromSegment
.
Elements
(
)
+
countToSniffingLimit
)
;
nsAutoCString
charset
;
auto
encoding
=
mMetaScanner
-
>
sniff
(
&
readable
)
;
nsresult
rv
;
if
(
NS_FAILED
(
(
rv
=
mTreeBuilder
-
>
IsBroken
(
)
)
)
)
{
MarkAsBroken
(
rv
)
;
return
rv
;
}
if
(
encoding
)
{
if
(
(
mCharsetSource
=
=
kCharsetFromParentForced
|
|
mCharsetSource
=
=
kCharsetFromUserForced
)
&
&
(
encoding
-
>
IsAsciiCompatible
(
)
|
|
encoding
=
=
ISO_2022_JP_ENCODING
)
)
{
if
(
mEncoding
-
>
IsJapaneseLegacy
(
)
)
{
mFeedChardet
=
true
;
mUseJapaneseDetector
=
true
;
FinalizeSniffingWithDetector
(
aFromSegment
countToSniffingLimit
false
)
;
}
else
{
DontGuessEncoding
(
)
;
}
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
mEncoding
=
WrapNotNull
(
encoding
)
;
mCharsetSource
=
kCharsetFromMetaPrescan
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
}
if
(
mCharsetSource
=
=
kCharsetFromParentForced
|
|
mCharsetSource
=
=
kCharsetFromUserForced
)
{
if
(
mEncoding
-
>
IsJapaneseLegacy
(
)
)
{
mFeedChardet
=
true
;
mUseJapaneseDetector
=
true
;
FinalizeSniffingWithDetector
(
aFromSegment
countToSniffingLimit
false
)
;
}
else
{
DontGuessEncoding
(
)
;
}
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
return
FinalizeSniffing
(
aFromSegment
countToSniffingLimit
false
)
;
}
if
(
mMode
=
=
NORMAL
|
|
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
LOAD_AS_DATA
)
{
nsHtml5ByteReadable
readable
(
aFromSegment
.
Elements
(
)
aFromSegment
.
Elements
(
)
+
aFromSegment
.
Length
(
)
)
;
auto
encoding
=
mMetaScanner
-
>
sniff
(
&
readable
)
;
nsresult
rv
;
if
(
NS_FAILED
(
(
rv
=
mTreeBuilder
-
>
IsBroken
(
)
)
)
)
{
MarkAsBroken
(
rv
)
;
return
rv
;
}
if
(
encoding
)
{
if
(
(
mCharsetSource
=
=
kCharsetFromParentForced
|
|
mCharsetSource
=
=
kCharsetFromUserForced
)
&
&
(
encoding
-
>
IsAsciiCompatible
(
)
|
|
encoding
=
=
ISO_2022_JP_ENCODING
)
)
{
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
mEncoding
=
WrapNotNull
(
encoding
)
;
mCharsetSource
=
kCharsetFromMetaPrescan
;
mTreeBuilder
-
>
SetDocumentCharset
(
mEncoding
mCharsetSource
)
;
return
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
aFromSegment
)
;
}
}
if
(
!
mSniffingBuffer
)
{
mSniffingBuffer
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
SNIFFING_BUFFER_SIZE
)
;
if
(
!
mSniffingBuffer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
memcpy
(
&
mSniffingBuffer
[
mSniffingLength
]
aFromSegment
.
Elements
(
)
aFromSegment
.
Length
(
)
)
;
mSniffingLength
+
=
aFromSegment
.
Length
(
)
;
return
NS_OK
;
}
class
AddContentRunnable
:
public
Runnable
{
public
:
AddContentRunnable
(
const
nsAString
&
aParserID
nsIURI
*
aURI
Span
<
const
char16_t
>
aData
bool
aComplete
)
:
Runnable
(
"
AddContent
"
)
{
nsAutoCString
spec
;
aURI
-
>
GetSpec
(
spec
)
;
mData
.
mUri
.
Construct
(
NS_ConvertUTF8toUTF16
(
spec
)
)
;
mData
.
mParserID
.
Construct
(
aParserID
)
;
mData
.
mContents
.
Construct
(
aData
.
Elements
(
)
aData
.
Length
(
)
)
;
mData
.
mComplete
.
Construct
(
aComplete
)
;
}
NS_IMETHOD
Run
(
)
override
{
nsAutoString
json
;
if
(
!
mData
.
ToJSON
(
json
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
devtools
-
html
-
content
"
PromiseFlatString
(
json
)
.
get
(
)
)
;
}
return
NS_OK
;
}
HTMLContent
mData
;
}
;
inline
void
nsHtml5StreamParser
:
:
OnNewContent
(
Span
<
const
char16_t
>
aData
)
{
if
(
mURIToSendToDevtools
)
{
NS_DispatchToMainThread
(
new
AddContentRunnable
(
mUUIDForDevtools
mURIToSendToDevtools
aData
false
)
)
;
}
}
inline
void
nsHtml5StreamParser
:
:
OnContentComplete
(
)
{
if
(
mURIToSendToDevtools
)
{
NS_DispatchToMainThread
(
new
AddContentRunnable
(
mUUIDForDevtools
mURIToSendToDevtools
Span
<
const
char16_t
>
(
)
true
)
)
;
mURIToSendToDevtools
=
nullptr
;
}
}
nsresult
nsHtml5StreamParser
:
:
WriteStreamBytes
(
Span
<
const
uint8_t
>
aFromSegment
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
if
(
!
mLastBuffer
)
{
NS_WARNING
(
"
mLastBuffer
should
not
be
null
!
"
)
;
MarkAsBroken
(
NS_ERROR_NULL_POINTER
)
;
return
NS_ERROR_NULL_POINTER
;
}
size_t
totalRead
=
0
;
auto
src
=
aFromSegment
;
for
(
;
;
)
{
auto
dst
=
mLastBuffer
-
>
TailAsSpan
(
READ_BUFFER_SIZE
)
;
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
Tie
(
result
read
written
hadErrors
)
=
mUnicodeDecoder
-
>
DecodeToUTF16
(
src
dst
false
)
;
if
(
!
mDecodingLocalFileWithoutTokenizing
)
{
OnNewContent
(
dst
.
To
(
written
)
)
;
}
if
(
hadErrors
&
&
!
mHasHadErrors
)
{
mHasHadErrors
=
true
;
if
(
mEncoding
=
=
UTF_8_ENCODING
)
{
mTreeBuilder
-
>
TryToEnableEncodingMenu
(
)
;
}
}
src
=
src
.
From
(
read
)
;
totalRead
+
=
read
;
mLastBuffer
-
>
AdvanceEnd
(
written
)
;
if
(
result
=
=
kOutputFull
)
{
RefPtr
<
nsHtml5OwningUTF16Buffer
>
newBuf
=
nsHtml5OwningUTF16Buffer
:
:
FalliblyCreate
(
READ_BUFFER_SIZE
)
;
if
(
!
newBuf
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
mLastBuffer
=
(
mLastBuffer
-
>
next
=
newBuf
.
forget
(
)
)
;
}
else
{
MOZ_ASSERT
(
totalRead
=
=
aFromSegment
.
Length
(
)
"
The
Unicode
decoder
consumed
the
wrong
number
of
bytes
.
"
)
;
if
(
mDecodingLocalFileWithoutTokenizing
&
&
mLocalFileBytesBuffered
=
=
LOCAL_FILE_UTF_8_BUFFER_SIZE
)
{
auto
encoding
=
mEncoding
;
GuessEncoding
(
false
false
)
;
if
(
encoding
=
=
mEncoding
)
{
CommitLocalFileToEncoding
(
)
;
}
else
{
ReDecodeLocalFile
(
)
;
}
}
return
NS_OK
;
}
}
}
void
nsHtml5StreamParser
:
:
ReDecodeLocalFile
(
)
{
MOZ_ASSERT
(
mDecodingLocalFileWithoutTokenizing
)
;
mDecodingLocalFileWithoutTokenizing
=
false
;
mUnicodeDecoder
=
mEncoding
-
>
NewDecoderWithBOMRemoval
(
)
;
mHasHadErrors
=
false
;
DontGuessEncoding
(
)
;
mLastBuffer
=
mFirstBuffer
;
mLastBuffer
-
>
next
=
nullptr
;
mLastBuffer
-
>
setStart
(
0
)
;
mLastBuffer
-
>
setEnd
(
0
)
;
for
(
auto
&
&
buffer
:
mBufferedLocalFileData
)
{
DoDataAvailable
(
buffer
)
;
}
}
void
nsHtml5StreamParser
:
:
CommitLocalFileToEncoding
(
)
{
MOZ_ASSERT
(
mDecodingLocalFileWithoutTokenizing
)
;
mDecodingLocalFileWithoutTokenizing
=
false
;
mFeedChardet
=
false
;
mGuessEncoding
=
false
;
nsHtml5OwningUTF16Buffer
*
buffer
=
mFirstBuffer
;
while
(
buffer
)
{
Span
<
const
char16_t
>
data
(
buffer
-
>
getBuffer
(
)
+
buffer
-
>
getStart
(
)
buffer
-
>
getLength
(
)
)
;
OnNewContent
(
data
)
;
buffer
=
buffer
-
>
next
;
}
}
class
MaybeRunCollector
:
public
Runnable
{
public
:
explicit
MaybeRunCollector
(
nsIDocShell
*
aDocShell
)
:
Runnable
(
"
MaybeRunCollector
"
)
mDocShell
(
aDocShell
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsJSContext
:
:
MaybeRunNextCollectorSlice
(
mDocShell
JS
:
:
GCReason
:
:
HTML_PARSER
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
}
;
nsresult
nsHtml5StreamParser
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
MOZ_RELEASE_ASSERT
(
STREAM_NOT_STARTED
=
=
mStreamState
"
Got
OnStartRequest
when
the
stream
had
already
started
.
"
)
;
MOZ_ASSERT
(
!
mExecutor
-
>
HasStarted
(
)
"
Got
OnStartRequest
at
the
wrong
stage
in
the
executor
life
cycle
.
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
auto
detectorCreator
=
MakeScopeExit
(
[
&
]
{
if
(
mFeedChardet
&
&
!
mUseJapaneseDetector
)
{
mDetector
=
mozilla
:
:
EncodingDetector
:
:
Create
(
)
;
}
}
)
;
if
(
mObserver
)
{
mObserver
-
>
OnStartRequest
(
aRequest
)
;
}
mRequest
=
aRequest
;
mStreamState
=
STREAM_BEING_READ
;
if
(
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
VIEW_SOURCE_XML
)
{
mTokenizer
-
>
StartViewSource
(
NS_ConvertUTF8toUTF16
(
mViewSourceTitle
)
)
;
}
bool
scriptingEnabled
=
mMode
=
=
LOAD_AS_DATA
?
false
:
mExecutor
-
>
IsScriptEnabled
(
)
;
mOwner
-
>
StartTokenizer
(
scriptingEnabled
)
;
MOZ_ASSERT
(
!
mDecodingLocalFileWithoutTokenizing
)
;
bool
isSrcdoc
=
false
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
GetChannel
(
getter_AddRefs
(
channel
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
isSrcdoc
=
NS_IsSrcdocChannel
(
channel
)
;
if
(
!
isSrcdoc
&
&
mCharsetSource
<
=
kCharsetFromFileURLGuess
)
{
nsCOMPtr
<
nsIURI
>
originalURI
;
rv
=
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
originalURI
-
>
SchemeIs
(
"
resource
"
)
)
{
mCharsetSource
=
kCharsetFromBuiltIn
;
mEncoding
=
UTF_8_ENCODING
;
}
else
{
nsCOMPtr
<
nsIURI
>
currentURI
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
currentURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIURI
>
innermost
=
NS_GetInnermostURI
(
currentURI
)
;
if
(
innermost
-
>
SchemeIs
(
"
file
"
)
)
{
mDecodingLocalFileWithoutTokenizing
=
true
;
}
else
{
nsAutoCString
host
;
innermost
-
>
GetAsciiHost
(
host
)
;
if
(
!
host
.
IsEmpty
(
)
)
{
if
(
host
.
Last
(
)
=
=
'
.
'
)
{
host
.
SetLength
(
host
.
Length
(
)
-
1
)
;
}
int32_t
index
=
host
.
RFindChar
(
'
.
'
)
;
if
(
index
!
=
kNotFound
)
{
ToLowerCase
(
Substring
(
host
index
+
1
host
.
Length
(
)
-
(
index
+
1
)
)
mTLD
)
;
}
}
}
}
}
}
}
}
mTreeBuilder
-
>
setIsSrcdocDocument
(
isSrcdoc
)
;
mTreeBuilder
-
>
setScriptingEnabled
(
scriptingEnabled
)
;
mTreeBuilder
-
>
SetPreventScriptExecution
(
!
(
(
mMode
=
=
NORMAL
)
&
&
scriptingEnabled
)
)
;
mTokenizer
-
>
start
(
)
;
mExecutor
-
>
Start
(
)
;
mExecutor
-
>
StartReadingFromStage
(
)
;
if
(
mMode
=
=
PLAIN_TEXT
)
{
mTreeBuilder
-
>
StartPlainText
(
)
;
mTokenizer
-
>
StartPlainText
(
)
;
}
else
if
(
mMode
=
=
VIEW_SOURCE_PLAIN
)
{
nsAutoString
viewSourceTitle
;
CopyUTF8toUTF16
(
mViewSourceTitle
viewSourceTitle
)
;
mTreeBuilder
-
>
EnsureBufferSpace
(
viewSourceTitle
.
Length
(
)
)
;
mTreeBuilder
-
>
StartPlainTextViewSource
(
viewSourceTitle
)
;
mTokenizer
-
>
StartPlainText
(
)
;
}
rv
=
mExecutor
-
>
WillBuildModel
(
eDTDMode_unknown
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsHtml5OwningUTF16Buffer
>
newBuf
=
nsHtml5OwningUTF16Buffer
:
:
FalliblyCreate
(
READ_BUFFER_SIZE
)
;
if
(
!
newBuf
)
{
return
mExecutor
-
>
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
MOZ_ASSERT
(
!
mFirstBuffer
"
How
come
we
have
the
first
buffer
set
?
"
)
;
MOZ_ASSERT
(
!
mLastBuffer
"
How
come
we
have
the
last
buffer
set
?
"
)
;
mFirstBuffer
=
mLastBuffer
=
newBuf
;
rv
=
NS_OK
;
mReparseForbidden
=
!
(
mMode
=
=
NORMAL
|
|
mMode
=
=
PLAIN_TEXT
)
;
mDocGroup
=
mExecutor
-
>
GetDocument
(
)
-
>
GetDocGroup
(
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mRequest
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
mDocGroup
|
|
mMode
=
=
LOAD_AS_DATA
"
How
come
the
doc
group
is
still
null
?
"
)
;
nsAutoCString
method
;
Unused
<
<
httpChannel
-
>
GetRequestMethod
(
method
)
;
if
(
!
method
.
EqualsLiteral
(
"
GET
"
)
)
{
mReparseForbidden
=
true
;
}
}
nsCOMPtr
<
nsIThreadRetargetableRequest
>
threadRetargetableRequest
=
do_QueryInterface
(
mRequest
&
rv
)
;
if
(
threadRetargetableRequest
)
{
rv
=
threadRetargetableRequest
-
>
RetargetDeliveryTo
(
mEventTarget
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
MaybeRunCollector
(
mExecutor
-
>
GetDocument
(
)
-
>
GetDocShell
(
)
)
;
mozilla
:
:
SystemGroup
:
:
Dispatch
(
mozilla
:
:
TaskCategory
:
:
GarbageCollection
runnable
.
forget
(
)
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
retarget
HTML
data
delivery
to
the
parser
thread
.
"
)
;
}
if
(
mCharsetSource
=
=
kCharsetFromParentFrame
)
{
mInitialEncodingWasFromParentFrame
=
true
;
}
if
(
mCharsetSource
>
=
kCharsetFromFinalAutoDetection
)
{
if
(
(
mCharsetSource
=
=
kCharsetFromParentForced
|
|
mCharsetSource
=
=
kCharsetFromUserForced
)
&
&
mEncoding
-
>
IsJapaneseLegacy
(
)
)
{
mUseJapaneseDetector
=
true
;
mGuessEncoding
=
false
;
}
else
{
DontGuessEncoding
(
)
;
}
}
if
(
!
mDecodingLocalFileWithoutTokenizing
&
&
mFeedChardet
)
{
if
(
StaticPrefs
:
:
intl_charset_detector_ng_enabled
(
)
)
{
if
(
mTLD
.
EqualsLiteral
(
"
jp
"
)
)
{
mUseJapaneseDetector
=
!
StaticPrefs
:
:
intl_charset_detector_ng_jp_enabled
(
)
;
}
else
if
(
mTLD
.
EqualsLiteral
(
"
in
"
)
&
&
mEncoding
=
=
WINDOWS_1252_ENCODING
&
&
!
StaticPrefs
:
:
intl_charset_detector_ng_in_enabled
(
)
)
{
DontGuessEncoding
(
)
;
}
else
if
(
mTLD
.
EqualsLiteral
(
"
lk
"
)
&
&
mEncoding
=
=
WINDOWS_1252_ENCODING
&
&
!
StaticPrefs
:
:
intl_charset_detector_ng_lk_enabled
(
)
)
{
DontGuessEncoding
(
)
;
}
}
else
{
nsAutoCString
detectorName
;
Preferences
:
:
GetLocalizedCString
(
"
intl
.
charset
.
detector
"
detectorName
)
;
bool
forceEncodingDetectorToCyrillicOnly
=
detectorName
.
EqualsLiteral
(
"
ruprob
"
)
|
|
detectorName
.
EqualsLiteral
(
"
ukprob
"
)
;
if
(
mEncoding
-
>
IsJapaneseLegacy
(
)
)
{
mUseJapaneseDetector
=
true
;
}
else
if
(
mEncoding
=
=
WINDOWS_1251_ENCODING
&
&
forceEncodingDetectorToCyrillicOnly
)
{
mTLD
.
AssignLiteral
(
"
ru
"
)
;
}
else
{
DontGuessEncoding
(
)
;
}
}
}
if
(
mCharsetSource
<
kCharsetFromUtf8OnlyMime
)
{
return
NS_OK
;
}
mReparseForbidden
=
true
;
DontGuessEncoding
(
)
;
mDecodingLocalFileWithoutTokenizing
=
false
;
mUnicodeDecoder
=
mEncoding
-
>
NewDecoderWithBOMRemoval
(
)
;
return
NS_OK
;
}
nsresult
nsHtml5StreamParser
:
:
CheckListenerChain
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
!
"
)
;
if
(
!
mObserver
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetable
=
do_QueryInterface
(
mObserver
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
retargetable
)
{
rv
=
retargetable
-
>
CheckListenerChain
(
)
;
}
return
rv
;
}
void
nsHtml5StreamParser
:
:
DoStopRequest
(
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
MOZ_RELEASE_ASSERT
(
STREAM_BEING_READ
=
=
mStreamState
"
Stream
ended
without
being
open
.
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
OnContentComplete
(
)
;
}
)
;
if
(
IsTerminated
(
)
)
{
return
;
}
if
(
!
mUnicodeDecoder
)
{
nsresult
rv
;
Span
<
const
uint8_t
>
empty
;
if
(
NS_FAILED
(
rv
=
FinalizeSniffing
(
empty
0
true
)
)
)
{
MarkAsBroken
(
rv
)
;
return
;
}
}
if
(
mFeedChardet
)
{
mFeedChardet
=
false
;
FeedDetector
(
Span
<
uint8_t
>
(
)
true
)
;
}
MOZ_ASSERT
(
mUnicodeDecoder
"
Should
have
a
decoder
after
finalizing
sniffing
.
"
)
;
if
(
!
mLastBuffer
)
{
NS_WARNING
(
"
mLastBuffer
should
not
be
null
!
"
)
;
MarkAsBroken
(
NS_ERROR_NULL_POINTER
)
;
return
;
}
Span
<
uint8_t
>
src
;
for
(
;
;
)
{
auto
dst
=
mLastBuffer
-
>
TailAsSpan
(
READ_BUFFER_SIZE
)
;
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
Tie
(
result
read
written
hadErrors
)
=
mUnicodeDecoder
-
>
DecodeToUTF16
(
src
dst
true
)
;
if
(
!
mDecodingLocalFileWithoutTokenizing
)
{
OnNewContent
(
dst
.
To
(
written
)
)
;
}
if
(
hadErrors
&
&
!
mHasHadErrors
)
{
mHasHadErrors
=
true
;
if
(
mEncoding
=
=
UTF_8_ENCODING
)
{
mTreeBuilder
-
>
TryToEnableEncodingMenu
(
)
;
}
}
MOZ_ASSERT
(
read
=
=
0
"
How
come
an
empty
span
was
read
form
?
"
)
;
mLastBuffer
-
>
AdvanceEnd
(
written
)
;
if
(
result
=
=
kOutputFull
)
{
RefPtr
<
nsHtml5OwningUTF16Buffer
>
newBuf
=
nsHtml5OwningUTF16Buffer
:
:
FalliblyCreate
(
READ_BUFFER_SIZE
)
;
if
(
!
newBuf
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
mLastBuffer
=
(
mLastBuffer
-
>
next
=
newBuf
.
forget
(
)
)
;
}
else
{
if
(
mDecodingLocalFileWithoutTokenizing
)
{
MOZ_ASSERT
(
mLocalFileBytesBuffered
<
LOCAL_FILE_UTF_8_BUFFER_SIZE
)
;
MOZ_ASSERT
(
mGuessEncoding
)
;
auto
encoding
=
mEncoding
;
GuessEncoding
(
true
false
)
;
if
(
encoding
=
=
mEncoding
)
{
CommitLocalFileToEncoding
(
)
;
}
else
{
ReDecodeLocalFile
(
)
;
DoStopRequest
(
)
;
return
;
}
}
else
if
(
mGuessEncoding
)
{
GuessEncoding
(
true
false
)
;
}
break
;
}
}
mStreamState
=
STREAM_ENDED
;
if
(
IsTerminatedOrInterrupted
(
)
)
{
return
;
}
ParseAvailableData
(
)
;
}
class
nsHtml5RequestStopper
:
public
Runnable
{
private
:
nsHtml5StreamParserPtr
mStreamParser
;
public
:
explicit
nsHtml5RequestStopper
(
nsHtml5StreamParser
*
aStreamParser
)
:
Runnable
(
"
nsHtml5RequestStopper
"
)
mStreamParser
(
aStreamParser
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
MutexAutoLock
autoLock
(
mStreamParser
-
>
mTokenizerMutex
)
;
mStreamParser
-
>
DoStopRequest
(
)
;
return
NS_OK
;
}
}
;
nsresult
nsHtml5StreamParser
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
status
)
{
NS_ASSERTION
(
mRequest
=
=
aRequest
"
Got
Stop
on
wrong
stream
.
"
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
if
(
mObserver
)
{
mObserver
-
>
OnStopRequest
(
aRequest
status
)
;
}
nsCOMPtr
<
nsIRunnable
>
stopper
=
new
nsHtml5RequestStopper
(
this
)
;
if
(
NS_FAILED
(
mEventTarget
-
>
Dispatch
(
stopper
nsIThread
:
:
DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Dispatching
StopRequest
event
failed
.
"
)
;
}
return
NS_OK
;
}
void
nsHtml5StreamParser
:
:
DoDataAvailableBuffer
(
mozilla
:
:
Buffer
<
uint8_t
>
&
&
aBuffer
)
{
if
(
MOZ_LIKELY
(
!
mDecodingLocalFileWithoutTokenizing
)
)
{
DoDataAvailable
(
aBuffer
)
;
return
;
}
CheckedInt
<
size_t
>
bufferedPlusLength
(
aBuffer
.
Length
(
)
)
;
bufferedPlusLength
+
=
mLocalFileBytesBuffered
;
if
(
!
bufferedPlusLength
.
isValid
(
)
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
bufferedPlusLength
.
value
(
)
<
=
LOCAL_FILE_UTF_8_BUFFER_SIZE
)
{
mLocalFileBytesBuffered
=
bufferedPlusLength
.
value
(
)
;
mBufferedLocalFileData
.
AppendElement
(
std
:
:
move
(
aBuffer
)
)
;
DoDataAvailable
(
mBufferedLocalFileData
.
LastElement
(
)
)
;
}
else
{
size_t
overBoundary
=
bufferedPlusLength
.
value
(
)
-
LOCAL_FILE_UTF_8_BUFFER_SIZE
;
MOZ_RELEASE_ASSERT
(
overBoundary
<
aBuffer
.
Length
(
)
)
;
size_t
untilBoundary
=
aBuffer
.
Length
(
)
-
overBoundary
;
auto
span
=
aBuffer
.
AsSpan
(
)
;
auto
head
=
span
.
To
(
untilBoundary
)
;
auto
tail
=
span
.
From
(
untilBoundary
)
;
MOZ_RELEASE_ASSERT
(
mLocalFileBytesBuffered
+
untilBoundary
=
=
LOCAL_FILE_UTF_8_BUFFER_SIZE
)
;
Maybe
<
Buffer
<
uint8_t
>
>
maybe
=
Buffer
<
uint8_t
>
:
:
CopyFrom
(
head
)
;
if
(
maybe
.
isNothing
(
)
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
mLocalFileBytesBuffered
=
LOCAL_FILE_UTF_8_BUFFER_SIZE
;
mBufferedLocalFileData
.
AppendElement
(
std
:
:
move
(
*
maybe
)
)
;
DoDataAvailable
(
head
)
;
DoDataAvailable
(
tail
)
;
}
if
(
!
mDecodingLocalFileWithoutTokenizing
)
{
mBufferedLocalFileData
.
Clear
(
)
;
}
}
void
nsHtml5StreamParser
:
:
DoDataAvailable
(
Span
<
const
uint8_t
>
aBuffer
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
MOZ_RELEASE_ASSERT
(
STREAM_BEING_READ
=
=
mStreamState
"
DoDataAvailable
called
when
stream
not
open
.
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
IsTerminated
(
)
)
{
return
;
}
nsresult
rv
;
if
(
HasDecoder
(
)
)
{
if
(
mFeedChardet
)
{
FeedDetector
(
aBuffer
false
)
;
}
rv
=
WriteStreamBytes
(
aBuffer
)
;
}
else
{
rv
=
SniffStreamBytes
(
aBuffer
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
MarkAsBroken
(
rv
)
;
return
;
}
if
(
IsTerminatedOrInterrupted
(
)
)
{
return
;
}
if
(
mDecodingLocalFileWithoutTokenizing
)
{
return
;
}
ParseAvailableData
(
)
;
if
(
mFlushTimerArmed
|
|
mSpeculating
)
{
return
;
}
{
mozilla
:
:
MutexAutoLock
flushTimerLock
(
mFlushTimerMutex
)
;
mFlushTimer
-
>
InitWithNamedFuncCallback
(
nsHtml5StreamParser
:
:
TimerCallback
static_cast
<
void
*
>
(
this
)
mFlushTimerEverFired
?
StaticPrefs
:
:
html5_flushtimer_initialdelay
(
)
:
StaticPrefs
:
:
html5_flushtimer_subsequentdelay
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
nsHtml5StreamParser
:
:
DoDataAvailable
"
)
;
}
mFlushTimerArmed
=
true
;
}
class
nsHtml5DataAvailable
:
public
Runnable
{
private
:
nsHtml5StreamParserPtr
mStreamParser
;
Buffer
<
uint8_t
>
mData
;
public
:
nsHtml5DataAvailable
(
nsHtml5StreamParser
*
aStreamParser
Buffer
<
uint8_t
>
&
&
aData
)
:
Runnable
(
"
nsHtml5DataAvailable
"
)
mStreamParser
(
aStreamParser
)
mData
(
std
:
:
move
(
aData
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
MutexAutoLock
autoLock
(
mStreamParser
-
>
mTokenizerMutex
)
;
mStreamParser
-
>
DoDataAvailableBuffer
(
std
:
:
move
(
mData
)
)
;
return
NS_OK
;
}
}
;
nsresult
nsHtml5StreamParser
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInStream
uint64_t
aSourceOffset
uint32_t
aLength
)
{
nsresult
rv
;
if
(
NS_FAILED
(
rv
=
mExecutor
-
>
IsBroken
(
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mRequest
=
=
aRequest
"
Got
data
on
wrong
stream
.
"
)
;
uint32_t
totalRead
;
if
(
MOZ_UNLIKELY
(
NS_IsMainThread
(
)
)
)
{
Maybe
<
Buffer
<
uint8_t
>
>
maybe
=
Buffer
<
uint8_t
>
:
:
Alloc
(
aLength
)
;
if
(
maybe
.
isNothing
(
)
)
{
return
mExecutor
-
>
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
Buffer
<
uint8_t
>
data
(
std
:
:
move
(
*
maybe
)
)
;
rv
=
aInStream
-
>
Read
(
reinterpret_cast
<
char
*
>
(
data
.
Elements
(
)
)
data
.
Length
(
)
&
totalRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
totalRead
=
=
aLength
)
;
nsCOMPtr
<
nsIRunnable
>
dataAvailable
=
new
nsHtml5DataAvailable
(
this
std
:
:
move
(
data
)
)
;
if
(
NS_FAILED
(
mEventTarget
-
>
Dispatch
(
dataAvailable
nsIThread
:
:
DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Dispatching
DataAvailable
event
failed
.
"
)
;
}
return
rv
;
}
MOZ_ASSERT
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mozilla
:
:
MutexAutoLock
autoLock
(
mTokenizerMutex
)
;
if
(
MOZ_UNLIKELY
(
mDecodingLocalFileWithoutTokenizing
)
)
{
Maybe
<
Buffer
<
uint8_t
>
>
maybe
=
Buffer
<
uint8_t
>
:
:
Alloc
(
aLength
)
;
if
(
maybe
.
isNothing
(
)
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
Buffer
<
uint8_t
>
data
(
std
:
:
move
(
*
maybe
)
)
;
rv
=
aInStream
-
>
Read
(
reinterpret_cast
<
char
*
>
(
data
.
Elements
(
)
)
data
.
Length
(
)
&
totalRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
totalRead
=
=
aLength
)
;
DoDataAvailableBuffer
(
std
:
:
move
(
data
)
)
;
return
rv
;
}
rv
=
aInStream
-
>
ReadSegments
(
CopySegmentsToParser
this
aLength
&
totalRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
totalRead
=
=
aLength
)
;
return
rv
;
}
nsresult
nsHtml5StreamParser
:
:
CopySegmentsToParser
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
nsHtml5StreamParser
*
parser
=
static_cast
<
nsHtml5StreamParser
*
>
(
aClosure
)
;
parser
-
>
DoDataAvailable
(
AsBytes
(
MakeSpan
(
aFromSegment
aCount
)
)
)
;
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
const
Encoding
*
nsHtml5StreamParser
:
:
PreferredForInternalEncodingDecl
(
const
nsACString
&
aEncoding
)
{
const
Encoding
*
newEncoding
=
Encoding
:
:
ForLabel
(
aEncoding
)
;
if
(
!
newEncoding
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncMetaUnsupported
"
true
mTokenizer
-
>
getLineNumber
(
)
)
;
return
nullptr
;
}
if
(
newEncoding
=
=
UTF_16BE_ENCODING
|
|
newEncoding
=
=
UTF_16LE_ENCODING
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncMetaUtf16
"
true
mTokenizer
-
>
getLineNumber
(
)
)
;
newEncoding
=
UTF_8_ENCODING
;
}
if
(
newEncoding
=
=
X_USER_DEFINED_ENCODING
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncMetaUserDefined
"
true
mTokenizer
-
>
getLineNumber
(
)
)
;
newEncoding
=
WINDOWS_1252_ENCODING
;
}
if
(
newEncoding
=
=
mEncoding
)
{
if
(
mCharsetSource
<
kCharsetFromMetaPrescan
)
{
if
(
mInitialEncodingWasFromParentFrame
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncLateMetaFrame
"
false
mTokenizer
-
>
getLineNumber
(
)
)
;
}
else
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncLateMeta
"
false
mTokenizer
-
>
getLineNumber
(
)
)
;
}
}
mCharsetSource
=
kCharsetFromMetaTag
;
DontGuessEncoding
(
)
;
return
nullptr
;
}
return
newEncoding
;
}
bool
nsHtml5StreamParser
:
:
internalEncodingDeclaration
(
nsHtml5String
aEncoding
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
if
(
mCharsetSource
>
=
kCharsetFromMetaTag
)
{
return
false
;
}
nsString
newEncoding16
;
aEncoding
.
ToString
(
newEncoding16
)
;
nsAutoCString
newEncoding
;
CopyUTF16toUTF8
(
newEncoding16
newEncoding
)
;
auto
encoding
=
PreferredForInternalEncodingDecl
(
newEncoding
)
;
if
(
!
encoding
)
{
return
false
;
}
if
(
mReparseForbidden
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncLateMetaTooLate
"
true
mTokenizer
-
>
getLineNumber
(
)
)
;
return
false
;
}
DontGuessEncoding
(
)
;
mTreeBuilder
-
>
NeedsCharsetSwitchTo
(
WrapNotNull
(
encoding
)
kCharsetFromMetaTag
mTokenizer
-
>
getLineNumber
(
)
)
;
FlushTreeOpsAndDisarmTimer
(
)
;
Interrupt
(
)
;
return
true
;
}
void
nsHtml5StreamParser
:
:
FlushTreeOpsAndDisarmTimer
(
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
if
(
mFlushTimerArmed
)
{
{
mozilla
:
:
MutexAutoLock
flushTimerLock
(
mFlushTimerMutex
)
;
mFlushTimer
-
>
Cancel
(
)
;
}
mFlushTimerArmed
=
false
;
}
if
(
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
VIEW_SOURCE_XML
)
{
mTokenizer
-
>
FlushViewSource
(
)
;
}
mTreeBuilder
-
>
Flush
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
mExecutorFlusher
)
;
if
(
NS_FAILED
(
DispatchToMain
(
runnable
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
void
nsHtml5StreamParser
:
:
ParseAvailableData
(
)
{
MOZ_ASSERT
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
!
mDecodingLocalFileWithoutTokenizing
)
;
if
(
IsTerminatedOrInterrupted
(
)
)
{
return
;
}
if
(
mSpeculating
&
&
!
IsSpeculationEnabled
(
)
)
{
return
;
}
for
(
;
;
)
{
if
(
!
mFirstBuffer
-
>
hasMore
(
)
)
{
if
(
mFirstBuffer
=
=
mLastBuffer
)
{
switch
(
mStreamState
)
{
case
STREAM_BEING_READ
:
if
(
!
mSpeculating
)
{
mFirstBuffer
-
>
setStart
(
0
)
;
mFirstBuffer
-
>
setEnd
(
0
)
;
}
mTreeBuilder
-
>
FlushLoads
(
)
;
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
mLoadFlusher
)
;
if
(
NS_FAILED
(
DispatchToMain
(
runnable
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
load
flush
event
"
)
;
}
}
return
;
case
STREAM_ENDED
:
if
(
mAtEOF
)
{
return
;
}
mAtEOF
=
true
;
if
(
mCharsetSource
<
kCharsetFromMetaTag
)
{
if
(
mInitialEncodingWasFromParentFrame
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncNoDeclarationFrame
"
false
0
)
;
}
else
if
(
mMode
=
=
NORMAL
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncNoDeclaration
"
true
0
)
;
}
else
if
(
mMode
=
=
PLAIN_TEXT
)
{
mTreeBuilder
-
>
MaybeComplainAboutCharset
(
"
EncNoDeclarationPlain
"
true
0
)
;
}
}
if
(
NS_SUCCEEDED
(
mTreeBuilder
-
>
IsBroken
(
)
)
)
{
mTokenizer
-
>
eof
(
)
;
nsresult
rv
;
if
(
NS_FAILED
(
(
rv
=
mTreeBuilder
-
>
IsBroken
(
)
)
)
)
{
MarkAsBroken
(
rv
)
;
}
else
{
mTreeBuilder
-
>
StreamEnded
(
)
;
if
(
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
VIEW_SOURCE_XML
)
{
mTokenizer
-
>
EndViewSource
(
)
;
}
}
}
FlushTreeOpsAndDisarmTimer
(
)
;
return
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
It
should
be
impossible
to
reach
this
.
"
)
;
return
;
}
}
mFirstBuffer
=
mFirstBuffer
-
>
next
;
continue
;
}
mFirstBuffer
-
>
adjust
(
mLastWasCR
)
;
mLastWasCR
=
false
;
if
(
mFirstBuffer
-
>
hasMore
(
)
)
{
if
(
!
mTokenizer
-
>
EnsureBufferSpace
(
mFirstBuffer
-
>
getLength
(
)
)
)
{
MarkAsBroken
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
mLastWasCR
=
mTokenizer
-
>
tokenizeBuffer
(
mFirstBuffer
)
;
nsresult
rv
;
if
(
NS_FAILED
(
(
rv
=
mTreeBuilder
-
>
IsBroken
(
)
)
)
)
{
MarkAsBroken
(
rv
)
;
return
;
}
if
(
mTreeBuilder
-
>
HasScript
(
)
)
{
MOZ_ASSERT
(
mMode
=
=
NORMAL
)
;
mozilla
:
:
MutexAutoLock
speculationAutoLock
(
mSpeculationMutex
)
;
nsHtml5Speculation
*
speculation
=
new
nsHtml5Speculation
(
mFirstBuffer
mFirstBuffer
-
>
getStart
(
)
mTokenizer
-
>
getLineNumber
(
)
mTreeBuilder
-
>
newSnapshot
(
)
)
;
mTreeBuilder
-
>
AddSnapshotToScript
(
speculation
-
>
GetSnapshot
(
)
speculation
-
>
GetStartLineNumber
(
)
)
;
FlushTreeOpsAndDisarmTimer
(
)
;
mTreeBuilder
-
>
SetOpSink
(
speculation
)
;
mSpeculations
.
AppendElement
(
speculation
)
;
mSpeculating
=
true
;
}
if
(
IsTerminatedOrInterrupted
(
)
)
{
return
;
}
}
}
}
class
nsHtml5StreamParserContinuation
:
public
Runnable
{
private
:
nsHtml5StreamParserPtr
mStreamParser
;
public
:
explicit
nsHtml5StreamParserContinuation
(
nsHtml5StreamParser
*
aStreamParser
)
:
Runnable
(
"
nsHtml5StreamParserContinuation
"
)
mStreamParser
(
aStreamParser
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
MutexAutoLock
autoLock
(
mStreamParser
-
>
mTokenizerMutex
)
;
mStreamParser
-
>
Uninterrupt
(
)
;
mStreamParser
-
>
ParseAvailableData
(
)
;
return
NS_OK
;
}
}
;
void
nsHtml5StreamParser
:
:
ContinueAfterScripts
(
nsHtml5Tokenizer
*
aTokenizer
nsHtml5TreeBuilder
*
aTreeBuilder
bool
aLastWasCR
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
NS_ASSERTION
(
!
(
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
VIEW_SOURCE_XML
)
"
ContinueAfterScripts
called
in
view
source
mode
!
"
)
;
if
(
NS_FAILED
(
mExecutor
-
>
IsBroken
(
)
)
)
{
return
;
}
#
ifdef
DEBUG
mExecutor
-
>
AssertStageEmpty
(
)
;
#
endif
bool
speculationFailed
=
false
;
{
mozilla
:
:
MutexAutoLock
speculationAutoLock
(
mSpeculationMutex
)
;
if
(
mSpeculations
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
ContinueAfterScripts
called
without
"
"
speculations
.
"
)
;
return
;
}
nsHtml5Speculation
*
speculation
=
mSpeculations
.
ElementAt
(
0
)
;
if
(
aLastWasCR
|
|
!
aTokenizer
-
>
isInDataState
(
)
|
|
!
aTreeBuilder
-
>
snapshotMatches
(
speculation
-
>
GetSnapshot
(
)
)
)
{
speculationFailed
=
true
;
MaybeDisableFutureSpeculation
(
)
;
Interrupt
(
)
;
}
else
{
if
(
mSpeculations
.
Length
(
)
>
1
)
{
speculation
-
>
FlushToSink
(
mExecutor
)
;
NS_ASSERTION
(
!
mExecutor
-
>
IsScriptExecuting
(
)
"
ParseUntilBlocked
(
)
was
supposed
to
ensure
we
don
'
t
come
"
"
here
when
scripts
are
executing
.
"
)
;
NS_ASSERTION
(
mExecutor
-
>
IsInFlushLoop
(
)
"
How
are
we
here
if
"
"
RunFlushLoop
(
)
didn
'
t
call
ParseUntilBlocked
(
)
which
is
the
"
"
only
caller
of
this
method
?
"
)
;
mSpeculations
.
RemoveElementAt
(
0
)
;
return
;
}
Interrupt
(
)
;
}
}
{
mozilla
:
:
MutexAutoLock
tokenizerAutoLock
(
mTokenizerMutex
)
;
#
ifdef
DEBUG
{
mAtomTable
.
SetPermittedLookupEventTarget
(
GetMainThreadSerialEventTarget
(
)
)
;
}
#
endif
if
(
speculationFailed
)
{
mAtEOF
=
false
;
nsHtml5Speculation
*
speculation
=
mSpeculations
.
ElementAt
(
0
)
;
mFirstBuffer
=
speculation
-
>
GetBuffer
(
)
;
mFirstBuffer
-
>
setStart
(
speculation
-
>
GetStart
(
)
)
;
mTokenizer
-
>
setLineNumber
(
speculation
-
>
GetStartLineNumber
(
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
Events
"
)
mExecutor
-
>
GetDocument
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
SpeculationFailed
"
nsTArray
<
nsString
>
(
)
nullptr
EmptyString
(
)
speculation
-
>
GetStartLineNumber
(
)
)
;
nsHtml5OwningUTF16Buffer
*
buffer
=
mFirstBuffer
-
>
next
;
while
(
buffer
)
{
buffer
-
>
setStart
(
0
)
;
buffer
=
buffer
-
>
next
;
}
mSpeculations
.
Clear
(
)
;
mTreeBuilder
-
>
flushCharacters
(
)
;
mTreeBuilder
-
>
ClearOps
(
)
;
mTreeBuilder
-
>
SetOpSink
(
mExecutor
-
>
GetStage
(
)
)
;
mExecutor
-
>
StartReadingFromStage
(
)
;
mSpeculating
=
false
;
mLastWasCR
=
aLastWasCR
;
mTokenizer
-
>
loadState
(
aTokenizer
)
;
mTreeBuilder
-
>
loadState
(
aTreeBuilder
)
;
}
else
{
mSpeculations
.
ElementAt
(
0
)
-
>
FlushToSink
(
mExecutor
)
;
NS_ASSERTION
(
!
mExecutor
-
>
IsScriptExecuting
(
)
"
ParseUntilBlocked
(
)
was
supposed
to
ensure
we
don
'
t
come
"
"
here
when
scripts
are
executing
.
"
)
;
NS_ASSERTION
(
mExecutor
-
>
IsInFlushLoop
(
)
"
How
are
we
here
if
"
"
RunFlushLoop
(
)
didn
'
t
call
ParseUntilBlocked
(
)
which
is
the
"
"
only
caller
of
this
method
?
"
)
;
mSpeculations
.
RemoveElementAt
(
0
)
;
if
(
mSpeculations
.
IsEmpty
(
)
)
{
mTreeBuilder
-
>
SetOpSink
(
mExecutor
)
;
mTreeBuilder
-
>
Flush
(
true
)
;
mTreeBuilder
-
>
SetOpSink
(
mExecutor
-
>
GetStage
(
)
)
;
mExecutor
-
>
StartReadingFromStage
(
)
;
mSpeculating
=
false
;
}
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsHtml5StreamParserContinuation
(
this
)
;
if
(
NS_FAILED
(
mEventTarget
-
>
Dispatch
(
event
nsIThread
:
:
DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
nsHtml5StreamParserContinuation
"
)
;
}
#
ifdef
DEBUG
mAtomTable
.
SetPermittedLookupEventTarget
(
mEventTarget
)
;
#
endif
}
}
void
nsHtml5StreamParser
:
:
ContinueAfterFailedCharsetSwitch
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsHtml5StreamParserContinuation
(
this
)
;
if
(
NS_FAILED
(
mEventTarget
-
>
Dispatch
(
event
nsIThread
:
:
DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
nsHtml5StreamParserContinuation
"
)
;
}
}
class
nsHtml5TimerKungFu
:
public
Runnable
{
private
:
nsHtml5StreamParserPtr
mStreamParser
;
public
:
explicit
nsHtml5TimerKungFu
(
nsHtml5StreamParser
*
aStreamParser
)
:
Runnable
(
"
nsHtml5TimerKungFu
"
)
mStreamParser
(
aStreamParser
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
MutexAutoLock
flushTimerLock
(
mStreamParser
-
>
mFlushTimerMutex
)
;
if
(
mStreamParser
-
>
mFlushTimer
)
{
mStreamParser
-
>
mFlushTimer
-
>
Cancel
(
)
;
mStreamParser
-
>
mFlushTimer
=
nullptr
;
}
return
NS_OK
;
}
}
;
void
nsHtml5StreamParser
:
:
DropTimer
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mozilla
:
:
MutexAutoLock
flushTimerLock
(
mFlushTimerMutex
)
;
if
(
mFlushTimer
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsHtml5TimerKungFu
(
this
)
;
if
(
NS_FAILED
(
mEventTarget
-
>
Dispatch
(
event
nsIThread
:
:
DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
TimerKungFu
event
"
)
;
}
}
}
void
nsHtml5StreamParser
:
:
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
(
static_cast
<
nsHtml5StreamParser
*
>
(
aClosure
)
)
-
>
TimerFlush
(
)
;
}
void
nsHtml5StreamParser
:
:
TimerFlush
(
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mozilla
:
:
MutexAutoLock
autoLock
(
mTokenizerMutex
)
;
NS_ASSERTION
(
!
mSpeculating
"
Flush
timer
fired
while
speculating
.
"
)
;
mFlushTimerArmed
=
false
;
mFlushTimerEverFired
=
true
;
if
(
IsTerminatedOrInterrupted
(
)
)
{
return
;
}
if
(
mMode
=
=
VIEW_SOURCE_HTML
|
|
mMode
=
=
VIEW_SOURCE_XML
)
{
mTreeBuilder
-
>
Flush
(
)
;
if
(
mTokenizer
-
>
FlushViewSource
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
mExecutorFlusher
)
;
if
(
NS_FAILED
(
DispatchToMain
(
runnable
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
}
else
{
if
(
mTreeBuilder
-
>
Flush
(
true
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
mExecutorFlusher
)
;
if
(
NS_FAILED
(
DispatchToMain
(
runnable
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
}
}
void
nsHtml5StreamParser
:
:
MarkAsBroken
(
nsresult
aRv
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
Terminate
(
)
;
mTreeBuilder
-
>
MarkAsBroken
(
aRv
)
;
mozilla
:
:
DebugOnly
<
bool
>
hadOps
=
mTreeBuilder
-
>
Flush
(
false
)
;
NS_ASSERTION
(
hadOps
"
Should
have
had
the
markAsBroken
op
!
"
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
mExecutorFlusher
)
;
if
(
NS_FAILED
(
DispatchToMain
(
runnable
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
executor
flush
event
"
)
;
}
}
nsresult
nsHtml5StreamParser
:
:
DispatchToMain
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
mDocGroup
)
{
return
mDocGroup
-
>
Dispatch
(
TaskCategory
:
:
Network
std
:
:
move
(
aRunnable
)
)
;
}
return
SchedulerGroup
:
:
UnlabeledDispatch
(
TaskCategory
:
:
Network
std
:
:
move
(
aRunnable
)
)
;
}
