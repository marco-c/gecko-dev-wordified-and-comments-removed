#
ifndef
nsHtml5StreamParser_h
#
define
nsHtml5StreamParser_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICharsetDetectionObserver
.
h
"
#
include
"
nsHtml5MetaScanner
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsHtml5OwningUTF16Buffer
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsHtml5AtomTable
.
h
"
#
include
"
nsHtml5Speculation
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsICharsetDetector
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
class
nsHtml5Parser
;
#
define
NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE
1024
#
define
NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE
1024
enum
eParserMode
{
NORMAL
VIEW_SOURCE_HTML
VIEW_SOURCE_XML
VIEW_SOURCE_PLAIN
PLAIN_TEXT
LOAD_AS_DATA
}
;
enum
eBomState
{
BOM_SNIFFING_NOT_STARTED
=
0
SEEN_UTF_16_LE_FIRST_BYTE
=
1
SEEN_UTF_16_BE_FIRST_BYTE
=
2
SEEN_UTF_8_FIRST_BYTE
=
3
SEEN_UTF_8_SECOND_BYTE
=
4
BOM_SNIFFING_OVER
=
5
}
;
enum
eHtml5StreamState
{
STREAM_NOT_STARTED
=
0
STREAM_BEING_READ
=
1
STREAM_ENDED
=
2
}
;
class
nsHtml5StreamParser
final
:
public
nsICharsetDetectionObserver
{
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
using
Encoding
=
mozilla
:
:
Encoding
;
friend
class
nsHtml5RequestStopper
;
friend
class
nsHtml5DataAvailable
;
friend
class
nsHtml5StreamParserContinuation
;
friend
class
nsHtml5TimerKungFu
;
friend
class
nsHtml5StreamParserPtr
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsHtml5StreamParser
nsICharsetDetectionObserver
)
nsHtml5StreamParser
(
nsHtml5TreeOpExecutor
*
aExecutor
nsHtml5Parser
*
aOwner
eParserMode
aMode
)
;
nsresult
CheckListenerChain
(
)
;
nsresult
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
;
nsresult
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStream
uint64_t
aSourceOffset
uint32_t
aLength
)
;
nsresult
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
status
)
;
NS_IMETHOD
Notify
(
const
char
*
aCharset
nsDetectionConfident
aConf
)
override
;
bool
internalEncodingDeclaration
(
nsHtml5String
aEncoding
)
;
inline
void
SetDocumentCharset
(
NotNull
<
const
Encoding
*
>
aEncoding
int32_t
aSource
)
{
MOZ_ASSERT
(
mStreamState
=
=
STREAM_NOT_STARTED
"
SetDocumentCharset
called
too
late
.
"
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mEncoding
=
aEncoding
;
mCharsetSource
=
aSource
;
}
inline
void
SetObserver
(
nsIRequestObserver
*
aObserver
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mObserver
=
aObserver
;
}
nsresult
GetChannel
(
nsIChannel
*
*
aChannel
)
;
void
ContinueAfterScripts
(
nsHtml5Tokenizer
*
aTokenizer
nsHtml5TreeBuilder
*
aTreeBuilder
bool
aLastWasCR
)
;
void
ContinueAfterFailedCharsetSwitch
(
)
;
void
Terminate
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
mTerminated
=
true
;
}
void
DropTimer
(
)
;
void
SetEncodingFromExpat
(
const
char16_t
*
aEncoding
)
;
void
SetViewSourceTitle
(
nsIURI
*
aURL
)
;
private
:
virtual
~
nsHtml5StreamParser
(
)
;
#
ifdef
DEBUG
bool
IsParserThread
(
)
{
return
mEventTarget
-
>
IsOnCurrentThread
(
)
;
}
#
endif
void
MarkAsBroken
(
nsresult
aRv
)
;
void
Interrupt
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
mInterrupted
=
true
;
}
void
Uninterrupt
(
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
mInterrupted
=
false
;
}
void
FlushTreeOpsAndDisarmTimer
(
)
;
void
ParseAvailableData
(
)
;
void
DoStopRequest
(
)
;
void
DoDataAvailable
(
const
uint8_t
*
aBuffer
uint32_t
aLength
)
;
static
nsresult
CopySegmentsToParser
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
bool
IsTerminatedOrInterrupted
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
return
mTerminated
|
|
mInterrupted
;
}
bool
IsTerminated
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
return
mTerminated
;
}
inline
bool
HasDecoder
(
)
{
return
!
!
mUnicodeDecoder
;
}
nsresult
SniffStreamBytes
(
const
uint8_t
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
nsresult
WriteStreamBytes
(
const
uint8_t
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
void
SniffBOMlessUTF16BasicLatin
(
const
uint8_t
*
aFromSegment
uint32_t
aCountToSniffingLimit
)
;
nsresult
FinalizeSniffing
(
const
uint8_t
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
uint32_t
aCountToSniffingLimit
)
;
nsresult
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
const
uint8_t
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
nsresult
SetupDecodingFromBom
(
NotNull
<
const
Encoding
*
>
aEncoding
)
;
const
Encoding
*
PreferredForInternalEncodingDecl
(
const
nsACString
&
aEncoding
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
TimerFlush
(
)
;
void
MaybeDisableFutureSpeculation
(
)
{
mSpeculationFailureCount
+
+
;
}
bool
IsSpeculationEnabled
(
)
{
return
mSpeculationFailureCount
<
100
;
}
nsresult
DispatchToMain
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
nsCOMPtr
<
nsIRequestObserver
>
mObserver
;
nsCString
mViewSourceTitle
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
Decoder
>
mUnicodeDecoder
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mSniffingBuffer
;
uint32_t
mSniffingLength
;
eBomState
mBomState
;
nsAutoPtr
<
nsHtml5MetaScanner
>
mMetaScanner
;
int32_t
mCharsetSource
;
NotNull
<
const
Encoding
*
>
mEncoding
;
bool
mReparseForbidden
;
RefPtr
<
nsHtml5OwningUTF16Buffer
>
mFirstBuffer
;
nsHtml5OwningUTF16Buffer
*
mLastBuffer
;
nsHtml5TreeOpExecutor
*
mExecutor
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
nsAutoPtr
<
nsHtml5TreeBuilder
>
mTreeBuilder
;
nsAutoPtr
<
nsHtml5Tokenizer
>
mTokenizer
;
mozilla
:
:
Mutex
mTokenizerMutex
;
nsHtml5AtomTable
mAtomTable
;
RefPtr
<
nsHtml5Parser
>
mOwner
;
bool
mLastWasCR
;
eHtml5StreamState
mStreamState
;
bool
mSpeculating
;
bool
mAtEOF
;
nsTArray
<
nsAutoPtr
<
nsHtml5Speculation
>
>
mSpeculations
;
mozilla
:
:
Mutex
mSpeculationMutex
;
uint32_t
mSpeculationFailureCount
;
bool
mTerminated
;
bool
mInterrupted
;
mozilla
:
:
Mutex
mTerminatedMutex
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
nsCOMPtr
<
nsIRunnable
>
mExecutorFlusher
;
nsCOMPtr
<
nsIRunnable
>
mLoadFlusher
;
nsCOMPtr
<
nsICharsetDetector
>
mChardet
;
bool
mFeedChardet
;
bool
mInitialEncodingWasFromParentFrame
;
bool
mHasHadErrors
;
nsCOMPtr
<
nsITimer
>
mFlushTimer
;
mozilla
:
:
Mutex
mFlushTimerMutex
;
bool
mFlushTimerArmed
;
bool
mFlushTimerEverFired
;
eParserMode
mMode
;
}
;
#
endif
