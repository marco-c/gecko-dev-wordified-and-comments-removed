#
ifndef
nsHtml5StreamParser_h
#
define
nsHtml5StreamParser_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHtml5MetaScanner
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EncodingDetector
.
h
"
#
include
"
mozilla
/
JapaneseDetector
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsHtml5OwningUTF16Buffer
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsHtml5AtomTable
.
h
"
#
include
"
nsHtml5Speculation
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
Buffer
.
h
"
class
nsHtml5Parser
;
enum
eParserMode
{
NORMAL
VIEW_SOURCE_HTML
VIEW_SOURCE_XML
VIEW_SOURCE_PLAIN
PLAIN_TEXT
LOAD_AS_DATA
}
;
enum
eBomState
{
BOM_SNIFFING_NOT_STARTED
=
0
SEEN_UTF_16_LE_FIRST_BYTE
=
1
SEEN_UTF_16_BE_FIRST_BYTE
=
2
SEEN_UTF_8_FIRST_BYTE
=
3
SEEN_UTF_8_SECOND_BYTE
=
4
BOM_SNIFFING_OVER
=
5
}
;
enum
eHtml5StreamState
{
STREAM_NOT_STARTED
=
0
STREAM_BEING_READ
=
1
STREAM_ENDED
=
2
}
;
class
nsHtml5StreamParser
final
:
public
nsISupports
{
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
using
Encoding
=
mozilla
:
:
Encoding
;
const
uint32_t
SNIFFING_BUFFER_SIZE
=
1024
;
const
uint32_t
READ_BUFFER_SIZE
=
1024
;
const
uint32_t
LOCAL_FILE_UTF_8_BUFFER_SIZE
=
1024
*
1024
*
4
;
friend
class
nsHtml5RequestStopper
;
friend
class
nsHtml5DataAvailable
;
friend
class
nsHtml5StreamParserContinuation
;
friend
class
nsHtml5TimerKungFu
;
friend
class
nsHtml5StreamParserPtr
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsHtml5StreamParser
)
nsHtml5StreamParser
(
nsHtml5TreeOpExecutor
*
aExecutor
nsHtml5Parser
*
aOwner
eParserMode
aMode
)
;
nsresult
CheckListenerChain
(
)
;
nsresult
OnStartRequest
(
nsIRequest
*
aRequest
)
;
nsresult
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInStream
uint64_t
aSourceOffset
uint32_t
aLength
)
;
nsresult
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
status
)
;
bool
internalEncodingDeclaration
(
nsHtml5String
aEncoding
)
;
void
FeedJapaneseDetector
(
mozilla
:
:
Span
<
const
uint8_t
>
aBuffer
bool
aLast
)
;
void
FeedDetector
(
mozilla
:
:
Span
<
const
uint8_t
>
aBuffer
bool
aLast
)
;
inline
void
SetDocumentCharset
(
NotNull
<
const
Encoding
*
>
aEncoding
int32_t
aSource
)
{
MOZ_ASSERT
(
mStreamState
=
=
STREAM_NOT_STARTED
"
SetDocumentCharset
called
too
late
.
"
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mEncoding
=
aEncoding
;
mCharsetSource
=
aSource
;
}
inline
void
SetObserver
(
nsIRequestObserver
*
aObserver
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
mObserver
=
aObserver
;
}
nsresult
GetChannel
(
nsIChannel
*
*
aChannel
)
;
void
ContinueAfterScripts
(
nsHtml5Tokenizer
*
aTokenizer
nsHtml5TreeBuilder
*
aTreeBuilder
bool
aLastWasCR
)
;
void
ContinueAfterFailedCharsetSwitch
(
)
;
void
Terminate
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
mTerminated
=
true
;
}
void
DropTimer
(
)
;
void
SetEncodingFromExpat
(
const
char16_t
*
aEncoding
)
;
void
SetViewSourceTitle
(
nsIURI
*
aURL
)
;
private
:
virtual
~
nsHtml5StreamParser
(
)
;
#
ifdef
DEBUG
bool
IsParserThread
(
)
{
return
mEventTarget
-
>
IsOnCurrentThread
(
)
;
}
#
endif
void
MarkAsBroken
(
nsresult
aRv
)
;
void
Interrupt
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
mInterrupted
=
true
;
}
void
Uninterrupt
(
)
{
NS_ASSERTION
(
IsParserThread
(
)
"
Wrong
thread
!
"
)
;
mTokenizerMutex
.
AssertCurrentThreadOwns
(
)
;
mInterrupted
=
false
;
}
void
FlushTreeOpsAndDisarmTimer
(
)
;
void
ParseAvailableData
(
)
;
void
DoStopRequest
(
)
;
void
DoDataAvailableBuffer
(
mozilla
:
:
Buffer
<
uint8_t
>
&
&
aBuffer
)
;
void
DoDataAvailable
(
mozilla
:
:
Span
<
const
uint8_t
>
aBuffer
)
;
static
nsresult
CopySegmentsToParser
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
bool
IsTerminatedOrInterrupted
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
return
mTerminated
|
|
mInterrupted
;
}
bool
IsTerminated
(
)
{
mozilla
:
:
MutexAutoLock
autoLock
(
mTerminatedMutex
)
;
return
mTerminated
;
}
inline
bool
HasDecoder
(
)
{
return
!
!
mUnicodeDecoder
;
}
nsresult
SniffStreamBytes
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
)
;
nsresult
WriteStreamBytes
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
)
;
void
SniffBOMlessUTF16BasicLatin
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
)
;
void
FinalizeSniffingWithDetector
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
uint32_t
aCountToSniffingLimit
bool
aEof
)
;
nsresult
FinalizeSniffing
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
uint32_t
aCountToSniffingLimit
bool
aEof
)
;
nsresult
SetupDecodingAndWriteSniffingBufferAndCurrentSegment
(
mozilla
:
:
Span
<
const
uint8_t
>
aFromSegment
)
;
nsresult
SetupDecodingFromBom
(
NotNull
<
const
Encoding
*
>
aEncoding
)
;
void
CommitLocalFileToEncoding
(
)
;
void
ReDecodeLocalFile
(
)
;
void
GuessEncoding
(
bool
aEof
bool
aInitial
)
;
inline
void
DontGuessEncoding
(
)
{
mFeedChardet
=
false
;
mGuessEncoding
=
false
;
if
(
mDecodingLocalFileWithoutTokenizing
)
{
CommitLocalFileToEncoding
(
)
;
}
}
const
Encoding
*
PreferredForInternalEncodingDecl
(
const
nsACString
&
aEncoding
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
TimerFlush
(
)
;
void
MaybeDisableFutureSpeculation
(
)
{
mSpeculationFailureCount
+
+
;
}
bool
IsSpeculationEnabled
(
)
{
return
mSpeculationFailureCount
<
100
;
}
nsresult
DispatchToMain
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
inline
void
OnNewContent
(
mozilla
:
:
Span
<
const
char16_t
>
aData
)
;
inline
void
OnContentComplete
(
)
;
nsCOMPtr
<
nsIRequest
>
mRequest
;
nsCOMPtr
<
nsIRequestObserver
>
mObserver
;
nsCString
mViewSourceTitle
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
Decoder
>
mUnicodeDecoder
;
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
mSniffingBuffer
;
uint32_t
mSniffingLength
;
eBomState
mBomState
;
nsAutoPtr
<
nsHtml5MetaScanner
>
mMetaScanner
;
int32_t
mCharsetSource
;
NotNull
<
const
Encoding
*
>
mEncoding
;
bool
mFeedChardet
;
bool
mGuessEncoding
;
bool
mReparseForbidden
;
RefPtr
<
nsHtml5OwningUTF16Buffer
>
mFirstBuffer
;
nsHtml5OwningUTF16Buffer
*
mLastBuffer
;
nsHtml5TreeOpExecutor
*
mExecutor
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
nsAutoPtr
<
nsHtml5TreeBuilder
>
mTreeBuilder
;
nsAutoPtr
<
nsHtml5Tokenizer
>
mTokenizer
;
mozilla
:
:
Mutex
mTokenizerMutex
;
nsHtml5AtomTable
mAtomTable
;
RefPtr
<
nsHtml5Parser
>
mOwner
;
bool
mLastWasCR
;
eHtml5StreamState
mStreamState
;
bool
mSpeculating
;
bool
mAtEOF
;
nsTArray
<
nsAutoPtr
<
nsHtml5Speculation
>
>
mSpeculations
;
mozilla
:
:
Mutex
mSpeculationMutex
;
uint32_t
mSpeculationFailureCount
;
uint32_t
mLocalFileBytesBuffered
;
nsTArray
<
mozilla
:
:
Buffer
<
uint8_t
>
>
mBufferedLocalFileData
;
bool
mTerminated
;
bool
mInterrupted
;
mozilla
:
:
Mutex
mTerminatedMutex
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
nsCOMPtr
<
nsIRunnable
>
mExecutorFlusher
;
nsCOMPtr
<
nsIRunnable
>
mLoadFlusher
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
JapaneseDetector
>
mJapaneseDetector
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
EncodingDetector
>
mDetector
;
nsCString
mTLD
;
bool
mUseJapaneseDetector
;
bool
mInitialEncodingWasFromParentFrame
;
bool
mHasHadErrors
;
bool
mDecodingLocalFileWithoutTokenizing
;
nsCOMPtr
<
nsITimer
>
mFlushTimer
;
mozilla
:
:
Mutex
mFlushTimerMutex
;
bool
mFlushTimerArmed
;
bool
mFlushTimerEverFired
;
eParserMode
mMode
;
bool
mSkipContentSniffing
;
nsCOMPtr
<
nsIURI
>
mURIToSendToDevtools
;
nsString
mUUIDForDevtools
;
}
;
#
endif
