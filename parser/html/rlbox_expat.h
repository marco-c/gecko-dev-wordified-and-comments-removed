#
ifndef
PARSER_HTML_RLBOX_EXPAT_H_
#
define
PARSER_HTML_RLBOX_EXPAT_H_
#
include
"
rlbox_expat_types
.
h
"
#
include
"
mozilla
/
rlbox
/
rlbox_config
.
h
"
#
ifdef
MOZ_WASM_SANDBOXING_EXPAT
#
include
"
mozilla
/
rlbox
/
rlbox_wasm2c_sandbox
.
hpp
"
#
else
#
define
RLBOX_USE_STATIC_CALLS
(
)
rlbox_noop_sandbox_lookup_symbol
#
include
"
mozilla
/
rlbox
/
rlbox_noop_sandbox
.
hpp
"
#
endif
#
include
"
mozilla
/
rlbox
/
rlbox
.
hpp
"
inline
enum
XML_Status
status_verifier
(
enum
XML_Status
s
)
{
MOZ_RELEASE_ASSERT
(
s
>
=
XML_STATUS_ERROR
&
&
s
<
=
XML_STATUS_SUSPENDED
"
unexpected
status
code
"
)
;
return
s
;
}
inline
enum
XML_Error
error_verifier
(
enum
XML_Error
code
)
{
MOZ_RELEASE_ASSERT
(
code
>
=
XML_ERROR_NONE
&
&
code
<
=
XML_ERROR_INVALID_ARGUMENT
"
unexpected
XML
error
code
"
)
;
return
code
;
}
inline
XML_Char
*
transfer_xmlstring_no_validate
(
rlbox_sandbox_expat
&
aSandbox
tainted_expat
<
const
XML_Char
*
>
t_aStr
bool
&
copied
)
{
copied
=
false
;
if
(
t_aStr
!
=
nullptr
)
{
const
mozilla
:
:
CheckedInt
<
size_t
>
len
=
std
:
:
char_traits
<
char16_t
>
:
:
length
(
t_aStr
.
unverified_safe_pointer_because
(
1
"
Even
with
bad
length
we
will
not
span
beyond
sandbox
boundary
.
"
)
)
;
const
mozilla
:
:
CheckedInt
<
size_t
>
strSize
=
(
len
+
1
)
*
sizeof
(
char16_t
)
;
MOZ_RELEASE_ASSERT
(
len
.
isValid
(
)
&
&
strSize
.
isValid
(
)
"
Bad
string
"
)
;
auto
*
aStr
=
rlbox
:
:
copy_memory_or_deny_access
(
aSandbox
rlbox
:
:
sandbox_const_cast
<
char16_t
*
>
(
t_aStr
)
strSize
.
value
(
)
false
copied
)
;
aStr
[
len
.
value
(
)
]
=
'
\
0
'
;
return
aStr
;
}
return
nullptr
;
}
#
endif
