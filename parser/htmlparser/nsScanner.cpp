#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsScanner
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsParser
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
using
mozilla
:
:
dom
:
:
EncodingUtils
;
nsReadEndCondition
:
:
nsReadEndCondition
(
const
char16_t
*
aTerminateChars
)
:
mChars
(
aTerminateChars
)
mFilter
(
char16_t
(
~
0
)
)
{
const
char16_t
*
current
=
aTerminateChars
;
char16_t
terminalChar
=
*
current
;
while
(
terminalChar
)
{
mFilter
&
=
~
terminalChar
;
+
+
current
;
terminalChar
=
*
current
;
}
}
nsScanner
:
:
nsScanner
(
const
nsAString
&
anHTMLString
)
{
MOZ_COUNT_CTOR
(
nsScanner
)
;
mSlidingBuffer
=
nullptr
;
if
(
AppendToBuffer
(
anHTMLString
)
)
{
mSlidingBuffer
-
>
BeginReading
(
mCurrentPosition
)
;
}
else
{
memset
(
&
mCurrentPosition
0
sizeof
(
mCurrentPosition
)
)
;
mEndPosition
=
mCurrentPosition
;
}
mMarkPosition
=
mCurrentPosition
;
mIncremental
=
false
;
mUnicodeDecoder
=
nullptr
;
mCharsetSource
=
kCharsetUninitialized
;
}
nsScanner
:
:
nsScanner
(
nsString
&
aFilename
bool
aCreateStream
)
:
mFilename
(
aFilename
)
{
MOZ_COUNT_CTOR
(
nsScanner
)
;
NS_ASSERTION
(
!
aCreateStream
"
This
is
always
true
.
"
)
;
mSlidingBuffer
=
nullptr
;
memset
(
&
mCurrentPosition
0
sizeof
(
mCurrentPosition
)
)
;
mMarkPosition
=
mCurrentPosition
;
mEndPosition
=
mCurrentPosition
;
mIncremental
=
true
;
mUnicodeDecoder
=
nullptr
;
mCharsetSource
=
kCharsetUninitialized
;
SetDocumentCharset
(
NS_LITERAL_CSTRING
(
"
UTF
-
8
"
)
kCharsetFromDocTypeDefault
)
;
}
nsresult
nsScanner
:
:
SetDocumentCharset
(
const
nsACString
&
aCharset
int32_t
aSource
)
{
if
(
aSource
<
mCharsetSource
)
return
NS_OK
;
mCharsetSource
=
aSource
;
nsCString
charsetName
;
mozilla
:
:
DebugOnly
<
bool
>
valid
=
EncodingUtils
:
:
FindEncodingForLabel
(
aCharset
charsetName
)
;
MOZ_ASSERT
(
valid
"
Should
never
call
with
a
bogus
aCharset
.
"
)
;
if
(
!
mCharset
.
IsEmpty
(
)
&
&
charsetName
.
Equals
(
mCharset
)
)
{
return
NS_OK
;
}
mCharset
.
Assign
(
charsetName
)
;
mUnicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
mCharset
)
;
mUnicodeDecoder
-
>
SetInputErrorBehavior
(
nsIUnicodeDecoder
:
:
kOnError_Signal
)
;
return
NS_OK
;
}
nsScanner
:
:
~
nsScanner
(
)
{
delete
mSlidingBuffer
;
MOZ_COUNT_DTOR
(
nsScanner
)
;
}
void
nsScanner
:
:
RewindToMark
(
void
)
{
if
(
mSlidingBuffer
)
{
mCurrentPosition
=
mMarkPosition
;
}
}
int32_t
nsScanner
:
:
Mark
(
)
{
int32_t
distance
=
0
;
if
(
mSlidingBuffer
)
{
nsScannerIterator
oldStart
;
mSlidingBuffer
-
>
BeginReading
(
oldStart
)
;
distance
=
Distance
(
oldStart
mCurrentPosition
)
;
mSlidingBuffer
-
>
DiscardPrefix
(
mCurrentPosition
)
;
mSlidingBuffer
-
>
BeginReading
(
mCurrentPosition
)
;
mMarkPosition
=
mCurrentPosition
;
}
return
distance
;
}
bool
nsScanner
:
:
UngetReadable
(
const
nsAString
&
aBuffer
)
{
if
(
!
mSlidingBuffer
)
{
return
false
;
}
mSlidingBuffer
-
>
UngetReadable
(
aBuffer
mCurrentPosition
)
;
mSlidingBuffer
-
>
BeginReading
(
mCurrentPosition
)
;
mSlidingBuffer
-
>
EndReading
(
mEndPosition
)
;
return
true
;
}
nsresult
nsScanner
:
:
Append
(
const
nsAString
&
aBuffer
)
{
if
(
!
AppendToBuffer
(
aBuffer
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
NS_OK
;
}
nsresult
nsScanner
:
:
Append
(
const
char
*
aBuffer
uint32_t
aLen
)
{
nsresult
res
=
NS_OK
;
if
(
mUnicodeDecoder
)
{
int32_t
unicharBufLen
=
0
;
nsresult
rv
=
mUnicodeDecoder
-
>
GetMaxLength
(
aBuffer
aLen
&
unicharBufLen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsScannerString
:
:
Buffer
*
buffer
=
nsScannerString
:
:
AllocBuffer
(
unicharBufLen
+
1
)
;
NS_ENSURE_TRUE
(
buffer
NS_ERROR_OUT_OF_MEMORY
)
;
char16_t
*
unichars
=
buffer
-
>
DataStart
(
)
;
int32_t
totalChars
=
0
;
int32_t
unicharLength
=
unicharBufLen
;
do
{
int32_t
srcLength
=
aLen
;
res
=
mUnicodeDecoder
-
>
Convert
(
aBuffer
&
srcLength
unichars
&
unicharLength
)
;
totalChars
+
=
unicharLength
;
if
(
NS_FAILED
(
res
)
)
{
if
(
(
unichars
+
unicharLength
)
>
=
buffer
-
>
DataEnd
(
)
)
{
NS_ERROR
(
"
Unexpected
end
of
destination
buffer
"
)
;
break
;
}
unichars
[
unicharLength
+
+
]
=
0xFFFF
;
unichars
=
unichars
+
unicharLength
;
unicharLength
=
unicharBufLen
-
(
+
+
totalChars
)
;
mUnicodeDecoder
-
>
Reset
(
)
;
if
(
(
(
uint32_t
)
(
srcLength
+
1
)
)
>
aLen
)
{
srcLength
=
aLen
;
}
else
{
+
+
srcLength
;
}
aBuffer
+
=
srcLength
;
aLen
-
=
srcLength
;
}
}
while
(
NS_FAILED
(
res
)
&
&
(
aLen
>
0
)
)
;
buffer
-
>
SetDataLength
(
totalChars
)
;
res
=
NS_OK
;
if
(
!
AppendToBuffer
(
buffer
)
)
res
=
NS_ERROR_OUT_OF_MEMORY
;
}
else
{
NS_WARNING
(
"
No
decoder
found
.
"
)
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
nsresult
nsScanner
:
:
GetChar
(
char16_t
&
aChar
)
{
if
(
!
mSlidingBuffer
|
|
mCurrentPosition
=
=
mEndPosition
)
{
aChar
=
0
;
return
NS_ERROR_HTMLPARSER_EOF
;
}
aChar
=
*
mCurrentPosition
+
+
;
return
NS_OK
;
}
void
nsScanner
:
:
BindSubstring
(
nsScannerSubstring
&
aSubstring
const
nsScannerIterator
&
aStart
const
nsScannerIterator
&
aEnd
)
{
aSubstring
.
Rebind
(
*
mSlidingBuffer
aStart
aEnd
)
;
}
void
nsScanner
:
:
CurrentPosition
(
nsScannerIterator
&
aPosition
)
{
aPosition
=
mCurrentPosition
;
}
void
nsScanner
:
:
EndReading
(
nsScannerIterator
&
aPosition
)
{
aPosition
=
mEndPosition
;
}
void
nsScanner
:
:
SetPosition
(
nsScannerIterator
&
aPosition
bool
aTerminate
)
{
if
(
mSlidingBuffer
)
{
mCurrentPosition
=
aPosition
;
if
(
aTerminate
&
&
(
mCurrentPosition
=
=
mEndPosition
)
)
{
mMarkPosition
=
mCurrentPosition
;
mSlidingBuffer
-
>
DiscardPrefix
(
mCurrentPosition
)
;
}
}
}
bool
nsScanner
:
:
AppendToBuffer
(
nsScannerString
:
:
Buffer
*
aBuf
)
{
if
(
!
mSlidingBuffer
)
{
mSlidingBuffer
=
new
nsScannerString
(
aBuf
)
;
if
(
!
mSlidingBuffer
)
return
false
;
mSlidingBuffer
-
>
BeginReading
(
mCurrentPosition
)
;
mMarkPosition
=
mCurrentPosition
;
mSlidingBuffer
-
>
EndReading
(
mEndPosition
)
;
}
else
{
mSlidingBuffer
-
>
AppendBuffer
(
aBuf
)
;
if
(
mCurrentPosition
=
=
mEndPosition
)
{
mSlidingBuffer
-
>
BeginReading
(
mCurrentPosition
)
;
}
mSlidingBuffer
-
>
EndReading
(
mEndPosition
)
;
}
return
true
;
}
bool
nsScanner
:
:
CopyUnusedData
(
nsString
&
aCopyBuffer
)
{
if
(
!
mSlidingBuffer
)
{
aCopyBuffer
.
Truncate
(
)
;
return
true
;
}
nsScannerIterator
start
end
;
start
=
mCurrentPosition
;
end
=
mEndPosition
;
return
CopyUnicodeTo
(
start
end
aCopyBuffer
)
;
}
nsString
&
nsScanner
:
:
GetFilename
(
void
)
{
return
mFilename
;
}
void
nsScanner
:
:
SelfTest
(
void
)
{
#
ifdef
_DEBUG
#
endif
}
