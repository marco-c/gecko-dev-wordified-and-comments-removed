#
include
"
nsAtom
.
h
"
#
include
"
nsParser
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsScanner
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
CNavDTD
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prlock
.
h
"
#
include
"
prcvar
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsExpatDriver
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIFragmentContentSink
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsHTMLTokenizer
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIHTMLContentSink
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
using
namespace
mozilla
;
#
define
NS_PARSER_FLAG_OBSERVERS_ENABLED
0x00000004
#
define
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
0x00000008
#
define
NS_PARSER_FLAG_FLUSH_TOKENS
0x00000020
#
define
NS_PARSER_FLAG_CAN_TOKENIZE
0x00000040
class
nsParserContinueEvent
:
public
Runnable
{
public
:
RefPtr
<
nsParser
>
mParser
;
explicit
nsParserContinueEvent
(
nsParser
*
aParser
)
:
mozilla
:
:
Runnable
(
"
nsParserContinueEvent
"
)
mParser
(
aParser
)
{
}
NS_IMETHOD
Run
(
)
override
{
mParser
-
>
HandleParserContinueEvent
(
this
)
;
return
NS_OK
;
}
}
;
nsParser
:
:
nsParser
(
)
:
mParserContext
(
nullptr
)
mCharset
(
WINDOWS_1252_ENCODING
)
{
Initialize
(
true
)
;
}
nsParser
:
:
~
nsParser
(
)
{
Cleanup
(
)
;
}
void
nsParser
:
:
Initialize
(
bool
aConstructor
)
{
if
(
aConstructor
)
{
mParserContext
=
0
;
}
else
{
mObserver
=
nullptr
;
mUnusedInput
.
Truncate
(
)
;
}
mContinueEvent
=
nullptr
;
mCharsetSource
=
kCharsetUninitialized
;
mCharset
=
WINDOWS_1252_ENCODING
;
mInternalState
=
NS_OK
;
mStreamStatus
=
NS_OK
;
mCommand
=
eViewNormal
;
mBlocked
=
0
;
mFlags
=
NS_PARSER_FLAG_OBSERVERS_ENABLED
|
NS_PARSER_FLAG_CAN_TOKENIZE
;
mProcessingNetworkData
=
false
;
mIsAboutBlank
=
false
;
}
void
nsParser
:
:
Cleanup
(
)
{
#
ifdef
DEBUG
if
(
mParserContext
&
&
mParserContext
-
>
mPrevContext
)
{
NS_WARNING
(
"
Extra
parser
contexts
still
on
the
parser
stack
"
)
;
}
#
endif
while
(
mParserContext
)
{
CParserContext
*
pc
=
mParserContext
-
>
mPrevContext
;
delete
mParserContext
;
mParserContext
=
pc
;
}
NS_ASSERTION
(
!
(
mFlags
&
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
)
"
bad
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsParser
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsParser
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDTD
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSink
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsParser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDTD
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSink
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObserver
)
CParserContext
*
pc
=
tmp
-
>
mParserContext
;
while
(
pc
)
{
cb
.
NoteXPCOMChild
(
pc
-
>
mTokenizer
)
;
pc
=
pc
-
>
mPrevContext
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsParser
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsParser
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsParser
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIParser
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIParser
)
NS_INTERFACE_MAP_END
nsresult
nsParser
:
:
PostContinueEvent
(
)
{
if
(
!
(
mFlags
&
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
)
)
{
NS_ASSERTION
(
!
mContinueEvent
"
bad
"
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsParserContinueEvent
(
this
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
event
)
)
)
{
NS_WARNING
(
"
failed
to
dispatch
parser
continuation
event
"
)
;
}
else
{
mFlags
|
=
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
;
mContinueEvent
=
event
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
GetCommand
(
nsCString
&
aCommand
)
{
aCommand
=
mCommandStr
;
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
SetCommand
(
const
char
*
aCommand
)
{
mCommandStr
.
Assign
(
aCommand
)
;
if
(
mCommandStr
.
EqualsLiteral
(
"
view
-
source
"
)
)
{
mCommand
=
eViewSource
;
}
else
if
(
mCommandStr
.
EqualsLiteral
(
"
view
-
fragment
"
)
)
{
mCommand
=
eViewFragment
;
}
else
{
mCommand
=
eViewNormal
;
}
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
SetCommand
(
eParserCommands
aParserCommand
)
{
mCommand
=
aParserCommand
;
}
void
nsParser
:
:
SetDocumentCharset
(
NotNull
<
const
Encoding
*
>
aCharset
int32_t
aCharsetSource
)
{
mCharset
=
aCharset
;
mCharsetSource
=
aCharsetSource
;
if
(
mParserContext
&
&
mParserContext
-
>
mScanner
)
{
mParserContext
-
>
mScanner
-
>
SetDocumentCharset
(
aCharset
aCharsetSource
)
;
}
}
void
nsParser
:
:
SetSinkCharset
(
NotNull
<
const
Encoding
*
>
aCharset
)
{
if
(
mSink
)
{
mSink
-
>
SetDocumentCharset
(
aCharset
)
;
}
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
SetContentSink
(
nsIContentSink
*
aSink
)
{
MOZ_ASSERT
(
aSink
"
sink
cannot
be
null
!
"
)
;
mSink
=
aSink
;
if
(
mSink
)
{
mSink
-
>
SetParser
(
this
)
;
nsCOMPtr
<
nsIHTMLContentSink
>
htmlSink
=
do_QueryInterface
(
mSink
)
;
if
(
htmlSink
)
{
mIsAboutBlank
=
true
;
}
}
}
NS_IMETHODIMP_
(
nsIContentSink
*
)
nsParser
:
:
GetContentSink
(
)
{
return
mSink
;
}
static
nsIDTD
*
FindSuitableDTD
(
CParserContext
&
aParserContext
)
{
aParserContext
.
mAutoDetectStatus
=
ePrimaryDetect
;
MOZ_ASSERT
(
aParserContext
.
mParserCommand
!
=
eViewSource
"
The
old
parser
is
not
supposed
to
be
used
for
View
Source
"
"
anymore
.
"
)
;
if
(
aParserContext
.
mDocType
!
=
eXML
)
{
return
new
CNavDTD
(
)
;
}
NS_ASSERTION
(
aParserContext
.
mDocType
=
=
eXML
"
What
are
you
trying
to
send
me
here
?
"
)
;
return
new
nsExpatDriver
(
)
;
}
NS_IMETHODIMP
nsParser
:
:
CancelParsingEvents
(
)
{
if
(
mFlags
&
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
)
{
NS_ASSERTION
(
mContinueEvent
"
mContinueEvent
is
null
"
)
;
mContinueEvent
=
nullptr
;
mFlags
&
=
~
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
;
}
return
NS_OK
;
}
#
define
PREFER_LATTER_ERROR_CODE
(
EXPR1
EXPR2
RV
)
{
\
nsresult
RV
#
#
__temp
=
EXPR1
;
\
RV
=
EXPR2
;
\
if
(
NS_FAILED
(
RV
)
)
{
\
RV
=
RV
#
#
__temp
;
\
}
\
}
nsresult
nsParser
:
:
WillBuildModel
(
nsString
&
aFilename
)
{
if
(
!
mParserContext
)
return
NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT
;
if
(
eUnknownDetect
!
=
mParserContext
-
>
mAutoDetectStatus
)
return
NS_OK
;
if
(
eDTDMode_unknown
=
=
mParserContext
-
>
mDTDMode
|
|
eDTDMode_autodetect
=
=
mParserContext
-
>
mDTDMode
)
{
if
(
mIsAboutBlank
)
{
mParserContext
-
>
mDTDMode
=
eDTDMode_quirks
;
mParserContext
-
>
mDocType
=
eHTML_Quirks
;
}
else
{
mParserContext
-
>
mDTDMode
=
eDTDMode_full_standards
;
mParserContext
-
>
mDocType
=
eXML
;
}
}
NS_ASSERTION
(
!
mDTD
|
|
!
mParserContext
-
>
mPrevContext
"
Clobbering
DTD
for
non
-
root
parser
context
!
"
)
;
mDTD
=
FindSuitableDTD
(
*
mParserContext
)
;
NS_ENSURE_TRUE
(
mDTD
NS_ERROR_OUT_OF_MEMORY
)
;
nsITokenizer
*
tokenizer
;
nsresult
rv
=
mParserContext
-
>
GetTokenizer
(
mDTD
mSink
tokenizer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDTD
-
>
WillBuildModel
(
*
mParserContext
tokenizer
mSink
)
;
nsresult
sinkResult
=
mSink
-
>
WillBuildModel
(
mDTD
-
>
GetMode
(
)
)
;
return
NS_FAILED
(
sinkResult
)
?
sinkResult
:
rv
;
}
nsresult
nsParser
:
:
DidBuildModel
(
nsresult
anErrorCode
)
{
nsresult
result
=
anErrorCode
;
if
(
IsComplete
(
)
)
{
if
(
mParserContext
&
&
!
mParserContext
-
>
mPrevContext
)
{
bool
terminated
=
mInternalState
=
=
NS_ERROR_HTMLPARSER_STOPPARSING
;
if
(
mDTD
&
&
mSink
)
{
nsresult
dtdResult
=
mDTD
-
>
DidBuildModel
(
anErrorCode
)
sinkResult
=
mSink
-
>
DidBuildModel
(
terminated
)
;
result
=
NS_FAILED
(
sinkResult
)
?
sinkResult
:
dtdResult
;
}
mParserContext
-
>
mRequest
=
nullptr
;
}
}
return
result
;
}
void
nsParser
:
:
PushContext
(
CParserContext
&
aContext
)
{
NS_ASSERTION
(
aContext
.
mPrevContext
=
=
mParserContext
"
Trying
to
push
a
context
whose
previous
context
differs
from
"
"
the
current
parser
context
.
"
)
;
mParserContext
=
&
aContext
;
}
CParserContext
*
nsParser
:
:
PopContext
(
)
{
CParserContext
*
oldContext
=
mParserContext
;
if
(
oldContext
)
{
mParserContext
=
oldContext
-
>
mPrevContext
;
if
(
mParserContext
)
{
if
(
mParserContext
-
>
mStreamListenerState
!
=
eOnStop
)
{
mParserContext
-
>
mStreamListenerState
=
oldContext
-
>
mStreamListenerState
;
}
}
}
return
oldContext
;
}
void
nsParser
:
:
SetUnusedInput
(
nsString
&
aBuffer
)
{
mUnusedInput
=
aBuffer
;
}
NS_IMETHODIMP
nsParser
:
:
Terminate
(
void
)
{
if
(
mInternalState
=
=
NS_ERROR_HTMLPARSER_STOPPARSING
)
{
return
NS_OK
;
}
nsresult
result
=
NS_OK
;
nsCOMPtr
<
nsIParser
>
kungFuDeathGrip
(
this
)
;
mInternalState
=
result
=
NS_ERROR_HTMLPARSER_STOPPARSING
;
CancelParsingEvents
(
)
;
while
(
mParserContext
&
&
mParserContext
-
>
mPrevContext
)
{
CParserContext
*
prev
=
mParserContext
-
>
mPrevContext
;
delete
mParserContext
;
mParserContext
=
prev
;
}
if
(
mDTD
)
{
mDTD
-
>
Terminate
(
)
;
DidBuildModel
(
result
)
;
}
else
if
(
mSink
)
{
result
=
mSink
-
>
DidBuildModel
(
true
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsParser
:
:
ContinueInterruptedParsing
(
)
{
if
(
!
IsOkToProcessNetworkData
(
)
)
{
return
NS_OK
;
}
nsresult
result
=
NS_OK
;
nsCOMPtr
<
nsIParser
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIContentSink
>
sinkDeathGrip
(
mSink
)
;
#
ifdef
DEBUG
if
(
mBlocked
)
{
NS_WARNING
(
"
Don
'
t
call
ContinueInterruptedParsing
on
a
blocked
parser
.
"
)
;
}
#
endif
bool
isFinalChunk
=
mParserContext
&
&
mParserContext
-
>
mStreamListenerState
=
=
eOnStop
;
mProcessingNetworkData
=
true
;
if
(
sinkDeathGrip
)
{
sinkDeathGrip
-
>
WillParse
(
)
;
}
result
=
ResumeParse
(
true
isFinalChunk
)
;
mProcessingNetworkData
=
false
;
if
(
result
!
=
NS_OK
)
{
result
=
mInternalState
;
}
return
result
;
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
BlockParser
(
)
{
mBlocked
+
+
;
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
UnblockParser
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mBlocked
>
0
)
;
if
(
MOZ_LIKELY
(
mBlocked
>
0
)
)
{
mBlocked
-
-
;
}
}
NS_IMETHODIMP_
(
void
)
nsParser
:
:
ContinueInterruptedParsingAsync
(
)
{
MOZ_ASSERT
(
mSink
)
;
if
(
MOZ_LIKELY
(
mSink
)
)
{
mSink
-
>
ContinueInterruptedParsingAsync
(
)
;
}
}
NS_IMETHODIMP_
(
bool
)
nsParser
:
:
IsParserEnabled
(
)
{
return
!
mBlocked
;
}
NS_IMETHODIMP_
(
bool
)
nsParser
:
:
IsComplete
(
)
{
return
!
(
mFlags
&
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
)
;
}
void
nsParser
:
:
HandleParserContinueEvent
(
nsParserContinueEvent
*
ev
)
{
if
(
mContinueEvent
!
=
ev
)
return
;
mFlags
&
=
~
NS_PARSER_FLAG_PENDING_CONTINUE_EVENT
;
mContinueEvent
=
nullptr
;
NS_ASSERTION
(
IsOkToProcessNetworkData
(
)
"
Interrupted
in
the
middle
of
a
script
?
"
)
;
ContinueInterruptedParsing
(
)
;
}
bool
nsParser
:
:
IsInsertionPointDefined
(
)
{
return
false
;
}
void
nsParser
:
:
PushDefinedInsertionPoint
(
)
{
}
void
nsParser
:
:
PopDefinedInsertionPoint
(
)
{
}
void
nsParser
:
:
MarkAsNotScriptCreated
(
const
char
*
aCommand
)
{
}
bool
nsParser
:
:
IsScriptCreated
(
)
{
return
false
;
}
NS_IMETHODIMP
nsParser
:
:
Parse
(
nsIURI
*
aURL
nsIRequestObserver
*
aListener
void
*
aKey
nsDTDMode
aMode
)
{
MOZ_ASSERT
(
aURL
"
Error
:
Null
URL
given
"
)
;
nsresult
result
=
NS_ERROR_HTMLPARSER_BADURL
;
mObserver
=
aListener
;
if
(
aURL
)
{
nsAutoCString
spec
;
nsresult
rv
=
aURL
-
>
GetSpec
(
spec
)
;
if
(
rv
!
=
NS_OK
)
{
return
rv
;
}
NS_ConvertUTF8toUTF16
theName
(
spec
)
;
nsScanner
*
theScanner
=
new
nsScanner
(
theName
false
)
;
CParserContext
*
pc
=
new
CParserContext
(
mParserContext
theScanner
aKey
mCommand
aListener
)
;
if
(
pc
&
&
theScanner
)
{
pc
-
>
mMultipart
=
true
;
pc
-
>
mContextType
=
CParserContext
:
:
eCTURL
;
pc
-
>
mDTDMode
=
aMode
;
PushContext
(
*
pc
)
;
result
=
NS_OK
;
}
else
{
result
=
mInternalState
=
NS_ERROR_HTMLPARSER_BADCONTEXT
;
}
}
return
result
;
}
nsresult
nsParser
:
:
Parse
(
const
nsAString
&
aSourceBuffer
void
*
aKey
bool
aLastCall
)
{
nsresult
result
=
NS_OK
;
if
(
mInternalState
=
=
NS_ERROR_HTMLPARSER_STOPPARSING
)
{
return
result
;
}
if
(
!
aLastCall
&
&
aSourceBuffer
.
IsEmpty
(
)
)
{
return
result
;
}
nsCOMPtr
<
nsIParser
>
kungFuDeathGrip
(
this
)
;
if
(
aLastCall
|
|
!
aSourceBuffer
.
IsEmpty
(
)
|
|
!
mUnusedInput
.
IsEmpty
(
)
)
{
CParserContext
*
pc
=
mParserContext
;
while
(
pc
&
&
pc
-
>
mKey
!
=
aKey
)
{
pc
=
pc
-
>
mPrevContext
;
}
if
(
!
pc
)
{
nsScanner
*
theScanner
=
new
nsScanner
(
mUnusedInput
)
;
NS_ENSURE_TRUE
(
theScanner
NS_ERROR_OUT_OF_MEMORY
)
;
eAutoDetectResult
theStatus
=
eUnknownDetect
;
if
(
mParserContext
&
&
mParserContext
-
>
mMimeType
.
EqualsLiteral
(
"
application
/
xml
"
)
)
{
NS_ASSERTION
(
mDTD
"
How
come
the
DTD
is
null
?
"
)
;
if
(
mParserContext
)
{
theStatus
=
mParserContext
-
>
mAutoDetectStatus
;
}
}
pc
=
new
CParserContext
(
mParserContext
theScanner
aKey
mCommand
0
theStatus
aLastCall
)
;
NS_ENSURE_TRUE
(
pc
NS_ERROR_OUT_OF_MEMORY
)
;
PushContext
(
*
pc
)
;
pc
-
>
mMultipart
=
!
aLastCall
;
if
(
pc
-
>
mPrevContext
)
{
pc
-
>
mMultipart
|
=
pc
-
>
mPrevContext
-
>
mMultipart
;
}
if
(
pc
-
>
mMultipart
)
{
pc
-
>
mStreamListenerState
=
eOnDataAvail
;
if
(
pc
-
>
mScanner
)
{
pc
-
>
mScanner
-
>
SetIncremental
(
true
)
;
}
}
else
{
pc
-
>
mStreamListenerState
=
eOnStop
;
if
(
pc
-
>
mScanner
)
{
pc
-
>
mScanner
-
>
SetIncremental
(
false
)
;
}
}
pc
-
>
mContextType
=
CParserContext
:
:
eCTString
;
pc
-
>
SetMimeType
(
NS_LITERAL_CSTRING
(
"
application
/
xml
"
)
)
;
pc
-
>
mDTDMode
=
eDTDMode_full_standards
;
mUnusedInput
.
Truncate
(
)
;
pc
-
>
mScanner
-
>
Append
(
aSourceBuffer
)
;
result
=
ResumeParse
(
false
false
false
)
;
}
else
{
pc
-
>
mScanner
-
>
Append
(
aSourceBuffer
)
;
if
(
!
pc
-
>
mPrevContext
)
{
if
(
aLastCall
)
{
pc
-
>
mStreamListenerState
=
eOnStop
;
pc
-
>
mScanner
-
>
SetIncremental
(
false
)
;
}
if
(
pc
=
=
mParserContext
)
{
ResumeParse
(
false
false
false
)
;
}
}
}
}
return
result
;
}
NS_IMETHODIMP
nsParser
:
:
ParseFragment
(
const
nsAString
&
aSourceBuffer
nsTArray
<
nsString
>
&
aTagStack
)
{
nsresult
result
=
NS_OK
;
nsAutoString
theContext
;
uint32_t
theCount
=
aTagStack
.
Length
(
)
;
uint32_t
theIndex
=
0
;
mFlags
&
=
~
NS_PARSER_FLAG_OBSERVERS_ENABLED
;
for
(
theIndex
=
0
;
theIndex
<
theCount
;
theIndex
+
+
)
{
theContext
.
Append
(
'
<
'
)
;
theContext
.
Append
(
aTagStack
[
theCount
-
theIndex
-
1
]
)
;
theContext
.
Append
(
'
>
'
)
;
}
if
(
theCount
=
=
0
)
{
theContext
.
Assign
(
'
'
)
;
}
result
=
Parse
(
theContext
(
void
*
)
&
theContext
false
)
;
if
(
NS_FAILED
(
result
)
)
{
mFlags
|
=
NS_PARSER_FLAG_OBSERVERS_ENABLED
;
return
result
;
}
if
(
!
mSink
)
{
return
NS_ERROR_HTMLPARSER_STOPPARSING
;
}
nsCOMPtr
<
nsIFragmentContentSink
>
fragSink
=
do_QueryInterface
(
mSink
)
;
NS_ASSERTION
(
fragSink
"
ParseFragment
requires
a
fragment
content
sink
"
)
;
fragSink
-
>
WillBuildContent
(
)
;
if
(
theCount
=
=
0
)
{
result
=
Parse
(
aSourceBuffer
&
theContext
true
)
;
fragSink
-
>
DidBuildContent
(
)
;
}
else
{
result
=
Parse
(
aSourceBuffer
+
NS_LITERAL_STRING
(
"
<
/
"
)
&
theContext
false
)
;
fragSink
-
>
DidBuildContent
(
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
nsAutoString
endContext
;
for
(
theIndex
=
0
;
theIndex
<
theCount
;
theIndex
+
+
)
{
if
(
theIndex
>
0
)
{
endContext
.
AppendLiteral
(
"
<
/
"
)
;
}
nsString
&
thisTag
=
aTagStack
[
theIndex
]
;
int32_t
endOfTag
=
thisTag
.
FindChar
(
char16_t
(
'
'
)
)
;
if
(
endOfTag
=
=
-
1
)
{
endContext
.
Append
(
thisTag
)
;
}
else
{
endContext
.
Append
(
Substring
(
thisTag
0
endOfTag
)
)
;
}
endContext
.
Append
(
'
>
'
)
;
}
result
=
Parse
(
endContext
&
theContext
true
)
;
}
}
mFlags
|
=
NS_PARSER_FLAG_OBSERVERS_ENABLED
;
return
result
;
}
nsresult
nsParser
:
:
ResumeParse
(
bool
allowIteration
bool
aIsFinalChunk
bool
aCanInterrupt
)
{
nsresult
result
=
NS_OK
;
if
(
!
mBlocked
&
&
mInternalState
!
=
NS_ERROR_HTMLPARSER_STOPPARSING
)
{
result
=
WillBuildModel
(
mParserContext
-
>
mScanner
-
>
GetFilename
(
)
)
;
if
(
NS_FAILED
(
result
)
)
{
mFlags
&
=
~
NS_PARSER_FLAG_CAN_TOKENIZE
;
return
result
;
}
if
(
mDTD
)
{
mSink
-
>
WillResume
(
)
;
bool
theIterationIsOk
=
true
;
while
(
result
=
=
NS_OK
&
&
theIterationIsOk
)
{
if
(
!
mUnusedInput
.
IsEmpty
(
)
&
&
mParserContext
-
>
mScanner
)
{
mParserContext
-
>
mScanner
-
>
UngetReadable
(
mUnusedInput
)
;
mUnusedInput
.
Truncate
(
0
)
;
}
nsresult
theTokenizerResult
=
(
mFlags
&
NS_PARSER_FLAG_CAN_TOKENIZE
)
?
Tokenize
(
aIsFinalChunk
)
:
NS_OK
;
result
=
BuildModel
(
)
;
if
(
result
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
&
&
aIsFinalChunk
)
{
PostContinueEvent
(
)
;
}
theIterationIsOk
=
theTokenizerResult
!
=
NS_ERROR_HTMLPARSER_EOF
&
&
result
!
=
NS_ERROR_HTMLPARSER_INTERRUPTED
;
if
(
NS_ERROR_HTMLPARSER_BLOCK
=
=
result
)
{
mSink
-
>
WillInterrupt
(
)
;
if
(
!
mBlocked
)
{
BlockParser
(
)
;
}
return
NS_OK
;
}
if
(
NS_ERROR_HTMLPARSER_STOPPARSING
=
=
result
)
{
if
(
mInternalState
!
=
NS_ERROR_HTMLPARSER_STOPPARSING
)
{
DidBuildModel
(
mStreamStatus
)
;
mInternalState
=
result
;
}
return
NS_OK
;
}
if
(
(
NS_OK
=
=
result
&
&
theTokenizerResult
=
=
NS_ERROR_HTMLPARSER_EOF
)
|
|
result
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
{
bool
theContextIsStringBased
=
CParserContext
:
:
eCTString
=
=
mParserContext
-
>
mContextType
;
if
(
mParserContext
-
>
mStreamListenerState
=
=
eOnStop
|
|
!
mParserContext
-
>
mMultipart
|
|
theContextIsStringBased
)
{
if
(
!
mParserContext
-
>
mPrevContext
)
{
if
(
mParserContext
-
>
mStreamListenerState
=
=
eOnStop
)
{
DidBuildModel
(
mStreamStatus
)
;
return
NS_OK
;
}
}
else
{
CParserContext
*
theContext
=
PopContext
(
)
;
if
(
theContext
)
{
theIterationIsOk
=
allowIteration
&
&
theContextIsStringBased
;
if
(
theContext
-
>
mCopyUnused
)
{
if
(
!
theContext
-
>
mScanner
-
>
CopyUnusedData
(
mUnusedInput
)
)
{
mInternalState
=
NS_ERROR_OUT_OF_MEMORY
;
}
}
delete
theContext
;
}
result
=
mInternalState
;
aIsFinalChunk
=
mParserContext
&
&
mParserContext
-
>
mStreamListenerState
=
=
eOnStop
;
}
}
}
if
(
theTokenizerResult
=
=
NS_ERROR_HTMLPARSER_EOF
|
|
result
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
{
result
=
(
result
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
?
NS_OK
:
result
;
mSink
-
>
WillInterrupt
(
)
;
}
}
}
else
{
mInternalState
=
result
=
NS_ERROR_HTMLPARSER_UNRESOLVEDDTD
;
}
}
return
(
result
=
=
NS_ERROR_HTMLPARSER_INTERRUPTED
)
?
NS_OK
:
result
;
}
nsresult
nsParser
:
:
BuildModel
(
)
{
nsITokenizer
*
theTokenizer
=
nullptr
;
nsresult
result
=
NS_OK
;
if
(
mParserContext
)
{
result
=
mParserContext
-
>
GetTokenizer
(
mDTD
mSink
theTokenizer
)
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
if
(
mDTD
)
{
result
=
mDTD
-
>
BuildModel
(
theTokenizer
mSink
)
;
}
}
else
{
mInternalState
=
result
=
NS_ERROR_HTMLPARSER_BADTOKENIZER
;
}
return
result
;
}
nsresult
nsParser
:
:
OnStartRequest
(
nsIRequest
*
request
nsISupports
*
aContext
)
{
MOZ_ASSERT
(
eNone
=
=
mParserContext
-
>
mStreamListenerState
"
Parser
'
s
nsIStreamListener
API
was
not
setup
"
"
correctly
in
constructor
.
"
)
;
if
(
mObserver
)
{
mObserver
-
>
OnStartRequest
(
request
aContext
)
;
}
mParserContext
-
>
mStreamListenerState
=
eOnStart
;
mParserContext
-
>
mAutoDetectStatus
=
eUnknownDetect
;
mParserContext
-
>
mRequest
=
request
;
NS_ASSERTION
(
!
mParserContext
-
>
mPrevContext
"
Clobbering
DTD
for
non
-
root
parser
context
!
"
)
;
mDTD
=
nullptr
;
nsresult
rv
;
nsAutoCString
contentType
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
if
(
channel
)
{
rv
=
channel
-
>
GetContentType
(
contentType
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mParserContext
-
>
SetMimeType
(
contentType
)
;
}
}
rv
=
NS_OK
;
return
rv
;
}
static
bool
ExtractCharsetFromXmlDeclaration
(
const
unsigned
char
*
aBytes
int32_t
aLen
nsCString
&
oCharset
)
{
oCharset
.
Truncate
(
)
;
if
(
(
aLen
>
=
5
)
&
&
(
'
<
'
=
=
aBytes
[
0
]
)
&
&
(
'
?
'
=
=
aBytes
[
1
]
)
&
&
(
'
x
'
=
=
aBytes
[
2
]
)
&
&
(
'
m
'
=
=
aBytes
[
3
]
)
&
&
(
'
l
'
=
=
aBytes
[
4
]
)
)
{
int32_t
i
;
bool
versionFound
=
false
encodingFound
=
false
;
for
(
i
=
6
;
i
<
aLen
&
&
!
encodingFound
;
+
+
i
)
{
if
(
(
(
(
char
*
)
aBytes
)
[
i
]
=
=
'
?
'
)
&
&
(
(
i
+
1
)
<
aLen
)
&
&
(
(
(
char
*
)
aBytes
)
[
i
+
1
]
=
=
'
>
'
)
)
{
break
;
}
if
(
!
versionFound
)
{
if
(
(
(
(
char
*
)
aBytes
)
[
i
]
=
=
'
n
'
)
&
&
(
i
>
=
12
)
&
&
(
0
=
=
PL_strncmp
(
"
versio
"
(
char
*
)
(
aBytes
+
i
-
6
)
6
)
)
)
{
char
q
=
0
;
for
(
+
+
i
;
i
<
aLen
;
+
+
i
)
{
char
qi
=
(
(
char
*
)
aBytes
)
[
i
]
;
if
(
qi
=
=
'
\
'
'
|
|
qi
=
=
'
"
'
)
{
if
(
q
&
&
q
=
=
qi
)
{
versionFound
=
true
;
break
;
}
else
{
q
=
qi
;
}
}
}
}
}
else
{
if
(
(
(
(
char
*
)
aBytes
)
[
i
]
=
=
'
g
'
)
&
&
(
i
>
=
25
)
&
&
(
0
=
=
PL_strncmp
(
"
encodin
"
(
char
*
)
(
aBytes
+
i
-
7
)
7
)
)
)
{
int32_t
encStart
=
0
;
char
q
=
0
;
for
(
+
+
i
;
i
<
aLen
;
+
+
i
)
{
char
qi
=
(
(
char
*
)
aBytes
)
[
i
]
;
if
(
qi
=
=
'
\
'
'
|
|
qi
=
=
'
"
'
)
{
if
(
q
&
&
q
=
=
qi
)
{
int32_t
count
=
i
-
encStart
;
if
(
count
>
0
&
&
PL_strncasecmp
(
"
UTF
-
16
"
(
char
*
)
(
aBytes
+
encStart
)
count
)
)
{
oCharset
.
Assign
(
(
char
*
)
(
aBytes
+
encStart
)
count
)
;
}
encodingFound
=
true
;
break
;
}
else
{
encStart
=
i
+
1
;
q
=
qi
;
}
}
}
}
}
}
}
return
!
oCharset
.
IsEmpty
(
)
;
}
inline
char
GetNextChar
(
nsACString
:
:
const_iterator
&
aStart
nsACString
:
:
const_iterator
&
aEnd
)
{
NS_ASSERTION
(
aStart
!
=
aEnd
"
end
of
buffer
"
)
;
return
(
+
+
aStart
!
=
aEnd
)
?
*
aStart
:
'
\
0
'
;
}
static
nsresult
NoOpParserWriteFunc
(
nsIInputStream
*
in
void
*
closure
const
char
*
fromRawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
{
*
writeCount
=
count
;
return
NS_OK
;
}
typedef
struct
{
bool
mNeedCharsetCheck
;
nsParser
*
mParser
;
nsScanner
*
mScanner
;
nsIRequest
*
mRequest
;
}
ParserWriteStruct
;
static
nsresult
ParserWriteFunc
(
nsIInputStream
*
in
void
*
closure
const
char
*
fromRawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
{
nsresult
result
;
ParserWriteStruct
*
pws
=
static_cast
<
ParserWriteStruct
*
>
(
closure
)
;
const
unsigned
char
*
buf
=
reinterpret_cast
<
const
unsigned
char
*
>
(
fromRawSegment
)
;
uint32_t
theNumRead
=
count
;
if
(
!
pws
)
{
return
NS_ERROR_FAILURE
;
}
if
(
pws
-
>
mNeedCharsetCheck
)
{
pws
-
>
mNeedCharsetCheck
=
false
;
int32_t
source
;
auto
preferred
=
pws
-
>
mParser
-
>
GetDocumentCharset
(
source
)
;
const
Encoding
*
encoding
;
size_t
bomLength
;
Tie
(
encoding
bomLength
)
=
Encoding
:
:
ForBOM
(
MakeSpan
(
buf
count
)
)
;
Unused
<
<
bomLength
;
if
(
encoding
)
{
preferred
=
WrapNotNull
(
encoding
)
;
source
=
kCharsetFromByteOrderMark
;
}
else
if
(
source
<
kCharsetFromChannel
)
{
nsAutoCString
declCharset
;
if
(
ExtractCharsetFromXmlDeclaration
(
buf
count
declCharset
)
)
{
encoding
=
Encoding
:
:
ForLabel
(
declCharset
)
;
if
(
encoding
)
{
preferred
=
WrapNotNull
(
encoding
)
;
source
=
kCharsetFromMetaTag
;
}
}
}
pws
-
>
mParser
-
>
SetDocumentCharset
(
preferred
source
)
;
pws
-
>
mParser
-
>
SetSinkCharset
(
preferred
)
;
}
result
=
pws
-
>
mScanner
-
>
Append
(
fromRawSegment
theNumRead
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
*
writeCount
=
count
;
}
return
result
;
}
nsresult
nsParser
:
:
OnDataAvailable
(
nsIRequest
*
request
nsISupports
*
aContext
nsIInputStream
*
pIStream
uint64_t
sourceOffset
uint32_t
aLength
)
{
MOZ_ASSERT
(
(
eOnStart
=
=
mParserContext
-
>
mStreamListenerState
|
|
eOnDataAvail
=
=
mParserContext
-
>
mStreamListenerState
)
"
Error
:
OnStartRequest
(
)
must
be
called
before
OnDataAvailable
(
)
"
)
;
MOZ_ASSERT
(
NS_InputStreamIsBuffered
(
pIStream
)
"
Must
have
a
buffered
input
stream
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mIsAboutBlank
)
{
MOZ_ASSERT
(
false
"
Must
not
get
OnDataAvailable
for
about
:
blank
"
)
;
uint32_t
totalRead
;
rv
=
pIStream
-
>
ReadSegments
(
NoOpParserWriteFunc
nullptr
aLength
&
totalRead
)
;
return
rv
;
}
CParserContext
*
theContext
=
mParserContext
;
while
(
theContext
&
&
theContext
-
>
mRequest
!
=
request
)
{
theContext
=
theContext
-
>
mPrevContext
;
}
if
(
theContext
)
{
theContext
-
>
mStreamListenerState
=
eOnDataAvail
;
if
(
eInvalidDetect
=
=
theContext
-
>
mAutoDetectStatus
)
{
if
(
theContext
-
>
mScanner
)
{
nsScannerIterator
iter
;
theContext
-
>
mScanner
-
>
EndReading
(
iter
)
;
theContext
-
>
mScanner
-
>
SetPosition
(
iter
true
)
;
}
}
uint32_t
totalRead
;
ParserWriteStruct
pws
;
pws
.
mNeedCharsetCheck
=
true
;
pws
.
mParser
=
this
;
pws
.
mScanner
=
theContext
-
>
mScanner
;
pws
.
mRequest
=
request
;
rv
=
pIStream
-
>
ReadSegments
(
ParserWriteFunc
&
pws
aLength
&
totalRead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
IsOkToProcessNetworkData
(
)
)
{
nsCOMPtr
<
nsIParser
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIContentSink
>
sinkDeathGrip
(
mSink
)
;
mProcessingNetworkData
=
true
;
if
(
sinkDeathGrip
)
{
sinkDeathGrip
-
>
WillParse
(
)
;
}
rv
=
ResumeParse
(
)
;
mProcessingNetworkData
=
false
;
}
}
else
{
rv
=
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
nsresult
nsParser
:
:
OnStopRequest
(
nsIRequest
*
request
nsISupports
*
aContext
nsresult
status
)
{
nsresult
rv
=
NS_OK
;
CParserContext
*
pc
=
mParserContext
;
while
(
pc
)
{
if
(
pc
-
>
mRequest
=
=
request
)
{
pc
-
>
mStreamListenerState
=
eOnStop
;
pc
-
>
mScanner
-
>
SetIncremental
(
false
)
;
break
;
}
pc
=
pc
-
>
mPrevContext
;
}
mStreamStatus
=
status
;
if
(
IsOkToProcessNetworkData
(
)
&
&
NS_SUCCEEDED
(
rv
)
)
{
mProcessingNetworkData
=
true
;
if
(
mSink
)
{
mSink
-
>
WillParse
(
)
;
}
rv
=
ResumeParse
(
true
true
)
;
mProcessingNetworkData
=
false
;
}
if
(
mObserver
)
{
mObserver
-
>
OnStopRequest
(
request
aContext
status
)
;
}
return
rv
;
}
bool
nsParser
:
:
WillTokenize
(
bool
aIsFinalChunk
)
{
if
(
!
mParserContext
)
{
return
true
;
}
nsITokenizer
*
theTokenizer
;
nsresult
result
=
mParserContext
-
>
GetTokenizer
(
mDTD
mSink
theTokenizer
)
;
NS_ENSURE_SUCCESS
(
result
false
)
;
return
NS_SUCCEEDED
(
theTokenizer
-
>
WillTokenize
(
aIsFinalChunk
)
)
;
}
nsresult
nsParser
:
:
Tokenize
(
bool
aIsFinalChunk
)
{
nsITokenizer
*
theTokenizer
;
nsresult
result
=
NS_ERROR_NOT_AVAILABLE
;
if
(
mParserContext
)
{
result
=
mParserContext
-
>
GetTokenizer
(
mDTD
mSink
theTokenizer
)
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
bool
flushTokens
=
false
;
bool
killSink
=
false
;
WillTokenize
(
aIsFinalChunk
)
;
while
(
NS_SUCCEEDED
(
result
)
)
{
mParserContext
-
>
mScanner
-
>
Mark
(
)
;
result
=
theTokenizer
-
>
ConsumeToken
(
*
mParserContext
-
>
mScanner
flushTokens
)
;
if
(
NS_FAILED
(
result
)
)
{
mParserContext
-
>
mScanner
-
>
RewindToMark
(
)
;
if
(
NS_ERROR_HTMLPARSER_EOF
=
=
result
)
{
break
;
}
if
(
NS_ERROR_HTMLPARSER_STOPPARSING
=
=
result
)
{
killSink
=
true
;
result
=
Terminate
(
)
;
break
;
}
}
else
if
(
flushTokens
&
&
(
mFlags
&
NS_PARSER_FLAG_OBSERVERS_ENABLED
)
)
{
mFlags
|
=
NS_PARSER_FLAG_FLUSH_TOKENS
;
mParserContext
-
>
mScanner
-
>
Mark
(
)
;
break
;
}
}
if
(
killSink
)
{
mSink
=
nullptr
;
}
}
else
{
result
=
mInternalState
=
NS_ERROR_HTMLPARSER_BADTOKENIZER
;
}
return
result
;
}
NS_IMETHODIMP
nsParser
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
nsresult
result
=
NS_ERROR_NOT_AVAILABLE
;
if
(
mParserContext
&
&
mParserContext
-
>
mRequest
)
{
result
=
CallQueryInterface
(
mParserContext
-
>
mRequest
aChannel
)
;
}
return
result
;
}
NS_IMETHODIMP
nsParser
:
:
GetDTD
(
nsIDTD
*
*
aDTD
)
{
if
(
mParserContext
)
{
NS_IF_ADDREF
(
*
aDTD
=
mDTD
)
;
}
return
NS_OK
;
}
nsIStreamListener
*
nsParser
:
:
GetStreamListener
(
)
{
return
this
;
}
