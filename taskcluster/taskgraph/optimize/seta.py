from
__future__
import
absolute_import
print_function
unicode_literals
import
json
import
logging
import
requests
from
collections
import
defaultdict
import
attr
from
redo
import
retry
from
requests
import
exceptions
from
taskgraph
.
optimize
import
OptimizationStrategy
register_strategy
logger
=
logging
.
getLogger
(
__name__
)
SETA_PROJECTS
=
[
'
mozilla
-
inbound
'
'
autoland
'
]
SETA_HIGH_PRIORITY
=
1
SETA_LOW_PRIORITY
=
5
SETA_ENDPOINT
=
"
https
:
/
/
treeherder
.
mozilla
.
org
/
api
/
project
/
%
s
/
seta
/
"
\
                
"
job
-
priorities
/
?
build_system_type
=
%
s
&
priority
=
%
s
"
PUSH_ENDPOINT
=
"
https
:
/
/
hg
.
mozilla
.
org
/
integration
/
%
s
/
json
-
pushes
/
?
startID
=
%
d
&
endID
=
%
d
"
attr
.
s
(
frozen
=
True
)
class
SETA
(
object
)
:
    
"
"
"
    
Interface
to
the
SETA
service
which
defines
low
-
value
tasks
that
can
be
optimized
out
    
of
the
taskgraph
.
    
"
"
"
    
low_value_tasks
=
attr
.
ib
(
factory
=
dict
init
=
False
)
    
low_value_bb_tasks
=
attr
.
ib
(
factory
=
dict
init
=
False
)
    
push_dates
=
attr
.
ib
(
factory
=
lambda
:
defaultdict
(
dict
)
init
=
False
)
    
failed_json_push_calls
=
attr
.
ib
(
factory
=
list
init
=
False
)
    
def
_get_task_string
(
self
task_tuple
)
:
        
task_tuple
=
[
x
for
x
in
task_tuple
if
len
(
x
)
!
=
0
]
        
if
len
(
task_tuple
)
=
=
0
:
            
return
'
'
        
if
len
(
task_tuple
)
!
=
3
:
            
return
'
'
.
join
(
task_tuple
)
        
return
'
test
-
%
s
/
%
s
-
%
s
'
%
(
task_tuple
[
0
]
task_tuple
[
1
]
task_tuple
[
2
]
)
    
def
query_low_value_tasks
(
self
project
)
:
        
low_value_tasks
=
[
]
        
url_low
=
SETA_ENDPOINT
%
(
project
'
taskcluster
'
SETA_LOW_PRIORITY
)
        
url_high
=
SETA_ENDPOINT
%
(
project
'
taskcluster
'
SETA_HIGH_PRIORITY
)
        
try
:
            
logger
.
debug
(
"
Retrieving
low
-
value
jobs
list
from
SETA
"
)
            
response
=
retry
(
requests
.
get
attempts
=
2
sleeptime
=
10
                             
args
=
(
url_low
)
                             
kwargs
=
{
'
timeout
'
:
60
'
headers
'
:
'
'
}
)
            
task_list
=
json
.
loads
(
response
.
content
)
.
get
(
'
jobtypes
'
'
'
)
            
if
type
(
task_list
)
=
=
dict
and
len
(
task_list
)
>
0
:
                
if
type
(
task_list
.
values
(
)
[
0
]
)
=
=
list
and
len
(
task_list
.
values
(
)
[
0
]
)
>
0
:
                    
low_value_tasks
=
set
(
task_list
.
values
(
)
[
0
]
)
            
logger
.
debug
(
"
Retrieving
high
-
value
jobs
list
from
SETA
"
)
            
response
=
retry
(
requests
.
get
attempts
=
2
sleeptime
=
10
                             
args
=
(
url_high
)
                             
kwargs
=
{
'
timeout
'
:
60
'
headers
'
:
'
'
}
)
            
task_list
=
json
.
loads
(
response
.
content
)
.
get
(
'
jobtypes
'
'
'
)
            
high_value_tasks
=
set
(
[
]
)
            
if
type
(
task_list
)
=
=
dict
and
len
(
task_list
)
>
0
:
                
if
type
(
task_list
.
values
(
)
[
0
]
)
=
=
list
and
len
(
task_list
.
values
(
)
[
0
]
)
>
0
:
                    
high_value_tasks
=
set
(
task_list
.
values
(
)
[
0
]
)
            
def
only_android_raptor
(
task
)
:
                
return
task
.
startswith
(
'
test
-
android
'
)
and
'
raptor
'
in
task
            
high_value_android_tasks
=
list
(
filter
(
only_android_raptor
high_value_tasks
)
)
            
low_value_tasks
.
update
(
high_value_android_tasks
)
            
seta_conversions
=
{
                
'
test
-
linux32
/
opt
'
:
'
test
-
linux32
-
shippable
/
opt
'
                
'
test
-
linux64
/
opt
'
:
'
test
-
linux64
-
shippable
/
opt
'
                
'
test
-
linux64
-
pgo
/
opt
'
:
'
test
-
linux64
-
shippable
/
opt
'
                
'
test
-
linux64
-
pgo
-
qr
/
opt
'
:
'
test
-
linux64
-
shippable
-
qr
/
opt
'
                
'
test
-
linux64
-
qr
/
opt
'
:
'
test
-
linux64
-
shippable
-
qr
/
opt
'
                
'
test
-
windows7
-
32
/
opt
'
:
'
test
-
windows7
-
32
-
shippable
/
opt
'
                
'
test
-
windows7
-
32
-
pgo
/
opt
'
:
'
test
-
windows7
-
32
-
shippable
/
opt
'
                
'
test
-
windows10
-
64
/
opt
'
:
'
test
-
windows10
-
64
-
shippable
/
opt
'
                
'
test
-
windows10
-
64
-
pgo
/
opt
'
:
'
test
-
windows10
-
64
-
shippable
/
opt
'
                
'
test
-
windows10
-
64
-
pgo
-
qr
/
opt
'
:
'
test
-
windows10
-
64
-
shippable
-
qr
/
opt
'
                
'
test
-
windows10
-
64
-
qr
/
opt
'
:
'
test
-
windows10
-
64
-
shippable
-
qr
/
opt
'
                
}
            
for
old
new
in
seta_conversions
.
iteritems
(
)
:
                
if
any
(
t
.
startswith
(
old
)
for
t
in
low_value_tasks
)
:
                    
low_value_tasks
.
update
(
                        
[
t
.
replace
(
old
new
)
for
t
in
low_value_tasks
]
                    
)
            
for
old
new
in
seta_conversions
.
iteritems
(
)
:
                
if
any
(
t
.
startswith
(
old
)
for
t
in
high_value_tasks
)
:
                    
high_value_tasks
.
update
(
                        
[
t
.
replace
(
old
new
)
for
t
in
high_value_tasks
]
                    
)
            
def
new_as_old_is_high_value
(
label
)
:
                
for
old
new
in
seta_conversions
.
iteritems
(
)
:
                    
if
label
.
startswith
(
new
)
:
                        
old_label
=
label
.
replace
(
new
old
)
                        
if
old_label
in
high_value_tasks
:
                            
return
True
                
return
False
            
low_value_tasks
=
set
(
[
x
for
x
in
low_value_tasks
if
not
new_as_old_is_high_value
(
x
)
]
)
            
low_value_tasks
=
set
(
[
x
for
x
in
low_value_tasks
                                   
if
'
build
'
not
in
x
or
'
fuzzing
'
in
x
]
)
            
low_value_tasks
=
list
(
set
(
low_value_tasks
)
)
        
except
exceptions
.
Timeout
:
            
logger
.
warning
(
"
SETA
timeout
we
will
treat
all
test
tasks
as
high
value
.
"
)
        
except
exceptions
.
ConnectionError
:
            
logger
.
warning
(
"
SETA
connection
error
we
will
treat
all
test
tasks
as
high
value
.
"
)
        
except
exceptions
.
HTTPError
:
            
logger
.
warning
(
"
We
got
bad
Http
response
from
ouija
"
                           
"
we
will
treat
all
test
tasks
as
high
value
.
"
)
        
except
exceptions
.
RequestException
as
error
:
            
logger
.
warning
(
error
)
        
except
ValueError
as
error
:
            
logger
.
warning
(
"
Invalid
JSON
possible
server
error
:
{
}
"
.
format
(
error
)
)
        
return
low_value_tasks
    
def
minutes_between_pushes
(
self
project
cur_push_id
cur_push_date
time_interval
)
:
        
min_between_pushes
=
time_interval
        
prev_push_id
=
cur_push_id
-
1
        
self
.
push_dates
[
project
]
.
update
(
{
cur_push_id
:
cur_push_date
}
)
        
prev_push_date
=
self
.
push_dates
[
project
]
.
get
(
prev_push_id
0
)
        
if
cur_push_date
>
0
and
prev_push_date
>
0
:
            
return
(
cur_push_date
-
prev_push_date
)
/
60
        
if
prev_push_id
in
self
.
failed_json_push_calls
:
            
return
min_between_pushes
        
url
=
PUSH_ENDPOINT
%
(
project
cur_push_id
-
2
prev_push_id
)
        
try
:
            
response
=
retry
(
requests
.
get
attempts
=
2
sleeptime
=
10
                             
args
=
(
url
)
                             
kwargs
=
{
'
timeout
'
:
60
'
headers
'
:
{
'
User
-
Agent
'
:
'
TaskCluster
'
}
}
)
            
prev_push_date
=
json
.
loads
(
response
.
content
)
.
get
(
str
(
prev_push_id
)
{
}
)
.
get
(
'
date
'
0
)
            
self
.
push_dates
[
project
]
.
update
(
{
prev_push_id
:
prev_push_date
}
)
            
if
cur_push_date
>
0
and
prev_push_date
>
0
:
                
min_between_pushes
=
(
cur_push_date
-
prev_push_date
)
/
60
        
except
exceptions
.
Timeout
:
            
logger
.
warning
(
"
json
-
pushes
timeout
treating
task
as
high
value
"
)
            
self
.
failed_json_push_calls
.
append
(
prev_push_id
)
        
except
exceptions
.
ConnectionError
:
            
logger
.
warning
(
"
json
-
pushes
connection
error
treating
task
as
high
value
"
)
            
self
.
failed_json_push_calls
.
append
(
prev_push_id
)
        
except
exceptions
.
HTTPError
:
            
logger
.
warning
(
"
Bad
Http
response
treating
task
as
high
value
"
)
            
self
.
failed_json_push_calls
.
append
(
prev_push_id
)
        
except
ValueError
as
error
:
            
logger
.
warning
(
"
Invalid
JSON
possible
server
error
:
{
}
"
.
format
(
error
)
)
            
self
.
failed_json_push_calls
.
append
(
prev_push_id
)
        
except
exceptions
.
RequestException
as
error
:
            
logger
.
warning
(
error
)
            
self
.
failed_json_push_calls
.
append
(
prev_push_id
)
        
return
min_between_pushes
    
def
is_low_value_task
(
self
label
project
pushlog_id
push_date
                          
push_interval
time_interval
)
:
        
if
project
not
in
SETA_PROJECTS
:
            
return
False
        
if
int
(
pushlog_id
)
%
push_interval
=
=
0
:
            
return
False
        
if
self
.
minutes_between_pushes
(
                
project
                
int
(
pushlog_id
)
                
int
(
push_date
)
                
time_interval
)
>
=
time_interval
:
            
return
False
        
if
project
not
in
self
.
low_value_tasks
:
            
self
.
low_value_tasks
[
project
]
=
self
.
query_low_value_tasks
(
project
)
        
return
label
in
self
.
low_value_tasks
[
project
]
is_low_value_task
=
SETA
(
)
.
is_low_value_task
register_strategy
(
'
seta
'
args
=
(
10
60
)
)
class
SkipLowValue
(
OptimizationStrategy
)
:
    
def
__init__
(
self
push_interval
time_interval
)
:
        
self
.
push_interval
=
push_interval
        
self
.
time_interval
=
time_interval
    
def
should_remove_task
(
self
task
params
_
)
:
        
label
=
task
.
label
        
if
is_low_value_task
(
label
                             
params
.
get
(
'
project
'
)
                             
params
.
get
(
'
pushlog_id
'
)
                             
params
.
get
(
'
pushdate
'
)
                             
self
.
push_interval
                             
self
.
time_interval
)
:
            
return
True
        
else
:
            
return
False
