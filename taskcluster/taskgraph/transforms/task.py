"
"
"
These
transformations
take
a
task
description
and
turn
it
into
a
TaskCluster
task
definition
(
along
with
attributes
label
etc
.
)
.
The
input
to
these
transformations
is
generic
to
any
kind
of
task
but
abstracts
away
some
of
the
complexities
of
worker
implementations
scopes
and
treeherder
annotations
.
"
"
"
from
__future__
import
absolute_import
print_function
unicode_literals
import
json
import
time
from
taskgraph
.
util
.
treeherder
import
split_symbol
from
taskgraph
.
transforms
.
base
import
TransformSequence
from
taskgraph
.
util
.
schema
import
validate_schema
from
voluptuous
import
Schema
Any
Required
Optional
Extra
from
.
gecko_v2_whitelist
import
JOB_NAME_WHITELIST
JOB_NAME_WHITELIST_ERROR
taskref_or_string
=
Any
(
    
basestring
    
{
Required
(
'
task
-
reference
'
)
:
basestring
}
)
task_description_schema
=
Schema
(
{
    
Required
(
'
label
'
)
:
basestring
    
Required
(
'
description
'
)
:
basestring
    
Optional
(
'
attributes
'
)
:
{
basestring
:
object
}
    
Optional
(
'
dependencies
'
)
:
{
basestring
:
object
}
    
Optional
(
'
expires
-
after
'
)
:
basestring
    
Optional
(
'
deadline
-
after
'
)
:
basestring
    
Optional
(
'
routes
'
)
:
[
basestring
]
    
Optional
(
'
index
-
paths
'
)
:
[
basestring
]
    
Optional
(
'
scopes
'
)
:
[
basestring
]
    
Optional
(
'
extra
'
)
:
{
basestring
:
object
}
    
Optional
(
'
treeherder
'
)
:
{
        
'
symbol
'
:
basestring
        
'
kind
'
:
Any
(
'
build
'
'
test
'
'
other
'
)
        
'
tier
'
:
int
        
'
platform
'
:
basestring
        
Required
(
'
environments
'
default
=
[
'
production
'
'
staging
'
]
)
:
[
'
production
'
'
staging
'
]
    
}
    
Optional
(
'
index
'
)
:
{
        
'
product
'
:
Any
(
'
firefox
'
'
mobile
'
'
static
-
analysis
'
)
        
'
job
-
name
'
:
basestring
        
'
type
'
:
Any
(
'
generic
'
'
nightly
'
'
l10n
'
'
nightly
-
with
-
multi
-
l10n
'
)
        
'
rank
'
:
Any
(
            
'
by
-
tier
'
            
int
            
'
build_date
'
        
)
    
}
    
Optional
(
'
run
-
on
-
projects
'
)
:
[
basestring
]
    
Optional
(
'
coalesce
-
name
'
)
:
basestring
    
'
worker
-
type
'
:
basestring
    
Required
(
'
needs
-
sccache
'
default
=
False
)
:
bool
    
'
worker
'
:
Any
(
{
        
Required
(
'
implementation
'
)
:
Any
(
'
docker
-
worker
'
'
docker
-
engine
'
)
        
Required
(
'
docker
-
image
'
)
:
Any
(
            
basestring
            
{
'
in
-
tree
'
:
basestring
}
        
)
        
Required
(
'
relengapi
-
proxy
'
default
=
False
)
:
bool
        
Required
(
'
chain
-
of
-
trust
'
default
=
False
)
:
bool
        
Required
(
'
taskcluster
-
proxy
'
default
=
False
)
:
bool
        
Required
(
'
allow
-
ptrace
'
default
=
False
)
:
bool
        
Required
(
'
loopback
-
video
'
default
=
False
)
:
bool
        
Required
(
'
loopback
-
audio
'
default
=
False
)
:
bool
        
Optional
(
'
caches
'
)
:
[
{
            
'
type
'
:
'
persistent
'
            
'
name
'
:
basestring
            
'
mount
-
point
'
:
basestring
        
}
]
        
Optional
(
'
artifacts
'
)
:
[
{
            
'
type
'
:
Any
(
'
file
'
'
directory
'
)
            
'
path
'
:
basestring
            
'
name
'
:
basestring
        
}
]
        
Required
(
'
env
'
default
=
{
}
)
:
{
basestring
:
taskref_or_string
}
        
'
command
'
:
[
taskref_or_string
]
        
'
max
-
run
-
time
'
:
int
        
Optional
(
'
retry
-
exit
-
status
'
)
:
int
    
}
{
        
Required
(
'
implementation
'
)
:
'
generic
-
worker
'
        
'
command
'
:
[
taskref_or_string
]
        
Optional
(
'
artifacts
'
)
:
[
{
            
'
type
'
:
Any
(
'
file
'
'
directory
'
)
            
'
path
'
:
basestring
        
}
]
        
Optional
(
'
mounts
'
)
:
[
{
            
'
cache
-
name
'
:
basestring
            
'
path
'
:
basestring
        
}
]
        
Required
(
'
env
'
default
=
{
}
)
:
{
basestring
:
taskref_or_string
}
        
'
max
-
run
-
time
'
:
int
        
Optional
(
'
os
-
groups
'
default
=
[
]
)
:
[
basestring
]
    
}
{
        
Required
(
'
implementation
'
)
:
'
buildbot
-
bridge
'
        
'
buildername
'
:
basestring
        
'
sourcestamp
'
:
{
            
'
branch
'
:
basestring
            
Optional
(
'
revision
'
)
:
basestring
            
Optional
(
'
repository
'
)
:
basestring
            
Optional
(
'
project
'
)
:
basestring
        
}
        
'
properties
'
:
{
            
'
product
'
:
basestring
            
Extra
:
basestring
        
}
    
}
{
        
'
implementation
'
:
'
native
-
engine
'
        
Optional
(
'
context
'
)
:
basestring
        
Optional
(
'
reboot
'
)
:
bool
        
Required
(
'
command
'
)
:
[
taskref_or_string
]
        
Optional
(
'
env
'
)
:
{
basestring
:
taskref_or_string
}
        
Optional
(
'
artifacts
'
)
:
[
{
            
Required
(
'
type
'
)
:
Any
(
'
file
'
'
directory
'
)
            
Required
(
'
path
'
)
:
basestring
            
Required
(
'
name
'
)
:
basestring
        
}
]
    
}
{
        
Required
(
'
implementation
'
)
:
'
scriptworker
-
signing
'
        
Required
(
'
max
-
run
-
time
'
default
=
600
)
:
int
        
Required
(
'
upstream
-
artifacts
'
)
:
[
{
            
Required
(
'
taskId
'
)
:
taskref_or_string
            
Required
(
'
taskType
'
)
:
basestring
            
Required
(
'
paths
'
)
:
[
basestring
]
            
Required
(
'
formats
'
)
:
[
basestring
]
        
}
]
    
}
{
        
Required
(
'
implementation
'
)
:
'
beetmover
'
        
Required
(
'
max
-
run
-
time
'
default
=
600
)
:
int
        
Optional
(
'
locale
'
)
:
basestring
        
Required
(
'
upstream
-
artifacts
'
)
:
[
{
            
Required
(
'
taskId
'
)
:
taskref_or_string
            
Required
(
'
taskType
'
)
:
basestring
            
Required
(
'
paths
'
)
:
[
basestring
]
            
Required
(
'
locale
'
)
:
basestring
        
}
]
    
}
{
        
Required
(
'
implementation
'
)
:
'
balrog
'
        
Required
(
'
upstream
-
artifacts
'
)
:
[
{
            
Required
(
'
taskId
'
)
:
taskref_or_string
            
Required
(
'
taskType
'
)
:
basestring
            
Required
(
'
paths
'
)
:
[
basestring
]
        
}
]
    
}
)
    
Optional
(
'
when
'
)
:
Any
(
{
        
Optional
(
'
files
-
changed
'
)
:
[
basestring
]
    
}
)
}
)
GROUP_NAMES
=
{
    
'
tc
'
:
'
Executed
by
TaskCluster
'
    
'
tc
-
e10s
'
:
'
Executed
by
TaskCluster
with
e10s
'
    
'
tc
-
Fxfn
-
l
'
:
'
Firefox
functional
tests
(
local
)
executed
by
TaskCluster
'
    
'
tc
-
Fxfn
-
l
-
e10s
'
:
'
Firefox
functional
tests
(
local
)
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
Fxfn
-
r
'
:
'
Firefox
functional
tests
(
remote
)
executed
by
TaskCluster
'
    
'
tc
-
Fxfn
-
r
-
e10s
'
:
'
Firefox
functional
tests
(
remote
)
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
M
'
:
'
Mochitests
executed
by
TaskCluster
'
    
'
tc
-
M
-
e10s
'
:
'
Mochitests
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
M
-
V
'
:
'
Mochitests
on
Valgrind
executed
by
TaskCluster
'
    
'
tc
-
R
'
:
'
Reftests
executed
by
TaskCluster
'
    
'
tc
-
R
-
e10s
'
:
'
Reftests
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
T
'
:
'
Talos
performance
tests
executed
by
TaskCluster
'
    
'
tc
-
T
-
e10s
'
:
'
Talos
performance
tests
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
VP
'
:
'
VideoPuppeteer
tests
executed
by
TaskCluster
'
    
'
tc
-
W
'
:
'
Web
platform
tests
executed
by
TaskCluster
'
    
'
tc
-
W
-
e10s
'
:
'
Web
platform
tests
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
X
'
:
'
Xpcshell
tests
executed
by
TaskCluster
'
    
'
tc
-
X
-
e10s
'
:
'
Xpcshell
tests
executed
by
TaskCluster
with
e10s
'
    
'
tc
-
L10n
'
:
'
Localised
Repacks
executed
by
Taskcluster
'
    
'
tc
-
BM
-
L10n
'
:
'
Beetmover
for
locales
executed
by
Taskcluster
'
    
'
tc
-
Up
'
:
'
Balrog
submission
of
updates
executed
by
Taskcluster
'
    
'
tc
-
cs
'
:
'
Checksum
signing
executed
by
Taskcluster
'
    
'
tc
-
BMcs
'
:
'
Beetmover
checksums
executed
by
Taskcluster
'
    
'
Aries
'
:
'
Aries
Device
Image
'
    
'
Nexus
5
-
L
'
:
'
Nexus
5
-
L
Device
Image
'
    
'
TL
'
:
'
Toolchain
builds
for
Linux
64
-
bits
'
    
'
TM
'
:
'
Toolchain
builds
for
OSX
'
    
'
TW32
'
:
'
Toolchain
builds
for
Windows
32
-
bits
'
    
'
TW64
'
:
'
Toolchain
builds
for
Windows
64
-
bits
'
    
'
SM
-
tc
'
:
'
Spidermonkey
builds
'
}
UNKNOWN_GROUP_NAME
=
"
Treeherder
group
{
}
has
no
name
;
add
it
to
"
+
__file__
V2_ROUTE_TEMPLATES
=
[
    
"
index
.
gecko
.
v2
.
{
project
}
.
latest
.
{
product
}
.
{
job
-
name
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
pushdate
.
{
build_date_long
}
.
{
product
}
.
{
job
-
name
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
revision
.
{
head_rev
}
.
{
product
}
.
{
job
-
name
}
"
]
V2_NIGHTLY_TEMPLATES
=
[
    
"
index
.
gecko
.
v2
.
{
project
}
.
nightly
.
latest
.
{
product
}
.
{
job
-
name
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
nightly
.
{
build_date
}
.
revision
.
{
head_rev
}
.
{
product
}
.
{
job
-
name
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
nightly
.
{
build_date
}
.
latest
.
{
product
}
.
{
job
-
name
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
nightly
.
revision
.
{
head_rev
}
.
{
product
}
.
{
job
-
name
}
"
]
V2_L10N_TEMPLATES
=
[
    
"
index
.
gecko
.
v2
.
{
project
}
.
revision
.
{
head_rev
}
.
{
product
}
-
l10n
.
{
job
-
name
}
.
{
locale
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
pushdate
.
{
build_date_long
}
.
{
product
}
-
l10n
.
{
job
-
name
}
.
{
locale
}
"
    
"
index
.
gecko
.
v2
.
{
project
}
.
latest
.
{
product
}
-
l10n
.
{
job
-
name
}
.
{
locale
}
"
]
TREEHERDER_ROUTE_ROOTS
=
{
    
'
production
'
:
'
tc
-
treeherder
'
    
'
staging
'
:
'
tc
-
treeherder
-
stage
'
}
COALESCE_KEY
=
'
builds
.
{
project
}
.
{
name
}
'
payload_builders
=
{
}
def
payload_builder
(
name
)
:
    
def
wrap
(
func
)
:
        
payload_builders
[
name
]
=
func
        
return
func
    
return
wrap
index_builders
=
{
}
def
index_builder
(
name
)
:
    
def
wrap
(
func
)
:
        
index_builders
[
name
]
=
func
        
return
func
    
return
wrap
payload_builder
(
'
docker
-
worker
'
)
def
build_docker_worker_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
image
=
worker
[
'
docker
-
image
'
]
    
if
isinstance
(
image
dict
)
:
        
docker_image_task
=
'
build
-
docker
-
image
-
'
+
image
[
'
in
-
tree
'
]
        
task
.
setdefault
(
'
dependencies
'
{
}
)
[
'
docker
-
image
'
]
=
docker_image_task
        
image
=
{
            
"
path
"
:
"
public
/
image
.
tar
.
zst
"
            
"
taskId
"
:
{
"
task
-
reference
"
:
"
<
docker
-
image
>
"
}
            
"
type
"
:
"
task
-
image
"
        
}
    
features
=
{
}
    
if
worker
.
get
(
'
relengapi
-
proxy
'
)
:
        
features
[
'
relengAPIProxy
'
]
=
True
    
if
worker
.
get
(
'
taskcluster
-
proxy
'
)
:
        
features
[
'
taskclusterProxy
'
]
=
True
    
if
worker
.
get
(
'
allow
-
ptrace
'
)
:
        
features
[
'
allowPtrace
'
]
=
True
        
task_def
[
'
scopes
'
]
.
append
(
'
docker
-
worker
:
feature
:
allowPtrace
'
)
    
if
worker
.
get
(
'
chain
-
of
-
trust
'
)
:
        
features
[
'
chainOfTrust
'
]
=
True
    
if
task
.
get
(
'
needs
-
sccache
'
)
:
        
features
[
'
taskclusterProxy
'
]
=
True
        
task_def
[
'
scopes
'
]
.
append
(
            
'
assume
:
project
:
taskcluster
:
level
-
{
level
}
-
sccache
-
buckets
'
.
format
(
                
level
=
config
.
params
[
'
level
'
]
)
        
)
        
worker
[
'
env
'
]
[
'
USE_SCCACHE
'
]
=
'
1
'
    
else
:
        
worker
[
'
env
'
]
[
'
SCCACHE_DISABLE
'
]
=
'
1
'
    
capabilities
=
{
}
    
for
lo
in
'
audio
'
'
video
'
:
        
if
worker
.
get
(
'
loopback
-
'
+
lo
)
:
            
capitalized
=
'
loopback
'
+
lo
.
capitalize
(
)
            
devices
=
capabilities
.
setdefault
(
'
devices
'
{
}
)
            
devices
[
capitalized
]
=
True
            
task_def
[
'
scopes
'
]
.
append
(
'
docker
-
worker
:
capability
:
device
:
'
+
capitalized
)
    
task_def
[
'
payload
'
]
=
payload
=
{
        
'
command
'
:
worker
[
'
command
'
]
        
'
image
'
:
image
        
'
env
'
:
worker
[
'
env
'
]
    
}
    
if
'
max
-
run
-
time
'
in
worker
:
        
payload
[
'
maxRunTime
'
]
=
worker
[
'
max
-
run
-
time
'
]
    
if
'
retry
-
exit
-
status
'
in
worker
:
        
payload
[
'
onExitStatus
'
]
=
{
'
retry
'
:
[
worker
[
'
retry
-
exit
-
status
'
]
]
}
    
if
'
artifacts
'
in
worker
:
        
artifacts
=
{
}
        
for
artifact
in
worker
[
'
artifacts
'
]
:
            
artifacts
[
artifact
[
'
name
'
]
]
=
{
                
'
path
'
:
artifact
[
'
path
'
]
                
'
type
'
:
artifact
[
'
type
'
]
                
'
expires
'
:
task_def
[
'
expires
'
]
            
}
        
payload
[
'
artifacts
'
]
=
artifacts
    
if
'
caches
'
in
worker
:
        
caches
=
{
}
        
for
cache
in
worker
[
'
caches
'
]
:
            
caches
[
cache
[
'
name
'
]
]
=
cache
[
'
mount
-
point
'
]
            
task_def
[
'
scopes
'
]
.
append
(
'
docker
-
worker
:
cache
:
'
+
cache
[
'
name
'
]
)
        
payload
[
'
cache
'
]
=
caches
    
if
features
:
        
payload
[
'
features
'
]
=
features
    
if
capabilities
:
        
payload
[
'
capabilities
'
]
=
capabilities
    
if
'
coalesce
-
name
'
in
task
and
int
(
config
.
params
[
'
level
'
]
)
>
1
:
        
key
=
COALESCE_KEY
.
format
(
            
project
=
config
.
params
[
'
project
'
]
            
name
=
task
[
'
coalesce
-
name
'
]
)
        
payload
[
'
supersederUrl
'
]
=
"
https
:
/
/
coalesce
.
mozilla
-
releng
.
net
/
v1
/
list
/
"
+
key
payload_builder
(
'
generic
-
worker
'
)
def
build_generic_worker_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
artifacts
=
[
]
    
for
artifact
in
worker
[
'
artifacts
'
]
:
        
artifacts
.
append
(
{
            
'
path
'
:
artifact
[
'
path
'
]
            
'
type
'
:
artifact
[
'
type
'
]
            
'
expires
'
:
task_def
[
'
expires
'
]
        
}
)
    
mounts
=
[
]
    
for
mount
in
worker
.
get
(
'
mounts
'
[
]
)
:
        
mounts
.
append
(
{
            
'
cacheName
'
:
mount
[
'
cache
-
name
'
]
            
'
directory
'
:
mount
[
'
path
'
]
        
}
)
    
task_def
[
'
payload
'
]
=
{
        
'
command
'
:
worker
[
'
command
'
]
        
'
artifacts
'
:
artifacts
        
'
env
'
:
worker
.
get
(
'
env
'
{
}
)
        
'
mounts
'
:
mounts
        
'
maxRunTime
'
:
worker
[
'
max
-
run
-
time
'
]
        
'
osGroups
'
:
worker
.
get
(
'
os
-
groups
'
[
]
)
    
}
    
if
'
retry
-
exit
-
status
'
in
worker
:
        
raise
Exception
(
"
retry
-
exit
-
status
not
supported
in
generic
-
worker
"
)
payload_builder
(
'
scriptworker
-
signing
'
)
def
build_scriptworker_signing_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
task_def
[
'
payload
'
]
=
{
        
'
maxRunTime
'
:
worker
[
'
max
-
run
-
time
'
]
        
'
upstreamArtifacts
'
:
worker
[
'
upstream
-
artifacts
'
]
    
}
payload_builder
(
'
beetmover
'
)
def
build_beetmover_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
task_def
[
'
payload
'
]
=
{
        
'
maxRunTime
'
:
worker
[
'
max
-
run
-
time
'
]
        
'
upload_date
'
:
config
.
params
[
'
build_date
'
]
        
'
upstreamArtifacts
'
:
worker
[
'
upstream
-
artifacts
'
]
    
}
    
if
worker
.
get
(
'
locale
'
)
:
        
task_def
[
'
payload
'
]
[
'
locale
'
]
=
worker
[
'
locale
'
]
payload_builder
(
'
balrog
'
)
def
build_balrog_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
task_def
[
'
payload
'
]
=
{
        
'
upstreamArtifacts
'
:
worker
[
'
upstream
-
artifacts
'
]
    
}
payload_builder
(
'
native
-
engine
'
)
def
build_macosx_engine_payload
(
config
task
task_def
)
:
    
worker
=
task
[
'
worker
'
]
    
artifacts
=
map
(
lambda
artifact
:
{
        
'
name
'
:
artifact
[
'
name
'
]
        
'
path
'
:
artifact
[
'
path
'
]
        
'
type
'
:
artifact
[
'
type
'
]
        
'
expires
'
:
task_def
[
'
expires
'
]
    
}
worker
[
'
artifacts
'
]
)
    
task_def
[
'
payload
'
]
=
{
        
'
context
'
:
worker
[
'
context
'
]
        
'
command
'
:
worker
[
'
command
'
]
        
'
env
'
:
worker
[
'
env
'
]
        
'
reboot
'
:
worker
[
'
reboot
'
]
        
'
artifacts
'
:
artifacts
    
}
    
if
task
.
get
(
'
needs
-
sccache
'
)
:
        
raise
Exception
(
'
needs
-
sccache
not
supported
in
native
-
engine
'
)
payload_builder
(
'
buildbot
-
bridge
'
)
def
build_buildbot_bridge_payload
(
config
task
task_def
)
:
    
del
task
[
'
extra
'
]
[
'
treeherder
'
]
    
del
task
[
'
extra
'
]
[
'
treeherderEnv
'
]
    
worker
=
task
[
'
worker
'
]
    
task_def
[
'
payload
'
]
=
{
        
'
buildername
'
:
worker
[
'
buildername
'
]
        
'
sourcestamp
'
:
worker
[
'
sourcestamp
'
]
        
'
properties
'
:
worker
[
'
properties
'
]
    
}
transforms
=
TransformSequence
(
)
transforms
.
add
def
validate
(
config
tasks
)
:
    
for
task
in
tasks
:
        
yield
validate_schema
(
            
task_description_schema
task
            
"
In
task
{
!
r
}
:
"
.
format
(
task
.
get
(
'
label
'
'
?
no
-
label
?
'
)
)
)
index_builder
(
'
generic
'
)
def
add_generic_index_routes
(
config
task
)
:
    
index
=
task
.
get
(
'
index
'
)
    
routes
=
task
.
setdefault
(
'
routes
'
[
]
)
    
job_name
=
index
[
'
job
-
name
'
]
    
if
job_name
not
in
JOB_NAME_WHITELIST
:
        
raise
Exception
(
JOB_NAME_WHITELIST_ERROR
.
format
(
job_name
)
)
    
subs
=
config
.
params
.
copy
(
)
    
subs
[
'
job
-
name
'
]
=
job_name
    
subs
[
'
build_date_long
'
]
=
time
.
strftime
(
"
%
Y
.
%
m
.
%
d
.
%
Y
%
m
%
d
%
H
%
M
%
S
"
                                            
time
.
gmtime
(
config
.
params
[
'
build_date
'
]
)
)
    
subs
[
'
product
'
]
=
index
[
'
product
'
]
    
for
tpl
in
V2_ROUTE_TEMPLATES
:
        
routes
.
append
(
tpl
.
format
(
*
*
subs
)
)
    
return
task
index_builder
(
'
nightly
'
)
def
add_nightly_index_routes
(
config
task
)
:
    
index
=
task
.
get
(
'
index
'
)
    
routes
=
task
.
setdefault
(
'
routes
'
[
]
)
    
job_name
=
index
[
'
job
-
name
'
]
    
if
job_name
not
in
JOB_NAME_WHITELIST
:
        
raise
Exception
(
JOB_NAME_WHITELIST_ERROR
.
format
(
job_name
)
)
    
subs
=
config
.
params
.
copy
(
)
    
subs
[
'
job
-
name
'
]
=
job_name
    
subs
[
'
build_date_long
'
]
=
time
.
strftime
(
"
%
Y
.
%
m
.
%
d
.
%
Y
%
m
%
d
%
H
%
M
%
S
"
                                            
time
.
gmtime
(
config
.
params
[
'
build_date
'
]
)
)
    
subs
[
'
build_date
'
]
=
time
.
strftime
(
"
%
Y
.
%
m
.
%
d
"
                                       
time
.
gmtime
(
config
.
params
[
'
build_date
'
]
)
)
    
subs
[
'
product
'
]
=
index
[
'
product
'
]
    
for
tpl
in
V2_NIGHTLY_TEMPLATES
:
        
routes
.
append
(
tpl
.
format
(
*
*
subs
)
)
    
task
=
add_l10n_index_routes
(
config
task
force_locale
=
"
en
-
US
"
)
    
return
task
index_builder
(
'
nightly
-
with
-
multi
-
l10n
'
)
def
add_nightly_multi_index_routes
(
config
task
)
:
    
task
=
add_nightly_index_routes
(
config
task
)
    
task
=
add_l10n_index_routes
(
config
task
force_locale
=
"
multi
"
)
    
return
task
index_builder
(
'
l10n
'
)
def
add_l10n_index_routes
(
config
task
force_locale
=
None
)
:
    
index
=
task
.
get
(
'
index
'
)
    
routes
=
task
.
setdefault
(
'
routes
'
[
]
)
    
job_name
=
index
[
'
job
-
name
'
]
    
if
job_name
not
in
JOB_NAME_WHITELIST
:
        
raise
Exception
(
JOB_NAME_WHITELIST_ERROR
.
format
(
job_name
)
)
    
subs
=
config
.
params
.
copy
(
)
    
subs
[
'
job
-
name
'
]
=
job_name
    
subs
[
'
build_date_long
'
]
=
time
.
strftime
(
"
%
Y
.
%
m
.
%
d
.
%
Y
%
m
%
d
%
H
%
M
%
S
"
                                            
time
.
gmtime
(
config
.
params
[
'
build_date
'
]
)
)
    
subs
[
'
product
'
]
=
index
[
'
product
'
]
    
locales
=
task
[
'
attributes
'
]
.
get
(
'
chunk_locales
'
                                     
task
[
'
attributes
'
]
.
get
(
'
all_locales
'
)
)
    
if
force_locale
:
        
locales
=
[
force_locale
]
    
if
not
locales
:
        
raise
Exception
(
"
Error
:
Unable
to
use
l10n
index
for
tasks
without
locales
"
)
    
if
len
(
locales
)
>
18
:
        
return
task
    
for
locale
in
locales
:
        
for
tpl
in
V2_L10N_TEMPLATES
:
            
routes
.
append
(
tpl
.
format
(
locale
=
locale
*
*
subs
)
)
    
return
task
transforms
.
add
def
add_index_routes
(
config
tasks
)
:
    
for
task
in
tasks
:
        
index
=
task
.
get
(
'
index
'
)
        
if
not
index
:
            
yield
task
            
continue
        
index_type
=
index
.
get
(
'
type
'
'
generic
'
)
        
task
=
index_builders
[
index_type
]
(
config
task
)
        
extra_index
=
task
.
setdefault
(
'
extra
'
{
}
)
.
setdefault
(
'
index
'
{
}
)
        
rank
=
index
.
get
(
'
rank
'
'
by
-
tier
'
)
        
if
rank
=
=
'
by
-
tier
'
:
            
tier
=
task
.
get
(
'
treeherder
'
{
}
)
.
get
(
'
tier
'
3
)
            
extra_index
[
'
rank
'
]
=
0
if
tier
>
1
else
int
(
config
.
params
[
'
build_date
'
]
)
        
elif
rank
=
=
'
build_date
'
:
            
extra_index
[
'
rank
'
]
=
int
(
config
.
params
[
'
build_date
'
]
)
        
else
:
            
extra_index
[
'
rank
'
]
=
rank
        
del
task
[
'
index
'
]
        
yield
task
transforms
.
add
def
add_files_changed
(
config
tasks
)
:
    
for
task
in
tasks
:
        
if
'
files
-
changed
'
not
in
task
.
get
(
'
when
'
{
}
)
:
            
yield
task
            
continue
        
task
[
'
when
'
]
[
'
files
-
changed
'
]
.
extend
(
[
            
'
{
}
/
*
*
'
.
format
(
config
.
path
)
            
'
taskcluster
/
taskgraph
/
*
*
'
        
]
)
        
if
'
in
-
tree
'
in
task
[
'
worker
'
]
.
get
(
'
docker
-
image
'
{
}
)
:
            
task
[
'
when
'
]
[
'
files
-
changed
'
]
.
append
(
'
taskcluster
/
docker
/
{
}
/
*
*
'
.
format
(
                
task
[
'
worker
'
]
[
'
docker
-
image
'
]
[
'
in
-
tree
'
]
)
)
        
yield
task
transforms
.
add
def
build_task
(
config
tasks
)
:
    
for
task
in
tasks
:
        
worker_type
=
task
[
'
worker
-
type
'
]
.
format
(
level
=
str
(
config
.
params
[
'
level
'
]
)
)
        
provisioner_id
worker_type
=
worker_type
.
split
(
'
/
'
1
)
        
routes
=
task
.
get
(
'
routes
'
[
]
)
        
scopes
=
task
.
get
(
'
scopes
'
[
]
)
        
extra
=
task
.
get
(
'
extra
'
{
}
)
        
task_th
=
task
.
get
(
'
treeherder
'
)
        
if
task_th
:
            
extra
[
'
treeherderEnv
'
]
=
task_th
[
'
environments
'
]
            
treeherder
=
extra
.
setdefault
(
'
treeherder
'
{
}
)
            
machine_platform
collection
=
task_th
[
'
platform
'
]
.
split
(
'
/
'
1
)
            
treeherder
[
'
machine
'
]
=
{
'
platform
'
:
machine_platform
}
            
treeherder
[
'
collection
'
]
=
{
collection
:
True
}
            
groupSymbol
symbol
=
split_symbol
(
task_th
[
'
symbol
'
]
)
            
if
groupSymbol
!
=
'
?
'
:
                
treeherder
[
'
groupSymbol
'
]
=
groupSymbol
                
if
groupSymbol
not
in
GROUP_NAMES
:
                    
raise
Exception
(
UNKNOWN_GROUP_NAME
.
format
(
groupSymbol
)
)
                
treeherder
[
'
groupName
'
]
=
GROUP_NAMES
[
groupSymbol
]
            
treeherder
[
'
symbol
'
]
=
symbol
            
treeherder
[
'
jobKind
'
]
=
task_th
[
'
kind
'
]
            
treeherder
[
'
tier
'
]
=
task_th
[
'
tier
'
]
            
routes
.
extend
(
[
                
'
{
}
.
v2
.
{
}
.
{
}
.
{
}
'
.
format
(
TREEHERDER_ROUTE_ROOTS
[
env
]
                                        
config
.
params
[
'
project
'
]
                                        
config
.
params
[
'
head_rev
'
]
                                        
config
.
params
[
'
pushlog_id
'
]
)
                
for
env
in
task_th
[
'
environments
'
]
            
]
)
        
if
'
expires
-
after
'
not
in
task
:
            
task
[
'
expires
-
after
'
]
=
'
28
days
'
if
config
.
params
[
'
project
'
]
=
=
'
try
'
else
'
1
year
'
        
if
'
deadline
-
after
'
not
in
task
:
            
task
[
'
deadline
-
after
'
]
=
'
1
day
'
        
if
'
coalesce
-
name
'
in
task
and
int
(
config
.
params
[
'
level
'
]
)
>
1
:
            
key
=
COALESCE_KEY
.
format
(
                
project
=
config
.
params
[
'
project
'
]
                
name
=
task
[
'
coalesce
-
name
'
]
)
            
routes
.
append
(
'
coalesce
.
v1
.
'
+
key
)
        
task_def
=
{
            
'
provisionerId
'
:
provisioner_id
            
'
workerType
'
:
worker_type
            
'
routes
'
:
routes
            
'
created
'
:
{
'
relative
-
datestamp
'
:
'
0
seconds
'
}
            
'
deadline
'
:
{
'
relative
-
datestamp
'
:
task
[
'
deadline
-
after
'
]
}
            
'
expires
'
:
{
'
relative
-
datestamp
'
:
task
[
'
expires
-
after
'
]
}
            
'
scopes
'
:
scopes
            
'
metadata
'
:
{
                
'
description
'
:
task
[
'
description
'
]
                
'
name
'
:
task
[
'
label
'
]
                
'
owner
'
:
config
.
params
[
'
owner
'
]
                
'
source
'
:
'
{
}
/
file
/
{
}
/
{
}
'
.
format
(
                    
config
.
params
[
'
head_repository
'
]
                    
config
.
params
[
'
head_rev
'
]
                    
config
.
path
)
            
}
            
'
extra
'
:
extra
            
'
tags
'
:
{
'
createdForUser
'
:
config
.
params
[
'
owner
'
]
}
        
}
        
if
task_th
:
            
th_push_link
=
'
https
:
/
/
treeherder
.
mozilla
.
org
/
#
/
jobs
?
repo
=
{
}
&
revision
=
{
}
'
.
format
(
                
config
.
params
[
'
project
'
]
config
.
params
[
'
head_rev
'
]
)
            
task_def
[
'
metadata
'
]
[
'
description
'
]
+
=
'
(
[
Treeherder
push
]
(
{
}
)
)
'
.
format
(
                
th_push_link
)
        
payload_builders
[
task
[
'
worker
'
]
[
'
implementation
'
]
]
(
config
task
task_def
)
        
attributes
=
task
.
get
(
'
attributes
'
{
}
)
        
attributes
[
'
run_on_projects
'
]
=
task
.
get
(
'
run
-
on
-
projects
'
[
'
all
'
]
)
        
yield
{
            
'
label
'
:
task
[
'
label
'
]
            
'
task
'
:
task_def
            
'
dependencies
'
:
task
.
get
(
'
dependencies
'
{
}
)
            
'
attributes
'
:
attributes
            
'
index
-
paths
'
:
task
.
get
(
'
index
-
paths
'
)
            
'
when
'
:
task
.
get
(
'
when
'
{
}
)
        
}
def
check_v2_routes
(
)
:
    
with
open
(
"
testing
/
mozharness
/
configs
/
routes
.
json
"
"
rb
"
)
as
f
:
        
routes_json
=
json
.
load
(
f
)
    
for
key
in
(
'
routes
'
'
nightly
'
'
l10n
'
)
:
        
if
key
=
=
'
routes
'
:
            
tc_template
=
V2_ROUTE_TEMPLATES
        
elif
key
=
=
'
nightly
'
:
            
tc_template
=
V2_NIGHTLY_TEMPLATES
        
elif
key
=
=
'
l10n
'
:
            
tc_template
=
V2_L10N_TEMPLATES
        
routes
=
routes_json
[
key
]
        
for
mh
tg
in
[
                
(
'
{
index
}
'
'
index
'
)
                
(
'
{
build_product
}
'
'
{
product
}
'
)
                
(
'
{
build_name
}
-
{
build_type
}
'
'
{
job
-
name
}
'
)
                
(
'
{
year
}
.
{
month
}
.
{
day
}
.
{
pushdate
}
'
'
{
build_date_long
}
'
)
                
(
'
{
year
}
.
{
month
}
.
{
day
}
'
'
{
build_date
}
'
)
]
:
            
routes
=
[
r
.
replace
(
mh
tg
)
for
r
in
routes
]
        
if
sorted
(
routes
)
!
=
sorted
(
tc_template
)
:
            
raise
Exception
(
"
V2
TEMPLATES
do
not
match
Mozharness
'
s
routes
.
json
:
"
                            
"
(
tc
)
:
%
s
vs
(
mh
)
:
%
s
"
%
(
tc_template
routes
)
)
check_v2_routes
(
)
