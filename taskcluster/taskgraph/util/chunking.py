from
__future__
import
absolute_import
print_function
unicode_literals
"
"
"
Utility
functions
to
handle
test
chunking
.
"
"
"
import
os
import
json
from
collections
import
defaultdict
from
manifestparser
import
TestManifest
from
manifestparser
.
filters
import
chunk_by_runtime
from
mozbuild
.
util
import
memoize
from
moztest
.
resolve
import
TestResolver
TestManifestLoader
from
taskgraph
import
GECKO
here
=
os
.
path
.
abspath
(
os
.
path
.
dirname
(
__file__
)
)
resolver
=
TestResolver
.
from_environment
(
cwd
=
here
loader_cls
=
TestManifestLoader
)
def
guess_mozinfo_from_task
(
task
)
:
    
"
"
"
Attempt
to
build
a
mozinfo
dict
from
a
task
definition
.
    
This
won
'
t
be
perfect
and
many
values
used
in
the
manifests
will
be
missing
.
But
    
it
should
cover
most
of
the
major
ones
and
be
"
good
enough
"
for
chunking
in
the
    
taskgraph
.
    
Args
:
        
task
(
dict
)
:
A
task
definition
.
    
Returns
:
        
A
dict
that
can
be
used
as
a
mozinfo
replacement
.
    
"
"
"
    
info
=
{
        
'
asan
'
:
'
asan
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
ccov
'
:
'
ccov
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
debug
'
:
task
[
'
build
-
attributes
'
]
[
'
build_type
'
]
=
=
'
debug
'
        
'
e10s
'
:
task
[
'
attributes
'
]
[
'
e10s
'
]
        
'
tsan
'
:
'
tsan
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
webrender
'
:
task
.
get
(
'
webrender
'
False
)
    
}
    
for
platform
in
(
'
android
'
'
linux
'
'
mac
'
'
win
'
)
:
        
if
platform
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
:
            
info
[
'
os
'
]
=
platform
            
break
    
else
:
        
raise
ValueError
(
"
{
}
is
not
a
known
platform
!
"
.
format
(
                         
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
)
)
    
return
info
memoize
def
get_runtimes
(
platform
)
:
    
base
=
os
.
path
.
join
(
GECKO
'
testing
'
'
runtimes
'
'
manifest
-
runtimes
-
{
}
.
json
'
)
    
for
key
in
(
'
android
'
'
windows
'
)
:
        
if
platform
in
key
:
            
path
=
base
.
format
(
key
)
            
break
    
else
:
        
path
=
base
.
format
(
'
unix
'
)
    
with
open
(
path
'
r
'
)
as
fh
:
        
return
json
.
load
(
fh
)
memoize
def
get_tests
(
flavor
subsuite
)
:
    
return
list
(
resolver
.
resolve_tests
(
flavor
=
flavor
subsuite
=
subsuite
)
)
def
tests_by_top_directory
(
tests
depth
)
:
    
"
"
"
Given
a
list
of
test
objects
return
a
dictionary
of
test
paths
keyed
by
    
the
top
level
group
.
    
Args
:
        
tests
(
list
)
:
List
of
test
objects
for
the
particular
suite
and
subsuite
.
        
depth
(
int
optional
)
:
The
maximum
depth
to
consider
when
grouping
tests
.
    
Returns
:
        
results
(
dict
)
:
Dictionary
representation
of
test
paths
grouped
by
the
            
top
level
group
name
.
    
"
"
"
    
results
=
defaultdict
(
list
)
    
for
t
in
tests
:
        
path
=
os
.
path
.
dirname
(
t
[
'
name
'
]
)
        
while
path
.
count
(
'
/
'
)
>
=
depth
+
1
:
            
path
=
os
.
path
.
dirname
(
path
)
        
components
=
3
if
t
[
'
name
'
]
.
startswith
(
'
/
_mozilla
'
)
else
2
        
key
=
'
/
'
.
join
(
t
[
'
name
'
]
.
split
(
'
/
'
)
[
:
components
]
)
        
results
[
key
]
.
append
(
path
)
    
return
results
memoize
def
get_chunked_manifests
(
flavor
subsuite
chunks
mozinfo
)
:
    
"
"
"
Compute
which
manifests
should
run
in
which
chunks
with
the
given
category
    
of
tests
.
    
Args
:
        
flavor
(
str
)
:
The
suite
to
run
.
Values
are
defined
by
the
'
build_flavor
'
key
            
in
moztest
.
resolve
.
TEST_SUITES
.
        
subsuite
(
str
)
:
The
subsuite
to
run
or
'
undefined
'
to
denote
no
subsuite
.
        
chunks
(
int
)
:
Number
of
chunks
to
split
manifests
across
.
        
mozinfo
(
frozenset
)
:
Set
of
data
in
the
form
of
(
<
key
>
<
value
>
)
used
                             
for
filtering
.
    
Returns
:
        
A
list
of
manifests
where
each
item
contains
the
manifest
that
should
        
run
in
the
corresponding
chunk
.
    
"
"
"
    
mozinfo
=
dict
(
mozinfo
)
    
tests
=
get_tests
(
flavor
subsuite
)
    
if
flavor
=
=
'
web
-
platform
-
tests
'
:
        
paths
=
tests_by_top_directory
(
tests
3
)
        
runtimes
=
get_runtimes
(
mozinfo
[
'
os
'
]
)
        
runtimes
=
[
(
k
v
)
for
k
v
in
runtimes
.
items
(
)
                    
if
k
.
startswith
(
'
/
'
)
and
not
os
.
path
.
splitext
(
k
)
[
-
1
]
]
        
chunked_manifests
=
[
[
[
]
0
]
for
_
in
range
(
chunks
)
]
        
for
key
rt
in
sorted
(
runtimes
key
=
lambda
x
:
x
[
1
]
reverse
=
True
)
:
            
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
            
test_paths
=
set
(
paths
[
key
]
)
            
if
test_paths
:
                
chunked_manifests
[
0
]
[
0
]
.
extend
(
test_paths
)
                
chunked_manifests
[
0
]
[
1
]
+
=
rt
                
paths
.
pop
(
key
)
        
for
test_paths
in
paths
.
values
(
)
:
            
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
            
chunked_manifests
[
0
]
[
0
]
.
extend
(
set
(
test_paths
)
)
        
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
        
chunked_manifests
=
[
c
[
0
]
for
c
in
chunked_manifests
]
    
else
:
        
chunker
=
chunk_by_runtime
(
None
chunks
get_runtimes
(
mozinfo
[
'
os
'
]
)
)
        
all_manifests
=
set
(
chunker
.
get_manifest
(
t
)
for
t
in
tests
)
        
m
=
TestManifest
(
)
        
m
.
tests
=
tests
        
tests
=
m
.
active_tests
(
disabled
=
False
exists
=
False
*
*
mozinfo
)
        
active_manifests
=
set
(
chunker
.
get_manifest
(
t
)
for
t
in
tests
)
        
chunked_manifests
=
[
c
[
1
]
for
c
in
chunker
.
get_chunked_manifests
(
active_manifests
)
]
        
skipped_manifests
=
all_manifests
-
active_manifests
        
chunked_manifests
[
0
]
.
extend
(
skipped_manifests
)
    
return
chunked_manifests
