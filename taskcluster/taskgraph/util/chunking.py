from
__future__
import
absolute_import
print_function
unicode_literals
"
"
"
Utility
functions
to
handle
test
chunking
.
"
"
"
import
os
import
json
from
collections
import
defaultdict
from
manifestparser
import
TestManifest
from
manifestparser
.
filters
import
chunk_by_runtime
from
mozbuild
.
util
import
memoize
from
moztest
.
resolve
import
TestResolver
TestManifestLoader
from
taskgraph
import
GECKO
here
=
os
.
path
.
abspath
(
os
.
path
.
dirname
(
__file__
)
)
resolver
=
TestResolver
.
from_environment
(
cwd
=
here
loader_cls
=
TestManifestLoader
)
def
guess_mozinfo_from_task
(
task
)
:
    
"
"
"
Attempt
to
build
a
mozinfo
dict
from
a
task
definition
.
    
This
won
'
t
be
perfect
and
many
values
used
in
the
manifests
will
be
missing
.
But
    
it
should
cover
most
of
the
major
ones
and
be
"
good
enough
"
for
chunking
in
the
    
taskgraph
.
    
Args
:
        
task
(
dict
)
:
A
task
definition
.
    
Returns
:
        
A
dict
that
can
be
used
as
a
mozinfo
replacement
.
    
"
"
"
    
info
=
{
        
'
asan
'
:
'
asan
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
ccov
'
:
'
ccov
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
debug
'
:
task
[
'
build
-
attributes
'
]
[
'
build_type
'
]
=
=
'
debug
'
        
'
e10s
'
:
task
[
'
attributes
'
]
[
'
e10s
'
]
        
'
tsan
'
:
'
tsan
'
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
        
'
webrender
'
:
task
.
get
(
'
webrender
'
False
)
    
}
    
for
platform
in
(
'
android
'
'
linux
'
'
mac
'
'
win
'
)
:
        
if
platform
in
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
:
            
info
[
'
os
'
]
=
platform
            
break
    
else
:
        
raise
ValueError
(
"
{
}
is
not
a
known
platform
!
"
.
format
(
                         
task
[
'
build
-
attributes
'
]
[
'
build_platform
'
]
)
)
    
return
info
memoize
def
get_runtimes
(
platform
)
:
    
base
=
os
.
path
.
join
(
GECKO
'
testing
'
'
runtimes
'
'
manifest
-
runtimes
-
{
}
.
json
'
)
    
for
key
in
(
'
android
'
'
windows
'
)
:
        
if
key
in
platform
:
            
path
=
base
.
format
(
key
)
            
break
    
else
:
        
path
=
base
.
format
(
'
unix
'
)
    
with
open
(
path
'
r
'
)
as
fh
:
        
return
json
.
load
(
fh
)
memoize
def
get_tests
(
flavor
subsuite
)
:
    
return
list
(
resolver
.
resolve_tests
(
flavor
=
flavor
subsuite
=
subsuite
)
)
wpt_group_translation
=
defaultdict
(
set
)
def
get_wpt_group
(
test
)
:
    
"
"
"
Get
the
group
for
a
web
-
platform
-
test
that
matches
those
created
by
the
    
WPT
harness
.
    
Args
:
        
test
(
dict
)
:
The
test
object
to
compute
the
group
for
.
    
Returns
:
        
str
:
Label
representing
the
group
name
.
    
"
"
"
    
depth
=
3
    
path
=
os
.
path
.
dirname
(
test
[
'
name
'
]
)
    
while
path
.
count
(
'
/
'
)
>
=
depth
+
1
:
        
path
=
os
.
path
.
dirname
(
path
)
    
return
path
memoize
def
get_manifests
(
flavor
subsuite
mozinfo
)
:
    
"
"
"
Compute
which
manifests
should
run
for
the
given
flavor
subsuite
and
mozinfo
.
    
This
function
returns
skipped
manifests
separately
so
that
more
balanced
    
chunks
can
be
achieved
by
only
considering
"
active
"
manifests
in
the
    
chunking
algorithm
.
    
Args
:
        
flavor
(
str
)
:
The
suite
to
run
.
Values
are
defined
by
the
'
build_flavor
'
key
            
in
moztest
.
resolve
.
TEST_SUITES
.
        
subsuite
(
str
)
:
The
subsuite
to
run
or
'
undefined
'
to
denote
no
subsuite
.
        
mozinfo
(
frozenset
)
:
Set
of
data
in
the
form
of
(
<
key
>
<
value
>
)
used
                             
for
filtering
.
    
Returns
:
        
A
tuple
of
two
manifest
lists
.
The
first
is
the
set
of
active
manifests
(
will
        
run
at
least
one
test
.
The
second
is
a
list
of
skipped
manifests
(
all
tests
are
        
skipped
)
.
    
"
"
"
    
mozinfo
=
dict
(
mozinfo
)
    
tests
=
get_tests
(
flavor
subsuite
)
    
if
flavor
=
=
"
web
-
platform
-
tests
"
:
        
manifests
=
set
(
)
        
for
t
in
tests
:
            
group
=
get_wpt_group
(
t
)
            
wpt_group_translation
[
t
[
'
manifest
'
]
]
.
add
(
group
)
            
manifests
.
add
(
t
[
'
manifest
'
]
)
        
return
{
"
active
"
:
list
(
manifests
)
"
skipped
"
:
[
]
}
    
manifests
=
set
(
chunk_by_runtime
.
get_manifest
(
t
)
for
t
in
tests
)
    
m
=
TestManifest
(
)
    
m
.
tests
=
tests
    
tests
=
m
.
active_tests
(
disabled
=
False
exists
=
False
*
*
mozinfo
)
    
active
=
set
(
chunk_by_runtime
.
get_manifest
(
t
)
for
t
in
tests
)
    
skipped
=
manifests
-
active
    
return
{
"
active
"
:
list
(
active
)
"
skipped
"
:
list
(
skipped
)
}
def
chunk_manifests
(
flavor
platform
chunks
manifests
)
:
    
"
"
"
Run
the
chunking
algorithm
.
    
Args
:
        
platform
(
str
)
:
Platform
used
to
find
runtime
info
.
        
chunks
(
int
)
:
Number
of
chunks
to
split
manifests
into
.
        
manifests
(
list
)
:
Manifests
to
chunk
.
    
Returns
:
        
A
list
of
length
chunks
where
each
item
contains
a
list
of
manifests
        
that
run
in
that
chunk
.
    
"
"
"
    
if
flavor
!
=
"
web
-
platform
-
tests
"
:
        
return
[
            
c
[
1
]
for
c
in
chunk_by_runtime
(
                
None
                
chunks
                
get_runtimes
(
platform
)
            
)
.
get_chunked_manifests
(
manifests
)
        
]
    
paths
=
{
k
:
v
for
k
v
in
wpt_group_translation
.
items
(
)
if
k
in
manifests
}
    
runtimes
=
get_runtimes
(
platform
)
    
runtimes
=
[
(
k
v
)
for
k
v
in
runtimes
.
items
(
)
                
if
k
.
startswith
(
'
/
'
)
and
not
os
.
path
.
splitext
(
k
)
[
-
1
]
                
if
k
in
manifests
]
    
chunked_manifests
=
[
[
[
]
0
]
for
_
in
range
(
chunks
)
]
    
for
key
rt
in
sorted
(
runtimes
key
=
lambda
x
:
x
[
1
]
reverse
=
True
)
:
        
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
        
test_paths
=
paths
[
key
]
        
if
test_paths
:
            
chunked_manifests
[
0
]
[
0
]
.
extend
(
test_paths
)
            
chunked_manifests
[
0
]
[
1
]
+
=
rt
            
paths
.
pop
(
key
)
    
for
test_paths
in
paths
.
values
(
)
:
        
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
        
chunked_manifests
[
0
]
[
0
]
.
extend
(
test_paths
)
    
chunked_manifests
.
sort
(
key
=
lambda
x
:
(
x
[
1
]
len
(
x
[
0
]
)
)
)
    
chunked_manifests
=
[
c
[
0
]
for
c
in
chunked_manifests
]
    
return
chunked_manifests
