#
-
*
-
coding
:
utf
-
8
-
*
-
from
__future__
import
absolute_import
print_function
unicode_literals
import
json
import
os
import
subprocess
import
tarfile
import
tempfile
import
which
from
subprocess
import
Popen
PIPE
from
io
import
BytesIO
from
taskgraph
.
util
import
docker
from
taskgraph
.
util
.
taskcluster
import
(
    
find_task_id
    
get_artifact_url
    
get_session
)
from
taskgraph
.
util
.
cached_tasks
import
cached_index_path
from
.
import
GECKO
def
load_image_by_name
(
image_name
tag
=
None
)
:
    
context_path
=
os
.
path
.
join
(
GECKO
'
taskcluster
'
'
docker
'
image_name
)
    
context_hash
=
docker
.
generate_context_hash
(
GECKO
context_path
image_name
)
    
index_path
=
cached_index_path
(
        
trust_domain
=
'
gecko
'
        
level
=
3
        
cache_type
=
'
docker
-
images
.
v1
'
        
cache_name
=
image_name
        
digest
=
context_hash
    
)
    
task_id
=
find_task_id
(
index_path
)
    
return
load_image_by_task_id
(
task_id
tag
)
def
load_image_by_task_id
(
task_id
tag
=
None
)
:
    
artifact_url
=
get_artifact_url
(
task_id
'
public
/
image
.
tar
.
zst
'
)
    
result
=
load_image
(
artifact_url
tag
)
    
print
(
"
Found
docker
image
:
{
}
:
{
}
"
.
format
(
result
[
'
image
'
]
result
[
'
tag
'
]
)
)
    
if
tag
:
        
print
(
"
Re
-
tagged
as
:
{
}
"
.
format
(
tag
)
)
    
else
:
        
tag
=
'
{
}
:
{
}
'
.
format
(
result
[
'
image
'
]
result
[
'
tag
'
]
)
    
print
(
"
Try
:
docker
run
-
ti
-
-
rm
{
}
bash
"
.
format
(
tag
)
)
    
return
True
def
build_context
(
name
outputFile
args
=
None
)
:
    
"
"
"
Build
a
context
.
tar
for
image
with
specified
name
.
    
"
"
"
    
if
not
name
:
        
raise
ValueError
(
'
must
provide
a
Docker
image
name
'
)
    
if
not
outputFile
:
        
raise
ValueError
(
'
must
provide
a
outputFile
'
)
    
image_dir
=
docker
.
image_path
(
name
)
    
if
not
os
.
path
.
isdir
(
image_dir
)
:
        
raise
Exception
(
'
image
directory
does
not
exist
:
%
s
'
%
image_dir
)
    
docker
.
create_context_tar
(
GECKO
image_dir
outputFile
"
"
args
)
def
build_image
(
name
args
=
None
)
:
    
"
"
"
Build
a
Docker
image
of
specified
name
.
    
Output
from
image
building
process
will
be
printed
to
stdout
.
    
"
"
"
    
if
not
name
:
        
raise
ValueError
(
'
must
provide
a
Docker
image
name
'
)
    
image_dir
=
docker
.
image_path
(
name
)
    
if
not
os
.
path
.
isdir
(
image_dir
)
:
        
raise
Exception
(
'
image
directory
does
not
exist
:
%
s
'
%
image_dir
)
    
tag
=
docker
.
docker_image
(
name
by_tag
=
True
)
    
docker_bin
=
which
.
which
(
'
docker
'
)
    
try
:
        
subprocess
.
check_output
(
[
docker_bin
'
-
-
version
'
]
)
    
except
subprocess
.
CalledProcessError
:
        
raise
Exception
(
'
Docker
server
is
unresponsive
.
Run
docker
ps
and
'
                        
'
check
that
Docker
is
running
'
)
    
fd
context_path
=
tempfile
.
mkstemp
(
)
    
os
.
close
(
fd
)
    
try
:
        
docker
.
create_context_tar
(
GECKO
image_dir
context_path
name
args
)
        
docker
.
build_from_context
(
docker_bin
context_path
name
tag
)
    
finally
:
        
os
.
unlink
(
context_path
)
    
print
(
'
Successfully
built
%
s
and
tagged
with
%
s
'
%
(
name
tag
)
)
    
if
tag
.
endswith
(
'
:
latest
'
)
:
        
print
(
'
*
'
*
50
)
        
print
(
'
WARNING
:
no
VERSION
file
found
in
image
directory
.
'
)
        
print
(
'
Image
is
not
suitable
for
deploying
/
pushing
.
'
)
        
print
(
'
Create
an
image
suitable
for
deploying
/
pushing
by
creating
'
)
        
print
(
'
a
VERSION
file
in
the
image
directory
.
'
)
        
print
(
'
*
'
*
50
)
class
IteratorReader
(
object
)
:
    
def
__init__
(
self
iterator
)
:
        
self
.
_iterator
=
iterator
        
self
.
_buf
=
b
'
'
    
def
read
(
self
size
)
:
        
result
=
b
'
'
        
while
len
(
result
)
<
size
:
            
wanted
=
min
(
size
-
len
(
result
)
len
(
self
.
_buf
)
)
            
if
not
self
.
_buf
:
                
try
:
                    
self
.
_buf
=
memoryview
(
next
(
self
.
_iterator
)
)
                
except
StopIteration
:
                    
break
            
result
+
=
self
.
_buf
[
:
wanted
]
.
tobytes
(
)
            
self
.
_buf
=
self
.
_buf
[
wanted
:
]
        
return
result
def
load_image
(
url
imageName
=
None
imageTag
=
None
)
:
    
"
"
"
    
Load
docker
image
from
URL
as
imageName
:
tag
if
no
imageName
or
tag
is
given
    
it
will
use
whatever
is
inside
the
zstd
compressed
tarball
.
    
Returns
an
object
with
properties
'
image
'
'
tag
'
and
'
layer
'
.
    
"
"
"
    
import
zstd
    
if
imageName
and
not
imageTag
:
        
if
'
:
'
in
imageName
:
            
imageName
imageTag
=
imageName
.
split
(
'
:
'
1
)
        
else
:
            
imageTag
=
'
latest
'
    
docker
=
None
    
image
tag
layer
=
None
None
None
    
try
:
        
print
(
"
Downloading
from
{
}
"
.
format
(
url
)
)
        
req
=
get_session
(
)
.
get
(
url
stream
=
True
)
        
req
.
raise_for_status
(
)
        
decompressed_reader
=
IteratorReader
(
zstd
.
ZstdDecompressor
(
)
.
read_from
(
req
.
raw
)
)
        
tarin
=
tarfile
.
open
(
            
mode
=
'
r
|
'
            
fileobj
=
decompressed_reader
            
bufsize
=
zstd
.
DECOMPRESSION_RECOMMENDED_OUTPUT_SIZE
)
        
docker
=
Popen
(
[
'
docker
'
'
load
'
]
stdin
=
PIPE
)
        
tarout
=
tarfile
.
open
(
mode
=
'
w
|
'
fileobj
=
docker
.
stdin
format
=
tarfile
.
GNU_FORMAT
)
        
for
member
in
tarin
:
            
if
not
member
.
isfile
(
)
:
                
tarout
.
addfile
(
member
)
                
continue
            
reader
=
tarin
.
extractfile
(
member
)
            
if
member
.
name
=
=
'
repositories
'
:
                
repos
=
json
.
loads
(
reader
.
read
(
)
)
                
reader
.
close
(
)
                
if
len
(
repos
.
keys
(
)
)
>
1
:
                    
raise
Exception
(
'
file
contains
more
than
one
image
'
)
                
image
=
repos
.
keys
(
)
[
0
]
                
if
len
(
repos
[
image
]
.
keys
(
)
)
>
1
:
                    
raise
Exception
(
'
file
contains
more
than
one
tag
'
)
                
tag
=
repos
[
image
]
.
keys
(
)
[
0
]
                
layer
=
repos
[
image
]
[
tag
]
                
data
=
json
.
dumps
(
{
imageName
or
image
:
{
imageTag
or
tag
:
layer
}
}
)
                
reader
=
BytesIO
(
data
)
                
member
.
size
=
len
(
data
)
            
tarout
.
addfile
(
member
reader
)
            
reader
.
close
(
)
        
tarout
.
close
(
)
    
finally
:
        
if
docker
:
            
docker
.
stdin
.
close
(
)
        
if
docker
and
docker
.
wait
(
)
!
=
0
:
            
raise
Exception
(
'
loading
into
docker
failed
'
)
    
if
not
image
or
not
tag
or
not
layer
:
        
raise
Exception
(
'
No
repositories
file
found
!
'
)
    
return
{
'
image
'
:
image
'
tag
'
:
tag
'
layer
'
:
layer
}
