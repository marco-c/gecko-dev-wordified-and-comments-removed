#
-
*
-
coding
:
utf
-
8
-
*
-
from
__future__
import
absolute_import
print_function
unicode_literals
import
logging
import
re
import
taskcluster_urls
from
.
util
import
(
    
create_tasks
    
fetch_graph_and_labels
)
from
taskgraph
.
util
.
taskcluster
import
(
    
send_email
    
get_root_url
)
from
.
registry
import
register_callback_action
from
taskgraph
.
util
import
taskcluster
logger
=
logging
.
getLogger
(
__name__
)
EMAIL_SUBJECT
=
'
Your
Interactive
Task
for
{
label
}
'
EMAIL_CONTENT
=
'
'
'
\
As
you
requested
Firefox
CI
has
created
an
interactive
task
to
run
{
label
}
on
revision
{
revision
}
in
{
repo
}
.
Click
the
button
below
to
connect
to
the
task
.
You
may
need
to
wait
for
it
to
begin
running
.
'
'
'
SCOPE_WHITELIST
=
[
    
re
.
compile
(
r
'
^
secrets
:
get
:
project
/
taskcluster
/
gecko
/
hgfingerprint
'
)
    
re
.
compile
(
r
'
^
docker
-
worker
:
relengapi
-
proxy
:
tooltool
.
download
.
public
'
)
    
re
.
compile
(
r
'
^
secrets
:
get
:
project
/
releng
/
gecko
/
build
/
level
-
[
0
-
9
]
/
\
*
'
)
    
re
.
compile
(
r
'
^
docker
-
worker
:
feature
:
allowPtrace
'
)
    
re
.
compile
(
r
'
^
docker
-
worker
:
capability
:
device
:
.
*
'
)
]
def
context
(
params
)
:
    
if
int
(
params
[
'
level
'
]
)
<
3
:
        
return
[
{
'
worker
-
implementation
'
:
'
docker
-
worker
'
}
]
    
else
:
        
return
[
{
'
worker
-
implementation
'
:
'
docker
-
worker
'
'
kind
'
:
'
test
'
}
]
register_callback_action
(
    
title
=
'
Create
Interactive
Task
'
    
name
=
'
create
-
interactive
'
    
symbol
=
'
create
-
inter
'
    
kind
=
'
hook
'
    
generic
=
True
    
description
=
(
        
'
Create
a
a
copy
of
the
task
that
you
can
interact
with
'
    
)
    
order
=
50
    
context
=
context
    
schema
=
{
        
'
type
'
:
'
object
'
        
'
properties
'
:
{
            
'
notify
'
:
{
                
'
type
'
:
'
string
'
                
'
format
'
:
'
email
'
                
'
title
'
:
'
Who
to
notify
of
the
pending
interactive
task
'
                
'
description
'
:
(
                    
'
Enter
your
email
here
to
get
an
email
containing
a
link
'
                    
'
to
interact
with
the
task
'
                
)
                
'
default
'
:
'
noreply
noreply
.
mozilla
.
org
'
            
}
        
}
        
'
additionalProperties
'
:
False
    
}
)
def
create_interactive_action
(
parameters
graph_config
input
task_group_id
task_id
)
:
    
decision_task_id
full_task_graph
label_to_taskid
=
fetch_graph_and_labels
(
        
parameters
graph_config
)
    
task
=
taskcluster
.
get_task_definition
(
task_id
)
    
label
=
task
[
'
metadata
'
]
[
'
name
'
]
    
def
edit
(
task
)
:
        
if
task
.
label
!
=
label
:
            
return
task
        
task_def
=
task
.
task
        
task_def
[
'
routes
'
]
=
[
]
        
task_def
[
'
retries
'
]
=
0
        
task_def
[
'
deadline
'
]
=
{
'
relative
-
datestamp
'
:
'
12
hours
'
}
        
task_def
[
'
created
'
]
=
{
'
relative
-
datestamp
'
:
'
0
hours
'
}
        
task_def
[
'
expires
'
]
=
{
'
relative
-
datestamp
'
:
'
1
day
'
}
        
task
.
task
[
'
scopes
'
]
=
[
s
for
s
in
task
.
task
.
get
(
'
scopes
'
[
]
)
                               
if
any
(
p
.
match
(
s
)
for
p
in
SCOPE_WHITELIST
)
]
        
payload
=
task_def
[
'
payload
'
]
        
payload
[
'
maxRunTime
'
]
=
max
(
3600
*
3
payload
.
get
(
'
maxRunTime
'
0
)
)
        
payload
[
'
cache
'
]
=
{
}
        
payload
[
'
artifacts
'
]
=
{
}
        
payload
.
setdefault
(
'
features
'
{
}
)
[
'
interactive
'
]
=
True
        
payload
.
setdefault
(
'
env
'
{
}
)
[
'
TASKCLUSTER_INTERACTIVE
'
]
=
'
true
'
        
return
task
    
label_to_taskid
=
create_tasks
(
[
label
]
full_task_graph
label_to_taskid
                                   
parameters
modifier
=
edit
)
    
taskId
=
label_to_taskid
[
label
]
    
logger
.
info
(
'
Created
interactive
task
{
}
;
sending
notification
'
.
format
(
taskId
)
)
    
if
input
and
'
notify
'
in
input
:
        
email
=
input
[
'
notify
'
]
        
if
email
=
=
'
noreply
noreply
.
mozilla
.
org
'
:
            
return
        
info
=
{
            
'
url
'
:
taskcluster_urls
.
ui
(
get_root_url
(
)
'
tasks
/
{
}
/
connect
'
.
format
(
taskId
)
)
            
'
label
'
:
label
            
'
revision
'
:
parameters
[
'
head_rev
'
]
            
'
repo
'
:
parameters
[
'
head_repository
'
]
        
}
        
send_email
(
            
email
            
subject
=
EMAIL_SUBJECT
.
format
(
*
*
info
)
            
content
=
EMAIL_CONTENT
.
format
(
*
*
info
)
            
link
=
{
                
'
text
'
:
'
Connect
'
                
'
href
'
:
info
[
'
url
'
]
            
}
            
use_proxy
=
True
)
