import
logging
import
os
import
re
import
taskcluster_urls
from
taskgraph
.
util
.
taskcluster
import
get_root_url
get_task_definition
from
gecko_taskgraph
.
actions
.
registry
import
register_callback_action
from
gecko_taskgraph
.
actions
.
util
import
create_tasks
fetch_graph_and_labels
from
gecko_taskgraph
.
util
.
constants
import
TEST_KINDS
logger
=
logging
.
getLogger
(
__name__
)
EMAIL_SUBJECT
=
"
Your
Interactive
Task
for
{
label
}
"
EMAIL_CONTENT
=
"
"
"
\
As
you
requested
Firefox
CI
has
created
an
interactive
task
to
run
{
label
}
on
revision
{
revision
}
in
{
repo
}
.
Click
the
button
below
to
connect
to
the
task
.
You
may
need
to
wait
for
it
to
begin
running
.
"
"
"
SCOPE_WHITELIST
=
[
    
re
.
compile
(
r
"
^
secrets
:
get
:
project
/
taskcluster
/
gecko
/
(
hgfingerprint
|
hgmointernal
)
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
relengapi
-
proxy
:
tooltool
.
download
.
public
"
)
    
re
.
compile
(
r
"
^
project
:
releng
:
services
/
tooltool
/
api
/
download
/
public
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
relengapi
-
proxy
:
tooltool
.
download
.
internal
"
)
    
re
.
compile
(
r
"
^
project
:
releng
:
services
/
tooltool
/
api
/
download
/
internal
"
)
    
re
.
compile
(
r
"
^
queue
:
get
-
artifact
:
project
/
gecko
/
.
*
"
)
    
re
.
compile
(
r
"
^
secrets
:
get
:
project
/
releng
/
gecko
/
build
/
level
-
[
0
-
9
]
/
\
*
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
feature
:
allowPtrace
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
capability
:
device
:
.
*
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
capability
:
privileged
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
cache
:
gecko
-
level
-
1
-
checkouts
.
*
"
)
    
re
.
compile
(
r
"
^
docker
-
worker
:
cache
:
gecko
-
level
-
1
-
tooltool
-
cache
.
*
"
)
]
def
context
(
params
)
:
    
if
int
(
params
[
"
level
"
]
)
<
3
:
        
return
[
{
"
worker
-
implementation
"
:
"
docker
-
worker
"
}
]
    
return
[
        
{
"
worker
-
implementation
"
:
"
docker
-
worker
"
"
kind
"
:
kind
}
for
kind
in
TEST_KINDS
    
]
register_callback_action
(
    
title
=
"
Create
Interactive
Task
"
    
name
=
"
create
-
interactive
"
    
symbol
=
"
create
-
inter
"
    
description
=
(
"
Create
a
a
copy
of
the
task
that
you
can
interact
with
"
)
    
order
=
50
    
context
=
context
    
schema
=
{
        
"
type
"
:
"
object
"
        
"
properties
"
:
{
            
"
notify
"
:
{
                
"
type
"
:
"
string
"
                
"
format
"
:
"
email
"
                
"
title
"
:
"
Who
to
notify
of
the
pending
interactive
task
"
                
"
description
"
:
(
                    
"
Enter
your
email
here
to
get
an
email
containing
a
link
"
                    
"
to
interact
with
the
task
"
                
)
                
"
default
"
:
"
noreply
noreply
.
mozilla
.
org
"
            
}
        
}
        
"
additionalProperties
"
:
False
    
}
)
def
create_interactive_action
(
parameters
graph_config
input
task_group_id
task_id
)
:
    
decision_task_id
full_task_graph
label_to_taskid
_
=
fetch_graph_and_labels
(
        
parameters
graph_config
    
)
    
task
=
get_task_definition
(
task_id
)
    
label
=
task
[
"
metadata
"
]
[
"
name
"
]
    
def
edit
(
task
)
:
        
if
task
.
label
!
=
label
:
            
return
task
        
task_def
=
task
.
task
        
task_def
[
"
routes
"
]
=
[
]
        
task_def
[
"
retries
"
]
=
0
        
task_def
[
"
deadline
"
]
=
{
"
relative
-
datestamp
"
:
"
12
hours
"
}
        
task_def
[
"
created
"
]
=
{
"
relative
-
datestamp
"
:
"
0
hours
"
}
        
task_def
[
"
expires
"
]
=
{
"
relative
-
datestamp
"
:
"
1
day
"
}
        
task
.
task
[
"
scopes
"
]
=
[
            
s
            
for
s
in
task
.
task
.
get
(
"
scopes
"
[
]
)
            
if
any
(
p
.
match
(
s
)
for
p
in
SCOPE_WHITELIST
)
        
]
        
payload
=
task_def
[
"
payload
"
]
        
payload
[
"
maxRunTime
"
]
=
max
(
3600
*
3
payload
.
get
(
"
maxRunTime
"
0
)
)
        
payload
[
"
cache
"
]
=
{
}
        
payload
[
"
artifacts
"
]
=
{
}
        
payload
.
setdefault
(
"
features
"
{
}
)
[
"
interactive
"
]
=
True
        
payload
.
setdefault
(
"
env
"
{
}
)
[
"
TASKCLUSTER_INTERACTIVE
"
]
=
"
true
"
        
for
key
in
task_def
[
"
payload
"
]
[
"
env
"
]
.
keys
(
)
:
            
payload
[
"
env
"
]
[
key
]
=
task_def
[
"
payload
"
]
[
"
env
"
]
.
get
(
key
"
"
)
        
email
=
input
.
get
(
"
notify
"
)
        
if
email
and
email
!
=
"
noreply
noreply
.
mozilla
.
org
"
:
            
info
=
{
                
"
url
"
:
taskcluster_urls
.
ui
(
                    
get_root_url
(
False
)
"
tasks
/
{
status
.
taskId
}
/
connect
"
                
)
                
"
label
"
:
label
                
"
revision
"
:
parameters
[
"
head_rev
"
]
                
"
repo
"
:
parameters
[
"
head_repository
"
]
            
}
            
task_def
.
setdefault
(
"
extra
"
{
}
)
.
setdefault
(
"
notify
"
{
}
)
[
"
email
"
]
=
{
                
"
subject
"
:
EMAIL_SUBJECT
.
format
(
*
*
info
)
                
"
content
"
:
EMAIL_CONTENT
.
format
(
*
*
info
)
                
"
link
"
:
{
"
text
"
:
"
Connect
"
"
href
"
:
info
[
"
url
"
]
}
            
}
            
task_def
[
"
routes
"
]
.
append
(
f
"
notify
.
email
.
{
email
}
.
on
-
pending
"
)
        
return
task
    
action_task_id
=
os
.
environ
.
get
(
"
TASK_ID
"
)
    
label_to_taskid
=
create_tasks
(
        
graph_config
        
[
label
]
        
full_task_graph
        
label_to_taskid
        
parameters
        
decision_task_id
=
action_task_id
        
modifier
=
edit
    
)
    
taskId
=
label_to_taskid
[
label
]
    
logger
.
info
(
f
"
Created
interactive
task
{
taskId
}
"
)
