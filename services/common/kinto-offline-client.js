this
.
EXPORTED_SYMBOLS
=
[
"
loadKinto
"
]
;
(
function
(
f
)
{
if
(
typeof
exports
=
=
=
"
object
"
&
&
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
loadKinto
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends2
=
require
(
"
babel
-
runtime
/
helpers
/
extends
"
)
;
var
_extends3
=
_interopRequireDefault
(
_extends2
)
;
var
_stringify
=
require
(
"
babel
-
runtime
/
core
-
js
/
json
/
stringify
"
)
;
var
_stringify2
=
_interopRequireDefault
(
_stringify
)
;
var
_promise
=
require
(
"
babel
-
runtime
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
exports
.
reduceRecords
=
reduceRecords
;
var
_base
=
require
(
"
.
.
/
src
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_utils
=
require
(
"
.
.
/
src
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
SQLITE_PATH
=
"
kinto
.
sqlite
"
;
const
statements
=
{
"
createCollectionData
"
:
CREATE
TABLE
collection_data
(
collection_name
TEXT
record_id
TEXT
record
TEXT
)
;
"
createCollectionMetadata
"
:
CREATE
TABLE
collection_metadata
(
collection_name
TEXT
PRIMARY
KEY
last_modified
INTEGER
)
WITHOUT
ROWID
;
"
createCollectionDataRecordIdIndex
"
:
CREATE
UNIQUE
INDEX
unique_collection_record
ON
collection_data
(
collection_name
record_id
)
;
"
clearData
"
:
DELETE
FROM
collection_data
WHERE
collection_name
=
:
collection_name
;
"
createData
"
:
INSERT
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
"
updateData
"
:
INSERT
OR
REPLACE
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
"
deleteData
"
:
DELETE
FROM
collection_data
WHERE
collection_name
=
:
collection_name
AND
record_id
=
:
record_id
;
"
saveLastModified
"
:
REPLACE
INTO
collection_metadata
(
collection_name
last_modified
)
VALUES
(
:
collection_name
:
last_modified
)
;
"
getLastModified
"
:
SELECT
last_modified
FROM
collection_metadata
WHERE
collection_name
=
:
collection_name
;
"
getRecord
"
:
SELECT
record
FROM
collection_data
WHERE
collection_name
=
:
collection_name
AND
record_id
=
:
record_id
;
"
listRecords
"
:
SELECT
record
FROM
collection_data
WHERE
collection_name
=
:
collection_name
;
"
listRecordsById
"
:
SELECT
record_id
record
FROM
collection_data
WHERE
collection_name
=
?
AND
record_id
IN
"
importData
"
:
REPLACE
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
"
scanAllRecords
"
:
SELECT
*
FROM
collection_data
;
"
clearCollectionMetadata
"
:
DELETE
FROM
collection_metadata
;
}
;
const
createStatements
=
[
"
createCollectionData
"
"
createCollectionMetadata
"
"
createCollectionDataRecordIdIndex
"
]
;
const
currentSchemaVersion
=
1
;
class
FirefoxAdapter
extends
_base2
.
default
{
constructor
(
collection
options
=
{
}
)
{
super
(
)
;
this
.
collection
=
collection
;
this
.
_connection
=
null
;
this
.
_options
=
options
;
}
_init
(
connection
)
{
return
Task
.
spawn
(
function
*
(
)
{
yield
connection
.
executeTransaction
(
function
*
doSetup
(
)
{
const
schema
=
yield
connection
.
getSchemaVersion
(
)
;
if
(
schema
=
=
0
)
{
for
(
let
statementName
of
createStatements
)
{
yield
connection
.
execute
(
statements
[
statementName
]
)
;
}
yield
connection
.
setSchemaVersion
(
currentSchemaVersion
)
;
}
else
if
(
schema
!
=
1
)
{
throw
new
Error
(
"
Unknown
database
schema
:
"
+
schema
)
;
}
}
)
;
return
connection
;
}
)
;
}
_executeStatement
(
statement
params
)
{
if
(
!
this
.
_connection
)
{
throw
new
Error
(
"
The
storage
adapter
is
not
open
"
)
;
}
return
this
.
_connection
.
executeCached
(
statement
params
)
;
}
open
(
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
path
=
self
.
_options
.
path
|
|
SQLITE_PATH
;
const
opts
=
{
path
sharedMemoryCache
:
false
}
;
if
(
!
self
.
_connection
)
{
self
.
_connection
=
yield
Sqlite
.
openConnection
(
opts
)
.
then
(
self
.
_init
)
;
}
}
)
;
}
close
(
)
{
if
(
this
.
_connection
)
{
const
promise
=
this
.
_connection
.
close
(
)
;
this
.
_connection
=
null
;
return
promise
;
}
return
_promise2
.
default
.
resolve
(
)
;
}
clear
(
)
{
const
params
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
clearData
params
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
if
(
!
this
.
_connection
)
{
throw
new
Error
(
"
The
storage
adapter
is
not
open
"
)
;
}
let
result
;
const
conn
=
this
.
_connection
;
const
collection
=
this
.
collection
;
return
conn
.
executeTransaction
(
function
*
doExecuteTransaction
(
)
{
const
parameters
=
[
collection
.
.
.
options
.
preload
]
;
const
placeholders
=
options
.
preload
.
map
(
_
=
>
"
?
"
)
;
const
stmt
=
statements
.
listRecordsById
+
"
(
"
+
placeholders
.
join
(
"
"
)
+
"
)
;
"
;
const
rows
=
yield
conn
.
execute
(
stmt
parameters
)
;
const
preloaded
=
rows
.
reduce
(
(
acc
row
)
=
>
{
const
record
=
JSON
.
parse
(
row
.
getResultByName
(
"
record
"
)
)
;
acc
[
row
.
getResultByName
(
"
record_id
"
)
]
=
record
;
return
acc
;
}
{
}
)
;
const
proxy
=
transactionProxy
(
collection
preloaded
)
;
result
=
callback
(
proxy
)
;
for
(
let
{
statement
params
}
of
proxy
.
operations
)
{
yield
conn
.
executeCached
(
statement
params
)
;
}
}
conn
.
TRANSACTION_EXCLUSIVE
)
.
then
(
_
=
>
result
)
;
}
get
(
id
)
{
const
params
=
{
collection_name
:
this
.
collection
record_id
:
id
}
;
return
this
.
_executeStatement
(
statements
.
getRecord
params
)
.
then
(
result
=
>
{
if
(
result
.
length
=
=
0
)
{
return
;
}
return
JSON
.
parse
(
result
[
0
]
.
getResultByName
(
"
record
"
)
)
;
}
)
;
}
list
(
params
=
{
filters
:
{
}
order
:
"
"
}
)
{
const
parameters
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
listRecords
parameters
)
.
then
(
result
=
>
{
const
records
=
[
]
;
for
(
let
k
=
0
;
k
<
result
.
length
;
k
+
+
)
{
const
row
=
result
[
k
]
;
records
.
push
(
JSON
.
parse
(
row
.
getResultByName
(
"
record
"
)
)
)
;
}
return
records
;
}
)
.
then
(
results
=
>
{
return
reduceRecords
(
params
.
filters
params
.
order
results
)
;
}
)
;
}
loadDump
(
records
)
{
const
connection
=
this
.
_connection
;
const
collection_name
=
this
.
collection
;
return
Task
.
spawn
(
function
*
(
)
{
yield
connection
.
executeTransaction
(
function
*
doImport
(
)
{
for
(
let
record
of
records
)
{
const
params
=
{
collection_name
:
collection_name
record_id
:
record
.
id
record
:
(
0
_stringify2
.
default
)
(
record
)
}
;
yield
connection
.
execute
(
statements
.
importData
params
)
;
}
const
lastModified
=
Math
.
max
(
.
.
.
records
.
map
(
record
=
>
record
.
last_modified
)
)
;
const
params
=
{
collection_name
:
collection_name
}
;
const
previousLastModified
=
yield
connection
.
execute
(
statements
.
getLastModified
params
)
.
then
(
result
=
>
{
return
result
.
length
>
0
?
result
[
0
]
.
getResultByName
(
"
last_modified
"
)
:
-
1
;
}
)
;
if
(
lastModified
>
previousLastModified
)
{
const
params
=
{
collection_name
:
collection_name
last_modified
:
lastModified
}
;
yield
connection
.
execute
(
statements
.
saveLastModified
params
)
;
}
}
)
;
return
records
;
}
)
;
}
saveLastModified
(
lastModified
)
{
const
parsedLastModified
=
parseInt
(
lastModified
10
)
|
|
null
;
const
params
=
{
collection_name
:
this
.
collection
last_modified
:
parsedLastModified
}
;
return
this
.
_executeStatement
(
statements
.
saveLastModified
params
)
.
then
(
(
)
=
>
parsedLastModified
)
;
}
getLastModified
(
)
{
const
params
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
getLastModified
params
)
.
then
(
result
=
>
{
if
(
result
.
length
=
=
0
)
{
return
0
;
}
return
result
[
0
]
.
getResultByName
(
"
last_modified
"
)
;
}
)
;
}
resetSyncStatus
(
)
{
if
(
!
this
.
_connection
)
{
throw
new
Error
(
"
The
storage
adapter
is
not
open
"
)
;
}
return
this
.
_connection
.
executeTransaction
(
function
*
(
conn
)
{
const
promises
=
[
]
;
yield
conn
.
execute
(
statements
.
scanAllRecords
null
function
(
row
)
{
const
record
=
JSON
.
parse
(
row
.
getResultByName
(
"
record
"
)
)
;
const
record_id
=
row
.
getResultByName
(
"
record_id
"
)
;
const
collection_name
=
row
.
getResultByName
(
"
collection_name
"
)
;
if
(
record
.
_status
=
=
=
"
deleted
"
)
{
promises
.
push
(
conn
.
execute
(
statements
.
deleteData
{
collection_name
record_id
}
)
)
;
}
else
{
const
newRecord
=
(
0
_extends3
.
default
)
(
{
}
record
{
_status
:
"
created
"
last_modified
:
undefined
}
)
;
promises
.
push
(
conn
.
execute
(
statements
.
updateData
{
record
:
(
0
_stringify2
.
default
)
(
newRecord
)
record_id
collection_name
}
)
)
;
}
}
)
;
yield
_promise2
.
default
.
all
(
promises
)
;
yield
conn
.
execute
(
statements
.
clearCollectionMetadata
)
;
}
)
;
}
}
exports
.
default
=
FirefoxAdapter
;
function
transactionProxy
(
collection
preloaded
)
{
const
_operations
=
[
]
;
return
{
get
operations
(
)
{
return
_operations
;
}
create
(
record
)
{
_operations
.
push
(
{
statement
:
statements
.
createData
params
:
{
collection_name
:
collection
record_id
:
record
.
id
record
:
(
0
_stringify2
.
default
)
(
record
)
}
}
)
;
}
update
(
record
)
{
_operations
.
push
(
{
statement
:
statements
.
updateData
params
:
{
collection_name
:
collection
record_id
:
record
.
id
record
:
(
0
_stringify2
.
default
)
(
record
)
}
}
)
;
}
delete
(
id
)
{
_operations
.
push
(
{
statement
:
statements
.
deleteData
params
:
{
collection_name
:
collection
record_id
:
id
}
}
)
;
}
get
(
id
)
{
return
id
in
preloaded
?
preloaded
[
id
]
:
undefined
;
}
}
;
}
function
reduceRecords
(
filters
order
list
)
{
const
filtered
=
filters
?
(
0
_utils
.
filterObjects
)
(
filters
list
)
:
list
;
return
order
?
(
0
_utils
.
sortObjects
)
(
order
filtered
)
:
filtered
;
}
}
{
"
.
.
/
src
/
adapters
/
base
"
:
85
"
.
.
/
src
/
utils
"
:
87
"
babel
-
runtime
/
core
-
js
/
json
/
stringify
"
:
3
"
babel
-
runtime
/
core
-
js
/
promise
"
:
6
"
babel
-
runtime
/
helpers
/
extends
"
:
8
}
]
2
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends2
=
require
(
"
babel
-
runtime
/
helpers
/
extends
"
)
;
var
_extends3
=
_interopRequireDefault
(
_extends2
)
;
exports
.
default
=
loadKinto
;
var
_base
=
require
(
"
.
.
/
src
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_KintoBase
=
require
(
"
.
.
/
src
/
KintoBase
"
)
;
var
_KintoBase2
=
_interopRequireDefault
(
_KintoBase
)
;
var
_FirefoxStorage
=
require
(
"
.
/
FirefoxStorage
"
)
;
var
_FirefoxStorage2
=
_interopRequireDefault
(
_FirefoxStorage
)
;
var
_utils
=
require
(
"
.
.
/
src
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
function
loadKinto
(
)
{
const
{
EventEmitter
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
{
}
)
;
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
{
KintoHttpClient
}
=
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
'
fetch
'
]
)
;
function
makeIDSchema
(
)
{
return
{
validate
:
_utils
.
RE_UUID
.
test
.
bind
(
_utils
.
RE_UUID
)
generate
:
function
(
)
{
return
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
]
/
g
"
"
)
;
}
}
;
}
class
KintoFX
extends
_KintoBase2
.
default
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
FirefoxAdapter
:
_FirefoxStorage2
.
default
}
;
}
constructor
(
options
=
{
}
)
{
const
emitter
=
{
}
;
EventEmitter
.
decorate
(
emitter
)
;
const
defaults
=
{
events
:
emitter
ApiClass
:
KintoHttpClient
adapter
:
_FirefoxStorage2
.
default
}
;
const
expandedOptions
=
(
0
_extends3
.
default
)
(
{
}
defaults
options
)
;
super
(
expandedOptions
)
;
}
collection
(
collName
options
=
{
}
)
{
const
idSchema
=
makeIDSchema
(
)
;
const
expandedOptions
=
(
0
_extends3
.
default
)
(
{
idSchema
}
options
)
;
return
super
.
collection
(
collName
expandedOptions
)
;
}
}
return
KintoFX
;
}
if
(
typeof
module
=
=
=
"
object
"
)
{
module
.
exports
=
loadKinto
;
}
}
{
"
.
.
/
src
/
KintoBase
"
:
83
"
.
.
/
src
/
adapters
/
base
"
:
85
"
.
.
/
src
/
utils
"
:
87
"
.
/
FirefoxStorage
"
:
1
"
babel
-
runtime
/
helpers
/
extends
"
:
8
}
]
3
:
[
function
(
require
module
exports
)
{
module
.
exports
=
{
"
default
"
:
require
(
"
core
-
js
/
library
/
fn
/
json
/
stringify
"
)
__esModule
:
true
}
;
}
{
"
core
-
js
/
library
/
fn
/
json
/
stringify
"
:
10
}
]
4
:
[
function
(
require
module
exports
)
{
module
.
exports
=
{
"
default
"
:
require
(
"
core
-
js
/
library
/
fn
/
object
/
assign
"
)
__esModule
:
true
}
;
}
{
"
core
-
js
/
library
/
fn
/
object
/
assign
"
:
11
}
]
5
:
[
function
(
require
module
exports
)
{
module
.
exports
=
{
"
default
"
:
require
(
"
core
-
js
/
library
/
fn
/
object
/
keys
"
)
__esModule
:
true
}
;
}
{
"
core
-
js
/
library
/
fn
/
object
/
keys
"
:
12
}
]
6
:
[
function
(
require
module
exports
)
{
module
.
exports
=
{
"
default
"
:
require
(
"
core
-
js
/
library
/
fn
/
promise
"
)
__esModule
:
true
}
;
}
{
"
core
-
js
/
library
/
fn
/
promise
"
:
13
}
]
7
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
var
_promise
=
require
(
"
.
.
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
exports
.
default
=
function
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
_promise2
.
default
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
;
}
{
"
.
.
/
core
-
js
/
promise
"
:
6
}
]
8
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
var
_assign
=
require
(
"
.
.
/
core
-
js
/
object
/
assign
"
)
;
var
_assign2
=
_interopRequireDefault
(
_assign
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
exports
.
default
=
_assign2
.
default
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
}
{
"
.
.
/
core
-
js
/
object
/
assign
"
:
4
}
]
9
:
[
function
(
require
module
exports
)
{
}
{
}
]
10
:
[
function
(
require
module
exports
)
{
var
core
=
require
(
'
.
.
/
.
.
/
modules
/
_core
'
)
JSON
=
core
.
JSON
|
|
(
core
.
JSON
=
{
stringify
:
JSON
.
stringify
}
)
;
module
.
exports
=
function
stringify
(
it
)
{
return
JSON
.
stringify
.
apply
(
JSON
arguments
)
;
}
;
}
{
"
.
.
/
.
.
/
modules
/
_core
"
:
21
}
]
11
:
[
function
(
require
module
exports
)
{
require
(
'
.
.
/
.
.
/
modules
/
es6
.
object
.
assign
'
)
;
module
.
exports
=
require
(
'
.
.
/
.
.
/
modules
/
_core
'
)
.
Object
.
assign
;
}
{
"
.
.
/
.
.
/
modules
/
_core
"
:
21
"
.
.
/
.
.
/
modules
/
es6
.
object
.
assign
"
:
77
}
]
12
:
[
function
(
require
module
exports
)
{
require
(
'
.
.
/
.
.
/
modules
/
es6
.
object
.
keys
'
)
;
module
.
exports
=
require
(
'
.
.
/
.
.
/
modules
/
_core
'
)
.
Object
.
keys
;
}
{
"
.
.
/
.
.
/
modules
/
_core
"
:
21
"
.
.
/
.
.
/
modules
/
es6
.
object
.
keys
"
:
78
}
]
13
:
[
function
(
require
module
exports
)
{
require
(
'
.
.
/
modules
/
es6
.
object
.
to
-
string
'
)
;
require
(
'
.
.
/
modules
/
es6
.
string
.
iterator
'
)
;
require
(
'
.
.
/
modules
/
web
.
dom
.
iterable
'
)
;
require
(
'
.
.
/
modules
/
es6
.
promise
'
)
;
module
.
exports
=
require
(
'
.
.
/
modules
/
_core
'
)
.
Promise
;
}
{
"
.
.
/
modules
/
_core
"
:
21
"
.
.
/
modules
/
es6
.
object
.
to
-
string
"
:
79
"
.
.
/
modules
/
es6
.
promise
"
:
80
"
.
.
/
modules
/
es6
.
string
.
iterator
"
:
81
"
.
.
/
modules
/
web
.
dom
.
iterable
"
:
82
}
]
14
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
it
)
{
if
(
typeof
it
!
=
'
function
'
)
throw
TypeError
(
it
+
'
is
not
a
function
!
'
)
;
return
it
;
}
;
}
{
}
]
15
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
)
{
}
;
}
{
}
]
16
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
it
Constructor
name
forbiddenField
)
{
if
(
!
(
it
instanceof
Constructor
)
|
|
(
forbiddenField
!
=
=
undefined
&
&
forbiddenField
in
it
)
)
{
throw
TypeError
(
name
+
'
:
incorrect
invocation
!
'
)
;
}
return
it
;
}
;
}
{
}
]
17
:
[
function
(
require
module
exports
)
{
var
isObject
=
require
(
'
.
/
_is
-
object
'
)
;
module
.
exports
=
function
(
it
)
{
if
(
!
isObject
(
it
)
)
throw
TypeError
(
it
+
'
is
not
an
object
!
'
)
;
return
it
;
}
;
}
{
"
.
/
_is
-
object
"
:
38
}
]
18
:
[
function
(
require
module
exports
)
{
var
toIObject
=
require
(
'
.
/
_to
-
iobject
'
)
toLength
=
require
(
'
.
/
_to
-
length
'
)
toIndex
=
require
(
'
.
/
_to
-
index
'
)
;
module
.
exports
=
function
(
IS_INCLUDES
)
{
return
function
(
this
el
fromIndex
)
{
var
O
=
toIObject
(
this
)
length
=
toLength
(
O
.
length
)
index
=
toIndex
(
fromIndex
length
)
value
;
if
(
IS_INCLUDES
&
&
el
!
=
el
)
while
(
length
>
index
)
{
value
=
O
[
index
+
+
]
;
if
(
value
!
=
value
)
return
true
;
}
else
for
(
;
length
>
index
;
index
+
+
)
if
(
IS_INCLUDES
|
|
index
in
O
)
{
if
(
O
[
index
]
=
=
=
el
)
return
IS_INCLUDES
|
|
index
|
|
0
;
}
return
!
IS_INCLUDES
&
&
-
1
;
}
;
}
;
}
{
"
.
/
_to
-
index
"
:
67
"
.
/
_to
-
iobject
"
:
69
"
.
/
_to
-
length
"
:
70
}
]
19
:
[
function
(
require
module
exports
)
{
var
cof
=
require
(
'
.
/
_cof
'
)
TAG
=
require
(
'
.
/
_wks
'
)
(
'
toStringTag
'
)
ARG
=
cof
(
function
(
)
{
return
arguments
;
}
(
)
)
=
=
'
Arguments
'
;
var
tryGet
=
function
(
it
key
)
{
try
{
return
it
[
key
]
;
}
catch
(
e
)
{
}
}
;
module
.
exports
=
function
(
it
)
{
var
O
T
B
;
return
it
=
=
=
undefined
?
'
Undefined
'
:
it
=
=
=
null
?
'
Null
'
:
typeof
(
T
=
tryGet
(
O
=
Object
(
it
)
TAG
)
)
=
=
'
string
'
?
T
:
ARG
?
cof
(
O
)
:
(
B
=
cof
(
O
)
)
=
=
'
Object
'
&
&
typeof
O
.
callee
=
=
'
function
'
?
'
Arguments
'
:
B
;
}
;
}
{
"
.
/
_cof
"
:
20
"
.
/
_wks
"
:
74
}
]
20
:
[
function
(
require
module
exports
)
{
var
toString
=
{
}
.
toString
;
module
.
exports
=
function
(
it
)
{
return
toString
.
call
(
it
)
.
slice
(
8
-
1
)
;
}
;
}
{
}
]
21
:
[
function
(
require
module
exports
)
{
var
core
=
module
.
exports
=
{
version
:
'
2
.
4
.
0
'
}
;
if
(
typeof
__e
=
=
'
number
'
)
__e
=
core
;
}
{
}
]
22
:
[
function
(
require
module
exports
)
{
var
aFunction
=
require
(
'
.
/
_a
-
function
'
)
;
module
.
exports
=
function
(
fn
that
length
)
{
aFunction
(
fn
)
;
if
(
that
=
=
=
undefined
)
return
fn
;
switch
(
length
)
{
case
1
:
return
function
(
a
)
{
return
fn
.
call
(
that
a
)
;
}
;
case
2
:
return
function
(
a
b
)
{
return
fn
.
call
(
that
a
b
)
;
}
;
case
3
:
return
function
(
a
b
c
)
{
return
fn
.
call
(
that
a
b
c
)
;
}
;
}
return
function
(
)
{
return
fn
.
apply
(
that
arguments
)
;
}
;
}
;
}
{
"
.
/
_a
-
function
"
:
14
}
]
23
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
it
)
{
if
(
it
=
=
undefined
)
throw
TypeError
(
"
Can
'
t
call
method
on
"
+
it
)
;
return
it
;
}
;
}
{
}
]
24
:
[
function
(
require
module
exports
)
{
module
.
exports
=
!
require
(
'
.
/
_fails
'
)
(
function
(
)
{
return
Object
.
defineProperty
(
{
}
'
a
'
{
get
:
function
(
)
{
return
7
;
}
}
)
.
a
!
=
7
;
}
)
;
}
{
"
.
/
_fails
"
:
28
}
]
25
:
[
function
(
require
module
exports
)
{
var
isObject
=
require
(
'
.
/
_is
-
object
'
)
document
=
require
(
'
.
/
_global
'
)
.
document
is
=
isObject
(
document
)
&
&
isObject
(
document
.
createElement
)
;
module
.
exports
=
function
(
it
)
{
return
is
?
document
.
createElement
(
it
)
:
{
}
;
}
;
}
{
"
.
/
_global
"
:
30
"
.
/
_is
-
object
"
:
38
}
]
26
:
[
function
(
require
module
exports
)
{
module
.
exports
=
(
'
constructor
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
toLocaleString
toString
valueOf
'
)
.
split
(
'
'
)
;
}
{
}
]
27
:
[
function
(
require
module
exports
)
{
var
global
=
require
(
'
.
/
_global
'
)
core
=
require
(
'
.
/
_core
'
)
ctx
=
require
(
'
.
/
_ctx
'
)
hide
=
require
(
'
.
/
_hide
'
)
PROTOTYPE
=
'
prototype
'
;
var
export
=
function
(
type
name
source
)
{
var
IS_FORCED
=
type
&
export
.
F
IS_GLOBAL
=
type
&
export
.
G
IS_STATIC
=
type
&
export
.
S
IS_PROTO
=
type
&
export
.
P
IS_BIND
=
type
&
export
.
B
IS_WRAP
=
type
&
export
.
W
exports
=
IS_GLOBAL
?
core
:
core
[
name
]
|
|
(
core
[
name
]
=
{
}
)
expProto
=
exports
[
PROTOTYPE
]
target
=
IS_GLOBAL
?
global
:
IS_STATIC
?
global
[
name
]
:
(
global
[
name
]
|
|
{
}
)
[
PROTOTYPE
]
key
own
out
;
if
(
IS_GLOBAL
)
source
=
name
;
for
(
key
in
source
)
{
own
=
!
IS_FORCED
&
&
target
&
&
target
[
key
]
!
=
=
undefined
;
if
(
own
&
&
key
in
exports
)
continue
;
out
=
own
?
target
[
key
]
:
source
[
key
]
;
exports
[
key
]
=
IS_GLOBAL
&
&
typeof
target
[
key
]
!
=
'
function
'
?
source
[
key
]
:
IS_BIND
&
&
own
?
ctx
(
out
global
)
:
IS_WRAP
&
&
target
[
key
]
=
=
out
?
(
function
(
C
)
{
var
F
=
function
(
a
b
c
)
{
if
(
this
instanceof
C
)
{
switch
(
arguments
.
length
)
{
case
0
:
return
new
C
;
case
1
:
return
new
C
(
a
)
;
case
2
:
return
new
C
(
a
b
)
;
}
return
new
C
(
a
b
c
)
;
}
return
C
.
apply
(
this
arguments
)
;
}
;
F
[
PROTOTYPE
]
=
C
[
PROTOTYPE
]
;
return
F
;
}
)
(
out
)
:
IS_PROTO
&
&
typeof
out
=
=
'
function
'
?
ctx
(
Function
.
call
out
)
:
out
;
if
(
IS_PROTO
)
{
(
exports
.
virtual
|
|
(
exports
.
virtual
=
{
}
)
)
[
key
]
=
out
;
if
(
type
&
export
.
R
&
&
expProto
&
&
!
expProto
[
key
]
)
hide
(
expProto
key
out
)
;
}
}
}
;
export
.
F
=
1
;
export
.
G
=
2
;
export
.
S
=
4
;
export
.
P
=
8
;
export
.
B
=
16
;
export
.
W
=
32
;
export
.
U
=
64
;
export
.
R
=
128
;
module
.
exports
=
export
;
}
{
"
.
/
_core
"
:
21
"
.
/
_ctx
"
:
22
"
.
/
_global
"
:
30
"
.
/
_hide
"
:
32
}
]
28
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
exec
)
{
try
{
return
!
!
exec
(
)
;
}
catch
(
e
)
{
return
true
;
}
}
;
}
{
}
]
29
:
[
function
(
require
module
exports
)
{
var
ctx
=
require
(
'
.
/
_ctx
'
)
call
=
require
(
'
.
/
_iter
-
call
'
)
isArrayIter
=
require
(
'
.
/
_is
-
array
-
iter
'
)
anObject
=
require
(
'
.
/
_an
-
object
'
)
toLength
=
require
(
'
.
/
_to
-
length
'
)
getIterFn
=
require
(
'
.
/
core
.
get
-
iterator
-
method
'
)
BREAK
=
{
}
RETURN
=
{
}
;
var
exports
=
module
.
exports
=
function
(
iterable
entries
fn
that
ITERATOR
)
{
var
iterFn
=
ITERATOR
?
function
(
)
{
return
iterable
;
}
:
getIterFn
(
iterable
)
f
=
ctx
(
fn
that
entries
?
2
:
1
)
index
=
0
length
step
iterator
result
;
if
(
typeof
iterFn
!
=
'
function
'
)
throw
TypeError
(
iterable
+
'
is
not
iterable
!
'
)
;
if
(
isArrayIter
(
iterFn
)
)
for
(
length
=
toLength
(
iterable
.
length
)
;
length
>
index
;
index
+
+
)
{
result
=
entries
?
f
(
anObject
(
step
=
iterable
[
index
]
)
[
0
]
step
[
1
]
)
:
f
(
iterable
[
index
]
)
;
if
(
result
=
=
=
BREAK
|
|
result
=
=
=
RETURN
)
return
result
;
}
else
for
(
iterator
=
iterFn
.
call
(
iterable
)
;
!
(
step
=
iterator
.
next
(
)
)
.
done
;
)
{
result
=
call
(
iterator
f
step
.
value
entries
)
;
if
(
result
=
=
=
BREAK
|
|
result
=
=
=
RETURN
)
return
result
;
}
}
;
exports
.
BREAK
=
BREAK
;
exports
.
RETURN
=
RETURN
;
}
{
"
.
/
_an
-
object
"
:
17
"
.
/
_ctx
"
:
22
"
.
/
_is
-
array
-
iter
"
:
37
"
.
/
_iter
-
call
"
:
39
"
.
/
_to
-
length
"
:
70
"
.
/
core
.
get
-
iterator
-
method
"
:
75
}
]
30
:
[
function
(
require
module
exports
)
{
var
global
=
module
.
exports
=
typeof
window
!
=
'
undefined
'
&
&
window
.
Math
=
=
Math
?
window
:
typeof
self
!
=
'
undefined
'
&
&
self
.
Math
=
=
Math
?
self
:
Function
(
'
return
this
'
)
(
)
;
if
(
typeof
__g
=
=
'
number
'
)
__g
=
global
;
}
{
}
]
31
:
[
function
(
require
module
exports
)
{
var
hasOwnProperty
=
{
}
.
hasOwnProperty
;
module
.
exports
=
function
(
it
key
)
{
return
hasOwnProperty
.
call
(
it
key
)
;
}
;
}
{
}
]
32
:
[
function
(
require
module
exports
)
{
var
dP
=
require
(
'
.
/
_object
-
dp
'
)
createDesc
=
require
(
'
.
/
_property
-
desc
'
)
;
module
.
exports
=
require
(
'
.
/
_descriptors
'
)
?
function
(
object
key
value
)
{
return
dP
.
f
(
object
key
createDesc
(
1
value
)
)
;
}
:
function
(
object
key
value
)
{
object
[
key
]
=
value
;
return
object
;
}
;
}
{
"
.
/
_descriptors
"
:
24
"
.
/
_object
-
dp
"
:
49
"
.
/
_property
-
desc
"
:
57
}
]
33
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
'
.
/
_global
'
)
.
document
&
&
document
.
documentElement
;
}
{
"
.
/
_global
"
:
30
}
]
34
:
[
function
(
require
module
exports
)
{
module
.
exports
=
!
require
(
'
.
/
_descriptors
'
)
&
&
!
require
(
'
.
/
_fails
'
)
(
function
(
)
{
return
Object
.
defineProperty
(
require
(
'
.
/
_dom
-
create
'
)
(
'
div
'
)
'
a
'
{
get
:
function
(
)
{
return
7
;
}
}
)
.
a
!
=
7
;
}
)
;
}
{
"
.
/
_descriptors
"
:
24
"
.
/
_dom
-
create
"
:
25
"
.
/
_fails
"
:
28
}
]
35
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
fn
args
that
)
{
var
un
=
that
=
=
=
undefined
;
switch
(
args
.
length
)
{
case
0
:
return
un
?
fn
(
)
:
fn
.
call
(
that
)
;
case
1
:
return
un
?
fn
(
args
[
0
]
)
:
fn
.
call
(
that
args
[
0
]
)
;
case
2
:
return
un
?
fn
(
args
[
0
]
args
[
1
]
)
:
fn
.
call
(
that
args
[
0
]
args
[
1
]
)
;
case
3
:
return
un
?
fn
(
args
[
0
]
args
[
1
]
args
[
2
]
)
:
fn
.
call
(
that
args
[
0
]
args
[
1
]
args
[
2
]
)
;
case
4
:
return
un
?
fn
(
args
[
0
]
args
[
1
]
args
[
2
]
args
[
3
]
)
:
fn
.
call
(
that
args
[
0
]
args
[
1
]
args
[
2
]
args
[
3
]
)
;
}
return
fn
.
apply
(
that
args
)
;
}
;
}
{
}
]
36
:
[
function
(
require
module
exports
)
{
var
cof
=
require
(
'
.
/
_cof
'
)
;
module
.
exports
=
Object
(
'
z
'
)
.
propertyIsEnumerable
(
0
)
?
Object
:
function
(
it
)
{
return
cof
(
it
)
=
=
'
String
'
?
it
.
split
(
'
'
)
:
Object
(
it
)
;
}
;
}
{
"
.
/
_cof
"
:
20
}
]
37
:
[
function
(
require
module
exports
)
{
var
Iterators
=
require
(
'
.
/
_iterators
'
)
ITERATOR
=
require
(
'
.
/
_wks
'
)
(
'
iterator
'
)
ArrayProto
=
Array
.
prototype
;
module
.
exports
=
function
(
it
)
{
return
it
!
=
=
undefined
&
&
(
Iterators
.
Array
=
=
=
it
|
|
ArrayProto
[
ITERATOR
]
=
=
=
it
)
;
}
;
}
{
"
.
/
_iterators
"
:
44
"
.
/
_wks
"
:
74
}
]
38
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
it
)
{
return
typeof
it
=
=
=
'
object
'
?
it
!
=
=
null
:
typeof
it
=
=
=
'
function
'
;
}
;
}
{
}
]
39
:
[
function
(
require
module
exports
)
{
var
anObject
=
require
(
'
.
/
_an
-
object
'
)
;
module
.
exports
=
function
(
iterator
fn
value
entries
)
{
try
{
return
entries
?
fn
(
anObject
(
value
)
[
0
]
value
[
1
]
)
:
fn
(
value
)
;
}
catch
(
e
)
{
var
ret
=
iterator
[
'
return
'
]
;
if
(
ret
!
=
=
undefined
)
anObject
(
ret
.
call
(
iterator
)
)
;
throw
e
;
}
}
;
}
{
"
.
/
_an
-
object
"
:
17
}
]
40
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
create
=
require
(
'
.
/
_object
-
create
'
)
descriptor
=
require
(
'
.
/
_property
-
desc
'
)
setToStringTag
=
require
(
'
.
/
_set
-
to
-
string
-
tag
'
)
IteratorPrototype
=
{
}
;
require
(
'
.
/
_hide
'
)
(
IteratorPrototype
require
(
'
.
/
_wks
'
)
(
'
iterator
'
)
function
(
)
{
return
this
;
}
)
;
module
.
exports
=
function
(
Constructor
NAME
next
)
{
Constructor
.
prototype
=
create
(
IteratorPrototype
{
next
:
descriptor
(
1
next
)
}
)
;
setToStringTag
(
Constructor
NAME
+
'
Iterator
'
)
;
}
;
}
{
"
.
/
_hide
"
:
32
"
.
/
_object
-
create
"
:
48
"
.
/
_property
-
desc
"
:
57
"
.
/
_set
-
to
-
string
-
tag
"
:
61
"
.
/
_wks
"
:
74
}
]
41
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
LIBRARY
=
require
(
'
.
/
_library
'
)
export
=
require
(
'
.
/
_export
'
)
redefine
=
require
(
'
.
/
_redefine
'
)
hide
=
require
(
'
.
/
_hide
'
)
has
=
require
(
'
.
/
_has
'
)
Iterators
=
require
(
'
.
/
_iterators
'
)
iterCreate
=
require
(
'
.
/
_iter
-
create
'
)
setToStringTag
=
require
(
'
.
/
_set
-
to
-
string
-
tag
'
)
getPrototypeOf
=
require
(
'
.
/
_object
-
gpo
'
)
ITERATOR
=
require
(
'
.
/
_wks
'
)
(
'
iterator
'
)
BUGGY
=
!
(
[
]
.
keys
&
&
'
next
'
in
[
]
.
keys
(
)
)
FF_ITERATOR
=
'
iterator
'
KEYS
=
'
keys
'
VALUES
=
'
values
'
;
var
returnThis
=
function
(
)
{
return
this
;
}
;
module
.
exports
=
function
(
Base
NAME
Constructor
next
DEFAULT
IS_SET
FORCED
)
{
iterCreate
(
Constructor
NAME
next
)
;
var
getMethod
=
function
(
kind
)
{
if
(
!
BUGGY
&
&
kind
in
proto
)
return
proto
[
kind
]
;
switch
(
kind
)
{
case
KEYS
:
return
function
keys
(
)
{
return
new
Constructor
(
this
kind
)
;
}
;
case
VALUES
:
return
function
values
(
)
{
return
new
Constructor
(
this
kind
)
;
}
;
}
return
function
entries
(
)
{
return
new
Constructor
(
this
kind
)
;
}
;
}
;
var
TAG
=
NAME
+
'
Iterator
'
DEF_VALUES
=
DEFAULT
=
=
VALUES
VALUES_BUG
=
false
proto
=
Base
.
prototype
native
=
proto
[
ITERATOR
]
|
|
proto
[
FF_ITERATOR
]
|
|
DEFAULT
&
&
proto
[
DEFAULT
]
default
=
native
|
|
getMethod
(
DEFAULT
)
entries
=
DEFAULT
?
!
DEF_VALUES
?
default
:
getMethod
(
'
entries
'
)
:
undefined
anyNative
=
NAME
=
=
'
Array
'
?
proto
.
entries
|
|
native
:
native
methods
key
IteratorPrototype
;
if
(
anyNative
)
{
IteratorPrototype
=
getPrototypeOf
(
anyNative
.
call
(
new
Base
)
)
;
if
(
IteratorPrototype
!
=
=
Object
.
prototype
)
{
setToStringTag
(
IteratorPrototype
TAG
true
)
;
if
(
!
LIBRARY
&
&
!
has
(
IteratorPrototype
ITERATOR
)
)
hide
(
IteratorPrototype
ITERATOR
returnThis
)
;
}
}
if
(
DEF_VALUES
&
&
native
&
&
native
.
name
!
=
=
VALUES
)
{
VALUES_BUG
=
true
;
default
=
function
values
(
)
{
return
native
.
call
(
this
)
;
}
;
}
if
(
(
!
LIBRARY
|
|
FORCED
)
&
&
(
BUGGY
|
|
VALUES_BUG
|
|
!
proto
[
ITERATOR
]
)
)
{
hide
(
proto
ITERATOR
default
)
;
}
Iterators
[
NAME
]
=
default
;
Iterators
[
TAG
]
=
returnThis
;
if
(
DEFAULT
)
{
methods
=
{
values
:
DEF_VALUES
?
default
:
getMethod
(
VALUES
)
keys
:
IS_SET
?
default
:
getMethod
(
KEYS
)
entries
:
entries
}
;
if
(
FORCED
)
for
(
key
in
methods
)
{
if
(
!
(
key
in
proto
)
)
redefine
(
proto
key
methods
[
key
]
)
;
}
else
export
(
export
.
P
+
export
.
F
*
(
BUGGY
|
|
VALUES_BUG
)
NAME
methods
)
;
}
return
methods
;
}
;
}
{
"
.
/
_export
"
:
27
"
.
/
_has
"
:
31
"
.
/
_hide
"
:
32
"
.
/
_iter
-
create
"
:
40
"
.
/
_iterators
"
:
44
"
.
/
_library
"
:
45
"
.
/
_object
-
gpo
"
:
52
"
.
/
_redefine
"
:
59
"
.
/
_set
-
to
-
string
-
tag
"
:
61
"
.
/
_wks
"
:
74
}
]
42
:
[
function
(
require
module
exports
)
{
var
ITERATOR
=
require
(
'
.
/
_wks
'
)
(
'
iterator
'
)
SAFE_CLOSING
=
false
;
try
{
var
riter
=
[
7
]
[
ITERATOR
]
(
)
;
riter
[
'
return
'
]
=
function
(
)
{
SAFE_CLOSING
=
true
;
}
;
Array
.
from
(
riter
function
(
)
{
throw
2
;
}
)
;
}
catch
(
e
)
{
}
module
.
exports
=
function
(
exec
skipClosing
)
{
if
(
!
skipClosing
&
&
!
SAFE_CLOSING
)
return
false
;
var
safe
=
false
;
try
{
var
arr
=
[
7
]
iter
=
arr
[
ITERATOR
]
(
)
;
iter
.
next
=
function
(
)
{
return
{
done
:
safe
=
true
}
;
}
;
arr
[
ITERATOR
]
=
function
(
)
{
return
iter
;
}
;
exec
(
arr
)
;
}
catch
(
e
)
{
}
return
safe
;
}
;
}
{
"
.
/
_wks
"
:
74
}
]
43
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
done
value
)
{
return
{
value
:
value
done
:
!
!
done
}
;
}
;
}
{
}
]
44
:
[
function
(
require
module
exports
)
{
module
.
exports
=
{
}
;
}
{
}
]
45
:
[
function
(
require
module
exports
)
{
module
.
exports
=
true
;
}
{
}
]
46
:
[
function
(
require
module
exports
)
{
var
global
=
require
(
'
.
/
_global
'
)
macrotask
=
require
(
'
.
/
_task
'
)
.
set
Observer
=
global
.
MutationObserver
|
|
global
.
WebKitMutationObserver
process
=
global
.
process
Promise
=
global
.
Promise
isNode
=
require
(
'
.
/
_cof
'
)
(
process
)
=
=
'
process
'
;
module
.
exports
=
function
(
)
{
var
head
last
notify
;
var
flush
=
function
(
)
{
var
parent
fn
;
if
(
isNode
&
&
(
parent
=
process
.
domain
)
)
parent
.
exit
(
)
;
while
(
head
)
{
fn
=
head
.
fn
;
head
=
head
.
next
;
try
{
fn
(
)
;
}
catch
(
e
)
{
if
(
head
)
notify
(
)
;
else
last
=
undefined
;
throw
e
;
}
}
last
=
undefined
;
if
(
parent
)
parent
.
enter
(
)
;
}
;
if
(
isNode
)
{
notify
=
function
(
)
{
process
.
nextTick
(
flush
)
;
}
;
}
else
if
(
Observer
)
{
var
toggle
=
true
node
=
document
.
createTextNode
(
'
'
)
;
new
Observer
(
flush
)
.
observe
(
node
{
characterData
:
true
}
)
;
notify
=
function
(
)
{
node
.
data
=
toggle
=
!
toggle
;
}
;
}
else
if
(
Promise
&
&
Promise
.
resolve
)
{
var
promise
=
Promise
.
resolve
(
)
;
notify
=
function
(
)
{
promise
.
then
(
flush
)
;
}
;
}
else
{
notify
=
function
(
)
{
macrotask
.
call
(
global
flush
)
;
}
;
}
return
function
(
fn
)
{
var
task
=
{
fn
:
fn
next
:
undefined
}
;
if
(
last
)
last
.
next
=
task
;
if
(
!
head
)
{
head
=
task
;
notify
(
)
;
}
last
=
task
;
}
;
}
;
}
{
"
.
/
_cof
"
:
20
"
.
/
_global
"
:
30
"
.
/
_task
"
:
66
}
]
47
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
getKeys
=
require
(
'
.
/
_object
-
keys
'
)
gOPS
=
require
(
'
.
/
_object
-
gops
'
)
pIE
=
require
(
'
.
/
_object
-
pie
'
)
toObject
=
require
(
'
.
/
_to
-
object
'
)
IObject
=
require
(
'
.
/
_iobject
'
)
assign
=
Object
.
assign
;
module
.
exports
=
!
assign
|
|
require
(
'
.
/
_fails
'
)
(
function
(
)
{
var
A
=
{
}
B
=
{
}
S
=
Symbol
(
)
K
=
'
abcdefghijklmnopqrst
'
;
A
[
S
]
=
7
;
K
.
split
(
'
'
)
.
forEach
(
function
(
k
)
{
B
[
k
]
=
k
;
}
)
;
return
assign
(
{
}
A
)
[
S
]
!
=
7
|
|
Object
.
keys
(
assign
(
{
}
B
)
)
.
join
(
'
'
)
!
=
K
;
}
)
?
function
assign
(
target
source
)
{
var
T
=
toObject
(
target
)
aLen
=
arguments
.
length
index
=
1
getSymbols
=
gOPS
.
f
isEnum
=
pIE
.
f
;
while
(
aLen
>
index
)
{
var
S
=
IObject
(
arguments
[
index
+
+
]
)
keys
=
getSymbols
?
getKeys
(
S
)
.
concat
(
getSymbols
(
S
)
)
:
getKeys
(
S
)
length
=
keys
.
length
j
=
0
key
;
while
(
length
>
j
)
if
(
isEnum
.
call
(
S
key
=
keys
[
j
+
+
]
)
)
T
[
key
]
=
S
[
key
]
;
}
return
T
;
}
:
assign
;
}
{
"
.
/
_fails
"
:
28
"
.
/
_iobject
"
:
36
"
.
/
_object
-
gops
"
:
51
"
.
/
_object
-
keys
"
:
54
"
.
/
_object
-
pie
"
:
55
"
.
/
_to
-
object
"
:
71
}
]
48
:
[
function
(
require
module
exports
)
{
var
anObject
=
require
(
'
.
/
_an
-
object
'
)
dPs
=
require
(
'
.
/
_object
-
dps
'
)
enumBugKeys
=
require
(
'
.
/
_enum
-
bug
-
keys
'
)
IE_PROTO
=
require
(
'
.
/
_shared
-
key
'
)
(
'
IE_PROTO
'
)
Empty
=
function
(
)
{
}
PROTOTYPE
=
'
prototype
'
;
var
createDict
=
function
(
)
{
var
iframe
=
require
(
'
.
/
_dom
-
create
'
)
(
'
iframe
'
)
i
=
enumBugKeys
.
length
lt
=
'
<
'
gt
=
'
>
'
iframeDocument
;
iframe
.
style
.
display
=
'
none
'
;
require
(
'
.
/
_html
'
)
.
appendChild
(
iframe
)
;
iframe
.
src
=
'
javascript
:
'
;
iframeDocument
=
iframe
.
contentWindow
.
document
;
iframeDocument
.
open
(
)
;
iframeDocument
.
write
(
lt
+
'
script
'
+
gt
+
'
document
.
F
=
Object
'
+
lt
+
'
/
script
'
+
gt
)
;
iframeDocument
.
close
(
)
;
createDict
=
iframeDocument
.
F
;
while
(
i
-
-
)
delete
createDict
[
PROTOTYPE
]
[
enumBugKeys
[
i
]
]
;
return
createDict
(
)
;
}
;
module
.
exports
=
Object
.
create
|
|
function
create
(
O
Properties
)
{
var
result
;
if
(
O
!
=
=
null
)
{
Empty
[
PROTOTYPE
]
=
anObject
(
O
)
;
result
=
new
Empty
;
Empty
[
PROTOTYPE
]
=
null
;
result
[
IE_PROTO
]
=
O
;
}
else
result
=
createDict
(
)
;
return
Properties
=
=
=
undefined
?
result
:
dPs
(
result
Properties
)
;
}
;
}
{
"
.
/
_an
-
object
"
:
17
"
.
/
_dom
-
create
"
:
25
"
.
/
_enum
-
bug
-
keys
"
:
26
"
.
/
_html
"
:
33
"
.
/
_object
-
dps
"
:
50
"
.
/
_shared
-
key
"
:
62
}
]
49
:
[
function
(
require
module
exports
)
{
var
anObject
=
require
(
'
.
/
_an
-
object
'
)
IE8_DOM_DEFINE
=
require
(
'
.
/
_ie8
-
dom
-
define
'
)
toPrimitive
=
require
(
'
.
/
_to
-
primitive
'
)
dP
=
Object
.
defineProperty
;
exports
.
f
=
require
(
'
.
/
_descriptors
'
)
?
Object
.
defineProperty
:
function
defineProperty
(
O
P
Attributes
)
{
anObject
(
O
)
;
P
=
toPrimitive
(
P
true
)
;
anObject
(
Attributes
)
;
if
(
IE8_DOM_DEFINE
)
try
{
return
dP
(
O
P
Attributes
)
;
}
catch
(
e
)
{
}
if
(
'
get
'
in
Attributes
|
|
'
set
'
in
Attributes
)
throw
TypeError
(
'
Accessors
not
supported
!
'
)
;
if
(
'
value
'
in
Attributes
)
O
[
P
]
=
Attributes
.
value
;
return
O
;
}
;
}
{
"
.
/
_an
-
object
"
:
17
"
.
/
_descriptors
"
:
24
"
.
/
_ie8
-
dom
-
define
"
:
34
"
.
/
_to
-
primitive
"
:
72
}
]
50
:
[
function
(
require
module
exports
)
{
var
dP
=
require
(
'
.
/
_object
-
dp
'
)
anObject
=
require
(
'
.
/
_an
-
object
'
)
getKeys
=
require
(
'
.
/
_object
-
keys
'
)
;
module
.
exports
=
require
(
'
.
/
_descriptors
'
)
?
Object
.
defineProperties
:
function
defineProperties
(
O
Properties
)
{
anObject
(
O
)
;
var
keys
=
getKeys
(
Properties
)
length
=
keys
.
length
i
=
0
P
;
while
(
length
>
i
)
dP
.
f
(
O
P
=
keys
[
i
+
+
]
Properties
[
P
]
)
;
return
O
;
}
;
}
{
"
.
/
_an
-
object
"
:
17
"
.
/
_descriptors
"
:
24
"
.
/
_object
-
dp
"
:
49
"
.
/
_object
-
keys
"
:
54
}
]
51
:
[
function
(
require
module
exports
)
{
exports
.
f
=
Object
.
getOwnPropertySymbols
;
}
{
}
]
52
:
[
function
(
require
module
exports
)
{
var
has
=
require
(
'
.
/
_has
'
)
toObject
=
require
(
'
.
/
_to
-
object
'
)
IE_PROTO
=
require
(
'
.
/
_shared
-
key
'
)
(
'
IE_PROTO
'
)
ObjectProto
=
Object
.
prototype
;
module
.
exports
=
Object
.
getPrototypeOf
|
|
function
(
O
)
{
O
=
toObject
(
O
)
;
if
(
has
(
O
IE_PROTO
)
)
return
O
[
IE_PROTO
]
;
if
(
typeof
O
.
constructor
=
=
'
function
'
&
&
O
instanceof
O
.
constructor
)
{
return
O
.
constructor
.
prototype
;
}
return
O
instanceof
Object
?
ObjectProto
:
null
;
}
;
}
{
"
.
/
_has
"
:
31
"
.
/
_shared
-
key
"
:
62
"
.
/
_to
-
object
"
:
71
}
]
53
:
[
function
(
require
module
exports
)
{
var
has
=
require
(
'
.
/
_has
'
)
toIObject
=
require
(
'
.
/
_to
-
iobject
'
)
arrayIndexOf
=
require
(
'
.
/
_array
-
includes
'
)
(
false
)
IE_PROTO
=
require
(
'
.
/
_shared
-
key
'
)
(
'
IE_PROTO
'
)
;
module
.
exports
=
function
(
object
names
)
{
var
O
=
toIObject
(
object
)
i
=
0
result
=
[
]
key
;
for
(
key
in
O
)
if
(
key
!
=
IE_PROTO
)
has
(
O
key
)
&
&
result
.
push
(
key
)
;
while
(
names
.
length
>
i
)
if
(
has
(
O
key
=
names
[
i
+
+
]
)
)
{
~
arrayIndexOf
(
result
key
)
|
|
result
.
push
(
key
)
;
}
return
result
;
}
;
}
{
"
.
/
_array
-
includes
"
:
18
"
.
/
_has
"
:
31
"
.
/
_shared
-
key
"
:
62
"
.
/
_to
-
iobject
"
:
69
}
]
54
:
[
function
(
require
module
exports
)
{
var
keys
=
require
(
'
.
/
_object
-
keys
-
internal
'
)
enumBugKeys
=
require
(
'
.
/
_enum
-
bug
-
keys
'
)
;
module
.
exports
=
Object
.
keys
|
|
function
keys
(
O
)
{
return
keys
(
O
enumBugKeys
)
;
}
;
}
{
"
.
/
_enum
-
bug
-
keys
"
:
26
"
.
/
_object
-
keys
-
internal
"
:
53
}
]
55
:
[
function
(
require
module
exports
)
{
exports
.
f
=
{
}
.
propertyIsEnumerable
;
}
{
}
]
56
:
[
function
(
require
module
exports
)
{
var
export
=
require
(
'
.
/
_export
'
)
core
=
require
(
'
.
/
_core
'
)
fails
=
require
(
'
.
/
_fails
'
)
;
module
.
exports
=
function
(
KEY
exec
)
{
var
fn
=
(
core
.
Object
|
|
{
}
)
[
KEY
]
|
|
Object
[
KEY
]
exp
=
{
}
;
exp
[
KEY
]
=
exec
(
fn
)
;
export
(
export
.
S
+
export
.
F
*
fails
(
function
(
)
{
fn
(
1
)
;
}
)
'
Object
'
exp
)
;
}
;
}
{
"
.
/
_core
"
:
21
"
.
/
_export
"
:
27
"
.
/
_fails
"
:
28
}
]
57
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
bitmap
value
)
{
return
{
enumerable
:
!
(
bitmap
&
1
)
configurable
:
!
(
bitmap
&
2
)
writable
:
!
(
bitmap
&
4
)
value
:
value
}
;
}
;
}
{
}
]
58
:
[
function
(
require
module
exports
)
{
var
hide
=
require
(
'
.
/
_hide
'
)
;
module
.
exports
=
function
(
target
src
safe
)
{
for
(
var
key
in
src
)
{
if
(
safe
&
&
target
[
key
]
)
target
[
key
]
=
src
[
key
]
;
else
hide
(
target
key
src
[
key
]
)
;
}
return
target
;
}
;
}
{
"
.
/
_hide
"
:
32
}
]
59
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
'
.
/
_hide
'
)
;
}
{
"
.
/
_hide
"
:
32
}
]
60
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
global
=
require
(
'
.
/
_global
'
)
core
=
require
(
'
.
/
_core
'
)
dP
=
require
(
'
.
/
_object
-
dp
'
)
DESCRIPTORS
=
require
(
'
.
/
_descriptors
'
)
SPECIES
=
require
(
'
.
/
_wks
'
)
(
'
species
'
)
;
module
.
exports
=
function
(
KEY
)
{
var
C
=
typeof
core
[
KEY
]
=
=
'
function
'
?
core
[
KEY
]
:
global
[
KEY
]
;
if
(
DESCRIPTORS
&
&
C
&
&
!
C
[
SPECIES
]
)
dP
.
f
(
C
SPECIES
{
configurable
:
true
get
:
function
(
)
{
return
this
;
}
}
)
;
}
;
}
{
"
.
/
_core
"
:
21
"
.
/
_descriptors
"
:
24
"
.
/
_global
"
:
30
"
.
/
_object
-
dp
"
:
49
"
.
/
_wks
"
:
74
}
]
61
:
[
function
(
require
module
exports
)
{
var
def
=
require
(
'
.
/
_object
-
dp
'
)
.
f
has
=
require
(
'
.
/
_has
'
)
TAG
=
require
(
'
.
/
_wks
'
)
(
'
toStringTag
'
)
;
module
.
exports
=
function
(
it
tag
stat
)
{
if
(
it
&
&
!
has
(
it
=
stat
?
it
:
it
.
prototype
TAG
)
)
def
(
it
TAG
{
configurable
:
true
value
:
tag
}
)
;
}
;
}
{
"
.
/
_has
"
:
31
"
.
/
_object
-
dp
"
:
49
"
.
/
_wks
"
:
74
}
]
62
:
[
function
(
require
module
exports
)
{
var
shared
=
require
(
'
.
/
_shared
'
)
(
'
keys
'
)
uid
=
require
(
'
.
/
_uid
'
)
;
module
.
exports
=
function
(
key
)
{
return
shared
[
key
]
|
|
(
shared
[
key
]
=
uid
(
key
)
)
;
}
;
}
{
"
.
/
_shared
"
:
63
"
.
/
_uid
"
:
73
}
]
63
:
[
function
(
require
module
exports
)
{
var
global
=
require
(
'
.
/
_global
'
)
SHARED
=
'
__core
-
js_shared__
'
store
=
global
[
SHARED
]
|
|
(
global
[
SHARED
]
=
{
}
)
;
module
.
exports
=
function
(
key
)
{
return
store
[
key
]
|
|
(
store
[
key
]
=
{
}
)
;
}
;
}
{
"
.
/
_global
"
:
30
}
]
64
:
[
function
(
require
module
exports
)
{
var
anObject
=
require
(
'
.
/
_an
-
object
'
)
aFunction
=
require
(
'
.
/
_a
-
function
'
)
SPECIES
=
require
(
'
.
/
_wks
'
)
(
'
species
'
)
;
module
.
exports
=
function
(
O
D
)
{
var
C
=
anObject
(
O
)
.
constructor
S
;
return
C
=
=
=
undefined
|
|
(
S
=
anObject
(
C
)
[
SPECIES
]
)
=
=
undefined
?
D
:
aFunction
(
S
)
;
}
;
}
{
"
.
/
_a
-
function
"
:
14
"
.
/
_an
-
object
"
:
17
"
.
/
_wks
"
:
74
}
]
65
:
[
function
(
require
module
exports
)
{
var
toInteger
=
require
(
'
.
/
_to
-
integer
'
)
defined
=
require
(
'
.
/
_defined
'
)
;
module
.
exports
=
function
(
TO_STRING
)
{
return
function
(
that
pos
)
{
var
s
=
String
(
defined
(
that
)
)
i
=
toInteger
(
pos
)
l
=
s
.
length
a
b
;
if
(
i
<
0
|
|
i
>
=
l
)
return
TO_STRING
?
'
'
:
undefined
;
a
=
s
.
charCodeAt
(
i
)
;
return
a
<
0xd800
|
|
a
>
0xdbff
|
|
i
+
1
=
=
=
l
|
|
(
b
=
s
.
charCodeAt
(
i
+
1
)
)
<
0xdc00
|
|
b
>
0xdfff
?
TO_STRING
?
s
.
charAt
(
i
)
:
a
:
TO_STRING
?
s
.
slice
(
i
i
+
2
)
:
(
a
-
0xd800
<
<
10
)
+
(
b
-
0xdc00
)
+
0x10000
;
}
;
}
;
}
{
"
.
/
_defined
"
:
23
"
.
/
_to
-
integer
"
:
68
}
]
66
:
[
function
(
require
module
exports
)
{
var
ctx
=
require
(
'
.
/
_ctx
'
)
invoke
=
require
(
'
.
/
_invoke
'
)
html
=
require
(
'
.
/
_html
'
)
cel
=
require
(
'
.
/
_dom
-
create
'
)
global
=
require
(
'
.
/
_global
'
)
process
=
global
.
process
setTask
=
global
.
setImmediate
clearTask
=
global
.
clearImmediate
MessageChannel
=
global
.
MessageChannel
counter
=
0
queue
=
{
}
ONREADYSTATECHANGE
=
'
onreadystatechange
'
defer
channel
port
;
var
run
=
function
(
)
{
var
id
=
+
this
;
if
(
queue
.
hasOwnProperty
(
id
)
)
{
var
fn
=
queue
[
id
]
;
delete
queue
[
id
]
;
fn
(
)
;
}
}
;
var
listener
=
function
(
event
)
{
run
.
call
(
event
.
data
)
;
}
;
if
(
!
setTask
|
|
!
clearTask
)
{
setTask
=
function
setImmediate
(
fn
)
{
var
args
=
[
]
i
=
1
;
while
(
arguments
.
length
>
i
)
args
.
push
(
arguments
[
i
+
+
]
)
;
queue
[
+
+
counter
]
=
function
(
)
{
invoke
(
typeof
fn
=
=
'
function
'
?
fn
:
Function
(
fn
)
args
)
;
}
;
defer
(
counter
)
;
return
counter
;
}
;
clearTask
=
function
clearImmediate
(
id
)
{
delete
queue
[
id
]
;
}
;
if
(
require
(
'
.
/
_cof
'
)
(
process
)
=
=
'
process
'
)
{
defer
=
function
(
id
)
{
process
.
nextTick
(
ctx
(
run
id
1
)
)
;
}
;
}
else
if
(
MessageChannel
)
{
channel
=
new
MessageChannel
;
port
=
channel
.
port2
;
channel
.
port1
.
onmessage
=
listener
;
defer
=
ctx
(
port
.
postMessage
port
1
)
;
}
else
if
(
global
.
addEventListener
&
&
typeof
postMessage
=
=
'
function
'
&
&
!
global
.
importScripts
)
{
defer
=
function
(
id
)
{
global
.
postMessage
(
id
+
'
'
'
*
'
)
;
}
;
global
.
addEventListener
(
'
message
'
listener
false
)
;
}
else
if
(
ONREADYSTATECHANGE
in
cel
(
'
script
'
)
)
{
defer
=
function
(
id
)
{
html
.
appendChild
(
cel
(
'
script
'
)
)
[
ONREADYSTATECHANGE
]
=
function
(
)
{
html
.
removeChild
(
this
)
;
run
.
call
(
id
)
;
}
;
}
;
}
else
{
defer
=
function
(
id
)
{
setTimeout
(
ctx
(
run
id
1
)
0
)
;
}
;
}
}
module
.
exports
=
{
set
:
setTask
clear
:
clearTask
}
;
}
{
"
.
/
_cof
"
:
20
"
.
/
_ctx
"
:
22
"
.
/
_dom
-
create
"
:
25
"
.
/
_global
"
:
30
"
.
/
_html
"
:
33
"
.
/
_invoke
"
:
35
}
]
67
:
[
function
(
require
module
exports
)
{
var
toInteger
=
require
(
'
.
/
_to
-
integer
'
)
max
=
Math
.
max
min
=
Math
.
min
;
module
.
exports
=
function
(
index
length
)
{
index
=
toInteger
(
index
)
;
return
index
<
0
?
max
(
index
+
length
0
)
:
min
(
index
length
)
;
}
;
}
{
"
.
/
_to
-
integer
"
:
68
}
]
68
:
[
function
(
require
module
exports
)
{
var
ceil
=
Math
.
ceil
floor
=
Math
.
floor
;
module
.
exports
=
function
(
it
)
{
return
isNaN
(
it
=
+
it
)
?
0
:
(
it
>
0
?
floor
:
ceil
)
(
it
)
;
}
;
}
{
}
]
69
:
[
function
(
require
module
exports
)
{
var
IObject
=
require
(
'
.
/
_iobject
'
)
defined
=
require
(
'
.
/
_defined
'
)
;
module
.
exports
=
function
(
it
)
{
return
IObject
(
defined
(
it
)
)
;
}
;
}
{
"
.
/
_defined
"
:
23
"
.
/
_iobject
"
:
36
}
]
70
:
[
function
(
require
module
exports
)
{
var
toInteger
=
require
(
'
.
/
_to
-
integer
'
)
min
=
Math
.
min
;
module
.
exports
=
function
(
it
)
{
return
it
>
0
?
min
(
toInteger
(
it
)
0x1fffffffffffff
)
:
0
;
}
;
}
{
"
.
/
_to
-
integer
"
:
68
}
]
71
:
[
function
(
require
module
exports
)
{
var
defined
=
require
(
'
.
/
_defined
'
)
;
module
.
exports
=
function
(
it
)
{
return
Object
(
defined
(
it
)
)
;
}
;
}
{
"
.
/
_defined
"
:
23
}
]
72
:
[
function
(
require
module
exports
)
{
var
isObject
=
require
(
'
.
/
_is
-
object
'
)
;
module
.
exports
=
function
(
it
S
)
{
if
(
!
isObject
(
it
)
)
return
it
;
var
fn
val
;
if
(
S
&
&
typeof
(
fn
=
it
.
toString
)
=
=
'
function
'
&
&
!
isObject
(
val
=
fn
.
call
(
it
)
)
)
return
val
;
if
(
typeof
(
fn
=
it
.
valueOf
)
=
=
'
function
'
&
&
!
isObject
(
val
=
fn
.
call
(
it
)
)
)
return
val
;
if
(
!
S
&
&
typeof
(
fn
=
it
.
toString
)
=
=
'
function
'
&
&
!
isObject
(
val
=
fn
.
call
(
it
)
)
)
return
val
;
throw
TypeError
(
"
Can
'
t
convert
object
to
primitive
value
"
)
;
}
;
}
{
"
.
/
_is
-
object
"
:
38
}
]
73
:
[
function
(
require
module
exports
)
{
var
id
=
0
px
=
Math
.
random
(
)
;
module
.
exports
=
function
(
key
)
{
return
'
Symbol
(
'
.
concat
(
key
=
=
=
undefined
?
'
'
:
key
'
)
_
'
(
+
+
id
+
px
)
.
toString
(
36
)
)
;
}
;
}
{
}
]
74
:
[
function
(
require
module
exports
)
{
var
store
=
require
(
'
.
/
_shared
'
)
(
'
wks
'
)
uid
=
require
(
'
.
/
_uid
'
)
Symbol
=
require
(
'
.
/
_global
'
)
.
Symbol
USE_SYMBOL
=
typeof
Symbol
=
=
'
function
'
;
var
exports
=
module
.
exports
=
function
(
name
)
{
return
store
[
name
]
|
|
(
store
[
name
]
=
USE_SYMBOL
&
&
Symbol
[
name
]
|
|
(
USE_SYMBOL
?
Symbol
:
uid
)
(
'
Symbol
.
'
+
name
)
)
;
}
;
exports
.
store
=
store
;
}
{
"
.
/
_global
"
:
30
"
.
/
_shared
"
:
63
"
.
/
_uid
"
:
73
}
]
75
:
[
function
(
require
module
exports
)
{
var
classof
=
require
(
'
.
/
_classof
'
)
ITERATOR
=
require
(
'
.
/
_wks
'
)
(
'
iterator
'
)
Iterators
=
require
(
'
.
/
_iterators
'
)
;
module
.
exports
=
require
(
'
.
/
_core
'
)
.
getIteratorMethod
=
function
(
it
)
{
if
(
it
!
=
undefined
)
return
it
[
ITERATOR
]
|
|
it
[
'
iterator
'
]
|
|
Iterators
[
classof
(
it
)
]
;
}
;
}
{
"
.
/
_classof
"
:
19
"
.
/
_core
"
:
21
"
.
/
_iterators
"
:
44
"
.
/
_wks
"
:
74
}
]
76
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
addToUnscopables
=
require
(
'
.
/
_add
-
to
-
unscopables
'
)
step
=
require
(
'
.
/
_iter
-
step
'
)
Iterators
=
require
(
'
.
/
_iterators
'
)
toIObject
=
require
(
'
.
/
_to
-
iobject
'
)
;
module
.
exports
=
require
(
'
.
/
_iter
-
define
'
)
(
Array
'
Array
'
function
(
iterated
kind
)
{
this
.
_t
=
toIObject
(
iterated
)
;
this
.
_i
=
0
;
this
.
_k
=
kind
;
}
function
(
)
{
var
O
=
this
.
_t
kind
=
this
.
_k
index
=
this
.
_i
+
+
;
if
(
!
O
|
|
index
>
=
O
.
length
)
{
this
.
_t
=
undefined
;
return
step
(
1
)
;
}
if
(
kind
=
=
'
keys
'
)
return
step
(
0
index
)
;
if
(
kind
=
=
'
values
'
)
return
step
(
0
O
[
index
]
)
;
return
step
(
0
[
index
O
[
index
]
]
)
;
}
'
values
'
)
;
Iterators
.
Arguments
=
Iterators
.
Array
;
addToUnscopables
(
'
keys
'
)
;
addToUnscopables
(
'
values
'
)
;
addToUnscopables
(
'
entries
'
)
;
}
{
"
.
/
_add
-
to
-
unscopables
"
:
15
"
.
/
_iter
-
define
"
:
41
"
.
/
_iter
-
step
"
:
43
"
.
/
_iterators
"
:
44
"
.
/
_to
-
iobject
"
:
69
}
]
77
:
[
function
(
require
module
exports
)
{
var
export
=
require
(
'
.
/
_export
'
)
;
export
(
export
.
S
+
export
.
F
'
Object
'
{
assign
:
require
(
'
.
/
_object
-
assign
'
)
}
)
;
}
{
"
.
/
_export
"
:
27
"
.
/
_object
-
assign
"
:
47
}
]
78
:
[
function
(
require
module
exports
)
{
var
toObject
=
require
(
'
.
/
_to
-
object
'
)
keys
=
require
(
'
.
/
_object
-
keys
'
)
;
require
(
'
.
/
_object
-
sap
'
)
(
'
keys
'
function
(
)
{
return
function
keys
(
it
)
{
return
keys
(
toObject
(
it
)
)
;
}
;
}
)
;
}
{
"
.
/
_object
-
keys
"
:
54
"
.
/
_object
-
sap
"
:
56
"
.
/
_to
-
object
"
:
71
}
]
79
:
[
function
(
require
module
exports
)
{
arguments
[
4
]
[
9
]
[
0
]
.
apply
(
exports
arguments
)
}
{
"
dup
"
:
9
}
]
80
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
LIBRARY
=
require
(
'
.
/
_library
'
)
global
=
require
(
'
.
/
_global
'
)
ctx
=
require
(
'
.
/
_ctx
'
)
classof
=
require
(
'
.
/
_classof
'
)
export
=
require
(
'
.
/
_export
'
)
isObject
=
require
(
'
.
/
_is
-
object
'
)
aFunction
=
require
(
'
.
/
_a
-
function
'
)
anInstance
=
require
(
'
.
/
_an
-
instance
'
)
forOf
=
require
(
'
.
/
_for
-
of
'
)
speciesConstructor
=
require
(
'
.
/
_species
-
constructor
'
)
task
=
require
(
'
.
/
_task
'
)
.
set
microtask
=
require
(
'
.
/
_microtask
'
)
(
)
PROMISE
=
'
Promise
'
TypeError
=
global
.
TypeError
process
=
global
.
process
Promise
=
global
[
PROMISE
]
process
=
global
.
process
isNode
=
classof
(
process
)
=
=
'
process
'
empty
=
function
(
)
{
}
Internal
GenericPromiseCapability
Wrapper
;
var
USE_NATIVE
=
!
!
function
(
)
{
try
{
var
promise
=
Promise
.
resolve
(
1
)
FakePromise
=
(
promise
.
constructor
=
{
}
)
[
require
(
'
.
/
_wks
'
)
(
'
species
'
)
]
=
function
(
exec
)
{
exec
(
empty
empty
)
;
}
;
return
(
isNode
|
|
typeof
PromiseRejectionEvent
=
=
'
function
'
)
&
&
promise
.
then
(
empty
)
instanceof
FakePromise
;
}
catch
(
e
)
{
}
}
(
)
;
var
sameConstructor
=
function
(
a
b
)
{
return
a
=
=
=
b
|
|
a
=
=
=
Promise
&
&
b
=
=
=
Wrapper
;
}
;
var
isThenable
=
function
(
it
)
{
var
then
;
return
isObject
(
it
)
&
&
typeof
(
then
=
it
.
then
)
=
=
'
function
'
?
then
:
false
;
}
;
var
newPromiseCapability
=
function
(
C
)
{
return
sameConstructor
(
Promise
C
)
?
new
PromiseCapability
(
C
)
:
new
GenericPromiseCapability
(
C
)
;
}
;
var
PromiseCapability
=
GenericPromiseCapability
=
function
(
C
)
{
var
resolve
reject
;
this
.
promise
=
new
C
(
function
(
resolve
reject
)
{
if
(
resolve
!
=
=
undefined
|
|
reject
!
=
=
undefined
)
throw
TypeError
(
'
Bad
Promise
constructor
'
)
;
resolve
=
resolve
;
reject
=
reject
;
}
)
;
this
.
resolve
=
aFunction
(
resolve
)
;
this
.
reject
=
aFunction
(
reject
)
;
}
;
var
perform
=
function
(
exec
)
{
try
{
exec
(
)
;
}
catch
(
e
)
{
return
{
error
:
e
}
;
}
}
;
var
notify
=
function
(
promise
isReject
)
{
if
(
promise
.
_n
)
return
;
promise
.
_n
=
true
;
var
chain
=
promise
.
_c
;
microtask
(
function
(
)
{
var
value
=
promise
.
_v
ok
=
promise
.
_s
=
=
1
i
=
0
;
var
run
=
function
(
reaction
)
{
var
handler
=
ok
?
reaction
.
ok
:
reaction
.
fail
resolve
=
reaction
.
resolve
reject
=
reaction
.
reject
domain
=
reaction
.
domain
result
then
;
try
{
if
(
handler
)
{
if
(
!
ok
)
{
if
(
promise
.
_h
=
=
2
)
onHandleUnhandled
(
promise
)
;
promise
.
_h
=
1
;
}
if
(
handler
=
=
=
true
)
result
=
value
;
else
{
if
(
domain
)
domain
.
enter
(
)
;
result
=
handler
(
value
)
;
if
(
domain
)
domain
.
exit
(
)
;
}
if
(
result
=
=
=
reaction
.
promise
)
{
reject
(
TypeError
(
'
Promise
-
chain
cycle
'
)
)
;
}
else
if
(
then
=
isThenable
(
result
)
)
{
then
.
call
(
result
resolve
reject
)
;
}
else
resolve
(
result
)
;
}
else
reject
(
value
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
;
while
(
chain
.
length
>
i
)
run
(
chain
[
i
+
+
]
)
;
promise
.
_c
=
[
]
;
promise
.
_n
=
false
;
if
(
isReject
&
&
!
promise
.
_h
)
onUnhandled
(
promise
)
;
}
)
;
}
;
var
onUnhandled
=
function
(
promise
)
{
task
.
call
(
global
function
(
)
{
var
value
=
promise
.
_v
abrupt
handler
console
;
if
(
isUnhandled
(
promise
)
)
{
abrupt
=
perform
(
function
(
)
{
if
(
isNode
)
{
process
.
emit
(
'
unhandledRejection
'
value
promise
)
;
}
else
if
(
handler
=
global
.
onunhandledrejection
)
{
handler
(
{
promise
:
promise
reason
:
value
}
)
;
}
else
if
(
(
console
=
global
.
console
)
&
&
console
.
error
)
{
console
.
error
(
'
Unhandled
promise
rejection
'
value
)
;
}
}
)
;
promise
.
_h
=
isNode
|
|
isUnhandled
(
promise
)
?
2
:
1
;
}
promise
.
_a
=
undefined
;
if
(
abrupt
)
throw
abrupt
.
error
;
}
)
;
}
;
var
isUnhandled
=
function
(
promise
)
{
if
(
promise
.
_h
=
=
1
)
return
false
;
var
chain
=
promise
.
_a
|
|
promise
.
_c
i
=
0
reaction
;
while
(
chain
.
length
>
i
)
{
reaction
=
chain
[
i
+
+
]
;
if
(
reaction
.
fail
|
|
!
isUnhandled
(
reaction
.
promise
)
)
return
false
;
}
return
true
;
}
;
var
onHandleUnhandled
=
function
(
promise
)
{
task
.
call
(
global
function
(
)
{
var
handler
;
if
(
isNode
)
{
process
.
emit
(
'
rejectionHandled
'
promise
)
;
}
else
if
(
handler
=
global
.
onrejectionhandled
)
{
handler
(
{
promise
:
promise
reason
:
promise
.
_v
}
)
;
}
}
)
;
}
;
var
reject
=
function
(
value
)
{
var
promise
=
this
;
if
(
promise
.
_d
)
return
;
promise
.
_d
=
true
;
promise
=
promise
.
_w
|
|
promise
;
promise
.
_v
=
value
;
promise
.
_s
=
2
;
if
(
!
promise
.
_a
)
promise
.
_a
=
promise
.
_c
.
slice
(
)
;
notify
(
promise
true
)
;
}
;
var
resolve
=
function
(
value
)
{
var
promise
=
this
then
;
if
(
promise
.
_d
)
return
;
promise
.
_d
=
true
;
promise
=
promise
.
_w
|
|
promise
;
try
{
if
(
promise
=
=
=
value
)
throw
TypeError
(
"
Promise
can
'
t
be
resolved
itself
"
)
;
if
(
then
=
isThenable
(
value
)
)
{
microtask
(
function
(
)
{
var
wrapper
=
{
_w
:
promise
_d
:
false
}
;
try
{
then
.
call
(
value
ctx
(
resolve
wrapper
1
)
ctx
(
reject
wrapper
1
)
)
;
}
catch
(
e
)
{
reject
.
call
(
wrapper
e
)
;
}
}
)
;
}
else
{
promise
.
_v
=
value
;
promise
.
_s
=
1
;
notify
(
promise
false
)
;
}
}
catch
(
e
)
{
reject
.
call
(
{
_w
:
promise
_d
:
false
}
e
)
;
}
}
;
if
(
!
USE_NATIVE
)
{
Promise
=
function
Promise
(
executor
)
{
anInstance
(
this
Promise
PROMISE
'
_h
'
)
;
aFunction
(
executor
)
;
Internal
.
call
(
this
)
;
try
{
executor
(
ctx
(
resolve
this
1
)
ctx
(
reject
this
1
)
)
;
}
catch
(
err
)
{
reject
.
call
(
this
err
)
;
}
}
;
Internal
=
function
Promise
(
executor
)
{
this
.
_c
=
[
]
;
this
.
_a
=
undefined
;
this
.
_s
=
0
;
this
.
_d
=
false
;
this
.
_v
=
undefined
;
this
.
_h
=
0
;
this
.
_n
=
false
;
}
;
Internal
.
prototype
=
require
(
'
.
/
_redefine
-
all
'
)
(
Promise
.
prototype
{
then
:
function
then
(
onFulfilled
onRejected
)
{
var
reaction
=
newPromiseCapability
(
speciesConstructor
(
this
Promise
)
)
;
reaction
.
ok
=
typeof
onFulfilled
=
=
'
function
'
?
onFulfilled
:
true
;
reaction
.
fail
=
typeof
onRejected
=
=
'
function
'
&
&
onRejected
;
reaction
.
domain
=
isNode
?
process
.
domain
:
undefined
;
this
.
_c
.
push
(
reaction
)
;
if
(
this
.
_a
)
this
.
_a
.
push
(
reaction
)
;
if
(
this
.
_s
)
notify
(
this
false
)
;
return
reaction
.
promise
;
}
'
catch
'
:
function
(
onRejected
)
{
return
this
.
then
(
undefined
onRejected
)
;
}
}
)
;
PromiseCapability
=
function
(
)
{
var
promise
=
new
Internal
;
this
.
promise
=
promise
;
this
.
resolve
=
ctx
(
resolve
promise
1
)
;
this
.
reject
=
ctx
(
reject
promise
1
)
;
}
;
}
export
(
export
.
G
+
export
.
W
+
export
.
F
*
!
USE_NATIVE
{
Promise
:
Promise
}
)
;
require
(
'
.
/
_set
-
to
-
string
-
tag
'
)
(
Promise
PROMISE
)
;
require
(
'
.
/
_set
-
species
'
)
(
PROMISE
)
;
Wrapper
=
require
(
'
.
/
_core
'
)
[
PROMISE
]
;
export
(
export
.
S
+
export
.
F
*
!
USE_NATIVE
PROMISE
{
reject
:
function
reject
(
r
)
{
var
capability
=
newPromiseCapability
(
this
)
reject
=
capability
.
reject
;
reject
(
r
)
;
return
capability
.
promise
;
}
}
)
;
export
(
export
.
S
+
export
.
F
*
(
LIBRARY
|
|
!
USE_NATIVE
)
PROMISE
{
resolve
:
function
resolve
(
x
)
{
if
(
x
instanceof
Promise
&
&
sameConstructor
(
x
.
constructor
this
)
)
return
x
;
var
capability
=
newPromiseCapability
(
this
)
resolve
=
capability
.
resolve
;
resolve
(
x
)
;
return
capability
.
promise
;
}
}
)
;
export
(
export
.
S
+
export
.
F
*
!
(
USE_NATIVE
&
&
require
(
'
.
/
_iter
-
detect
'
)
(
function
(
iter
)
{
Promise
.
all
(
iter
)
[
'
catch
'
]
(
empty
)
;
}
)
)
PROMISE
{
all
:
function
all
(
iterable
)
{
var
C
=
this
capability
=
newPromiseCapability
(
C
)
resolve
=
capability
.
resolve
reject
=
capability
.
reject
;
var
abrupt
=
perform
(
function
(
)
{
var
values
=
[
]
index
=
0
remaining
=
1
;
forOf
(
iterable
false
function
(
promise
)
{
var
index
=
index
+
+
alreadyCalled
=
false
;
values
.
push
(
undefined
)
;
remaining
+
+
;
C
.
resolve
(
promise
)
.
then
(
function
(
value
)
{
if
(
alreadyCalled
)
return
;
alreadyCalled
=
true
;
values
[
index
]
=
value
;
-
-
remaining
|
|
resolve
(
values
)
;
}
reject
)
;
}
)
;
-
-
remaining
|
|
resolve
(
values
)
;
}
)
;
if
(
abrupt
)
reject
(
abrupt
.
error
)
;
return
capability
.
promise
;
}
race
:
function
race
(
iterable
)
{
var
C
=
this
capability
=
newPromiseCapability
(
C
)
reject
=
capability
.
reject
;
var
abrupt
=
perform
(
function
(
)
{
forOf
(
iterable
false
function
(
promise
)
{
C
.
resolve
(
promise
)
.
then
(
capability
.
resolve
reject
)
;
}
)
;
}
)
;
if
(
abrupt
)
reject
(
abrupt
.
error
)
;
return
capability
.
promise
;
}
}
)
;
}
{
"
.
/
_a
-
function
"
:
14
"
.
/
_an
-
instance
"
:
16
"
.
/
_classof
"
:
19
"
.
/
_core
"
:
21
"
.
/
_ctx
"
:
22
"
.
/
_export
"
:
27
"
.
/
_for
-
of
"
:
29
"
.
/
_global
"
:
30
"
.
/
_is
-
object
"
:
38
"
.
/
_iter
-
detect
"
:
42
"
.
/
_library
"
:
45
"
.
/
_microtask
"
:
46
"
.
/
_redefine
-
all
"
:
58
"
.
/
_set
-
species
"
:
60
"
.
/
_set
-
to
-
string
-
tag
"
:
61
"
.
/
_species
-
constructor
"
:
64
"
.
/
_task
"
:
66
"
.
/
_wks
"
:
74
}
]
81
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
at
=
require
(
'
.
/
_string
-
at
'
)
(
true
)
;
require
(
'
.
/
_iter
-
define
'
)
(
String
'
String
'
function
(
iterated
)
{
this
.
_t
=
String
(
iterated
)
;
this
.
_i
=
0
;
}
function
(
)
{
var
O
=
this
.
_t
index
=
this
.
_i
point
;
if
(
index
>
=
O
.
length
)
return
{
value
:
undefined
done
:
true
}
;
point
=
at
(
O
index
)
;
this
.
_i
+
=
point
.
length
;
return
{
value
:
point
done
:
false
}
;
}
)
;
}
{
"
.
/
_iter
-
define
"
:
41
"
.
/
_string
-
at
"
:
65
}
]
82
:
[
function
(
require
module
exports
)
{
require
(
'
.
/
es6
.
array
.
iterator
'
)
;
var
global
=
require
(
'
.
/
_global
'
)
hide
=
require
(
'
.
/
_hide
'
)
Iterators
=
require
(
'
.
/
_iterators
'
)
TO_STRING_TAG
=
require
(
'
.
/
_wks
'
)
(
'
toStringTag
'
)
;
for
(
var
collections
=
[
'
NodeList
'
'
DOMTokenList
'
'
MediaList
'
'
StyleSheetList
'
'
CSSRuleList
'
]
i
=
0
;
i
<
5
;
i
+
+
)
{
var
NAME
=
collections
[
i
]
Collection
=
global
[
NAME
]
proto
=
Collection
&
&
Collection
.
prototype
;
if
(
proto
&
&
!
proto
[
TO_STRING_TAG
]
)
hide
(
proto
TO_STRING_TAG
NAME
)
;
Iterators
[
NAME
]
=
Iterators
.
Array
;
}
}
{
"
.
/
_global
"
:
30
"
.
/
_hide
"
:
32
"
.
/
_iterators
"
:
44
"
.
/
_wks
"
:
74
"
.
/
es6
.
array
.
iterator
"
:
76
}
]
83
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends2
=
require
(
"
babel
-
runtime
/
helpers
/
extends
"
)
;
var
_extends3
=
_interopRequireDefault
(
_extends2
)
;
var
_collection
=
require
(
"
.
/
collection
"
)
;
var
_collection2
=
_interopRequireDefault
(
_collection
)
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
DEFAULT_BUCKET_NAME
=
"
default
"
;
const
DEFAULT_REMOTE
=
"
http
:
/
/
localhost
:
8888
/
v1
"
;
class
KintoBase
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
}
;
}
static
get
syncStrategy
(
)
{
return
_collection2
.
default
.
strategy
;
}
constructor
(
options
=
{
}
)
{
const
defaults
=
{
bucket
:
DEFAULT_BUCKET_NAME
remote
:
DEFAULT_REMOTE
}
;
this
.
_options
=
(
0
_extends3
.
default
)
(
{
}
defaults
options
)
;
if
(
!
this
.
_options
.
adapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
{
remote
events
headers
requestMode
timeout
ApiClass
}
=
this
.
_options
;
this
.
api
=
new
ApiClass
(
remote
{
events
headers
requestMode
timeout
}
)
;
this
.
events
=
this
.
_options
.
events
;
}
collection
(
collName
options
=
{
}
)
{
if
(
!
collName
)
{
throw
new
Error
(
"
missing
collection
name
"
)
;
}
const
bucket
=
this
.
_options
.
bucket
;
return
new
_collection2
.
default
(
bucket
collName
this
.
api
{
events
:
this
.
_options
.
events
adapter
:
this
.
_options
.
adapter
adapterOptions
:
this
.
_options
.
adapterOptions
dbPrefix
:
this
.
_options
.
dbPrefix
idSchema
:
options
.
idSchema
remoteTransformers
:
options
.
remoteTransformers
hooks
:
options
.
hooks
}
)
;
}
}
exports
.
default
=
KintoBase
;
}
{
"
.
/
adapters
/
base
"
:
85
"
.
/
collection
"
:
86
"
babel
-
runtime
/
helpers
/
extends
"
:
8
}
]
84
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_asyncToGenerator2
=
require
(
"
babel
-
runtime
/
helpers
/
asyncToGenerator
"
)
;
var
_asyncToGenerator3
=
_interopRequireDefault
(
_asyncToGenerator2
)
;
var
_promise
=
require
(
"
babel
-
runtime
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
var
_keys
=
require
(
"
babel
-
runtime
/
core
-
js
/
object
/
keys
"
)
;
var
_keys2
=
_interopRequireDefault
(
_keys
)
;
var
_base
=
require
(
"
.
/
base
.
js
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_utils
=
require
(
"
.
.
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
INDEXED_FIELDS
=
[
"
id
"
"
_status
"
"
last_modified
"
]
;
const
cursorHandlers
=
{
all
(
filters
done
)
{
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
if
(
(
0
_utils
.
filterObject
)
(
filters
cursor
.
value
)
)
{
results
.
push
(
cursor
.
value
)
;
}
cursor
.
continue
(
)
;
}
else
{
done
(
results
)
;
}
}
;
}
in
(
values
done
)
{
if
(
values
.
length
=
=
=
0
)
{
return
done
(
[
]
)
;
}
const
sortedValues
=
[
]
.
slice
.
call
(
values
)
.
sort
(
)
;
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
!
cursor
)
{
done
(
results
)
;
return
;
}
const
{
key
value
}
=
cursor
;
let
i
=
0
;
while
(
key
>
sortedValues
[
i
]
)
{
+
+
i
;
if
(
i
=
=
=
sortedValues
.
length
)
{
done
(
results
)
;
return
;
}
}
if
(
key
=
=
=
sortedValues
[
i
]
)
{
results
.
push
(
value
)
;
cursor
.
continue
(
)
;
}
else
{
cursor
.
continue
(
sortedValues
[
i
]
)
;
}
}
;
}
}
;
function
findIndexedField
(
filters
)
{
const
filteredFields
=
(
0
_keys2
.
default
)
(
filters
)
;
const
indexedFields
=
filteredFields
.
filter
(
field
=
>
{
return
INDEXED_FIELDS
.
indexOf
(
field
)
!
=
=
-
1
;
}
)
;
return
indexedFields
[
0
]
;
}
function
createListRequest
(
store
indexField
value
filters
done
)
{
if
(
!
indexField
)
{
const
request
=
store
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
filters
done
)
;
return
request
;
}
if
(
Array
.
isArray
(
value
)
)
{
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
in
(
value
done
)
;
return
request
;
}
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
IDBKeyRange
.
only
(
value
)
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
filters
done
)
;
return
request
;
}
class
IDB
extends
_base2
.
default
{
constructor
(
dbname
)
{
super
(
)
;
this
.
_db
=
null
;
this
.
dbname
=
dbname
;
}
_handleError
(
method
err
)
{
const
error
=
new
Error
(
method
+
"
(
)
"
+
err
.
message
)
;
error
.
stack
=
err
.
stack
;
throw
error
;
}
open
(
)
{
if
(
this
.
_db
)
{
return
_promise2
.
default
.
resolve
(
this
)
;
}
return
new
_promise2
.
default
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
this
.
dbname
1
)
;
request
.
onupgradeneeded
=
event
=
>
{
const
db
=
event
.
target
.
result
;
const
collStore
=
db
.
createObjectStore
(
this
.
dbname
{
keyPath
:
"
id
"
}
)
;
collStore
.
createIndex
(
"
id
"
"
id
"
{
unique
:
true
}
)
;
collStore
.
createIndex
(
"
_status
"
"
_status
"
)
;
collStore
.
createIndex
(
"
last_modified
"
"
last_modified
"
)
;
const
metaStore
=
db
.
createObjectStore
(
"
__meta__
"
{
keyPath
:
"
name
"
}
)
;
metaStore
.
createIndex
(
"
name
"
"
name
"
{
unique
:
true
}
)
;
}
;
request
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
request
.
onsuccess
=
event
=
>
{
this
.
_db
=
event
.
target
.
result
;
resolve
(
this
)
;
}
;
}
)
;
}
close
(
)
{
if
(
this
.
_db
)
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
}
return
super
.
close
(
)
;
}
prepare
(
mode
=
undefined
name
=
null
)
{
const
storeName
=
name
|
|
this
.
dbname
;
const
transaction
=
mode
?
this
.
_db
.
transaction
(
[
storeName
]
mode
)
:
this
.
_db
.
transaction
(
[
storeName
]
)
;
const
store
=
transaction
.
objectStore
(
storeName
)
;
return
{
transaction
store
}
;
}
clear
(
)
{
var
_this
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
try
{
yield
_this
.
open
(
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
const
{
transaction
store
}
=
_this
.
prepare
(
"
readwrite
"
)
;
store
.
clear
(
)
;
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
new
Error
(
event
.
target
.
error
)
)
;
}
;
transaction
.
oncomplete
=
function
(
)
{
return
resolve
(
)
;
}
;
}
)
;
}
catch
(
e
)
{
_this
.
_handleError
(
"
clear
"
e
)
;
}
}
)
(
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
var
_this2
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
yield
_this2
.
open
(
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
const
{
transaction
store
}
=
_this2
.
prepare
(
"
readwrite
"
)
;
const
ids
=
options
.
preload
;
store
.
index
(
"
id
"
)
.
openCursor
(
)
.
onsuccess
=
cursorHandlers
.
in
(
ids
function
(
records
)
{
const
preloaded
=
records
.
reduce
(
function
(
acc
record
)
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
const
proxy
=
transactionProxy
(
store
preloaded
)
;
let
result
;
try
{
result
=
callback
(
proxy
)
;
}
catch
(
e
)
{
transaction
.
abort
(
)
;
reject
(
e
)
;
}
if
(
result
instanceof
_promise2
.
default
)
{
reject
(
new
Error
(
"
execute
(
)
callback
should
not
return
a
Promise
.
"
)
)
;
}
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
new
Error
(
event
.
target
.
error
)
)
;
}
;
transaction
.
oncomplete
=
function
(
event
)
{
return
resolve
(
result
)
;
}
;
}
)
;
}
)
;
}
)
(
)
;
}
get
(
id
)
{
var
_this3
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
try
{
yield
_this3
.
open
(
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
const
{
transaction
store
}
=
_this3
.
prepare
(
)
;
const
request
=
store
.
get
(
id
)
;
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
new
Error
(
event
.
target
.
error
)
)
;
}
;
transaction
.
oncomplete
=
function
(
)
{
return
resolve
(
request
.
result
)
;
}
;
}
)
;
}
catch
(
e
)
{
_this3
.
_handleError
(
"
get
"
e
)
;
}
}
)
(
)
;
}
list
(
params
=
{
filters
:
{
}
}
)
{
var
_this4
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
{
filters
}
=
params
;
const
indexField
=
findIndexedField
(
filters
)
;
const
value
=
filters
[
indexField
]
;
try
{
yield
_this4
.
open
(
)
;
const
results
=
yield
new
_promise2
.
default
(
function
(
resolve
reject
)
{
let
results
=
[
]
;
const
remainingFilters
=
(
0
_utils
.
omitKeys
)
(
filters
indexField
)
;
const
{
transaction
store
}
=
_this4
.
prepare
(
)
;
createListRequest
(
store
indexField
value
remainingFilters
function
(
_results
)
{
results
=
_results
;
}
)
;
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
new
Error
(
event
.
target
.
error
)
)
;
}
;
transaction
.
oncomplete
=
function
(
event
)
{
return
resolve
(
results
)
;
}
;
}
)
;
return
params
.
order
?
(
0
_utils
.
sortObjects
)
(
params
.
order
results
)
:
results
;
}
catch
(
e
)
{
_this4
.
_handleError
(
"
list
"
e
)
;
}
}
)
(
)
;
}
saveLastModified
(
lastModified
)
{
var
_this5
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
value
=
parseInt
(
lastModified
10
)
|
|
null
;
yield
_this5
.
open
(
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
const
{
transaction
store
}
=
_this5
.
prepare
(
"
readwrite
"
"
__meta__
"
)
;
store
.
put
(
{
name
:
"
lastModified
"
value
:
value
}
)
;
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
event
.
target
.
error
)
;
}
;
transaction
.
oncomplete
=
function
(
event
)
{
return
resolve
(
value
)
;
}
;
}
)
;
}
)
(
)
;
}
getLastModified
(
)
{
var
_this6
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
yield
_this6
.
open
(
)
;
return
new
_promise2
.
default
(
function
(
resolve
reject
)
{
const
{
transaction
store
}
=
_this6
.
prepare
(
undefined
"
__meta__
"
)
;
const
request
=
store
.
get
(
"
lastModified
"
)
;
transaction
.
onerror
=
function
(
event
)
{
return
reject
(
event
.
target
.
error
)
;
}
;
transaction
.
oncomplete
=
function
(
event
)
{
resolve
(
request
.
result
&
&
request
.
result
.
value
|
|
null
)
;
}
;
}
)
;
}
)
(
)
;
}
loadDump
(
records
)
{
var
_this7
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
try
{
yield
_this7
.
execute
(
function
(
transaction
)
{
records
.
forEach
(
function
(
record
)
{
return
transaction
.
update
(
record
)
;
}
)
;
}
)
;
const
previousLastModified
=
yield
_this7
.
getLastModified
(
)
;
const
lastModified
=
Math
.
max
(
.
.
.
records
.
map
(
function
(
record
)
{
return
record
.
last_modified
;
}
)
)
;
if
(
lastModified
>
previousLastModified
)
{
yield
_this7
.
saveLastModified
(
lastModified
)
;
}
return
records
;
}
catch
(
e
)
{
_this7
.
_handleError
(
"
loadDump
"
e
)
;
}
}
)
(
)
;
}
}
exports
.
default
=
IDB
;
function
transactionProxy
(
store
preloaded
=
[
]
)
{
return
{
create
(
record
)
{
store
.
add
(
record
)
;
}
update
(
record
)
{
store
.
put
(
record
)
;
}
delete
(
id
)
{
store
.
delete
(
id
)
;
}
get
(
id
)
{
return
preloaded
[
id
]
;
}
}
;
}
}
{
"
.
.
/
utils
"
:
87
"
.
/
base
.
js
"
:
85
"
babel
-
runtime
/
core
-
js
/
object
/
keys
"
:
5
"
babel
-
runtime
/
core
-
js
/
promise
"
:
6
"
babel
-
runtime
/
helpers
/
asyncToGenerator
"
:
7
}
]
85
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_promise
=
require
(
"
babel
-
runtime
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
class
BaseAdapter
{
open
(
)
{
return
_promise2
.
default
.
resolve
(
)
;
}
close
(
)
{
return
_promise2
.
default
.
resolve
(
)
;
}
clear
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
get
(
id
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
list
(
params
=
{
filters
:
{
}
order
:
"
"
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
saveLastModified
(
lastModified
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
getLastModified
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
loadDump
(
records
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
}
exports
.
default
=
BaseAdapter
;
}
{
"
babel
-
runtime
/
core
-
js
/
promise
"
:
6
}
]
86
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
CollectionTransaction
=
exports
.
SyncResultObject
=
undefined
;
var
_stringify
=
require
(
"
babel
-
runtime
/
core
-
js
/
json
/
stringify
"
)
;
var
_stringify2
=
_interopRequireDefault
(
_stringify
)
;
var
_promise
=
require
(
"
babel
-
runtime
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
var
_asyncToGenerator2
=
require
(
"
babel
-
runtime
/
helpers
/
asyncToGenerator
"
)
;
var
_asyncToGenerator3
=
_interopRequireDefault
(
_asyncToGenerator2
)
;
var
_extends2
=
require
(
"
babel
-
runtime
/
helpers
/
extends
"
)
;
var
_extends3
=
_interopRequireDefault
(
_extends2
)
;
var
_assign
=
require
(
"
babel
-
runtime
/
core
-
js
/
object
/
assign
"
)
;
var
_assign2
=
_interopRequireDefault
(
_assign
)
;
exports
.
recordsEqual
=
recordsEqual
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_IDB
=
require
(
"
.
/
adapters
/
IDB
"
)
;
var
_IDB2
=
_interopRequireDefault
(
_IDB
)
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_uuid
=
require
(
"
uuid
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
RECORD_FIELDS_TO_CLEAN
=
[
"
_status
"
]
;
const
AVAILABLE_HOOKS
=
[
"
incoming
-
changes
"
]
;
function
recordsEqual
(
a
b
localFields
=
[
]
)
{
const
fieldsToClean
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
[
"
last_modified
"
]
)
.
concat
(
localFields
)
;
const
cleanLocal
=
r
=
>
(
0
_utils
.
omitKeys
)
(
r
fieldsToClean
)
;
return
(
0
_utils
.
deepEqual
)
(
cleanLocal
(
a
)
cleanLocal
(
b
)
)
;
}
class
SyncResultObject
{
static
get
defaults
(
)
{
return
{
ok
:
true
lastModified
:
null
errors
:
[
]
created
:
[
]
updated
:
[
]
deleted
:
[
]
published
:
[
]
conflicts
:
[
]
skipped
:
[
]
resolved
:
[
]
}
;
}
constructor
(
)
{
this
.
ok
=
true
;
(
0
_assign2
.
default
)
(
this
SyncResultObject
.
defaults
)
;
}
add
(
type
entries
)
{
if
(
!
Array
.
isArray
(
this
[
type
]
)
)
{
return
;
}
const
deduplicated
=
this
[
type
]
.
concat
(
entries
)
.
reduce
(
(
acc
cur
)
=
>
{
const
existing
=
acc
.
filter
(
r
=
>
cur
.
id
&
&
r
.
id
?
cur
.
id
!
=
r
.
id
:
true
)
;
return
existing
.
concat
(
cur
)
;
}
[
]
)
;
this
[
type
]
=
deduplicated
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
reset
(
type
)
{
this
[
type
]
=
SyncResultObject
.
defaults
[
type
]
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
}
exports
.
SyncResultObject
=
SyncResultObject
;
function
createUUIDSchema
(
)
{
return
{
generate
(
)
{
return
(
0
_uuid
.
v4
)
(
)
;
}
validate
(
id
)
{
return
(
0
_utils
.
isUUID
)
(
id
)
;
}
}
;
}
function
markStatus
(
record
status
)
{
return
(
0
_extends3
.
default
)
(
{
}
record
{
_status
:
status
}
)
;
}
function
markDeleted
(
record
)
{
return
markStatus
(
record
"
deleted
"
)
;
}
function
markSynced
(
record
)
{
return
markStatus
(
record
"
synced
"
)
;
}
function
importChange
(
transaction
remote
localFields
)
{
const
local
=
transaction
.
get
(
remote
.
id
)
;
if
(
!
local
)
{
if
(
remote
.
deleted
)
{
return
{
type
:
"
skipped
"
data
:
remote
}
;
}
const
synced
=
markSynced
(
remote
)
;
transaction
.
create
(
synced
)
;
return
{
type
:
"
created
"
data
:
synced
}
;
}
const
isIdentical
=
recordsEqual
(
local
remote
localFields
)
;
const
synced
=
(
0
_extends3
.
default
)
(
{
}
local
markSynced
(
remote
)
)
;
if
(
local
.
_status
!
=
=
"
synced
"
)
{
if
(
local
.
_status
=
=
=
"
deleted
"
)
{
return
{
type
:
"
skipped
"
data
:
local
}
;
}
if
(
isIdentical
)
{
transaction
.
update
(
synced
)
;
return
{
type
:
"
updated
"
data
:
{
old
:
local
new
:
synced
}
}
;
}
if
(
local
.
last_modified
!
=
=
undefined
&
&
local
.
last_modified
=
=
=
remote
.
last_modified
)
{
return
{
type
:
"
void
"
}
;
}
return
{
type
:
"
conflicts
"
data
:
{
type
:
"
incoming
"
local
:
local
remote
:
remote
}
}
;
}
if
(
remote
.
deleted
)
{
transaction
.
delete
(
remote
.
id
)
;
return
{
type
:
"
deleted
"
data
:
local
}
;
}
transaction
.
update
(
synced
)
;
const
type
=
isIdentical
?
"
void
"
:
"
updated
"
;
return
{
type
data
:
{
old
:
local
new
:
synced
}
}
;
}
class
Collection
{
constructor
(
bucket
name
api
options
=
{
}
)
{
this
.
_bucket
=
bucket
;
this
.
_name
=
name
;
this
.
_lastModified
=
null
;
const
DBAdapter
=
options
.
adapter
|
|
_IDB2
.
default
;
if
(
!
DBAdapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
dbPrefix
=
options
.
dbPrefix
|
|
"
"
;
const
db
=
new
DBAdapter
(
{
dbPrefix
}
{
bucket
}
/
{
name
}
options
.
adapterOptions
)
;
if
(
!
(
db
instanceof
_base2
.
default
)
)
{
throw
new
Error
(
"
Unsupported
adapter
.
"
)
;
}
this
.
db
=
db
;
this
.
api
=
api
;
this
.
events
=
options
.
events
;
this
.
idSchema
=
this
.
_validateIdSchema
(
options
.
idSchema
)
;
this
.
remoteTransformers
=
this
.
_validateRemoteTransformers
(
options
.
remoteTransformers
)
;
this
.
hooks
=
this
.
_validateHooks
(
options
.
hooks
)
;
this
.
localFields
=
options
.
localFields
|
|
[
]
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
bucket
(
)
{
return
this
.
_bucket
;
}
get
lastModified
(
)
{
return
this
.
_lastModified
;
}
static
get
strategy
(
)
{
return
{
CLIENT_WINS
:
"
client_wins
"
SERVER_WINS
:
"
server_wins
"
MANUAL
:
"
manual
"
}
;
}
_validateIdSchema
(
idSchema
)
{
if
(
typeof
idSchema
=
=
=
"
undefined
"
)
{
return
createUUIDSchema
(
)
;
}
if
(
typeof
idSchema
!
=
=
"
object
"
)
{
throw
new
Error
(
"
idSchema
must
be
an
object
.
"
)
;
}
else
if
(
typeof
idSchema
.
generate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
generate
function
.
"
)
;
}
else
if
(
typeof
idSchema
.
validate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
validate
function
.
"
)
;
}
return
idSchema
;
}
_validateRemoteTransformers
(
remoteTransformers
)
{
if
(
typeof
remoteTransformers
=
=
=
"
undefined
"
)
{
return
[
]
;
}
if
(
!
Array
.
isArray
(
remoteTransformers
)
)
{
throw
new
Error
(
"
remoteTransformers
should
be
an
array
.
"
)
;
}
return
remoteTransformers
.
map
(
transformer
=
>
{
if
(
typeof
transformer
!
=
=
"
object
"
)
{
throw
new
Error
(
"
A
transformer
must
be
an
object
.
"
)
;
}
else
if
(
typeof
transformer
.
encode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
an
encode
function
.
"
)
;
}
else
if
(
typeof
transformer
.
decode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
a
decode
function
.
"
)
;
}
return
transformer
;
}
)
;
}
_validateHook
(
hook
)
{
if
(
!
Array
.
isArray
(
hook
)
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
hook
.
map
(
fn
=
>
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
fn
;
}
)
;
}
_validateHooks
(
hooks
)
{
if
(
typeof
hooks
=
=
=
"
undefined
"
)
{
return
{
}
;
}
if
(
Array
.
isArray
(
hooks
)
)
{
throw
new
Error
(
"
hooks
should
be
an
object
not
an
array
.
"
)
;
}
if
(
typeof
hooks
!
=
=
"
object
"
)
{
throw
new
Error
(
"
hooks
should
be
an
object
.
"
)
;
}
const
validatedHooks
=
{
}
;
for
(
let
hook
in
hooks
)
{
if
(
AVAILABLE_HOOKS
.
indexOf
(
hook
)
=
=
=
-
1
)
{
throw
new
Error
(
"
The
hook
should
be
one
of
"
+
AVAILABLE_HOOKS
.
join
(
"
"
)
)
;
}
validatedHooks
[
hook
]
=
this
.
_validateHook
(
hooks
[
hook
]
)
;
}
return
validatedHooks
;
}
clear
(
)
{
var
_this
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
yield
_this
.
db
.
clear
(
)
;
yield
_this
.
db
.
saveLastModified
(
null
)
;
return
{
data
:
[
]
permissions
:
{
}
}
;
}
)
(
)
;
}
_encodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
_promise2
.
default
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
encode
(
record
)
;
}
)
record
)
;
}
_decodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
_promise2
.
default
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
reverse
(
)
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
decode
(
record
)
;
}
)
record
)
;
}
create
(
record
options
=
{
useRecordId
:
false
synced
:
false
}
)
{
const
reject
=
msg
=
>
_promise2
.
default
.
reject
(
new
Error
(
msg
)
)
;
if
(
typeof
record
!
=
=
"
object
"
)
{
return
reject
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
(
options
.
synced
|
|
options
.
useRecordId
)
&
&
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Missing
required
Id
;
synced
and
useRecordId
options
require
one
"
)
;
}
if
(
!
options
.
synced
&
&
!
options
.
useRecordId
&
&
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Extraneous
Id
;
can
'
t
create
a
record
having
one
set
.
"
)
;
}
const
newRecord
=
(
0
_extends3
.
default
)
(
{
}
record
{
id
:
options
.
synced
|
|
options
.
useRecordId
?
record
.
id
:
this
.
idSchema
.
generate
(
)
_status
:
options
.
synced
?
"
synced
"
:
"
created
"
}
)
;
if
(
!
this
.
idSchema
.
validate
(
newRecord
.
id
)
)
{
return
reject
(
Invalid
Id
:
{
newRecord
.
id
}
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
create
(
newRecord
)
{
preloadIds
:
[
newRecord
.
id
]
}
)
.
catch
(
err
=
>
{
if
(
options
.
useRecordId
)
{
throw
new
Error
(
"
Couldn
'
t
create
record
.
It
may
have
been
virtually
deleted
.
"
)
;
}
throw
err
;
}
)
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
update
(
record
options
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
_promise2
.
default
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
upsert
(
record
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
return
this
.
execute
(
txn
=
>
txn
.
get
(
id
options
)
{
preloadIds
:
[
id
]
}
)
;
}
getAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
getAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
return
this
.
execute
(
transaction
=
>
{
return
transaction
.
delete
(
id
options
)
;
}
{
preloadIds
:
[
id
]
}
)
;
}
deleteAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
deleteAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
list
(
params
=
{
}
options
=
{
includeDeleted
:
false
}
)
{
var
_this2
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
params
=
(
0
_extends3
.
default
)
(
{
order
:
"
-
last_modified
"
filters
:
{
}
}
params
)
;
const
results
=
yield
_this2
.
db
.
list
(
params
)
;
let
data
=
results
;
if
(
!
options
.
includeDeleted
)
{
data
=
results
.
filter
(
function
(
record
)
{
return
record
.
_status
!
=
=
"
deleted
"
;
}
)
;
}
return
{
data
permissions
:
{
}
}
;
}
)
(
)
;
}
importChanges
(
syncResultObject
decodedChanges
strategy
=
Collection
.
strategy
.
MANUAL
)
{
var
_this3
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
try
{
const
{
imports
resolved
}
=
yield
_this3
.
db
.
execute
(
function
(
transaction
)
{
const
imports
=
decodedChanges
.
map
(
function
(
remote
)
{
return
importChange
(
transaction
remote
_this3
.
localFields
)
;
}
)
;
const
conflicts
=
imports
.
filter
(
function
(
i
)
{
return
i
.
type
=
=
=
"
conflicts
"
;
}
)
.
map
(
function
(
i
)
{
return
i
.
data
;
}
)
;
const
resolved
=
_this3
.
_handleConflicts
(
transaction
conflicts
strategy
)
;
return
{
imports
resolved
}
;
}
{
preload
:
decodedChanges
.
map
(
function
(
record
)
{
return
record
.
id
;
}
)
}
)
;
imports
.
forEach
(
function
(
{
type
data
}
)
{
return
syncResultObject
.
add
(
type
data
)
;
}
)
;
if
(
resolved
.
length
>
0
)
{
syncResultObject
.
reset
(
"
conflicts
"
)
.
add
(
"
resolved
"
resolved
)
;
}
}
catch
(
err
)
{
const
data
=
{
type
:
"
incoming
"
message
:
err
.
message
stack
:
err
.
stack
}
;
syncResultObject
.
add
(
"
errors
"
data
)
;
}
return
syncResultObject
;
}
)
(
)
;
}
_applyPushedResults
(
syncResultObject
toApplyLocally
conflicts
strategy
=
Collection
.
strategy
.
MANUAL
)
{
var
_this4
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
toDeleteLocally
=
toApplyLocally
.
filter
(
function
(
r
)
{
return
r
.
deleted
;
}
)
;
const
toUpdateLocally
=
toApplyLocally
.
filter
(
function
(
r
)
{
return
!
r
.
deleted
;
}
)
;
const
{
published
resolved
}
=
yield
_this4
.
db
.
execute
(
function
(
transaction
)
{
const
updated
=
toUpdateLocally
.
map
(
function
(
record
)
{
const
synced
=
markSynced
(
record
)
;
transaction
.
update
(
synced
)
;
return
synced
;
}
)
;
const
deleted
=
toDeleteLocally
.
map
(
function
(
record
)
{
transaction
.
delete
(
record
.
id
)
;
return
{
id
:
record
.
id
deleted
:
true
}
;
}
)
;
const
published
=
updated
.
concat
(
deleted
)
;
const
resolved
=
_this4
.
_handleConflicts
(
transaction
conflicts
strategy
)
;
return
{
published
resolved
}
;
}
)
;
syncResultObject
.
add
(
"
published
"
published
)
;
if
(
resolved
.
length
>
0
)
{
syncResultObject
.
reset
(
"
conflicts
"
)
.
reset
(
"
resolved
"
)
.
add
(
"
resolved
"
resolved
)
;
}
return
syncResultObject
;
}
)
(
)
;
}
_handleConflicts
(
transaction
conflicts
strategy
)
{
if
(
strategy
=
=
=
Collection
.
strategy
.
MANUAL
)
{
return
[
]
;
}
return
conflicts
.
map
(
conflict
=
>
{
const
resolution
=
strategy
=
=
=
Collection
.
strategy
.
CLIENT_WINS
?
conflict
.
local
:
conflict
.
remote
;
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
return
updated
;
}
)
;
}
execute
(
doOperations
{
preloadIds
=
[
]
}
=
{
}
)
{
for
(
let
id
of
preloadIds
)
{
if
(
!
this
.
idSchema
.
validate
(
id
)
)
{
return
_promise2
.
default
.
reject
(
Error
(
Invalid
Id
:
{
id
}
)
)
;
}
}
return
this
.
db
.
execute
(
transaction
=
>
{
const
txn
=
new
CollectionTransaction
(
this
transaction
)
;
const
result
=
doOperations
(
txn
)
;
txn
.
emitEvents
(
)
;
return
result
;
}
{
preload
:
preloadIds
}
)
;
}
resetSyncStatus
(
)
{
var
_this5
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
unsynced
=
yield
_this5
.
list
(
{
filters
:
{
_status
:
[
"
deleted
"
"
synced
"
]
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
;
yield
_this5
.
db
.
execute
(
function
(
transaction
)
{
unsynced
.
data
.
forEach
(
function
(
record
)
{
if
(
record
.
_status
=
=
=
"
deleted
"
)
{
transaction
.
delete
(
record
.
id
)
;
}
else
{
transaction
.
update
(
(
0
_extends3
.
default
)
(
{
}
record
{
last_modified
:
undefined
_status
:
"
created
"
}
)
)
;
}
}
)
;
}
)
;
_this5
.
_lastModified
=
null
;
yield
_this5
.
db
.
saveLastModified
(
null
)
;
return
unsynced
.
data
.
length
;
}
)
(
)
;
}
gatherLocalChanges
(
)
{
var
_this6
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
unsynced
=
yield
_this6
.
list
(
{
filters
:
{
_status
:
[
"
created
"
"
updated
"
]
}
order
:
"
"
}
)
;
const
deleted
=
yield
_this6
.
list
(
{
filters
:
{
_status
:
"
deleted
"
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
;
const
toSync
=
yield
_promise2
.
default
.
all
(
unsynced
.
data
.
map
(
_this6
.
_encodeRecord
.
bind
(
_this6
"
remote
"
)
)
)
;
const
toDelete
=
yield
_promise2
.
default
.
all
(
deleted
.
data
.
map
(
_this6
.
_encodeRecord
.
bind
(
_this6
"
remote
"
)
)
)
;
return
{
toSync
toDelete
}
;
}
)
(
)
;
}
pullChanges
(
client
syncResultObject
options
=
{
}
)
{
var
_this7
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
if
(
!
syncResultObject
.
ok
)
{
return
syncResultObject
;
}
const
since
=
_this7
.
lastModified
?
_this7
.
lastModified
:
yield
_this7
.
db
.
getLastModified
(
)
;
options
=
(
0
_extends3
.
default
)
(
{
strategy
:
Collection
.
strategy
.
MANUAL
lastModified
:
since
headers
:
{
}
}
options
)
;
let
filters
;
if
(
options
.
exclude
)
{
const
exclude_id
=
options
.
exclude
.
slice
(
0
50
)
.
map
(
function
(
r
)
{
return
r
.
id
;
}
)
.
join
(
"
"
)
;
filters
=
{
exclude_id
}
;
}
const
{
data
last_modified
}
=
yield
client
.
listRecords
(
{
since
:
options
.
lastModified
?
{
options
.
lastModified
}
:
undefined
headers
:
options
.
headers
filters
}
)
;
const
unquoted
=
last_modified
?
parseInt
(
last_modified
10
)
:
undefined
;
const
localSynced
=
options
.
lastModified
;
const
serverChanged
=
unquoted
>
options
.
lastModified
;
const
emptyCollection
=
data
.
length
=
=
=
0
;
if
(
!
options
.
exclude
&
&
localSynced
&
&
serverChanged
&
&
emptyCollection
)
{
throw
Error
(
"
Server
has
been
flushed
.
"
)
;
}
syncResultObject
.
lastModified
=
unquoted
;
const
decodedChanges
=
yield
_promise2
.
default
.
all
(
data
.
map
(
function
(
change
)
{
return
_this7
.
_decodeRecord
(
"
remote
"
change
)
;
}
)
)
;
const
payload
=
{
lastModified
:
unquoted
changes
:
decodedChanges
}
;
const
afterHooks
=
yield
_this7
.
applyHook
(
"
incoming
-
changes
"
payload
)
;
if
(
afterHooks
.
changes
.
length
>
0
)
{
yield
_this7
.
importChanges
(
syncResultObject
afterHooks
.
changes
options
.
strategy
)
;
}
return
syncResultObject
;
}
)
(
)
;
}
applyHook
(
hookName
payload
)
{
if
(
typeof
this
.
hooks
[
hookName
]
=
=
"
undefined
"
)
{
return
_promise2
.
default
.
resolve
(
payload
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
.
hooks
[
hookName
]
.
map
(
hook
=
>
{
return
record
=
>
{
const
result
=
hook
(
payload
this
)
;
const
resultThenable
=
result
&
&
typeof
result
.
then
=
=
=
"
function
"
;
const
resultChanges
=
result
&
&
result
.
hasOwnProperty
(
"
changes
"
)
;
if
(
!
(
resultThenable
|
|
resultChanges
)
)
{
throw
new
Error
(
Invalid
return
value
for
hook
:
{
(
0
_stringify2
.
default
)
(
result
)
}
has
no
'
then
(
)
'
or
'
changes
'
properties
)
;
}
return
result
;
}
;
}
)
payload
)
;
}
pushChanges
(
client
{
toDelete
=
[
]
toSync
}
syncResultObject
options
=
{
}
)
{
var
_this8
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
if
(
!
syncResultObject
.
ok
)
{
return
syncResultObject
;
}
const
safe
=
!
options
.
strategy
|
|
options
.
strategy
!
=
=
Collection
.
CLIENT_WINS
;
const
synced
=
yield
client
.
batch
(
function
(
batch
)
{
toDelete
.
forEach
(
function
(
r
)
{
if
(
r
.
last_modified
)
{
batch
.
deleteRecord
(
r
)
;
}
}
)
;
toSync
.
forEach
(
function
(
r
)
{
const
published
=
_this8
.
cleanLocalFields
(
r
)
;
if
(
r
.
_status
=
=
=
"
created
"
)
{
batch
.
createRecord
(
published
)
;
}
else
{
batch
.
updateRecord
(
published
)
;
}
}
)
;
}
{
headers
:
options
.
headers
safe
aggregate
:
true
}
)
;
syncResultObject
.
add
(
"
errors
"
synced
.
errors
.
map
(
function
(
e
)
{
return
(
0
_extends3
.
default
)
(
{
}
e
{
type
:
"
outgoing
"
}
)
;
}
)
)
;
const
conflicts
=
[
]
;
for
(
let
{
type
local
remote
}
of
synced
.
conflicts
)
{
const
safeLocal
=
local
&
&
local
.
data
|
|
{
id
:
remote
.
id
}
;
const
realLocal
=
yield
_this8
.
_decodeRecord
(
"
remote
"
safeLocal
)
;
const
realRemote
=
yield
_this8
.
_decodeRecord
(
"
remote
"
remote
)
;
const
conflict
=
{
type
local
:
realLocal
remote
:
realRemote
}
;
conflicts
.
push
(
conflict
)
;
}
syncResultObject
.
add
(
"
conflicts
"
conflicts
)
;
const
missingRemotely
=
synced
.
skipped
.
map
(
function
(
r
)
{
return
(
0
_extends3
.
default
)
(
{
}
r
{
deleted
:
true
}
)
;
}
)
;
const
published
=
synced
.
published
.
map
(
function
(
c
)
{
return
c
.
data
;
}
)
;
const
toApplyLocally
=
published
.
concat
(
missingRemotely
)
;
const
decoded
=
yield
_promise2
.
default
.
all
(
toApplyLocally
.
map
(
function
(
record
)
{
return
_this8
.
_decodeRecord
(
"
remote
"
record
)
;
}
)
)
;
if
(
decoded
.
length
>
0
|
|
conflicts
.
length
>
0
)
{
yield
_this8
.
_applyPushedResults
(
syncResultObject
decoded
conflicts
options
.
strategy
)
;
}
return
syncResultObject
;
}
)
(
)
;
}
cleanLocalFields
(
record
)
{
const
localKeys
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
this
.
localFields
)
;
return
(
0
_utils
.
omitKeys
)
(
record
localKeys
)
;
}
resolve
(
conflict
resolution
)
{
return
this
.
db
.
execute
(
transaction
=
>
{
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
return
{
data
:
updated
permissions
:
{
}
}
;
}
)
;
}
_resolveRaw
(
conflict
resolution
)
{
const
resolved
=
(
0
_extends3
.
default
)
(
{
}
resolution
{
last_modified
:
conflict
.
remote
.
last_modified
}
)
;
const
synced
=
(
0
_utils
.
deepEqual
)
(
resolved
conflict
.
remote
)
;
return
markStatus
(
resolved
synced
?
"
synced
"
:
"
updated
"
)
;
}
sync
(
options
=
{
strategy
:
Collection
.
strategy
.
MANUAL
headers
:
{
}
ignoreBackoff
:
false
bucket
:
null
collection
:
null
remote
:
null
}
)
{
var
_this9
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
const
previousRemote
=
_this9
.
api
.
remote
;
if
(
options
.
remote
)
{
_this9
.
api
.
remote
=
options
.
remote
;
}
if
(
!
options
.
ignoreBackoff
&
&
_this9
.
api
.
backoff
>
0
)
{
const
seconds
=
Math
.
ceil
(
_this9
.
api
.
backoff
/
1000
)
;
return
_promise2
.
default
.
reject
(
new
Error
(
Server
is
asking
clients
to
back
off
;
retry
in
{
seconds
}
s
or
use
the
ignoreBackoff
option
.
)
)
;
}
const
client
=
_this9
.
api
.
bucket
(
options
.
bucket
|
|
_this9
.
bucket
)
.
collection
(
options
.
collection
|
|
_this9
.
name
)
;
const
result
=
new
SyncResultObject
(
)
;
try
{
yield
_this9
.
pullChanges
(
client
result
options
)
;
const
{
lastModified
}
=
result
;
const
{
toDelete
toSync
}
=
yield
_this9
.
gatherLocalChanges
(
)
;
yield
_this9
.
pushChanges
(
client
{
toDelete
toSync
}
result
options
)
;
const
resolvedUnsynced
=
result
.
resolved
.
filter
(
function
(
r
)
{
return
r
.
_status
!
=
=
"
synced
"
;
}
)
;
if
(
resolvedUnsynced
.
length
>
0
)
{
const
resolvedEncoded
=
yield
_promise2
.
default
.
all
(
resolvedUnsynced
.
map
(
_this9
.
_encodeRecord
.
bind
(
_this9
"
remote
"
)
)
)
;
yield
_this9
.
pushChanges
(
client
{
toSync
:
resolvedEncoded
}
result
options
)
;
}
if
(
result
.
published
.
length
>
0
)
{
const
pullOpts
=
(
0
_extends3
.
default
)
(
{
}
options
{
lastModified
exclude
:
result
.
published
}
)
;
yield
_this9
.
pullChanges
(
client
result
pullOpts
)
;
}
if
(
result
.
ok
)
{
_this9
.
_lastModified
=
yield
_this9
.
db
.
saveLastModified
(
result
.
lastModified
)
;
}
}
finally
{
_this9
.
api
.
remote
=
previousRemote
;
}
return
result
;
}
)
(
)
;
}
loadDump
(
records
)
{
var
_this10
=
this
;
return
(
0
_asyncToGenerator3
.
default
)
(
function
*
(
)
{
if
(
!
Array
.
isArray
(
records
)
)
{
throw
new
Error
(
"
Records
is
not
an
array
.
"
)
;
}
for
(
let
record
of
records
)
{
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
|
|
!
_this10
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
"
Record
has
invalid
ID
:
"
+
(
0
_stringify2
.
default
)
(
record
)
)
;
}
if
(
!
record
.
last_modified
)
{
throw
new
Error
(
"
Record
has
no
last_modified
value
:
"
+
(
0
_stringify2
.
default
)
(
record
)
)
;
}
}
const
{
data
}
=
yield
_this10
.
list
(
{
}
{
includeDeleted
:
true
}
)
;
const
existingById
=
data
.
reduce
(
function
(
acc
record
)
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
const
newRecords
=
records
.
filter
(
function
(
record
)
{
const
localRecord
=
existingById
[
record
.
id
]
;
const
shouldKeep
=
localRecord
=
=
=
undefined
|
|
localRecord
.
_status
=
=
=
"
synced
"
&
&
localRecord
.
last_modified
!
=
=
undefined
&
&
record
.
last_modified
>
localRecord
.
last_modified
;
return
shouldKeep
;
}
)
;
return
yield
_this10
.
db
.
loadDump
(
newRecords
.
map
(
markSynced
)
)
;
}
)
(
)
;
}
}
exports
.
default
=
Collection
;
class
CollectionTransaction
{
constructor
(
collection
adapterTransaction
)
{
this
.
collection
=
collection
;
this
.
adapterTransaction
=
adapterTransaction
;
this
.
_events
=
[
]
;
}
_queueEvent
(
action
payload
)
{
this
.
_events
.
push
(
{
action
payload
}
)
;
}
emitEvents
(
)
{
for
(
let
{
action
payload
}
of
this
.
_events
)
{
this
.
collection
.
events
.
emit
(
action
payload
)
;
}
if
(
this
.
_events
.
length
>
0
)
{
const
targets
=
this
.
_events
.
map
(
(
{
action
payload
}
)
=
>
(
0
_extends3
.
default
)
(
{
action
}
payload
)
)
;
this
.
collection
.
events
.
emit
(
"
change
"
{
targets
}
)
;
}
this
.
_events
=
[
]
;
}
getAny
(
id
)
{
const
record
=
this
.
adapterTransaction
.
get
(
id
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
const
res
=
this
.
getAny
(
id
)
;
if
(
!
res
.
data
|
|
!
options
.
includeDeleted
&
&
res
.
data
.
_status
=
=
=
"
deleted
"
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
return
res
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
const
alreadyDeleted
=
existing
&
&
existing
.
_status
=
=
"
deleted
"
;
if
(
!
existing
|
|
alreadyDeleted
&
&
options
.
virtual
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
if
(
options
.
virtual
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
}
else
{
this
.
adapterTransaction
.
delete
(
id
)
;
}
this
.
_queueEvent
(
"
delete
"
{
data
:
existing
}
)
;
return
{
data
:
existing
permissions
:
{
}
}
;
}
deleteAny
(
id
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
if
(
existing
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
this
.
_queueEvent
(
"
delete
"
{
data
:
existing
}
)
;
}
return
{
data
:
(
0
_extends3
.
default
)
(
{
id
}
existing
)
deleted
:
!
!
existing
permissions
:
{
}
}
;
}
create
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
create
a
record
missing
id
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
this
.
adapterTransaction
.
create
(
record
)
;
this
.
_queueEvent
(
"
create
"
{
data
:
record
}
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
const
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
if
(
!
oldRecord
)
{
throw
new
Error
(
Record
with
id
=
{
record
.
id
}
not
found
.
)
;
}
const
newRecord
=
options
.
patch
?
(
0
_extends3
.
default
)
(
{
}
oldRecord
record
)
:
record
;
const
updated
=
this
.
_updateRaw
(
oldRecord
newRecord
options
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
this
.
_queueEvent
(
"
update
"
{
data
:
updated
oldRecord
}
)
;
return
{
data
:
updated
oldRecord
permissions
:
{
}
}
;
}
_updateRaw
(
oldRecord
newRecord
{
synced
=
false
}
=
{
}
)
{
const
updated
=
(
0
_extends3
.
default
)
(
{
}
newRecord
)
;
if
(
oldRecord
&
&
oldRecord
.
last_modified
&
&
!
updated
.
last_modified
)
{
updated
.
last_modified
=
oldRecord
.
last_modified
;
}
const
isIdentical
=
oldRecord
&
&
recordsEqual
(
oldRecord
updated
this
.
localFields
)
;
const
keepSynced
=
isIdentical
&
&
oldRecord
.
_status
=
=
"
synced
"
;
const
neverSynced
=
!
oldRecord
|
|
oldRecord
&
&
oldRecord
.
_status
=
=
"
created
"
;
const
newStatus
=
keepSynced
|
|
synced
?
"
synced
"
:
neverSynced
?
"
created
"
:
"
updated
"
;
return
markStatus
(
updated
newStatus
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
let
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
const
updated
=
this
.
_updateRaw
(
oldRecord
record
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
if
(
oldRecord
&
&
oldRecord
.
_status
=
=
"
deleted
"
)
{
oldRecord
=
undefined
;
}
if
(
oldRecord
)
{
this
.
_queueEvent
(
"
update
"
{
data
:
updated
oldRecord
}
)
;
}
else
{
this
.
_queueEvent
(
"
create
"
{
data
:
updated
}
)
;
}
return
{
data
:
updated
oldRecord
permissions
:
{
}
}
;
}
}
exports
.
CollectionTransaction
=
CollectionTransaction
;
}
{
"
.
/
adapters
/
IDB
"
:
84
"
.
/
adapters
/
base
"
:
85
"
.
/
utils
"
:
87
"
babel
-
runtime
/
core
-
js
/
json
/
stringify
"
:
3
"
babel
-
runtime
/
core
-
js
/
object
/
assign
"
:
4
"
babel
-
runtime
/
core
-
js
/
promise
"
:
6
"
babel
-
runtime
/
helpers
/
asyncToGenerator
"
:
7
"
babel
-
runtime
/
helpers
/
extends
"
:
8
"
uuid
"
:
9
}
]
87
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
RE_UUID
=
undefined
;
var
_promise
=
require
(
"
babel
-
runtime
/
core
-
js
/
promise
"
)
;
var
_promise2
=
_interopRequireDefault
(
_promise
)
;
var
_keys
=
require
(
"
babel
-
runtime
/
core
-
js
/
object
/
keys
"
)
;
var
_keys2
=
_interopRequireDefault
(
_keys
)
;
exports
.
sortObjects
=
sortObjects
;
exports
.
filterObject
=
filterObject
;
exports
.
filterObjects
=
filterObjects
;
exports
.
isUUID
=
isUUID
;
exports
.
waterfall
=
waterfall
;
exports
.
deepEqual
=
deepEqual
;
exports
.
omitKeys
=
omitKeys
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
RE_UUID
=
exports
.
RE_UUID
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
function
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
function
filterObject
(
filters
entry
)
{
return
(
0
_keys2
.
default
)
(
filters
)
.
every
(
filter
=
>
{
const
value
=
filters
[
filter
]
;
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
function
filterObjects
(
filters
list
)
{
return
list
.
filter
(
entry
=
>
{
return
filterObject
(
filters
entry
)
;
}
)
;
}
function
isUUID
(
uuid
)
{
return
RE_UUID
.
test
(
uuid
)
;
}
function
waterfall
(
fns
init
)
{
if
(
!
fns
.
length
)
{
return
_promise2
.
default
.
resolve
(
init
)
;
}
return
fns
.
reduce
(
(
promise
nextFn
)
=
>
{
return
promise
.
then
(
nextFn
)
;
}
_promise2
.
default
.
resolve
(
init
)
)
;
}
function
deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
typeof
a
!
=
=
typeof
b
)
{
return
false
;
}
if
(
!
(
a
&
&
typeof
a
=
=
"
object
"
)
|
|
!
(
b
&
&
typeof
b
=
=
"
object
"
)
)
{
return
false
;
}
if
(
(
0
_keys2
.
default
)
(
a
)
.
length
!
=
=
(
0
_keys2
.
default
)
(
b
)
.
length
)
{
return
false
;
}
for
(
let
k
in
a
)
{
if
(
!
deepEqual
(
a
[
k
]
b
[
k
]
)
)
{
return
false
;
}
}
return
true
;
}
function
omitKeys
(
obj
keys
=
[
]
)
{
return
(
0
_keys2
.
default
)
(
obj
)
.
reduce
(
(
acc
key
)
=
>
{
if
(
keys
.
indexOf
(
key
)
=
=
=
-
1
)
{
acc
[
key
]
=
obj
[
key
]
;
}
return
acc
;
}
{
}
)
;
}
}
{
"
babel
-
runtime
/
core
-
js
/
object
/
keys
"
:
5
"
babel
-
runtime
/
core
-
js
/
promise
"
:
6
}
]
}
{
}
[
2
]
)
(
2
)
}
)
;
