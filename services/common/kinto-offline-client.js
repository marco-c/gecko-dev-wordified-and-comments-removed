this
.
EXPORTED_SYMBOLS
=
[
"
loadKinto
"
]
;
(
function
(
f
)
{
if
(
typeof
exports
=
=
=
"
object
"
&
&
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
loadKinto
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_base
=
require
(
"
.
.
/
src
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_utils
=
require
(
"
.
.
/
src
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Sqlite
.
jsm
"
)
;
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
SQLITE_PATH
=
"
kinto
.
sqlite
"
;
const
statements
=
{
"
createCollectionData
"
:
CREATE
TABLE
collection_data
(
collection_name
TEXT
record_id
TEXT
record
TEXT
)
;
"
createCollectionMetadata
"
:
CREATE
TABLE
collection_metadata
(
collection_name
TEXT
PRIMARY
KEY
last_modified
INTEGER
)
WITHOUT
ROWID
;
"
createCollectionDataRecordIdIndex
"
:
CREATE
UNIQUE
INDEX
unique_collection_record
ON
collection_data
(
collection_name
record_id
)
;
"
clearData
"
:
DELETE
FROM
collection_data
WHERE
collection_name
=
:
collection_name
;
"
createData
"
:
INSERT
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
"
updateData
"
:
INSERT
OR
REPLACE
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
"
deleteData
"
:
DELETE
FROM
collection_data
WHERE
collection_name
=
:
collection_name
AND
record_id
=
:
record_id
;
"
saveLastModified
"
:
REPLACE
INTO
collection_metadata
(
collection_name
last_modified
)
VALUES
(
:
collection_name
:
last_modified
)
;
"
getLastModified
"
:
SELECT
last_modified
FROM
collection_metadata
WHERE
collection_name
=
:
collection_name
;
"
getRecord
"
:
SELECT
record
FROM
collection_data
WHERE
collection_name
=
:
collection_name
AND
record_id
=
:
record_id
;
"
listRecords
"
:
SELECT
record
FROM
collection_data
WHERE
collection_name
=
:
collection_name
;
"
listRecordsById
"
:
SELECT
record_id
record
FROM
collection_data
WHERE
collection_name
=
?
AND
record_id
IN
"
importData
"
:
REPLACE
INTO
collection_data
(
collection_name
record_id
record
)
VALUES
(
:
collection_name
:
record_id
:
record
)
;
}
;
const
createStatements
=
[
"
createCollectionData
"
"
createCollectionMetadata
"
"
createCollectionDataRecordIdIndex
"
]
;
const
currentSchemaVersion
=
1
;
class
FirefoxAdapter
extends
_base2
.
default
{
constructor
(
collection
options
=
{
}
)
{
super
(
)
;
this
.
collection
=
collection
;
this
.
_connection
=
null
;
this
.
_options
=
options
;
}
_init
(
connection
)
{
return
Task
.
spawn
(
function
*
(
)
{
yield
connection
.
executeTransaction
(
function
*
doSetup
(
)
{
const
schema
=
yield
connection
.
getSchemaVersion
(
)
;
if
(
schema
=
=
0
)
{
for
(
let
statementName
of
createStatements
)
{
yield
connection
.
execute
(
statements
[
statementName
]
)
;
}
yield
connection
.
setSchemaVersion
(
currentSchemaVersion
)
;
}
else
if
(
schema
!
=
1
)
{
throw
new
Error
(
"
Unknown
database
schema
:
"
+
schema
)
;
}
}
)
;
return
connection
;
}
)
;
}
_executeStatement
(
statement
params
)
{
if
(
!
this
.
_connection
)
{
throw
new
Error
(
"
The
storage
adapter
is
not
open
"
)
;
}
return
this
.
_connection
.
executeCached
(
statement
params
)
;
}
open
(
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
path
=
self
.
_options
.
path
|
|
SQLITE_PATH
;
const
opts
=
{
path
sharedMemoryCache
:
false
}
;
if
(
!
self
.
_connection
)
{
self
.
_connection
=
yield
Sqlite
.
openConnection
(
opts
)
.
then
(
self
.
_init
)
;
}
}
)
;
}
close
(
)
{
if
(
this
.
_connection
)
{
const
promise
=
this
.
_connection
.
close
(
)
;
this
.
_connection
=
null
;
return
promise
;
}
return
Promise
.
resolve
(
)
;
}
clear
(
)
{
const
params
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
clearData
params
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
if
(
!
this
.
_connection
)
{
throw
new
Error
(
"
The
storage
adapter
is
not
open
"
)
;
}
let
result
;
const
conn
=
this
.
_connection
;
const
collection
=
this
.
collection
;
return
conn
.
executeTransaction
(
function
*
doExecuteTransaction
(
)
{
const
parameters
=
[
collection
.
.
.
options
.
preload
]
;
const
placeholders
=
options
.
preload
.
map
(
_
=
>
"
?
"
)
;
const
stmt
=
statements
.
listRecordsById
+
"
(
"
+
placeholders
.
join
(
"
"
)
+
"
)
;
"
;
const
rows
=
yield
conn
.
execute
(
stmt
parameters
)
;
const
preloaded
=
rows
.
reduce
(
(
acc
row
)
=
>
{
const
record
=
JSON
.
parse
(
row
.
getResultByName
(
"
record
"
)
)
;
acc
[
row
.
getResultByName
(
"
record_id
"
)
]
=
record
;
return
acc
;
}
{
}
)
;
const
proxy
=
transactionProxy
(
collection
preloaded
)
;
result
=
callback
(
proxy
)
;
for
(
let
{
statement
params
}
of
proxy
.
operations
)
{
yield
conn
.
executeCached
(
statement
params
)
;
}
}
conn
.
TRANSACTION_EXCLUSIVE
)
.
then
(
_
=
>
result
)
;
}
get
(
id
)
{
const
params
=
{
collection_name
:
this
.
collection
record_id
:
id
}
;
return
this
.
_executeStatement
(
statements
.
getRecord
params
)
.
then
(
result
=
>
{
if
(
result
.
length
=
=
0
)
{
return
;
}
return
JSON
.
parse
(
result
[
0
]
.
getResultByName
(
"
record
"
)
)
;
}
)
;
}
list
(
params
=
{
filters
:
{
}
order
:
"
"
}
)
{
const
parameters
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
listRecords
parameters
)
.
then
(
result
=
>
{
const
records
=
[
]
;
for
(
let
k
=
0
;
k
<
result
.
length
;
k
+
+
)
{
const
row
=
result
[
k
]
;
records
.
push
(
JSON
.
parse
(
row
.
getResultByName
(
"
record
"
)
)
)
;
}
return
records
;
}
)
.
then
(
results
=
>
{
return
(
0
_utils
.
reduceRecords
)
(
params
.
filters
params
.
order
results
)
;
}
)
;
}
loadDump
(
records
)
{
const
connection
=
this
.
_connection
;
const
collection_name
=
this
.
collection
;
return
Task
.
spawn
(
function
*
(
)
{
yield
connection
.
executeTransaction
(
function
*
doImport
(
)
{
for
(
let
record
of
records
)
{
const
params
=
{
collection_name
:
collection_name
record_id
:
record
.
id
record
:
JSON
.
stringify
(
record
)
}
;
yield
connection
.
execute
(
statements
.
importData
params
)
;
}
const
lastModified
=
Math
.
max
(
.
.
.
records
.
map
(
record
=
>
record
.
last_modified
)
)
;
const
params
=
{
collection_name
:
collection_name
}
;
const
previousLastModified
=
yield
connection
.
execute
(
statements
.
getLastModified
params
)
.
then
(
result
=
>
{
return
result
.
length
>
0
?
result
[
0
]
.
getResultByName
(
"
last_modified
"
)
:
-
1
;
}
)
;
if
(
lastModified
>
previousLastModified
)
{
const
params
=
{
collection_name
:
collection_name
last_modified
:
lastModified
}
;
yield
connection
.
execute
(
statements
.
saveLastModified
params
)
;
}
}
)
;
return
records
;
}
)
;
}
saveLastModified
(
lastModified
)
{
const
parsedLastModified
=
parseInt
(
lastModified
10
)
|
|
null
;
const
params
=
{
collection_name
:
this
.
collection
last_modified
:
parsedLastModified
}
;
return
this
.
_executeStatement
(
statements
.
saveLastModified
params
)
.
then
(
(
)
=
>
parsedLastModified
)
;
}
getLastModified
(
)
{
const
params
=
{
collection_name
:
this
.
collection
}
;
return
this
.
_executeStatement
(
statements
.
getLastModified
params
)
.
then
(
result
=
>
{
if
(
result
.
length
=
=
0
)
{
return
0
;
}
return
result
[
0
]
.
getResultByName
(
"
last_modified
"
)
;
}
)
;
}
}
exports
.
default
=
FirefoxAdapter
;
function
transactionProxy
(
collection
preloaded
)
{
const
_operations
=
[
]
;
return
{
get
operations
(
)
{
return
_operations
;
}
create
(
record
)
{
_operations
.
push
(
{
statement
:
statements
.
createData
params
:
{
collection_name
:
collection
record_id
:
record
.
id
record
:
JSON
.
stringify
(
record
)
}
}
)
;
}
update
(
record
)
{
_operations
.
push
(
{
statement
:
statements
.
updateData
params
:
{
collection_name
:
collection
record_id
:
record
.
id
record
:
JSON
.
stringify
(
record
)
}
}
)
;
}
delete
(
id
)
{
_operations
.
push
(
{
statement
:
statements
.
deleteData
params
:
{
collection_name
:
collection
record_id
:
id
}
}
)
;
}
get
(
id
)
{
return
id
in
preloaded
?
preloaded
[
id
]
:
undefined
;
}
}
;
}
}
{
"
.
.
/
src
/
adapters
/
base
"
:
6
"
.
.
/
src
/
utils
"
:
8
}
]
2
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
.
default
=
loadKinto
;
var
_base
=
require
(
"
.
.
/
src
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_KintoBase
=
require
(
"
.
.
/
src
/
KintoBase
"
)
;
var
_KintoBase2
=
_interopRequireDefault
(
_KintoBase
)
;
var
_FirefoxStorage
=
require
(
"
.
/
FirefoxStorage
"
)
;
var
_FirefoxStorage2
=
_interopRequireDefault
(
_FirefoxStorage
)
;
var
_utils
=
require
(
"
.
.
/
src
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
function
loadKinto
(
)
{
const
{
EventEmitter
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
{
}
)
;
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
{
KintoHttpClient
}
=
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
'
fetch
'
]
)
;
function
makeIDSchema
(
)
{
return
{
validate
:
_utils
.
RE_UUID
.
test
.
bind
(
_utils
.
RE_UUID
)
generate
:
function
(
)
{
return
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
]
/
g
"
"
)
;
}
}
;
}
class
KintoFX
extends
_KintoBase2
.
default
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
FirefoxAdapter
:
_FirefoxStorage2
.
default
}
;
}
constructor
(
options
=
{
}
)
{
const
emitter
=
{
}
;
EventEmitter
.
decorate
(
emitter
)
;
const
defaults
=
{
events
:
emitter
ApiClass
:
KintoHttpClient
adapter
:
_FirefoxStorage2
.
default
}
;
const
expandedOptions
=
_extends
(
{
}
defaults
options
)
;
super
(
expandedOptions
)
;
}
collection
(
collName
options
=
{
}
)
{
const
idSchema
=
makeIDSchema
(
)
;
const
expandedOptions
=
_extends
(
{
idSchema
}
options
)
;
return
super
.
collection
(
collName
expandedOptions
)
;
}
}
return
KintoFX
;
}
if
(
typeof
module
=
=
=
"
object
"
)
{
module
.
exports
=
loadKinto
;
}
}
{
"
.
.
/
src
/
KintoBase
"
:
4
"
.
.
/
src
/
adapters
/
base
"
:
6
"
.
.
/
src
/
utils
"
:
8
"
.
/
FirefoxStorage
"
:
1
}
]
3
:
[
function
(
require
module
exports
)
{
}
{
}
]
4
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_collection
=
require
(
"
.
/
collection
"
)
;
var
_collection2
=
_interopRequireDefault
(
_collection
)
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
DEFAULT_BUCKET_NAME
=
"
default
"
;
const
DEFAULT_REMOTE
=
"
http
:
/
/
localhost
:
8888
/
v1
"
;
class
KintoBase
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
}
;
}
static
get
syncStrategy
(
)
{
return
_collection2
.
default
.
strategy
;
}
constructor
(
options
=
{
}
)
{
const
defaults
=
{
bucket
:
DEFAULT_BUCKET_NAME
remote
:
DEFAULT_REMOTE
}
;
this
.
_options
=
_extends
(
{
}
defaults
options
)
;
if
(
!
this
.
_options
.
adapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
{
remote
events
headers
requestMode
timeout
ApiClass
}
=
this
.
_options
;
this
.
api
=
new
ApiClass
(
remote
{
events
headers
requestMode
timeout
}
)
;
this
.
events
=
this
.
_options
.
events
;
}
collection
(
collName
options
=
{
}
)
{
if
(
!
collName
)
{
throw
new
Error
(
"
missing
collection
name
"
)
;
}
const
bucket
=
this
.
_options
.
bucket
;
return
new
_collection2
.
default
(
bucket
collName
this
.
api
{
events
:
this
.
_options
.
events
adapter
:
this
.
_options
.
adapter
adapterOptions
:
this
.
_options
.
adapterOptions
dbPrefix
:
this
.
_options
.
dbPrefix
idSchema
:
options
.
idSchema
remoteTransformers
:
options
.
remoteTransformers
hooks
:
options
.
hooks
}
)
;
}
}
exports
.
default
=
KintoBase
;
}
{
"
.
/
adapters
/
base
"
:
6
"
.
/
collection
"
:
7
}
]
5
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_base
=
require
(
"
.
/
base
.
js
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_utils
=
require
(
"
.
.
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
INDEXED_FIELDS
=
[
"
id
"
"
_status
"
"
last_modified
"
]
;
const
cursorHandlers
=
{
all
(
done
)
{
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
results
.
push
(
cursor
.
value
)
;
cursor
.
continue
(
)
;
}
else
{
done
(
results
)
;
}
}
;
}
in
(
values
done
)
{
const
sortedValues
=
[
]
.
slice
.
call
(
values
)
.
sort
(
)
;
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
!
cursor
)
{
done
(
results
)
;
return
;
}
const
{
key
value
}
=
cursor
;
let
i
=
0
;
while
(
key
>
sortedValues
[
i
]
)
{
+
+
i
;
if
(
i
=
=
=
sortedValues
.
length
)
{
done
(
results
)
;
return
;
}
}
if
(
key
=
=
=
sortedValues
[
i
]
)
{
results
.
push
(
value
)
;
cursor
.
continue
(
)
;
}
else
{
cursor
.
continue
(
sortedValues
[
i
]
)
;
}
}
;
}
}
;
function
findIndexedField
(
filters
)
{
const
filteredFields
=
Object
.
keys
(
filters
)
;
const
indexedFields
=
filteredFields
.
filter
(
field
=
>
{
return
INDEXED_FIELDS
.
indexOf
(
field
)
!
=
=
-
1
;
}
)
;
return
indexedFields
[
0
]
;
}
function
createListRequest
(
store
indexField
value
done
)
{
if
(
!
indexField
)
{
const
request
=
store
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
done
)
;
return
request
;
}
if
(
Array
.
isArray
(
value
)
)
{
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
in
(
value
done
)
;
return
request
;
}
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
IDBKeyRange
.
only
(
value
)
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
done
)
;
return
request
;
}
class
IDB
extends
_base2
.
default
{
constructor
(
dbname
)
{
super
(
)
;
this
.
_db
=
null
;
this
.
dbname
=
dbname
;
}
_handleError
(
method
)
{
return
err
=
>
{
const
error
=
new
Error
(
method
+
"
(
)
"
+
err
.
message
)
;
error
.
stack
=
err
.
stack
;
throw
error
;
}
;
}
open
(
)
{
if
(
this
.
_db
)
{
return
Promise
.
resolve
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
this
.
dbname
1
)
;
request
.
onupgradeneeded
=
event
=
>
{
const
db
=
event
.
target
.
result
;
const
collStore
=
db
.
createObjectStore
(
this
.
dbname
{
keyPath
:
"
id
"
}
)
;
collStore
.
createIndex
(
"
id
"
"
id
"
{
unique
:
true
}
)
;
collStore
.
createIndex
(
"
_status
"
"
_status
"
)
;
collStore
.
createIndex
(
"
last_modified
"
"
last_modified
"
)
;
const
metaStore
=
db
.
createObjectStore
(
"
__meta__
"
{
keyPath
:
"
name
"
}
)
;
metaStore
.
createIndex
(
"
name
"
"
name
"
{
unique
:
true
}
)
;
}
;
request
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
request
.
onsuccess
=
event
=
>
{
this
.
_db
=
event
.
target
.
result
;
resolve
(
this
)
;
}
;
}
)
;
}
close
(
)
{
if
(
this
.
_db
)
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
}
return
super
.
close
(
)
;
}
prepare
(
mode
=
undefined
name
=
null
)
{
const
storeName
=
name
|
|
this
.
dbname
;
const
transaction
=
mode
?
this
.
_db
.
transaction
(
[
storeName
]
mode
)
:
this
.
_db
.
transaction
(
[
storeName
]
)
;
const
store
=
transaction
.
objectStore
(
storeName
)
;
return
{
transaction
store
}
;
}
clear
(
)
{
return
this
.
open
(
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
)
;
store
.
clear
(
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
(
)
=
>
resolve
(
)
;
}
)
;
}
)
.
catch
(
this
.
_handleError
(
"
clear
"
)
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
return
this
.
open
(
)
.
then
(
_
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
)
;
const
ids
=
options
.
preload
;
store
.
index
(
"
id
"
)
.
openCursor
(
)
.
onsuccess
=
cursorHandlers
.
in
(
ids
records
=
>
{
const
preloaded
=
records
.
reduce
(
(
acc
record
)
=
>
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
const
proxy
=
transactionProxy
(
store
preloaded
)
;
let
result
;
try
{
result
=
callback
(
proxy
)
;
}
catch
(
e
)
{
transaction
.
abort
(
)
;
reject
(
e
)
;
}
if
(
result
instanceof
Promise
)
{
reject
(
new
Error
(
"
execute
(
)
callback
should
not
return
a
Promise
.
"
)
)
;
}
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
result
)
;
}
)
;
}
)
)
;
}
get
(
id
)
{
return
this
.
open
(
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
)
;
const
request
=
store
.
get
(
id
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
(
)
=
>
resolve
(
request
.
result
)
;
}
)
;
}
)
.
catch
(
this
.
_handleError
(
"
get
"
)
)
;
}
list
(
params
=
{
filters
:
{
}
}
)
{
const
{
filters
}
=
params
;
const
indexField
=
findIndexedField
(
filters
)
;
const
value
=
filters
[
indexField
]
;
return
this
.
open
(
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
results
=
[
]
;
const
{
transaction
store
}
=
this
.
prepare
(
)
;
createListRequest
(
store
indexField
value
_results
=
>
{
results
=
_results
;
}
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
results
)
;
}
)
;
}
)
.
then
(
results
=
>
{
const
remainingFilters
=
_extends
(
{
}
filters
)
;
delete
remainingFilters
[
indexField
]
;
return
(
0
_utils
.
reduceRecords
)
(
remainingFilters
params
.
order
results
)
;
}
)
.
catch
(
this
.
_handleError
(
"
list
"
)
)
;
}
saveLastModified
(
lastModified
)
{
const
value
=
parseInt
(
lastModified
10
)
|
|
null
;
return
this
.
open
(
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
"
__meta__
"
)
;
store
.
put
(
{
name
:
"
lastModified
"
value
:
value
}
)
;
transaction
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
value
)
;
}
)
;
}
)
;
}
getLastModified
(
)
{
return
this
.
open
(
)
.
then
(
(
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
undefined
"
__meta__
"
)
;
const
request
=
store
.
get
(
"
lastModified
"
)
;
transaction
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
transaction
.
oncomplete
=
event
=
>
{
resolve
(
request
.
result
&
&
request
.
result
.
value
|
|
null
)
;
}
;
}
)
;
}
)
;
}
loadDump
(
records
)
{
return
this
.
execute
(
transaction
=
>
{
records
.
forEach
(
record
=
>
transaction
.
update
(
record
)
)
;
}
)
.
then
(
(
)
=
>
this
.
getLastModified
(
)
)
.
then
(
previousLastModified
=
>
{
const
lastModified
=
Math
.
max
(
.
.
.
records
.
map
(
record
=
>
record
.
last_modified
)
)
;
if
(
lastModified
>
previousLastModified
)
{
return
this
.
saveLastModified
(
lastModified
)
;
}
}
)
.
then
(
(
)
=
>
records
)
.
catch
(
this
.
_handleError
(
"
loadDump
"
)
)
;
}
}
exports
.
default
=
IDB
;
function
transactionProxy
(
store
preloaded
=
[
]
)
{
return
{
create
(
record
)
{
store
.
add
(
record
)
;
}
update
(
record
)
{
store
.
put
(
record
)
;
}
delete
(
id
)
{
store
.
delete
(
id
)
;
}
get
(
id
)
{
return
preloaded
[
id
]
;
}
}
;
}
}
{
"
.
.
/
utils
"
:
8
"
.
/
base
.
js
"
:
6
}
]
6
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
class
BaseAdapter
{
open
(
)
{
return
Promise
.
resolve
(
)
;
}
close
(
)
{
return
Promise
.
resolve
(
)
;
}
clear
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
get
(
id
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
list
(
params
=
{
filters
:
{
}
order
:
"
"
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
saveLastModified
(
lastModified
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
getLastModified
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
loadDump
(
records
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
}
exports
.
default
=
BaseAdapter
;
}
{
}
]
7
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
CollectionTransaction
=
exports
.
SyncResultObject
=
undefined
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
.
recordsEqual
=
recordsEqual
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_IDB
=
require
(
"
.
/
adapters
/
IDB
"
)
;
var
_IDB2
=
_interopRequireDefault
(
_IDB
)
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_uuid
=
require
(
"
uuid
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
RECORD_FIELDS_TO_CLEAN
=
[
"
_status
"
]
;
const
AVAILABLE_HOOKS
=
[
"
incoming
-
changes
"
]
;
function
recordsEqual
(
a
b
localFields
=
[
]
)
{
const
fieldsToClean
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
[
"
last_modified
"
]
)
.
concat
(
localFields
)
;
const
cleanLocal
=
r
=
>
(
0
_utils
.
omitKeys
)
(
r
fieldsToClean
)
;
return
(
0
_utils
.
deepEqual
)
(
cleanLocal
(
a
)
cleanLocal
(
b
)
)
;
}
class
SyncResultObject
{
static
get
defaults
(
)
{
return
{
ok
:
true
lastModified
:
null
errors
:
[
]
created
:
[
]
updated
:
[
]
deleted
:
[
]
published
:
[
]
conflicts
:
[
]
skipped
:
[
]
resolved
:
[
]
}
;
}
constructor
(
)
{
this
.
ok
=
true
;
Object
.
assign
(
this
SyncResultObject
.
defaults
)
;
}
add
(
type
entries
)
{
if
(
!
Array
.
isArray
(
this
[
type
]
)
)
{
return
;
}
this
[
type
]
=
this
[
type
]
.
concat
(
entries
)
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
reset
(
type
)
{
this
[
type
]
=
SyncResultObject
.
defaults
[
type
]
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
}
exports
.
SyncResultObject
=
SyncResultObject
;
function
createUUIDSchema
(
)
{
return
{
generate
(
)
{
return
(
0
_uuid
.
v4
)
(
)
;
}
validate
(
id
)
{
return
(
0
_utils
.
isUUID
)
(
id
)
;
}
}
;
}
function
markStatus
(
record
status
)
{
return
_extends
(
{
}
record
{
_status
:
status
}
)
;
}
function
markDeleted
(
record
)
{
return
markStatus
(
record
"
deleted
"
)
;
}
function
markSynced
(
record
)
{
return
markStatus
(
record
"
synced
"
)
;
}
function
importChange
(
transaction
remote
localFields
)
{
const
local
=
transaction
.
get
(
remote
.
id
)
;
if
(
!
local
)
{
if
(
remote
.
deleted
)
{
return
{
type
:
"
skipped
"
data
:
remote
}
;
}
const
synced
=
markSynced
(
remote
)
;
transaction
.
create
(
synced
)
;
return
{
type
:
"
created
"
data
:
synced
}
;
}
const
isIdentical
=
recordsEqual
(
local
remote
localFields
)
;
const
synced
=
_extends
(
{
}
local
markSynced
(
remote
)
)
;
if
(
local
.
_status
!
=
=
"
synced
"
)
{
if
(
local
.
_status
=
=
=
"
deleted
"
)
{
return
{
type
:
"
skipped
"
data
:
local
}
;
}
if
(
isIdentical
)
{
transaction
.
update
(
synced
)
;
return
{
type
:
"
updated
"
data
:
{
old
:
local
new
:
synced
}
}
;
}
if
(
local
.
last_modified
!
=
=
undefined
&
&
local
.
last_modified
=
=
=
remote
.
last_modified
)
{
return
{
type
:
"
void
"
}
;
}
return
{
type
:
"
conflicts
"
data
:
{
type
:
"
incoming
"
local
:
local
remote
:
remote
}
}
;
}
if
(
remote
.
deleted
)
{
transaction
.
delete
(
remote
.
id
)
;
return
{
type
:
"
deleted
"
data
:
local
}
;
}
transaction
.
update
(
synced
)
;
const
type
=
isIdentical
?
"
void
"
:
"
updated
"
;
return
{
type
data
:
{
old
:
local
new
:
synced
}
}
;
}
class
Collection
{
constructor
(
bucket
name
api
options
=
{
}
)
{
this
.
_bucket
=
bucket
;
this
.
_name
=
name
;
this
.
_lastModified
=
null
;
const
DBAdapter
=
options
.
adapter
|
|
_IDB2
.
default
;
if
(
!
DBAdapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
dbPrefix
=
options
.
dbPrefix
|
|
"
"
;
const
db
=
new
DBAdapter
(
{
dbPrefix
}
{
bucket
}
/
{
name
}
options
.
adapterOptions
)
;
if
(
!
(
db
instanceof
_base2
.
default
)
)
{
throw
new
Error
(
"
Unsupported
adapter
.
"
)
;
}
this
.
db
=
db
;
this
.
api
=
api
;
this
.
events
=
options
.
events
;
this
.
idSchema
=
this
.
_validateIdSchema
(
options
.
idSchema
)
;
this
.
remoteTransformers
=
this
.
_validateRemoteTransformers
(
options
.
remoteTransformers
)
;
this
.
hooks
=
this
.
_validateHooks
(
options
.
hooks
)
;
this
.
localFields
=
options
.
localFields
|
|
[
]
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
bucket
(
)
{
return
this
.
_bucket
;
}
get
lastModified
(
)
{
return
this
.
_lastModified
;
}
static
get
strategy
(
)
{
return
{
CLIENT_WINS
:
"
client_wins
"
SERVER_WINS
:
"
server_wins
"
MANUAL
:
"
manual
"
}
;
}
_validateIdSchema
(
idSchema
)
{
if
(
typeof
idSchema
=
=
=
"
undefined
"
)
{
return
createUUIDSchema
(
)
;
}
if
(
typeof
idSchema
!
=
=
"
object
"
)
{
throw
new
Error
(
"
idSchema
must
be
an
object
.
"
)
;
}
else
if
(
typeof
idSchema
.
generate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
generate
function
.
"
)
;
}
else
if
(
typeof
idSchema
.
validate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
validate
function
.
"
)
;
}
return
idSchema
;
}
_validateRemoteTransformers
(
remoteTransformers
)
{
if
(
typeof
remoteTransformers
=
=
=
"
undefined
"
)
{
return
[
]
;
}
if
(
!
Array
.
isArray
(
remoteTransformers
)
)
{
throw
new
Error
(
"
remoteTransformers
should
be
an
array
.
"
)
;
}
return
remoteTransformers
.
map
(
transformer
=
>
{
if
(
typeof
transformer
!
=
=
"
object
"
)
{
throw
new
Error
(
"
A
transformer
must
be
an
object
.
"
)
;
}
else
if
(
typeof
transformer
.
encode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
an
encode
function
.
"
)
;
}
else
if
(
typeof
transformer
.
decode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
a
decode
function
.
"
)
;
}
return
transformer
;
}
)
;
}
_validateHook
(
hook
)
{
if
(
!
Array
.
isArray
(
hook
)
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
hook
.
map
(
fn
=
>
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
fn
;
}
)
;
}
_validateHooks
(
hooks
)
{
if
(
typeof
hooks
=
=
=
"
undefined
"
)
{
return
{
}
;
}
if
(
Array
.
isArray
(
hooks
)
)
{
throw
new
Error
(
"
hooks
should
be
an
object
not
an
array
.
"
)
;
}
if
(
typeof
hooks
!
=
=
"
object
"
)
{
throw
new
Error
(
"
hooks
should
be
an
object
.
"
)
;
}
const
validatedHooks
=
{
}
;
for
(
let
hook
in
hooks
)
{
if
(
AVAILABLE_HOOKS
.
indexOf
(
hook
)
=
=
=
-
1
)
{
throw
new
Error
(
"
The
hook
should
be
one
of
"
+
AVAILABLE_HOOKS
.
join
(
"
"
)
)
;
}
validatedHooks
[
hook
]
=
this
.
_validateHook
(
hooks
[
hook
]
)
;
}
return
validatedHooks
;
}
clear
(
)
{
return
this
.
db
.
clear
(
)
.
then
(
_
=
>
this
.
db
.
saveLastModified
(
null
)
)
.
then
(
_
=
>
(
{
data
:
[
]
permissions
:
{
}
}
)
)
;
}
_encodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
Promise
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
encode
(
record
)
;
}
)
record
)
;
}
_decodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
Promise
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
reverse
(
)
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
decode
(
record
)
;
}
)
record
)
;
}
create
(
record
options
=
{
useRecordId
:
false
synced
:
false
}
)
{
const
reject
=
msg
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
;
if
(
typeof
record
!
=
=
"
object
"
)
{
return
reject
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
(
options
.
synced
|
|
options
.
useRecordId
)
&
&
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Missing
required
Id
;
synced
and
useRecordId
options
require
one
"
)
;
}
if
(
!
options
.
synced
&
&
!
options
.
useRecordId
&
&
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Extraneous
Id
;
can
'
t
create
a
record
having
one
set
.
"
)
;
}
const
newRecord
=
_extends
(
{
}
record
{
id
:
options
.
synced
|
|
options
.
useRecordId
?
record
.
id
:
this
.
idSchema
.
generate
(
)
_status
:
options
.
synced
?
"
synced
"
:
"
created
"
}
)
;
if
(
!
this
.
idSchema
.
validate
(
newRecord
.
id
)
)
{
return
reject
(
Invalid
Id
:
{
newRecord
.
id
}
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
create
(
newRecord
)
{
preloadIds
:
[
newRecord
.
id
]
}
)
.
catch
(
err
=
>
{
if
(
options
.
useRecordId
)
{
throw
new
Error
(
"
Couldn
'
t
create
record
.
It
may
have
been
virtually
deleted
.
"
)
;
}
throw
err
;
}
)
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
Promise
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
Promise
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
Promise
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
update
(
record
options
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
Promise
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
Promise
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
Promise
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
upsert
(
record
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
return
this
.
execute
(
txn
=
>
txn
.
get
(
id
options
)
{
preloadIds
:
[
id
]
}
)
;
}
getAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
getAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
return
this
.
execute
(
transaction
=
>
{
return
transaction
.
delete
(
id
options
)
;
}
{
preloadIds
:
[
id
]
}
)
;
}
deleteAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
deleteAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
list
(
params
=
{
}
options
=
{
includeDeleted
:
false
}
)
{
params
=
_extends
(
{
order
:
"
-
last_modified
"
filters
:
{
}
}
params
)
;
return
this
.
db
.
list
(
params
)
.
then
(
results
=
>
{
let
data
=
results
;
if
(
!
options
.
includeDeleted
)
{
data
=
results
.
filter
(
record
=
>
record
.
_status
!
=
=
"
deleted
"
)
;
}
return
{
data
permissions
:
{
}
}
;
}
)
;
}
importChanges
(
syncResultObject
changeObject
)
{
return
Promise
.
all
(
changeObject
.
changes
.
map
(
change
=
>
{
if
(
change
.
deleted
)
{
return
Promise
.
resolve
(
change
)
;
}
return
this
.
_decodeRecord
(
"
remote
"
change
)
;
}
)
)
.
then
(
decodedChanges
=
>
{
if
(
decodedChanges
.
length
=
=
=
0
)
{
return
Promise
.
resolve
(
syncResultObject
)
;
}
return
this
.
db
.
execute
(
transaction
=
>
{
return
decodedChanges
.
map
(
remote
=
>
{
return
importChange
(
transaction
remote
this
.
localFields
)
;
}
)
;
}
{
preload
:
decodedChanges
.
map
(
record
=
>
record
.
id
)
}
)
.
catch
(
err
=
>
{
const
data
=
{
type
:
"
incoming
"
message
:
err
.
message
stack
:
err
.
stack
}
;
return
[
{
type
:
"
errors
"
data
}
]
;
}
)
.
then
(
imports
=
>
{
for
(
let
imported
of
imports
)
{
if
(
imported
.
type
!
=
=
"
void
"
)
{
syncResultObject
.
add
(
imported
.
type
imported
.
data
)
;
}
}
return
syncResultObject
;
}
)
;
}
)
.
then
(
syncResultObject
=
>
{
syncResultObject
.
lastModified
=
changeObject
.
lastModified
;
if
(
!
syncResultObject
.
ok
)
{
return
syncResultObject
;
}
return
this
.
db
.
saveLastModified
(
syncResultObject
.
lastModified
)
.
then
(
lastModified
=
>
{
this
.
_lastModified
=
lastModified
;
return
syncResultObject
;
}
)
;
}
)
;
}
execute
(
doOperations
{
preloadIds
=
[
]
}
=
{
}
)
{
for
(
let
id
of
preloadIds
)
{
if
(
!
this
.
idSchema
.
validate
(
id
)
)
{
return
Promise
.
reject
(
Error
(
Invalid
Id
:
{
id
}
)
)
;
}
}
return
this
.
db
.
execute
(
transaction
=
>
{
const
txn
=
new
CollectionTransaction
(
this
transaction
)
;
return
doOperations
(
txn
)
;
}
{
preload
:
preloadIds
}
)
;
}
resetSyncStatus
(
)
{
let
_count
;
return
this
.
list
(
{
filters
:
{
_status
:
[
"
deleted
"
"
synced
"
]
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
.
then
(
unsynced
=
>
{
return
this
.
db
.
execute
(
transaction
=
>
{
_count
=
unsynced
.
data
.
length
;
unsynced
.
data
.
forEach
(
record
=
>
{
if
(
record
.
_status
=
=
=
"
deleted
"
)
{
transaction
.
delete
(
record
.
id
)
;
}
else
{
transaction
.
update
(
_extends
(
{
}
record
{
last_modified
:
undefined
_status
:
"
created
"
}
)
)
;
}
}
)
;
}
)
;
}
)
.
then
(
(
)
=
>
this
.
db
.
saveLastModified
(
null
)
)
.
then
(
(
)
=
>
_count
)
;
}
gatherLocalChanges
(
)
{
let
_toDelete
;
return
Promise
.
all
(
[
this
.
list
(
{
filters
:
{
_status
:
[
"
created
"
"
updated
"
]
}
order
:
"
"
}
)
this
.
list
(
{
filters
:
{
_status
:
"
deleted
"
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
]
)
.
then
(
(
[
unsynced
deleted
]
)
=
>
{
_toDelete
=
deleted
.
data
;
return
Promise
.
all
(
unsynced
.
data
.
map
(
this
.
_encodeRecord
.
bind
(
this
"
remote
"
)
)
)
;
}
)
.
then
(
toSync
=
>
(
{
toDelete
:
_toDelete
toSync
}
)
)
;
}
pullChanges
(
client
syncResultObject
options
=
{
}
)
{
if
(
!
syncResultObject
.
ok
)
{
return
Promise
.
resolve
(
syncResultObject
)
;
}
options
=
_extends
(
{
strategy
:
Collection
.
strategy
.
MANUAL
lastModified
:
this
.
lastModified
headers
:
{
}
}
options
)
;
let
filters
;
if
(
options
.
exclude
)
{
const
exclude_id
=
options
.
exclude
.
slice
(
0
50
)
.
map
(
r
=
>
r
.
id
)
.
join
(
"
"
)
;
filters
=
{
exclude_id
}
;
}
return
client
.
listRecords
(
{
since
:
options
.
lastModified
?
{
options
.
lastModified
}
:
undefined
headers
:
options
.
headers
filters
}
)
.
then
(
(
{
data
last_modified
}
)
=
>
{
const
unquoted
=
last_modified
?
parseInt
(
last_modified
10
)
:
undefined
;
const
localSynced
=
options
.
lastModified
;
const
serverChanged
=
unquoted
>
options
.
lastModified
;
const
emptyCollection
=
data
.
length
=
=
=
0
;
if
(
!
options
.
exclude
&
&
localSynced
&
&
serverChanged
&
&
emptyCollection
)
{
throw
Error
(
"
Server
has
been
flushed
.
"
)
;
}
const
payload
=
{
lastModified
:
unquoted
changes
:
data
}
;
return
this
.
applyHook
(
"
incoming
-
changes
"
payload
)
;
}
)
.
then
(
changes
=
>
this
.
importChanges
(
syncResultObject
changes
)
)
.
then
(
result
=
>
this
.
_handleConflicts
(
result
options
.
strategy
)
)
;
}
applyHook
(
hookName
payload
)
{
if
(
typeof
this
.
hooks
[
hookName
]
=
=
"
undefined
"
)
{
return
Promise
.
resolve
(
payload
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
.
hooks
[
hookName
]
.
map
(
hook
=
>
{
return
record
=
>
{
const
result
=
hook
(
payload
this
)
;
const
resultThenable
=
result
&
&
typeof
result
.
then
=
=
=
"
function
"
;
const
resultChanges
=
result
&
&
result
.
hasOwnProperty
(
"
changes
"
)
;
if
(
!
(
resultThenable
|
|
resultChanges
)
)
{
throw
new
Error
(
Invalid
return
value
for
hook
:
{
JSON
.
stringify
(
result
)
}
has
no
'
then
(
)
'
or
'
changes
'
properties
)
;
}
return
result
;
}
;
}
)
payload
)
;
}
pushChanges
(
client
syncResultObject
options
=
{
}
)
{
if
(
!
syncResultObject
.
ok
)
{
return
Promise
.
resolve
(
syncResultObject
)
;
}
const
safe
=
!
options
.
strategy
|
|
options
.
strategy
!
=
=
Collection
.
CLIENT_WINS
;
return
this
.
gatherLocalChanges
(
)
.
then
(
(
{
toDelete
toSync
}
)
=
>
{
return
client
.
batch
(
batch
=
>
{
toDelete
.
forEach
(
r
=
>
{
if
(
r
.
last_modified
)
{
batch
.
deleteRecord
(
r
)
;
}
}
)
;
toSync
.
forEach
(
r
=
>
{
const
published
=
this
.
cleanLocalFields
(
r
)
;
if
(
r
.
_status
=
=
=
"
created
"
)
{
batch
.
createRecord
(
published
)
;
}
else
{
batch
.
updateRecord
(
published
)
;
}
}
)
;
}
{
headers
:
options
.
headers
safe
aggregate
:
true
}
)
;
}
)
.
then
(
synced
=
>
{
syncResultObject
.
add
(
"
errors
"
synced
.
errors
.
map
(
error
=
>
{
error
.
type
=
"
outgoing
"
;
return
error
;
}
)
)
;
const
conflicts
=
synced
.
conflicts
.
map
(
c
=
>
{
return
{
type
:
c
.
type
local
:
c
.
local
.
data
remote
:
c
.
remote
}
;
}
)
;
syncResultObject
.
add
(
"
conflicts
"
conflicts
)
;
const
published
=
synced
.
published
.
map
(
c
=
>
c
.
data
)
;
const
skipped
=
synced
.
skipped
.
map
(
c
=
>
c
.
data
)
;
const
missingRemotely
=
skipped
.
map
(
r
=
>
{
return
_extends
(
{
}
r
{
deleted
:
true
}
)
;
}
)
;
const
toApplyLocally
=
published
.
concat
(
missingRemotely
)
;
const
toDeleteLocally
=
toApplyLocally
.
filter
(
r
=
>
r
.
deleted
)
;
const
toUpdateLocally
=
toApplyLocally
.
filter
(
r
=
>
!
r
.
deleted
)
;
return
Promise
.
all
(
toUpdateLocally
.
map
(
record
=
>
{
return
this
.
_decodeRecord
(
"
remote
"
record
)
;
}
)
)
.
then
(
results
=
>
{
return
this
.
db
.
execute
(
transaction
=
>
{
const
updated
=
results
.
map
(
record
=
>
{
const
synced
=
markSynced
(
record
)
;
transaction
.
update
(
synced
)
;
return
{
data
:
synced
}
;
}
)
;
const
deleted
=
toDeleteLocally
.
map
(
record
=
>
{
transaction
.
delete
(
record
.
id
)
;
return
{
data
:
{
id
:
record
.
id
deleted
:
true
}
}
;
}
)
;
return
updated
.
concat
(
deleted
)
;
}
)
;
}
)
.
then
(
published
=
>
{
syncResultObject
.
add
(
"
published
"
published
.
map
(
res
=
>
res
.
data
)
)
;
return
syncResultObject
;
}
)
;
}
)
.
then
(
result
=
>
this
.
_handleConflicts
(
result
options
.
strategy
)
)
.
then
(
result
=
>
{
const
resolvedUnsynced
=
result
.
resolved
.
filter
(
record
=
>
record
.
_status
!
=
=
"
synced
"
)
;
if
(
resolvedUnsynced
.
length
=
=
=
0
|
|
options
.
resolved
)
{
return
result
;
}
else
if
(
options
.
strategy
=
=
=
Collection
.
strategy
.
CLIENT_WINS
&
&
!
options
.
resolved
)
{
return
this
.
pushChanges
(
client
result
_extends
(
{
}
options
{
resolved
:
true
}
)
)
;
}
else
if
(
options
.
strategy
=
=
=
Collection
.
strategy
.
SERVER_WINS
)
{
return
this
.
db
.
execute
(
transaction
=
>
{
resolvedUnsynced
.
forEach
(
record
=
>
{
transaction
.
update
(
markSynced
(
record
)
)
;
}
)
;
return
result
;
}
)
;
}
}
)
;
}
cleanLocalFields
(
record
)
{
const
localKeys
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
this
.
localFields
)
;
return
(
0
_utils
.
omitKeys
)
(
record
localKeys
)
;
}
resolve
(
conflict
resolution
)
{
return
this
.
db
.
execute
(
transaction
=
>
{
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
return
{
data
:
updated
permissions
:
{
}
}
;
}
)
;
}
_resolveRaw
(
conflict
resolution
)
{
const
resolved
=
_extends
(
{
}
resolution
{
last_modified
:
conflict
.
remote
.
last_modified
}
)
;
const
synced
=
(
0
_utils
.
deepEqual
)
(
resolved
conflict
.
remote
)
;
return
markStatus
(
resolved
synced
?
"
synced
"
:
"
updated
"
)
;
}
_handleConflicts
(
result
strategy
=
Collection
.
strategy
.
MANUAL
)
{
if
(
strategy
=
=
=
Collection
.
strategy
.
MANUAL
|
|
result
.
conflicts
.
length
=
=
=
0
)
{
return
Promise
.
resolve
(
result
)
;
}
return
this
.
db
.
execute
(
transaction
=
>
{
return
result
.
conflicts
.
map
(
conflict
=
>
{
const
resolution
=
strategy
=
=
=
Collection
.
strategy
.
CLIENT_WINS
?
conflict
.
local
:
conflict
.
remote
;
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
return
updated
;
}
)
;
}
)
.
then
(
imports
=
>
{
return
result
.
reset
(
"
conflicts
"
)
.
add
(
"
resolved
"
imports
)
;
}
)
;
}
sync
(
options
=
{
strategy
:
Collection
.
strategy
.
MANUAL
headers
:
{
}
ignoreBackoff
:
false
bucket
:
null
collection
:
null
remote
:
null
}
)
{
const
previousRemote
=
this
.
api
.
remote
;
if
(
options
.
remote
)
{
this
.
api
.
remote
=
options
.
remote
;
}
if
(
!
options
.
ignoreBackoff
&
&
this
.
api
.
backoff
>
0
)
{
const
seconds
=
Math
.
ceil
(
this
.
api
.
backoff
/
1000
)
;
return
Promise
.
reject
(
new
Error
(
Server
is
asking
clients
to
back
off
;
retry
in
{
seconds
}
s
or
use
the
ignoreBackoff
option
.
)
)
;
}
const
client
=
this
.
api
.
bucket
(
options
.
bucket
|
|
this
.
bucket
)
.
collection
(
options
.
collection
|
|
this
.
name
)
;
const
result
=
new
SyncResultObject
(
)
;
const
syncPromise
=
this
.
db
.
getLastModified
(
)
.
then
(
lastModified
=
>
this
.
_lastModified
=
lastModified
)
.
then
(
_
=
>
this
.
pullChanges
(
client
result
options
)
)
.
then
(
result
=
>
this
.
pushChanges
(
client
result
options
)
)
.
then
(
result
=
>
{
if
(
result
.
published
.
length
=
=
=
0
)
{
return
result
;
}
const
pullOpts
=
_extends
(
{
}
options
{
exclude
:
result
.
published
}
)
;
return
this
.
pullChanges
(
client
result
pullOpts
)
;
}
)
;
return
(
0
_utils
.
pFinally
)
(
syncPromise
(
)
=
>
this
.
api
.
remote
=
previousRemote
)
;
}
loadDump
(
records
)
{
const
reject
=
msg
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
;
if
(
!
Array
.
isArray
(
records
)
)
{
return
reject
(
"
Records
is
not
an
array
.
"
)
;
}
for
(
let
record
of
records
)
{
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
|
|
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
reject
(
"
Record
has
invalid
ID
:
"
+
JSON
.
stringify
(
record
)
)
;
}
if
(
!
record
.
last_modified
)
{
return
reject
(
"
Record
has
no
last_modified
value
:
"
+
JSON
.
stringify
(
record
)
)
;
}
}
return
this
.
list
(
{
}
{
includeDeleted
:
true
}
)
.
then
(
res
=
>
{
return
res
.
data
.
reduce
(
(
acc
record
)
=
>
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
}
)
.
then
(
existingById
=
>
{
return
records
.
filter
(
record
=
>
{
const
localRecord
=
existingById
[
record
.
id
]
;
const
shouldKeep
=
localRecord
=
=
=
undefined
|
|
localRecord
.
_status
=
=
=
"
synced
"
&
&
localRecord
.
last_modified
!
=
=
undefined
&
&
record
.
last_modified
>
localRecord
.
last_modified
;
return
shouldKeep
;
}
)
;
}
)
.
then
(
newRecords
=
>
newRecords
.
map
(
markSynced
)
)
.
then
(
newRecords
=
>
this
.
db
.
loadDump
(
newRecords
)
)
;
}
}
exports
.
default
=
Collection
;
class
CollectionTransaction
{
constructor
(
collection
adapterTransaction
)
{
this
.
collection
=
collection
;
this
.
adapterTransaction
=
adapterTransaction
;
}
getAny
(
id
)
{
const
record
=
this
.
adapterTransaction
.
get
(
id
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
const
res
=
this
.
getAny
(
id
)
;
if
(
!
res
.
data
|
|
!
options
.
includeDeleted
&
&
res
.
data
.
_status
=
=
=
"
deleted
"
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
return
res
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
const
alreadyDeleted
=
existing
&
&
existing
.
_status
=
=
"
deleted
"
;
if
(
!
existing
|
|
alreadyDeleted
&
&
options
.
virtual
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
if
(
options
.
virtual
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
}
else
{
this
.
adapterTransaction
.
delete
(
id
)
;
}
return
{
data
:
existing
permissions
:
{
}
}
;
}
deleteAny
(
id
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
if
(
existing
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
}
return
{
data
:
_extends
(
{
id
}
existing
)
deleted
:
!
!
existing
permissions
:
{
}
}
;
}
create
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
create
a
record
missing
id
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
this
.
adapterTransaction
.
create
(
record
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
const
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
if
(
!
oldRecord
)
{
throw
new
Error
(
Record
with
id
=
{
record
.
id
}
not
found
.
)
;
}
const
newRecord
=
options
.
patch
?
_extends
(
{
}
oldRecord
record
)
:
record
;
const
updated
=
this
.
_updateRaw
(
oldRecord
newRecord
options
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
return
{
data
:
updated
oldRecord
:
oldRecord
permissions
:
{
}
}
;
}
_updateRaw
(
oldRecord
newRecord
{
synced
=
false
}
=
{
}
)
{
const
updated
=
_extends
(
{
}
newRecord
)
;
if
(
oldRecord
&
&
oldRecord
.
last_modified
&
&
!
updated
.
last_modified
)
{
updated
.
last_modified
=
oldRecord
.
last_modified
;
}
const
isIdentical
=
oldRecord
&
&
recordsEqual
(
oldRecord
updated
this
.
localFields
)
;
const
keepSynced
=
isIdentical
&
&
oldRecord
.
_status
=
=
"
synced
"
;
const
neverSynced
=
!
oldRecord
|
|
oldRecord
&
&
oldRecord
.
_status
=
=
"
created
"
;
const
newStatus
=
keepSynced
|
|
synced
?
"
synced
"
:
neverSynced
?
"
created
"
:
"
updated
"
;
return
markStatus
(
updated
newStatus
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
let
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
const
updated
=
this
.
_updateRaw
(
oldRecord
record
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
if
(
oldRecord
&
&
oldRecord
.
_status
=
=
"
deleted
"
)
{
oldRecord
=
undefined
;
}
return
{
data
:
updated
oldRecord
:
oldRecord
permissions
:
{
}
}
;
}
}
exports
.
CollectionTransaction
=
CollectionTransaction
;
}
{
"
.
/
adapters
/
IDB
"
:
5
"
.
/
adapters
/
base
"
:
6
"
.
/
utils
"
:
8
"
uuid
"
:
3
}
]
8
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
sortObjects
=
sortObjects
;
exports
.
filterObjects
=
filterObjects
;
exports
.
reduceRecords
=
reduceRecords
;
exports
.
isUUID
=
isUUID
;
exports
.
waterfall
=
waterfall
;
exports
.
pFinally
=
pFinally
;
exports
.
deepEqual
=
deepEqual
;
exports
.
omitKeys
=
omitKeys
;
const
RE_UUID
=
exports
.
RE_UUID
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
function
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
function
filterObjects
(
filters
list
)
{
return
list
.
filter
(
entry
=
>
{
return
Object
.
keys
(
filters
)
.
every
(
filter
=
>
{
const
value
=
filters
[
filter
]
;
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
)
;
}
function
reduceRecords
(
filters
order
list
)
{
const
filtered
=
filters
?
filterObjects
(
filters
list
)
:
list
;
return
order
?
sortObjects
(
order
filtered
)
:
filtered
;
}
function
isUUID
(
uuid
)
{
return
RE_UUID
.
test
(
uuid
)
;
}
function
waterfall
(
fns
init
)
{
if
(
!
fns
.
length
)
{
return
Promise
.
resolve
(
init
)
;
}
return
fns
.
reduce
(
(
promise
nextFn
)
=
>
{
return
promise
.
then
(
nextFn
)
;
}
Promise
.
resolve
(
init
)
)
;
}
function
pFinally
(
promise
fn
)
{
return
promise
.
then
(
value
=
>
Promise
.
resolve
(
fn
(
)
)
.
then
(
(
)
=
>
value
)
reason
=
>
Promise
.
resolve
(
fn
(
)
)
.
then
(
(
)
=
>
{
throw
reason
;
}
)
)
;
}
function
deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
typeof
a
!
=
=
typeof
b
)
{
return
false
;
}
if
(
!
(
a
instanceof
Object
)
|
|
!
(
b
instanceof
Object
)
)
{
return
false
;
}
if
(
Object
.
keys
(
a
)
.
length
!
=
=
Object
.
keys
(
b
)
.
length
)
{
return
false
;
}
for
(
let
k
in
a
)
{
if
(
!
deepEqual
(
a
[
k
]
b
[
k
]
)
)
{
return
false
;
}
}
return
true
;
}
function
omitKeys
(
obj
keys
=
[
]
)
{
return
Object
.
keys
(
obj
)
.
reduce
(
(
acc
key
)
=
>
{
if
(
keys
.
indexOf
(
key
)
=
=
=
-
1
)
{
acc
[
key
]
=
obj
[
key
]
;
}
return
acc
;
}
{
}
)
;
}
}
{
}
]
}
{
}
[
2
]
)
(
2
)
}
)
;
