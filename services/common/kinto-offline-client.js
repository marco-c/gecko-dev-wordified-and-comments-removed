"
use
strict
"
;
const
global
=
this
;
var
EXPORTED_SYMBOLS
=
[
"
Kinto
"
]
;
(
function
(
f
)
{
if
(
typeof
exports
=
=
=
"
object
"
&
&
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
Kinto
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
(
)
{
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
return
e
}
)
(
)
(
{
1
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_KintoBase
=
require
(
"
.
.
/
src
/
KintoBase
"
)
;
var
_KintoBase2
=
_interopRequireDefault
(
_KintoBase
)
;
var
_base
=
require
(
"
.
.
/
src
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_IDB
=
require
(
"
.
.
/
src
/
adapters
/
IDB
"
)
;
var
_IDB2
=
_interopRequireDefault
(
_IDB
)
;
var
_utils
=
require
(
"
.
.
/
src
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
global
[
"
fetch
"
"
indexedDB
"
]
)
;
const
{
EventEmitter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
EventEmitter
.
jsm
"
{
}
)
;
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
{
KintoHttpClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
class
Kinto
extends
_KintoBase2
.
default
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
IDB
:
_IDB2
.
default
}
;
}
constructor
(
options
=
{
}
)
{
const
events
=
{
}
;
EventEmitter
.
decorate
(
events
)
;
const
defaults
=
{
adapter
:
_IDB2
.
default
events
ApiClass
:
KintoHttpClient
}
;
super
(
{
.
.
.
defaults
.
.
.
options
}
)
;
}
collection
(
collName
options
=
{
}
)
{
const
idSchema
=
{
validate
:
_utils
.
RE_UUID
.
test
.
bind
(
_utils
.
RE_UUID
)
generate
:
function
(
)
{
return
generateUUID
(
)
.
toString
(
)
.
replace
(
/
[
{
}
]
/
g
"
"
)
;
}
}
;
return
super
.
collection
(
collName
{
idSchema
.
.
.
options
}
)
;
}
}
exports
.
default
=
Kinto
;
if
(
typeof
module
=
=
=
"
object
"
)
{
module
.
exports
=
Kinto
;
}
}
{
"
.
.
/
src
/
KintoBase
"
:
3
"
.
.
/
src
/
adapters
/
IDB
"
:
4
"
.
.
/
src
/
adapters
/
base
"
:
5
"
.
.
/
src
/
utils
"
:
7
}
]
2
:
[
function
(
require
module
exports
)
{
}
{
}
]
3
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_collection
=
require
(
"
.
/
collection
"
)
;
var
_collection2
=
_interopRequireDefault
(
_collection
)
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
DEFAULT_BUCKET_NAME
=
"
default
"
;
const
DEFAULT_REMOTE
=
"
http
:
/
/
localhost
:
8888
/
v1
"
;
const
DEFAULT_RETRY
=
1
;
class
KintoBase
{
static
get
adapters
(
)
{
return
{
BaseAdapter
:
_base2
.
default
}
;
}
static
get
syncStrategy
(
)
{
return
_collection2
.
default
.
strategy
;
}
constructor
(
options
=
{
}
)
{
const
defaults
=
{
bucket
:
DEFAULT_BUCKET_NAME
remote
:
DEFAULT_REMOTE
retry
:
DEFAULT_RETRY
}
;
this
.
_options
=
{
.
.
.
defaults
.
.
.
options
}
;
if
(
!
this
.
_options
.
adapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
{
ApiClass
events
headers
remote
requestMode
retry
timeout
}
=
this
.
_options
;
this
.
api
=
new
ApiClass
(
remote
{
events
headers
requestMode
retry
timeout
}
)
;
this
.
events
=
this
.
_options
.
events
;
}
collection
(
collName
options
=
{
}
)
{
if
(
!
collName
)
{
throw
new
Error
(
"
missing
collection
name
"
)
;
}
const
{
bucket
events
adapter
adapterOptions
dbPrefix
}
=
{
.
.
.
this
.
_options
.
.
.
options
}
;
const
{
idSchema
remoteTransformers
hooks
localFields
}
=
options
;
return
new
_collection2
.
default
(
bucket
collName
this
.
api
{
events
adapter
adapterOptions
dbPrefix
idSchema
remoteTransformers
hooks
localFields
}
)
;
}
}
exports
.
default
=
KintoBase
;
}
{
"
.
/
adapters
/
base
"
:
5
"
.
/
collection
"
:
6
}
]
4
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_base
=
require
(
"
.
/
base
.
js
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_utils
=
require
(
"
.
.
/
utils
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
INDEXED_FIELDS
=
[
"
id
"
"
_status
"
"
last_modified
"
]
;
const
cursorHandlers
=
{
all
(
filters
done
)
{
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
if
(
(
0
_utils
.
filterObject
)
(
filters
cursor
.
value
)
)
{
results
.
push
(
cursor
.
value
)
;
}
cursor
.
continue
(
)
;
}
else
{
done
(
results
)
;
}
}
;
}
in
(
values
done
)
{
if
(
values
.
length
=
=
=
0
)
{
return
done
(
[
]
)
;
}
const
sortedValues
=
[
]
.
slice
.
call
(
values
)
.
sort
(
)
;
const
results
=
[
]
;
return
function
(
event
)
{
const
cursor
=
event
.
target
.
result
;
if
(
!
cursor
)
{
done
(
results
)
;
return
;
}
const
{
key
value
}
=
cursor
;
let
i
=
0
;
while
(
key
>
sortedValues
[
i
]
)
{
+
+
i
;
if
(
i
=
=
=
sortedValues
.
length
)
{
done
(
results
)
;
return
;
}
}
if
(
key
=
=
=
sortedValues
[
i
]
)
{
results
.
push
(
value
)
;
cursor
.
continue
(
)
;
}
else
{
cursor
.
continue
(
sortedValues
[
i
]
)
;
}
}
;
}
}
;
function
findIndexedField
(
filters
)
{
const
filteredFields
=
Object
.
keys
(
filters
)
;
const
indexedFields
=
filteredFields
.
filter
(
field
=
>
{
return
INDEXED_FIELDS
.
includes
(
field
)
;
}
)
;
return
indexedFields
[
0
]
;
}
function
createListRequest
(
store
indexField
value
filters
done
)
{
if
(
!
indexField
)
{
const
request
=
store
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
filters
done
)
;
return
request
;
}
if
(
Array
.
isArray
(
value
)
)
{
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
)
;
request
.
onsuccess
=
cursorHandlers
.
in
(
value
done
)
;
return
request
;
}
const
request
=
store
.
index
(
indexField
)
.
openCursor
(
IDBKeyRange
.
only
(
value
)
)
;
request
.
onsuccess
=
cursorHandlers
.
all
(
filters
done
)
;
return
request
;
}
class
IDB
extends
_base2
.
default
{
constructor
(
dbname
)
{
super
(
)
;
this
.
_db
=
null
;
this
.
dbname
=
dbname
;
}
_handleError
(
method
err
)
{
const
error
=
new
Error
(
method
+
"
(
)
"
+
err
.
message
)
;
error
.
stack
=
err
.
stack
;
throw
error
;
}
open
(
)
{
if
(
this
.
_db
)
{
return
Promise
.
resolve
(
this
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
request
=
indexedDB
.
open
(
this
.
dbname
1
)
;
request
.
onupgradeneeded
=
event
=
>
{
const
db
=
event
.
target
.
result
;
const
collStore
=
db
.
createObjectStore
(
this
.
dbname
{
keyPath
:
"
id
"
}
)
;
collStore
.
createIndex
(
"
id
"
"
id
"
{
unique
:
true
}
)
;
collStore
.
createIndex
(
"
_status
"
"
_status
"
)
;
collStore
.
createIndex
(
"
last_modified
"
"
last_modified
"
)
;
const
metaStore
=
db
.
createObjectStore
(
"
__meta__
"
{
keyPath
:
"
name
"
}
)
;
metaStore
.
createIndex
(
"
name
"
"
name
"
{
unique
:
true
}
)
;
}
;
request
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
request
.
onsuccess
=
event
=
>
{
this
.
_db
=
event
.
target
.
result
;
resolve
(
this
)
;
}
;
}
)
;
}
close
(
)
{
if
(
this
.
_db
)
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
}
return
Promise
.
resolve
(
)
;
}
prepare
(
mode
=
undefined
name
=
null
)
{
const
storeName
=
name
|
|
this
.
dbname
;
const
transaction
=
mode
?
this
.
_db
.
transaction
(
[
storeName
]
mode
)
:
this
.
_db
.
transaction
(
[
storeName
]
)
;
const
store
=
transaction
.
objectStore
(
storeName
)
;
return
{
transaction
store
}
;
}
async
clear
(
)
{
try
{
await
this
.
open
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
)
;
store
.
clear
(
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
(
)
=
>
resolve
(
)
;
}
)
;
}
catch
(
e
)
{
this
.
_handleError
(
"
clear
"
e
)
;
}
}
async
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
await
this
.
open
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
)
;
const
ids
=
options
.
preload
;
store
.
index
(
"
id
"
)
.
openCursor
(
)
.
onsuccess
=
cursorHandlers
.
in
(
ids
records
=
>
{
const
preloaded
=
records
.
reduce
(
(
acc
record
)
=
>
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
const
proxy
=
transactionProxy
(
store
preloaded
)
;
let
result
;
try
{
result
=
callback
(
proxy
)
;
}
catch
(
e
)
{
transaction
.
abort
(
)
;
reject
(
e
)
;
}
if
(
result
instanceof
Promise
)
{
reject
(
new
Error
(
"
execute
(
)
callback
should
not
return
a
Promise
.
"
)
)
;
}
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
result
)
;
}
)
;
}
)
;
}
async
get
(
id
)
{
try
{
await
this
.
open
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
)
;
const
request
=
store
.
get
(
id
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
(
)
=
>
resolve
(
request
.
result
)
;
}
)
;
}
catch
(
e
)
{
this
.
_handleError
(
"
get
"
e
)
;
}
}
async
list
(
params
=
{
filters
:
{
}
}
)
{
const
{
filters
}
=
params
;
const
indexField
=
findIndexedField
(
filters
)
;
const
value
=
filters
[
indexField
]
;
try
{
await
this
.
open
(
)
;
const
results
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
results
=
[
]
;
const
remainingFilters
=
(
0
_utils
.
omitKeys
)
(
filters
indexField
)
;
const
{
transaction
store
}
=
this
.
prepare
(
)
;
createListRequest
(
store
indexField
value
remainingFilters
_results
=
>
{
results
=
_results
;
}
)
;
transaction
.
onerror
=
event
=
>
reject
(
new
Error
(
event
.
target
.
error
)
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
results
)
;
}
)
;
return
params
.
order
?
(
0
_utils
.
sortObjects
)
(
params
.
order
results
)
:
results
;
}
catch
(
e
)
{
this
.
_handleError
(
"
list
"
e
)
;
}
}
async
saveLastModified
(
lastModified
)
{
const
value
=
parseInt
(
lastModified
10
)
|
|
null
;
await
this
.
open
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
"
readwrite
"
"
__meta__
"
)
;
store
.
put
(
{
name
:
"
lastModified
"
value
:
value
}
)
;
transaction
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
transaction
.
oncomplete
=
event
=
>
resolve
(
value
)
;
}
)
;
}
async
getLastModified
(
)
{
await
this
.
open
(
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
transaction
store
}
=
this
.
prepare
(
undefined
"
__meta__
"
)
;
const
request
=
store
.
get
(
"
lastModified
"
)
;
transaction
.
onerror
=
event
=
>
reject
(
event
.
target
.
error
)
;
transaction
.
oncomplete
=
event
=
>
{
resolve
(
request
.
result
&
&
request
.
result
.
value
|
|
null
)
;
}
;
}
)
;
}
async
loadDump
(
records
)
{
try
{
await
this
.
execute
(
transaction
=
>
{
records
.
forEach
(
record
=
>
transaction
.
update
(
record
)
)
;
}
)
;
const
previousLastModified
=
await
this
.
getLastModified
(
)
;
const
lastModified
=
Math
.
max
(
.
.
.
records
.
map
(
record
=
>
record
.
last_modified
)
)
;
if
(
lastModified
>
previousLastModified
)
{
await
this
.
saveLastModified
(
lastModified
)
;
}
return
records
;
}
catch
(
e
)
{
this
.
_handleError
(
"
loadDump
"
e
)
;
}
}
}
exports
.
default
=
IDB
;
function
transactionProxy
(
store
preloaded
=
[
]
)
{
return
{
create
(
record
)
{
store
.
add
(
record
)
;
}
update
(
record
)
{
store
.
put
(
record
)
;
}
delete
(
id
)
{
store
.
delete
(
id
)
;
}
get
(
id
)
{
return
preloaded
[
id
]
;
}
}
;
}
}
{
"
.
.
/
utils
"
:
7
"
.
/
base
.
js
"
:
5
}
]
5
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
class
BaseAdapter
{
clear
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
execute
(
callback
options
=
{
preload
:
[
]
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
get
(
id
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
list
(
params
=
{
filters
:
{
}
order
:
"
"
}
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
saveLastModified
(
lastModified
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
getLastModified
(
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
loadDump
(
records
)
{
throw
new
Error
(
"
Not
Implemented
.
"
)
;
}
}
exports
.
default
=
BaseAdapter
;
}
{
}
]
6
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
CollectionTransaction
=
exports
.
SyncResultObject
=
undefined
;
exports
.
recordsEqual
=
recordsEqual
;
var
_base
=
require
(
"
.
/
adapters
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_IDB
=
require
(
"
.
/
adapters
/
IDB
"
)
;
var
_IDB2
=
_interopRequireDefault
(
_IDB
)
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_uuid
=
require
(
"
uuid
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
RECORD_FIELDS_TO_CLEAN
=
[
"
_status
"
]
;
const
AVAILABLE_HOOKS
=
[
"
incoming
-
changes
"
]
;
function
recordsEqual
(
a
b
localFields
=
[
]
)
{
const
fieldsToClean
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
[
"
last_modified
"
]
)
.
concat
(
localFields
)
;
const
cleanLocal
=
r
=
>
(
0
_utils
.
omitKeys
)
(
r
fieldsToClean
)
;
return
(
0
_utils
.
deepEqual
)
(
cleanLocal
(
a
)
cleanLocal
(
b
)
)
;
}
class
SyncResultObject
{
static
get
defaults
(
)
{
return
{
ok
:
true
lastModified
:
null
errors
:
[
]
created
:
[
]
updated
:
[
]
deleted
:
[
]
published
:
[
]
conflicts
:
[
]
skipped
:
[
]
resolved
:
[
]
}
;
}
constructor
(
)
{
this
.
ok
=
true
;
Object
.
assign
(
this
SyncResultObject
.
defaults
)
;
}
add
(
type
entries
)
{
if
(
!
Array
.
isArray
(
this
[
type
]
)
)
{
return
;
}
if
(
!
Array
.
isArray
(
entries
)
)
{
entries
=
[
entries
]
;
}
const
recordsWithoutId
=
new
Set
(
)
;
const
recordsById
=
new
Map
(
)
;
function
addOneRecord
(
record
)
{
if
(
!
record
.
id
)
{
recordsWithoutId
.
add
(
record
)
;
}
else
{
recordsById
.
set
(
record
.
id
record
)
;
}
}
this
[
type
]
.
forEach
(
addOneRecord
)
;
entries
.
forEach
(
addOneRecord
)
;
this
[
type
]
=
Array
.
from
(
recordsById
.
values
(
)
)
.
concat
(
Array
.
from
(
recordsWithoutId
)
)
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
reset
(
type
)
{
this
[
type
]
=
SyncResultObject
.
defaults
[
type
]
;
this
.
ok
=
this
.
errors
.
length
+
this
.
conflicts
.
length
=
=
=
0
;
return
this
;
}
}
exports
.
SyncResultObject
=
SyncResultObject
;
function
createUUIDSchema
(
)
{
return
{
generate
(
)
{
return
(
0
_uuid
.
v4
)
(
)
;
}
validate
(
id
)
{
return
(
0
_utils
.
isUUID
)
(
id
)
;
}
}
;
}
function
markStatus
(
record
status
)
{
return
{
.
.
.
record
_status
:
status
}
;
}
function
markDeleted
(
record
)
{
return
markStatus
(
record
"
deleted
"
)
;
}
function
markSynced
(
record
)
{
return
markStatus
(
record
"
synced
"
)
;
}
function
importChange
(
transaction
remote
localFields
)
{
const
local
=
transaction
.
get
(
remote
.
id
)
;
if
(
!
local
)
{
if
(
remote
.
deleted
)
{
return
{
type
:
"
skipped
"
data
:
remote
}
;
}
const
synced
=
markSynced
(
remote
)
;
transaction
.
create
(
synced
)
;
return
{
type
:
"
created
"
data
:
synced
}
;
}
const
isIdentical
=
recordsEqual
(
local
remote
localFields
)
;
const
synced
=
{
.
.
.
local
.
.
.
markSynced
(
remote
)
}
;
if
(
local
.
_status
!
=
=
"
synced
"
)
{
if
(
local
.
_status
=
=
=
"
deleted
"
)
{
return
{
type
:
"
skipped
"
data
:
local
}
;
}
if
(
isIdentical
)
{
transaction
.
update
(
synced
)
;
return
{
type
:
"
updated
"
data
:
{
old
:
local
new
:
synced
}
}
;
}
if
(
local
.
last_modified
!
=
=
undefined
&
&
local
.
last_modified
=
=
=
remote
.
last_modified
)
{
return
{
type
:
"
void
"
}
;
}
return
{
type
:
"
conflicts
"
data
:
{
type
:
"
incoming
"
local
:
local
remote
:
remote
}
}
;
}
if
(
remote
.
deleted
)
{
transaction
.
delete
(
remote
.
id
)
;
return
{
type
:
"
deleted
"
data
:
local
}
;
}
transaction
.
update
(
synced
)
;
const
type
=
isIdentical
?
"
void
"
:
"
updated
"
;
return
{
type
data
:
{
old
:
local
new
:
synced
}
}
;
}
class
Collection
{
constructor
(
bucket
name
api
options
=
{
}
)
{
this
.
_bucket
=
bucket
;
this
.
_name
=
name
;
this
.
_lastModified
=
null
;
const
DBAdapter
=
options
.
adapter
|
|
_IDB2
.
default
;
if
(
!
DBAdapter
)
{
throw
new
Error
(
"
No
adapter
provided
"
)
;
}
const
dbPrefix
=
options
.
dbPrefix
|
|
"
"
;
const
db
=
new
DBAdapter
(
{
dbPrefix
}
{
bucket
}
/
{
name
}
options
.
adapterOptions
)
;
if
(
!
(
db
instanceof
_base2
.
default
)
)
{
throw
new
Error
(
"
Unsupported
adapter
.
"
)
;
}
this
.
db
=
db
;
this
.
api
=
api
;
this
.
events
=
options
.
events
;
this
.
idSchema
=
this
.
_validateIdSchema
(
options
.
idSchema
)
;
this
.
remoteTransformers
=
this
.
_validateRemoteTransformers
(
options
.
remoteTransformers
)
;
this
.
hooks
=
this
.
_validateHooks
(
options
.
hooks
)
;
this
.
localFields
=
options
.
localFields
|
|
[
]
;
}
get
name
(
)
{
return
this
.
_name
;
}
get
bucket
(
)
{
return
this
.
_bucket
;
}
get
lastModified
(
)
{
return
this
.
_lastModified
;
}
static
get
strategy
(
)
{
return
{
CLIENT_WINS
:
"
client_wins
"
SERVER_WINS
:
"
server_wins
"
MANUAL
:
"
manual
"
}
;
}
_validateIdSchema
(
idSchema
)
{
if
(
typeof
idSchema
=
=
=
"
undefined
"
)
{
return
createUUIDSchema
(
)
;
}
if
(
typeof
idSchema
!
=
=
"
object
"
)
{
throw
new
Error
(
"
idSchema
must
be
an
object
.
"
)
;
}
else
if
(
typeof
idSchema
.
generate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
generate
function
.
"
)
;
}
else
if
(
typeof
idSchema
.
validate
!
=
=
"
function
"
)
{
throw
new
Error
(
"
idSchema
must
provide
a
validate
function
.
"
)
;
}
return
idSchema
;
}
_validateRemoteTransformers
(
remoteTransformers
)
{
if
(
typeof
remoteTransformers
=
=
=
"
undefined
"
)
{
return
[
]
;
}
if
(
!
Array
.
isArray
(
remoteTransformers
)
)
{
throw
new
Error
(
"
remoteTransformers
should
be
an
array
.
"
)
;
}
return
remoteTransformers
.
map
(
transformer
=
>
{
if
(
typeof
transformer
!
=
=
"
object
"
)
{
throw
new
Error
(
"
A
transformer
must
be
an
object
.
"
)
;
}
else
if
(
typeof
transformer
.
encode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
an
encode
function
.
"
)
;
}
else
if
(
typeof
transformer
.
decode
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
transformer
must
provide
a
decode
function
.
"
)
;
}
return
transformer
;
}
)
;
}
_validateHook
(
hook
)
{
if
(
!
Array
.
isArray
(
hook
)
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
hook
.
map
(
fn
=
>
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
throw
new
Error
(
"
A
hook
definition
should
be
an
array
of
functions
.
"
)
;
}
return
fn
;
}
)
;
}
_validateHooks
(
hooks
)
{
if
(
typeof
hooks
=
=
=
"
undefined
"
)
{
return
{
}
;
}
if
(
Array
.
isArray
(
hooks
)
)
{
throw
new
Error
(
"
hooks
should
be
an
object
not
an
array
.
"
)
;
}
if
(
typeof
hooks
!
=
=
"
object
"
)
{
throw
new
Error
(
"
hooks
should
be
an
object
.
"
)
;
}
const
validatedHooks
=
{
}
;
for
(
const
hook
in
hooks
)
{
if
(
!
AVAILABLE_HOOKS
.
includes
(
hook
)
)
{
throw
new
Error
(
"
The
hook
should
be
one
of
"
+
AVAILABLE_HOOKS
.
join
(
"
"
)
)
;
}
validatedHooks
[
hook
]
=
this
.
_validateHook
(
hooks
[
hook
]
)
;
}
return
validatedHooks
;
}
async
clear
(
)
{
await
this
.
db
.
clear
(
)
;
await
this
.
db
.
saveLastModified
(
null
)
;
return
{
data
:
[
]
permissions
:
{
}
}
;
}
_encodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
Promise
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
encode
(
record
)
;
}
)
record
)
;
}
_decodeRecord
(
type
record
)
{
if
(
!
this
[
{
type
}
Transformers
]
.
length
)
{
return
Promise
.
resolve
(
record
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
[
{
type
}
Transformers
]
.
reverse
(
)
.
map
(
transformer
=
>
{
return
record
=
>
transformer
.
decode
(
record
)
;
}
)
record
)
;
}
create
(
record
options
=
{
useRecordId
:
false
synced
:
false
}
)
{
const
reject
=
msg
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
;
if
(
typeof
record
!
=
=
"
object
"
)
{
return
reject
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
(
options
.
synced
|
|
options
.
useRecordId
)
&
&
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Missing
required
Id
;
synced
and
useRecordId
options
require
one
"
)
;
}
if
(
!
options
.
synced
&
&
!
options
.
useRecordId
&
&
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
reject
(
"
Extraneous
Id
;
can
'
t
create
a
record
having
one
set
.
"
)
;
}
const
newRecord
=
{
.
.
.
record
id
:
options
.
synced
|
|
options
.
useRecordId
?
record
.
id
:
this
.
idSchema
.
generate
(
record
)
_status
:
options
.
synced
?
"
synced
"
:
"
created
"
}
;
if
(
!
this
.
idSchema
.
validate
(
newRecord
.
id
)
)
{
return
reject
(
Invalid
Id
:
{
newRecord
.
id
}
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
create
(
newRecord
)
{
preloadIds
:
[
newRecord
.
id
]
}
)
.
catch
(
err
=
>
{
if
(
options
.
useRecordId
)
{
throw
new
Error
(
"
Couldn
'
t
create
record
.
It
may
have
been
virtually
deleted
.
"
)
;
}
throw
err
;
}
)
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
Promise
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
Promise
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
Promise
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
update
(
record
options
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
return
Promise
.
reject
(
new
Error
(
"
Record
is
not
an
object
.
"
)
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
return
Promise
.
reject
(
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
)
;
}
if
(
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
return
Promise
.
reject
(
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
)
;
}
return
this
.
execute
(
txn
=
>
txn
.
upsert
(
record
)
{
preloadIds
:
[
record
.
id
]
}
)
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
return
this
.
execute
(
txn
=
>
txn
.
get
(
id
options
)
{
preloadIds
:
[
id
]
}
)
;
}
getAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
getAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
return
this
.
execute
(
transaction
=
>
{
return
transaction
.
delete
(
id
options
)
;
}
{
preloadIds
:
[
id
]
}
)
;
}
async
deleteAll
(
)
{
const
{
data
}
=
await
this
.
list
(
{
}
{
includeDeleted
:
false
}
)
;
const
recordIds
=
data
.
map
(
record
=
>
record
.
id
)
;
return
this
.
execute
(
transaction
=
>
{
return
transaction
.
deleteAll
(
recordIds
)
;
}
{
preloadIds
:
recordIds
}
)
;
}
deleteAny
(
id
)
{
return
this
.
execute
(
txn
=
>
txn
.
deleteAny
(
id
)
{
preloadIds
:
[
id
]
}
)
;
}
async
list
(
params
=
{
}
options
=
{
includeDeleted
:
false
}
)
{
params
=
{
order
:
"
-
last_modified
"
filters
:
{
}
.
.
.
params
}
;
const
results
=
await
this
.
db
.
list
(
params
)
;
let
data
=
results
;
if
(
!
options
.
includeDeleted
)
{
data
=
results
.
filter
(
record
=
>
record
.
_status
!
=
=
"
deleted
"
)
;
}
return
{
data
permissions
:
{
}
}
;
}
async
importChanges
(
syncResultObject
decodedChanges
strategy
=
Collection
.
strategy
.
MANUAL
)
{
try
{
const
{
imports
resolved
}
=
await
this
.
db
.
execute
(
transaction
=
>
{
const
imports
=
decodedChanges
.
map
(
remote
=
>
{
return
importChange
(
transaction
remote
this
.
localFields
)
;
}
)
;
const
conflicts
=
imports
.
filter
(
i
=
>
i
.
type
=
=
=
"
conflicts
"
)
.
map
(
i
=
>
i
.
data
)
;
const
resolved
=
this
.
_handleConflicts
(
transaction
conflicts
strategy
)
;
return
{
imports
resolved
}
;
}
{
preload
:
decodedChanges
.
map
(
record
=
>
record
.
id
)
}
)
;
imports
.
forEach
(
(
{
type
data
}
)
=
>
syncResultObject
.
add
(
type
data
)
)
;
if
(
resolved
.
length
>
0
)
{
syncResultObject
.
reset
(
"
conflicts
"
)
.
add
(
"
resolved
"
resolved
)
;
}
}
catch
(
err
)
{
const
data
=
{
type
:
"
incoming
"
message
:
err
.
message
stack
:
err
.
stack
}
;
syncResultObject
.
add
(
"
errors
"
data
)
;
}
return
syncResultObject
;
}
async
_applyPushedResults
(
syncResultObject
toApplyLocally
conflicts
strategy
=
Collection
.
strategy
.
MANUAL
)
{
const
toDeleteLocally
=
toApplyLocally
.
filter
(
r
=
>
r
.
deleted
)
;
const
toUpdateLocally
=
toApplyLocally
.
filter
(
r
=
>
!
r
.
deleted
)
;
const
{
published
resolved
}
=
await
this
.
db
.
execute
(
transaction
=
>
{
const
updated
=
toUpdateLocally
.
map
(
record
=
>
{
const
synced
=
markSynced
(
record
)
;
transaction
.
update
(
synced
)
;
return
synced
;
}
)
;
const
deleted
=
toDeleteLocally
.
map
(
record
=
>
{
transaction
.
delete
(
record
.
id
)
;
return
{
id
:
record
.
id
deleted
:
true
}
;
}
)
;
const
published
=
updated
.
concat
(
deleted
)
;
const
resolved
=
this
.
_handleConflicts
(
transaction
conflicts
strategy
)
;
return
{
published
resolved
}
;
}
)
;
syncResultObject
.
add
(
"
published
"
published
)
;
if
(
resolved
.
length
>
0
)
{
syncResultObject
.
reset
(
"
conflicts
"
)
.
reset
(
"
resolved
"
)
.
add
(
"
resolved
"
resolved
)
;
}
return
syncResultObject
;
}
_handleConflicts
(
transaction
conflicts
strategy
)
{
if
(
strategy
=
=
=
Collection
.
strategy
.
MANUAL
)
{
return
[
]
;
}
return
conflicts
.
map
(
conflict
=
>
{
const
resolution
=
strategy
=
=
=
Collection
.
strategy
.
CLIENT_WINS
?
conflict
.
local
:
conflict
.
remote
;
const
rejected
=
strategy
=
=
=
Collection
.
strategy
.
CLIENT_WINS
?
conflict
.
remote
:
conflict
.
local
;
let
accepted
status
id
;
if
(
resolution
=
=
=
null
)
{
transaction
.
delete
(
conflict
.
local
.
id
)
;
accepted
=
null
;
status
=
"
synced
"
;
id
=
conflict
.
local
.
id
;
}
else
{
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
accepted
=
updated
;
status
=
updated
.
_status
;
id
=
updated
.
id
;
}
return
{
rejected
accepted
id
_status
:
status
}
;
}
)
;
}
execute
(
doOperations
{
preloadIds
=
[
]
}
=
{
}
)
{
for
(
const
id
of
preloadIds
)
{
if
(
!
this
.
idSchema
.
validate
(
id
)
)
{
return
Promise
.
reject
(
Error
(
Invalid
Id
:
{
id
}
)
)
;
}
}
return
this
.
db
.
execute
(
transaction
=
>
{
const
txn
=
new
CollectionTransaction
(
this
transaction
)
;
const
result
=
doOperations
(
txn
)
;
txn
.
emitEvents
(
)
;
return
result
;
}
{
preload
:
preloadIds
}
)
;
}
async
resetSyncStatus
(
)
{
const
unsynced
=
await
this
.
list
(
{
filters
:
{
_status
:
[
"
deleted
"
"
synced
"
]
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
;
await
this
.
db
.
execute
(
transaction
=
>
{
unsynced
.
data
.
forEach
(
record
=
>
{
if
(
record
.
_status
=
=
=
"
deleted
"
)
{
transaction
.
delete
(
record
.
id
)
;
}
else
{
transaction
.
update
(
{
.
.
.
record
last_modified
:
undefined
_status
:
"
created
"
}
)
;
}
}
)
;
}
)
;
this
.
_lastModified
=
null
;
await
this
.
db
.
saveLastModified
(
null
)
;
return
unsynced
.
data
.
length
;
}
async
gatherLocalChanges
(
)
{
const
unsynced
=
await
this
.
list
(
{
filters
:
{
_status
:
[
"
created
"
"
updated
"
]
}
order
:
"
"
}
)
;
const
deleted
=
await
this
.
list
(
{
filters
:
{
_status
:
"
deleted
"
}
order
:
"
"
}
{
includeDeleted
:
true
}
)
;
return
await
Promise
.
all
(
unsynced
.
data
.
concat
(
deleted
.
data
)
.
map
(
this
.
_encodeRecord
.
bind
(
this
"
remote
"
)
)
)
;
}
async
pullChanges
(
client
syncResultObject
options
=
{
}
)
{
if
(
!
syncResultObject
.
ok
)
{
return
syncResultObject
;
}
const
since
=
this
.
lastModified
?
this
.
lastModified
:
await
this
.
db
.
getLastModified
(
)
;
options
=
{
strategy
:
Collection
.
strategy
.
MANUAL
lastModified
:
since
headers
:
{
}
.
.
.
options
}
;
let
filters
;
if
(
options
.
exclude
)
{
const
exclude_id
=
options
.
exclude
.
slice
(
0
50
)
.
map
(
r
=
>
r
.
id
)
.
join
(
"
"
)
;
filters
=
{
exclude_id
}
;
}
const
{
data
last_modified
}
=
await
client
.
listRecords
(
{
since
:
options
.
lastModified
?
{
options
.
lastModified
}
:
undefined
headers
:
options
.
headers
retry
:
options
.
retry
pages
:
Infinity
filters
}
)
;
const
unquoted
=
last_modified
?
parseInt
(
last_modified
10
)
:
undefined
;
const
localSynced
=
options
.
lastModified
;
const
serverChanged
=
unquoted
>
options
.
lastModified
;
const
emptyCollection
=
data
.
length
=
=
=
0
;
if
(
!
options
.
exclude
&
&
localSynced
&
&
serverChanged
&
&
emptyCollection
)
{
throw
Error
(
"
Server
has
been
flushed
.
"
)
;
}
syncResultObject
.
lastModified
=
unquoted
;
const
decodedChanges
=
await
Promise
.
all
(
data
.
map
(
change
=
>
{
return
this
.
_decodeRecord
(
"
remote
"
change
)
;
}
)
)
;
const
payload
=
{
lastModified
:
unquoted
changes
:
decodedChanges
}
;
const
afterHooks
=
await
this
.
applyHook
(
"
incoming
-
changes
"
payload
)
;
if
(
afterHooks
.
changes
.
length
>
0
)
{
await
this
.
importChanges
(
syncResultObject
afterHooks
.
changes
options
.
strategy
)
;
}
return
syncResultObject
;
}
applyHook
(
hookName
payload
)
{
if
(
typeof
this
.
hooks
[
hookName
]
=
=
"
undefined
"
)
{
return
Promise
.
resolve
(
payload
)
;
}
return
(
0
_utils
.
waterfall
)
(
this
.
hooks
[
hookName
]
.
map
(
hook
=
>
{
return
record
=
>
{
const
result
=
hook
(
payload
this
)
;
const
resultThenable
=
result
&
&
typeof
result
.
then
=
=
=
"
function
"
;
const
resultChanges
=
result
&
&
result
.
hasOwnProperty
(
"
changes
"
)
;
if
(
!
(
resultThenable
|
|
resultChanges
)
)
{
throw
new
Error
(
Invalid
return
value
for
hook
:
{
JSON
.
stringify
(
result
)
}
has
no
'
then
(
)
'
or
'
changes
'
properties
)
;
}
return
result
;
}
;
}
)
payload
)
;
}
async
pushChanges
(
client
changes
syncResultObject
options
=
{
}
)
{
if
(
!
syncResultObject
.
ok
)
{
return
syncResultObject
;
}
const
safe
=
!
options
.
strategy
|
|
options
.
strategy
!
=
=
Collection
.
CLIENT_WINS
;
const
toDelete
=
changes
.
filter
(
r
=
>
r
.
_status
=
=
"
deleted
"
)
;
const
toSync
=
changes
.
filter
(
r
=
>
r
.
_status
!
=
"
deleted
"
)
;
const
synced
=
await
client
.
batch
(
batch
=
>
{
toDelete
.
forEach
(
r
=
>
{
if
(
r
.
last_modified
)
{
batch
.
deleteRecord
(
r
)
;
}
}
)
;
toSync
.
forEach
(
r
=
>
{
const
published
=
this
.
cleanLocalFields
(
r
)
;
if
(
r
.
_status
=
=
=
"
created
"
)
{
batch
.
createRecord
(
published
)
;
}
else
{
batch
.
updateRecord
(
published
)
;
}
}
)
;
}
{
headers
:
options
.
headers
retry
:
options
.
retry
safe
aggregate
:
true
}
)
;
syncResultObject
.
add
(
"
errors
"
synced
.
errors
.
map
(
e
=
>
(
{
.
.
.
e
type
:
"
outgoing
"
}
)
)
)
;
const
conflicts
=
[
]
;
for
(
const
{
type
local
remote
}
of
synced
.
conflicts
)
{
const
safeLocal
=
local
&
&
local
.
data
|
|
{
id
:
remote
.
id
}
;
const
realLocal
=
await
this
.
_decodeRecord
(
"
remote
"
safeLocal
)
;
const
realRemote
=
remote
&
&
(
await
this
.
_decodeRecord
(
"
remote
"
remote
)
)
;
const
conflict
=
{
type
local
:
realLocal
remote
:
realRemote
}
;
conflicts
.
push
(
conflict
)
;
}
syncResultObject
.
add
(
"
conflicts
"
conflicts
)
;
const
missingRemotely
=
synced
.
skipped
.
map
(
r
=
>
(
{
.
.
.
r
deleted
:
true
}
)
)
;
const
published
=
synced
.
published
.
map
(
c
=
>
c
.
data
)
;
const
toApplyLocally
=
published
.
concat
(
missingRemotely
)
;
const
decoded
=
await
Promise
.
all
(
toApplyLocally
.
map
(
record
=
>
{
return
this
.
_decodeRecord
(
"
remote
"
record
)
;
}
)
)
;
if
(
decoded
.
length
>
0
|
|
conflicts
.
length
>
0
)
{
await
this
.
_applyPushedResults
(
syncResultObject
decoded
conflicts
options
.
strategy
)
;
}
return
syncResultObject
;
}
cleanLocalFields
(
record
)
{
const
localKeys
=
RECORD_FIELDS_TO_CLEAN
.
concat
(
this
.
localFields
)
;
return
(
0
_utils
.
omitKeys
)
(
record
localKeys
)
;
}
resolve
(
conflict
resolution
)
{
return
this
.
db
.
execute
(
transaction
=
>
{
const
updated
=
this
.
_resolveRaw
(
conflict
resolution
)
;
transaction
.
update
(
updated
)
;
return
{
data
:
updated
permissions
:
{
}
}
;
}
)
;
}
_resolveRaw
(
conflict
resolution
)
{
const
resolved
=
{
.
.
.
resolution
last_modified
:
conflict
.
remote
&
&
conflict
.
remote
.
last_modified
}
;
const
synced
=
(
0
_utils
.
deepEqual
)
(
resolved
conflict
.
remote
)
;
return
markStatus
(
resolved
synced
?
"
synced
"
:
"
updated
"
)
;
}
async
sync
(
options
=
{
strategy
:
Collection
.
strategy
.
MANUAL
headers
:
{
}
retry
:
1
ignoreBackoff
:
false
bucket
:
null
collection
:
null
remote
:
null
}
)
{
options
=
{
.
.
.
options
bucket
:
options
.
bucket
|
|
this
.
bucket
collection
:
options
.
collection
|
|
this
.
name
}
;
const
previousRemote
=
this
.
api
.
remote
;
if
(
options
.
remote
)
{
this
.
api
.
remote
=
options
.
remote
;
}
if
(
!
options
.
ignoreBackoff
&
&
this
.
api
.
backoff
>
0
)
{
const
seconds
=
Math
.
ceil
(
this
.
api
.
backoff
/
1000
)
;
return
Promise
.
reject
(
new
Error
(
Server
is
asking
clients
to
back
off
;
retry
in
{
seconds
}
s
or
use
the
ignoreBackoff
option
.
)
)
;
}
const
client
=
this
.
api
.
bucket
(
options
.
bucket
)
.
collection
(
options
.
collection
)
;
const
result
=
new
SyncResultObject
(
)
;
try
{
await
this
.
pullChanges
(
client
result
options
)
;
const
{
lastModified
}
=
result
;
const
toSync
=
await
this
.
gatherLocalChanges
(
)
;
await
this
.
pushChanges
(
client
toSync
result
options
)
;
const
resolvedUnsynced
=
result
.
resolved
.
filter
(
r
=
>
r
.
_status
!
=
=
"
synced
"
)
;
if
(
resolvedUnsynced
.
length
>
0
)
{
const
resolvedEncoded
=
await
Promise
.
all
(
resolvedUnsynced
.
map
(
resolution
=
>
{
let
record
=
resolution
.
accepted
;
if
(
record
=
=
=
null
)
{
record
=
{
id
:
resolution
.
id
_status
:
resolution
.
_status
}
;
}
return
this
.
_encodeRecord
(
"
remote
"
record
)
;
}
)
)
;
await
this
.
pushChanges
(
client
resolvedEncoded
result
options
)
;
}
if
(
result
.
published
.
length
>
0
)
{
const
pullOpts
=
{
.
.
.
options
lastModified
exclude
:
result
.
published
}
;
await
this
.
pullChanges
(
client
result
pullOpts
)
;
}
if
(
result
.
ok
)
{
this
.
_lastModified
=
await
this
.
db
.
saveLastModified
(
result
.
lastModified
)
;
}
}
catch
(
e
)
{
this
.
events
.
emit
(
"
sync
:
error
"
{
.
.
.
options
error
:
e
}
)
;
throw
e
;
}
finally
{
this
.
api
.
remote
=
previousRemote
;
}
this
.
events
.
emit
(
"
sync
:
success
"
{
.
.
.
options
result
}
)
;
return
result
;
}
async
loadDump
(
records
)
{
if
(
!
Array
.
isArray
(
records
)
)
{
throw
new
Error
(
"
Records
is
not
an
array
.
"
)
;
}
for
(
const
record
of
records
)
{
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
|
|
!
this
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
"
Record
has
invalid
ID
:
"
+
JSON
.
stringify
(
record
)
)
;
}
if
(
!
record
.
last_modified
)
{
throw
new
Error
(
"
Record
has
no
last_modified
value
:
"
+
JSON
.
stringify
(
record
)
)
;
}
}
const
{
data
}
=
await
this
.
list
(
{
}
{
includeDeleted
:
true
}
)
;
const
existingById
=
data
.
reduce
(
(
acc
record
)
=
>
{
acc
[
record
.
id
]
=
record
;
return
acc
;
}
{
}
)
;
const
newRecords
=
records
.
filter
(
record
=
>
{
const
localRecord
=
existingById
[
record
.
id
]
;
const
shouldKeep
=
localRecord
=
=
=
undefined
|
|
localRecord
.
_status
=
=
=
"
synced
"
&
&
localRecord
.
last_modified
!
=
=
undefined
&
&
record
.
last_modified
>
localRecord
.
last_modified
;
return
shouldKeep
;
}
)
;
return
await
this
.
db
.
loadDump
(
newRecords
.
map
(
markSynced
)
)
;
}
}
exports
.
default
=
Collection
;
class
CollectionTransaction
{
constructor
(
collection
adapterTransaction
)
{
this
.
collection
=
collection
;
this
.
adapterTransaction
=
adapterTransaction
;
this
.
_events
=
[
]
;
}
_queueEvent
(
action
payload
)
{
this
.
_events
.
push
(
{
action
payload
}
)
;
}
emitEvents
(
)
{
for
(
const
{
action
payload
}
of
this
.
_events
)
{
this
.
collection
.
events
.
emit
(
action
payload
)
;
}
if
(
this
.
_events
.
length
>
0
)
{
const
targets
=
this
.
_events
.
map
(
(
{
action
payload
}
)
=
>
(
{
action
.
.
.
payload
}
)
)
;
this
.
collection
.
events
.
emit
(
"
change
"
{
targets
}
)
;
}
this
.
_events
=
[
]
;
}
getAny
(
id
)
{
const
record
=
this
.
adapterTransaction
.
get
(
id
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
get
(
id
options
=
{
includeDeleted
:
false
}
)
{
const
res
=
this
.
getAny
(
id
)
;
if
(
!
res
.
data
|
|
!
options
.
includeDeleted
&
&
res
.
data
.
_status
=
=
=
"
deleted
"
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
return
res
;
}
delete
(
id
options
=
{
virtual
:
true
}
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
const
alreadyDeleted
=
existing
&
&
existing
.
_status
=
=
"
deleted
"
;
if
(
!
existing
|
|
alreadyDeleted
&
&
options
.
virtual
)
{
throw
new
Error
(
Record
with
id
=
{
id
}
not
found
.
)
;
}
if
(
options
.
virtual
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
}
else
{
this
.
adapterTransaction
.
delete
(
id
)
;
}
this
.
_queueEvent
(
"
delete
"
{
data
:
existing
}
)
;
return
{
data
:
existing
permissions
:
{
}
}
;
}
deleteAll
(
ids
)
{
const
existingRecords
=
[
]
;
ids
.
forEach
(
id
=
>
{
existingRecords
.
push
(
this
.
adapterTransaction
.
get
(
id
)
)
;
this
.
delete
(
id
)
;
}
)
;
this
.
_queueEvent
(
"
deleteAll
"
{
data
:
existingRecords
}
)
;
return
{
data
:
existingRecords
permissions
:
{
}
}
;
}
deleteAny
(
id
)
{
const
existing
=
this
.
adapterTransaction
.
get
(
id
)
;
if
(
existing
)
{
this
.
adapterTransaction
.
update
(
markDeleted
(
existing
)
)
;
this
.
_queueEvent
(
"
delete
"
{
data
:
existing
}
)
;
}
return
{
data
:
{
id
.
.
.
existing
}
deleted
:
!
!
existing
permissions
:
{
}
}
;
}
create
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
create
a
record
missing
id
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
this
.
adapterTransaction
.
create
(
record
)
;
this
.
_queueEvent
(
"
create
"
{
data
:
record
}
)
;
return
{
data
:
record
permissions
:
{
}
}
;
}
update
(
record
options
=
{
synced
:
false
patch
:
false
}
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
const
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
if
(
!
oldRecord
)
{
throw
new
Error
(
Record
with
id
=
{
record
.
id
}
not
found
.
)
;
}
const
newRecord
=
options
.
patch
?
{
.
.
.
oldRecord
.
.
.
record
}
:
record
;
const
updated
=
this
.
_updateRaw
(
oldRecord
newRecord
options
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
this
.
_queueEvent
(
"
update
"
{
data
:
updated
oldRecord
}
)
;
return
{
data
:
updated
oldRecord
permissions
:
{
}
}
;
}
_updateRaw
(
oldRecord
newRecord
{
synced
=
false
}
=
{
}
)
{
const
updated
=
{
.
.
.
newRecord
}
;
if
(
oldRecord
&
&
oldRecord
.
last_modified
&
&
!
updated
.
last_modified
)
{
updated
.
last_modified
=
oldRecord
.
last_modified
;
}
const
isIdentical
=
oldRecord
&
&
recordsEqual
(
oldRecord
updated
this
.
localFields
)
;
const
keepSynced
=
isIdentical
&
&
oldRecord
.
_status
=
=
"
synced
"
;
const
neverSynced
=
!
oldRecord
|
|
oldRecord
&
&
oldRecord
.
_status
=
=
"
created
"
;
const
newStatus
=
keepSynced
|
|
synced
?
"
synced
"
:
neverSynced
?
"
created
"
:
"
updated
"
;
return
markStatus
(
updated
newStatus
)
;
}
upsert
(
record
)
{
if
(
typeof
record
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Record
is
not
an
object
.
"
)
;
}
if
(
!
record
.
hasOwnProperty
(
"
id
"
)
)
{
throw
new
Error
(
"
Cannot
update
a
record
missing
id
.
"
)
;
}
if
(
!
this
.
collection
.
idSchema
.
validate
(
record
.
id
)
)
{
throw
new
Error
(
Invalid
Id
:
{
record
.
id
}
)
;
}
let
oldRecord
=
this
.
adapterTransaction
.
get
(
record
.
id
)
;
const
updated
=
this
.
_updateRaw
(
oldRecord
record
)
;
this
.
adapterTransaction
.
update
(
updated
)
;
if
(
oldRecord
&
&
oldRecord
.
_status
=
=
"
deleted
"
)
{
oldRecord
=
undefined
;
}
if
(
oldRecord
)
{
this
.
_queueEvent
(
"
update
"
{
data
:
updated
oldRecord
}
)
;
}
else
{
this
.
_queueEvent
(
"
create
"
{
data
:
updated
}
)
;
}
return
{
data
:
updated
oldRecord
permissions
:
{
}
}
;
}
}
exports
.
CollectionTransaction
=
CollectionTransaction
;
}
{
"
.
/
adapters
/
IDB
"
:
4
"
.
/
adapters
/
base
"
:
5
"
.
/
utils
"
:
7
"
uuid
"
:
2
}
]
7
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
sortObjects
=
sortObjects
;
exports
.
filterObject
=
filterObject
;
exports
.
filterObjects
=
filterObjects
;
exports
.
isUUID
=
isUUID
;
exports
.
waterfall
=
waterfall
;
exports
.
deepEqual
=
deepEqual
;
exports
.
omitKeys
=
omitKeys
;
const
RE_UUID
=
exports
.
RE_UUID
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
function
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
function
filterObject
(
filters
entry
)
{
return
Object
.
keys
(
filters
)
.
every
(
filter
=
>
{
const
value
=
filters
[
filter
]
;
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
function
filterObjects
(
filters
list
)
{
return
list
.
filter
(
entry
=
>
{
return
filterObject
(
filters
entry
)
;
}
)
;
}
function
isUUID
(
uuid
)
{
return
RE_UUID
.
test
(
uuid
)
;
}
function
waterfall
(
fns
init
)
{
if
(
!
fns
.
length
)
{
return
Promise
.
resolve
(
init
)
;
}
return
fns
.
reduce
(
(
promise
nextFn
)
=
>
{
return
promise
.
then
(
nextFn
)
;
}
Promise
.
resolve
(
init
)
)
;
}
function
deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
typeof
a
!
=
=
typeof
b
)
{
return
false
;
}
if
(
!
(
a
&
&
typeof
a
=
=
"
object
"
)
|
|
!
(
b
&
&
typeof
b
=
=
"
object
"
)
)
{
return
false
;
}
if
(
Object
.
keys
(
a
)
.
length
!
=
=
Object
.
keys
(
b
)
.
length
)
{
return
false
;
}
for
(
const
k
in
a
)
{
if
(
!
deepEqual
(
a
[
k
]
b
[
k
]
)
)
{
return
false
;
}
}
return
true
;
}
function
omitKeys
(
obj
keys
=
[
]
)
{
return
Object
.
keys
(
obj
)
.
reduce
(
(
acc
key
)
=
>
{
if
(
!
keys
.
includes
(
key
)
)
{
acc
[
key
]
=
obj
[
key
]
;
}
return
acc
;
}
{
}
)
;
}
}
{
}
]
}
{
}
[
1
]
)
(
1
)
}
)
;
