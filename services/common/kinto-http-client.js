this
.
EXPORTED_SYMBOLS
=
[
"
KintoHttpClient
"
]
;
(
function
(
f
)
{
if
(
typeof
exports
=
=
=
"
object
"
&
&
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
KintoHttpClient
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
undefined
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_base
=
require
(
"
.
.
/
src
/
base
"
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
'
fetch
'
]
)
;
const
{
EventEmitter
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
{
}
)
;
let
KintoHttpClient
=
class
KintoHttpClient
extends
_base2
.
default
{
constructor
(
remote
options
=
{
}
)
{
const
events
=
{
}
;
EventEmitter
.
decorate
(
events
)
;
super
(
remote
_extends
(
{
events
}
options
)
)
;
}
}
;
exports
.
default
=
KintoHttpClient
;
if
(
typeof
module
=
=
=
"
object
"
)
{
module
.
exports
=
KintoHttpClient
;
}
}
{
"
.
.
/
src
/
base
"
:
2
}
]
2
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
exports
.
SUPPORTED_PROTOCOL_VERSION
=
undefined
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_dec
_dec2
_dec3
_dec4
_dec5
_dec6
_desc
_value
_class
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_http
=
require
(
"
.
/
http
"
)
;
var
_http2
=
_interopRequireDefault
(
_http
)
;
var
_endpoint
=
require
(
"
.
/
endpoint
"
)
;
var
_endpoint2
=
_interopRequireDefault
(
_endpoint
)
;
var
_requests
=
require
(
"
.
/
requests
"
)
;
var
requests
=
_interopRequireWildcard
(
_requests
)
;
var
_batch
=
require
(
"
.
/
batch
"
)
;
var
_bucket
=
require
(
"
.
/
bucket
"
)
;
var
_bucket2
=
_interopRequireDefault
(
_bucket
)
;
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
else
{
var
newObj
=
{
}
;
if
(
obj
!
=
null
)
{
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
newObj
[
key
]
=
obj
[
key
]
;
}
}
newObj
.
default
=
obj
;
return
newObj
;
}
}
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_applyDecoratedDescriptor
(
target
property
decorators
descriptor
context
)
{
var
desc
=
{
}
;
Object
[
'
ke
'
+
'
ys
'
]
(
descriptor
)
.
forEach
(
function
(
key
)
{
desc
[
key
]
=
descriptor
[
key
]
;
}
)
;
desc
.
enumerable
=
!
!
desc
.
enumerable
;
desc
.
configurable
=
!
!
desc
.
configurable
;
if
(
'
value
'
in
desc
|
|
desc
.
initializer
)
{
desc
.
writable
=
true
;
}
desc
=
decorators
.
slice
(
)
.
reverse
(
)
.
reduce
(
function
(
desc
decorator
)
{
return
decorator
(
target
property
desc
)
|
|
desc
;
}
desc
)
;
if
(
context
&
&
desc
.
initializer
!
=
=
void
0
)
{
desc
.
value
=
desc
.
initializer
?
desc
.
initializer
.
call
(
context
)
:
void
0
;
desc
.
initializer
=
undefined
;
}
if
(
desc
.
initializer
=
=
=
void
0
)
{
Object
[
'
define
'
+
'
Property
'
]
(
target
property
desc
)
;
desc
=
null
;
}
return
desc
;
}
const
SUPPORTED_PROTOCOL_VERSION
=
exports
.
SUPPORTED_PROTOCOL_VERSION
=
"
v1
"
;
let
KintoClientBase
=
(
_dec
=
(
0
_utils
.
nobatch
)
(
"
This
operation
is
not
supported
within
a
batch
operation
.
"
)
_dec2
=
(
0
_utils
.
nobatch
)
(
"
This
operation
is
not
supported
within
a
batch
operation
.
"
)
_dec3
=
(
0
_utils
.
nobatch
)
(
"
This
operation
is
not
supported
within
a
batch
operation
.
"
)
_dec4
=
(
0
_utils
.
nobatch
)
(
"
This
operation
is
not
supported
within
a
batch
operation
.
"
)
_dec5
=
(
0
_utils
.
nobatch
)
(
"
Can
'
t
use
batch
within
a
batch
!
"
)
_dec6
=
(
0
_utils
.
support
)
(
"
1
.
4
"
"
2
.
0
"
)
(
_class
=
class
KintoClientBase
{
constructor
(
remote
options
=
{
}
)
{
if
(
typeof
remote
!
=
=
"
string
"
|
|
!
remote
.
length
)
{
throw
new
Error
(
"
Invalid
remote
URL
:
"
+
remote
)
;
}
if
(
remote
[
remote
.
length
-
1
]
=
=
=
"
/
"
)
{
remote
=
remote
.
slice
(
0
-
1
)
;
}
this
.
_backoffReleaseTime
=
null
;
this
.
defaultReqOptions
=
{
bucket
:
options
.
bucket
|
|
"
default
"
headers
:
options
.
headers
|
|
{
}
safe
:
!
!
options
.
safe
}
;
this
.
_options
=
options
;
this
.
_requests
=
[
]
;
this
.
_isBatch
=
!
!
options
.
batch
;
this
.
remote
=
remote
;
this
.
serverInfo
=
null
;
this
.
events
=
options
.
events
;
const
{
requestMode
timeout
}
=
options
;
this
.
http
=
new
_http2
.
default
(
this
.
events
{
requestMode
timeout
}
)
;
this
.
_registerHTTPEvents
(
)
;
}
get
remote
(
)
{
return
this
.
_remote
;
}
set
remote
(
url
)
{
let
version
;
try
{
version
=
url
.
match
(
/
\
/
(
v
\
d
+
)
\
/
?
/
)
[
1
]
;
}
catch
(
err
)
{
throw
new
Error
(
"
The
remote
URL
must
contain
the
version
:
"
+
url
)
;
}
if
(
version
!
=
=
SUPPORTED_PROTOCOL_VERSION
)
{
throw
new
Error
(
Unsupported
protocol
version
:
{
version
}
)
;
}
this
.
_remote
=
url
;
this
.
_version
=
version
;
}
get
version
(
)
{
return
this
.
_version
;
}
get
backoff
(
)
{
const
currentTime
=
new
Date
(
)
.
getTime
(
)
;
if
(
this
.
_backoffReleaseTime
&
&
currentTime
<
this
.
_backoffReleaseTime
)
{
return
this
.
_backoffReleaseTime
-
currentTime
;
}
return
0
;
}
_registerHTTPEvents
(
)
{
if
(
!
this
.
_isBatch
)
{
this
.
events
.
on
(
"
backoff
"
backoffMs
=
>
{
this
.
_backoffReleaseTime
=
backoffMs
;
}
)
;
}
}
bucket
(
name
options
=
{
}
)
{
const
bucketOptions
=
(
0
_utils
.
omit
)
(
this
.
_getRequestOptions
(
options
)
"
bucket
"
)
;
return
new
_bucket2
.
default
(
this
name
bucketOptions
)
;
}
_getRequestOptions
(
options
=
{
}
)
{
return
_extends
(
{
}
this
.
defaultReqOptions
options
{
batch
:
this
.
_isBatch
headers
:
_extends
(
{
}
this
.
defaultReqOptions
.
headers
options
.
headers
)
}
)
;
}
fetchServerInfo
(
options
=
{
}
)
{
if
(
this
.
serverInfo
)
{
return
Promise
.
resolve
(
this
.
serverInfo
)
;
}
return
this
.
http
.
request
(
this
.
remote
+
(
0
_endpoint2
.
default
)
(
"
root
"
)
{
headers
:
_extends
(
{
}
this
.
defaultReqOptions
.
headers
options
.
headers
)
}
)
.
then
(
(
{
json
}
)
=
>
{
this
.
serverInfo
=
json
;
return
this
.
serverInfo
;
}
)
;
}
fetchServerSettings
(
options
=
{
}
)
{
return
this
.
fetchServerInfo
(
options
)
.
then
(
(
{
settings
}
)
=
>
settings
)
;
}
fetchServerCapabilities
(
options
=
{
}
)
{
return
this
.
fetchServerInfo
(
options
)
.
then
(
(
{
capabilities
}
)
=
>
capabilities
)
;
}
fetchUser
(
options
=
{
}
)
{
return
this
.
fetchServerInfo
(
options
)
.
then
(
(
{
user
}
)
=
>
user
)
;
}
fetchHTTPApiVersion
(
options
=
{
}
)
{
return
this
.
fetchServerInfo
(
options
)
.
then
(
(
{
http_api_version
}
)
=
>
{
return
http_api_version
;
}
)
;
}
_batchRequests
(
requests
options
=
{
}
)
{
const
headers
=
_extends
(
{
}
this
.
defaultReqOptions
.
headers
options
.
headers
)
;
if
(
!
requests
.
length
)
{
return
Promise
.
resolve
(
[
]
)
;
}
return
this
.
fetchServerSettings
(
)
.
then
(
serverSettings
=
>
{
const
maxRequests
=
serverSettings
[
"
batch_max_requests
"
]
;
if
(
maxRequests
&
&
requests
.
length
>
maxRequests
)
{
const
chunks
=
(
0
_utils
.
partition
)
(
requests
maxRequests
)
;
return
(
0
_utils
.
pMap
)
(
chunks
chunk
=
>
this
.
_batchRequests
(
chunk
options
)
)
;
}
return
this
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
batch
"
)
method
:
"
POST
"
headers
:
headers
body
:
{
defaults
:
{
headers
}
requests
:
requests
}
}
)
.
then
(
(
{
responses
}
)
=
>
responses
)
;
}
)
;
}
batch
(
fn
options
=
{
}
)
{
const
rootBatch
=
new
KintoClientBase
(
this
.
remote
_extends
(
{
}
this
.
_options
this
.
_getRequestOptions
(
options
)
{
batch
:
true
}
)
)
;
let
bucketBatch
collBatch
;
if
(
options
.
bucket
)
{
bucketBatch
=
rootBatch
.
bucket
(
options
.
bucket
)
;
if
(
options
.
collection
)
{
collBatch
=
bucketBatch
.
collection
(
options
.
collection
)
;
}
}
const
batchClient
=
collBatch
|
|
bucketBatch
|
|
rootBatch
;
try
{
fn
(
batchClient
)
;
}
catch
(
err
)
{
return
Promise
.
reject
(
err
)
;
}
return
this
.
_batchRequests
(
rootBatch
.
_requests
options
)
.
then
(
responses
=
>
{
if
(
options
.
aggregate
)
{
return
(
0
_batch
.
aggregate
)
(
responses
rootBatch
.
_requests
)
;
}
return
responses
;
}
)
;
}
execute
(
request
options
=
{
raw
:
false
}
)
{
if
(
this
.
_isBatch
)
{
this
.
_requests
.
push
(
request
)
;
const
msg
=
"
This
result
is
generated
from
within
a
batch
"
+
"
operation
and
should
not
be
consumed
.
"
;
return
Promise
.
resolve
(
options
.
raw
?
{
json
:
msg
}
:
msg
)
;
}
const
promise
=
this
.
fetchServerSettings
(
)
.
then
(
_
=
>
{
return
this
.
http
.
request
(
this
.
remote
+
request
.
path
_extends
(
{
}
request
{
body
:
JSON
.
stringify
(
request
.
body
)
}
)
)
;
}
)
;
return
options
.
raw
?
promise
:
promise
.
then
(
(
{
json
}
)
=
>
json
)
;
}
listBuckets
(
options
=
{
}
)
{
return
this
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
bucket
"
)
headers
:
_extends
(
{
}
this
.
defaultReqOptions
.
headers
options
.
headers
)
}
)
;
}
createBucket
(
id
options
=
{
}
)
{
if
(
!
id
)
{
throw
new
Error
(
"
A
bucket
id
is
required
.
"
)
;
}
const
reqOptions
=
this
.
_getRequestOptions
(
options
)
;
const
{
data
=
{
}
permissions
}
=
reqOptions
;
data
.
id
=
id
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
bucket
"
id
)
;
return
this
.
execute
(
requests
.
createRequest
(
path
{
data
permissions
}
reqOptions
)
)
;
}
deleteBucket
(
bucket
options
=
{
}
)
{
const
bucketObj
=
(
0
_utils
.
toDataBody
)
(
bucket
)
;
if
(
!
bucketObj
.
id
)
{
throw
new
Error
(
"
A
bucket
id
is
required
.
"
)
;
}
const
path
=
(
0
_endpoint2
.
default
)
(
"
bucket
"
bucketObj
.
id
)
;
const
{
last_modified
}
=
{
bucketObj
}
;
const
reqOptions
=
this
.
_getRequestOptions
(
_extends
(
{
last_modified
}
options
)
)
;
return
this
.
execute
(
requests
.
deleteRequest
(
path
reqOptions
)
)
;
}
deleteBuckets
(
options
=
{
}
)
{
const
reqOptions
=
this
.
_getRequestOptions
(
options
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
bucket
"
)
;
return
this
.
execute
(
requests
.
deleteRequest
(
path
reqOptions
)
)
;
}
}
(
_applyDecoratedDescriptor
(
_class
.
prototype
"
fetchServerSettings
"
[
_dec
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
fetchServerSettings
"
)
_class
.
prototype
)
_applyDecoratedDescriptor
(
_class
.
prototype
"
fetchServerCapabilities
"
[
_dec2
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
fetchServerCapabilities
"
)
_class
.
prototype
)
_applyDecoratedDescriptor
(
_class
.
prototype
"
fetchUser
"
[
_dec3
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
fetchUser
"
)
_class
.
prototype
)
_applyDecoratedDescriptor
(
_class
.
prototype
"
fetchHTTPApiVersion
"
[
_dec4
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
fetchHTTPApiVersion
"
)
_class
.
prototype
)
_applyDecoratedDescriptor
(
_class
.
prototype
"
batch
"
[
_dec5
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
batch
"
)
_class
.
prototype
)
_applyDecoratedDescriptor
(
_class
.
prototype
"
deleteBuckets
"
[
_dec6
]
Object
.
getOwnPropertyDescriptor
(
_class
.
prototype
"
deleteBuckets
"
)
_class
.
prototype
)
)
_class
)
)
;
exports
.
default
=
KintoClientBase
;
}
{
"
.
/
batch
"
:
3
"
.
/
bucket
"
:
4
"
.
/
endpoint
"
:
6
"
.
/
http
"
:
8
"
.
/
requests
"
:
9
"
.
/
utils
"
:
10
}
]
3
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
aggregate
=
aggregate
;
function
aggregate
(
responses
=
[
]
requests
=
[
]
)
{
if
(
responses
.
length
!
=
=
requests
.
length
)
{
throw
new
Error
(
"
Responses
length
should
match
requests
one
.
"
)
;
}
const
results
=
{
errors
:
[
]
published
:
[
]
conflicts
:
[
]
skipped
:
[
]
}
;
return
responses
.
reduce
(
(
acc
response
index
)
=
>
{
const
{
status
}
=
response
;
if
(
status
>
=
200
&
&
status
<
400
)
{
acc
.
published
.
push
(
response
.
body
)
;
}
else
if
(
status
=
=
=
404
)
{
acc
.
skipped
.
push
(
response
.
body
)
;
}
else
if
(
status
=
=
=
412
)
{
acc
.
conflicts
.
push
(
{
type
:
"
outgoing
"
local
:
requests
[
index
]
.
body
remote
:
response
.
body
.
details
&
&
response
.
body
.
details
.
existing
|
|
null
}
)
;
}
else
{
acc
.
errors
.
push
(
{
path
:
response
.
path
sent
:
requests
[
index
]
error
:
response
.
body
}
)
;
}
return
acc
;
}
results
)
;
}
}
{
}
]
4
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
undefined
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_collection
=
require
(
"
.
/
collection
"
)
;
var
_collection2
=
_interopRequireDefault
(
_collection
)
;
var
_requests
=
require
(
"
.
/
requests
"
)
;
var
requests
=
_interopRequireWildcard
(
_requests
)
;
var
_endpoint
=
require
(
"
.
/
endpoint
"
)
;
var
_endpoint2
=
_interopRequireDefault
(
_endpoint
)
;
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
else
{
var
newObj
=
{
}
;
if
(
obj
!
=
null
)
{
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
newObj
[
key
]
=
obj
[
key
]
;
}
}
newObj
.
default
=
obj
;
return
newObj
;
}
}
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
let
Bucket
=
class
Bucket
{
constructor
(
client
name
options
=
{
}
)
{
this
.
client
=
client
;
this
.
name
=
name
;
this
.
options
=
options
;
this
.
_isBatch
=
!
!
options
.
batch
;
}
_bucketOptions
(
options
=
{
}
)
{
const
headers
=
_extends
(
{
}
this
.
options
&
&
this
.
options
.
headers
options
.
headers
)
;
return
_extends
(
{
}
this
.
options
options
{
headers
bucket
:
this
.
name
batch
:
this
.
_isBatch
}
)
;
}
collection
(
name
options
=
{
}
)
{
return
new
_collection2
.
default
(
this
.
client
this
name
this
.
_bucketOptions
(
options
)
)
;
}
getData
(
options
=
{
}
)
{
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
bucket
"
this
.
name
)
headers
:
_extends
(
{
}
this
.
options
.
headers
options
.
headers
)
}
)
.
then
(
res
=
>
res
.
data
)
;
}
setData
(
data
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
data
)
)
{
throw
new
Error
(
"
A
bucket
object
is
required
.
"
)
;
}
const
bucket
=
_extends
(
{
}
data
{
id
:
this
.
name
}
)
;
const
bucketId
=
bucket
.
id
;
if
(
bucket
.
id
=
=
=
"
default
"
)
{
delete
bucket
.
id
;
}
const
path
=
(
0
_endpoint2
.
default
)
(
"
bucket
"
bucketId
)
;
const
{
permissions
}
=
options
;
const
reqOptions
=
_extends
(
{
}
this
.
_bucketOptions
(
options
)
)
;
const
request
=
requests
.
updateRequest
(
path
{
data
:
bucket
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
listCollections
(
options
=
{
}
)
{
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
name
)
headers
:
_extends
(
{
}
this
.
options
.
headers
options
.
headers
)
}
)
;
}
createCollection
(
id
options
=
{
}
)
{
const
reqOptions
=
this
.
_bucketOptions
(
options
)
;
const
{
permissions
data
=
{
}
}
=
reqOptions
;
data
.
id
=
id
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
name
id
)
;
const
request
=
requests
.
createRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
deleteCollection
(
collection
options
=
{
}
)
{
const
collectionObj
=
(
0
_utils
.
toDataBody
)
(
collection
)
;
if
(
!
collectionObj
.
id
)
{
throw
new
Error
(
"
A
collection
id
is
required
.
"
)
;
}
const
{
id
last_modified
}
=
collectionObj
;
const
reqOptions
=
this
.
_bucketOptions
(
_extends
(
{
last_modified
}
options
)
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
name
id
)
;
const
request
=
requests
.
deleteRequest
(
path
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
listGroups
(
options
=
{
}
)
{
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
group
"
this
.
name
)
headers
:
_extends
(
{
}
this
.
options
.
headers
options
.
headers
)
}
)
;
}
getGroup
(
id
options
=
{
}
)
{
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
group
"
this
.
name
id
)
headers
:
_extends
(
{
}
this
.
options
.
headers
options
.
headers
)
}
)
;
}
createGroup
(
id
members
=
[
]
options
=
{
}
)
{
const
reqOptions
=
this
.
_bucketOptions
(
options
)
;
const
data
=
_extends
(
{
}
options
.
data
{
id
members
}
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
group
"
this
.
name
id
)
;
const
{
permissions
}
=
options
;
const
request
=
requests
.
createRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
updateGroup
(
group
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
group
)
)
{
throw
new
Error
(
"
A
group
object
is
required
.
"
)
;
}
if
(
!
group
.
id
)
{
throw
new
Error
(
"
A
group
id
is
required
.
"
)
;
}
const
reqOptions
=
this
.
_bucketOptions
(
options
)
;
const
data
=
_extends
(
{
}
options
.
data
group
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
group
"
this
.
name
group
.
id
)
;
const
{
permissions
}
=
options
;
const
request
=
requests
.
updateRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
deleteGroup
(
group
options
=
{
}
)
{
const
groupObj
=
(
0
_utils
.
toDataBody
)
(
group
)
;
const
{
id
last_modified
}
=
groupObj
;
const
reqOptions
=
this
.
_bucketOptions
(
_extends
(
{
last_modified
}
options
)
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
group
"
this
.
name
id
)
;
const
request
=
requests
.
deleteRequest
(
path
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
getPermissions
(
options
=
{
}
)
{
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
bucket
"
this
.
name
)
headers
:
_extends
(
{
}
this
.
options
.
headers
options
.
headers
)
}
)
.
then
(
res
=
>
res
.
permissions
)
;
}
setPermissions
(
permissions
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
permissions
)
)
{
throw
new
Error
(
"
A
permissions
object
is
required
.
"
)
;
}
const
path
=
(
0
_endpoint2
.
default
)
(
"
bucket
"
this
.
name
)
;
const
reqOptions
=
_extends
(
{
}
this
.
_bucketOptions
(
options
)
)
;
const
{
last_modified
}
=
options
;
const
data
=
{
last_modified
}
;
const
request
=
requests
.
updateRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
batch
(
fn
options
=
{
}
)
{
return
this
.
client
.
batch
(
fn
this
.
_bucketOptions
(
options
)
)
;
}
}
;
exports
.
default
=
Bucket
;
}
{
"
.
/
collection
"
:
5
"
.
/
endpoint
"
:
6
"
.
/
requests
"
:
9
"
.
/
utils
"
:
10
}
]
5
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
undefined
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_requests
=
require
(
"
.
/
requests
"
)
;
var
requests
=
_interopRequireWildcard
(
_requests
)
;
var
_endpoint
=
require
(
"
.
/
endpoint
"
)
;
var
_endpoint2
=
_interopRequireDefault
(
_endpoint
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
else
{
var
newObj
=
{
}
;
if
(
obj
!
=
null
)
{
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
newObj
[
key
]
=
obj
[
key
]
;
}
}
newObj
.
default
=
obj
;
return
newObj
;
}
}
let
Collection
=
class
Collection
{
constructor
(
client
bucket
name
options
=
{
}
)
{
this
.
client
=
client
;
this
.
bucket
=
bucket
;
this
.
name
=
name
;
this
.
options
=
_extends
(
{
}
this
.
bucket
.
options
options
{
headers
:
_extends
(
{
}
this
.
bucket
.
options
&
&
this
.
bucket
.
options
.
headers
options
.
headers
)
}
)
;
this
.
_isBatch
=
!
!
options
.
batch
;
}
_collOptions
(
options
=
{
}
)
{
const
headers
=
_extends
(
{
}
this
.
options
&
&
this
.
options
.
headers
options
.
headers
)
;
return
_extends
(
{
}
this
.
options
options
{
headers
}
)
;
}
getData
(
options
=
{
}
)
{
const
{
headers
}
=
this
.
_collOptions
(
options
)
;
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
bucket
.
name
this
.
name
)
headers
}
)
.
then
(
res
=
>
res
.
data
)
;
}
setData
(
data
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
data
)
)
{
throw
new
Error
(
"
A
collection
object
is
required
.
"
)
;
}
const
reqOptions
=
this
.
_collOptions
(
options
)
;
const
{
permissions
}
=
reqOptions
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
bucket
.
name
this
.
name
)
;
const
request
=
requests
.
updateRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
getPermissions
(
options
=
{
}
)
{
const
{
headers
}
=
this
.
_collOptions
(
options
)
;
return
this
.
client
.
execute
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
bucket
.
name
this
.
name
)
headers
}
)
.
then
(
res
=
>
res
.
permissions
)
;
}
setPermissions
(
permissions
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
permissions
)
)
{
throw
new
Error
(
"
A
permissions
object
is
required
.
"
)
;
}
const
reqOptions
=
this
.
_collOptions
(
options
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
collection
"
this
.
bucket
.
name
this
.
name
)
;
const
data
=
{
last_modified
:
options
.
last_modified
}
;
const
request
=
requests
.
updateRequest
(
path
{
data
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
createRecord
(
record
options
=
{
}
)
{
const
reqOptions
=
this
.
_collOptions
(
options
)
;
const
{
permissions
}
=
reqOptions
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
record
"
this
.
bucket
.
name
this
.
name
record
.
id
)
;
const
request
=
requests
.
createRequest
(
path
{
data
:
record
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
updateRecord
(
record
options
=
{
}
)
{
if
(
!
(
0
_utils
.
isObject
)
(
record
)
)
{
throw
new
Error
(
"
A
record
object
is
required
.
"
)
;
}
if
(
!
record
.
id
)
{
throw
new
Error
(
"
A
record
id
is
required
.
"
)
;
}
const
reqOptions
=
this
.
_collOptions
(
options
)
;
const
{
permissions
}
=
reqOptions
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
record
"
this
.
bucket
.
name
this
.
name
record
.
id
)
;
const
request
=
requests
.
updateRequest
(
path
{
data
:
record
permissions
}
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
deleteRecord
(
record
options
=
{
}
)
{
const
recordObj
=
(
0
_utils
.
toDataBody
)
(
record
)
;
if
(
!
recordObj
.
id
)
{
throw
new
Error
(
"
A
record
id
is
required
.
"
)
;
}
const
{
id
last_modified
}
=
recordObj
;
const
reqOptions
=
this
.
_collOptions
(
_extends
(
{
last_modified
}
options
)
)
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
record
"
this
.
bucket
.
name
this
.
name
id
)
;
const
request
=
requests
.
deleteRequest
(
path
reqOptions
)
;
return
this
.
client
.
execute
(
request
)
;
}
getRecord
(
id
options
=
{
}
)
{
return
this
.
client
.
execute
(
_extends
(
{
path
:
(
0
_endpoint2
.
default
)
(
"
record
"
this
.
bucket
.
name
this
.
name
id
)
}
this
.
_collOptions
(
options
)
)
)
;
}
listRecords
(
options
=
{
}
)
{
const
{
http
}
=
this
.
client
;
const
{
sort
filters
limit
pages
since
}
=
_extends
(
{
sort
:
"
-
last_modified
"
}
options
)
;
if
(
since
&
&
typeof
since
!
=
=
"
string
"
)
{
throw
new
Error
(
Invalid
value
for
since
(
{
since
}
)
should
be
ETag
value
.
)
;
}
const
collHeaders
=
this
.
options
.
headers
;
const
path
=
(
0
_endpoint2
.
default
)
(
"
record
"
this
.
bucket
.
name
this
.
name
)
;
const
querystring
=
(
0
_utils
.
qsify
)
(
_extends
(
{
}
filters
{
_sort
:
sort
_limit
:
limit
_since
:
since
}
)
)
;
let
results
=
[
]
current
=
0
;
const
next
=
function
(
nextPage
)
{
if
(
!
nextPage
)
{
throw
new
Error
(
"
Pagination
exhausted
.
"
)
;
}
return
processNextPage
(
nextPage
)
;
}
;
const
processNextPage
=
nextPage
=
>
{
return
http
.
request
(
nextPage
{
headers
:
collHeaders
}
)
.
then
(
handleResponse
)
;
}
;
const
pageResults
=
(
results
nextPage
etag
)
=
>
{
return
{
last_modified
:
etag
?
etag
.
replace
(
/
"
/
g
"
"
)
:
etag
data
:
results
next
:
next
.
bind
(
null
nextPage
)
}
;
}
;
const
handleResponse
=
(
{
headers
json
}
)
=
>
{
const
nextPage
=
headers
.
get
(
"
Next
-
Page
"
)
;
const
etag
=
headers
.
get
(
"
ETag
"
)
;
if
(
!
pages
)
{
return
pageResults
(
json
.
data
nextPage
etag
)
;
}
results
=
results
.
concat
(
json
.
data
)
;
current
+
=
1
;
if
(
current
>
=
pages
|
|
!
nextPage
)
{
return
pageResults
(
results
nextPage
etag
)
;
}
return
processNextPage
(
nextPage
)
;
}
;
return
this
.
client
.
execute
(
_extends
(
{
path
:
path
+
"
?
"
+
querystring
}
this
.
_collOptions
(
options
)
)
{
raw
:
true
}
)
.
then
(
handleResponse
)
;
}
batch
(
fn
options
=
{
}
)
{
const
reqOptions
=
this
.
_collOptions
(
options
)
;
return
this
.
client
.
batch
(
fn
_extends
(
{
}
reqOptions
{
bucket
:
this
.
bucket
.
name
collection
:
this
.
name
}
)
)
;
}
}
;
exports
.
default
=
Collection
;
}
{
"
.
/
endpoint
"
:
6
"
.
/
requests
"
:
9
"
.
/
utils
"
:
10
}
]
6
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
endpoint
;
const
ENDPOINTS
=
{
root
:
(
)
=
>
"
/
"
batch
:
(
)
=
>
"
/
batch
"
bucket
:
bucket
=
>
"
/
buckets
"
+
(
bucket
?
/
{
bucket
}
:
"
"
)
collection
:
(
bucket
coll
)
=
>
{
ENDPOINTS
.
bucket
(
bucket
)
}
/
collections
+
(
coll
?
/
{
coll
}
:
"
"
)
group
:
(
bucket
group
)
=
>
{
ENDPOINTS
.
bucket
(
bucket
)
}
/
groups
+
(
group
?
/
{
group
}
:
"
"
)
record
:
(
bucket
coll
id
)
=
>
{
ENDPOINTS
.
collection
(
bucket
coll
)
}
/
records
+
(
id
?
/
{
id
}
:
"
"
)
}
;
function
endpoint
(
name
.
.
.
args
)
{
return
ENDPOINTS
[
name
]
(
.
.
.
args
)
;
}
}
{
}
]
7
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
{
104
:
"
Missing
Authorization
Token
"
105
:
"
Invalid
Authorization
Token
"
106
:
"
Request
body
was
not
valid
JSON
"
107
:
"
Invalid
request
parameter
"
108
:
"
Missing
request
parameter
"
109
:
"
Invalid
posted
data
"
110
:
"
Invalid
Token
/
id
"
111
:
"
Missing
Token
/
id
"
112
:
"
Content
-
Length
header
was
not
provided
"
113
:
"
Request
body
too
large
"
114
:
"
Resource
was
modified
meanwhile
"
115
:
"
Method
not
allowed
on
this
end
point
(
hint
:
server
may
be
readonly
)
"
116
:
"
Requested
version
not
available
on
this
server
"
117
:
"
Client
has
sent
too
many
requests
"
121
:
"
Resource
access
is
forbidden
for
this
user
"
122
:
"
Another
resource
violates
constraint
"
201
:
"
Service
Temporary
unavailable
due
to
high
load
"
202
:
"
Service
deprecated
"
999
:
"
Internal
Server
Error
"
}
;
}
{
}
]
8
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
undefined
;
var
_errors
=
require
(
"
.
/
errors
"
)
;
var
_errors2
=
_interopRequireDefault
(
_errors
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
let
HTTP
=
class
HTTP
{
static
get
DEFAULT_REQUEST_HEADERS
(
)
{
return
{
"
Accept
"
:
"
application
/
json
"
"
Content
-
Type
"
:
"
application
/
json
"
}
;
}
static
get
defaultOptions
(
)
{
return
{
timeout
:
5000
requestMode
:
"
cors
"
}
;
}
constructor
(
events
options
=
{
}
)
{
if
(
!
events
)
{
throw
new
Error
(
"
No
events
handler
provided
"
)
;
}
this
.
events
=
events
;
this
.
requestMode
=
options
.
requestMode
|
|
HTTP
.
defaultOptions
.
requestMode
;
this
.
timeout
=
options
.
timeout
|
|
HTTP
.
defaultOptions
.
timeout
;
}
request
(
url
options
=
{
headers
:
{
}
}
)
{
let
response
status
statusText
headers
hasTimedout
;
options
.
headers
=
Object
.
assign
(
{
}
HTTP
.
DEFAULT_REQUEST_HEADERS
options
.
headers
)
;
options
.
mode
=
this
.
requestMode
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
_timeoutId
=
setTimeout
(
(
)
=
>
{
hasTimedout
=
true
;
reject
(
new
Error
(
"
Request
timeout
.
"
)
)
;
}
this
.
timeout
)
;
fetch
(
url
options
)
.
then
(
res
=
>
{
if
(
!
hasTimedout
)
{
clearTimeout
(
_timeoutId
)
;
resolve
(
res
)
;
}
}
)
.
catch
(
err
=
>
{
if
(
!
hasTimedout
)
{
clearTimeout
(
_timeoutId
)
;
reject
(
err
)
;
}
}
)
;
}
)
.
then
(
res
=
>
{
response
=
res
;
headers
=
res
.
headers
;
status
=
res
.
status
;
statusText
=
res
.
statusText
;
this
.
_checkForDeprecationHeader
(
headers
)
;
this
.
_checkForBackoffHeader
(
status
headers
)
;
this
.
_checkForRetryAfterHeader
(
status
headers
)
;
return
res
.
text
(
)
;
}
)
.
then
(
text
=
>
{
if
(
text
.
length
=
=
=
0
)
{
return
null
;
}
return
JSON
.
parse
(
text
)
;
}
)
.
catch
(
err
=
>
{
const
error
=
new
Error
(
HTTP
{
status
|
|
0
}
;
{
err
}
)
;
error
.
response
=
response
;
error
.
stack
=
err
.
stack
;
throw
error
;
}
)
.
then
(
json
=
>
{
if
(
json
&
&
status
>
=
400
)
{
let
message
=
HTTP
{
status
}
{
json
.
error
|
|
"
"
}
:
;
if
(
json
.
errno
&
&
json
.
errno
in
_errors2
.
default
)
{
const
errnoMsg
=
_errors2
.
default
[
json
.
errno
]
;
message
+
=
errnoMsg
;
if
(
json
.
message
&
&
json
.
message
!
=
=
errnoMsg
)
{
message
+
=
(
{
json
.
message
}
)
;
}
}
else
{
message
+
=
statusText
|
|
"
"
;
}
const
error
=
new
Error
(
message
.
trim
(
)
)
;
error
.
response
=
response
;
error
.
data
=
json
;
throw
error
;
}
return
{
status
json
headers
}
;
}
)
;
}
_checkForDeprecationHeader
(
headers
)
{
const
alertHeader
=
headers
.
get
(
"
Alert
"
)
;
if
(
!
alertHeader
)
{
return
;
}
let
alert
;
try
{
alert
=
JSON
.
parse
(
alertHeader
)
;
}
catch
(
err
)
{
console
.
warn
(
"
Unable
to
parse
Alert
header
message
"
alertHeader
)
;
return
;
}
console
.
warn
(
alert
.
message
alert
.
url
)
;
this
.
events
.
emit
(
"
deprecated
"
alert
)
;
}
_checkForBackoffHeader
(
status
headers
)
{
let
backoffMs
;
const
backoffSeconds
=
parseInt
(
headers
.
get
(
"
Backoff
"
)
10
)
;
if
(
backoffSeconds
>
0
)
{
backoffMs
=
new
Date
(
)
.
getTime
(
)
+
backoffSeconds
*
1000
;
}
else
{
backoffMs
=
0
;
}
this
.
events
.
emit
(
"
backoff
"
backoffMs
)
;
}
_checkForRetryAfterHeader
(
status
headers
)
{
let
retryAfter
=
headers
.
get
(
"
Retry
-
After
"
)
;
if
(
!
retryAfter
)
{
return
;
}
retryAfter
=
new
Date
(
)
.
getTime
(
)
+
parseInt
(
retryAfter
10
)
*
1000
;
this
.
events
.
emit
(
"
retry
-
after
"
retryAfter
)
;
}
}
;
exports
.
default
=
HTTP
;
}
{
"
.
/
errors
"
:
7
}
]
9
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
.
createRequest
=
createRequest
;
exports
.
updateRequest
=
updateRequest
;
exports
.
deleteRequest
=
deleteRequest
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
const
requestDefaults
=
{
safe
:
false
headers
:
{
}
permissions
:
undefined
data
:
undefined
patch
:
false
}
;
function
safeHeader
(
safe
last_modified
)
{
if
(
!
safe
)
{
return
{
}
;
}
if
(
last_modified
)
{
return
{
"
If
-
Match
"
:
"
{
last_modified
}
"
}
;
}
return
{
"
If
-
None
-
Match
"
:
"
*
"
}
;
}
function
createRequest
(
path
{
data
permissions
}
options
=
{
}
)
{
const
{
headers
safe
}
=
_extends
(
{
}
requestDefaults
options
)
;
return
{
method
:
data
&
&
data
.
id
?
"
PUT
"
:
"
POST
"
path
headers
:
_extends
(
{
}
headers
safeHeader
(
safe
)
)
body
:
{
data
permissions
}
}
;
}
function
updateRequest
(
path
{
data
permissions
}
options
=
{
}
)
{
const
{
headers
safe
patch
}
=
_extends
(
{
}
requestDefaults
options
)
;
const
{
last_modified
}
=
_extends
(
{
}
data
options
)
;
if
(
Object
.
keys
(
(
0
_utils
.
omit
)
(
data
"
id
"
"
last_modified
"
)
)
.
length
=
=
=
0
)
{
data
=
undefined
;
}
return
{
method
:
patch
?
"
PATCH
"
:
"
PUT
"
path
headers
:
_extends
(
{
}
headers
safeHeader
(
safe
last_modified
)
)
body
:
{
data
permissions
}
}
;
}
function
deleteRequest
(
path
options
=
{
}
)
{
const
{
headers
safe
last_modified
}
=
_extends
(
{
}
requestDefaults
options
)
;
if
(
safe
&
&
!
last_modified
)
{
throw
new
Error
(
"
Safe
concurrency
check
requires
a
last_modified
value
.
"
)
;
}
return
{
method
:
"
DELETE
"
path
headers
:
_extends
(
{
}
headers
safeHeader
(
safe
last_modified
)
)
}
;
}
}
{
"
.
/
utils
"
:
10
}
]
10
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
partition
=
partition
;
exports
.
pMap
=
pMap
;
exports
.
omit
=
omit
;
exports
.
toDataBody
=
toDataBody
;
exports
.
qsify
=
qsify
;
exports
.
checkVersion
=
checkVersion
;
exports
.
support
=
support
;
exports
.
capable
=
capable
;
exports
.
nobatch
=
nobatch
;
exports
.
isObject
=
isObject
;
function
partition
(
array
n
)
{
if
(
n
<
=
0
)
{
return
array
;
}
return
array
.
reduce
(
(
acc
x
i
)
=
>
{
if
(
i
=
=
=
0
|
|
i
%
n
=
=
=
0
)
{
acc
.
push
(
[
x
]
)
;
}
else
{
acc
[
acc
.
length
-
1
]
.
push
(
x
)
;
}
return
acc
;
}
[
]
)
;
}
function
pMap
(
list
fn
)
{
let
results
=
[
]
;
return
list
.
reduce
(
(
promise
entry
)
=
>
{
return
promise
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
fn
(
entry
)
)
.
then
(
result
=
>
results
=
results
.
concat
(
result
)
)
;
}
)
;
}
Promise
.
resolve
(
)
)
.
then
(
(
)
=
>
results
)
;
}
function
omit
(
obj
.
.
.
keys
)
{
return
Object
.
keys
(
obj
)
.
reduce
(
(
acc
key
)
=
>
{
if
(
keys
.
indexOf
(
key
)
=
=
=
-
1
)
{
acc
[
key
]
=
obj
[
key
]
;
}
return
acc
;
}
{
}
)
;
}
function
toDataBody
(
resource
)
{
if
(
isObject
(
resource
)
)
{
return
resource
;
}
if
(
typeof
resource
=
=
=
"
string
"
)
{
return
{
id
:
resource
}
;
}
throw
new
Error
(
"
Invalid
argument
.
"
)
;
}
function
qsify
(
obj
)
{
const
sep
=
"
&
"
;
const
encode
=
v
=
>
encodeURIComponent
(
typeof
v
=
=
=
"
boolean
"
?
String
(
v
)
:
v
)
;
const
stripUndefined
=
o
=
>
JSON
.
parse
(
JSON
.
stringify
(
o
)
)
;
const
stripped
=
stripUndefined
(
obj
)
;
return
Object
.
keys
(
stripped
)
.
map
(
k
=
>
{
const
ks
=
encode
(
k
)
+
"
=
"
;
if
(
Array
.
isArray
(
stripped
[
k
]
)
)
{
return
stripped
[
k
]
.
map
(
v
=
>
ks
+
encode
(
v
)
)
.
join
(
sep
)
;
}
else
{
return
ks
+
encode
(
stripped
[
k
]
)
;
}
}
)
.
join
(
sep
)
;
}
function
checkVersion
(
version
minVersion
maxVersion
)
{
const
extract
=
str
=
>
str
.
split
(
"
.
"
)
.
map
(
x
=
>
parseInt
(
x
10
)
)
;
const
[
verMajor
verMinor
]
=
extract
(
version
)
;
const
[
minMajor
minMinor
]
=
extract
(
minVersion
)
;
const
[
maxMajor
maxMinor
]
=
extract
(
maxVersion
)
;
const
checks
=
[
verMajor
<
minMajor
verMajor
=
=
=
minMajor
&
&
verMinor
<
minMinor
verMajor
>
maxMajor
verMajor
=
=
=
maxMajor
&
&
verMinor
>
=
maxMinor
]
;
if
(
checks
.
some
(
x
=
>
x
)
)
{
throw
new
Error
(
Version
{
version
}
doesn
'
t
satisfy
+
{
minVersion
}
<
=
x
<
{
maxVersion
}
)
;
}
}
function
support
(
min
max
)
{
return
function
(
target
key
descriptor
)
{
const
fn
=
descriptor
.
value
;
return
{
configurable
:
true
get
(
)
{
const
wrappedMethod
=
(
.
.
.
args
)
=
>
{
const
client
=
"
client
"
in
this
?
this
.
client
:
this
;
return
client
.
fetchHTTPApiVersion
(
)
.
then
(
version
=
>
checkVersion
(
version
min
max
)
)
.
then
(
Promise
.
resolve
(
fn
.
apply
(
this
args
)
)
)
;
}
;
Object
.
defineProperty
(
this
key
{
value
:
wrappedMethod
configurable
:
true
writable
:
true
}
)
;
return
wrappedMethod
;
}
}
;
}
;
}
function
capable
(
capabilities
)
{
return
function
(
target
key
descriptor
)
{
const
fn
=
descriptor
.
value
;
return
{
configurable
:
true
get
(
)
{
const
wrappedMethod
=
(
.
.
.
args
)
=
>
{
const
client
=
"
client
"
in
this
?
this
.
client
:
this
;
return
client
.
fetchServerCapabilities
(
)
.
then
(
available
=
>
{
const
missing
=
capabilities
.
filter
(
c
=
>
available
.
indexOf
(
c
)
<
0
)
;
if
(
missing
.
length
>
0
)
{
throw
new
Error
(
Required
capabilities
{
missing
.
join
(
"
"
)
}
+
"
not
present
on
server
"
)
;
}
}
)
.
then
(
Promise
.
resolve
(
fn
.
apply
(
this
args
)
)
)
;
}
;
Object
.
defineProperty
(
this
key
{
value
:
wrappedMethod
configurable
:
true
writable
:
true
}
)
;
return
wrappedMethod
;
}
}
;
}
;
}
function
nobatch
(
message
)
{
return
function
(
target
key
descriptor
)
{
const
fn
=
descriptor
.
value
;
return
{
configurable
:
true
get
(
)
{
const
wrappedMethod
=
(
.
.
.
args
)
=
>
{
if
(
this
.
_isBatch
)
{
throw
new
Error
(
message
)
;
}
return
fn
.
apply
(
this
args
)
;
}
;
Object
.
defineProperty
(
this
key
{
value
:
wrappedMethod
configurable
:
true
writable
:
true
}
)
;
return
wrappedMethod
;
}
}
;
}
;
}
function
isObject
(
thing
)
{
return
typeof
thing
=
=
=
"
object
"
&
&
thing
!
=
=
null
&
&
!
Array
.
isArray
(
thing
)
;
}
}
{
}
]
}
{
}
[
1
]
)
(
1
)
}
)
;
