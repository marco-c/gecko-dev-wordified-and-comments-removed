"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
BlocklistClients
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
null
)
;
const
{
UptakeTelemetry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
uptake
-
telemetry
.
js
"
)
;
let
server
;
const
PREF_SETTINGS_VERIFY_SIGNATURE
=
"
services
.
settings
.
verify_signature
"
;
const
PREF_SETTINGS_SERVER
=
"
services
.
settings
.
server
"
;
const
PREF_SIGNATURE_ROOT
=
"
security
.
content
.
signature
.
root_hash
"
;
const
CERT_DIR
=
"
test_blocklist_signatures
/
"
;
const
CHAIN_FILES
=
[
"
collection_signing_ee
.
pem
"
"
collection_signing_int
.
pem
"
"
collection_signing_root
.
pem
"
]
;
function
getFileData
(
file
)
{
const
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
file
-
1
0
0
)
;
const
data
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
return
data
;
}
function
setRoot
(
)
{
const
filename
=
CERT_DIR
+
CHAIN_FILES
[
0
]
;
const
certFile
=
do_get_file
(
filename
false
)
;
const
b64cert
=
getFileData
(
certFile
)
.
replace
(
/
-
-
-
-
-
BEGIN
CERTIFICATE
-
-
-
-
-
/
"
"
)
.
replace
(
/
-
-
-
-
-
END
CERTIFICATE
-
-
-
-
-
/
"
"
)
.
replace
(
/
[
\
r
\
n
]
/
g
"
"
)
;
const
certdb
=
Cc
[
"
mozilla
.
org
/
security
/
x509certdb
;
1
"
]
.
getService
(
Ci
.
nsIX509CertDB
)
;
const
cert
=
certdb
.
constructX509FromBase64
(
b64cert
)
;
Services
.
prefs
.
setCharPref
(
PREF_SIGNATURE_ROOT
cert
.
sha256Fingerprint
)
;
}
function
getCertChain
(
)
{
const
chain
=
[
]
;
for
(
let
file
of
CHAIN_FILES
)
{
chain
.
push
(
getFileData
(
do_get_file
(
CERT_DIR
+
file
)
)
)
;
}
return
chain
.
join
(
"
\
n
"
)
;
}
async
function
checkRecordCount
(
client
count
)
{
const
records
=
await
client
.
get
(
)
;
Assert
.
equal
(
count
records
.
length
)
;
}
add_task
(
async
function
test_check_signatures
(
)
{
const
port
=
server
.
identity
.
primaryPort
;
const
OneCRLBlocklistClient
=
BlocklistClients
.
OneCRLBlocklistClient
;
const
TELEMETRY_HISTOGRAM_KEY
=
OneCRLBlocklistClient
.
identifier
;
function
makeMetaResponseBody
(
lastModified
signature
)
{
return
{
data
:
{
id
:
"
certificates
"
last_modified
:
lastModified
signature
:
{
x5u
:
http
:
/
/
localhost
:
{
port
}
/
test_blocklist_signatures
/
test_cert_chain
.
pem
public_key
:
"
fake
"
"
content
-
signature
"
:
x5u
=
http
:
/
/
localhost
:
{
port
}
/
test_blocklist_signatures
/
test_cert_chain
.
pem
;
p384ecdsa
=
{
signature
}
signature_encoding
:
"
rs_base64url
"
signature
hash_algorithm
:
"
sha384
"
ref
:
"
1yryrnmzou5rf31ou80znpnq8n
"
}
}
}
;
}
function
makeMetaResponse
(
eTag
body
comment
)
{
return
{
comment
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
ETag
:
\
"
{
eTag
}
\
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
body
)
}
;
}
function
registerHandlers
(
responses
)
{
function
handleResponse
(
serverTimeMillis
request
response
)
{
const
key
=
{
request
.
method
}
:
{
request
.
path
}
?
{
request
.
queryString
}
;
const
available
=
responses
[
key
]
;
const
sampled
=
available
.
length
>
1
?
available
.
shift
(
)
:
available
[
0
]
;
if
(
!
sampled
)
{
do_throw
(
unexpected
{
request
.
method
}
request
for
{
request
.
path
}
?
{
request
.
queryString
}
)
;
}
response
.
setStatusLine
(
null
sampled
.
status
.
status
sampled
.
status
.
statusText
)
;
for
(
let
headerLine
of
sampled
.
sampleHeaders
)
{
let
headerElements
=
headerLine
.
split
(
"
:
"
)
;
response
.
setHeader
(
headerElements
[
0
]
headerElements
[
1
]
.
trimLeft
(
)
)
;
}
response
.
setHeader
(
"
Date
"
(
new
Date
(
serverTimeMillis
)
)
.
toUTCString
(
)
)
;
response
.
write
(
sampled
.
responseBody
)
;
}
for
(
let
key
of
Object
.
keys
(
responses
)
)
{
const
keyParts
=
key
.
split
(
"
:
"
)
;
const
valueParts
=
keyParts
[
1
]
.
split
(
"
?
"
)
;
const
path
=
valueParts
[
0
]
;
server
.
registerPathHandler
(
path
handleResponse
.
bind
(
null
2000
)
)
;
}
}
let
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
const
emptyData
=
"
[
]
"
;
const
emptySignature
=
"
p384ecdsa
=
zbugm2FDitsHwk5
-
IWsas1PpWwY29f0Fg5ZHeqD8fzep7AVl2vfcaHA7LdmCZ28qZLOioGKvco3qT117Q4
-
HlqFTJM7COHzxGyU2MMJ0ZTnhJrPOC1fP3cVQjU1PTWi9
"
;
const
name
=
"
onecrl
.
content
-
signature
.
mozilla
.
org
"
;
ok
(
verifier
.
verifyContentSignature
(
emptyData
emptySignature
getCertChain
(
)
name
)
)
;
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
const
collectionData
=
'
[
{
"
details
"
:
{
"
bug
"
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
"
created
"
:
"
2016
-
01
-
18T14
:
43
:
37Z
"
"
name
"
:
"
GlobalSign
certs
"
"
who
"
:
"
.
"
"
why
"
:
"
.
"
}
"
enabled
"
:
true
"
id
"
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
"
issuerName
"
:
"
MHExKDAmBgNVBAMTH0dsb2JhbFNpZ24gUm9vdFNpZ24gUGFydG5lcnMgQ0ExHTAbBgNVBAsTFFJvb3RTaWduIFBhcnRuZXJzIENBMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMQswCQYDVQQGEwJCRQ
=
=
"
"
last_modified
"
:
2000
"
serialNumber
"
:
"
BAAAAAABA
/
A35EU
=
"
}
{
"
details
"
:
{
"
bug
"
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
"
created
"
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
"
name
"
:
"
GlobalSign
certs
"
"
who
"
:
"
.
"
"
why
"
:
"
.
"
}
"
enabled
"
:
true
"
id
"
:
"
e3bd531e
-
1ee4
-
7407
-
27ce
-
6fdc9cecbbdc
"
"
issuerName
"
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
"
last_modified
"
:
3000
"
serialNumber
"
:
"
BAAAAAABI54PryQ
=
"
}
]
'
;
const
collectionSignature
=
"
p384ecdsa
=
f4pA2tYM5jQgWY6YUmhUwQiBLj6QO5sHLD_5MqLePz95qv
-
7cNCuQoZnPQwxoptDtW8hcWH3kLb0quR7SB
-
r82gkpR9POVofsnWJRA
-
ETb0BcIz6VvI3pDT49ZLlNg3p
"
;
ok
(
verifier
.
verifyContentSignature
(
collectionData
collectionSignature
getCertChain
(
)
name
)
)
;
Services
.
prefs
.
setCharPref
(
PREF_SETTINGS_SERVER
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
v1
)
;
const
RECORD1
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
43
:
37Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
issuerName
:
"
MHExKDAmBgNVBAMTH0dsb2JhbFNpZ24gUm9vdFNpZ24gUGFydG5lcnMgQ0ExHTAbBgNVBAsTFFJvb3RTaWduIFBhcnRuZXJzIENBMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMQswCQYDVQQGEwJCRQ
=
=
"
last_modified
:
2000
serialNumber
:
"
BAAAAAABA
/
A35EU
=
"
}
;
const
RECORD2
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
e3bd531e
-
1ee4
-
7407
-
27ce
-
6fdc9cecbbdc
"
issuerName
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
last_modified
:
3000
serialNumber
:
"
BAAAAAABI54PryQ
=
"
}
;
const
RECORD3
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
c7c49b69
-
a4ab
-
418e
-
92a9
-
e1961459aa7f
"
issuerName
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
last_modified
:
4000
serialNumber
:
"
BAAAAAABI54PryQ
=
"
}
;
const
RECORD1_DELETION
=
{
deleted
:
true
enabled
:
true
id
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
last_modified
:
3500
}
;
const
RESPONSE_CERT_CHAIN
=
{
comment
:
"
RESPONSE_CERT_CHAIN
"
sampleHeaders
:
[
"
Content
-
Type
:
text
/
plain
;
charset
=
UTF
-
8
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
getCertChain
(
)
}
;
const
RESPONSE_SERVER_SETTINGS
=
{
comment
:
"
RESPONSE_SERVER_SETTINGS
"
sampleHeaders
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
settings
"
:
{
"
batch_max_requests
"
:
25
}
"
url
"
:
http
:
/
/
localhost
:
{
port
}
/
v1
/
"
documentation
"
:
"
https
:
/
/
kinto
.
readthedocs
.
org
/
"
"
version
"
:
"
1
.
5
.
1
"
"
commit
"
:
"
cbc6f58
"
"
hello
"
:
"
kinto
"
}
)
}
;
const
RESPONSE_EMPTY_INITIAL
=
{
comment
:
"
RESPONSE_EMPTY_INITIAL
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
1000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
]
}
)
}
;
const
RESPONSE_BODY_META_EMPTY_SIG
=
makeMetaResponseBody
(
1000
"
vxuAg5rDCB
-
1pul4a91vqSBQRXJG_j7WOYUTswxRSMltdYmbhLRH8R8brQ9YKuNDF56F
-
w6pn4HWxb076qgKPwgcEBtUeZAO_RtaHXRkRUUgVzAr86yQL4
-
aJTbv3D6u
"
)
;
const
RESPONSE_META_NO_SIG
=
{
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
ETag
:
\
"
123456
\
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
data
:
{
last_modified
:
123456
}
}
)
}
;
const
RESPONSE_META_EMPTY_SIG
=
makeMetaResponse
(
1000
RESPONSE_BODY_META_EMPTY_SIG
"
RESPONSE_META_EMPTY_SIG
"
)
;
const
emptyCollectionResponses
=
{
"
GET
:
/
test_blocklist_signatures
/
test_cert_chain
.
pem
?
"
:
[
RESPONSE_CERT_CHAIN
]
"
GET
:
/
v1
/
?
"
:
[
RESPONSE_SERVER_SETTINGS
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
1000
&
_sort
=
-
last_modified
"
:
[
RESPONSE_EMPTY_INITIAL
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
1000
"
:
[
RESPONSE_META_EMPTY_SIG
]
}
;
registerHandlers
(
emptyCollectionResponses
)
;
let
startHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
1000
{
loadDump
:
false
}
)
;
let
endHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
let
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SUCCESS
]
:
1
}
;
checkUptakeTelemetry
(
startHistogram
endHistogram
expectedIncrements
)
;
const
RESPONSE_TWO_ADDED
=
{
comment
:
"
RESPONSE_TWO_ADDED
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
3000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
RECORD2
RECORD1
]
}
)
}
;
const
RESPONSE_BODY_META_TWO_ITEMS_SIG
=
makeMetaResponseBody
(
3000
"
dwhJeypadNIyzGj3QdI0KMRTPnHhFPF_j73mNrsPAHKMW46S2Ftf4BzsPMvPMB8h0TjDus13wo_R4l432DHe7tYyMIWXY0PBeMcoe5BREhFIxMxTsh9eGVXBD1e3UwRy
"
)
;
const
RESPONSE_META_TWO_ITEMS_SIG
=
makeMetaResponse
(
3000
RESPONSE_BODY_META_TWO_ITEMS_SIG
"
RESPONSE_META_TWO_ITEMS_SIG
"
)
;
const
twoItemsResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
3000
&
_sort
=
-
last_modified
&
_since
=
1000
"
:
[
RESPONSE_TWO_ADDED
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
3000
"
:
[
RESPONSE_META_TWO_ITEMS_SIG
]
}
;
registerHandlers
(
twoItemsResponses
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
3000
)
;
const
RESPONSE_ONE_ADDED_ONE_REMOVED
=
{
comment
:
"
RESPONSE_ONE_ADDED_ONE_REMOVED
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
4000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
RECORD3
RECORD1_DELETION
]
}
)
}
;
const
RESPONSE_BODY_META_THREE_ITEMS_SIG
=
makeMetaResponseBody
(
4000
"
MIEmNghKnkz12UodAAIc3q_Y4a3IJJ7GhHF4JYNYmm8avAGyPM9fYU7NzVo94pzjotG7vmtiYuHyIX2rTHTbT587w0LdRWxipgFd_PC1mHiwUyjFYNqBBG
-
kifYk7kEw
"
)
;
const
RESPONSE_META_THREE_ITEMS_SIG
=
makeMetaResponse
(
4000
RESPONSE_BODY_META_THREE_ITEMS_SIG
"
RESPONSE_META_THREE_ITEMS_SIG
"
)
;
const
oneAddedOneRemovedResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
4000
&
_sort
=
-
last_modified
&
_since
=
3000
"
:
[
RESPONSE_ONE_ADDED_ONE_REMOVED
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
4000
"
:
[
RESPONSE_META_THREE_ITEMS_SIG
]
}
;
registerHandlers
(
oneAddedOneRemovedResponses
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
4000
)
;
const
RESPONSE_EMPTY_NO_UPDATE
=
{
comment
:
"
RESPONSE_EMPTY_NO_UPDATE
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
4000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
]
}
)
}
;
const
noOpResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
4100
&
_sort
=
-
last_modified
&
_since
=
4000
"
:
[
RESPONSE_EMPTY_NO_UPDATE
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
4100
"
:
[
RESPONSE_META_THREE_ITEMS_SIG
]
}
;
registerHandlers
(
noOpResponses
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
4100
)
;
const
RESPONSE_COMPLETE_INITIAL
=
{
comment
:
"
RESPONSE_COMPLETE_INITIAL
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
4000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
RECORD2
RECORD3
]
}
)
}
;
const
RESPONSE_COMPLETE_INITIAL_SORTED_BY_ID
=
{
comment
:
"
RESPONSE_COMPLETE_INITIAL
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
ETag
:
\
"
4000
\
"
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
"
data
"
:
[
RECORD3
RECORD2
]
}
)
}
;
const
RESPONSE_BODY_META_BAD_SIG
=
makeMetaResponseBody
(
4000
"
aW52YWxpZCBzaWduYXR1cmUK
"
)
;
const
RESPONSE_META_BAD_SIG
=
makeMetaResponse
(
4000
RESPONSE_BODY_META_BAD_SIG
"
RESPONSE_META_BAD_SIG
"
)
;
const
badSigGoodSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
5000
"
:
[
RESPONSE_META_BAD_SIG
RESPONSE_META_THREE_ITEMS_SIG
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
-
last_modified
&
_since
=
4000
"
:
[
RESPONSE_EMPTY_NO_UPDATE
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_sort
=
-
last_modified
"
:
[
RESPONSE_COMPLETE_INITIAL
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
id
"
:
[
RESPONSE_COMPLETE_INITIAL_SORTED_BY_ID
]
}
;
registerHandlers
(
badSigGoodSigResponses
)
;
startHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
let
syncEventSent
=
false
;
OneCRLBlocklistClient
.
on
(
"
sync
"
(
{
data
}
)
=
>
{
syncEventSent
=
true
;
}
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
5000
)
;
endHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
equal
(
syncEventSent
false
)
;
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_ERROR
]
:
1
}
;
checkUptakeTelemetry
(
startHistogram
endHistogram
expectedIncrements
)
;
const
badSigGoodOldResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
5000
"
:
[
RESPONSE_META_BAD_SIG
RESPONSE_META_EMPTY_SIG
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
-
last_modified
&
_since
=
4000
"
:
[
RESPONSE_EMPTY_NO_UPDATE
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
id
"
:
[
RESPONSE_EMPTY_INITIAL
]
}
;
await
checkRecordCount
(
OneCRLBlocklistClient
2
)
;
registerHandlers
(
badSigGoodOldResponses
)
;
syncEventSent
=
false
;
OneCRLBlocklistClient
.
on
(
"
sync
"
(
{
data
}
)
=
>
{
syncEventSent
=
true
;
}
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
5000
)
;
equal
(
syncEventSent
false
)
;
const
badLocalContentGoodSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
5000
"
:
[
RESPONSE_META_BAD_SIG
RESPONSE_META_THREE_ITEMS_SIG
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
-
last_modified
"
:
[
RESPONSE_COMPLETE_INITIAL
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
5000
&
_sort
=
id
"
:
[
RESPONSE_COMPLETE_INITIAL_SORTED_BY_ID
]
}
;
registerHandlers
(
badLocalContentGoodSigResponses
)
;
const
kintoCol
=
await
OneCRLBlocklistClient
.
openCollection
(
)
;
await
kintoCol
.
clear
(
)
;
await
kintoCol
.
create
(
{
.
.
.
RECORD2
last_modified
:
1234567890
serialNumber
:
"
abc
"
}
{
synced
:
true
useRecordId
:
true
}
)
;
const
localId
=
"
0602b1b2
-
12ab
-
4d3a
-
b6fb
-
593244e7b035
"
;
await
kintoCol
.
create
(
{
id
:
localId
}
{
synced
:
true
useRecordId
:
true
}
)
;
let
syncData
;
OneCRLBlocklistClient
.
on
(
"
sync
"
(
{
data
}
)
=
>
{
syncData
=
data
;
}
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
5000
{
loadDump
:
false
}
)
;
equal
(
syncData
.
current
.
length
2
)
;
equal
(
syncData
.
created
.
length
1
)
;
equal
(
syncData
.
created
[
0
]
.
id
RECORD3
.
id
)
;
equal
(
syncData
.
updated
.
length
1
)
;
equal
(
syncData
.
updated
[
0
]
.
old
.
serialNumber
"
abc
"
)
;
equal
(
syncData
.
updated
[
0
]
.
new
.
serialNumber
RECORD2
.
serialNumber
)
;
equal
(
syncData
.
deleted
.
length
1
)
;
equal
(
syncData
.
deleted
[
0
]
.
id
localId
)
;
const
allBadSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
6000
"
:
[
RESPONSE_META_BAD_SIG
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
6000
&
_sort
=
-
last_modified
&
_since
=
4000
"
:
[
RESPONSE_EMPTY_NO_UPDATE
]
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
/
records
?
_expected
=
6000
&
_sort
=
id
"
:
[
RESPONSE_COMPLETE_INITIAL_SORTED_BY_ID
]
}
;
startHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
registerHandlers
(
allBadSigResponses
)
;
try
{
await
OneCRLBlocklistClient
.
maybeSync
(
6000
)
;
do_throw
(
"
Sync
should
fail
(
the
signature
is
intentionally
bad
)
"
)
;
}
catch
(
e
)
{
await
checkRecordCount
(
OneCRLBlocklistClient
2
)
;
}
endHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_RETRY_ERROR
]
:
1
}
;
checkUptakeTelemetry
(
startHistogram
endHistogram
expectedIncrements
)
;
const
missingSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
security
-
state
/
collections
/
onecrl
?
_expected
=
6000
"
:
[
RESPONSE_META_NO_SIG
]
}
;
startHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
registerHandlers
(
missingSigResponses
)
;
try
{
await
OneCRLBlocklistClient
.
maybeSync
(
6000
)
;
do_throw
(
"
Sync
should
fail
(
the
signature
is
missing
)
"
)
;
}
catch
(
e
)
{
await
checkRecordCount
(
OneCRLBlocklistClient
2
)
;
}
endHistogram
=
getUptakeTelemetrySnapshot
(
TELEMETRY_HISTOGRAM_KEY
)
;
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_ERROR
]
:
1
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_RETRY_ERROR
]
:
0
}
;
checkUptakeTelemetry
(
startHistogram
endHistogram
expectedIncrements
)
;
}
)
;
function
run_test
(
)
{
BlocklistClients
.
initialize
(
)
;
Services
.
prefs
.
setBoolPref
(
PREF_SETTINGS_VERIFY_SIGNATURE
true
)
;
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
setRoot
(
)
;
server
=
new
HttpServer
(
)
;
server
.
start
(
-
1
)
;
run_next_test
(
)
;
registerCleanupFunction
(
function
(
)
{
server
.
stop
(
function
(
)
{
}
)
;
}
)
;
}
