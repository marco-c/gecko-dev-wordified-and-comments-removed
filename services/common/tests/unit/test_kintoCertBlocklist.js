const
{
Constructor
:
CC
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
KintoCertificateBlocklist
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
BinaryInputStream
=
CC
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
var
server
;
const
Kinto
=
loadKinto
(
)
;
const
FirefoxAdapter
=
Kinto
.
adapters
.
FirefoxAdapter
;
const
kintoFilename
=
"
kinto
.
sqlite
"
;
let
kintoClient
;
function
do_get_kinto_collection
(
collectionName
)
{
if
(
!
kintoClient
)
{
let
config
=
{
remote
:
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
/
"
adapter
:
FirefoxAdapter
bucket
:
"
blocklists
"
}
;
kintoClient
=
new
Kinto
(
config
)
;
}
return
kintoClient
.
collection
(
collectionName
)
;
}
add_task
(
function
*
test_something
(
)
{
const
configPath
=
"
/
v1
/
"
;
const
recordsPath
=
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
"
;
Services
.
prefs
.
setCharPref
(
"
services
.
kinto
.
base
"
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
v1
)
;
function
handleResponse
(
request
response
)
{
try
{
const
sampled
=
getSampleResponse
(
request
server
.
identity
.
primaryPort
)
;
if
(
!
sampled
)
{
do_throw
(
unexpected
{
request
.
method
}
request
for
{
request
.
path
}
?
{
request
.
queryString
}
)
;
}
response
.
setStatusLine
(
null
sampled
.
status
.
status
sampled
.
status
.
statusText
)
;
for
(
let
headerLine
of
sampled
.
sampleHeaders
)
{
let
headerElements
=
headerLine
.
split
(
'
:
'
)
;
response
.
setHeader
(
headerElements
[
0
]
headerElements
[
1
]
.
trimLeft
(
)
)
;
}
response
.
setHeader
(
"
Date
"
(
new
Date
(
)
)
.
toUTCString
(
)
)
;
response
.
write
(
sampled
.
responseBody
)
;
}
catch
(
e
)
{
dump
(
{
e
}
\
n
)
;
}
}
server
.
registerPathHandler
(
configPath
handleResponse
)
;
server
.
registerPathHandler
(
recordsPath
handleResponse
)
;
let
result
=
yield
OneCRLClient
.
maybeSync
(
2000
Date
.
now
(
)
)
;
let
collection
=
do_get_kinto_collection
(
"
certificates
"
)
;
yield
collection
.
db
.
open
(
)
;
let
list
=
yield
collection
.
list
(
)
;
do_check_eq
(
list
.
data
.
length
1
)
;
yield
collection
.
db
.
close
(
)
;
result
=
yield
OneCRLClient
.
maybeSync
(
4000
Date
.
now
(
)
)
;
collection
=
do_get_kinto_collection
(
"
certificates
"
)
;
yield
collection
.
db
.
open
(
)
;
list
=
yield
collection
.
list
(
)
;
do_check_eq
(
list
.
data
.
length
3
)
;
yield
collection
.
db
.
close
(
)
;
Services
.
prefs
.
clearUserPref
(
"
services
.
kinto
.
base
"
)
;
yield
OneCRLClient
.
maybeSync
(
4000
Date
.
now
(
)
)
;
yield
OneCRLClient
.
maybeSync
(
3000
Date
.
now
(
)
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
kinto
.
onecrl
.
checked
"
0
)
;
yield
OneCRLClient
.
maybeSync
(
3000
Date
.
now
(
)
)
;
let
newValue
=
Services
.
prefs
.
getIntPref
(
"
services
.
kinto
.
onecrl
.
checked
"
)
;
do_check_neq
(
newValue
0
)
;
}
)
;
function
run_test
(
)
{
server
=
new
HttpServer
(
)
;
server
.
start
(
-
1
)
;
run_next_test
(
)
;
do_register_cleanup
(
function
(
)
{
server
.
stop
(
function
(
)
{
}
)
;
}
)
;
}
function
getSampleResponse
(
req
port
)
{
const
responses
=
{
"
OPTIONS
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Headers
:
Content
-
Length
Expires
Backoff
Retry
-
After
Last
-
Modified
Total
-
Records
ETag
Pragma
Cache
-
Control
authorization
content
-
type
if
-
none
-
match
Alert
Next
-
Page
"
"
Access
-
Control
-
Allow
-
Methods
:
GET
HEAD
OPTIONS
POST
DELETE
OPTIONS
"
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
"
null
"
}
"
GET
:
/
v1
/
?
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
settings
"
:
{
"
cliquet
.
batch_max_requests
"
:
25
}
"
url
"
:
http
:
/
/
localhost
:
{
port
}
/
v1
/
"
documentation
"
:
"
https
:
/
/
kinto
.
readthedocs
.
org
/
"
"
version
"
:
"
1
.
5
.
1
"
"
commit
"
:
"
cbc6f58
"
"
hello
"
:
"
kinto
"
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
3000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
"
issuerName
"
:
"
MEQxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwx0aGF3dGUsIEluYy4xHjAcBgNVBAMTFXRoYXd0ZSBFViBTU0wgQ0EgLSBHMw
=
=
"
"
serialNumber
"
:
"
CrTHPEE6AZSfI3jysin2bA
=
=
"
"
id
"
:
"
78cf8900
-
fdea
-
4ce5
-
f8fb
-
b78710617718
"
"
last_modified
"
:
3000
}
]
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
&
_since
=
3000
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
4000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
"
issuerName
"
:
"
MFkxCzAJBgNVBAYTAk5MMR4wHAYDVQQKExVTdGFhdCBkZXIgTmVkZXJsYW5kZW4xKjAoBgNVBAMTIVN0YWF0IGRlciBOZWRlcmxhbmRlbiBPdmVyaGVpZCBDQQ
"
"
serialNumber
"
:
"
ATFpsA
=
=
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02c
"
"
last_modified
"
:
4000
}
{
"
subject
"
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
"
pubKeyHash
"
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02d
"
"
last_modified
"
:
4000
}
]
}
)
}
}
;
return
responses
[
{
req
.
method
}
:
{
req
.
path
}
?
{
req
.
queryString
}
]
|
|
responses
[
req
.
method
]
;
}
