const
{
Constructor
:
CC
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
{
OneCRLBlocklistClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
blocklist
-
clients
.
js
"
{
}
)
;
const
BinaryInputStream
=
CC
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
let
server
;
add_task
(
async
function
test_something
(
)
{
const
configPath
=
"
/
v1
/
"
;
const
recordsPath
=
"
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
"
;
const
dummyServerURL
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
v1
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
dummyServerURL
)
;
function
handleResponse
(
request
response
)
{
try
{
const
sample
=
getSampleResponse
(
request
server
.
identity
.
primaryPort
)
;
if
(
!
sample
)
{
do_throw
(
unexpected
{
request
.
method
}
request
for
{
request
.
path
}
?
{
request
.
queryString
}
)
;
}
response
.
setStatusLine
(
null
sample
.
status
.
status
sample
.
status
.
statusText
)
;
for
(
let
headerLine
of
sample
.
sampleHeaders
)
{
let
headerElements
=
headerLine
.
split
(
"
:
"
)
;
response
.
setHeader
(
headerElements
[
0
]
headerElements
[
1
]
.
trimLeft
(
)
)
;
}
response
.
setHeader
(
"
Date
"
(
new
Date
(
)
)
.
toUTCString
(
)
)
;
response
.
write
(
sample
.
responseBody
)
;
}
catch
(
e
)
{
info
(
e
)
;
}
}
server
.
registerPathHandler
(
configPath
handleResponse
)
;
server
.
registerPathHandler
(
recordsPath
handleResponse
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
2000
Date
.
now
(
)
)
;
await
OneCRLBlocklistClient
.
openCollection
(
async
(
collection
)
=
>
{
const
list
=
await
collection
.
list
(
)
;
Assert
.
ok
(
list
.
data
.
length
>
=
363
)
;
}
)
;
Services
.
prefs
.
clearUserPref
(
"
services
.
settings
.
server
"
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
blocklist
.
onecrl
.
checked
"
0
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
123456
Date
.
now
(
)
)
;
Assert
.
notEqual
(
0
Services
.
prefs
.
getIntPref
(
"
services
.
blocklist
.
onecrl
.
checked
"
)
)
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
dummyServerURL
)
;
await
OneCRLBlocklistClient
.
openCollection
(
async
(
collection
)
=
>
{
await
collection
.
clear
(
)
;
await
collection
.
db
.
saveLastModified
(
1000
)
;
}
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
2000
Date
.
now
(
)
)
;
await
OneCRLBlocklistClient
.
openCollection
(
async
(
collection
)
=
>
{
const
list
=
await
collection
.
list
(
)
;
Assert
.
equal
(
list
.
data
.
length
1
)
;
}
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
4000
Date
.
now
(
)
)
;
await
OneCRLBlocklistClient
.
openCollection
(
async
(
collection
)
=
>
{
const
list
=
await
collection
.
list
(
)
;
Assert
.
equal
(
list
.
data
.
length
3
)
;
}
)
;
Services
.
prefs
.
clearUserPref
(
"
services
.
settings
.
server
"
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
4000
Date
.
now
(
)
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
3000
Date
.
now
(
)
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
blocklist
.
onecrl
.
checked
"
0
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
3000
Date
.
now
(
)
)
;
let
newValue
=
Services
.
prefs
.
getIntPref
(
"
services
.
blocklist
.
onecrl
.
checked
"
)
;
Assert
.
notEqual
(
newValue
0
)
;
Services
.
prefs
.
setCharPref
(
"
services
.
settings
.
server
"
dummyServerURL
)
;
await
OneCRLBlocklistClient
.
maybeSync
(
5000
Date
.
now
(
)
)
;
}
)
;
function
run_test
(
)
{
Services
.
prefs
.
setBoolPref
(
"
services
.
blocklist
.
signing
.
enforced
"
false
)
;
server
=
new
HttpServer
(
)
;
server
.
start
(
-
1
)
;
run_next_test
(
)
;
registerCleanupFunction
(
function
(
)
{
server
.
stop
(
(
)
=
>
{
}
)
;
}
)
;
}
function
getSampleResponse
(
req
port
)
{
const
responses
=
{
"
OPTIONS
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Headers
:
Content
-
Length
Expires
Backoff
Retry
-
After
Last
-
Modified
Total
-
Records
ETag
Pragma
Cache
-
Control
authorization
content
-
type
if
-
none
-
match
Alert
Next
-
Page
"
"
Access
-
Control
-
Allow
-
Methods
:
GET
HEAD
OPTIONS
POST
DELETE
OPTIONS
"
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
"
null
"
}
"
GET
:
/
v1
/
?
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
settings
"
:
{
"
batch_max_requests
"
:
25
}
"
url
"
:
http
:
/
/
localhost
:
{
port
}
/
v1
/
"
documentation
"
:
"
https
:
/
/
kinto
.
readthedocs
.
org
/
"
"
version
"
:
"
1
.
5
.
1
"
"
commit
"
:
"
cbc6f58
"
"
hello
"
:
"
kinto
"
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
1000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
}
]
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
&
_since
=
1000
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
3000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
"
issuerName
"
:
"
MEQxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwx0aGF3dGUsIEluYy4xHjAcBgNVBAMTFXRoYXd0ZSBFViBTU0wgQ0EgLSBHMw
=
=
"
"
serialNumber
"
:
"
CrTHPEE6AZSfI3jysin2bA
=
=
"
"
id
"
:
"
78cf8900
-
fdea
-
4ce5
-
f8fb
-
b78710617718
"
"
last_modified
"
:
3000
}
]
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
&
_since
=
3000
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
4000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
"
issuerName
"
:
"
MFkxCzAJBgNVBAYTAk5MMR4wHAYDVQQKExVTdGFhdCBkZXIgTmVkZXJsYW5kZW4xKjAoBgNVBAMTIVN0YWF0IGRlciBOZWRlcmxhbmRlbiBPdmVyaGVpZCBDQQ
"
"
serialNumber
"
:
"
ATFpsA
=
=
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02c
"
"
last_modified
"
:
4000
}
{
"
subject
"
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
"
pubKeyHash
"
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02d
"
"
last_modified
"
:
4000
}
]
}
)
}
"
GET
:
/
v1
/
buckets
/
blocklists
/
collections
/
certificates
/
records
?
_sort
=
-
last_modified
&
_since
=
4000
"
:
{
"
sampleHeaders
"
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
"
Etag
:
\
"
5000
\
"
"
]
"
status
"
:
{
status
:
200
statusText
:
"
OK
"
}
"
responseBody
"
:
JSON
.
stringify
(
{
"
data
"
:
[
{
"
issuerName
"
:
"
not
a
base64
encoded
issuer
"
"
serialNumber
"
:
"
not
a
base64
encoded
serial
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02e
"
"
last_modified
"
:
5000
}
{
"
subject
"
:
"
not
a
base64
encoded
subject
"
"
pubKeyHash
"
:
"
not
a
base64
encoded
pubKeyHash
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02f
"
"
last_modified
"
:
5000
}
{
"
subject
"
:
"
MCIxIDAeBgNVBAMMF0Fub3RoZXIgVGVzdCBFbmQtZW50aXR5
"
"
pubKeyHash
"
:
"
VCIlmPM9NkgFQtrs4Oa5TeFcDu6MWRTKSNdePEhOgD8
=
"
"
id
"
:
"
dabafde9
-
df4a
-
ddba
-
2548
-
748da04cc02g
"
"
last_modified
"
:
5000
}
]
}
)
}
}
;
return
responses
[
{
req
.
method
}
:
{
req
.
path
}
?
{
req
.
queryString
}
]
|
|
responses
[
req
.
method
]
;
}
