ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
common
/
logging
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
MockRegistrar
.
jsm
"
)
;
function
do_check_empty
(
obj
)
{
do_check_attribute_count
(
obj
0
)
;
}
function
do_check_attribute_count
(
obj
c
)
{
Assert
.
equal
(
c
Object
.
keys
(
obj
)
.
length
)
;
}
function
do_check_throws
(
aFunc
aResult
aStack
)
{
if
(
!
aStack
)
{
try
{
aStack
=
Components
.
stack
.
caller
;
}
catch
(
e
)
{
}
}
try
{
aFunc
(
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
result
aResult
aStack
)
;
return
;
}
do_throw
(
"
Expected
result
"
+
aResult
+
"
none
thrown
.
"
aStack
)
;
}
function
do_check_throws_message
(
aFunc
aResult
)
{
try
{
aFunc
(
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
message
aResult
)
;
return
;
}
do_throw
(
"
Expected
an
error
none
thrown
.
"
)
;
}
var
_
=
function
(
some
debug
text
to
)
{
print
(
Array
.
slice
(
arguments
)
.
join
(
"
"
)
)
;
}
;
function
httpd_setup
(
handlers
port
=
-
1
)
{
let
server
=
new
HttpServer
(
)
;
for
(
let
path
in
handlers
)
{
server
.
registerPathHandler
(
path
handlers
[
path
]
)
;
}
try
{
server
.
start
(
port
)
;
}
catch
(
ex
)
{
_
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
)
;
_
(
"
Got
exception
starting
HTTP
server
on
port
"
+
port
)
;
_
(
"
Error
:
"
+
Log
.
exceptionStr
(
ex
)
)
;
_
(
"
Is
there
a
process
already
listening
on
port
"
+
port
+
"
?
"
)
;
_
(
"
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
"
)
;
do_throw
(
ex
)
;
}
let
i
=
server
.
identity
;
server
.
baseURI
=
i
.
primaryScheme
+
"
:
/
/
"
+
i
.
primaryHost
+
"
:
"
+
i
.
primaryPort
;
return
server
;
}
function
httpd_handler
(
statusCode
status
body
)
{
return
function
handler
(
request
response
)
{
_
(
"
Processing
request
"
)
;
request
.
body
=
readBytesFromInputStream
(
request
.
bodyInputStream
)
;
handler
.
request
=
request
;
response
.
setStatusLine
(
request
.
httpVersion
statusCode
status
)
;
if
(
body
)
{
response
.
bodyOutputStream
.
write
(
body
body
.
length
)
;
}
}
;
}
function
promiseStopServer
(
server
)
{
return
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
}
function
readBytesFromInputStream
(
inputStream
count
)
{
return
CommonUtils
.
readBytesFromInputStream
(
inputStream
count
)
;
}
function
ensureThrows
(
func
)
{
return
function
(
)
{
try
{
func
.
apply
(
this
arguments
)
;
}
catch
(
ex
)
{
do_throw
(
ex
)
;
}
}
;
}
var
PACSystemSettings
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISystemProxySettings
]
)
mainThreadOnly
:
true
PACURI
:
null
getProxyForURI
:
function
getProxyForURI
(
aURI
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
}
;
var
fakePACCID
;
function
installFakePAC
(
)
{
_
(
"
Installing
fake
PAC
.
"
)
;
fakePACCID
=
MockRegistrar
.
register
(
"
mozilla
.
org
/
system
-
proxy
-
settings
;
1
"
PACSystemSettings
)
;
}
function
uninstallFakePAC
(
)
{
_
(
"
Uninstalling
fake
PAC
.
"
)
;
MockRegistrar
.
unregister
(
fakePACCID
)
;
}
function
getUptakeTelemetrySnapshot
(
key
)
{
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
TELEMETRY_HISTOGRAM_ID
=
"
UPTAKE_REMOTE_CONTENT_RESULT_1
"
;
return
Services
.
telemetry
.
getKeyedHistogramById
(
TELEMETRY_HISTOGRAM_ID
)
.
snapshot
(
key
)
;
}
function
checkUptakeTelemetry
(
snapshot1
snapshot2
expectedIncrements
)
{
const
LABELS
=
[
"
up_to_date
"
"
success
"
"
backoff
"
"
pref_disabled
"
"
parse_error
"
"
content_error
"
"
sign_error
"
"
sign_retry_error
"
"
conflict_error
"
"
sync_error
"
"
apply_error
"
"
server_error
"
"
certificate_error
"
"
download_error
"
"
timeout_error
"
"
network_error
"
"
offline_error
"
"
cleanup_error
"
"
unknown_error
"
"
custom_1_error
"
"
custom_2_error
"
"
custom_3_error
"
"
custom_4_error
"
"
custom_5_error
"
]
;
for
(
const
label
of
LABELS
)
{
const
key
=
LABELS
.
indexOf
(
label
)
;
const
expected
=
expectedIncrements
[
label
]
|
|
0
;
const
actual
=
snapshot2
.
counts
[
key
]
-
snapshot1
.
counts
[
key
]
;
equal
(
expected
actual
check
histogram
count
for
{
label
}
)
;
}
}
