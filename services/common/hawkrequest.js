"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
HAWKAuthenticatedRESTRequest
"
"
deriveHawkCredentials
"
]
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
RESTRequest
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
rest
.
js
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
Credentials
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Credentials
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CryptoUtils
"
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
Prefs
=
new
Preferences
(
"
services
.
common
.
rest
.
"
)
;
var
HAWKAuthenticatedRESTRequest
=
function
HawkAuthenticatedRESTRequest
(
uri
credentials
extra
=
{
}
)
{
RESTRequest
.
call
(
this
uri
)
;
this
.
credentials
=
credentials
;
this
.
now
=
extra
.
now
|
|
Date
.
now
(
)
;
this
.
localtimeOffsetMsec
=
extra
.
localtimeOffsetMsec
|
|
0
;
this
.
_log
.
trace
(
"
local
time
offset
:
"
+
this
.
now
+
"
"
+
this
.
localtimeOffsetMsec
)
;
this
.
extraHeaders
=
extra
.
headers
|
|
{
}
;
this
.
_intl
=
getIntl
(
)
;
}
;
HAWKAuthenticatedRESTRequest
.
prototype
=
{
__proto__
:
RESTRequest
.
prototype
async
dispatch
(
method
data
)
{
let
contentType
=
"
text
/
plain
"
;
if
(
method
=
=
"
POST
"
|
|
method
=
=
"
PUT
"
|
|
method
=
=
"
PATCH
"
)
{
contentType
=
"
application
/
json
"
;
}
if
(
this
.
credentials
)
{
let
options
=
{
now
:
this
.
now
localtimeOffsetMsec
:
this
.
localtimeOffsetMsec
credentials
:
this
.
credentials
payload
:
(
data
&
&
JSON
.
stringify
(
data
)
)
|
|
"
"
contentType
}
;
let
header
=
await
CryptoUtils
.
computeHAWK
(
this
.
uri
method
options
)
;
this
.
setHeader
(
"
Authorization
"
header
.
field
)
;
}
for
(
let
header
in
this
.
extraHeaders
)
{
this
.
setHeader
(
header
this
.
extraHeaders
[
header
]
)
;
}
this
.
setHeader
(
"
Content
-
Type
"
contentType
)
;
this
.
setHeader
(
"
Accept
-
Language
"
this
.
_intl
.
accept_languages
)
;
return
super
.
dispatch
(
method
data
)
;
}
}
;
async
function
deriveHawkCredentials
(
tokenHex
context
size
=
96
)
{
let
token
=
CommonUtils
.
hexToBytes
(
tokenHex
)
;
let
out
=
await
CryptoUtils
.
hkdfLegacy
(
token
undefined
Credentials
.
keyWord
(
context
)
size
)
;
let
result
=
{
key
:
out
.
slice
(
32
64
)
id
:
CommonUtils
.
bytesAsHex
(
out
.
slice
(
0
32
)
)
}
;
if
(
size
>
64
)
{
result
.
extra
=
out
.
slice
(
64
)
;
}
return
result
;
}
function
Intl
(
)
{
this
.
_accepted
=
"
"
;
this
.
_everRead
=
false
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Services
.
Common
.
RESTRequest
"
)
;
this
.
_log
.
level
=
Log
.
Level
[
Prefs
.
get
(
"
log
.
logger
.
rest
.
request
"
)
]
;
this
.
init
(
)
;
}
this
.
Intl
.
prototype
=
{
init
(
)
{
Services
.
prefs
.
addObserver
(
"
intl
.
accept_languages
"
this
)
;
}
uninit
(
)
{
Services
.
prefs
.
removeObserver
(
"
intl
.
accept_languages
"
this
)
;
}
observe
(
subject
topic
data
)
{
this
.
readPref
(
)
;
}
readPref
(
)
{
this
.
_everRead
=
true
;
try
{
this
.
_accepted
=
Services
.
prefs
.
getComplexValue
(
"
intl
.
accept_languages
"
Ci
.
nsIPrefLocalizedString
)
.
data
;
}
catch
(
err
)
{
this
.
_log
.
error
(
"
Error
reading
intl
.
accept_languages
pref
"
err
)
;
}
}
get
accept_languages
(
)
{
if
(
!
this
.
_everRead
)
{
this
.
readPref
(
)
;
}
return
this
.
_accepted
;
}
}
;
var
intl
=
null
;
function
getIntl
(
)
{
if
(
!
intl
)
{
intl
=
new
Intl
(
)
;
}
return
intl
;
}
