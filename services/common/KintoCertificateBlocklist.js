"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
OneCRLClient
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
moz
-
kinto
-
client
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidgen
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
PREF_KINTO_BASE
=
"
services
.
kinto
.
base
"
;
const
PREF_KINTO_BUCKET
=
"
services
.
kinto
.
bucket
"
;
const
PREF_KINTO_ONECRL_COLLECTION
=
"
services
.
kinto
.
onecrl
.
collection
"
;
const
PREF_KINTO_ONECRL_CHECKED_SECONDS
=
"
services
.
kinto
.
onecrl
.
checked
"
;
const
RE_UUID
=
/
^
[
0
-
9a
-
f
]
{
8
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
4
}
-
[
0
-
9a
-
f
]
{
12
}
/
i
;
function
makeIDSchema
(
)
{
return
{
validate
:
RE_UUID
.
test
.
bind
(
RE_UUID
)
generate
:
function
(
)
{
return
uuidgen
.
generateUUID
(
)
.
toString
(
)
;
}
}
;
}
function
CertBlocklistClient
(
)
{
this
.
maybeSync
=
function
(
lastModified
serverTime
)
{
let
base
=
Services
.
prefs
.
getCharPref
(
PREF_KINTO_BASE
)
;
let
bucket
=
Services
.
prefs
.
getCharPref
(
PREF_KINTO_BUCKET
)
;
let
Kinto
=
loadKinto
(
)
;
let
FirefoxAdapter
=
Kinto
.
adapters
.
FirefoxAdapter
;
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certblocklist
;
1
"
]
.
getService
(
Ci
.
nsICertBlocklist
)
;
let
config
=
{
remote
:
base
bucket
:
bucket
adapter
:
FirefoxAdapter
}
;
let
db
=
new
Kinto
(
config
)
;
let
collectionName
=
Services
.
prefs
.
getCharPref
(
PREF_KINTO_ONECRL_COLLECTION
"
certificates
"
)
;
let
blocklist
=
db
.
collection
(
collectionName
{
idSchema
:
makeIDSchema
(
)
}
)
;
let
updateLastCheck
=
function
(
)
{
let
checkedServerTimeInSeconds
=
Math
.
round
(
serverTime
/
1000
)
;
Services
.
prefs
.
setIntPref
(
PREF_KINTO_ONECRL_CHECKED_SECONDS
checkedServerTimeInSeconds
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
try
{
yield
blocklist
.
db
.
open
(
)
;
let
collectionLastModified
=
yield
blocklist
.
db
.
getLastModified
(
)
;
if
(
lastModified
<
=
collectionLastModified
)
{
updateLastCheck
(
)
;
return
;
}
yield
blocklist
.
sync
(
)
;
let
list
=
yield
blocklist
.
list
(
)
;
for
(
let
item
of
list
.
data
)
{
if
(
item
.
issuerName
&
&
item
.
serialNumber
)
{
certList
.
revokeCertByIssuerAndSerial
(
item
.
issuerName
item
.
serialNumber
)
;
}
else
if
(
item
.
subject
&
&
item
.
pubKeyHash
)
{
certList
.
revokeCertBySubjectAndPubKey
(
item
.
subject
item
.
pubKeyHash
)
;
}
else
{
throw
new
Error
(
"
Cert
blocklist
record
has
incomplete
data
"
)
;
}
}
certList
.
saveEntries
(
)
;
updateLastCheck
(
)
;
}
finally
{
blocklist
.
db
.
close
(
)
}
}
)
;
}
}
this
.
OneCRLClient
=
new
CertBlocklistClient
(
)
;
