"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
AddonBlocklistClient
"
"
GfxBlocklistClient
"
"
OneCRLBlocklistClient
"
"
PluginBlocklistClient
"
"
PinningBlocklistClient
"
"
FILENAME_ADDONS_JSON
"
"
FILENAME_GFX_JSON
"
"
FILENAME_PLUGINS_JSON
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
{
OS
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
const
{
Kinto
}
=
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
const
{
KintoHttpClient
}
=
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
const
{
FirefoxAdapter
}
=
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
kinto
-
storage
-
adapter
.
js
"
)
;
const
{
CanonicalJSON
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CanonicalJSON
.
jsm
"
)
;
const
PREF_SETTINGS_SERVER
=
"
services
.
settings
.
server
"
;
const
PREF_BLOCKLIST_BUCKET
=
"
services
.
blocklist
.
bucket
"
;
const
PREF_BLOCKLIST_ONECRL_COLLECTION
=
"
services
.
blocklist
.
onecrl
.
collection
"
;
const
PREF_BLOCKLIST_ONECRL_CHECKED_SECONDS
=
"
services
.
blocklist
.
onecrl
.
checked
"
;
const
PREF_BLOCKLIST_ADDONS_COLLECTION
=
"
services
.
blocklist
.
addons
.
collection
"
;
const
PREF_BLOCKLIST_ADDONS_CHECKED_SECONDS
=
"
services
.
blocklist
.
addons
.
checked
"
;
const
PREF_BLOCKLIST_PLUGINS_COLLECTION
=
"
services
.
blocklist
.
plugins
.
collection
"
;
const
PREF_BLOCKLIST_PLUGINS_CHECKED_SECONDS
=
"
services
.
blocklist
.
plugins
.
checked
"
;
const
PREF_BLOCKLIST_PINNING_ENABLED
=
"
services
.
blocklist
.
pinning
.
enabled
"
;
const
PREF_BLOCKLIST_PINNING_BUCKET
=
"
services
.
blocklist
.
pinning
.
bucket
"
;
const
PREF_BLOCKLIST_PINNING_COLLECTION
=
"
services
.
blocklist
.
pinning
.
collection
"
;
const
PREF_BLOCKLIST_PINNING_CHECKED_SECONDS
=
"
services
.
blocklist
.
pinning
.
checked
"
;
const
PREF_BLOCKLIST_GFX_COLLECTION
=
"
services
.
blocklist
.
gfx
.
collection
"
;
const
PREF_BLOCKLIST_GFX_CHECKED_SECONDS
=
"
services
.
blocklist
.
gfx
.
checked
"
;
const
PREF_BLOCKLIST_ENFORCE_SIGNING
=
"
services
.
blocklist
.
signing
.
enforced
"
;
const
INVALID_SIGNATURE
=
"
Invalid
content
/
signature
"
;
this
.
KINTO_STORAGE_PATH
=
"
kinto
.
sqlite
"
;
this
.
FILENAME_ADDONS_JSON
=
"
blocklist
-
addons
.
json
"
;
this
.
FILENAME_GFX_JSON
=
"
blocklist
-
gfx
.
json
"
;
this
.
FILENAME_PLUGINS_JSON
=
"
blocklist
-
plugins
.
json
"
;
function
mergeChanges
(
collection
localRecords
changes
)
{
const
records
=
{
}
;
localRecords
.
forEach
(
(
record
)
=
>
records
[
record
.
id
]
=
collection
.
cleanLocalFields
(
record
)
)
;
changes
.
forEach
(
(
record
)
=
>
records
[
record
.
id
]
=
record
)
;
return
Object
.
values
(
records
)
.
filter
(
(
record
)
=
>
record
.
deleted
!
=
true
)
.
sort
(
(
a
b
)
=
>
a
.
id
<
b
.
id
?
-
1
:
a
.
id
>
b
.
id
?
1
:
0
)
;
}
function
fetchCollectionMetadata
(
collection
)
{
const
client
=
new
KintoHttpClient
(
collection
.
api
.
remote
)
;
return
client
.
bucket
(
collection
.
bucket
)
.
collection
(
collection
.
name
)
.
getData
(
)
.
then
(
result
=
>
{
return
result
.
signature
;
}
)
;
}
function
fetchRemoteCollection
(
collection
)
{
const
client
=
new
KintoHttpClient
(
collection
.
api
.
remote
)
;
return
client
.
bucket
(
collection
.
bucket
)
.
collection
(
collection
.
name
)
.
listRecords
(
{
sort
:
"
id
"
}
)
;
}
function
kintoClient
(
connection
bucket
)
{
let
base
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_SERVER
)
;
let
config
=
{
remote
:
base
bucket
:
bucket
adapter
:
FirefoxAdapter
adapterOptions
:
{
sqliteHandle
:
connection
}
}
;
return
new
Kinto
(
config
)
;
}
class
BlocklistClient
{
constructor
(
collectionName
lastCheckTimePref
processCallback
bucketName
signerName
)
{
this
.
collectionName
=
collectionName
;
this
.
lastCheckTimePref
=
lastCheckTimePref
;
this
.
processCallback
=
processCallback
;
this
.
bucketName
=
bucketName
;
this
.
signerName
=
signerName
;
}
validateCollectionSignature
(
payload
collection
ignoreLocal
)
{
return
Task
.
spawn
(
(
function
*
(
)
{
const
{
x5u
signature
}
=
yield
fetchCollectionMetadata
(
collection
)
;
const
certChain
=
yield
fetch
(
x5u
)
.
then
(
(
res
)
=
>
res
.
text
(
)
)
;
const
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
let
toSerialize
;
if
(
ignoreLocal
)
{
toSerialize
=
{
last_modified
:
{
payload
.
last_modified
}
data
:
payload
.
data
}
;
}
else
{
const
localRecords
=
(
yield
collection
.
list
(
)
)
.
data
;
const
records
=
mergeChanges
(
collection
localRecords
payload
.
changes
)
;
toSerialize
=
{
last_modified
:
{
payload
.
lastModified
}
data
:
records
}
;
}
const
serialized
=
CanonicalJSON
.
stringify
(
toSerialize
)
;
if
(
verifier
.
verifyContentSignature
(
serialized
"
p384ecdsa
=
"
+
signature
certChain
this
.
signerName
)
)
{
return
payload
;
}
throw
new
Error
(
INVALID_SIGNATURE
)
;
}
)
.
bind
(
this
)
)
;
}
maybeSync
(
lastModified
serverTime
)
{
let
opts
=
{
}
;
let
enforceCollectionSigning
=
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_ENFORCE_SIGNING
)
;
if
(
this
.
signerName
&
&
enforceCollectionSigning
)
{
opts
.
hooks
=
{
"
incoming
-
changes
"
:
[
this
.
validateCollectionSignature
.
bind
(
this
)
]
}
}
return
Task
.
spawn
(
(
function
*
syncCollection
(
)
{
let
connection
;
try
{
connection
=
yield
FirefoxAdapter
.
openConnection
(
{
path
:
KINTO_STORAGE_PATH
}
)
;
let
db
=
kintoClient
(
connection
this
.
bucketName
)
;
let
collection
=
db
.
collection
(
this
.
collectionName
opts
)
;
let
collectionLastModified
=
yield
collection
.
db
.
getLastModified
(
)
;
if
(
lastModified
<
=
collectionLastModified
)
{
this
.
updateLastCheck
(
serverTime
)
;
return
;
}
try
{
let
syncResult
=
yield
collection
.
sync
(
)
;
if
(
!
syncResult
.
ok
)
{
throw
new
Error
(
"
Sync
failed
"
)
;
}
}
catch
(
e
)
{
if
(
e
.
message
=
=
INVALID_SIGNATURE
)
{
let
payload
=
yield
fetchRemoteCollection
(
collection
)
;
yield
this
.
validateCollectionSignature
(
payload
collection
true
)
;
const
localLastModified
=
yield
collection
.
db
.
getLastModified
(
)
;
if
(
payload
.
last_modified
>
=
localLastModified
)
{
yield
collection
.
clear
(
)
;
yield
collection
.
loadDump
(
payload
.
data
)
;
}
}
else
{
throw
e
;
}
}
let
list
=
yield
collection
.
list
(
)
;
yield
this
.
processCallback
(
list
.
data
)
;
this
.
updateLastCheck
(
serverTime
)
;
}
finally
{
yield
connection
.
close
(
)
;
}
}
)
.
bind
(
this
)
)
;
}
updateLastCheck
(
serverTime
)
{
let
checkedServerTimeInSeconds
=
Math
.
round
(
serverTime
/
1000
)
;
Services
.
prefs
.
setIntPref
(
this
.
lastCheckTimePref
checkedServerTimeInSeconds
)
;
}
}
function
*
updateCertBlocklist
(
records
)
{
let
certList
=
Cc
[
"
mozilla
.
org
/
security
/
certblocklist
;
1
"
]
.
getService
(
Ci
.
nsICertBlocklist
)
;
for
(
let
item
of
records
)
{
try
{
if
(
item
.
issuerName
&
&
item
.
serialNumber
)
{
certList
.
revokeCertByIssuerAndSerial
(
item
.
issuerName
item
.
serialNumber
)
;
}
else
if
(
item
.
subject
&
&
item
.
pubKeyHash
)
{
certList
.
revokeCertBySubjectAndPubKey
(
item
.
subject
item
.
pubKeyHash
)
;
}
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
certList
.
saveEntries
(
)
;
}
function
*
updatePinningList
(
records
)
{
if
(
Services
.
prefs
.
getBoolPref
(
PREF_BLOCKLIST_PINNING_ENABLED
)
)
{
const
appInfo
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULAppInfo
)
;
const
siteSecurityService
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
siteSecurityService
.
clearPreloads
(
)
;
for
(
let
item
of
records
)
{
try
{
const
{
pinType
pins
=
[
]
versions
}
=
item
;
if
(
pinType
=
=
"
KeyPin
"
&
&
pins
.
length
&
&
versions
.
indexOf
(
appInfo
.
version
)
!
=
-
1
)
{
siteSecurityService
.
setKeyPins
(
item
.
hostName
item
.
includeSubdomains
item
.
expires
pins
.
length
pins
true
)
;
}
}
catch
(
e
)
{
}
}
}
else
{
return
;
}
}
function
*
updateJSONBlocklist
(
filename
records
)
{
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
filename
)
;
const
serialized
=
JSON
.
stringify
(
{
data
:
records
}
null
2
)
;
try
{
yield
OS
.
File
.
writeAtomic
(
path
serialized
{
tmpPath
:
path
+
"
.
tmp
"
}
)
;
const
eventData
=
{
filename
:
filename
}
;
Services
.
cpmm
.
sendAsyncMessage
(
"
Blocklist
:
reload
-
from
-
disk
"
eventData
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
this
.
OneCRLBlocklistClient
=
new
BlocklistClient
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_ONECRL_COLLECTION
)
PREF_BLOCKLIST_ONECRL_CHECKED_SECONDS
updateCertBlocklist
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_BUCKET
)
"
onecrl
.
content
-
signature
.
mozilla
.
org
"
)
;
this
.
AddonBlocklistClient
=
new
BlocklistClient
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_ADDONS_COLLECTION
)
PREF_BLOCKLIST_ADDONS_CHECKED_SECONDS
updateJSONBlocklist
.
bind
(
undefined
FILENAME_ADDONS_JSON
)
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_BUCKET
)
)
;
this
.
GfxBlocklistClient
=
new
BlocklistClient
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_GFX_COLLECTION
)
PREF_BLOCKLIST_GFX_CHECKED_SECONDS
updateJSONBlocklist
.
bind
(
undefined
FILENAME_GFX_JSON
)
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_BUCKET
)
)
;
this
.
PluginBlocklistClient
=
new
BlocklistClient
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_PLUGINS_COLLECTION
)
PREF_BLOCKLIST_PLUGINS_CHECKED_SECONDS
updateJSONBlocklist
.
bind
(
undefined
FILENAME_PLUGINS_JSON
)
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_BUCKET
)
)
;
this
.
PinningPreloadClient
=
new
BlocklistClient
(
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_PINNING_COLLECTION
)
PREF_BLOCKLIST_PINNING_CHECKED_SECONDS
updatePinningList
Services
.
prefs
.
getCharPref
(
PREF_BLOCKLIST_PINNING_BUCKET
)
"
pinning
-
preload
.
content
-
signature
.
mozilla
.
org
"
)
;
