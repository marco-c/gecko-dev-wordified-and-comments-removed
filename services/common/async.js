this
.
EXPORTED_SYMBOLS
=
[
"
Async
"
]
;
const
CB_READY
=
{
}
;
const
CB_COMPLETE
=
{
}
;
const
CB_FAIL
=
{
}
;
const
REASON_ERROR
=
Ci
.
mozIStorageStatementCallback
.
REASON_ERROR
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
this
.
Async
=
{
chain
:
function
chain
(
)
{
let
funcs
=
Array
.
slice
(
arguments
)
;
let
thisObj
=
this
;
return
function
callback
(
)
{
if
(
funcs
.
length
)
{
let
args
=
Array
.
slice
(
arguments
)
.
concat
(
callback
)
;
let
f
=
funcs
.
shift
(
)
;
f
.
apply
(
thisObj
args
)
;
}
}
;
}
makeSyncCallback
:
function
makeSyncCallback
(
)
{
let
onComplete
=
function
onComplete
(
data
)
{
onComplete
.
state
=
CB_COMPLETE
;
onComplete
.
value
=
data
;
}
;
onComplete
.
state
=
CB_READY
;
onComplete
.
value
=
null
;
onComplete
.
throw
=
function
onComplete_throw
(
data
)
{
onComplete
.
state
=
CB_FAIL
;
onComplete
.
value
=
data
;
}
;
return
onComplete
;
}
waitForSyncCallback
:
function
waitForSyncCallback
(
callback
)
{
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
(
)
=
>
!
Async
.
checkAppReady
|
|
callback
.
state
!
=
CB_READY
)
;
let
state
=
callback
.
state
;
callback
.
state
=
CB_READY
;
if
(
state
=
=
CB_FAIL
)
{
throw
callback
.
value
;
}
return
callback
.
value
;
}
checkAppReady
:
function
checkAppReady
(
)
{
Services
.
obs
.
addObserver
(
function
onQuitApplication
(
)
{
Services
.
obs
.
removeObserver
(
onQuitApplication
"
quit
-
application
"
)
;
Async
.
checkAppReady
=
Async
.
promiseYield
=
function
(
)
{
let
exception
=
Components
.
Exception
(
"
App
.
Quitting
"
Cr
.
NS_ERROR_ABORT
)
;
exception
.
appIsShuttingDown
=
true
;
throw
exception
;
}
;
}
"
quit
-
application
"
)
;
return
(
Async
.
checkAppReady
=
function
(
)
{
return
true
;
}
)
(
)
;
}
isAppReady
(
)
{
try
{
return
Async
.
checkAppReady
(
)
;
}
catch
(
ex
)
{
if
(
!
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
}
return
false
;
}
isShutdownException
(
exception
)
{
return
exception
&
&
exception
.
appIsShuttingDown
=
=
=
true
;
}
makeSpinningCallback
:
function
makeSpinningCallback
(
)
{
let
cb
=
Async
.
makeSyncCallback
(
)
;
function
callback
(
error
ret
)
{
if
(
error
)
cb
.
throw
(
error
)
;
else
cb
(
ret
)
;
}
callback
.
wait
=
(
)
=
>
Async
.
waitForSyncCallback
(
cb
)
;
return
callback
;
}
promiseSpinningly
(
promise
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
promise
.
then
(
result
=
>
{
cb
(
null
result
)
;
}
err
=
>
{
cb
(
err
|
|
new
Error
(
"
Promise
rejected
without
explicit
error
"
)
)
;
}
)
;
return
cb
.
wait
(
)
;
}
promiseYield
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
tm
.
currentThread
.
dispatch
(
resolve
Ci
.
nsIThread
.
DISPATCH_NORMAL
)
;
}
)
;
}
jankYielder
(
yieldEvery
=
50
)
{
let
iterations
=
0
;
return
async
(
)
=
>
{
Async
.
checkAppReady
(
)
;
if
(
+
+
iterations
%
yieldEvery
=
=
=
0
)
{
await
Async
.
promiseYield
(
)
;
}
}
;
}
asyncQueueCaller
(
log
)
{
return
new
AsyncQueueCaller
(
log
)
;
}
asyncObserver
(
log
obj
)
{
return
new
AsyncObserver
(
log
obj
)
;
}
}
;
class
AsyncQueueCaller
{
constructor
(
log
)
{
this
.
_log
=
log
;
this
.
_queue
=
Promise
.
resolve
(
)
;
this
.
QueryInterface
=
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
;
}
enqueueCall
(
func
)
{
this
.
_queue
=
(
async
(
)
=
>
{
await
this
.
_queue
;
try
{
await
func
(
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
e
)
;
}
}
)
(
)
;
}
promiseCallsComplete
(
)
{
return
this
.
_queue
;
}
}
class
AsyncObserver
extends
AsyncQueueCaller
{
constructor
(
obj
log
)
{
super
(
log
)
;
this
.
obj
=
obj
;
}
observe
(
subject
topic
data
)
{
this
.
enqueueCall
(
(
)
=
>
this
.
obj
.
observe
(
subject
topic
data
)
)
;
}
promiseObserversComplete
(
)
{
return
this
.
promiseCallsComplete
(
)
;
}
}
