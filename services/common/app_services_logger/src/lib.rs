#
[
macro_use
]
extern
crate
cstr
;
#
[
macro_use
]
extern
crate
xpcom
;
use
golden_gate
:
:
log
:
:
LogSink
;
use
log
;
use
nserror
:
:
{
nsresult
NS_OK
}
;
use
nsstring
:
:
nsAString
;
use
once_cell
:
:
sync
:
:
Lazy
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
use
std
:
:
{
cmp
collections
:
:
HashMap
sync
:
:
{
atomic
:
:
{
AtomicBool
Ordering
}
RwLock
}
}
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIAppServicesLogger
mozIServicesLogSink
nsISupports
}
RefPtr
}
;
static
SHUTDOWN_OBSERVED
:
AtomicBool
=
AtomicBool
:
:
new
(
false
)
;
#
[
xpcom
(
implement
(
mozIAppServicesLogger
)
nonatomic
)
]
pub
struct
AppServicesLogger
{
}
pub
static
LOGGERS_BY_TARGET
:
Lazy
<
RwLock
<
HashMap
<
String
LogSink
>
>
>
=
Lazy
:
:
new
(
|
|
{
let
h
:
HashMap
<
String
LogSink
>
=
HashMap
:
:
new
(
)
;
let
m
=
RwLock
:
:
new
(
h
)
;
m
}
)
;
impl
AppServicesLogger
{
xpcom_method
!
(
register
=
>
Register
(
target
:
*
const
nsAString
logger
:
*
const
mozIServicesLogSink
)
)
;
fn
register
(
&
self
target
:
&
nsAString
logger
:
&
mozIServicesLogSink
)
-
>
Result
<
(
)
nsresult
>
{
let
log_sink_logger
=
LogSink
:
:
with_logger
(
Some
(
logger
)
)
?
;
let
max_level
=
cmp
:
:
max
(
log
:
:
max_level
(
)
log_sink_logger
.
max_level
)
;
log
:
:
set_max_level
(
max_level
)
;
ensure_observing_shutdown
(
)
;
LOGGERS_BY_TARGET
.
write
(
)
.
unwrap
(
)
.
insert
(
target
.
to_string
(
)
log_sink_logger
)
;
Ok
(
(
)
)
}
pub
fn
is_app_services_logger_registered
(
target
:
String
)
-
>
bool
{
match
LOGGERS_BY_TARGET
.
read
(
)
{
Ok
(
loggers_by_target
)
=
>
loggers_by_target
.
contains_key
(
&
target
)
Err
(
_e
)
=
>
false
}
}
}
extern
"
C
"
{
fn
NS_IsMainThread
(
)
-
>
bool
;
}
fn
ensure_observing_shutdown
(
)
{
assert
!
(
unsafe
{
NS_IsMainThread
(
)
}
)
;
if
SHUTDOWN_OBSERVED
.
load
(
Ordering
:
:
Relaxed
)
{
return
;
}
if
let
Some
(
service
)
=
xpcom
:
:
services
:
:
get_ObserverService
(
)
{
let
observer
=
ShutdownObserver
:
:
allocate
(
InitShutdownObserver
{
}
)
;
let
rv
=
unsafe
{
service
.
AddObserver
(
observer
.
coerce
(
)
cstr
!
(
"
xpcom
-
shutdown
"
)
.
as_ptr
(
)
false
)
}
;
SHUTDOWN_OBSERVED
.
store
(
rv
.
succeeded
(
)
Ordering
:
:
Relaxed
)
;
}
}
#
[
xpcom
(
implement
(
nsIObserver
)
nonatomic
)
]
struct
ShutdownObserver
{
}
impl
ShutdownObserver
{
xpcom_method
!
(
observe
=
>
Observe
(
_subject
:
*
const
nsISupports
topic
:
*
const
c_char
_data
:
*
const
u16
)
)
;
fn
observe
(
&
self
_subject
:
&
nsISupports
topic
:
*
const
c_char
_data
:
*
const
u16
)
-
>
Result
<
(
)
nsresult
>
{
LOGGERS_BY_TARGET
.
write
(
)
.
unwrap
(
)
.
clear
(
)
;
if
let
Some
(
service
)
=
xpcom
:
:
services
:
:
get_ObserverService
(
)
{
let
_
=
unsafe
{
service
.
RemoveObserver
(
self
.
coerce
(
)
topic
)
}
;
}
Ok
(
(
)
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
NS_NewAppServicesLogger
(
result
:
*
mut
*
const
mozIAppServicesLogger
)
-
>
nsresult
{
let
logger
=
AppServicesLogger
:
:
allocate
(
InitAppServicesLogger
{
}
)
;
RefPtr
:
:
new
(
logger
.
coerce
:
:
<
mozIAppServicesLogger
>
(
)
)
.
forget
(
&
mut
*
result
)
;
NS_OK
}
