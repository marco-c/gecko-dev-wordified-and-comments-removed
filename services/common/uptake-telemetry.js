"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UptakeTelemetry
"
"
Policy
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ClientID
"
"
resource
:
/
/
gre
/
modules
/
ClientID
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
CryptoHash
"
(
)
=
>
{
return
Components
.
Constructor
(
"
mozilla
.
org
/
security
/
hash
;
1
"
"
nsICryptoHash
"
"
initWithString
"
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gSampleRate
"
"
services
.
common
.
uptake
.
sampleRate
"
)
;
const
TELEMETRY_HISTOGRAM_ID
=
"
UPTAKE_REMOTE_CONTENT_RESULT_1
"
;
const
TELEMETRY_EVENTS_ID
=
"
uptake
.
remotecontent
.
result
"
;
var
Policy
=
{
_clientIDHash
:
null
getClientID
(
)
{
return
ClientID
.
getClientID
(
)
;
}
async
getClientIDHash
(
)
{
if
(
this
.
_clientIDHash
=
=
=
null
)
{
this
.
_clientIDHash
=
this
.
_doComputeClientIDHash
(
)
;
}
return
this
.
_clientIDHash
;
}
async
_doComputeClientIDHash
(
)
{
const
clientID
=
await
this
.
getClientID
(
)
;
let
byteArr
=
new
TextEncoder
(
)
.
encode
(
clientID
)
;
let
hash
=
new
CryptoHash
(
"
sha256
"
)
;
hash
.
update
(
byteArr
byteArr
.
length
)
;
const
bytes
=
hash
.
finish
(
false
)
;
let
rem
=
0
;
for
(
let
i
=
0
len
=
bytes
.
length
;
i
<
len
;
i
+
+
)
{
rem
=
(
(
rem
<
<
8
)
+
(
bytes
[
i
]
.
charCodeAt
(
0
)
&
0xff
)
)
%
100
;
}
return
rem
;
}
getChannel
(
)
{
return
AppConstants
.
MOZ_UPDATE_CHANNEL
;
}
}
;
class
UptakeTelemetry
{
static
get
STATUS
(
)
{
return
{
.
.
.
UptakeTelemetry
.
HISTOGRAM_LABELS
SHUTDOWN_ERROR
:
"
shutdown_error
"
CORRUPTION_ERROR
:
"
corruption_error
"
}
;
}
static
get
HISTOGRAM_LABELS
(
)
{
return
{
UP_TO_DATE
:
"
up_to_date
"
SUCCESS
:
"
success
"
BACKOFF
:
"
backoff
"
PREF_DISABLED
:
"
pref_disabled
"
PARSE_ERROR
:
"
parse_error
"
CONTENT_ERROR
:
"
content_error
"
SIGNATURE_ERROR
:
"
sign_error
"
SIGNATURE_RETRY_ERROR
:
"
sign_retry_error
"
CONFLICT_ERROR
:
"
conflict_error
"
SYNC_ERROR
:
"
sync_error
"
APPLY_ERROR
:
"
apply_error
"
SERVER_ERROR
:
"
server_error
"
CERTIFICATE_ERROR
:
"
certificate_error
"
DOWNLOAD_ERROR
:
"
download_error
"
TIMEOUT_ERROR
:
"
timeout_error
"
NETWORK_ERROR
:
"
network_error
"
NETWORK_OFFLINE_ERROR
:
"
offline_error
"
CLEANUP_ERROR
:
"
cleanup_error
"
UNKNOWN_ERROR
:
"
unknown_error
"
CUSTOM_1_ERROR
:
"
custom_1_error
"
CUSTOM_2_ERROR
:
"
custom_2_error
"
CUSTOM_3_ERROR
:
"
custom_3_error
"
CUSTOM_4_ERROR
:
"
custom_4_error
"
CUSTOM_5_ERROR
:
"
custom_5_error
"
}
;
}
static
get
Policy
(
)
{
return
Policy
;
}
static
async
report
(
component
status
extra
=
{
}
)
{
const
{
source
}
=
extra
;
if
(
!
source
)
{
throw
new
Error
(
"
source
value
is
mandatory
.
"
)
;
}
if
(
!
this
.
_eventsEnabled
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
TELEMETRY_EVENTS_ID
true
)
;
this
.
_eventsEnabled
=
true
;
}
const
hash
=
await
UptakeTelemetry
.
Policy
.
getClientIDHash
(
)
;
const
channel
=
UptakeTelemetry
.
Policy
.
getChannel
(
)
;
const
shouldSendEvent
=
!
[
"
release
"
"
esr
"
]
.
includes
(
channel
)
|
|
hash
<
gSampleRate
;
if
(
shouldSendEvent
)
{
const
extraStr
=
Object
.
keys
(
extra
)
.
reduce
(
(
acc
k
)
=
>
{
acc
[
k
]
=
extra
[
k
]
.
toString
(
)
;
return
acc
;
}
{
}
)
;
Services
.
telemetry
.
recordEvent
(
TELEMETRY_EVENTS_ID
"
uptake
"
component
status
extraStr
)
;
}
if
(
Object
.
values
(
UptakeTelemetry
.
HISTOGRAM_LABELS
)
.
includes
(
status
)
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
TELEMETRY_HISTOGRAM_ID
)
.
add
(
source
status
)
;
}
}
}
this
.
UptakeTelemetry
=
UptakeTelemetry
;
