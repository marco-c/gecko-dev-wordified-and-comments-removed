"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
RemoteSettings
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
{
}
)
;
Cu
.
importGlobalProperties
(
[
"
fetch
"
]
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Kinto
"
"
resource
:
/
/
services
-
common
/
kinto
-
offline
-
client
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
KintoHttpClient
"
"
resource
:
/
/
services
-
common
/
kinto
-
http
-
client
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FirefoxAdapter
"
"
resource
:
/
/
services
-
common
/
kinto
-
storage
-
adapter
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
CanonicalJSON
"
"
resource
:
/
/
gre
/
modules
/
CanonicalJSON
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
UptakeTelemetry
"
"
resource
:
/
/
services
-
common
/
uptake
-
telemetry
.
js
"
)
;
const
PREF_SETTINGS_SERVER
=
"
services
.
settings
.
server
"
;
const
PREF_SETTINGS_DEFAULT_BUCKET
=
"
services
.
settings
.
default_bucket
"
;
const
PREF_SETTINGS_DEFAULT_SIGNER
=
"
services
.
settings
.
default_signer
"
;
const
PREF_SETTINGS_VERIFY_SIGNATURE
=
"
services
.
settings
.
verify_signature
"
;
const
PREF_SETTINGS_SERVER_BACKOFF
=
"
services
.
settings
.
server
.
backoff
"
;
const
PREF_SETTINGS_CHANGES_PATH
=
"
services
.
settings
.
changes
.
path
"
;
const
PREF_SETTINGS_LAST_UPDATE
=
"
services
.
settings
.
last_update_seconds
"
;
const
PREF_SETTINGS_LAST_ETAG
=
"
services
.
settings
.
last_etag
"
;
const
PREF_SETTINGS_CLOCK_SKEW_SECONDS
=
"
services
.
settings
.
clock_skew_seconds
"
;
const
PREF_SETTINGS_LOAD_DUMP
=
"
services
.
settings
.
load_dump
"
;
const
TELEMETRY_HISTOGRAM_KEY
=
"
settings
-
changes
-
monitoring
"
;
const
INVALID_SIGNATURE
=
"
Invalid
content
/
signature
"
;
const
KINTO_STORAGE_PATH
=
"
kinto
.
sqlite
"
;
function
mergeChanges
(
collection
localRecords
changes
)
{
const
records
=
{
}
;
localRecords
.
forEach
(
(
record
)
=
>
records
[
record
.
id
]
=
collection
.
cleanLocalFields
(
record
)
)
;
changes
.
forEach
(
(
record
)
=
>
records
[
record
.
id
]
=
record
)
;
return
Object
.
values
(
records
)
.
filter
(
(
record
)
=
>
!
record
.
deleted
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
id
<
b
.
id
)
{
return
-
1
;
}
return
a
.
id
>
b
.
id
?
1
:
0
;
}
)
;
}
function
fetchCollectionMetadata
(
remote
collection
)
{
const
client
=
new
KintoHttpClient
(
remote
)
;
return
client
.
bucket
(
collection
.
bucket
)
.
collection
(
collection
.
name
)
.
getData
(
)
.
then
(
result
=
>
{
return
result
.
signature
;
}
)
;
}
function
fetchRemoteCollection
(
remote
collection
)
{
const
client
=
new
KintoHttpClient
(
remote
)
;
return
client
.
bucket
(
collection
.
bucket
)
.
collection
(
collection
.
name
)
.
listRecords
(
{
sort
:
"
id
"
}
)
;
}
async
function
fetchLatestChanges
(
url
lastEtag
)
{
const
headers
=
{
}
;
if
(
lastEtag
)
{
headers
[
"
If
-
None
-
Match
"
]
=
lastEtag
;
}
const
response
=
await
fetch
(
url
{
headers
}
)
;
let
changes
=
[
]
;
if
(
response
.
status
!
=
304
)
{
let
payload
;
try
{
payload
=
await
response
.
json
(
)
;
}
catch
(
e
)
{
}
if
(
!
payload
.
hasOwnProperty
(
"
data
"
)
)
{
throw
new
Error
(
Server
error
response
{
JSON
.
stringify
(
payload
)
}
)
;
}
changes
=
payload
.
data
;
}
const
currentEtag
=
response
.
headers
.
has
(
"
ETag
"
)
?
response
.
headers
.
get
(
"
ETag
"
)
:
undefined
;
const
serverTimeMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Date
"
)
)
;
let
backoffSeconds
;
if
(
response
.
headers
.
has
(
"
Backoff
"
)
)
{
const
value
=
parseInt
(
response
.
headers
.
get
(
"
Backoff
"
)
10
)
;
if
(
!
isNaN
(
value
)
)
{
backoffSeconds
=
value
;
}
}
return
{
changes
currentEtag
serverTimeMillis
backoffSeconds
}
;
}
class
RemoteSettingsClient
{
constructor
(
collectionName
{
lastCheckTimePref
bucketName
signerName
}
)
{
this
.
collectionName
=
collectionName
;
this
.
lastCheckTimePref
=
lastCheckTimePref
;
this
.
bucketName
=
bucketName
;
this
.
signerName
=
signerName
;
this
.
_callbacks
=
new
Map
(
)
;
this
.
_callbacks
.
set
(
"
change
"
[
]
)
;
this
.
_kinto
=
null
;
}
get
identifier
(
)
{
return
{
this
.
bucketName
}
/
{
this
.
collectionName
}
;
}
get
filename
(
)
{
const
identifier
=
OS
.
Path
.
join
(
.
.
.
this
.
identifier
.
split
(
"
/
"
)
)
;
return
{
identifier
}
.
json
;
}
on
(
event
callback
)
{
if
(
!
this
.
_callbacks
.
has
(
event
)
)
{
throw
new
Error
(
Unknown
event
type
{
event
}
)
;
}
this
.
_callbacks
.
get
(
event
)
.
push
(
callback
)
;
}
async
openCollection
(
callback
options
=
{
}
)
{
const
{
bucket
=
this
.
bucketName
path
=
KINTO_STORAGE_PATH
}
=
options
;
if
(
!
this
.
_kinto
)
{
this
.
_kinto
=
new
Kinto
(
{
bucket
adapter
:
FirefoxAdapter
}
)
;
}
let
sqliteHandle
;
try
{
sqliteHandle
=
await
FirefoxAdapter
.
openConnection
(
{
path
}
)
;
const
colOptions
=
Object
.
assign
(
{
adapterOptions
:
{
sqliteHandle
}
}
options
)
;
const
{
collection
:
collectionName
=
this
.
collectionName
}
=
options
;
const
collection
=
this
.
_kinto
.
collection
(
collectionName
colOptions
)
;
return
await
callback
(
collection
)
;
}
finally
{
if
(
sqliteHandle
)
{
await
sqliteHandle
.
close
(
)
;
}
}
}
async
get
(
options
=
{
}
)
{
const
{
filters
order
}
=
options
;
return
this
.
openCollection
(
async
c
=
>
{
const
{
data
}
=
await
c
.
list
(
{
filters
order
}
)
;
return
data
;
}
)
;
}
async
maybeSync
(
lastModified
serverTime
options
=
{
loadDump
:
true
}
)
{
const
{
loadDump
}
=
options
;
const
remote
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_SERVER
)
;
const
verifySignature
=
Services
.
prefs
.
getBoolPref
(
PREF_SETTINGS_VERIFY_SIGNATURE
true
)
;
const
colOptions
=
{
}
;
if
(
this
.
signerName
&
&
verifySignature
)
{
colOptions
.
hooks
=
{
"
incoming
-
changes
"
:
[
(
payload
collection
)
=
>
{
return
this
.
_validateCollectionSignature
(
remote
payload
collection
)
;
}
]
}
;
}
let
reportStatus
=
null
;
try
{
return
await
this
.
openCollection
(
async
(
collection
)
=
>
{
let
collectionLastModified
=
await
collection
.
db
.
getLastModified
(
)
;
if
(
!
collectionLastModified
&
&
loadDump
)
{
try
{
const
initialData
=
await
this
.
_loadDumpFile
(
)
;
await
collection
.
loadDump
(
initialData
.
data
)
;
collectionLastModified
=
await
collection
.
db
.
getLastModified
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
if
(
lastModified
<
=
collectionLastModified
)
{
this
.
_updateLastCheck
(
serverTime
)
;
reportStatus
=
UptakeTelemetry
.
STATUS
.
UP_TO_DATE
;
return
;
}
try
{
const
strategy
=
Kinto
.
syncStrategy
.
SERVER_WINS
;
const
{
ok
}
=
await
collection
.
sync
(
{
remote
strategy
}
)
;
if
(
!
ok
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
CONFLICT_ERROR
;
throw
new
Error
(
"
Sync
failed
"
)
;
}
}
catch
(
e
)
{
if
(
e
.
message
=
=
INVALID_SIGNATURE
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
SIGNATURE_ERROR
;
const
payload
=
await
fetchRemoteCollection
(
remote
collection
)
;
try
{
await
this
.
_validateCollectionSignature
(
remote
payload
collection
{
ignoreLocal
:
true
}
)
;
}
catch
(
e
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
SIGNATURE_RETRY_ERROR
;
throw
e
;
}
const
localLastModified
=
await
collection
.
db
.
getLastModified
(
)
;
if
(
payload
.
last_modified
>
=
localLastModified
)
{
await
collection
.
clear
(
)
;
await
collection
.
loadDump
(
payload
.
data
)
;
}
}
else
{
if
(
/
NetworkError
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
NETWORK_ERROR
;
}
else
if
(
/
Backoff
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
BACKOFF
;
}
else
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
SYNC_ERROR
;
}
throw
e
;
}
}
const
{
data
}
=
await
collection
.
list
(
)
;
try
{
const
callbacks
=
this
.
_callbacks
.
get
(
"
change
"
)
;
for
(
const
cb
of
callbacks
)
{
await
cb
(
{
data
}
)
;
}
}
catch
(
e
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
APPLY_ERROR
;
throw
e
;
}
this
.
_updateLastCheck
(
serverTime
)
;
}
colOptions
)
;
}
catch
(
e
)
{
if
(
reportStatus
=
=
=
null
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
UNKNOWN_ERROR
;
}
throw
e
;
}
finally
{
if
(
reportStatus
=
=
=
null
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
SUCCESS
;
}
UptakeTelemetry
.
report
(
this
.
identifier
reportStatus
)
;
}
}
async
_loadDumpFile
(
)
{
const
{
components
:
folderFile
}
=
OS
.
Path
.
split
(
this
.
filename
)
;
const
fileURI
=
resource
:
/
/
app
/
defaults
/
{
folderFile
.
join
(
"
/
"
)
}
;
const
response
=
await
fetch
(
fileURI
)
;
if
(
!
response
.
ok
)
{
throw
new
Error
(
Could
not
read
from
'
{
fileURI
}
'
)
;
}
return
response
.
json
(
)
;
}
async
_validateCollectionSignature
(
remote
payload
collection
options
=
{
}
)
{
const
{
ignoreLocal
}
=
options
;
const
{
x5u
signature
}
=
await
fetchCollectionMetadata
(
remote
collection
)
;
const
certChainResponse
=
await
fetch
(
x5u
)
;
const
certChain
=
await
certChainResponse
.
text
(
)
;
const
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
let
toSerialize
;
if
(
ignoreLocal
)
{
toSerialize
=
{
last_modified
:
{
payload
.
last_modified
}
data
:
payload
.
data
}
;
}
else
{
const
{
data
:
localRecords
}
=
await
collection
.
list
(
)
;
const
records
=
mergeChanges
(
collection
localRecords
payload
.
changes
)
;
toSerialize
=
{
last_modified
:
{
payload
.
lastModified
}
data
:
records
}
;
}
const
serialized
=
CanonicalJSON
.
stringify
(
toSerialize
)
;
if
(
verifier
.
verifyContentSignature
(
serialized
"
p384ecdsa
=
"
+
signature
certChain
this
.
signerName
)
)
{
return
payload
;
}
throw
new
Error
(
INVALID_SIGNATURE
)
;
}
_updateLastCheck
(
serverTime
)
{
if
(
!
this
.
lastCheckTimePref
)
{
return
;
}
const
checkedServerTimeInSeconds
=
Math
.
round
(
serverTime
/
1000
)
;
Services
.
prefs
.
setIntPref
(
this
.
lastCheckTimePref
checkedServerTimeInSeconds
)
;
}
}
function
remoteSettingsFunction
(
)
{
const
_clients
=
new
Map
(
)
;
const
mainBucket
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_DEFAULT_BUCKET
)
;
const
defaultSigner
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_DEFAULT_SIGNER
)
;
const
remoteSettings
=
function
(
collectionName
options
)
{
const
rsOptions
=
{
bucketName
:
mainBucket
signerName
:
defaultSigner
.
.
.
options
}
;
const
{
bucketName
}
=
rsOptions
;
const
key
=
{
bucketName
}
/
{
collectionName
}
;
if
(
!
_clients
.
has
(
key
)
)
{
const
c
=
new
RemoteSettingsClient
(
collectionName
rsOptions
)
;
_clients
.
set
(
key
c
)
;
}
return
_clients
.
get
(
key
)
;
}
;
remoteSettings
.
pollChanges
=
async
(
)
=
>
{
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_SETTINGS_SERVER_BACKOFF
)
)
{
const
backoffReleaseTime
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_SERVER_BACKOFF
)
;
const
remainingMilliseconds
=
parseInt
(
backoffReleaseTime
10
)
-
Date
.
now
(
)
;
if
(
remainingMilliseconds
>
0
)
{
UptakeTelemetry
.
report
(
TELEMETRY_HISTOGRAM_KEY
UptakeTelemetry
.
STATUS
.
BACKOFF
)
;
throw
new
Error
(
Server
is
asking
clients
to
back
off
;
retry
in
{
Math
.
ceil
(
remainingMilliseconds
/
1000
)
}
s
.
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
PREF_SETTINGS_SERVER_BACKOFF
)
;
}
}
const
kintoBase
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_SERVER
)
;
const
changesEndpoint
=
kintoBase
+
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_CHANGES_PATH
)
;
let
lastEtag
;
if
(
Services
.
prefs
.
prefHasUserValue
(
PREF_SETTINGS_LAST_ETAG
)
)
{
lastEtag
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_LAST_ETAG
)
;
}
let
pollResult
;
try
{
pollResult
=
await
fetchLatestChanges
(
changesEndpoint
lastEtag
)
;
}
catch
(
e
)
{
let
report
;
if
(
/
Server
/
.
test
(
e
.
message
)
)
{
report
=
UptakeTelemetry
.
STATUS
.
SERVER_ERROR
;
}
else
if
(
/
NetworkError
/
.
test
(
e
.
message
)
)
{
report
=
UptakeTelemetry
.
STATUS
.
NETWORK_ERROR
;
}
else
{
report
=
UptakeTelemetry
.
STATUS
.
UNKNOWN_ERROR
;
}
UptakeTelemetry
.
report
(
TELEMETRY_HISTOGRAM_KEY
report
)
;
throw
new
Error
(
Polling
for
changes
failed
:
{
e
.
message
}
.
)
;
}
const
{
serverTimeMillis
changes
currentEtag
backoffSeconds
}
=
pollResult
;
const
report
=
changes
.
length
=
=
0
?
UptakeTelemetry
.
STATUS
.
UP_TO_DATE
:
UptakeTelemetry
.
STATUS
.
SUCCESS
;
UptakeTelemetry
.
report
(
TELEMETRY_HISTOGRAM_KEY
report
)
;
if
(
backoffSeconds
)
{
const
backoffReleaseTime
=
Date
.
now
(
)
+
backoffSeconds
*
1000
;
Services
.
prefs
.
setCharPref
(
PREF_SETTINGS_SERVER_BACKOFF
backoffReleaseTime
)
;
}
const
clockDifference
=
Math
.
floor
(
(
Date
.
now
(
)
-
serverTimeMillis
)
/
1000
)
;
Services
.
prefs
.
setIntPref
(
PREF_SETTINGS_CLOCK_SKEW_SECONDS
clockDifference
)
;
Services
.
prefs
.
setIntPref
(
PREF_SETTINGS_LAST_UPDATE
serverTimeMillis
/
1000
)
;
const
loadDump
=
Services
.
prefs
.
getBoolPref
(
PREF_SETTINGS_LOAD_DUMP
true
)
;
let
firstError
;
for
(
const
change
of
changes
)
{
const
{
bucket
collection
last_modified
:
lastModified
}
=
change
;
const
key
=
{
bucket
}
/
{
collection
}
;
if
(
!
_clients
.
has
(
key
)
)
{
continue
;
}
const
client
=
_clients
.
get
(
key
)
;
if
(
client
.
bucketName
!
=
bucket
)
{
continue
;
}
try
{
await
client
.
maybeSync
(
lastModified
serverTimeMillis
{
loadDump
}
)
;
}
catch
(
e
)
{
if
(
!
firstError
)
{
firstError
=
e
;
}
}
}
if
(
firstError
)
{
throw
firstError
;
}
if
(
currentEtag
)
{
Services
.
prefs
.
setCharPref
(
PREF_SETTINGS_LAST_ETAG
currentEtag
)
;
}
Services
.
obs
.
notifyObservers
(
null
"
remote
-
settings
-
changes
-
polled
"
)
;
}
;
return
remoteSettings
;
}
var
RemoteSettings
=
remoteSettingsFunction
(
)
;
