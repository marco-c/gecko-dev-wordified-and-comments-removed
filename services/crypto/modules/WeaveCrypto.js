var
EXPORTED_SYMBOLS
=
[
"
WeaveCrypto
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
crypto
"
]
)
;
const
CRYPT_ALGO
=
"
AES
-
CBC
"
;
const
CRYPT_ALGO_LENGTH
=
256
;
const
AES_CBC_IV_SIZE
=
16
;
const
OPERATIONS
=
{
ENCRYPT
:
0
DECRYPT
:
1
}
;
const
UTF_LABEL
=
"
utf
-
8
"
;
const
KEY_DERIVATION_ALGO
=
"
PBKDF2
"
;
const
KEY_DERIVATION_HASHING_ALGO
=
"
SHA
-
1
"
;
const
KEY_DERIVATION_ITERATIONS
=
4096
;
const
DERIVED_KEY_ALGO
=
CRYPT_ALGO
;
function
WeaveCrypto
(
)
{
this
.
init
(
)
;
}
WeaveCrypto
.
prototype
=
{
prefBranch
:
null
debug
:
true
observer
:
{
_self
:
null
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
observe
(
subject
topic
data
)
{
let
self
=
this
.
_self
;
self
.
log
(
"
Observed
"
+
topic
+
"
topic
.
"
)
;
if
(
topic
=
=
"
nsPref
:
changed
"
)
{
self
.
debug
=
self
.
prefBranch
.
getBoolPref
(
"
cryptoDebug
"
)
;
}
}
}
init
(
)
{
this
.
prefBranch
=
Services
.
prefs
.
getBranch
(
"
services
.
sync
.
log
.
"
)
;
this
.
prefBranch
.
addObserver
(
"
cryptoDebug
"
this
.
observer
)
;
this
.
observer
.
_self
=
this
;
this
.
debug
=
this
.
prefBranch
.
getBoolPref
(
"
cryptoDebug
"
false
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
encoder
"
(
)
=
>
new
TextEncoder
(
UTF_LABEL
)
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
decoder
"
(
)
=
>
new
TextDecoder
(
UTF_LABEL
{
fatal
:
true
}
)
)
;
}
log
(
message
)
{
if
(
!
this
.
debug
)
{
return
;
}
dump
(
"
WeaveCrypto
:
"
+
message
+
"
\
n
"
)
;
Services
.
console
.
logStringMessage
(
"
WeaveCrypto
:
"
+
message
)
;
}
_getCrypto
(
)
{
return
crypto
;
}
async
encrypt
(
clearTextUCS2
symmetricKey
iv
)
{
this
.
log
(
"
encrypt
(
)
called
"
)
;
let
clearTextBuffer
=
this
.
encoder
.
encode
(
clearTextUCS2
)
.
buffer
;
let
encrypted
=
await
this
.
_commonCrypt
(
clearTextBuffer
symmetricKey
iv
OPERATIONS
.
ENCRYPT
)
;
return
this
.
encodeBase64
(
encrypted
)
;
}
async
decrypt
(
cipherText
symmetricKey
iv
)
{
this
.
log
(
"
decrypt
(
)
called
"
)
;
if
(
cipherText
.
length
)
{
cipherText
=
atob
(
cipherText
)
;
}
let
cipherTextBuffer
=
this
.
byteCompressInts
(
cipherText
)
;
let
decrypted
=
await
this
.
_commonCrypt
(
cipherTextBuffer
symmetricKey
iv
OPERATIONS
.
DECRYPT
)
;
return
this
.
decoder
.
decode
(
decrypted
)
;
}
async
_commonCrypt
(
data
symKeyStr
ivStr
operation
)
{
this
.
log
(
"
_commonCrypt
(
)
called
"
)
;
ivStr
=
atob
(
ivStr
)
;
if
(
operation
!
=
=
OPERATIONS
.
ENCRYPT
&
&
operation
!
=
=
OPERATIONS
.
DECRYPT
)
{
throw
new
Error
(
"
Unsupported
operation
in
_commonCrypt
.
"
)
;
}
if
(
ivStr
.
length
!
=
=
AES_CBC_IV_SIZE
)
{
throw
new
Error
(
Invalid
IV
size
;
must
be
{
AES_CBC_IV_SIZE
}
bytes
.
)
;
}
let
iv
=
this
.
byteCompressInts
(
ivStr
)
;
let
symKey
=
await
this
.
importSymKey
(
symKeyStr
operation
)
;
let
cryptMethod
=
(
operation
=
=
=
OPERATIONS
.
ENCRYPT
?
crypto
.
subtle
.
encrypt
:
crypto
.
subtle
.
decrypt
)
.
bind
(
crypto
.
subtle
)
;
let
algo
=
{
name
:
CRYPT_ALGO
iv
}
;
let
keyBytes
=
await
cryptMethod
.
call
(
crypto
.
subtle
algo
symKey
data
)
;
return
new
Uint8Array
(
keyBytes
)
;
}
async
generateRandomKey
(
)
{
this
.
log
(
"
generateRandomKey
(
)
called
"
)
;
let
algo
=
{
name
:
CRYPT_ALGO
length
:
CRYPT_ALGO_LENGTH
}
;
let
key
=
await
crypto
.
subtle
.
generateKey
(
algo
true
[
]
)
;
let
keyBytes
=
await
crypto
.
subtle
.
exportKey
(
"
raw
"
key
)
;
return
this
.
encodeBase64
(
new
Uint8Array
(
keyBytes
)
)
;
}
generateRandomIV
(
)
{
return
this
.
generateRandomBytes
(
AES_CBC_IV_SIZE
)
;
}
generateRandomBytes
(
byteCount
)
{
this
.
log
(
"
generateRandomBytes
(
)
called
"
)
;
let
randBytes
=
new
Uint8Array
(
byteCount
)
;
crypto
.
getRandomValues
(
randBytes
)
;
return
this
.
encodeBase64
(
randBytes
)
;
}
_encryptionSymKeyMemo
:
{
}
_decryptionSymKeyMemo
:
{
}
async
importSymKey
(
encodedKeyString
operation
)
{
let
memo
;
switch
(
operation
)
{
case
OPERATIONS
.
ENCRYPT
:
memo
=
this
.
_encryptionSymKeyMemo
;
break
;
case
OPERATIONS
.
DECRYPT
:
memo
=
this
.
_decryptionSymKeyMemo
;
break
;
default
:
throw
new
Error
(
"
Unsupported
operation
in
importSymKey
.
"
)
;
}
if
(
encodedKeyString
in
memo
)
return
memo
[
encodedKeyString
]
;
let
symmetricKeyBuffer
=
this
.
makeUint8Array
(
encodedKeyString
true
)
;
let
algo
=
{
name
:
CRYPT_ALGO
}
;
let
usages
=
[
operation
=
=
=
OPERATIONS
.
ENCRYPT
?
"
encrypt
"
:
"
decrypt
"
]
;
let
symKey
=
await
crypto
.
subtle
.
importKey
(
"
raw
"
symmetricKeyBuffer
algo
false
usages
)
;
memo
[
encodedKeyString
]
=
symKey
;
return
symKey
;
}
byteCompressInts
(
str
)
{
let
arrayBuffer
=
new
Uint8Array
(
str
.
length
)
;
for
(
let
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
arrayBuffer
[
i
]
=
str
.
charCodeAt
(
i
)
&
0xFF
;
}
return
arrayBuffer
;
}
expandData
(
data
)
{
let
expanded
=
"
"
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
expanded
+
=
String
.
fromCharCode
(
data
[
i
]
)
;
}
return
expanded
;
}
encodeBase64
(
data
)
{
return
btoa
(
this
.
expandData
(
data
)
)
;
}
makeUint8Array
(
input
isEncoded
)
{
if
(
isEncoded
)
{
input
=
atob
(
input
)
;
}
return
this
.
byteCompressInts
(
input
)
;
}
}
;
