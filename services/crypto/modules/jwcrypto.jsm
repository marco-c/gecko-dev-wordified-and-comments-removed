"
use
strict
"
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
const
Cc
=
Components
.
classes
;
const
Cr
=
Components
.
results
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
IdentityCryptoService
"
"
mozilla
.
org
/
identity
/
crypto
-
service
;
1
"
"
nsIIdentityCryptoService
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
jwcrypto
"
]
;
const
PREF_LOG_LEVEL
=
"
services
.
crypto
.
jwcrypto
.
log
.
level
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Services
.
Crypto
.
jwcrypto
"
)
;
log
.
level
=
Log
.
Level
.
Error
;
let
appender
=
new
Log
.
DumpAppender
(
)
;
log
.
addAppender
(
appender
)
;
try
{
let
level
=
Services
.
prefs
.
getPrefType
(
PREF_LOG_LEVEL
)
=
=
Ci
.
nsIPrefBranch
.
PREF_STRING
&
&
Services
.
prefs
.
getCharPref
(
PREF_LOG_LEVEL
)
;
log
.
level
=
Log
.
Level
[
level
]
|
|
Log
.
Level
.
Error
;
}
catch
(
e
)
{
log
.
error
(
e
)
;
}
return
log
;
}
)
;
const
ALGORITHMS
=
{
RS256
:
"
RS256
"
DS160
:
"
DS160
"
}
;
const
DURATION_MS
=
1000
*
60
*
2
;
function
generateKeyPair
(
aAlgorithmName
aCallback
)
{
log
.
debug
(
"
Generate
key
pair
;
alg
=
"
+
aAlgorithmName
)
;
IdentityCryptoService
.
generateKeyPair
(
aAlgorithmName
function
(
rv
aKeyPair
)
{
if
(
!
Components
.
isSuccessCode
(
rv
)
)
{
return
aCallback
(
"
key
generation
failed
"
)
;
}
var
publicKey
;
switch
(
aKeyPair
.
keyType
)
{
case
ALGORITHMS
.
RS256
:
publicKey
=
{
algorithm
:
"
RS
"
exponent
:
aKeyPair
.
hexRSAPublicKeyExponent
modulus
:
aKeyPair
.
hexRSAPublicKeyModulus
}
;
break
;
case
ALGORITHMS
.
DS160
:
publicKey
=
{
algorithm
:
"
DS
"
y
:
aKeyPair
.
hexDSAPublicValue
p
:
aKeyPair
.
hexDSAPrime
q
:
aKeyPair
.
hexDSASubPrime
g
:
aKeyPair
.
hexDSAGenerator
}
;
break
;
default
:
return
aCallback
(
"
unknown
key
type
"
)
;
}
let
keyWrapper
=
{
serializedPublicKey
:
JSON
.
stringify
(
publicKey
)
_kp
:
aKeyPair
}
;
return
aCallback
(
null
keyWrapper
)
;
}
)
;
}
function
sign
(
aPayload
aKeypair
aCallback
)
{
aKeypair
.
_kp
.
sign
(
aPayload
function
(
rv
signature
)
{
if
(
!
Components
.
isSuccessCode
(
rv
)
)
{
log
.
error
(
"
signer
.
sign
failed
"
)
;
return
aCallback
(
"
Sign
failed
"
)
;
}
log
.
debug
(
"
signer
.
sign
:
success
"
)
;
return
aCallback
(
null
signature
)
;
}
)
;
}
function
jwcryptoClass
(
)
{
}
jwcryptoClass
.
prototype
=
{
getExpiration
(
duration
=
DURATION_MS
localtimeOffsetMsec
=
0
now
=
Date
.
now
(
)
)
{
return
now
+
localtimeOffsetMsec
+
duration
;
}
isCertValid
(
aCert
aCallback
)
{
aCallback
(
true
)
;
}
generateKeyPair
(
aAlgorithmName
aCallback
)
{
log
.
debug
(
"
generating
"
)
;
generateKeyPair
(
aAlgorithmName
aCallback
)
;
}
generateAssertion
(
aCert
aKeyPair
aAudience
aOptions
aCallback
)
{
if
(
typeof
aOptions
=
=
"
function
"
)
{
aCallback
=
aOptions
;
aOptions
=
{
}
;
}
var
header
=
{
"
alg
"
:
"
DS128
"
}
;
var
headerBytes
=
IdentityCryptoService
.
base64UrlEncode
(
JSON
.
stringify
(
header
)
)
;
var
payload
=
{
exp
:
this
.
getExpiration
(
aOptions
.
duration
aOptions
.
localtimeOffsetMsec
aOptions
.
now
)
aud
:
aAudience
}
;
var
payloadBytes
=
IdentityCryptoService
.
base64UrlEncode
(
JSON
.
stringify
(
payload
)
)
;
log
.
debug
(
"
payload
"
{
payload
payloadBytes
}
)
;
sign
(
headerBytes
+
"
.
"
+
payloadBytes
aKeyPair
function
(
err
signature
)
{
if
(
err
)
return
aCallback
(
err
)
;
var
signedAssertion
=
headerBytes
+
"
.
"
+
payloadBytes
+
"
.
"
+
signature
;
return
aCallback
(
null
aCert
+
"
~
"
+
signedAssertion
)
;
}
)
;
}
}
;
this
.
jwcrypto
=
new
jwcryptoClass
(
)
;
this
.
jwcrypto
.
ALGORITHMS
=
ALGORITHMS
;
