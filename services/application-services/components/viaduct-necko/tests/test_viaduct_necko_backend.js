"
use
strict
"
;
const
{
HttpServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
)
;
const
{
NetUtil
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
sys
.
mjs
"
)
;
let
gHttpServer
=
null
;
let
gServerPort
=
-
1
;
let
gServerURL
=
"
"
;
let
gRequestsReceived
=
[
]
;
function
decodeRequestBody
(
request
)
{
let
bodyStream
=
request
.
bodyInputStream
;
let
avail
=
bodyStream
.
available
(
)
;
if
(
avail
=
=
=
0
)
{
return
"
"
;
}
if
(
request
.
hasHeader
(
"
content
-
encoding
"
)
&
&
request
.
getHeader
(
"
content
-
encoding
"
)
=
=
=
"
gzip
"
)
{
return
"
[
gzipped
content
]
"
;
}
return
NetUtil
.
readInputStreamToString
(
bodyStream
avail
)
;
}
async
function
waitForRequestsToSettle
(
settleTime
=
300
timeout
=
10000
interval
=
50
)
{
let
start
=
Date
.
now
(
)
;
while
(
gRequestsReceived
.
length
=
=
=
0
)
{
if
(
Date
.
now
(
)
-
start
>
timeout
)
{
throw
new
Error
(
"
Timeout
waiting
for
initial
request
"
)
;
}
await
new
Promise
(
resolve
=
>
do_timeout
(
interval
resolve
)
)
;
}
let
lastCount
=
0
;
let
lastChangeTime
=
Date
.
now
(
)
;
while
(
Date
.
now
(
)
-
lastChangeTime
<
settleTime
)
{
if
(
Date
.
now
(
)
-
start
>
timeout
)
{
info
(
Timeout
waiting
for
requests
to
settle
proceeding
with
{
gRequestsReceived
.
length
}
requests
)
;
break
;
}
if
(
gRequestsReceived
.
length
!
=
=
lastCount
)
{
lastCount
=
gRequestsReceived
.
length
;
lastChangeTime
=
Date
.
now
(
)
;
}
await
new
Promise
(
resolve
=
>
do_timeout
(
interval
resolve
)
)
;
}
info
(
Requests
settled
with
{
gRequestsReceived
.
length
}
total
requests
)
;
}
add_setup
(
async
function
(
)
{
info
(
"
Setting
up
viaduct
-
necko
test
environment
"
)
;
do_get_profile
(
)
;
gHttpServer
=
new
HttpServer
(
)
;
setupTestEndpoints
(
)
;
gHttpServer
.
start
(
-
1
)
;
gServerPort
=
gHttpServer
.
identity
.
primaryPort
;
gServerURL
=
http
:
/
/
localhost
:
{
gServerPort
}
;
info
(
Test
HTTP
server
started
on
port
{
gServerPort
}
)
;
Services
.
prefs
.
setIntPref
(
"
telemetry
.
fog
.
test
.
localhost_port
"
gServerPort
)
;
Services
.
prefs
.
setBoolPref
(
"
datareporting
.
healthreport
.
uploadEnabled
"
true
)
;
Services
.
fog
.
testResetFOG
(
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
telemetry
.
fog
.
test
.
localhost_port
"
)
;
Services
.
prefs
.
clearUserPref
(
"
datareporting
.
healthreport
.
uploadEnabled
"
)
;
await
new
Promise
(
resolve
=
>
gHttpServer
.
stop
(
resolve
)
)
;
}
)
;
}
)
;
function
setupTestEndpoints
(
)
{
gHttpServer
.
registerPrefixHandler
(
"
/
submit
/
"
(
request
response
)
=
>
{
const
path
=
request
.
path
;
info
(
Viaduct
request
received
:
{
request
.
method
}
{
path
}
)
;
const
body
=
decodeRequestBody
(
request
)
;
const
pathParts
=
path
.
split
(
"
/
"
)
;
const
pingType
=
pathParts
[
3
]
|
|
"
unknown
"
;
gRequestsReceived
.
push
(
{
path
method
:
request
.
method
pingType
body
bodySize
:
request
.
hasHeader
(
"
content
-
length
"
)
?
parseInt
(
request
.
getHeader
(
"
content
-
length
"
)
10
)
:
body
.
length
headers
:
{
"
content
-
type
"
:
request
.
hasHeader
(
"
content
-
type
"
)
?
request
.
getHeader
(
"
content
-
type
"
)
:
null
"
content
-
encoding
"
:
request
.
hasHeader
(
"
content
-
encoding
"
)
?
request
.
getHeader
(
"
content
-
encoding
"
)
:
null
"
user
-
agent
"
:
request
.
hasHeader
(
"
user
-
agent
"
)
?
request
.
getHeader
(
"
user
-
agent
"
)
:
null
}
}
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
setHeader
(
"
Server
"
"
TestServer
/
1
.
0
(
Viaduct
Backend
)
"
)
;
response
.
setHeader
(
"
Date
"
new
Date
(
)
.
toUTCString
(
)
)
;
response
.
setHeader
(
"
Connection
"
"
close
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
const
responseBody
=
JSON
.
stringify
(
{
status
:
"
ok
"
message
:
"
Test
server
response
"
}
)
;
response
.
setHeader
(
"
Content
-
Length
"
responseBody
.
length
.
toString
(
)
)
;
response
.
write
(
responseBody
)
;
}
)
;
}
add_task
(
async
function
test_viaduct_backend_working
(
)
{
info
(
"
Testing
viaduct
-
necko
backend
initialization
and
request
processing
"
)
;
const
initialRequestCount
=
gRequestsReceived
.
length
;
info
(
Already
received
{
initialRequestCount
}
requests
during
initialization
)
;
await
waitForRequestsToSettle
(
)
;
Assert
.
ok
(
!
!
gRequestsReceived
.
length
Viaduct
-
necko
backend
is
processing
requests
.
Received
{
gRequestsReceived
.
length
}
requests
.
)
;
const
healthPings
=
gRequestsReceived
.
filter
(
r
=
>
r
.
pingType
=
=
=
"
health
"
)
;
info
(
Received
{
healthPings
.
length
}
health
pings
through
viaduct
-
necko
)
;
for
(
const
request
of
gRequestsReceived
)
{
Assert
.
equal
(
request
.
method
"
POST
"
Request
to
{
request
.
path
}
should
be
POST
)
;
}
const
pingTypes
=
[
.
.
.
new
Set
(
gRequestsReceived
.
map
(
r
=
>
r
.
pingType
)
)
]
;
info
(
Test
successful
:
Viaduct
-
necko
backend
processed
{
gRequestsReceived
.
length
}
requests
)
;
info
(
Ping
types
received
:
{
pingTypes
.
join
(
"
"
)
}
)
;
info
(
The
C
+
+
backend
successfully
handled
requests
from
Rust
through
the
FFI
layer
)
;
}
)
;
add_task
(
async
function
test_different_parameters
(
)
{
info
(
"
Testing
different
HTTP
parameters
through
viaduct
-
necko
"
)
;
const
requestCount
=
gRequestsReceived
.
length
;
info
(
Analyzing
{
requestCount
}
requests
from
previous
operations
)
;
const
contentTypes
=
new
Set
(
)
;
const
contentEncodings
=
new
Set
(
)
;
const
bodySizes
=
new
Set
(
)
;
for
(
const
request
of
gRequestsReceived
)
{
if
(
request
.
headers
[
"
content
-
type
"
]
)
{
contentTypes
.
add
(
request
.
headers
[
"
content
-
type
"
]
)
;
}
if
(
request
.
headers
[
"
content
-
encoding
"
]
)
{
contentEncodings
.
add
(
request
.
headers
[
"
content
-
encoding
"
]
)
;
}
if
(
request
.
bodySize
)
{
bodySizes
.
add
(
request
.
bodySize
)
;
}
}
info
(
Content
types
seen
:
{
Array
.
from
(
contentTypes
)
.
join
(
"
"
)
}
)
;
info
(
Content
encodings
seen
:
{
Array
.
from
(
contentEncodings
)
.
join
(
"
"
)
}
)
;
info
(
Body
sizes
seen
:
{
Array
.
from
(
bodySizes
)
.
sort
(
(
a
b
)
=
>
a
-
b
)
.
join
(
"
"
)
}
)
;
Assert
.
ok
(
!
!
gRequestsReceived
.
length
"
Different
parameters
were
processed
successfully
"
)
;
Assert
.
ok
(
bodySizes
.
size
>
=
1
Body
sizes
handled
:
{
Array
.
from
(
bodySizes
)
.
join
(
"
"
)
}
)
;
}
)
;
add_task
(
async
function
test_header_handling
(
)
{
info
(
"
Testing
header
handling
through
viaduct
-
necko
"
)
;
let
hasHeaders
=
false
;
let
headerCount
=
0
;
for
(
const
request
of
gRequestsReceived
)
{
if
(
request
.
headers
&
&
Object
.
keys
(
request
.
headers
)
.
length
)
{
hasHeaders
=
true
;
const
nonNullHeaders
=
Object
.
entries
(
request
.
headers
)
.
filter
(
(
[
value
]
)
=
>
value
!
=
=
null
)
;
if
(
nonNullHeaders
.
length
)
{
headerCount
+
+
;
info
(
Request
headers
found
:
{
JSON
.
stringify
(
Object
.
fromEntries
(
nonNullHeaders
)
)
}
)
;
}
}
}
Assert
.
ok
(
hasHeaders
"
Headers
are
properly
transmitted
through
viaduct
-
necko
"
)
;
Assert
.
ok
(
headerCount
>
0
Found
{
headerCount
}
requests
with
headers
)
;
const
hasContentType
=
gRequestsReceived
.
some
(
r
=
>
r
.
headers
&
&
r
.
headers
[
"
content
-
type
"
]
!
=
=
null
)
;
const
hasContentEncoding
=
gRequestsReceived
.
some
(
r
=
>
r
.
headers
&
&
r
.
headers
[
"
content
-
encoding
"
]
!
=
=
null
)
;
const
hasUserAgent
=
gRequestsReceived
.
some
(
r
=
>
r
.
headers
&
&
r
.
headers
[
"
user
-
agent
"
]
!
=
=
null
)
;
Assert
.
ok
(
hasContentType
"
Content
-
Type
header
is
present
"
)
;
Assert
.
ok
(
hasContentEncoding
"
Content
-
Encoding
header
is
present
"
)
;
Assert
.
ok
(
hasUserAgent
"
User
-
Agent
header
is
present
"
)
;
info
(
"
Headers
are
properly
handled
through
the
Rust
-
>
C
+
+
-
>
Necko
chain
"
)
;
}
)
;
add_task
(
async
function
test_configuration_validation
(
)
{
info
(
"
Validating
viaduct
-
necko
configuration
"
)
;
const
successfulRequests
=
gRequestsReceived
.
filter
(
r
=
>
r
.
method
=
=
=
"
POST
"
&
&
r
.
path
.
includes
(
"
/
submit
/
"
)
)
;
Assert
.
ok
(
!
!
successfulRequests
.
length
Configuration
is
valid
:
{
successfulRequests
.
length
}
successful
requests
processed
)
;
info
(
"
Viaduct
-
necko
backend
configuration
validated
through
successful
request
processing
"
)
;
}
)
;
