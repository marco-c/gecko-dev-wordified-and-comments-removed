use
error_support
:
:
{
info
warn
}
;
use
std
:
:
{
ffi
:
:
{
CStr
c_char
}
ptr
slice
sync
:
:
Arc
}
;
use
url
:
:
Url
;
use
viaduct
:
:
{
init_backend
Backend
ClientSettings
Method
Request
Response
Result
ViaductError
}
;
const
NULL
:
char
=
'
\
0
'
;
#
[
repr
(
C
)
]
pub
struct
FfiRequest
{
pub
timeout
:
u32
pub
redirect_limit
:
u32
pub
method
:
Method
pub
url
:
*
mut
u8
pub
headers
:
*
mut
FfiHeader
pub
header_count
:
usize
pub
body
:
*
mut
u8
pub
body_len
:
usize
}
#
[
repr
(
C
)
]
pub
struct
FfiHeader
{
pub
key
:
*
mut
u8
pub
value
:
*
mut
u8
}
pub
struct
FfiResult
{
sender
:
Option
<
oneshot
:
:
Sender
<
Result
<
Response
>
>
>
response
:
Response
pub
url
:
String
pub
headers
:
Vec
<
(
String
String
)
>
pub
body
:
Option
<
Vec
<
u8
>
>
pub
request
:
FfiRequest
pub
ffi_headers
:
Vec
<
FfiHeader
>
}
extern
"
C
"
{
fn
viaduct_necko_backend_init
(
)
;
#
[
allow
(
improper_ctypes
)
]
fn
viaduct_necko_backend_send_request
(
request
:
*
const
FfiRequest
result
:
*
mut
FfiResult
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_set_url
(
result
:
*
mut
FfiResult
url
:
*
const
u8
length
:
usize
)
{
let
result
=
unsafe
{
&
mut
*
result
}
;
let
url_bytes
=
unsafe
{
slice
:
:
from_raw_parts
(
url
length
)
}
;
if
!
url_bytes
.
is_ascii
(
)
{
warn
!
(
"
Non
-
ASCII
URL
received
-
length
:
{
}
-
skipping
URL
update
"
length
)
;
return
;
}
let
url_str
=
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
url_bytes
)
}
;
match
Url
:
:
parse
(
url_str
)
{
Ok
(
url
)
=
>
{
result
.
response
.
url
=
url
;
}
Err
(
e
)
=
>
{
warn
!
(
"
Error
parsing
URL
from
C
backend
:
{
e
}
"
)
}
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_set_status_code
(
result
:
*
mut
FfiResult
code
:
u16
)
{
let
result
=
unsafe
{
&
mut
*
result
}
;
result
.
response
.
status
=
code
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_add_header
(
result
:
*
mut
FfiResult
key
:
*
const
u8
key_length
:
usize
value
:
*
const
u8
value_length
:
usize
)
{
let
result
=
unsafe
{
&
mut
*
result
}
;
let
key_bytes
=
unsafe
{
slice
:
:
from_raw_parts
(
key
key_length
)
}
;
let
value_bytes
=
unsafe
{
slice
:
:
from_raw_parts
(
value
value_length
)
}
;
if
!
key_bytes
.
is_ascii
(
)
|
|
!
value_bytes
.
is_ascii
(
)
{
warn
!
(
"
Non
-
ASCII
HTTP
header
received
-
key_len
:
{
}
value_len
:
{
}
-
skipping
header
"
key_length
value_length
)
;
return
;
}
let
(
key
value
)
=
unsafe
{
(
String
:
:
from_utf8_unchecked
(
key_bytes
.
to_vec
(
)
)
String
:
:
from_utf8_unchecked
(
value_bytes
.
to_vec
(
)
)
)
}
;
let
_
=
result
.
response
.
headers
.
insert
(
key
value
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_extend_body
(
result
:
*
mut
FfiResult
data
:
*
const
u8
length
:
usize
)
{
let
result
=
unsafe
{
&
mut
*
result
}
;
result
.
response
.
body
.
extend_from_slice
(
unsafe
{
slice
:
:
from_raw_parts
(
data
length
)
}
)
;
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_complete
(
result
:
*
mut
FfiResult
)
{
let
mut
result
=
unsafe
{
Box
:
:
from_raw
(
result
)
}
;
match
result
.
sender
.
take
(
)
{
Some
(
sender
)
=
>
{
let
_
=
sender
.
send
(
Ok
(
result
.
response
)
)
;
}
None
=
>
warn
!
(
"
viaduct
-
necko
:
result
completed
twice
"
)
}
}
#
[
no_mangle
]
pub
unsafe
extern
"
C
"
fn
viaduct_necko_result_complete_error
(
result
:
*
mut
FfiResult
error_code
:
u32
message
:
*
const
u8
)
{
let
mut
result
=
unsafe
{
Box
:
:
from_raw
(
result
)
}
;
let
msg_str
=
unsafe
{
CStr
:
:
from_ptr
(
message
as
*
const
c_char
)
.
to_string_lossy
(
)
.
into_owned
(
)
}
;
let
msg
=
format
!
(
"
{
}
(
0x
{
:
08x
}
)
"
msg_str
error_code
)
;
match
result
.
sender
.
take
(
)
{
Some
(
sender
)
=
>
{
let
_
=
sender
.
send
(
Err
(
ViaductError
:
:
BackendError
(
msg
)
)
)
;
}
None
=
>
warn
!
(
"
viaduct
-
necko
:
result
completed
twice
"
)
}
}
struct
NeckoBackend
;
pub
fn
init_necko_backend
(
)
-
>
Result
<
(
)
>
{
info
!
(
"
Initializing
viaduct
Necko
backend
"
)
;
unsafe
{
viaduct_necko_backend_init
(
)
}
;
init_backend
(
Arc
:
:
new
(
NeckoBackend
)
)
}
#
[
async_trait
:
:
async_trait
]
impl
Backend
for
NeckoBackend
{
async
fn
send_request
(
&
self
request
:
Request
settings
:
ClientSettings
)
-
>
Result
<
Response
>
{
let
mut
url
=
request
.
url
.
to_string
(
)
;
url
.
push
(
NULL
)
;
let
header_strings
:
Vec
<
(
String
String
)
>
=
request
.
headers
.
iter
(
)
.
map
(
|
h
|
{
let
mut
key_str
=
h
.
name
(
)
.
to_string
(
)
;
key_str
.
push
(
NULL
)
;
let
mut
value_str
=
h
.
value
(
)
.
to_string
(
)
;
value_str
.
push
(
NULL
)
;
(
key_str
value_str
)
}
)
.
collect
(
)
;
let
(
sender
receiver
)
=
oneshot
:
:
channel
(
)
;
let
mut
result
=
Box
:
:
new
(
FfiResult
{
sender
:
Some
(
sender
)
response
:
Response
{
request_method
:
request
.
method
url
:
request
.
url
.
clone
(
)
status
:
0
headers
:
viaduct
:
:
Headers
:
:
new
(
)
body
:
Vec
:
:
default
(
)
}
url
headers
:
header_strings
body
:
request
.
body
request
:
FfiRequest
{
timeout
:
settings
.
timeout
redirect_limit
:
settings
.
redirect_limit
method
:
request
.
method
url
:
ptr
:
:
null_mut
(
)
headers
:
ptr
:
:
null_mut
(
)
header_count
:
0
body
:
ptr
:
:
null_mut
(
)
body_len
:
0
}
ffi_headers
:
Vec
:
:
new
(
)
}
)
;
result
.
ffi_headers
=
result
.
headers
.
iter_mut
(
)
.
map
(
|
(
key
value
)
|
FfiHeader
{
key
:
key
.
as_mut_ptr
(
)
value
:
value
.
as_mut_ptr
(
)
}
)
.
collect
(
)
;
let
(
body_ptr
body_len
)
=
match
&
result
.
body
{
Some
(
body
)
=
>
(
body
.
as_ptr
(
)
as
*
mut
u8
body
.
len
(
)
)
None
=
>
(
ptr
:
:
null_mut
(
)
0
)
}
;
result
.
request
.
url
=
result
.
url
.
as_mut_ptr
(
)
;
result
.
request
.
headers
=
result
.
ffi_headers
.
as_mut_ptr
(
)
;
result
.
request
.
header_count
=
result
.
ffi_headers
.
len
(
)
;
result
.
request
.
body
=
body_ptr
;
result
.
request
.
body_len
=
body_len
;
let
request_ptr
=
&
result
.
request
as
*
const
FfiRequest
;
unsafe
{
viaduct_necko_backend_send_request
(
request_ptr
Box
:
:
into_raw
(
result
)
)
;
}
;
receiver
.
await
.
unwrap_or_else
(
|
_
|
{
Err
(
ViaductError
:
:
BackendError
(
"
Error
receiving
result
from
C
+
+
backend
"
.
to_string
(
)
)
)
}
)
}
}
unsafe
impl
Send
for
FfiRequest
{
}
unsafe
impl
Send
for
FfiResult
{
}
unsafe
impl
Send
for
FfiHeader
{
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
test_method_layout
(
)
{
assert_eq
!
(
Method
:
:
Get
as
u8
0
)
;
assert_eq
!
(
Method
:
:
Head
as
u8
1
)
;
assert_eq
!
(
Method
:
:
Post
as
u8
2
)
;
assert_eq
!
(
Method
:
:
Put
as
u8
3
)
;
assert_eq
!
(
Method
:
:
Delete
as
u8
4
)
;
assert_eq
!
(
Method
:
:
Connect
as
u8
5
)
;
assert_eq
!
(
Method
:
:
Options
as
u8
6
)
;
assert_eq
!
(
Method
:
:
Trace
as
u8
7
)
;
assert_eq
!
(
Method
:
:
Patch
as
u8
8
)
;
}
}
