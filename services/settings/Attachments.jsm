var
EXPORTED_SYMBOLS
=
[
"
Downloader
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
RemoteSettingsWorker
"
"
resource
:
/
/
services
-
settings
/
RemoteSettingsWorker
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
class
DownloadError
extends
Error
{
constructor
(
url
resp
)
{
super
(
Could
not
download
{
url
}
)
;
this
.
name
=
"
DownloadError
"
;
this
.
resp
=
resp
;
}
}
class
BadContentError
extends
Error
{
constructor
(
path
)
{
super
(
{
path
}
content
does
not
match
server
hash
)
;
this
.
name
=
"
BadContentError
"
;
}
}
class
Downloader
{
static
get
DownloadError
(
)
{
return
DownloadError
;
}
static
get
BadContentError
(
)
{
return
BadContentError
;
}
constructor
(
.
.
.
folders
)
{
this
.
folders
=
[
"
settings
"
.
.
.
folders
]
;
this
.
_cdnURL
=
null
;
}
async
download
(
record
options
=
{
}
)
{
const
{
retries
=
3
}
=
options
;
const
{
attachment
:
{
location
filename
hash
size
}
}
=
record
;
const
localFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
filename
)
;
const
localFileUrl
=
file
:
/
/
{
[
.
.
.
OS
.
Path
.
split
(
OS
.
Constants
.
Path
.
localProfileDir
)
.
components
.
.
.
this
.
folders
filename
]
.
join
(
"
/
"
)
}
;
const
remoteFileUrl
=
(
await
this
.
_baseAttachmentsURL
(
)
)
+
location
;
await
this
.
_makeDirs
(
)
;
let
retried
=
0
;
while
(
true
)
{
if
(
await
RemoteSettingsWorker
.
checkFileHash
(
localFileUrl
size
hash
)
)
{
return
localFileUrl
;
}
if
(
retried
>
retries
)
{
throw
new
Downloader
.
BadContentError
(
localFilePath
)
;
}
try
{
await
this
.
_fetchAttachment
(
remoteFileUrl
localFilePath
)
;
}
catch
(
e
)
{
if
(
retried
>
=
retries
)
{
throw
e
;
}
}
retried
+
+
;
}
}
async
delete
(
record
)
{
const
{
attachment
:
{
filename
}
}
=
record
;
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
filename
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
await
this
.
_rmDirs
(
)
;
}
async
_baseAttachmentsURL
(
)
{
if
(
!
this
.
_cdnURL
)
{
const
server
=
Services
.
prefs
.
getCharPref
(
"
services
.
settings
.
server
"
)
;
const
serverInfo
=
await
(
await
fetch
(
{
server
}
/
)
)
.
json
(
)
;
const
{
capabilities
:
{
attachments
:
{
base_url
}
}
}
=
serverInfo
;
this
.
_cdnURL
=
base_url
+
(
base_url
.
endsWith
(
"
/
"
)
?
"
"
:
"
/
"
)
;
}
return
this
.
_cdnURL
;
}
async
_fetchAttachment
(
url
destination
)
{
const
headers
=
new
Headers
(
)
;
headers
.
set
(
"
Accept
-
Encoding
"
"
gzip
"
)
;
const
resp
=
await
fetch
(
url
{
headers
}
)
;
if
(
!
resp
.
ok
)
{
throw
new
Downloader
.
DownloadError
(
url
resp
)
;
}
const
buffer
=
await
resp
.
arrayBuffer
(
)
;
await
OS
.
File
.
writeAtomic
(
destination
buffer
{
tmpPath
:
{
destination
}
.
tmp
}
)
;
}
async
_makeDirs
(
)
{
const
dirPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
)
;
await
OS
.
File
.
makeDir
(
dirPath
{
from
:
OS
.
Constants
.
Path
.
localProfileDir
}
)
;
}
async
_rmDirs
(
)
{
for
(
let
i
=
this
.
folders
.
length
;
i
>
0
;
i
-
-
)
{
const
dirPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
.
slice
(
0
i
)
)
;
try
{
await
OS
.
File
.
removeEmptyDir
(
dirPath
{
ignoreAbsent
:
true
}
)
;
}
catch
(
e
)
{
break
;
}
}
}
}
