var
EXPORTED_SYMBOLS
=
[
"
Downloader
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
RemoteSettingsWorker
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsWorker
.
jsm
"
Utils
:
"
resource
:
/
/
services
-
settings
/
Utils
.
jsm
"
}
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
class
DownloadError
extends
Error
{
constructor
(
url
resp
)
{
super
(
Could
not
download
{
url
}
)
;
this
.
name
=
"
DownloadError
"
;
this
.
resp
=
resp
;
}
}
class
BadContentError
extends
Error
{
constructor
(
path
)
{
super
(
{
path
}
content
does
not
match
server
hash
)
;
this
.
name
=
"
BadContentError
"
;
}
}
class
LazyRecordAndBuffer
{
constructor
(
getRecordAndLazyBuffer
)
{
this
.
getRecordAndLazyBuffer
=
getRecordAndLazyBuffer
;
}
async
_ensureRecordAndLazyBuffer
(
)
{
if
(
!
this
.
recordAndLazyBufferPromise
)
{
this
.
recordAndLazyBufferPromise
=
this
.
getRecordAndLazyBuffer
(
)
;
}
return
this
.
recordAndLazyBufferPromise
;
}
async
getRecord
(
)
{
try
{
return
(
await
this
.
_ensureRecordAndLazyBuffer
(
)
)
.
record
;
}
catch
(
e
)
{
return
null
;
}
}
async
isMatchingRequestedRecord
(
requestedRecord
)
{
const
record
=
await
this
.
getRecord
(
)
;
return
(
record
&
&
record
.
last_modified
=
=
=
requestedRecord
.
last_modified
&
&
record
.
attachment
.
size
=
=
=
requestedRecord
.
attachment
.
size
&
&
record
.
attachment
.
hash
=
=
=
requestedRecord
.
attachment
.
hash
)
;
}
async
getResult
(
)
{
const
{
record
readBuffer
}
=
await
this
.
_ensureRecordAndLazyBuffer
(
)
;
if
(
!
this
.
bufferPromise
)
{
this
.
bufferPromise
=
readBuffer
(
)
;
}
return
{
record
buffer
:
await
this
.
bufferPromise
}
;
}
}
class
Downloader
{
static
get
DownloadError
(
)
{
return
DownloadError
;
}
static
get
BadContentError
(
)
{
return
BadContentError
;
}
constructor
(
.
.
.
folders
)
{
this
.
folders
=
[
"
settings
"
.
.
.
folders
]
;
this
.
_cdnURL
=
null
;
}
get
cacheImpl
(
)
{
throw
new
Error
(
"
This
Downloader
does
not
support
caching
"
)
;
}
async
download
(
record
options
)
{
let
{
retries
checkHash
attachmentId
=
record
?
.
id
useCache
=
false
fallbackToCache
=
false
fallbackToDump
=
false
}
=
options
|
|
{
}
;
if
(
!
useCache
)
{
return
this
.
downloadToDisk
(
record
options
)
;
}
if
(
!
this
.
cacheImpl
)
{
throw
new
Error
(
"
useCache
is
true
but
there
is
no
cacheImpl
!
"
)
;
}
if
(
!
attachmentId
)
{
throw
new
Error
(
"
download
(
)
was
called
without
attachmentId
or
recordID
"
)
;
}
const
dumpInfo
=
new
LazyRecordAndBuffer
(
(
)
=
>
this
.
_readAttachmentDump
(
attachmentId
)
)
;
const
cacheInfo
=
new
LazyRecordAndBuffer
(
(
)
=
>
this
.
_readAttachmentCache
(
attachmentId
)
)
;
if
(
fallbackToDump
&
&
record
)
{
if
(
await
dumpInfo
.
isMatchingRequestedRecord
(
record
)
)
{
try
{
return
{
.
.
.
(
await
dumpInfo
.
getResult
(
)
)
_source
:
"
dump_match
"
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
if
(
useCache
&
&
record
)
{
if
(
await
cacheInfo
.
isMatchingRequestedRecord
(
record
)
)
{
try
{
return
{
.
.
.
(
await
cacheInfo
.
getResult
(
)
)
_source
:
"
cache_match
"
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
let
errorIfAllFails
;
if
(
record
&
&
record
.
attachment
)
{
try
{
const
newBuffer
=
await
this
.
downloadAsBytes
(
record
{
retries
checkHash
}
)
;
const
blob
=
new
Blob
(
[
newBuffer
]
)
;
if
(
useCache
)
{
this
.
cacheImpl
.
set
(
attachmentId
{
record
blob
}
)
.
catch
(
e
=
>
Cu
.
reportError
(
e
)
)
;
}
return
{
buffer
:
newBuffer
record
_source
:
"
remote_match
"
}
;
}
catch
(
e
)
{
errorIfAllFails
=
e
;
}
}
const
cacheRecord
=
fallbackToCache
&
&
(
await
cacheInfo
.
getRecord
(
)
)
;
if
(
cacheRecord
)
{
const
dumpRecord
=
fallbackToDump
&
&
(
await
dumpInfo
.
getRecord
(
)
)
;
if
(
dumpRecord
?
.
last_modified
>
=
cacheRecord
.
last_modified
)
{
try
{
return
{
.
.
.
(
await
dumpInfo
.
getResult
(
)
)
_source
:
"
dump_fallback
"
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
try
{
return
{
.
.
.
(
await
cacheInfo
.
getResult
(
)
)
_source
:
"
cache_fallback
"
}
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
if
(
fallbackToDump
&
&
(
await
dumpInfo
.
getRecord
(
)
)
)
{
try
{
return
{
.
.
.
(
await
dumpInfo
.
getResult
(
)
)
_source
:
"
dump_fallback
"
}
;
}
catch
(
e
)
{
errorIfAllFails
=
e
;
}
}
if
(
errorIfAllFails
)
{
throw
errorIfAllFails
;
}
throw
new
Downloader
.
DownloadError
(
attachmentId
)
;
}
async
downloadToDisk
(
record
options
=
{
}
)
{
const
{
retries
=
3
}
=
options
;
const
{
attachment
:
{
filename
size
hash
}
}
=
record
;
const
localFilePath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
filename
)
;
const
localFileUrl
=
file
:
/
/
{
[
.
.
.
OS
.
Path
.
split
(
OS
.
Constants
.
Path
.
localProfileDir
)
.
components
.
.
.
this
.
folders
filename
]
.
join
(
"
/
"
)
}
;
await
this
.
_makeDirs
(
)
;
let
retried
=
0
;
while
(
true
)
{
if
(
await
RemoteSettingsWorker
.
checkFileHash
(
localFileUrl
size
hash
)
)
{
return
localFileUrl
;
}
if
(
retried
>
retries
)
{
throw
new
Downloader
.
BadContentError
(
localFilePath
)
;
}
try
{
const
buffer
=
await
this
.
downloadAsBytes
(
record
{
checkHash
:
false
retries
:
0
}
)
;
await
OS
.
File
.
writeAtomic
(
localFilePath
buffer
{
tmpPath
:
{
localFilePath
}
.
tmp
}
)
;
}
catch
(
e
)
{
if
(
retried
>
=
retries
)
{
throw
e
;
}
}
retried
+
+
;
}
}
async
downloadAsBytes
(
record
options
=
{
}
)
{
const
{
attachment
:
{
location
hash
size
}
}
=
record
;
const
remoteFileUrl
=
(
await
this
.
_baseAttachmentsURL
(
)
)
+
location
;
const
{
retries
=
3
checkHash
=
true
}
=
options
;
let
retried
=
0
;
while
(
true
)
{
try
{
const
buffer
=
await
this
.
_fetchAttachment
(
remoteFileUrl
)
;
if
(
!
checkHash
)
{
return
buffer
;
}
if
(
await
RemoteSettingsWorker
.
checkContentHash
(
buffer
size
hash
)
)
{
return
buffer
;
}
throw
new
Downloader
.
BadContentError
(
location
)
;
}
catch
(
e
)
{
if
(
retried
>
=
retries
)
{
throw
e
;
}
}
retried
+
+
;
}
}
async
delete
(
record
)
{
const
{
attachment
:
{
filename
}
}
=
record
;
const
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
filename
)
;
await
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
await
this
.
_rmDirs
(
)
;
}
async
deleteCached
(
attachmentId
)
{
return
this
.
cacheImpl
.
delete
(
attachmentId
)
;
}
async
_baseAttachmentsURL
(
)
{
if
(
!
this
.
_cdnURL
)
{
const
server
=
Utils
.
SERVER_URL
;
const
serverInfo
=
await
(
await
Utils
.
fetch
(
{
server
}
/
)
)
.
json
(
)
;
const
{
capabilities
:
{
attachments
:
{
base_url
}
}
}
=
serverInfo
;
this
.
_cdnURL
=
base_url
+
(
base_url
.
endsWith
(
"
/
"
)
?
"
"
:
"
/
"
)
;
}
return
this
.
_cdnURL
;
}
async
_fetchAttachment
(
url
)
{
const
headers
=
new
Headers
(
)
;
headers
.
set
(
"
Accept
-
Encoding
"
"
gzip
"
)
;
const
resp
=
await
Utils
.
fetch
(
url
{
headers
}
)
;
if
(
!
resp
.
ok
)
{
throw
new
Downloader
.
DownloadError
(
url
resp
)
;
}
return
resp
.
arrayBuffer
(
)
;
}
async
_readAttachmentCache
(
attachmentId
)
{
const
cached
=
await
this
.
cacheImpl
.
get
(
attachmentId
)
;
if
(
!
cached
)
{
throw
new
Downloader
.
DownloadError
(
attachmentId
)
;
}
return
{
record
:
cached
.
record
async
readBuffer
(
)
{
const
buffer
=
await
cached
.
blob
.
arrayBuffer
(
)
;
const
{
size
hash
}
=
cached
.
record
.
attachment
;
if
(
await
RemoteSettingsWorker
.
checkContentHash
(
buffer
size
hash
)
)
{
return
buffer
;
}
throw
new
Downloader
.
BadContentError
(
attachmentId
)
;
}
}
;
}
async
_readAttachmentDump
(
attachmentId
)
{
async
function
fetchResource
(
resourceUrl
)
{
try
{
return
await
fetch
(
resourceUrl
)
;
}
catch
(
e
)
{
throw
new
Downloader
.
DownloadError
(
resourceUrl
)
;
}
}
const
resourceUrlPrefix
=
Downloader
.
_RESOURCE_BASE_URL
+
"
/
"
+
this
.
folders
.
join
(
"
/
"
)
+
"
/
"
;
const
recordUrl
=
{
resourceUrlPrefix
}
{
attachmentId
}
.
meta
.
json
;
const
attachmentUrl
=
{
resourceUrlPrefix
}
{
attachmentId
}
;
const
record
=
await
(
await
fetchResource
(
recordUrl
)
)
.
json
(
)
;
return
{
record
async
readBuffer
(
)
{
return
(
await
fetchResource
(
attachmentUrl
)
)
.
arrayBuffer
(
)
;
}
}
;
}
static
_RESOURCE_BASE_URL
=
"
resource
:
/
/
app
/
defaults
"
;
async
_makeDirs
(
)
{
const
dirPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
)
;
await
OS
.
File
.
makeDir
(
dirPath
{
from
:
OS
.
Constants
.
Path
.
localProfileDir
}
)
;
}
async
_rmDirs
(
)
{
for
(
let
i
=
this
.
folders
.
length
;
i
>
0
;
i
-
-
)
{
const
dirPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
localProfileDir
.
.
.
this
.
folders
.
slice
(
0
i
)
)
;
try
{
await
OS
.
File
.
removeEmptyDir
(
dirPath
{
ignoreAbsent
:
true
}
)
;
}
catch
(
e
)
{
break
;
}
}
}
}
