var
EXPORTED_SYMBOLS
=
[
"
Utils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
CaptivePortalService
"
"
mozilla
.
org
/
network
/
captive
-
portal
-
service
;
1
"
"
nsICaptivePortalService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gNetworkLinkService
"
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
"
nsINetworkLinkService
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
const
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
maxLogLevel
:
"
warn
"
maxLogLevelPref
:
"
services
.
settings
.
loglevel
"
prefix
:
"
services
.
settings
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gServerURL
"
"
services
.
settings
.
server
"
)
;
var
Utils
=
{
get
SERVER_URL
(
)
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
isXpcshell
=
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
return
AppConstants
.
RELEASE_OR_BETA
&
&
!
Cu
.
isInAutomation
&
&
!
isXpcshell
?
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
"
:
gServerURL
;
}
CHANGES_PATH
:
"
/
buckets
/
monitor
/
collections
/
changes
/
records
"
log
get
isOffline
(
)
{
try
{
return
(
Services
.
io
.
offline
|
|
CaptivePortalService
.
state
=
=
CaptivePortalService
.
LOCKED_PORTAL
|
|
!
gNetworkLinkService
.
isLinkUp
)
;
}
catch
(
ex
)
{
log
.
warn
(
"
Could
not
determine
network
status
.
"
ex
)
;
}
return
false
;
}
async
hasLocalData
(
client
)
{
const
timestamp
=
await
client
.
db
.
getLastModified
(
)
;
return
timestamp
!
=
=
null
;
}
async
hasLocalDump
(
bucket
collection
)
{
try
{
await
fetch
(
resource
:
/
/
app
/
defaults
/
settings
/
{
bucket
}
/
{
collection
}
.
json
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
async
fetchLatestChanges
(
serverUrl
options
=
{
}
)
{
const
{
expectedTimestamp
lastEtag
=
"
"
filters
=
{
}
}
=
options
;
let
url
=
serverUrl
+
Utils
.
CHANGES_PATH
;
const
headers
=
{
}
;
const
params
=
{
.
.
.
filters
}
;
if
(
lastEtag
!
=
"
"
)
{
headers
[
"
If
-
None
-
Match
"
]
=
lastEtag
;
params
.
_since
=
lastEtag
;
}
if
(
expectedTimestamp
)
{
params
.
_expected
=
expectedTimestamp
;
}
if
(
params
)
{
url
+
=
"
?
"
+
Object
.
entries
(
params
)
.
map
(
(
[
k
v
]
)
=
>
{
k
}
=
{
encodeURIComponent
(
v
)
}
)
.
join
(
"
&
"
)
;
}
const
response
=
await
fetch
(
url
{
headers
}
)
;
let
changes
=
[
]
;
if
(
response
.
status
!
=
304
)
{
if
(
response
.
status
>
=
500
)
{
throw
new
Error
(
Server
error
{
response
.
status
}
{
response
.
statusText
}
)
;
}
const
is404FromCustomServer
=
response
.
status
=
=
404
&
&
Services
.
prefs
.
prefHasUserValue
(
"
services
.
settings
.
server
"
)
;
const
ct
=
response
.
headers
.
get
(
"
Content
-
Type
"
)
;
if
(
!
is404FromCustomServer
&
&
(
!
ct
|
|
!
ct
.
includes
(
"
application
/
json
"
)
)
)
{
throw
new
Error
(
Unexpected
content
-
type
"
{
ct
}
"
)
;
}
let
payload
;
try
{
payload
=
await
response
.
json
(
)
;
}
catch
(
e
)
{
payload
=
e
.
message
;
}
if
(
!
payload
.
hasOwnProperty
(
"
data
"
)
)
{
if
(
!
is404FromCustomServer
)
{
throw
new
Error
(
Server
error
{
response
.
status
}
{
response
.
statusText
}
:
{
JSON
.
stringify
(
payload
)
}
)
;
}
}
else
{
changes
=
payload
.
data
;
}
}
const
currentEtag
=
response
.
headers
.
has
(
"
ETag
"
)
?
response
.
headers
.
get
(
"
ETag
"
)
:
undefined
;
let
serverTimeMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Date
"
)
)
;
const
cacheAgeSeconds
=
response
.
headers
.
has
(
"
Age
"
)
?
parseInt
(
response
.
headers
.
get
(
"
Age
"
)
10
)
:
0
;
serverTimeMillis
+
=
cacheAgeSeconds
*
1000
;
let
lastModifiedMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Last
-
Modified
"
)
)
;
const
ageSeconds
=
(
serverTimeMillis
-
lastModifiedMillis
)
/
1000
;
let
backoffSeconds
;
if
(
response
.
headers
.
has
(
"
Backoff
"
)
)
{
const
value
=
parseInt
(
response
.
headers
.
get
(
"
Backoff
"
)
10
)
;
if
(
!
isNaN
(
value
)
)
{
backoffSeconds
=
value
;
}
}
return
{
changes
currentEtag
serverTimeMillis
backoffSeconds
ageSeconds
}
;
}
}
;
