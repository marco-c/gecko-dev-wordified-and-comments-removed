var
EXPORTED_SYMBOLS
=
[
"
Utils
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
ServiceRequest
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
sys
.
mjs
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
SharedUtils
:
"
resource
:
/
/
services
-
settings
/
SharedUtils
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
CaptivePortalService
"
"
mozilla
.
org
/
network
/
captive
-
portal
-
service
;
1
"
"
nsICaptivePortalService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
gNetworkLinkService
"
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
"
nsINetworkLinkService
"
)
;
const
log
=
(
(
)
=
>
{
const
{
ConsoleAPI
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Console
.
sys
.
mjs
"
)
;
return
new
ConsoleAPI
(
{
maxLogLevel
:
"
warn
"
maxLogLevelPref
:
"
services
.
settings
.
loglevel
"
prefix
:
"
services
.
settings
"
}
)
;
}
)
(
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
isRunningTests
"
(
)
=
>
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
get
(
"
MOZ_DISABLE_NONLOCAL_CONNECTIONS
"
)
=
=
=
"
1
"
)
{
return
true
;
}
return
false
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
allowServerURLOverride
"
(
)
=
>
{
if
(
!
AppConstants
.
RELEASE_OR_BETA
)
{
return
true
;
}
if
(
lazy
.
isRunningTests
)
{
return
true
;
}
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
get
(
"
MOZ_REMOTE_SETTINGS_DEVTOOLS
"
)
=
=
=
"
1
"
)
{
return
true
;
}
return
false
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
gServerURL
"
"
services
.
settings
.
server
"
AppConstants
.
REMOTE_SETTINGS_SERVER_URL
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
gPreviewEnabled
"
"
services
.
settings
.
preview_enabled
"
false
)
;
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
var
Utils
=
{
get
SERVER_URL
(
)
{
return
lazy
.
allowServerURLOverride
?
lazy
.
gServerURL
:
AppConstants
.
REMOTE_SETTINGS_SERVER_URL
;
}
CHANGES_PATH
:
"
/
buckets
/
monitor
/
collections
/
changes
/
changeset
"
log
get
CERT_CHAIN_ROOT_IDENTIFIER
(
)
{
if
(
this
.
SERVER_URL
=
=
AppConstants
.
REMOTE_SETTINGS_SERVER_URL
)
{
return
Ci
.
nsIContentSignatureVerifier
.
ContentSignatureProdRoot
;
}
if
(
this
.
SERVER_URL
.
includes
(
"
stage
.
"
)
)
{
return
Ci
.
nsIContentSignatureVerifier
.
ContentSignatureStageRoot
;
}
if
(
this
.
SERVER_URL
.
includes
(
"
dev
.
"
)
)
{
return
Ci
.
nsIContentSignatureVerifier
.
ContentSignatureDevRoot
;
}
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
)
{
return
Ci
.
nsIX509CertDB
.
AppXPCShellRoot
;
}
return
Ci
.
nsIContentSignatureVerifier
.
ContentSignatureLocalRoot
;
}
get
LOAD_DUMPS
(
)
{
return
(
this
.
SERVER_URL
=
=
AppConstants
.
REMOTE_SETTINGS_SERVER_URL
|
|
lazy
.
isRunningTests
)
;
}
get
PREVIEW_MODE
(
)
{
if
(
_isUndefined
(
this
.
_previewModeEnabled
)
&
&
lazy
.
allowServerURLOverride
)
{
return
lazy
.
gPreviewEnabled
;
}
return
!
!
this
.
_previewModeEnabled
;
}
enablePreviewMode
(
enabled
)
{
const
bool2str
=
v
=
>
_isUndefined
(
v
)
?
"
unset
"
:
v
?
"
enabled
"
:
"
disabled
"
;
this
.
log
.
debug
(
Preview
mode
:
{
bool2str
(
this
.
_previewModeEnabled
)
}
-
>
{
bool2str
(
enabled
)
}
)
;
this
.
_previewModeEnabled
=
enabled
;
}
actualBucketName
(
bucketName
)
{
let
actual
=
bucketName
.
replace
(
"
-
preview
"
"
"
)
;
if
(
this
.
PREVIEW_MODE
)
{
actual
+
=
"
-
preview
"
;
}
return
actual
;
}
get
isOffline
(
)
{
try
{
return
(
Services
.
io
.
offline
|
|
lazy
.
CaptivePortalService
.
state
=
=
lazy
.
CaptivePortalService
.
LOCKED_PORTAL
|
|
!
lazy
.
gNetworkLinkService
.
isLinkUp
)
;
}
catch
(
ex
)
{
log
.
warn
(
"
Could
not
determine
network
status
.
"
ex
)
;
}
return
false
;
}
async
fetch
(
input
init
=
{
}
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
const
request
=
new
ServiceRequest
(
)
;
function
fallbackOrReject
(
err
)
{
if
(
bypassProxy
|
|
Services
.
startup
.
shuttingDown
|
|
Utils
.
isOffline
|
|
!
request
.
isProxied
|
|
!
request
.
bypassProxyEnabled
)
{
reject
(
err
)
;
return
;
}
ServiceRequest
.
logProxySource
(
request
.
channel
"
remote
-
settings
"
)
;
resolve
(
Utils
.
fetch
(
input
{
.
.
.
init
bypassProxy
:
true
}
)
)
;
}
request
.
onerror
=
(
)
=
>
fallbackOrReject
(
new
TypeError
(
"
NetworkError
:
Network
request
failed
"
)
)
;
request
.
ontimeout
=
(
)
=
>
fallbackOrReject
(
new
TypeError
(
"
Timeout
:
Network
request
failed
"
)
)
;
request
.
onabort
=
(
)
=
>
fallbackOrReject
(
new
DOMException
(
"
Aborted
"
"
AbortError
"
)
)
;
request
.
onload
=
(
)
=
>
{
const
headers
=
new
Headers
(
)
;
const
rawHeaders
=
request
.
getAllResponseHeaders
(
)
;
rawHeaders
.
trim
(
)
.
split
(
/
[
\
r
\
n
]
+
/
)
.
forEach
(
line
=
>
{
const
parts
=
line
.
split
(
"
:
"
)
;
const
header
=
parts
.
shift
(
)
;
const
value
=
parts
.
join
(
"
:
"
)
;
headers
.
set
(
header
value
)
;
}
)
;
const
responseAttributes
=
{
status
:
request
.
status
statusText
:
request
.
statusText
url
:
request
.
responseURL
headers
}
;
resolve
(
new
Response
(
request
.
response
responseAttributes
)
)
;
}
;
const
{
method
=
"
GET
"
headers
=
{
}
bypassProxy
=
false
}
=
init
;
request
.
open
(
method
input
{
bypassProxy
}
)
;
request
.
responseType
=
"
arraybuffer
"
;
for
(
const
[
name
value
]
of
Object
.
entries
(
headers
)
)
{
request
.
setRequestHeader
(
name
value
)
;
}
request
.
send
(
)
;
}
)
;
}
async
hasLocalData
(
client
)
{
const
timestamp
=
await
client
.
db
.
getLastModified
(
)
;
return
timestamp
!
=
=
null
;
}
async
hasLocalDump
(
bucket
collection
)
{
try
{
await
fetch
(
resource
:
/
/
app
/
defaults
/
settings
/
{
bucket
}
/
{
collection
}
.
json
{
method
:
"
HEAD
"
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
async
getLocalDumpLastModified
(
bucket
collection
)
{
if
(
!
this
.
_dumpStats
)
{
if
(
!
this
.
_dumpStatsInitPromise
)
{
this
.
_dumpStatsInitPromise
=
(
async
(
)
=
>
{
try
{
let
res
=
await
fetch
(
"
resource
:
/
/
app
/
defaults
/
settings
/
last_modified
.
json
"
)
;
this
.
_dumpStats
=
await
res
.
json
(
)
;
}
catch
(
e
)
{
log
.
warn
(
Failed
to
load
last_modified
.
json
:
{
e
}
)
;
this
.
_dumpStats
=
{
}
;
}
delete
this
.
_dumpStatsInitPromise
;
}
)
(
)
;
}
await
this
.
_dumpStatsInitPromise
;
}
const
identifier
=
{
bucket
}
/
{
collection
}
;
let
lastModified
=
this
.
_dumpStats
[
identifier
]
;
if
(
lastModified
=
=
=
undefined
)
{
const
{
timestamp
:
dumpTimestamp
}
=
await
lazy
.
SharedUtils
.
loadJSONDump
(
bucket
collection
)
;
lastModified
=
dumpTimestamp
?
?
-
1
;
this
.
_dumpStats
[
identifier
]
=
lastModified
;
}
return
lastModified
;
}
async
fetchLatestChanges
(
serverUrl
options
=
{
}
)
{
const
{
expectedTimestamp
lastEtag
=
"
"
filters
=
{
}
}
=
options
;
let
url
=
serverUrl
+
Utils
.
CHANGES_PATH
;
const
params
=
{
.
.
.
filters
_expected
:
expectedTimestamp
?
?
0
}
;
if
(
lastEtag
!
=
"
"
)
{
params
.
_since
=
lastEtag
;
}
if
(
params
)
{
url
+
=
"
?
"
+
Object
.
entries
(
params
)
.
map
(
(
[
k
v
]
)
=
>
{
k
}
=
{
encodeURIComponent
(
v
)
}
)
.
join
(
"
&
"
)
;
}
const
response
=
await
Utils
.
fetch
(
url
)
;
if
(
response
.
status
>
=
500
)
{
throw
new
Error
(
Server
error
{
response
.
status
}
{
response
.
statusText
}
)
;
}
const
is404FromCustomServer
=
response
.
status
=
=
404
&
&
Services
.
prefs
.
prefHasUserValue
(
"
services
.
settings
.
server
"
)
;
const
ct
=
response
.
headers
.
get
(
"
Content
-
Type
"
)
;
if
(
!
is404FromCustomServer
&
&
(
!
ct
|
|
!
ct
.
includes
(
"
application
/
json
"
)
)
)
{
throw
new
Error
(
Unexpected
content
-
type
"
{
ct
}
"
)
;
}
let
payload
;
try
{
payload
=
await
response
.
json
(
)
;
}
catch
(
e
)
{
payload
=
e
.
message
;
}
if
(
!
payload
.
hasOwnProperty
(
"
changes
"
)
)
{
if
(
!
is404FromCustomServer
)
{
throw
new
Error
(
Server
error
{
url
}
{
response
.
status
}
{
response
.
statusText
}
:
{
JSON
.
stringify
(
payload
)
}
)
;
}
}
const
{
changes
=
[
]
timestamp
}
=
payload
;
let
serverTimeMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Date
"
)
)
;
const
cacheAgeSeconds
=
response
.
headers
.
has
(
"
Age
"
)
?
parseInt
(
response
.
headers
.
get
(
"
Age
"
)
10
)
:
0
;
serverTimeMillis
+
=
cacheAgeSeconds
*
1000
;
const
ageSeconds
=
(
serverTimeMillis
-
timestamp
)
/
1000
;
let
backoffSeconds
;
if
(
response
.
headers
.
has
(
"
Backoff
"
)
)
{
const
value
=
parseInt
(
response
.
headers
.
get
(
"
Backoff
"
)
10
)
;
if
(
!
isNaN
(
value
)
)
{
backoffSeconds
=
value
;
}
}
return
{
changes
currentEtag
:
"
{
timestamp
}
"
serverTimeMillis
backoffSeconds
ageSeconds
}
;
}
filterObject
(
filters
entry
)
{
return
Object
.
entries
(
filters
)
.
every
(
(
[
filter
value
]
)
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
else
if
(
typeof
value
=
=
=
"
object
"
)
{
return
Utils
.
filterObject
(
value
entry
[
filter
]
)
;
}
else
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
entry
filter
)
)
{
console
.
error
(
The
property
{
filter
}
does
not
exist
)
;
return
false
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
}
;
