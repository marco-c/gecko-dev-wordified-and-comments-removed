var
EXPORTED_SYMBOLS
=
[
"
Utils
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
ServiceRequest
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ServiceRequest
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
CaptivePortalService
"
"
mozilla
.
org
/
network
/
captive
-
portal
-
service
;
1
"
"
nsICaptivePortalService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gNetworkLinkService
"
"
mozilla
.
org
/
network
/
network
-
link
-
service
;
1
"
"
nsINetworkLinkService
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
(
)
=
>
{
const
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
maxLogLevel
:
"
warn
"
maxLogLevelPref
:
"
services
.
settings
.
loglevel
"
prefix
:
"
services
.
settings
"
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gServerURL
"
"
services
.
settings
.
server
"
)
;
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
var
Utils
=
{
get
SERVER_URL
(
)
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
isXpcshell
=
env
.
exists
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
const
isNotThunderbird
=
AppConstants
.
MOZ_APP_NAME
!
=
"
thunderbird
"
;
return
AppConstants
.
RELEASE_OR_BETA
&
&
!
Cu
.
isInAutomation
&
&
!
isXpcshell
&
&
isNotThunderbird
?
"
https
:
/
/
firefox
.
settings
.
services
.
mozilla
.
com
/
v1
"
:
gServerURL
;
}
CHANGES_PATH
:
"
/
buckets
/
monitor
/
collections
/
changes
/
changeset
"
log
get
isOffline
(
)
{
try
{
return
(
Services
.
io
.
offline
|
|
CaptivePortalService
.
state
=
=
CaptivePortalService
.
LOCKED_PORTAL
|
|
!
gNetworkLinkService
.
isLinkUp
)
;
}
catch
(
ex
)
{
log
.
warn
(
"
Could
not
determine
network
status
.
"
ex
)
;
}
return
false
;
}
async
fetch
(
input
init
=
{
}
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
const
request
=
new
ServiceRequest
(
)
;
request
.
onerror
=
(
)
=
>
reject
(
new
TypeError
(
"
NetworkError
:
Network
request
failed
"
)
)
;
request
.
ontimeout
=
(
)
=
>
reject
(
new
TypeError
(
"
Timeout
:
Network
request
failed
"
)
)
;
request
.
onabort
=
(
)
=
>
reject
(
new
DOMException
(
"
Aborted
"
"
AbortError
"
)
)
;
request
.
onload
=
(
)
=
>
{
const
headers
=
new
Headers
(
)
;
const
rawHeaders
=
request
.
getAllResponseHeaders
(
)
;
rawHeaders
.
trim
(
)
.
split
(
/
[
\
r
\
n
]
+
/
)
.
forEach
(
line
=
>
{
const
parts
=
line
.
split
(
"
:
"
)
;
const
header
=
parts
.
shift
(
)
;
const
value
=
parts
.
join
(
"
:
"
)
;
headers
.
set
(
header
value
)
;
}
)
;
const
responseAttributes
=
{
status
:
request
.
status
statusText
:
request
.
statusText
url
:
request
.
responseURL
headers
}
;
resolve
(
new
Response
(
request
.
response
responseAttributes
)
)
;
}
;
const
{
method
=
"
GET
"
headers
=
{
}
}
=
init
;
request
.
open
(
method
input
true
)
;
request
.
responseType
=
"
arraybuffer
"
;
for
(
const
[
name
value
]
of
Object
.
entries
(
headers
)
)
{
request
.
setRequestHeader
(
name
value
)
;
}
request
.
send
(
)
;
}
)
;
}
async
hasLocalData
(
client
)
{
const
timestamp
=
await
client
.
db
.
getLastModified
(
)
;
return
timestamp
!
=
=
null
;
}
async
hasLocalDump
(
bucket
collection
)
{
try
{
await
fetch
(
resource
:
/
/
app
/
defaults
/
settings
/
{
bucket
}
/
{
collection
}
.
json
{
method
:
"
HEAD
"
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
async
getLocalDumpLastModified
(
bucket
collection
)
{
if
(
!
this
.
_dumpStats
)
{
if
(
!
this
.
_dumpStatsInitPromise
)
{
this
.
_dumpStatsInitPromise
=
(
async
(
)
=
>
{
try
{
let
res
=
await
fetch
(
"
resource
:
/
/
app
/
defaults
/
settings
/
last_modified
.
json
"
)
;
this
.
_dumpStats
=
await
res
.
json
(
)
;
}
catch
(
e
)
{
log
.
warn
(
Failed
to
load
last_modified
.
json
:
{
e
}
)
;
this
.
_dumpStats
=
{
}
;
}
delete
this
.
_dumpStatsInitPromise
;
}
)
(
)
;
}
await
this
.
_dumpStatsInitPromise
;
}
const
identifier
=
{
bucket
}
/
{
collection
}
;
let
lastModified
=
this
.
_dumpStats
[
identifier
]
;
if
(
lastModified
=
=
=
undefined
)
{
try
{
let
res
=
await
fetch
(
resource
:
/
/
app
/
defaults
/
settings
/
{
bucket
}
/
{
collection
}
.
json
)
;
let
records
=
(
await
res
.
json
(
)
)
.
data
;
lastModified
=
records
[
0
]
?
.
last_modified
|
|
0
;
}
catch
(
e
)
{
lastModified
=
-
1
;
}
this
.
_dumpStats
[
identifier
]
=
lastModified
;
}
return
lastModified
;
}
async
fetchLatestChanges
(
serverUrl
options
=
{
}
)
{
const
{
expectedTimestamp
lastEtag
=
"
"
filters
=
{
}
}
=
options
;
let
url
=
serverUrl
+
Utils
.
CHANGES_PATH
;
const
params
=
{
.
.
.
filters
_expected
:
expectedTimestamp
?
?
0
}
;
if
(
lastEtag
!
=
"
"
)
{
params
.
_since
=
lastEtag
;
}
if
(
params
)
{
url
+
=
"
?
"
+
Object
.
entries
(
params
)
.
map
(
(
[
k
v
]
)
=
>
{
k
}
=
{
encodeURIComponent
(
v
)
}
)
.
join
(
"
&
"
)
;
}
const
response
=
await
Utils
.
fetch
(
url
)
;
if
(
response
.
status
>
=
500
)
{
throw
new
Error
(
Server
error
{
response
.
status
}
{
response
.
statusText
}
)
;
}
const
is404FromCustomServer
=
response
.
status
=
=
404
&
&
Services
.
prefs
.
prefHasUserValue
(
"
services
.
settings
.
server
"
)
;
const
ct
=
response
.
headers
.
get
(
"
Content
-
Type
"
)
;
if
(
!
is404FromCustomServer
&
&
(
!
ct
|
|
!
ct
.
includes
(
"
application
/
json
"
)
)
)
{
throw
new
Error
(
Unexpected
content
-
type
"
{
ct
}
"
)
;
}
let
payload
;
try
{
payload
=
await
response
.
json
(
)
;
}
catch
(
e
)
{
payload
=
e
.
message
;
}
if
(
!
payload
.
hasOwnProperty
(
"
changes
"
)
)
{
if
(
!
is404FromCustomServer
)
{
throw
new
Error
(
Server
error
{
url
}
{
response
.
status
}
{
response
.
statusText
}
:
{
JSON
.
stringify
(
payload
)
}
)
;
}
}
const
{
changes
=
[
]
timestamp
}
=
payload
;
let
serverTimeMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Date
"
)
)
;
const
cacheAgeSeconds
=
response
.
headers
.
has
(
"
Age
"
)
?
parseInt
(
response
.
headers
.
get
(
"
Age
"
)
10
)
:
0
;
serverTimeMillis
+
=
cacheAgeSeconds
*
1000
;
let
lastModifiedMillis
=
Date
.
parse
(
response
.
headers
.
get
(
"
Last
-
Modified
"
)
)
;
const
ageSeconds
=
(
serverTimeMillis
-
lastModifiedMillis
)
/
1000
;
let
backoffSeconds
;
if
(
response
.
headers
.
has
(
"
Backoff
"
)
)
{
const
value
=
parseInt
(
response
.
headers
.
get
(
"
Backoff
"
)
10
)
;
if
(
!
isNaN
(
value
)
)
{
backoffSeconds
=
value
;
}
}
return
{
changes
currentEtag
:
"
{
timestamp
}
"
serverTimeMillis
backoffSeconds
ageSeconds
}
;
}
filterObject
(
filters
entry
)
{
return
Object
.
entries
(
filters
)
.
every
(
(
[
filter
value
]
)
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
else
if
(
typeof
value
=
=
=
"
object
"
)
{
return
Utils
.
filterObject
(
value
entry
[
filter
]
)
;
}
else
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
entry
filter
)
)
{
console
.
error
(
The
property
{
filter
}
does
not
exist
)
;
return
false
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
}
;
