"
use
strict
"
;
const
{
Database
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
settings
/
Database
.
jsm
"
)
;
add_task
(
async
function
test_shutdown_abort_after_start
(
)
{
let
counter
=
0
;
let
transactionStarted
;
let
startedPromise
=
new
Promise
(
r
=
>
{
transactionStarted
=
r
;
}
)
;
let
promise
=
Database
.
_executeIDB
(
"
records
"
store
=
>
{
transactionStarted
(
)
;
function
makeRequest
(
)
{
if
(
+
+
counter
>
1000
)
{
Assert
.
ok
(
false
"
We
ran
1000
requests
and
didn
'
t
get
aborted
what
?
"
)
;
return
;
}
dump
(
"
Making
request
"
+
counter
+
"
\
n
"
)
;
const
request
=
store
.
index
(
"
cid
"
)
.
openCursor
(
IDBKeyRange
.
only
(
"
foopydoo
/
foo
"
)
)
;
request
.
onsuccess
=
event
=
>
{
makeRequest
(
)
;
}
;
}
makeRequest
(
)
;
}
{
mode
:
"
readonly
"
}
)
;
await
startedPromise
;
Database
.
_shutdownHandler
(
)
;
let
rejection
;
await
promise
.
catch
(
e
=
>
{
rejection
=
e
;
}
)
;
ok
(
rejection
"
Promise
should
have
rejected
.
"
)
;
Database
.
_cancelShutdown
(
)
;
rejection
=
null
;
}
)
;
add_task
(
async
function
test_shutdown_immediate_abort
(
)
{
let
promise
=
Database
.
_executeIDB
(
"
records
"
store
=
>
{
let
request
=
store
.
index
(
"
cid
"
)
.
openCursor
(
IDBKeyRange
.
only
(
"
foopydoo
/
foo
"
)
)
;
request
.
onsuccess
=
event
=
>
{
Database
.
_shutdownHandler
(
)
;
request
=
store
.
index
(
"
cid
"
)
.
openCursor
(
IDBKeyRange
.
only
(
"
foopydoo
/
foo
"
)
)
;
Assert
.
ok
(
false
"
IndexedDB
allowed
opening
a
cursor
after
aborting
?
!
"
)
;
}
;
}
{
mode
:
"
readonly
"
}
)
;
let
rejection
;
await
promise
.
catch
(
e
=
>
{
rejection
=
e
;
}
)
;
ok
(
rejection
"
Directly
aborted
promise
should
also
have
rejected
.
"
)
;
}
)
;
