"
use
strict
"
;
const
PREF_SETTINGS_SERVER
=
"
services
.
settings
.
server
"
;
const
SIGNER_NAME
=
"
onecrl
.
content
-
signature
.
mozilla
.
org
"
;
const
TELEMETRY_COMPONENT
=
"
remotesettings
"
;
const
CERT_DIR
=
"
test_remote_settings_signatures
/
"
;
const
CHAIN_FILES
=
[
"
collection_signing_ee
.
pem
"
"
collection_signing_int
.
pem
"
]
;
function
getFileData
(
file
)
{
const
stream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
stream
.
init
(
file
-
1
0
0
)
;
const
data
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
return
data
;
}
function
getCertChain
(
)
{
const
chain
=
[
]
;
for
(
let
file
of
CHAIN_FILES
)
{
chain
.
push
(
getFileData
(
do_get_file
(
CERT_DIR
+
file
)
)
)
;
}
return
chain
.
join
(
"
\
n
"
)
;
}
let
server
;
let
client
;
add_setup
(
(
)
=
>
{
client
=
RemoteSettings
(
"
signed
"
{
signerName
:
SIGNER_NAME
}
)
;
Services
.
prefs
.
setStringPref
(
"
services
.
settings
.
loglevel
"
"
debug
"
)
;
server
=
new
HttpServer
(
)
;
server
.
start
(
-
1
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
services
.
settings
.
loglevel
"
)
;
Services
.
prefs
.
clearUserPref
(
PREF_SETTINGS_SERVER
)
;
server
.
stop
(
(
)
=
>
{
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_check_signatures
(
)
{
let
verifier
=
Cc
[
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
]
.
createInstance
(
Ci
.
nsIContentSignatureVerifier
)
;
const
emptyData
=
"
[
]
"
;
const
emptySignature
=
"
p384ecdsa
=
zbugm2FDitsHwk5
-
IWsas1PpWwY29f0Fg5ZHeqD8fzep7AVl2vfcaHA7LdmCZ28qZLOioGKvco3qT117Q4
-
HlqFTJM7COHzxGyU2MMJ0ZTnhJrPOC1fP3cVQjU1PTWi9
"
;
ok
(
await
verifier
.
asyncVerifyContentSignature
(
emptyData
emptySignature
getCertChain
(
)
SIGNER_NAME
Ci
.
nsIX509CertDB
.
AppXPCShellRoot
)
)
;
const
collectionData
=
'
[
{
"
details
"
:
{
"
bug
"
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
"
created
"
:
"
2016
-
01
-
18T14
:
43
:
37Z
"
"
name
"
:
"
GlobalSign
certs
"
"
who
"
:
"
.
"
"
why
"
:
"
.
"
}
"
enabled
"
:
true
"
id
"
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
"
issuerName
"
:
"
MHExKDAmBgNVBAMTH0dsb2JhbFNpZ24gUm9vdFNpZ24gUGFydG5lcnMgQ0ExHTAbBgNVBAsTFFJvb3RTaWduIFBhcnRuZXJzIENBMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMQswCQYDVQQGEwJCRQ
=
=
"
"
last_modified
"
:
2000
"
serialNumber
"
:
"
BAAAAAABA
/
A35EU
=
"
}
{
"
details
"
:
{
"
bug
"
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
"
created
"
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
"
name
"
:
"
GlobalSign
certs
"
"
who
"
:
"
.
"
"
why
"
:
"
.
"
}
"
enabled
"
:
true
"
id
"
:
"
e3bd531e
-
1ee4
-
7407
-
27ce
-
6fdc9cecbbdc
"
"
issuerName
"
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
"
last_modified
"
:
3000
"
serialNumber
"
:
"
BAAAAAABI54PryQ
=
"
}
]
'
;
const
collectionSignature
=
"
p384ecdsa
=
f4pA2tYM5jQgWY6YUmhUwQiBLj6QO5sHLD_5MqLePz95qv
-
7cNCuQoZnPQwxoptDtW8hcWH3kLb0quR7SB
-
r82gkpR9POVofsnWJRA
-
ETb0BcIz6VvI3pDT49ZLlNg3p
"
;
ok
(
await
verifier
.
asyncVerifyContentSignature
(
collectionData
collectionSignature
getCertChain
(
)
SIGNER_NAME
Ci
.
nsIX509CertDB
.
AppXPCShellRoot
)
)
;
}
)
;
add_task
(
async
function
test_bad_signature_does_not_lead_to_empty_list
(
)
{
Services
.
prefs
.
setStringPref
(
PREF_SETTINGS_SERVER
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
v1
)
;
const
x5u
=
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
x5u
.
pem
;
const
networkCalls
=
[
]
;
server
.
registerPathHandler
(
"
/
v1
/
buckets
/
monitor
/
collections
/
changes
/
changeset
"
(
request
response
)
=
>
{
response
.
write
(
JSON
.
stringify
(
{
changes
:
[
{
bucket
:
"
main
"
collection
:
"
no
-
dump
-
no
-
local
-
data
"
last_modified
:
42
}
]
}
)
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
;
charset
=
UTF
-
8
"
)
;
response
.
setStatusLine
(
null
200
"
OK
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
v1
/
buckets
/
monitor
/
collections
/
changes
/
changeset
"
(
request
response
)
=
>
{
networkCalls
.
push
(
request
)
;
response
.
write
(
JSON
.
stringify
(
{
changes
:
[
{
bucket
:
"
main
"
collection
:
"
no
-
dump
-
no
-
local
-
data
"
last_modified
:
42
}
]
}
)
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
;
charset
=
UTF
-
8
"
)
;
response
.
setStatusLine
(
null
200
"
OK
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
v1
/
buckets
/
main
/
collections
/
no
-
dump
-
no
-
local
-
data
/
changeset
"
(
request
response
)
=
>
{
response
.
write
(
JSON
.
stringify
(
{
timestamp
:
42
changes
:
[
]
metadata
:
{
signature
:
{
signature
:
"
bad
-
signature
"
x5u
}
}
}
)
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
;
charset
=
UTF
-
8
"
)
;
response
.
setStatusLine
(
null
200
"
OK
"
)
;
}
)
;
server
.
registerPathHandler
(
"
/
x5u
.
pem
"
(
request
response
)
=
>
{
response
.
write
(
getCertChain
(
)
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
;
charset
=
UTF
-
8
"
)
;
response
.
setStatusLine
(
null
200
"
OK
"
)
;
}
)
;
const
clientEmpty
=
RemoteSettings
(
"
no
-
dump
-
no
-
local
-
data
"
)
;
clientEmpty
.
verifySignature
=
true
;
let
error
;
try
{
await
clientEmpty
.
get
(
{
emptyListFallback
:
false
syncIfEmpty
:
true
}
)
;
}
catch
(
exc
)
{
error
=
exc
;
}
equal
(
error
.
name
"
InvalidSignatureError
"
)
;
error
=
null
;
try
{
await
clientEmpty
.
sync
(
)
;
}
catch
(
exc
)
{
error
=
exc
;
}
equal
(
error
.
name
"
InvalidSignatureError
"
)
;
equal
(
await
clientEmpty
.
db
.
getLastModified
(
)
null
)
;
networkCalls
.
length
=
0
;
try
{
await
clientEmpty
.
get
(
{
emptyListFallback
:
false
syncIfEmpty
:
true
}
)
;
}
catch
(
exc
)
{
error
=
exc
;
}
Assert
.
greater
(
networkCalls
.
length
0
"
Network
calls
were
made
"
)
;
equal
(
error
.
name
"
InvalidSignatureError
"
)
;
}
)
;
add_task
(
async
function
test_check_synchronization_with_signatures
(
)
{
const
port
=
server
.
identity
.
primaryPort
;
const
x5u
=
http
:
/
/
localhost
:
{
port
}
/
test_remote_settings_signatures
/
test_cert_chain
.
pem
;
const
TELEMETRY_SOURCE
=
client
.
identifier
;
function
registerHandlers
(
responses
)
{
function
handleResponse
(
serverTimeMillis
request
response
)
{
const
key
=
{
request
.
method
}
:
{
request
.
path
}
?
{
request
.
queryString
}
;
const
available
=
responses
[
key
]
;
const
sampled
=
available
.
length
>
1
?
available
.
shift
(
)
:
available
[
0
]
;
if
(
!
sampled
)
{
do_throw
(
unexpected
{
request
.
method
}
request
for
{
request
.
path
}
?
{
request
.
queryString
}
)
;
}
response
.
setStatusLine
(
null
sampled
.
status
.
status
sampled
.
status
.
statusText
)
;
for
(
let
headerLine
of
sampled
.
sampleHeaders
)
{
let
headerElements
=
headerLine
.
split
(
"
:
"
)
;
response
.
setHeader
(
headerElements
[
0
]
headerElements
[
1
]
.
trimLeft
(
)
)
;
}
response
.
setHeader
(
"
Date
"
new
Date
(
serverTimeMillis
)
.
toUTCString
(
)
)
;
response
.
write
(
sampled
.
responseBody
)
;
}
for
(
let
key
of
Object
.
keys
(
responses
)
)
{
const
keyParts
=
key
.
split
(
"
:
"
)
;
const
valueParts
=
keyParts
[
1
]
.
split
(
"
?
"
)
;
const
path
=
valueParts
[
0
]
;
server
.
registerPathHandler
(
path
handleResponse
.
bind
(
null
2000
)
)
;
}
}
Services
.
prefs
.
setStringPref
(
PREF_SETTINGS_SERVER
http
:
/
/
localhost
:
{
server
.
identity
.
primaryPort
}
/
v1
)
;
const
RECORD1
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
43
:
37Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
issuerName
:
"
MHExKDAmBgNVBAMTH0dsb2JhbFNpZ24gUm9vdFNpZ24gUGFydG5lcnMgQ0ExHTAbBgNVBAsTFFJvb3RTaWduIFBhcnRuZXJzIENBMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMQswCQYDVQQGEwJCRQ
=
=
"
last_modified
:
2000
serialNumber
:
"
BAAAAAABA
/
A35EU
=
"
}
;
const
RECORD2
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
e3bd531e
-
1ee4
-
7407
-
27ce
-
6fdc9cecbbdc
"
issuerName
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
last_modified
:
3000
serialNumber
:
"
BAAAAAABI54PryQ
=
"
}
;
const
RECORD3
=
{
details
:
{
bug
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1155145
"
created
:
"
2016
-
01
-
18T14
:
48
:
11Z
"
name
:
"
GlobalSign
certs
"
who
:
"
.
"
why
:
"
.
"
}
enabled
:
true
id
:
"
c7c49b69
-
a4ab
-
418e
-
92a9
-
e1961459aa7f
"
issuerName
:
"
MIGBMQswCQYDVQQGEwJCRTEZMBcGA1UEChMQR2xvYmFsU2lnbiBudi1zYTElMCMGA1UECxMcUHJpbWFyeSBPYmplY3QgUHVibGlzaGluZyBDQTEwMC4GA1UEAxMnR2xvYmFsU2lnbiBQcmltYXJ5IE9iamVjdCBQdWJsaXNoaW5nIENB
"
last_modified
:
4000
serialNumber
:
"
BAAAAAABI54PryQ
=
"
}
;
const
RECORD1_DELETION
=
{
deleted
:
true
enabled
:
true
id
:
"
97fbf7c4
-
3ef2
-
f54f
-
0029
-
1ba6540c63ea
"
last_modified
:
3500
}
;
const
RESPONSE_CERT_CHAIN
=
{
comment
:
"
RESPONSE_CERT_CHAIN
"
sampleHeaders
:
[
"
Content
-
Type
:
text
/
plain
;
charset
=
UTF
-
8
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
getCertChain
(
)
}
;
const
RESPONSE_SERVER_SETTINGS
=
{
comment
:
"
RESPONSE_SERVER_SETTINGS
"
sampleHeaders
:
[
"
Access
-
Control
-
Allow
-
Origin
:
*
"
"
Access
-
Control
-
Expose
-
Headers
:
Retry
-
After
Content
-
Length
Alert
Backoff
"
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
"
Server
:
waitress
"
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
settings
:
{
batch_max_requests
:
25
}
url
:
http
:
/
/
localhost
:
{
port
}
/
v1
/
documentation
:
"
https
:
/
/
kinto
.
readthedocs
.
org
/
"
version
:
"
1
.
5
.
1
"
commit
:
"
cbc6f58
"
hello
:
"
kinto
"
}
)
}
;
const
RESPONSE_EMPTY_INITIAL
=
{
comment
:
"
RESPONSE_EMPTY_INITIAL
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
1000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
1000
metadata
:
{
signature
:
{
x5u
signature
:
"
vxuAg5rDCB
-
1pul4a91vqSBQRXJG_j7WOYUTswxRSMltdYmbhLRH8R8brQ9YKuNDF56F
-
w6pn4HWxb076qgKPwgcEBtUeZAO_RtaHXRkRUUgVzAr86yQL4
-
aJTbv3D6u
"
}
}
changes
:
[
]
}
)
}
;
const
emptyCollectionResponses
=
{
"
GET
:
/
test_remote_settings_signatures
/
test_cert_chain
.
pem
?
"
:
[
RESPONSE_CERT_CHAIN
]
"
GET
:
/
v1
/
?
"
:
[
RESPONSE_SERVER_SETTINGS
]
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
1000
"
:
[
RESPONSE_EMPTY_INITIAL
]
}
;
registerHandlers
(
emptyCollectionResponses
)
;
let
startSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
await
client
.
maybeSync
(
1000
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
0
)
;
let
endSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
let
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SYNC_START
]
:
1
[
UptakeTelemetry
.
STATUS
.
SUCCESS
]
:
1
}
;
checkUptakeTelemetry
(
startSnapshot
endSnapshot
expectedIncrements
)
;
const
RESPONSE_TWO_ADDED
=
{
comment
:
"
RESPONSE_TWO_ADDED
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
3000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
3000
metadata
:
{
signature
:
{
x5u
signature
:
"
dwhJeypadNIyzGj3QdI0KMRTPnHhFPF_j73mNrsPAHKMW46S2Ftf4BzsPMvPMB8h0TjDus13wo_R4l432DHe7tYyMIWXY0PBeMcoe5BREhFIxMxTsh9eGVXBD1e3UwRy
"
}
}
changes
:
[
RECORD2
RECORD1
]
}
)
}
;
const
twoItemsResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
3000
&
_since
=
%
221000
%
22
"
:
[
RESPONSE_TWO_ADDED
]
}
;
registerHandlers
(
twoItemsResponses
)
;
await
client
.
maybeSync
(
3000
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
2
)
;
const
THREE_ITEMS_SIG
=
"
MIEmNghKnkz12UodAAIc3q_Y4a3IJJ7GhHF4JYNYmm8avAGyPM9fYU7NzVo94pzjotG7vmtiYuHyIX2rTHTbT587w0LdRWxipgFd_PC1mHiwUyjFYNqBBG
-
kifYk7kEw
"
;
const
RESPONSE_ONE_ADDED_ONE_REMOVED
=
{
comment
:
"
RESPONSE_ONE_ADDED_ONE_REMOVED
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
4000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
4000
metadata
:
{
signature
:
{
x5u
signature
:
THREE_ITEMS_SIG
}
}
changes
:
[
RECORD3
RECORD1_DELETION
]
}
)
}
;
const
oneAddedOneRemovedResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
4000
&
_since
=
%
223000
%
22
"
:
[
RESPONSE_ONE_ADDED_ONE_REMOVED
]
}
;
registerHandlers
(
oneAddedOneRemovedResponses
)
;
await
client
.
maybeSync
(
4000
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
2
)
;
const
RESPONSE_EMPTY_NO_UPDATE
=
{
comment
:
"
RESPONSE_EMPTY_NO_UPDATE
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
4000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
4000
metadata
:
{
signature
:
{
x5u
signature
:
THREE_ITEMS_SIG
}
}
changes
:
[
]
}
)
}
;
const
noOpResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
4100
&
_since
=
%
224000
%
22
"
:
[
RESPONSE_EMPTY_NO_UPDATE
]
}
;
registerHandlers
(
noOpResponses
)
;
await
client
.
maybeSync
(
4100
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
2
)
;
const
RESPONSE_COMPLETE_INITIAL
=
{
comment
:
"
RESPONSE_COMPLETE_INITIAL
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
4000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
4000
metadata
:
{
signature
:
{
x5u
signature
:
THREE_ITEMS_SIG
}
}
changes
:
[
RECORD2
RECORD3
]
}
)
}
;
const
RESPONSE_EMPTY_NO_UPDATE_BAD_SIG
=
{
.
.
.
RESPONSE_EMPTY_NO_UPDATE
responseBody
:
JSON
.
stringify
(
{
timestamp
:
4000
metadata
:
{
signature
:
{
x5u
signature
:
"
aW52YWxpZCBzaWduYXR1cmUK
"
}
}
changes
:
[
]
}
)
}
;
const
badSigGoodSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
&
_since
=
%
224000
%
22
"
:
[
RESPONSE_EMPTY_NO_UPDATE_BAD_SIG
]
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
"
:
[
RESPONSE_COMPLETE_INITIAL
]
}
;
registerHandlers
(
badSigGoodSigResponses
)
;
startSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
let
syncEventSent
=
false
;
client
.
on
(
"
sync
"
(
)
=
>
{
syncEventSent
=
true
;
}
)
;
await
client
.
maybeSync
(
5000
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
2
)
;
endSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
equal
(
syncEventSent
false
)
;
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SYNC_START
]
:
-
2
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_ERROR
]
:
1
}
;
checkUptakeTelemetry
(
startSnapshot
endSnapshot
expectedIncrements
)
;
const
badSigGoodOldResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
&
_since
=
%
224000
%
22
"
:
[
RESPONSE_EMPTY_NO_UPDATE_BAD_SIG
]
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
"
:
[
RESPONSE_EMPTY_INITIAL
]
}
;
equal
(
(
await
client
.
get
(
)
)
.
length
2
"
collection
was
restored
"
)
;
registerHandlers
(
badSigGoodOldResponses
)
;
syncEventSent
=
false
;
client
.
on
(
"
sync
"
(
)
=
>
{
syncEventSent
=
true
;
}
)
;
await
client
.
maybeSync
(
5000
)
;
equal
(
syncEventSent
false
"
event
was
not
sent
"
)
;
const
RESPONSE_COMPLETE_BAD_SIG
=
{
.
.
.
RESPONSE_EMPTY_NO_UPDATE
responseBody
:
JSON
.
stringify
(
{
timestamp
:
5000
metadata
:
{
signature
:
{
x5u
signature
:
"
aW52YWxpZCBzaWduYXR1cmUK
"
}
}
changes
:
[
RECORD2
RECORD3
]
}
)
}
;
const
badLocalContentGoodSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
&
_since
=
%
223900
%
22
"
:
[
RESPONSE_COMPLETE_BAD_SIG
]
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
5000
"
:
[
RESPONSE_COMPLETE_INITIAL
]
}
;
registerHandlers
(
badLocalContentGoodSigResponses
)
;
const
localId
=
"
0602b1b2
-
12ab
-
4d3a
-
b6fb
-
593244e7b035
"
;
await
client
.
db
.
importChanges
(
{
signature
:
{
x5u
signature
:
"
abc
"
}
}
3900
[
{
.
.
.
RECORD2
last_modified
:
1234567890
serialNumber
:
"
abc
"
}
{
id
:
localId
}
]
{
clear
:
true
}
)
;
let
syncData
=
null
;
client
.
on
(
"
sync
"
(
{
data
}
)
=
>
{
syncData
=
data
;
}
)
;
TelemetryTestUtils
.
assertEvents
(
[
]
{
}
{
process
:
"
dummy
"
}
)
;
const
TELEMETRY_EVENTS_FILTERS
=
{
category
:
"
uptake
.
remotecontent
.
result
"
method
:
"
uptake
"
}
;
await
client
.
maybeSync
(
5000
)
;
TelemetryTestUtils
.
assertEvents
(
[
[
"
uptake
.
remotecontent
.
result
"
"
uptake
"
"
remotesettings
"
UptakeTelemetry
.
STATUS
.
SYNC_START
{
source
:
client
.
identifier
trigger
:
"
manual
"
}
]
[
"
uptake
.
remotecontent
.
result
"
"
uptake
"
"
remotesettings
"
UptakeTelemetry
.
STATUS
.
CORRUPTION_ERROR
{
source
:
client
.
identifier
duration
:
v
=
>
v
>
0
trigger
:
"
manual
"
}
]
]
TELEMETRY_EVENTS_FILTERS
)
;
equal
(
syncData
.
current
.
length
2
)
;
equal
(
syncData
.
created
.
length
1
)
;
equal
(
syncData
.
created
[
0
]
.
id
RECORD3
.
id
)
;
equal
(
syncData
.
updated
.
length
1
)
;
equal
(
syncData
.
updated
[
0
]
.
old
.
serialNumber
"
abc
"
)
;
equal
(
syncData
.
updated
[
0
]
.
new
.
serialNumber
RECORD2
.
serialNumber
)
;
equal
(
syncData
.
deleted
.
length
1
)
;
equal
(
syncData
.
deleted
[
0
]
.
id
localId
)
;
const
RESPONSE_ONLY_RECORD4_BAD_SIG
=
{
comment
:
"
Create
RECORD4
"
sampleHeaders
:
[
"
Content
-
Type
:
application
/
json
;
charset
=
UTF
-
8
"
'
ETag
:
"
6000
"
'
]
status
:
{
status
:
200
statusText
:
"
OK
"
}
responseBody
:
JSON
.
stringify
(
{
timestamp
:
6000
metadata
:
{
signature
:
{
x5u
signature
:
"
aaaaaaaaaaaaaaaaaaaaaaaa
"
}
}
changes
:
[
{
id
:
"
f765df30
-
b2f1
-
42f6
-
9803
-
7bd5a07b5098
"
last_modified
:
6000
}
]
}
)
}
;
const
RESPONSE_EMPTY_NO_UPDATE_BAD_SIG_6000
=
{
.
.
.
RESPONSE_EMPTY_NO_UPDATE
responseBody
:
JSON
.
stringify
(
{
timestamp
:
6000
metadata
:
{
signature
:
{
x5u
signature
:
"
aW52YWxpZCBzaWduYXR1cmUK
"
}
}
changes
:
[
]
}
)
}
;
const
allBadSigResponses
=
{
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
6000
&
_since
=
%
224000
%
22
"
:
[
RESPONSE_EMPTY_NO_UPDATE_BAD_SIG_6000
]
"
GET
:
/
v1
/
buckets
/
main
/
collections
/
signed
/
changeset
?
_expected
=
6000
"
:
[
RESPONSE_ONLY_RECORD4_BAD_SIG
]
}
;
startSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
registerHandlers
(
allBadSigResponses
)
;
await
Assert
.
rejects
(
client
.
maybeSync
(
6000
)
RemoteSettingsClient
.
InvalidSignatureError
"
Sync
failed
as
expected
(
bad
signature
after
retry
)
"
)
;
endSnapshot
=
getUptakeTelemetrySnapshot
(
TELEMETRY_COMPONENT
TELEMETRY_SOURCE
)
;
expectedIncrements
=
{
[
UptakeTelemetry
.
STATUS
.
SYNC_START
]
:
1
[
UptakeTelemetry
.
STATUS
.
SIGNATURE_RETRY_ERROR
]
:
1
}
;
checkUptakeTelemetry
(
startSnapshot
endSnapshot
expectedIncrements
)
;
ok
(
arrayEqual
(
(
await
client
.
get
(
)
)
.
map
(
r
=
>
r
.
id
)
[
RECORD3
.
id
RECORD2
.
id
]
)
"
Local
records
were
not
changed
"
)
;
await
client
.
get
(
{
verifySignature
:
true
}
)
;
await
client
.
db
.
create
(
{
id
:
"
c6b19c67
-
2e0e
-
4a82
-
b7f7
-
1777b05f3e81
"
last_modified
:
42
tampered
:
true
}
)
;
await
Assert
.
rejects
(
client
.
maybeSync
(
6000
)
RemoteSettingsClient
.
InvalidSignatureError
"
Sync
failed
as
expected
(
bad
signature
after
retry
)
"
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
0
"
Local
database
is
now
empty
.
"
)
;
await
client
.
db
.
create
(
{
id
:
"
c6b19c67
-
2e0e
-
4a82
-
b7f7
-
1777b05f3e81
"
last_modified
:
42
tampered
:
true
}
)
;
await
Assert
.
rejects
(
client
.
maybeSync
(
6000
)
RemoteSettingsClient
.
InvalidSignatureError
"
Sync
failed
as
expected
(
bad
signature
after
retry
)
"
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
0
"
Local
database
is
now
empty
.
"
)
;
const
sigCalls
=
[
]
;
let
i
=
0
;
client
.
_verifier
=
{
async
asyncVerifyContentSignature
(
serialized
)
{
sigCalls
.
push
(
serialized
)
;
console
.
log
(
verify
call
{
i
}
)
;
return
[
false
true
false
true
]
[
i
+
+
]
;
}
}
;
await
client
.
db
.
importChanges
(
{
signature
:
{
x5u
signature
:
"
aa
"
}
}
4000
[
{
id
:
"
extraId
"
last_modified
:
42
}
]
)
;
equal
(
(
await
client
.
get
(
)
)
.
length
1
)
;
await
Assert
.
rejects
(
client
.
maybeSync
(
6000
)
RemoteSettingsClient
.
InvalidSignatureError
"
Sync
failed
as
expected
(
bad
signature
after
retry
)
"
)
;
equal
(
i
4
"
sync
has
retried
as
expected
"
)
;
ok
(
/
extraId
/
.
test
(
sigCalls
[
0
]
)
"
extra
record
when
importing
changes
"
)
;
ok
(
/
extraId
/
.
test
(
sigCalls
[
1
]
)
"
extra
record
when
checking
local
"
)
;
ok
(
!
/
extraId
/
.
test
(
sigCalls
[
2
]
)
"
db
was
flushed
before
retry
"
)
;
ok
(
/
extraId
/
.
test
(
sigCalls
[
3
]
)
"
when
checking
local
after
retry
"
)
;
}
)
;
