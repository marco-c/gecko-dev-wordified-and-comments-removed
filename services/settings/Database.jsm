const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
IDBHelpers
:
"
resource
:
/
/
services
-
settings
/
IDBHelpers
.
jsm
"
CommonUtils
:
"
resource
:
/
/
services
-
common
/
utils
.
js
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
Database
"
]
;
class
Database
{
constructor
(
identifier
)
{
ensureShutdownBlocker
(
)
;
this
.
identifier
=
identifier
;
}
async
list
(
options
=
{
}
)
{
const
{
filters
=
{
}
sort
=
"
"
}
=
options
;
let
results
=
[
]
;
try
{
await
executeIDB
(
"
records
"
(
store
rejectTransaction
)
=
>
{
if
(
ObjectUtils
.
isEmpty
(
filters
)
)
{
const
range
=
IDBKeyRange
.
only
(
this
.
identifier
)
;
const
request
=
store
.
index
(
"
cid
"
)
.
getAll
(
range
)
;
request
.
onsuccess
=
e
=
>
{
results
=
e
.
target
.
result
;
}
;
return
;
}
const
request
=
store
.
index
(
"
cid
"
)
.
openCursor
(
IDBKeyRange
.
only
(
this
.
identifier
)
)
;
const
objFilters
=
transformSubObjectFilters
(
filters
)
;
request
.
onsuccess
=
event
=
>
{
try
{
const
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
const
{
value
}
=
cursor
;
if
(
filterObject
(
objFilters
value
)
)
{
results
.
push
(
value
)
;
}
cursor
.
continue
(
)
;
}
}
catch
(
ex
)
{
rejectTransaction
(
ex
)
;
}
}
;
}
{
mode
:
"
readonly
"
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
list
(
)
"
this
.
identifier
)
;
}
for
(
const
result
of
results
)
{
delete
result
.
_cid
;
}
return
sort
?
sortObjects
(
sort
results
)
:
results
;
}
async
importBulk
(
toInsert
)
{
const
_cid
=
this
.
identifier
;
try
{
await
executeIDB
(
"
records
"
(
store
rejectTransaction
)
=
>
{
IDBHelpers
.
bulkOperationHelper
(
store
rejectTransaction
"
put
"
toInsert
.
map
(
item
=
>
{
return
Object
.
assign
(
{
_cid
}
item
)
;
}
)
)
;
}
{
desc
:
"
importBulk
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
importBulk
(
)
"
this
.
identifier
)
;
}
}
async
deleteBulk
(
toDelete
)
{
const
_cid
=
this
.
identifier
;
try
{
await
executeIDB
(
"
records
"
(
store
rejectTransaction
)
=
>
{
IDBHelpers
.
bulkOperationHelper
(
store
rejectTransaction
"
delete
"
toDelete
.
map
(
item
=
>
{
return
[
_cid
item
.
id
]
;
}
)
)
;
}
{
desc
:
"
deleteBulk
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
deleteBulk
(
)
"
this
.
identifier
)
;
}
}
async
getLastModified
(
)
{
let
entry
=
null
;
try
{
await
executeIDB
(
"
timestamps
"
store
=
>
{
store
.
get
(
this
.
identifier
)
.
onsuccess
=
e
=
>
(
entry
=
e
.
target
.
result
)
;
}
{
mode
:
"
readonly
"
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
getLastModified
(
)
"
this
.
identifier
)
;
}
return
entry
?
entry
.
value
:
null
;
}
async
saveLastModified
(
lastModified
)
{
const
value
=
parseInt
(
lastModified
10
)
|
|
null
;
try
{
await
executeIDB
(
"
timestamps
"
store
=
>
{
if
(
value
=
=
=
null
)
{
store
.
delete
(
this
.
identifier
)
;
}
else
{
store
.
put
(
{
cid
:
this
.
identifier
value
}
)
;
}
}
{
desc
:
"
saveLastModified
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
saveLastModified
(
)
"
this
.
identifier
)
;
}
return
value
;
}
async
getMetadata
(
)
{
let
entry
=
null
;
try
{
await
executeIDB
(
"
collections
"
store
=
>
{
store
.
get
(
this
.
identifier
)
.
onsuccess
=
e
=
>
(
entry
=
e
.
target
.
result
)
;
}
{
mode
:
"
readonly
"
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
getMetadata
(
)
"
this
.
identifier
)
;
}
return
entry
?
entry
.
metadata
:
null
;
}
async
saveMetadata
(
metadata
)
{
try
{
await
executeIDB
(
"
collections
"
store
=
>
{
if
(
metadata
=
=
=
null
)
{
store
.
delete
(
this
.
identifier
)
;
}
else
{
store
.
put
(
{
cid
:
this
.
identifier
metadata
}
)
;
}
}
{
desc
:
"
saveMetadata
(
)
in
"
+
this
.
identifier
}
)
;
return
metadata
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
saveMetadata
(
)
"
this
.
identifier
)
;
}
}
async
getAttachment
(
attachmentId
)
{
let
entry
=
null
;
try
{
await
executeIDB
(
"
attachments
"
store
=
>
{
store
.
get
(
[
this
.
identifier
attachmentId
]
)
.
onsuccess
=
e
=
>
{
entry
=
e
.
target
.
result
;
}
;
}
{
mode
:
"
readonly
"
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
getAttachment
(
)
"
this
.
identifier
)
;
}
return
entry
?
entry
.
attachment
:
null
;
}
async
saveAttachment
(
attachmentId
attachment
)
{
try
{
await
executeIDB
(
"
attachments
"
store
=
>
{
if
(
attachment
)
{
store
.
put
(
{
cid
:
this
.
identifier
attachmentId
attachment
}
)
;
}
else
{
store
.
delete
(
[
this
.
identifier
attachmentId
]
)
;
}
}
{
desc
:
"
saveAttachment
(
"
+
attachmentId
+
"
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
saveAttachment
(
)
"
this
.
identifier
)
;
}
}
async
clear
(
)
{
try
{
await
this
.
saveLastModified
(
null
)
;
await
this
.
saveMetadata
(
null
)
;
await
executeIDB
(
"
records
"
store
=
>
{
return
store
.
delete
(
IDBKeyRange
.
bound
(
[
this
.
identifier
]
[
this
.
identifier
[
]
]
false
true
)
)
;
}
{
desc
:
"
clear
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
clear
(
)
"
this
.
identifier
)
;
}
}
async
create
(
record
)
{
if
(
!
(
"
id
"
in
record
)
)
{
record
=
{
.
.
.
record
id
:
CommonUtils
.
generateUUID
(
)
}
;
}
try
{
await
executeIDB
(
"
records
"
store
=
>
{
store
.
add
(
{
.
.
.
record
_cid
:
this
.
identifier
}
)
;
}
{
desc
:
"
create
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
create
(
)
"
this
.
identifier
)
;
}
return
record
;
}
async
update
(
record
)
{
try
{
await
executeIDB
(
"
records
"
store
=
>
{
store
.
put
(
{
.
.
.
record
_cid
:
this
.
identifier
}
)
;
}
{
desc
:
"
update
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
update
(
)
"
this
.
identifier
)
;
}
}
async
delete
(
recordId
)
{
try
{
await
executeIDB
(
"
records
"
store
=
>
{
store
.
delete
(
[
this
.
identifier
recordId
]
)
;
}
{
desc
:
"
delete
(
)
in
"
+
this
.
identifier
}
)
;
}
catch
(
e
)
{
throw
new
IDBHelpers
.
IndexedDBError
(
e
"
delete
(
)
"
this
.
identifier
)
;
}
}
}
let
gDB
=
null
;
let
gDBPromise
=
null
;
async
function
openIDB
(
)
{
if
(
!
gDBPromise
)
{
gDBPromise
=
IDBHelpers
.
openIDB
(
)
;
}
let
db
=
await
gDBPromise
;
if
(
!
gDB
)
{
gDB
=
db
;
}
}
const
gPendingReadOnlyTransactions
=
new
Set
(
)
;
const
gPendingWriteOperations
=
new
Set
(
)
;
async
function
executeIDB
(
storeName
callback
options
=
{
}
)
{
if
(
!
gDB
)
{
if
(
gShutdownStarted
|
|
Services
.
startup
.
shuttingDown
)
{
throw
new
IDBHelpers
.
ShutdownError
(
"
The
application
is
shutting
down
"
"
execute
(
)
"
)
;
}
await
openIDB
(
)
;
}
else
{
await
Promise
.
resolve
(
)
;
}
if
(
!
gDB
&
&
(
gShutdownStarted
|
|
Services
.
startup
.
shuttingDown
)
)
{
throw
new
IDBHelpers
.
ShutdownError
(
"
The
application
is
shutting
down
"
"
execute
(
)
"
)
;
}
const
{
mode
=
"
readwrite
"
desc
=
"
"
}
=
options
;
let
{
promise
transaction
}
=
IDBHelpers
.
executeIDB
(
gDB
storeName
mode
callback
desc
)
;
let
finishedFn
;
if
(
mode
=
=
"
readonly
"
)
{
gPendingReadOnlyTransactions
.
add
(
transaction
)
;
finishedFn
=
(
)
=
>
gPendingReadOnlyTransactions
.
delete
(
transaction
)
;
}
else
{
let
obj
=
{
promise
desc
}
;
gPendingWriteOperations
.
add
(
obj
)
;
finishedFn
=
(
)
=
>
gPendingWriteOperations
.
delete
(
obj
)
;
}
return
promise
.
finally
(
finishedFn
)
;
}
function
_isUndefined
(
value
)
{
return
typeof
value
=
=
=
"
undefined
"
;
}
function
makeNestedObjectFromArr
(
arr
val
nestedFiltersObj
)
{
const
last
=
arr
.
length
-
1
;
return
arr
.
reduce
(
(
acc
cv
i
)
=
>
{
if
(
i
=
=
=
last
)
{
return
(
acc
[
cv
]
=
val
)
;
}
else
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
acc
cv
)
)
{
return
acc
[
cv
]
;
}
return
(
acc
[
cv
]
=
{
}
)
;
}
nestedFiltersObj
)
;
}
function
transformSubObjectFilters
(
filtersObj
)
{
const
transformedFilters
=
{
}
;
for
(
const
[
key
val
]
of
Object
.
entries
(
filtersObj
)
)
{
const
keysArr
=
key
.
split
(
"
.
"
)
;
makeNestedObjectFromArr
(
keysArr
val
transformedFilters
)
;
}
return
transformedFilters
;
}
function
filterObject
(
filters
entry
)
{
return
Object
.
entries
(
filters
)
.
every
(
(
[
filter
value
]
)
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
return
value
.
some
(
candidate
=
>
candidate
=
=
=
entry
[
filter
]
)
;
}
else
if
(
typeof
value
=
=
=
"
object
"
)
{
return
filterObject
(
value
entry
[
filter
]
)
;
}
else
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
entry
filter
)
)
{
console
.
error
(
The
property
{
filter
}
does
not
exist
)
;
return
false
;
}
return
entry
[
filter
]
=
=
=
value
;
}
)
;
}
function
sortObjects
(
order
list
)
{
const
hasDash
=
order
[
0
]
=
=
=
"
-
"
;
const
field
=
hasDash
?
order
.
slice
(
1
)
:
order
;
const
direction
=
hasDash
?
-
1
:
1
;
return
list
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
[
field
]
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
direction
;
}
if
(
b
[
field
]
&
&
_isUndefined
(
a
[
field
]
)
)
{
return
-
direction
;
}
if
(
_isUndefined
(
a
[
field
]
)
&
&
_isUndefined
(
b
[
field
]
)
)
{
return
0
;
}
return
a
[
field
]
>
b
[
field
]
?
direction
:
-
direction
;
}
)
;
}
Database
.
_executeIDB
=
executeIDB
;
let
gShutdownStarted
=
false
;
Database
.
_cancelShutdown
=
(
)
=
>
{
gShutdownStarted
=
false
;
}
;
let
gShutdownBlocker
=
false
;
Database
.
_shutdownHandler
=
(
)
=
>
{
gShutdownStarted
=
true
;
const
NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR
=
0x80660006
;
for
(
let
transaction
of
Array
.
from
(
gPendingReadOnlyTransactions
)
)
{
try
{
transaction
.
abort
(
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR
)
{
Cu
.
reportError
(
ex
)
;
}
}
}
if
(
gDB
)
{
gDB
.
close
(
)
;
gDB
=
null
;
}
gDBPromise
=
null
;
return
Promise
.
allSettled
(
Array
.
from
(
gPendingWriteOperations
)
.
map
(
op
=
>
op
.
promise
)
)
;
}
;
function
ensureShutdownBlocker
(
)
{
if
(
gShutdownBlocker
)
{
return
;
}
gShutdownBlocker
=
true
;
AsyncShutdown
.
profileBeforeChange
.
addBlocker
(
"
RemoteSettingsClient
-
finish
IDB
access
.
"
Database
.
_shutdownHandler
{
fetchState
(
)
{
return
Array
.
from
(
gPendingWriteOperations
)
.
map
(
op
=
>
op
.
desc
)
;
}
}
)
;
}
