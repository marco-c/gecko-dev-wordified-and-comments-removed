"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
RemoteSettings
"
"
jexlFilterFunc
"
"
remoteSettingsBroadcastHandler
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
UptakeTelemetry
:
"
resource
:
/
/
services
-
common
/
uptake
-
telemetry
.
js
"
pushBroadcastService
:
"
resource
:
/
/
gre
/
modules
/
PushBroadcastService
.
jsm
"
RemoteSettingsClient
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsClient
.
jsm
"
SyncHistory
:
"
resource
:
/
/
services
-
settings
/
SyncHistory
.
jsm
"
Utils
:
"
resource
:
/
/
services
-
settings
/
Utils
.
jsm
"
FilterExpressions
:
"
resource
:
/
/
gre
/
modules
/
components
-
utils
/
FilterExpressions
.
jsm
"
RemoteSettingsWorker
:
"
resource
:
/
/
services
-
settings
/
RemoteSettingsWorker
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
]
)
;
const
PREF_SETTINGS_DEFAULT_BUCKET
=
"
services
.
settings
.
default_bucket
"
;
const
PREF_SETTINGS_BRANCH
=
"
services
.
settings
.
"
;
const
PREF_SETTINGS_SERVER_BACKOFF
=
"
server
.
backoff
"
;
const
PREF_SETTINGS_LAST_UPDATE
=
"
last_update_seconds
"
;
const
PREF_SETTINGS_LAST_ETAG
=
"
last_etag
"
;
const
PREF_SETTINGS_CLOCK_SKEW_SECONDS
=
"
clock_skew_seconds
"
;
const
PREF_SETTINGS_SYNC_HISTORY_SIZE
=
"
sync_history_size
"
;
const
PREF_SETTINGS_SYNC_HISTORY_ERROR_THRESHOLD
=
"
sync_history_error_threshold
"
;
const
TELEMETRY_COMPONENT
=
"
remotesettings
"
;
const
TELEMETRY_SOURCE_POLL
=
"
settings
-
changes
-
monitoring
"
;
const
TELEMETRY_SOURCE_SYNC
=
"
settings
-
sync
"
;
const
BROADCAST_ID
=
"
remote
-
settings
/
monitor_changes
"
;
const
DEFAULT_SIGNER
=
"
remote
-
settings
.
content
-
signature
.
mozilla
.
org
"
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gPrefs
"
(
)
=
>
{
return
Services
.
prefs
.
getBranch
(
PREF_SETTINGS_BRANCH
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
Utils
.
log
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
gSyncHistory
"
(
)
=
>
{
const
prefSize
=
gPrefs
.
getIntPref
(
PREF_SETTINGS_SYNC_HISTORY_SIZE
100
)
;
const
size
=
Math
.
min
(
Math
.
max
(
prefSize
1000
)
10
)
;
return
new
SyncHistory
(
TELEMETRY_SOURCE_SYNC
{
size
}
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
gPrefBrokenSyncThreshold
"
PREF_SETTINGS_BRANCH
+
PREF_SETTINGS_SYNC_HISTORY_ERROR_THRESHOLD
10
)
;
async
function
jexlFilterFunc
(
entry
environment
)
{
const
{
filter_expression
}
=
entry
;
if
(
!
filter_expression
)
{
return
entry
;
}
let
result
;
try
{
const
context
=
{
env
:
environment
}
;
result
=
await
FilterExpressions
.
eval
(
filter_expression
context
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
return
result
?
entry
:
null
;
}
function
remoteSettingsFunction
(
)
{
const
_clients
=
new
Map
(
)
;
let
_invalidatePolling
=
false
;
const
defaultOptions
=
{
bucketNamePref
:
PREF_SETTINGS_DEFAULT_BUCKET
signerName
:
DEFAULT_SIGNER
filterFunc
:
jexlFilterFunc
}
;
const
remoteSettings
=
function
(
collectionName
options
)
{
if
(
!
_clients
.
has
(
collectionName
)
)
{
const
c
=
new
RemoteSettingsClient
(
collectionName
{
.
.
.
defaultOptions
.
.
.
options
}
)
;
_clients
.
set
(
collectionName
c
)
;
_invalidatePolling
=
true
;
console
.
debug
(
Instantiated
new
client
{
c
.
identifier
}
)
;
}
return
_clients
.
get
(
collectionName
)
;
}
;
async
function
_client
(
bucketName
collectionName
)
{
const
client
=
_clients
.
get
(
collectionName
)
;
if
(
client
&
&
client
.
bucketName
=
=
bucketName
)
{
return
client
;
}
if
(
bucketName
=
=
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_DEFAULT_BUCKET
)
)
{
const
c
=
new
RemoteSettingsClient
(
collectionName
defaultOptions
)
;
const
[
dbExists
localDump
]
=
await
Promise
.
all
(
[
Utils
.
hasLocalData
(
c
)
Utils
.
hasLocalDump
(
bucketName
collectionName
)
]
)
;
if
(
dbExists
|
|
localDump
)
{
return
c
;
}
}
console
.
debug
(
No
known
client
for
{
bucketName
}
/
{
collectionName
}
)
;
return
null
;
}
async
function
isSynchronizationBroken
(
)
{
const
threshold
=
Math
.
min
(
gPrefBrokenSyncThreshold
20
)
;
const
pastEntries
=
await
gSyncHistory
.
list
(
)
;
const
lastSuccessIdx
=
pastEntries
.
findIndex
(
e
=
>
e
.
status
=
=
UptakeTelemetry
.
STATUS_SUCCESS
)
;
return
(
lastSuccessIdx
>
=
threshold
|
|
(
lastSuccessIdx
<
0
&
&
pastEntries
.
length
>
=
threshold
)
)
;
}
remoteSettings
.
pollChanges
=
async
(
{
expectedTimestamp
trigger
=
"
manual
"
full
=
false
}
=
{
}
)
=
>
{
if
(
full
)
{
gPrefs
.
clearUserPref
(
PREF_SETTINGS_SERVER_BACKOFF
)
;
gPrefs
.
clearUserPref
(
PREF_SETTINGS_LAST_UPDATE
)
;
gPrefs
.
clearUserPref
(
PREF_SETTINGS_LAST_ETAG
)
;
}
let
pollTelemetryArgs
=
{
source
:
TELEMETRY_SOURCE_POLL
trigger
}
;
if
(
Utils
.
isOffline
)
{
console
.
info
(
"
Network
is
offline
.
Give
up
.
"
)
;
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
UptakeTelemetry
.
STATUS
.
NETWORK_OFFLINE_ERROR
pollTelemetryArgs
)
;
return
;
}
const
startedAt
=
new
Date
(
)
;
if
(
gPrefs
.
prefHasUserValue
(
PREF_SETTINGS_SERVER_BACKOFF
)
)
{
const
backoffReleaseTime
=
gPrefs
.
getCharPref
(
PREF_SETTINGS_SERVER_BACKOFF
)
;
const
remainingMilliseconds
=
parseInt
(
backoffReleaseTime
10
)
-
Date
.
now
(
)
;
if
(
remainingMilliseconds
>
0
)
{
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
UptakeTelemetry
.
STATUS
.
BACKOFF
pollTelemetryArgs
)
;
throw
new
Error
(
Server
is
asking
clients
to
back
off
;
retry
in
{
Math
.
ceil
(
remainingMilliseconds
/
1000
)
}
s
.
)
;
}
else
{
gPrefs
.
clearUserPref
(
PREF_SETTINGS_SERVER_BACKOFF
)
;
}
}
console
.
info
(
"
Start
polling
for
changes
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
remote
-
settings
:
changes
-
poll
-
start
"
JSON
.
stringify
(
{
expectedTimestamp
}
)
)
;
const
lastEtag
=
_invalidatePolling
?
"
"
:
gPrefs
.
getCharPref
(
PREF_SETTINGS_LAST_ETAG
"
"
)
;
let
pollResult
;
try
{
pollResult
=
await
Utils
.
fetchLatestChanges
(
Utils
.
SERVER_URL
{
expectedTimestamp
lastEtag
}
)
;
}
catch
(
e
)
{
let
reportStatus
;
if
(
/
JSON
\
.
parse
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
PARSE_ERROR
;
}
else
if
(
/
content
-
type
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
CONTENT_ERROR
;
}
else
if
(
/
Server
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
SERVER_ERROR
;
}
else
if
(
/
Timeout
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
TIMEOUT_ERROR
;
}
else
if
(
/
NetworkError
/
.
test
(
e
.
message
)
)
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
NETWORK_ERROR
;
}
else
{
reportStatus
=
UptakeTelemetry
.
STATUS
.
UNKNOWN_ERROR
;
}
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
reportStatus
pollTelemetryArgs
)
;
throw
new
Error
(
Polling
for
changes
failed
:
{
e
.
message
}
.
)
;
}
const
{
serverTimeMillis
changes
currentEtag
backoffSeconds
ageSeconds
}
=
pollResult
;
pollTelemetryArgs
=
{
age
:
ageSeconds
.
.
.
pollTelemetryArgs
}
;
const
reportStatus
=
changes
.
length
=
=
=
0
?
UptakeTelemetry
.
STATUS
.
UP_TO_DATE
:
UptakeTelemetry
.
STATUS
.
SUCCESS
;
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
reportStatus
pollTelemetryArgs
)
;
if
(
backoffSeconds
)
{
console
.
info
(
"
Server
asks
clients
to
backoff
for
{
backoffSeconds
}
seconds
"
)
;
const
backoffReleaseTime
=
Date
.
now
(
)
+
backoffSeconds
*
1000
;
gPrefs
.
setCharPref
(
PREF_SETTINGS_SERVER_BACKOFF
backoffReleaseTime
)
;
}
const
clockDifference
=
Math
.
floor
(
(
Date
.
now
(
)
-
serverTimeMillis
)
/
1000
)
;
gPrefs
.
setIntPref
(
PREF_SETTINGS_CLOCK_SKEW_SECONDS
clockDifference
)
;
const
checkedServerTimeInSeconds
=
Math
.
round
(
serverTimeMillis
/
1000
)
;
gPrefs
.
setIntPref
(
PREF_SETTINGS_LAST_UPDATE
checkedServerTimeInSeconds
)
;
let
firstError
;
for
(
const
change
of
changes
)
{
const
{
bucket
collection
last_modified
}
=
change
;
const
client
=
await
_client
(
bucket
collection
)
;
if
(
!
client
)
{
continue
;
}
try
{
await
client
.
maybeSync
(
last_modified
{
trigger
}
)
;
Services
.
prefs
.
setIntPref
(
client
.
lastCheckTimePref
checkedServerTimeInSeconds
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
if
(
!
firstError
)
{
firstError
=
e
;
firstError
.
details
=
change
;
}
}
}
_invalidatePolling
=
false
;
const
durationMilliseconds
=
new
Date
(
)
-
startedAt
;
const
syncTelemetryArgs
=
{
source
:
TELEMETRY_SOURCE_SYNC
duration
:
durationMilliseconds
timestamp
:
{
currentEtag
}
trigger
}
;
if
(
firstError
)
{
const
status
=
UptakeTelemetry
.
STATUS
.
SYNC_ERROR
;
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
status
syncTelemetryArgs
)
;
await
gSyncHistory
.
store
(
currentEtag
status
{
expectedTimestamp
errorName
:
firstError
.
name
}
)
.
catch
(
error
=
>
Cu
.
reportError
(
error
)
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
error
:
firstError
}
}
"
remote
-
settings
:
sync
-
error
"
)
;
if
(
await
isSynchronizationBroken
(
)
)
{
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
UptakeTelemetry
.
STATUS
.
SYNC_BROKEN_ERROR
syncTelemetryArgs
)
;
Services
.
obs
.
notifyObservers
(
{
wrappedJSObject
:
{
error
:
firstError
}
}
"
remote
-
settings
:
broken
-
sync
-
error
"
)
;
}
throw
firstError
;
}
gPrefs
.
setCharPref
(
PREF_SETTINGS_LAST_ETAG
currentEtag
)
;
const
status
=
UptakeTelemetry
.
STATUS
.
SUCCESS
;
await
UptakeTelemetry
.
report
(
TELEMETRY_COMPONENT
status
syncTelemetryArgs
)
;
await
gSyncHistory
.
store
(
currentEtag
status
)
.
catch
(
error
=
>
Cu
.
reportError
(
error
)
)
;
console
.
info
(
"
Polling
for
changes
done
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
remote
-
settings
:
changes
-
poll
-
end
"
)
;
}
;
remoteSettings
.
inspect
=
async
(
)
=
>
{
const
{
changes
currentEtag
:
serverTimestamp
}
=
await
Utils
.
fetchLatestChanges
(
Utils
.
SERVER_URL
)
;
const
collections
=
await
Promise
.
all
(
changes
.
map
(
async
change
=
>
{
const
{
bucket
collection
last_modified
:
serverTimestamp
}
=
change
;
const
client
=
await
_client
(
bucket
collection
)
;
if
(
!
client
)
{
return
null
;
}
const
localTimestamp
=
await
client
.
getLastModified
(
)
;
const
lastCheck
=
Services
.
prefs
.
getIntPref
(
client
.
lastCheckTimePref
0
)
;
return
{
bucket
collection
localTimestamp
serverTimestamp
lastCheck
signerName
:
client
.
signerName
}
;
}
)
)
;
return
{
serverURL
:
Utils
.
SERVER_URL
pollingEndpoint
:
Utils
.
SERVER_URL
+
Utils
.
CHANGES_PATH
serverTimestamp
localTimestamp
:
gPrefs
.
getCharPref
(
PREF_SETTINGS_LAST_ETAG
null
)
lastCheck
:
gPrefs
.
getIntPref
(
PREF_SETTINGS_LAST_UPDATE
0
)
mainBucket
:
Services
.
prefs
.
getCharPref
(
PREF_SETTINGS_DEFAULT_BUCKET
)
defaultSigner
:
DEFAULT_SIGNER
collections
:
collections
.
filter
(
c
=
>
!
!
c
)
history
:
{
[
TELEMETRY_SOURCE_SYNC
]
:
await
gSyncHistory
.
list
(
)
}
}
;
}
;
remoteSettings
.
clearAll
=
async
(
)
=
>
{
const
{
collections
}
=
await
remoteSettings
.
inspect
(
)
;
await
Promise
.
all
(
collections
.
map
(
async
(
{
collection
}
)
=
>
{
const
client
=
RemoteSettings
(
collection
)
;
await
client
.
attachments
.
deleteAll
(
)
;
await
client
.
db
.
clear
(
)
;
Services
.
prefs
.
clearUserPref
(
client
.
lastCheckTimePref
)
;
}
)
)
;
}
;
remoteSettings
.
init
=
(
)
=
>
{
console
.
info
(
"
Initialize
Remote
Settings
"
)
;
const
currentVersion
=
gPrefs
.
getStringPref
(
PREF_SETTINGS_LAST_ETAG
'
"
0
"
'
)
;
const
moduleInfo
=
{
moduleURI
:
__URI__
symbolName
:
"
remoteSettingsBroadcastHandler
"
}
;
pushBroadcastService
.
addListener
(
BROADCAST_ID
currentVersion
moduleInfo
)
;
}
;
return
remoteSettings
;
}
var
RemoteSettings
=
remoteSettingsFunction
(
)
;
var
remoteSettingsBroadcastHandler
=
{
async
receivedBroadcastMessage
(
version
broadcastID
context
)
{
const
{
phase
}
=
context
;
const
isStartup
=
[
pushBroadcastService
.
PHASES
.
HELLO
pushBroadcastService
.
PHASES
.
REGISTER
]
.
includes
(
phase
)
;
console
.
info
(
Push
notification
received
(
version
=
{
version
}
phase
=
{
phase
}
)
)
;
return
RemoteSettings
.
pollChanges
(
{
expectedTimestamp
:
version
trigger
:
isStartup
?
"
startup
"
:
"
broadcast
"
}
)
;
}
}
;
