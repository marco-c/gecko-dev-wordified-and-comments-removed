const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
KeyValueService
:
"
resource
:
/
/
gre
/
modules
/
kvstore
.
jsm
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
SyncHistory
"
]
;
class
SyncHistory
{
#
store
;
constructor
(
source
{
size
}
=
{
size
:
100
}
)
{
this
.
source
=
source
;
this
.
size
=
size
;
}
async
store
(
etag
status
infos
=
{
}
)
{
const
rkv
=
await
this
.
#
init
(
)
;
const
timestamp
=
parseInt
(
etag
.
replace
(
'
"
'
"
"
)
10
)
;
if
(
Number
.
isNaN
(
timestamp
)
)
{
throw
new
Error
(
Invalid
ETag
value
{
etag
}
)
;
}
const
key
=
v1
-
{
this
.
source
}
\
t
{
timestamp
}
;
const
value
=
{
timestamp
status
infos
}
;
await
rkv
.
put
(
key
JSON
.
stringify
(
value
)
)
;
const
allEntries
=
await
this
.
list
(
)
;
for
(
let
i
=
this
.
size
;
i
<
allEntries
.
length
;
i
+
+
)
{
let
{
timestamp
}
=
allEntries
[
i
]
;
await
rkv
.
delete
(
v1
-
{
this
.
source
}
\
t
{
timestamp
}
)
;
}
}
async
list
(
)
{
const
rkv
=
await
this
.
#
init
(
)
;
const
entries
=
[
]
;
for
(
const
{
value
}
of
await
rkv
.
enumerate
(
v1
-
{
this
.
source
}
v1
-
{
this
.
source
}
\
n
)
)
{
try
{
const
stored
=
JSON
.
parse
(
value
)
;
entries
.
push
(
{
.
.
.
stored
datetime
:
new
Date
(
stored
.
timestamp
)
}
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
entries
.
sort
(
(
a
b
)
=
>
(
a
.
timestamp
>
b
.
timestamp
?
-
1
:
1
)
)
;
return
entries
;
}
async
last
(
)
{
return
(
await
this
.
list
(
)
)
[
0
]
;
}
async
clear
(
)
{
const
rkv
=
await
this
.
#
init
(
)
;
await
rkv
.
clear
(
)
;
}
async
#
init
(
)
{
if
(
!
this
.
#
store
)
{
const
dir
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
settings
"
)
;
await
IOUtils
.
makeDirectory
(
dir
)
;
this
.
#
store
=
await
lazy
.
KeyValueService
.
getOrCreate
(
dir
"
synchistory
"
)
;
}
return
this
.
#
store
;
}
}
