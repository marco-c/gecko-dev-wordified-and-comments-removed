"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
rest
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsStorage
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccountsClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsClient
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccountsConfig
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsConfig
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
jwcrypto
"
"
resource
:
/
/
services
-
crypto
/
jwcrypto
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccountsOAuthGrantClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsOAuthGrantClient
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccountsCommands
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommands
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
FxAccountsProfile
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsProfile
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
FXA_ENABLED
"
"
identity
.
fxaccounts
.
enabled
"
true
)
;
var
publicProperties
=
[
"
_withCurrentAccountState
"
"
accountStatus
"
"
canGetKeys
"
"
checkVerificationStatus
"
"
commands
"
"
getAccountsClient
"
"
getAssertion
"
"
getDeviceId
"
"
getDeviceList
"
"
getKeys
"
"
getOAuthToken
"
"
getProfileCache
"
"
getPushSubscription
"
"
getSignedInUser
"
"
getSignedInUserProfile
"
"
handleAccountDestroyed
"
"
handleDeviceDisconnection
"
"
handleEmailUpdated
"
"
hasLocalSession
"
"
invalidateCertificate
"
"
loadAndPoll
"
"
localtimeOffsetMsec
"
"
notifyDevices
"
"
now
"
"
removeCachedOAuthToken
"
"
resendVerificationEmail
"
"
resetCredentials
"
"
sessionStatus
"
"
setProfileCache
"
"
setSignedInUser
"
"
signOut
"
"
updateDeviceRegistration
"
"
updateUserAccountData
"
"
whenVerified
"
]
;
var
AccountState
=
this
.
AccountState
=
function
(
storageManager
)
{
this
.
storageManager
=
storageManager
;
this
.
promiseInitialized
=
this
.
storageManager
.
getAccountData
(
)
.
then
(
data
=
>
{
this
.
oauthTokens
=
data
&
&
data
.
oauthTokens
?
data
.
oauthTokens
:
{
}
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Failed
to
initialize
the
storage
manager
"
err
)
;
}
)
;
}
;
AccountState
.
prototype
=
{
oauthTokens
:
null
whenVerifiedDeferred
:
null
whenKeysReadyDeferred
:
null
get
isCurrent
(
)
{
return
this
.
storageManager
!
=
null
;
}
abort
(
)
{
if
(
this
.
whenVerifiedDeferred
)
{
this
.
whenVerifiedDeferred
.
reject
(
new
Error
(
"
Verification
aborted
;
Another
user
signing
in
"
)
)
;
this
.
whenVerifiedDeferred
=
null
;
}
if
(
this
.
whenKeysReadyDeferred
)
{
this
.
whenKeysReadyDeferred
.
reject
(
new
Error
(
"
Verification
aborted
;
Another
user
signing
in
"
)
)
;
this
.
whenKeysReadyDeferred
=
null
;
}
return
this
.
signOut
(
)
;
}
async
signOut
(
)
{
this
.
cert
=
null
;
this
.
keyPair
=
null
;
this
.
oauthTokens
=
null
;
if
(
!
this
.
storageManager
)
{
return
;
}
const
storageManager
=
this
.
storageManager
;
this
.
storageManager
=
null
;
await
storageManager
.
deleteAccountData
(
)
;
await
storageManager
.
finalize
(
)
;
}
getUserAccountData
(
fieldNames
=
null
)
{
if
(
!
this
.
isCurrent
)
{
return
Promise
.
reject
(
new
Error
(
"
Another
user
has
signed
in
"
)
)
;
}
return
this
.
storageManager
.
getAccountData
(
fieldNames
)
.
then
(
result
=
>
{
return
this
.
resolve
(
result
)
;
}
)
;
}
updateUserAccountData
(
updatedFields
)
{
if
(
!
this
.
isCurrent
)
{
return
Promise
.
reject
(
new
Error
(
"
Another
user
has
signed
in
"
)
)
;
}
return
this
.
storageManager
.
updateAccountData
(
updatedFields
)
;
}
resolve
(
result
)
{
if
(
!
this
.
isCurrent
)
{
log
.
info
(
"
An
accountState
promise
was
resolved
but
was
actually
rejected
"
+
"
due
to
a
different
user
being
signed
in
.
Originally
resolved
"
+
"
with
"
result
)
;
return
Promise
.
reject
(
new
Error
(
"
A
different
user
signed
in
"
)
)
;
}
return
Promise
.
resolve
(
result
)
;
}
reject
(
error
)
{
if
(
!
this
.
isCurrent
)
{
log
.
info
(
"
An
accountState
promise
was
rejected
but
we
are
ignoring
that
"
+
"
reason
and
rejecting
it
due
to
a
different
user
being
signed
in
.
"
+
"
Originally
rejected
with
"
error
)
;
return
Promise
.
reject
(
new
Error
(
"
A
different
user
signed
in
"
)
)
;
}
return
Promise
.
reject
(
error
)
;
}
_cachePreamble
(
)
{
if
(
!
this
.
isCurrent
)
{
throw
new
Error
(
"
Another
user
has
signed
in
"
)
;
}
}
setCachedToken
(
scopeArray
tokenData
)
{
this
.
_cachePreamble
(
)
;
if
(
!
tokenData
.
token
)
{
throw
new
Error
(
"
No
token
"
)
;
}
let
key
=
getScopeKey
(
scopeArray
)
;
this
.
oauthTokens
[
key
]
=
tokenData
;
this
.
_persistCachedTokens
(
)
;
}
getCachedToken
(
scopeArray
)
{
this
.
_cachePreamble
(
)
;
let
key
=
getScopeKey
(
scopeArray
)
;
let
result
=
this
.
oauthTokens
[
key
]
;
if
(
result
)
{
log
.
trace
(
"
getCachedToken
returning
cached
token
"
)
;
return
result
;
}
return
null
;
}
removeCachedToken
(
token
)
{
this
.
_cachePreamble
(
)
;
let
data
=
this
.
oauthTokens
;
for
(
let
[
key
tokenValue
]
of
Object
.
entries
(
data
)
)
{
if
(
tokenValue
.
token
=
=
token
)
{
delete
data
[
key
]
;
this
.
_persistCachedTokens
(
)
;
return
tokenValue
;
}
}
return
null
;
}
_persistCachedTokens
(
)
{
this
.
_cachePreamble
(
)
;
return
this
.
updateUserAccountData
(
{
oauthTokens
:
this
.
oauthTokens
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Failed
to
update
cached
tokens
"
err
)
;
}
)
;
}
}
;
function
getScopeKey
(
scopeArray
)
{
let
normalizedScopes
=
scopeArray
.
map
(
item
=
>
item
.
toLowerCase
(
)
)
;
return
normalizedScopes
.
sort
(
)
.
join
(
"
|
"
)
;
}
function
getPropertyDescriptor
(
obj
prop
)
{
return
Object
.
getOwnPropertyDescriptor
(
obj
prop
)
|
|
getPropertyDescriptor
(
Object
.
getPrototypeOf
(
obj
)
prop
)
;
}
function
copyObjectProperties
(
from
to
thisObj
keys
)
{
for
(
let
prop
of
keys
)
{
let
desc
=
getPropertyDescriptor
(
from
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
desc
.
value
=
desc
.
value
.
bind
(
thisObj
)
;
}
if
(
desc
.
get
)
{
desc
.
get
=
desc
.
get
.
bind
(
thisObj
)
;
}
if
(
desc
.
set
)
{
desc
.
set
=
desc
.
set
.
bind
(
thisObj
)
;
}
Object
.
defineProperty
(
to
prop
desc
)
;
}
}
function
urlsafeBase64Encode
(
key
)
{
return
ChromeUtils
.
base64URLEncode
(
new
Uint8Array
(
key
)
{
pad
:
false
}
)
;
}
var
FxAccounts
=
function
(
mockInternal
)
{
let
external
=
{
}
;
let
internal
;
if
(
!
mockInternal
)
{
internal
=
new
FxAccountsInternal
(
)
;
copyObjectProperties
(
FxAccountsInternal
.
prototype
external
internal
publicProperties
)
;
}
else
{
internal
=
Object
.
create
(
FxAccountsInternal
.
prototype
Object
.
getOwnPropertyDescriptors
(
mockInternal
)
)
;
copyObjectProperties
(
internal
external
internal
publicProperties
)
;
external
.
internal
=
internal
;
}
if
(
!
internal
.
fxaPushService
)
{
XPCOMUtils
.
defineLazyGetter
(
internal
"
fxaPushService
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
fxaccounts
/
push
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
)
;
}
if
(
!
internal
.
observerPreloads
)
{
internal
.
observerPreloads
=
[
(
)
=
>
{
let
scope
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
scope
)
;
return
scope
.
Weave
.
Service
.
promiseInitialized
;
}
]
;
}
internal
.
initialize
(
)
;
return
Object
.
freeze
(
external
)
;
}
;
this
.
FxAccounts
.
config
=
FxAccountsConfig
;
function
FxAccountsInternal
(
)
{
this
.
POLL_SESSION
=
POLL_SESSION
;
}
FxAccountsInternal
.
prototype
=
{
VERIFICATION_POLL_TIMEOUT_INITIAL
:
60000
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
:
5
*
60000
VERIFICATION_POLL_START_SLOWDOWN_THRESHOLD
:
5
DEVICE_REGISTRATION_VERSION
:
2
_fxAccountsClient
:
null
initialize
(
)
{
this
.
currentTimer
=
null
;
this
.
currentAccountState
=
this
.
newAccountState
(
)
;
}
get
fxAccountsClient
(
)
{
if
(
!
this
.
_fxAccountsClient
)
{
this
.
_fxAccountsClient
=
new
FxAccountsClient
(
)
;
}
return
this
.
_fxAccountsClient
;
}
_profile
:
null
get
profile
(
)
{
if
(
!
this
.
_profile
)
{
let
profileServerUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
profile
.
uri
"
)
;
this
.
_profile
=
new
FxAccountsProfile
(
{
fxa
:
this
profileServerUrl
}
)
;
}
return
this
.
_profile
;
}
_commands
:
null
get
commands
(
)
{
if
(
!
this
.
_commands
)
{
this
.
_commands
=
new
FxAccountsCommands
(
this
)
;
}
return
this
.
_commands
;
}
newAccountState
(
credentials
)
{
let
storage
=
new
FxAccountsStorageManager
(
)
;
storage
.
initialize
(
credentials
)
;
return
new
AccountState
(
storage
)
;
}
_withCurrentAccountState
(
func
)
{
const
state
=
this
.
currentAccountState
;
const
getUserData
=
(
fields
)
=
>
state
.
getUserAccountData
(
fields
)
;
const
updateUserData
=
(
data
)
=
>
state
.
updateUserAccountData
(
data
)
;
return
func
(
getUserData
updateUserData
)
;
}
notifyDevices
(
deviceIds
excludedIds
payload
TTL
)
{
if
(
typeof
deviceIds
=
=
"
string
"
)
{
deviceIds
=
[
deviceIds
]
;
}
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
throw
this
.
_error
(
ERROR_NO_ACCOUNT
)
;
}
if
(
!
data
.
sessionToken
)
{
throw
this
.
_error
(
ERROR_AUTH_ERROR
"
notifyDevices
called
without
a
session
token
"
)
;
}
return
this
.
fxAccountsClient
.
notifyDevices
(
data
.
sessionToken
deviceIds
excludedIds
payload
TTL
)
;
}
)
;
}
now
(
)
{
return
this
.
fxAccountsClient
.
now
(
)
;
}
getAccountsClient
(
)
{
return
this
.
fxAccountsClient
;
}
get
localtimeOffsetMsec
(
)
{
return
this
.
fxAccountsClient
.
localtimeOffsetMsec
;
}
checkEmailStatus
:
function
checkEmailStatus
(
sessionToken
options
=
{
}
)
{
if
(
!
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
checkEmailStatus
called
without
a
session
token
"
)
)
;
}
return
this
.
fxAccountsClient
.
recoveryEmailStatus
(
sessionToken
options
)
.
catch
(
error
=
>
this
.
_handleTokenError
(
error
)
)
;
}
fetchKeys
:
function
fetchKeys
(
keyFetchToken
)
{
log
.
debug
(
"
fetchKeys
:
"
+
!
!
keyFetchToken
)
;
if
(
logPII
)
{
log
.
debug
(
"
fetchKeys
-
the
token
is
"
+
keyFetchToken
)
;
}
return
this
.
fxAccountsClient
.
accountKeys
(
keyFetchToken
)
;
}
async
getSignedInUser
(
)
{
let
currentState
=
this
.
currentAccountState
;
const
data
=
await
currentState
.
getUserAccountData
(
)
;
if
(
!
data
)
{
return
currentState
.
resolve
(
null
)
;
}
if
(
!
FXA_ENABLED
)
{
await
this
.
signOut
(
)
;
return
currentState
.
resolve
(
null
)
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
this
.
startVerifiedCheck
(
data
)
;
}
return
currentState
.
resolve
(
data
)
;
}
async
setSignedInUser
(
credentials
)
{
if
(
!
FXA_ENABLED
)
{
throw
new
Error
(
"
Cannot
call
setSignedInUser
when
FxA
is
disabled
.
"
)
;
}
log
.
debug
(
"
setSignedInUser
-
aborting
any
existing
flows
"
)
;
const
signedInUser
=
await
this
.
getSignedInUser
(
)
;
if
(
signedInUser
)
{
await
this
.
_signOutServer
(
signedInUser
.
sessionToken
signedInUser
.
oauthTokens
)
;
}
await
this
.
abortExistingFlow
(
)
;
let
currentAccountState
=
this
.
currentAccountState
=
this
.
newAccountState
(
Cu
.
cloneInto
(
credentials
{
}
)
)
;
await
currentAccountState
.
promiseInitialized
;
if
(
!
this
.
isUserEmailVerified
(
credentials
)
)
{
this
.
startVerifiedCheck
(
credentials
)
;
}
Services
.
telemetry
.
getHistogramById
(
"
FXA_CONFIGURED
"
)
.
add
(
1
)
;
await
this
.
notifyObservers
(
ONLOGIN_NOTIFICATION
)
;
await
this
.
updateDeviceRegistration
(
)
;
return
currentAccountState
.
resolve
(
)
;
}
updateUserAccountData
(
credentials
)
{
log
.
debug
(
"
updateUserAccountData
called
with
fields
"
Object
.
keys
(
credentials
)
)
;
if
(
logPII
)
{
log
.
debug
(
"
updateUserAccountData
called
with
data
"
credentials
)
;
}
let
currentAccountState
=
this
.
currentAccountState
;
return
currentAccountState
.
promiseInitialized
.
then
(
(
)
=
>
{
return
currentAccountState
.
getUserAccountData
(
[
"
uid
"
]
)
;
}
)
.
then
(
existing
=
>
{
if
(
existing
.
uid
!
=
credentials
.
uid
)
{
throw
new
Error
(
"
The
specified
credentials
aren
'
t
for
the
current
user
"
)
;
}
credentials
=
Cu
.
cloneInto
(
credentials
{
}
)
;
delete
credentials
.
uid
;
return
currentAccountState
.
updateUserAccountData
(
credentials
)
;
}
)
;
}
getAssertion
:
function
getAssertion
(
audience
)
{
return
this
.
_getAssertion
(
audience
)
;
}
_getAssertion
:
function
_getAssertion
(
audience
)
{
log
.
debug
(
"
enter
getAssertion
(
)
"
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
return
null
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
return
null
;
}
if
(
!
data
.
sessionToken
)
{
throw
this
.
_error
(
ERROR_AUTH_ERROR
"
getAssertion
called
without
a
session
token
"
)
;
}
return
this
.
getKeypairAndCertificate
(
currentState
)
.
then
(
(
{
keyPair
certificate
}
)
=
>
{
return
this
.
getAssertionFromCert
(
data
keyPair
certificate
audience
)
;
}
)
;
}
)
.
catch
(
err
=
>
this
.
_handleTokenError
(
err
)
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
invalidateCertificate
(
)
{
return
this
.
currentAccountState
.
updateUserAccountData
(
{
cert
:
null
}
)
;
}
async
getDeviceId
(
)
{
let
data
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
if
(
!
data
)
{
return
null
;
}
if
(
data
.
deviceId
)
{
log
.
info
(
"
Migrating
from
deviceId
to
device
.
"
)
;
await
this
.
currentAccountState
.
updateUserAccountData
(
{
deviceId
:
null
deviceRegistrationVersion
:
null
device
:
{
id
:
data
.
deviceId
registrationVersion
:
data
.
deviceRegistrationVersion
}
}
)
;
data
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
}
const
{
device
}
=
data
;
if
(
(
await
this
.
checkDeviceUpdateNeeded
(
device
)
)
)
{
return
this
.
_registerOrUpdateDevice
(
data
)
;
}
return
device
.
id
;
}
async
checkDeviceUpdateNeeded
(
device
)
{
const
availableCommandsKeys
=
Object
.
keys
(
(
await
this
.
availableCommands
(
)
)
)
.
sort
(
)
;
return
!
device
|
|
!
device
.
registrationVersion
|
|
device
.
registrationVersion
<
this
.
DEVICE_REGISTRATION_VERSION
|
|
!
device
.
registeredCommandsKeys
|
|
!
CommonUtils
.
arrayEqual
(
device
.
registeredCommandsKeys
availableCommandsKeys
)
;
}
async
getDeviceList
(
)
{
const
accountData
=
await
this
.
_getVerifiedAccountOrReject
(
)
;
const
devices
=
await
this
.
fxAccountsClient
.
getDeviceList
(
accountData
.
sessionToken
)
;
const
ourDevice
=
devices
.
find
(
device
=
>
device
.
isCurrentDevice
)
;
if
(
ourDevice
.
pushEndpointExpired
)
{
await
this
.
fxaPushService
.
unsubscribe
(
)
;
await
this
.
_registerOrUpdateDevice
(
accountData
)
;
}
return
devices
;
}
resendVerificationEmail
:
function
resendVerificationEmail
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
this
.
getSignedInUser
(
)
.
then
(
data
=
>
{
if
(
data
)
{
if
(
!
data
.
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
resendVerificationEmail
called
without
a
session
token
"
)
)
;
}
this
.
startPollEmailStatus
(
currentState
data
.
sessionToken
"
start
"
)
;
return
this
.
fxAccountsClient
.
resendVerificationEmail
(
data
.
sessionToken
)
.
catch
(
err
=
>
this
.
_handleTokenError
(
err
)
)
;
}
throw
new
Error
(
"
Cannot
resend
verification
email
;
no
signed
-
in
user
"
)
;
}
)
;
}
abortExistingFlow
(
)
{
if
(
this
.
currentTimer
)
{
log
.
debug
(
"
Polling
aborted
;
Another
user
signing
in
"
)
;
clearTimeout
(
this
.
currentTimer
)
;
this
.
currentTimer
=
0
;
}
if
(
this
.
_profile
)
{
this
.
_profile
.
tearDown
(
)
;
this
.
_profile
=
null
;
}
if
(
this
.
_commands
)
{
this
.
_commands
=
null
;
}
return
this
.
currentAccountState
.
abort
(
)
;
}
accountStatus
:
function
accountStatus
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
return
false
;
}
return
this
.
fxAccountsClient
.
accountStatus
(
data
.
uid
)
;
}
)
;
}
checkVerificationStatus
(
)
{
log
.
trace
(
"
checkVerificationStatus
"
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
log
.
trace
(
"
checkVerificationStatus
-
no
user
data
"
)
;
return
null
;
}
log
.
trace
(
"
checkVerificationStatus
-
forcing
verification
status
check
"
)
;
return
this
.
startPollEmailStatus
(
currentState
data
.
sessionToken
"
push
"
)
;
}
)
;
}
_destroyOAuthToken
(
tokenData
)
{
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
tokenData
.
server
client_id
:
FX_OAUTH_CLIENT_ID
}
)
;
return
client
.
destroyToken
(
tokenData
.
token
)
;
}
_destroyAllOAuthTokens
(
tokenInfos
)
{
if
(
!
tokenInfos
)
{
return
Promise
.
resolve
(
)
;
}
let
promises
=
[
]
;
for
(
let
tokenInfo
of
Object
.
values
(
tokenInfos
)
)
{
promises
.
push
(
this
.
_destroyOAuthToken
(
tokenInfo
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
async
signOut
(
localOnly
)
{
let
sessionToken
;
let
tokensToRevoke
;
const
data
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
if
(
data
)
{
sessionToken
=
data
.
sessionToken
;
tokensToRevoke
=
data
.
oauthTokens
;
}
await
this
.
_signOutLocal
(
)
;
if
(
!
localOnly
)
{
Services
.
tm
.
dispatchToMainThread
(
async
(
)
=
>
{
await
this
.
_signOutServer
(
sessionToken
tokensToRevoke
)
;
FxAccountsConfig
.
resetConfigURLs
(
)
;
this
.
notifyObservers
(
"
testhelper
-
fxa
-
signout
-
complete
"
)
;
}
)
;
}
else
{
FxAccountsConfig
.
resetConfigURLs
(
)
;
}
return
this
.
notifyObservers
(
ONLOGOUT_NOTIFICATION
)
;
}
async
_signOutLocal
(
)
{
await
this
.
currentAccountState
.
signOut
(
)
;
await
this
.
abortExistingFlow
(
)
;
this
.
currentAccountState
=
this
.
newAccountState
(
)
;
return
this
.
currentAccountState
.
promiseInitialized
;
}
async
_signOutServer
(
sessionToken
tokensToRevoke
)
{
log
.
debug
(
"
Unsubscribing
from
FxA
push
.
"
)
;
try
{
await
this
.
fxaPushService
.
unsubscribe
(
)
;
}
catch
(
err
)
{
log
.
error
(
"
Could
not
unsubscribe
from
push
.
"
err
)
;
}
if
(
sessionToken
)
{
log
.
debug
(
"
Destroying
session
and
device
.
"
)
;
try
{
await
this
.
fxAccountsClient
.
signOut
(
sessionToken
{
service
:
"
sync
"
}
)
;
}
catch
(
err
)
{
log
.
error
(
"
Error
during
remote
sign
out
of
Firefox
Accounts
"
err
)
;
}
}
else
{
log
.
warn
(
"
Missing
session
token
;
skipping
remote
sign
out
"
)
;
}
log
.
debug
(
"
Destroying
all
OAuth
tokens
.
"
)
;
try
{
await
this
.
_destroyAllOAuthTokens
(
tokensToRevoke
)
;
}
catch
(
err
)
{
log
.
error
(
"
Error
during
destruction
of
oauth
tokens
during
signout
"
err
)
;
}
}
sessionStatus
(
)
{
return
this
.
getSignedInUser
(
)
.
then
(
data
=
>
{
if
(
!
data
.
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
sessionStatus
called
without
a
session
token
"
)
)
;
}
return
this
.
fxAccountsClient
.
sessionStatus
(
data
.
sessionToken
)
;
}
)
;
}
async
hasLocalSession
(
)
{
let
data
=
await
this
.
getSignedInUser
(
)
;
return
data
&
&
data
.
sessionToken
;
}
async
canGetKeys
(
)
{
let
currentState
=
this
.
currentAccountState
;
let
userData
=
await
currentState
.
getUserAccountData
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
Can
'
t
possibly
get
keys
;
User
is
not
signed
in
"
)
;
}
return
userData
&
&
(
userData
.
keyFetchToken
|
|
DERIVED_KEYS_NAMES
.
every
(
k
=
>
userData
[
k
]
)
|
|
userData
.
kB
)
;
}
async
getKeys
(
)
{
let
currentState
=
this
.
currentAccountState
;
try
{
let
userData
=
await
currentState
.
getUserAccountData
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
Can
'
t
get
keys
;
User
is
not
signed
in
"
)
;
}
if
(
userData
.
kB
)
{
log
.
info
(
"
Migrating
kB
to
derived
keys
.
"
)
;
const
{
uid
kB
}
=
userData
;
await
this
.
updateUserAccountData
(
{
uid
.
.
.
this
.
_deriveKeys
(
uid
CommonUtils
.
hexToBytes
(
kB
)
)
kA
:
null
kB
:
null
}
)
;
userData
=
await
this
.
getUserAccountData
(
)
;
}
if
(
DERIVED_KEYS_NAMES
.
every
(
k
=
>
userData
[
k
]
)
)
{
return
currentState
.
resolve
(
userData
)
;
}
if
(
!
currentState
.
whenKeysReadyDeferred
)
{
currentState
.
whenKeysReadyDeferred
=
PromiseUtils
.
defer
(
)
;
if
(
userData
.
keyFetchToken
)
{
this
.
fetchAndUnwrapKeys
(
userData
.
keyFetchToken
)
.
then
(
(
dataWithKeys
)
=
>
{
if
(
DERIVED_KEYS_NAMES
.
some
(
k
=
>
!
dataWithKeys
[
k
]
)
)
{
const
missing
=
DERIVED_KEYS_NAMES
.
filter
(
k
=
>
!
dataWithKeys
[
k
]
)
;
currentState
.
whenKeysReadyDeferred
.
reject
(
new
Error
(
user
data
missing
:
{
missing
.
join
(
"
"
)
}
)
)
;
return
;
}
currentState
.
whenKeysReadyDeferred
.
resolve
(
dataWithKeys
)
;
}
(
err
)
=
>
{
currentState
.
whenKeysReadyDeferred
.
reject
(
err
)
;
}
)
;
}
else
{
currentState
.
whenKeysReadyDeferred
.
reject
(
"
No
keyFetchToken
"
)
;
}
}
return
await
currentState
.
resolve
(
currentState
.
whenKeysReadyDeferred
.
promise
)
;
}
catch
(
err
)
{
return
currentState
.
resolve
(
this
.
_handleTokenError
(
err
)
)
;
}
}
async
fetchAndUnwrapKeys
(
keyFetchToken
)
{
if
(
logPII
)
{
log
.
debug
(
"
fetchAndUnwrapKeys
:
token
:
"
+
keyFetchToken
)
;
}
let
currentState
=
this
.
currentAccountState
;
if
(
!
keyFetchToken
)
{
log
.
warn
(
"
improper
fetchAndUnwrapKeys
(
)
call
:
token
missing
"
)
;
await
this
.
signOut
(
)
;
return
currentState
.
resolve
(
null
)
;
}
let
{
wrapKB
}
=
await
this
.
fetchKeys
(
keyFetchToken
)
;
let
data
=
await
currentState
.
getUserAccountData
(
)
;
if
(
data
.
keyFetchToken
!
=
=
keyFetchToken
)
{
throw
new
Error
(
"
Signed
in
user
changed
while
fetching
keys
!
"
)
;
}
let
kBbytes
=
CryptoUtils
.
xor
(
CommonUtils
.
hexToBytes
(
data
.
unwrapBKey
)
wrapKB
)
;
if
(
logPII
)
{
log
.
debug
(
"
kBbytes
:
"
+
kBbytes
)
;
}
let
updateData
=
{
.
.
.
this
.
_deriveKeys
(
data
.
uid
kBbytes
)
keyFetchToken
:
null
unwrapBKey
:
null
}
;
log
.
debug
(
"
Keys
Obtained
:
"
+
DERIVED_KEYS_NAMES
.
map
(
k
=
>
{
k
}
=
{
!
!
updateData
[
k
]
}
)
.
join
(
"
"
)
)
;
if
(
logPII
)
{
log
.
debug
(
"
Keys
Obtained
:
"
+
DERIVED_KEYS_NAMES
.
map
(
k
=
>
{
k
}
=
{
updateData
[
k
]
}
)
.
join
(
"
"
)
)
;
}
await
currentState
.
updateUserAccountData
(
updateData
)
;
await
this
.
notifyObservers
(
ONVERIFIED_NOTIFICATION
)
;
await
this
.
updateDeviceRegistration
(
)
;
data
=
await
currentState
.
getUserAccountData
(
)
;
return
currentState
.
resolve
(
data
)
;
}
_deriveKeys
(
uid
kBbytes
)
{
return
{
kSync
:
CommonUtils
.
bytesAsHex
(
this
.
_deriveSyncKey
(
kBbytes
)
)
kXCS
:
CommonUtils
.
bytesAsHex
(
this
.
_deriveXClientState
(
kBbytes
)
)
kExtSync
:
CommonUtils
.
bytesAsHex
(
this
.
_deriveWebExtSyncStoreKey
(
kBbytes
)
)
kExtKbHash
:
CommonUtils
.
bytesAsHex
(
this
.
_deriveWebExtKbHash
(
uid
kBbytes
)
)
}
;
}
_deriveSyncKey
(
kBbytes
)
{
return
CryptoUtils
.
hkdf
(
kBbytes
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
oldsync
"
2
*
32
)
;
}
_deriveWebExtSyncStoreKey
(
kBbytes
)
{
return
CryptoUtils
.
hkdf
(
kBbytes
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
chrome
.
storage
.
sync
"
2
*
32
)
;
}
_deriveWebExtKbHash
(
uid
kBbytes
)
{
return
this
.
_sha256
(
uid
+
kBbytes
)
;
}
_deriveXClientState
(
kBbytes
)
{
return
this
.
_sha256
(
kBbytes
)
.
slice
(
0
16
)
;
}
_sha256
(
bytes
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
return
CryptoUtils
.
digestBytes
(
bytes
hasher
)
;
}
async
getAssertionFromCert
(
data
keyPair
cert
audience
)
{
log
.
debug
(
"
getAssertionFromCert
"
)
;
let
options
=
{
duration
:
ASSERTION_LIFETIME
localtimeOffsetMsec
:
this
.
localtimeOffsetMsec
now
:
this
.
now
(
)
}
;
let
currentState
=
this
.
currentAccountState
;
let
assertion
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
jwcrypto
.
generateAssertion
(
cert
keyPair
audience
options
(
err
signed
)
=
>
{
if
(
err
)
{
log
.
error
(
"
getAssertionFromCert
:
"
+
err
)
;
reject
(
err
)
;
}
else
{
log
.
debug
(
"
getAssertionFromCert
returning
signed
:
"
+
!
!
signed
)
;
if
(
logPII
)
{
log
.
debug
(
"
getAssertionFromCert
returning
signed
:
"
+
signed
)
;
}
resolve
(
signed
)
;
}
}
)
;
}
)
;
return
currentState
.
resolve
(
assertion
)
;
}
getCertificateSigned
(
sessionToken
serializedPublicKey
lifetime
)
{
log
.
debug
(
"
getCertificateSigned
:
"
+
!
!
sessionToken
+
"
"
+
!
!
serializedPublicKey
)
;
if
(
logPII
)
{
log
.
debug
(
"
getCertificateSigned
:
"
+
sessionToken
+
"
"
+
serializedPublicKey
)
;
}
return
this
.
fxAccountsClient
.
signCertificate
(
sessionToken
JSON
.
parse
(
serializedPublicKey
)
lifetime
)
;
}
async
getKeypairAndCertificate
(
currentState
)
{
let
ignoreCachedAuthCredentials
=
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
debug
.
ignoreCachedAuthCredentials
"
false
)
;
let
mustBeValidUntil
=
this
.
now
(
)
+
ASSERTION_USE_PERIOD
;
let
accountData
=
await
currentState
.
getUserAccountData
(
[
"
cert
"
"
keyPair
"
"
sessionToken
"
]
)
;
let
keyPairValid
=
!
ignoreCachedAuthCredentials
&
&
accountData
.
keyPair
&
&
(
accountData
.
keyPair
.
validUntil
>
mustBeValidUntil
)
;
let
certValid
=
!
ignoreCachedAuthCredentials
&
&
accountData
.
cert
&
&
(
accountData
.
cert
.
validUntil
>
mustBeValidUntil
)
;
if
(
keyPairValid
&
&
certValid
)
{
log
.
debug
(
"
getKeypairAndCertificate
:
already
have
keyPair
and
certificate
"
)
;
return
{
keyPair
:
accountData
.
keyPair
.
rawKeyPair
certificate
:
accountData
.
cert
.
rawCert
}
;
}
if
(
Services
.
io
.
offline
)
{
throw
new
Error
(
ERROR_OFFLINE
)
;
}
let
keyPair
;
if
(
keyPairValid
)
{
keyPair
=
accountData
.
keyPair
;
}
else
{
let
keyWillBeValidUntil
=
this
.
now
(
)
+
KEY_LIFETIME
;
keyPair
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
jwcrypto
.
generateKeyPair
(
"
DS160
"
(
err
kp
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
log
.
debug
(
"
got
keyPair
"
)
;
resolve
(
{
rawKeyPair
:
kp
validUntil
:
keyWillBeValidUntil
}
)
;
}
)
;
}
)
;
}
let
certWillBeValidUntil
=
this
.
now
(
)
+
CERT_LIFETIME
;
let
certificate
=
await
this
.
getCertificateSigned
(
accountData
.
sessionToken
keyPair
.
rawKeyPair
.
serializedPublicKey
CERT_LIFETIME
)
;
log
.
debug
(
"
getCertificate
got
a
new
one
:
"
+
!
!
certificate
)
;
if
(
certificate
)
{
let
toUpdate
=
{
keyPair
cert
:
{
rawCert
:
certificate
validUntil
:
certWillBeValidUntil
}
}
;
await
currentState
.
updateUserAccountData
(
toUpdate
)
;
}
return
{
keyPair
:
keyPair
.
rawKeyPair
certificate
}
;
}
getUserAccountData
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
;
}
isUserEmailVerified
:
function
isUserEmailVerified
(
data
)
{
return
!
!
(
data
&
&
data
.
verified
)
;
}
loadAndPoll
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
data
)
{
Services
.
telemetry
.
getHistogramById
(
"
FXA_CONFIGURED
"
)
.
add
(
1
)
;
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
this
.
startPollEmailStatus
(
currentState
data
.
sessionToken
"
browser
-
startup
"
)
;
}
}
return
data
;
}
)
;
}
startVerifiedCheck
(
data
)
{
log
.
debug
(
"
startVerifiedCheck
"
data
&
&
data
.
verified
)
;
if
(
logPII
)
{
log
.
debug
(
"
startVerifiedCheck
with
user
data
"
data
)
;
}
this
.
whenVerified
(
data
)
.
then
(
(
)
=
>
this
.
getKeys
(
)
err
=
>
log
.
info
(
"
startVerifiedCheck
promise
was
rejected
:
"
+
err
)
)
;
}
whenVerified
(
data
)
{
let
currentState
=
this
.
currentAccountState
;
if
(
data
.
verified
)
{
log
.
debug
(
"
already
verified
"
)
;
return
currentState
.
resolve
(
data
)
;
}
if
(
!
currentState
.
whenVerifiedDeferred
)
{
log
.
debug
(
"
whenVerified
promise
starts
polling
for
verified
email
"
)
;
this
.
startPollEmailStatus
(
currentState
data
.
sessionToken
"
start
"
)
;
}
return
currentState
.
whenVerifiedDeferred
.
promise
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
async
notifyObservers
(
topic
data
)
{
for
(
let
f
of
this
.
observerPreloads
)
{
try
{
await
f
(
)
;
}
catch
(
O_o
)
{
}
}
log
.
debug
(
"
Notifying
observers
of
"
+
topic
)
;
Services
.
obs
.
notifyObservers
(
null
topic
data
)
;
}
startPollEmailStatus
(
currentState
sessionToken
why
)
{
log
.
debug
(
"
entering
startPollEmailStatus
:
"
+
why
)
;
if
(
this
.
currentTimer
)
{
log
.
debug
(
"
startPollEmailStatus
starting
while
existing
timer
is
running
"
)
;
clearTimeout
(
this
.
currentTimer
)
;
this
.
currentTimer
=
null
;
}
this
.
pollStartDate
=
Date
.
now
(
)
;
if
(
!
currentState
.
whenVerifiedDeferred
)
{
currentState
.
whenVerifiedDeferred
=
PromiseUtils
.
defer
(
)
;
currentState
.
whenVerifiedDeferred
.
promise
.
catch
(
err
=
>
{
log
.
info
(
"
the
wait
for
user
verification
was
stopped
:
"
+
err
)
;
}
)
;
}
return
this
.
pollEmailStatus
(
currentState
sessionToken
why
)
;
}
async
pollEmailStatus
(
currentState
sessionToken
why
)
{
log
.
debug
(
"
entering
pollEmailStatus
:
"
+
why
)
;
let
nextPollMs
;
try
{
const
response
=
await
this
.
checkEmailStatus
(
sessionToken
{
reason
:
why
}
)
;
log
.
debug
(
"
checkEmailStatus
-
>
"
+
JSON
.
stringify
(
response
)
)
;
if
(
response
&
&
response
.
verified
)
{
await
this
.
onPollEmailSuccess
(
currentState
)
;
return
;
}
}
catch
(
error
)
{
if
(
error
&
&
error
.
code
&
&
error
.
code
=
=
401
)
{
let
error
=
new
Error
(
"
Verification
status
check
failed
"
)
;
this
.
_rejectWhenVerified
(
currentState
error
)
;
return
;
}
if
(
error
&
&
error
.
retryAfter
)
{
nextPollMs
=
(
error
.
retryAfter
+
3
)
*
1000
;
log
.
warn
(
the
server
rejected
our
email
status
check
and
told
us
to
try
again
in
{
nextPollMs
}
ms
)
;
}
else
{
log
.
error
(
checkEmailStatus
failed
to
poll
error
)
;
}
}
if
(
why
=
=
"
push
"
)
{
return
;
}
let
pollDuration
=
Date
.
now
(
)
-
this
.
pollStartDate
;
if
(
pollDuration
>
=
this
.
POLL_SESSION
)
{
if
(
currentState
.
whenVerifiedDeferred
)
{
let
error
=
new
Error
(
"
User
email
verification
timed
out
.
"
)
;
this
.
_rejectWhenVerified
(
currentState
error
)
;
}
log
.
debug
(
"
polling
session
exceeded
giving
up
"
)
;
return
;
}
if
(
nextPollMs
=
=
=
undefined
)
{
let
currentMinute
=
Math
.
ceil
(
pollDuration
/
60000
)
;
nextPollMs
=
(
why
=
=
"
start
"
&
&
currentMinute
<
this
.
VERIFICATION_POLL_START_SLOWDOWN_THRESHOLD
)
?
this
.
VERIFICATION_POLL_TIMEOUT_INITIAL
:
this
.
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
;
}
this
.
_scheduleNextPollEmailStatus
(
currentState
sessionToken
nextPollMs
why
)
;
}
_scheduleNextPollEmailStatus
(
currentState
sessionToken
nextPollMs
why
)
{
log
.
debug
(
"
polling
with
timeout
=
"
+
nextPollMs
)
;
this
.
currentTimer
=
setTimeout
(
(
)
=
>
{
this
.
pollEmailStatus
(
currentState
sessionToken
why
)
;
}
nextPollMs
)
;
}
async
onPollEmailSuccess
(
currentState
)
{
try
{
await
currentState
.
updateUserAccountData
(
{
verified
:
true
}
)
;
const
accountData
=
await
currentState
.
getUserAccountData
(
)
;
if
(
currentState
.
whenVerifiedDeferred
)
{
currentState
.
whenVerifiedDeferred
.
resolve
(
accountData
)
;
delete
currentState
.
whenVerifiedDeferred
;
}
}
catch
(
e
)
{
log
.
error
(
e
)
;
}
}
_rejectWhenVerified
(
currentState
error
)
{
currentState
.
whenVerifiedDeferred
.
reject
(
error
)
;
delete
currentState
.
whenVerifiedDeferred
;
}
async
getOAuthToken
(
options
=
{
}
)
{
log
.
debug
(
"
getOAuthToken
enter
"
)
;
let
scope
=
options
.
scope
;
if
(
typeof
scope
=
=
=
"
string
"
)
{
scope
=
[
scope
]
;
}
if
(
!
scope
|
|
!
scope
.
length
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
"
Missing
or
invalid
'
scope
'
option
"
)
;
}
await
this
.
_getVerifiedAccountOrReject
(
)
;
let
currentState
=
this
.
currentAccountState
;
let
cached
=
currentState
.
getCachedToken
(
scope
)
;
if
(
cached
)
{
log
.
debug
(
"
getOAuthToken
returning
a
cached
token
"
)
;
return
cached
.
token
;
}
let
scopeString
=
scope
.
join
(
"
"
)
;
let
client
=
options
.
client
;
if
(
!
client
)
{
try
{
let
defaultURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
)
;
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
defaultURL
client_id
:
FX_OAUTH_CLIENT_ID
}
)
;
}
catch
(
e
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
e
)
;
}
}
let
oAuthURL
=
client
.
serverURL
.
href
;
try
{
log
.
debug
(
"
getOAuthToken
fetching
new
token
from
"
oAuthURL
)
;
let
assertion
=
await
this
.
getAssertion
(
oAuthURL
)
;
let
result
=
await
client
.
getTokenFromAssertion
(
assertion
scopeString
)
;
let
token
=
result
.
access_token
;
if
(
token
)
{
let
entry
=
{
token
server
:
oAuthURL
}
;
let
cached
=
currentState
.
getCachedToken
(
scope
)
;
if
(
cached
)
{
log
.
debug
(
"
Detected
a
race
for
this
token
-
revoking
the
new
one
.
"
)
;
this
.
_destroyOAuthToken
(
entry
)
;
return
cached
.
token
;
}
currentState
.
setCachedToken
(
scope
entry
)
;
}
return
token
;
}
catch
(
err
)
{
throw
this
.
_errorToErrorClass
(
err
)
;
}
}
async
removeCachedOAuthToken
(
options
)
{
if
(
!
options
.
token
|
|
typeof
options
.
token
!
=
=
"
string
"
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
"
Missing
or
invalid
'
token
'
option
"
)
;
}
let
currentState
=
this
.
currentAccountState
;
let
existing
=
currentState
.
removeCachedToken
(
options
.
token
)
;
if
(
existing
)
{
this
.
_destroyOAuthToken
(
existing
)
.
catch
(
err
=
>
{
log
.
warn
(
"
FxA
failed
to
revoke
a
cached
token
"
err
)
;
}
)
;
}
}
async
_getVerifiedAccountOrReject
(
)
{
let
data
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
if
(
!
data
)
{
throw
this
.
_error
(
ERROR_NO_ACCOUNT
)
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
throw
this
.
_error
(
ERROR_UNVERIFIED_ACCOUNT
)
;
}
return
data
;
}
_errorToErrorClass
(
aError
)
{
if
(
aError
.
errno
)
{
let
error
=
SERVER_ERRNO_TO_ERROR
[
aError
.
errno
]
;
return
this
.
_error
(
ERROR_TO_GENERAL_ERROR_CLASS
[
error
]
|
|
ERROR_UNKNOWN
aError
)
;
}
else
if
(
aError
.
message
&
&
(
aError
.
message
=
=
=
"
INVALID_PARAMETER
"
|
|
aError
.
message
=
=
=
"
NO_ACCOUNT
"
|
|
aError
.
message
=
=
=
"
UNVERIFIED_ACCOUNT
"
|
|
aError
.
message
=
=
=
"
AUTH_ERROR
"
)
)
{
return
aError
;
}
return
this
.
_error
(
ERROR_UNKNOWN
aError
)
;
}
_error
(
aError
aDetails
)
{
log
.
error
(
"
FxA
rejecting
with
error
{
aError
}
details
:
{
aDetails
}
"
{
aError
aDetails
}
)
;
let
reason
=
new
Error
(
aError
)
;
if
(
aDetails
)
{
reason
.
details
=
aDetails
;
}
return
reason
;
}
getSignedInUserProfile
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
this
.
profile
.
getProfile
(
)
.
then
(
profileData
=
>
{
let
profile
=
Cu
.
cloneInto
(
profileData
{
}
)
;
return
currentState
.
resolve
(
profile
)
;
}
error
=
>
{
log
.
error
(
"
Could
not
retrieve
profile
data
"
error
)
;
return
currentState
.
reject
(
error
)
;
}
)
.
catch
(
err
=
>
Promise
.
reject
(
this
.
_errorToErrorClass
(
err
)
)
)
;
}
async
updateDeviceRegistration
(
)
{
try
{
const
signedInUser
=
await
this
.
getSignedInUser
(
)
;
if
(
signedInUser
)
{
await
this
.
_registerOrUpdateDevice
(
signedInUser
)
;
}
}
catch
(
error
)
{
await
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
;
}
}
async
handleDeviceDisconnection
(
deviceId
)
{
const
accountData
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
if
(
!
accountData
|
|
!
accountData
.
device
)
{
return
;
}
const
localDeviceId
=
accountData
.
device
.
id
;
const
isLocalDevice
=
(
deviceId
=
=
localDeviceId
)
;
if
(
isLocalDevice
)
{
this
.
signOut
(
true
)
;
}
const
data
=
JSON
.
stringify
(
{
isLocalDevice
}
)
;
await
this
.
notifyObservers
(
ON_DEVICE_DISCONNECTED_NOTIFICATION
data
)
;
}
handleEmailUpdated
(
newEmail
)
{
Services
.
prefs
.
setStringPref
(
PREF_LAST_FXA_USER
CryptoUtils
.
sha256Base64
(
newEmail
)
)
;
return
this
.
currentAccountState
.
updateUserAccountData
(
{
email
:
newEmail
}
)
;
}
async
handleAccountDestroyed
(
uid
)
{
const
accountData
=
await
this
.
currentAccountState
.
getUserAccountData
(
)
;
const
localUid
=
accountData
?
accountData
.
uid
:
null
;
if
(
!
localUid
)
{
log
.
info
(
Account
destroyed
push
notification
received
but
we
'
re
already
logged
-
out
)
;
return
null
;
}
if
(
uid
=
=
localUid
)
{
const
data
=
JSON
.
stringify
(
{
isLocalDevice
:
true
}
)
;
await
this
.
notifyObservers
(
ON_DEVICE_DISCONNECTED_NOTIFICATION
data
)
;
return
this
.
signOut
(
true
)
;
}
log
.
info
(
The
destroyed
account
uid
doesn
'
t
match
with
the
local
uid
.
+
Local
:
{
localUid
}
account
uid
destroyed
:
{
uid
}
)
;
return
null
;
}
resetCredentials
(
)
{
let
updateData
=
{
}
;
let
clearField
=
field
=
>
{
if
(
!
FXA_PWDMGR_REAUTH_WHITELIST
.
has
(
field
)
)
{
updateData
[
field
]
=
null
;
}
}
;
FXA_PWDMGR_PLAINTEXT_FIELDS
.
forEach
(
clearField
)
;
FXA_PWDMGR_SECURE_FIELDS
.
forEach
(
clearField
)
;
FXA_PWDMGR_MEMORY_FIELDS
.
forEach
(
clearField
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
updateUserAccountData
(
updateData
)
;
}
getProfileCache
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
[
"
profileCache
"
]
)
.
then
(
data
=
>
data
?
data
.
profileCache
:
null
)
;
}
setProfileCache
(
profileCache
)
{
return
this
.
currentAccountState
.
updateUserAccountData
(
{
profileCache
}
)
;
}
getPushSubscription
(
)
{
return
this
.
fxaPushService
.
getSubscription
(
)
;
}
async
availableCommands
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
commands
.
enabled
"
true
)
)
{
return
{
}
;
}
const
sendTabKey
=
await
this
.
commands
.
sendTab
.
getEncryptedKey
(
)
;
if
(
!
sendTabKey
)
{
return
{
}
;
}
return
{
[
COMMAND_SENDTAB
]
:
sendTabKey
}
;
}
async
_registerOrUpdateDevice
(
signedInUser
)
{
const
{
sessionToken
device
:
currentDevice
}
=
signedInUser
;
if
(
!
sessionToken
)
{
throw
new
Error
(
"
_registerOrUpdateDevice
called
without
a
session
token
"
)
;
}
try
{
const
subscription
=
await
this
.
fxaPushService
.
registerPushEndpoint
(
)
;
const
deviceName
=
this
.
_getDeviceName
(
)
;
let
deviceOptions
=
{
}
;
if
(
subscription
&
&
subscription
.
endpoint
)
{
deviceOptions
.
pushCallback
=
subscription
.
endpoint
;
let
publicKey
=
subscription
.
getKey
(
"
p256dh
"
)
;
let
authKey
=
subscription
.
getKey
(
"
auth
"
)
;
if
(
publicKey
&
&
authKey
)
{
deviceOptions
.
pushPublicKey
=
urlsafeBase64Encode
(
publicKey
)
;
deviceOptions
.
pushAuthKey
=
urlsafeBase64Encode
(
authKey
)
;
}
}
deviceOptions
.
availableCommands
=
await
this
.
availableCommands
(
)
;
const
availableCommandsKeys
=
Object
.
keys
(
deviceOptions
.
availableCommands
)
.
sort
(
)
;
let
device
;
if
(
currentDevice
&
&
currentDevice
.
id
)
{
log
.
debug
(
"
updating
existing
device
details
"
)
;
device
=
await
this
.
fxAccountsClient
.
updateDevice
(
sessionToken
currentDevice
.
id
deviceName
deviceOptions
)
;
}
else
{
log
.
debug
(
"
registering
new
device
details
"
)
;
device
=
await
this
.
fxAccountsClient
.
registerDevice
(
sessionToken
deviceName
this
.
_getDeviceType
(
)
deviceOptions
)
;
Services
.
obs
.
notifyObservers
(
null
ON_NEW_DEVICE_ID
)
;
}
let
{
device
:
deviceProps
}
=
await
this
.
getSignedInUser
(
)
;
await
this
.
currentAccountState
.
updateUserAccountData
(
{
device
:
{
.
.
.
deviceProps
id
:
device
.
id
registrationVersion
:
this
.
DEVICE_REGISTRATION_VERSION
registeredCommandsKeys
:
availableCommandsKeys
}
}
)
;
return
device
.
id
;
}
catch
(
error
)
{
return
this
.
_handleDeviceError
(
error
sessionToken
)
;
}
}
_getDeviceName
(
)
{
return
Utils
.
getDeviceName
(
)
;
}
_getDeviceType
(
)
{
return
Utils
.
getDeviceType
(
)
;
}
_handleDeviceError
(
error
sessionToken
)
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
error
.
code
=
=
=
400
)
{
if
(
error
.
errno
=
=
=
ERRNO_UNKNOWN_DEVICE
)
{
return
this
.
_recoverFromUnknownDevice
(
)
;
}
if
(
error
.
errno
=
=
=
ERRNO_DEVICE_SESSION_CONFLICT
)
{
return
this
.
_recoverFromDeviceSessionConflict
(
error
sessionToken
)
;
}
}
return
this
.
_handleTokenError
(
error
)
;
}
)
.
catch
(
error
=
>
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
)
.
catch
(
(
)
=
>
{
}
)
;
}
async
_recoverFromUnknownDevice
(
)
{
log
.
warn
(
"
unknown
device
id
clearing
the
local
device
data
"
)
;
try
{
await
this
.
currentAccountState
.
updateUserAccountData
(
{
device
:
null
}
)
;
}
catch
(
error
)
{
await
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
;
}
}
async
_recoverFromDeviceSessionConflict
(
error
sessionToken
)
{
log
.
warn
(
"
device
session
conflict
attempting
to
ascertain
the
correct
device
id
"
)
;
try
{
const
devices
=
await
this
.
fxAccountsClient
.
getDeviceList
(
sessionToken
)
;
const
matchingDevices
=
devices
.
filter
(
device
=
>
device
.
isCurrentDevice
)
;
const
length
=
matchingDevices
.
length
;
if
(
length
=
=
=
1
)
{
const
deviceId
=
matchingDevices
[
0
]
.
id
;
await
this
.
currentAccountState
.
updateUserAccountData
(
{
device
:
{
id
:
deviceId
registrationVersion
:
null
}
}
)
;
return
deviceId
;
}
if
(
length
>
1
)
{
log
.
error
(
"
insane
server
state
"
+
length
+
"
devices
for
this
session
"
)
;
}
await
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
;
}
catch
(
secondError
)
{
log
.
error
(
"
failed
to
recover
from
device
-
session
conflict
"
secondError
)
;
await
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
;
}
return
null
;
}
async
_logErrorAndResetDeviceRegistrationVersion
(
error
)
{
log
.
error
(
"
device
registration
failed
"
error
)
;
try
{
this
.
currentAccountState
.
updateUserAccountData
(
{
device
:
null
}
)
;
}
catch
(
secondError
)
{
log
.
error
(
"
failed
to
reset
the
device
registration
version
device
registration
won
'
t
be
retried
"
secondError
)
;
}
}
_handleTokenError
(
err
)
{
if
(
!
err
|
|
err
.
code
!
=
401
|
|
err
.
errno
!
=
ERRNO_INVALID_AUTH_TOKEN
)
{
throw
err
;
}
log
.
warn
(
"
recovering
from
invalid
token
error
"
err
)
;
return
this
.
accountStatus
(
)
.
then
(
exists
=
>
{
if
(
!
exists
)
{
log
.
info
(
"
token
invalidated
because
the
account
no
longer
exists
"
)
;
return
this
.
signOut
(
true
)
;
}
log
.
info
(
"
clearing
credentials
to
handle
invalid
token
error
"
)
;
return
this
.
resetCredentials
(
)
;
}
)
.
then
(
(
)
=
>
Promise
.
reject
(
err
)
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
fxAccounts
"
function
(
)
{
let
a
=
new
FxAccounts
(
)
;
a
.
loadAndPoll
(
)
;
return
a
;
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
fxAccounts
"
"
FxAccounts
"
]
;
