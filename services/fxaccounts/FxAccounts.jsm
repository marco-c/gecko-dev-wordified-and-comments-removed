"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
fxAccounts
"
"
FxAccounts
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
rest
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsStorage
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsClient
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsConfig
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsConfig
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
jwcrypto
"
"
resource
:
/
/
gre
/
modules
/
identity
/
jwcrypto
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsOAuthGrantClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsOAuthGrantClient
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsProfile
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsProfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Utils
"
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
var
publicProperties
=
[
"
accountStatus
"
"
checkVerificationStatus
"
"
getAccountsClient
"
"
getAssertion
"
"
getDeviceId
"
"
getKeys
"
"
getOAuthToken
"
"
getSignedInUser
"
"
getSignedInUserProfile
"
"
handleDeviceDisconnection
"
"
invalidateCertificate
"
"
loadAndPoll
"
"
localtimeOffsetMsec
"
"
notifyDevices
"
"
now
"
"
promiseAccountsChangeProfileURI
"
"
promiseAccountsForceSigninURI
"
"
promiseAccountsManageURI
"
"
promiseAccountsSignUpURI
"
"
promiseAccountsSignInURI
"
"
removeCachedOAuthToken
"
"
requiresHttps
"
"
resendVerificationEmail
"
"
resetCredentials
"
"
sessionStatus
"
"
setSignedInUser
"
"
signOut
"
"
updateDeviceRegistration
"
"
updateUserAccountData
"
"
whenVerified
"
]
;
var
AccountState
=
this
.
AccountState
=
function
(
storageManager
)
{
this
.
storageManager
=
storageManager
;
this
.
promiseInitialized
=
this
.
storageManager
.
getAccountData
(
)
.
then
(
data
=
>
{
this
.
oauthTokens
=
data
&
&
data
.
oauthTokens
?
data
.
oauthTokens
:
{
}
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Failed
to
initialize
the
storage
manager
"
err
)
;
}
)
;
}
;
AccountState
.
prototype
=
{
oauthTokens
:
null
whenVerifiedDeferred
:
null
whenKeysReadyDeferred
:
null
get
isCurrent
(
)
{
return
this
.
storageManager
!
=
null
;
}
abort
(
)
{
if
(
this
.
whenVerifiedDeferred
)
{
this
.
whenVerifiedDeferred
.
reject
(
new
Error
(
"
Verification
aborted
;
Another
user
signing
in
"
)
)
;
this
.
whenVerifiedDeferred
=
null
;
}
if
(
this
.
whenKeysReadyDeferred
)
{
this
.
whenKeysReadyDeferred
.
reject
(
new
Error
(
"
Verification
aborted
;
Another
user
signing
in
"
)
)
;
this
.
whenKeysReadyDeferred
=
null
;
}
this
.
cert
=
null
;
this
.
keyPair
=
null
;
this
.
oauthTokens
=
null
;
if
(
!
this
.
storageManager
)
{
return
Promise
.
resolve
(
)
;
}
let
storageManager
=
this
.
storageManager
;
this
.
storageManager
=
null
;
return
storageManager
.
finalize
(
)
;
}
signOut
(
)
{
this
.
cert
=
null
;
this
.
keyPair
=
null
;
this
.
oauthTokens
=
null
;
let
storageManager
=
this
.
storageManager
;
this
.
storageManager
=
null
;
return
storageManager
.
deleteAccountData
(
)
.
then
(
(
)
=
>
{
return
storageManager
.
finalize
(
)
;
}
)
;
}
getUserAccountData
(
fieldNames
=
null
)
{
if
(
!
this
.
isCurrent
)
{
return
Promise
.
reject
(
new
Error
(
"
Another
user
has
signed
in
"
)
)
;
}
return
this
.
storageManager
.
getAccountData
(
fieldNames
)
.
then
(
result
=
>
{
return
this
.
resolve
(
result
)
;
}
)
;
}
updateUserAccountData
(
updatedFields
)
{
if
(
!
this
.
isCurrent
)
{
return
Promise
.
reject
(
new
Error
(
"
Another
user
has
signed
in
"
)
)
;
}
return
this
.
storageManager
.
updateAccountData
(
updatedFields
)
;
}
resolve
:
function
(
result
)
{
if
(
!
this
.
isCurrent
)
{
log
.
info
(
"
An
accountState
promise
was
resolved
but
was
actually
rejected
"
+
"
due
to
a
different
user
being
signed
in
.
Originally
resolved
"
+
"
with
"
result
)
;
return
Promise
.
reject
(
new
Error
(
"
A
different
user
signed
in
"
)
)
;
}
return
Promise
.
resolve
(
result
)
;
}
reject
:
function
(
error
)
{
if
(
!
this
.
isCurrent
)
{
log
.
info
(
"
An
accountState
promise
was
rejected
but
we
are
ignoring
that
"
+
"
reason
and
rejecting
it
due
to
a
different
user
being
signed
in
.
"
+
"
Originally
rejected
with
"
error
)
;
return
Promise
.
reject
(
new
Error
(
"
A
different
user
signed
in
"
)
)
;
}
return
Promise
.
reject
(
error
)
;
}
_cachePreamble
(
)
{
if
(
!
this
.
isCurrent
)
{
throw
new
Error
(
"
Another
user
has
signed
in
"
)
;
}
}
setCachedToken
(
scopeArray
tokenData
)
{
this
.
_cachePreamble
(
)
;
if
(
!
tokenData
.
token
)
{
throw
new
Error
(
"
No
token
"
)
;
}
let
key
=
getScopeKey
(
scopeArray
)
;
this
.
oauthTokens
[
key
]
=
tokenData
;
this
.
_persistCachedTokens
(
)
;
}
getCachedToken
(
scopeArray
)
{
this
.
_cachePreamble
(
)
;
let
key
=
getScopeKey
(
scopeArray
)
;
let
result
=
this
.
oauthTokens
[
key
]
;
if
(
result
)
{
log
.
trace
(
"
getCachedToken
returning
cached
token
"
)
;
return
result
;
}
return
null
;
}
removeCachedToken
(
token
)
{
this
.
_cachePreamble
(
)
;
let
data
=
this
.
oauthTokens
;
for
(
let
[
key
tokenValue
]
of
Object
.
entries
(
data
)
)
{
if
(
tokenValue
.
token
=
=
token
)
{
delete
data
[
key
]
;
this
.
_persistCachedTokens
(
)
;
return
tokenValue
;
}
}
return
null
;
}
_persistCachedTokens
(
)
{
this
.
_cachePreamble
(
)
;
return
this
.
updateUserAccountData
(
{
oauthTokens
:
this
.
oauthTokens
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Failed
to
update
cached
tokens
"
err
)
;
}
)
;
}
}
function
getScopeKey
(
scopeArray
)
{
let
normalizedScopes
=
scopeArray
.
map
(
item
=
>
item
.
toLowerCase
(
)
)
;
return
normalizedScopes
.
sort
(
)
.
join
(
"
|
"
)
;
}
function
copyObjectProperties
(
from
to
opts
=
{
}
)
{
let
keys
=
(
opts
&
&
opts
.
keys
)
|
|
Object
.
keys
(
from
)
;
let
thisArg
=
(
opts
&
&
opts
.
bind
)
|
|
to
;
for
(
let
prop
of
keys
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
from
prop
)
;
if
(
typeof
(
desc
.
value
)
=
=
"
function
"
)
{
desc
.
value
=
desc
.
value
.
bind
(
thisArg
)
;
}
if
(
desc
.
get
)
{
desc
.
get
=
desc
.
get
.
bind
(
thisArg
)
;
}
if
(
desc
.
set
)
{
desc
.
set
=
desc
.
set
.
bind
(
thisArg
)
;
}
Object
.
defineProperty
(
to
prop
desc
)
;
}
}
function
urlsafeBase64Encode
(
key
)
{
return
ChromeUtils
.
base64URLEncode
(
new
Uint8Array
(
key
)
{
pad
:
false
}
)
;
}
this
.
FxAccounts
=
function
(
mockInternal
)
{
let
internal
=
new
FxAccountsInternal
(
)
;
let
external
=
{
}
;
let
prototype
=
FxAccountsInternal
.
prototype
;
let
options
=
{
keys
:
publicProperties
bind
:
internal
}
;
copyObjectProperties
(
prototype
external
options
)
;
if
(
mockInternal
&
&
!
mockInternal
.
onlySetInternal
)
{
copyObjectProperties
(
mockInternal
internal
)
;
}
if
(
mockInternal
)
{
external
.
internal
=
internal
;
}
if
(
!
internal
.
fxaPushService
)
{
XPCOMUtils
.
defineLazyGetter
(
internal
"
fxaPushService
"
function
(
)
{
return
Components
.
classes
[
"
mozilla
.
org
/
fxaccounts
/
push
;
1
"
]
.
getService
(
Components
.
interfaces
.
nsISupports
)
.
wrappedJSObject
;
}
)
;
}
internal
.
initialize
(
)
;
return
Object
.
freeze
(
external
)
;
}
function
FxAccountsInternal
(
)
{
this
.
POLL_SESSION
=
POLL_SESSION
;
}
FxAccountsInternal
.
prototype
=
{
VERIFICATION_POLL_TIMEOUT_INITIAL
:
15000
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
:
30000
DEVICE_REGISTRATION_VERSION
:
2
_fxAccountsClient
:
null
initialize
(
)
{
this
.
currentTimer
=
null
;
this
.
currentAccountState
=
this
.
newAccountState
(
)
;
}
get
fxAccountsClient
(
)
{
if
(
!
this
.
_fxAccountsClient
)
{
this
.
_fxAccountsClient
=
new
FxAccountsClient
(
)
;
}
return
this
.
_fxAccountsClient
;
}
_profile
:
null
get
profile
(
)
{
if
(
!
this
.
_profile
)
{
let
profileServerUrl
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
profile
.
uri
"
)
;
this
.
_profile
=
new
FxAccountsProfile
(
{
fxa
:
this
profileServerUrl
:
profileServerUrl
}
)
;
}
return
this
.
_profile
;
}
newAccountState
(
credentials
)
{
let
storage
=
new
FxAccountsStorageManager
(
)
;
storage
.
initialize
(
credentials
)
;
return
new
AccountState
(
storage
)
;
}
notifyDevices
:
function
(
deviceIds
payload
TTL
)
{
if
(
!
Array
.
isArray
(
deviceIds
)
)
{
deviceIds
=
[
deviceIds
]
;
}
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
throw
this
.
_error
(
ERROR_NO_ACCOUNT
)
;
}
if
(
!
data
.
sessionToken
)
{
throw
this
.
_error
(
ERROR_AUTH_ERROR
"
notifyDevices
called
without
a
session
token
"
)
;
}
return
this
.
fxAccountsClient
.
notifyDevices
(
data
.
sessionToken
deviceIds
payload
TTL
)
;
}
)
;
}
now
:
function
(
)
{
return
this
.
fxAccountsClient
.
now
(
)
;
}
getAccountsClient
:
function
(
)
{
return
this
.
fxAccountsClient
;
}
get
localtimeOffsetMsec
(
)
{
return
this
.
fxAccountsClient
.
localtimeOffsetMsec
;
}
checkEmailStatus
:
function
checkEmailStatus
(
sessionToken
options
=
{
}
)
{
if
(
!
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
checkEmailStatus
called
without
a
session
token
"
)
)
;
}
return
this
.
fxAccountsClient
.
recoveryEmailStatus
(
sessionToken
options
)
.
catch
(
error
=
>
this
.
_handleTokenError
(
error
)
)
;
}
fetchKeys
:
function
fetchKeys
(
keyFetchToken
)
{
log
.
debug
(
"
fetchKeys
:
"
+
!
!
keyFetchToken
)
;
if
(
logPII
)
{
log
.
debug
(
"
fetchKeys
-
the
token
is
"
+
keyFetchToken
)
;
}
return
this
.
fxAccountsClient
.
accountKeys
(
keyFetchToken
)
;
}
getSignedInUser
:
function
getSignedInUser
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
return
null
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
this
.
startVerifiedCheck
(
data
)
;
}
return
data
;
}
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
setSignedInUser
:
function
setSignedInUser
(
credentials
)
{
log
.
debug
(
"
setSignedInUser
-
aborting
any
existing
flows
"
)
;
return
this
.
abortExistingFlow
(
)
.
then
(
(
)
=
>
{
let
currentAccountState
=
this
.
currentAccountState
=
this
.
newAccountState
(
Cu
.
cloneInto
(
credentials
{
}
)
)
;
return
currentAccountState
.
promiseInitialized
.
then
(
(
)
=
>
{
if
(
!
this
.
isUserEmailVerified
(
credentials
)
)
{
this
.
startVerifiedCheck
(
credentials
)
;
}
return
this
.
updateDeviceRegistration
(
)
;
}
)
.
then
(
(
)
=
>
{
Services
.
telemetry
.
getHistogramById
(
"
FXA_CONFIGURED
"
)
.
add
(
1
)
;
this
.
notifyObservers
(
ONLOGIN_NOTIFICATION
)
;
}
)
.
then
(
(
)
=
>
{
return
currentAccountState
.
resolve
(
)
;
}
)
;
}
)
}
updateUserAccountData
(
credentials
)
{
log
.
debug
(
"
updateUserAccountData
called
with
fields
"
Object
.
keys
(
credentials
)
)
;
if
(
logPII
)
{
log
.
debug
(
"
updateUserAccountData
called
with
data
"
credentials
)
;
}
let
currentAccountState
=
this
.
currentAccountState
;
return
currentAccountState
.
promiseInitialized
.
then
(
(
)
=
>
{
return
currentAccountState
.
getUserAccountData
(
[
"
email
"
"
uid
"
]
)
;
}
)
.
then
(
existing
=
>
{
if
(
existing
.
email
!
=
credentials
.
email
|
|
existing
.
uid
!
=
credentials
.
uid
)
{
throw
new
Error
(
"
The
specified
credentials
aren
'
t
for
the
current
user
"
)
;
}
credentials
=
Cu
.
cloneInto
(
credentials
{
}
)
;
delete
credentials
.
email
;
delete
credentials
.
uid
;
return
currentAccountState
.
updateUserAccountData
(
credentials
)
;
}
)
;
}
getAssertion
:
function
getAssertion
(
audience
)
{
return
this
.
_getAssertion
(
audience
)
;
}
_getAssertion
:
function
_getAssertion
(
audience
)
{
log
.
debug
(
"
enter
getAssertion
(
)
"
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
return
null
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
return
null
;
}
if
(
!
data
.
sessionToken
)
{
throw
this
.
_error
(
ERROR_AUTH_ERROR
"
getAssertion
called
without
a
session
token
"
)
;
}
return
this
.
getKeypairAndCertificate
(
currentState
)
.
then
(
(
{
keyPair
certificate
}
)
=
>
{
return
this
.
getAssertionFromCert
(
data
keyPair
certificate
audience
)
;
}
)
;
}
)
.
catch
(
err
=
>
this
.
_handleTokenError
(
err
)
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
invalidateCertificate
(
)
{
return
this
.
currentAccountState
.
updateUserAccountData
(
{
cert
:
null
}
)
;
}
getDeviceId
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
data
)
{
if
(
!
data
.
deviceId
|
|
!
data
.
deviceRegistrationVersion
|
|
data
.
deviceRegistrationVersion
<
this
.
DEVICE_REGISTRATION_VERSION
)
{
return
this
.
_registerOrUpdateDevice
(
data
)
;
}
return
data
.
deviceId
;
}
return
null
;
}
)
;
}
resendVerificationEmail
:
function
resendVerificationEmail
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
this
.
getSignedInUser
(
)
.
then
(
data
=
>
{
if
(
data
)
{
if
(
!
data
.
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
resendVerificationEmail
called
without
a
session
token
"
)
)
;
}
this
.
pollEmailStatus
(
currentState
data
.
sessionToken
"
start
"
)
;
return
this
.
fxAccountsClient
.
resendVerificationEmail
(
data
.
sessionToken
)
.
catch
(
err
=
>
this
.
_handleTokenError
(
err
)
)
;
}
throw
new
Error
(
"
Cannot
resend
verification
email
;
no
signed
-
in
user
"
)
;
}
)
;
}
abortExistingFlow
:
function
abortExistingFlow
(
)
{
if
(
this
.
currentTimer
)
{
log
.
debug
(
"
Polling
aborted
;
Another
user
signing
in
"
)
;
clearTimeout
(
this
.
currentTimer
)
;
this
.
currentTimer
=
0
;
}
if
(
this
.
_profile
)
{
this
.
_profile
.
tearDown
(
)
;
this
.
_profile
=
null
;
}
return
this
.
currentAccountState
.
abort
(
)
;
}
accountStatus
:
function
accountStatus
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
return
false
;
}
return
this
.
fxAccountsClient
.
accountStatus
(
data
.
uid
)
;
}
)
;
}
checkVerificationStatus
:
function
(
)
{
log
.
trace
(
'
checkVerificationStatus
'
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
!
data
)
{
log
.
trace
(
"
checkVerificationStatus
-
no
user
data
"
)
;
return
null
;
}
log
.
trace
(
"
checkVerificationStatus
-
forcing
verification
status
check
"
)
;
return
this
.
pollEmailStatus
(
currentState
data
.
sessionToken
"
push
"
)
;
}
)
;
}
_destroyOAuthToken
:
function
(
tokenData
)
{
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
tokenData
.
server
client_id
:
FX_OAUTH_CLIENT_ID
}
)
;
return
client
.
destroyToken
(
tokenData
.
token
)
}
_destroyAllOAuthTokens
:
function
(
tokenInfos
)
{
let
promises
=
[
]
;
for
(
let
[
key
tokenInfo
]
of
Object
.
entries
(
tokenInfos
|
|
{
}
)
)
{
promises
.
push
(
this
.
_destroyOAuthToken
(
tokenInfo
)
)
;
}
return
Promise
.
all
(
promises
)
;
}
signOut
:
function
signOut
(
localOnly
)
{
let
currentState
=
this
.
currentAccountState
;
let
sessionToken
;
let
tokensToRevoke
;
let
deviceId
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
data
)
{
sessionToken
=
data
.
sessionToken
;
tokensToRevoke
=
data
.
oauthTokens
;
deviceId
=
data
.
deviceId
;
}
return
this
.
_signOutLocal
(
)
;
}
)
.
then
(
(
)
=
>
{
if
(
!
localOnly
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
sessionToken
)
{
return
this
.
_signOutServer
(
sessionToken
deviceId
)
;
}
log
.
warn
(
"
Missing
session
token
;
skipping
remote
sign
out
"
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Error
during
remote
sign
out
of
Firefox
Accounts
"
err
)
;
}
)
.
then
(
(
)
=
>
{
return
this
.
_destroyAllOAuthTokens
(
tokensToRevoke
)
;
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
Error
during
destruction
of
oauth
tokens
during
signout
"
err
)
;
}
)
.
then
(
(
)
=
>
{
FxAccountsConfig
.
resetConfigURLs
(
)
;
this
.
notifyObservers
(
"
testhelper
-
fxa
-
signout
-
complete
"
)
;
}
)
}
else
{
FxAccountsConfig
.
resetConfigURLs
(
)
;
}
}
)
.
then
(
(
)
=
>
{
this
.
notifyObservers
(
ONLOGOUT_NOTIFICATION
)
;
}
)
;
}
_signOutLocal
:
function
signOutLocal
(
)
{
let
currentAccountState
=
this
.
currentAccountState
;
return
currentAccountState
.
signOut
(
)
.
then
(
(
)
=
>
{
return
this
.
abortExistingFlow
(
)
;
}
)
.
then
(
(
)
=
>
{
this
.
currentAccountState
=
this
.
newAccountState
(
)
;
return
this
.
currentAccountState
.
promiseInitialized
;
}
)
;
}
_signOutServer
(
sessionToken
deviceId
)
{
const
options
=
{
service
:
"
sync
"
}
;
if
(
deviceId
)
{
log
.
debug
(
"
destroying
device
and
session
"
)
;
return
this
.
fxAccountsClient
.
signOutAndDestroyDevice
(
sessionToken
deviceId
options
)
;
}
log
.
debug
(
"
destroying
session
"
)
;
return
this
.
fxAccountsClient
.
signOut
(
sessionToken
options
)
;
}
sessionStatus
(
)
{
return
this
.
getSignedInUser
(
)
.
then
(
data
=
>
{
if
(
!
data
.
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
sessionStatus
called
without
a
session
token
"
)
)
;
}
return
this
.
fxAccountsClient
.
sessionStatus
(
data
.
sessionToken
)
;
}
)
;
}
getKeys
:
function
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
(
userData
)
=
>
{
if
(
!
userData
)
{
throw
new
Error
(
"
Can
'
t
get
keys
;
User
is
not
signed
in
"
)
;
}
if
(
userData
.
kA
&
&
userData
.
kB
)
{
return
userData
;
}
if
(
!
currentState
.
whenKeysReadyDeferred
)
{
currentState
.
whenKeysReadyDeferred
=
Promise
.
defer
(
)
;
if
(
userData
.
keyFetchToken
)
{
this
.
fetchAndUnwrapKeys
(
userData
.
keyFetchToken
)
.
then
(
(
dataWithKeys
)
=
>
{
if
(
!
dataWithKeys
.
kA
|
|
!
dataWithKeys
.
kB
)
{
currentState
.
whenKeysReadyDeferred
.
reject
(
new
Error
(
"
user
data
missing
kA
or
kB
"
)
)
;
return
;
}
currentState
.
whenKeysReadyDeferred
.
resolve
(
dataWithKeys
)
;
}
(
err
)
=
>
{
currentState
.
whenKeysReadyDeferred
.
reject
(
err
)
;
}
)
;
}
else
{
currentState
.
whenKeysReadyDeferred
.
reject
(
'
No
keyFetchToken
'
)
;
}
}
return
currentState
.
whenKeysReadyDeferred
.
promise
;
}
)
.
catch
(
err
=
>
this
.
_handleTokenError
(
err
)
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
fetchAndUnwrapKeys
:
function
(
keyFetchToken
)
{
if
(
logPII
)
{
log
.
debug
(
"
fetchAndUnwrapKeys
:
token
:
"
+
keyFetchToken
)
;
}
let
currentState
=
this
.
currentAccountState
;
return
Task
.
spawn
(
function
*
task
(
)
{
if
(
!
keyFetchToken
)
{
log
.
warn
(
"
improper
fetchAndUnwrapKeys
(
)
call
:
token
missing
"
)
;
yield
this
.
signOut
(
)
;
return
null
;
}
let
{
kA
wrapKB
}
=
yield
this
.
fetchKeys
(
keyFetchToken
)
;
let
data
=
yield
currentState
.
getUserAccountData
(
)
;
if
(
data
.
keyFetchToken
!
=
=
keyFetchToken
)
{
throw
new
Error
(
"
Signed
in
user
changed
while
fetching
keys
!
"
)
;
}
let
kB_hex
=
CryptoUtils
.
xor
(
CommonUtils
.
hexToBytes
(
data
.
unwrapBKey
)
wrapKB
)
;
if
(
logPII
)
{
log
.
debug
(
"
kB_hex
:
"
+
kB_hex
)
;
}
let
updateData
=
{
kA
:
CommonUtils
.
bytesAsHex
(
kA
)
kB
:
CommonUtils
.
bytesAsHex
(
kB_hex
)
keyFetchToken
:
null
unwrapBKey
:
null
}
log
.
debug
(
"
Keys
Obtained
:
kA
=
"
+
!
!
updateData
.
kA
+
"
kB
=
"
+
!
!
updateData
.
kB
)
;
if
(
logPII
)
{
log
.
debug
(
"
Keys
Obtained
:
kA
=
"
+
updateData
.
kA
+
"
kB
=
"
+
updateData
.
kB
)
;
}
yield
currentState
.
updateUserAccountData
(
updateData
)
;
this
.
notifyObservers
(
ONVERIFIED_NOTIFICATION
)
;
return
currentState
.
getUserAccountData
(
)
;
}
.
bind
(
this
)
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
getAssertionFromCert
:
function
(
data
keyPair
cert
audience
)
{
log
.
debug
(
"
getAssertionFromCert
"
)
;
let
payload
=
{
}
;
let
d
=
Promise
.
defer
(
)
;
let
options
=
{
duration
:
ASSERTION_LIFETIME
localtimeOffsetMsec
:
this
.
localtimeOffsetMsec
now
:
this
.
now
(
)
}
;
let
currentState
=
this
.
currentAccountState
;
jwcrypto
.
generateAssertion
(
cert
keyPair
audience
options
(
err
signed
)
=
>
{
if
(
err
)
{
log
.
error
(
"
getAssertionFromCert
:
"
+
err
)
;
d
.
reject
(
err
)
;
}
else
{
log
.
debug
(
"
getAssertionFromCert
returning
signed
:
"
+
!
!
signed
)
;
if
(
logPII
)
{
log
.
debug
(
"
getAssertionFromCert
returning
signed
:
"
+
signed
)
;
}
d
.
resolve
(
signed
)
;
}
}
)
;
return
d
.
promise
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
getCertificateSigned
:
function
(
sessionToken
serializedPublicKey
lifetime
)
{
log
.
debug
(
"
getCertificateSigned
:
"
+
!
!
sessionToken
+
"
"
+
!
!
serializedPublicKey
)
;
if
(
logPII
)
{
log
.
debug
(
"
getCertificateSigned
:
"
+
sessionToken
+
"
"
+
serializedPublicKey
)
;
}
return
this
.
fxAccountsClient
.
signCertificate
(
sessionToken
JSON
.
parse
(
serializedPublicKey
)
lifetime
)
;
}
getKeypairAndCertificate
:
Task
.
async
(
function
*
(
currentState
)
{
let
ignoreCachedAuthCredentials
=
false
;
try
{
ignoreCachedAuthCredentials
=
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
debug
.
ignoreCachedAuthCredentials
"
)
;
}
catch
(
e
)
{
}
let
mustBeValidUntil
=
this
.
now
(
)
+
ASSERTION_USE_PERIOD
;
let
accountData
=
yield
currentState
.
getUserAccountData
(
[
"
cert
"
"
keyPair
"
"
sessionToken
"
]
)
;
let
keyPairValid
=
!
ignoreCachedAuthCredentials
&
&
accountData
.
keyPair
&
&
(
accountData
.
keyPair
.
validUntil
>
mustBeValidUntil
)
;
let
certValid
=
!
ignoreCachedAuthCredentials
&
&
accountData
.
cert
&
&
(
accountData
.
cert
.
validUntil
>
mustBeValidUntil
)
;
if
(
keyPairValid
&
&
certValid
)
{
log
.
debug
(
"
getKeypairAndCertificate
:
already
have
keyPair
and
certificate
"
)
;
return
{
keyPair
:
accountData
.
keyPair
.
rawKeyPair
certificate
:
accountData
.
cert
.
rawCert
}
}
if
(
Services
.
io
.
offline
)
{
throw
new
Error
(
ERROR_OFFLINE
)
;
}
let
keyPair
;
if
(
keyPairValid
)
{
keyPair
=
accountData
.
keyPair
;
}
else
{
let
keyWillBeValidUntil
=
this
.
now
(
)
+
KEY_LIFETIME
;
keyPair
=
yield
new
Promise
(
(
resolve
reject
)
=
>
{
jwcrypto
.
generateKeyPair
(
"
DS160
"
(
err
kp
)
=
>
{
if
(
err
)
{
return
reject
(
err
)
;
}
log
.
debug
(
"
got
keyPair
"
)
;
resolve
(
{
rawKeyPair
:
kp
validUntil
:
keyWillBeValidUntil
}
)
;
}
)
;
}
)
;
}
let
certWillBeValidUntil
=
this
.
now
(
)
+
CERT_LIFETIME
;
let
certificate
=
yield
this
.
getCertificateSigned
(
accountData
.
sessionToken
keyPair
.
rawKeyPair
.
serializedPublicKey
CERT_LIFETIME
)
;
log
.
debug
(
"
getCertificate
got
a
new
one
:
"
+
!
!
certificate
)
;
if
(
certificate
)
{
let
toUpdate
=
{
keyPair
cert
:
{
rawCert
:
certificate
validUntil
:
certWillBeValidUntil
}
}
;
yield
currentState
.
updateUserAccountData
(
toUpdate
)
;
}
return
{
keyPair
:
keyPair
.
rawKeyPair
certificate
:
certificate
}
}
)
getUserAccountData
:
function
(
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
;
}
isUserEmailVerified
:
function
isUserEmailVerified
(
data
)
{
return
!
!
(
data
&
&
data
.
verified
)
;
}
loadAndPoll
:
function
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
getUserAccountData
(
)
.
then
(
data
=
>
{
if
(
data
)
{
Services
.
telemetry
.
getHistogramById
(
"
FXA_CONFIGURED
"
)
.
add
(
1
)
;
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
this
.
pollEmailStatus
(
currentState
data
.
sessionToken
"
start
"
)
;
}
}
return
data
;
}
)
;
}
startVerifiedCheck
:
function
(
data
)
{
log
.
debug
(
"
startVerifiedCheck
"
data
&
&
data
.
verified
)
;
if
(
logPII
)
{
log
.
debug
(
"
startVerifiedCheck
with
user
data
"
data
)
;
}
this
.
whenVerified
(
data
)
.
then
(
(
)
=
>
this
.
getKeys
(
)
err
=
>
log
.
info
(
"
startVerifiedCheck
promise
was
rejected
:
"
+
err
)
)
;
}
whenVerified
:
function
(
data
)
{
let
currentState
=
this
.
currentAccountState
;
if
(
data
.
verified
)
{
log
.
debug
(
"
already
verified
"
)
;
return
currentState
.
resolve
(
data
)
;
}
if
(
!
currentState
.
whenVerifiedDeferred
)
{
log
.
debug
(
"
whenVerified
promise
starts
polling
for
verified
email
"
)
;
this
.
pollEmailStatus
(
currentState
data
.
sessionToken
"
start
"
)
;
}
return
currentState
.
whenVerifiedDeferred
.
promise
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
notifyObservers
:
function
(
topic
data
)
{
log
.
debug
(
"
Notifying
observers
of
"
+
topic
)
;
Services
.
obs
.
notifyObservers
(
null
topic
data
)
;
}
pollEmailStatus
:
function
pollEmailStatus
(
currentState
sessionToken
why
)
{
log
.
debug
(
"
entering
pollEmailStatus
:
"
+
why
)
;
if
(
why
=
=
"
start
"
|
|
why
=
=
"
push
"
)
{
if
(
this
.
currentTimer
)
{
log
.
debug
(
"
pollEmailStatus
starting
while
existing
timer
is
running
"
)
;
clearTimeout
(
this
.
currentTimer
)
;
this
.
currentTimer
=
null
;
}
this
.
pollStartDate
=
Date
.
now
(
)
;
if
(
!
currentState
.
whenVerifiedDeferred
)
{
currentState
.
whenVerifiedDeferred
=
Promise
.
defer
(
)
;
currentState
.
whenVerifiedDeferred
.
promise
.
then
(
null
err
=
>
{
log
.
info
(
"
the
wait
for
user
verification
was
stopped
:
"
+
err
)
;
}
)
;
}
}
return
this
.
checkEmailStatus
(
sessionToken
{
reason
:
why
}
)
.
then
(
(
response
)
=
>
{
log
.
debug
(
"
checkEmailStatus
-
>
"
+
JSON
.
stringify
(
response
)
)
;
if
(
response
&
&
response
.
verified
)
{
currentState
.
updateUserAccountData
(
{
verified
:
true
}
)
.
then
(
(
)
=
>
{
return
currentState
.
getUserAccountData
(
)
;
}
)
.
then
(
data
=
>
{
if
(
currentState
.
whenVerifiedDeferred
)
{
currentState
.
whenVerifiedDeferred
.
resolve
(
data
)
;
delete
currentState
.
whenVerifiedDeferred
;
}
this
.
notifyObservers
(
ON_FXA_UPDATE_NOTIFICATION
ONVERIFIED_NOTIFICATION
)
;
}
)
;
}
else
{
this
.
pollEmailStatusAgain
(
currentState
sessionToken
)
;
}
}
error
=
>
{
let
timeoutMs
=
undefined
;
if
(
error
&
&
error
.
retryAfter
)
{
timeoutMs
=
(
error
.
retryAfter
+
3
)
*
1000
;
}
if
(
!
error
|
|
!
error
.
code
|
|
error
.
code
!
=
401
)
{
this
.
pollEmailStatusAgain
(
currentState
sessionToken
timeoutMs
)
;
}
else
{
let
error
=
new
Error
(
"
Verification
status
check
failed
"
)
;
this
.
_rejectWhenVerified
(
currentState
error
)
;
}
}
)
;
}
_rejectWhenVerified
(
currentState
error
)
{
currentState
.
whenVerifiedDeferred
.
reject
(
error
)
;
delete
currentState
.
whenVerifiedDeferred
;
}
pollEmailStatusAgain
:
function
(
currentState
sessionToken
timeoutMs
)
{
let
ageMs
=
Date
.
now
(
)
-
this
.
pollStartDate
;
if
(
ageMs
>
=
this
.
POLL_SESSION
)
{
if
(
currentState
.
whenVerifiedDeferred
)
{
let
error
=
new
Error
(
"
User
email
verification
timed
out
.
"
)
;
this
.
_rejectWhenVerified
(
currentState
error
)
;
}
log
.
debug
(
"
polling
session
exceeded
giving
up
"
)
;
return
;
}
if
(
timeoutMs
=
=
=
undefined
)
{
let
currentMinute
=
Math
.
ceil
(
ageMs
/
60000
)
;
timeoutMs
=
currentMinute
<
=
2
?
this
.
VERIFICATION_POLL_TIMEOUT_INITIAL
:
this
.
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
;
}
log
.
debug
(
"
polling
with
timeout
=
"
+
timeoutMs
)
;
this
.
currentTimer
=
setTimeout
(
(
)
=
>
{
this
.
pollEmailStatus
(
currentState
sessionToken
"
timer
"
)
;
}
timeoutMs
)
;
}
requiresHttps
:
function
(
)
{
let
allowHttp
=
false
;
try
{
allowHttp
=
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
allowHttp
"
)
;
}
catch
(
e
)
{
}
return
allowHttp
!
=
=
true
;
}
promiseAccountsSignUpURI
(
)
{
return
FxAccountsConfig
.
promiseAccountsSignUpURI
(
)
;
}
promiseAccountsSignInURI
(
)
{
return
FxAccountsConfig
.
promiseAccountsSignInURI
(
)
;
}
promiseAccountsForceSigninURI
:
Task
.
async
(
function
*
(
)
{
yield
FxAccountsConfig
.
ensureConfigured
(
)
;
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
force_auth
.
uri
"
)
;
if
(
this
.
requiresHttps
(
)
&
&
!
/
^
https
:
/
.
test
(
url
)
)
{
throw
new
Error
(
"
Firefox
Accounts
server
must
use
HTTPS
"
)
;
}
let
currentState
=
this
.
currentAccountState
;
return
this
.
getSignedInUser
(
)
.
then
(
accountData
=
>
{
if
(
!
accountData
)
{
return
null
;
}
let
newQueryPortion
=
url
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
;
newQueryPortion
+
=
"
email
=
"
+
encodeURIComponent
(
accountData
.
email
)
;
return
url
+
newQueryPortion
;
}
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
)
promiseAccountsChangeProfileURI
:
function
(
entrypoint
settingToEdit
=
null
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
settings
.
uri
"
)
;
if
(
settingToEdit
)
{
url
+
=
(
url
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
)
+
"
setting
=
"
+
encodeURIComponent
(
settingToEdit
)
;
}
if
(
this
.
requiresHttps
(
)
&
&
!
/
^
https
:
/
.
test
(
url
)
)
{
throw
new
Error
(
"
Firefox
Accounts
server
must
use
HTTPS
"
)
;
}
let
currentState
=
this
.
currentAccountState
;
return
this
.
getSignedInUser
(
)
.
then
(
accountData
=
>
{
if
(
!
accountData
)
{
return
null
;
}
let
newQueryPortion
=
url
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
;
newQueryPortion
+
=
"
email
=
"
+
encodeURIComponent
(
accountData
.
email
)
;
newQueryPortion
+
=
"
&
uid
=
"
+
encodeURIComponent
(
accountData
.
uid
)
;
if
(
entrypoint
)
{
newQueryPortion
+
=
"
&
entrypoint
=
"
+
encodeURIComponent
(
entrypoint
)
;
}
return
url
+
newQueryPortion
;
}
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
promiseAccountsManageURI
:
function
(
entrypoint
)
{
let
url
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
settings
.
uri
"
)
;
if
(
this
.
requiresHttps
(
)
&
&
!
/
^
https
:
/
.
test
(
url
)
)
{
throw
new
Error
(
"
Firefox
Accounts
server
must
use
HTTPS
"
)
;
}
let
currentState
=
this
.
currentAccountState
;
return
this
.
getSignedInUser
(
)
.
then
(
accountData
=
>
{
if
(
!
accountData
)
{
return
null
;
}
let
newQueryPortion
=
url
.
indexOf
(
"
?
"
)
=
=
-
1
?
"
?
"
:
"
&
"
;
newQueryPortion
+
=
"
uid
=
"
+
encodeURIComponent
(
accountData
.
uid
)
+
"
&
email
=
"
+
encodeURIComponent
(
accountData
.
email
)
;
if
(
entrypoint
)
{
newQueryPortion
+
=
"
&
entrypoint
=
"
+
encodeURIComponent
(
entrypoint
)
;
}
return
url
+
newQueryPortion
;
}
)
.
then
(
result
=
>
currentState
.
resolve
(
result
)
)
;
}
getOAuthToken
:
Task
.
async
(
function
*
(
options
=
{
}
)
{
log
.
debug
(
"
getOAuthToken
enter
"
)
;
let
scope
=
options
.
scope
;
if
(
typeof
scope
=
=
=
"
string
"
)
{
scope
=
[
scope
]
;
}
if
(
!
scope
|
|
!
scope
.
length
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
"
Missing
or
invalid
'
scope
'
option
"
)
;
}
yield
this
.
_getVerifiedAccountOrReject
(
)
;
let
currentState
=
this
.
currentAccountState
;
let
cached
=
currentState
.
getCachedToken
(
scope
)
;
if
(
cached
)
{
log
.
debug
(
"
getOAuthToken
returning
a
cached
token
"
)
;
return
cached
.
token
;
}
let
scopeString
=
scope
.
join
(
"
"
)
;
let
client
=
options
.
client
;
if
(
!
client
)
{
try
{
let
defaultURL
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
)
;
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
defaultURL
client_id
:
FX_OAUTH_CLIENT_ID
}
)
;
}
catch
(
e
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
e
)
;
}
}
let
oAuthURL
=
client
.
serverURL
.
href
;
try
{
log
.
debug
(
"
getOAuthToken
fetching
new
token
from
"
oAuthURL
)
;
let
assertion
=
yield
this
.
getAssertion
(
oAuthURL
)
;
let
result
=
yield
client
.
getTokenFromAssertion
(
assertion
scopeString
)
;
let
token
=
result
.
access_token
;
if
(
token
)
{
let
entry
=
{
token
:
token
server
:
oAuthURL
}
;
let
cached
=
currentState
.
getCachedToken
(
scope
)
;
if
(
cached
)
{
log
.
debug
(
"
Detected
a
race
for
this
token
-
revoking
the
new
one
.
"
)
;
this
.
_destroyOAuthToken
(
entry
)
;
return
cached
.
token
;
}
currentState
.
setCachedToken
(
scope
entry
)
;
}
return
token
;
}
catch
(
err
)
{
throw
this
.
_errorToErrorClass
(
err
)
;
}
}
)
removeCachedOAuthToken
:
Task
.
async
(
function
*
(
options
)
{
if
(
!
options
.
token
|
|
typeof
options
.
token
!
=
=
"
string
"
)
{
throw
this
.
_error
(
ERROR_INVALID_PARAMETER
"
Missing
or
invalid
'
token
'
option
"
)
;
}
let
currentState
=
this
.
currentAccountState
;
let
existing
=
currentState
.
removeCachedToken
(
options
.
token
)
;
if
(
existing
)
{
this
.
_destroyOAuthToken
(
existing
)
.
catch
(
err
=
>
{
log
.
warn
(
"
FxA
failed
to
revoke
a
cached
token
"
err
)
;
}
)
;
}
}
)
_getVerifiedAccountOrReject
:
Task
.
async
(
function
*
(
)
{
let
data
=
yield
this
.
currentAccountState
.
getUserAccountData
(
)
;
if
(
!
data
)
{
throw
this
.
_error
(
ERROR_NO_ACCOUNT
)
;
}
if
(
!
this
.
isUserEmailVerified
(
data
)
)
{
throw
this
.
_error
(
ERROR_UNVERIFIED_ACCOUNT
)
;
}
}
)
_errorToErrorClass
:
function
(
aError
)
{
if
(
aError
.
errno
)
{
let
error
=
SERVER_ERRNO_TO_ERROR
[
aError
.
errno
]
;
return
this
.
_error
(
ERROR_TO_GENERAL_ERROR_CLASS
[
error
]
|
|
ERROR_UNKNOWN
aError
)
;
}
else
if
(
aError
.
message
&
&
(
aError
.
message
=
=
=
"
INVALID_PARAMETER
"
|
|
aError
.
message
=
=
=
"
NO_ACCOUNT
"
|
|
aError
.
message
=
=
=
"
UNVERIFIED_ACCOUNT
"
|
|
aError
.
message
=
=
=
"
AUTH_ERROR
"
)
)
{
return
aError
;
}
return
this
.
_error
(
ERROR_UNKNOWN
aError
)
;
}
_error
:
function
(
aError
aDetails
)
{
log
.
error
(
"
FxA
rejecting
with
error
{
aError
}
details
:
{
aDetails
}
"
{
aError
aDetails
}
)
;
let
reason
=
new
Error
(
aError
)
;
if
(
aDetails
)
{
reason
.
details
=
aDetails
;
}
return
reason
;
}
getSignedInUserProfile
:
function
(
)
{
let
currentState
=
this
.
currentAccountState
;
return
this
.
profile
.
getProfile
(
)
.
then
(
profileData
=
>
{
let
profile
=
Cu
.
cloneInto
(
profileData
{
}
)
;
return
currentState
.
resolve
(
profile
)
;
}
error
=
>
{
log
.
error
(
"
Could
not
retrieve
profile
data
"
error
)
;
return
currentState
.
reject
(
error
)
;
}
)
.
catch
(
err
=
>
Promise
.
reject
(
this
.
_errorToErrorClass
(
err
)
)
)
;
}
updateDeviceRegistration
(
)
{
return
this
.
getSignedInUser
(
)
.
then
(
signedInUser
=
>
{
if
(
signedInUser
)
{
return
this
.
_registerOrUpdateDevice
(
signedInUser
)
;
}
}
)
.
catch
(
error
=
>
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
)
;
}
handleDeviceDisconnection
(
deviceId
)
{
return
this
.
currentAccountState
.
getUserAccountData
(
)
.
then
(
data
=
>
data
?
data
.
deviceId
:
null
)
.
then
(
localDeviceId
=
>
{
if
(
deviceId
=
=
localDeviceId
)
{
this
.
notifyObservers
(
ON_DEVICE_DISCONNECTED_NOTIFICATION
deviceId
)
;
return
this
.
signOut
(
true
)
;
}
log
.
error
(
"
The
device
ID
to
disconnect
doesn
'
t
match
with
the
local
device
ID
.
\
n
"
+
"
Local
:
"
+
localDeviceId
+
"
ID
to
disconnect
:
"
+
deviceId
)
;
}
)
;
}
resetCredentials
(
)
{
let
updateData
=
{
}
;
let
clearField
=
field
=
>
{
if
(
!
FXA_PWDMGR_REAUTH_WHITELIST
.
has
(
field
)
)
{
updateData
[
field
]
=
null
;
}
}
FXA_PWDMGR_PLAINTEXT_FIELDS
.
forEach
(
clearField
)
;
FXA_PWDMGR_SECURE_FIELDS
.
forEach
(
clearField
)
;
FXA_PWDMGR_MEMORY_FIELDS
.
forEach
(
clearField
)
;
let
currentState
=
this
.
currentAccountState
;
return
currentState
.
updateUserAccountData
(
updateData
)
;
}
_registerOrUpdateDevice
(
signedInUser
)
{
try
{
if
(
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
skipDeviceRegistration
"
)
)
{
return
Promise
.
resolve
(
)
;
}
}
catch
(
ignore
)
{
}
if
(
!
signedInUser
.
sessionToken
)
{
return
Promise
.
reject
(
new
Error
(
"
_registerOrUpdateDevice
called
without
a
session
token
"
)
)
;
}
return
this
.
fxaPushService
.
registerPushEndpoint
(
)
.
then
(
subscription
=
>
{
const
deviceName
=
this
.
_getDeviceName
(
)
;
let
deviceOptions
=
{
}
;
if
(
subscription
&
&
subscription
.
endpoint
)
{
deviceOptions
.
pushCallback
=
subscription
.
endpoint
;
let
publicKey
=
subscription
.
getKey
(
'
p256dh
'
)
;
let
authKey
=
subscription
.
getKey
(
'
auth
'
)
;
if
(
publicKey
&
&
authKey
)
{
deviceOptions
.
pushPublicKey
=
urlsafeBase64Encode
(
publicKey
)
;
deviceOptions
.
pushAuthKey
=
urlsafeBase64Encode
(
authKey
)
;
}
}
if
(
signedInUser
.
deviceId
)
{
log
.
debug
(
"
updating
existing
device
details
"
)
;
return
this
.
fxAccountsClient
.
updateDevice
(
signedInUser
.
sessionToken
signedInUser
.
deviceId
deviceName
deviceOptions
)
;
}
log
.
debug
(
"
registering
new
device
details
"
)
;
return
this
.
fxAccountsClient
.
registerDevice
(
signedInUser
.
sessionToken
deviceName
this
.
_getDeviceType
(
)
deviceOptions
)
;
}
)
.
then
(
device
=
>
this
.
currentAccountState
.
updateUserAccountData
(
{
deviceId
:
device
.
id
deviceRegistrationVersion
:
this
.
DEVICE_REGISTRATION_VERSION
}
)
.
then
(
(
)
=
>
device
.
id
)
)
.
catch
(
error
=
>
this
.
_handleDeviceError
(
error
signedInUser
.
sessionToken
)
)
;
}
_getDeviceName
(
)
{
return
Utils
.
getDeviceName
(
)
;
}
_getDeviceType
(
)
{
return
Utils
.
getDeviceType
(
)
;
}
_handleDeviceError
(
error
sessionToken
)
{
return
Promise
.
resolve
(
)
.
then
(
(
)
=
>
{
if
(
error
.
code
=
=
=
400
)
{
if
(
error
.
errno
=
=
=
ERRNO_UNKNOWN_DEVICE
)
{
return
this
.
_recoverFromUnknownDevice
(
)
;
}
if
(
error
.
errno
=
=
=
ERRNO_DEVICE_SESSION_CONFLICT
)
{
return
this
.
_recoverFromDeviceSessionConflict
(
error
sessionToken
)
;
}
}
return
this
.
_handleTokenError
(
error
)
;
}
)
.
catch
(
error
=
>
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
)
.
catch
(
(
)
=
>
{
}
)
;
}
_recoverFromUnknownDevice
(
)
{
log
.
warn
(
"
unknown
device
id
clearing
the
local
device
data
"
)
;
return
this
.
currentAccountState
.
updateUserAccountData
(
{
deviceId
:
null
}
)
.
catch
(
error
=
>
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
)
;
}
_recoverFromDeviceSessionConflict
(
error
sessionToken
)
{
log
.
warn
(
"
device
session
conflict
attempting
to
ascertain
the
correct
device
id
"
)
;
return
this
.
fxAccountsClient
.
getDeviceList
(
sessionToken
)
.
then
(
devices
=
>
{
const
matchingDevices
=
devices
.
filter
(
device
=
>
device
.
isCurrentDevice
)
;
const
length
=
matchingDevices
.
length
;
if
(
length
=
=
=
1
)
{
const
deviceId
=
matchingDevices
[
0
]
.
id
;
return
this
.
currentAccountState
.
updateUserAccountData
(
{
deviceId
deviceRegistrationVersion
:
null
}
)
.
then
(
(
)
=
>
deviceId
)
;
}
if
(
length
>
1
)
{
log
.
error
(
"
insane
server
state
"
+
length
+
"
devices
for
this
session
"
)
;
}
return
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
;
}
)
.
catch
(
secondError
=
>
{
log
.
error
(
"
failed
to
recover
from
device
-
session
conflict
"
secondError
)
;
this
.
_logErrorAndResetDeviceRegistrationVersion
(
error
)
}
)
;
}
_logErrorAndResetDeviceRegistrationVersion
(
error
)
{
log
.
error
(
"
device
registration
failed
"
error
)
;
return
this
.
currentAccountState
.
updateUserAccountData
(
{
deviceRegistrationVersion
:
null
}
)
.
catch
(
secondError
=
>
{
log
.
error
(
"
failed
to
reset
the
device
registration
version
device
registration
won
'
t
be
retried
"
secondError
)
;
}
)
.
then
(
(
)
=
>
{
}
)
;
}
_handleTokenError
(
err
)
{
if
(
!
err
|
|
err
.
code
!
=
401
|
|
err
.
errno
!
=
ERRNO_INVALID_AUTH_TOKEN
)
{
throw
err
;
}
log
.
warn
(
"
recovering
from
invalid
token
error
"
err
)
;
return
this
.
accountStatus
(
)
.
then
(
exists
=
>
{
if
(
!
exists
)
{
log
.
info
(
"
token
invalidated
because
the
account
no
longer
exists
"
)
;
return
this
.
signOut
(
true
)
;
}
log
.
info
(
"
clearing
credentials
to
handle
invalid
token
error
"
)
;
return
this
.
resetCredentials
(
)
;
}
)
.
then
(
(
)
=
>
Promise
.
reject
(
err
)
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
this
"
fxAccounts
"
function
(
)
{
let
a
=
new
FxAccounts
(
)
;
a
.
loadAndPoll
(
)
;
return
a
;
}
)
;
