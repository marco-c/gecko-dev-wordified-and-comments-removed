const
EXPORTED_SYMBOLS
=
[
"
SendTab
"
"
FxAccountsCommands
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PushCrypto
"
"
resource
:
/
/
gre
/
modules
/
PushCrypto
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BulkKeyBundle
:
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
CommonUtils
:
"
resource
:
/
/
services
-
common
/
utils
.
js
"
CryptoUtils
:
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
CryptoWrapper
:
"
resource
:
/
/
services
-
sync
/
record
.
js
"
}
)
;
class
FxAccountsCommands
{
constructor
(
fxAccounts
)
{
this
.
_fxAccounts
=
fxAccounts
;
this
.
sendTab
=
new
SendTab
(
this
fxAccounts
)
;
}
async
invoke
(
command
device
payload
)
{
const
userData
=
await
this
.
_fxAccounts
.
getSignedInUser
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
No
user
.
"
)
;
}
const
{
sessionToken
}
=
userData
;
if
(
!
sessionToken
)
{
throw
new
Error
(
"
_send
called
without
a
session
token
.
"
)
;
}
const
client
=
this
.
_fxAccounts
.
getAccountsClient
(
)
;
await
client
.
invokeCommand
(
sessionToken
command
device
.
id
payload
)
;
log
.
info
(
Payload
sent
to
device
{
device
.
id
}
.
)
;
}
async
consumeRemoteCommand
(
index
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
commands
.
enabled
"
true
)
)
{
return
false
;
}
log
.
info
(
Consuming
command
with
index
{
index
}
.
)
;
const
{
messages
}
=
await
this
.
_fetchRemoteCommands
(
index
1
)
;
if
(
messages
.
length
!
=
1
)
{
log
.
warn
(
Should
have
retrieved
1
and
only
1
message
got
{
messages
.
length
}
.
)
;
}
return
this
.
_fxAccounts
.
_withCurrentAccountState
(
async
(
getUserData
updateUserData
)
=
>
{
const
{
device
}
=
await
getUserData
(
[
"
device
"
]
)
;
if
(
!
device
)
{
throw
new
Error
(
"
No
device
registration
.
"
)
;
}
const
handledCommands
=
(
device
.
handledCommands
|
|
[
]
)
.
concat
(
messages
.
map
(
m
=
>
m
.
index
)
)
;
await
updateUserData
(
{
device
:
{
.
.
.
device
handledCommands
}
}
)
;
await
this
.
_handleCommands
(
messages
)
;
if
(
handledCommands
.
length
>
20
)
{
await
this
.
fetchMissedRemoteCommands
(
)
;
}
}
)
;
}
async
fetchMissedRemoteCommands
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
commands
.
enabled
"
true
)
)
{
return
false
;
}
log
.
info
(
Consuming
missed
commands
.
)
;
await
this
.
_fxAccounts
.
_withCurrentAccountState
(
async
(
getUserData
updateUserData
)
=
>
{
const
{
device
}
=
await
getUserData
(
[
"
device
"
]
)
;
if
(
!
device
)
{
throw
new
Error
(
"
No
device
registration
.
"
)
;
}
const
lastCommandIndex
=
device
.
lastCommandIndex
|
|
0
;
const
handledCommands
=
device
.
handledCommands
|
|
[
]
;
handledCommands
.
push
(
lastCommandIndex
)
;
const
{
index
messages
}
=
await
this
.
_fetchRemoteCommands
(
lastCommandIndex
)
;
const
missedMessages
=
messages
.
filter
(
m
=
>
!
handledCommands
.
includes
(
m
.
index
)
)
;
await
updateUserData
(
{
device
:
{
.
.
.
device
lastCommandIndex
:
index
handledCommands
:
[
]
}
}
)
;
if
(
missedMessages
.
length
)
{
log
.
info
(
Handling
{
missedMessages
.
length
}
missed
messages
)
;
Services
.
telemetry
.
scalarAdd
(
"
identity
.
fxaccounts
.
missed_commands_fetched
"
missedMessages
.
length
)
;
await
this
.
_handleCommands
(
missedMessages
)
;
}
}
)
;
return
true
;
}
async
_fetchRemoteCommands
(
index
limit
=
null
)
{
const
userData
=
await
this
.
_fxAccounts
.
getSignedInUser
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
No
user
.
"
)
;
}
const
{
sessionToken
}
=
userData
;
if
(
!
sessionToken
)
{
throw
new
Error
(
"
No
session
token
.
"
)
;
}
const
client
=
this
.
_fxAccounts
.
getAccountsClient
(
)
;
const
opts
=
{
index
}
;
if
(
limit
!
=
null
)
{
opts
.
limit
=
limit
;
}
return
client
.
getCommands
(
sessionToken
opts
)
;
}
async
_handleCommands
(
messages
)
{
const
fxaDevices
=
await
this
.
_fxAccounts
.
getDeviceList
(
)
;
for
(
const
{
data
}
of
messages
)
{
let
{
command
payload
sender
}
=
data
;
if
(
sender
)
{
sender
=
fxaDevices
.
find
(
d
=
>
d
.
id
=
=
sender
)
;
}
switch
(
command
)
{
case
COMMAND_SENDTAB
:
try
{
await
this
.
sendTab
.
handle
(
sender
payload
)
;
}
catch
(
e
)
{
log
.
error
(
Error
while
handling
incoming
Send
Tab
payload
.
e
)
;
}
break
;
default
:
log
.
info
(
Unknown
command
:
{
command
}
.
)
;
}
}
}
}
class
SendTab
{
constructor
(
commands
fxAccounts
)
{
this
.
_commands
=
commands
;
this
.
_fxAccounts
=
fxAccounts
;
}
async
send
(
to
tab
)
{
log
.
info
(
Sending
a
tab
to
{
to
.
length
}
devices
.
)
;
const
encoder
=
new
TextEncoder
(
"
utf8
"
)
;
const
data
=
{
entries
:
[
{
title
:
tab
.
title
url
:
tab
.
url
}
]
}
;
const
bytes
=
encoder
.
encode
(
JSON
.
stringify
(
data
)
)
;
const
report
=
{
succeeded
:
[
]
failed
:
[
]
}
;
for
(
let
device
of
to
)
{
try
{
const
encrypted
=
await
this
.
_encrypt
(
bytes
device
)
;
const
payload
=
{
encrypted
}
;
await
this
.
_commands
.
invoke
(
COMMAND_SENDTAB
device
payload
)
;
report
.
succeeded
.
push
(
device
)
;
}
catch
(
error
)
{
log
.
error
(
"
Error
while
invoking
a
send
tab
command
.
"
error
)
;
report
.
failed
.
push
(
{
device
error
}
)
;
}
}
return
report
;
}
isDeviceCompatible
(
device
)
{
return
Services
.
prefs
.
getBoolPref
(
"
identity
.
fxaccounts
.
commands
.
enabled
"
true
)
&
&
device
.
availableCommands
&
&
device
.
availableCommands
[
COMMAND_SENDTAB
]
;
}
async
handle
(
sender
{
encrypted
}
)
{
if
(
!
sender
)
{
log
.
warn
(
"
Incoming
tab
is
from
an
unknown
device
(
maybe
disconnected
?
)
"
)
;
}
const
bytes
=
await
this
.
_decrypt
(
encrypted
)
;
const
decoder
=
new
TextDecoder
(
"
utf8
"
)
;
const
data
=
JSON
.
parse
(
decoder
.
decode
(
bytes
)
)
;
const
current
=
data
.
hasOwnProperty
(
"
current
"
)
?
data
.
current
:
data
.
entries
.
length
-
1
;
const
tabSender
=
{
id
:
sender
?
sender
.
id
:
"
"
name
:
sender
?
sender
.
name
:
"
"
}
;
const
{
title
url
:
uri
}
=
data
.
entries
[
current
]
;
log
.
info
(
Tab
received
with
FxA
commands
:
{
title
}
from
{
tabSender
.
name
}
.
)
;
Observers
.
notify
(
"
fxaccounts
:
commands
:
open
-
uri
"
[
{
uri
title
sender
:
tabSender
}
]
)
;
}
async
_encrypt
(
bytes
device
)
{
let
bundle
=
device
.
availableCommands
[
COMMAND_SENDTAB
]
;
if
(
!
bundle
)
{
throw
new
Error
(
Device
{
device
.
id
}
does
not
have
send
tab
keys
.
)
;
}
const
{
kSync
kXCS
:
ourKid
}
=
await
this
.
_fxAccounts
.
getKeys
(
)
;
const
{
kid
:
theirKid
}
=
JSON
.
parse
(
device
.
availableCommands
[
COMMAND_SENDTAB
]
)
;
if
(
theirKid
!
=
ourKid
)
{
throw
new
Error
(
"
Target
Send
Tab
key
ID
is
different
from
ours
"
)
;
}
const
json
=
JSON
.
parse
(
bundle
)
;
const
wrapper
=
new
CryptoWrapper
(
)
;
wrapper
.
deserialize
(
{
payload
:
json
}
)
;
const
syncKeyBundle
=
BulkKeyBundle
.
fromHexKey
(
kSync
)
;
let
{
publicKey
authSecret
}
=
await
wrapper
.
decrypt
(
syncKeyBundle
)
;
authSecret
=
urlsafeBase64Decode
(
authSecret
)
;
publicKey
=
urlsafeBase64Decode
(
publicKey
)
;
const
{
ciphertext
:
encrypted
}
=
await
PushCrypto
.
encrypt
(
bytes
publicKey
authSecret
)
;
return
urlsafeBase64Encode
(
encrypted
)
;
}
async
_getKeys
(
)
{
const
{
device
}
=
await
this
.
_fxAccounts
.
getSignedInUser
(
)
;
return
device
&
&
device
.
sendTabKeys
;
}
async
_decrypt
(
ciphertext
)
{
let
{
privateKey
publicKey
authSecret
}
=
await
this
.
_getKeys
(
)
;
publicKey
=
urlsafeBase64Decode
(
publicKey
)
;
authSecret
=
urlsafeBase64Decode
(
authSecret
)
;
ciphertext
=
new
Uint8Array
(
urlsafeBase64Decode
(
ciphertext
)
)
;
return
PushCrypto
.
decrypt
(
privateKey
publicKey
authSecret
{
encoding
:
"
aes128gcm
"
}
ciphertext
)
;
}
async
_generateAndPersistKeys
(
)
{
let
[
publicKey
privateKey
]
=
await
PushCrypto
.
generateKeys
(
)
;
publicKey
=
urlsafeBase64Encode
(
publicKey
)
;
let
authSecret
=
PushCrypto
.
generateAuthenticationSecret
(
)
;
authSecret
=
urlsafeBase64Encode
(
authSecret
)
;
const
sendTabKeys
=
{
publicKey
privateKey
authSecret
}
;
await
this
.
_fxAccounts
.
_withCurrentAccountState
(
async
(
getUserData
updateUserData
)
=
>
{
const
{
device
}
=
await
getUserData
(
)
;
await
updateUserData
(
{
device
:
{
.
.
.
device
sendTabKeys
}
}
)
;
}
)
;
return
sendTabKeys
;
}
async
getEncryptedKey
(
)
{
let
sendTabKeys
=
await
this
.
_getKeys
(
)
;
if
(
!
sendTabKeys
)
{
sendTabKeys
=
await
this
.
_generateAndPersistKeys
(
)
;
}
const
keyToEncrypt
=
{
publicKey
:
sendTabKeys
.
publicKey
authSecret
:
sendTabKeys
.
authSecret
}
;
const
{
kSync
kXCS
}
=
await
this
.
_fxAccounts
.
getSignedInUser
(
)
;
if
(
!
kSync
|
|
!
kXCS
)
{
return
null
;
}
const
wrapper
=
new
CryptoWrapper
(
)
;
wrapper
.
cleartext
=
keyToEncrypt
;
const
keyBundle
=
BulkKeyBundle
.
fromHexKey
(
kSync
)
;
await
wrapper
.
encrypt
(
keyBundle
)
;
return
JSON
.
stringify
(
{
kid
:
kXCS
IV
:
wrapper
.
IV
hmac
:
wrapper
.
hmac
ciphertext
:
wrapper
.
ciphertext
}
)
;
}
}
function
urlsafeBase64Encode
(
buffer
)
{
return
ChromeUtils
.
base64URLEncode
(
new
Uint8Array
(
buffer
)
{
pad
:
false
}
)
;
}
function
urlsafeBase64Decode
(
str
)
{
return
ChromeUtils
.
base64URLDecode
(
str
{
padding
:
"
reject
"
}
)
;
}
