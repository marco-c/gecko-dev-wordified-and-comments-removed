"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
FxAccountsProfile
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsProfileClient
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsProfileClient
.
jsm
"
)
;
this
.
FxAccountsProfile
=
function
(
options
=
{
}
)
{
this
.
_currentFetchPromise
=
null
;
this
.
_cachedAt
=
0
;
this
.
_isNotifying
=
false
;
this
.
fxa
=
options
.
fxa
|
|
fxAccounts
;
this
.
client
=
options
.
profileClient
|
|
new
FxAccountsProfileClient
(
{
fxa
:
this
.
fxa
serverURL
:
options
.
profileServerUrl
}
)
;
Services
.
obs
.
addObserver
(
this
ON_PROFILE_CHANGE_NOTIFICATION
true
)
;
if
(
options
.
channel
)
{
this
.
channel
=
options
.
channel
;
}
}
this
.
FxAccountsProfile
.
prototype
=
{
PROFILE_FRESHNESS_THRESHOLD
:
120000
observe
(
subject
topic
data
)
{
if
(
topic
=
=
ON_PROFILE_CHANGE_NOTIFICATION
&
&
!
this
.
_isNotifying
)
{
log
.
debug
(
"
FxAccountsProfile
observed
profile
change
"
)
;
this
.
_cachedAt
=
0
;
}
}
tearDown
(
)
{
this
.
fxa
=
null
;
this
.
client
=
null
;
Services
.
obs
.
removeObserver
(
this
ON_PROFILE_CHANGE_NOTIFICATION
)
;
}
_notifyProfileChange
(
uid
)
{
this
.
_isNotifying
=
true
;
Services
.
obs
.
notifyObservers
(
null
ON_PROFILE_CHANGE_NOTIFICATION
uid
)
;
this
.
_isNotifying
=
false
;
}
_cacheProfile
(
response
)
{
let
profileCache
=
{
profile
:
response
.
body
etag
:
response
.
etag
}
;
return
this
.
fxa
.
setProfileCache
(
profileCache
)
.
then
(
(
)
=
>
{
return
this
.
fxa
.
getSignedInUser
(
)
;
}
)
.
then
(
userData
=
>
{
log
.
debug
(
"
notifying
profile
changed
for
user
{
uid
}
"
userData
)
;
this
.
_notifyProfileChange
(
userData
.
uid
)
;
return
response
.
body
;
}
)
;
}
_fetchAndCacheProfileInternal
(
)
{
let
onFinally
=
(
)
=
>
{
this
.
_cachedAt
=
Date
.
now
(
)
;
this
.
_currentFetchPromise
=
null
;
}
return
this
.
fxa
.
getProfileCache
(
)
.
then
(
profileCache
=
>
{
const
etag
=
profileCache
?
profileCache
.
etag
:
null
;
return
this
.
client
.
fetchProfile
(
etag
)
;
}
)
.
then
(
response
=
>
{
return
response
?
this
.
_cacheProfile
(
response
)
:
null
;
}
)
.
then
(
body
=
>
{
onFinally
(
)
;
return
body
;
}
err
=
>
{
onFinally
(
)
;
throw
err
;
}
)
;
}
_fetchAndCacheProfile
(
)
{
if
(
!
this
.
_currentFetchPromise
)
{
this
.
_currentFetchPromise
=
this
.
_fetchAndCacheProfileInternal
(
)
;
}
return
this
.
_currentFetchPromise
;
}
getProfile
(
)
{
return
this
.
fxa
.
getProfileCache
(
)
.
then
(
profileCache
=
>
{
if
(
profileCache
)
{
if
(
Date
.
now
(
)
>
this
.
_cachedAt
+
this
.
PROFILE_FRESHNESS_THRESHOLD
)
{
this
.
_fetchAndCacheProfile
(
)
.
catch
(
err
=
>
{
log
.
error
(
"
Background
refresh
of
profile
failed
"
err
)
;
}
)
;
}
else
{
log
.
trace
(
"
not
checking
freshness
of
profile
as
it
remains
recent
"
)
;
}
return
profileCache
.
profile
;
}
return
this
.
_fetchAndCacheProfile
(
)
;
}
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
