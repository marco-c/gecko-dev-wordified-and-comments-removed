const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
function
FxAccountsPushService
(
options
=
{
}
)
{
this
.
log
=
log
;
if
(
options
.
log
)
{
this
.
log
=
options
.
log
;
}
this
.
log
.
debug
(
"
FxAccountsPush
loading
service
"
)
;
this
.
wrappedJSObject
=
this
;
this
.
initialize
(
options
)
;
}
FxAccountsPushService
.
prototype
=
{
_initialized
:
false
pushService
:
null
fxAccounts
:
null
classID
:
Components
.
ID
(
"
{
1b7db999
-
2ecd
-
4abf
-
bb95
-
a726896798ca
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
initialize
(
options
)
{
if
(
this
.
_initialized
)
{
return
false
;
}
this
.
_initialized
=
true
;
if
(
options
.
pushService
)
{
this
.
pushService
=
options
.
pushService
;
}
else
{
this
.
pushService
=
Cc
[
"
mozilla
.
org
/
push
/
Service
;
1
"
]
.
getService
(
Ci
.
nsIPushService
)
;
}
if
(
options
.
fxAccounts
)
{
this
.
fxAccounts
=
options
.
fxAccounts
;
}
else
{
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
}
Services
.
obs
.
addObserver
(
this
this
.
pushService
.
pushTopic
false
)
;
Services
.
obs
.
addObserver
(
this
this
.
pushService
.
subscriptionChangeTopic
false
)
;
Services
.
obs
.
addObserver
(
this
ONLOGOUT_NOTIFICATION
false
)
;
this
.
log
.
debug
(
"
FxAccountsPush
initialized
"
)
;
}
registerPushEndpoint
(
)
{
this
.
log
.
trace
(
"
FxAccountsPush
registerPushEndpoint
"
)
;
return
new
Promise
(
(
resolve
)
=
>
{
this
.
pushService
.
subscribe
(
FXA_PUSH_SCOPE_ACCOUNT_UPDATE
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
(
result
subscription
)
=
>
{
if
(
Components
.
isSuccessCode
(
result
)
)
{
this
.
log
.
debug
(
"
FxAccountsPush
got
subscription
"
)
;
resolve
(
subscription
)
;
}
else
{
this
.
log
.
warn
(
"
FxAccountsPush
failed
to
subscribe
"
result
)
;
resolve
(
null
)
;
}
}
)
;
}
)
;
}
_observe
(
subject
topic
data
)
{
this
.
log
.
trace
(
observed
topic
=
{
topic
}
data
=
{
data
}
subject
=
{
subject
}
)
;
switch
(
topic
)
{
case
this
.
pushService
.
pushTopic
:
if
(
data
=
=
=
FXA_PUSH_SCOPE_ACCOUNT_UPDATE
)
{
let
message
=
subject
.
QueryInterface
(
Ci
.
nsIPushMessage
)
;
return
this
.
_onPushMessage
(
message
)
;
}
break
;
case
this
.
pushService
.
subscriptionChangeTopic
:
if
(
data
=
=
=
FXA_PUSH_SCOPE_ACCOUNT_UPDATE
)
{
return
this
.
_onPushSubscriptionChange
(
)
;
}
break
;
case
ONLOGOUT_NOTIFICATION
:
return
this
.
unsubscribe
(
)
.
catch
(
err
=
>
{
this
.
log
.
error
(
"
Error
during
unsubscribe
"
err
)
;
}
)
;
break
;
default
:
break
;
}
}
observe
(
subject
topic
data
)
{
Promise
.
resolve
(
)
.
then
(
(
)
=
>
this
.
_observe
(
subject
topic
data
)
)
.
catch
(
err
=
>
this
.
log
.
error
(
err
)
)
;
}
_onPushMessage
(
message
)
{
this
.
log
.
trace
(
"
FxAccountsPushService
_onPushMessage
"
)
;
if
(
!
message
.
data
)
{
this
.
log
.
debug
(
"
empty
push
message
-
checking
account
status
"
)
;
return
this
.
fxAccounts
.
checkVerificationStatus
(
)
;
}
let
payload
=
message
.
data
.
json
(
)
;
this
.
log
.
debug
(
push
command
:
{
payload
.
command
}
)
;
switch
(
payload
.
command
)
{
case
ON_DEVICE_DISCONNECTED_NOTIFICATION
:
return
this
.
fxAccounts
.
handleDeviceDisconnection
(
payload
.
data
.
id
)
;
break
;
case
ON_PASSWORD_CHANGED_NOTIFICATION
:
case
ON_PASSWORD_RESET_NOTIFICATION
:
return
this
.
_onPasswordChanged
(
)
;
break
;
case
ON_COLLECTION_CHANGED_NOTIFICATION
:
Services
.
obs
.
notifyObservers
(
null
ON_COLLECTION_CHANGED_NOTIFICATION
payload
.
data
.
collections
)
;
default
:
this
.
log
.
warn
(
"
FxA
Push
command
unrecognized
:
"
+
payload
.
command
)
;
}
}
_onPasswordChanged
:
Task
.
async
(
function
*
(
)
{
if
(
!
(
yield
this
.
fxAccounts
.
sessionStatus
(
)
)
)
{
yield
this
.
fxAccounts
.
resetCredentials
(
)
;
Services
.
obs
.
notifyObservers
(
null
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
null
)
;
}
}
)
_onPushSubscriptionChange
(
)
{
this
.
log
.
trace
(
"
FxAccountsPushService
_onPushSubscriptionChange
"
)
;
return
this
.
fxAccounts
.
updateDeviceRegistration
(
)
;
}
unsubscribe
(
)
{
this
.
log
.
trace
(
"
FxAccountsPushService
unsubscribe
"
)
;
return
new
Promise
(
(
resolve
)
=
>
{
this
.
pushService
.
unsubscribe
(
FXA_PUSH_SCOPE_ACCOUNT_UPDATE
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
(
result
ok
)
=
>
{
if
(
Components
.
isSuccessCode
(
result
)
)
{
if
(
ok
=
=
=
true
)
{
this
.
log
.
debug
(
"
FxAccountsPushService
unsubscribed
"
)
;
}
else
{
this
.
log
.
debug
(
"
FxAccountsPushService
had
no
subscription
to
unsubscribe
"
)
;
}
}
else
{
this
.
log
.
warn
(
"
FxAccountsPushService
failed
to
unsubscribe
"
result
)
;
}
return
resolve
(
ok
)
;
}
)
;
}
)
;
}
}
;
const
components
=
[
FxAccountsPushService
]
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
components
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
FxAccountsPushService
"
]
;
