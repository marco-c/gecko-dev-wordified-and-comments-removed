"
use
strict
"
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsClient
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsOAuthGrantClient
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
var
{
AccountState
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
{
}
)
;
const
ONE_HOUR_MS
=
1000
*
60
*
60
;
const
ONE_DAY_MS
=
ONE_HOUR_MS
*
24
;
const
TWO_MINUTES_MS
=
1000
*
60
*
2
;
initTestLogging
(
"
Trace
"
)
;
Cu
.
importGlobalProperties
(
[
"
atob
"
]
)
;
var
log
=
Log
.
repository
.
getLogger
(
"
Services
.
FxAccounts
.
test
"
)
;
log
.
level
=
Log
.
Level
.
Debug
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
loglevel
"
"
Trace
"
)
;
Log
.
repository
.
getLogger
(
"
FirefoxAccounts
"
)
.
level
=
Log
.
Level
.
Trace
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
"
https
:
/
/
example
.
com
/
v1
"
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
oauth
.
client_id
"
"
abc123
"
)
;
const
PROFILE_SERVER_URL
=
"
http
:
/
/
example
.
com
/
v1
"
;
const
CONTENT_URL
=
"
http
:
/
/
accounts
.
example
.
com
/
"
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
profile
.
uri
"
PROFILE_SERVER_URL
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
settings
.
uri
"
CONTENT_URL
)
;
function
MockStorageManager
(
)
{
}
MockStorageManager
.
prototype
=
{
promiseInitialized
:
Promise
.
resolve
(
)
initialize
(
accountData
)
{
this
.
accountData
=
accountData
;
}
finalize
(
)
{
return
Promise
.
resolve
(
)
;
}
getAccountData
(
)
{
return
Promise
.
resolve
(
this
.
accountData
)
;
}
updateAccountData
(
updatedFields
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
updatedFields
)
)
{
if
(
value
=
=
null
)
{
delete
this
.
accountData
[
name
]
;
}
else
{
this
.
accountData
[
name
]
=
value
;
}
}
return
Promise
.
resolve
(
)
;
}
deleteAccountData
(
)
{
this
.
accountData
=
null
;
return
Promise
.
resolve
(
)
;
}
}
function
MockFxAccountsClient
(
)
{
this
.
_email
=
"
nobody
example
.
com
"
;
this
.
_verified
=
false
;
this
.
_deletedOnServer
=
false
;
this
.
recoveryEmailStatus
=
function
(
sessionToken
)
{
return
Promise
.
resolve
(
{
email
:
this
.
_email
verified
:
this
.
_verified
}
)
;
}
;
this
.
accountStatus
=
function
(
uid
)
{
let
deferred
=
Promise
.
defer
(
)
;
deferred
.
resolve
(
!
!
uid
&
&
(
!
this
.
_deletedOnServer
)
)
;
return
deferred
.
promise
;
}
;
this
.
accountKeys
=
function
(
keyFetchToken
)
{
let
deferred
=
Promise
.
defer
(
)
;
do_timeout
(
50
(
)
=
>
{
let
response
=
{
kA
:
expandBytes
(
"
11
"
)
wrapKB
:
expandBytes
(
"
22
"
)
}
;
deferred
.
resolve
(
response
)
;
}
)
;
return
deferred
.
promise
;
}
;
this
.
resendVerificationEmail
=
function
(
sessionToken
)
{
return
Promise
.
resolve
(
sessionToken
)
;
}
;
this
.
signCertificate
=
function
(
)
{
throw
"
no
"
}
;
this
.
signOut
=
(
)
=
>
Promise
.
resolve
(
)
;
this
.
signOutAndDestroyDevice
=
(
)
=
>
Promise
.
resolve
(
{
}
)
;
FxAccountsClient
.
apply
(
this
)
;
}
MockFxAccountsClient
.
prototype
=
{
__proto__
:
FxAccountsClient
.
prototype
}
function
MockFxAccounts
(
)
{
return
new
FxAccounts
(
{
VERIFICATION_POLL_TIMEOUT_INITIAL
:
100
_getCertificateSigned_calls
:
[
]
_d_signCertificate
:
Promise
.
defer
(
)
_now_is
:
new
Date
(
)
now
(
)
{
return
this
.
_now_is
;
}
newAccountState
(
credentials
)
{
let
storage
=
new
MockStorageManager
(
)
;
storage
.
initialize
(
credentials
)
;
return
new
AccountState
(
storage
)
;
}
getCertificateSigned
(
sessionToken
serializedPublicKey
)
{
_
(
"
mock
getCertificateSigned
\
n
"
)
;
this
.
_getCertificateSigned_calls
.
push
(
[
sessionToken
serializedPublicKey
]
)
;
return
this
.
_d_signCertificate
.
promise
;
}
_registerOrUpdateDevice
(
)
{
return
Promise
.
resolve
(
)
;
}
fxAccountsClient
:
new
MockFxAccountsClient
(
)
}
)
;
}
function
MakeFxAccounts
(
internal
=
{
}
)
{
if
(
!
internal
.
newAccountState
)
{
internal
.
newAccountState
=
function
(
credentials
)
{
let
storage
=
new
MockStorageManager
(
)
;
storage
.
initialize
(
credentials
)
;
return
new
AccountState
(
storage
)
;
}
;
}
if
(
!
internal
.
_signOutServer
)
{
internal
.
_signOutServer
=
(
)
=
>
Promise
.
resolve
(
)
;
}
if
(
!
internal
.
_registerOrUpdateDevice
)
{
internal
.
_registerOrUpdateDevice
=
(
)
=
>
Promise
.
resolve
(
)
;
}
return
new
FxAccounts
(
internal
)
;
}
add_task
(
function
*
test_non_https_remote_server_uri_with_requireHttps_false
(
)
{
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
allowHttp
"
true
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
signup
.
uri
"
"
http
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
accounts_testRemoteCommands
.
html
"
)
;
do_check_eq
(
yield
fxAccounts
.
promiseAccountsSignUpURI
(
)
"
http
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
accounts_testRemoteCommands
.
html
"
)
;
Services
.
prefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
remote
.
signup
.
uri
"
)
;
Services
.
prefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
allowHttp
"
)
;
}
)
;
add_task
(
function
*
test_non_https_remote_server_uri
(
)
{
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
signup
.
uri
"
"
http
:
/
/
example
.
com
/
browser
/
browser
/
base
/
content
/
test
/
general
/
accounts_testRemoteCommands
.
html
"
)
;
rejects
(
fxAccounts
.
promiseAccountsSignUpURI
(
)
null
"
Firefox
Accounts
server
must
use
HTTPS
"
)
;
Services
.
prefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
remote
.
signup
.
uri
"
)
;
}
)
;
add_task
(
function
*
test_get_signed_in_user_initially_unset
(
)
{
_
(
"
Check
getSignedInUser
initially
and
after
signout
reports
no
user
"
)
;
let
account
=
MakeFxAccounts
(
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
assertion
:
"
foobar
"
sessionToken
:
"
dead
"
kA
:
"
beef
"
kB
:
"
cafe
"
verified
:
true
}
;
let
result
=
yield
account
.
getSignedInUser
(
)
;
do_check_eq
(
result
null
)
;
yield
account
.
setSignedInUser
(
credentials
)
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
"
FXA_CONFIGURED
"
)
;
do_check_eq
(
histogram
.
snapshot
(
)
.
sum
1
)
;
histogram
.
clear
(
)
;
result
=
yield
account
.
getSignedInUser
(
)
;
do_check_eq
(
result
.
email
credentials
.
email
)
;
do_check_eq
(
result
.
assertion
credentials
.
assertion
)
;
do_check_eq
(
result
.
kB
credentials
.
kB
)
;
delete
account
.
internal
.
signedInUser
;
result
=
yield
account
.
getSignedInUser
(
)
;
do_check_eq
(
result
.
email
credentials
.
email
)
;
do_check_eq
(
result
.
assertion
credentials
.
assertion
)
;
do_check_eq
(
result
.
kB
credentials
.
kB
)
;
let
localOnly
=
true
;
yield
account
.
signOut
(
localOnly
)
;
result
=
yield
account
.
getSignedInUser
(
)
;
do_check_eq
(
result
null
)
;
}
)
;
add_task
(
function
*
test_update_account_data
(
)
{
_
(
"
Check
updateUserAccountData
does
the
right
thing
.
"
)
;
let
account
=
MakeFxAccounts
(
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
assertion
:
"
foobar
"
sessionToken
:
"
dead
"
kA
:
"
beef
"
kB
:
"
cafe
"
verified
:
true
}
;
yield
account
.
setSignedInUser
(
credentials
)
;
let
newCreds
=
{
email
:
credentials
.
email
uid
:
credentials
.
uid
assertion
:
"
new_assertion
"
}
yield
account
.
updateUserAccountData
(
newCreds
)
;
do_check_eq
(
(
yield
account
.
getSignedInUser
(
)
)
.
assertion
"
new_assertion
"
"
new
field
value
was
saved
"
)
;
newCreds
=
{
email
:
"
someoneelse
example
.
com
"
uid
:
credentials
.
uid
assertion
:
"
new_assertion
"
}
yield
Assert
.
rejects
(
account
.
updateUserAccountData
(
newCreds
)
)
;
newCreds
=
{
email
:
credentials
.
email
uid
:
"
another_uid
"
assertion
:
"
new_assertion
"
}
yield
Assert
.
rejects
(
account
.
updateUserAccountData
(
newCreds
)
)
;
newCreds
=
{
assertion
:
"
new_assertion
"
}
yield
Assert
.
rejects
(
account
.
updateUserAccountData
(
newCreds
)
)
;
newCreds
=
{
email
:
credentials
.
email
uid
:
"
another_uid
"
foo
:
"
bar
"
}
yield
Assert
.
rejects
(
account
.
updateUserAccountData
(
newCreds
)
)
;
}
)
;
add_task
(
function
*
test_getCertificateOffline
(
)
{
_
(
"
getCertificateOffline
(
)
"
)
;
let
fxa
=
MakeFxAccounts
(
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
sessionToken
:
"
dead
"
verified
:
true
}
;
yield
fxa
.
setSignedInUser
(
credentials
)
;
let
offline
=
Services
.
io
.
offline
;
Services
.
io
.
offline
=
true
;
yield
fxa
.
internal
.
getKeypairAndCertificate
(
fxa
.
internal
.
currentAccountState
)
.
then
(
result
=
>
{
Services
.
io
.
offline
=
offline
;
do_throw
(
"
Unexpected
success
"
)
;
}
err
=
>
{
Services
.
io
.
offline
=
offline
;
do_check_eq
(
err
"
Error
:
OFFLINE
"
)
;
}
)
;
yield
fxa
.
signOut
(
true
)
;
}
)
;
add_task
(
function
*
test_getCertificateCached
(
)
{
_
(
"
getCertificateCached
(
)
"
)
;
let
fxa
=
MakeFxAccounts
(
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
sessionToken
:
"
dead
"
verified
:
true
keyPair
:
{
validUntil
:
Date
.
now
(
)
+
KEY_LIFETIME
+
10000
rawKeyPair
:
"
good
-
keypair
"
}
cert
:
{
validUntil
:
Date
.
now
(
)
+
CERT_LIFETIME
+
10000
rawCert
:
"
good
-
cert
"
}
}
;
yield
fxa
.
setSignedInUser
(
credentials
)
;
let
{
keyPair
certificate
}
=
yield
fxa
.
internal
.
getKeypairAndCertificate
(
fxa
.
internal
.
currentAccountState
)
;
do_check_eq
(
keyPair
credentials
.
keyPair
.
rawKeyPair
)
;
do_check_eq
(
certificate
credentials
.
cert
.
rawCert
)
;
yield
fxa
.
signOut
(
true
)
;
}
)
;
add_task
(
function
*
test_getCertificateExpiredCert
(
)
{
_
(
"
getCertificateExpiredCert
(
)
"
)
;
let
fxa
=
MakeFxAccounts
(
{
getCertificateSigned
(
)
{
return
"
new
cert
"
;
}
}
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
sessionToken
:
"
dead
"
verified
:
true
keyPair
:
{
validUntil
:
Date
.
now
(
)
+
KEY_LIFETIME
+
10000
rawKeyPair
:
"
good
-
keypair
"
}
cert
:
{
validUntil
:
Date
.
parse
(
"
Mon
13
Jan
2000
21
:
45
:
06
GMT
"
)
rawCert
:
"
expired
-
cert
"
}
}
;
yield
fxa
.
setSignedInUser
(
credentials
)
;
let
{
keyPair
certificate
}
=
yield
fxa
.
internal
.
getKeypairAndCertificate
(
fxa
.
internal
.
currentAccountState
)
;
do_check_eq
(
keyPair
credentials
.
keyPair
.
rawKeyPair
)
;
do_check_neq
(
certificate
credentials
.
cert
.
rawCert
)
;
yield
fxa
.
signOut
(
true
)
;
}
)
;
add_task
(
function
*
test_getCertificateExpiredKeypair
(
)
{
_
(
"
getCertificateExpiredKeypair
(
)
"
)
;
let
fxa
=
MakeFxAccounts
(
{
getCertificateSigned
(
)
{
return
"
new
cert
"
;
}
}
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
sessionToken
:
"
dead
"
verified
:
true
keyPair
:
{
validUntil
:
Date
.
now
(
)
-
1000
rawKeyPair
:
"
expired
-
keypair
"
}
cert
:
{
validUntil
:
Date
.
now
(
)
+
CERT_LIFETIME
+
10000
rawCert
:
"
expired
-
cert
"
}
}
;
yield
fxa
.
setSignedInUser
(
credentials
)
;
let
{
keyPair
certificate
}
=
yield
fxa
.
internal
.
getKeypairAndCertificate
(
fxa
.
internal
.
currentAccountState
)
;
do_check_neq
(
keyPair
credentials
.
keyPair
.
rawKeyPair
)
;
do_check_neq
(
certificate
credentials
.
cert
.
rawCert
)
;
yield
fxa
.
signOut
(
true
)
;
}
)
;
add_test
(
function
test_client_mock
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
do_check_eq
(
client
.
_verified
false
)
;
do_check_eq
(
typeof
client
.
signIn
"
function
"
)
;
client
.
recoveryEmailStatus
(
)
.
then
(
response
=
>
{
do_check_eq
(
response
.
verified
false
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_verification_poll
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
francine
"
)
;
let
login_notification_received
=
false
;
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_verification_poll
observed
onverified
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
do_check_eq
(
user
.
verified
true
)
;
do_check_eq
(
user
.
email
test_user
.
email
)
;
do_check_true
(
login_notification_received
)
;
run_next_test
(
)
;
}
)
;
}
)
;
makeObserver
(
ONLOGIN_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_verification_poll
observer
onlogin
"
)
;
login_notification_received
=
true
;
}
)
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
do_check_eq
(
user
.
verified
false
)
;
do_timeout
(
200
function
(
)
{
log
.
debug
(
"
Mocking
verification
of
francine
'
s
email
"
)
;
fxa
.
internal
.
fxAccountsClient
.
_email
=
test_user
.
email
;
fxa
.
internal
.
fxAccountsClient
.
_verified
=
true
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_polling_timeout
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
let
removeObserver
=
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
do_throw
(
"
We
should
not
be
getting
a
login
event
!
"
)
;
}
)
;
fxa
.
internal
.
POLL_SESSION
=
1
;
let
p
=
fxa
.
internal
.
whenVerified
(
{
}
)
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
p
.
then
(
(
success
)
=
>
{
do_throw
(
"
this
should
not
succeed
"
)
;
}
(
fail
)
=
>
{
removeObserver
(
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getKeys
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
eusebius
"
)
;
user
.
verified
=
true
;
fxa
.
setSignedInUser
(
user
)
.
then
(
(
)
=
>
{
fxa
.
getSignedInUser
(
)
.
then
(
(
user
)
=
>
{
do_check_eq
(
!
!
user
.
kA
false
)
;
do_check_eq
(
!
!
user
.
kB
false
)
;
do_check_eq
(
!
!
user
.
keyFetchToken
true
)
;
do_check_eq
(
!
!
user
.
unwrapBKey
true
)
;
fxa
.
internal
.
getKeys
(
)
.
then
(
(
)
=
>
{
fxa
.
getSignedInUser
(
)
.
then
(
(
user
)
=
>
{
do_check_eq
(
fxa
.
internal
.
isUserEmailVerified
(
user
)
true
)
;
do_check_eq
(
!
!
user
.
verified
true
)
;
do_check_eq
(
user
.
kA
expandHex
(
"
11
"
)
)
;
do_check_eq
(
user
.
kB
expandHex
(
"
66
"
)
)
;
do_check_eq
(
user
.
keyFetchToken
undefined
)
;
do_check_eq
(
user
.
unwrapBKey
undefined
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
function
*
test_getKeys_nonexistent_account
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
bismarck
=
getTestUser
(
"
bismarck
"
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
false
)
;
client
.
accountKeys
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
yield
fxa
.
setSignedInUser
(
bismarck
)
;
let
promiseLogout
=
new
Promise
(
resolve
=
>
{
makeObserver
(
ONLOGOUT_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_getKeys_nonexistent_account
observed
logout
"
)
;
resolve
(
)
;
}
)
;
}
)
;
try
{
yield
fxa
.
internal
.
getKeys
(
)
;
do_check_true
(
false
)
;
}
catch
(
err
)
{
do_check_eq
(
err
.
code
401
)
;
do_check_eq
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
yield
promiseLogout
;
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
null
)
;
}
)
;
add_task
(
function
*
test_getKeys_invalid_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
yusuf
=
getTestUser
(
"
yusuf
"
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
client
.
accountKeys
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
yield
fxa
.
setSignedInUser
(
yusuf
)
;
try
{
yield
fxa
.
internal
.
getKeys
(
)
;
do_check_true
(
false
)
;
}
catch
(
err
)
{
do_check_eq
(
err
.
code
401
)
;
do_check_eq
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
.
email
yusuf
.
email
)
;
do_check_eq
(
user
.
keyFetchToken
null
)
;
}
)
;
add_test
(
function
test_fetchAndUnwrapKeys_no_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
lettuce
.
protheroe
"
)
;
delete
user
.
keyFetchToken
makeObserver
(
ONLOGOUT_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_fetchAndUnwrapKeys_no_token
observed
logout
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
run_next_test
(
)
;
}
)
;
}
)
;
fxa
.
setSignedInUser
(
user
)
.
then
(
user
=
>
{
return
fxa
.
internal
.
fetchAndUnwrapKeys
(
)
;
}
)
.
then
(
null
error
=
>
{
log
.
info
(
"
setSignedInUser
correctly
rejected
"
)
;
}
)
}
)
;
add_test
(
function
test_overlapping_signins
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
let
bob
=
getTestUser
(
"
bob
"
)
;
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_overlapping_signins
observed
onverified
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
do_check_eq
(
user
.
email
bob
.
email
)
;
do_check_eq
(
user
.
verified
true
)
;
run_next_test
(
)
;
}
)
;
}
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
log
.
debug
(
"
Alice
signing
in
.
.
.
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
do_check_eq
(
user
.
email
alice
.
email
)
;
do_check_eq
(
user
.
verified
false
)
;
log
.
debug
(
"
Alice
has
not
verified
her
email
.
.
.
"
)
;
log
.
debug
(
"
Bob
signing
in
.
.
.
"
)
;
fxa
.
setSignedInUser
(
bob
)
.
then
(
(
)
=
>
{
do_timeout
(
200
function
(
)
{
log
.
debug
(
"
Bob
verifying
his
email
.
.
.
"
)
;
fxa
.
internal
.
fxAccountsClient
.
_verified
=
true
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
function
*
test_getAssertion_invalid_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
let
creds
=
{
sessionToken
:
"
sessionToken
"
kA
:
expandHex
(
"
11
"
)
kB
:
expandHex
(
"
66
"
)
verified
:
true
email
:
"
sonia
example
.
com
"
}
;
yield
fxa
.
setSignedInUser
(
creds
)
;
try
{
let
promiseAssertion
=
fxa
.
getAssertion
(
"
audience
.
example
.
com
"
)
;
fxa
.
internal
.
_d_signCertificate
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
yield
promiseAssertion
;
do_check_true
(
false
"
getAssertion
should
reject
invalid
session
token
"
)
;
}
catch
(
err
)
{
do_check_eq
(
err
.
code
401
)
;
do_check_eq
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
.
email
creds
.
email
)
;
do_check_eq
(
user
.
sessionToken
null
)
;
}
)
;
add_task
(
function
*
test_getAssertion
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
do_check_throws
(
function
*
(
)
{
yield
fxa
.
getAssertion
(
"
nonaudience
"
)
;
}
)
;
let
creds
=
{
sessionToken
:
"
sessionToken
"
kA
:
expandHex
(
"
11
"
)
kB
:
expandHex
(
"
66
"
)
verified
:
true
}
;
yield
fxa
.
setSignedInUser
(
creds
)
;
_
(
"
=
=
ready
to
go
\
n
"
)
;
let
now
=
Date
.
parse
(
"
Mon
13
Jan
2014
21
:
45
:
06
GMT
"
)
;
let
start
=
now
;
fxa
.
internal
.
_now_is
=
now
;
let
d
=
fxa
.
getAssertion
(
"
audience
.
example
.
com
"
)
;
_
(
"
-
-
back
from
fxa
.
getAssertion
\
n
"
)
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
assertion
=
yield
d
;
do_check_eq
(
fxa
.
internal
.
_getCertificateSigned_calls
.
length
1
)
;
do_check_eq
(
fxa
.
internal
.
_getCertificateSigned_calls
[
0
]
[
0
]
"
sessionToken
"
)
;
do_check_neq
(
assertion
null
)
;
_
(
"
ASSERTION
:
"
+
assertion
+
"
\
n
"
)
;
let
pieces
=
assertion
.
split
(
"
~
"
)
;
do_check_eq
(
pieces
[
0
]
"
cert1
"
)
;
let
userData
=
yield
fxa
.
getSignedInUser
(
)
;
let
keyPair
=
userData
.
keyPair
;
let
cert
=
userData
.
cert
;
do_check_neq
(
keyPair
undefined
)
;
_
(
keyPair
.
validUntil
+
"
\
n
"
)
;
let
p2
=
pieces
[
1
]
.
split
(
"
.
"
)
;
let
header
=
JSON
.
parse
(
atob
(
p2
[
0
]
)
)
;
_
(
"
HEADER
:
"
+
JSON
.
stringify
(
header
)
+
"
\
n
"
)
;
do_check_eq
(
header
.
alg
"
DS128
"
)
;
let
payload
=
JSON
.
parse
(
atob
(
p2
[
1
]
)
)
;
_
(
"
PAYLOAD
:
"
+
JSON
.
stringify
(
payload
)
+
"
\
n
"
)
;
do_check_eq
(
payload
.
aud
"
audience
.
example
.
com
"
)
;
do_check_eq
(
keyPair
.
validUntil
start
+
KEY_LIFETIME
)
;
do_check_eq
(
cert
.
validUntil
start
+
CERT_LIFETIME
)
;
_
(
"
delta
:
"
+
Date
.
parse
(
payload
.
exp
-
start
)
+
"
\
n
"
)
;
let
exp
=
Number
(
payload
.
exp
)
;
do_check_eq
(
exp
now
+
ASSERTION_LIFETIME
)
;
fxa
.
internal
.
_d_signCertificate
=
Promise
.
defer
(
)
;
assertion
=
yield
fxa
.
getAssertion
(
"
other
.
example
.
com
"
)
;
do_check_eq
(
fxa
.
internal
.
_getCertificateSigned_calls
.
length
1
)
;
now
+
=
ONE_HOUR_MS
;
fxa
.
internal
.
_now_is
=
now
;
assertion
=
yield
fxa
.
getAssertion
(
"
third
.
example
.
com
"
)
;
pieces
=
assertion
.
split
(
"
~
"
)
;
do_check_eq
(
pieces
[
0
]
"
cert1
"
)
;
p2
=
pieces
[
1
]
.
split
(
"
.
"
)
;
header
=
JSON
.
parse
(
atob
(
p2
[
0
]
)
)
;
payload
=
JSON
.
parse
(
atob
(
p2
[
1
]
)
)
;
do_check_eq
(
payload
.
aud
"
third
.
example
.
com
"
)
;
userData
=
yield
fxa
.
getSignedInUser
(
)
;
keyPair
=
userData
.
keyPair
;
cert
=
userData
.
cert
;
do_check_eq
(
keyPair
.
validUntil
start
+
KEY_LIFETIME
)
;
do_check_eq
(
cert
.
validUntil
start
+
CERT_LIFETIME
)
;
exp
=
Number
(
payload
.
exp
)
;
do_check_eq
(
exp
now
+
ASSERTION_LIFETIME
)
;
now
+
=
ONE_DAY_MS
;
fxa
.
internal
.
_now_is
=
now
;
d
=
fxa
.
getAssertion
(
"
fourth
.
example
.
com
"
)
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert2
"
)
;
assertion
=
yield
d
;
do_check_eq
(
fxa
.
internal
.
_getCertificateSigned_calls
.
length
2
)
;
do_check_eq
(
fxa
.
internal
.
_getCertificateSigned_calls
[
1
]
[
0
]
"
sessionToken
"
)
;
pieces
=
assertion
.
split
(
"
~
"
)
;
do_check_eq
(
pieces
[
0
]
"
cert2
"
)
;
p2
=
pieces
[
1
]
.
split
(
"
.
"
)
;
header
=
JSON
.
parse
(
atob
(
p2
[
0
]
)
)
;
payload
=
JSON
.
parse
(
atob
(
p2
[
1
]
)
)
;
do_check_eq
(
payload
.
aud
"
fourth
.
example
.
com
"
)
;
userData
=
yield
fxa
.
getSignedInUser
(
)
;
keyPair
=
userData
.
keyPair
;
cert
=
userData
.
cert
;
do_check_eq
(
keyPair
.
validUntil
now
+
KEY_LIFETIME
)
;
do_check_eq
(
cert
.
validUntil
now
+
CERT_LIFETIME
)
;
exp
=
Number
(
payload
.
exp
)
;
do_check_eq
(
exp
now
+
ASSERTION_LIFETIME
)
;
_
(
"
-
-
-
-
-
DONE
-
-
-
-
\
n
"
)
;
}
)
;
add_task
(
function
*
test_resend_email_not_signed_in
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
try
{
yield
fxa
.
resendVerificationEmail
(
)
;
}
catch
(
err
)
{
do_check_eq
(
err
.
message
"
Cannot
resend
verification
email
;
no
signed
-
in
user
"
)
;
return
;
}
do_throw
(
"
Should
not
be
able
to
resend
email
when
nobody
is
signed
in
"
)
;
}
)
;
add_test
(
function
test_accountStatus
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
fxa
.
accountStatus
(
)
.
then
(
(
result
)
=
>
{
do_check_false
(
result
)
;
}
)
.
then
(
(
)
=
>
{
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
accountStatus
(
)
.
then
(
(
result
)
=
>
{
do_check_true
(
result
)
;
fxa
.
internal
.
fxAccountsClient
.
_deletedOnServer
=
true
;
fxa
.
accountStatus
(
)
.
then
(
(
result
)
=
>
{
do_check_false
(
result
)
;
fxa
.
internal
.
fxAccountsClient
.
_deletedOnServer
=
false
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
}
)
;
}
)
;
}
)
;
add_task
(
function
*
test_resend_email_invalid_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
sophia
=
getTestUser
(
"
sophia
"
)
;
do_check_neq
(
sophia
.
sessionToken
null
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
resendVerificationEmail
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
yield
fxa
.
setSignedInUser
(
sophia
)
;
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
.
email
sophia
.
email
)
;
do_check_eq
(
user
.
verified
false
)
;
log
.
debug
(
"
Sophia
wants
verification
email
resent
"
)
;
try
{
yield
fxa
.
resendVerificationEmail
(
)
;
do_check_true
(
false
"
resendVerificationEmail
should
reject
invalid
session
token
"
)
;
}
catch
(
err
)
{
do_check_eq
(
err
.
code
401
)
;
do_check_eq
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
.
email
sophia
.
email
)
;
do_check_eq
(
user
.
sessionToken
null
)
;
}
)
;
add_test
(
function
test_resend_email
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
let
initialState
=
fxa
.
internal
.
currentAccountState
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
log
.
debug
(
"
Alice
signing
in
"
)
;
do_check_true
(
fxa
.
internal
.
currentAccountState
!
=
=
initialState
)
;
let
aliceState
=
fxa
.
internal
.
currentAccountState
;
do_check_true
(
fxa
.
internal
.
currentTimer
>
0
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
do_check_eq
(
user
.
email
alice
.
email
)
;
do_check_eq
(
user
.
verified
false
)
;
log
.
debug
(
"
Alice
wants
verification
email
resent
"
)
;
fxa
.
resendVerificationEmail
(
)
.
then
(
(
result
)
=
>
{
do_check_eq
(
result
"
alice
'
s
session
token
"
)
;
do_check_true
(
fxa
.
internal
.
currentAccountState
=
=
=
aliceState
)
;
do_check_true
(
fxa
.
internal
.
currentTimer
>
0
)
;
fxa
.
internal
.
abortExistingFlow
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
function
*
test_sign_out_with_device
(
)
{
const
fxa
=
new
MockFxAccounts
(
)
;
const
credentials
=
getTestUser
(
"
alice
"
)
;
yield
fxa
.
internal
.
setSignedInUser
(
credentials
)
;
const
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_true
(
user
)
;
Object
.
keys
(
credentials
)
.
forEach
(
key
=
>
do_check_eq
(
credentials
[
key
]
user
[
key
]
)
)
;
const
spy
=
{
signOut
:
{
count
:
0
}
signOutAndDeviceDestroy
:
{
count
:
0
args
:
[
]
}
}
;
const
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
signOut
=
function
(
)
{
spy
.
signOut
.
count
+
=
1
;
return
Promise
.
resolve
(
)
;
}
;
client
.
signOutAndDestroyDevice
=
function
(
)
{
spy
.
signOutAndDeviceDestroy
.
count
+
=
1
;
spy
.
signOutAndDeviceDestroy
.
args
.
push
(
arguments
)
;
return
Promise
.
resolve
(
)
;
}
;
const
promise
=
new
Promise
(
resolve
=
>
{
makeObserver
(
ONLOGOUT_NOTIFICATION
(
)
=
>
{
log
.
debug
(
"
test_sign_out_with_device
observed
onlogout
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user2
=
>
{
do_check_eq
(
user2
null
)
;
do_check_eq
(
spy
.
signOut
.
count
0
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
count
1
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
args
[
0
]
.
length
3
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
args
[
0
]
[
0
]
credentials
.
sessionToken
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
args
[
0
]
[
1
]
credentials
.
deviceId
)
;
do_check_true
(
spy
.
signOutAndDeviceDestroy
.
args
[
0
]
[
2
]
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
args
[
0
]
[
2
]
.
service
"
sync
"
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
yield
fxa
.
signOut
(
)
;
yield
promise
;
}
)
;
add_task
(
function
*
test_sign_out_without_device
(
)
{
const
fxa
=
new
MockFxAccounts
(
)
;
const
credentials
=
getTestUser
(
"
alice
"
)
;
delete
credentials
.
deviceId
;
yield
fxa
.
internal
.
setSignedInUser
(
credentials
)
;
const
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
const
spy
=
{
signOut
:
{
count
:
0
args
:
[
]
}
signOutAndDeviceDestroy
:
{
count
:
0
}
}
;
const
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
signOut
=
function
(
)
{
spy
.
signOut
.
count
+
=
1
;
spy
.
signOut
.
args
.
push
(
arguments
)
;
return
Promise
.
resolve
(
)
;
}
;
client
.
signOutAndDestroyDevice
=
function
(
)
{
spy
.
signOutAndDeviceDestroy
.
count
+
=
1
;
return
Promise
.
resolve
(
)
;
}
;
const
promise
=
new
Promise
(
resolve
=
>
{
makeObserver
(
ONLOGOUT_NOTIFICATION
(
)
=
>
{
log
.
debug
(
"
test_sign_out_without_device
observed
onlogout
"
)
;
fxa
.
internal
.
getUserAccountData
(
)
.
then
(
user2
=
>
{
do_check_eq
(
user2
null
)
;
do_check_eq
(
spy
.
signOut
.
count
1
)
;
do_check_eq
(
spy
.
signOut
.
args
[
0
]
.
length
2
)
;
do_check_eq
(
spy
.
signOut
.
args
[
0
]
[
0
]
credentials
.
sessionToken
)
;
do_check_true
(
spy
.
signOut
.
args
[
0
]
[
1
]
)
;
do_check_eq
(
spy
.
signOut
.
args
[
0
]
[
1
]
.
service
"
sync
"
)
;
do_check_eq
(
spy
.
signOutAndDeviceDestroy
.
count
0
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
yield
fxa
.
signOut
(
)
;
yield
promise
;
}
)
;
add_task
(
function
*
test_sign_out_with_remote_error
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
let
remoteSignOutCalled
=
false
;
client
.
signOutAndDestroyDevice
=
function
(
)
{
remoteSignOutCalled
=
true
;
throw
"
Remote
sign
out
error
"
;
}
;
let
promiseLogout
=
new
Promise
(
resolve
=
>
{
makeObserver
(
ONLOGOUT_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_sign_out_with_remote_error
observed
onlogout
"
)
;
resolve
(
)
;
}
)
;
}
)
;
let
jane
=
getTestUser
(
"
jane
"
)
;
yield
fxa
.
setSignedInUser
(
jane
)
;
yield
fxa
.
signOut
(
)
;
yield
promiseLogout
;
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
null
)
;
do_check_true
(
remoteSignOutCalled
)
;
}
)
;
add_test
(
function
test_getOAuthToken
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
getTokenFromAssertionCalled
=
false
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
getTokenFromAssertionCalled
=
true
;
return
Promise
.
resolve
(
{
access_token
:
"
token
"
}
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
}
)
.
then
(
(
result
)
=
>
{
do_check_true
(
getTokenFromAssertionCalled
)
;
do_check_eq
(
result
"
token
"
)
;
run_next_test
(
)
;
}
)
}
)
;
}
)
;
add_test
(
function
test_getOAuthTokenScoped
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
getTokenFromAssertionCalled
=
false
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
assertion
scopeString
)
{
equal
(
scopeString
"
foo
bar
"
)
;
getTokenFromAssertionCalled
=
true
;
return
Promise
.
resolve
(
{
access_token
:
"
token
"
}
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
]
client
}
)
.
then
(
(
result
)
=
>
{
do_check_true
(
getTokenFromAssertionCalled
)
;
do_check_eq
(
result
"
token
"
)
;
run_next_test
(
)
;
}
)
}
)
;
}
)
;
add_task
(
function
*
test_getOAuthTokenCached
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
numTokenFromAssertionCalls
=
0
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
numTokenFromAssertionCalls
+
=
1
;
return
Promise
.
resolve
(
{
access_token
:
"
token
"
}
)
;
}
;
yield
fxa
.
setSignedInUser
(
alice
)
;
let
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
1
)
;
do_check_eq
(
result
"
token
"
)
;
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
1
)
;
do_check_eq
(
result
"
token
"
)
;
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
"
something
-
else
"
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
2
)
;
do_check_eq
(
result
"
token
"
)
;
}
)
;
add_task
(
function
*
test_getOAuthTokenCachedScopeNormalization
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
numTokenFromAssertionCalls
=
0
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
numTokenFromAssertionCalls
+
=
1
;
return
Promise
.
resolve
(
{
access_token
:
"
token
"
}
)
;
}
;
yield
fxa
.
setSignedInUser
(
alice
)
;
let
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
]
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
1
)
;
do_check_eq
(
result
"
token
"
)
;
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
[
"
bar
"
"
foo
"
]
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
1
)
;
do_check_eq
(
result
"
token
"
)
;
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
[
"
Bar
"
"
Foo
"
]
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
1
)
;
do_check_eq
(
result
"
token
"
)
;
result
=
yield
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
"
etc
"
]
client
service
:
"
test
-
service
"
}
)
;
do_check_eq
(
numTokenFromAssertionCalls
2
)
;
do_check_eq
(
result
"
token
"
)
;
}
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
"
https
:
/
/
example
.
com
/
v1
"
)
;
add_test
(
function
test_getOAuthToken_invalid_param
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
getOAuthToken
(
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
INVALID_PARAMETER
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_invalid_scope_array
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
getOAuthToken
(
{
scope
:
[
]
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
INVALID_PARAMETER
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_misconfigure_oauth_uri
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
Services
.
prefs
.
deleteBranch
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
)
;
fxa
.
getOAuthToken
(
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
INVALID_PARAMETER
"
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
"
https
:
/
/
example
.
com
/
v1
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_no_account
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
internal
.
currentAccountState
.
getUserAccountData
=
function
(
)
{
return
Promise
.
resolve
(
null
)
;
}
;
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
NO_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_unverified
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
UNVERIFIED_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_network_error
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
return
Promise
.
reject
(
new
FxAccountsOAuthGrantClientError
(
{
error
:
ERROR_NETWORK
errno
:
ERRNO_NETWORK
}
)
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
NETWORK_ERROR
"
)
;
do_check_eq
(
err
.
details
.
errno
ERRNO_NETWORK
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_auth_error
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
return
Promise
.
reject
(
new
FxAccountsOAuthGrantClientError
(
{
error
:
ERROR_INVALID_FXA_ASSERTION
errno
:
ERRNO_INVALID_FXA_ASSERTION
}
)
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
AUTH_ERROR
"
)
;
do_check_eq
(
err
.
details
.
errno
ERRNO_INVALID_FXA_ASSERTION
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_unknown_error
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
fxa
.
internal
.
_d_signCertificate
.
resolve
(
"
cert1
"
)
;
let
client
=
new
FxAccountsOAuthGrantClient
(
{
serverURL
:
"
http
:
/
/
example
.
com
/
v1
"
client_id
:
"
abc123
"
}
)
;
client
.
getTokenFromAssertion
=
function
(
)
{
return
Promise
.
reject
(
"
boom
"
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
client
}
)
.
then
(
null
err
=
>
{
do_check_eq
(
err
.
message
"
UNKNOWN_ERROR
"
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getSignedInUserProfile
(
)
{
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
mockProfile
=
{
getProfile
(
)
{
return
Promise
.
resolve
(
{
avatar
:
"
image
"
}
)
;
}
tearDown
(
)
{
}
}
;
let
fxa
=
new
FxAccounts
(
{
_signOutServer
(
)
{
return
Promise
.
resolve
(
)
;
}
_registerOrUpdateDevice
(
)
{
return
Promise
.
resolve
(
)
;
}
}
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
internal
.
_profile
=
mockProfile
;
fxa
.
getSignedInUserProfile
(
)
.
then
(
result
=
>
{
do_check_true
(
!
!
result
)
;
do_check_eq
(
result
.
avatar
"
image
"
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getSignedInUserProfile_error_uses_account_data
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
fxa
.
internal
.
getSignedInUser
=
function
(
)
{
return
Promise
.
resolve
(
{
email
:
"
foo
bar
.
com
"
}
)
;
}
;
let
teardownCalled
=
false
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
internal
.
_profile
=
{
getProfile
(
)
{
return
Promise
.
reject
(
"
boom
"
)
;
}
tearDown
(
)
{
teardownCalled
=
true
;
}
}
;
fxa
.
getSignedInUserProfile
(
)
.
catch
(
error
=
>
{
do_check_eq
(
error
.
message
"
UNKNOWN_ERROR
"
)
;
fxa
.
signOut
(
)
.
then
(
(
)
=
>
{
do_check_true
(
teardownCalled
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getSignedInUserProfile_unverified_account
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getSignedInUserProfile
(
)
.
catch
(
error
=
>
{
do_check_eq
(
error
.
message
"
UNVERIFIED_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getSignedInUserProfile_no_account_data
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
internal
.
getSignedInUser
=
function
(
)
{
return
Promise
.
resolve
(
null
)
;
}
;
fxa
.
getSignedInUserProfile
(
)
.
catch
(
error
=
>
{
do_check_eq
(
error
.
message
"
NO_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_task
(
function
*
test_checkVerificationStatusFailed
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
client
=
fxa
.
internal
.
fxAccountsClient
;
client
.
recoveryEmailStatus
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
yield
fxa
.
setSignedInUser
(
alice
)
;
let
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_neq
(
alice
.
sessionToken
null
)
;
do_check_eq
(
user
.
email
alice
.
email
)
;
do_check_eq
(
user
.
verified
true
)
;
yield
fxa
.
checkVerificationStatus
(
)
;
user
=
yield
fxa
.
internal
.
getUserAccountData
(
)
;
do_check_eq
(
user
.
email
alice
.
email
)
;
do_check_eq
(
user
.
sessionToken
null
)
;
}
)
;
function
expandHex
(
two_hex
)
{
let
eight_hex
=
two_hex
+
two_hex
+
two_hex
+
two_hex
;
let
thirtytwo_hex
=
eight_hex
+
eight_hex
+
eight_hex
+
eight_hex
;
return
thirtytwo_hex
+
thirtytwo_hex
;
}
function
expandBytes
(
two_hex
)
{
return
CommonUtils
.
hexToBytes
(
expandHex
(
two_hex
)
)
;
}
function
getTestUser
(
name
)
{
return
{
email
:
name
+
"
example
.
com
"
uid
:
"
1ad7f502
-
4cc7
-
4ec1
-
a209
-
071fd2fae348
"
deviceId
:
name
+
"
'
s
device
id
"
sessionToken
:
name
+
"
'
s
session
token
"
keyFetchToken
:
name
+
"
'
s
keyfetch
token
"
unwrapBKey
:
expandHex
(
"
44
"
)
verified
:
false
}
;
}
function
makeObserver
(
aObserveTopic
aObserveFunc
)
{
let
observer
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupports
Ci
.
nsIObserver
]
)
observe
(
aSubject
aTopic
aData
)
{
log
.
debug
(
"
observed
"
+
aTopic
+
"
"
+
aData
)
;
if
(
aTopic
=
=
aObserveTopic
)
{
removeMe
(
)
;
aObserveFunc
(
aSubject
aTopic
aData
)
;
}
}
}
;
function
removeMe
(
)
{
log
.
debug
(
"
removing
observer
for
"
+
aObserveTopic
)
;
Services
.
obs
.
removeObserver
(
observer
aObserveTopic
)
;
}
Services
.
obs
.
addObserver
(
observer
aObserveTopic
false
)
;
return
removeMe
;
}
function
do_check_throws
(
func
result
stack
)
{
if
(
!
stack
)
stack
=
Components
.
stack
.
caller
;
try
{
func
(
)
;
}
catch
(
ex
)
{
if
(
ex
.
name
=
=
result
)
{
return
;
}
do_throw
(
"
Expected
result
"
+
result
+
"
caught
"
+
ex
.
name
stack
)
;
}
if
(
result
)
{
do_throw
(
"
Expected
result
"
+
result
+
"
none
thrown
"
stack
)
;
}
}
