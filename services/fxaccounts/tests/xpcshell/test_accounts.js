"
use
strict
"
;
const
{
FxAccounts
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
const
{
FxAccountsClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsClient
.
jsm
"
)
;
const
{
ERRNO_INVALID_AUTH_TOKEN
ERROR_NETWORK
ERROR_NO_ACCOUNT
FX_OAUTH_CLIENT_ID
ONLOGIN_NOTIFICATION
ONLOGOUT_NOTIFICATION
ONVERIFIED_NOTIFICATION
DEPRECATED_SCOPE_ECOSYSTEM_TELEMETRY
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
var
{
AccountState
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
null
)
;
const
ONE_HOUR_MS
=
1000
*
60
*
60
;
const
ONE_DAY_MS
=
ONE_HOUR_MS
*
24
;
const
MOCK_TOKEN_RESPONSE
=
{
access_token
:
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
token_type
:
"
bearer
"
scope
:
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
expires_in
:
21600
auth_at
:
1589579900
}
;
initTestLogging
(
"
Trace
"
)
;
var
log
=
Log
.
repository
.
getLogger
(
"
Services
.
FxAccounts
.
test
"
)
;
log
.
level
=
Log
.
Level
.
Debug
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
loglevel
"
"
Trace
"
)
;
Log
.
repository
.
getLogger
(
"
FirefoxAccounts
"
)
.
level
=
Log
.
Level
.
Trace
;
Services
.
prefs
.
setCharPref
(
"
services
.
crypto
.
jwcrypto
.
log
.
level
"
"
Debug
"
)
;
function
MockStorageManager
(
)
{
}
MockStorageManager
.
prototype
=
{
promiseInitialized
:
Promise
.
resolve
(
)
initialize
(
accountData
)
{
this
.
accountData
=
accountData
;
}
finalize
(
)
{
return
Promise
.
resolve
(
)
;
}
getAccountData
(
fields
=
null
)
{
let
result
;
if
(
!
this
.
accountData
)
{
result
=
null
;
}
else
if
(
fields
=
=
null
)
{
result
=
{
}
;
for
(
let
field
of
Object
.
keys
(
this
.
accountData
)
)
{
result
[
field
]
=
this
.
accountData
[
field
]
;
}
}
else
{
if
(
!
Array
.
isArray
(
fields
)
)
{
fields
=
[
fields
]
;
}
result
=
{
}
;
for
(
let
field
of
fields
)
{
result
[
field
]
=
this
.
accountData
[
field
]
;
}
}
return
Promise
.
resolve
(
result
)
;
}
updateAccountData
(
updatedFields
)
{
if
(
!
this
.
accountData
)
{
return
Promise
.
resolve
(
)
;
}
for
(
let
[
name
value
]
of
Object
.
entries
(
updatedFields
)
)
{
if
(
value
=
=
null
)
{
delete
this
.
accountData
[
name
]
;
}
else
{
this
.
accountData
[
name
]
=
value
;
}
}
return
Promise
.
resolve
(
)
;
}
deleteAccountData
(
)
{
this
.
accountData
=
null
;
return
Promise
.
resolve
(
)
;
}
}
;
function
MockFxAccountsClient
(
)
{
this
.
_email
=
"
nobody
example
.
com
"
;
this
.
_verified
=
false
;
this
.
_deletedOnServer
=
false
;
this
.
recoveryEmailStatus
=
async
function
(
sessionToken
)
{
return
{
email
:
this
.
_email
verified
:
this
.
_verified
}
;
}
;
this
.
accountStatus
=
async
function
(
uid
)
{
return
!
!
uid
&
&
!
this
.
_deletedOnServer
;
}
;
this
.
sessionStatus
=
async
function
(
)
{
return
!
this
.
_deletedOnServer
;
}
;
this
.
accountKeys
=
function
(
keyFetchToken
)
{
return
new
Promise
(
resolve
=
>
{
do_timeout
(
50
(
)
=
>
{
resolve
(
{
kA
:
expandBytes
(
"
11
"
)
wrapKB
:
expandBytes
(
"
22
"
)
}
)
;
}
)
;
}
)
;
}
;
this
.
getScopedKeyData
=
function
(
sessionToken
client_id
scopes
)
{
Assert
.
ok
(
sessionToken
)
;
Assert
.
equal
(
client_id
FX_OAUTH_CLIENT_ID
)
;
Assert
.
equal
(
scopes
SCOPE_OLD_SYNC
)
;
return
new
Promise
(
resolve
=
>
{
do_timeout
(
50
(
)
=
>
{
resolve
(
{
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
:
{
identifier
:
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
keyRotationSecret
:
"
0000000000000000000000000000000000000000000000000000000000000000
"
keyRotationTimestamp
:
1234567890123
}
}
)
;
}
)
;
}
)
;
}
;
this
.
resendVerificationEmail
=
function
(
sessionToken
)
{
return
Promise
.
resolve
(
sessionToken
)
;
}
;
this
.
signOut
=
(
)
=
>
Promise
.
resolve
(
)
;
FxAccountsClient
.
apply
(
this
)
;
}
MockFxAccountsClient
.
prototype
=
{
__proto__
:
FxAccountsClient
.
prototype
}
;
function
MockFxAccounts
(
credentials
=
null
)
{
let
result
=
new
FxAccounts
(
{
VERIFICATION_POLL_TIMEOUT_INITIAL
:
100
_getCertificateSigned_calls
:
[
]
_d_signCertificate
:
PromiseUtils
.
defer
(
)
_now_is
:
new
Date
(
)
now
(
)
{
return
this
.
_now_is
;
}
newAccountState
(
newCredentials
)
{
let
storage
=
new
MockStorageManager
(
)
;
storage
.
initialize
(
newCredentials
)
;
return
new
AccountState
(
storage
)
;
}
fxAccountsClient
:
new
MockFxAccountsClient
(
)
observerPreloads
:
[
]
device
:
{
_registerOrUpdateDevice
(
)
{
}
}
profile
:
{
getProfile
(
)
{
return
null
;
}
}
}
)
;
result
.
setSignedInUser
=
function
(
creds
)
{
return
result
.
_internal
.
setSignedInUser
(
creds
)
;
}
;
return
result
;
}
async
function
MakeFxAccounts
(
{
internal
=
{
}
credentials
}
=
{
}
)
{
if
(
!
internal
.
newAccountState
)
{
internal
.
newAccountState
=
function
(
newCredentials
)
{
let
storage
=
new
MockStorageManager
(
)
;
storage
.
initialize
(
newCredentials
)
;
return
new
AccountState
(
storage
)
;
}
;
}
if
(
!
internal
.
_signOutServer
)
{
internal
.
_signOutServer
=
(
)
=
>
Promise
.
resolve
(
)
;
}
if
(
internal
.
device
)
{
if
(
!
internal
.
device
.
_registerOrUpdateDevice
)
{
internal
.
device
.
_registerOrUpdateDevice
=
(
)
=
>
Promise
.
resolve
(
)
;
}
}
else
{
internal
.
device
=
{
_registerOrUpdateDevice
(
)
{
}
}
;
}
if
(
!
internal
.
observerPreloads
)
{
internal
.
observerPreloads
=
[
]
;
}
let
result
=
new
FxAccounts
(
internal
)
;
if
(
credentials
)
{
await
result
.
_internal
.
setSignedInUser
(
credentials
)
;
}
return
result
;
}
add_task
(
async
function
test_get_signed_in_user_initially_unset
(
)
{
_
(
"
Check
getSignedInUser
initially
and
after
signout
reports
no
user
"
)
;
let
account
=
await
MakeFxAccounts
(
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234567890abcdef1234567890abcdef
"
sessionToken
:
"
dead
"
verified
:
true
.
.
.
MOCK_ACCOUNT_KEYS
}
;
let
result
=
await
account
.
getSignedInUser
(
)
;
Assert
.
equal
(
result
null
)
;
await
account
.
_internal
.
setSignedInUser
(
credentials
)
;
result
=
await
account
.
getSignedInUser
(
)
;
Assert
.
deepEqual
(
result
.
email
credentials
.
email
)
;
Assert
.
deepEqual
(
result
.
scopedKeys
undefined
)
;
Assert
.
deepEqual
(
result
.
kSync
undefined
)
;
Assert
.
deepEqual
(
result
.
kXCS
undefined
)
;
Assert
.
deepEqual
(
result
.
kExtSync
undefined
)
;
Assert
.
deepEqual
(
result
.
kExtKbHash
undefined
)
;
result
=
await
account
.
_internal
.
currentAccountState
.
getUserAccountData
(
)
;
Assert
.
deepEqual
(
result
.
email
credentials
.
email
)
;
Assert
.
deepEqual
(
result
.
scopedKeys
credentials
.
scopedKeys
)
;
Assert
.
ok
(
result
.
kSync
)
;
Assert
.
ok
(
result
.
kXCS
)
;
Assert
.
ok
(
result
.
kExtSync
)
;
Assert
.
ok
(
result
.
kExtKbHash
)
;
let
localOnly
=
true
;
await
account
.
signOut
(
localOnly
)
;
result
=
await
account
.
getSignedInUser
(
)
;
Assert
.
equal
(
result
null
)
;
}
)
;
add_task
(
async
function
test_set_signed_in_user_signs_out_previous_account
(
)
{
_
(
"
Check
setSignedInUser
signs
out
the
previous
account
.
"
)
;
let
signOutServerCalled
=
false
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234567890abcdef1234567890abcdef
"
sessionToken
:
"
dead
"
verified
:
true
.
.
.
MOCK_ACCOUNT_KEYS
}
;
let
account
=
await
MakeFxAccounts
(
{
credentials
}
)
;
account
.
_internal
.
_signOutServer
=
(
)
=
>
{
signOutServerCalled
=
true
;
return
Promise
.
resolve
(
true
)
;
}
;
await
account
.
_internal
.
setSignedInUser
(
credentials
)
;
Assert
.
ok
(
signOutServerCalled
)
;
}
)
;
add_task
(
async
function
test_update_account_data
(
)
{
_
(
"
Check
updateUserAccountData
does
the
right
thing
.
"
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234567890abcdef1234567890abcdef
"
sessionToken
:
"
dead
"
verified
:
true
.
.
.
MOCK_ACCOUNT_KEYS
}
;
let
account
=
await
MakeFxAccounts
(
{
credentials
}
)
;
let
newCreds
=
{
email
:
credentials
.
email
uid
:
credentials
.
uid
sessionToken
:
"
alive
"
}
;
await
account
.
_internal
.
updateUserAccountData
(
newCreds
)
;
Assert
.
equal
(
(
await
account
.
_internal
.
getUserAccountData
(
)
)
.
sessionToken
"
alive
"
"
new
field
value
was
saved
"
)
;
newCreds
=
{
email
:
credentials
.
email
uid
:
"
11111111111111111111222222222222
"
sessionToken
:
"
alive
"
}
;
await
Assert
.
rejects
(
account
.
_internal
.
updateUserAccountData
(
newCreds
)
/
The
specified
credentials
aren
'
t
for
the
current
user
/
)
;
newCreds
=
{
sessionToken
:
"
alive
"
}
;
await
Assert
.
rejects
(
account
.
_internal
.
updateUserAccountData
(
newCreds
)
/
The
specified
credentials
have
no
uid
/
)
;
newCreds
=
{
email
:
credentials
.
email
uid
:
"
11111111111111111111222222222222
"
foo
:
"
bar
"
}
;
await
Assert
.
rejects
(
account
.
_internal
.
updateUserAccountData
(
newCreds
)
/
The
specified
credentials
aren
'
t
for
the
current
user
/
)
;
}
)
;
add_test
(
function
test_client_mock
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
Assert
.
equal
(
client
.
_verified
false
)
;
Assert
.
equal
(
typeof
client
.
signIn
"
function
"
)
;
client
.
recoveryEmailStatus
(
)
.
then
(
response
=
>
{
Assert
.
equal
(
response
.
verified
false
)
;
run_next_test
(
)
;
}
)
;
}
)
;
add_test
(
function
test_verification_poll
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
francine
"
)
;
let
login_notification_received
=
false
;
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_verification_poll
observed
onverified
"
)
;
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
Assert
.
equal
(
user
.
verified
true
)
;
Assert
.
equal
(
user
.
email
test_user
.
email
)
;
Assert
.
ok
(
login_notification_received
)
;
run_next_test
(
)
;
}
)
;
}
)
;
makeObserver
(
ONLOGIN_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_verification_poll
observer
onlogin
"
)
;
login_notification_received
=
true
;
}
)
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
Assert
.
equal
(
user
.
verified
false
)
;
do_timeout
(
200
function
(
)
{
log
.
debug
(
"
Mocking
verification
of
francine
'
s
email
"
)
;
fxa
.
_internal
.
fxAccountsClient
.
_email
=
test_user
.
email
;
fxa
.
_internal
.
fxAccountsClient
.
_verified
=
true
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_polling_timeout
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
let
removeObserver
=
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
do_throw
(
"
We
should
not
be
getting
a
login
event
!
"
)
;
}
)
;
fxa
.
_internal
.
POLL_SESSION
=
1
;
let
p
=
fxa
.
_internal
.
whenVerified
(
{
}
)
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
p
.
then
(
success
=
>
{
do_throw
(
"
this
should
not
succeed
"
)
;
}
fail
=
>
{
removeObserver
(
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_onverified_once
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
francine
"
)
;
let
numNotifications
=
0
;
function
observe
(
aSubject
aTopic
aData
)
{
numNotifications
+
=
1
;
}
Services
.
obs
.
addObserver
(
observe
ONVERIFIED_NOTIFICATION
)
;
fxa
.
_internal
.
POLL_SESSION
=
1
;
await
fxa
.
setSignedInUser
(
user
)
;
Assert
.
ok
(
!
(
await
fxa
.
getSignedInUser
(
)
)
.
verified
"
starts
unverified
"
)
;
await
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
start
"
)
;
Assert
.
ok
(
!
(
await
fxa
.
getSignedInUser
(
)
)
.
verified
"
still
unverified
"
)
;
log
.
debug
(
"
Mocking
verification
of
francine
'
s
email
"
)
;
fxa
.
_internal
.
fxAccountsClient
.
_email
=
user
.
email
;
fxa
.
_internal
.
fxAccountsClient
.
_verified
=
true
;
await
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
again
"
)
;
Assert
.
ok
(
(
await
fxa
.
getSignedInUser
(
)
)
.
verified
"
now
verified
"
)
;
Assert
.
equal
(
numNotifications
1
"
expect
exactly
1
ONVERIFIED
"
)
;
Services
.
obs
.
removeObserver
(
observe
ONVERIFIED_NOTIFICATION
)
;
await
fxa
.
signOut
(
)
;
}
)
;
add_test
(
function
test_pollEmailStatus_start_verified
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
fxa
.
_internal
.
POLL_SESSION
=
20
*
60000
;
fxa
.
_internal
.
VERIFICATION_POLL_TIMEOUT_INITIAL
=
50000
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
fxa
.
_internal
.
fxAccountsClient
.
_email
=
test_user
.
email
;
fxa
.
_internal
.
fxAccountsClient
.
_verified
=
true
;
const
mock
=
sinon
.
mock
(
fxa
.
_internal
)
;
mock
.
expects
(
"
_scheduleNextPollEmailStatus
"
)
.
never
(
)
;
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
start
"
)
.
then
(
(
)
=
>
{
mock
.
verify
(
)
;
mock
.
restore
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_pollEmailStatus_start
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
fxa
.
_internal
.
POLL_SESSION
=
20
*
60000
;
fxa
.
_internal
.
VERIFICATION_POLL_TIMEOUT_INITIAL
=
123456
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
const
mock
=
sinon
.
mock
(
fxa
.
_internal
)
;
mock
.
expects
(
"
_scheduleNextPollEmailStatus
"
)
.
once
(
)
.
withArgs
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
123456
"
start
"
)
;
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
start
"
)
.
then
(
(
)
=
>
{
mock
.
verify
(
)
;
mock
.
restore
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_pollEmailStatus_start_subsequent
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
fxa
.
_internal
.
POLL_SESSION
=
20
*
60000
;
fxa
.
_internal
.
VERIFICATION_POLL_TIMEOUT_INITIAL
=
123456
;
fxa
.
_internal
.
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
=
654321
;
fxa
.
_internal
.
VERIFICATION_POLL_START_SLOWDOWN_THRESHOLD
=
-
1
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
const
mock
=
sinon
.
mock
(
fxa
.
_internal
)
;
mock
.
expects
(
"
_scheduleNextPollEmailStatus
"
)
.
once
(
)
.
withArgs
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
654321
"
start
"
)
;
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
start
"
)
.
then
(
(
)
=
>
{
mock
.
verify
(
)
;
mock
.
restore
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_pollEmailStatus_browser_startup
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
fxa
.
_internal
.
POLL_SESSION
=
20
*
60000
;
fxa
.
_internal
.
VERIFICATION_POLL_TIMEOUT_SUBSEQUENT
=
654321
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
const
mock
=
sinon
.
mock
(
fxa
.
_internal
)
;
mock
.
expects
(
"
_scheduleNextPollEmailStatus
"
)
.
once
(
)
.
withArgs
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
654321
"
browser
-
startup
"
)
;
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
browser
-
startup
"
)
.
then
(
(
)
=
>
{
mock
.
verify
(
)
;
mock
.
restore
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_pollEmailStatus_push
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
test_user
=
getTestUser
(
"
carol
"
)
;
fxa
.
setSignedInUser
(
test_user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
const
mock
=
sinon
.
mock
(
fxa
.
_internal
)
;
mock
.
expects
(
"
_scheduleNextPollEmailStatus
"
)
.
never
(
)
;
fxa
.
_internal
.
startPollEmailStatus
(
fxa
.
_internal
.
currentAccountState
user
.
sessionToken
"
push
"
)
.
then
(
(
)
=
>
{
mock
.
verify
(
)
;
mock
.
restore
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getKeyForScope
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
eusebius
"
)
;
user
.
verified
=
true
;
fxa
.
setSignedInUser
(
user
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user2
=
>
{
Assert
.
equal
(
!
!
user2
.
scopedKeys
false
)
;
Assert
.
equal
(
!
!
user2
.
kSync
false
)
;
Assert
.
equal
(
!
!
user2
.
kXCS
false
)
;
Assert
.
equal
(
!
!
user2
.
kExtSync
false
)
;
Assert
.
equal
(
!
!
user2
.
kExtKbHash
false
)
;
Assert
.
equal
(
!
!
user2
.
keyFetchToken
true
)
;
Assert
.
equal
(
!
!
user2
.
unwrapBKey
true
)
;
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
.
then
(
(
)
=
>
{
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user3
=
>
{
Assert
.
equal
(
fxa
.
_internal
.
isUserEmailVerified
(
user3
)
true
)
;
Assert
.
equal
(
!
!
user3
.
verified
true
)
;
Assert
.
notEqual
(
null
user3
.
scopedKeys
)
;
Assert
.
notEqual
(
null
user3
.
kSync
)
;
Assert
.
notEqual
(
null
user3
.
kXCS
)
;
Assert
.
notEqual
(
null
user3
.
kExtSync
)
;
Assert
.
notEqual
(
null
user3
.
kExtKbHash
)
;
Assert
.
equal
(
user3
.
keyFetchToken
undefined
)
;
Assert
.
equal
(
user3
.
unwrapBKey
undefined
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_kb_migration
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
eusebius
"
)
;
user
.
verified
=
true
;
user
.
kA
=
"
e0245ab7f10e483470388e0a28f0a03379a3b417174fb2b42feab158b4ac2dbd
"
;
user
.
kB
=
"
eaf9570b7219a4187d3d6bf3cec2770c2e0719b7cc0dfbb38243d6f1881675e9
"
;
await
fxa
.
setSignedInUser
(
user
)
;
await
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
;
let
newUser
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
newUser
.
kA
null
)
;
Assert
.
equal
(
newUser
.
kB
null
)
;
Assert
.
deepEqual
(
newUser
.
scopedKeys
{
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
:
{
kid
:
"
1234567890123
-
IqQv4onc7VcVE1kTQkyyOw
"
k
:
"
DW_ll5GwX6SJ5GPqJVAuMUP2t6kDqhUulc2cbt26xbTcaKGQl
-
9l29FHAQ7kUiJETma4s9fIpEHrt909zgFang
"
kty
:
"
oct
"
}
"
sync
:
addon_storage
"
:
{
kid
:
"
1234567890123
-
pBOR6B6JulbJr3BxKVOqIU4Cq_WAjFp4ApLn5NRVARE
"
k
:
"
ut7VPrNYfXkA5gTopo2GCr
-
d4wtclV08TV26Y_Jv2IJlzYWSP26dzRau87gryIA5qJxZ7NnojeCadBjH2U
-
QyQ
"
kty
:
"
oct
"
}
}
)
;
Assert
.
equal
(
newUser
.
kSync
"
0d6fe59791b05fa489e463ea25502e3143f6b7a903aa152e95cd9c6eddbac5b4
"
+
"
dc68a19097ef65dbd147010ee45222444e66b8b3d7c8a441ebb7dd3dce015a9e
"
)
;
Assert
.
equal
(
newUser
.
kXCS
"
22a42fe289dced5715135913424cb23b
"
)
;
Assert
.
equal
(
newUser
.
kExtSync
"
baded53eb3587d7900e604e8a68d860abf9de30b5c955d3c4d5dba63f26fd882
"
+
"
65cd85923f6e9dcd16aef3b82bc88039a89c59ecd9e88de09a7418c7d94f90c9
"
)
;
Assert
.
equal
(
newUser
.
kExtKbHash
"
a41391e81e89ba56c9af70712953aa214e02abf5808c5a780292e7e4d4550111
"
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_scopedKeys_migration
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
eusebius
"
)
;
user
.
verified
=
true
;
user
.
kSync
=
MOCK_ACCOUNT_KEYS
.
kSync
;
user
.
kXCS
=
MOCK_ACCOUNT_KEYS
.
kXCS
;
user
.
kExtSync
=
MOCK_ACCOUNT_KEYS
.
kExtSync
;
user
.
kExtKbHash
=
MOCK_ACCOUNT_KEYS
.
kExtKbHash
;
Assert
.
equal
(
user
.
scopedKeys
null
)
;
await
fxa
.
setSignedInUser
(
user
)
;
await
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
;
let
newUser
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
newUser
.
kA
null
)
;
Assert
.
equal
(
newUser
.
kB
null
)
;
const
expectedScopedKeys
=
{
.
.
.
MOCK_ACCOUNT_KEYS
.
scopedKeys
}
;
Assert
.
deepEqual
(
newUser
.
scopedKeys
expectedScopedKeys
)
;
Assert
.
equal
(
newUser
.
kSync
user
.
kSync
)
;
Assert
.
equal
(
newUser
.
kXCS
user
.
kXCS
)
;
Assert
.
equal
(
newUser
.
kExtSync
user
.
kExtSync
)
;
Assert
.
equal
(
newUser
.
kExtKbHash
user
.
kExtKbHash
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_scopedKeys_migration_removes_deprecated_scoped_keys
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
eusebius
"
)
;
const
EXTRA_SCOPE
=
"
an
unknown
but
non
-
deprecated
scope
"
;
user
.
verified
=
true
;
user
.
ecosystemUserId
=
"
ecoUserId
"
;
user
.
ecosystemAnonId
=
"
ecoAnonId
"
;
user
.
scopedKeys
=
{
.
.
.
MOCK_ACCOUNT_KEYS
.
scopedKeys
[
DEPRECATED_SCOPE_ECOSYSTEM_TELEMETRY
]
:
MOCK_ACCOUNT_KEYS
.
scopedKeys
[
SCOPE_OLD_SYNC
]
[
EXTRA_SCOPE
]
:
MOCK_ACCOUNT_KEYS
.
scopedKeys
[
SCOPE_OLD_SYNC
]
}
;
await
fxa
.
setSignedInUser
(
user
)
;
await
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
;
let
newUser
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
const
expectedScopedKeys
=
{
.
.
.
MOCK_ACCOUNT_KEYS
.
scopedKeys
[
EXTRA_SCOPE
]
:
MOCK_ACCOUNT_KEYS
.
scopedKeys
[
SCOPE_OLD_SYNC
]
}
;
Assert
.
deepEqual
(
newUser
.
scopedKeys
expectedScopedKeys
)
;
Assert
.
equal
(
newUser
.
ecosystemUserId
null
)
;
Assert
.
equal
(
newUser
.
ecosystemAnonId
null
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_nonexistent_account
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
bismarck
=
getTestUser
(
"
bismarck
"
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
false
)
;
client
.
sessionStatus
=
(
)
=
>
Promise
.
resolve
(
false
)
;
client
.
accountKeys
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
await
fxa
.
setSignedInUser
(
bismarck
)
;
let
promiseLogout
=
new
Promise
(
resolve
=
>
{
makeObserver
(
ONLOGOUT_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_getKeyForScope_nonexistent_account
observed
logout
"
)
;
resolve
(
)
;
}
)
;
}
)
;
await
Assert
.
rejects
(
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
/
A
different
user
signed
in
/
)
;
await
promiseLogout
;
let
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
user
null
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_invalid_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
yusuf
=
getTestUser
(
"
yusuf
"
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
client
.
sessionStatus
=
(
)
=
>
Promise
.
resolve
(
false
)
;
client
.
accountKeys
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
await
fxa
.
setSignedInUser
(
yusuf
)
;
try
{
await
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
;
Assert
.
ok
(
false
)
;
}
catch
(
err
)
{
Assert
.
equal
(
err
.
code
401
)
;
Assert
.
equal
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
let
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
user
.
email
yusuf
.
email
)
;
Assert
.
equal
(
user
.
keyFetchToken
null
)
;
await
fxa
.
_internal
.
abortExistingFlow
(
)
;
}
)
;
add_task
(
async
function
test_getKeyForScope_oldsync
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
getScopedKeyData
=
(
)
=
>
Promise
.
resolve
(
{
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
:
{
identifier
:
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
keyRotationSecret
:
"
0000000000000000000000000000000000000000000000000000000000000000
"
keyRotationTimestamp
:
1510726317123
}
}
)
;
let
user
=
{
.
.
.
getTestUser
(
"
eusebius
"
)
uid
:
"
aeaa1725c7a24ff983c6295725d5fc9b
"
kB
:
"
eaf9570b7219a4187d3d6bf3cec2770c2e0719b7cc0dfbb38243d6f1881675e9
"
verified
:
true
}
;
await
fxa
.
setSignedInUser
(
user
)
;
const
key
=
await
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
;
Assert
.
deepEqual
(
key
{
scope
:
SCOPE_OLD_SYNC
kid
:
"
1510726317123
-
IqQv4onc7VcVE1kTQkyyOw
"
k
:
"
DW_ll5GwX6SJ5GPqJVAuMUP2t6kDqhUulc2cbt26xbTcaKGQl
-
9l29FHAQ7kUiJETma4s9fIpEHrt909zgFang
"
kty
:
"
oct
"
}
)
;
}
)
;
add_task
(
async
function
test_getScopedKeys_unavailable_scope
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
{
.
.
.
getTestUser
(
"
eusebius
"
)
uid
:
"
aeaa1725c7a24ff983c6295725d5fc9b
"
verified
:
true
.
.
.
MOCK_ACCOUNT_KEYS
}
;
await
fxa
.
setSignedInUser
(
user
)
;
await
Assert
.
rejects
(
fxa
.
keys
.
getKeyForScope
(
"
otherkeybearingscope
"
)
/
Key
not
available
for
scope
/
)
;
}
)
;
add_task
(
async
function
test_getScopedKeys_misconfigured_fxa_server
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
getScopedKeyData
=
(
)
=
>
Promise
.
resolve
(
{
wrongscope
:
{
identifier
:
"
wrongscope
"
keyRotationSecret
:
"
0000000000000000000000000000000000000000000000000000000000000000
"
keyRotationTimestamp
:
1510726331712
}
}
)
;
let
user
=
{
.
.
.
getTestUser
(
"
eusebius
"
)
uid
:
"
aeaa1725c7a24ff983c6295725d5fc9b
"
verified
:
true
kSync
:
"
0d6fe59791b05fa489e463ea25502e3143f6b7a903aa152e95cd9c6eddbac5b4dc68a19097ef65dbd147010ee45222444e66b8b3d7c8a441ebb7dd3dce015a9e
"
kXCS
:
"
22a42fe289dced5715135913424cb23b
"
kExtSync
:
"
baded53eb3587d7900e604e8a68d860abf9de30b5c955d3c4d5dba63f26fd88265cd85923f6e9dcd16aef3b82bc88039a89c59ecd9e88de09a7418c7d94f90c9
"
kExtKbHash
:
"
b776a89db29f22daedd154b44ff88397d0b210223fb956f5a749521dd8de8ddf
"
}
;
await
fxa
.
setSignedInUser
(
user
)
;
await
Assert
.
rejects
(
fxa
.
keys
.
getKeyForScope
(
SCOPE_OLD_SYNC
)
/
The
FxA
server
did
not
grant
Firefox
the
oldsync
scope
/
)
;
}
)
;
add_test
(
function
test_fetchAndUnwrapAndDeriveKeys_no_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
user
=
getTestUser
(
"
lettuce
.
protheroe
"
)
;
delete
user
.
keyFetchToken
;
makeObserver
(
ONLOGOUT_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_fetchAndUnwrapKeys_no_token
observed
logout
"
)
;
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user2
=
>
{
fxa
.
_internal
.
abortExistingFlow
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
fxa
.
setSignedInUser
(
user
)
.
then
(
user2
=
>
{
return
fxa
.
keys
.
_fetchAndUnwrapAndDeriveKeys
(
)
;
}
)
.
catch
(
error
=
>
{
log
.
info
(
"
setSignedInUser
correctly
rejected
"
)
;
}
)
;
}
)
;
add_test
(
function
test_overlapping_signins
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
let
bob
=
getTestUser
(
"
bob
"
)
;
makeObserver
(
ONVERIFIED_NOTIFICATION
function
(
)
{
log
.
debug
(
"
test_overlapping_signins
observed
onverified
"
)
;
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
Assert
.
equal
(
user
.
email
bob
.
email
)
;
Assert
.
equal
(
user
.
verified
true
)
;
run_next_test
(
)
;
}
)
;
}
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
log
.
debug
(
"
Alice
signing
in
.
.
.
"
)
;
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
Assert
.
equal
(
user
.
email
alice
.
email
)
;
Assert
.
equal
(
user
.
verified
false
)
;
log
.
debug
(
"
Alice
has
not
verified
her
email
.
.
.
"
)
;
log
.
debug
(
"
Bob
signing
in
.
.
.
"
)
;
fxa
.
setSignedInUser
(
bob
)
.
then
(
(
)
=
>
{
do_timeout
(
200
function
(
)
{
log
.
debug
(
"
Bob
verifying
his
email
.
.
.
"
)
;
fxa
.
_internal
.
fxAccountsClient
.
_verified
=
true
;
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_resend_email_not_signed_in
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
try
{
await
fxa
.
resendVerificationEmail
(
)
;
}
catch
(
err
)
{
Assert
.
equal
(
err
.
message
ERROR_NO_ACCOUNT
)
;
return
;
}
do_throw
(
"
Should
not
be
able
to
resend
email
when
nobody
is
signed
in
"
)
;
}
)
;
add_task
(
async
function
test_accountStatus
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
let
result
=
await
fxa
.
checkAccountStatus
(
)
;
Assert
.
ok
(
!
result
)
;
await
fxa
.
setSignedInUser
(
alice
)
;
result
=
await
fxa
.
checkAccountStatus
(
)
;
Assert
.
ok
(
result
)
;
fxa
.
_internal
.
fxAccountsClient
.
_deletedOnServer
=
true
;
result
=
await
fxa
.
checkAccountStatus
(
)
;
Assert
.
ok
(
!
result
)
;
fxa
.
_internal
.
fxAccountsClient
.
_deletedOnServer
=
false
;
await
fxa
.
signOut
(
)
;
}
)
;
add_task
(
async
function
test_resend_email_invalid_token
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
sophia
=
getTestUser
(
"
sophia
"
)
;
Assert
.
notEqual
(
sophia
.
sessionToken
null
)
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
resendVerificationEmail
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
client
.
accountStatus
=
uid
=
>
{
Assert
.
ok
(
uid
"
got
a
uid
to
check
"
)
;
return
Promise
.
resolve
(
true
)
;
}
;
client
.
sessionStatus
=
token
=
>
{
Assert
.
ok
(
token
"
got
a
token
to
check
"
)
;
return
Promise
.
resolve
(
false
)
;
}
;
await
fxa
.
setSignedInUser
(
sophia
)
;
let
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
user
.
email
sophia
.
email
)
;
Assert
.
equal
(
user
.
verified
false
)
;
log
.
debug
(
"
Sophia
wants
verification
email
resent
"
)
;
try
{
await
fxa
.
resendVerificationEmail
(
)
;
Assert
.
ok
(
false
"
resendVerificationEmail
should
reject
invalid
session
token
"
)
;
}
catch
(
err
)
{
Assert
.
equal
(
err
.
code
401
)
;
Assert
.
equal
(
err
.
errno
ERRNO_INVALID_AUTH_TOKEN
)
;
}
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
user
.
email
sophia
.
email
)
;
Assert
.
equal
(
user
.
sessionToken
null
)
;
await
fxa
.
_internal
.
abortExistingFlow
(
)
;
}
)
;
add_test
(
function
test_resend_email
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
let
initialState
=
fxa
.
_internal
.
currentAccountState
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
log
.
debug
(
"
Alice
signing
in
"
)
;
Assert
.
ok
(
fxa
.
_internal
.
currentAccountState
!
=
=
initialState
)
;
let
aliceState
=
fxa
.
_internal
.
currentAccountState
;
Assert
.
ok
(
fxa
.
_internal
.
currentTimer
>
0
)
;
fxa
.
_internal
.
getUserAccountData
(
)
.
then
(
user
=
>
{
Assert
.
equal
(
user
.
email
alice
.
email
)
;
Assert
.
equal
(
user
.
verified
false
)
;
log
.
debug
(
"
Alice
wants
verification
email
resent
"
)
;
fxa
.
resendVerificationEmail
(
)
.
then
(
result
=
>
{
Assert
.
equal
(
result
"
alice
'
s
session
token
"
)
;
Assert
.
ok
(
fxa
.
_internal
.
currentAccountState
=
=
=
aliceState
)
;
Assert
.
ok
(
fxa
.
_internal
.
currentTimer
>
0
)
;
fxa
.
_internal
.
abortExistingFlow
(
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
}
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
"
https
:
/
/
example
.
com
/
v1
"
)
;
add_test
(
async
function
test_getOAuthTokenWithSessionToken
(
)
{
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
useSessionTokensForOAuth
"
true
)
;
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
oauthTokenCalled
=
false
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accessTokenWithSessionToken
=
async
(
sessionTokenHex
clientId
scope
ttl
)
=
>
{
oauthTokenCalled
=
true
;
Assert
.
equal
(
sessionTokenHex
"
alice
'
s
session
token
"
)
;
Assert
.
equal
(
clientId
"
5882386c6d801776
"
)
;
Assert
.
equal
(
scope
"
profile
"
)
;
Assert
.
equal
(
ttl
undefined
)
;
return
MOCK_TOKEN_RESPONSE
;
}
;
await
fxa
.
setSignedInUser
(
alice
)
;
const
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
;
Assert
.
ok
(
oauthTokenCalled
)
;
Assert
.
equal
(
result
MOCK_TOKEN_RESPONSE
.
access_token
)
;
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
useSessionTokensForOAuth
"
false
)
;
run_next_test
(
)
;
}
)
;
add_task
(
async
function
test_getOAuthTokenCachedWithSessionToken
(
)
{
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
useSessionTokensForOAuth
"
true
)
;
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
numOauthTokenCalls
=
0
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accessTokenWithSessionToken
=
async
(
)
=
>
{
numOauthTokenCalls
+
+
;
return
MOCK_TOKEN_RESPONSE
;
}
;
await
fxa
.
setSignedInUser
(
alice
)
;
let
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOauthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOauthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
"
something
-
else
"
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOauthTokenCalls
2
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
Services
.
prefs
.
setBoolPref
(
"
identity
.
fxaccounts
.
useSessionTokensForOAuth
"
false
)
;
}
)
;
add_test
(
function
test_getOAuthTokenScopedWithSessionToken
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
numOauthTokenCalls
=
0
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accessTokenWithSessionToken
=
async
(
_sessionTokenHex
_clientId
scopeString
)
=
>
{
equal
(
scopeString
"
bar
foo
"
)
;
numOauthTokenCalls
+
+
;
return
MOCK_TOKEN_RESPONSE
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
]
}
)
.
then
(
result
=
>
{
Assert
.
equal
(
numOauthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_getOAuthTokenCachedScopeNormalization
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
numOAuthTokenCalls
=
0
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accessTokenWithSessionToken
=
async
(
_sessionTokenHex
_clientId
scopeString
)
=
>
{
numOAuthTokenCalls
+
+
;
return
MOCK_TOKEN_RESPONSE
;
}
;
await
fxa
.
setSignedInUser
(
alice
)
;
let
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
]
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOAuthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
[
"
bar
"
"
foo
"
]
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOAuthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
[
"
Bar
"
"
Foo
"
]
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOAuthTokenCalls
1
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
result
=
await
fxa
.
getOAuthToken
(
{
scope
:
[
"
foo
"
"
bar
"
"
etc
"
]
service
:
"
test
-
service
"
}
)
;
Assert
.
equal
(
numOAuthTokenCalls
2
)
;
Assert
.
equal
(
result
"
43793fdfffec22eb39fc3c44ed09193a6fde4c24e5d6a73f73178597b268af69
"
)
;
}
)
;
add_test
(
function
test_getOAuthToken_invalid_param
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
getOAuthToken
(
)
.
catch
(
err
=
>
{
Assert
.
equal
(
err
.
message
"
INVALID_PARAMETER
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_invalid_scope_array
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
getOAuthToken
(
{
scope
:
[
]
}
)
.
catch
(
err
=
>
{
Assert
.
equal
(
err
.
message
"
INVALID_PARAMETER
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_misconfigure_oauth_uri
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
const
prevServerURL
=
Services
.
prefs
.
getCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
)
;
Services
.
prefs
.
deleteBranch
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
)
;
fxa
.
getOAuthToken
(
)
.
catch
(
err
=
>
{
Assert
.
equal
(
err
.
message
"
INVALID_PARAMETER
"
)
;
Services
.
prefs
.
setCharPref
(
"
identity
.
fxaccounts
.
remote
.
oauth
.
uri
"
prevServerURL
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_no_account
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
fxa
.
_internal
.
currentAccountState
.
getUserAccountData
=
function
(
)
{
return
Promise
.
resolve
(
null
)
;
}
;
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
.
catch
(
err
=
>
{
Assert
.
equal
(
err
.
message
"
NO_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_unverified
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
.
catch
(
err
=
>
{
Assert
.
equal
(
err
.
message
"
UNVERIFIED_ACCOUNT
"
)
;
fxa
.
signOut
(
)
.
then
(
run_next_test
)
;
}
)
;
}
)
;
}
)
;
add_test
(
function
test_getOAuthToken_error
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
accessTokenWithSessionToken
=
(
)
=
>
{
return
Promise
.
reject
(
"
boom
"
)
;
}
;
fxa
.
setSignedInUser
(
alice
)
.
then
(
(
)
=
>
{
fxa
.
getOAuthToken
(
{
scope
:
"
profile
"
}
)
.
catch
(
err
=
>
{
equal
(
err
.
details
"
boom
"
)
;
run_next_test
(
)
;
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_listAttachedOAuthClients
(
)
{
const
ONE_HOUR
=
60
*
60
*
1000
;
const
ONE_DAY
=
24
*
ONE_HOUR
;
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
attachedClients
=
async
(
)
=
>
{
return
[
{
clientId
:
"
a2270f727f45f648
"
deviceId
:
"
deadbeef
"
sessionTokenId
:
null
name
:
"
Firefox
Preview
(
no
session
token
)
"
scope
:
[
"
profile
"
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
oldsync
"
]
lastAccessTime
:
Date
.
now
(
)
}
{
clientId
:
"
802d56ef2a9af9fa
"
deviceId
:
null
sessionTokenId
:
null
name
:
"
Firefox
Monitor
"
scope
:
[
"
profile
"
]
lastAccessTime
:
Date
.
now
(
)
-
ONE_DAY
-
ONE_HOUR
}
{
clientId
:
"
1f30e32975ae5112
"
deviceId
:
null
sessionTokenId
:
null
name
:
"
Firefox
Send
"
scope
:
[
"
profile
"
"
https
:
/
/
identity
.
mozilla
.
com
/
apps
/
send
"
]
lastAccessTime
:
Date
.
now
(
)
-
ONE_DAY
*
2
-
ONE_HOUR
}
{
clientId
:
"
future
-
date
"
deviceId
:
null
sessionTokenId
:
null
name
:
"
Whatever
"
lastAccessTime
:
Date
.
now
(
)
+
ONE_DAY
}
{
clientId
:
"
missing
-
date
"
deviceId
:
null
sessionTokenId
:
null
name
:
"
Whatever
"
}
]
;
}
;
await
fxa
.
setSignedInUser
(
alice
)
;
const
clients
=
await
fxa
.
listAttachedOAuthClients
(
)
;
Assert
.
deepEqual
(
clients
[
{
id
:
"
a2270f727f45f648
"
lastAccessedDaysAgo
:
0
}
{
id
:
"
802d56ef2a9af9fa
"
lastAccessedDaysAgo
:
1
}
{
id
:
"
1f30e32975ae5112
"
lastAccessedDaysAgo
:
2
}
{
id
:
"
future
-
date
"
lastAccessedDaysAgo
:
0
}
{
id
:
"
missing
-
date
"
lastAccessedDaysAgo
:
null
}
]
)
;
}
)
;
add_task
(
async
function
test_getSignedInUserProfile
(
)
{
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
mockProfile
=
{
getProfile
(
)
{
return
Promise
.
resolve
(
{
avatar
:
"
image
"
}
)
;
}
tearDown
(
)
{
}
}
;
let
fxa
=
new
FxAccounts
(
{
_signOutServer
(
)
{
return
Promise
.
resolve
(
)
;
}
device
:
{
_registerOrUpdateDevice
(
)
{
return
Promise
.
resolve
(
)
;
}
}
}
)
;
await
fxa
.
_internal
.
setSignedInUser
(
alice
)
;
fxa
.
_internal
.
_profile
=
mockProfile
;
let
result
=
await
fxa
.
getSignedInUser
(
)
;
Assert
.
ok
(
!
!
result
)
;
Assert
.
equal
(
result
.
avatar
"
image
"
)
;
}
)
;
add_task
(
async
function
test_getSignedInUserProfile_error_uses_account_data
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
fxa
.
_internal
.
getSignedInUser
=
function
(
)
{
return
Promise
.
resolve
(
{
email
:
"
foo
bar
.
com
"
}
)
;
}
;
fxa
.
_internal
.
_profile
=
{
getProfile
(
)
{
return
Promise
.
reject
(
"
boom
"
)
;
}
tearDown
(
)
{
teardownCalled
=
true
;
}
}
;
let
teardownCalled
=
false
;
await
fxa
.
setSignedInUser
(
alice
)
;
let
result
=
await
fxa
.
getSignedInUser
(
)
;
Assert
.
deepEqual
(
result
.
avatar
null
)
;
await
fxa
.
signOut
(
)
;
Assert
.
ok
(
teardownCalled
)
;
}
)
;
add_task
(
async
function
test_checkVerificationStatusFailed
(
)
{
let
fxa
=
new
MockFxAccounts
(
)
;
let
alice
=
getTestUser
(
"
alice
"
)
;
alice
.
verified
=
true
;
let
client
=
fxa
.
_internal
.
fxAccountsClient
;
client
.
recoveryEmailStatus
=
(
)
=
>
{
return
Promise
.
reject
(
{
code
:
401
errno
:
ERRNO_INVALID_AUTH_TOKEN
}
)
;
}
;
client
.
accountStatus
=
(
)
=
>
Promise
.
resolve
(
true
)
;
client
.
sessionStatus
=
(
)
=
>
Promise
.
resolve
(
false
)
;
await
fxa
.
setSignedInUser
(
alice
)
;
let
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
notEqual
(
alice
.
sessionToken
null
)
;
Assert
.
equal
(
user
.
email
alice
.
email
)
;
Assert
.
equal
(
user
.
verified
true
)
;
await
fxa
.
_internal
.
checkVerificationStatus
(
)
;
user
=
await
fxa
.
_internal
.
getUserAccountData
(
)
;
Assert
.
equal
(
user
.
email
alice
.
email
)
;
Assert
.
equal
(
user
.
sessionToken
null
)
;
}
)
;
add_task
(
async
function
test_deriveKeys
(
)
{
let
account
=
await
MakeFxAccounts
(
)
;
let
kBhex
=
"
fd5c747806c07ce0b9d69dcfea144663e630b65ec4963596a22f24910d7dd15d
"
;
let
kB
=
CommonUtils
.
hexToBytes
(
kBhex
)
;
const
uid
=
"
1ad7f502
-
4cc7
-
4ec1
-
a209
-
071fd2fae348
"
;
const
{
kSync
kXCS
kExtSync
kExtKbHash
}
=
await
account
.
keys
.
_deriveKeys
(
uid
kB
)
;
Assert
.
equal
(
kSync
"
ad501a50561be52b008878b2e0d8a73357778a712255f7722f497b5d4df14b05
"
+
"
dc06afb836e1521e882f521eb34691d172337accdbf6e2a5b968b05a7bbb9885
"
)
;
Assert
.
equal
(
kXCS
"
6ae94683571c7a7c54dab4700aa3995f
"
)
;
Assert
.
equal
(
kExtSync
"
f5ccd9cfdefd9b1ac4d02c56964f59239d8dfa1ca326e63696982765c1352cdc
"
+
"
5d78a5a9c633a6d25edfea0a6c221a3480332a49fd866f311c2e3508ddd07395
"
)
;
Assert
.
equal
(
kExtKbHash
"
6192f1cc7dce95334455ba135fa1d8fca8f70e8f594ae318528de06f24ed0273
"
)
;
}
)
;
add_task
(
async
function
test_flushLogFile
(
)
{
_
(
"
Tests
flushLogFile
"
)
;
let
account
=
await
MakeFxAccounts
(
)
;
let
promiseObserved
=
new
Promise
(
res
=
>
{
log
.
info
(
"
Adding
flush
-
log
-
file
observer
.
"
)
;
Services
.
obs
.
addObserver
(
function
onFlushLogFile
(
)
{
Services
.
obs
.
removeObserver
(
onFlushLogFile
"
service
:
log
-
manager
:
flush
-
log
-
file
"
)
;
res
(
)
;
}
"
service
:
log
-
manager
:
flush
-
log
-
file
"
)
;
}
)
;
account
.
flushLogFile
(
)
;
await
promiseObserved
;
}
)
;
function
expandHex
(
two_hex
)
{
let
eight_hex
=
two_hex
+
two_hex
+
two_hex
+
two_hex
;
let
thirtytwo_hex
=
eight_hex
+
eight_hex
+
eight_hex
+
eight_hex
;
return
thirtytwo_hex
+
thirtytwo_hex
;
}
function
expandBytes
(
two_hex
)
{
return
CommonUtils
.
hexToBytes
(
expandHex
(
two_hex
)
)
;
}
function
getTestUser
(
name
)
{
return
{
email
:
name
+
"
example
.
com
"
uid
:
"
1ad7f5024cc74ec1a209071fd2fae348
"
sessionToken
:
name
+
"
'
s
session
token
"
keyFetchToken
:
name
+
"
'
s
keyfetch
token
"
unwrapBKey
:
expandHex
(
"
44
"
)
verified
:
false
}
;
}
function
makeObserver
(
aObserveTopic
aObserveFunc
)
{
let
observer
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
observe
(
aSubject
aTopic
aData
)
{
log
.
debug
(
"
observed
"
+
aTopic
+
"
"
+
aData
)
;
if
(
aTopic
=
=
aObserveTopic
)
{
removeMe
(
)
;
aObserveFunc
(
aSubject
aTopic
aData
)
;
}
}
}
;
function
removeMe
(
)
{
log
.
debug
(
"
removing
observer
for
"
+
aObserveTopic
)
;
Services
.
obs
.
removeObserver
(
observer
aObserveTopic
)
;
}
Services
.
obs
.
addObserver
(
observer
aObserveTopic
)
;
return
removeMe
;
}
