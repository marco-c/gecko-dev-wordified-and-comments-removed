"
use
strict
"
;
const
{
getFxAccountsSingleton
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
sys
.
mjs
"
)
;
const
fxAccounts
=
getFxAccountsSingleton
(
)
;
const
{
ON_NEW_DEVICE_ID
PREF_ACCOUNT_ROOT
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
sys
.
mjs
"
)
;
function
promiseObserved
(
topic
)
{
return
new
Promise
(
res
=
>
{
Services
.
obs
.
addObserver
(
res
topic
)
;
}
)
;
}
_
(
"
Misc
tests
for
FxAccounts
.
device
"
)
;
fxAccounts
.
device
.
_checkRemoteCommandsUpdateNeeded
=
async
(
)
=
>
false
;
add_test
(
function
test_default_device_name
(
)
{
let
def
=
fxAccounts
.
device
.
getDefaultLocalName
(
)
;
_
(
"
default
value
is
"
+
def
)
;
ok
(
!
!
def
.
length
)
;
let
hostname
=
Services
.
sysinfo
.
get
(
"
device
"
)
|
|
Services
.
dns
.
myHostName
;
_
(
"
hostname
is
"
+
hostname
)
;
ok
(
!
!
hostname
.
length
)
;
ok
(
def
.
includes
(
hostname
)
)
;
let
fallback
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
.
oscpu
;
_
(
"
UA
fallback
is
"
+
fallback
)
;
ok
(
!
!
fallback
.
length
)
;
ok
(
!
def
.
includes
(
fallback
)
)
;
run_next_test
(
)
;
}
)
;
add_test
(
function
test_migration
(
)
{
Services
.
prefs
.
clearUserPref
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
)
;
Services
.
prefs
.
setStringPref
(
"
services
.
sync
.
client
.
name
"
"
my
client
name
"
)
;
equal
(
fxAccounts
.
device
.
getLocalName
(
)
"
my
client
name
"
)
;
equal
(
Services
.
prefs
.
getStringPref
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
)
"
my
client
name
"
)
;
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
client
.
name
"
)
)
;
run_next_test
(
)
;
}
)
;
add_test
(
function
test_migration_set_before_get
(
)
{
Services
.
prefs
.
setStringPref
(
"
services
.
sync
.
client
.
name
"
"
old
client
name
"
)
;
fxAccounts
.
device
.
setLocalName
(
"
new
client
name
"
)
;
equal
(
fxAccounts
.
device
.
getLocalName
(
)
"
new
client
name
"
)
;
run_next_test
(
)
;
}
)
;
add_task
(
async
function
test_reset
(
)
{
const
testPref
=
PREF_ACCOUNT_ROOT
+
"
test
-
pref
"
;
Services
.
prefs
.
setStringPref
(
testPref
"
whatever
"
)
;
let
credentials
=
{
email
:
"
foo
example
.
com
"
uid
:
"
1234
lcip
.
org
"
sessionToken
:
"
dead
"
verified
:
true
.
.
.
MOCK_ACCOUNT_KEYS
}
;
const
registerDevice
=
sinon
.
stub
(
fxAccounts
.
_internal
.
fxAccountsClient
"
registerDevice
"
)
.
callsFake
(
async
(
)
=
>
{
return
{
id
:
"
foo
"
}
;
}
)
;
await
fxAccounts
.
_internal
.
setSignedInUser
(
credentials
)
;
await
promiseObserved
(
ON_NEW_DEVICE_ID
)
;
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
testPref
)
)
;
const
namePref
=
PREF_ACCOUNT_ROOT
+
"
device
.
name
"
;
ok
(
Services
.
prefs
.
prefHasUserValue
(
namePref
)
)
;
await
fxAccounts
.
signOut
(
true
)
;
ok
(
!
Services
.
prefs
.
prefHasUserValue
(
namePref
)
)
;
registerDevice
.
restore
(
)
;
}
)
;
add_task
(
async
function
test_name_sanitization
(
)
{
fxAccounts
.
device
.
setLocalName
(
"
emoji
is
valid
\
u2665
"
)
;
Assert
.
equal
(
fxAccounts
.
device
.
getLocalName
(
)
"
emoji
is
valid
\
u2665
"
)
;
let
invalid
=
"
x
\
uFFFD
\
n
\
r
\
t
"
+
"
x
"
.
repeat
(
255
)
;
let
sanitized
=
"
x
\
uFFFD
\
uFFFD
\
uFFFD
\
uFFFD
"
+
"
x
"
.
repeat
(
250
)
;
Services
.
prefs
.
setStringPref
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
invalid
)
;
Assert
.
equal
(
fxAccounts
.
device
.
getLocalName
(
)
sanitized
)
;
fxAccounts
.
device
.
setLocalName
(
invalid
)
;
Assert
.
equal
(
fxAccounts
.
device
.
getLocalName
(
)
sanitized
)
;
Assert
.
equal
(
Services
.
prefs
.
getStringPref
(
"
identity
.
fxaccounts
.
account
.
device
.
name
"
)
sanitized
)
;
}
)
;
