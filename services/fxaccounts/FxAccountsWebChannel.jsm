this
.
EXPORTED_SYMBOLS
=
[
"
EnsureFxAccountsWebChannel
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
WebChannel
"
"
resource
:
/
/
gre
/
modules
/
WebChannel
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
FxAccountsStorageManagerCanStoreField
"
"
resource
:
/
/
gre
/
modules
/
FxAccountsStorage
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Weave
"
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
const
COMMAND_PROFILE_CHANGE
=
"
profile
:
change
"
;
const
COMMAND_CAN_LINK_ACCOUNT
=
"
fxaccounts
:
can_link_account
"
;
const
COMMAND_LOGIN
=
"
fxaccounts
:
login
"
;
const
COMMAND_LOGOUT
=
"
fxaccounts
:
logout
"
;
const
COMMAND_DELETE
=
"
fxaccounts
:
delete
"
;
const
COMMAND_SYNC_PREFERENCES
=
"
fxaccounts
:
sync_preferences
"
;
const
COMMAND_CHANGE_PASSWORD
=
"
fxaccounts
:
change_password
"
;
const
PREF_LAST_FXA_USER
=
"
identity
.
fxaccounts
.
lastSignedInUserHash
"
;
function
getErrorDetails
(
error
)
{
let
details
=
{
message
:
String
(
error
)
stack
:
null
}
;
if
(
error
.
stack
)
{
let
frames
=
[
]
;
for
(
let
frame
=
error
.
stack
;
frame
;
frame
=
frame
.
caller
)
{
frames
.
push
(
String
(
frame
)
.
padStart
(
4
)
)
;
}
details
.
stack
=
frames
.
join
(
"
\
n
"
)
;
}
return
details
;
}
this
.
FxAccountsWebChannel
=
function
(
options
)
{
if
(
!
options
)
{
throw
new
Error
(
"
Missing
configuration
options
"
)
;
}
if
(
!
options
[
"
content_uri
"
]
)
{
throw
new
Error
(
"
Missing
'
content_uri
'
option
"
)
;
}
this
.
_contentUri
=
options
.
content_uri
;
if
(
!
options
[
"
channel_id
"
]
)
{
throw
new
Error
(
"
Missing
'
channel_id
'
option
"
)
;
}
this
.
_webChannelId
=
options
.
channel_id
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_helpers
"
(
)
=
>
{
return
options
.
helpers
|
|
new
FxAccountsWebChannelHelpers
(
options
)
;
}
)
;
this
.
_setupChannel
(
)
;
}
;
this
.
FxAccountsWebChannel
.
prototype
=
{
_channel
:
null
_helpers
:
null
_webChannelId
:
null
_webChannelOrigin
:
null
tearDown
(
)
{
this
.
_channel
.
stopListening
(
)
;
this
.
_channel
=
null
;
this
.
_channelCallback
=
null
;
}
_setupChannel
(
)
{
try
{
this
.
_webChannelOrigin
=
Services
.
io
.
newURI
(
this
.
_contentUri
)
;
this
.
_registerChannel
(
)
;
}
catch
(
e
)
{
log
.
error
(
e
)
;
throw
e
;
}
}
_receiveMessage
(
message
sendingContext
)
{
let
command
=
message
.
command
;
let
data
=
message
.
data
;
switch
(
command
)
{
case
COMMAND_PROFILE_CHANGE
:
Services
.
obs
.
notifyObservers
(
null
ON_PROFILE_CHANGE_NOTIFICATION
data
.
uid
)
;
break
;
case
COMMAND_LOGIN
:
this
.
_helpers
.
login
(
data
)
.
catch
(
error
=
>
this
.
_sendError
(
error
message
sendingContext
)
)
;
break
;
case
COMMAND_LOGOUT
:
case
COMMAND_DELETE
:
this
.
_helpers
.
logout
(
data
.
uid
)
.
catch
(
error
=
>
this
.
_sendError
(
error
message
sendingContext
)
)
;
break
;
case
COMMAND_CAN_LINK_ACCOUNT
:
let
canLinkAccount
=
this
.
_helpers
.
shouldAllowRelink
(
data
.
email
)
;
let
response
=
{
command
messageId
:
message
.
messageId
data
:
{
ok
:
canLinkAccount
}
}
;
log
.
debug
(
"
FxAccountsWebChannel
response
"
response
)
;
this
.
_channel
.
send
(
response
sendingContext
)
;
break
;
case
COMMAND_SYNC_PREFERENCES
:
this
.
_helpers
.
openSyncPreferences
(
sendingContext
.
browser
data
.
entryPoint
)
;
break
;
case
COMMAND_CHANGE_PASSWORD
:
this
.
_helpers
.
changePassword
(
data
)
.
catch
(
error
=
>
this
.
_sendError
(
error
message
sendingContext
)
)
;
break
;
default
:
log
.
warn
(
"
Unrecognized
FxAccountsWebChannel
command
"
command
)
;
break
;
}
}
_sendError
(
error
incomingMessage
sendingContext
)
{
log
.
error
(
"
Failed
to
handle
FxAccountsWebChannel
message
"
error
)
;
this
.
_channel
.
send
(
{
command
:
incomingMessage
.
command
messageId
:
incomingMessage
.
messageId
data
:
{
error
:
getErrorDetails
(
error
)
}
}
sendingContext
)
;
}
_registerChannel
(
)
{
let
listener
=
(
webChannelId
message
sendingContext
)
=
>
{
if
(
message
)
{
log
.
debug
(
"
FxAccountsWebChannel
message
received
"
message
.
command
)
;
if
(
logPII
)
{
log
.
debug
(
"
FxAccountsWebChannel
message
details
"
message
)
;
}
try
{
this
.
_receiveMessage
(
message
sendingContext
)
;
}
catch
(
error
)
{
this
.
_sendError
(
error
message
sendingContext
)
;
}
}
}
;
this
.
_channelCallback
=
listener
;
this
.
_channel
=
new
WebChannel
(
this
.
_webChannelId
this
.
_webChannelOrigin
)
;
this
.
_channel
.
listen
(
listener
)
;
log
.
debug
(
"
FxAccountsWebChannel
registered
:
"
+
this
.
_webChannelId
+
"
with
origin
"
+
this
.
_webChannelOrigin
.
prePath
)
;
}
}
;
this
.
FxAccountsWebChannelHelpers
=
function
(
options
)
{
options
=
options
|
|
{
}
;
this
.
_fxAccounts
=
options
.
fxAccounts
|
|
fxAccounts
;
}
;
this
.
FxAccountsWebChannelHelpers
.
prototype
=
{
shouldAllowRelink
(
acctName
)
{
return
!
this
.
_needRelinkWarning
(
acctName
)
|
|
this
.
_promptForRelink
(
acctName
)
;
}
login
(
accountData
)
{
delete
accountData
.
customizeSync
;
if
(
accountData
.
declinedSyncEngines
)
{
let
declinedSyncEngines
=
accountData
.
declinedSyncEngines
;
log
.
debug
(
"
Received
declined
engines
"
declinedSyncEngines
)
;
Weave
.
Service
.
engineManager
.
setDeclined
(
declinedSyncEngines
)
;
declinedSyncEngines
.
forEach
(
engine
=
>
{
Services
.
prefs
.
setBoolPref
(
"
services
.
sync
.
engine
.
"
+
engine
false
)
;
}
)
;
delete
accountData
.
declinedSyncEngines
;
}
delete
accountData
.
verifiedCanLinkAccount
;
this
.
setPreviousAccountNameHashPref
(
accountData
.
email
)
;
let
xps
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
return
xps
.
whenLoaded
(
)
.
then
(
(
)
=
>
{
return
this
.
_fxAccounts
.
setSignedInUser
(
accountData
)
;
}
)
;
}
logout
(
uid
)
{
return
fxAccounts
.
getSignedInUser
(
)
.
then
(
userData
=
>
{
if
(
userData
.
uid
=
=
=
uid
)
{
return
fxAccounts
.
signOut
(
true
)
;
}
return
null
;
}
)
;
}
changePassword
(
credentials
)
{
let
newCredentials
=
{
deviceId
:
null
}
;
for
(
let
name
of
Object
.
keys
(
credentials
)
)
{
if
(
name
=
=
"
email
"
|
|
name
=
=
"
uid
"
|
|
FxAccountsStorageManagerCanStoreField
(
name
)
)
{
newCredentials
[
name
]
=
credentials
[
name
]
;
}
else
{
log
.
info
(
"
changePassword
ignoring
unsupported
field
"
name
)
;
}
}
return
this
.
_fxAccounts
.
updateUserAccountData
(
newCredentials
)
.
then
(
(
)
=
>
this
.
_fxAccounts
.
updateDeviceRegistration
(
)
)
;
}
getPreviousAccountNameHashPref
(
)
{
try
{
return
Services
.
prefs
.
getStringPref
(
PREF_LAST_FXA_USER
)
;
}
catch
(
_
)
{
return
"
"
;
}
}
setPreviousAccountNameHashPref
(
acctName
)
{
Services
.
prefs
.
setStringPref
(
PREF_LAST_FXA_USER
this
.
sha256
(
acctName
)
)
;
}
sha256
(
str
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
data
=
converter
.
convertToByteArray
(
str
{
}
)
;
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
length
)
;
return
hasher
.
finish
(
true
)
;
}
openSyncPreferences
(
browser
entryPoint
)
{
let
uri
=
"
about
:
preferences
"
;
if
(
entryPoint
)
{
uri
+
=
"
?
entrypoint
=
"
+
encodeURIComponent
(
entryPoint
)
;
}
uri
+
=
"
#
sync
"
;
browser
.
loadURI
(
uri
)
;
}
_needRelinkWarning
(
acctName
)
{
let
prevAcctHash
=
this
.
getPreviousAccountNameHashPref
(
)
;
return
prevAcctHash
&
&
prevAcctHash
!
=
this
.
sha256
(
acctName
)
;
}
_promptForRelink
(
acctName
)
{
let
sb
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
browser
/
locale
/
syncSetup
.
properties
"
)
;
let
continueLabel
=
sb
.
GetStringFromName
(
"
continue
.
label
"
)
;
let
title
=
sb
.
GetStringFromName
(
"
relinkVerify
.
title
"
)
;
let
description
=
sb
.
formatStringFromName
(
"
relinkVerify
.
description
"
[
acctName
]
1
)
;
let
body
=
sb
.
GetStringFromName
(
"
relinkVerify
.
heading
"
)
+
"
\
n
\
n
"
+
description
;
let
ps
=
Services
.
prompt
;
let
buttonFlags
=
(
ps
.
BUTTON_POS_0
*
ps
.
BUTTON_TITLE_IS_STRING
)
+
(
ps
.
BUTTON_POS_1
*
ps
.
BUTTON_TITLE_CANCEL
)
+
ps
.
BUTTON_POS_1_DEFAULT
;
var
targetWindow
=
typeof
window
=
=
=
"
undefined
"
?
null
:
window
;
let
pressed
=
Services
.
prompt
.
confirmEx
(
targetWindow
title
body
buttonFlags
continueLabel
null
null
null
{
}
)
;
return
pressed
=
=
=
0
;
}
}
;
var
singleton
;
this
.
EnsureFxAccountsWebChannel
=
function
(
)
{
let
contentUri
=
Services
.
urlFormatter
.
formatURLPref
(
"
identity
.
fxaccounts
.
remote
.
webchannel
.
uri
"
)
;
if
(
singleton
&
&
singleton
.
_contentUri
!
=
=
contentUri
)
{
singleton
.
tearDown
(
)
;
singleton
=
null
;
}
if
(
!
singleton
)
{
try
{
if
(
contentUri
)
{
singleton
=
new
this
.
FxAccountsWebChannel
(
{
content_uri
:
contentUri
channel_id
:
WEBCHANNEL_ID
}
)
;
}
else
{
log
.
warn
(
"
FxA
WebChannel
functionaly
is
disabled
due
to
no
URI
pref
.
"
)
;
}
}
catch
(
ex
)
{
log
.
error
(
"
Failed
to
create
FxA
WebChannel
"
ex
)
;
}
}
}
