var
EXPORTED_SYMBOLS
=
[
"
FxAccountsClient
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
hawkclient
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
hawkrequest
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Credentials
.
jsm
"
)
;
const
HOST_PREF
=
"
identity
.
fxaccounts
.
auth
.
uri
"
;
const
SIGNIN
=
"
/
account
/
login
"
;
const
SIGNUP
=
"
/
account
/
create
"
;
var
FxAccountsClient
=
function
(
host
=
Services
.
prefs
.
getCharPref
(
HOST_PREF
)
)
{
this
.
host
=
host
;
this
.
hawk
=
new
HawkClient
(
host
)
;
this
.
hawk
.
observerPrefix
=
"
FxA
:
hawk
"
;
this
.
backoffError
=
null
;
}
;
this
.
FxAccountsClient
.
prototype
=
{
get
localtimeOffsetMsec
(
)
{
return
this
.
hawk
.
localtimeOffsetMsec
;
}
now
(
)
{
return
this
.
hawk
.
now
(
)
;
}
_createSession
(
path
email
password
getKeys
=
false
retryOK
=
true
)
{
return
Credentials
.
setup
(
email
password
)
.
then
(
(
creds
)
=
>
{
let
data
=
{
authPW
:
CommonUtils
.
bytesAsHex
(
creds
.
authPW
)
email
}
;
let
keys
=
getKeys
?
"
?
keys
=
true
"
:
"
"
;
return
this
.
_request
(
path
+
keys
"
POST
"
null
data
)
.
then
(
result
=
>
{
result
.
email
=
data
.
email
;
result
.
unwrapBKey
=
CommonUtils
.
bytesAsHex
(
creds
.
unwrapBKey
)
;
return
result
;
}
error
=
>
{
log
.
debug
(
"
Session
creation
failed
"
error
)
;
if
(
ERRNO_INCORRECT_EMAIL_CASE
=
=
=
error
.
errno
&
&
retryOK
)
{
if
(
!
error
.
email
)
{
log
.
error
(
"
Server
returned
errno
120
but
did
not
provide
email
"
)
;
throw
error
;
}
return
this
.
_createSession
(
path
error
.
email
password
getKeys
false
)
;
}
throw
error
;
}
)
;
}
)
;
}
signUp
(
email
password
getKeys
=
false
)
{
return
this
.
_createSession
(
SIGNUP
email
password
getKeys
false
)
;
}
signIn
:
function
signIn
(
email
password
getKeys
=
false
)
{
return
this
.
_createSession
(
SIGNIN
email
password
getKeys
true
)
;
}
sessionStatus
(
sessionTokenHex
)
{
return
this
.
_request
(
"
/
session
/
status
"
"
GET
"
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
)
.
then
(
(
)
=
>
Promise
.
resolve
(
true
)
error
=
>
{
if
(
isInvalidTokenError
(
error
)
)
{
return
Promise
.
resolve
(
false
)
;
}
throw
error
;
}
)
;
}
signOut
(
sessionTokenHex
options
=
{
}
)
{
let
path
=
"
/
session
/
destroy
"
;
if
(
options
.
service
)
{
path
+
=
"
?
service
=
"
+
encodeURIComponent
(
options
.
service
)
;
}
return
this
.
_request
(
path
"
POST
"
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
)
;
}
recoveryEmailStatus
(
sessionTokenHex
options
=
{
}
)
{
let
path
=
"
/
recovery_email
/
status
"
;
if
(
options
.
reason
)
{
path
+
=
"
?
reason
=
"
+
encodeURIComponent
(
options
.
reason
)
;
}
return
this
.
_request
(
path
"
GET
"
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
)
;
}
resendVerificationEmail
(
sessionTokenHex
)
{
return
this
.
_request
(
"
/
recovery_email
/
resend_code
"
"
POST
"
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
)
;
}
accountKeys
(
keyFetchTokenHex
)
{
let
creds
=
deriveHawkCredentials
(
keyFetchTokenHex
"
keyFetchToken
"
)
;
let
keyRequestKey
=
creds
.
extra
.
slice
(
0
32
)
;
let
morecreds
=
CryptoUtils
.
hkdf
(
keyRequestKey
undefined
Credentials
.
keyWord
(
"
account
/
keys
"
)
3
*
32
)
;
let
respHMACKey
=
morecreds
.
slice
(
0
32
)
;
let
respXORKey
=
morecreds
.
slice
(
32
96
)
;
return
this
.
_request
(
"
/
account
/
keys
"
"
GET
"
creds
)
.
then
(
resp
=
>
{
if
(
!
resp
.
bundle
)
{
throw
new
Error
(
"
failed
to
retrieve
keys
"
)
;
}
let
bundle
=
CommonUtils
.
hexToBytes
(
resp
.
bundle
)
;
let
mac
=
bundle
.
slice
(
-
32
)
;
let
hasher
=
CryptoUtils
.
makeHMACHasher
(
Ci
.
nsICryptoHMAC
.
SHA256
CryptoUtils
.
makeHMACKey
(
respHMACKey
)
)
;
let
bundleMAC
=
CryptoUtils
.
digestBytes
(
bundle
.
slice
(
0
-
32
)
hasher
)
;
if
(
mac
!
=
=
bundleMAC
)
{
throw
new
Error
(
"
error
unbundling
encryption
keys
"
)
;
}
let
keyAWrapB
=
CryptoUtils
.
xor
(
respXORKey
bundle
.
slice
(
0
64
)
)
;
return
{
kA
:
keyAWrapB
.
slice
(
0
32
)
wrapKB
:
keyAWrapB
.
slice
(
32
)
}
;
}
)
;
}
signCertificate
(
sessionTokenHex
serializedPublicKey
lifetime
)
{
let
creds
=
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
;
let
body
=
{
publicKey
:
serializedPublicKey
duration
:
lifetime
}
;
return
Promise
.
resolve
(
)
.
then
(
_
=
>
this
.
_request
(
"
/
certificate
/
sign
"
"
POST
"
creds
body
)
)
.
then
(
resp
=
>
resp
.
cert
err
=
>
{
log
.
error
(
"
HAWK
.
signCertificate
error
:
"
+
JSON
.
stringify
(
err
)
)
;
throw
err
;
}
)
;
}
accountExists
(
email
)
{
return
this
.
signIn
(
email
"
"
)
.
then
(
(
cantHappen
)
=
>
{
throw
new
Error
(
"
How
did
I
sign
in
with
an
empty
password
?
"
)
;
}
(
expectedError
)
=
>
{
switch
(
expectedError
.
errno
)
{
case
ERRNO_ACCOUNT_DOES_NOT_EXIST
:
return
false
;
case
ERRNO_INCORRECT_PASSWORD
:
return
true
;
default
:
throw
expectedError
;
}
}
)
;
}
accountStatus
(
uid
)
{
return
this
.
_request
(
"
/
account
/
status
?
uid
=
"
+
uid
"
GET
"
)
.
then
(
(
result
)
=
>
{
return
result
.
exists
;
}
(
error
)
=
>
{
log
.
error
(
"
accountStatus
failed
with
:
"
+
error
)
;
return
Promise
.
reject
(
error
)
;
}
)
;
}
registerDevice
(
sessionTokenHex
name
type
options
=
{
}
)
{
let
path
=
"
/
account
/
device
"
;
let
creds
=
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
;
let
body
=
{
name
type
}
;
if
(
options
.
pushCallback
)
{
body
.
pushCallback
=
options
.
pushCallback
;
}
if
(
options
.
pushPublicKey
&
&
options
.
pushAuthKey
)
{
body
.
pushPublicKey
=
options
.
pushPublicKey
;
body
.
pushAuthKey
=
options
.
pushAuthKey
;
}
return
this
.
_request
(
path
"
POST
"
creds
body
)
;
}
notifyDevices
(
sessionTokenHex
deviceIds
excludedIds
payload
TTL
=
0
)
{
if
(
deviceIds
&
&
excludedIds
)
{
throw
new
Error
(
"
You
cannot
specify
excluded
devices
if
deviceIds
is
set
.
"
)
;
}
const
body
=
{
to
:
deviceIds
|
|
"
all
"
payload
TTL
}
;
if
(
excludedIds
)
{
body
.
excluded
=
excludedIds
;
}
return
this
.
_request
(
"
/
account
/
devices
/
notify
"
"
POST
"
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
body
)
;
}
updateDevice
(
sessionTokenHex
id
name
options
=
{
}
)
{
let
path
=
"
/
account
/
device
"
;
let
creds
=
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
;
let
body
=
{
id
name
}
;
if
(
options
.
pushCallback
)
{
body
.
pushCallback
=
options
.
pushCallback
;
}
if
(
options
.
pushPublicKey
&
&
options
.
pushAuthKey
)
{
body
.
pushPublicKey
=
options
.
pushPublicKey
;
body
.
pushAuthKey
=
options
.
pushAuthKey
;
}
return
this
.
_request
(
path
"
POST
"
creds
body
)
;
}
getDeviceList
(
sessionTokenHex
)
{
let
path
=
"
/
account
/
devices
"
;
let
creds
=
deriveHawkCredentials
(
sessionTokenHex
"
sessionToken
"
)
;
return
this
.
_request
(
path
"
GET
"
creds
{
}
)
;
}
_clearBackoff
(
)
{
this
.
backoffError
=
null
;
}
async
_request
(
path
method
credentials
jsonPayload
)
{
if
(
this
.
backoffError
)
{
log
.
debug
(
"
Received
new
request
during
backoff
re
-
rejecting
.
"
)
;
throw
this
.
backoffError
;
}
let
response
;
try
{
response
=
await
this
.
hawk
.
request
(
path
method
credentials
jsonPayload
)
;
}
catch
(
error
)
{
log
.
error
(
"
error
"
+
method
+
"
ing
"
+
path
+
"
:
"
+
JSON
.
stringify
(
error
)
)
;
if
(
error
.
retryAfter
)
{
log
.
debug
(
"
Received
backoff
response
;
caching
error
as
flag
.
"
)
;
this
.
backoffError
=
error
;
CommonUtils
.
namedTimer
(
this
.
_clearBackoff
error
.
retryAfter
*
1000
this
"
fxaBackoffTimer
"
)
;
}
throw
error
;
}
try
{
return
JSON
.
parse
(
response
.
body
)
;
}
catch
(
error
)
{
log
.
error
(
"
json
parse
error
on
response
:
"
+
response
.
body
)
;
throw
{
error
}
;
}
}
}
;
function
isInvalidTokenError
(
error
)
{
if
(
error
.
code
!
=
401
)
{
return
false
;
}
switch
(
error
.
errno
)
{
case
ERRNO_INVALID_AUTH_TOKEN
:
case
ERRNO_INVALID_AUTH_TIMESTAMP
:
case
ERRNO_INVALID_AUTH_NONCE
:
return
true
;
}
return
false
;
}
