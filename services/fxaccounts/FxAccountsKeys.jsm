"
use
strict
"
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
CryptoUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
{
LEGACY_DERIVED_KEYS_NAMES
SCOPE_OLD_SYNC
LEGACY_SCOPE_WEBEXT_SYNC
DEPRECATED_SCOPE_ECOSYSTEM_TELEMETRY
FX_OAUTH_CLIENT_ID
log
logPII
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
)
;
const
LEGACY_DERIVED_KEY_SCOPES
=
[
SCOPE_OLD_SYNC
LEGACY_SCOPE_WEBEXT_SYNC
]
;
const
DEPRECATED_KEY_SCOPES
=
[
DEPRECATED_SCOPE_ECOSYSTEM_TELEMETRY
]
;
class
FxAccountsKeys
{
constructor
(
fxAccountsInternal
)
{
this
.
_fxai
=
fxAccountsInternal
;
}
canGetKeyForScope
(
scope
)
{
return
this
.
_fxai
.
withCurrentAccountState
(
async
currentState
=
>
{
let
userData
=
await
currentState
.
getUserAccountData
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
Can
'
t
possibly
get
keys
;
User
is
not
signed
in
"
)
;
}
if
(
!
userData
.
verified
)
{
log
.
info
(
"
Can
'
t
get
keys
;
user
is
not
verified
"
)
;
return
false
;
}
if
(
userData
.
scopedKeys
&
&
userData
.
scopedKeys
.
hasOwnProperty
(
scope
)
)
{
return
true
;
}
if
(
scope
=
=
SCOPE_OLD_SYNC
)
{
if
(
userData
.
kSync
&
&
userData
.
kXCS
)
{
return
true
;
}
}
if
(
scope
=
=
LEGACY_SCOPE_WEBEXT_SYNC
)
{
if
(
userData
.
kExtSync
&
&
userData
.
kExtKbHash
)
{
return
true
;
}
}
if
(
userData
.
kB
)
{
return
true
;
}
if
(
userData
.
keyFetchToken
)
{
return
true
;
}
log
.
info
(
"
Can
'
t
get
keys
;
no
key
material
or
tokens
available
"
)
;
return
false
;
}
)
;
}
async
getKeyForScope
(
scope
)
{
const
{
scopedKeys
}
=
await
this
.
_loadOrFetchKeys
(
)
;
if
(
!
scopedKeys
.
hasOwnProperty
(
scope
)
)
{
throw
new
Error
(
Key
not
available
for
scope
"
{
scope
}
"
)
;
}
return
{
scope
.
.
.
scopedKeys
[
scope
]
}
;
}
keyAsHex
(
jwk
)
{
return
CommonUtils
.
base64urlToHex
(
jwk
.
k
)
;
}
kidAsHex
(
jwk
)
{
const
idx
=
jwk
.
kid
.
indexOf
(
"
-
"
)
+
1
;
if
(
idx
<
=
1
)
{
throw
new
Error
(
Invalid
kid
:
{
jwk
.
kid
}
)
;
}
return
CommonUtils
.
base64urlToHex
(
jwk
.
kid
.
slice
(
idx
)
)
;
}
async
_loadOrFetchKeys
(
)
{
return
this
.
_fxai
.
withCurrentAccountState
(
async
currentState
=
>
{
try
{
let
userData
=
await
currentState
.
getUserAccountData
(
)
;
if
(
!
userData
)
{
throw
new
Error
(
"
Can
'
t
get
keys
;
User
is
not
signed
in
"
)
;
}
if
(
userData
.
scopedKeys
)
{
if
(
LEGACY_DERIVED_KEY_SCOPES
.
every
(
scope
=
>
userData
.
scopedKeys
.
hasOwnProperty
(
scope
)
)
&
&
!
DEPRECATED_KEY_SCOPES
.
some
(
scope
=
>
userData
.
scopedKeys
.
hasOwnProperty
(
scope
)
)
)
{
return
userData
;
}
}
if
(
!
currentState
.
whenKeysReadyDeferred
)
{
currentState
.
whenKeysReadyDeferred
=
PromiseUtils
.
defer
(
)
;
this
.
_migrateOrFetchKeys
(
currentState
userData
)
.
then
(
dataWithKeys
=
>
{
currentState
.
whenKeysReadyDeferred
.
resolve
(
dataWithKeys
)
;
currentState
.
whenKeysReadyDeferred
=
null
;
}
err
=
>
{
currentState
.
whenKeysReadyDeferred
.
reject
(
err
)
;
currentState
.
whenKeysReadyDeferred
=
null
;
}
)
;
}
return
await
currentState
.
whenKeysReadyDeferred
.
promise
;
}
catch
(
err
)
{
return
this
.
_fxai
.
_handleTokenError
(
err
)
;
}
}
)
;
}
async
_migrateOrFetchKeys
(
currentState
userData
)
{
if
(
userData
.
scopedKeys
)
{
const
toRemove
=
DEPRECATED_KEY_SCOPES
.
filter
(
scope
=
>
userData
.
scopedKeys
.
hasOwnProperty
(
scope
)
)
;
if
(
toRemove
.
length
)
{
for
(
const
scope
of
toRemove
)
{
delete
userData
.
scopedKeys
[
scope
]
;
}
await
currentState
.
updateUserAccountData
(
{
scopedKeys
:
userData
.
scopedKeys
ecosystemUserId
:
null
ecosystemAnonId
:
null
}
)
;
userData
=
await
currentState
.
getUserAccountData
(
)
;
return
userData
;
}
}
if
(
LEGACY_DERIVED_KEYS_NAMES
.
every
(
name
=
>
userData
.
hasOwnProperty
(
name
)
)
)
{
log
.
info
(
"
Migrating
from
legacy
key
fields
to
scopedKeys
.
"
)
;
const
scopedKeys
=
userData
.
scopedKeys
|
|
{
}
;
await
currentState
.
updateUserAccountData
(
{
scopedKeys
:
{
.
.
.
scopedKeys
.
.
.
(
await
this
.
_deriveScopedKeysFromAccountData
(
userData
)
)
}
}
)
;
userData
=
await
currentState
.
getUserAccountData
(
)
;
return
userData
;
}
if
(
userData
.
kB
)
{
log
.
info
(
"
Migrating
kB
to
derived
keys
.
"
)
;
const
{
uid
kB
sessionToken
}
=
userData
;
const
scopedKeysMetadata
=
await
this
.
_fetchScopedKeysMetadata
(
sessionToken
)
;
await
currentState
.
updateUserAccountData
(
{
uid
.
.
.
(
await
this
.
_deriveKeys
(
uid
CommonUtils
.
hexToBytes
(
kB
)
scopedKeysMetadata
)
)
kA
:
null
kB
:
null
}
)
;
userData
=
await
currentState
.
getUserAccountData
(
)
;
return
userData
;
}
if
(
!
userData
.
sessionToken
)
{
throw
new
Error
(
"
No
sessionToken
"
)
;
}
if
(
!
userData
.
keyFetchToken
)
{
throw
new
Error
(
"
No
keyFetchToken
"
)
;
}
return
this
.
_fetchAndUnwrapAndDeriveKeys
(
currentState
userData
.
sessionToken
userData
.
keyFetchToken
)
;
}
async
_fetchAndUnwrapAndDeriveKeys
(
currentState
sessionToken
keyFetchToken
)
{
if
(
logPII
)
{
log
.
debug
(
fetchAndUnwrapKeys
:
sessionToken
:
{
sessionToken
}
keyFetchToken
:
{
keyFetchToken
}
)
;
}
if
(
!
sessionToken
|
|
!
keyFetchToken
)
{
log
.
warn
(
"
improper
_fetchAndUnwrapKeys
(
)
call
:
token
missing
"
)
;
await
this
.
_fxai
.
signOut
(
)
;
return
null
;
}
const
scopedKeysMetadata
=
await
this
.
_fetchScopedKeysMetadata
(
sessionToken
)
;
let
{
wrapKB
}
=
await
this
.
_fetchKeys
(
keyFetchToken
)
;
let
data
=
await
currentState
.
getUserAccountData
(
)
;
if
(
data
.
keyFetchToken
!
=
=
keyFetchToken
)
{
throw
new
Error
(
"
Signed
in
user
changed
while
fetching
keys
!
"
)
;
}
let
kBbytes
=
CryptoUtils
.
xor
(
CommonUtils
.
hexToBytes
(
data
.
unwrapBKey
)
wrapKB
)
;
if
(
logPII
)
{
log
.
debug
(
"
kBbytes
:
"
+
kBbytes
)
;
}
let
updateData
=
{
.
.
.
(
await
this
.
_deriveKeys
(
data
.
uid
kBbytes
scopedKeysMetadata
)
)
keyFetchToken
:
null
unwrapBKey
:
null
}
;
if
(
logPII
)
{
log
.
debug
(
Keys
Obtained
:
{
updateData
.
scopedKeys
}
)
;
}
else
{
log
.
debug
(
"
Keys
Obtained
:
"
+
Object
.
keys
(
updateData
.
scopedKeys
)
.
join
(
"
"
)
)
;
}
const
EXPECTED_FIELDS
=
LEGACY_DERIVED_KEYS_NAMES
.
concat
(
[
"
scopedKeys
"
]
)
;
if
(
EXPECTED_FIELDS
.
some
(
k
=
>
!
updateData
[
k
]
)
)
{
const
missing
=
EXPECTED_FIELDS
.
filter
(
k
=
>
!
updateData
[
k
]
)
;
throw
new
Error
(
user
data
missing
:
{
missing
.
join
(
"
"
)
}
)
;
}
await
currentState
.
updateUserAccountData
(
updateData
)
;
return
currentState
.
getUserAccountData
(
)
;
}
_fetchKeys
(
keyFetchToken
)
{
let
client
=
this
.
_fxai
.
fxAccountsClient
;
log
.
debug
(
Fetching
keys
with
token
{
!
!
keyFetchToken
}
from
{
client
.
host
}
)
;
if
(
logPII
)
{
log
.
debug
(
"
fetchKeys
-
the
token
is
"
+
keyFetchToken
)
;
}
return
client
.
accountKeys
(
keyFetchToken
)
;
}
async
_fetchScopedKeysMetadata
(
sessionToken
)
{
const
scopes
=
[
SCOPE_OLD_SYNC
]
.
join
(
"
"
)
;
const
scopedKeysMetadata
=
await
this
.
_fxai
.
fxAccountsClient
.
getScopedKeyData
(
sessionToken
FX_OAUTH_CLIENT_ID
scopes
)
;
if
(
!
scopedKeysMetadata
.
hasOwnProperty
(
SCOPE_OLD_SYNC
)
)
{
log
.
warn
(
"
The
FxA
server
did
not
grant
Firefox
the
oldsync
scope
;
this
is
most
unexpected
!
"
+
scopes
were
:
{
Object
.
keys
(
scopedKeysMetadata
)
}
)
;
throw
new
Error
(
"
The
FxA
server
did
not
grant
Firefox
the
oldsync
scope
"
)
;
}
scopedKeysMetadata
[
LEGACY_SCOPE_WEBEXT_SYNC
]
=
{
.
.
.
scopedKeysMetadata
[
SCOPE_OLD_SYNC
]
identifier
:
LEGACY_SCOPE_WEBEXT_SYNC
}
;
return
scopedKeysMetadata
;
}
async
_deriveKeys
(
uid
kBbytes
scopedKeysMetadata
)
{
const
scopedKeys
=
await
this
.
_deriveScopedKeys
(
uid
kBbytes
scopedKeysMetadata
)
;
return
{
scopedKeys
kSync
:
scopedKeys
[
SCOPE_OLD_SYNC
]
?
this
.
keyAsHex
(
scopedKeys
[
SCOPE_OLD_SYNC
]
)
:
CommonUtils
.
bytesAsHex
(
await
this
.
_deriveSyncKey
(
kBbytes
)
)
kXCS
:
scopedKeys
[
SCOPE_OLD_SYNC
]
?
this
.
kidAsHex
(
scopedKeys
[
SCOPE_OLD_SYNC
]
)
:
CommonUtils
.
bytesAsHex
(
await
this
.
_deriveXClientState
(
kBbytes
)
)
kExtSync
:
scopedKeys
[
LEGACY_SCOPE_WEBEXT_SYNC
]
?
this
.
keyAsHex
(
scopedKeys
[
LEGACY_SCOPE_WEBEXT_SYNC
]
)
:
CommonUtils
.
bytesAsHex
(
await
this
.
_deriveWebExtSyncStoreKey
(
kBbytes
)
)
kExtKbHash
:
scopedKeys
[
LEGACY_SCOPE_WEBEXT_SYNC
]
?
this
.
kidAsHex
(
scopedKeys
[
LEGACY_SCOPE_WEBEXT_SYNC
]
)
:
CommonUtils
.
bytesAsHex
(
await
this
.
_deriveWebExtKbHash
(
uid
kBbytes
)
)
}
;
}
async
_deriveScopedKeys
(
uid
kBbytes
scopedKeysMetadata
)
{
const
scopedKeys
=
{
}
;
for
(
const
scope
in
scopedKeysMetadata
)
{
if
(
LEGACY_DERIVED_KEY_SCOPES
.
includes
(
scope
)
)
{
scopedKeys
[
scope
]
=
await
this
.
_deriveLegacyScopedKey
(
uid
kBbytes
scope
scopedKeysMetadata
[
scope
]
)
;
}
else
{
scopedKeys
[
scope
]
=
await
this
.
_deriveScopedKey
(
uid
kBbytes
scope
scopedKeysMetadata
[
scope
]
)
;
}
}
return
scopedKeys
;
}
async
_deriveScopedKeysFromAccountData
(
userData
)
{
const
scopedKeysMetadata
=
await
this
.
_fetchScopedKeysMetadata
(
userData
.
sessionToken
)
;
const
scopedKeys
=
userData
.
scopedKeys
|
|
{
}
;
for
(
const
scope
of
LEGACY_DERIVED_KEY_SCOPES
)
{
if
(
scopedKeysMetadata
.
hasOwnProperty
(
scope
)
)
{
let
kid
key
;
if
(
scope
=
=
SCOPE_OLD_SYNC
)
{
(
{
kXCS
:
kid
kSync
:
key
}
=
userData
)
;
}
else
if
(
scope
=
=
LEGACY_SCOPE_WEBEXT_SYNC
)
{
(
{
kExtKbHash
:
kid
kExtSync
:
key
}
=
userData
)
;
}
else
{
throw
new
Error
(
Unexpected
legacy
key
-
bearing
scope
:
{
scope
}
)
;
}
if
(
!
kid
|
|
!
key
)
{
throw
new
Error
(
Account
is
missing
legacy
key
fields
for
scope
:
{
scope
}
)
;
}
scopedKeys
[
scope
]
=
await
this
.
_formatLegacyScopedKey
(
CommonUtils
.
hexToArrayBuffer
(
kid
)
CommonUtils
.
hexToArrayBuffer
(
key
)
scope
scopedKeysMetadata
[
scope
]
)
;
}
}
return
scopedKeys
;
}
async
_deriveScopedKey
(
uid
kBbytes
scope
scopedKeyMetadata
)
{
kBbytes
=
CommonUtils
.
byteStringToArrayBuffer
(
kBbytes
)
;
const
FINGERPRINT_LENGTH
=
16
;
const
KEY_LENGTH
=
32
;
const
VALID_UID
=
/
^
[
0
-
9a
-
f
]
{
32
}
/
i
;
const
VALID_ROTATION_SECRET
=
/
^
[
0
-
9a
-
f
]
{
64
}
/
i
;
if
(
!
VALID_UID
.
test
(
uid
)
)
{
throw
new
Error
(
"
uid
must
be
a
32
-
character
hex
string
"
)
;
}
if
(
kBbytes
.
length
!
=
32
)
{
throw
new
Error
(
"
kBbytes
must
be
exactly
32
bytes
"
)
;
}
if
(
typeof
scopedKeyMetadata
.
identifier
!
=
=
"
string
"
|
|
scopedKeyMetadata
.
identifier
.
length
<
10
)
{
throw
new
Error
(
"
identifier
must
be
a
string
of
length
>
=
10
"
)
;
}
if
(
typeof
scopedKeyMetadata
.
keyRotationTimestamp
!
=
=
"
number
"
)
{
throw
new
Error
(
"
keyRotationTimestamp
must
be
a
number
"
)
;
}
if
(
!
VALID_ROTATION_SECRET
.
test
(
scopedKeyMetadata
.
keyRotationSecret
)
)
{
throw
new
Error
(
"
keyRotationSecret
must
be
a
64
-
character
hex
string
"
)
;
}
const
keyRotationTimestamp
=
"
"
+
Math
.
round
(
scopedKeyMetadata
.
keyRotationTimestamp
/
1000
)
;
if
(
keyRotationTimestamp
.
length
<
10
)
{
throw
new
Error
(
"
keyRotationTimestamp
must
round
to
a
10
-
digit
number
"
)
;
}
const
keyRotationSecret
=
CommonUtils
.
hexToArrayBuffer
(
scopedKeyMetadata
.
keyRotationSecret
)
;
const
salt
=
CommonUtils
.
hexToArrayBuffer
(
uid
)
;
const
context
=
new
TextEncoder
(
"
utf8
"
)
.
encode
(
"
identity
.
mozilla
.
com
/
picl
/
v1
/
scoped_key
\
n
"
+
scopedKeyMetadata
.
identifier
)
;
const
inputKey
=
new
Uint8Array
(
64
)
;
inputKey
.
set
(
kBbytes
0
)
;
inputKey
.
set
(
keyRotationSecret
32
)
;
const
derivedKeyMaterial
=
await
CryptoUtils
.
hkdf
(
inputKey
salt
context
FINGERPRINT_LENGTH
+
KEY_LENGTH
)
;
const
fingerprint
=
derivedKeyMaterial
.
slice
(
0
FINGERPRINT_LENGTH
)
;
const
key
=
derivedKeyMaterial
.
slice
(
FINGERPRINT_LENGTH
FINGERPRINT_LENGTH
+
KEY_LENGTH
)
;
return
{
kid
:
keyRotationTimestamp
+
"
-
"
+
ChromeUtils
.
base64URLEncode
(
fingerprint
{
pad
:
false
}
)
k
:
ChromeUtils
.
base64URLEncode
(
key
{
pad
:
false
}
)
kty
:
"
oct
"
}
;
}
async
_deriveLegacyScopedKey
(
uid
kBbytes
scope
scopedKeyMetadata
)
{
let
kid
key
;
if
(
scope
=
=
SCOPE_OLD_SYNC
)
{
kid
=
await
this
.
_deriveXClientState
(
kBbytes
)
;
key
=
await
this
.
_deriveSyncKey
(
kBbytes
)
;
}
else
if
(
scope
=
=
LEGACY_SCOPE_WEBEXT_SYNC
)
{
kid
=
await
this
.
_deriveWebExtKbHash
(
uid
kBbytes
)
;
key
=
await
this
.
_deriveWebExtSyncStoreKey
(
kBbytes
)
;
}
else
{
throw
new
Error
(
Unexpected
legacy
key
-
bearing
scope
:
{
scope
}
)
;
}
kid
=
CommonUtils
.
byteStringToArrayBuffer
(
kid
)
;
key
=
CommonUtils
.
byteStringToArrayBuffer
(
key
)
;
return
this
.
_formatLegacyScopedKey
(
kid
key
scope
scopedKeyMetadata
)
;
}
_formatLegacyScopedKey
(
kid
key
scope
{
keyRotationTimestamp
}
)
{
kid
=
ChromeUtils
.
base64URLEncode
(
kid
{
pad
:
false
}
)
;
key
=
ChromeUtils
.
base64URLEncode
(
key
{
pad
:
false
}
)
;
return
{
kid
:
{
keyRotationTimestamp
}
-
{
kid
}
k
:
key
kty
:
"
oct
"
}
;
}
async
_deriveSyncKey
(
kBbytes
)
{
return
CryptoUtils
.
hkdfLegacy
(
kBbytes
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
oldsync
"
2
*
32
)
;
}
async
_deriveXClientState
(
kBbytes
)
{
return
this
.
_sha256
(
kBbytes
)
.
slice
(
0
16
)
;
}
async
_deriveWebExtSyncStoreKey
(
kBbytes
)
{
return
CryptoUtils
.
hkdfLegacy
(
kBbytes
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
chrome
.
storage
.
sync
"
2
*
32
)
;
}
async
_deriveWebExtKbHash
(
uid
kBbytes
)
{
return
this
.
_sha256
(
uid
+
kBbytes
)
;
}
_sha256
(
bytes
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
return
CryptoUtils
.
digestBytes
(
bytes
hasher
)
;
}
}
var
EXPORTED_SYMBOLS
=
[
"
FxAccountsKeys
"
]
;
