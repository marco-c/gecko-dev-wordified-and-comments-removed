const
{
Doctor
REPAIR_ADVANCE_PERIOD
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
doctor
.
js
"
null
)
;
function
mockDoctor
(
mocks
)
{
return
Object
.
assign
(
{
}
Doctor
mocks
)
;
}
add_task
(
async
function
test_validation_interval
(
)
{
let
now
=
1000
;
let
doctor
=
mockDoctor
(
{
_now
(
)
{
return
now
;
}
}
)
;
let
engine
=
{
name
:
"
test
-
engine
"
getValidator
(
)
{
return
{
validate
(
e
)
{
return
{
}
;
}
}
;
}
}
;
Services
.
prefs
.
setBoolPref
(
"
services
.
sync
.
engine
.
test
-
engine
.
validation
.
enabled
"
true
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
sync
.
engine
.
test
-
engine
.
validation
.
percentageChance
"
100
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
sync
.
engine
.
test
-
engine
.
validation
.
maxRecords
"
1
)
;
Services
.
prefs
.
setIntPref
(
"
services
.
sync
.
engine
.
test
-
engine
.
validation
.
interval
"
10
)
;
deepEqual
(
doctor
.
_getEnginesToValidate
(
[
engine
]
)
{
"
test
-
engine
"
:
{
engine
maxRecords
:
1
}
}
)
;
deepEqual
(
doctor
.
_getEnginesToValidate
(
[
engine
]
)
{
}
)
;
now
+
=
11
;
deepEqual
(
doctor
.
_getEnginesToValidate
(
[
engine
]
)
{
"
test
-
engine
"
:
{
engine
maxRecords
:
1
}
}
)
;
}
)
;
add_task
(
async
function
test_repairs_start
(
)
{
let
repairStarted
=
false
;
let
problems
=
{
missingChildren
:
[
"
a
"
"
b
"
"
c
"
]
}
;
let
validator
=
{
validate
(
engine
)
{
return
problems
;
}
canValidate
(
)
{
return
Promise
.
resolve
(
true
)
;
}
}
;
let
engine
=
{
name
:
"
test
-
engine
"
getValidator
(
)
{
return
validator
;
}
}
;
let
requestor
=
{
async
startRepairs
(
validationInfo
flowID
)
{
ok
(
flowID
"
got
a
flow
ID
"
)
;
equal
(
validationInfo
problems
)
;
repairStarted
=
true
;
return
true
;
}
tryServerOnlyRepairs
(
)
{
return
false
;
}
}
;
let
doctor
=
mockDoctor
(
{
_getEnginesToValidate
(
recentlySyncedEngines
)
{
deepEqual
(
recentlySyncedEngines
[
engine
]
)
;
return
{
"
test
-
engine
"
:
{
engine
maxRecords
:
-
1
}
}
;
}
_getRepairRequestor
(
engineName
)
{
equal
(
engineName
engine
.
name
)
;
return
requestor
;
}
_shouldRepair
(
e
)
{
return
true
;
}
}
)
;
let
promiseValidationDone
=
promiseOneObserver
(
"
weave
:
engine
:
validate
:
finish
"
)
;
await
doctor
.
consult
(
[
engine
]
)
;
await
promiseValidationDone
;
ok
(
repairStarted
)
;
}
)
;
add_task
(
async
function
test_repairs_advanced_daily
(
)
{
let
repairCalls
=
0
;
let
requestor
=
{
async
continueRepairs
(
)
{
repairCalls
+
+
;
}
tryServerOnlyRepairs
(
)
{
return
false
;
}
}
;
let
now
=
REPAIR_ADVANCE_PERIOD
+
1
;
let
doctor
=
mockDoctor
(
{
_getEnginesToValidate
(
)
{
return
{
}
;
}
_runValidators
(
)
{
}
_getAllRepairRequestors
(
)
{
return
{
foo
:
requestor
}
;
}
_now
(
)
{
return
now
;
}
}
)
;
await
doctor
.
consult
(
)
;
equal
(
repairCalls
1
)
;
now
+
=
10
;
await
doctor
.
consult
(
)
;
equal
(
repairCalls
1
)
;
now
+
=
REPAIR_ADVANCE_PERIOD
;
await
doctor
.
consult
(
)
;
equal
(
repairCalls
2
)
;
}
)
;
add_task
(
async
function
test_repairs_skip_if_cant_vaidate
(
)
{
let
validator
=
{
canValidate
(
)
{
return
Promise
.
resolve
(
false
)
;
}
validate
(
)
{
ok
(
false
"
Shouldn
'
t
validate
"
)
;
}
}
;
let
engine
=
{
name
:
"
test
-
engine
"
getValidator
(
)
{
return
validator
;
}
}
;
let
requestor
=
{
async
startRepairs
(
validationInfo
flowID
)
{
ok
(
false
"
Never
should
start
repairs
"
)
;
}
tryServerOnlyRepairs
(
)
{
return
false
;
}
}
;
let
doctor
=
mockDoctor
(
{
_getEnginesToValidate
(
recentlySyncedEngines
)
{
deepEqual
(
recentlySyncedEngines
[
engine
]
)
;
return
{
"
test
-
engine
"
:
{
engine
maxRecords
:
-
1
}
}
;
}
_getRepairRequestor
(
engineName
)
{
equal
(
engineName
engine
.
name
)
;
return
requestor
;
}
}
)
;
await
doctor
.
consult
(
[
engine
]
)
;
}
)
;
