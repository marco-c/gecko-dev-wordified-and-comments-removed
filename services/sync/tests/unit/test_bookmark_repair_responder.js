Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
PlacesTestUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
/
modules
/
PlacesUIUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
/
bookmarks
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
bookmark_repair
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
sync
/
utils
.
js
"
)
;
initTestLogging
(
"
Trace
"
)
;
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
"
)
.
level
=
Log
.
Level
.
Trace
;
Log
.
repository
.
getLogger
(
"
Sqlite
"
)
.
level
=
Log
.
Level
.
Error
;
var
recordedEvents
=
[
]
;
Service
.
recordTelemetryEvent
=
(
object
method
value
extra
=
undefined
)
=
>
{
recordedEvents
.
push
(
{
object
method
value
extra
}
)
;
}
;
function
checkRecordedEvents
(
expected
)
{
deepEqual
(
recordedEvents
expected
)
;
recordedEvents
=
[
]
;
}
function
getServerBookmarks
(
server
)
{
return
server
.
user
(
"
foo
"
)
.
collection
(
"
bookmarks
"
)
;
}
async
function
setup
(
)
{
let
bookmarksEngine
=
Service
.
engineManager
.
get
(
"
bookmarks
"
)
;
let
server
=
serverForFoo
(
bookmarksEngine
)
;
await
SyncTestingInfrastructure
(
server
)
;
Svc
.
Prefs
.
set
(
"
engine
.
bookmarks
.
validation
.
enabled
"
false
)
;
return
server
;
}
async
function
cleanup
(
server
)
{
await
promiseStopServer
(
server
)
;
await
PlacesSyncUtils
.
bookmarks
.
wipe
(
)
;
Svc
.
Prefs
.
reset
(
"
engine
.
bookmarks
.
validation
.
enabled
"
)
;
Service
.
collectionKeys
.
clear
(
)
;
}
add_task
(
async
function
test_responder_error
(
)
{
let
server
=
await
setup
(
)
;
Service
.
sync
(
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
Utils
.
makeGUID
(
)
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
responder
.
_fetchItemsToUpload
=
async
function
(
)
{
throw
new
Error
(
"
oh
no
!
"
)
;
}
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
failed
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
0
"
failureReason
:
'
{
"
name
"
:
"
unexpectederror
"
"
error
"
:
"
Error
:
oh
no
!
"
}
'
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_responder_no_items
(
)
{
let
server
=
await
setup
(
)
;
Service
.
sync
(
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
Utils
.
makeGUID
(
)
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
0
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_responder_upload
(
)
{
let
server
=
await
setup
(
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
Get
Firefox
"
url
:
"
http
:
/
/
getfirefox
.
com
/
"
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
}
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
]
"
Should
only
upload
roots
on
first
sync
"
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
bm
.
guid
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
uploading
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
1
"
}
}
]
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
bm
.
guid
]
.
sort
(
)
"
Should
upload
requested
bookmark
on
second
sync
"
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
1
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_responder_item_exists_locally
(
)
{
let
server
=
await
setup
(
)
;
let
bm
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
Get
Firefox
"
url
:
"
http
:
/
/
getfirefox
.
com
/
"
}
)
;
_
(
"
Syncing
to
get
item
on
the
server
"
)
;
Service
.
sync
(
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
bm
.
guid
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
uploading
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
1
"
}
}
]
)
;
_
(
"
Syncing
to
do
the
upload
.
"
)
;
Service
.
sync
(
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
1
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_responder_tombstone
(
)
{
let
server
=
await
setup
(
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_responder_missing_items
(
)
{
let
server
=
await
setup
(
)
;
let
fxBmk
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
Get
Firefox
"
url
:
"
http
:
/
/
getfirefox
.
com
/
"
}
)
;
let
tbBmk
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
PlacesUtils
.
bookmarks
.
unfiledGuid
title
:
"
Get
Thunderbird
"
url
:
"
http
:
/
/
getthunderbird
.
com
/
"
source
:
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
}
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
fxBmk
.
guid
]
.
sort
(
)
"
Should
upload
roots
and
Firefox
on
first
sync
"
)
;
_
(
"
Request
Firefox
Thunderbird
and
nonexistent
GUID
"
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
fxBmk
.
guid
tbBmk
.
guid
Utils
.
makeGUID
(
)
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
uploading
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
2
"
}
}
]
)
;
_
(
"
Sync
after
requesting
IDs
"
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
fxBmk
.
guid
tbBmk
.
guid
]
.
sort
(
)
"
Second
sync
should
upload
Thunderbird
;
skip
nonexistent
"
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
2
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_non_syncable
(
)
{
let
server
=
await
setup
(
)
;
Service
.
sync
(
)
;
let
leftPaneId
=
PlacesUIUtils
.
leftPaneFolderId
;
_
(
Left
pane
root
ID
:
{
leftPaneId
}
)
;
await
PlacesTestUtils
.
promiseAsyncUpdates
(
)
;
let
allBookmarksId
=
PlacesUIUtils
.
leftPaneQueries
.
AllBookmarks
;
let
allBookmarksGuid
=
await
PlacesUtils
.
promiseItemGuid
(
allBookmarksId
)
;
let
unfiledQueryId
=
PlacesUIUtils
.
leftPaneQueries
.
UnfiledBookmarks
;
let
unfiledQueryGuid
=
await
PlacesUtils
.
promiseItemGuid
(
unfiledQueryId
)
;
let
bookmarksMenuQueryId
=
PlacesUIUtils
.
leftPaneQueries
.
BookmarksMenu
;
let
bookmarksMenuQueryGuid
=
await
PlacesUtils
.
promiseItemGuid
(
bookmarksMenuQueryId
)
;
let
collection
=
getServerBookmarks
(
server
)
;
collection
.
insert
(
bookmarksMenuQueryGuid
"
doesn
'
t
matter
"
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
allBookmarksGuid
unfiledQueryGuid
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
uploading
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
3
"
}
}
]
)
;
_
(
"
Sync
to
upload
tombstones
for
items
"
)
;
Service
.
sync
(
)
;
let
toolbarQueryId
=
PlacesUIUtils
.
leftPaneQueries
.
BookmarksToolbar
;
let
menuQueryId
=
PlacesUIUtils
.
leftPaneQueries
.
BookmarksMenu
;
let
queryGuids
=
[
allBookmarksGuid
await
PlacesUtils
.
promiseItemGuid
(
toolbarQueryId
)
await
PlacesUtils
.
promiseItemGuid
(
menuQueryId
)
unfiledQueryGuid
]
;
deepEqual
(
collection
.
keys
(
)
.
sort
(
)
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
.
.
.
request
.
ids
bookmarksMenuQueryGuid
]
.
sort
(
)
"
Should
upload
roots
and
queries
on
first
sync
"
)
;
for
(
let
guid
of
queryGuids
)
{
let
wbo
=
collection
.
wbo
(
guid
)
;
if
(
request
.
ids
.
indexOf
(
guid
)
>
=
0
|
|
guid
=
=
bookmarksMenuQueryGuid
)
{
let
payload
=
JSON
.
parse
(
JSON
.
parse
(
wbo
.
payload
)
.
ciphertext
)
;
ok
(
payload
.
deleted
Should
upload
tombstone
for
left
pane
query
{
guid
}
)
;
}
else
{
ok
(
!
wbo
Should
not
upload
anything
for
left
pane
query
{
guid
}
)
;
}
}
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
3
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_folder_descendants
(
)
{
let
server
=
await
setup
(
)
;
let
parentFolder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
PlacesUtils
.
bookmarks
.
menuGuid
title
:
"
Parent
folder
"
}
)
;
let
childFolder
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
parentGuid
:
parentFolder
.
guid
title
:
"
Child
folder
"
}
)
;
let
existingChildBmk
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
parentFolder
.
guid
title
:
"
Get
Firefox
"
url
:
"
http
:
/
/
firefox
.
com
"
}
)
;
let
childSiblingBmk
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
parentFolder
.
guid
title
:
"
Get
Thunderbird
"
url
:
"
http
:
/
/
getthunderbird
.
com
"
}
)
;
_
(
"
Initial
sync
to
upload
roots
and
parent
folder
"
)
;
Service
.
sync
(
)
;
let
initialSyncIds
=
[
"
menu
"
"
mobile
"
"
toolbar
"
"
unfiled
"
parentFolder
.
guid
existingChildBmk
.
guid
childFolder
.
guid
childSiblingBmk
.
guid
]
.
sort
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
initialSyncIds
"
Should
upload
roots
and
partial
folder
contents
on
first
sync
"
)
;
_
(
"
Insert
missing
bookmarks
locally
to
request
later
"
)
;
let
childBmk
=
await
PlacesSyncUtils
.
bookmarks
.
insert
(
{
kind
:
"
bookmark
"
syncId
:
Utils
.
makeGUID
(
)
parentSyncId
:
parentFolder
.
guid
title
:
"
Get
Firefox
"
url
:
"
http
:
/
/
getfirefox
.
com
"
}
)
;
let
grandChildBmk
=
await
PlacesSyncUtils
.
bookmarks
.
insert
(
{
kind
:
"
bookmark
"
syncId
:
Utils
.
makeGUID
(
)
parentSyncId
:
childFolder
.
guid
title
:
"
Bugzilla
"
url
:
"
https
:
/
/
bugzilla
.
mozilla
.
org
"
}
)
;
let
grandChildSiblingBmk
=
await
PlacesSyncUtils
.
bookmarks
.
insert
(
{
kind
:
"
bookmark
"
syncId
:
Utils
.
makeGUID
(
)
parentSyncId
:
childFolder
.
guid
title
:
"
Mozilla
"
url
:
"
https
:
/
/
mozilla
.
org
"
}
)
;
_
(
"
Sync
again
;
server
contents
shouldn
'
t
change
"
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
initialSyncIds
"
Second
sync
should
not
upload
missing
bookmarks
"
)
;
_
(
"
Request
missing
bookmarks
"
)
;
let
request
=
{
request
:
"
upload
"
ids
:
[
parentFolder
.
guid
childSiblingBmk
.
guid
childBmk
.
syncId
grandChildSiblingBmk
.
syncId
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
uploading
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
5
"
}
}
]
)
;
_
(
"
Sync
after
requesting
repair
;
should
upload
missing
records
"
)
;
Service
.
sync
(
)
;
deepEqual
(
getServerBookmarks
(
server
)
.
keys
(
)
.
sort
(
)
[
.
.
.
initialSyncIds
childBmk
.
syncId
grandChildBmk
.
syncId
grandChildSiblingBmk
.
syncId
]
.
sort
(
)
"
Third
sync
should
upload
requested
items
"
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
finished
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
numIDs
:
"
5
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
add_task
(
async
function
test_aborts_unknown_request
(
)
{
let
server
=
await
setup
(
)
;
let
request
=
{
request
:
"
not
-
upload
"
ids
:
[
]
flowID
:
Utils
.
makeGUID
(
)
}
let
responder
=
new
BookmarkRepairResponder
(
)
;
await
responder
.
repair
(
request
null
)
;
checkRecordedEvents
(
[
{
object
:
"
repairResponse
"
method
:
"
aborted
"
value
:
undefined
extra
:
{
flowID
:
request
.
flowID
reason
:
"
Don
'
t
understand
request
type
'
not
-
upload
'
"
}
}
]
)
;
await
cleanup
(
server
)
;
}
)
;
