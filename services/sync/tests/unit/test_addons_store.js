"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
addonutils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
/
addons
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
HTTP_PORT
=
8888
;
const
prefs
=
new
Preferences
(
)
;
prefs
.
set
(
"
extensions
.
getAddons
.
get
.
url
"
"
http
:
/
/
localhost
:
8888
/
search
/
guid
:
%
IDS
%
"
)
;
prefs
.
set
(
"
extensions
.
install
.
requireSecureOrigin
"
false
)
;
const
SYSTEM_ADDON_ID
=
"
system1
tests
.
mozilla
.
org
"
;
let
systemAddonFile
;
function
loadSystemAddon
(
)
{
let
addonFilename
=
SYSTEM_ADDON_ID
+
"
.
xpi
"
;
const
distroDir
=
FileUtils
.
getDir
(
"
ProfD
"
[
"
sysfeatures
"
"
app0
"
]
true
)
;
do_get_file
(
ExtensionsTestPath
(
"
/
data
/
system_addons
/
system1_1
.
xpi
"
)
)
.
copyTo
(
distroDir
addonFilename
)
;
systemAddonFile
=
FileUtils
.
File
(
distroDir
.
path
)
;
systemAddonFile
.
append
(
addonFilename
)
;
systemAddonFile
.
lastModifiedTime
=
Date
.
now
(
)
;
registerDirectory
(
"
XREAppFeat
"
distroDir
)
;
}
loadAddonTestFunctions
(
)
;
loadSystemAddon
(
)
;
awaitPromise
(
overrideBuiltIns
(
{
"
system
"
:
[
SYSTEM_ADDON_ID
]
}
)
)
;
startupManager
(
)
;
let
engine
;
let
tracker
;
let
store
;
let
reconciler
;
function
createRecordForThisApp
(
id
addonId
enabled
deleted
)
{
return
{
id
addonID
:
addonId
enabled
deleted
:
!
!
deleted
applicationID
:
Services
.
appinfo
.
ID
source
:
"
amo
"
}
;
}
function
createAndStartHTTPServer
(
port
)
{
try
{
let
server
=
new
HttpServer
(
)
;
let
bootstrap1XPI
=
ExtensionsTestPath
(
"
/
addons
/
test_bootstrap1_1
.
xpi
"
)
;
server
.
registerFile
(
"
/
search
/
guid
:
bootstrap1
%
40tests
.
mozilla
.
org
"
do_get_file
(
"
bootstrap1
-
search
.
xml
"
)
)
;
server
.
registerFile
(
"
/
bootstrap1
.
xpi
"
do_get_file
(
bootstrap1XPI
)
)
;
server
.
registerFile
(
"
/
search
/
guid
:
missing
-
xpi
%
40tests
.
mozilla
.
org
"
do_get_file
(
"
missing
-
xpi
-
search
.
xml
"
)
)
;
server
.
registerFile
(
"
/
search
/
guid
:
system1
%
40tests
.
mozilla
.
org
"
do_get_file
(
"
systemaddon
-
search
.
xml
"
)
)
;
server
.
registerFile
(
"
/
system
.
xpi
"
systemAddonFile
)
;
server
.
start
(
port
)
;
return
server
;
}
catch
(
ex
)
{
_
(
"
Got
exception
starting
HTTP
server
on
port
"
+
port
)
;
_
(
"
Error
:
"
+
Log
.
exceptionStr
(
ex
)
)
;
do_throw
(
ex
)
;
}
return
null
;
}
async
function
checkReconcilerUpToDate
(
addon
)
{
let
stateBefore
=
Object
.
assign
(
{
}
store
.
reconciler
.
addons
[
addon
.
id
]
)
;
await
store
.
reconciler
.
rectifyStateFromAddon
(
addon
)
;
let
stateAfter
=
store
.
reconciler
.
addons
[
addon
.
id
]
;
deepEqual
(
stateBefore
stateAfter
)
;
}
add_task
(
async
function
setup
(
)
{
await
Service
.
engineManager
.
register
(
AddonsEngine
)
;
engine
=
Service
.
engineManager
.
get
(
"
addons
"
)
;
tracker
=
engine
.
_tracker
;
store
=
engine
.
_store
;
reconciler
=
engine
.
_reconciler
;
reconciler
.
startListening
(
)
;
reconciler
.
_shouldPersist
=
false
;
}
)
;
add_task
(
async
function
test_remove
(
)
{
_
(
"
Ensure
removing
add
-
ons
from
deleted
records
works
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
record
=
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
true
true
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
0
failed
.
length
)
;
let
newAddon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
equal
(
null
newAddon
)
;
}
)
;
add_task
(
async
function
test_apply_enabled
(
)
{
_
(
"
Ensures
that
changes
to
the
userEnabled
flag
apply
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
Assert
.
ok
(
addon
.
isActive
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
_
(
"
Ensure
application
of
a
disable
record
works
as
expected
.
"
)
;
let
records
=
[
]
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
false
false
)
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
addon
.
userDisabled
)
;
await
checkReconcilerUpToDate
(
addon
)
;
records
=
[
]
;
_
(
"
Ensure
enable
record
works
as
expected
.
"
)
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
true
false
)
)
;
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
await
checkReconcilerUpToDate
(
addon
)
;
records
=
[
]
;
_
(
"
Ensure
enabled
state
updates
don
'
t
apply
if
the
ignore
pref
is
set
.
"
)
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
false
false
)
)
;
Svc
.
Prefs
.
set
(
"
addons
.
ignoreUserEnabledChanges
"
true
)
;
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
records
=
[
]
;
await
uninstallAddon
(
addon
reconciler
)
;
Svc
.
Prefs
.
reset
(
"
addons
.
ignoreUserEnabledChanges
"
)
;
}
)
;
add_task
(
async
function
test_apply_enabled_appDisabled
(
)
{
_
(
"
Ensures
that
changes
to
the
userEnabled
flag
apply
when
the
addon
is
appDisabled
.
"
)
;
let
addon
=
await
installAddon
(
"
test_install3
"
)
;
Assert
.
ok
(
addon
.
appDisabled
)
;
Assert
.
ok
(
!
addon
.
isActive
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
_
(
"
Ensure
application
of
a
disable
record
works
as
expected
.
"
)
;
store
.
reconciler
.
pruneChangesBeforeDate
(
Date
.
now
(
)
+
10
)
;
store
.
reconciler
.
_changes
=
[
]
;
let
records
=
[
]
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
false
false
)
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
addon
.
userDisabled
)
;
await
checkReconcilerUpToDate
(
addon
)
;
records
=
[
]
;
_
(
"
Ensure
enable
record
works
as
expected
.
"
)
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
true
false
)
)
;
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
await
checkReconcilerUpToDate
(
addon
)
;
records
=
[
]
;
await
uninstallAddon
(
addon
reconciler
)
;
}
)
;
add_task
(
async
function
test_ignore_different_appid
(
)
{
_
(
"
Ensure
that
incoming
records
with
a
different
application
ID
are
ignored
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
Assert
.
ok
(
!
addon
.
userDisabled
)
;
let
record
=
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
false
false
)
;
record
.
applicationID
=
"
FAKE_ID
"
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
0
failed
.
length
)
;
let
newAddon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
!
newAddon
.
userDisabled
)
;
await
uninstallAddon
(
addon
reconciler
)
;
}
)
;
add_task
(
async
function
test_ignore_unknown_source
(
)
{
_
(
"
Ensure
incoming
records
with
unknown
source
are
ignored
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
record
=
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
false
false
)
;
record
.
source
=
"
DUMMY_SOURCE
"
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
0
failed
.
length
)
;
let
newAddon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
ok
(
!
newAddon
.
userDisabled
)
;
await
uninstallAddon
(
addon
reconciler
)
;
}
)
;
add_task
(
async
function
test_apply_uninstall
(
)
{
_
(
"
Ensures
that
uninstalling
an
add
-
on
from
a
record
works
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
records
=
[
]
;
records
.
push
(
createRecordForThisApp
(
addon
.
syncGUID
addon
.
id
true
true
)
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
records
)
;
Assert
.
equal
(
0
failed
.
length
)
;
addon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
equal
(
null
addon
)
;
}
)
;
add_task
(
async
function
test_addon_syncability
(
)
{
_
(
"
Ensure
isAddonSyncable
functions
properly
.
"
)
;
Svc
.
Prefs
.
set
(
"
addons
.
trustedSourceHostnames
"
"
addons
.
mozilla
.
org
other
.
example
.
com
"
)
;
Assert
.
ok
(
!
(
await
store
.
isAddonSyncable
(
null
)
)
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
Assert
.
ok
(
(
await
store
.
isAddonSyncable
(
addon
)
)
)
;
let
dummy
=
{
}
;
const
KEYS
=
[
"
id
"
"
syncGUID
"
"
type
"
"
scope
"
"
foreignInstall
"
"
isSyncable
"
]
;
for
(
let
k
of
KEYS
)
{
dummy
[
k
]
=
addon
[
k
]
;
}
Assert
.
ok
(
(
await
store
.
isAddonSyncable
(
dummy
)
)
)
;
dummy
.
type
=
"
UNSUPPORTED
"
;
Assert
.
ok
(
!
(
await
store
.
isAddonSyncable
(
dummy
)
)
)
;
dummy
.
type
=
addon
.
type
;
dummy
.
scope
=
0
;
Assert
.
ok
(
!
(
await
store
.
isAddonSyncable
(
dummy
)
)
)
;
dummy
.
scope
=
addon
.
scope
;
dummy
.
isSyncable
=
false
;
Assert
.
ok
(
!
(
await
store
.
isAddonSyncable
(
dummy
)
)
)
;
dummy
.
isSyncable
=
addon
.
isSyncable
;
dummy
.
foreignInstall
=
true
;
Assert
.
ok
(
!
(
await
store
.
isAddonSyncable
(
dummy
)
)
)
;
dummy
.
foreignInstall
=
false
;
await
uninstallAddon
(
addon
reconciler
)
;
Assert
.
ok
(
!
store
.
isSourceURITrusted
(
null
)
)
;
let
trusted
=
[
"
https
:
/
/
addons
.
mozilla
.
org
/
foo
"
"
https
:
/
/
other
.
example
.
com
/
foo
"
]
;
let
untrusted
=
[
"
http
:
/
/
addons
.
mozilla
.
org
/
foo
"
"
ftps
:
/
/
addons
.
mozilla
.
org
/
foo
"
"
https
:
/
/
untrusted
.
example
.
com
/
foo
"
]
;
for
(
let
uri
of
trusted
)
{
Assert
.
ok
(
store
.
isSourceURITrusted
(
Services
.
io
.
newURI
(
uri
)
)
)
;
}
for
(
let
uri
of
untrusted
)
{
Assert
.
ok
(
!
store
.
isSourceURITrusted
(
Services
.
io
.
newURI
(
uri
)
)
)
;
}
Svc
.
Prefs
.
set
(
"
addons
.
trustedSourceHostnames
"
"
"
)
;
for
(
let
uri
of
trusted
)
{
Assert
.
ok
(
!
store
.
isSourceURITrusted
(
Services
.
io
.
newURI
(
uri
)
)
)
;
}
Svc
.
Prefs
.
set
(
"
addons
.
trustedSourceHostnames
"
"
addons
.
mozilla
.
org
"
)
;
Assert
.
ok
(
store
.
isSourceURITrusted
(
Services
.
io
.
newURI
(
"
https
:
/
/
addons
.
mozilla
.
org
/
foo
"
)
)
)
;
Svc
.
Prefs
.
reset
(
"
addons
.
trustedSourceHostnames
"
)
;
}
)
;
add_task
(
async
function
test_get_all_ids
(
)
{
_
(
"
Ensures
that
getAllIDs
(
)
returns
an
appropriate
set
.
"
)
;
_
(
"
Installing
two
addons
.
"
)
;
let
addon1
=
await
installAddon
(
"
test_install1
"
reconciler
)
;
let
addon2
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
addon3
=
await
installAddon
(
"
test_install3
"
reconciler
)
;
_
(
"
Ensure
they
'
re
syncable
.
"
)
;
Assert
.
ok
(
(
await
store
.
isAddonSyncable
(
addon1
)
)
)
;
Assert
.
ok
(
(
await
store
.
isAddonSyncable
(
addon2
)
)
)
;
Assert
.
ok
(
(
await
store
.
isAddonSyncable
(
addon3
)
)
)
;
let
ids
=
await
store
.
getAllIDs
(
)
;
Assert
.
equal
(
"
object
"
typeof
(
ids
)
)
;
Assert
.
equal
(
3
Object
.
keys
(
ids
)
.
length
)
;
Assert
.
ok
(
addon1
.
syncGUID
in
ids
)
;
Assert
.
ok
(
addon2
.
syncGUID
in
ids
)
;
Assert
.
ok
(
addon3
.
syncGUID
in
ids
)
;
addon1
.
install
.
cancel
(
)
;
await
uninstallAddon
(
addon2
reconciler
)
;
await
uninstallAddon
(
addon3
reconciler
)
;
}
)
;
add_task
(
async
function
test_change_item_id
(
)
{
_
(
"
Ensures
that
changeItemID
(
)
works
properly
.
"
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
oldID
=
addon
.
syncGUID
;
let
newID
=
Utils
.
makeGUID
(
)
;
await
store
.
changeItemID
(
oldID
newID
)
;
let
newAddon
=
await
AddonManager
.
getAddonByID
(
addon
.
id
)
;
Assert
.
notEqual
(
null
newAddon
)
;
Assert
.
equal
(
newID
newAddon
.
syncGUID
)
;
await
uninstallAddon
(
newAddon
reconciler
)
;
}
)
;
add_task
(
async
function
test_create
(
)
{
_
(
"
Ensure
creating
/
installing
an
add
-
on
from
a
record
works
.
"
)
;
let
server
=
createAndStartHTTPServer
(
HTTP_PORT
)
;
let
addon
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
id
=
addon
.
id
;
await
uninstallAddon
(
addon
reconciler
)
;
let
guid
=
Utils
.
makeGUID
(
)
;
let
record
=
createRecordForThisApp
(
guid
id
true
false
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
0
failed
.
length
)
;
let
newAddon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
notEqual
(
null
newAddon
)
;
Assert
.
equal
(
guid
newAddon
.
syncGUID
)
;
Assert
.
ok
(
!
newAddon
.
userDisabled
)
;
await
uninstallAddon
(
newAddon
reconciler
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_create_missing_search
(
)
{
_
(
"
Ensures
that
failed
add
-
on
searches
are
handled
gracefully
.
"
)
;
let
server
=
createAndStartHTTPServer
(
HTTP_PORT
)
;
const
id
=
"
missing
tests
.
mozilla
.
org
"
;
let
guid
=
Utils
.
makeGUID
(
)
;
let
record
=
createRecordForThisApp
(
guid
id
true
false
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
1
failed
.
length
)
;
Assert
.
equal
(
guid
failed
[
0
]
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
equal
(
null
addon
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_create_bad_install
(
)
{
_
(
"
Ensures
that
add
-
ons
without
a
valid
install
are
handled
gracefully
.
"
)
;
let
server
=
createAndStartHTTPServer
(
HTTP_PORT
)
;
const
id
=
"
missing
-
xpi
tests
.
mozilla
.
org
"
;
let
guid
=
Utils
.
makeGUID
(
)
;
let
record
=
createRecordForThisApp
(
guid
id
true
false
)
;
await
store
.
applyIncomingBatch
(
[
record
]
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
id
)
;
Assert
.
equal
(
null
addon
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_ignore_system
(
)
{
_
(
"
Ensure
we
ignore
system
addons
"
)
;
await
engine
.
_refreshReconcilerState
(
)
;
let
num
=
0
;
let
ids
=
await
store
.
getAllIDs
(
)
;
for
(
let
guid
in
ids
)
{
num
+
=
1
;
let
addon
=
reconciler
.
getAddonStateFromSyncGUID
(
guid
)
;
Assert
.
notEqual
(
addon
.
id
SYSTEM_ADDON_ID
)
;
}
Assert
.
ok
(
num
>
1
"
should
have
seen
at
least
one
.
"
)
;
}
)
;
add_task
(
async
function
test_incoming_system
(
)
{
_
(
"
Ensure
we
handle
incoming
records
that
refer
to
a
system
addon
"
)
;
Assert
.
ok
(
!
(
await
AddonManager
.
getAddonByID
(
SYSTEM_ADDON_ID
)
.
userDisabled
)
)
;
let
server
=
createAndStartHTTPServer
(
HTTP_PORT
)
;
let
guid
=
Utils
.
makeGUID
(
)
;
let
record
=
createRecordForThisApp
(
guid
SYSTEM_ADDON_ID
false
false
)
;
let
failed
=
await
store
.
applyIncomingBatch
(
[
record
]
)
;
Assert
.
equal
(
0
failed
.
length
)
;
Assert
.
ok
(
!
(
await
AddonManager
.
getAddonByID
(
SYSTEM_ADDON_ID
)
.
userDisabled
)
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_wipe
(
)
{
_
(
"
Ensures
that
wiping
causes
add
-
ons
to
be
uninstalled
.
"
)
;
let
addon1
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
await
store
.
wipe
(
)
;
let
addon
=
await
AddonManager
.
getAddonByID
(
addon1
.
id
)
;
Assert
.
equal
(
null
addon
)
;
}
)
;
add_task
(
async
function
test_wipe_and_install
(
)
{
_
(
"
Ensure
wipe
followed
by
install
works
.
"
)
;
let
installed
=
await
installAddon
(
"
test_bootstrap1_1
"
reconciler
)
;
let
record
=
createRecordForThisApp
(
installed
.
syncGUID
installed
.
id
true
false
)
;
await
store
.
wipe
(
)
;
let
deleted
=
await
AddonManager
.
getAddonByID
(
installed
.
id
)
;
Assert
.
equal
(
null
deleted
)
;
let
server
=
createAndStartHTTPServer
(
HTTP_PORT
)
;
await
store
.
applyIncoming
(
record
)
;
let
fetched
=
await
AddonManager
.
getAddonByID
(
record
.
addonID
)
;
Assert
.
ok
(
!
!
fetched
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
cleanup
(
)
{
reconciler
.
stopListening
(
)
;
}
)
;
