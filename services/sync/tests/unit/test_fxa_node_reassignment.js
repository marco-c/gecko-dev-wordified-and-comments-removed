_
(
"
Test
that
node
reassignment
happens
correctly
using
the
FxA
identity
mgr
.
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
rest
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
status
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
sync
/
rotaryengine
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
browserid_identity
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
add_task
(
async
function
setup
(
)
{
Service
.
engineManager
.
clear
(
)
;
Status
.
__authManager
=
Service
.
identity
=
new
BrowserIDManager
(
)
;
Service
.
_clusterManager
=
Service
.
identity
.
createClusterManager
(
Service
)
;
function
onUIError
(
)
{
do_throw
(
"
Errors
should
not
be
presented
in
the
UI
.
"
)
;
}
Svc
.
Obs
.
add
(
"
weave
:
ui
:
login
:
error
"
onUIError
)
;
Svc
.
Obs
.
add
(
"
weave
:
ui
:
sync
:
error
"
onUIError
)
;
}
)
;
function
handleReassign
(
handler
req
resp
)
{
resp
.
setStatusLine
(
req
.
httpVersion
401
"
Node
reassignment
"
)
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
let
reassignBody
=
JSON
.
stringify
(
{
error
:
"
401inator
in
place
"
}
)
;
resp
.
bodyOutputStream
.
write
(
reassignBody
reassignBody
.
length
)
;
}
var
numTokenRequests
=
0
;
function
prepareServer
(
cbAfterTokenFetch
)
{
syncTestLogging
(
)
;
let
config
=
makeIdentityConfig
(
{
username
:
"
johndoe
"
}
)
;
let
callback
=
{
__proto__
:
SyncServerCallback
onRequest
(
req
resp
)
{
let
full
=
{
req
.
scheme
}
:
/
/
{
req
.
host
}
:
{
req
.
port
}
{
req
.
path
}
;
Assert
.
ok
(
full
.
startsWith
(
config
.
fxaccount
.
token
.
endpoint
)
request
made
to
{
full
}
)
;
}
}
;
let
server
=
new
SyncServer
(
callback
)
;
server
.
registerUser
(
"
johndoe
"
)
;
server
.
start
(
)
;
config
.
fxaccount
.
token
.
endpoint
=
server
.
baseURI
+
"
1
.
1
/
johndoe
/
"
;
let
numReassigns
=
0
;
return
configureIdentity
(
config
)
.
then
(
(
)
=
>
{
Service
.
identity
.
_tokenServerClient
=
{
getTokenFromBrowserIDAssertion
(
uri
assertion
cb
)
{
numReassigns
+
=
1
;
let
trailingZeros
=
new
Array
(
numReassigns
+
1
)
.
join
(
"
0
"
)
;
let
token
=
config
.
fxaccount
.
token
;
token
.
endpoint
=
server
.
baseURI
+
"
1
.
1
"
+
trailingZeros
+
"
/
johndoe
"
;
token
.
uid
=
config
.
username
;
numTokenRequests
+
=
1
;
cb
(
null
token
)
;
if
(
cbAfterTokenFetch
)
{
cbAfterTokenFetch
(
)
;
}
}
}
;
return
server
;
}
)
;
}
function
getReassigned
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
lastSyncReassigned
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
do_throw
(
"
Got
exception
retrieving
lastSyncReassigned
:
"
+
Log
.
exceptionStr
(
ex
)
)
;
}
}
return
false
;
}
async
function
syncAndExpectNodeReassignment
(
server
firstNotification
between
secondNotification
url
)
{
_
(
"
Starting
syncAndExpectNodeReassignment
\
n
"
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
async
function
onwards
(
)
{
let
numTokenRequestsBefore
;
function
onFirstSync
(
)
{
_
(
"
First
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
firstNotification
onFirstSync
)
;
Svc
.
Obs
.
add
(
secondNotification
onSecondSync
)
;
Assert
.
equal
(
Service
.
clusterURL
"
"
)
;
numTokenRequestsBefore
=
numTokenRequests
;
between
(
)
;
}
function
onSecondSync
(
)
{
_
(
"
Second
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
secondNotification
onSecondSync
)
;
Service
.
scheduler
.
clearSyncTriggers
(
)
;
waitForZeroTimer
(
function
(
)
{
_
(
"
Second
sync
nextTick
.
"
)
;
Assert
.
equal
(
numTokenRequests
numTokenRequestsBefore
+
1
"
fetched
a
new
token
"
)
;
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
server
.
stop
(
deferred
.
resolve
)
;
}
)
;
}
)
;
}
Svc
.
Obs
.
add
(
firstNotification
onFirstSync
)
;
await
Service
.
sync
(
)
;
}
if
(
Service
.
isLoggedIn
)
{
_
(
"
Making
request
to
"
+
url
+
"
which
should
401
"
)
;
let
request
=
new
RESTRequest
(
url
)
;
request
.
get
(
function
(
)
{
Assert
.
equal
(
request
.
response
.
status
401
)
;
CommonUtils
.
nextTick
(
onwards
)
;
}
)
;
}
else
{
_
(
"
Skipping
preliminary
validation
check
for
a
401
as
we
aren
'
t
logged
in
"
)
;
CommonUtils
.
nextTick
(
onwards
)
;
}
await
deferred
.
promise
;
}
add_task
(
async
function
test_single_token_fetch
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
normal
sync
only
fetches
1
token
"
)
;
let
numTokenFetches
=
0
;
function
afterTokenFetch
(
)
{
numTokenFetches
+
+
;
}
Service
.
clusterURL
=
"
http
:
/
/
example
.
com
/
"
;
let
server
=
await
prepareServer
(
afterTokenFetch
)
;
Assert
.
ok
(
!
Service
.
isLoggedIn
"
not
already
logged
in
"
)
;
await
Service
.
sync
(
)
;
Assert
.
equal
(
Status
.
sync
SYNC_SUCCEEDED
"
sync
succeeded
"
)
;
Assert
.
equal
(
numTokenFetches
0
"
didn
'
t
fetch
a
new
token
"
)
;
let
expectedClusterURL
=
server
.
baseURI
+
"
1
.
1
/
johndoe
/
"
;
Assert
.
equal
(
Service
.
clusterURL
expectedClusterURL
)
;
await
Service
.
startOver
(
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_momentary_401_engine
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
engine
URLs
that
'
s
resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
john
=
server
.
user
(
"
johndoe
"
)
;
_
(
"
Enabling
the
Rotary
engine
.
"
)
;
let
{
engine
tracker
}
=
await
registerRotaryEngine
(
)
;
let
global
=
{
syncID
:
Service
.
syncID
storageVersion
:
STORAGE_VERSION
rotary
:
{
version
:
engine
.
version
syncID
:
engine
.
syncID
}
}
;
john
.
createCollection
(
"
meta
"
)
.
insert
(
"
global
"
global
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
_
(
"
Setting
up
Rotary
collection
to
401
.
"
)
;
let
rotary
=
john
.
createCollection
(
"
rotary
"
)
;
let
oldHandler
=
rotary
.
collectionHandler
;
rotary
.
collectionHandler
=
handleReassign
.
bind
(
this
undefined
)
;
john
.
collection
(
"
rotary
"
)
.
timestamp
+
=
1000
;
function
between
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
rotary
.
collectionHandler
=
oldHandler
;
function
onLoginStart
(
)
{
_
(
"
Ensuring
that
lastSyncReassigned
is
still
set
at
next
sync
start
.
"
)
;
Svc
.
Obs
.
remove
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
Assert
.
ok
(
getReassigned
(
)
)
;
}
_
(
"
Adding
observer
that
lastSyncReassigned
is
still
set
on
login
.
"
)
;
Svc
.
Obs
.
add
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
}
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
finish
"
between
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
rotary
"
)
;
tracker
.
clearChangedIDs
(
)
;
Service
.
engineManager
.
unregister
(
engine
)
;
}
)
;
add_task
(
async
function
test_momentary_401_info_collections_loggedin
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
info
/
collections
after
login
that
'
s
resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
_
(
"
Arrange
for
info
/
collections
to
return
a
401
.
"
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
info
;
server
.
toplevelHandlers
.
info
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
info
=
oldHandler
;
}
Assert
.
ok
(
Service
.
isLoggedIn
"
already
logged
in
"
)
;
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
infoURL
)
;
}
)
;
add_task
(
async
function
test_momentary_401_info_collections_loggedout
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
info
/
collections
before
login
that
'
s
resolved
by
reassignment
.
"
)
;
let
oldHandler
;
let
sawTokenFetch
=
false
;
function
afterTokenFetch
(
)
{
server
.
toplevelHandlers
.
info
=
oldHandler
;
sawTokenFetch
=
true
;
}
let
server
=
await
prepareServer
(
afterTokenFetch
)
;
oldHandler
=
server
.
toplevelHandlers
.
info
;
server
.
toplevelHandlers
.
info
=
handleReassign
;
Assert
.
ok
(
!
Service
.
isLoggedIn
"
not
already
logged
in
"
)
;
await
Service
.
sync
(
)
;
Assert
.
equal
(
Status
.
sync
SYNC_SUCCEEDED
"
sync
succeeded
"
)
;
Assert
.
ok
(
sawTokenFetch
"
a
new
token
was
fetched
by
this
test
.
"
)
;
await
Service
.
startOver
(
)
;
await
promiseStopServer
(
server
)
;
}
)
;
add_task
(
async
function
test_momentary_401_storage_loggedin
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
any
storage
URL
after
login
that
'
s
resolved
by
"
+
"
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
_
(
"
Arrange
for
meta
/
global
to
return
a
401
.
"
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
storage
;
server
.
toplevelHandlers
.
storage
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
storage
=
oldHandler
;
}
Assert
.
ok
(
Service
.
isLoggedIn
"
already
logged
in
"
)
;
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
meta
/
global
"
)
;
}
)
;
add_task
(
async
function
test_momentary_401_storage_loggedout
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
any
storage
URL
before
login
not
just
engine
parts
.
"
+
"
Resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
storage
;
server
.
toplevelHandlers
.
storage
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
storage
=
oldHandler
;
}
Assert
.
ok
(
!
Service
.
isLoggedIn
"
already
logged
in
"
)
;
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
login
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
meta
/
global
"
)
;
}
)
;
