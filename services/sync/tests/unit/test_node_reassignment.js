_
(
"
Test
that
node
reassignment
responses
are
respected
on
all
kinds
of
"
+
"
requests
.
"
)
;
const
{
RESTRequest
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
rest
.
js
"
)
;
const
{
Service
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
const
{
PromiseUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
add_task
(
async
function
setup
(
)
{
validate_all_future_pings
(
)
;
}
)
;
const
reassignBody
=
"
\
"
server
request
:
node
reassignment
\
"
"
;
function
handleReassign
(
handler
req
resp
)
{
resp
.
setStatusLine
(
req
.
httpVersion
401
"
Node
reassignment
"
)
;
resp
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
resp
.
bodyOutputStream
.
write
(
reassignBody
reassignBody
.
length
)
;
}
async
function
prepareServer
(
)
{
let
server
=
new
SyncServer
(
)
;
server
.
registerUser
(
"
johndoe
"
)
;
server
.
start
(
)
;
syncTestLogging
(
)
;
await
configureIdentity
(
{
username
:
"
johndoe
"
}
server
)
;
return
server
;
}
function
getReassigned
(
)
{
try
{
return
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
lastSyncReassigned
"
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_UNEXPECTED
)
{
do_throw
(
"
Got
exception
retrieving
lastSyncReassigned
:
"
+
Log
.
exceptionStr
(
ex
)
)
;
}
}
return
false
;
}
async
function
syncAndExpectNodeReassignment
(
server
firstNotification
between
secondNotification
url
)
{
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
getTokenCount
=
0
;
let
mockTSC
=
{
async
getTokenFromBrowserIDAssertion
(
uri
assertion
)
{
getTokenCount
+
+
;
return
{
endpoint
:
server
.
baseURI
+
"
1
.
1
/
johndoe
/
"
}
;
}
}
;
Service
.
identity
.
_tokenServerClient
=
mockTSC
;
let
request
=
new
RESTRequest
(
url
)
;
let
response
=
await
request
.
get
(
)
;
Assert
.
equal
(
response
.
status
401
)
;
function
onFirstSync
(
)
{
_
(
"
First
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
firstNotification
onFirstSync
)
;
Svc
.
Obs
.
add
(
secondNotification
onSecondSync
)
;
Assert
.
equal
(
Service
.
clusterURL
"
"
)
;
between
(
)
;
}
function
onSecondSync
(
)
{
_
(
"
Second
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
secondNotification
onSecondSync
)
;
Service
.
scheduler
.
clearSyncTriggers
(
)
;
waitForZeroTimer
(
function
(
)
{
_
(
"
Second
sync
nextTick
.
"
)
;
Assert
.
equal
(
getTokenCount
1
)
;
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
server
.
stop
(
deferred
.
resolve
)
;
}
)
;
}
)
;
}
Svc
.
Obs
.
add
(
firstNotification
onFirstSync
)
;
await
Service
.
sync
(
)
;
await
deferred
.
promise
;
}
add_task
(
async
function
test_momentary_401_engine
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
engine
URLs
that
'
s
resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
john
=
server
.
user
(
"
johndoe
"
)
;
_
(
"
Enabling
the
Rotary
engine
.
"
)
;
let
{
engine
syncID
tracker
}
=
await
registerRotaryEngine
(
)
;
let
global
=
{
syncID
:
Service
.
syncID
storageVersion
:
STORAGE_VERSION
rotary
:
{
version
:
engine
.
version
syncID
}
}
;
john
.
createCollection
(
"
meta
"
)
.
insert
(
"
global
"
global
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
_
(
"
Setting
up
Rotary
collection
to
401
.
"
)
;
let
rotary
=
john
.
createCollection
(
"
rotary
"
)
;
let
oldHandler
=
rotary
.
collectionHandler
;
rotary
.
collectionHandler
=
handleReassign
.
bind
(
this
undefined
)
;
john
.
collection
(
"
rotary
"
)
.
timestamp
+
=
1000
;
function
between
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
rotary
.
collectionHandler
=
oldHandler
;
function
onLoginStart
(
)
{
_
(
"
Ensuring
that
lastSyncReassigned
is
still
set
at
next
sync
start
.
"
)
;
Svc
.
Obs
.
remove
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
Assert
.
ok
(
getReassigned
(
)
)
;
}
_
(
"
Adding
observer
that
lastSyncReassigned
is
still
set
on
login
.
"
)
;
Svc
.
Obs
.
add
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
}
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
finish
"
between
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
rotary
"
)
;
await
tracker
.
clearChangedIDs
(
)
;
await
Service
.
engineManager
.
unregister
(
engine
)
;
}
)
;
add_task
(
async
function
test_momentary_401_info_collections
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
info
/
collections
that
'
s
resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
info
;
server
.
toplevelHandlers
.
info
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
info
=
oldHandler
;
}
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
infoURL
)
;
}
)
;
add_task
(
async
function
test_momentary_401_storage_loggedin
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
any
storage
URL
not
just
engine
parts
.
"
+
"
Resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
_
(
"
Performing
initial
sync
to
ensure
we
are
logged
in
.
"
)
;
await
Service
.
sync
(
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
storage
;
server
.
toplevelHandlers
.
storage
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
storage
=
oldHandler
;
}
Assert
.
ok
(
Service
.
isLoggedIn
"
already
logged
in
"
)
;
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
sync
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
meta
/
global
"
)
;
}
)
;
add_task
(
async
function
test_momentary_401_storage_loggedout
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
a
failure
for
any
storage
URL
not
just
engine
parts
.
"
+
"
Resolved
by
reassignment
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
storage
;
server
.
toplevelHandlers
.
storage
=
handleReassign
;
function
undo
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
server
.
toplevelHandlers
.
storage
=
oldHandler
;
}
Assert
.
ok
(
!
Service
.
isLoggedIn
"
not
already
logged
in
"
)
;
await
syncAndExpectNodeReassignment
(
server
"
weave
:
service
:
login
:
error
"
undo
"
weave
:
service
:
sync
:
finish
"
Service
.
storageURL
+
"
meta
/
global
"
)
;
}
)
;
add_task
(
async
function
test_loop_avoidance_storage
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
that
a
repeated
failure
doesn
'
t
result
in
a
sync
loop
"
+
"
if
node
reassignment
cannot
resolve
the
failure
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
oldHandler
=
server
.
toplevelHandlers
.
storage
;
server
.
toplevelHandlers
.
storage
=
handleReassign
;
let
firstNotification
=
"
weave
:
service
:
login
:
error
"
;
let
secondNotification
=
"
weave
:
service
:
login
:
error
"
;
let
thirdNotification
=
"
weave
:
service
:
sync
:
finish
"
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
getTokenCount
=
0
;
let
mockTSC
=
{
async
getTokenFromBrowserIDAssertion
(
uri
assertion
)
{
getTokenCount
+
+
;
return
{
endpoint
:
server
.
baseURI
+
"
1
.
1
/
johndoe
/
"
}
;
}
}
;
Service
.
identity
.
_tokenServerClient
=
mockTSC
;
let
now
;
function
onFirstSync
(
)
{
_
(
"
First
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
firstNotification
onFirstSync
)
;
Svc
.
Obs
.
add
(
secondNotification
onSecondSync
)
;
Assert
.
equal
(
Service
.
clusterURL
"
"
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
lastSyncReassigned
"
)
)
;
now
=
Date
.
now
(
)
;
}
function
onSecondSync
(
)
{
_
(
"
Second
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
secondNotification
onSecondSync
)
;
Svc
.
Obs
.
add
(
thirdNotification
onThirdSync
)
;
let
elapsedTime
=
Date
.
now
(
)
-
now
;
Assert
.
ok
(
elapsedTime
<
MINIMUM_BACKOFF_INTERVAL
)
;
Assert
.
ok
(
getReassigned
(
)
)
;
let
expectedNextSync
=
1000
*
Math
.
floor
(
(
now
+
MINIMUM_BACKOFF_INTERVAL
)
/
1000
)
;
_
(
"
Next
sync
scheduled
for
"
+
Service
.
scheduler
.
nextSync
)
;
_
(
"
Expected
to
be
slightly
greater
than
"
+
expectedNextSync
)
;
Assert
.
ok
(
Service
.
scheduler
.
nextSync
>
=
expectedNextSync
)
;
Assert
.
ok
(
!
!
Service
.
scheduler
.
syncTimer
)
;
server
.
toplevelHandlers
.
storage
=
oldHandler
;
Service
.
scheduler
.
scheduleNextSync
(
0
)
;
}
function
onThirdSync
(
)
{
Svc
.
Obs
.
remove
(
thirdNotification
onThirdSync
)
;
Service
.
scheduler
.
clearSyncTriggers
(
)
;
waitForZeroTimer
(
function
(
)
{
_
(
"
Third
sync
nextTick
.
"
)
;
Assert
.
ok
(
!
getReassigned
(
)
)
;
Assert
.
equal
(
getTokenCount
2
)
;
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
server
.
stop
(
deferred
.
resolve
)
;
}
)
;
}
)
;
}
Svc
.
Obs
.
add
(
firstNotification
onFirstSync
)
;
now
=
Date
.
now
(
)
;
await
Service
.
sync
(
)
;
await
deferred
.
promise
;
}
)
;
add_task
(
async
function
test_loop_avoidance_engine
(
)
{
enableValidationPrefs
(
)
;
_
(
"
Test
that
a
repeated
401
in
an
engine
doesn
'
t
result
in
a
sync
loop
"
+
"
if
node
reassignment
cannot
resolve
the
failure
.
"
)
;
let
server
=
await
prepareServer
(
)
;
let
john
=
server
.
user
(
"
johndoe
"
)
;
_
(
"
Enabling
the
Rotary
engine
.
"
)
;
let
{
engine
syncID
tracker
}
=
await
registerRotaryEngine
(
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
getTokenCount
=
0
;
let
mockTSC
=
{
getTokenFromBrowserIDAssertion
(
uri
assertion
)
{
getTokenCount
+
+
;
return
{
endpoint
:
server
.
baseURI
+
"
1
.
1
/
johndoe
/
"
}
;
}
}
;
Service
.
identity
.
_tokenServerClient
=
mockTSC
;
let
global
=
{
syncID
:
Service
.
syncID
storageVersion
:
STORAGE_VERSION
rotary
:
{
version
:
engine
.
version
syncID
}
}
;
john
.
createCollection
(
"
meta
"
)
.
insert
(
"
global
"
global
)
;
_
(
"
First
sync
to
prepare
server
contents
.
"
)
;
await
Service
.
sync
(
)
;
_
(
"
Setting
up
Rotary
collection
to
401
.
"
)
;
let
rotary
=
john
.
createCollection
(
"
rotary
"
)
;
let
oldHandler
=
rotary
.
collectionHandler
;
rotary
.
collectionHandler
=
handleReassign
.
bind
(
this
undefined
)
;
john
.
collection
(
"
rotary
"
)
.
timestamp
+
=
1000
;
function
onLoginStart
(
)
{
_
(
"
Ensuring
that
lastSyncReassigned
is
still
set
at
next
sync
start
.
"
)
;
Assert
.
ok
(
getReassigned
(
)
)
;
}
function
beforeSuccessfulSync
(
)
{
_
(
"
Undoing
test
changes
.
"
)
;
rotary
.
collectionHandler
=
oldHandler
;
}
let
firstNotification
=
"
weave
:
service
:
sync
:
finish
"
;
let
secondNotification
=
"
weave
:
service
:
sync
:
finish
"
;
let
thirdNotification
=
"
weave
:
service
:
sync
:
finish
"
;
let
now
;
function
onFirstSync
(
)
{
_
(
"
First
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
firstNotification
onFirstSync
)
;
Svc
.
Obs
.
add
(
secondNotification
onSecondSync
)
;
Assert
.
equal
(
Service
.
clusterURL
"
"
)
;
_
(
"
Adding
observer
that
lastSyncReassigned
is
still
set
on
login
.
"
)
;
Svc
.
Obs
.
add
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
Assert
.
ok
(
Services
.
prefs
.
getBoolPref
(
"
services
.
sync
.
lastSyncReassigned
"
)
)
;
now
=
Date
.
now
(
)
;
}
function
onSecondSync
(
)
{
_
(
"
Second
sync
completed
.
"
)
;
Svc
.
Obs
.
remove
(
secondNotification
onSecondSync
)
;
Svc
.
Obs
.
add
(
thirdNotification
onThirdSync
)
;
let
elapsedTime
=
Date
.
now
(
)
-
now
;
Assert
.
ok
(
elapsedTime
<
MINIMUM_BACKOFF_INTERVAL
)
;
Assert
.
ok
(
getReassigned
(
)
)
;
let
expectedNextSync
=
1000
*
Math
.
floor
(
(
now
+
MINIMUM_BACKOFF_INTERVAL
)
/
1000
)
;
_
(
"
Next
sync
scheduled
for
"
+
Service
.
scheduler
.
nextSync
)
;
_
(
"
Expected
to
be
slightly
greater
than
"
+
expectedNextSync
)
;
Assert
.
ok
(
Service
.
scheduler
.
nextSync
>
=
expectedNextSync
)
;
Assert
.
ok
(
!
!
Service
.
scheduler
.
syncTimer
)
;
beforeSuccessfulSync
(
)
;
Service
.
scheduler
.
scheduleNextSync
(
0
)
;
}
function
onThirdSync
(
)
{
Svc
.
Obs
.
remove
(
thirdNotification
onThirdSync
)
;
Service
.
scheduler
.
clearSyncTriggers
(
)
;
waitForZeroTimer
(
function
(
)
{
_
(
"
Third
sync
nextTick
.
"
)
;
Assert
.
ok
(
!
getReassigned
(
)
)
;
Assert
.
equal
(
getTokenCount
2
)
;
Svc
.
Obs
.
remove
(
"
weave
:
service
:
login
:
start
"
onLoginStart
)
;
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
server
.
stop
(
deferred
.
resolve
)
;
}
)
;
}
)
;
}
Svc
.
Obs
.
add
(
firstNotification
onFirstSync
)
;
now
=
Date
.
now
(
)
;
await
Service
.
sync
(
)
;
await
deferred
.
promise
;
await
tracker
.
clearChangedIDs
(
)
;
await
Service
.
engineManager
.
unregister
(
engine
)
;
}
)
;
