Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
/
bookmarks
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
sync
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
bookmark_validator
.
js
"
)
;
initTestLogging
(
"
Trace
"
)
;
const
bms
=
PlacesUtils
.
bookmarks
;
Service
.
engineManager
.
register
(
BookmarksEngine
)
;
const
engine
=
new
BookmarksEngine
(
Service
)
;
const
store
=
engine
.
_store
;
store
.
_log
.
level
=
Log
.
Level
.
Trace
;
engine
.
_log
.
level
=
Log
.
Level
.
Trace
;
function
promiseOneObserver
(
topic
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
observer
=
function
(
subject
topic
data
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
{
subject
:
subject
data
:
data
}
)
;
}
Services
.
obs
.
addObserver
(
observer
topic
false
)
;
}
)
;
}
function
setup
(
)
{
let
server
=
serverForUsers
(
{
"
foo
"
:
"
password
"
}
{
meta
:
{
global
:
{
engines
:
{
bookmarks
:
{
version
:
engine
.
version
syncID
:
engine
.
syncID
}
}
}
}
bookmarks
:
{
}
}
)
;
generateNewKeys
(
Service
.
collectionKeys
)
;
new
SyncTestingInfrastructure
(
server
.
server
)
;
let
collection
=
server
.
user
(
"
foo
"
)
.
collection
(
"
bookmarks
"
)
;
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
start
-
tracking
"
)
;
return
{
server
collection
}
;
}
function
*
cleanup
(
server
)
{
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
stop
-
tracking
"
)
;
Services
.
prefs
.
setBoolPref
(
"
services
.
sync
-
testing
.
startOverKeepIdentity
"
true
)
;
let
promiseStartOver
=
promiseOneObserver
(
"
weave
:
service
:
start
-
over
:
finish
"
)
;
Service
.
startOver
(
)
;
yield
promiseStartOver
;
yield
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
yield
bms
.
eraseEverything
(
)
;
}
function
getFolderChildrenIDs
(
folderId
)
{
let
index
=
0
;
let
result
=
[
]
;
while
(
true
)
{
let
childId
=
bms
.
getIdForItemAt
(
folderId
index
)
;
if
(
childId
=
=
-
1
)
{
break
;
}
result
.
push
(
childId
)
;
index
+
+
;
}
return
result
;
}
function
createFolder
(
parentId
title
)
{
let
id
=
bms
.
createFolder
(
parentId
title
0
)
;
let
guid
=
store
.
GUIDForId
(
id
)
;
return
{
id
guid
}
;
}
function
createBookmark
(
parentId
url
title
index
=
bms
.
DEFAULT_INDEX
)
{
let
uri
=
Utils
.
makeURI
(
url
)
;
let
id
=
bms
.
insertBookmark
(
parentId
uri
index
title
)
let
guid
=
store
.
GUIDForId
(
id
)
;
return
{
id
guid
}
;
}
function
getServerRecord
(
collection
id
)
{
let
wbo
=
collection
.
get
(
{
full
:
true
ids
:
[
id
]
}
)
;
return
JSON
.
parse
(
JSON
.
parse
(
JSON
.
parse
(
wbo
)
.
payload
)
.
ciphertext
)
;
}
function
*
promiseNoLocalItem
(
guid
)
{
let
got
=
yield
bms
.
fetch
(
{
guid
}
)
;
ok
(
!
got
No
record
remains
with
GUID
{
guid
}
)
;
yield
Assert
.
rejects
(
PlacesUtils
.
promiseItemId
(
guid
)
)
;
}
function
*
validate
(
collection
expectedFailures
=
[
]
)
{
let
validator
=
new
BookmarkValidator
(
)
;
let
records
=
collection
.
payloads
(
)
;
let
problems
=
validator
.
inspectServerRecords
(
records
)
.
problemData
;
let
summary
=
problems
.
getSummary
(
)
.
filter
(
prob
=
>
prob
.
count
!
=
0
)
;
let
isInExpectedFailures
=
elt
=
>
{
for
(
let
i
=
0
;
i
<
expectedFailures
.
length
;
i
+
+
)
{
if
(
elt
.
name
=
=
expectedFailures
[
i
]
.
name
&
&
elt
.
count
=
=
expectedFailures
[
i
]
.
count
)
{
return
true
;
}
}
return
false
;
}
let
expected
=
[
]
;
let
unexpected
=
[
]
;
for
(
let
elt
of
summary
)
{
(
isInExpectedFailures
(
elt
)
?
expected
:
unexpected
)
.
push
(
elt
)
;
}
if
(
unexpected
.
length
|
|
expected
.
length
!
=
expectedFailures
.
length
)
{
do_print
(
"
Validation
failed
:
"
)
;
do_print
(
JSON
.
stringify
(
summary
)
)
;
do_print
(
JSON
.
stringify
(
problems
undefined
2
)
)
;
do_print
(
"
Server
records
:
\
n
"
+
JSON
.
stringify
(
collection
.
payloads
(
)
undefined
2
)
)
;
let
tree
=
yield
PlacesUtils
.
promiseBookmarksTree
(
"
"
{
includeItemIds
:
true
}
)
;
do_print
(
"
Local
bookmark
tree
:
\
n
"
+
JSON
.
stringify
(
tree
undefined
2
)
)
;
ok
(
false
)
;
}
}
add_task
(
function
*
test_dupe_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
is
handled
correctly
.
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
6
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder1_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
yield
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
serverRecord
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord
.
children
.
includes
(
newGUID
)
)
;
yield
validate
(
collection
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_reparented_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
is
handled
correctly
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
do_print
(
folder1_guid
=
{
folder1_guid
}
folder2_guid
=
{
folder2_guid
}
bmk1_guid
=
{
bmk1_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
equal
(
getFolderChildrenIDs
(
folder2_id
)
.
length
0
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder2_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
yield
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
0
)
;
equal
(
getFolderChildrenIDs
(
folder2_id
)
.
length
1
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
let
serverRecord2
=
getServerRecord
(
collection
folder2_guid
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord2
.
children
.
includes
(
newGUID
)
)
;
yield
validate
(
collection
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_reparented_locally_changed_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
with
local
changes
we
consider
a
dupe
from
a
different
parent
is
handled
correctly
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
do_print
(
folder1_guid
=
{
folder1_guid
}
folder2_guid
=
{
folder2_guid
}
bmk1_guid
=
{
bmk1_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
equal
(
getFolderChildrenIDs
(
folder2_id
)
.
length
0
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder2_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
engine
.
_tracker
.
addChangedID
(
bmk1_guid
Date
.
now
(
)
/
1000
+
60
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
yield
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
equal
(
getFolderChildrenIDs
(
folder2_id
)
.
length
0
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
let
serverRecord2
=
getServerRecord
(
collection
folder2_guid
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
newGUID
)
)
;
yield
validate
(
collection
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_reparented_to_earlier_appearing_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
appears
in
the
same
sync
before
the
dupe
item
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
records
are
processed
.
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
yield
validate
(
collection
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_reparented_to_later_appearing_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
doesn
'
t
exist
locally
as
we
process
the
child
but
does
appear
in
the
same
sync
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
out
-
of
-
order
records
are
processed
.
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
yield
validate
(
collection
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_reparented_to_future_arriving_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
doesn
'
t
exist
locally
and
doesn
'
t
appear
in
this
Sync
is
handled
correctly
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
id
:
bmk1_id
guid
:
bmk1_guid
}
=
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
yield
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
1
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
equal
(
PlacesUtils
.
annotations
.
getItemAnnotation
(
store
.
idForGUID
(
newGUID
)
"
sync
/
parent
"
)
newParentGUID
)
;
let
expected
=
[
{
name
:
"
orphans
"
count
:
1
}
]
;
yield
validate
(
collection
expected
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
missing
parent
appears
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
getFolderChildrenIDs
(
folder1_id
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
expected
=
[
{
name
:
"
multipleParents
"
count
:
1
}
]
;
yield
validate
(
collection
expected
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
add_task
(
function
*
test_dupe_empty_folder
(
)
{
_
(
"
Ensure
that
an
empty
folder
we
consider
a
dupe
is
handled
correctly
.
"
)
;
let
{
server
collection
}
=
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
5
)
;
let
newFolderGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newFolderGUID
encryptPayload
(
{
id
:
newFolderGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
records
are
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
yield
validate
(
collection
)
;
equal
(
collection
.
count
(
)
6
)
;
ok
(
getServerRecord
(
collection
folder1_guid
)
.
deleted
)
;
yield
promiseNoLocalItem
(
folder1_guid
)
;
}
finally
{
yield
cleanup
(
server
)
;
}
}
)
;
