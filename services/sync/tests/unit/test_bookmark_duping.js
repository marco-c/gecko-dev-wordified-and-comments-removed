Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
/
bookmarks
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
sync
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
bookmark_validator
.
js
"
)
;
initTestLogging
(
"
Trace
"
)
;
const
bms
=
PlacesUtils
.
bookmarks
;
Service
.
engineManager
.
register
(
BookmarksEngine
)
;
const
engine
=
new
BookmarksEngine
(
Service
)
;
const
store
=
engine
.
_store
;
store
.
_log
.
level
=
Log
.
Level
.
Trace
;
engine
.
_log
.
level
=
Log
.
Level
.
Trace
;
async
function
setup
(
)
{
let
server
=
serverForUsers
(
{
"
foo
"
:
"
password
"
}
{
meta
:
{
global
:
{
engines
:
{
bookmarks
:
{
version
:
engine
.
version
syncID
:
engine
.
syncID
}
}
}
}
bookmarks
:
{
}
}
)
;
generateNewKeys
(
Service
.
collectionKeys
)
;
await
SyncTestingInfrastructure
(
server
)
;
let
collection
=
server
.
user
(
"
foo
"
)
.
collection
(
"
bookmarks
"
)
;
Service
.
scheduler
.
syncThreshold
=
10000000
;
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
start
-
tracking
"
)
;
return
{
server
collection
}
;
}
async
function
cleanup
(
server
)
{
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
stop
-
tracking
"
)
;
let
promiseStartOver
=
promiseOneObserver
(
"
weave
:
service
:
start
-
over
:
finish
"
)
;
Service
.
startOver
(
)
;
await
promiseStartOver
;
await
promiseStopServer
(
server
)
;
await
bms
.
eraseEverything
(
)
;
}
async
function
syncIdToId
(
syncId
)
{
let
guid
=
await
PlacesSyncUtils
.
bookmarks
.
syncIdToGuid
(
syncId
)
;
return
PlacesUtils
.
promiseItemId
(
guid
)
;
}
async
function
getFolderChildrenIDs
(
folderId
)
{
let
folderSyncId
=
PlacesSyncUtils
.
bookmarks
.
guidToSyncId
(
await
PlacesUtils
.
promiseItemGuid
(
folderId
)
)
;
let
syncIds
=
await
PlacesSyncUtils
.
bookmarks
.
fetchChildSyncIds
(
folderSyncId
)
;
return
Promise
.
all
(
syncIds
.
map
(
async
(
syncId
)
=
>
await
syncIdToId
(
syncId
)
)
)
;
}
async
function
createFolder
(
parentId
title
)
{
let
parentGuid
=
await
PlacesUtils
.
promiseItemGuid
(
parentId
)
;
let
folder
=
await
bms
.
insert
(
{
type
:
bms
.
TYPE_FOLDER
parentGuid
title
index
:
0
}
)
;
let
id
=
await
PlacesUtils
.
promiseItemId
(
folder
.
guid
)
;
return
{
id
guid
:
folder
.
guid
}
;
}
async
function
createBookmark
(
parentId
url
title
index
=
bms
.
DEFAULT_INDEX
)
{
let
parentGuid
=
await
PlacesUtils
.
promiseItemGuid
(
parentId
)
;
let
bookmark
=
await
bms
.
insert
(
{
parentGuid
url
index
title
}
)
;
let
id
=
await
PlacesUtils
.
promiseItemId
(
bookmark
.
guid
)
;
return
{
id
guid
:
bookmark
.
guid
}
;
}
function
getServerRecord
(
collection
id
)
{
let
wbo
=
collection
.
get
(
{
full
:
true
ids
:
[
id
]
}
)
;
return
JSON
.
parse
(
JSON
.
parse
(
JSON
.
parse
(
wbo
)
.
payload
)
.
ciphertext
)
;
}
async
function
promiseNoLocalItem
(
guid
)
{
let
got
=
await
bms
.
fetch
(
{
guid
}
)
;
ok
(
!
got
No
record
remains
with
GUID
{
guid
}
)
;
await
Assert
.
rejects
(
PlacesUtils
.
promiseItemId
(
guid
)
)
;
}
async
function
validate
(
collection
expectedFailures
=
[
]
)
{
let
validator
=
new
BookmarkValidator
(
)
;
let
records
=
collection
.
payloads
(
)
;
let
problems
=
validator
.
inspectServerRecords
(
records
)
.
problemData
;
let
summary
=
problems
.
getSummary
(
)
.
filter
(
prob
=
>
prob
.
count
!
=
0
)
;
let
isInExpectedFailures
=
elt
=
>
{
for
(
let
i
=
0
;
i
<
expectedFailures
.
length
;
i
+
+
)
{
if
(
elt
.
name
=
=
expectedFailures
[
i
]
.
name
&
&
elt
.
count
=
=
expectedFailures
[
i
]
.
count
)
{
return
true
;
}
}
return
false
;
}
let
expected
=
[
]
;
let
unexpected
=
[
]
;
for
(
let
elt
of
summary
)
{
(
isInExpectedFailures
(
elt
)
?
expected
:
unexpected
)
.
push
(
elt
)
;
}
if
(
unexpected
.
length
|
|
expected
.
length
!
=
expectedFailures
.
length
)
{
do_print
(
"
Validation
failed
:
"
)
;
do_print
(
JSON
.
stringify
(
summary
)
)
;
do_print
(
JSON
.
stringify
(
problems
undefined
2
)
)
;
do_print
(
"
Server
records
:
\
n
"
+
JSON
.
stringify
(
collection
.
payloads
(
)
undefined
2
)
)
;
let
tree
=
await
PlacesUtils
.
promiseBookmarksTree
(
"
"
{
includeItemIds
:
true
}
)
;
do_print
(
"
Local
bookmark
tree
:
\
n
"
+
JSON
.
stringify
(
tree
undefined
2
)
)
;
ok
(
false
)
;
}
}
add_task
(
async
function
test_dupe_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
is
handled
correctly
.
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
6
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder1_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
await
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
serverRecord
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord
.
children
.
includes
(
newGUID
)
)
;
await
validate
(
collection
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_reparented_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
is
handled
correctly
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
do_print
(
folder1_guid
=
{
folder1_guid
}
folder2_guid
=
{
folder2_guid
}
bmk1_guid
=
{
bmk1_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder2_id
)
)
.
length
0
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder2_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
await
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
0
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder2_id
)
)
.
length
1
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
let
serverRecord2
=
getServerRecord
(
collection
folder2_guid
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord2
.
children
.
includes
(
newGUID
)
)
;
await
validate
(
collection
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_reparented_locally_changed_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
with
local
changes
we
consider
a
dupe
from
a
different
parent
is
handled
correctly
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
id
:
folder2_id
guid
:
folder2_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
do_print
(
folder1_guid
=
{
folder1_guid
}
folder2_guid
=
{
folder2_guid
}
bmk1_guid
=
{
bmk1_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder2_id
)
)
.
length
0
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
to_apply
=
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
folder2_guid
}
;
collection
.
insert
(
newGUID
encryptPayload
(
to_apply
)
Date
.
now
(
)
/
1000
+
10
)
;
await
PlacesTestUtils
.
setBookmarkSyncFields
(
{
guid
:
bmk1_guid
syncChangeCounter
:
1
lastModified
:
Date
.
now
(
)
+
60000
}
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
await
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder2_id
)
)
.
length
0
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
let
serverRecord2
=
getServerRecord
(
collection
folder2_guid
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
!
serverRecord2
.
children
.
includes
(
newGUID
)
)
;
await
validate
(
collection
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_reparented_to_earlier_appearing_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
appears
in
the
same
sync
before
the
dupe
item
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
guid
:
folder2_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
records
are
processed
.
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
await
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
await
validate
(
collection
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_reparented_to_later_appearing_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
doesn
'
t
exist
locally
as
we
process
the
child
but
does
appear
in
the
same
sync
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
guid
:
folder2_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
out
-
of
-
order
records
are
processed
.
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
await
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
await
validate
(
collection
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_reparented_to_future_arriving_parent_bookmark
(
)
{
_
(
"
Ensure
that
a
bookmark
we
consider
a
dupe
from
a
different
parent
that
"
+
"
doesn
'
t
exist
locally
and
doesn
'
t
appear
in
this
Sync
is
handled
correctly
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
id
:
folder1_id
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
let
{
guid
:
bmk1_guid
}
=
await
createBookmark
(
folder1_id
"
http
:
/
/
getfirefox
.
com
/
"
"
Get
Firefox
!
"
)
;
let
{
guid
:
folder2_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
A
second
folder
"
)
;
do_print
(
folder1
=
{
folder1_guid
}
bmk1
=
{
bmk1_guid
}
folder2
=
{
folder2_guid
}
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
7
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
newGUID
=
Utils
.
makeGUID
(
)
;
let
newParentGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newGUID
encryptPayload
(
{
id
:
newGUID
bmkUri
:
"
http
:
/
/
getfirefox
.
com
/
"
type
:
"
bookmark
"
title
:
"
Get
Firefox
!
"
parentName
:
"
Folder
1
"
parentid
:
newParentGUID
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
record
is
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
8
)
;
ok
(
getServerRecord
(
collection
bmk1_guid
)
.
deleted
)
;
await
promiseNoLocalItem
(
bmk1_guid
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
1
)
;
let
serverRecord1
=
getServerRecord
(
collection
folder1_guid
)
;
ok
(
!
serverRecord1
.
children
.
includes
(
bmk1_guid
)
)
;
ok
(
serverRecord1
.
children
.
includes
(
newGUID
)
)
;
equal
(
PlacesUtils
.
annotations
.
getItemAnnotation
(
store
.
idForGUID
(
newGUID
)
"
sync
/
parent
"
)
newParentGUID
)
;
let
expected
=
[
{
name
:
"
orphans
"
count
:
1
}
]
;
await
validate
(
collection
expected
)
;
collection
.
insert
(
newParentGUID
encryptPayload
(
{
id
:
newParentGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
A
second
folder
"
parentid
:
folder2_guid
children
:
[
newGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
collection
.
insert
(
folder2_guid
encryptPayload
(
{
id
:
folder2_guid
type
:
"
folder
"
title
:
"
A
second
folder
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
newParentGUID
]
tags
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
missing
parent
appears
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
equal
(
(
await
getFolderChildrenIDs
(
folder1_id
)
)
.
length
0
)
;
let
newParentID
=
store
.
idForGUID
(
newParentGUID
)
;
let
newID
=
store
.
idForGUID
(
newGUID
)
;
deepEqual
(
await
getFolderChildrenIDs
(
newParentID
)
[
newID
]
)
;
expected
=
[
{
name
:
"
multipleParents
"
count
:
1
}
]
;
await
validate
(
collection
expected
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
add_task
(
async
function
test_dupe_empty_folder
(
)
{
_
(
"
Ensure
that
an
empty
folder
we
consider
a
dupe
is
handled
correctly
.
"
)
;
let
{
server
collection
}
=
await
this
.
setup
(
)
;
try
{
let
{
guid
:
folder1_guid
}
=
await
createFolder
(
bms
.
toolbarFolder
"
Folder
1
"
)
;
engine
.
sync
(
)
;
equal
(
collection
.
count
(
)
5
)
;
let
newFolderGUID
=
Utils
.
makeGUID
(
)
;
collection
.
insert
(
newFolderGUID
encryptPayload
(
{
id
:
newFolderGUID
type
:
"
folder
"
title
:
"
Folder
1
"
parentName
:
"
Bookmarks
Toolbar
"
parentid
:
"
toolbar
"
children
:
[
]
}
)
Date
.
now
(
)
/
1000
+
10
)
;
_
(
"
Syncing
so
new
dupe
records
are
processed
"
)
;
engine
.
lastSync
=
engine
.
lastSync
-
0
.
01
;
engine
.
sync
(
)
;
await
validate
(
collection
)
;
equal
(
collection
.
count
(
)
6
)
;
ok
(
getServerRecord
(
collection
folder1_guid
)
.
deleted
)
;
await
promiseNoLocalItem
(
folder1_guid
)
;
}
finally
{
await
cleanup
(
server
)
;
}
}
)
;
