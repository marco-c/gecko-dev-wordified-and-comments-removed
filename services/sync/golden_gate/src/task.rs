use
std
:
:
{
fmt
:
:
Write
mem
sync
:
:
{
Arc
Weak
}
}
;
use
atomic_refcell
:
:
AtomicRefCell
;
use
moz_task
:
:
{
DispatchOptions
Task
TaskRunnable
ThreadPtrHandle
ThreadPtrHolder
}
;
use
nserror
:
:
nsresult
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
sync15_traits
:
:
{
ApplyResults
BridgedEngine
Guid
}
;
use
thin_vec
:
:
ThinVec
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIBridgedSyncEngineApplyCallback
mozIBridgedSyncEngineCallback
nsIEventTarget
}
RefPtr
}
;
use
crate
:
:
error
:
:
{
self
BridgedError
Error
}
;
use
crate
:
:
ferry
:
:
{
Ferry
FerryResult
}
;
pub
struct
FerryTask
<
N
:
?
Sized
+
BridgedEngine
>
{
engine
:
Weak
<
N
>
ferry
:
Ferry
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineCallback
>
result
:
AtomicRefCell
<
Result
<
FerryResult
N
:
:
Error
>
>
}
impl
<
N
>
FerryTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
+
Send
+
Sync
+
'
static
N
:
:
Error
:
BridgedError
{
#
[
inline
]
pub
fn
for_last_sync
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
LastSync
callback
)
}
#
[
inline
]
pub
fn
for_set_last_sync
(
engine
:
&
Arc
<
N
>
last_sync_millis
:
i64
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetLastSync
(
last_sync_millis
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_id
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncId
callback
)
}
#
[
inline
]
pub
fn
for_reset_sync_id
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
ResetSyncId
callback
)
}
#
[
inline
]
pub
fn
for_ensure_current_sync_id
(
engine
:
&
Arc
<
N
>
new_sync_id
:
&
nsACString
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
EnsureCurrentSyncId
(
std
:
:
str
:
:
from_utf8
(
new_sync_id
)
?
.
into
(
)
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_started
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncStarted
callback
)
}
pub
fn
for_store_incoming
(
engine
:
&
Arc
<
N
>
incoming_envelopes_json
:
&
[
nsCString
]
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
let
incoming_envelopes
=
incoming_envelopes_json
.
iter
(
)
.
try_fold
(
Vec
:
:
with_capacity
(
incoming_envelopes_json
.
len
(
)
)
|
mut
envelopes
envelope
|
-
>
error
:
:
Result
<
_
>
{
envelopes
.
push
(
serde_json
:
:
from_slice
(
&
*
envelope
)
?
)
;
Ok
(
envelopes
)
}
)
?
;
Self
:
:
with_ferry
(
engine
Ferry
:
:
StoreIncoming
(
incoming_envelopes
)
callback
)
}
pub
fn
for_set_uploaded
(
engine
:
&
Arc
<
N
>
server_modified_millis
:
i64
uploaded_ids
:
&
[
nsCString
]
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
let
uploaded_ids
=
uploaded_ids
.
iter
(
)
.
map
(
|
id
|
Guid
:
:
from_slice
(
&
*
id
)
)
.
collect
(
)
;
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_finished
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncFinished
callback
)
}
#
[
inline
]
pub
fn
for_reset
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Reset
callback
)
}
#
[
inline
]
pub
fn
for_wipe
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Wipe
callback
)
}
fn
with_ferry
(
engine
:
&
Arc
<
N
>
ferry
:
Ferry
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
>
>
{
let
name
=
ferry
.
name
(
)
;
Ok
(
FerryTask
{
engine
:
Arc
:
:
downgrade
(
engine
)
ferry
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
name
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
Error
>
{
let
runnable
=
TaskRunnable
:
:
new
(
self
.
ferry
.
name
(
)
Box
:
:
new
(
self
)
)
?
;
runnable
.
dispatch_with_options
(
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
}
impl
<
N
>
FerryTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
N
:
:
Error
:
BridgedError
{
fn
inner_run
(
&
self
)
-
>
Result
<
FerryResult
N
:
:
Error
>
{
let
engine
=
match
self
.
engine
.
upgrade
(
)
{
Some
(
outer
)
=
>
outer
None
=
>
return
Err
(
Error
:
:
DidNotRun
(
self
.
ferry
.
name
(
)
)
.
into
(
)
)
}
;
Ok
(
match
&
self
.
ferry
{
Ferry
:
:
LastSync
=
>
FerryResult
:
:
LastSync
(
engine
.
last_sync
(
)
?
)
Ferry
:
:
SetLastSync
(
last_sync_millis
)
=
>
{
engine
.
set_last_sync
(
*
last_sync_millis
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SyncId
=
>
FerryResult
:
:
SyncId
(
engine
.
sync_id
(
)
?
)
Ferry
:
:
ResetSyncId
=
>
FerryResult
:
:
AssignedSyncId
(
engine
.
reset_sync_id
(
)
?
)
Ferry
:
:
EnsureCurrentSyncId
(
new_sync_id
)
=
>
{
FerryResult
:
:
AssignedSyncId
(
engine
.
ensure_current_sync_id
(
&
*
new_sync_id
)
?
)
}
Ferry
:
:
SyncStarted
=
>
{
engine
.
sync_started
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
StoreIncoming
(
incoming_envelopes
)
=
>
{
engine
.
store_incoming
(
incoming_envelopes
.
as_slice
(
)
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
)
=
>
{
engine
.
set_uploaded
(
*
server_modified_millis
uploaded_ids
.
as_slice
(
)
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SyncFinished
=
>
{
engine
.
sync_finished
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
Reset
=
>
{
engine
.
reset
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
Wipe
=
>
{
engine
.
wipe
(
)
?
;
FerryResult
:
:
default
(
)
}
}
)
}
}
impl
<
N
>
Task
for
FerryTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
N
:
:
Error
:
BridgedError
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
self
.
inner_run
(
)
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
self
.
ferry
.
name
(
)
)
.
into
(
)
)
)
{
Ok
(
result
)
=
>
unsafe
{
callback
.
HandleSuccess
(
result
.
into_variant
(
)
.
coerce
(
)
)
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
pub
struct
ApplyTask
<
N
:
?
Sized
+
BridgedEngine
>
{
engine
:
Weak
<
N
>
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineApplyCallback
>
result
:
AtomicRefCell
<
Result
<
Vec
<
String
>
N
:
:
Error
>
>
}
impl
<
N
>
ApplyTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
N
:
:
Error
:
BridgedError
{
pub
fn
name
(
)
-
>
&
'
static
str
{
concat
!
(
module_path
!
(
)
"
apply
"
)
}
fn
inner_run
(
&
self
)
-
>
Result
<
Vec
<
String
>
N
:
:
Error
>
{
let
engine
=
match
self
.
engine
.
upgrade
(
)
{
Some
(
outer
)
=
>
outer
None
=
>
return
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
}
;
let
ApplyResults
{
envelopes
:
outgoing_envelopes
.
.
}
=
engine
.
apply
(
)
?
;
let
outgoing_envelopes_json
=
outgoing_envelopes
.
iter
(
)
.
try_fold
(
Vec
:
:
with_capacity
(
outgoing_envelopes
.
len
(
)
)
|
mut
envelopes
envelope
|
{
envelopes
.
push
(
serde_json
:
:
to_string
(
envelope
)
?
)
;
Ok
(
envelopes
)
}
)
?
;
Ok
(
outgoing_envelopes_json
)
}
}
impl
<
N
>
ApplyTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
+
Send
+
Sync
+
'
static
N
:
:
Error
:
BridgedError
{
pub
fn
new
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineApplyCallback
)
-
>
error
:
:
Result
<
ApplyTask
<
N
>
>
{
Ok
(
ApplyTask
{
engine
:
Arc
:
:
downgrade
(
engine
)
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineApplyCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
Error
>
{
let
runnable
=
TaskRunnable
:
:
new
(
Self
:
:
name
(
)
Box
:
:
new
(
self
)
)
?
;
runnable
.
dispatch_with_options
(
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
}
impl
<
N
>
Task
for
ApplyTask
<
N
>
where
N
:
?
Sized
+
BridgedEngine
N
:
:
Error
:
BridgedError
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
self
.
inner_run
(
)
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
{
Ok
(
envelopes
)
=
>
{
let
result
=
envelopes
.
into_iter
(
)
.
map
(
nsCString
:
:
from
)
.
collect
:
:
<
ThinVec
<
_
>
>
(
)
;
unsafe
{
callback
.
HandleSuccess
(
&
result
)
}
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
