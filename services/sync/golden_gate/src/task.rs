use
std
:
:
{
fmt
:
:
Write
mem
sync
:
:
Arc
}
;
use
atomic_refcell
:
:
AtomicRefCell
;
use
golden_gate_traits
:
:
{
BridgedEngine
Interruptee
}
;
use
moz_task
:
:
{
DispatchOptions
Task
TaskRunnable
ThreadPtrHandle
ThreadPtrHolder
}
;
use
nserror
:
:
nsresult
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
thin_vec
:
:
ThinVec
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIBridgedSyncEngineApplyCallback
mozIBridgedSyncEngineCallback
nsIEventTarget
}
RefPtr
}
;
use
crate
:
:
error
:
:
{
self
BridgedError
Error
}
;
use
crate
:
:
ferry
:
:
{
Ferry
FerryResult
}
;
pub
struct
FerryTask
<
N
:
?
Sized
+
BridgedEngine
S
>
{
engine
:
Arc
<
N
>
ferry
:
Ferry
<
S
>
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineCallback
>
result
:
AtomicRefCell
<
Result
<
FerryResult
N
:
:
Error
>
>
}
impl
<
N
S
>
FerryTask
<
N
S
>
where
N
:
?
Sized
+
BridgedEngine
+
Send
+
Sync
+
'
static
S
:
Interruptee
+
Send
+
Sync
+
'
static
N
:
:
Error
:
BridgedError
{
#
[
inline
]
pub
fn
for_initialize
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Initialize
callback
)
}
#
[
inline
]
pub
fn
for_last_sync
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
LastSync
callback
)
}
#
[
inline
]
pub
fn
for_set_last_sync
(
engine
:
&
Arc
<
N
>
last_sync_millis
:
i64
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetLastSync
(
last_sync_millis
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_id
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncId
callback
)
}
#
[
inline
]
pub
fn
for_reset_sync_id
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
ResetSyncId
callback
)
}
#
[
inline
]
pub
fn
for_ensure_current_sync_id
(
engine
:
&
Arc
<
N
>
new_sync_id
:
&
nsACString
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
EnsureCurrentSyncId
(
std
:
:
str
:
:
from_utf8
(
new_sync_id
)
?
.
into
(
)
)
callback
)
}
pub
fn
for_store_incoming
(
engine
:
&
Arc
<
N
>
incoming_cleartexts
:
&
[
nsCString
]
signal
:
&
Arc
<
S
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
let
incoming_cleartexts
=
incoming_cleartexts
.
iter
(
)
.
try_fold
(
Vec
:
:
with_capacity
(
incoming_cleartexts
.
len
(
)
)
|
mut
cleartexts
cleartext
|
-
>
error
:
:
Result
<
_
>
{
cleartexts
.
push
(
std
:
:
str
:
:
from_utf8
(
&
*
cleartext
)
?
.
into
(
)
)
;
Ok
(
cleartexts
)
}
)
?
;
Self
:
:
with_ferry
(
engine
Ferry
:
:
StoreIncoming
(
incoming_cleartexts
Arc
:
:
clone
(
signal
)
)
callback
)
}
pub
fn
for_set_uploaded
(
engine
:
&
Arc
<
N
>
server_modified_millis
:
i64
uploaded_ids
:
&
[
nsCString
]
signal
:
&
Arc
<
S
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
let
uploaded_ids
=
uploaded_ids
.
iter
(
)
.
try_fold
(
Vec
:
:
with_capacity
(
uploaded_ids
.
len
(
)
)
|
mut
ids
id
|
-
>
error
:
:
Result
<
_
>
{
ids
.
push
(
std
:
:
str
:
:
from_utf8
(
&
*
id
)
?
.
into
(
)
)
;
Ok
(
ids
)
}
)
?
;
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
Arc
:
:
clone
(
signal
)
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_finished
(
engine
:
&
Arc
<
N
>
signal
:
&
Arc
<
S
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncFinished
(
Arc
:
:
clone
(
signal
)
)
callback
)
}
#
[
inline
]
pub
fn
for_reset
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Reset
callback
)
}
#
[
inline
]
pub
fn
for_wipe
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Wipe
callback
)
}
#
[
inline
]
pub
fn
for_finalize
(
engine
:
&
Arc
<
N
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Finalize
callback
)
}
fn
with_ferry
(
engine
:
&
Arc
<
N
>
ferry
:
Ferry
<
S
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
error
:
:
Result
<
FerryTask
<
N
S
>
>
{
let
name
=
ferry
.
name
(
)
;
Ok
(
FerryTask
{
engine
:
Arc
:
:
clone
(
engine
)
ferry
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
name
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
Error
>
{
let
runnable
=
TaskRunnable
:
:
new
(
self
.
ferry
.
name
(
)
Box
:
:
new
(
self
)
)
?
;
runnable
.
dispatch_with_options
(
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
}
impl
<
N
S
>
Task
for
FerryTask
<
N
S
>
where
N
:
?
Sized
+
BridgedEngine
S
:
Interruptee
N
:
:
Error
:
BridgedError
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
match
&
self
.
ferry
{
Ferry
:
:
Initialize
=
>
self
.
engine
.
initialize
(
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
LastSync
=
>
self
.
engine
.
last_sync
(
)
.
map
(
FerryResult
:
:
LastSync
)
Ferry
:
:
SetLastSync
(
last_sync_millis
)
=
>
self
.
engine
.
set_last_sync
(
*
last_sync_millis
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
SyncId
=
>
self
.
engine
.
sync_id
(
)
.
map
(
FerryResult
:
:
SyncId
)
Ferry
:
:
ResetSyncId
=
>
self
.
engine
.
reset_sync_id
(
)
.
map
(
FerryResult
:
:
AssignedSyncId
)
Ferry
:
:
EnsureCurrentSyncId
(
new_sync_id
)
=
>
self
.
engine
.
ensure_current_sync_id
(
&
*
new_sync_id
)
.
map
(
FerryResult
:
:
AssignedSyncId
)
Ferry
:
:
StoreIncoming
(
incoming_cleartexts
signal
)
=
>
self
.
engine
.
store_incoming
(
incoming_cleartexts
.
as_slice
(
)
signal
.
as_ref
(
)
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
signal
)
=
>
self
.
engine
.
set_uploaded
(
*
server_modified_millis
uploaded_ids
.
as_slice
(
)
signal
.
as_ref
(
)
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
SyncFinished
(
signal
)
=
>
self
.
engine
.
sync_finished
(
signal
.
as_ref
(
)
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
Reset
=
>
self
.
engine
.
reset
(
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
Wipe
=
>
self
.
engine
.
wipe
(
)
.
map
(
FerryResult
:
:
from
)
Ferry
:
:
Finalize
=
>
self
.
engine
.
finalize
(
)
.
map
(
FerryResult
:
:
from
)
}
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
self
.
ferry
.
name
(
)
)
.
into
(
)
)
)
{
Ok
(
result
)
=
>
unsafe
{
callback
.
HandleSuccess
(
result
.
into_variant
(
)
.
coerce
(
)
)
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
pub
struct
ApplyTask
<
N
:
?
Sized
+
BridgedEngine
S
>
{
engine
:
Arc
<
N
>
signal
:
Arc
<
S
>
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineApplyCallback
>
result
:
AtomicRefCell
<
Result
<
Vec
<
String
>
N
:
:
Error
>
>
}
impl
<
N
S
>
ApplyTask
<
N
S
>
where
N
:
?
Sized
+
BridgedEngine
{
pub
fn
name
(
)
-
>
&
'
static
str
{
concat
!
(
module_path
!
(
)
"
apply
"
)
}
}
impl
<
N
S
>
ApplyTask
<
N
S
>
where
N
:
?
Sized
+
BridgedEngine
+
Send
+
Sync
+
'
static
S
:
Interruptee
+
Send
+
Sync
+
'
static
N
:
:
Error
:
BridgedError
{
pub
fn
new
(
engine
:
&
Arc
<
N
>
signal
:
&
Arc
<
S
>
callback
:
&
mozIBridgedSyncEngineApplyCallback
)
-
>
error
:
:
Result
<
ApplyTask
<
N
S
>
>
{
Ok
(
ApplyTask
{
engine
:
Arc
:
:
clone
(
engine
)
signal
:
Arc
:
:
clone
(
signal
)
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineApplyCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
Error
>
{
let
runnable
=
TaskRunnable
:
:
new
(
Self
:
:
name
(
)
Box
:
:
new
(
self
)
)
?
;
runnable
.
dispatch_with_options
(
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
}
impl
<
N
S
>
Task
for
ApplyTask
<
N
S
>
where
N
:
?
Sized
+
BridgedEngine
S
:
Interruptee
N
:
:
Error
:
BridgedError
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
self
.
engine
.
apply
(
self
.
signal
.
as_ref
(
)
)
;
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
{
Ok
(
outgoing
)
=
>
{
let
result
=
outgoing
.
into_iter
(
)
.
map
(
nsCString
:
:
from
)
.
collect
:
:
<
ThinVec
<
_
>
>
(
)
;
unsafe
{
callback
.
HandleSuccess
(
&
result
)
}
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
}
"
err
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
err
.
into
(
)
&
*
message
)
}
}
}
.
to_result
(
)
}
}
