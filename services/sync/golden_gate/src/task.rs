use
std
:
:
{
fmt
:
:
Write
mem
result
}
;
use
atomic_refcell
:
:
AtomicRefCell
;
use
moz_task
:
:
{
DispatchOptions
Task
TaskRunnable
ThreadPtrHandle
ThreadPtrHolder
}
;
use
nserror
:
:
{
nsresult
NS_ERROR_FAILURE
}
;
use
nsstring
:
:
{
nsACString
nsCString
}
;
use
sync15
:
:
engine
:
:
{
ApplyResults
BridgedEngine
}
;
use
sync15
:
:
Guid
;
use
thin_vec
:
:
ThinVec
;
use
xpcom
:
:
{
interfaces
:
:
{
mozIBridgedSyncEngineApplyCallback
mozIBridgedSyncEngineCallback
nsIEventTarget
}
RefPtr
}
;
use
crate
:
:
error
:
:
{
Error
Result
}
;
use
crate
:
:
ferry
:
:
{
Ferry
FerryResult
}
;
pub
struct
FerryTask
{
engine
:
Box
<
dyn
BridgedEngine
>
ferry
:
Ferry
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineCallback
>
result
:
AtomicRefCell
<
anyhow
:
:
Result
<
FerryResult
>
>
}
impl
FerryTask
{
#
[
inline
]
pub
fn
for_last_sync
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
LastSync
callback
)
}
#
[
inline
]
pub
fn
for_set_last_sync
(
engine
:
Box
<
dyn
BridgedEngine
>
last_sync_millis
:
i64
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetLastSync
(
last_sync_millis
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_id
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncId
callback
)
}
#
[
inline
]
pub
fn
for_reset_sync_id
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
ResetSyncId
callback
)
}
#
[
inline
]
pub
fn
for_ensure_current_sync_id
(
engine
:
Box
<
dyn
BridgedEngine
>
new_sync_id
:
&
nsACString
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
EnsureCurrentSyncId
(
std
:
:
str
:
:
from_utf8
(
new_sync_id
)
?
.
into
(
)
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_started
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncStarted
callback
)
}
pub
fn
for_store_incoming
(
engine
:
Box
<
dyn
BridgedEngine
>
incoming_envelopes_json
:
&
[
nsCString
]
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
StoreIncoming
(
incoming_envelopes_json
.
to_vec
(
)
)
callback
)
}
pub
fn
for_set_uploaded
(
engine
:
Box
<
dyn
BridgedEngine
>
server_modified_millis
:
i64
uploaded_ids
:
&
[
nsCString
]
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
let
uploaded_ids
=
uploaded_ids
.
iter
(
)
.
map
(
|
id
|
Guid
:
:
from_slice
(
id
)
)
.
collect
(
)
;
Self
:
:
with_ferry
(
engine
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
)
callback
)
}
#
[
inline
]
pub
fn
for_sync_finished
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
SyncFinished
callback
)
}
#
[
inline
]
pub
fn
for_reset
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Reset
callback
)
}
#
[
inline
]
pub
fn
for_wipe
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
Self
:
:
with_ferry
(
engine
Ferry
:
:
Wipe
callback
)
}
fn
with_ferry
(
engine
:
Box
<
dyn
BridgedEngine
>
ferry
:
Ferry
callback
:
&
mozIBridgedSyncEngineCallback
)
-
>
Result
<
FerryTask
>
{
let
name
=
ferry
.
name
(
)
;
Ok
(
FerryTask
{
engine
ferry
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
name
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
>
{
let
runnable
=
TaskRunnable
:
:
new
(
self
.
ferry
.
name
(
)
Box
:
:
new
(
self
)
)
?
;
TaskRunnable
:
:
dispatch_with_options
(
runnable
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
fn
inner_run
(
&
self
)
-
>
anyhow
:
:
Result
<
FerryResult
>
{
let
engine
=
&
self
.
engine
;
Ok
(
match
&
self
.
ferry
{
Ferry
:
:
LastSync
=
>
FerryResult
:
:
LastSync
(
engine
.
last_sync
(
)
?
)
Ferry
:
:
SetLastSync
(
last_sync_millis
)
=
>
{
engine
.
set_last_sync
(
*
last_sync_millis
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SyncId
=
>
FerryResult
:
:
SyncId
(
engine
.
sync_id
(
)
?
)
Ferry
:
:
ResetSyncId
=
>
FerryResult
:
:
AssignedSyncId
(
engine
.
reset_sync_id
(
)
?
)
Ferry
:
:
EnsureCurrentSyncId
(
new_sync_id
)
=
>
{
FerryResult
:
:
AssignedSyncId
(
engine
.
ensure_current_sync_id
(
new_sync_id
)
?
)
}
Ferry
:
:
SyncStarted
=
>
{
engine
.
sync_started
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
StoreIncoming
(
incoming_envelopes_json
)
=
>
{
let
incoming_envelopes
=
incoming_envelopes_json
.
iter
(
)
.
map
(
|
envelope
|
Ok
(
serde_json
:
:
from_slice
(
envelope
)
?
)
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
engine
.
store_incoming
(
incoming_envelopes
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SetUploaded
(
server_modified_millis
uploaded_ids
)
=
>
{
engine
.
set_uploaded
(
*
server_modified_millis
uploaded_ids
.
as_slice
(
)
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
SyncFinished
=
>
{
engine
.
sync_finished
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
Reset
=
>
{
engine
.
reset
(
)
?
;
FerryResult
:
:
default
(
)
}
Ferry
:
:
Wipe
=
>
{
engine
.
wipe
(
)
?
;
FerryResult
:
:
default
(
)
}
}
)
}
}
impl
Task
for
FerryTask
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
self
.
inner_run
(
)
;
}
fn
done
(
&
self
)
-
>
result
:
:
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
self
.
ferry
.
name
(
)
)
.
into
(
)
)
)
{
Ok
(
result
)
=
>
unsafe
{
callback
.
HandleSuccess
(
result
.
into_variant
(
)
.
coerce
(
)
)
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
err
}
"
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
NS_ERROR_FAILURE
&
*
message
)
}
}
}
.
to_result
(
)
}
}
pub
struct
ApplyTask
{
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
ThreadPtrHandle
<
mozIBridgedSyncEngineApplyCallback
>
result
:
AtomicRefCell
<
anyhow
:
:
Result
<
Vec
<
String
>
>
>
}
impl
ApplyTask
{
pub
fn
name
(
)
-
>
&
'
static
str
{
concat
!
(
module_path
!
(
)
"
apply
"
)
}
fn
inner_run
(
&
self
)
-
>
anyhow
:
:
Result
<
Vec
<
String
>
>
{
let
ApplyResults
{
records
:
outgoing_records
.
.
}
=
self
.
engine
.
apply
(
)
?
;
let
outgoing_records_json
=
outgoing_records
.
iter
(
)
.
map
(
|
record
|
Ok
(
serde_json
:
:
to_string
(
record
)
?
)
)
.
collect
:
:
<
Result
<
_
>
>
(
)
?
;
Ok
(
outgoing_records_json
)
}
pub
fn
new
(
engine
:
Box
<
dyn
BridgedEngine
>
callback
:
&
mozIBridgedSyncEngineApplyCallback
)
-
>
Result
<
ApplyTask
>
{
Ok
(
ApplyTask
{
engine
callback
:
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIBridgedSyncEngineApplyCallback
"
)
RefPtr
:
:
new
(
callback
)
)
?
result
:
AtomicRefCell
:
:
new
(
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
}
)
}
pub
fn
dispatch
(
self
target
:
&
nsIEventTarget
)
-
>
Result
<
(
)
>
{
let
runnable
=
TaskRunnable
:
:
new
(
Self
:
:
name
(
)
Box
:
:
new
(
self
)
)
?
;
TaskRunnable
:
:
dispatch_with_options
(
runnable
target
DispatchOptions
:
:
default
(
)
.
may_block
(
true
)
)
?
;
Ok
(
(
)
)
}
}
impl
Task
for
ApplyTask
{
fn
run
(
&
self
)
{
*
self
.
result
.
borrow_mut
(
)
=
self
.
inner_run
(
)
;
}
fn
done
(
&
self
)
-
>
result
:
:
Result
<
(
)
nsresult
>
{
let
callback
=
self
.
callback
.
get
(
)
.
unwrap
(
)
;
match
mem
:
:
replace
(
&
mut
*
self
.
result
.
borrow_mut
(
)
Err
(
Error
:
:
DidNotRun
(
Self
:
:
name
(
)
)
.
into
(
)
)
)
{
Ok
(
envelopes
)
=
>
{
let
result
=
envelopes
.
into_iter
(
)
.
map
(
nsCString
:
:
from
)
.
collect
:
:
<
ThinVec
<
_
>
>
(
)
;
unsafe
{
callback
.
HandleSuccess
(
&
result
)
}
}
Err
(
err
)
=
>
{
let
mut
message
=
nsCString
:
:
new
(
)
;
write
!
(
message
"
{
err
}
"
)
.
unwrap
(
)
;
unsafe
{
callback
.
HandleError
(
NS_ERROR_FAILURE
&
*
message
)
}
}
}
.
to_result
(
)
}
}
