use
std
:
:
fmt
:
:
{
self
Write
}
;
use
log
:
:
{
Level
LevelFilter
Log
Metadata
Record
}
;
use
moz_task
:
:
{
Task
TaskRunnable
ThreadPtrHandle
ThreadPtrHolder
}
;
use
nserror
:
:
nsresult
;
use
nsstring
:
:
nsString
;
use
xpcom
:
:
{
interfaces
:
:
mozIServicesLogSink
RefPtr
}
;
pub
struct
LogSink
{
pub
max_level
:
LevelFilter
logger
:
Option
<
ThreadPtrHandle
<
mozIServicesLogSink
>
>
}
impl
Default
for
LogSink
{
fn
default
(
)
-
>
Self
{
LogSink
{
max_level
:
LevelFilter
:
:
Off
logger
:
None
}
}
}
impl
LogSink
{
#
[
inline
]
pub
fn
new
(
max_level
:
LevelFilter
logger
:
ThreadPtrHandle
<
mozIServicesLogSink
>
)
-
>
LogSink
{
LogSink
{
max_level
logger
:
Some
(
logger
)
}
}
pub
fn
with_logger
(
logger
:
Option
<
&
mozIServicesLogSink
>
)
-
>
Result
<
LogSink
nsresult
>
{
Ok
(
if
let
Some
(
logger
)
=
logger
{
let
mut
raw_max_level
=
0i16
;
let
rv
=
unsafe
{
logger
.
GetMaxLevel
(
&
mut
raw_max_level
)
}
;
let
max_level
=
if
rv
.
succeeded
(
)
{
match
raw_max_level
as
i64
{
mozIServicesLogSink
:
:
LEVEL_ERROR
=
>
LevelFilter
:
:
Error
mozIServicesLogSink
:
:
LEVEL_WARN
=
>
LevelFilter
:
:
Warn
mozIServicesLogSink
:
:
LEVEL_DEBUG
=
>
LevelFilter
:
:
Debug
mozIServicesLogSink
:
:
LEVEL_TRACE
=
>
LevelFilter
:
:
Trace
mozIServicesLogSink
:
:
LEVEL_INFO
=
>
LevelFilter
:
:
Info
_
=
>
LevelFilter
:
:
Off
}
}
else
{
LevelFilter
:
:
Off
}
;
LogSink
:
:
new
(
max_level
ThreadPtrHolder
:
:
new
(
cstr
!
(
"
mozIServicesLogSink
"
)
RefPtr
:
:
new
(
logger
)
)
?
)
}
else
{
LogSink
:
:
default
(
)
}
)
}
pub
fn
logger
(
&
self
)
-
>
Option
<
&
mozIServicesLogSink
>
{
self
.
logger
.
as_ref
(
)
.
and_then
(
|
l
|
l
.
get
(
)
)
}
pub
fn
debug
(
&
self
args
:
fmt
:
:
Arguments
)
{
let
meta
=
Metadata
:
:
builder
(
)
.
level
(
Level
:
:
Debug
)
.
target
(
module_path
!
(
)
)
.
build
(
)
;
if
self
.
enabled
(
&
meta
)
{
self
.
log
(
&
Record
:
:
builder
(
)
.
args
(
args
)
.
metadata
(
meta
)
.
build
(
)
)
;
}
}
}
impl
Log
for
LogSink
{
#
[
inline
]
fn
enabled
(
&
self
meta
:
&
Metadata
)
-
>
bool
{
self
.
logger
.
is_some
(
)
&
&
meta
.
level
(
)
<
=
self
.
max_level
}
fn
log
(
&
self
record
:
&
Record
)
{
if
!
self
.
enabled
(
record
.
metadata
(
)
)
{
return
;
}
if
let
Some
(
logger
)
=
&
self
.
logger
{
let
mut
message
=
nsString
:
:
new
(
)
;
match
write
!
(
message
"
{
}
"
record
.
args
(
)
)
{
Ok
(
_
)
=
>
{
let
task
=
LogTask
{
logger
:
logger
.
clone
(
)
level
:
record
.
metadata
(
)
.
level
(
)
message
}
;
let
_
=
TaskRunnable
:
:
new
(
"
extension_storage_sync
:
:
Logger
:
:
log
"
Box
:
:
new
(
task
)
)
.
and_then
(
|
r
|
TaskRunnable
:
:
dispatch
(
r
logger
.
owning_thread
(
)
)
)
;
}
Err
(
_
)
=
>
{
}
}
}
}
fn
flush
(
&
self
)
{
}
}
struct
LogTask
{
logger
:
ThreadPtrHandle
<
mozIServicesLogSink
>
level
:
Level
message
:
nsString
}
impl
Task
for
LogTask
{
fn
run
(
&
self
)
{
let
logger
=
self
.
logger
.
get
(
)
.
unwrap
(
)
;
match
self
.
level
{
Level
:
:
Error
=
>
unsafe
{
logger
.
Error
(
&
*
self
.
message
)
;
}
Level
:
:
Warn
=
>
unsafe
{
logger
.
Warn
(
&
*
self
.
message
)
;
}
Level
:
:
Debug
=
>
unsafe
{
logger
.
Debug
(
&
*
self
.
message
)
;
}
Level
:
:
Trace
=
>
unsafe
{
logger
.
Trace
(
&
*
self
.
message
)
;
}
Level
:
:
Info
=
>
unsafe
{
logger
.
Info
(
&
*
self
.
message
)
;
}
}
}
fn
done
(
&
self
)
-
>
Result
<
(
)
nsresult
>
{
Ok
(
(
)
)
}
}
