"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
encryptPayload
"
"
makeIdentityConfig
"
"
makeFxAccountsInternalMock
"
"
configureFxAccountIdentity
"
"
configureIdentity
"
"
SyncTestingInfrastructure
"
"
waitForZeroTimer
"
"
promiseZeroTimer
"
"
promiseNamedTimer
"
"
MockFxaStorageManager
"
"
AccountState
"
"
sumHistogram
"
"
getLoginTelemetryScalar
"
"
syncTestLogging
"
]
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
CryptoUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
initTestLogging
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
common
/
logging
.
js
"
)
;
const
{
FakeCryptoService
FakeFilesystemService
FakeGUIDService
fakeSHA256HMAC
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
services
/
sync
/
fakeservices
.
js
"
)
;
const
{
FxAccounts
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
const
{
FxAccountsClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsClient
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AccountState
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
null
)
;
function
MockFxaStorageManager
(
)
{
}
MockFxaStorageManager
.
prototype
=
{
promiseInitialized
:
Promise
.
resolve
(
)
initialize
(
accountData
)
{
this
.
accountData
=
accountData
;
}
finalize
(
)
{
return
Promise
.
resolve
(
)
;
}
getAccountData
(
)
{
return
Promise
.
resolve
(
this
.
accountData
)
;
}
updateAccountData
(
updatedFields
)
{
for
(
let
[
name
value
]
of
Object
.
entries
(
updatedFields
)
)
{
if
(
value
=
=
null
)
{
delete
this
.
accountData
[
name
]
;
}
else
{
this
.
accountData
[
name
]
=
value
;
}
}
return
Promise
.
resolve
(
)
;
}
deleteAccountData
(
)
{
this
.
accountData
=
null
;
return
Promise
.
resolve
(
)
;
}
}
;
function
waitForZeroTimer
(
callback
)
{
let
ticks
=
2
;
function
wait
(
)
{
if
(
ticks
)
{
ticks
-
=
1
;
CommonUtils
.
nextTick
(
wait
)
;
return
;
}
callback
(
)
;
}
CommonUtils
.
namedTimer
(
wait
150
{
}
"
timer
"
)
;
}
var
promiseZeroTimer
=
function
(
)
{
return
new
Promise
(
resolve
=
>
{
waitForZeroTimer
(
resolve
)
;
}
)
;
}
;
var
promiseNamedTimer
=
function
(
wait
thisObj
name
)
{
return
new
Promise
(
resolve
=
>
{
CommonUtils
.
namedTimer
(
resolve
wait
thisObj
name
)
;
}
)
;
}
;
var
makeIdentityConfig
=
function
(
overrides
)
{
let
result
=
{
username
:
"
foo
"
fxaccount
:
{
user
:
{
assertion
:
"
assertion
"
email
:
"
foo
"
kSync
:
"
a
"
.
repeat
(
128
)
kXCS
:
"
a
"
.
repeat
(
32
)
kExtSync
:
"
a
"
.
repeat
(
128
)
kExtKbHash
:
"
a
"
.
repeat
(
32
)
sessionToken
:
"
sessionToken
"
uid
:
"
a
"
.
repeat
(
32
)
verified
:
true
}
token
:
{
endpoint
:
null
duration
:
300
id
:
"
id
"
key
:
"
key
"
hashed_fxa_uid
:
"
f
"
.
repeat
(
32
)
}
}
}
;
if
(
overrides
)
{
if
(
overrides
.
username
)
{
result
.
username
=
overrides
.
username
;
}
if
(
overrides
.
fxaccount
)
{
result
.
fxaccount
=
overrides
.
fxaccount
;
}
}
return
result
;
}
;
var
makeFxAccountsInternalMock
=
function
(
config
)
{
return
{
newAccountState
(
credentials
)
{
if
(
credentials
)
{
throw
new
Error
(
"
Not
expecting
to
have
credentials
passed
"
)
;
}
let
storageManager
=
new
MockFxaStorageManager
(
)
;
storageManager
.
initialize
(
config
.
fxaccount
.
user
)
;
let
accountState
=
new
AccountState
(
storageManager
)
;
return
accountState
;
}
_getAssertion
(
audience
)
{
return
Promise
.
resolve
(
config
.
fxaccount
.
user
.
assertion
)
;
}
}
;
}
;
var
configureFxAccountIdentity
=
function
(
authService
config
=
makeIdentityConfig
(
)
fxaInternal
=
makeFxAccountsInternalMock
(
config
)
)
{
config
.
fxaccount
.
user
.
email
=
config
.
username
;
let
fxa
=
new
FxAccounts
(
fxaInternal
)
;
let
MockFxAccountsClient
=
function
(
)
{
FxAccountsClient
.
apply
(
this
)
;
}
;
MockFxAccountsClient
.
prototype
=
{
__proto__
:
FxAccountsClient
.
prototype
accountStatus
(
)
{
return
Promise
.
resolve
(
true
)
;
}
}
;
let
mockFxAClient
=
new
MockFxAccountsClient
(
)
;
fxa
.
internal
.
_fxAccountsClient
=
mockFxAClient
;
let
mockTSC
=
{
async
getTokenFromBrowserIDAssertion
(
uri
assertion
)
{
Assert
.
equal
(
uri
Services
.
prefs
.
getStringPref
(
"
identity
.
sync
.
tokenserver
.
uri
"
)
)
;
Assert
.
equal
(
assertion
config
.
fxaccount
.
user
.
assertion
)
;
config
.
fxaccount
.
token
.
uid
=
config
.
username
;
return
config
.
fxaccount
.
token
;
}
}
;
authService
.
_fxaService
=
fxa
;
authService
.
_tokenServerClient
=
mockTSC
;
authService
.
_signedInUser
=
config
.
fxaccount
.
user
;
authService
.
_account
=
config
.
fxaccount
.
user
.
email
;
}
;
var
configureIdentity
=
async
function
(
identityOverrides
server
)
{
let
config
=
makeIdentityConfig
(
identityOverrides
server
)
;
let
ns
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
ns
)
;
if
(
server
&
&
!
config
.
fxaccount
.
token
.
endpoint
)
{
let
ep
=
server
.
baseURI
;
if
(
!
ep
.
endsWith
(
"
/
"
)
)
{
ep
+
=
"
/
"
;
}
ep
+
=
"
1
.
1
/
"
+
config
.
username
+
"
/
"
;
config
.
fxaccount
.
token
.
endpoint
=
ep
;
}
configureFxAccountIdentity
(
ns
.
Service
.
identity
config
)
;
ns
.
Service
.
identity
.
username
=
config
.
username
;
await
ns
.
Service
.
identity
.
_ensureValidToken
(
)
;
if
(
config
.
fxaccount
.
token
.
endpoint
)
{
ns
.
Service
.
clusterURL
=
config
.
fxaccount
.
token
.
endpoint
;
}
}
;
function
syncTestLogging
(
level
=
"
Trace
"
)
{
let
logStats
=
initTestLogging
(
level
)
;
Services
.
prefs
.
setStringPref
(
"
services
.
sync
.
log
.
logger
"
level
)
;
Services
.
prefs
.
setStringPref
(
"
services
.
sync
.
log
.
logger
.
engine
"
"
"
)
;
return
logStats
;
}
var
SyncTestingInfrastructure
=
async
function
(
server
username
)
{
let
ns
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
ns
)
;
let
config
=
makeIdentityConfig
(
{
username
}
)
;
await
configureIdentity
(
config
server
)
;
return
{
logStats
:
syncTestLogging
(
)
fakeFilesystem
:
new
FakeFilesystemService
(
{
}
)
fakeGUIDService
:
new
FakeGUIDService
(
)
fakeCryptoService
:
new
FakeCryptoService
(
)
}
;
}
;
function
encryptPayload
(
cleartext
)
{
if
(
typeof
cleartext
=
=
"
object
"
)
{
cleartext
=
JSON
.
stringify
(
cleartext
)
;
}
return
{
ciphertext
:
cleartext
IV
:
"
irrelevant
"
hmac
:
fakeSHA256HMAC
(
cleartext
CryptoUtils
.
makeHMACKey
(
"
"
)
)
}
;
}
var
sumHistogram
=
function
(
name
options
=
{
}
)
{
let
histogram
=
options
.
key
?
Services
.
telemetry
.
getKeyedHistogramById
(
name
)
:
Services
.
telemetry
.
getHistogramById
(
name
)
;
let
snapshot
=
histogram
.
snapshot
(
)
;
let
sum
=
-
Infinity
;
if
(
snapshot
)
{
if
(
options
.
key
&
&
snapshot
[
options
.
key
]
)
{
sum
=
snapshot
[
options
.
key
]
.
sum
;
}
else
{
sum
=
snapshot
.
sum
;
}
}
histogram
.
clear
(
)
;
return
sum
;
}
;
var
getLoginTelemetryScalar
=
function
(
)
{
let
snapshot
=
Services
.
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
true
)
;
return
snapshot
.
parent
?
snapshot
.
parent
[
"
services
.
sync
.
sync_login_state_transitions
"
]
:
{
}
;
}
;
