var
EXPORTED_SYMBOLS
=
[
"
PlacesItem
"
"
Bookmark
"
"
Separator
"
"
BookmarkFolder
"
"
DumpBookmarks
"
]
;
const
{
PlacesBackups
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
)
;
const
{
PlacesSyncUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
const
{
PlacesUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
const
{
Logger
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
tps
/
logger
.
jsm
"
)
;
async
function
DumpBookmarks
(
)
{
let
[
bookmarks
]
=
await
PlacesBackups
.
getBookmarksTree
(
)
;
Logger
.
logInfo
(
"
Dumping
Bookmarks
.
.
.
\
n
"
+
JSON
.
stringify
(
bookmarks
undefined
2
)
+
"
\
n
\
n
"
)
;
}
function
extend
(
child
supertype
)
{
child
.
prototype
.
__proto__
=
supertype
.
prototype
;
}
function
PlacesItemProps
(
props
)
{
this
.
location
=
null
;
this
.
uri
=
null
;
this
.
keyword
=
null
;
this
.
title
=
null
;
this
.
after
=
null
;
this
.
before
=
null
;
this
.
folder
=
null
;
this
.
position
=
null
;
this
.
delete
=
false
;
this
.
tags
=
null
;
this
.
last_item_pos
=
null
;
this
.
type
=
null
;
for
(
var
prop
in
props
)
{
if
(
prop
in
this
)
{
this
[
prop
]
=
props
[
prop
]
;
}
}
}
function
PlacesItem
(
props
)
{
this
.
props
=
new
PlacesItemProps
(
props
)
;
if
(
this
.
props
.
location
=
=
null
)
{
this
.
props
.
location
=
"
menu
"
;
}
if
(
"
changes
"
in
props
)
{
this
.
updateProps
=
new
PlacesItemProps
(
props
.
changes
)
;
}
else
{
this
.
updateProps
=
null
;
}
}
PlacesItem
.
prototype
=
{
_bookmarkFolders
:
{
places
:
PlacesUtils
.
bookmarks
.
rootGuid
menu
:
PlacesUtils
.
bookmarks
.
menuGuid
tags
:
PlacesUtils
.
bookmarks
.
tagsGuid
unfiled
:
PlacesUtils
.
bookmarks
.
unfiledGuid
toolbar
:
PlacesUtils
.
bookmarks
.
toolbarGuid
mobile
:
PlacesUtils
.
bookmarks
.
mobileGuid
}
_typeMap
:
new
Map
(
[
[
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
]
[
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
]
[
PlacesUtils
.
TYPE_X_MOZ_PLACE
PlacesUtils
.
bookmarks
.
TYPE_BOOKMARK
]
]
)
toString
(
)
{
var
that
=
this
;
var
props
=
[
"
uri
"
"
title
"
"
location
"
"
folder
"
]
;
var
string
=
(
this
.
props
.
type
?
this
.
props
.
type
+
"
"
:
"
"
)
+
"
(
"
+
(
function
(
)
{
var
ret
=
[
]
;
for
(
var
i
in
props
)
{
if
(
that
.
props
[
props
[
i
]
]
)
{
ret
.
push
(
props
[
i
]
+
"
:
"
+
that
.
props
[
props
[
i
]
]
)
;
}
}
return
ret
;
}
)
(
)
.
join
(
"
"
)
+
"
)
"
;
return
string
;
}
async
GetPlacesChildGuid
(
folder
type
title
uri
)
{
let
children
=
(
await
PlacesUtils
.
promiseBookmarksTree
(
folder
)
)
.
children
;
if
(
!
children
)
{
return
null
;
}
let
guid
=
null
;
for
(
let
node
of
children
)
{
if
(
node
.
title
=
=
title
)
{
let
nodeType
=
this
.
_typeMap
.
get
(
node
.
type
)
;
if
(
type
=
=
null
|
|
type
=
=
undefined
|
|
nodeType
=
=
type
)
{
if
(
uri
=
=
undefined
|
|
uri
=
=
null
|
|
node
.
uri
.
spec
=
=
uri
.
spec
)
{
guid
=
node
.
guid
;
}
}
}
}
return
guid
;
}
async
IsAdjacentTo
(
itemName
relativePos
)
{
Logger
.
AssertTrue
(
this
.
props
.
folder_id
!
=
-
1
&
&
this
.
props
.
guid
!
=
null
"
Either
folder_id
or
guid
was
invalid
"
)
;
let
otherGuid
=
await
this
.
GetPlacesChildGuid
(
this
.
props
.
parentGuid
null
itemName
)
;
Logger
.
AssertTrue
(
otherGuid
"
item
"
+
itemName
+
"
not
found
"
)
;
let
other_pos
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
otherGuid
)
)
.
index
;
let
this_pos
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
props
.
guid
)
)
.
index
;
if
(
other_pos
+
relativePos
!
=
this_pos
)
{
Logger
.
logPotentialError
(
"
Invalid
position
-
"
+
(
this
.
props
.
title
?
this
.
props
.
title
:
this
.
props
.
folder
)
+
"
not
"
+
(
relativePos
=
=
1
?
"
after
"
:
"
before
"
)
+
itemName
+
"
for
"
+
this
.
toString
(
)
)
;
return
false
;
}
return
true
;
}
async
GetItemIndex
(
)
{
if
(
this
.
props
.
guid
=
=
null
)
{
return
-
1
;
}
return
(
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
props
.
guid
)
)
.
index
;
}
async
GetFolder
(
location
)
{
let
folder_parts
=
location
.
split
(
"
/
"
)
;
if
(
!
(
folder_parts
[
0
]
in
this
.
_bookmarkFolders
)
)
{
return
null
;
}
let
folderGuid
=
this
.
_bookmarkFolders
[
folder_parts
[
0
]
]
;
for
(
let
i
=
1
;
i
<
folder_parts
.
length
;
i
+
+
)
{
let
guid
=
await
this
.
GetPlacesChildGuid
(
folderGuid
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
folder_parts
[
i
]
)
;
if
(
guid
=
=
null
)
{
return
null
;
}
folderGuid
=
guid
;
}
return
folderGuid
;
}
async
CreateFolder
(
location
)
{
let
folder_parts
=
location
.
split
(
"
/
"
)
;
if
(
!
(
folder_parts
[
0
]
in
this
.
_bookmarkFolders
)
)
{
return
-
1
;
}
let
folderGuid
=
this
.
_bookmarkFolders
[
folder_parts
[
0
]
]
;
for
(
let
i
=
1
;
i
<
folder_parts
.
length
;
i
+
+
)
{
let
subfolderGuid
=
await
this
.
GetPlacesChildGuid
(
folderGuid
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
folder_parts
[
i
]
)
;
if
(
subfolderGuid
=
=
null
)
{
let
{
guid
}
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
folderGuid
name
:
folder_parts
[
i
]
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
folderGuid
=
guid
;
}
else
{
folderGuid
=
subfolderGuid
;
}
}
return
folderGuid
;
}
async
GetOrCreateFolder
(
location
)
{
let
parentGuid
=
await
this
.
GetFolder
(
location
)
;
if
(
parentGuid
=
=
null
)
{
parentGuid
=
await
this
.
CreateFolder
(
location
)
;
}
return
parentGuid
;
}
async
CheckPosition
(
before
after
last_item_pos
)
{
if
(
after
)
{
if
(
!
(
await
this
.
IsAdjacentTo
(
after
1
)
)
)
{
return
false
;
}
}
if
(
before
)
{
if
(
!
(
await
this
.
IsAdjacentTo
(
before
-
1
)
)
)
{
return
false
;
}
}
if
(
last_item_pos
!
=
null
&
&
last_item_pos
>
-
1
)
{
let
index
=
await
this
.
GetItemIndex
(
)
;
if
(
index
!
=
last_item_pos
+
1
)
{
Logger
.
logPotentialError
(
"
Item
not
found
at
the
expected
index
got
"
+
index
+
"
expected
"
+
(
last_item_pos
+
1
)
+
"
for
"
+
this
.
toString
(
)
)
;
return
false
;
}
}
return
true
;
}
async
SetLocation
(
location
)
{
if
(
location
!
=
null
)
{
let
newfolderGuid
=
await
this
.
GetOrCreateFolder
(
location
)
;
Logger
.
AssertTrue
(
newfolderGuid
"
Location
"
+
location
+
"
doesn
'
t
exist
;
can
'
t
change
item
'
s
location
"
)
;
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
this
.
props
.
guid
parentGuid
:
newfolderGuid
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
}
)
;
this
.
props
.
parentGuid
=
newfolderGuid
;
}
}
async
SetPosition
(
position
)
{
if
(
position
=
=
null
)
{
return
;
}
let
index
=
-
1
;
if
(
position
!
=
-
1
)
{
let
existingGuid
=
await
this
.
GetPlacesChildGuid
(
this
.
props
.
parentGuid
null
position
)
;
if
(
existingGuid
)
{
index
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
existingGuid
)
)
.
index
;
}
Logger
.
AssertTrue
(
index
!
=
-
1
"
position
"
+
position
+
"
is
invalid
;
unable
to
change
position
"
)
;
}
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
this
.
props
.
guid
index
}
)
;
}
async
SetTitle
(
title
)
{
if
(
title
!
=
null
)
{
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
this
.
props
.
guid
title
}
)
;
}
}
}
;
function
Bookmark
(
props
)
{
PlacesItem
.
call
(
this
props
)
;
if
(
this
.
props
.
title
=
=
null
)
{
this
.
props
.
title
=
this
.
props
.
uri
;
}
this
.
props
.
type
=
"
bookmark
"
;
}
Bookmark
.
prototype
=
{
async
SetKeyword
(
keyword
)
{
if
(
keyword
!
=
null
)
{
let
entry
=
await
PlacesUtils
.
keywords
.
fetch
(
{
url
:
this
.
props
.
uri
}
)
;
if
(
entry
)
{
await
PlacesUtils
.
keywords
.
remove
(
entry
)
;
}
await
PlacesUtils
.
keywords
.
insert
(
{
keyword
url
:
this
.
props
.
uri
}
)
;
}
}
async
SetUri
(
uri
)
{
if
(
uri
)
{
let
url
=
Services
.
io
.
newURI
(
uri
)
;
await
PlacesUtils
.
bookmarks
.
update
(
{
guid
:
this
.
props
.
guid
url
}
)
;
}
}
SetTags
(
tags
)
{
if
(
tags
!
=
null
)
{
let
URI
=
Services
.
io
.
newURI
(
this
.
props
.
uri
)
;
PlacesUtils
.
tagging
.
untagURI
(
URI
null
)
;
if
(
tags
.
length
>
0
)
{
PlacesUtils
.
tagging
.
tagURI
(
URI
tags
)
;
}
}
}
async
Create
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetOrCreateFolder
(
this
.
props
.
location
)
;
Logger
.
AssertTrue
(
this
.
props
.
parentGuid
"
Unable
to
create
"
+
"
bookmark
error
creating
folder
"
+
this
.
props
.
location
)
;
let
bookmarkURI
=
Services
.
io
.
newURI
(
this
.
props
.
uri
)
;
let
{
guid
}
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
this
.
props
.
parentGuid
url
:
bookmarkURI
title
:
this
.
props
.
title
}
)
;
this
.
props
.
guid
=
guid
;
await
this
.
SetKeyword
(
this
.
props
.
keyword
)
;
await
this
.
SetTags
(
this
.
props
.
tags
)
;
return
this
.
props
.
guid
;
}
async
Update
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Update
"
)
;
await
this
.
SetTitle
(
this
.
updateProps
.
title
)
;
await
this
.
SetUri
(
this
.
updateProps
.
uri
)
;
await
this
.
SetKeyword
(
this
.
updateProps
.
keyword
)
;
await
this
.
SetTags
(
this
.
updateProps
.
tags
)
;
await
this
.
SetLocation
(
this
.
updateProps
.
location
)
;
await
this
.
SetPosition
(
this
.
updateProps
.
position
)
;
}
async
Find
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetFolder
(
this
.
props
.
location
)
;
if
(
this
.
props
.
parentGuid
=
=
null
)
{
Logger
.
logError
(
"
Unable
to
find
folder
"
+
this
.
props
.
location
)
;
return
null
;
}
let
bookmarkTitle
=
this
.
props
.
title
;
this
.
props
.
guid
=
await
this
.
GetPlacesChildGuid
(
this
.
props
.
parentGuid
null
bookmarkTitle
this
.
props
.
uri
)
;
if
(
!
this
.
props
.
guid
)
{
Logger
.
logPotentialError
(
this
.
toString
(
)
+
"
not
found
"
)
;
return
null
;
}
if
(
this
.
props
.
keyword
!
=
null
)
{
let
{
keyword
}
=
await
PlacesSyncUtils
.
bookmarks
.
fetch
(
this
.
props
.
guid
)
;
if
(
keyword
!
=
this
.
props
.
keyword
)
{
Logger
.
logPotentialError
(
"
Incorrect
keyword
-
expected
:
"
+
this
.
props
.
keyword
+
"
actual
:
"
+
keyword
+
"
for
"
+
this
.
toString
(
)
)
;
return
null
;
}
}
if
(
this
.
props
.
tags
!
=
null
)
{
try
{
let
URI
=
Services
.
io
.
newURI
(
this
.
props
.
uri
)
;
let
tags
=
PlacesUtils
.
tagging
.
getTagsForURI
(
URI
)
;
tags
.
sort
(
)
;
this
.
props
.
tags
.
sort
(
)
;
if
(
JSON
.
stringify
(
tags
)
!
=
JSON
.
stringify
(
this
.
props
.
tags
)
)
{
Logger
.
logPotentialError
(
"
Wrong
tags
-
expected
:
"
+
JSON
.
stringify
(
this
.
props
.
tags
)
+
"
actual
:
"
+
JSON
.
stringify
(
tags
)
+
"
for
"
+
this
.
toString
(
)
)
;
return
null
;
}
}
catch
(
e
)
{
Logger
.
logPotentialError
(
"
error
processing
tags
"
+
e
)
;
return
null
;
}
}
if
(
!
(
await
this
.
CheckPosition
(
this
.
props
.
before
this
.
props
.
after
this
.
props
.
last_item_pos
)
)
)
{
return
null
;
}
return
this
.
props
.
guid
;
}
async
Remove
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Remove
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
this
.
props
.
guid
)
;
}
}
;
extend
(
Bookmark
PlacesItem
)
;
function
BookmarkFolder
(
props
)
{
PlacesItem
.
call
(
this
props
)
;
this
.
props
.
type
=
"
folder
"
;
}
BookmarkFolder
.
prototype
=
{
async
Create
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetOrCreateFolder
(
this
.
props
.
location
)
;
Logger
.
AssertTrue
(
this
.
props
.
parentGuid
"
Unable
to
create
"
+
"
folder
error
creating
parent
folder
"
+
this
.
props
.
location
)
;
let
{
guid
}
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
this
.
props
.
parentGuid
title
:
this
.
props
.
folder
index
:
PlacesUtils
.
bookmarks
.
DEFAULT_INDEX
type
:
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
}
)
;
this
.
props
.
guid
=
guid
;
return
this
.
props
.
parentGuid
;
}
async
Find
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetFolder
(
this
.
props
.
location
)
;
if
(
this
.
props
.
parentGuid
=
=
null
)
{
Logger
.
logError
(
"
Unable
to
find
folder
"
+
this
.
props
.
location
)
;
return
null
;
}
this
.
props
.
guid
=
await
this
.
GetPlacesChildGuid
(
this
.
props
.
parentGuid
PlacesUtils
.
bookmarks
.
TYPE_FOLDER
this
.
props
.
folder
)
;
if
(
this
.
props
.
guid
=
=
null
)
{
return
null
;
}
if
(
!
(
await
this
.
CheckPosition
(
this
.
props
.
before
this
.
props
.
after
this
.
props
.
last_item_pos
)
)
)
{
return
null
;
}
return
this
.
props
.
guid
;
}
async
Remove
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Remove
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
this
.
props
.
guid
)
;
}
async
Update
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Update
"
)
;
await
this
.
SetLocation
(
this
.
updateProps
.
location
)
;
await
this
.
SetPosition
(
this
.
updateProps
.
position
)
;
await
this
.
SetTitle
(
this
.
updateProps
.
folder
)
;
}
}
;
extend
(
BookmarkFolder
PlacesItem
)
;
function
Separator
(
props
)
{
PlacesItem
.
call
(
this
props
)
;
this
.
props
.
type
=
"
separator
"
;
}
Separator
.
prototype
=
{
async
Create
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetOrCreateFolder
(
this
.
props
.
location
)
;
Logger
.
AssertTrue
(
this
.
props
.
parentGuid
"
Unable
to
create
"
+
"
folder
error
creating
parent
folder
"
+
this
.
props
.
location
)
;
let
{
guid
}
=
await
PlacesUtils
.
bookmarks
.
insert
(
{
parentGuid
:
this
.
props
.
parentGuid
type
:
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
}
)
;
this
.
props
.
guid
=
guid
;
return
guid
;
}
async
Find
(
)
{
this
.
props
.
parentGuid
=
await
this
.
GetFolder
(
this
.
props
.
location
)
;
if
(
this
.
props
.
parentGuid
=
=
null
)
{
Logger
.
logError
(
"
Unable
to
find
folder
"
+
this
.
props
.
location
)
;
return
null
;
}
if
(
this
.
props
.
before
=
=
null
&
&
this
.
props
.
last_item_pos
=
=
null
)
{
Logger
.
logPotentialError
(
"
Separator
requires
'
before
'
attribute
if
it
'
s
the
"
+
"
first
item
in
the
list
"
)
;
return
null
;
}
let
expected_pos
=
-
1
;
if
(
this
.
props
.
before
)
{
let
otherGuid
=
this
.
GetPlacesChildGuid
(
this
.
props
.
parentGuid
null
this
.
props
.
before
)
;
if
(
otherGuid
=
=
null
)
{
Logger
.
logPotentialError
(
"
Can
'
t
find
places
item
"
+
this
.
props
.
before
+
"
for
locating
separator
"
)
;
return
null
;
}
expected_pos
=
(
await
PlacesUtils
.
bookmarks
.
fetch
(
otherGuid
)
)
.
index
-
1
;
}
else
{
expected_pos
=
this
.
props
.
last_item_pos
+
1
;
}
let
children
=
await
PlacesSyncUtils
.
bookmarks
.
fetchChildRecordIds
(
this
.
props
.
parentGuid
)
;
this
.
props
.
guid
=
children
[
expected_pos
]
;
if
(
this
.
props
.
guid
=
=
null
)
{
Logger
.
logPotentialError
(
"
No
separator
found
at
position
"
+
expected_pos
)
;
return
null
;
}
let
info
=
await
PlacesUtils
.
bookmarks
.
fetch
(
this
.
props
.
guid
)
;
if
(
info
.
type
!
=
PlacesUtils
.
bookmarks
.
TYPE_SEPARATOR
)
{
Logger
.
logPotentialError
(
"
Places
item
at
position
"
+
expected_pos
+
"
is
not
a
separator
"
)
;
return
null
;
}
return
this
.
props
.
guid
;
}
async
Update
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Update
"
)
;
await
this
.
SetLocation
(
this
.
updateProps
.
location
)
;
await
this
.
SetPosition
(
this
.
updateProps
.
position
)
;
return
true
;
}
async
Remove
(
)
{
Logger
.
AssertTrue
(
this
.
props
.
guid
"
Invalid
guid
during
Update
"
)
;
await
PlacesUtils
.
bookmarks
.
remove
(
this
.
props
.
guid
)
;
}
}
;
extend
(
Separator
PlacesItem
)
;
