this
.
EXPORTED_SYMBOLS
=
[
"
EngineManager
"
"
Engine
"
"
SyncEngine
"
"
Tracker
"
"
Store
"
"
Changeset
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
JSONFile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
this
.
Tracker
=
function
Tracker
(
name
engine
)
{
if
(
!
engine
)
{
throw
new
Error
(
"
Tracker
must
be
associated
with
an
Engine
instance
.
"
)
;
}
name
=
name
|
|
"
Unnamed
"
;
this
.
name
=
this
.
file
=
name
.
toLowerCase
(
)
;
this
.
engine
=
engine
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Tracker
.
"
+
name
)
;
let
level
=
Svc
.
Prefs
.
get
(
"
log
.
logger
.
engine
.
"
+
this
.
name
"
Debug
"
)
;
this
.
_log
.
level
=
Log
.
Level
[
level
]
;
this
.
_score
=
0
;
this
.
_ignored
=
[
]
;
this
.
_storage
=
new
JSONFile
(
{
path
:
Utils
.
jsonFilePath
(
"
changes
/
"
+
this
.
file
)
dataPostProcessor
:
json
=
>
this
.
_dataPostProcessor
(
json
)
beforeSave
:
(
)
=
>
this
.
_beforeSave
(
)
}
)
;
this
.
ignoreAll
=
false
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
start
-
tracking
"
this
)
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
stop
-
tracking
"
this
)
;
Svc
.
Prefs
.
observe
(
"
engine
.
"
+
this
.
engine
.
prefName
this
)
;
}
;
Tracker
.
prototype
=
{
get
score
(
)
{
return
this
.
_score
;
}
_dataPostProcessor
(
json
)
{
return
typeof
json
=
=
"
object
"
&
&
json
|
|
{
}
;
}
_beforeSave
(
)
{
let
basename
=
OS
.
Path
.
dirname
(
this
.
_storage
.
path
)
;
return
OS
.
File
.
makeDir
(
basename
{
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
}
get
changedIDs
(
)
{
Async
.
promiseSpinningly
(
this
.
_storage
.
load
(
)
)
;
return
this
.
_storage
.
data
;
}
set
score
(
value
)
{
this
.
_score
=
value
;
Observers
.
notify
(
"
weave
:
engine
:
score
:
updated
"
this
.
name
)
;
}
resetScore
(
)
{
this
.
_score
=
0
;
}
persistChangedIDs
:
true
_saveChangedIDs
(
)
{
if
(
!
this
.
persistChangedIDs
)
{
this
.
_log
.
debug
(
"
Not
saving
changedIDs
.
"
)
;
return
;
}
this
.
_storage
.
saveSoon
(
)
;
}
ignoreID
(
id
)
{
this
.
unignoreID
(
id
)
;
this
.
_ignored
.
push
(
id
)
;
}
unignoreID
(
id
)
{
let
index
=
this
.
_ignored
.
indexOf
(
id
)
;
if
(
index
!
=
-
1
)
this
.
_ignored
.
splice
(
index
1
)
;
}
_saveChangedID
(
id
when
)
{
this
.
_log
.
trace
(
Adding
changed
ID
:
{
id
}
{
JSON
.
stringify
(
when
)
}
)
;
this
.
changedIDs
[
id
]
=
when
;
this
.
_saveChangedIDs
(
)
;
}
addChangedID
(
id
when
)
{
if
(
!
id
)
{
this
.
_log
.
warn
(
"
Attempted
to
add
undefined
ID
to
tracker
"
)
;
return
false
;
}
if
(
this
.
ignoreAll
|
|
this
.
_ignored
.
includes
(
id
)
)
{
return
false
;
}
if
(
when
=
=
null
)
{
when
=
this
.
_now
(
)
;
}
if
(
(
this
.
changedIDs
[
id
]
|
|
-
Infinity
)
<
when
)
{
this
.
_saveChangedID
(
id
when
)
;
}
return
true
;
}
removeChangedID
(
.
.
.
ids
)
{
if
(
!
ids
.
length
|
|
this
.
ignoreAll
)
{
return
false
;
}
for
(
let
id
of
ids
)
{
if
(
!
id
)
{
this
.
_log
.
warn
(
"
Attempted
to
remove
undefined
ID
from
tracker
"
)
;
continue
;
}
if
(
this
.
_ignored
.
includes
(
id
)
)
{
this
.
_log
.
debug
(
Not
removing
ignored
ID
{
id
}
from
tracker
)
;
continue
;
}
if
(
this
.
changedIDs
[
id
]
!
=
null
)
{
this
.
_log
.
trace
(
"
Removing
changed
ID
"
+
id
)
;
delete
this
.
changedIDs
[
id
]
;
}
}
this
.
_saveChangedIDs
(
)
;
return
true
;
}
clearChangedIDs
(
)
{
this
.
_log
.
trace
(
"
Clearing
changed
ID
list
"
)
;
this
.
_storage
.
data
=
{
}
;
this
.
_saveChangedIDs
(
)
;
}
_now
(
)
{
return
Date
.
now
(
)
/
1000
;
}
_isTracking
:
false
startTracking
(
)
{
}
stopTracking
(
)
{
}
engineIsEnabled
(
)
{
if
(
!
this
.
engine
)
{
return
true
;
}
return
this
.
engine
.
enabled
;
}
onEngineEnabledChanged
(
engineEnabled
)
{
if
(
engineEnabled
=
=
this
.
_isTracking
)
{
return
;
}
if
(
engineEnabled
)
{
this
.
startTracking
(
)
;
this
.
_isTracking
=
true
;
}
else
{
this
.
stopTracking
(
)
;
this
.
_isTracking
=
false
;
this
.
clearChangedIDs
(
)
;
}
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
weave
:
engine
:
start
-
tracking
"
:
if
(
!
this
.
engineIsEnabled
(
)
)
{
return
;
}
this
.
_log
.
trace
(
"
Got
start
-
tracking
.
"
)
;
if
(
!
this
.
_isTracking
)
{
this
.
startTracking
(
)
;
this
.
_isTracking
=
true
;
}
return
;
case
"
weave
:
engine
:
stop
-
tracking
"
:
this
.
_log
.
trace
(
"
Got
stop
-
tracking
.
"
)
;
if
(
this
.
_isTracking
)
{
this
.
stopTracking
(
)
;
this
.
_isTracking
=
false
;
}
return
;
case
"
nsPref
:
changed
"
:
if
(
data
=
=
PREFS_BRANCH
+
"
engine
.
"
+
this
.
engine
.
prefName
)
{
this
.
onEngineEnabledChanged
(
this
.
engine
.
enabled
)
;
}
}
}
}
;
this
.
Store
=
function
Store
(
name
engine
)
{
if
(
!
engine
)
{
throw
new
Error
(
"
Store
must
be
associated
with
an
Engine
instance
.
"
)
;
}
name
=
name
|
|
"
Unnamed
"
;
this
.
name
=
name
.
toLowerCase
(
)
;
this
.
engine
=
engine
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Store
.
"
+
name
)
;
let
level
=
Svc
.
Prefs
.
get
(
"
log
.
logger
.
engine
.
"
+
this
.
name
"
Debug
"
)
;
this
.
_log
.
level
=
Log
.
Level
[
level
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_timer
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
)
;
}
Store
.
prototype
=
{
_sleep
:
function
_sleep
(
delay
)
{
let
cb
=
Async
.
makeSyncCallback
(
)
;
this
.
_timer
.
initWithCallback
(
cb
delay
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
Async
.
waitForSyncCallback
(
cb
)
;
}
applyIncomingBatch
(
records
)
{
let
failed
=
[
]
;
for
(
let
record
of
records
)
{
try
{
this
.
applyIncoming
(
record
)
;
}
catch
(
ex
)
{
if
(
ex
.
code
=
=
Engine
.
prototype
.
eEngineAbortApplyIncoming
)
{
throw
ex
.
cause
;
}
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
warn
(
"
Failed
to
apply
incoming
record
"
+
record
.
id
ex
)
;
this
.
engine
.
_noteApplyFailure
(
)
;
failed
.
push
(
record
.
id
)
;
}
}
return
failed
;
}
applyIncoming
(
record
)
{
if
(
record
.
deleted
)
this
.
remove
(
record
)
;
else
if
(
!
this
.
itemExists
(
record
.
id
)
)
this
.
create
(
record
)
;
else
this
.
update
(
record
)
;
}
create
(
record
)
{
throw
"
override
create
in
a
subclass
"
;
}
remove
(
record
)
{
throw
"
override
remove
in
a
subclass
"
;
}
update
(
record
)
{
throw
"
override
update
in
a
subclass
"
;
}
itemExists
(
id
)
{
throw
"
override
itemExists
in
a
subclass
"
;
}
createRecord
(
id
collection
)
{
throw
"
override
createRecord
in
a
subclass
"
;
}
changeItemID
(
oldID
newID
)
{
throw
"
override
changeItemID
in
a
subclass
"
;
}
getAllIDs
(
)
{
throw
"
override
getAllIDs
in
a
subclass
"
;
}
wipe
(
)
{
throw
"
override
wipe
in
a
subclass
"
;
}
}
;
this
.
EngineManager
=
function
EngineManager
(
service
)
{
this
.
service
=
service
;
this
.
_engines
=
{
}
;
this
.
_declined
=
new
Set
(
)
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
EngineManager
"
)
;
this
.
_log
.
level
=
Log
.
Level
[
Svc
.
Prefs
.
get
(
"
log
.
logger
.
service
.
engines
"
"
Debug
"
)
]
;
}
EngineManager
.
prototype
=
{
get
(
name
)
{
if
(
Array
.
isArray
(
name
)
)
{
let
engines
=
[
]
;
name
.
forEach
(
function
(
name
)
{
let
engine
=
this
.
get
(
name
)
;
if
(
engine
)
{
engines
.
push
(
engine
)
;
}
}
this
)
;
return
engines
;
}
let
engine
=
this
.
_engines
[
name
]
;
if
(
!
engine
)
{
this
.
_log
.
debug
(
"
Could
not
get
engine
:
"
+
name
)
;
if
(
Object
.
keys
)
{
this
.
_log
.
debug
(
"
Engines
are
:
"
+
JSON
.
stringify
(
Object
.
keys
(
this
.
_engines
)
)
)
;
}
}
return
engine
;
}
getAll
(
)
{
let
engines
=
[
]
;
for
(
let
[
engine
]
of
Object
.
entries
(
this
.
_engines
)
)
{
engines
.
push
(
engine
)
;
}
return
engines
;
}
getEnabled
(
)
{
return
this
.
getAll
(
)
.
filter
(
(
engine
)
=
>
engine
.
enabled
)
.
sort
(
(
a
b
)
=
>
a
.
syncPriority
-
b
.
syncPriority
)
;
}
get
enabledEngineNames
(
)
{
return
this
.
getEnabled
(
)
.
map
(
e
=
>
e
.
name
)
;
}
persistDeclined
(
)
{
Svc
.
Prefs
.
set
(
"
declinedEngines
"
[
.
.
.
this
.
_declined
]
.
join
(
"
"
)
)
;
}
getDeclined
(
)
{
return
[
.
.
.
this
.
_declined
]
;
}
setDeclined
(
engines
)
{
this
.
_declined
=
new
Set
(
engines
)
;
this
.
persistDeclined
(
)
;
}
isDeclined
(
engineName
)
{
return
this
.
_declined
.
has
(
engineName
)
;
}
decline
(
engines
)
{
for
(
let
e
of
engines
)
{
this
.
_declined
.
add
(
e
)
;
}
this
.
persistDeclined
(
)
;
}
undecline
(
engines
)
{
for
(
let
e
of
engines
)
{
this
.
_declined
.
delete
(
e
)
;
}
this
.
persistDeclined
(
)
;
}
declineDisabled
(
)
{
for
(
let
e
of
this
.
getAll
(
)
)
{
if
(
!
e
.
enabled
)
{
this
.
_log
.
debug
(
"
Declining
disabled
engine
"
+
e
.
name
)
;
this
.
_declined
.
add
(
e
.
name
)
;
}
}
this
.
persistDeclined
(
)
;
}
register
(
engineObject
)
{
if
(
Array
.
isArray
(
engineObject
)
)
{
return
engineObject
.
map
(
this
.
register
this
)
;
}
try
{
let
engine
=
new
engineObject
(
this
.
service
)
;
let
name
=
engine
.
name
;
if
(
name
in
this
.
_engines
)
{
this
.
_log
.
error
(
"
Engine
'
"
+
name
+
"
'
is
already
registered
!
"
)
;
}
else
{
this
.
_engines
[
name
]
=
engine
;
}
}
catch
(
ex
)
{
let
name
=
engineObject
|
|
"
"
;
name
=
name
.
prototype
|
|
"
"
;
name
=
name
.
name
|
|
"
"
;
this
.
_log
.
error
(
Could
not
initialize
engine
{
name
}
ex
)
;
return
engineObject
;
}
}
unregister
(
val
)
{
let
name
=
val
;
if
(
val
instanceof
Engine
)
{
name
=
val
.
name
;
}
if
(
name
in
this
.
_engines
)
{
let
engine
=
this
.
_engines
[
name
]
;
delete
this
.
_engines
[
name
]
;
engine
.
finalize
(
)
;
}
}
clear
(
)
{
for
(
let
name
in
this
.
_engines
)
{
delete
this
.
_engines
[
name
]
;
}
}
}
;
this
.
Engine
=
function
Engine
(
name
service
)
{
if
(
!
service
)
{
throw
new
Error
(
"
Engine
must
be
associated
with
a
Service
instance
.
"
)
;
}
this
.
Name
=
name
|
|
"
Unnamed
"
;
this
.
name
=
name
.
toLowerCase
(
)
;
this
.
service
=
service
;
this
.
_notify
=
Utils
.
notify
(
"
weave
:
engine
:
"
)
;
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
"
+
this
.
Name
)
;
let
level
=
Svc
.
Prefs
.
get
(
"
log
.
logger
.
engine
.
"
+
this
.
name
"
Debug
"
)
;
this
.
_log
.
level
=
Log
.
Level
[
level
]
;
this
.
_tracker
;
this
.
_log
.
debug
(
"
Engine
initialized
"
)
;
}
Engine
.
prototype
=
{
_storeObj
:
Store
_trackerObj
:
Tracker
eEngineAbortApplyIncoming
:
"
error
.
engine
.
abort
.
applyincoming
"
allowSkippedRecord
:
true
get
prefName
(
)
{
return
this
.
name
;
}
get
enabled
(
)
{
return
Svc
.
Prefs
.
get
(
"
engine
.
"
+
this
.
prefName
false
)
;
}
set
enabled
(
val
)
{
Svc
.
Prefs
.
set
(
"
engine
.
"
+
this
.
prefName
!
!
val
)
;
}
get
score
(
)
{
return
this
.
_tracker
.
score
;
}
get
_store
(
)
{
let
store
=
new
this
.
_storeObj
(
this
.
Name
this
)
;
this
.
__defineGetter__
(
"
_store
"
(
)
=
>
store
)
;
return
store
;
}
get
_tracker
(
)
{
let
tracker
=
new
this
.
_trackerObj
(
this
.
Name
this
)
;
this
.
__defineGetter__
(
"
_tracker
"
(
)
=
>
tracker
)
;
return
tracker
;
}
sync
(
)
{
if
(
!
this
.
enabled
)
{
return
;
}
if
(
!
this
.
_sync
)
{
throw
"
engine
does
not
implement
_sync
method
"
;
}
this
.
_notify
(
"
sync
"
this
.
name
this
.
_sync
)
(
)
;
}
resetClient
(
)
{
if
(
!
this
.
_resetClient
)
{
throw
"
engine
does
not
implement
_resetClient
method
"
;
}
this
.
_notify
(
"
reset
-
client
"
this
.
name
this
.
_resetClient
)
(
)
;
}
_wipeClient
(
)
{
this
.
resetClient
(
)
;
this
.
_log
.
debug
(
"
Deleting
all
local
data
"
)
;
this
.
_tracker
.
ignoreAll
=
true
;
this
.
_store
.
wipe
(
)
;
this
.
_tracker
.
ignoreAll
=
false
;
this
.
_tracker
.
clearChangedIDs
(
)
;
}
wipeClient
(
)
{
this
.
_notify
(
"
wipe
-
client
"
this
.
name
this
.
_wipeClient
)
(
)
;
}
getValidator
(
)
{
return
null
;
}
finalize
(
)
{
Async
.
promiseSpinningly
(
this
.
_tracker
.
_storage
.
finalize
(
)
)
;
}
}
;
this
.
SyncEngine
=
function
SyncEngine
(
name
service
)
{
Engine
.
call
(
this
name
|
|
"
SyncEngine
"
service
)
;
this
.
loadToFetch
(
)
;
this
.
loadPreviousFailed
(
)
;
}
SyncEngine
.
kRecoveryStrategy
=
{
ignore
:
"
ignore
"
retry
:
"
retry
"
error
:
"
error
"
}
;
SyncEngine
.
prototype
=
{
__proto__
:
Engine
.
prototype
_recordObj
:
CryptoWrapper
version
:
1
_defaultSort
:
undefined
syncPriority
:
0
downloadLimit
:
null
guidFetchBatchSize
:
DEFAULT_GUID_FETCH_BATCH_SIZE
mobileGUIDFetchBatchSize
:
DEFAULT_MOBILE_GUID_FETCH_BATCH_SIZE
applyIncomingBatchSize
:
DEFAULT_STORE_BATCH_SIZE
get
storageURL
(
)
{
return
this
.
service
.
storageURL
;
}
get
engineURL
(
)
{
return
this
.
storageURL
+
this
.
name
;
}
get
cryptoKeysURL
(
)
{
return
this
.
storageURL
+
"
crypto
/
keys
"
;
}
get
metaURL
(
)
{
return
this
.
storageURL
+
"
meta
/
global
"
;
}
get
syncID
(
)
{
let
syncID
=
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
syncID
"
"
"
)
;
return
syncID
=
=
"
"
?
this
.
syncID
=
Utils
.
makeGUID
(
)
:
syncID
;
}
set
syncID
(
value
)
{
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
syncID
"
value
)
;
}
get
lastSync
(
)
{
return
parseFloat
(
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
lastSync
"
"
0
"
)
)
;
}
set
lastSync
(
value
)
{
Svc
.
Prefs
.
reset
(
this
.
name
+
"
.
lastSync
"
)
;
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastSync
"
value
.
toString
(
)
)
;
}
resetLastSync
(
)
{
this
.
_log
.
debug
(
"
Resetting
"
+
this
.
name
+
"
last
sync
time
"
)
;
Svc
.
Prefs
.
reset
(
this
.
name
+
"
.
lastSync
"
)
;
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastSync
"
"
0
"
)
;
this
.
lastSyncLocal
=
0
;
}
get
toFetch
(
)
{
return
this
.
_toFetch
;
}
set
toFetch
(
val
)
{
let
cb
=
(
error
)
=
>
{
if
(
error
)
{
this
.
_log
.
error
(
"
Failed
to
read
JSON
records
to
fetch
"
error
)
;
}
}
if
(
val
+
"
"
=
=
this
.
_toFetch
)
{
return
;
}
this
.
_toFetch
=
val
;
Utils
.
namedTimer
(
function
(
)
{
Utils
.
jsonSave
(
"
toFetch
/
"
+
this
.
name
this
val
cb
)
;
}
0
this
"
_toFetchDelay
"
)
;
}
loadToFetch
(
)
{
this
.
_toFetch
=
[
]
;
Utils
.
jsonLoad
(
"
toFetch
/
"
+
this
.
name
this
function
(
toFetch
)
{
if
(
toFetch
)
{
this
.
_toFetch
=
toFetch
;
}
}
)
;
}
get
previousFailed
(
)
{
return
this
.
_previousFailed
;
}
set
previousFailed
(
val
)
{
let
cb
=
(
error
)
=
>
{
if
(
error
)
{
this
.
_log
.
error
(
"
Failed
to
set
previousFailed
"
error
)
;
}
else
{
this
.
_log
.
debug
(
"
Successfully
wrote
previousFailed
.
"
)
;
}
}
if
(
val
+
"
"
=
=
this
.
_previousFailed
)
{
return
;
}
this
.
_previousFailed
=
val
;
Utils
.
namedTimer
(
function
(
)
{
Utils
.
jsonSave
(
"
failed
/
"
+
this
.
name
this
val
cb
)
;
}
0
this
"
_previousFailedDelay
"
)
;
}
loadPreviousFailed
(
)
{
this
.
_previousFailed
=
[
]
;
Utils
.
jsonLoad
(
"
failed
/
"
+
this
.
name
this
function
(
previousFailed
)
{
if
(
previousFailed
)
{
this
.
_previousFailed
=
previousFailed
;
}
}
)
;
}
get
lastSyncLocal
(
)
{
return
parseInt
(
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
lastSyncLocal
"
"
0
"
)
10
)
;
}
set
lastSyncLocal
(
value
)
{
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastSyncLocal
"
value
.
toString
(
)
)
;
}
getChangedIDs
(
)
{
return
this
.
_tracker
.
changedIDs
;
}
_createRecord
(
id
)
{
let
record
=
this
.
_store
.
createRecord
(
id
this
.
name
)
;
record
.
id
=
id
;
record
.
collection
=
this
.
name
;
return
record
;
}
_syncStartup
(
)
{
let
metaGlobal
=
this
.
service
.
recordManager
.
get
(
this
.
metaURL
)
;
let
engines
=
metaGlobal
.
payload
.
engines
|
|
{
}
;
let
engineData
=
engines
[
this
.
name
]
|
|
{
}
;
let
needsWipe
=
false
;
if
(
(
engineData
.
version
|
|
0
)
<
this
.
version
)
{
this
.
_log
.
debug
(
"
Old
engine
data
:
"
+
[
engineData
.
version
this
.
version
]
)
;
needsWipe
=
true
;
this
.
syncID
=
"
"
;
engineData
.
version
=
this
.
version
;
engineData
.
syncID
=
this
.
syncID
;
engines
[
this
.
name
]
=
engineData
;
metaGlobal
.
payload
.
engines
=
engines
;
metaGlobal
.
changed
=
true
;
}
else
if
(
engineData
.
version
>
this
.
version
)
{
let
error
=
new
String
(
"
New
data
:
"
+
[
engineData
.
version
this
.
version
]
)
;
error
.
failureCode
=
VERSION_OUT_OF_DATE
;
throw
error
;
}
else
if
(
engineData
.
syncID
!
=
this
.
syncID
)
{
this
.
_log
.
debug
(
"
Engine
syncIDs
:
"
+
[
engineData
.
syncID
this
.
syncID
]
)
;
this
.
syncID
=
engineData
.
syncID
;
this
.
_resetClient
(
)
;
}
if
(
needsWipe
)
{
this
.
wipeServer
(
)
;
}
this
.
lastSyncLocal
=
Date
.
now
(
)
;
if
(
this
.
lastSync
)
{
this
.
_modified
=
this
.
pullNewChanges
(
)
;
}
else
{
this
.
_log
.
debug
(
"
First
sync
uploading
all
items
"
)
;
this
.
_modified
=
this
.
pullAllChanges
(
)
;
}
this
.
_tracker
.
clearChangedIDs
(
)
;
this
.
_log
.
info
(
this
.
_modified
.
count
(
)
+
"
outgoing
items
pre
-
reconciliation
"
)
;
this
.
_delete
=
{
}
;
}
itemSource
(
)
{
return
new
Collection
(
this
.
engineURL
this
.
_recordObj
this
.
service
)
;
}
_processIncoming
(
newitems
)
{
this
.
_log
.
trace
(
"
Downloading
&
applying
server
changes
"
)
;
let
batchSize
=
this
.
downloadLimit
|
|
Infinity
;
let
isMobile
=
(
Svc
.
Prefs
.
get
(
"
client
.
type
"
)
=
=
"
mobile
"
)
;
if
(
!
newitems
)
{
newitems
=
this
.
itemSource
(
)
;
}
if
(
this
.
_defaultSort
)
{
newitems
.
sort
=
this
.
_defaultSort
;
}
if
(
isMobile
)
{
batchSize
=
MOBILE_BATCH_SIZE
;
}
newitems
.
newer
=
this
.
lastSync
;
newitems
.
full
=
true
;
newitems
.
limit
=
batchSize
;
let
count
=
{
applied
:
0
failed
:
0
newFailed
:
0
reconciled
:
0
}
;
let
handled
=
[
]
;
let
applyBatch
=
[
]
;
let
failed
=
[
]
;
let
failedInPreviousSync
=
this
.
previousFailed
;
let
fetchBatch
=
Utils
.
arrayUnion
(
this
.
toFetch
failedInPreviousSync
)
;
this
.
previousFailed
=
[
]
;
let
aborting
=
undefined
;
function
doApplyBatch
(
)
{
this
.
_tracker
.
ignoreAll
=
true
;
try
{
failed
=
failed
.
concat
(
this
.
_store
.
applyIncomingBatch
(
applyBatch
)
)
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
warn
(
"
Got
exception
aborting
processIncoming
"
ex
)
;
aborting
=
ex
;
}
this
.
_tracker
.
ignoreAll
=
false
;
applyBatch
=
[
]
;
}
function
doApplyBatchAndPersistFailed
(
)
{
if
(
applyBatch
.
length
)
{
doApplyBatch
.
call
(
this
)
;
}
if
(
failed
.
length
)
{
this
.
previousFailed
=
Utils
.
arrayUnion
(
failed
this
.
previousFailed
)
;
count
.
failed
+
=
failed
.
length
;
this
.
_log
.
debug
(
"
Records
that
failed
to
apply
:
"
+
failed
)
;
failed
=
[
]
;
}
}
let
key
=
this
.
service
.
collectionKeys
.
keyForCollection
(
this
.
name
)
;
let
self
=
this
;
newitems
.
recordHandler
=
function
(
item
)
{
if
(
aborting
)
{
return
;
}
if
(
self
.
lastModified
=
=
null
|
|
item
.
modified
>
self
.
lastModified
)
self
.
lastModified
=
item
.
modified
;
item
.
collection
=
self
.
name
;
handled
.
push
(
item
.
id
)
;
try
{
try
{
item
.
decrypt
(
key
)
;
}
catch
(
ex
)
{
if
(
!
Utils
.
isHMACMismatch
(
ex
)
)
{
throw
ex
;
}
let
strategy
=
self
.
handleHMACMismatch
(
item
true
)
;
if
(
strategy
=
=
SyncEngine
.
kRecoveryStrategy
.
retry
)
{
try
{
self
.
_log
.
info
(
"
Trying
decrypt
again
.
.
.
"
)
;
key
=
self
.
service
.
collectionKeys
.
keyForCollection
(
self
.
name
)
;
item
.
decrypt
(
key
)
;
strategy
=
null
;
}
catch
(
ex
)
{
if
(
!
Utils
.
isHMACMismatch
(
ex
)
)
{
throw
ex
;
}
strategy
=
self
.
handleHMACMismatch
(
item
false
)
;
}
}
switch
(
strategy
)
{
case
null
:
break
;
case
SyncEngine
.
kRecoveryStrategy
.
retry
:
self
.
_log
.
debug
(
"
Ignoring
second
retry
suggestion
.
"
)
;
case
SyncEngine
.
kRecoveryStrategy
.
error
:
self
.
_log
.
warn
(
"
Error
decrypting
record
"
ex
)
;
self
.
_noteApplyFailure
(
)
;
failed
.
push
(
item
.
id
)
;
return
;
case
SyncEngine
.
kRecoveryStrategy
.
ignore
:
self
.
_log
.
debug
(
"
Ignoring
record
"
+
item
.
id
+
"
with
bad
HMAC
:
already
handled
.
"
)
;
return
;
}
}
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
self
.
_log
.
warn
(
"
Error
decrypting
record
"
ex
)
;
self
.
_noteApplyFailure
(
)
;
failed
.
push
(
item
.
id
)
;
return
;
}
if
(
self
.
_shouldDeleteRemotely
(
item
)
)
{
self
.
_log
.
trace
(
"
Deleting
item
from
server
without
applying
"
item
)
;
self
.
_deleteId
(
item
.
id
)
;
return
;
}
let
shouldApply
;
try
{
shouldApply
=
self
.
_reconcile
(
item
)
;
}
catch
(
ex
)
{
if
(
ex
.
code
=
=
Engine
.
prototype
.
eEngineAbortApplyIncoming
)
{
self
.
_log
.
warn
(
"
Reconciliation
failed
:
aborting
incoming
processing
.
"
)
;
self
.
_noteApplyFailure
(
)
;
failed
.
push
(
item
.
id
)
;
aborting
=
ex
.
cause
;
}
else
if
(
!
Async
.
isShutdownException
(
ex
)
)
{
self
.
_log
.
warn
(
"
Failed
to
reconcile
incoming
record
"
+
item
.
id
ex
)
;
self
.
_noteApplyFailure
(
)
;
failed
.
push
(
item
.
id
)
;
return
;
}
else
{
throw
ex
;
}
}
if
(
shouldApply
)
{
count
.
applied
+
+
;
applyBatch
.
push
(
item
)
;
}
else
{
count
.
reconciled
+
+
;
self
.
_log
.
trace
(
"
Skipping
reconciled
incoming
item
"
+
item
.
id
)
;
}
if
(
applyBatch
.
length
=
=
self
.
applyIncomingBatchSize
)
{
doApplyBatch
.
call
(
self
)
;
}
self
.
_store
.
_sleep
(
0
)
;
}
;
if
(
this
.
lastModified
=
=
null
|
|
this
.
lastModified
>
this
.
lastSync
)
{
let
resp
=
newitems
.
getBatched
(
)
;
doApplyBatchAndPersistFailed
.
call
(
this
)
;
if
(
!
resp
.
success
)
{
resp
.
failureCode
=
ENGINE_DOWNLOAD_FAIL
;
throw
resp
;
}
if
(
aborting
)
{
throw
aborting
;
}
}
if
(
handled
.
length
=
=
newitems
.
limit
)
{
let
guidColl
=
new
Collection
(
this
.
engineURL
null
this
.
service
)
;
guidColl
.
limit
=
this
.
downloadLimit
;
guidColl
.
newer
=
this
.
lastSync
;
guidColl
.
sort
=
"
index
"
;
let
guids
=
guidColl
.
get
(
)
;
if
(
!
guids
.
success
)
throw
guids
;
let
extra
=
Utils
.
arraySub
(
guids
.
obj
handled
)
;
if
(
extra
.
length
>
0
)
{
fetchBatch
=
Utils
.
arrayUnion
(
extra
fetchBatch
)
;
this
.
toFetch
=
Utils
.
arrayUnion
(
extra
this
.
toFetch
)
;
}
}
if
(
this
.
lastSync
<
this
.
lastModified
)
{
this
.
lastSync
=
this
.
lastModified
;
}
batchSize
=
isMobile
?
this
.
mobileGUIDFetchBatchSize
:
this
.
guidFetchBatchSize
;
while
(
fetchBatch
.
length
&
&
!
aborting
)
{
newitems
.
limit
=
0
;
newitems
.
newer
=
0
;
newitems
.
ids
=
fetchBatch
.
slice
(
0
batchSize
)
;
let
resp
=
newitems
.
get
(
)
;
if
(
!
resp
.
success
)
{
resp
.
failureCode
=
ENGINE_DOWNLOAD_FAIL
;
throw
resp
;
}
fetchBatch
=
fetchBatch
.
slice
(
batchSize
)
;
this
.
toFetch
=
Utils
.
arraySub
(
this
.
toFetch
newitems
.
ids
)
;
this
.
previousFailed
=
Utils
.
arrayUnion
(
this
.
previousFailed
failed
)
;
if
(
failed
.
length
)
{
count
.
failed
+
=
failed
.
length
;
this
.
_log
.
debug
(
"
Records
that
failed
to
apply
:
"
+
failed
)
;
}
failed
=
[
]
;
if
(
aborting
)
{
throw
aborting
;
}
if
(
this
.
lastSync
<
this
.
lastModified
)
{
this
.
lastSync
=
this
.
lastModified
;
}
}
doApplyBatchAndPersistFailed
.
call
(
this
)
;
count
.
newFailed
=
this
.
previousFailed
.
reduce
(
(
count
engine
)
=
>
{
if
(
failedInPreviousSync
.
indexOf
(
engine
)
=
=
-
1
)
{
count
+
+
;
this
.
_noteApplyNewFailure
(
)
;
}
return
count
;
}
0
)
;
count
.
succeeded
=
Math
.
max
(
0
count
.
applied
-
count
.
failed
)
;
this
.
_log
.
info
(
[
"
Records
:
"
count
.
applied
"
applied
"
count
.
succeeded
"
successfully
"
count
.
failed
"
failed
to
apply
"
count
.
newFailed
"
newly
failed
to
apply
"
count
.
reconciled
"
reconciled
.
"
]
.
join
(
"
"
)
)
;
Observers
.
notify
(
"
weave
:
engine
:
sync
:
applied
"
count
this
.
name
)
;
}
_shouldDeleteRemotely
(
remoteItem
)
{
return
false
;
}
_noteApplyFailure
(
)
{
}
_noteApplyNewFailure
(
)
{
}
_findDupe
(
item
)
{
}
_shouldReviveRemotelyDeletedRecord
(
remoteItem
)
{
return
true
;
}
_deleteId
(
id
)
{
this
.
_tracker
.
removeChangedID
(
id
)
;
this
.
_noteDeletedId
(
id
)
;
}
_noteDeletedId
(
id
)
{
if
(
this
.
_delete
.
ids
=
=
null
)
this
.
_delete
.
ids
=
[
id
]
;
else
this
.
_delete
.
ids
.
push
(
id
)
;
}
_switchItemToDupe
(
localDupeGUID
incomingItem
)
{
this
.
_deleteId
(
localDupeGUID
)
;
this
.
_log
.
debug
(
"
Switching
local
ID
to
incoming
:
"
+
localDupeGUID
+
"
-
>
"
+
incomingItem
.
id
)
;
this
.
_store
.
changeItemID
(
localDupeGUID
incomingItem
.
id
)
;
}
_reconcile
(
item
)
{
if
(
this
.
_log
.
level
<
=
Log
.
Level
.
Trace
)
{
this
.
_log
.
trace
(
"
Incoming
:
"
+
item
)
;
}
let
existsLocally
=
this
.
_store
.
itemExists
(
item
.
id
)
;
let
locallyModified
=
this
.
_modified
.
has
(
item
.
id
)
;
let
remoteAge
=
AsyncResource
.
serverTime
-
item
.
modified
;
let
localAge
=
locallyModified
?
(
Date
.
now
(
)
/
1000
-
this
.
_modified
.
getModifiedTimestamp
(
item
.
id
)
)
:
null
;
let
remoteIsNewer
=
remoteAge
<
localAge
;
this
.
_log
.
trace
(
"
Reconciling
"
+
item
.
id
+
"
.
exists
=
"
+
existsLocally
+
"
;
modified
=
"
+
locallyModified
+
"
;
local
age
=
"
+
localAge
+
"
;
incoming
age
=
"
+
remoteAge
)
;
if
(
item
.
deleted
)
{
if
(
!
existsLocally
)
{
this
.
_log
.
trace
(
"
Ignoring
incoming
item
because
it
was
deleted
and
"
+
"
the
item
does
not
exist
locally
.
"
)
;
return
false
;
}
if
(
!
locallyModified
)
{
this
.
_log
.
trace
(
"
Applying
incoming
delete
because
the
local
item
"
+
"
exists
and
isn
'
t
modified
.
"
)
;
return
true
;
}
this
.
_log
.
trace
(
"
Incoming
record
is
deleted
but
we
had
local
changes
.
"
)
;
if
(
remoteIsNewer
)
{
this
.
_log
.
trace
(
"
Remote
record
is
newer
-
-
deleting
local
record
.
"
)
;
return
true
;
}
let
willRevive
=
this
.
_shouldReviveRemotelyDeletedRecord
(
item
)
;
this
.
_log
.
trace
(
"
Local
record
is
newer
-
-
reviving
?
"
+
willRevive
)
;
return
!
willRevive
;
}
if
(
!
existsLocally
)
{
let
localDupeGUID
=
this
.
_findDupe
(
item
)
;
if
(
localDupeGUID
)
{
this
.
_log
.
trace
(
"
Local
item
"
+
localDupeGUID
+
"
is
a
duplicate
for
"
+
"
incoming
item
"
+
item
.
id
)
;
existsLocally
=
this
.
_store
.
itemExists
(
localDupeGUID
)
;
if
(
this
.
_modified
.
has
(
localDupeGUID
)
)
{
locallyModified
=
true
;
localAge
=
this
.
_tracker
.
_now
(
)
-
this
.
_modified
.
getModifiedTimestamp
(
localDupeGUID
)
;
remoteIsNewer
=
remoteAge
<
localAge
;
this
.
_modified
.
swap
(
localDupeGUID
item
.
id
)
;
}
else
{
locallyModified
=
false
;
localAge
=
null
;
}
this
.
_switchItemToDupe
(
localDupeGUID
item
)
;
this
.
_log
.
debug
(
"
Local
item
after
duplication
:
age
=
"
+
localAge
+
"
;
modified
=
"
+
locallyModified
+
"
;
exists
=
"
+
existsLocally
)
;
}
else
{
this
.
_log
.
trace
(
"
No
duplicate
found
for
incoming
item
:
"
+
item
.
id
)
;
}
}
if
(
!
existsLocally
)
{
if
(
!
locallyModified
)
{
this
.
_log
.
trace
(
"
Applying
incoming
because
local
item
does
not
exist
"
+
"
and
was
not
deleted
.
"
)
;
return
true
;
}
if
(
remoteIsNewer
)
{
this
.
_log
.
trace
(
"
Applying
incoming
because
local
item
was
deleted
"
+
"
before
the
incoming
item
was
changed
.
"
)
;
this
.
_modified
.
delete
(
item
.
id
)
;
return
true
;
}
this
.
_log
.
trace
(
"
Ignoring
incoming
item
because
the
local
item
'
s
"
+
"
deletion
is
newer
.
"
)
;
return
false
;
}
let
localRecord
=
this
.
_createRecord
(
item
.
id
)
;
let
recordsEqual
=
Utils
.
deepEquals
(
item
.
cleartext
localRecord
.
cleartext
)
;
if
(
recordsEqual
)
{
this
.
_log
.
trace
(
"
Ignoring
incoming
item
because
the
local
item
is
"
+
"
identical
.
"
)
;
this
.
_modified
.
delete
(
item
.
id
)
;
return
false
;
}
if
(
!
locallyModified
)
{
this
.
_log
.
trace
(
"
Applying
incoming
record
because
no
local
conflicts
.
"
)
;
return
true
;
}
this
.
_log
.
warn
(
"
DATA
LOSS
:
Both
local
and
remote
changes
to
record
:
"
+
item
.
id
)
;
return
remoteIsNewer
;
}
_uploadOutgoing
(
)
{
this
.
_log
.
trace
(
"
Uploading
local
changes
to
server
.
"
)
;
let
modifiedIDs
=
this
.
_modified
.
ids
(
)
;
if
(
modifiedIDs
.
length
)
{
this
.
_log
.
trace
(
"
Preparing
"
+
modifiedIDs
.
length
+
"
outgoing
records
"
)
;
let
counts
=
{
sent
:
modifiedIDs
.
length
failed
:
0
}
;
let
up
=
new
Collection
(
this
.
engineURL
null
this
.
service
)
;
let
failed
=
[
]
;
let
successful
=
[
]
;
let
handleResponse
=
(
resp
batchOngoing
=
false
)
=
>
{
if
(
!
resp
.
success
)
{
this
.
_log
.
debug
(
"
Uploading
records
failed
:
"
+
resp
)
;
resp
.
failureCode
=
resp
.
status
=
=
412
?
ENGINE_BATCH_INTERRUPTED
:
ENGINE_UPLOAD_FAIL
;
throw
resp
;
}
failed
=
failed
.
concat
(
Object
.
keys
(
resp
.
obj
.
failed
)
)
;
successful
=
successful
.
concat
(
resp
.
obj
.
success
)
;
if
(
batchOngoing
)
{
return
;
}
let
modified
=
resp
.
headers
[
"
x
-
weave
-
timestamp
"
]
;
if
(
modified
>
this
.
lastSync
)
{
this
.
lastSync
=
modified
;
}
if
(
failed
.
length
&
&
this
.
_log
.
level
<
=
Log
.
Level
.
Debug
)
{
this
.
_log
.
debug
(
"
Records
that
will
be
uploaded
again
because
"
+
"
the
server
couldn
'
t
store
them
:
"
+
failed
.
join
(
"
"
)
)
;
}
counts
.
failed
+
=
failed
.
length
;
for
(
let
id
of
successful
)
{
this
.
_modified
.
delete
(
id
)
;
}
this
.
_onRecordsWritten
(
successful
failed
)
;
failed
.
length
=
0
;
successful
.
length
=
0
;
}
;
let
postQueue
=
up
.
newPostQueue
(
this
.
_log
this
.
lastSync
handleResponse
)
;
for
(
let
id
of
modifiedIDs
)
{
let
out
;
let
ok
=
false
;
try
{
out
=
this
.
_createRecord
(
id
)
;
if
(
this
.
_log
.
level
<
=
Log
.
Level
.
Trace
)
this
.
_log
.
trace
(
"
Outgoing
:
"
+
out
)
;
out
.
encrypt
(
this
.
service
.
collectionKeys
.
keyForCollection
(
this
.
name
)
)
;
ok
=
true
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
warn
(
"
Error
creating
record
"
ex
)
;
}
if
(
ok
)
{
let
{
enqueued
error
}
=
postQueue
.
enqueue
(
out
)
;
if
(
!
enqueued
)
{
+
+
counts
.
failed
;
if
(
!
this
.
allowSkippedRecord
)
{
throw
error
;
}
this
.
_modified
.
delete
(
id
)
;
this
.
_log
.
warn
(
Failed
to
enqueue
record
"
{
id
}
"
(
skipping
)
error
)
;
}
}
this
.
_store
.
_sleep
(
0
)
;
}
postQueue
.
flush
(
true
)
;
Observers
.
notify
(
"
weave
:
engine
:
sync
:
uploaded
"
counts
this
.
name
)
;
}
}
_onRecordsWritten
(
succeeded
failed
)
{
}
_syncFinish
(
)
{
this
.
_log
.
trace
(
"
Finishing
up
sync
"
)
;
this
.
_tracker
.
resetScore
(
)
;
let
doDelete
=
Utils
.
bind2
(
this
function
(
key
val
)
{
let
coll
=
new
Collection
(
this
.
engineURL
this
.
_recordObj
this
.
service
)
;
coll
[
key
]
=
val
;
coll
.
delete
(
)
;
}
)
;
for
(
let
[
key
val
]
of
Object
.
entries
(
this
.
_delete
)
)
{
delete
this
.
_delete
[
key
]
;
if
(
key
!
=
"
ids
"
|
|
val
.
length
<
=
100
)
doDelete
(
key
val
)
;
else
{
while
(
val
.
length
>
0
)
{
doDelete
(
key
val
.
slice
(
0
100
)
)
;
val
=
val
.
slice
(
100
)
;
}
}
}
}
_syncCleanup
(
)
{
if
(
!
this
.
_modified
)
{
return
;
}
try
{
this
.
trackRemainingChanges
(
)
;
}
finally
{
this
.
_modified
.
clear
(
)
;
}
}
_sync
(
)
{
try
{
this
.
_syncStartup
(
)
;
Observers
.
notify
(
"
weave
:
engine
:
sync
:
status
"
"
process
-
incoming
"
)
;
this
.
_processIncoming
(
)
;
Observers
.
notify
(
"
weave
:
engine
:
sync
:
status
"
"
upload
-
outgoing
"
)
;
this
.
_uploadOutgoing
(
)
;
this
.
_syncFinish
(
)
;
}
finally
{
this
.
_syncCleanup
(
)
;
}
}
canDecrypt
(
)
{
let
canDecrypt
=
false
;
let
test
=
new
Collection
(
this
.
engineURL
this
.
_recordObj
this
.
service
)
;
test
.
limit
=
1
;
test
.
sort
=
"
newest
"
;
test
.
full
=
true
;
let
key
=
this
.
service
.
collectionKeys
.
keyForCollection
(
this
.
name
)
;
test
.
recordHandler
=
function
recordHandler
(
record
)
{
record
.
decrypt
(
key
)
;
canDecrypt
=
true
;
}
;
try
{
this
.
_log
.
trace
(
"
Trying
to
decrypt
a
record
from
the
server
.
.
"
)
;
test
.
get
(
)
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
debug
(
"
Failed
test
decrypt
"
ex
)
;
}
return
canDecrypt
;
}
_resetClient
(
)
{
this
.
resetLastSync
(
)
;
this
.
previousFailed
=
[
]
;
this
.
toFetch
=
[
]
;
}
wipeServer
(
)
{
let
response
=
this
.
service
.
resource
(
this
.
engineURL
)
.
delete
(
)
;
if
(
response
.
status
!
=
200
&
&
response
.
status
!
=
404
)
{
throw
response
;
}
this
.
_resetClient
(
)
;
}
removeClientData
(
)
{
}
handleHMACMismatch
(
item
mayRetry
)
{
return
(
this
.
service
.
handleHMACEvent
(
)
&
&
mayRetry
)
?
SyncEngine
.
kRecoveryStrategy
.
retry
:
SyncEngine
.
kRecoveryStrategy
.
error
;
}
pullAllChanges
(
)
{
let
changeset
=
new
Changeset
(
)
;
for
(
let
id
in
this
.
_store
.
getAllIDs
(
)
)
{
changeset
.
set
(
id
0
)
;
}
return
changeset
;
}
pullNewChanges
(
)
{
return
new
Changeset
(
this
.
getChangedIDs
(
)
)
;
}
trackRemainingChanges
(
)
{
for
(
let
[
id
change
]
of
this
.
_modified
.
entries
(
)
)
{
this
.
_tracker
.
addChangedID
(
id
change
)
;
}
}
}
;
class
Changeset
{
constructor
(
changes
=
{
}
)
{
this
.
changes
=
changes
;
}
getModifiedTimestamp
(
id
)
{
return
this
.
changes
[
id
]
;
}
set
(
id
change
)
{
this
.
changes
[
id
]
=
change
;
}
insert
(
changes
)
{
Object
.
assign
(
this
.
changes
changes
)
;
}
has
(
id
)
{
return
id
in
this
.
changes
;
}
delete
(
id
)
{
delete
this
.
changes
[
id
]
;
}
swap
(
oldID
newID
)
{
this
.
changes
[
newID
]
=
this
.
changes
[
oldID
]
;
delete
this
.
changes
[
oldID
]
;
}
ids
(
)
{
return
Object
.
keys
(
this
.
changes
)
;
}
entries
(
)
{
return
Object
.
entries
(
this
.
changes
)
;
}
count
(
)
{
return
this
.
ids
(
)
.
length
;
}
clear
(
)
{
this
.
changes
=
{
}
;
}
}
