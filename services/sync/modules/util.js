var
EXPORTED_SYMBOLS
=
[
"
Utils
"
"
Svc
"
"
SerializableSet
"
]
;
const
{
Observers
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
CryptoUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
{
DEVICE_TYPE_DESKTOP
MAXIMUM_BACKOFF_INTERVAL
PREFS_BRANCH
SYNC_KEY_DECODED_LENGTH
SYNC_KEY_ENCODED_LENGTH
WEAVE_VERSION
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
const
{
Preferences
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
FxAccountsCommon
"
function
(
)
{
let
FxAccountsCommon
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
FxAccountsCommon
)
;
return
FxAccountsCommon
;
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
cryptoSDR
"
"
mozilla
.
org
/
login
-
manager
/
crypto
/
SDR
;
1
"
"
nsILoginManagerCrypto
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
localDeviceName
"
"
services
.
sync
.
client
.
name
"
"
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
localDeviceType
"
"
services
.
sync
.
client
.
type
"
DEVICE_TYPE_DESKTOP
)
;
class
LockException
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
LockException
"
;
}
}
class
HMACMismatch
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
HMACMismatch
"
;
}
}
var
Utils
=
{
generateRandomBytesLegacy
:
CryptoUtils
.
generateRandomBytesLegacy
computeHTTPMACSHA1
:
CryptoUtils
.
computeHTTPMACSHA1
digestUTF8
:
CryptoUtils
.
digestUTF8
digestBytes
:
CryptoUtils
.
digestBytes
sha256
:
CryptoUtils
.
sha256
makeHMACKey
:
CryptoUtils
.
makeHMACKey
makeHMACHasher
:
CryptoUtils
.
makeHMACHasher
hkdfExpand
:
CryptoUtils
.
hkdfExpand
pbkdf2Generate
:
CryptoUtils
.
pbkdf2Generate
getHTTPMACSHA1Header
:
CryptoUtils
.
getHTTPMACSHA1Header
_userAgent
:
null
get
userAgent
(
)
{
if
(
!
this
.
_userAgent
)
{
let
hph
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
;
this
.
_userAgent
=
Services
.
appinfo
.
name
+
"
/
"
+
Services
.
appinfo
.
version
+
"
(
"
+
hph
.
oscpu
+
"
)
"
+
"
FxSync
/
"
+
WEAVE_VERSION
+
"
.
"
+
Services
.
appinfo
.
appBuildID
+
"
.
"
;
}
return
this
.
_userAgent
+
localDeviceType
;
}
catch
(
func
exceptionCallback
)
{
let
thisArg
=
this
;
return
async
function
WrappedCatch
(
)
{
try
{
return
await
func
.
call
(
thisArg
)
;
}
catch
(
ex
)
{
thisArg
.
_log
.
debug
(
"
Exception
calling
"
+
(
func
.
name
|
|
"
anonymous
function
"
)
ex
)
;
if
(
exceptionCallback
)
{
return
exceptionCallback
.
call
(
thisArg
ex
)
;
}
return
null
;
}
}
;
}
throwLockException
(
label
)
{
throw
new
LockException
(
Could
not
acquire
lock
.
Label
:
"
{
label
}
"
.
)
;
}
lock
(
label
func
)
{
let
thisArg
=
this
;
return
async
function
WrappedLock
(
)
{
if
(
!
thisArg
.
lock
(
)
)
{
Utils
.
throwLockException
(
label
)
;
}
try
{
return
await
func
.
call
(
thisArg
)
;
}
finally
{
thisArg
.
unlock
(
)
;
}
}
;
}
isLockException
:
function
isLockException
(
ex
)
{
return
ex
instanceof
LockException
;
}
notify
(
prefix
)
{
return
function
NotifyMaker
(
name
data
func
)
{
let
thisArg
=
this
;
let
notify
=
function
(
state
subject
)
{
let
mesg
=
prefix
+
name
+
"
:
"
+
state
;
thisArg
.
_log
.
trace
(
"
Event
:
"
+
mesg
)
;
Observers
.
notify
(
mesg
subject
data
)
;
}
;
return
async
function
WrappedNotify
(
)
{
notify
(
"
start
"
null
)
;
try
{
let
ret
=
await
func
.
call
(
thisArg
)
;
notify
(
"
finish
"
ret
)
;
return
ret
;
}
catch
(
ex
)
{
notify
(
"
error
"
ex
)
;
throw
ex
;
}
}
;
}
;
}
makeGUID
:
function
makeGUID
(
)
{
return
CommonUtils
.
encodeBase64URL
(
Utils
.
generateRandomBytesLegacy
(
9
)
)
;
}
_base64url_regex
:
/
^
[
-
abcdefghijklmnopqrstuvwxyz0123456789_
]
{
12
}
/
i
checkGUID
:
function
checkGUID
(
guid
)
{
return
!
!
guid
&
&
this
.
_base64url_regex
.
test
(
guid
)
;
}
deferGetSet
:
function
Utils_deferGetSet
(
obj
defer
prop
)
{
if
(
Array
.
isArray
(
prop
)
)
{
return
prop
.
map
(
prop
=
>
Utils
.
deferGetSet
(
obj
defer
prop
)
)
;
}
let
prot
=
obj
.
prototype
;
if
(
!
prot
.
__lookupGetter__
(
prop
)
)
{
prot
.
__defineGetter__
(
prop
function
(
)
{
return
this
[
defer
]
[
prop
]
;
}
)
;
}
if
(
!
prot
.
__lookupSetter__
(
prop
)
)
{
prot
.
__defineSetter__
(
prop
function
(
val
)
{
this
[
defer
]
[
prop
]
=
val
;
}
)
;
}
}
deepEquals
:
function
eq
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
typeof
a
!
=
"
object
"
|
|
typeof
b
!
=
"
object
"
)
{
return
false
;
}
if
(
a
=
=
=
null
|
|
b
=
=
=
null
)
{
return
false
;
}
for
(
let
k
in
a
)
{
if
(
!
eq
(
a
[
k
]
b
[
k
]
)
)
{
return
false
;
}
}
for
(
let
k
in
b
)
{
if
(
!
(
k
in
a
)
&
&
!
eq
(
a
[
k
]
b
[
k
]
)
)
{
return
false
;
}
}
return
true
;
}
throwHMACMismatch
:
function
throwHMACMismatch
(
shouldBe
is
)
{
throw
new
HMACMismatch
(
Record
SHA256
HMAC
mismatch
:
should
be
{
shouldBe
}
is
{
is
}
)
;
}
isHMACMismatch
:
function
isHMACMismatch
(
ex
)
{
return
ex
instanceof
HMACMismatch
;
}
base32ToFriendly
:
function
base32ToFriendly
(
input
)
{
return
input
.
toLowerCase
(
)
.
replace
(
/
l
/
g
"
8
"
)
.
replace
(
/
o
/
g
"
9
"
)
;
}
base32FromFriendly
:
function
base32FromFriendly
(
input
)
{
return
input
.
toUpperCase
(
)
.
replace
(
/
8
/
g
"
L
"
)
.
replace
(
/
9
/
g
"
O
"
)
;
}
encodeKeyBase32
:
function
encodeKeyBase32
(
keyData
)
{
return
Utils
.
base32ToFriendly
(
CommonUtils
.
encodeBase32
(
keyData
)
)
.
slice
(
0
SYNC_KEY_ENCODED_LENGTH
)
;
}
decodeKeyBase32
:
function
decodeKeyBase32
(
encoded
)
{
return
CommonUtils
.
decodeBase32
(
Utils
.
base32FromFriendly
(
Utils
.
normalizePassphrase
(
encoded
)
)
)
.
slice
(
0
SYNC_KEY_DECODED_LENGTH
)
;
}
jsonFilePath
(
filePath
)
{
return
OS
.
Path
.
normalize
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
filePath
+
"
.
json
"
)
)
;
}
async
jsonLoad
(
filePath
that
)
{
let
path
=
Utils
.
jsonFilePath
(
filePath
)
;
if
(
that
.
_log
&
&
that
.
_log
.
trace
)
{
that
.
_log
.
trace
(
"
Loading
json
from
disk
:
"
+
filePath
)
;
}
try
{
return
await
CommonUtils
.
readJSON
(
path
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseNoSuchFile
)
)
{
if
(
that
.
_log
)
{
that
.
_log
.
debug
(
"
Failed
to
load
json
"
e
)
;
}
}
return
null
;
}
}
async
jsonSave
(
filePath
that
obj
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
filePath
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
let
dir
=
OS
.
Path
.
dirname
(
path
)
;
await
OS
.
File
.
makeDir
(
dir
{
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Saving
json
to
disk
:
"
+
path
)
;
}
let
json
=
typeof
obj
=
=
"
function
"
?
obj
.
call
(
that
)
:
obj
;
return
CommonUtils
.
writeJSON
(
json
path
)
;
}
tryFitItems
(
records
payloadSizeMaxBytes
)
{
records
=
records
.
slice
(
)
;
let
encoder
=
Utils
.
utf8Encoder
;
const
computeSerializedSize
=
(
)
=
>
encoder
.
encode
(
JSON
.
stringify
(
records
)
)
.
byteLength
;
let
size
=
computeSerializedSize
(
)
;
const
maxSerializedSize
=
payloadSizeMaxBytes
/
4
*
3
-
1500
;
if
(
maxSerializedSize
<
0
)
{
return
[
]
;
}
if
(
size
>
maxSerializedSize
)
{
let
cutoff
=
Math
.
ceil
(
records
.
length
*
maxSerializedSize
/
size
)
;
records
=
records
.
slice
(
0
cutoff
+
1
)
;
while
(
computeSerializedSize
(
)
>
maxSerializedSize
)
{
records
.
pop
(
)
;
}
}
return
records
;
}
jsonMove
(
aFrom
aTo
that
)
{
let
pathFrom
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
aFrom
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
let
pathTo
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
aTo
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Moving
"
+
pathFrom
+
"
to
"
+
pathTo
)
;
}
return
OS
.
File
.
move
(
pathFrom
pathTo
{
noOverwrite
:
true
}
)
;
}
jsonRemove
(
filePath
that
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
filePath
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Deleting
"
+
path
)
;
}
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
isPassphrase
(
s
)
{
if
(
s
)
{
return
/
^
[
abcdefghijkmnpqrstuvwxyz23456789
]
{
26
}
/
.
test
(
Utils
.
normalizePassphrase
(
s
)
)
;
}
return
false
;
}
normalizePassphrase
:
function
normalizePassphrase
(
pp
)
{
pp
=
pp
.
trim
(
)
.
toLowerCase
(
)
;
if
(
pp
.
length
=
=
23
&
&
[
5
11
17
]
.
every
(
i
=
>
pp
[
i
]
=
=
"
-
"
)
)
{
return
pp
.
slice
(
0
5
)
+
pp
.
slice
(
6
11
)
+
pp
.
slice
(
12
17
)
+
pp
.
slice
(
18
23
)
;
}
if
(
pp
.
length
=
=
31
&
&
[
1
7
13
19
25
]
.
every
(
i
=
>
pp
[
i
]
=
=
"
-
"
)
)
{
return
pp
.
slice
(
0
1
)
+
pp
.
slice
(
2
7
)
+
pp
.
slice
(
8
13
)
+
pp
.
slice
(
14
19
)
+
pp
.
slice
(
20
25
)
+
pp
.
slice
(
26
31
)
;
}
return
pp
;
}
arraySub
:
function
arraySub
(
minuend
subtrahend
)
{
if
(
!
minuend
.
length
|
|
!
subtrahend
.
length
)
{
return
minuend
;
}
let
setSubtrahend
=
new
Set
(
subtrahend
)
;
return
minuend
.
filter
(
i
=
>
!
setSubtrahend
.
has
(
i
)
)
;
}
arrayUnion
:
function
arrayUnion
(
foo
bar
)
{
if
(
!
foo
.
length
)
{
return
bar
;
}
if
(
!
bar
.
length
)
{
return
foo
;
}
return
foo
.
concat
(
Utils
.
arraySub
(
bar
foo
)
)
;
}
setAddAll
(
set
items
)
{
for
(
let
item
of
items
)
{
set
.
add
(
item
)
;
}
return
set
;
}
setDeleteAll
(
set
items
)
{
for
(
let
item
of
items
)
{
set
.
delete
(
item
)
;
}
return
set
;
}
subsetOfSize
(
items
size
)
{
let
result
=
new
Set
(
)
;
let
count
=
0
;
for
(
let
item
of
items
)
{
if
(
count
+
+
=
=
size
)
{
return
result
;
}
result
.
add
(
item
)
;
}
return
result
;
}
bind2
:
function
Async_bind2
(
object
method
)
{
return
function
innerBind
(
)
{
return
method
.
apply
(
object
arguments
)
;
}
;
}
mpLocked
(
)
{
return
!
cryptoSDR
.
isLoggedIn
;
}
ensureMPUnlocked
(
)
{
if
(
cryptoSDR
.
uiBusy
)
{
return
false
;
}
try
{
cryptoSDR
.
encrypt
(
"
bacon
"
)
;
return
true
;
}
catch
(
e
)
{
}
return
false
;
}
calculateBackoff
:
function
calculateBackoff
(
attempts
baseInterval
statusInterval
)
{
let
backoffInterval
=
attempts
*
(
Math
.
floor
(
Math
.
random
(
)
*
baseInterval
)
+
baseInterval
)
;
return
Math
.
max
(
Math
.
min
(
backoffInterval
MAXIMUM_BACKOFF_INTERVAL
)
statusInterval
)
;
}
getSyncCredentialsHosts
(
)
{
let
result
=
new
Set
(
)
;
result
.
add
(
FxAccountsCommon
.
FXA_PWDMGR_HOST
)
;
return
result
;
}
getDefaultDeviceName
(
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
user
=
env
.
get
(
"
USER
"
)
|
|
env
.
get
(
"
USERNAME
"
)
|
|
Svc
.
Prefs
.
get
(
"
account
"
)
|
|
Svc
.
Prefs
.
get
(
"
username
"
)
;
if
(
user
=
=
"
%
USERNAME
%
"
&
&
env
.
get
(
"
USERNAME
"
)
)
{
user
=
env
.
get
(
"
USERNAME
"
)
;
}
let
brand
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
let
brandName
=
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
let
hostname
;
try
{
hostname
=
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
.
myHostName
;
}
catch
(
ex
)
{
Cu
.
reportError
(
ex
)
;
}
let
system
=
Services
.
sysinfo
.
get
(
"
device
"
)
|
|
hostname
|
|
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
.
oscpu
;
let
syncStrings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
weave
/
locale
/
sync
.
properties
"
)
;
return
syncStrings
.
formatStringFromName
(
"
client
.
name2
"
[
user
brandName
system
]
3
)
;
}
getDeviceName
(
)
{
let
deviceName
=
localDeviceName
;
if
(
deviceName
=
=
=
"
"
)
{
deviceName
=
this
.
getDefaultDeviceName
(
)
;
Svc
.
Prefs
.
set
(
"
client
.
name
"
deviceName
)
;
}
return
deviceName
;
}
defineLazyIDProperty
(
object
propName
prefName
)
{
const
storage
=
{
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
storage
"
value
"
prefName
"
"
)
;
Object
.
defineProperty
(
object
propName
{
configurable
:
true
enumerable
:
true
get
(
)
{
let
value
=
storage
.
value
;
if
(
!
value
)
{
value
=
Utils
.
makeGUID
(
)
;
Services
.
prefs
.
setStringPref
(
prefName
value
)
;
}
return
value
;
}
set
(
value
)
{
Services
.
prefs
.
setStringPref
(
prefName
value
)
;
}
}
)
;
}
getDeviceType
(
)
{
return
localDeviceType
;
}
formatTimestamp
(
date
)
{
let
year
=
String
(
date
.
getFullYear
(
)
)
;
let
month
=
String
(
date
.
getMonth
(
)
+
1
)
.
padStart
(
2
"
0
"
)
;
let
day
=
String
(
date
.
getDate
(
)
)
.
padStart
(
2
"
0
"
)
;
let
hours
=
String
(
date
.
getHours
(
)
)
.
padStart
(
2
"
0
"
)
;
let
minutes
=
String
(
date
.
getMinutes
(
)
)
.
padStart
(
2
"
0
"
)
;
let
seconds
=
String
(
date
.
getSeconds
(
)
)
.
padStart
(
2
"
0
"
)
;
return
{
year
}
-
{
month
}
-
{
day
}
{
hours
}
:
{
minutes
}
:
{
seconds
}
;
}
*
walkTree
(
tree
parent
=
null
)
{
if
(
tree
)
{
if
(
parent
)
{
yield
[
tree
parent
]
;
}
if
(
tree
.
children
)
{
for
(
let
child
of
tree
.
children
)
{
yield
*
Utils
.
walkTree
(
child
tree
)
;
}
}
}
}
}
;
class
SerializableSet
extends
Set
{
toJSON
(
)
{
return
Array
.
from
(
this
)
;
}
}
XPCOMUtils
.
defineLazyGetter
(
Utils
"
_utf8Converter
"
function
(
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
return
converter
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
Utils
"
utf8Encoder
"
(
)
=
>
new
TextEncoder
(
"
utf
-
8
"
)
)
;
var
Svc
=
{
}
;
Svc
.
Prefs
=
new
Preferences
(
PREFS_BRANCH
)
;
Svc
.
Obs
=
Observers
;
Svc
.
Obs
.
add
(
"
xpcom
-
shutdown
"
function
(
)
{
for
(
let
name
in
Svc
)
{
delete
Svc
[
name
]
;
}
}
)
;
