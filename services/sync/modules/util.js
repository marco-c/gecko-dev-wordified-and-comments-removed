this
.
EXPORTED_SYMBOLS
=
[
"
Utils
"
"
Svc
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
FxAccountsCommon
"
function
(
)
{
let
FxAccountsCommon
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
FxAccountsCommon
)
;
return
FxAccountsCommon
;
}
)
;
class
LockException
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
LockException
"
;
}
}
class
HMACMismatch
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
HMACMismatch
"
;
}
}
this
.
Utils
=
{
nextTick
:
CommonUtils
.
nextTick
namedTimer
:
CommonUtils
.
namedTimer
makeURI
:
CommonUtils
.
makeURI
encodeUTF8
:
CommonUtils
.
encodeUTF8
decodeUTF8
:
CommonUtils
.
decodeUTF8
safeAtoB
:
CommonUtils
.
safeAtoB
byteArrayToString
:
CommonUtils
.
byteArrayToString
bytesAsHex
:
CommonUtils
.
bytesAsHex
hexToBytes
:
CommonUtils
.
hexToBytes
encodeBase32
:
CommonUtils
.
encodeBase32
decodeBase32
:
CommonUtils
.
decodeBase32
generateRandomBytes
:
CryptoUtils
.
generateRandomBytes
computeHTTPMACSHA1
:
CryptoUtils
.
computeHTTPMACSHA1
digestUTF8
:
CryptoUtils
.
digestUTF8
digestBytes
:
CryptoUtils
.
digestBytes
sha1
:
CryptoUtils
.
sha1
sha1Base32
:
CryptoUtils
.
sha1Base32
sha256
:
CryptoUtils
.
sha256
makeHMACKey
:
CryptoUtils
.
makeHMACKey
makeHMACHasher
:
CryptoUtils
.
makeHMACHasher
hkdfExpand
:
CryptoUtils
.
hkdfExpand
pbkdf2Generate
:
CryptoUtils
.
pbkdf2Generate
getHTTPMACSHA1Header
:
CryptoUtils
.
getHTTPMACSHA1Header
_userAgent
:
null
get
userAgent
(
)
{
if
(
!
this
.
_userAgent
)
{
let
hph
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
;
this
.
_userAgent
=
Services
.
appinfo
.
name
+
"
/
"
+
Services
.
appinfo
.
version
+
"
(
"
+
hph
.
oscpu
+
"
)
"
+
"
FxSync
/
"
+
WEAVE_VERSION
+
"
.
"
+
Services
.
appinfo
.
appBuildID
+
"
.
"
;
}
return
this
.
_userAgent
+
Svc
.
Prefs
.
get
(
"
client
.
type
"
"
desktop
"
)
;
}
catch
(
func
exceptionCallback
)
{
let
thisArg
=
this
;
return
async
function
WrappedCatch
(
)
{
try
{
return
await
func
.
call
(
thisArg
)
;
}
catch
(
ex
)
{
thisArg
.
_log
.
debug
(
"
Exception
calling
"
+
(
func
.
name
|
|
"
anonymous
function
"
)
ex
)
;
if
(
exceptionCallback
)
{
return
exceptionCallback
.
call
(
thisArg
ex
)
;
}
return
null
;
}
}
;
}
throwLockException
(
label
)
{
throw
new
LockException
(
Could
not
acquire
lock
.
Label
:
"
{
label
}
"
.
)
;
}
lock
(
label
func
)
{
let
thisArg
=
this
;
return
async
function
WrappedLock
(
)
{
if
(
!
thisArg
.
lock
(
)
)
{
Utils
.
throwLockException
(
label
)
;
}
try
{
return
await
func
.
call
(
thisArg
)
;
}
finally
{
thisArg
.
unlock
(
)
;
}
}
;
}
isLockException
:
function
isLockException
(
ex
)
{
return
ex
instanceof
LockException
;
}
notify
(
prefix
)
{
return
function
NotifyMaker
(
name
data
func
)
{
let
thisArg
=
this
;
let
notify
=
function
(
state
subject
)
{
let
mesg
=
prefix
+
name
+
"
:
"
+
state
;
thisArg
.
_log
.
trace
(
"
Event
:
"
+
mesg
)
;
Observers
.
notify
(
mesg
subject
data
)
;
}
;
return
async
function
WrappedNotify
(
)
{
notify
(
"
start
"
null
)
;
try
{
let
ret
=
await
func
.
call
(
thisArg
)
;
notify
(
"
finish
"
ret
)
;
return
ret
;
}
catch
(
ex
)
{
notify
(
"
error
"
ex
)
;
throw
ex
;
}
}
;
}
;
}
makeGUID
:
function
makeGUID
(
)
{
return
CommonUtils
.
encodeBase64URL
(
Utils
.
generateRandomBytes
(
9
)
)
;
}
_base64url_regex
:
/
^
[
-
abcdefghijklmnopqrstuvwxyz0123456789_
]
{
12
}
/
i
checkGUID
:
function
checkGUID
(
guid
)
{
return
!
!
guid
&
&
this
.
_base64url_regex
.
test
(
guid
)
;
}
deferGetSet
:
function
Utils_deferGetSet
(
obj
defer
prop
)
{
if
(
Array
.
isArray
(
prop
)
)
return
prop
.
map
(
prop
=
>
Utils
.
deferGetSet
(
obj
defer
prop
)
)
;
let
prot
=
obj
.
prototype
;
if
(
!
prot
.
__lookupGetter__
(
prop
)
)
{
prot
.
__defineGetter__
(
prop
function
(
)
{
return
this
[
defer
]
[
prop
]
;
}
)
;
}
if
(
!
prot
.
__lookupSetter__
(
prop
)
)
{
prot
.
__defineSetter__
(
prop
function
(
val
)
{
this
[
defer
]
[
prop
]
=
val
;
}
)
;
}
}
deepEquals
:
function
eq
(
a
b
)
{
if
(
a
=
=
=
b
)
return
true
;
if
(
typeof
a
!
=
"
object
"
|
|
typeof
b
!
=
"
object
"
)
return
false
;
if
(
a
=
=
=
null
|
|
b
=
=
=
null
)
return
false
;
for
(
let
k
in
a
)
if
(
!
eq
(
a
[
k
]
b
[
k
]
)
)
return
false
;
for
(
let
k
in
b
)
if
(
!
(
k
in
a
)
&
&
!
eq
(
a
[
k
]
b
[
k
]
)
)
return
false
;
return
true
;
}
throwHMACMismatch
:
function
throwHMACMismatch
(
shouldBe
is
)
{
throw
new
HMACMismatch
(
Record
SHA256
HMAC
mismatch
:
should
be
{
shouldBe
}
is
{
is
}
)
;
}
isHMACMismatch
:
function
isHMACMismatch
(
ex
)
{
return
ex
instanceof
HMACMismatch
;
}
base32ToFriendly
:
function
base32ToFriendly
(
input
)
{
return
input
.
toLowerCase
(
)
.
replace
(
/
l
/
g
"
8
"
)
.
replace
(
/
o
/
g
"
9
"
)
;
}
base32FromFriendly
:
function
base32FromFriendly
(
input
)
{
return
input
.
toUpperCase
(
)
.
replace
(
/
8
/
g
"
L
"
)
.
replace
(
/
9
/
g
"
O
"
)
;
}
encodeKeyBase32
:
function
encodeKeyBase32
(
keyData
)
{
return
Utils
.
base32ToFriendly
(
Utils
.
encodeBase32
(
keyData
)
)
.
slice
(
0
SYNC_KEY_ENCODED_LENGTH
)
;
}
decodeKeyBase32
:
function
decodeKeyBase32
(
encoded
)
{
return
Utils
.
decodeBase32
(
Utils
.
base32FromFriendly
(
Utils
.
normalizePassphrase
(
encoded
)
)
)
.
slice
(
0
SYNC_KEY_DECODED_LENGTH
)
;
}
jsonFilePath
(
filePath
)
{
return
OS
.
Path
.
normalize
(
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
filePath
+
"
.
json
"
)
)
;
}
async
jsonLoad
(
filePath
that
)
{
let
path
=
Utils
.
jsonFilePath
(
filePath
)
;
if
(
that
.
_log
&
&
that
.
_log
.
trace
)
{
that
.
_log
.
trace
(
"
Loading
json
from
disk
:
"
+
filePath
)
;
}
try
{
return
await
CommonUtils
.
readJSON
(
path
)
;
}
catch
(
e
)
{
if
(
!
(
e
instanceof
OS
.
File
.
Error
&
&
e
.
becauseNoSuchFile
)
)
{
if
(
that
.
_log
)
{
that
.
_log
.
debug
(
"
Failed
to
load
json
"
e
)
;
}
}
return
null
;
}
}
async
jsonSave
(
filePath
that
obj
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
filePath
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
let
dir
=
OS
.
Path
.
dirname
(
path
)
;
await
OS
.
File
.
makeDir
(
dir
{
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Saving
json
to
disk
:
"
+
path
)
;
}
let
json
=
typeof
obj
=
=
"
function
"
?
obj
.
call
(
that
)
:
obj
;
return
CommonUtils
.
writeJSON
(
json
path
)
;
}
jsonMove
(
aFrom
aTo
that
)
{
let
pathFrom
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
aFrom
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
let
pathTo
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
aTo
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Moving
"
+
pathFrom
+
"
to
"
+
pathTo
)
;
}
return
OS
.
File
.
move
(
pathFrom
pathTo
{
noOverwrite
:
true
}
)
;
}
jsonRemove
(
filePath
that
)
{
let
path
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
.
.
.
(
filePath
+
"
.
json
"
)
.
split
(
"
/
"
)
)
;
if
(
that
.
_log
)
{
that
.
_log
.
trace
(
"
Deleting
"
+
path
)
;
}
return
OS
.
File
.
remove
(
path
{
ignoreAbsent
:
true
}
)
;
}
isPassphrase
(
s
)
{
if
(
s
)
{
return
/
^
[
abcdefghijkmnpqrstuvwxyz23456789
]
{
26
}
/
.
test
(
Utils
.
normalizePassphrase
(
s
)
)
;
}
return
false
;
}
normalizePassphrase
:
function
normalizePassphrase
(
pp
)
{
pp
=
pp
.
trim
(
)
.
toLowerCase
(
)
;
if
(
pp
.
length
=
=
23
&
&
[
5
11
17
]
.
every
(
i
=
>
pp
[
i
]
=
=
"
-
"
)
)
{
return
pp
.
slice
(
0
5
)
+
pp
.
slice
(
6
11
)
+
pp
.
slice
(
12
17
)
+
pp
.
slice
(
18
23
)
;
}
if
(
pp
.
length
=
=
31
&
&
[
1
7
13
19
25
]
.
every
(
i
=
>
pp
[
i
]
=
=
"
-
"
)
)
{
return
pp
.
slice
(
0
1
)
+
pp
.
slice
(
2
7
)
+
pp
.
slice
(
8
13
)
+
pp
.
slice
(
14
19
)
+
pp
.
slice
(
20
25
)
+
pp
.
slice
(
26
31
)
;
}
return
pp
;
}
arraySub
:
function
arraySub
(
minuend
subtrahend
)
{
if
(
!
minuend
.
length
|
|
!
subtrahend
.
length
)
return
minuend
;
let
setSubtrahend
=
new
Set
(
subtrahend
)
;
return
minuend
.
filter
(
i
=
>
!
setSubtrahend
.
has
(
i
)
)
;
}
arrayUnion
:
function
arrayUnion
(
foo
bar
)
{
if
(
!
foo
.
length
)
return
bar
;
if
(
!
bar
.
length
)
return
foo
;
return
foo
.
concat
(
Utils
.
arraySub
(
bar
foo
)
)
;
}
bind2
:
function
Async_bind2
(
object
method
)
{
return
function
innerBind
(
)
{
return
method
.
apply
(
object
arguments
)
;
}
;
}
mpEnabled
:
function
mpEnabled
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
return
token
.
hasPassword
;
}
mpLocked
:
function
mpLocked
(
)
{
let
tokenDB
=
Cc
[
"
mozilla
.
org
/
security
/
pk11tokendb
;
1
"
]
.
getService
(
Ci
.
nsIPK11TokenDB
)
;
let
token
=
tokenDB
.
getInternalKeyToken
(
)
;
return
token
.
hasPassword
&
&
!
token
.
isLoggedIn
(
)
;
}
ensureMPUnlocked
:
function
ensureMPUnlocked
(
)
{
if
(
!
Utils
.
mpLocked
(
)
)
{
return
true
;
}
let
sdr
=
Cc
[
"
mozilla
.
org
/
security
/
sdr
;
1
"
]
.
getService
(
Ci
.
nsISecretDecoderRing
)
;
try
{
sdr
.
encryptString
(
"
bacon
"
)
;
return
true
;
}
catch
(
e
)
{
}
return
false
;
}
calculateBackoff
:
function
calculateBackoff
(
attempts
baseInterval
statusInterval
)
{
let
backoffInterval
=
attempts
*
(
Math
.
floor
(
Math
.
random
(
)
*
baseInterval
)
+
baseInterval
)
;
return
Math
.
max
(
Math
.
min
(
backoffInterval
MAXIMUM_BACKOFF_INTERVAL
)
statusInterval
)
;
}
getSyncCredentialsHosts
(
)
{
let
result
=
new
Set
(
this
.
getSyncCredentialsHostsLegacy
(
)
)
;
for
(
let
host
of
this
.
getSyncCredentialsHostsFxA
(
)
)
{
result
.
add
(
host
)
;
}
return
result
;
}
getSyncCredentialsHostsLegacy
(
)
{
return
new
Set
(
[
PWDMGR_HOST
]
)
;
}
getSyncCredentialsHostsFxA
(
)
{
let
result
=
new
Set
(
)
;
result
.
add
(
FxAccountsCommon
.
FXA_PWDMGR_HOST
)
;
return
result
;
}
getDefaultDeviceName
(
)
{
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
let
user
=
env
.
get
(
"
USER
"
)
|
|
env
.
get
(
"
USERNAME
"
)
|
|
Svc
.
Prefs
.
get
(
"
account
"
)
|
|
Svc
.
Prefs
.
get
(
"
username
"
)
;
if
(
user
=
=
"
%
USERNAME
%
"
&
&
env
.
get
(
"
USERNAME
"
)
)
{
user
=
env
.
get
(
"
USERNAME
"
)
;
}
let
brand
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
let
brandName
=
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
let
system
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
.
get
(
"
device
"
)
|
|
Cc
[
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
]
.
getService
(
Ci
.
nsIDNSService
)
.
myHostName
|
|
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
.
oscpu
;
let
syncStrings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
weave
/
locale
/
sync
.
properties
"
)
;
return
syncStrings
.
formatStringFromName
(
"
client
.
name2
"
[
user
brandName
system
]
3
)
;
}
getDeviceName
(
)
{
const
deviceName
=
Svc
.
Prefs
.
get
(
"
client
.
name
"
"
"
)
;
if
(
deviceName
=
=
=
"
"
)
{
return
this
.
getDefaultDeviceName
(
)
;
}
return
deviceName
;
}
getDeviceType
(
)
{
return
Svc
.
Prefs
.
get
(
"
client
.
type
"
DEVICE_TYPE_DESKTOP
)
;
}
formatTimestamp
(
date
)
{
let
year
=
String
(
date
.
getFullYear
(
)
)
;
let
month
=
String
(
date
.
getMonth
(
)
+
1
)
.
padStart
(
2
"
0
"
)
;
let
day
=
String
(
date
.
getDate
(
)
)
.
padStart
(
2
"
0
"
)
;
let
hours
=
String
(
date
.
getHours
(
)
)
.
padStart
(
2
"
0
"
)
;
let
minutes
=
String
(
date
.
getMinutes
(
)
)
.
padStart
(
2
"
0
"
)
;
let
seconds
=
String
(
date
.
getSeconds
(
)
)
.
padStart
(
2
"
0
"
)
;
return
{
year
}
-
{
month
}
-
{
day
}
{
hours
}
:
{
minutes
}
:
{
seconds
}
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
Utils
"
_utf8Converter
"
function
(
)
{
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
return
converter
;
}
)
;
this
.
Svc
=
{
}
;
Svc
.
Prefs
=
new
Preferences
(
PREFS_BRANCH
)
;
Svc
.
Obs
=
Observers
;
Svc
.
Obs
.
add
(
"
xpcom
-
shutdown
"
function
(
)
{
for
(
let
name
in
Svc
)
delete
Svc
[
name
]
;
}
)
;
