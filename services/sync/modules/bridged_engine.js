const
{
Changeset
SyncEngine
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
RawCryptoWrapper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
sys
.
mjs
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
}
)
;
var
EXPORTED_SYMBOLS
=
[
"
BridgeWrapperXPCOM
"
"
BridgedEngine
"
"
BridgedStore
"
"
LogAdapter
"
]
;
class
BridgedStore
{
constructor
(
name
engine
)
{
if
(
!
engine
)
{
throw
new
Error
(
"
Store
must
be
associated
with
an
Engine
instance
.
"
)
;
}
this
.
engine
=
engine
;
this
.
_log
=
lazy
.
Log
.
repository
.
getLogger
(
Sync
.
Engine
.
{
name
}
.
Store
)
;
this
.
_batchChunkSize
=
500
;
}
async
applyIncomingBatch
(
records
)
{
for
(
let
chunk
of
lazy
.
PlacesUtils
.
chunkArray
(
records
this
.
_batchChunkSize
)
)
{
let
incomingEnvelopesAsJSON
=
chunk
.
map
(
record
=
>
JSON
.
stringify
(
record
.
toIncomingBso
(
)
)
)
;
this
.
_log
.
trace
(
"
incoming
envelopes
"
incomingEnvelopesAsJSON
)
;
await
this
.
engine
.
_bridge
.
storeIncoming
(
incomingEnvelopesAsJSON
)
;
}
return
[
]
;
}
async
wipe
(
)
{
await
this
.
engine
.
_bridge
.
wipe
(
)
;
}
}
class
BridgedRecord
extends
RawCryptoWrapper
{
static
fromOutgoingBso
(
collection
bso
)
{
if
(
typeof
bso
.
id
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Outgoing
BSO
missing
ID
"
)
;
}
if
(
typeof
bso
.
payload
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Outgoing
BSO
missing
payload
"
)
;
}
let
record
=
new
BridgedRecord
(
collection
bso
.
id
)
;
record
.
cleartext
=
bso
.
payload
;
return
record
;
}
transformBeforeEncrypt
(
cleartext
)
{
if
(
typeof
cleartext
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Outgoing
bridged
engine
records
must
be
strings
"
)
;
}
return
cleartext
;
}
transformAfterDecrypt
(
cleartext
)
{
if
(
typeof
cleartext
!
=
"
string
"
)
{
throw
new
TypeError
(
"
Incoming
bridged
engine
records
must
be
strings
"
)
;
}
return
cleartext
;
}
toIncomingBso
(
)
{
return
{
id
:
this
.
data
.
id
modified
:
this
.
data
.
modified
payload
:
this
.
cleartext
}
;
}
}
class
BridgeError
extends
Error
{
constructor
(
code
message
)
{
super
(
message
)
;
this
.
name
=
"
BridgeError
"
;
this
.
result
=
code
;
}
}
class
InterruptedError
extends
Error
{
constructor
(
message
)
{
super
(
message
)
;
this
.
name
=
"
InterruptedError
"
;
}
}
class
LogAdapter
{
constructor
(
log
)
{
this
.
log
=
log
;
}
get
maxLevel
(
)
{
let
level
=
this
.
log
.
level
;
if
(
level
<
=
lazy
.
Log
.
Level
.
All
)
{
return
Ci
.
mozIServicesLogSink
.
LEVEL_TRACE
;
}
if
(
level
<
=
lazy
.
Log
.
Level
.
Info
)
{
return
Ci
.
mozIServicesLogSink
.
LEVEL_DEBUG
;
}
if
(
level
<
=
lazy
.
Log
.
Level
.
Warn
)
{
return
Ci
.
mozIServicesLogSink
.
LEVEL_WARN
;
}
if
(
level
<
=
lazy
.
Log
.
Level
.
Error
)
{
return
Ci
.
mozIServicesLogSink
.
LEVEL_ERROR
;
}
return
Ci
.
mozIServicesLogSink
.
LEVEL_OFF
;
}
trace
(
message
)
{
this
.
log
.
trace
(
message
)
;
}
debug
(
message
)
{
this
.
log
.
debug
(
message
)
;
}
warn
(
message
)
{
this
.
log
.
warn
(
message
)
;
}
error
(
message
)
{
this
.
log
.
error
(
message
)
;
}
}
class
BridgeWrapperXPCOM
{
constructor
(
component
)
{
this
.
comp
=
component
;
}
get
storageVersion
(
)
{
return
this
.
comp
.
storageVersion
;
}
get
allowSkippedRecord
(
)
{
return
this
.
comp
.
allowSkippedRecord
;
}
get
logger
(
)
{
return
this
.
comp
.
logger
;
}
lastSync
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
getLastSync
)
;
}
setLastSync
(
lastSyncMillis
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
setLastSync
lastSyncMillis
)
;
}
getSyncId
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
getSyncId
)
;
}
resetSyncId
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
resetSyncId
)
;
}
ensureCurrentSyncId
(
newSyncId
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
ensureCurrentSyncId
newSyncId
)
;
}
syncStarted
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
syncStarted
)
;
}
storeIncoming
(
incomingEnvelopesAsJSON
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
storeIncoming
incomingEnvelopesAsJSON
)
;
}
apply
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
apply
)
;
}
setUploaded
(
newTimestampMillis
uploadedIds
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
setUploaded
newTimestampMillis
uploadedIds
)
;
}
syncFinished
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
syncFinished
)
;
}
reset
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
reset
)
;
}
wipe
(
)
{
return
BridgeWrapperXPCOM
.
#
promisify
(
this
.
comp
.
wipe
)
;
}
static
#
promisify
(
func
.
.
.
params
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
func
(
.
.
.
params
{
handleSuccess
:
resolve
handleError
(
code
message
)
{
reject
(
transformError
(
code
message
)
)
;
}
}
)
;
}
)
;
}
}
function
BridgedEngine
(
name
service
)
{
SyncEngine
.
call
(
this
name
service
)
;
}
BridgedEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_bridge
:
null
_trackerObj
:
Tracker
get
_recordObj
(
)
{
return
BridgedRecord
;
}
set
_recordObj
(
obj
)
{
throw
new
TypeError
(
"
Don
'
t
override
the
record
class
for
bridged
engines
"
)
;
}
get
_storeObj
(
)
{
return
BridgedStore
;
}
set
_storeObj
(
obj
)
{
throw
new
TypeError
(
"
Don
'
t
override
the
store
class
for
bridged
engines
"
)
;
}
get
version
(
)
{
return
this
.
_bridge
.
storageVersion
;
}
get
allowSkippedRecord
(
)
{
return
this
.
_bridge
.
allowSkippedRecord
;
}
async
getSyncID
(
)
{
let
syncID
=
await
this
.
_bridge
.
getSyncId
(
)
;
return
syncID
;
}
async
resetSyncID
(
)
{
await
this
.
_deleteServerCollection
(
)
;
let
newSyncID
=
await
this
.
resetLocalSyncID
(
)
;
return
newSyncID
;
}
async
resetLocalSyncID
(
)
{
let
newSyncID
=
await
this
.
_bridge
.
resetSyncId
(
)
;
return
newSyncID
;
}
async
ensureCurrentSyncID
(
newSyncID
)
{
let
assignedSyncID
=
await
this
.
_bridge
.
ensureCurrentSyncId
(
newSyncID
)
;
return
assignedSyncID
;
}
async
getLastSync
(
)
{
let
lastSyncMS
=
await
this
.
_bridge
.
lastSync
(
)
;
return
Math
.
round
(
lastSyncMS
/
10
)
/
100
;
}
async
setLastSync
(
lastSyncSeconds
)
{
await
this
.
_bridge
.
setLastSync
(
Math
.
round
(
lastSyncSeconds
*
1000
)
)
;
}
async
pullChanges
(
)
{
return
{
}
;
}
async
trackRemainingChanges
(
)
{
await
this
.
_bridge
.
syncFinished
(
)
;
}
_deleteId
(
id
)
{
this
.
_noteDeletedId
(
id
)
;
}
async
_reconcile
(
)
{
return
true
;
}
async
_syncStartup
(
)
{
await
super
.
_syncStartup
(
)
;
await
this
.
_bridge
.
syncStarted
(
)
;
}
async
_processIncoming
(
newitems
)
{
await
super
.
_processIncoming
(
newitems
)
;
let
outgoingBsosAsJSON
=
await
this
.
_bridge
.
apply
(
)
;
let
changeset
=
{
}
;
for
(
let
bsoAsJSON
of
outgoingBsosAsJSON
)
{
this
.
_log
.
trace
(
"
outgoing
bso
"
bsoAsJSON
)
;
let
record
=
BridgedRecord
.
fromOutgoingBso
(
this
.
name
JSON
.
parse
(
bsoAsJSON
)
)
;
changeset
[
record
.
id
]
=
{
synced
:
false
record
}
;
}
this
.
_modified
.
replace
(
changeset
)
;
}
async
_onRecordsWritten
(
succeeded
failed
serverModifiedTime
)
{
let
serverModifiedMS
=
Math
.
round
(
serverModifiedTime
*
1000
)
;
await
this
.
_bridge
.
setUploaded
(
Math
.
floor
(
serverModifiedMS
)
succeeded
)
;
}
async
_createTombstone
(
)
{
throw
new
Error
(
"
Bridged
engines
don
'
t
support
weak
uploads
"
)
;
}
async
_createRecord
(
id
)
{
let
change
=
this
.
_modified
.
changes
[
id
]
;
if
(
!
change
)
{
throw
new
TypeError
(
"
Can
'
t
create
record
for
unchanged
item
"
)
;
}
return
change
.
record
;
}
async
_resetClient
(
)
{
await
super
.
_resetClient
(
)
;
await
this
.
_bridge
.
reset
(
)
;
}
}
;
function
transformError
(
code
message
)
{
switch
(
code
)
{
case
Cr
.
NS_ERROR_ABORT
:
return
new
InterruptedError
(
message
)
;
default
:
return
new
BridgeError
(
code
message
)
;
}
}
class
BridgedChangeset
extends
Changeset
{
getModifiedTimestamp
(
id
)
{
throw
new
Error
(
"
Don
'
t
use
timestamps
to
resolve
bridged
engine
conflicts
"
)
;
}
has
(
id
)
{
throw
new
Error
(
"
Don
'
t
use
the
changeset
to
resolve
bridged
engine
conflicts
"
)
;
}
delete
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
change
.
synced
=
true
;
}
}
ids
(
)
{
let
results
=
[
]
;
for
(
let
id
in
this
.
changes
)
{
if
(
!
this
.
changes
[
id
]
.
synced
)
{
results
.
push
(
id
)
;
}
}
return
results
;
}
}
