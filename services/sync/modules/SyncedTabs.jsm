"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
SyncedTabs
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
weaveXPCService
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
function
escapeRegExp
(
string
)
{
return
string
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
;
}
const
TOPIC_TABS_CHANGED
=
"
services
.
sync
.
tabs
.
changed
"
;
const
TABS_FRESH_ENOUGH_INTERVAL
=
30
;
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
RemoteTabs
"
)
;
(
function
(
)
{
let
level
=
Preferences
.
get
(
"
services
.
sync
.
log
.
logger
.
tabs
"
)
;
if
(
level
)
{
let
appender
=
new
Log
.
DumpAppender
(
)
;
log
.
level
=
appender
.
level
=
Log
.
Level
[
level
]
|
|
Log
.
Level
.
Debug
;
log
.
addAppender
(
appender
)
;
}
}
)
(
)
;
let
SyncedTabsInternal
=
{
async
_makeTab
(
client
tab
url
showRemoteIcons
)
{
let
icon
;
if
(
showRemoteIcons
)
{
icon
=
tab
.
icon
;
}
if
(
!
icon
)
{
try
{
icon
=
(
await
PlacesUtils
.
promiseFaviconLinkUrl
(
url
)
)
.
spec
;
}
catch
(
ex
)
{
}
}
if
(
!
icon
)
{
icon
=
"
"
;
}
return
{
type
:
"
tab
"
title
:
tab
.
title
|
|
url
url
icon
client
:
client
.
id
lastUsed
:
tab
.
lastUsed
}
;
}
async
_makeClient
(
client
)
{
return
{
id
:
client
.
id
type
:
"
client
"
name
:
Weave
.
Service
.
clientsEngine
.
getClientName
(
client
.
id
)
isMobile
:
Weave
.
Service
.
clientsEngine
.
isMobile
(
client
.
id
)
lastModified
:
client
.
lastModified
*
1000
tabs
:
[
]
}
;
}
_tabMatchesFilter
(
tab
filter
)
{
let
reFilter
=
new
RegExp
(
escapeRegExp
(
filter
)
"
i
"
)
;
return
tab
.
url
.
match
(
reFilter
)
|
|
tab
.
title
.
match
(
reFilter
)
;
}
async
getTabClients
(
filter
)
{
log
.
info
(
"
Generating
tab
list
with
filter
"
filter
)
;
let
result
=
[
]
;
if
(
!
weaveXPCService
.
ready
)
{
log
.
debug
(
"
Sync
isn
'
t
yet
ready
so
returning
an
empty
tab
list
"
)
;
return
result
;
}
const
showRemoteIcons
=
Preferences
.
get
(
"
services
.
sync
.
syncedTabs
.
showRemoteIcons
"
true
)
;
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
let
ntabs
=
0
;
for
(
let
client
of
Object
.
values
(
engine
.
getAllClients
(
)
)
)
{
if
(
!
Weave
.
Service
.
clientsEngine
.
remoteClientExists
(
client
.
id
)
)
{
continue
;
}
let
clientRepr
=
await
this
.
_makeClient
(
client
)
;
log
.
debug
(
"
Processing
client
"
clientRepr
)
;
for
(
let
tab
of
client
.
tabs
)
{
let
url
=
tab
.
urlHistory
[
0
]
;
log
.
debug
(
"
remote
tab
"
url
)
;
if
(
!
url
)
{
continue
;
}
let
tabRepr
=
await
this
.
_makeTab
(
client
tab
url
showRemoteIcons
)
;
if
(
filter
&
&
!
this
.
_tabMatchesFilter
(
tabRepr
filter
)
)
{
continue
;
}
clientRepr
.
tabs
.
push
(
tabRepr
)
;
}
ntabs
+
=
clientRepr
.
tabs
.
length
;
result
.
push
(
clientRepr
)
;
}
log
.
info
(
Final
tab
list
has
{
result
.
length
}
clients
with
{
ntabs
}
tabs
.
)
;
return
result
;
}
syncTabs
(
force
)
{
if
(
!
force
)
{
let
lastFetch
=
Preferences
.
get
(
"
services
.
sync
.
lastTabFetch
"
0
)
;
let
now
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
if
(
now
-
lastFetch
<
TABS_FRESH_ENOUGH_INTERVAL
)
{
log
.
info
(
"
_refetchTabs
was
done
recently
do
not
doing
it
again
"
)
;
return
Promise
.
resolve
(
false
)
;
}
}
if
(
Weave
.
Status
.
checkSetup
(
)
=
=
Weave
.
CLIENT_NOT_CONFIGURED
)
{
log
.
info
(
"
Sync
client
is
not
configured
so
not
attempting
a
tab
sync
"
)
;
return
Promise
.
resolve
(
false
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
tm
.
dispatchToMainThread
(
(
)
=
>
{
try
{
log
.
info
(
"
Doing
a
tab
sync
.
"
)
;
Weave
.
Service
.
sync
(
[
"
tabs
"
]
)
;
resolve
(
true
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Sync
failed
"
ex
)
;
reject
(
ex
)
;
}
}
)
;
}
)
;
}
observe
(
subject
topic
data
)
{
log
.
trace
(
observed
topic
=
{
topic
}
data
=
{
data
}
subject
=
{
subject
}
)
;
switch
(
topic
)
{
case
"
weave
:
engine
:
sync
:
finish
"
:
if
(
data
!
=
"
tabs
"
)
{
return
;
}
Preferences
.
set
(
"
services
.
sync
.
lastTabFetch
"
Math
.
floor
(
Date
.
now
(
)
/
1000
)
)
;
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
case
"
weave
:
service
:
start
-
over
"
:
Preferences
.
reset
(
"
services
.
sync
.
lastTabFetch
"
)
;
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
case
"
nsPref
:
changed
"
:
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
default
:
break
;
}
}
get
loginFailed
(
)
{
if
(
!
weaveXPCService
.
ready
)
{
log
.
debug
(
"
Sync
isn
'
t
yet
ready
;
assuming
the
login
didn
'
t
fail
"
)
;
return
false
;
}
return
Weave
.
Status
.
login
=
=
Weave
.
LOGIN_FAILED_LOGIN_REJECTED
;
}
get
isConfiguredToSyncTabs
(
)
{
if
(
!
weaveXPCService
.
ready
)
{
log
.
debug
(
"
Sync
isn
'
t
yet
ready
;
assuming
tab
engine
is
enabled
"
)
;
return
true
;
}
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
return
engine
&
&
engine
.
enabled
;
}
get
hasSyncedThisSession
(
)
{
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
return
engine
&
&
engine
.
hasSyncedThisSession
;
}
}
;
Services
.
obs
.
addObserver
(
SyncedTabsInternal
"
weave
:
engine
:
sync
:
finish
"
)
;
Services
.
obs
.
addObserver
(
SyncedTabsInternal
"
weave
:
service
:
start
-
over
"
)
;
Services
.
prefs
.
addObserver
(
"
services
.
sync
.
engine
.
tabs
"
SyncedTabsInternal
)
;
this
.
SyncedTabs
=
{
_internal
:
SyncedTabsInternal
TOPIC_TABS_CHANGED
get
isConfiguredToSyncTabs
(
)
{
return
this
.
_internal
.
isConfiguredToSyncTabs
;
}
get
hasSyncedThisSession
(
)
{
return
this
.
_internal
.
hasSyncedThisSession
;
}
getTabClients
(
query
)
{
return
this
.
_internal
.
getTabClients
(
query
)
;
}
syncTabs
(
force
)
{
return
this
.
_internal
.
syncTabs
(
force
)
;
}
sortTabClientsByLastUsed
(
clients
)
{
for
(
let
client
of
clients
)
{
let
tabs
=
client
.
tabs
;
tabs
.
sort
(
(
a
b
)
=
>
b
.
lastUsed
-
a
.
lastUsed
)
;
}
clients
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
tabs
.
length
=
=
0
)
{
return
1
;
}
if
(
b
.
tabs
.
length
=
=
0
)
{
return
-
1
;
}
return
b
.
tabs
[
0
]
.
lastUsed
-
a
.
tabs
[
0
]
.
lastUsed
;
}
)
;
}
}
;
