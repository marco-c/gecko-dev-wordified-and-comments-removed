"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
SyncedTabs
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Log
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Log
.
sys
.
mjs
"
)
;
const
{
Weave
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
const
{
Preferences
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
weaveXPCService
"
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
)
;
function
escapeRegExp
(
string
)
{
return
string
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
;
}
const
TOPIC_TABS_CHANGED
=
"
services
.
sync
.
tabs
.
changed
"
;
const
TABS_FRESH_ENOUGH_INTERVAL_SECONDS
=
30
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
log
"
function
(
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
RemoteTabs
"
)
;
log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
tabs
"
)
;
return
log
;
}
)
;
let
SyncedTabsInternal
=
{
async
_makeTab
(
client
tab
url
showRemoteIcons
)
{
let
icon
;
if
(
showRemoteIcons
)
{
icon
=
tab
.
icon
;
}
if
(
!
icon
)
{
icon
=
"
page
-
icon
:
"
+
url
;
}
return
{
type
:
"
tab
"
title
:
tab
.
title
|
|
url
url
icon
client
:
client
.
id
lastUsed
:
tab
.
lastUsed
}
;
}
async
_makeClient
(
client
)
{
return
{
id
:
client
.
id
type
:
"
client
"
name
:
Weave
.
Service
.
clientsEngine
.
getClientName
(
client
.
id
)
clientType
:
Weave
.
Service
.
clientsEngine
.
getClientType
(
client
.
id
)
lastModified
:
client
.
lastModified
*
1000
tabs
:
[
]
}
;
}
_tabMatchesFilter
(
tab
filter
)
{
let
reFilter
=
new
RegExp
(
escapeRegExp
(
filter
)
"
i
"
)
;
return
reFilter
.
test
(
tab
.
url
)
|
|
reFilter
.
test
(
tab
.
title
)
;
}
_createRecentTabsList
(
clients
maxCount
)
{
let
tabs
=
[
]
;
for
(
let
client
of
clients
)
{
for
(
let
tab
of
client
.
tabs
)
{
tab
.
device
=
client
.
name
;
tab
.
deviceType
=
client
.
clientType
;
}
tabs
=
[
.
.
.
tabs
.
.
.
client
.
tabs
.
reverse
(
)
]
;
}
tabs
=
this
.
_filterRecentTabsDupes
(
tabs
)
;
tabs
=
tabs
.
sort
(
(
a
b
)
=
>
b
.
lastUsed
-
a
.
lastUsed
)
.
slice
(
0
maxCount
)
;
return
tabs
;
}
_filterRecentTabsDupes
(
tabs
)
{
return
tabs
.
filter
(
tab
=
>
{
return
!
tabs
.
some
(
t
=
>
{
return
t
.
url
=
=
=
tab
.
url
&
&
tab
.
lastUsed
<
t
.
lastUsed
;
}
)
;
}
)
;
}
async
getTabClients
(
filter
)
{
lazy
.
log
.
info
(
"
Generating
tab
list
with
filter
"
filter
)
;
let
result
=
[
]
;
if
(
!
lazy
.
weaveXPCService
.
ready
)
{
lazy
.
log
.
debug
(
"
Sync
isn
'
t
yet
ready
so
returning
an
empty
tab
list
"
)
;
return
result
;
}
const
showRemoteIcons
=
Preferences
.
get
(
"
services
.
sync
.
syncedTabs
.
showRemoteIcons
"
true
)
;
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
let
ntabs
=
0
;
let
clientTabList
=
await
engine
.
getAllClients
(
)
;
for
(
let
client
of
clientTabList
)
{
if
(
!
Weave
.
Service
.
clientsEngine
.
remoteClientExists
(
client
.
id
)
)
{
continue
;
}
let
clientRepr
=
await
this
.
_makeClient
(
client
)
;
lazy
.
log
.
debug
(
"
Processing
client
"
clientRepr
)
;
for
(
let
tab
of
client
.
tabs
)
{
let
url
=
tab
.
urlHistory
[
0
]
;
lazy
.
log
.
trace
(
"
remote
tab
"
url
)
;
if
(
!
url
)
{
continue
;
}
let
tabRepr
=
await
this
.
_makeTab
(
client
tab
url
showRemoteIcons
)
;
if
(
filter
&
&
!
this
.
_tabMatchesFilter
(
tabRepr
filter
)
)
{
continue
;
}
clientRepr
.
tabs
.
push
(
tabRepr
)
;
}
ntabs
+
=
clientRepr
.
tabs
.
length
;
result
.
push
(
clientRepr
)
;
}
lazy
.
log
.
info
(
Final
tab
list
has
{
result
.
length
}
clients
with
{
ntabs
}
tabs
.
)
;
return
result
;
}
async
syncTabs
(
force
)
{
if
(
!
force
)
{
let
lastFetch
=
Preferences
.
get
(
"
services
.
sync
.
lastTabFetch
"
0
)
;
let
now
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
if
(
now
-
lastFetch
<
TABS_FRESH_ENOUGH_INTERVAL_SECONDS
)
{
lazy
.
log
.
info
(
"
_refetchTabs
was
done
recently
do
not
doing
it
again
"
)
;
return
false
;
}
}
if
(
Weave
.
Status
.
checkSetup
(
)
=
=
=
Weave
.
CLIENT_NOT_CONFIGURED
)
{
lazy
.
log
.
info
(
"
Sync
client
is
not
configured
so
not
attempting
a
tab
sync
"
)
;
return
false
;
}
if
(
!
(
Weave
.
Status
.
login
=
=
=
Weave
.
STATUS_OK
|
|
Weave
.
Status
.
login
=
=
=
Weave
.
LOGIN_SUCCEEDED
)
)
{
lazy
.
log
.
info
(
"
Can
'
t
sync
tabs
due
to
the
login
status
"
Weave
.
Status
.
login
)
;
return
false
;
}
try
{
lazy
.
log
.
info
(
"
Doing
a
tab
sync
.
"
)
;
await
Weave
.
Service
.
sync
(
{
why
:
"
tabs
"
engines
:
[
"
tabs
"
]
}
)
;
return
true
;
}
catch
(
ex
)
{
lazy
.
log
.
error
(
"
Sync
failed
"
ex
)
;
throw
ex
;
}
}
observe
(
subject
topic
data
)
{
lazy
.
log
.
trace
(
observed
topic
=
{
topic
}
data
=
{
data
}
subject
=
{
subject
}
)
;
switch
(
topic
)
{
case
"
weave
:
engine
:
sync
:
finish
"
:
if
(
data
!
=
"
tabs
"
)
{
return
;
}
Preferences
.
set
(
"
services
.
sync
.
lastTabFetch
"
Math
.
floor
(
Date
.
now
(
)
/
1000
)
)
;
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
case
"
weave
:
service
:
start
-
over
"
:
Preferences
.
reset
(
"
services
.
sync
.
lastTabFetch
"
)
;
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
case
"
nsPref
:
changed
"
:
Services
.
obs
.
notifyObservers
(
null
TOPIC_TABS_CHANGED
)
;
break
;
default
:
break
;
}
}
get
isConfiguredToSyncTabs
(
)
{
if
(
!
lazy
.
weaveXPCService
.
ready
)
{
lazy
.
log
.
debug
(
"
Sync
isn
'
t
yet
ready
;
assuming
tab
engine
is
enabled
"
)
;
return
true
;
}
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
return
engine
&
&
engine
.
enabled
;
}
get
hasSyncedThisSession
(
)
{
let
engine
=
Weave
.
Service
.
engineManager
.
get
(
"
tabs
"
)
;
return
engine
&
&
engine
.
hasSyncedThisSession
;
}
}
;
Services
.
obs
.
addObserver
(
SyncedTabsInternal
"
weave
:
engine
:
sync
:
finish
"
)
;
Services
.
obs
.
addObserver
(
SyncedTabsInternal
"
weave
:
service
:
start
-
over
"
)
;
Services
.
prefs
.
addObserver
(
"
services
.
sync
.
engine
.
tabs
"
SyncedTabsInternal
)
;
var
SyncedTabs
=
{
_internal
:
SyncedTabsInternal
TOPIC_TABS_CHANGED
TABS_FRESH_ENOUGH_INTERVAL_SECONDS
get
isConfiguredToSyncTabs
(
)
{
return
this
.
_internal
.
isConfiguredToSyncTabs
;
}
get
hasSyncedThisSession
(
)
{
return
this
.
_internal
.
hasSyncedThisSession
;
}
getTabClients
(
query
)
{
return
this
.
_internal
.
getTabClients
(
query
)
;
}
syncTabs
(
force
)
{
return
this
.
_internal
.
syncTabs
(
force
)
;
}
sortTabClientsByLastUsed
(
clients
)
{
for
(
let
client
of
clients
)
{
let
tabs
=
client
.
tabs
;
tabs
.
sort
(
(
a
b
)
=
>
b
.
lastUsed
-
a
.
lastUsed
)
;
}
clients
.
sort
(
(
a
b
)
=
>
{
if
(
!
a
.
tabs
.
length
)
{
return
1
;
}
if
(
!
b
.
tabs
.
length
)
{
return
-
1
;
}
return
b
.
tabs
[
0
]
.
lastUsed
-
a
.
tabs
[
0
]
.
lastUsed
;
}
)
;
}
recordSyncedTabsTelemetry
(
object
tabEvent
extraOptions
)
{
Services
.
telemetry
.
setEventRecordingEnabled
(
"
synced_tabs
"
true
)
;
Services
.
telemetry
.
recordEvent
(
"
synced_tabs
"
tabEvent
object
null
extraOptions
)
;
}
async
getRecentTabs
(
maxCount
)
{
let
clients
=
await
this
.
getTabClients
(
)
;
return
this
.
_internal
.
_createRecentTabsList
(
clients
maxCount
)
;
}
}
;
