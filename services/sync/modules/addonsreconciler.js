"
use
strict
"
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
DEFAULT_STATE_FILE
=
"
addonsreconciler
"
;
this
.
CHANGE_INSTALLED
=
1
;
this
.
CHANGE_UNINSTALLED
=
2
;
this
.
CHANGE_ENABLED
=
3
;
this
.
CHANGE_DISABLED
=
4
;
this
.
EXPORTED_SYMBOLS
=
[
"
AddonsReconciler
"
"
CHANGE_INSTALLED
"
"
CHANGE_UNINSTALLED
"
"
CHANGE_ENABLED
"
"
CHANGE_DISABLED
"
]
;
this
.
AddonsReconciler
=
function
AddonsReconciler
(
queueCaller
)
{
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
AddonsReconciler
"
)
;
this
.
_log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
addonsreconciler
"
)
;
this
.
queueCaller
=
queueCaller
;
Svc
.
Obs
.
add
(
"
xpcom
-
shutdown
"
this
.
stopListening
this
)
;
}
;
AddonsReconciler
.
prototype
=
{
_listening
:
false
_shouldPersist
:
true
_log
:
null
_addons
:
{
}
_changes
:
[
]
_listeners
:
[
]
get
addons
(
)
{
return
this
.
_addons
;
}
async
ensureStateLoaded
(
)
{
if
(
!
this
.
_promiseStateLoaded
)
{
this
.
_promiseStateLoaded
=
this
.
loadState
(
)
;
}
return
this
.
_promiseStateLoaded
;
}
async
loadState
(
file
=
DEFAULT_STATE_FILE
)
{
let
json
=
await
Utils
.
jsonLoad
(
file
this
)
;
this
.
_addons
=
{
}
;
this
.
_changes
=
[
]
;
if
(
!
json
)
{
this
.
_log
.
debug
(
"
No
data
seen
in
loaded
file
:
"
+
file
)
;
return
false
;
}
let
version
=
json
.
version
;
if
(
!
version
|
|
version
!
=
1
)
{
this
.
_log
.
error
(
"
Could
not
load
JSON
file
because
version
not
"
+
"
supported
:
"
+
version
)
;
return
false
;
}
this
.
_addons
=
json
.
addons
;
for
(
let
id
in
this
.
_addons
)
{
let
record
=
this
.
_addons
[
id
]
;
record
.
modified
=
new
Date
(
record
.
modified
)
;
}
for
(
let
[
time
change
id
]
of
json
.
changes
)
{
this
.
_changes
.
push
(
[
new
Date
(
time
)
change
id
]
)
;
}
return
true
;
}
async
saveState
(
file
=
DEFAULT_STATE_FILE
)
{
let
state
=
{
version
:
1
addons
:
{
}
changes
:
[
]
}
;
for
(
let
[
id
record
]
of
Object
.
entries
(
this
.
_addons
)
)
{
state
.
addons
[
id
]
=
{
}
;
for
(
let
[
k
v
]
of
Object
.
entries
(
record
)
)
{
if
(
k
=
=
"
modified
"
)
{
state
.
addons
[
id
]
[
k
]
=
v
.
getTime
(
)
;
}
else
{
state
.
addons
[
id
]
[
k
]
=
v
;
}
}
}
for
(
let
[
time
change
id
]
of
this
.
_changes
)
{
state
.
changes
.
push
(
[
time
.
getTime
(
)
change
id
]
)
;
}
this
.
_log
.
info
(
"
Saving
reconciler
state
to
file
:
"
+
file
)
;
await
Utils
.
jsonSave
(
file
this
state
)
;
}
addChangeListener
:
function
addChangeListener
(
listener
)
{
if
(
!
this
.
_listeners
.
includes
(
listener
)
)
{
this
.
_log
.
debug
(
"
Adding
change
listener
.
"
)
;
this
.
_listeners
.
push
(
listener
)
;
}
}
removeChangeListener
:
function
removeChangeListener
(
listener
)
{
this
.
_listeners
=
this
.
_listeners
.
filter
(
element
=
>
{
if
(
element
=
=
listener
)
{
this
.
_log
.
debug
(
"
Removing
change
listener
.
"
)
;
return
false
;
}
return
true
;
}
)
;
}
startListening
:
function
startListening
(
)
{
if
(
this
.
_listening
)
{
return
;
}
this
.
_log
.
info
(
"
Registering
as
Add
-
on
Manager
listener
.
"
)
;
AddonManager
.
addAddonListener
(
this
)
;
AddonManager
.
addInstallListener
(
this
)
;
this
.
_listening
=
true
;
}
stopListening
:
function
stopListening
(
)
{
if
(
!
this
.
_listening
)
{
return
;
}
this
.
_log
.
debug
(
"
Stopping
listening
and
removing
AddonManager
listeners
.
"
)
;
AddonManager
.
removeInstallListener
(
this
)
;
AddonManager
.
removeAddonListener
(
this
)
;
this
.
_listening
=
false
;
}
async
refreshGlobalState
(
)
{
this
.
_log
.
info
(
"
Refreshing
global
state
from
AddonManager
.
"
)
;
let
installs
;
let
addons
=
await
AddonManager
.
getAllAddons
(
)
;
let
ids
=
{
}
;
for
(
let
addon
of
addons
)
{
ids
[
addon
.
id
]
=
true
;
await
this
.
rectifyStateFromAddon
(
addon
)
;
}
for
(
let
[
id
addon
]
of
Object
.
entries
(
this
.
_addons
)
)
{
if
(
id
in
ids
)
{
continue
;
}
if
(
!
installs
)
{
installs
=
await
AddonManager
.
getAllInstalls
(
)
;
}
let
installFound
=
false
;
for
(
let
install
of
installs
)
{
if
(
install
.
addon
&
&
install
.
addon
.
id
=
=
id
&
&
install
.
state
=
=
AddonManager
.
STATE_INSTALLED
)
{
installFound
=
true
;
break
;
}
}
if
(
installFound
)
{
continue
;
}
if
(
addon
.
installed
)
{
addon
.
installed
=
false
;
this
.
_log
.
debug
(
"
Adding
change
because
add
-
on
not
present
in
"
+
"
Add
-
on
Manager
:
"
+
id
)
;
await
this
.
_addChange
(
new
Date
(
)
CHANGE_UNINSTALLED
addon
)
;
}
}
if
(
this
.
_shouldPersist
)
{
await
this
.
saveState
(
)
;
}
}
async
rectifyStateFromAddon
(
addon
)
{
this
.
_log
.
debug
(
Rectifying
state
for
addon
{
addon
.
name
}
(
version
=
{
addon
.
version
}
id
=
{
addon
.
id
}
)
)
;
let
id
=
addon
.
id
;
let
enabled
=
!
addon
.
userDisabled
;
let
guid
=
addon
.
syncGUID
;
let
now
=
new
Date
(
)
;
if
(
!
(
id
in
this
.
_addons
)
)
{
let
record
=
{
id
guid
enabled
installed
:
true
modified
:
now
type
:
addon
.
type
scope
:
addon
.
scope
foreignInstall
:
addon
.
foreignInstall
isSyncable
:
addon
.
isSyncable
}
;
this
.
_addons
[
id
]
=
record
;
this
.
_log
.
debug
(
"
Adding
change
because
add
-
on
not
present
locally
:
"
+
id
)
;
await
this
.
_addChange
(
now
CHANGE_INSTALLED
record
)
;
return
;
}
let
record
=
this
.
_addons
[
id
]
;
record
.
isSyncable
=
addon
.
isSyncable
;
if
(
!
record
.
installed
)
{
if
(
!
(
addon
.
pendingOperations
&
AddonManager
.
PENDING_UNINSTALL
)
)
{
record
.
installed
=
true
;
record
.
modified
=
now
;
}
}
if
(
record
.
enabled
!
=
enabled
)
{
record
.
enabled
=
enabled
;
record
.
modified
=
now
;
let
change
=
enabled
?
CHANGE_ENABLED
:
CHANGE_DISABLED
;
this
.
_log
.
debug
(
"
Adding
change
because
enabled
state
changed
:
"
+
id
)
;
await
this
.
_addChange
(
new
Date
(
)
change
record
)
;
}
if
(
record
.
guid
!
=
guid
)
{
record
.
guid
=
guid
;
}
}
async
_addChange
(
date
change
state
)
{
this
.
_log
.
info
(
"
Change
recorded
for
"
+
state
.
id
)
;
this
.
_changes
.
push
(
[
date
change
state
.
id
]
)
;
for
(
let
listener
of
this
.
_listeners
)
{
try
{
await
listener
.
changeListener
(
date
change
state
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
Exception
calling
change
listener
"
ex
)
;
}
}
}
getChangesSinceDate
(
date
)
{
let
length
=
this
.
_changes
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
this
.
_changes
[
i
]
[
0
]
>
=
date
)
{
return
this
.
_changes
.
slice
(
i
)
;
}
}
return
[
]
;
}
pruneChangesBeforeDate
(
date
)
{
this
.
_changes
=
this
.
_changes
.
filter
(
function
test_age
(
change
)
{
return
change
[
0
]
>
=
date
;
}
)
;
}
getAllSyncGUIDs
(
)
{
let
result
=
{
}
;
for
(
let
id
in
this
.
addons
)
{
result
[
id
]
=
true
;
}
return
result
;
}
getAddonStateFromSyncGUID
(
guid
)
{
for
(
let
id
in
this
.
addons
)
{
let
addon
=
this
.
addons
[
id
]
;
if
(
addon
.
guid
=
=
guid
)
{
return
addon
;
}
}
return
null
;
}
async
_handleListener
(
action
addon
requiresRestart
)
{
try
{
let
id
=
addon
.
id
;
this
.
_log
.
debug
(
"
Add
-
on
change
:
"
+
action
+
"
to
"
+
id
)
;
if
(
requiresRestart
=
=
=
false
)
{
this
.
_log
.
debug
(
"
Ignoring
"
+
action
+
"
for
restartless
add
-
on
.
"
)
;
return
;
}
switch
(
action
)
{
case
"
onEnabling
"
:
case
"
onEnabled
"
:
case
"
onDisabling
"
:
case
"
onDisabled
"
:
case
"
onInstalled
"
:
case
"
onInstallEnded
"
:
case
"
onOperationCancelled
"
:
await
this
.
rectifyStateFromAddon
(
addon
)
;
break
;
case
"
onUninstalling
"
:
case
"
onUninstalled
"
:
let
id
=
addon
.
id
;
let
addons
=
this
.
addons
;
if
(
id
in
addons
)
{
let
now
=
new
Date
(
)
;
let
record
=
addons
[
id
]
;
record
.
installed
=
false
;
record
.
modified
=
now
;
this
.
_log
.
debug
(
"
Adding
change
because
of
uninstall
listener
:
"
+
id
)
;
await
this
.
_addChange
(
now
CHANGE_UNINSTALLED
record
)
;
}
}
if
(
this
.
_shouldPersist
)
{
await
this
.
saveState
(
)
;
}
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
Exception
"
ex
)
;
}
}
onEnabling
:
function
onEnabling
(
addon
requiresRestart
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onEnabling
"
addon
requiresRestart
)
)
;
}
onEnabled
:
function
onEnabled
(
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onEnabled
"
addon
)
)
;
}
onDisabling
:
function
onDisabling
(
addon
requiresRestart
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onDisabling
"
addon
requiresRestart
)
)
;
}
onDisabled
:
function
onDisabled
(
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onDisabled
"
addon
)
)
;
}
onInstalling
:
function
onInstalling
(
addon
requiresRestart
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onInstalling
"
addon
requiresRestart
)
)
;
}
onInstalled
:
function
onInstalled
(
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onInstalled
"
addon
)
)
;
}
onUninstalling
:
function
onUninstalling
(
addon
requiresRestart
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onUninstalling
"
addon
requiresRestart
)
)
;
}
onUninstalled
:
function
onUninstalled
(
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onUninstalled
"
addon
)
)
;
}
onOperationCancelled
:
function
onOperationCancelled
(
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onOperationCancelled
"
addon
)
)
;
}
onInstallEnded
:
function
onInstallEnded
(
install
addon
)
{
this
.
queueCaller
.
enqueueCall
(
(
)
=
>
this
.
_handleListener
(
"
onInstallEnded
"
addon
)
)
;
}
}
;
