"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
UIState
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Weave
"
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
const
TOPICS
=
[
"
weave
:
service
:
login
:
change
"
"
weave
:
service
:
login
:
error
"
"
weave
:
service
:
ready
"
"
weave
:
service
:
sync
:
start
"
"
weave
:
service
:
sync
:
finish
"
"
weave
:
service
:
sync
:
error
"
"
weave
:
service
:
start
-
over
:
finish
"
"
fxaccounts
:
onverified
"
"
fxaccounts
:
onlogin
"
"
fxaccounts
:
onlogout
"
"
fxaccounts
:
profilechange
"
"
fxaccounts
:
statechange
"
]
;
const
ON_UPDATE
=
"
sync
-
ui
-
state
:
update
"
;
const
STATUS_NOT_CONFIGURED
=
"
not_configured
"
;
const
STATUS_LOGIN_FAILED
=
"
login_failed
"
;
const
STATUS_NOT_VERIFIED
=
"
not_verified
"
;
const
STATUS_SIGNED_IN
=
"
signed_in
"
;
const
DEFAULT_STATE
=
{
status
:
STATUS_NOT_CONFIGURED
}
;
const
UIStateInternal
=
{
_initialized
:
false
_state
:
null
_syncing
:
false
get
state
(
)
{
if
(
!
this
.
_state
)
{
return
DEFAULT_STATE
;
}
return
Object
.
assign
(
{
}
this
.
_state
{
syncing
:
this
.
_syncing
}
)
;
}
isReady
(
)
{
if
(
!
this
.
_initialized
)
{
this
.
init
(
)
;
return
false
;
}
return
true
;
}
init
(
)
{
this
.
_initialized
=
true
;
if
(
!
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
username
"
)
)
{
return
;
}
this
.
refreshState
(
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
;
}
reset
(
)
{
this
.
_state
=
null
;
this
.
_syncing
=
false
;
this
.
_initialized
=
false
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
weave
:
service
:
sync
:
start
"
:
this
.
toggleSyncActivity
(
true
)
;
break
;
case
"
weave
:
service
:
sync
:
finish
"
:
case
"
weave
:
service
:
sync
:
error
"
:
this
.
toggleSyncActivity
(
false
)
;
break
;
default
:
this
.
refreshState
(
)
.
catch
(
e
=
>
{
Cu
.
reportError
(
e
)
;
}
)
;
break
;
}
}
async
refreshState
(
)
{
const
newState
=
{
}
;
await
this
.
_refreshFxAState
(
newState
)
;
this
.
_setLastSyncTime
(
newState
)
;
this
.
_state
=
newState
;
this
.
notifyStateUpdated
(
)
;
return
this
.
state
;
}
toggleSyncActivity
(
syncing
)
{
this
.
_syncing
=
syncing
;
this
.
_setLastSyncTime
(
this
.
_state
)
;
this
.
notifyStateUpdated
(
)
;
}
notifyStateUpdated
(
)
{
Services
.
obs
.
notifyObservers
(
null
ON_UPDATE
)
;
}
async
_refreshFxAState
(
newState
)
{
let
userData
=
await
this
.
_getUserData
(
)
;
await
this
.
_populateWithUserData
(
newState
userData
)
;
if
(
newState
.
status
!
=
STATUS_SIGNED_IN
)
{
return
;
}
let
profile
=
await
this
.
_getProfile
(
)
;
if
(
!
profile
)
{
return
;
}
this
.
_populateWithProfile
(
newState
profile
)
;
}
async
_populateWithUserData
(
state
userData
)
{
let
status
;
if
(
!
userData
)
{
let
syncUserName
=
Services
.
prefs
.
getStringPref
(
"
services
.
sync
.
username
"
"
"
)
;
if
(
syncUserName
)
{
state
.
email
=
syncUserName
;
status
=
STATUS_LOGIN_FAILED
;
}
else
{
status
=
STATUS_NOT_CONFIGURED
;
}
}
else
{
let
loginFailed
=
await
this
.
_loginFailed
(
)
;
if
(
loginFailed
)
{
status
=
STATUS_LOGIN_FAILED
;
}
else
if
(
!
userData
.
verified
)
{
status
=
STATUS_NOT_VERIFIED
;
}
else
{
status
=
STATUS_SIGNED_IN
;
}
state
.
uid
=
userData
.
uid
;
state
.
email
=
userData
.
email
;
}
state
.
status
=
status
;
}
_populateWithProfile
(
state
profile
)
{
state
.
displayName
=
profile
.
displayName
;
state
.
avatarURL
=
profile
.
avatar
;
}
async
_getUserData
(
)
{
try
{
return
await
this
.
fxAccounts
.
getSignedInUser
(
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Error
updating
FxA
account
info
:
"
+
e
)
;
return
null
;
}
}
async
_getProfile
(
)
{
try
{
return
await
this
.
fxAccounts
.
getSignedInUserProfile
(
)
;
}
catch
(
e
)
{
return
null
;
}
}
_setLastSyncTime
(
state
)
{
if
(
state
.
status
=
=
UIState
.
STATUS_SIGNED_IN
)
{
const
lastSync
=
Services
.
prefs
.
getCharPref
(
"
services
.
sync
.
lastSync
"
null
)
;
state
.
lastSync
=
lastSync
?
new
Date
(
lastSync
)
:
null
;
}
}
async
_loginFailed
(
)
{
let
hasLocalSession
=
await
this
.
fxAccounts
.
hasLocalSession
(
)
;
if
(
!
hasLocalSession
)
{
return
true
;
}
let
service
=
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
if
(
!
service
.
ready
)
{
return
false
;
}
return
Weave
.
Status
.
login
=
=
Weave
.
LOGIN_FAILED_LOGIN_REJECTED
;
}
set
fxAccounts
(
mockFxAccounts
)
{
delete
this
.
fxAccounts
;
this
.
fxAccounts
=
mockFxAccounts
;
}
}
;
ChromeUtils
.
defineModuleGetter
(
UIStateInternal
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
for
(
let
topic
of
TOPICS
)
{
Services
.
obs
.
addObserver
(
UIStateInternal
topic
)
;
}
var
UIState
=
{
_internal
:
UIStateInternal
ON_UPDATE
STATUS_NOT_CONFIGURED
STATUS_LOGIN_FAILED
STATUS_NOT_VERIFIED
STATUS_SIGNED_IN
isReady
(
)
{
return
this
.
_internal
.
isReady
(
)
;
}
get
(
)
{
return
this
.
_internal
.
state
;
}
refresh
(
)
{
return
this
.
_internal
.
refreshState
(
)
;
}
reset
(
)
{
this
.
_internal
.
reset
(
)
;
}
}
;
