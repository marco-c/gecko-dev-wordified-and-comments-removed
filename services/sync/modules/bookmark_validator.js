"
use
strict
"
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
bookmark_utils
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
BookmarkValidator
"
"
BookmarkProblemData
"
]
;
class
BookmarkProblemData
{
constructor
(
)
{
this
.
rootOnServer
=
false
;
this
.
missingIDs
=
0
;
this
.
duplicates
=
[
]
;
this
.
parentChildMismatches
=
[
]
;
this
.
cycles
=
[
]
;
this
.
orphans
=
[
]
;
this
.
missingChildren
=
[
]
;
this
.
multipleParents
=
[
]
;
this
.
deletedParents
=
[
]
;
this
.
childrenOnNonFolder
=
[
]
;
this
.
duplicateChildren
=
[
]
;
this
.
parentNotFolder
=
[
]
;
this
.
wrongParentName
=
[
]
;
this
.
clientMissing
=
[
]
;
this
.
serverMissing
=
[
]
;
this
.
serverDeleted
=
[
]
;
this
.
serverUnexpected
=
[
]
;
this
.
differences
=
[
]
;
this
.
structuralDifferences
=
[
]
;
}
getSummary
(
)
{
return
[
{
name
:
"
clientMissing
"
count
:
this
.
clientMissing
.
length
}
{
name
:
"
serverMissing
"
count
:
this
.
serverMissing
.
length
}
{
name
:
"
serverDeleted
"
count
:
this
.
serverDeleted
.
length
}
{
name
:
"
serverUnexpected
"
count
:
this
.
serverUnexpected
.
length
}
{
name
:
"
structuralDifferences
"
count
:
this
.
structuralDifferences
.
length
}
{
name
:
"
differences
"
count
:
this
.
differences
.
length
}
{
name
:
"
missingIDs
"
count
:
this
.
missingIDs
}
{
name
:
"
rootOnServer
"
count
:
this
.
rootOnServer
?
1
:
0
}
{
name
:
"
duplicates
"
count
:
this
.
duplicates
.
length
}
{
name
:
"
parentChildMismatches
"
count
:
this
.
parentChildMismatches
.
length
}
{
name
:
"
cycles
"
count
:
this
.
cycles
.
length
}
{
name
:
"
orphans
"
count
:
this
.
orphans
.
length
}
{
name
:
"
missingChildren
"
count
:
this
.
missingChildren
.
length
}
{
name
:
"
multipleParents
"
count
:
this
.
multipleParents
.
length
}
{
name
:
"
deletedParents
"
count
:
this
.
deletedParents
.
length
}
{
name
:
"
childrenOnNonFolder
"
count
:
this
.
childrenOnNonFolder
.
length
}
{
name
:
"
duplicateChildren
"
count
:
this
.
duplicateChildren
.
length
}
{
name
:
"
parentNotFolder
"
count
:
this
.
parentNotFolder
.
length
}
{
name
:
"
wrongParentName
"
count
:
this
.
wrongParentName
.
length
}
]
;
}
}
class
BookmarkValidator
{
createClientRecordsFromTree
(
clientTree
)
{
let
records
=
[
]
;
function
traverse
(
treeNode
)
{
let
guid
=
BookmarkSpecialIds
.
specialGUIDForId
(
treeNode
.
id
)
|
|
treeNode
.
guid
;
let
itemType
=
'
item
'
;
treeNode
.
ignored
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
treeNode
.
id
BookmarkAnnos
.
EXCLUDEBACKUP_ANNO
)
;
treeNode
.
id
=
guid
;
switch
(
treeNode
.
type
)
{
case
PlacesUtils
.
TYPE_X_MOZ_PLACE
:
let
query
=
null
;
if
(
treeNode
.
annos
&
&
treeNode
.
uri
.
startsWith
(
"
place
:
"
)
)
{
query
=
treeNode
.
annos
.
find
(
(
{
name
}
)
=
>
name
=
=
=
BookmarkAnnos
.
SMART_BOOKMARKS_ANNO
)
;
}
if
(
query
&
&
query
.
value
)
{
itemType
=
'
query
'
;
}
else
{
itemType
=
'
bookmark
'
;
}
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
:
let
isLivemark
=
false
;
if
(
treeNode
.
annos
)
{
for
(
let
anno
of
treeNode
.
annos
)
{
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
{
isLivemark
=
true
;
treeNode
.
feedUri
=
anno
.
value
;
}
else
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_SITEURI
)
{
isLivemark
=
true
;
treeNode
.
siteUri
=
anno
.
value
;
}
}
}
itemType
=
isLivemark
?
"
livemark
"
:
"
folder
"
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
itemType
=
'
separator
'
;
break
;
}
if
(
treeNode
.
tags
)
{
treeNode
.
tags
=
treeNode
.
tags
.
split
(
"
"
)
;
}
else
{
treeNode
.
tags
=
[
]
;
}
treeNode
.
type
=
itemType
;
treeNode
.
pos
=
treeNode
.
index
;
treeNode
.
bmkUri
=
treeNode
.
uri
;
records
.
push
(
treeNode
)
;
if
(
treeNode
.
type
=
=
=
'
folder
'
)
{
treeNode
.
childGUIDs
=
[
]
;
if
(
!
treeNode
.
children
)
{
treeNode
.
children
=
[
]
;
}
for
(
let
child
of
treeNode
.
children
)
{
traverse
(
child
)
;
child
.
parent
=
treeNode
;
child
.
parentid
=
guid
;
child
.
parentName
=
treeNode
.
title
;
treeNode
.
childGUIDs
.
push
(
child
.
guid
)
;
}
}
}
traverse
(
clientTree
)
;
clientTree
.
id
=
'
places
'
;
return
records
;
}
inspectServerRecords
(
serverRecords
)
{
let
deletedItemIds
=
new
Set
(
)
;
let
idToRecord
=
new
Map
(
)
;
let
deletedRecords
=
[
]
;
let
folders
=
[
]
;
let
problems
=
[
]
;
let
problemData
=
new
BookmarkProblemData
(
)
;
let
resultRecords
=
[
]
;
for
(
let
record
of
serverRecords
)
{
if
(
!
record
.
id
)
{
+
+
problemData
.
missingIDs
;
continue
;
}
if
(
record
.
deleted
)
{
deletedItemIds
.
add
(
record
.
id
)
;
}
else
{
if
(
idToRecord
.
has
(
record
.
id
)
)
{
problemData
.
duplicates
.
push
(
record
.
id
)
;
continue
;
}
idToRecord
.
set
(
record
.
id
record
)
;
}
if
(
record
.
children
&
&
record
.
type
!
=
=
"
livemark
"
)
{
if
(
record
.
type
!
=
=
'
folder
'
)
{
problemData
.
childrenOnNonFolder
.
push
(
record
.
id
)
;
}
folders
.
push
(
record
)
;
if
(
new
Set
(
record
.
children
)
.
size
!
=
=
record
.
children
.
length
)
{
problemData
.
duplicateChildren
.
push
(
record
.
id
)
}
record
.
childGUIDs
=
record
.
children
;
record
.
children
=
record
.
children
.
map
(
childID
=
>
{
let
match
=
childID
.
match
(
/
_
+
/
)
;
if
(
!
match
)
{
return
childID
;
}
let
possibleSpecialID
=
childID
.
slice
(
0
match
.
index
)
;
if
(
possibleSpecialID
=
=
=
'
root
'
)
{
possibleSpecialID
=
'
places
'
;
}
if
(
BookmarkSpecialIds
.
isSpecialGUID
(
possibleSpecialID
)
)
{
return
possibleSpecialID
;
}
return
childID
;
}
)
;
}
}
for
(
let
deletedId
of
deletedItemIds
)
{
let
record
=
idToRecord
.
get
(
deletedId
)
;
if
(
record
&
&
!
record
.
isDeleted
)
{
deletedRecords
.
push
(
record
)
;
record
.
isDeleted
=
true
;
}
}
let
root
=
idToRecord
.
get
(
'
places
'
)
;
if
(
!
root
)
{
root
=
{
id
:
'
places
'
children
:
[
]
type
:
'
folder
'
title
:
'
'
}
;
resultRecords
.
push
(
root
)
;
idToRecord
.
set
(
'
places
'
root
)
;
}
else
{
problemData
.
rootOnServer
=
true
;
}
for
(
let
[
id
record
]
of
idToRecord
)
{
if
(
record
=
=
=
root
)
{
continue
;
}
let
parentID
=
record
.
parentid
;
if
(
!
parentID
)
{
problemData
.
orphans
.
push
(
{
id
:
record
.
id
parent
:
parentID
}
)
;
continue
;
}
let
parent
=
idToRecord
.
get
(
parentID
)
;
if
(
!
parent
)
{
problemData
.
orphans
.
push
(
{
id
:
record
.
id
parent
:
parentID
}
)
;
continue
;
}
if
(
parent
.
type
!
=
=
'
folder
'
)
{
problemData
.
parentNotFolder
.
push
(
record
.
id
)
;
}
if
(
!
record
.
isDeleted
)
{
resultRecords
.
push
(
record
)
;
}
record
.
parent
=
parent
;
if
(
parent
!
=
=
root
|
|
problemData
.
rootOnServer
)
{
let
childIndex
=
parent
.
children
.
indexOf
(
id
)
;
if
(
childIndex
<
0
)
{
problemData
.
parentChildMismatches
.
push
(
{
parent
:
parent
.
id
child
:
record
.
id
}
)
;
}
else
{
parent
.
children
[
childIndex
]
=
record
;
}
}
else
{
parent
.
children
.
push
(
record
)
;
}
if
(
parent
.
isDeleted
&
&
!
record
.
isDeleted
)
{
problemData
.
deletedParents
.
push
(
record
.
id
)
;
}
if
(
record
.
parentName
!
=
=
parent
.
title
&
&
parent
.
id
!
=
=
'
unfiled
'
)
{
problemData
.
wrongParentName
.
push
(
record
.
id
)
;
}
}
for
(
let
folder
of
folders
)
{
for
(
let
ci
=
0
;
ci
<
folder
.
children
.
length
;
+
+
ci
)
{
let
child
=
folder
.
children
[
ci
]
;
if
(
typeof
child
=
=
=
'
string
'
)
{
let
childObject
=
idToRecord
.
get
(
child
)
;
if
(
!
childObject
)
{
problemData
.
missingChildren
.
push
(
{
parent
:
folder
.
id
child
}
)
;
}
else
{
if
(
childObject
.
parentid
=
=
=
folder
.
id
)
{
continue
;
}
let
currentProblemRecord
=
problemData
.
multipleParents
.
find
(
pr
=
>
pr
.
child
=
=
=
child
)
;
if
(
currentProblemRecord
)
{
currentProblemRecord
.
parents
.
push
(
folder
.
id
)
;
}
else
{
problemData
.
multipleParents
.
push
(
{
child
parents
:
[
childObject
.
parentid
folder
.
id
]
}
)
;
}
}
folder
.
children
.
splice
(
ci
1
)
;
-
-
ci
;
}
}
}
problemData
.
cycles
=
this
.
_detectCycles
(
resultRecords
)
;
return
{
deletedRecords
records
:
resultRecords
problemData
root
}
;
}
_detectCycles
(
records
)
{
let
pathLookup
=
new
Set
(
)
;
let
currentPath
=
[
]
;
let
cycles
=
[
]
;
let
seenEver
=
new
Set
(
)
;
const
traverse
=
node
=
>
{
if
(
pathLookup
.
has
(
node
)
)
{
let
cycleStart
=
currentPath
.
lastIndexOf
(
node
)
;
let
cyclePath
=
currentPath
.
slice
(
cycleStart
)
.
map
(
n
=
>
n
.
id
)
;
cycles
.
push
(
cyclePath
)
;
return
;
}
else
if
(
seenEver
.
has
(
node
)
)
{
return
;
}
seenEver
.
add
(
node
)
;
if
(
node
.
children
)
{
pathLookup
.
add
(
node
)
;
currentPath
.
push
(
node
)
;
for
(
let
child
of
node
.
children
)
{
traverse
(
child
)
;
}
currentPath
.
pop
(
)
;
pathLookup
.
delete
(
node
)
;
}
}
;
for
(
let
record
of
records
)
{
if
(
!
seenEver
.
has
(
record
)
)
{
traverse
(
record
)
;
}
}
return
cycles
;
}
compareServerWithClient
(
serverRecords
clientTree
)
{
let
clientRecords
=
this
.
createClientRecordsFromTree
(
clientTree
)
;
let
inspectionInfo
=
this
.
inspectServerRecords
(
serverRecords
)
;
inspectionInfo
.
clientRecords
=
clientRecords
;
serverRecords
=
inspectionInfo
.
records
;
let
problemData
=
inspectionInfo
.
problemData
;
let
matches
=
[
]
;
let
allRecords
=
new
Map
(
)
;
let
serverDeletedLookup
=
new
Set
(
inspectionInfo
.
deletedRecords
.
map
(
r
=
>
r
.
id
)
)
;
for
(
let
sr
of
serverRecords
)
{
allRecords
.
set
(
sr
.
id
{
client
:
null
server
:
sr
}
)
;
}
for
(
let
cr
of
clientRecords
)
{
let
unified
=
allRecords
.
get
(
cr
.
id
)
;
if
(
!
unified
)
{
allRecords
.
set
(
cr
.
id
{
client
:
cr
server
:
null
}
)
;
}
else
{
unified
.
client
=
cr
;
}
}
for
(
let
[
id
{
client
server
}
]
of
allRecords
)
{
if
(
!
client
&
&
server
)
{
problemData
.
clientMissing
.
push
(
id
)
;
continue
;
}
if
(
!
server
&
&
client
)
{
if
(
serverDeletedLookup
.
has
(
id
)
)
{
problemData
.
serverDeleted
.
push
(
id
)
;
}
else
if
(
!
client
.
ignored
&
&
client
.
id
!
=
"
places
"
)
{
problemData
.
serverMissing
.
push
(
id
)
;
}
continue
;
}
if
(
server
&
&
client
&
&
client
.
ignored
)
{
problemData
.
serverUnexpected
.
push
(
id
)
;
}
let
differences
=
[
]
;
let
structuralDifferences
=
[
]
;
if
(
(
client
.
title
|
|
"
"
)
!
=
=
(
server
.
title
|
|
"
"
)
)
{
differences
.
push
(
'
title
'
)
;
}
if
(
client
.
parentid
|
|
server
.
parentid
)
{
if
(
client
.
parentid
!
=
=
server
.
parentid
)
{
structuralDifferences
.
push
(
'
parentid
'
)
;
}
if
(
client
.
parentName
!
=
=
server
.
parentName
&
&
server
.
parentid
!
=
=
'
unfiled
'
)
{
differences
.
push
(
'
parentName
'
)
;
}
}
if
(
client
.
tags
|
|
server
.
tags
)
{
let
cl
=
client
.
tags
|
|
[
]
;
let
sl
=
server
.
tags
|
|
[
]
;
if
(
cl
.
length
!
=
=
sl
.
length
|
|
!
cl
.
every
(
(
tag
i
)
=
>
sl
.
indexOf
(
tag
)
>
=
0
)
)
{
differences
.
push
(
'
tags
'
)
;
}
}
let
sameType
=
client
.
type
=
=
=
server
.
type
;
if
(
!
sameType
)
{
if
(
server
.
type
=
=
=
"
query
"
&
&
client
.
type
=
=
=
"
bookmark
"
&
&
client
.
bmkUri
.
startsWith
(
"
place
:
"
)
)
{
sameType
=
true
;
}
}
if
(
!
sameType
)
{
differences
.
push
(
'
type
'
)
;
}
else
{
switch
(
server
.
type
)
{
case
'
bookmark
'
:
case
'
query
'
:
if
(
server
.
bmkUri
!
=
=
client
.
bmkUri
)
{
differences
.
push
(
'
bmkUri
'
)
;
}
break
;
case
"
livemark
"
:
if
(
server
.
feedUri
!
=
client
.
feedUri
)
{
differences
.
push
(
"
feedUri
"
)
;
}
if
(
server
.
siteUri
!
=
client
.
siteUri
)
{
differences
.
push
(
"
siteUri
"
)
;
}
break
;
case
'
folder
'
:
if
(
server
.
id
=
=
=
'
places
'
&
&
!
problemData
.
rootOnServer
)
{
break
;
}
if
(
client
.
childGUIDs
|
|
server
.
childGUIDs
)
{
let
cl
=
client
.
childGUIDs
|
|
[
]
;
let
sl
=
server
.
childGUIDs
|
|
[
]
;
if
(
cl
.
length
!
=
=
sl
.
length
|
|
!
cl
.
every
(
(
id
i
)
=
>
sl
[
i
]
=
=
=
id
)
)
{
structuralDifferences
.
push
(
'
childGUIDs
'
)
;
}
}
break
;
}
}
if
(
differences
.
length
)
{
problemData
.
differences
.
push
(
{
id
differences
}
)
;
}
if
(
structuralDifferences
.
length
)
{
problemData
.
structuralDifferences
.
push
(
{
id
differences
:
structuralDifferences
}
)
;
}
}
return
inspectionInfo
;
}
}
;
