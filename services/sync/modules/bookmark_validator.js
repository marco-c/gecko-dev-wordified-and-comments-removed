"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Async
"
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesSyncUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
URLSearchParams
"
]
)
;
var
EXPORTED_SYMBOLS
=
[
"
BookmarkValidator
"
"
BookmarkProblemData
"
]
;
const
QUERY_PROTOCOL
=
"
place
:
"
;
function
areURLsEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
a
.
startsWith
(
QUERY_PROTOCOL
)
!
=
b
.
startsWith
(
QUERY_PROTOCOL
)
)
{
return
false
;
}
let
aParams
=
new
URLSearchParams
(
a
.
slice
(
QUERY_PROTOCOL
.
length
)
)
;
let
aType
=
+
aParams
.
get
(
"
type
"
)
;
if
(
aType
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
false
;
}
let
bParams
=
new
URLSearchParams
(
b
.
slice
(
QUERY_PROTOCOL
.
length
)
)
;
let
bType
=
+
bParams
.
get
(
"
type
"
)
;
if
(
bType
!
=
Ci
.
nsINavHistoryQueryOptions
.
RESULTS_AS_TAG_CONTENTS
)
{
return
false
;
}
let
aKeys
=
new
Set
(
aParams
.
keys
(
)
)
;
let
bKeys
=
new
Set
(
bParams
.
keys
(
)
)
;
if
(
aKeys
.
size
!
=
bKeys
.
size
)
{
return
false
;
}
if
(
aKeys
.
has
(
"
folder
"
)
&
&
aParams
.
getAll
(
"
folder
"
)
.
every
(
isFinite
)
)
{
aKeys
.
delete
(
"
folder
"
)
;
}
if
(
bKeys
.
has
(
"
folder
"
)
&
&
bParams
.
getAll
(
"
folder
"
)
.
every
(
isFinite
)
)
{
bKeys
.
delete
(
"
folder
"
)
;
}
for
(
let
key
of
aKeys
)
{
if
(
!
bKeys
.
has
(
key
)
)
{
return
false
;
}
if
(
!
CommonUtils
.
arrayEqual
(
aParams
.
getAll
(
key
)
.
sort
(
)
bParams
.
getAll
(
key
)
.
sort
(
)
)
)
{
return
false
;
}
}
for
(
let
key
of
bKeys
)
{
if
(
!
aKeys
.
has
(
key
)
)
{
return
false
;
}
}
return
true
;
}
const
BOOKMARK_VALIDATOR_VERSION
=
1
;
class
BookmarkProblemData
{
constructor
(
)
{
this
.
rootOnServer
=
false
;
this
.
missingIDs
=
0
;
this
.
duplicates
=
[
]
;
this
.
parentChildMismatches
=
[
]
;
this
.
cycles
=
[
]
;
this
.
clientCycles
=
[
]
;
this
.
orphans
=
[
]
;
this
.
missingChildren
=
[
]
;
this
.
deletedChildren
=
[
]
;
this
.
multipleParents
=
[
]
;
this
.
deletedParents
=
[
]
;
this
.
childrenOnNonFolder
=
[
]
;
this
.
duplicateChildren
=
[
]
;
this
.
parentNotFolder
=
[
]
;
this
.
badClientRoots
=
[
]
;
this
.
clientMissing
=
[
]
;
this
.
serverMissing
=
[
]
;
this
.
serverDeleted
=
[
]
;
this
.
serverUnexpected
=
[
]
;
this
.
differences
=
[
]
;
this
.
structuralDifferences
=
[
]
;
}
_summarizeDifferences
(
prefix
diffs
)
{
let
diffCounts
=
new
Map
(
)
;
for
(
let
{
differences
}
of
diffs
)
{
for
(
let
type
of
differences
)
{
let
name
=
prefix
+
"
:
"
+
type
;
let
count
=
diffCounts
.
get
(
name
)
|
|
0
;
diffCounts
.
set
(
name
count
+
1
)
;
}
}
return
[
.
.
.
diffCounts
]
.
map
(
(
[
name
count
]
)
=
>
(
{
name
count
}
)
)
;
}
getSummary
(
full
)
{
let
result
=
[
{
name
:
"
clientMissing
"
count
:
this
.
clientMissing
.
length
}
{
name
:
"
serverMissing
"
count
:
this
.
serverMissing
.
length
}
{
name
:
"
serverDeleted
"
count
:
this
.
serverDeleted
.
length
}
{
name
:
"
serverUnexpected
"
count
:
this
.
serverUnexpected
.
length
}
{
name
:
"
structuralDifferences
"
count
:
this
.
structuralDifferences
.
length
}
{
name
:
"
differences
"
count
:
this
.
differences
.
length
}
{
name
:
"
missingIDs
"
count
:
this
.
missingIDs
}
{
name
:
"
rootOnServer
"
count
:
this
.
rootOnServer
?
1
:
0
}
{
name
:
"
duplicates
"
count
:
this
.
duplicates
.
length
}
{
name
:
"
parentChildMismatches
"
count
:
this
.
parentChildMismatches
.
length
}
{
name
:
"
cycles
"
count
:
this
.
cycles
.
length
}
{
name
:
"
clientCycles
"
count
:
this
.
clientCycles
.
length
}
{
name
:
"
badClientRoots
"
count
:
this
.
badClientRoots
.
length
}
{
name
:
"
orphans
"
count
:
this
.
orphans
.
length
}
{
name
:
"
missingChildren
"
count
:
this
.
missingChildren
.
length
}
{
name
:
"
deletedChildren
"
count
:
this
.
deletedChildren
.
length
}
{
name
:
"
multipleParents
"
count
:
this
.
multipleParents
.
length
}
{
name
:
"
deletedParents
"
count
:
this
.
deletedParents
.
length
}
{
name
:
"
childrenOnNonFolder
"
count
:
this
.
childrenOnNonFolder
.
length
}
{
name
:
"
duplicateChildren
"
count
:
this
.
duplicateChildren
.
length
}
{
name
:
"
parentNotFolder
"
count
:
this
.
parentNotFolder
.
length
}
]
;
if
(
full
)
{
let
structural
=
this
.
_summarizeDifferences
(
"
sdiff
"
this
.
structuralDifferences
)
;
result
.
push
.
apply
(
result
structural
)
;
}
return
result
;
}
}
XPCOMUtils
.
defineLazyGetter
(
this
"
SYNCED_ROOTS
"
(
)
=
>
[
PlacesUtils
.
bookmarks
.
menuGuid
PlacesUtils
.
bookmarks
.
toolbarGuid
PlacesUtils
.
bookmarks
.
unfiledGuid
PlacesUtils
.
bookmarks
.
mobileGuid
]
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ROOT_GUID_TO_QUERY_FOLDER_NAME
"
(
)
=
>
(
{
[
PlacesUtils
.
bookmarks
.
rootGuid
]
:
"
PLACES_ROOT
"
[
PlacesUtils
.
bookmarks
.
menuGuid
]
:
"
BOOKMARKS_MENU
"
[
PlacesUtils
.
bookmarks
.
tagsGuid
]
:
"
TAGS
"
[
PlacesUtils
.
bookmarks
.
unfiledGuid
]
:
"
UNFILED_BOOKMARKS
"
[
PlacesUtils
.
bookmarks
.
toolbarGuid
]
:
"
TOOLBAR
"
[
PlacesUtils
.
bookmarks
.
mobileGuid
]
:
"
MOBILE_BOOKMARKS
"
}
)
)
;
async
function
detectCycles
(
records
)
{
let
pathLookup
=
new
Set
(
)
;
let
currentPath
=
[
]
;
let
cycles
=
[
]
;
let
seenEver
=
new
Set
(
)
;
const
yieldState
=
Async
.
yieldState
(
)
;
const
traverse
=
async
node
=
>
{
if
(
pathLookup
.
has
(
node
)
)
{
let
cycleStart
=
currentPath
.
lastIndexOf
(
node
)
;
let
cyclePath
=
currentPath
.
slice
(
cycleStart
)
.
map
(
n
=
>
n
.
id
)
;
cycles
.
push
(
cyclePath
)
;
return
;
}
else
if
(
seenEver
.
has
(
node
)
)
{
return
;
}
seenEver
.
add
(
node
)
;
let
children
=
node
.
children
|
|
[
]
;
if
(
node
.
concreteItems
)
{
children
.
push
(
.
.
.
node
.
concreteItems
)
;
}
if
(
children
.
length
)
{
pathLookup
.
add
(
node
)
;
currentPath
.
push
(
node
)
;
await
Async
.
yieldingForEach
(
children
traverse
yieldState
)
;
currentPath
.
pop
(
)
;
pathLookup
.
delete
(
node
)
;
}
}
;
await
Async
.
yieldingForEach
(
records
async
record
=
>
{
if
(
!
seenEver
.
has
(
record
)
)
{
await
traverse
(
record
)
;
}
}
yieldState
)
;
return
cycles
;
}
class
ServerRecordInspection
{
constructor
(
)
{
this
.
serverRecords
=
null
;
this
.
liveRecords
=
[
]
;
this
.
folders
=
[
]
;
this
.
root
=
null
;
this
.
idToRecord
=
new
Map
(
)
;
this
.
deletedIds
=
new
Set
(
)
;
this
.
deletedRecords
=
[
]
;
this
.
problemData
=
new
BookmarkProblemData
(
)
;
this
.
_orphans
=
new
Map
(
)
;
this
.
_multipleParents
=
new
Map
(
)
;
this
.
yieldState
=
Async
.
yieldState
(
)
;
}
static
async
create
(
records
)
{
return
new
ServerRecordInspection
(
)
.
performInspection
(
records
)
;
}
async
performInspection
(
records
)
{
await
this
.
_setRecords
(
records
)
;
await
this
.
_linkParentIDs
(
)
;
await
this
.
_linkChildren
(
)
;
await
this
.
_findOrphans
(
)
;
await
this
.
_finish
(
)
;
return
this
;
}
_noteOrphan
(
id
parentId
=
undefined
)
{
if
(
parentId
|
|
!
this
.
_orphans
.
has
(
id
)
)
{
this
.
_orphans
.
set
(
id
parentId
)
;
}
}
noteParent
(
child
parent
)
{
let
parents
=
this
.
_multipleParents
.
get
(
child
)
;
if
(
!
parents
)
{
this
.
_multipleParents
.
set
(
child
[
parent
]
)
;
}
else
{
parents
.
push
(
parent
)
;
}
}
noteMismatch
(
child
parent
)
{
let
exists
=
this
.
problemData
.
parentChildMismatches
.
some
(
match
=
>
match
.
child
=
=
child
&
&
match
.
parent
=
=
parent
)
;
if
(
!
exists
)
{
this
.
problemData
.
parentChildMismatches
.
push
(
{
child
parent
}
)
;
}
}
async
_setRecords
(
records
)
{
if
(
this
.
serverRecords
)
{
throw
new
Error
(
"
Bug
:
ServerRecordInspection
can
'
t
setRecords
twice
"
)
;
}
this
.
serverRecords
=
records
;
let
rootChildren
=
[
]
;
await
Async
.
yieldingForEach
(
this
.
serverRecords
async
record
=
>
{
if
(
!
record
.
id
)
{
+
+
this
.
problemData
.
missingIDs
;
return
;
}
if
(
record
.
deleted
)
{
this
.
deletedIds
.
add
(
record
.
id
)
;
}
if
(
this
.
idToRecord
.
has
(
record
.
id
)
)
{
this
.
problemData
.
duplicates
.
push
(
record
.
id
)
;
return
;
}
this
.
idToRecord
.
set
(
record
.
id
record
)
;
if
(
!
record
.
deleted
)
{
this
.
liveRecords
.
push
(
record
)
;
if
(
record
.
parentid
=
=
"
places
"
)
{
rootChildren
.
push
(
record
)
;
}
}
if
(
!
record
.
children
)
{
return
;
}
if
(
record
.
type
!
=
"
folder
"
)
{
if
(
!
record
.
children
.
length
)
{
return
;
}
this
.
problemData
.
childrenOnNonFolder
.
push
(
record
.
id
)
;
}
this
.
folders
.
push
(
record
)
;
if
(
new
Set
(
record
.
children
)
.
size
!
=
=
record
.
children
.
length
)
{
this
.
problemData
.
duplicateChildren
.
push
(
record
.
id
)
;
}
record
.
childGUIDs
=
record
.
children
;
await
Async
.
yieldingForEach
(
record
.
childGUIDs
id
=
>
{
this
.
noteParent
(
id
record
.
id
)
;
}
this
.
yieldState
)
;
record
.
children
=
[
]
;
}
this
.
yieldState
)
;
this
.
deletedRecords
=
Array
.
from
(
this
.
deletedIds
id
=
>
this
.
idToRecord
.
get
(
id
)
)
;
this
.
_initRoot
(
rootChildren
)
;
}
_initRoot
(
rootChildren
)
{
let
serverRoot
=
this
.
idToRecord
.
get
(
"
places
"
)
;
if
(
serverRoot
)
{
this
.
root
=
serverRoot
;
this
.
problemData
.
rootOnServer
=
true
;
return
;
}
this
.
root
=
{
id
:
"
places
"
fake
:
true
children
:
rootChildren
childGUIDs
:
rootChildren
.
map
(
record
=
>
record
.
id
)
type
:
"
folder
"
title
:
"
"
}
;
this
.
liveRecords
.
push
(
this
.
root
)
;
this
.
idToRecord
.
set
(
"
places
"
this
.
root
)
;
}
async
_linkParentIDs
(
)
{
await
Async
.
yieldingForEach
(
this
.
idToRecord
(
[
id
record
]
)
=
>
{
if
(
record
=
=
this
.
root
|
|
record
.
deleted
)
{
return
false
;
}
let
parentID
=
record
.
parentid
;
let
parent
=
this
.
idToRecord
.
get
(
parentID
)
;
if
(
!
parentID
|
|
!
parent
)
{
this
.
_noteOrphan
(
id
parentID
)
;
return
false
;
}
record
.
parent
=
parent
;
if
(
parent
.
deleted
)
{
this
.
problemData
.
deletedParents
.
push
(
id
)
;
return
true
;
}
else
if
(
parent
.
type
!
=
"
folder
"
)
{
this
.
problemData
.
parentNotFolder
.
push
(
record
.
id
)
;
return
true
;
}
if
(
parent
.
id
!
=
=
"
place
"
|
|
this
.
problemData
.
rootOnServer
)
{
if
(
!
parent
.
childGUIDs
.
includes
(
record
.
id
)
)
{
this
.
noteMismatch
(
record
.
id
parent
.
id
)
;
}
}
if
(
parent
.
deleted
&
&
!
record
.
deleted
)
{
this
.
problemData
.
deletedParents
.
push
(
record
.
id
)
;
}
return
false
;
}
this
.
yieldState
)
;
}
async
_linkChildren
(
)
{
await
Async
.
yieldingForEach
(
this
.
folders
async
folder
=
>
{
folder
.
children
=
[
]
;
folder
.
unfilteredChildren
=
[
]
;
let
idsThisFolder
=
new
Set
(
)
;
await
Async
.
yieldingForEach
(
folder
.
childGUIDs
childID
=
>
{
let
child
=
this
.
idToRecord
.
get
(
childID
)
;
if
(
!
child
)
{
this
.
problemData
.
missingChildren
.
push
(
{
parent
:
folder
.
id
child
:
childID
}
)
;
return
;
}
if
(
child
.
deleted
)
{
this
.
problemData
.
deletedChildren
.
push
(
{
parent
:
folder
.
id
child
:
childID
}
)
;
return
;
}
if
(
child
.
parentid
!
=
folder
.
id
)
{
this
.
noteMismatch
(
childID
folder
.
id
)
;
return
;
}
if
(
idsThisFolder
.
has
(
childID
)
)
{
return
;
}
folder
.
children
.
push
(
child
)
;
}
this
.
yieldState
)
;
}
this
.
yieldState
)
;
}
async
_findOrphans
(
)
{
let
seen
=
new
Set
(
[
this
.
root
.
id
]
)
;
const
inCycle
=
await
Async
.
yieldingForEach
(
Utils
.
walkTree
(
this
.
root
)
(
[
node
]
)
=
>
{
if
(
seen
.
has
(
node
.
id
)
)
{
return
true
;
}
seen
.
add
(
node
.
id
)
;
return
false
;
}
this
.
yieldState
)
;
if
(
inCycle
)
{
return
;
}
await
Async
.
yieldingForEach
(
this
.
liveRecords
(
record
i
)
=
>
{
if
(
!
seen
.
has
(
record
.
id
)
)
{
this
.
_noteOrphan
(
record
.
id
)
;
}
}
this
.
yieldState
)
;
await
Async
.
yieldingForEach
(
this
.
_orphans
(
[
id
parent
]
)
=
>
{
this
.
problemData
.
orphans
.
push
(
{
id
parent
}
)
;
}
this
.
yieldState
)
;
}
async
_finish
(
)
{
this
.
problemData
.
cycles
=
await
detectCycles
(
this
.
liveRecords
)
;
for
(
const
[
child
recordedParents
]
of
this
.
_multipleParents
)
{
let
parents
=
new
Set
(
recordedParents
)
;
if
(
parents
.
size
>
1
)
{
this
.
problemData
.
multipleParents
.
push
(
{
child
parents
:
[
.
.
.
parents
]
}
)
;
}
}
const
idArrayProps
=
[
"
duplicates
"
"
deletedParents
"
"
childrenOnNonFolder
"
"
duplicateChildren
"
"
parentNotFolder
"
]
;
for
(
let
prop
of
idArrayProps
)
{
this
.
problemData
[
prop
]
=
[
.
.
.
new
Set
(
this
.
problemData
[
prop
]
)
]
;
}
}
}
class
BookmarkValidator
{
constructor
(
)
{
this
.
yieldState
=
Async
.
yieldState
(
)
;
}
async
canValidate
(
)
{
return
!
(
await
PlacesSyncUtils
.
bookmarks
.
havePendingChanges
(
)
)
;
}
async
_followQueries
(
recordsByQueryId
)
{
await
Async
.
yieldingForEach
(
recordsByQueryId
.
values
(
)
entry
=
>
{
if
(
entry
.
type
!
=
=
"
query
"
&
&
(
!
entry
.
bmkUri
|
|
!
entry
.
bmkUri
.
startsWith
(
QUERY_PROTOCOL
)
)
)
{
return
;
}
let
params
=
new
URLSearchParams
(
entry
.
bmkUri
.
slice
(
QUERY_PROTOCOL
.
length
)
)
;
let
excludeQueries
=
params
.
get
(
"
excludeQueries
"
)
;
if
(
excludeQueries
=
=
=
"
1
"
|
|
excludeQueries
=
=
=
"
true
"
)
{
return
;
}
entry
.
concreteItems
=
[
]
;
let
queryIds
=
params
.
getAll
(
"
folder
"
)
;
for
(
let
queryId
of
queryIds
)
{
let
concreteItem
=
recordsByQueryId
.
get
(
queryId
)
;
if
(
concreteItem
)
{
entry
.
concreteItems
.
push
(
concreteItem
)
;
}
}
}
this
.
yieldState
)
;
}
async
createClientRecordsFromTree
(
clientTree
)
{
let
records
=
[
]
;
let
recordsByQueryId
=
new
Map
(
)
;
let
syncedRoots
=
SYNCED_ROOTS
;
const
traverse
=
async
(
treeNode
synced
)
=
>
{
if
(
!
synced
)
{
synced
=
syncedRoots
.
includes
(
treeNode
.
guid
)
;
}
let
localId
=
treeNode
.
id
;
let
guid
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
treeNode
.
guid
)
;
let
itemType
=
"
item
"
;
treeNode
.
ignored
=
!
synced
;
treeNode
.
id
=
guid
;
switch
(
treeNode
.
type
)
{
case
PlacesUtils
.
TYPE_X_MOZ_PLACE
:
if
(
treeNode
.
uri
.
startsWith
(
QUERY_PROTOCOL
)
)
{
itemType
=
"
query
"
;
}
else
{
itemType
=
"
bookmark
"
;
}
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
:
let
isLivemark
=
false
;
if
(
treeNode
.
annos
)
{
for
(
let
anno
of
treeNode
.
annos
)
{
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
{
isLivemark
=
true
;
treeNode
.
feedUri
=
anno
.
value
;
}
else
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_SITEURI
)
{
isLivemark
=
true
;
treeNode
.
siteUri
=
anno
.
value
;
}
}
}
itemType
=
isLivemark
?
"
livemark
"
:
"
folder
"
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
itemType
=
"
separator
"
;
break
;
}
if
(
treeNode
.
tags
)
{
treeNode
.
tags
=
treeNode
.
tags
.
split
(
"
"
)
;
}
else
{
treeNode
.
tags
=
[
]
;
}
treeNode
.
type
=
itemType
;
treeNode
.
pos
=
treeNode
.
index
;
treeNode
.
bmkUri
=
treeNode
.
uri
;
records
.
push
(
treeNode
)
;
if
(
treeNode
.
guid
in
ROOT_GUID_TO_QUERY_FOLDER_NAME
)
{
let
queryId
=
ROOT_GUID_TO_QUERY_FOLDER_NAME
[
treeNode
.
guid
]
;
recordsByQueryId
.
set
(
queryId
treeNode
)
;
}
if
(
localId
)
{
recordsByQueryId
.
set
(
localId
.
toString
(
10
)
treeNode
)
;
}
if
(
treeNode
.
type
=
=
=
"
folder
"
)
{
treeNode
.
childGUIDs
=
[
]
;
if
(
!
treeNode
.
children
)
{
treeNode
.
children
=
[
]
;
}
await
Async
.
yieldingForEach
(
treeNode
.
children
async
child
=
>
{
await
traverse
(
child
synced
)
;
child
.
parent
=
treeNode
;
child
.
parentid
=
guid
;
treeNode
.
childGUIDs
.
push
(
child
.
guid
)
;
}
this
.
yieldState
)
;
}
}
;
await
traverse
(
clientTree
false
)
;
clientTree
.
id
=
"
places
"
;
await
this
.
_followQueries
(
recordsByQueryId
)
;
return
records
;
}
async
inspectServerRecords
(
serverRecords
)
{
const
data
=
await
ServerRecordInspection
.
create
(
serverRecords
)
;
return
{
deletedRecords
:
data
.
deletedRecords
records
:
data
.
liveRecords
problemData
:
data
.
problemData
root
:
data
.
root
}
;
}
async
_validateClient
(
problemData
clientRecords
)
{
problemData
.
clientCycles
=
await
detectCycles
(
clientRecords
)
;
for
(
let
rootGUID
of
SYNCED_ROOTS
)
{
let
record
=
clientRecords
.
find
(
record
=
>
record
.
guid
=
=
=
rootGUID
)
;
if
(
!
record
|
|
record
.
parentid
!
=
=
"
places
"
)
{
problemData
.
badClientRoots
.
push
(
rootGUID
)
;
}
}
}
async
_computeUnifiedRecordMap
(
serverRecords
clientRecords
)
{
let
allRecords
=
new
Map
(
)
;
await
Async
.
yieldingForEach
(
serverRecords
sr
=
>
{
if
(
sr
.
fake
)
{
return
;
}
allRecords
.
set
(
sr
.
id
{
client
:
null
server
:
sr
}
)
;
}
this
.
yieldState
)
;
await
Async
.
yieldingForEach
(
clientRecords
cr
=
>
{
let
unified
=
allRecords
.
get
(
cr
.
id
)
;
if
(
!
unified
)
{
allRecords
.
set
(
cr
.
id
{
client
:
cr
server
:
null
}
)
;
}
else
{
unified
.
client
=
cr
;
}
}
this
.
yieldState
)
;
return
allRecords
;
}
_recordMissing
(
problems
id
clientRecord
serverRecord
serverTombstones
)
{
if
(
!
clientRecord
&
&
serverRecord
)
{
problems
.
clientMissing
.
push
(
id
)
;
}
if
(
!
serverRecord
&
&
clientRecord
)
{
if
(
serverTombstones
.
has
(
id
)
)
{
problems
.
serverDeleted
.
push
(
id
)
;
}
else
if
(
!
clientRecord
.
ignored
&
&
clientRecord
.
id
!
=
"
places
"
)
{
problems
.
serverMissing
.
push
(
id
)
;
}
}
}
_compareRecords
(
client
server
)
{
let
structuralDifferences
=
[
]
;
let
differences
=
[
]
;
if
(
!
SYNCED_ROOTS
.
includes
(
client
.
guid
)
)
{
if
(
(
client
.
title
|
|
"
"
)
!
=
=
(
server
.
title
|
|
"
"
)
)
{
differences
.
push
(
"
title
"
)
;
}
}
if
(
client
.
parentid
|
|
server
.
parentid
)
{
if
(
client
.
parentid
!
=
=
server
.
parentid
)
{
structuralDifferences
.
push
(
"
parentid
"
)
;
}
}
if
(
client
.
tags
|
|
server
.
tags
)
{
let
cl
=
client
.
tags
?
[
.
.
.
client
.
tags
]
.
sort
(
)
:
[
]
;
let
sl
=
server
.
tags
?
[
.
.
.
server
.
tags
]
.
sort
(
)
:
[
]
;
if
(
!
CommonUtils
.
arrayEqual
(
cl
sl
)
)
{
differences
.
push
(
"
tags
"
)
;
}
}
let
sameType
=
client
.
type
=
=
=
server
.
type
;
if
(
!
sameType
)
{
if
(
server
.
type
=
=
=
"
query
"
&
&
client
.
type
=
=
=
"
bookmark
"
&
&
client
.
bmkUri
.
startsWith
(
QUERY_PROTOCOL
)
)
{
sameType
=
true
;
}
}
if
(
!
sameType
)
{
differences
.
push
(
"
type
"
)
;
}
else
{
switch
(
server
.
type
)
{
case
"
bookmark
"
:
case
"
query
"
:
if
(
!
areURLsEqual
(
server
.
bmkUri
client
.
bmkUri
)
)
{
differences
.
push
(
"
bmkUri
"
)
;
}
break
;
case
"
separator
"
:
if
(
server
.
pos
!
=
client
.
pos
)
{
differences
.
push
(
"
pos
"
)
;
}
break
;
case
"
livemark
"
:
if
(
server
.
feedUri
!
=
client
.
feedUri
)
{
differences
.
push
(
"
feedUri
"
)
;
}
if
(
server
.
siteUri
!
=
client
.
siteUri
)
{
differences
.
push
(
"
siteUri
"
)
;
}
break
;
case
"
folder
"
:
if
(
server
.
id
=
=
=
"
places
"
&
&
server
.
fake
)
{
break
;
}
if
(
client
.
childGUIDs
|
|
server
.
childGUIDs
)
{
let
cl
=
client
.
childGUIDs
|
|
[
]
;
let
sl
=
server
.
childGUIDs
|
|
[
]
;
if
(
!
CommonUtils
.
arrayEqual
(
cl
sl
)
)
{
structuralDifferences
.
push
(
"
childGUIDs
"
)
;
}
}
break
;
}
}
return
{
differences
structuralDifferences
}
;
}
async
compareServerWithClient
(
serverRecords
clientTree
)
{
let
clientRecords
=
await
this
.
createClientRecordsFromTree
(
clientTree
)
;
let
inspectionInfo
=
await
this
.
inspectServerRecords
(
serverRecords
)
;
inspectionInfo
.
clientRecords
=
clientRecords
;
serverRecords
=
inspectionInfo
.
records
;
let
problemData
=
inspectionInfo
.
problemData
;
await
this
.
_validateClient
(
problemData
clientRecords
)
;
let
allRecords
=
await
this
.
_computeUnifiedRecordMap
(
serverRecords
clientRecords
)
;
let
serverDeleted
=
new
Set
(
inspectionInfo
.
deletedRecords
.
map
(
r
=
>
r
.
id
)
)
;
await
Async
.
yieldingForEach
(
allRecords
(
[
id
{
client
server
}
]
)
=
>
{
if
(
!
client
|
|
!
server
)
{
this
.
_recordMissing
(
problemData
id
client
server
serverDeleted
)
;
return
;
}
if
(
server
&
&
client
&
&
client
.
ignored
)
{
problemData
.
serverUnexpected
.
push
(
id
)
;
}
let
{
differences
structuralDifferences
}
=
this
.
_compareRecords
(
client
server
)
;
if
(
differences
.
length
)
{
problemData
.
differences
.
push
(
{
id
differences
}
)
;
}
if
(
structuralDifferences
.
length
)
{
problemData
.
structuralDifferences
.
push
(
{
id
differences
:
structuralDifferences
}
)
;
}
}
this
.
yieldState
)
;
return
inspectionInfo
;
}
async
_getServerState
(
engine
)
{
let
collection
=
engine
.
itemSource
(
)
;
let
collectionKey
=
engine
.
service
.
collectionKeys
.
keyForCollection
(
engine
.
name
)
;
collection
.
full
=
true
;
let
result
=
await
collection
.
getBatched
(
)
;
if
(
!
result
.
response
.
success
)
{
throw
result
.
response
;
}
let
cleartexts
=
[
]
;
await
Async
.
yieldingForEach
(
result
.
records
async
record
=
>
{
await
record
.
decrypt
(
collectionKey
)
;
cleartexts
.
push
(
record
.
cleartext
)
;
}
this
.
yieldState
)
;
return
cleartexts
;
}
async
validate
(
engine
)
{
let
start
=
Date
.
now
(
)
;
let
clientTree
=
await
PlacesUtils
.
promiseBookmarksTree
(
"
"
{
includeItemIds
:
true
}
)
;
let
serverState
=
await
this
.
_getServerState
(
engine
)
;
let
serverRecordCount
=
serverState
.
length
;
let
result
=
await
this
.
compareServerWithClient
(
serverState
clientTree
)
;
let
end
=
Date
.
now
(
)
;
let
duration
=
end
-
start
;
engine
.
_log
.
debug
(
Validated
bookmarks
in
{
duration
}
ms
)
;
engine
.
_log
.
debug
(
Problem
summary
)
;
for
(
let
{
name
count
}
of
result
.
problemData
.
getSummary
(
)
)
{
engine
.
_log
.
debug
(
{
name
}
:
{
count
}
)
;
}
return
{
duration
version
:
this
.
version
problems
:
result
.
problemData
recordCount
:
serverRecordCount
}
;
}
}
BookmarkValidator
.
prototype
.
version
=
BOOKMARK_VALIDATOR_VERSION
;
