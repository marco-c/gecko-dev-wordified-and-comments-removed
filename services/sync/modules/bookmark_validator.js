"
use
strict
"
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
BookmarkValidator
"
"
BookmarkProblemData
"
]
;
class
BookmarkProblemData
{
constructor
(
)
{
this
.
rootOnServer
=
false
;
this
.
missingIDs
=
0
;
this
.
duplicates
=
[
]
;
this
.
parentChildMismatches
=
[
]
;
this
.
cycles
=
[
]
;
this
.
clientCycles
=
[
]
;
this
.
orphans
=
[
]
;
this
.
missingChildren
=
[
]
;
this
.
deletedChildren
=
[
]
;
this
.
multipleParents
=
[
]
;
this
.
deletedParents
=
[
]
;
this
.
childrenOnNonFolder
=
[
]
;
this
.
duplicateChildren
=
[
]
;
this
.
parentNotFolder
=
[
]
;
this
.
badClientRoots
=
[
]
;
this
.
clientMissing
=
[
]
;
this
.
serverMissing
=
[
]
;
this
.
serverDeleted
=
[
]
;
this
.
serverUnexpected
=
[
]
;
this
.
differences
=
[
]
;
this
.
structuralDifferences
=
[
]
;
}
_summarizeDifferences
(
prefix
diffs
)
{
let
diffCounts
=
new
Map
(
)
;
for
(
let
{
differences
}
of
diffs
)
{
for
(
let
type
of
differences
)
{
let
name
=
prefix
+
"
:
"
+
type
;
let
count
=
diffCounts
.
get
(
name
)
|
|
0
;
diffCounts
.
set
(
name
count
+
1
)
;
}
}
return
[
.
.
.
diffCounts
]
.
map
(
(
[
name
count
]
)
=
>
(
{
name
count
}
)
)
;
}
getSummary
(
full
)
{
let
result
=
[
{
name
:
"
clientMissing
"
count
:
this
.
clientMissing
.
length
}
{
name
:
"
serverMissing
"
count
:
this
.
serverMissing
.
length
}
{
name
:
"
serverDeleted
"
count
:
this
.
serverDeleted
.
length
}
{
name
:
"
serverUnexpected
"
count
:
this
.
serverUnexpected
.
length
}
{
name
:
"
structuralDifferences
"
count
:
this
.
structuralDifferences
.
length
}
{
name
:
"
differences
"
count
:
this
.
differences
.
length
}
{
name
:
"
missingIDs
"
count
:
this
.
missingIDs
}
{
name
:
"
rootOnServer
"
count
:
this
.
rootOnServer
?
1
:
0
}
{
name
:
"
duplicates
"
count
:
this
.
duplicates
.
length
}
{
name
:
"
parentChildMismatches
"
count
:
this
.
parentChildMismatches
.
length
}
{
name
:
"
cycles
"
count
:
this
.
cycles
.
length
}
{
name
:
"
clientCycles
"
count
:
this
.
clientCycles
.
length
}
{
name
:
"
badClientRoots
"
count
:
this
.
badClientRoots
.
length
}
{
name
:
"
orphans
"
count
:
this
.
orphans
.
length
}
{
name
:
"
missingChildren
"
count
:
this
.
missingChildren
.
length
}
{
name
:
"
deletedChildren
"
count
:
this
.
deletedChildren
.
length
}
{
name
:
"
multipleParents
"
count
:
this
.
multipleParents
.
length
}
{
name
:
"
deletedParents
"
count
:
this
.
deletedParents
.
length
}
{
name
:
"
childrenOnNonFolder
"
count
:
this
.
childrenOnNonFolder
.
length
}
{
name
:
"
duplicateChildren
"
count
:
this
.
duplicateChildren
.
length
}
{
name
:
"
parentNotFolder
"
count
:
this
.
parentNotFolder
.
length
}
]
;
if
(
full
)
{
let
structural
=
this
.
_summarizeDifferences
(
"
sdiff
"
this
.
structuralDifferences
)
;
result
.
push
.
apply
(
result
structural
)
;
}
return
result
;
}
}
class
BookmarkValidator
{
_followQueries
(
recordMap
)
{
for
(
let
[
guid
entry
]
of
recordMap
)
{
if
(
entry
.
type
!
=
=
"
query
"
&
&
(
!
entry
.
bmkUri
|
|
!
entry
.
bmkUri
.
startsWith
(
"
place
:
"
)
)
)
{
continue
;
}
let
queryNodeParent
=
PlacesUtils
.
getFolderContents
(
entry
false
true
)
;
if
(
!
queryNodeParent
|
|
!
queryNodeParent
.
root
.
hasChildren
)
{
continue
;
}
queryNodeParent
=
queryNodeParent
.
root
;
let
queryNode
=
null
;
let
numSiblings
=
0
;
let
containerWasOpen
=
queryNodeParent
.
containerOpen
;
queryNodeParent
.
containerOpen
=
true
;
try
{
try
{
numSiblings
=
queryNodeParent
.
childCount
;
}
catch
(
e
)
{
continue
;
}
for
(
let
i
=
0
;
i
<
numSiblings
&
&
!
queryNode
;
+
+
i
)
{
let
child
=
queryNodeParent
.
getChild
(
i
)
;
if
(
child
&
&
child
.
bookmarkGuid
&
&
child
.
bookmarkGuid
=
=
=
guid
)
{
queryNode
=
child
;
}
}
}
finally
{
queryNodeParent
.
containerOpen
=
containerWasOpen
;
}
if
(
!
queryNode
)
{
continue
;
}
let
concreteId
=
PlacesUtils
.
getConcreteItemGuid
(
queryNode
)
;
if
(
!
concreteId
)
{
continue
;
}
let
concreteItem
=
recordMap
.
get
(
concreteId
)
;
if
(
!
concreteItem
)
{
continue
;
}
entry
.
concrete
=
concreteItem
;
}
}
createClientRecordsFromTree
(
clientTree
)
{
let
records
=
[
]
;
let
recordsByGuid
=
new
Map
(
)
;
function
traverse
(
treeNode
)
{
let
guid
=
PlacesSyncUtils
.
bookmarks
.
guidToSyncId
(
treeNode
.
guid
)
;
let
itemType
=
'
item
'
;
treeNode
.
ignored
=
PlacesUtils
.
annotations
.
itemHasAnnotation
(
treeNode
.
id
PlacesUtils
.
EXCLUDE_FROM_BACKUP_ANNO
)
;
treeNode
.
id
=
guid
;
switch
(
treeNode
.
type
)
{
case
PlacesUtils
.
TYPE_X_MOZ_PLACE
:
let
query
=
null
;
if
(
treeNode
.
annos
&
&
treeNode
.
uri
.
startsWith
(
"
place
:
"
)
)
{
query
=
treeNode
.
annos
.
find
(
(
{
name
}
)
=
>
name
=
=
=
PlacesSyncUtils
.
bookmarks
.
SMART_BOOKMARKS_ANNO
)
;
}
if
(
query
&
&
query
.
value
)
{
itemType
=
'
query
'
;
}
else
{
itemType
=
'
bookmark
'
;
}
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
:
let
isLivemark
=
false
;
if
(
treeNode
.
annos
)
{
for
(
let
anno
of
treeNode
.
annos
)
{
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_FEEDURI
)
{
isLivemark
=
true
;
treeNode
.
feedUri
=
anno
.
value
;
}
else
if
(
anno
.
name
=
=
=
PlacesUtils
.
LMANNO_SITEURI
)
{
isLivemark
=
true
;
treeNode
.
siteUri
=
anno
.
value
;
}
}
}
itemType
=
isLivemark
?
"
livemark
"
:
"
folder
"
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
itemType
=
'
separator
'
;
break
;
}
if
(
treeNode
.
tags
)
{
treeNode
.
tags
=
treeNode
.
tags
.
split
(
"
"
)
;
}
else
{
treeNode
.
tags
=
[
]
;
}
treeNode
.
type
=
itemType
;
treeNode
.
pos
=
treeNode
.
index
;
treeNode
.
bmkUri
=
treeNode
.
uri
;
records
.
push
(
treeNode
)
;
recordsByGuid
.
set
(
treeNode
.
guid
treeNode
)
;
if
(
treeNode
.
type
=
=
=
'
folder
'
)
{
treeNode
.
childGUIDs
=
[
]
;
if
(
!
treeNode
.
children
)
{
treeNode
.
children
=
[
]
;
}
for
(
let
child
of
treeNode
.
children
)
{
traverse
(
child
)
;
child
.
parent
=
treeNode
;
child
.
parentid
=
guid
;
treeNode
.
childGUIDs
.
push
(
child
.
guid
)
;
}
}
}
traverse
(
clientTree
)
;
clientTree
.
id
=
'
places
'
;
this
.
_followQueries
(
recordsByGuid
)
;
return
records
;
}
inspectServerRecords
(
serverRecords
)
{
let
deletedItemIds
=
new
Set
(
)
;
let
idToRecord
=
new
Map
(
)
;
let
deletedRecords
=
[
]
;
let
folders
=
[
]
;
let
problems
=
[
]
;
let
problemData
=
new
BookmarkProblemData
(
)
;
let
resultRecords
=
[
]
;
for
(
let
record
of
serverRecords
)
{
if
(
!
record
.
id
)
{
+
+
problemData
.
missingIDs
;
continue
;
}
if
(
record
.
deleted
)
{
deletedItemIds
.
add
(
record
.
id
)
;
}
else
{
if
(
idToRecord
.
has
(
record
.
id
)
)
{
problemData
.
duplicates
.
push
(
record
.
id
)
;
continue
;
}
}
idToRecord
.
set
(
record
.
id
record
)
;
if
(
record
.
children
)
{
if
(
record
.
type
!
=
=
"
folder
"
)
{
if
(
!
record
.
children
.
length
)
{
continue
;
}
problemData
.
childrenOnNonFolder
.
push
(
record
.
id
)
;
}
folders
.
push
(
record
)
;
if
(
new
Set
(
record
.
children
)
.
size
!
=
=
record
.
children
.
length
)
{
problemData
.
duplicateChildren
.
push
(
record
.
id
)
}
record
.
childGUIDs
=
record
.
children
;
record
.
children
=
record
.
children
.
map
(
childID
=
>
{
return
PlacesSyncUtils
.
bookmarks
.
guidToSyncId
(
childID
)
;
}
)
;
}
}
for
(
let
deletedId
of
deletedItemIds
)
{
let
record
=
idToRecord
.
get
(
deletedId
)
;
if
(
record
&
&
!
record
.
isDeleted
)
{
deletedRecords
.
push
(
record
)
;
record
.
isDeleted
=
true
;
}
}
let
root
=
idToRecord
.
get
(
'
places
'
)
;
if
(
!
root
)
{
root
=
{
id
:
'
places
'
children
:
[
]
type
:
'
folder
'
title
:
'
'
}
;
resultRecords
.
push
(
root
)
;
idToRecord
.
set
(
'
places
'
root
)
;
}
else
{
problemData
.
rootOnServer
=
true
;
}
for
(
let
[
id
record
]
of
idToRecord
)
{
if
(
record
=
=
=
root
)
{
continue
;
}
if
(
record
.
isDeleted
)
{
continue
;
}
let
parentID
=
record
.
parentid
;
if
(
!
parentID
)
{
problemData
.
orphans
.
push
(
{
id
:
record
.
id
parent
:
parentID
}
)
;
continue
;
}
let
parent
=
idToRecord
.
get
(
parentID
)
;
if
(
!
parent
)
{
problemData
.
orphans
.
push
(
{
id
:
record
.
id
parent
:
parentID
}
)
;
continue
;
}
if
(
parent
.
type
!
=
=
'
folder
'
)
{
problemData
.
parentNotFolder
.
push
(
record
.
id
)
;
if
(
!
parent
.
children
)
{
parent
.
children
=
[
]
;
}
if
(
!
parent
.
childGUIDs
)
{
parent
.
childGUIDs
=
[
]
;
}
}
if
(
!
record
.
isDeleted
)
{
resultRecords
.
push
(
record
)
;
}
record
.
parent
=
parent
;
if
(
parent
!
=
=
root
|
|
problemData
.
rootOnServer
)
{
let
childIndex
=
parent
.
children
.
indexOf
(
id
)
;
if
(
childIndex
<
0
)
{
problemData
.
parentChildMismatches
.
push
(
{
parent
:
parent
.
id
child
:
record
.
id
}
)
;
}
else
{
parent
.
children
[
childIndex
]
=
record
;
}
}
else
{
parent
.
children
.
push
(
record
)
;
}
if
(
parent
.
isDeleted
&
&
!
record
.
isDeleted
)
{
problemData
.
deletedParents
.
push
(
record
.
id
)
;
}
}
for
(
let
folder
of
folders
)
{
folder
.
unfilteredChildren
=
folder
.
children
;
folder
.
children
=
[
]
;
for
(
let
ci
=
0
;
ci
<
folder
.
unfilteredChildren
.
length
;
+
+
ci
)
{
let
child
=
folder
.
unfilteredChildren
[
ci
]
;
let
childObject
;
if
(
typeof
child
=
=
"
string
"
)
{
childObject
=
idToRecord
.
get
(
child
)
;
if
(
!
childObject
)
{
problemData
.
missingChildren
.
push
(
{
parent
:
folder
.
id
child
}
)
;
}
else
{
folder
.
unfilteredChildren
[
ci
]
=
childObject
;
if
(
childObject
.
isDeleted
)
{
problemData
.
deletedChildren
.
push
(
{
parent
:
folder
.
id
child
}
)
;
}
}
}
else
{
childObject
=
child
;
}
if
(
!
childObject
)
{
continue
;
}
if
(
childObject
.
parentid
=
=
=
folder
.
id
)
{
folder
.
children
.
push
(
childObject
)
;
continue
;
}
let
currentProblemRecord
=
problemData
.
multipleParents
.
find
(
pr
=
>
pr
.
child
=
=
=
child
)
;
if
(
currentProblemRecord
)
{
currentProblemRecord
.
parents
.
push
(
folder
.
id
)
;
continue
;
}
let
otherParent
=
idToRecord
.
get
(
childObject
.
parentid
)
;
if
(
!
otherParent
)
{
problemData
.
multipleParents
.
push
(
{
child
parents
:
[
folder
.
id
]
}
)
;
if
(
!
problemData
.
orphans
.
some
(
r
=
>
r
.
id
=
=
=
child
)
)
{
problemData
.
orphans
.
push
(
{
id
:
child
parent
:
childObject
.
parentid
}
)
;
}
continue
;
}
if
(
otherParent
.
isDeleted
)
{
if
(
!
problemData
.
deletedParents
.
includes
(
child
)
)
{
problemData
.
deletedParents
.
push
(
child
)
;
}
continue
;
}
if
(
otherParent
.
childGUIDs
&
&
!
otherParent
.
childGUIDs
.
includes
(
child
)
)
{
if
(
!
problemData
.
parentChildMismatches
.
some
(
r
=
>
r
.
child
=
=
=
child
)
)
{
problemData
.
parentChildMismatches
.
push
(
{
child
parent
:
folder
.
id
}
)
;
}
}
problemData
.
multipleParents
.
push
(
{
child
parents
:
[
childObject
.
parentid
folder
.
id
]
}
)
;
}
}
problemData
.
multipleParents
=
problemData
.
multipleParents
.
filter
(
record
=
>
record
.
parents
.
length
>
=
2
)
;
problemData
.
cycles
=
this
.
_detectCycles
(
resultRecords
)
;
return
{
deletedRecords
records
:
resultRecords
problemData
root
}
;
}
_detectCycles
(
records
)
{
let
pathLookup
=
new
Set
(
)
;
let
currentPath
=
[
]
;
let
cycles
=
[
]
;
let
seenEver
=
new
Set
(
)
;
const
traverse
=
node
=
>
{
if
(
pathLookup
.
has
(
node
)
)
{
let
cycleStart
=
currentPath
.
lastIndexOf
(
node
)
;
let
cyclePath
=
currentPath
.
slice
(
cycleStart
)
.
map
(
n
=
>
n
.
id
)
;
cycles
.
push
(
cyclePath
)
;
return
;
}
else
if
(
seenEver
.
has
(
node
)
)
{
return
;
}
seenEver
.
add
(
node
)
;
let
children
=
node
.
children
|
|
[
]
;
if
(
node
.
concrete
)
{
children
.
push
(
node
.
concrete
)
;
}
if
(
children
)
{
pathLookup
.
add
(
node
)
;
currentPath
.
push
(
node
)
;
for
(
let
child
of
children
)
{
traverse
(
child
)
;
}
currentPath
.
pop
(
)
;
pathLookup
.
delete
(
node
)
;
}
}
;
for
(
let
record
of
records
)
{
if
(
!
seenEver
.
has
(
record
)
)
{
traverse
(
record
)
;
}
}
return
cycles
;
}
_validateClient
(
problemData
clientRecords
)
{
problemData
.
clientCycles
=
this
.
_detectCycles
(
clientRecords
)
;
const
rootsToCheck
=
[
PlacesUtils
.
bookmarks
.
menuGuid
PlacesUtils
.
bookmarks
.
toolbarGuid
PlacesUtils
.
bookmarks
.
unfiledGuid
PlacesUtils
.
bookmarks
.
mobileGuid
]
;
for
(
let
rootGUID
of
rootsToCheck
)
{
let
record
=
clientRecords
.
find
(
record
=
>
record
.
guid
=
=
=
rootGUID
)
;
if
(
!
record
|
|
record
.
parentid
!
=
=
"
places
"
)
{
problemData
.
badClientRoots
.
push
(
rootGUID
)
;
}
}
}
compareServerWithClient
(
serverRecords
clientTree
)
{
let
clientRecords
=
this
.
createClientRecordsFromTree
(
clientTree
)
;
let
inspectionInfo
=
this
.
inspectServerRecords
(
serverRecords
)
;
inspectionInfo
.
clientRecords
=
clientRecords
;
serverRecords
=
inspectionInfo
.
records
;
let
problemData
=
inspectionInfo
.
problemData
;
this
.
_validateClient
(
problemData
clientRecords
)
;
let
matches
=
[
]
;
let
allRecords
=
new
Map
(
)
;
let
serverDeletedLookup
=
new
Set
(
inspectionInfo
.
deletedRecords
.
map
(
r
=
>
r
.
id
)
)
;
for
(
let
sr
of
serverRecords
)
{
allRecords
.
set
(
sr
.
id
{
client
:
null
server
:
sr
}
)
;
}
for
(
let
cr
of
clientRecords
)
{
let
unified
=
allRecords
.
get
(
cr
.
id
)
;
if
(
!
unified
)
{
allRecords
.
set
(
cr
.
id
{
client
:
cr
server
:
null
}
)
;
}
else
{
unified
.
client
=
cr
;
}
}
for
(
let
[
id
{
client
server
}
]
of
allRecords
)
{
if
(
!
client
&
&
server
)
{
problemData
.
clientMissing
.
push
(
id
)
;
continue
;
}
if
(
!
server
&
&
client
)
{
if
(
serverDeletedLookup
.
has
(
id
)
)
{
problemData
.
serverDeleted
.
push
(
id
)
;
}
else
if
(
!
client
.
ignored
&
&
client
.
id
!
=
"
places
"
)
{
problemData
.
serverMissing
.
push
(
id
)
;
}
continue
;
}
if
(
server
&
&
client
&
&
client
.
ignored
)
{
problemData
.
serverUnexpected
.
push
(
id
)
;
}
let
differences
=
[
]
;
let
structuralDifferences
=
[
]
;
if
(
(
client
.
title
|
|
"
"
)
!
=
=
(
server
.
title
|
|
"
"
)
)
{
differences
.
push
(
'
title
'
)
;
}
if
(
client
.
parentid
|
|
server
.
parentid
)
{
if
(
client
.
parentid
!
=
=
server
.
parentid
)
{
structuralDifferences
.
push
(
'
parentid
'
)
;
}
}
if
(
client
.
tags
|
|
server
.
tags
)
{
let
cl
=
client
.
tags
|
|
[
]
;
let
sl
=
server
.
tags
|
|
[
]
;
if
(
cl
.
length
!
=
=
sl
.
length
|
|
!
cl
.
every
(
(
tag
i
)
=
>
sl
.
indexOf
(
tag
)
>
=
0
)
)
{
differences
.
push
(
'
tags
'
)
;
}
}
let
sameType
=
client
.
type
=
=
=
server
.
type
;
if
(
!
sameType
)
{
if
(
server
.
type
=
=
=
"
query
"
&
&
client
.
type
=
=
=
"
bookmark
"
&
&
client
.
bmkUri
.
startsWith
(
"
place
:
"
)
)
{
sameType
=
true
;
}
}
if
(
!
sameType
)
{
differences
.
push
(
'
type
'
)
;
}
else
{
switch
(
server
.
type
)
{
case
'
bookmark
'
:
case
'
query
'
:
if
(
server
.
bmkUri
!
=
=
client
.
bmkUri
)
{
differences
.
push
(
'
bmkUri
'
)
;
}
break
;
case
"
livemark
"
:
if
(
server
.
feedUri
!
=
client
.
feedUri
)
{
differences
.
push
(
"
feedUri
"
)
;
}
if
(
server
.
siteUri
!
=
client
.
siteUri
)
{
differences
.
push
(
"
siteUri
"
)
;
}
break
;
case
'
folder
'
:
if
(
server
.
id
=
=
=
'
places
'
&
&
!
problemData
.
rootOnServer
)
{
break
;
}
if
(
client
.
childGUIDs
|
|
server
.
childGUIDs
)
{
let
cl
=
client
.
childGUIDs
|
|
[
]
;
let
sl
=
server
.
childGUIDs
|
|
[
]
;
if
(
cl
.
length
!
=
=
sl
.
length
|
|
!
cl
.
every
(
(
id
i
)
=
>
sl
[
i
]
=
=
=
id
)
)
{
structuralDifferences
.
push
(
'
childGUIDs
'
)
;
}
}
break
;
}
}
if
(
differences
.
length
)
{
problemData
.
differences
.
push
(
{
id
differences
}
)
;
}
if
(
structuralDifferences
.
length
)
{
problemData
.
structuralDifferences
.
push
(
{
id
differences
:
structuralDifferences
}
)
;
}
}
return
inspectionInfo
;
}
_getServerState
(
engine
)
{
let
collection
=
engine
.
itemSource
(
)
;
let
collectionKey
=
engine
.
service
.
collectionKeys
.
keyForCollection
(
engine
.
name
)
;
collection
.
full
=
true
;
let
items
=
[
]
;
collection
.
recordHandler
=
function
(
item
)
{
item
.
decrypt
(
collectionKey
)
;
items
.
push
(
item
.
cleartext
)
;
}
;
let
resp
=
collection
.
getBatched
(
)
;
if
(
!
resp
.
success
)
{
throw
resp
;
}
return
items
;
}
validate
(
engine
)
{
let
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
let
start
=
Date
.
now
(
)
;
let
clientTree
=
yield
PlacesUtils
.
promiseBookmarksTree
(
"
"
{
includeItemIds
:
true
}
)
;
let
serverState
=
self
.
_getServerState
(
engine
)
;
let
serverRecordCount
=
serverState
.
length
;
let
result
=
self
.
compareServerWithClient
(
serverState
clientTree
)
;
let
end
=
Date
.
now
(
)
;
let
duration
=
end
-
start
;
return
{
duration
problems
:
result
.
problemData
recordCount
:
serverRecordCount
}
;
}
)
;
}
}
;
