"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ErrorSanitizer
"
"
SyncRecord
"
"
SyncTelemetry
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
Async
:
"
resource
:
/
/
services
-
common
/
async
.
js
"
AuthenticationError
:
"
resource
:
/
/
services
-
sync
/
sync_auth
.
js
"
FxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
ObjectUtils
:
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
Observers
:
"
resource
:
/
/
services
-
common
/
observers
.
js
"
Resource
:
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
Status
:
"
resource
:
/
/
services
-
sync
/
status
.
js
"
Svc
:
"
resource
:
/
/
services
-
sync
/
util
.
js
"
TelemetryController
:
"
resource
:
/
/
gre
/
modules
/
TelemetryController
.
jsm
"
TelemetryEnvironment
:
"
resource
:
/
/
gre
/
modules
/
TelemetryEnvironment
.
jsm
"
TelemetryUtils
:
"
resource
:
/
/
gre
/
modules
/
TelemetryUtils
.
jsm
"
Weave
:
"
resource
:
/
/
services
-
sync
/
main
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
fxAccounts
"
(
)
=
>
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
.
getFxAccountsSingleton
(
)
;
}
)
;
let
constants
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
WeaveService
"
(
)
=
>
Cc
[
"
mozilla
.
org
/
weave
/
service
;
1
"
]
.
getService
(
)
.
wrappedJSObject
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Telemetry
"
)
;
const
TOPICS
=
[
"
fxaccounts
:
new_device_id
"
"
fxaccounts
:
onlogout
"
"
weave
:
service
:
ready
"
"
weave
:
service
:
login
:
got
-
hashed
-
id
"
"
weave
:
service
:
sync
:
start
"
"
weave
:
service
:
sync
:
finish
"
"
weave
:
service
:
sync
:
error
"
"
weave
:
engine
:
sync
:
start
"
"
weave
:
engine
:
sync
:
finish
"
"
weave
:
engine
:
sync
:
error
"
"
weave
:
engine
:
sync
:
applied
"
"
weave
:
engine
:
sync
:
step
"
"
weave
:
engine
:
sync
:
uploaded
"
"
weave
:
engine
:
validate
:
finish
"
"
weave
:
engine
:
validate
:
error
"
"
weave
:
telemetry
:
event
"
"
weave
:
telemetry
:
histogram
"
"
fxa
:
telemetry
:
event
"
"
weave
:
telemetry
:
migration
"
]
;
const
PING_FORMAT_VERSION
=
1
;
const
EMPTY_UID
=
"
0
"
.
repeat
(
32
)
;
const
ENGINES
=
new
Set
(
[
"
addons
"
"
bookmarks
"
"
clients
"
"
forms
"
"
history
"
"
passwords
"
"
prefs
"
"
tabs
"
"
extension
-
storage
"
"
addresses
"
"
creditcards
"
]
)
;
function
tryGetMonotonicTimestamp
(
)
{
try
{
return
Services
.
telemetry
.
msSinceProcessStart
(
)
;
}
catch
(
e
)
{
log
.
warn
(
"
Unable
to
get
a
monotonic
timestamp
!
"
)
;
return
-
1
;
}
}
function
timeDeltaFrom
(
monotonicStartTime
)
{
let
now
=
tryGetMonotonicTimestamp
(
)
;
if
(
monotonicStartTime
!
=
=
-
1
&
&
now
!
=
=
-
1
)
{
return
Math
.
round
(
now
-
monotonicStartTime
)
;
}
return
-
1
;
}
const
NS_ERROR_MODULE_BASE_OFFSET
=
0x45
;
const
NS_ERROR_MODULE_NETWORK
=
6
;
function
NS_ERROR_GET_MODULE
(
code
)
{
return
(
(
code
&
0x7fff0000
)
>
>
16
)
-
NS_ERROR_MODULE_BASE_OFFSET
;
}
function
normalizeExtraTelemetryFields
(
extra
)
{
let
result
=
{
}
;
for
(
let
key
in
extra
)
{
let
value
=
extra
[
key
]
;
let
type
=
typeof
value
;
if
(
type
=
=
"
string
"
)
{
result
[
key
]
=
ErrorSanitizer
.
cleanErrorMessage
(
value
)
;
}
else
if
(
type
=
=
"
number
"
)
{
result
[
key
]
=
Number
.
isInteger
(
value
)
?
value
.
toString
(
10
)
:
value
.
toFixed
(
3
)
;
}
else
if
(
type
!
=
"
undefined
"
)
{
throw
new
TypeError
(
Invalid
type
{
type
}
for
extra
telemetry
field
{
key
}
)
;
}
}
return
lazy
.
ObjectUtils
.
isEmpty
(
result
)
?
undefined
:
result
;
}
class
ErrorSanitizer
{
static
E_NO_SPACE_ON_DEVICE
=
"
OS
error
[
No
space
left
on
device
]
"
;
static
E_PERMISSION_DENIED
=
"
OS
error
[
Permission
denied
]
"
;
static
E_NO_FILE_OR_DIR
=
"
OS
error
[
File
/
Path
not
found
]
"
;
static
E_NO_MEM
=
"
OS
error
[
No
memory
]
"
;
static
WindowsErrorSubstitutions
=
{
"
2
"
:
this
.
E_NO_FILE_OR_DIR
"
3
"
:
this
.
E_NO_FILE_OR_DIR
"
5
"
:
this
.
E_PERMISSION_DENIED
"
8
"
:
this
.
E_NO_MEM
"
112
"
:
this
.
E_NO_SPACE_ON_DEVICE
}
;
static
UnixErrorSubstitutions
=
{
"
2
"
:
this
.
E_NO_FILE_OR_DIR
"
12
"
:
this
.
E_NO_MEM
"
13
"
:
this
.
E_PERMISSION_DENIED
"
28
"
:
this
.
E_NO_SPACE_ON_DEVICE
}
;
static
DOMErrorSubstitutions
=
{
NotFoundError
:
this
.
E_NO_FILE_OR_DIR
NotAllowedError
:
this
.
E_PERMISSION_DENIED
}
;
static
reWinError
=
/
^
(
?
<
head
>
Win
error
(
?
<
errno
>
\
d
+
)
)
(
?
<
detail
>
.
*
)
\
(
.
*
\
r
?
\
n
?
\
)
/
m
;
static
reUnixError
=
/
^
(
?
<
head
>
Unix
error
(
?
<
errno
>
\
d
+
)
)
(
?
<
detail
>
.
*
)
\
(
.
*
\
)
/
;
static
#
cleanOSErrorMessage
(
message
error
=
undefined
)
{
if
(
DOMException
.
isInstance
(
error
)
)
{
const
sub
=
this
.
DOMErrorSubstitutions
[
error
.
name
]
;
message
=
message
.
replaceAll
(
"
\
\
"
"
/
"
)
;
if
(
sub
)
{
return
{
sub
}
{
message
}
;
}
}
let
match
=
this
.
reWinError
.
exec
(
message
)
;
if
(
match
)
{
let
head
=
this
.
WindowsErrorSubstitutions
[
match
.
groups
.
errno
]
|
|
match
.
groups
.
head
;
return
head
+
match
.
groups
.
detail
.
replaceAll
(
"
\
\
"
"
/
"
)
;
}
match
=
this
.
reUnixError
.
exec
(
message
)
;
if
(
match
)
{
let
head
=
this
.
UnixErrorSubstitutions
[
match
.
groups
.
errno
]
|
|
match
.
groups
.
head
;
return
head
+
match
.
groups
.
detail
;
}
return
message
;
}
static
reProfileDir
=
new
RegExp
(
PathUtils
.
profileDir
.
replace
(
/
[
.
*
+
?
^
{
}
(
)
|
[
\
]
\
\
]
/
g
"
\
\
&
"
)
"
gi
"
)
;
static
cleanErrorMessage
(
message
error
=
undefined
)
{
message
=
message
.
replace
(
this
.
reProfileDir
"
[
profileDir
]
"
)
;
if
(
message
.
endsWith
(
"
is
not
a
valid
URL
.
"
)
)
{
message
=
"
<
URL
>
is
not
a
valid
URL
.
"
;
}
message
=
message
.
replace
(
/
[
^
\
s
"
]
+
:
[
^
\
s
"
]
+
/
g
"
<
URL
>
"
)
;
message
=
message
.
replace
(
/
<
guid
:
(
[
^
>
]
+
)
>
/
g
"
<
GUID
>
"
)
;
return
this
.
#
cleanOSErrorMessage
(
message
error
)
;
}
}
function
validateTelemetryEvent
(
eventDetails
)
{
let
{
object
method
value
extra
}
=
eventDetails
;
if
(
typeof
method
!
=
"
string
"
|
|
typeof
object
!
=
"
string
"
|
|
(
value
&
&
typeof
value
!
=
"
string
"
)
|
|
(
extra
&
&
typeof
extra
!
=
"
object
"
)
)
{
log
.
warn
(
"
Invalid
event
parameters
-
wrong
types
"
eventDetails
)
;
return
false
;
}
if
(
method
.
length
>
20
|
|
object
.
length
>
20
|
|
(
value
&
&
value
.
length
>
80
)
)
{
log
.
warn
(
"
Invalid
event
parameters
-
wrong
lengths
"
eventDetails
)
;
return
false
;
}
if
(
extra
)
{
if
(
Object
.
keys
(
extra
)
.
length
>
10
)
{
log
.
warn
(
"
Invalid
event
parameters
-
too
many
extra
keys
"
eventDetails
)
;
return
false
;
}
for
(
let
[
ename
evalue
]
of
Object
.
entries
(
extra
)
)
{
if
(
typeof
ename
!
=
"
string
"
|
|
ename
.
length
>
15
|
|
typeof
evalue
!
=
"
string
"
|
|
evalue
.
length
>
85
)
{
log
.
warn
(
Invalid
event
parameters
:
extra
item
"
{
ename
}
is
invalid
eventDetails
)
;
return
false
;
}
}
}
return
true
;
}
class
EngineRecord
{
constructor
(
name
)
{
this
.
startTime
=
tryGetMonotonicTimestamp
(
)
;
this
.
name
=
name
;
let
engineImpl
=
lazy
.
Weave
.
Service
.
engineManager
.
get
(
name
)
;
if
(
engineImpl
&
&
engineImpl
.
overrideTelemetryName
)
{
this
.
overrideTelemetryName
=
engineImpl
.
overrideTelemetryName
;
}
}
toJSON
(
)
{
let
result
=
{
name
:
this
.
overrideTelemetryName
|
|
this
.
name
}
;
let
properties
=
[
"
took
"
"
status
"
"
failureReason
"
"
incoming
"
"
outgoing
"
"
validation
"
"
steps
"
]
;
for
(
let
property
of
properties
)
{
result
[
property
]
=
this
[
property
]
;
}
return
result
;
}
finished
(
error
)
{
let
took
=
timeDeltaFrom
(
this
.
startTime
)
;
if
(
took
>
0
)
{
this
.
took
=
took
;
}
if
(
error
)
{
this
.
failureReason
=
SyncTelemetry
.
transformError
(
error
)
;
}
}
recordApplied
(
counts
)
{
if
(
this
.
incoming
)
{
log
.
error
(
Incoming
records
applied
multiple
times
for
engine
{
this
.
name
}
!
)
;
return
;
}
if
(
this
.
name
=
=
=
"
clients
"
&
&
!
counts
.
failed
)
{
return
;
}
let
incomingData
=
{
}
;
let
properties
=
[
"
applied
"
"
failed
"
]
;
for
(
let
property
of
properties
)
{
if
(
counts
[
property
]
)
{
incomingData
[
property
]
=
counts
[
property
]
;
this
.
incoming
=
incomingData
;
}
}
}
recordStep
(
stepResult
)
{
let
step
=
{
name
:
stepResult
.
name
}
;
if
(
stepResult
.
took
>
0
)
{
step
.
took
=
Math
.
round
(
stepResult
.
took
)
;
}
if
(
stepResult
.
counts
)
{
let
counts
=
stepResult
.
counts
.
filter
(
(
{
count
}
)
=
>
count
>
0
)
;
if
(
counts
.
length
)
{
step
.
counts
=
counts
;
}
}
if
(
this
.
steps
)
{
this
.
steps
.
push
(
step
)
;
}
else
{
this
.
steps
=
[
step
]
;
}
}
recordValidation
(
validationResult
)
{
if
(
this
.
validation
)
{
log
.
error
(
Multiple
validations
occurred
for
engine
{
this
.
name
}
!
)
;
return
;
}
let
{
problems
version
took
checked
}
=
validationResult
;
let
validation
=
{
version
:
version
|
|
0
checked
:
checked
|
|
0
}
;
if
(
took
>
0
)
{
validation
.
took
=
Math
.
round
(
took
)
;
}
let
summarized
=
problems
.
filter
(
(
{
count
}
)
=
>
count
>
0
)
;
if
(
summarized
.
length
)
{
validation
.
problems
=
summarized
;
}
this
.
validation
=
validation
;
}
recordValidationError
(
e
)
{
if
(
this
.
validation
)
{
log
.
error
(
Multiple
validations
occurred
for
engine
{
this
.
name
}
!
)
;
return
;
}
this
.
validation
=
{
failureReason
:
SyncTelemetry
.
transformError
(
e
)
}
;
}
recordUploaded
(
counts
)
{
if
(
counts
.
sent
|
|
counts
.
failed
)
{
if
(
!
this
.
outgoing
)
{
this
.
outgoing
=
[
]
;
}
this
.
outgoing
.
push
(
{
sent
:
counts
.
sent
|
|
undefined
failed
:
counts
.
failed
|
|
undefined
}
)
;
}
}
}
class
SyncRecord
{
constructor
(
allowedEngines
why
)
{
this
.
allowedEngines
=
allowedEngines
;
this
.
failureReason
=
undefined
;
this
.
syncNodeType
=
null
;
this
.
when
=
Date
.
now
(
)
;
this
.
startTime
=
tryGetMonotonicTimestamp
(
)
;
this
.
took
=
0
;
this
.
why
=
why
;
this
.
engines
=
[
]
;
this
.
currentEngine
=
null
;
}
toJSON
(
)
{
let
result
=
{
when
:
this
.
when
took
:
this
.
took
failureReason
:
this
.
failureReason
status
:
this
.
status
}
;
if
(
this
.
why
)
{
result
.
why
=
this
.
why
;
}
let
engines
=
[
]
;
for
(
let
engine
of
this
.
engines
)
{
engines
.
push
(
engine
.
toJSON
(
)
)
;
}
if
(
engines
.
length
>
0
)
{
result
.
engines
=
engines
;
}
return
result
;
}
finished
(
error
)
{
this
.
took
=
timeDeltaFrom
(
this
.
startTime
)
;
if
(
this
.
currentEngine
!
=
null
)
{
log
.
error
(
"
Finished
called
for
the
sync
before
the
current
engine
finished
"
)
;
this
.
currentEngine
.
finished
(
null
)
;
this
.
onEngineStop
(
this
.
currentEngine
.
name
)
;
}
if
(
error
)
{
this
.
failureReason
=
SyncTelemetry
.
transformError
(
error
)
;
}
this
.
syncNodeType
=
lazy
.
Weave
.
Service
.
identity
.
telemetryNodeType
;
for
(
let
engine
of
this
.
engines
)
{
let
status
=
lazy
.
Status
.
engines
[
engine
.
name
]
;
if
(
status
&
&
status
!
=
=
constants
.
ENGINE_SUCCEEDED
)
{
engine
.
status
=
status
;
}
}
let
statusObject
=
{
}
;
let
serviceStatus
=
lazy
.
Status
.
service
;
if
(
serviceStatus
&
&
serviceStatus
!
=
=
constants
.
STATUS_OK
)
{
statusObject
.
service
=
serviceStatus
;
this
.
status
=
statusObject
;
}
let
syncStatus
=
lazy
.
Status
.
sync
;
if
(
syncStatus
&
&
syncStatus
!
=
=
constants
.
SYNC_SUCCEEDED
)
{
statusObject
.
sync
=
syncStatus
;
this
.
status
=
statusObject
;
}
}
onEngineStart
(
engineName
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
false
)
)
{
return
;
}
if
(
this
.
currentEngine
)
{
log
.
error
(
Being
told
that
engine
{
engineName
}
has
started
but
current
engine
{
this
.
currentEngine
.
name
}
hasn
'
t
stopped
)
;
}
this
.
currentEngine
=
new
EngineRecord
(
engineName
)
;
}
onEngineStop
(
engineName
error
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
!
!
this
.
currentEngine
)
)
{
return
;
}
if
(
!
this
.
currentEngine
)
{
if
(
!
error
)
{
return
;
}
log
.
error
(
Error
triggered
on
{
engineName
}
when
no
current
engine
exists
:
{
error
}
)
;
this
.
currentEngine
=
new
EngineRecord
(
engineName
)
;
}
this
.
currentEngine
.
finished
(
error
)
;
this
.
engines
.
push
(
this
.
currentEngine
)
;
this
.
currentEngine
=
null
;
}
onEngineApplied
(
engineName
counts
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
)
)
{
return
;
}
this
.
currentEngine
.
recordApplied
(
counts
)
;
}
onEngineStep
(
engineName
step
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
)
)
{
return
;
}
this
.
currentEngine
.
recordStep
(
step
)
;
}
onEngineValidated
(
engineName
validationData
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
false
)
)
{
return
;
}
let
engine
=
this
.
engines
.
find
(
e
=
>
e
.
name
=
=
=
engineName
)
;
if
(
!
engine
&
&
this
.
currentEngine
&
&
engineName
=
=
=
this
.
currentEngine
.
name
)
{
engine
=
this
.
currentEngine
;
}
if
(
engine
)
{
engine
.
recordValidation
(
validationData
)
;
}
else
{
log
.
warn
(
Validation
event
triggered
for
engine
{
engineName
}
which
hasn
'
t
been
synced
!
)
;
}
}
onEngineValidateError
(
engineName
error
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
false
)
)
{
return
;
}
let
engine
=
this
.
engines
.
find
(
e
=
>
e
.
name
=
=
=
engineName
)
;
if
(
!
engine
&
&
this
.
currentEngine
&
&
engineName
=
=
=
this
.
currentEngine
.
name
)
{
engine
=
this
.
currentEngine
;
}
if
(
engine
)
{
engine
.
recordValidationError
(
error
)
;
}
else
{
log
.
warn
(
Validation
failure
event
triggered
for
engine
{
engineName
}
which
hasn
'
t
been
synced
!
)
;
}
}
onEngineUploaded
(
engineName
counts
)
{
if
(
this
.
_shouldIgnoreEngine
(
engineName
)
)
{
return
;
}
this
.
currentEngine
.
recordUploaded
(
counts
)
;
}
_shouldIgnoreEngine
(
engineName
shouldBeCurrent
=
true
)
{
if
(
!
this
.
allowedEngines
.
has
(
engineName
)
)
{
log
.
info
(
Notification
for
engine
{
engineName
}
but
we
aren
'
t
recording
telemetry
for
it
)
;
return
true
;
}
if
(
shouldBeCurrent
)
{
if
(
!
this
.
currentEngine
|
|
engineName
!
=
this
.
currentEngine
.
name
)
{
log
.
error
(
Notification
for
engine
{
engineName
}
but
it
isn
'
t
current
)
;
return
true
;
}
}
return
false
;
}
}
class
SyncTelemetryImpl
{
constructor
(
allowedEngines
)
{
log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
telemetry
"
)
;
this
.
allowedEngines
=
allowedEngines
;
this
.
current
=
null
;
this
.
setupObservers
(
)
;
this
.
payloads
=
[
]
;
this
.
discarded
=
0
;
this
.
events
=
[
]
;
this
.
histograms
=
{
}
;
this
.
migrations
=
[
]
;
this
.
maxEventsCount
=
lazy
.
Svc
.
Prefs
.
get
(
"
telemetry
.
maxEventsCount
"
1000
)
;
this
.
maxPayloadCount
=
lazy
.
Svc
.
Prefs
.
get
(
"
telemetry
.
maxPayloadCount
"
)
;
this
.
submissionInterval
=
lazy
.
Svc
.
Prefs
.
get
(
"
telemetry
.
submissionInterval
"
)
*
1000
;
this
.
lastSubmissionTime
=
Services
.
telemetry
.
msSinceProcessStart
(
)
;
this
.
lastUID
=
EMPTY_UID
;
this
.
lastSyncNodeType
=
null
;
this
.
currentSyncNodeType
=
null
;
let
sessionStartDate
=
new
Date
(
)
;
this
.
sessionStartDate
=
lazy
.
TelemetryUtils
.
toLocalTimeISOString
(
lazy
.
TelemetryUtils
.
truncateToHours
(
sessionStartDate
)
)
;
lazy
.
TelemetryController
.
registerSyncPingShutdown
(
(
)
=
>
this
.
shutdown
(
)
)
;
}
sanitizeFxaDeviceId
(
deviceId
)
{
return
lazy
.
fxAccounts
.
telemetry
.
sanitizeDeviceId
(
deviceId
)
;
}
prepareFxaDevices
(
devices
)
{
let
extraInfoMap
=
new
Map
(
)
;
if
(
this
.
syncIsEnabled
(
)
)
{
for
(
let
client
of
this
.
getClientsEngineRecords
(
)
)
{
if
(
client
.
fxaDeviceId
)
{
extraInfoMap
.
set
(
client
.
fxaDeviceId
{
os
:
client
.
os
version
:
client
.
version
syncID
:
this
.
sanitizeFxaDeviceId
(
client
.
id
)
}
)
;
}
}
}
return
devices
.
map
(
d
=
>
{
let
{
os
version
syncID
}
=
extraInfoMap
.
get
(
d
.
id
)
|
|
{
os
:
undefined
version
:
undefined
syncID
:
undefined
}
;
return
{
id
:
this
.
sanitizeFxaDeviceId
(
d
.
id
)
|
|
EMPTY_UID
type
:
d
.
type
os
version
syncID
}
;
}
)
;
}
syncIsEnabled
(
)
{
return
lazy
.
WeaveService
.
enabled
&
&
lazy
.
WeaveService
.
ready
;
}
getClientsEngineRecords
(
)
{
if
(
!
this
.
syncIsEnabled
(
)
)
{
throw
new
Error
(
"
Bug
:
syncIsEnabled
(
)
must
be
true
check
it
first
"
)
;
}
return
lazy
.
Weave
.
Service
.
clientsEngine
.
remoteClients
;
}
updateFxaDevices
(
devices
)
{
if
(
!
devices
)
{
return
{
}
;
}
let
me
=
devices
.
find
(
d
=
>
d
.
isCurrentDevice
)
;
let
id
=
me
?
this
.
sanitizeFxaDeviceId
(
me
.
id
)
:
undefined
;
let
cleanDevices
=
this
.
prepareFxaDevices
(
devices
)
;
return
{
deviceID
:
id
devices
:
cleanDevices
}
;
}
getFxaDevices
(
)
{
return
lazy
.
fxAccounts
.
device
.
recentDeviceList
;
}
getPingJSON
(
reason
)
{
let
{
devices
deviceID
}
=
this
.
updateFxaDevices
(
this
.
getFxaDevices
(
)
)
;
return
{
os
:
lazy
.
TelemetryEnvironment
.
currentEnvironment
.
system
.
os
why
:
reason
devices
discarded
:
this
.
discarded
|
|
undefined
version
:
PING_FORMAT_VERSION
syncs
:
this
.
payloads
.
slice
(
)
uid
:
this
.
lastUID
syncNodeType
:
this
.
lastSyncNodeType
|
|
undefined
deviceID
sessionStartDate
:
this
.
sessionStartDate
events
:
this
.
events
.
length
=
=
0
?
undefined
:
this
.
events
migrations
:
this
.
migrations
.
length
=
=
0
?
undefined
:
this
.
migrations
histograms
:
Object
.
keys
(
this
.
histograms
)
.
length
=
=
0
?
undefined
:
this
.
histograms
}
;
}
_addMigrationRecord
(
type
info
)
{
log
.
debug
(
"
Saw
telemetry
migration
info
"
type
info
)
;
switch
(
type
)
{
case
"
webext
-
storage
"
:
this
.
migrations
.
push
(
{
type
:
"
webext
-
storage
"
entries
:
+
info
.
entries
entriesSuccessful
:
+
info
.
entries_successful
extensions
:
+
info
.
extensions
extensionsSuccessful
:
+
info
.
extensions_successful
openFailure
:
!
!
info
.
open_failure
}
)
;
break
;
default
:
throw
new
Error
(
"
Bug
:
Unknown
migration
record
type
"
+
type
)
;
}
}
finish
(
reason
)
{
let
result
=
this
.
getPingJSON
(
reason
)
;
this
.
payloads
=
[
]
;
this
.
discarded
=
0
;
this
.
events
=
[
]
;
this
.
migrations
=
[
]
;
this
.
histograms
=
{
}
;
this
.
submit
(
result
)
;
}
setupObservers
(
)
{
for
(
let
topic
of
TOPICS
)
{
lazy
.
Observers
.
add
(
topic
this
this
)
;
}
}
shutdown
(
)
{
this
.
finish
(
"
shutdown
"
)
;
for
(
let
topic
of
TOPICS
)
{
lazy
.
Observers
.
remove
(
topic
this
this
)
;
}
}
submit
(
record
)
{
if
(
!
this
.
isProductionSyncUser
(
)
)
{
return
false
;
}
let
numEvents
=
record
.
events
?
record
.
events
.
length
:
0
;
let
numMigrations
=
record
.
migrations
?
record
.
migrations
.
length
:
0
;
if
(
record
.
syncs
.
length
|
|
numEvents
|
|
numMigrations
)
{
log
.
trace
(
submitting
{
record
.
syncs
.
length
}
sync
record
(
s
)
and
+
{
numEvents
}
event
(
s
)
to
telemetry
)
;
lazy
.
TelemetryController
.
submitExternalPing
(
"
sync
"
record
{
usePingSender
:
true
}
)
.
catch
(
err
=
>
{
log
.
error
(
"
failed
to
submit
ping
"
err
)
;
}
)
;
return
true
;
}
return
false
;
}
isProductionSyncUser
(
)
{
if
(
!
lazy
.
FxAccounts
.
config
.
isProductionConfig
(
)
|
|
Services
.
prefs
.
prefHasUserValue
(
"
services
.
sync
.
tokenServerURI
"
)
)
{
log
.
trace
(
Not
sending
telemetry
ping
for
self
-
hosted
Sync
user
)
;
return
false
;
}
return
true
;
}
onSyncStarted
(
data
)
{
const
why
=
data
&
&
JSON
.
parse
(
data
)
.
why
;
if
(
this
.
current
)
{
log
.
warn
(
"
Observed
weave
:
service
:
sync
:
start
but
we
'
re
already
recording
a
sync
!
"
)
;
this
.
current
=
null
;
}
this
.
current
=
new
SyncRecord
(
this
.
allowedEngines
why
)
;
}
onAccountInitOrChange
(
)
{
if
(
!
this
.
isProductionSyncUser
(
)
)
{
return
;
}
lazy
.
fxAccounts
.
device
.
getLocalId
(
)
.
then
(
deviceId
=
>
{
let
sanitizedDeviceId
=
lazy
.
fxAccounts
.
telemetry
.
sanitizeDeviceId
(
deviceId
)
;
if
(
sanitizedDeviceId
)
{
sanitizedDeviceId
=
sanitizedDeviceId
.
substr
(
0
32
)
;
Services
.
telemetry
.
scalarSet
(
"
deletion
.
request
.
sync_device_id
"
sanitizedDeviceId
)
;
}
}
)
.
catch
(
err
=
>
{
log
.
warn
(
Failed
to
set
sync
identifiers
in
the
deletion
-
request
ping
:
{
err
}
)
;
}
)
;
}
onAccountLogout
(
)
{
Services
.
telemetry
.
scalarSet
(
"
deletion
.
request
.
sync_device_id
"
"
"
)
;
}
_checkCurrent
(
topic
)
{
if
(
!
this
.
current
)
{
log
.
info
(
Observed
notification
{
topic
}
but
no
current
sync
is
being
recorded
.
)
;
return
false
;
}
return
true
;
}
_shouldSubmitForDataChange
(
)
{
let
newID
=
lazy
.
fxAccounts
.
telemetry
.
getSanitizedUID
(
)
|
|
EMPTY_UID
;
let
oldID
=
this
.
lastUID
;
if
(
newID
!
=
EMPTY_UID
&
&
oldID
!
=
EMPTY_UID
&
&
newID
!
=
oldID
)
{
log
.
trace
(
shouldSubmitForDataChange
-
uid
from
'
{
oldID
}
'
-
>
'
{
newID
}
'
)
;
return
true
;
}
if
(
this
.
lastSyncNodeType
&
&
this
.
currentSyncNodeType
!
=
this
.
lastSyncNodeType
)
{
log
.
trace
(
shouldSubmitForDataChange
-
nodeType
from
'
{
this
.
lastSyncNodeType
}
'
-
>
'
{
this
.
currentSyncNodeType
}
'
)
;
return
true
;
}
log
.
trace
(
"
shouldSubmitForDataChange
-
no
need
to
submit
"
)
;
return
false
;
}
maybeSubmitForDataChange
(
)
{
if
(
this
.
_shouldSubmitForDataChange
(
)
)
{
log
.
info
(
"
Early
submission
of
sync
telemetry
due
to
changed
IDs
/
NodeType
"
)
;
this
.
finish
(
"
idchange
"
)
;
this
.
lastSubmissionTime
=
Services
.
telemetry
.
msSinceProcessStart
(
)
;
}
let
current_uid
=
lazy
.
fxAccounts
.
telemetry
.
getSanitizedUID
(
)
;
if
(
current_uid
)
{
this
.
lastUID
=
current_uid
;
}
if
(
this
.
currentSyncNodeType
)
{
this
.
lastSyncNodeType
=
this
.
currentSyncNodeType
;
}
}
maybeSubmitForInterval
(
)
{
if
(
this
.
current
=
=
null
&
&
Services
.
telemetry
.
msSinceProcessStart
(
)
-
this
.
lastSubmissionTime
>
this
.
submissionInterval
)
{
this
.
finish
(
"
schedule
"
)
;
this
.
lastSubmissionTime
=
Services
.
telemetry
.
msSinceProcessStart
(
)
;
}
}
onSyncFinished
(
error
)
{
if
(
!
this
.
current
)
{
log
.
warn
(
"
onSyncFinished
but
we
aren
'
t
recording
"
)
;
return
;
}
this
.
current
.
finished
(
error
)
;
this
.
currentSyncNodeType
=
this
.
current
.
syncNodeType
;
let
current
=
this
.
current
;
this
.
current
=
null
;
this
.
takeTelemetryRecord
(
current
)
;
}
takeTelemetryRecord
(
record
)
{
this
.
maybeSubmitForDataChange
(
)
;
if
(
this
.
payloads
.
length
<
this
.
maxPayloadCount
)
{
this
.
payloads
.
push
(
record
.
toJSON
(
)
)
;
}
else
{
+
+
this
.
discarded
;
}
this
.
maybeSubmitForInterval
(
)
;
}
_addHistogram
(
hist
)
{
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
hist
)
;
let
s
=
histogram
.
snapshot
(
)
;
this
.
histograms
[
hist
]
=
s
;
}
_recordEvent
(
eventDetails
)
{
this
.
maybeSubmitForDataChange
(
)
;
if
(
this
.
events
.
length
>
=
this
.
maxEventsCount
)
{
log
.
warn
(
"
discarding
event
-
already
queued
our
maximum
"
eventDetails
)
;
return
;
}
let
{
object
method
value
extra
}
=
eventDetails
;
if
(
extra
)
{
extra
=
normalizeExtraTelemetryFields
(
extra
)
;
eventDetails
=
{
object
method
value
extra
}
;
}
if
(
!
validateTelemetryEvent
(
eventDetails
)
)
{
return
;
}
log
.
debug
(
"
recording
event
"
eventDetails
)
;
if
(
extra
&
&
lazy
.
Resource
.
serverTime
&
&
!
extra
.
serverTime
)
{
extra
.
serverTime
=
String
(
lazy
.
Resource
.
serverTime
)
;
}
let
category
=
"
sync
"
;
let
ts
=
Math
.
floor
(
tryGetMonotonicTimestamp
(
)
)
;
let
event
=
[
ts
category
method
object
]
;
if
(
value
)
{
event
.
push
(
value
)
;
if
(
extra
)
{
event
.
push
(
extra
)
;
}
}
else
if
(
extra
)
{
event
.
push
(
null
)
;
event
.
push
(
extra
)
;
}
this
.
events
.
push
(
event
)
;
this
.
maybeSubmitForInterval
(
)
;
}
observe
(
subject
topic
data
)
{
log
.
trace
(
observed
{
topic
}
{
data
}
)
;
switch
(
topic
)
{
case
"
weave
:
service
:
ready
"
:
case
"
weave
:
service
:
login
:
got
-
hashed
-
id
"
:
case
"
fxaccounts
:
new_device_id
"
:
this
.
onAccountInitOrChange
(
)
;
break
;
case
"
fxaccounts
:
onlogout
"
:
this
.
onAccountLogout
(
)
;
break
;
case
"
weave
:
service
:
sync
:
start
"
:
this
.
onSyncStarted
(
data
)
;
break
;
case
"
weave
:
service
:
sync
:
finish
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
onSyncFinished
(
null
)
;
}
break
;
case
"
weave
:
service
:
sync
:
error
"
:
this
.
onSyncFinished
(
subject
|
|
"
Unknown
"
)
;
break
;
case
"
weave
:
engine
:
sync
:
start
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineStart
(
data
)
;
}
break
;
case
"
weave
:
engine
:
sync
:
finish
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineStop
(
data
null
)
;
}
break
;
case
"
weave
:
engine
:
sync
:
error
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineStop
(
data
subject
|
|
"
Unknown
"
)
;
}
break
;
case
"
weave
:
engine
:
sync
:
applied
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineApplied
(
data
subject
)
;
}
break
;
case
"
weave
:
engine
:
sync
:
step
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineStep
(
data
subject
)
;
}
break
;
case
"
weave
:
engine
:
sync
:
uploaded
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineUploaded
(
data
subject
)
;
}
break
;
case
"
weave
:
engine
:
validate
:
finish
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineValidated
(
data
subject
)
;
}
break
;
case
"
weave
:
engine
:
validate
:
error
"
:
if
(
this
.
_checkCurrent
(
topic
)
)
{
this
.
current
.
onEngineValidateError
(
data
subject
|
|
"
Unknown
"
)
;
}
break
;
case
"
weave
:
telemetry
:
event
"
:
case
"
fxa
:
telemetry
:
event
"
:
this
.
_recordEvent
(
subject
)
;
break
;
case
"
weave
:
telemetry
:
histogram
"
:
this
.
_addHistogram
(
data
)
;
break
;
case
"
weave
:
telemetry
:
migration
"
:
this
.
_addMigrationRecord
(
data
subject
)
;
break
;
default
:
log
.
warn
(
unexpected
observer
topic
{
topic
}
)
;
break
;
}
}
transformError
(
error
)
{
if
(
typeof
error
=
=
"
object
"
&
&
error
.
code
&
&
error
.
cause
)
{
error
=
error
.
cause
;
}
if
(
lazy
.
Async
.
isShutdownException
(
error
)
)
{
return
{
name
:
"
shutdownerror
"
}
;
}
if
(
typeof
error
=
=
=
"
string
"
)
{
if
(
error
.
startsWith
(
"
error
.
"
)
)
{
return
{
name
:
"
othererror
"
error
}
;
}
error
=
ErrorSanitizer
.
cleanErrorMessage
(
error
)
;
return
{
name
:
"
unexpectederror
"
error
}
;
}
if
(
error
instanceof
lazy
.
AuthenticationError
)
{
return
{
name
:
"
autherror
"
from
:
error
.
source
}
;
}
if
(
DOMException
.
isInstance
(
error
)
)
{
return
{
name
:
"
unexpectederror
"
error
:
ErrorSanitizer
.
cleanErrorMessage
(
error
.
message
error
)
}
;
}
let
httpCode
=
error
.
status
|
|
(
error
.
response
&
&
error
.
response
.
status
)
|
|
error
.
code
;
if
(
httpCode
)
{
return
{
name
:
"
httperror
"
code
:
httpCode
}
;
}
if
(
error
.
failureCode
)
{
return
{
name
:
"
othererror
"
error
:
error
.
failureCode
}
;
}
if
(
error
.
result
)
{
if
(
error
.
result
=
=
Cr
.
NS_ERROR_ABORT
|
|
NS_ERROR_GET_MODULE
(
error
.
result
)
=
=
NS_ERROR_MODULE_NETWORK
)
{
return
{
name
:
"
httperror
"
code
:
error
.
result
}
;
}
return
{
name
:
"
nserror
"
code
:
error
.
result
}
;
}
let
msg
=
String
(
error
)
;
if
(
msg
.
startsWith
(
"
[
object
"
)
)
{
if
(
typeof
error
.
message
=
=
"
string
"
)
{
msg
=
String
(
error
.
message
)
;
}
else
{
msg
=
JSON
.
stringify
(
error
)
;
}
}
return
{
name
:
"
unexpectederror
"
error
:
ErrorSanitizer
.
cleanErrorMessage
(
msg
)
}
;
}
}
var
SyncTelemetry
=
new
SyncTelemetryImpl
(
ENGINES
)
;
