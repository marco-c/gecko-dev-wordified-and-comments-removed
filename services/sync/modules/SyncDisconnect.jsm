const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
Log
:
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
Sanitizer
:
"
resource
:
/
/
/
modules
/
Sanitizer
.
jsm
"
AsyncShutdown
:
"
resource
:
/
/
gre
/
modules
/
AsyncShutdown
.
jsm
"
fxAccounts
:
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
setTimeout
:
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
Utils
:
"
resource
:
/
/
services
-
sync
/
util
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
FxAccountsCommon
"
function
(
)
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
{
}
)
;
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
SyncDisconnectInternal
"
"
SyncDisconnect
"
]
;
this
.
SyncDisconnectInternal
=
{
lockRetryInterval
:
1000
lockRetryCount
:
120
promiseDisconnectFinished
:
null
getWeave
(
)
{
return
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
{
}
)
.
Weave
;
}
async
promiseNotSyncing
(
abortController
)
{
let
weave
=
this
.
getWeave
(
)
;
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Service
"
)
;
return
new
Promise
(
resolve
=
>
{
abortController
.
signal
.
onabort
=
(
)
=
>
{
resolve
(
false
)
;
}
;
let
attempts
=
0
;
let
checkLock
=
(
)
=
>
{
if
(
abortController
.
signal
.
aborted
)
{
return
;
}
if
(
weave
.
Service
.
lock
(
)
)
{
resolve
(
true
)
;
return
;
}
attempts
+
=
1
;
if
(
attempts
>
=
this
.
lockRetryCount
)
{
log
.
error
(
"
Gave
up
waiting
for
the
sync
lock
-
going
ahead
with
sanitize
anyway
"
)
;
resolve
(
false
)
;
return
;
}
log
.
debug
(
"
Waiting
a
couple
of
seconds
to
get
the
sync
lock
"
)
;
setTimeout
(
checkLock
this
.
lockRetryInterval
)
;
}
;
checkLock
(
)
;
}
)
;
}
async
doSanitizeSyncData
(
)
{
let
weave
=
this
.
getWeave
(
)
;
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Service
"
)
;
log
.
info
(
"
Starting
santitize
of
Sync
data
"
)
;
try
{
await
weave
.
Service
.
promiseInitialized
;
weave
.
Service
.
enabled
=
false
;
log
.
info
(
"
starting
actual
sanitization
"
)
;
for
(
let
engine
of
weave
.
Service
.
engineManager
.
getAll
(
)
)
{
if
(
engine
.
enabled
)
{
try
{
log
.
info
(
"
Wiping
engine
"
engine
.
name
)
;
await
engine
.
wipeClient
(
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Failed
to
wipe
engine
"
ex
)
;
}
}
}
Services
.
prefs
.
clearUserPref
(
FxAccountsCommon
.
PREF_LAST_FXA_USER
)
;
log
.
info
(
"
Finished
wiping
sync
data
"
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Failed
to
sanitize
Sync
data
"
ex
)
;
console
.
error
(
"
Failed
to
sanitize
Sync
data
"
ex
)
;
}
try
{
await
weave
.
Service
.
errorHandler
.
resetFileLog
(
)
;
}
catch
(
ex
)
{
console
.
log
(
"
Failed
to
flush
the
Sync
log
"
ex
)
;
}
}
async
doSanitizeBrowserData
(
)
{
try
{
let
itemsToClear
=
Object
.
keys
(
Sanitizer
.
items
)
.
filter
(
k
=
>
k
!
=
"
openWindows
"
)
;
await
Sanitizer
.
sanitize
(
itemsToClear
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Failed
to
sanitize
other
data
"
ex
)
;
}
}
async
doSyncAndAccountDisconnect
(
shouldUnlock
)
{
let
Weave
=
this
.
getWeave
(
)
;
await
Weave
.
Service
.
promiseInitialized
;
await
Weave
.
Service
.
startOver
(
)
;
await
fxAccounts
.
signOut
(
)
;
Weave
.
Service
.
enabled
=
true
;
if
(
shouldUnlock
)
{
Weave
.
Service
.
unlock
(
)
;
}
}
async
_startDisconnect
(
abortController
sanitizeData
=
false
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Service
"
)
;
log
.
info
(
"
checking
master
-
password
state
"
)
;
if
(
!
Utils
.
ensureMPUnlocked
(
)
)
{
log
.
warn
(
"
The
master
-
password
needs
to
be
unlocked
to
fully
disconnect
from
sync
"
)
;
return
;
}
log
.
info
(
"
waiting
for
any
existing
syncs
to
complete
"
)
;
let
locked
=
await
this
.
promiseNotSyncing
(
abortController
)
;
if
(
sanitizeData
)
{
await
this
.
doSanitizeSyncData
(
)
;
log
.
info
(
"
disconnecting
account
"
)
;
await
this
.
doSyncAndAccountDisconnect
(
locked
)
;
await
this
.
doSanitizeBrowserData
(
)
;
}
else
{
log
.
info
(
"
disconnecting
account
"
)
;
await
this
.
doSyncAndAccountDisconnect
(
locked
)
;
}
}
async
disconnect
(
sanitizeData
)
{
if
(
this
.
promiseDisconnectFinished
)
{
throw
new
Error
(
"
A
disconnect
is
already
in
progress
"
)
;
}
let
abortController
=
new
AbortController
(
)
;
let
promiseDisconnectFinished
=
this
.
_startDisconnect
(
abortController
sanitizeData
)
;
this
.
promiseDisconnectFinished
=
promiseDisconnectFinished
;
let
shutdownBlocker
=
(
)
=
>
{
abortController
.
abort
(
)
;
return
promiseDisconnectFinished
;
}
;
AsyncShutdown
.
quitApplicationGranted
.
addBlocker
(
"
SyncDisconnect
:
removing
requested
data
"
shutdownBlocker
)
;
await
promiseDisconnectFinished
;
this
.
promiseDisconnectFinished
=
null
;
AsyncShutdown
.
quitApplicationGranted
.
removeBlocker
(
shutdownBlocker
)
;
}
}
;
this
.
SyncDisconnect
=
{
get
promiseDisconnectFinished
(
)
{
return
SyncDisconnectInternal
.
promiseDisconnectFinished
;
}
disconnect
(
sanitizeData
)
{
return
SyncDisconnectInternal
.
disconnect
(
sanitizeData
)
;
}
}
;
