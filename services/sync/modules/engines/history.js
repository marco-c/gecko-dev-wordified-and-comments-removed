this
.
EXPORTED_SYMBOLS
=
[
"
HistoryEngine
"
"
HistoryRec
"
]
;
const
HISTORY_TTL
=
5184000
;
const
THIRTY_DAYS_IN_MS
=
2592000000
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PlacesSyncUtils
"
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
this
.
HistoryRec
=
function
HistoryRec
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
;
HistoryRec
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
History
"
ttl
:
HISTORY_TTL
}
;
Utils
.
deferGetSet
(
HistoryRec
"
cleartext
"
[
"
histUri
"
"
title
"
"
visits
"
]
)
;
this
.
HistoryEngine
=
function
HistoryEngine
(
service
)
{
SyncEngine
.
call
(
this
"
History
"
service
)
;
}
;
HistoryEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_recordObj
:
HistoryRec
_storeObj
:
HistoryStore
_trackerObj
:
HistoryTracker
downloadLimit
:
MAX_HISTORY_DOWNLOAD
syncPriority
:
7
async
_processIncoming
(
newitems
)
{
let
observers
=
PlacesUtils
.
history
.
getObservers
(
)
;
function
notifyHistoryObservers
(
notification
)
{
for
(
let
observer
of
observers
)
{
try
{
observer
[
notification
]
(
)
;
}
catch
(
ex
)
{
}
}
}
notifyHistoryObservers
(
"
onBeginUpdateBatch
"
)
;
try
{
await
SyncEngine
.
prototype
.
_processIncoming
.
call
(
this
newitems
)
;
}
finally
{
notifyHistoryObservers
(
"
onEndUpdateBatch
"
)
;
}
}
shouldSyncURL
(
url
)
{
return
!
url
.
startsWith
(
"
file
:
"
)
;
}
async
pullNewChanges
(
)
{
const
changedIDs
=
await
this
.
_tracker
.
getChangedIDs
(
)
;
let
modifiedGUIDs
=
Object
.
keys
(
changedIDs
)
;
if
(
!
modifiedGUIDs
.
length
)
{
return
{
}
;
}
let
guidsToRemove
=
await
PlacesSyncUtils
.
history
.
determineNonSyncableGuids
(
modifiedGUIDs
)
;
await
this
.
_tracker
.
removeChangedID
(
.
.
.
guidsToRemove
)
;
return
changedIDs
;
}
}
;
function
HistoryStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
Svc
.
Obs
.
add
(
"
places
-
shutdown
"
function
(
)
{
for
(
let
query
in
this
.
_stmts
)
{
let
stmt
=
this
.
_stmts
[
query
]
;
stmt
.
finalize
(
)
;
}
this
.
_stmts
=
{
}
;
}
this
)
;
}
HistoryStore
.
prototype
=
{
__proto__
:
Store
.
prototype
__asyncHistory
:
null
MAX_VISITS_PER_INSERT
:
500
get
_asyncHistory
(
)
{
if
(
!
this
.
__asyncHistory
)
{
this
.
__asyncHistory
=
Cc
[
"
mozilla
.
org
/
browser
/
history
;
1
"
]
.
getService
(
Ci
.
mozIAsyncHistory
)
;
}
return
this
.
__asyncHistory
;
}
_stmts
:
{
}
_getStmt
(
query
)
{
if
(
query
in
this
.
_stmts
)
{
return
this
.
_stmts
[
query
]
;
}
this
.
_log
.
trace
(
"
Creating
SQL
statement
:
"
+
query
)
;
let
db
=
PlacesUtils
.
history
.
QueryInterface
(
Ci
.
nsPIPlacesDatabase
)
.
DBConnection
;
return
this
.
_stmts
[
query
]
=
db
.
createAsyncStatement
(
query
)
;
}
async
setGUID
(
uri
guid
)
{
if
(
!
guid
)
{
guid
=
Utils
.
makeGUID
(
)
;
}
try
{
await
PlacesSyncUtils
.
history
.
changeGuid
(
uri
guid
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Error
setting
GUID
{
guid
}
for
URI
{
uri
}
"
guid
uri
)
;
}
return
guid
;
}
async
GUIDForUri
(
uri
create
)
{
let
guid
;
try
{
guid
=
await
PlacesSyncUtils
.
history
.
fetchGuidForURL
(
uri
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Error
fetching
GUID
for
URL
{
uri
}
"
uri
)
;
}
if
(
guid
)
{
return
guid
;
}
if
(
create
)
{
return
this
.
setGUID
(
uri
)
;
}
return
null
;
}
async
changeItemID
(
oldID
newID
)
{
let
info
=
await
PlacesSyncUtils
.
history
.
fetchURLInfoForGuid
(
oldID
)
;
if
(
!
info
)
{
throw
new
Error
(
Can
'
t
change
ID
for
nonexistent
history
entry
{
oldID
}
)
;
}
this
.
setGUID
(
info
.
url
newID
)
;
}
async
getAllIDs
(
)
{
let
urls
=
await
PlacesSyncUtils
.
history
.
getAllURLs
(
{
since
:
new
Date
(
(
Date
.
now
(
)
-
THIRTY_DAYS_IN_MS
)
)
limit
:
MAX_HISTORY_UPLOAD
}
)
;
let
urlsByGUID
=
{
}
;
for
(
let
url
of
urls
)
{
if
(
!
this
.
engine
.
shouldSyncURL
(
url
)
)
{
continue
;
}
let
guid
=
await
this
.
GUIDForUri
(
url
true
)
;
urlsByGUID
[
guid
]
=
url
;
}
return
urlsByGUID
;
}
async
applyIncomingBatch
(
records
)
{
let
failed
=
[
]
;
let
i
k
;
let
maybeYield
=
Async
.
jankYielder
(
)
;
for
(
i
=
0
k
=
0
;
i
<
records
.
length
;
i
+
+
)
{
await
maybeYield
(
)
;
let
record
=
records
[
k
]
=
records
[
i
]
;
let
shouldApply
;
try
{
if
(
record
.
deleted
)
{
await
this
.
remove
(
record
)
;
shouldApply
=
false
;
}
else
{
shouldApply
=
await
this
.
_recordToPlaceInfo
(
record
)
;
}
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
failed
.
push
(
record
.
id
)
;
shouldApply
=
false
;
}
if
(
shouldApply
)
{
k
+
=
1
;
}
}
records
.
length
=
k
;
if
(
records
.
length
)
{
for
(
let
chunk
of
this
.
_generateChunks
(
records
)
)
{
try
{
await
PlacesUtils
.
history
.
insertMany
(
chunk
null
failedVisit
=
>
{
this
.
_log
.
info
(
"
Failed
to
insert
a
history
record
"
failedVisit
.
guid
)
;
this
.
_log
.
trace
(
"
The
record
that
failed
"
failedVisit
)
;
failed
.
push
(
failedVisit
.
guid
)
;
}
)
;
}
catch
(
ex
)
{
this
.
_log
.
info
(
"
Failed
to
insert
history
records
"
ex
)
;
}
}
}
return
failed
;
}
*
_generateChunks
(
records
)
{
let
curIndex
=
0
;
this
.
_log
.
debug
(
adding
{
records
.
length
}
records
to
history
)
;
while
(
curIndex
<
records
.
length
)
{
Async
.
checkAppReady
(
)
;
let
toAdd
=
[
]
;
let
count
=
0
;
do
{
let
record
=
records
[
curIndex
]
;
curIndex
+
=
1
;
toAdd
.
push
(
record
)
;
count
+
=
record
.
visits
.
length
;
}
while
(
curIndex
<
records
.
length
&
&
count
+
records
[
curIndex
]
.
visits
.
length
<
=
this
.
MAX_VISITS_PER_INSERT
)
;
this
.
_log
.
trace
(
adding
{
toAdd
.
length
}
items
in
this
chunk
)
;
yield
toAdd
;
}
}
_canAddURI
(
uri
)
{
return
PlacesUtils
.
history
.
canAddURI
(
uri
)
;
}
async
_recordToPlaceInfo
(
record
)
{
record
.
url
=
PlacesUtils
.
normalizeToURLOrGUID
(
record
.
histUri
)
;
record
.
uri
=
CommonUtils
.
makeURI
(
record
.
histUri
)
;
if
(
!
Utils
.
checkGUID
(
record
.
id
)
)
{
this
.
_log
.
warn
(
"
Encountered
record
with
invalid
GUID
:
"
+
record
.
id
)
;
return
false
;
}
record
.
guid
=
record
.
id
;
if
(
!
this
.
_canAddURI
(
record
.
uri
)
|
|
!
this
.
engine
.
shouldSyncURL
(
record
.
uri
.
spec
)
)
{
this
.
_log
.
trace
(
"
Ignoring
record
"
+
record
.
id
+
"
with
URI
"
+
record
.
uri
.
spec
+
"
:
can
'
t
add
this
URI
.
"
)
;
return
false
;
}
let
curVisitsAsArray
=
[
]
;
let
curVisits
=
new
Set
(
)
;
try
{
curVisitsAsArray
=
await
PlacesSyncUtils
.
history
.
fetchVisitsForURL
(
record
.
histUri
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Error
while
fetching
visits
for
URL
{
record
.
histUri
}
"
record
.
histUri
)
;
}
let
oldestAllowed
=
PlacesSyncUtils
.
bookmarks
.
EARLIEST_BOOKMARK_TIMESTAMP
;
if
(
curVisitsAsArray
.
length
=
=
20
)
{
let
oldestVisit
=
curVisitsAsArray
[
curVisitsAsArray
.
length
-
1
]
;
oldestAllowed
=
PlacesSyncUtils
.
history
.
clampVisitDate
(
PlacesUtils
.
toDate
(
oldestVisit
.
date
)
.
getTime
(
)
)
;
}
let
i
k
;
for
(
i
=
0
;
i
<
curVisitsAsArray
.
length
;
i
+
+
)
{
let
{
date
type
}
=
curVisitsAsArray
[
i
]
;
let
dateObj
=
PlacesUtils
.
toDate
(
date
)
;
let
millis
=
PlacesSyncUtils
.
history
.
clampVisitDate
(
dateObj
)
.
getTime
(
)
;
curVisits
.
add
(
{
millis
}
{
type
}
)
;
}
for
(
i
=
0
k
=
0
;
i
<
record
.
visits
.
length
;
i
+
+
)
{
let
visit
=
record
.
visits
[
k
]
=
record
.
visits
[
i
]
;
if
(
!
visit
.
date
|
|
typeof
visit
.
date
!
=
"
number
"
|
|
!
Number
.
isInteger
(
visit
.
date
)
)
{
this
.
_log
.
warn
(
"
Encountered
record
with
invalid
visit
date
:
"
+
visit
.
date
)
;
continue
;
}
if
(
!
visit
.
type
|
|
!
Object
.
values
(
PlacesUtils
.
history
.
TRANSITIONS
)
.
includes
(
visit
.
type
)
)
{
this
.
_log
.
warn
(
"
Encountered
record
with
invalid
visit
type
:
"
+
visit
.
type
+
"
;
ignoring
.
"
)
;
continue
;
}
let
originalVisitDate
=
PlacesUtils
.
toDate
(
Math
.
round
(
visit
.
date
)
)
;
visit
.
date
=
PlacesSyncUtils
.
history
.
clampVisitDate
(
originalVisitDate
)
;
if
(
visit
.
date
.
getTime
(
)
<
oldestAllowed
)
{
continue
;
}
let
visitKey
=
{
visit
.
date
.
getTime
(
)
}
{
visit
.
type
}
;
if
(
curVisits
.
has
(
visitKey
)
)
{
continue
;
}
curVisits
.
add
(
visitKey
)
;
visit
.
transition
=
visit
.
type
;
k
+
=
1
;
}
record
.
visits
.
length
=
k
;
if
(
!
record
.
visits
.
length
)
{
this
.
_log
.
trace
(
"
Ignoring
record
"
+
record
.
id
+
"
with
URI
"
+
record
.
uri
.
spec
+
"
:
no
visits
to
add
.
"
)
;
return
false
;
}
return
true
;
}
async
remove
(
record
)
{
this
.
_log
.
trace
(
"
Removing
page
:
"
+
record
.
id
)
;
let
removed
=
await
PlacesUtils
.
history
.
remove
(
record
.
id
)
;
if
(
removed
)
{
this
.
_log
.
trace
(
"
Removed
page
:
"
+
record
.
id
)
;
}
else
{
this
.
_log
.
debug
(
"
Page
already
removed
:
"
+
record
.
id
)
;
}
}
async
itemExists
(
id
)
{
return
!
!
(
await
PlacesSyncUtils
.
history
.
fetchURLInfoForGuid
(
id
)
)
;
}
async
createRecord
(
id
collection
)
{
let
foo
=
await
PlacesSyncUtils
.
history
.
fetchURLInfoForGuid
(
id
)
;
let
record
=
new
HistoryRec
(
collection
id
)
;
if
(
foo
)
{
record
.
histUri
=
foo
.
url
;
record
.
title
=
foo
.
title
;
record
.
sortindex
=
foo
.
frecency
;
try
{
record
.
visits
=
await
PlacesSyncUtils
.
history
.
fetchVisitsForURL
(
record
.
histUri
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Error
while
fetching
visits
for
URL
{
record
.
histUri
}
"
record
.
histUri
)
;
record
.
visits
=
[
]
;
}
}
else
{
record
.
deleted
=
true
;
}
return
record
;
}
async
wipe
(
)
{
return
PlacesUtils
.
history
.
clear
(
)
;
}
}
;
function
HistoryTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
}
HistoryTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
onStart
(
)
{
this
.
_log
.
info
(
"
Adding
Places
observer
.
"
)
;
PlacesUtils
.
history
.
addObserver
(
this
true
)
;
}
onStop
(
)
{
this
.
_log
.
info
(
"
Removing
Places
observer
.
"
)
;
PlacesUtils
.
history
.
removeObserver
(
this
)
;
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsINavHistoryObserver
Ci
.
nsISupportsWeakReference
]
)
async
onDeleteAffectsGUID
(
uri
guid
reason
source
increment
)
{
if
(
this
.
ignoreAll
|
|
reason
=
=
Ci
.
nsINavHistoryObserver
.
REASON_EXPIRED
)
{
return
;
}
this
.
_log
.
trace
(
source
+
"
:
"
+
uri
.
spec
+
"
reason
"
+
reason
)
;
const
added
=
await
this
.
addChangedID
(
guid
)
;
if
(
added
)
{
this
.
score
+
=
increment
;
}
}
onDeleteVisits
(
uri
visitTime
guid
reason
)
{
this
.
asyncObserver
.
enqueueCall
(
(
)
=
>
this
.
onDeleteAffectsGUID
(
uri
guid
reason
"
onDeleteVisits
"
SCORE_INCREMENT_SMALL
)
)
;
}
onDeleteURI
(
uri
guid
reason
)
{
this
.
asyncObserver
.
enqueueCall
(
(
)
=
>
this
.
onDeleteAffectsGUID
(
uri
guid
reason
"
onDeleteURI
"
SCORE_INCREMENT_XLARGE
)
)
;
}
onVisits
(
aVisits
)
{
this
.
asyncObserver
.
enqueueCall
(
(
)
=
>
this
.
_onVisits
(
aVisits
)
)
;
}
async
_onVisits
(
aVisits
)
{
if
(
this
.
ignoreAll
)
{
this
.
_log
.
trace
(
"
ignoreAll
:
ignoring
visits
[
"
+
aVisits
.
map
(
v
=
>
v
.
guid
)
.
join
(
"
"
)
+
"
]
"
)
;
return
;
}
for
(
let
{
uri
guid
}
of
aVisits
)
{
this
.
_log
.
trace
(
"
onVisits
:
"
+
uri
.
spec
)
;
if
(
this
.
engine
.
shouldSyncURL
(
uri
.
spec
)
&
&
(
await
this
.
addChangedID
(
guid
)
)
)
{
this
.
score
+
=
SCORE_INCREMENT_SMALL
;
}
}
}
onClearHistory
(
)
{
this
.
_log
.
trace
(
"
onClearHistory
"
)
;
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
onBeginUpdateBatch
(
)
{
}
onEndUpdateBatch
(
)
{
}
onPageChanged
(
)
{
}
onTitleChanged
(
)
{
}
onBeforeDeleteURI
(
)
{
}
}
;
