var
EXPORTED_SYMBOLS
=
[
"
PrefsEngine
"
"
PrefRec
"
"
getPrefsGUIDForTest
"
]
;
const
PREF_SYNC_PREFS_PREFIX
=
"
services
.
sync
.
prefs
.
sync
.
"
;
const
PREF_SYNC_SEEN_PREFIX
=
"
services
.
sync
.
prefs
.
sync
-
seen
.
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Preferences
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
sys
.
mjs
"
)
;
const
{
Store
SyncEngine
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
CryptoWrapper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
const
{
Svc
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
SCORE_INCREMENT_XLARGE
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
PREFS_GUID
"
(
)
=
>
CommonUtils
.
encodeBase64URL
(
Services
.
appinfo
.
ID
)
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
PREF_SYNC_PREFS_ARBITRARY
=
"
services
.
sync
.
prefs
.
dangerously_allow_arbitrary
"
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
ALLOW_ARBITRARY
"
PREF_SYNC_PREFS_ARBITRARY
)
;
const
PREFS_DOC_URL_TEMPLATE
=
"
https
:
/
/
support
.
mozilla
.
org
/
1
/
firefox
/
%
VERSION
%
/
%
OS
%
/
%
LOCALE
%
/
sync
-
custom
-
preferences
"
;
XPCOMUtils
.
defineLazyGetter
(
lazy
"
PREFS_DOC_URL
"
(
)
=
>
Services
.
urlFormatter
.
formatURL
(
PREFS_DOC_URL_TEMPLATE
)
)
;
function
isAllowedPrefName
(
prefName
)
{
if
(
prefName
=
=
PREF_SYNC_PREFS_ARBITRARY
)
{
return
false
;
}
if
(
lazy
.
ALLOW_ARBITRARY
)
{
return
true
;
}
try
{
Services
.
prefs
.
getBoolPref
(
PREF_SYNC_PREFS_PREFIX
+
prefName
)
;
return
true
;
}
catch
(
_
)
{
return
false
;
}
}
function
PrefRec
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
PrefRec
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
Pref
"
}
;
Utils
.
deferGetSet
(
PrefRec
"
cleartext
"
[
"
value
"
]
)
;
function
PrefsEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Prefs
"
service
)
;
}
PrefsEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
PrefStore
_trackerObj
:
PrefTracker
_recordObj
:
PrefRec
version
:
2
syncPriority
:
1
allowSkippedRecord
:
false
async
getChangedIDs
(
)
{
let
changedIDs
=
{
}
;
if
(
this
.
_tracker
.
modified
)
{
changedIDs
[
lazy
.
PREFS_GUID
]
=
0
;
}
return
changedIDs
;
}
async
_wipeClient
(
)
{
await
SyncEngine
.
prototype
.
_wipeClient
.
call
(
this
)
;
this
.
justWiped
=
true
;
}
async
_reconcile
(
item
)
{
if
(
this
.
justWiped
)
{
this
.
justWiped
=
false
;
return
true
;
}
return
SyncEngine
.
prototype
.
_reconcile
.
call
(
this
item
)
;
}
async
trackRemainingChanges
(
)
{
if
(
this
.
_modified
.
count
(
)
>
0
)
{
this
.
_tracker
.
modified
=
true
;
}
}
}
;
const
UNSYNCABLE_URL_REGEXP
=
/
^
(
moz
-
extension
|
blob
|
data
|
file
)
:
/
i
;
function
isUnsyncableURLPref
(
prefName
)
{
if
(
Services
.
prefs
.
getPrefType
(
prefName
)
!
=
Ci
.
nsIPrefBranch
.
PREF_STRING
)
{
return
false
;
}
const
prefValue
=
Services
.
prefs
.
getStringPref
(
prefName
"
"
)
;
return
UNSYNCABLE_URL_REGEXP
.
test
(
prefValue
)
;
}
function
PrefStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
Svc
.
Obs
.
add
(
"
profile
-
before
-
change
"
function
(
)
{
this
.
__prefs
=
null
;
}
this
)
;
}
PrefStore
.
prototype
=
{
__proto__
:
Store
.
prototype
__prefs
:
null
get
_prefs
(
)
{
if
(
!
this
.
__prefs
)
{
this
.
__prefs
=
new
Preferences
(
)
;
}
return
this
.
__prefs
;
}
_getSyncPrefs
(
)
{
let
syncPrefs
=
Services
.
prefs
.
getBranch
(
PREF_SYNC_PREFS_PREFIX
)
.
getChildList
(
"
"
)
.
filter
(
pref
=
>
isAllowedPrefName
(
pref
)
&
&
!
isUnsyncableURLPref
(
pref
)
)
;
let
controlPrefs
=
syncPrefs
.
map
(
pref
=
>
PREF_SYNC_PREFS_PREFIX
+
pref
)
;
return
controlPrefs
.
concat
(
syncPrefs
)
;
}
_isSynced
(
pref
)
{
if
(
pref
.
startsWith
(
PREF_SYNC_PREFS_PREFIX
)
)
{
let
controlledPref
=
pref
.
slice
(
PREF_SYNC_PREFS_PREFIX
.
length
)
;
return
isAllowedPrefName
(
controlledPref
)
;
}
if
(
!
this
.
_prefs
.
get
(
PREF_SYNC_PREFS_PREFIX
+
pref
false
)
)
{
return
false
;
}
return
isAllowedPrefName
(
pref
)
;
}
_getAllPrefs
(
)
{
let
values
=
{
}
;
for
(
let
pref
of
this
.
_getSyncPrefs
(
)
)
{
if
(
this
.
_isSynced
(
pref
)
&
&
!
isUnsyncableURLPref
(
pref
)
)
{
let
isSet
=
this
.
_prefs
.
isSet
(
pref
)
;
let
forceValue
=
this
.
_prefs
.
get
(
PREF_SYNC_SEEN_PREFIX
+
pref
false
)
;
values
[
pref
]
=
isSet
|
|
forceValue
?
this
.
_prefs
.
get
(
pref
null
)
:
null
;
if
(
isSet
&
&
this
.
_prefs
.
get
(
PREF_SYNC_SEEN_PREFIX
+
pref
false
)
=
=
=
false
)
{
this
.
_log
.
trace
(
toggling
sync
-
seen
pref
for
'
{
pref
}
'
to
true
)
;
this
.
_prefs
.
set
(
PREF_SYNC_SEEN_PREFIX
+
pref
true
)
;
}
}
}
return
values
;
}
_setAllPrefs
(
values
)
{
const
selectedThemeIDPref
=
"
extensions
.
activeThemeID
"
;
let
selectedThemeIDBefore
=
this
.
_prefs
.
get
(
selectedThemeIDPref
null
)
;
let
selectedThemeIDAfter
=
selectedThemeIDBefore
;
let
prefs
=
Object
.
keys
(
values
)
.
sort
(
a
=
>
-
a
.
indexOf
(
PREF_SYNC_PREFS_PREFIX
)
)
;
for
(
let
pref
of
prefs
)
{
let
value
=
values
[
pref
]
;
if
(
!
this
.
_isSynced
(
pref
)
)
{
if
(
!
pref
.
startsWith
(
PREF_SYNC_PREFS_PREFIX
)
)
{
if
(
value
!
=
=
null
)
{
let
controlPref
=
PREF_SYNC_PREFS_PREFIX
+
pref
;
let
controlPrefExists
;
try
{
Services
.
prefs
.
getBoolPref
(
controlPref
)
;
controlPrefExists
=
true
;
}
catch
(
ex
)
{
controlPrefExists
=
false
;
}
if
(
!
controlPrefExists
)
{
let
msg
=
Not
syncing
the
preference
'
{
pref
}
'
because
it
has
no
local
+
control
preference
(
{
PREF_SYNC_PREFS_PREFIX
}
{
pref
}
)
and
+
the
preference
{
PREF_SYNC_PREFS_ARBITRARY
}
isn
'
t
true
.
+
See
{
lazy
.
PREFS_DOC_URL
}
for
more
information
;
console
.
warn
(
msg
)
;
this
.
_log
.
warn
(
msg
)
;
}
}
}
continue
;
}
if
(
typeof
value
=
=
"
string
"
&
&
UNSYNCABLE_URL_REGEXP
.
test
(
value
)
)
{
this
.
_log
.
trace
(
Skipping
incoming
unsyncable
url
for
pref
:
{
pref
}
)
;
continue
;
}
switch
(
pref
)
{
case
selectedThemeIDPref
:
selectedThemeIDAfter
=
value
;
break
;
default
:
if
(
value
=
=
null
)
{
this
.
_prefs
.
reset
(
pref
)
;
}
else
{
try
{
this
.
_prefs
.
set
(
pref
value
)
;
}
catch
(
ex
)
{
this
.
_log
.
trace
(
Failed
to
set
pref
:
{
pref
}
ex
)
;
}
}
let
seenPref
=
PREF_SYNC_SEEN_PREFIX
+
pref
;
if
(
this
.
_prefs
.
get
(
seenPref
undefined
)
=
=
=
false
)
{
this
.
_prefs
.
set
(
PREF_SYNC_SEEN_PREFIX
+
pref
true
)
;
}
}
}
if
(
selectedThemeIDBefore
!
=
selectedThemeIDAfter
)
{
this
.
_maybeEnableBuiltinTheme
(
selectedThemeIDAfter
)
.
catch
(
e
=
>
{
this
.
_log
.
error
(
"
Failed
to
maybe
update
the
default
theme
"
e
)
;
}
)
;
}
}
async
_maybeEnableBuiltinTheme
(
themeId
)
{
let
addon
=
null
;
try
{
addon
=
await
lazy
.
AddonManager
.
getAddonByID
(
themeId
)
;
}
catch
(
ex
)
{
this
.
_log
.
trace
(
There
'
s
no
addon
with
ID
'
{
themeId
}
-
it
can
'
t
be
a
builtin
theme
)
;
return
;
}
if
(
addon
&
&
addon
.
isBuiltin
&
&
addon
.
type
=
=
"
theme
"
)
{
this
.
_log
.
trace
(
Enabling
builtin
theme
'
{
themeId
}
'
)
;
await
addon
.
enable
(
)
;
}
else
{
this
.
_log
.
trace
(
Have
incoming
theme
ID
of
'
{
themeId
}
'
but
it
'
s
not
a
builtin
theme
)
;
}
}
async
getAllIDs
(
)
{
let
allprefs
=
{
}
;
allprefs
[
lazy
.
PREFS_GUID
]
=
true
;
return
allprefs
;
}
async
changeItemID
(
oldID
newID
)
{
this
.
_log
.
trace
(
"
PrefStore
GUID
is
constant
!
"
)
;
}
async
itemExists
(
id
)
{
return
id
=
=
=
lazy
.
PREFS_GUID
;
}
async
createRecord
(
id
collection
)
{
let
record
=
new
PrefRec
(
collection
id
)
;
if
(
id
=
=
lazy
.
PREFS_GUID
)
{
record
.
value
=
this
.
_getAllPrefs
(
)
;
}
else
{
record
.
deleted
=
true
;
}
return
record
;
}
async
create
(
record
)
{
this
.
_log
.
trace
(
"
Ignoring
create
request
"
)
;
}
async
remove
(
record
)
{
this
.
_log
.
trace
(
"
Ignoring
remove
request
"
)
;
}
async
update
(
record
)
{
if
(
record
.
id
!
=
lazy
.
PREFS_GUID
)
{
return
;
}
this
.
_log
.
trace
(
"
Received
pref
updates
applying
.
.
.
"
)
;
this
.
_setAllPrefs
(
record
.
value
)
;
}
async
wipe
(
)
{
this
.
_log
.
trace
(
"
Ignoring
wipe
request
"
)
;
}
}
;
function
PrefTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
this
.
_ignoreAll
=
false
;
Svc
.
Obs
.
add
(
"
profile
-
before
-
change
"
this
.
asyncObserver
)
;
}
PrefTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
get
ignoreAll
(
)
{
return
this
.
_ignoreAll
;
}
set
ignoreAll
(
value
)
{
this
.
_ignoreAll
=
value
;
}
get
modified
(
)
{
return
Svc
.
Prefs
.
get
(
"
engine
.
prefs
.
modified
"
false
)
;
}
set
modified
(
value
)
{
Svc
.
Prefs
.
set
(
"
engine
.
prefs
.
modified
"
value
)
;
}
clearChangedIDs
:
function
clearChangedIDs
(
)
{
this
.
modified
=
false
;
}
__prefs
:
null
get
_prefs
(
)
{
if
(
!
this
.
__prefs
)
{
this
.
__prefs
=
new
Preferences
(
)
;
}
return
this
.
__prefs
;
}
onStart
(
)
{
Services
.
prefs
.
addObserver
(
"
"
this
.
asyncObserver
)
;
}
onStop
(
)
{
this
.
__prefs
=
null
;
Services
.
prefs
.
removeObserver
(
"
"
this
.
asyncObserver
)
;
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profile
-
before
-
change
"
:
await
this
.
stop
(
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
this
.
ignoreAll
)
{
break
;
}
if
(
data
.
indexOf
(
PREF_SYNC_PREFS_PREFIX
)
=
=
0
|
|
this
.
_prefs
.
get
(
PREF_SYNC_PREFS_PREFIX
+
data
false
)
)
{
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
this
.
modified
=
true
;
this
.
_log
.
trace
(
"
Preference
"
+
data
+
"
changed
"
)
;
}
break
;
}
}
}
;
function
getPrefsGUIDForTest
(
)
{
return
lazy
.
PREFS_GUID
;
}
