"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
addonutils
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
addonsreconciler
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
collection_validator
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
AddonRepository
"
"
resource
:
/
/
gre
/
modules
/
addons
/
AddonRepository
.
jsm
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
AddonsEngine
"
"
AddonValidator
"
]
;
const
PRUNE_ADDON_CHANGES_THRESHOLD
=
60
*
60
*
24
*
7
*
1000
;
function
AddonRecord
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
AddonRecord
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Record
.
Addon
"
}
;
Utils
.
deferGetSet
(
AddonRecord
"
cleartext
"
[
"
addonID
"
"
applicationID
"
"
enabled
"
"
source
"
]
)
;
this
.
AddonsEngine
=
function
AddonsEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Addons
"
service
)
;
this
.
_reconciler
=
new
AddonsReconciler
(
)
;
}
;
AddonsEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
AddonsStore
_trackerObj
:
AddonsTracker
_recordObj
:
AddonRecord
version
:
1
syncPriority
:
5
_reconciler
:
null
async
initialize
(
)
{
await
SyncEngine
.
prototype
.
initialize
.
call
(
this
)
;
await
this
.
_reconciler
.
ensureStateLoaded
(
)
;
}
async
_findDupe
(
item
)
{
let
id
=
item
.
addonID
;
let
addons
=
this
.
_reconciler
.
addons
;
if
(
!
(
id
in
addons
)
)
{
return
null
;
}
let
addon
=
addons
[
id
]
;
if
(
addon
.
guid
!
=
item
.
id
)
{
return
addon
.
guid
;
}
return
null
;
}
async
getChangedIDs
(
)
{
let
changes
=
{
}
;
for
(
let
[
id
modified
]
of
Object
.
entries
(
this
.
_tracker
.
changedIDs
)
)
{
changes
[
id
]
=
modified
;
}
let
lastSyncDate
=
new
Date
(
this
.
lastSync
*
1000
)
;
let
reconcilerChanges
=
this
.
_reconciler
.
getChangesSinceDate
(
lastSyncDate
)
;
let
addons
=
this
.
_reconciler
.
addons
;
for
(
let
change
of
reconcilerChanges
)
{
let
changeTime
=
change
[
0
]
;
let
id
=
change
[
2
]
;
if
(
!
(
id
in
addons
)
)
{
continue
;
}
if
(
id
in
changes
&
&
changeTime
<
changes
[
id
]
)
{
continue
;
}
if
(
!
(
await
this
.
isAddonSyncable
(
addons
[
id
]
)
)
)
{
continue
;
}
this
.
_log
.
debug
(
"
Adding
changed
add
-
on
from
changes
log
:
"
+
id
)
;
let
addon
=
addons
[
id
]
;
changes
[
addon
.
guid
]
=
changeTime
.
getTime
(
)
/
1000
;
}
return
changes
;
}
async
_syncStartup
(
)
{
await
this
.
_refreshReconcilerState
(
)
;
return
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
}
async
_syncCleanup
(
)
{
let
ms
=
1000
*
this
.
lastSync
-
PRUNE_ADDON_CHANGES_THRESHOLD
;
this
.
_reconciler
.
pruneChangesBeforeDate
(
new
Date
(
ms
)
)
;
return
SyncEngine
.
prototype
.
_syncCleanup
.
call
(
this
)
;
}
async
_refreshReconcilerState
(
)
{
this
.
_log
.
debug
(
"
Refreshing
reconciler
state
"
)
;
return
this
.
_reconciler
.
refreshGlobalState
(
)
;
}
isAddonSyncable
(
addon
ignoreRepoCheck
)
{
return
this
.
_store
.
isAddonSyncable
(
addon
ignoreRepoCheck
)
;
}
}
;
function
AddonsStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
AddonsStore
.
prototype
=
{
__proto__
:
Store
.
prototype
_syncableTypes
:
[
"
extension
"
"
theme
"
]
_extensionsPrefs
:
new
Preferences
(
"
extensions
.
"
)
get
reconciler
(
)
{
return
this
.
engine
.
_reconciler
;
}
async
applyIncoming
(
record
)
{
if
(
!
record
.
deleted
)
{
if
(
record
.
applicationID
!
=
Services
.
appinfo
.
ID
)
{
this
.
_log
.
info
(
"
Ignoring
incoming
record
from
other
App
ID
:
"
+
record
.
id
)
;
return
;
}
if
(
record
.
source
!
=
"
amo
"
)
{
this
.
_log
.
info
(
"
Ignoring
unknown
add
-
on
source
(
"
+
record
.
source
+
"
)
"
+
"
for
"
+
record
.
id
)
;
return
;
}
}
let
existingMeta
=
this
.
reconciler
.
addons
[
record
.
addonID
]
;
if
(
existingMeta
&
&
!
(
await
this
.
isAddonSyncable
(
existingMeta
)
)
)
{
this
.
_log
.
info
(
"
Ignoring
incoming
record
for
an
existing
but
non
-
syncable
addon
"
record
.
addonID
)
;
return
;
}
await
Store
.
prototype
.
applyIncoming
.
call
(
this
record
)
;
}
async
create
(
record
)
{
const
results
=
await
AddonUtils
.
installAddons
(
[
{
id
:
record
.
addonID
syncGUID
:
record
.
id
enabled
:
record
.
enabled
requireSecureURI
:
this
.
_extensionsPrefs
.
get
(
"
install
.
requireSecureOrigin
"
true
)
}
]
)
;
if
(
results
.
skipped
.
includes
(
record
.
addonID
)
)
{
this
.
_log
.
info
(
"
Add
-
on
skipped
:
"
+
record
.
addonID
)
;
return
;
}
let
addon
;
for
(
let
a
of
results
.
addons
)
{
if
(
a
.
id
=
=
record
.
addonID
)
{
addon
=
a
;
break
;
}
}
if
(
!
addon
)
{
throw
new
Error
(
"
Add
-
on
not
found
after
install
:
"
+
record
.
addonID
)
;
}
this
.
_log
.
info
(
"
Add
-
on
installed
:
"
+
record
.
addonID
)
;
}
async
remove
(
record
)
{
let
addon
=
await
this
.
getAddonByGUID
(
record
.
id
)
;
if
(
!
addon
)
{
return
;
}
this
.
_log
.
info
(
"
Uninstalling
add
-
on
:
"
+
addon
.
id
)
;
await
AddonUtils
.
uninstallAddon
(
addon
)
;
}
async
update
(
record
)
{
let
addon
=
await
this
.
getAddonByID
(
record
.
addonID
)
;
if
(
!
addon
)
{
await
this
.
create
(
record
)
;
return
;
}
if
(
addon
.
pendingOperations
&
AddonManager
.
PENDING_UNINSTALL
)
{
addon
.
cancelUninstall
(
)
;
}
this
.
updateUserDisabled
(
addon
!
record
.
enabled
)
;
}
async
itemExists
(
guid
)
{
let
addon
=
this
.
reconciler
.
getAddonStateFromSyncGUID
(
guid
)
;
return
!
!
addon
;
}
async
createRecord
(
guid
collection
)
{
let
record
=
new
AddonRecord
(
collection
guid
)
;
record
.
applicationID
=
Services
.
appinfo
.
ID
;
let
addon
=
this
.
reconciler
.
getAddonStateFromSyncGUID
(
guid
)
;
if
(
!
addon
|
|
!
addon
.
installed
)
{
record
.
deleted
=
true
;
return
record
;
}
record
.
modified
=
addon
.
modified
.
getTime
(
)
/
1000
;
record
.
addonID
=
addon
.
id
;
record
.
enabled
=
addon
.
enabled
;
record
.
source
=
"
amo
"
;
return
record
;
}
async
changeItemID
(
oldID
newID
)
{
let
state
=
this
.
reconciler
.
getAddonStateFromSyncGUID
(
oldID
)
;
if
(
state
)
{
state
.
guid
=
newID
;
await
this
.
reconciler
.
saveState
(
)
;
}
let
addon
=
await
this
.
getAddonByGUID
(
oldID
)
;
if
(
!
addon
)
{
this
.
_log
.
debug
(
"
Cannot
change
item
ID
(
"
+
oldID
+
"
)
in
Add
-
on
"
+
"
Manager
because
old
add
-
on
not
present
:
"
+
oldID
)
;
return
;
}
addon
.
syncGUID
=
newID
;
}
async
getAllIDs
(
)
{
let
ids
=
{
}
;
let
addons
=
this
.
reconciler
.
addons
;
for
(
let
id
in
addons
)
{
let
addon
=
addons
[
id
]
;
if
(
(
await
this
.
isAddonSyncable
(
addon
)
)
)
{
ids
[
addon
.
guid
]
=
true
;
}
}
return
ids
;
}
async
wipe
(
)
{
this
.
_log
.
info
(
"
Processing
wipe
.
"
)
;
await
this
.
engine
.
_refreshReconcilerState
(
)
;
let
ids
=
await
this
.
getAllIDs
(
)
;
for
(
let
guid
in
ids
)
{
let
addon
=
await
this
.
getAddonByGUID
(
guid
)
;
if
(
!
addon
)
{
this
.
_log
.
debug
(
"
Ignoring
add
-
on
because
it
couldn
'
t
be
obtained
:
"
+
guid
)
;
continue
;
}
this
.
_log
.
info
(
"
Uninstalling
add
-
on
as
part
of
wipe
:
"
+
addon
.
id
)
;
await
Utils
.
catch
.
call
(
this
(
)
=
>
addon
.
uninstall
(
)
)
(
)
;
}
}
async
getAddonByID
(
id
)
{
return
AddonManager
.
getAddonByID
(
id
)
;
}
async
getAddonByGUID
(
guid
)
{
return
AddonManager
.
getAddonBySyncGUID
(
guid
)
;
}
async
isAddonSyncable
(
addon
ignoreRepoCheck
=
false
)
{
if
(
!
addon
)
{
this
.
_log
.
debug
(
"
Null
object
passed
to
isAddonSyncable
.
"
)
;
return
false
;
}
if
(
this
.
_syncableTypes
.
indexOf
(
addon
.
type
)
=
=
-
1
)
{
this
.
_log
.
debug
(
addon
.
id
+
"
not
syncable
:
type
not
in
whitelist
:
"
+
addon
.
type
)
;
return
false
;
}
if
(
!
(
addon
.
scope
&
AddonManager
.
SCOPE_PROFILE
)
)
{
this
.
_log
.
debug
(
addon
.
id
+
"
not
syncable
:
not
installed
in
profile
.
"
)
;
return
false
;
}
if
(
!
addon
.
isSyncable
)
{
this
.
_log
.
debug
(
addon
.
id
+
"
not
syncable
:
vetoed
by
the
addon
manager
.
"
)
;
return
false
;
}
if
(
addon
.
foreignInstall
)
{
this
.
_log
.
debug
(
addon
.
id
+
"
not
syncable
:
is
foreign
install
.
"
)
;
return
false
;
}
if
(
ignoreRepoCheck
|
|
!
AddonRepository
.
cacheEnabled
)
{
return
true
;
}
let
result
=
await
new
Promise
(
res
=
>
{
AddonRepository
.
getCachedAddonByID
(
addon
.
id
res
)
;
}
)
;
if
(
!
result
)
{
this
.
_log
.
debug
(
addon
.
id
+
"
not
syncable
:
add
-
on
not
found
in
add
-
on
"
+
"
repository
.
"
)
;
return
false
;
}
return
this
.
isSourceURITrusted
(
result
.
sourceURI
)
;
}
isSourceURITrusted
:
function
isSourceURITrusted
(
uri
)
{
let
trustedHostnames
=
Svc
.
Prefs
.
get
(
"
addons
.
trustedSourceHostnames
"
"
"
)
.
split
(
"
"
)
;
if
(
!
uri
)
{
this
.
_log
.
debug
(
"
Undefined
argument
to
isSourceURITrusted
(
)
.
"
)
;
return
false
;
}
if
(
uri
.
scheme
!
=
"
https
"
)
{
this
.
_log
.
debug
(
"
Source
URI
not
HTTPS
:
"
+
uri
.
spec
)
;
return
false
;
}
if
(
trustedHostnames
.
indexOf
(
uri
.
host
)
=
=
-
1
)
{
this
.
_log
.
debug
(
"
Source
hostname
not
trusted
:
"
+
uri
.
host
)
;
return
false
;
}
return
true
;
}
updateUserDisabled
(
addon
value
)
{
if
(
addon
.
userDisabled
=
=
value
)
{
return
;
}
if
(
Svc
.
Prefs
.
get
(
"
addons
.
ignoreUserEnabledChanges
"
false
)
)
{
this
.
_log
.
info
(
"
Ignoring
enabled
state
change
due
to
preference
:
"
+
addon
.
id
)
;
return
;
}
AddonUtils
.
updateUserDisabled
(
addon
value
)
;
if
(
addon
.
appDisabled
)
{
this
.
reconciler
.
rectifyStateFromAddon
(
addon
)
;
}
}
}
;
function
AddonsTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
}
AddonsTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
get
reconciler
(
)
{
return
this
.
engine
.
_reconciler
;
}
get
store
(
)
{
return
this
.
engine
.
_store
;
}
changeListener
:
function
changeHandler
(
date
change
addon
)
{
this
.
_log
.
debug
(
"
changeListener
invoked
:
"
+
change
+
"
"
+
addon
.
id
)
;
if
(
this
.
ignoreAll
)
{
return
;
}
if
(
!
Async
.
promiseSpinningly
(
this
.
store
.
isAddonSyncable
(
addon
)
)
)
{
this
.
_log
.
debug
(
"
Ignoring
change
because
add
-
on
isn
'
t
syncable
:
"
+
addon
.
id
)
;
return
;
}
if
(
this
.
addChangedID
(
addon
.
guid
date
.
getTime
(
)
/
1000
)
)
{
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
}
startTracking
(
)
{
if
(
this
.
engine
.
enabled
)
{
this
.
reconciler
.
startListening
(
)
;
}
this
.
reconciler
.
addChangeListener
(
this
)
;
}
stopTracking
(
)
{
this
.
reconciler
.
removeChangeListener
(
this
)
;
this
.
reconciler
.
stopListening
(
)
;
}
}
;
class
AddonValidator
extends
CollectionValidator
{
constructor
(
engine
=
null
)
{
super
(
"
addons
"
"
id
"
[
"
addonID
"
"
enabled
"
"
applicationID
"
"
source
"
]
)
;
this
.
engine
=
engine
;
}
async
getClientItems
(
)
{
const
installed
=
await
AddonManager
.
getAllAddons
(
)
;
const
addonsWithPendingOperation
=
await
AddonManager
.
getAddonsWithOperationsByTypes
(
[
"
extension
"
"
theme
"
]
)
;
let
all
=
new
Map
(
installed
.
map
(
addon
=
>
[
addon
.
id
addon
]
)
)
;
for
(
let
addon
of
addonsWithPendingOperation
)
{
all
.
set
(
addon
.
id
addon
)
;
}
return
[
.
.
.
all
.
values
(
)
]
;
}
normalizeClientItem
(
item
)
{
let
enabled
=
!
item
.
userDisabled
;
if
(
item
.
pendingOperations
&
AddonManager
.
PENDING_ENABLE
)
{
enabled
=
true
;
}
else
if
(
item
.
pendingOperations
&
AddonManager
.
PENDING_DISABLE
)
{
enabled
=
false
;
}
return
{
enabled
id
:
item
.
syncGUID
addonID
:
item
.
id
applicationID
:
Services
.
appinfo
.
ID
source
:
"
amo
"
original
:
item
}
;
}
async
normalizeServerItem
(
item
)
{
let
guid
=
await
this
.
engine
.
_findDupe
(
item
)
;
if
(
guid
)
{
item
.
id
=
guid
;
}
return
item
;
}
clientUnderstands
(
item
)
{
return
item
.
applicationID
=
=
=
Services
.
appinfo
.
ID
;
}
async
syncedByClient
(
item
)
{
return
!
item
.
original
.
hidden
&
&
!
item
.
original
.
isSystem
&
&
!
(
item
.
original
.
pendingOperations
&
AddonManager
.
PENDING_UNINSTALL
)
&
&
this
.
engine
.
isAddonSyncable
(
item
.
original
true
)
;
}
}
