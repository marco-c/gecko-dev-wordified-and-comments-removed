"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageEngineKinto
"
"
ExtensionStorageEngineBridge
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
BridgedEngine
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
bridged_engine
.
js
"
)
;
const
{
SyncEngine
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
lazy
=
{
}
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
LogAdapter
:
"
resource
:
/
/
services
-
sync
/
bridged_engine
.
js
"
extensionStorageSync
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageSync
.
jsm
"
extensionStorageSyncKinto
:
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageSyncKinto
.
jsm
"
Observers
:
"
resource
:
/
/
services
-
common
/
observers
.
js
"
Svc
:
"
resource
:
/
/
services
-
sync
/
util
.
js
"
SCORE_INCREMENT_MEDIUM
:
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
MULTI_DEVICE_THRESHOLD
:
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
}
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
lazy
"
StorageSyncService
"
"
mozilla
.
org
/
extensions
/
storage
/
sync
;
1
"
"
nsIInterfaceRequestor
"
)
;
const
PREF_FORCE_ENABLE
=
"
engine
.
extension
-
storage
.
force
"
;
function
getEngineEnabled
(
)
{
const
forced
=
lazy
.
Svc
.
Prefs
.
get
(
PREF_FORCE_ENABLE
undefined
)
;
if
(
forced
!
=
=
undefined
)
{
return
forced
;
}
return
lazy
.
Svc
.
Prefs
.
get
(
"
engine
.
addons
"
false
)
;
}
function
setEngineEnabled
(
enabled
)
{
if
(
lazy
.
Svc
.
Prefs
.
has
(
PREF_FORCE_ENABLE
)
)
{
lazy
.
Svc
.
Prefs
.
set
(
PREF_FORCE_ENABLE
enabled
)
;
}
}
function
ExtensionStorageEngineBridge
(
service
)
{
let
bridge
=
lazy
.
StorageSyncService
.
getInterface
(
Ci
.
mozIBridgedSyncEngine
)
;
BridgedEngine
.
call
(
this
bridge
"
Extension
-
Storage
"
service
)
;
let
app_services_logger
=
Cc
[
"
mozilla
.
org
/
appservices
/
logger
;
1
"
]
.
getService
(
Ci
.
mozIAppServicesLogger
)
;
let
logger_target
=
"
app
-
services
:
webext_storage
:
sync
"
;
app_services_logger
.
register
(
logger_target
new
lazy
.
LogAdapter
(
this
.
_log
)
)
;
}
ExtensionStorageEngineBridge
.
prototype
=
{
__proto__
:
BridgedEngine
.
prototype
syncPriority
:
10
overrideTelemetryName
:
"
rust
-
webext
-
storage
"
_notifyPendingChanges
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
_bridge
.
QueryInterface
(
Ci
.
mozISyncedExtensionStorageArea
)
.
fetchPendingSyncChanges
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
mozIExtensionStorageListener
"
"
mozIExtensionStorageCallback
"
]
)
onChanged
:
(
extId
json
)
=
>
{
try
{
lazy
.
extensionStorageSync
.
notifyListeners
(
extId
JSON
.
parse
(
json
)
)
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
Error
notifying
change
listeners
for
{
extId
}
ex
)
;
}
}
handleSuccess
:
resolve
handleError
:
(
code
message
)
=
>
{
this
.
_log
.
warn
(
"
Error
fetching
pending
synced
changes
"
message
code
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
_takeMigrationInfo
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_bridge
.
QueryInterface
(
Ci
.
mozIExtensionStorageArea
)
.
takeMigrationInfo
(
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
mozIExtensionStorageCallback
"
]
)
handleSuccess
:
result
=
>
{
resolve
(
result
?
JSON
.
parse
(
result
)
:
null
)
;
}
handleError
:
(
code
message
)
=
>
{
this
.
_log
.
warn
(
"
Error
fetching
migration
info
"
message
code
)
;
resolve
(
null
)
;
}
}
)
;
}
)
;
}
async
_syncStartup
(
)
{
let
result
=
await
super
.
_syncStartup
(
)
;
let
info
=
await
this
.
_takeMigrationInfo
(
)
;
if
(
info
)
{
lazy
.
Observers
.
notify
(
"
weave
:
telemetry
:
migration
"
info
"
webext
-
storage
"
)
;
}
return
result
;
}
async
_processIncoming
(
)
{
await
super
.
_processIncoming
(
)
;
try
{
await
this
.
_notifyPendingChanges
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
Error
notifying
about
synced
changes
"
ex
)
;
}
}
get
enabled
(
)
{
return
getEngineEnabled
(
)
;
}
set
enabled
(
enabled
)
{
setEngineEnabled
(
enabled
)
;
}
}
;
function
ExtensionStorageEngineKinto
(
service
)
{
SyncEngine
.
call
(
this
"
Extension
-
Storage
"
service
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_skipPercentageChance
"
"
services
.
sync
.
extension
-
storage
.
skipPercentageChance
"
0
)
;
}
ExtensionStorageEngineKinto
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_trackerObj
:
ExtensionStorageTracker
_storeObj
:
undefined
_recordObj
:
undefined
syncPriority
:
10
allowSkippedRecord
:
false
async
_sync
(
)
{
return
lazy
.
extensionStorageSyncKinto
.
syncAll
(
)
;
}
get
enabled
(
)
{
return
getEngineEnabled
(
)
;
}
set
enabled
(
enabled
)
{
setEngineEnabled
(
enabled
)
;
}
_wipeClient
(
)
{
return
lazy
.
extensionStorageSyncKinto
.
clearAll
(
)
;
}
shouldSkipSync
(
syncReason
)
{
if
(
syncReason
=
=
"
user
"
|
|
syncReason
=
=
"
startup
"
)
{
this
.
_log
.
info
(
Not
skipping
extension
storage
sync
:
reason
=
=
{
syncReason
}
)
;
return
false
;
}
if
(
this
.
_tracker
.
score
>
=
lazy
.
MULTI_DEVICE_THRESHOLD
)
{
this
.
_log
.
info
(
"
Not
skipping
extension
storage
sync
:
Would
trigger
resync
anyway
"
)
;
return
false
;
}
let
probability
=
this
.
_skipPercentageChance
/
100
.
0
;
let
shouldSkip
=
probability
>
Math
.
random
(
)
;
this
.
_log
.
info
(
Skipping
extension
-
storage
sync
with
a
chance
of
{
probability
}
:
{
shouldSkip
}
)
;
return
shouldSkip
;
}
}
;
function
ExtensionStorageTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
this
.
_ignoreAll
=
false
;
}
ExtensionStorageTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
get
ignoreAll
(
)
{
return
this
.
_ignoreAll
;
}
set
ignoreAll
(
value
)
{
this
.
_ignoreAll
=
value
;
}
onStart
(
)
{
lazy
.
Svc
.
Obs
.
add
(
"
ext
.
storage
.
sync
-
changed
"
this
.
asyncObserver
)
;
}
onStop
(
)
{
lazy
.
Svc
.
Obs
.
remove
(
"
ext
.
storage
.
sync
-
changed
"
this
.
asyncObserver
)
;
}
async
observe
(
subject
topic
data
)
{
if
(
this
.
ignoreAll
)
{
return
;
}
if
(
topic
!
=
=
"
ext
.
storage
.
sync
-
changed
"
)
{
return
;
}
this
.
score
+
=
lazy
.
SCORE_INCREMENT_MEDIUM
;
}
}
;
