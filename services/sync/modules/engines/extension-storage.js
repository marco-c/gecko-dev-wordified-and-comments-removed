"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
ExtensionStorageEngine
"
"
EncryptionRemoteTransformer
"
"
KeyRingEncryptionRemoteTransformer
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ExtensionStorageSync
"
"
resource
:
/
/
gre
/
modules
/
ExtensionStorageSync
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
this
.
ExtensionStorageEngine
=
function
ExtensionStorageEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Extension
-
Storage
"
service
)
;
}
;
ExtensionStorageEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_trackerObj
:
ExtensionStorageTracker
_storeObj
:
undefined
_recordObj
:
undefined
syncPriority
:
10
allowSkippedRecord
:
false
_sync
(
)
{
return
Async
.
promiseSpinningly
(
ExtensionStorageSync
.
syncAll
(
)
)
;
}
get
enabled
(
)
{
const
forced
=
Svc
.
Prefs
.
get
(
"
engine
.
"
+
this
.
prefName
+
"
.
force
"
undefined
)
;
if
(
forced
!
=
=
undefined
)
{
return
forced
;
}
return
Svc
.
Prefs
.
get
(
"
engine
.
addons
"
false
)
;
}
}
;
function
ExtensionStorageTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
}
ExtensionStorageTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
startTracking
(
)
{
Svc
.
Obs
.
add
(
"
ext
.
storage
.
sync
-
changed
"
this
)
;
}
stopTracking
(
)
{
Svc
.
Obs
.
remove
(
"
ext
.
storage
.
sync
-
changed
"
this
)
;
}
observe
(
subject
topic
data
)
{
Tracker
.
prototype
.
observe
.
call
(
this
subject
topic
data
)
;
if
(
this
.
ignoreAll
)
{
return
;
}
if
(
topic
!
=
=
"
ext
.
storage
.
sync
-
changed
"
)
{
return
;
}
this
.
score
+
=
SCORE_INCREMENT_MEDIUM
;
}
ignoreID
(
)
{
}
unignoreID
(
)
{
}
addChangedID
(
)
{
}
removeChangedID
(
)
{
}
clearChangedIDs
(
)
{
}
}
;
function
ciphertextHMAC
(
keyBundle
id
IV
ciphertext
)
{
const
hasher
=
keyBundle
.
sha256HMACHasher
;
return
Utils
.
bytesAsHex
(
Utils
.
digestUTF8
(
id
+
IV
+
ciphertext
hasher
)
)
;
}
class
EncryptionRemoteTransformer
{
encode
(
record
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
keyBundle
=
yield
self
.
getKeys
(
)
;
if
(
record
.
ciphertext
)
{
throw
new
Error
(
"
Attempt
to
reencrypt
?
?
"
)
;
}
let
id
=
record
.
id
;
if
(
!
record
.
id
)
{
throw
new
Error
(
"
Record
ID
is
missing
or
invalid
"
)
;
}
let
IV
=
Svc
.
Crypto
.
generateRandomIV
(
)
;
let
ciphertext
=
Svc
.
Crypto
.
encrypt
(
JSON
.
stringify
(
record
)
keyBundle
.
encryptionKeyB64
IV
)
;
let
hmac
=
ciphertextHMAC
(
keyBundle
id
IV
ciphertext
)
;
const
encryptedResult
=
{
ciphertext
IV
hmac
id
}
;
encryptedResult
.
_status
=
record
.
_status
=
=
"
deleted
"
?
"
updated
"
:
record
.
_status
;
if
(
record
.
hasOwnProperty
(
"
last_modified
"
)
)
{
encryptedResult
.
last_modified
=
record
.
last_modified
;
}
return
encryptedResult
;
}
)
;
}
decode
(
record
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
if
(
!
record
.
ciphertext
)
{
if
(
record
.
deleted
)
{
return
record
;
}
throw
new
Error
(
"
No
ciphertext
:
nothing
to
decrypt
?
"
)
;
}
const
keyBundle
=
yield
self
.
getKeys
(
)
;
let
computedHMAC
=
ciphertextHMAC
(
keyBundle
record
.
id
record
.
IV
record
.
ciphertext
)
;
if
(
computedHMAC
!
=
record
.
hmac
)
{
Utils
.
throwHMACMismatch
(
record
.
hmac
computedHMAC
)
;
}
let
cleartext
=
Svc
.
Crypto
.
decrypt
(
record
.
ciphertext
keyBundle
.
encryptionKeyB64
record
.
IV
)
;
let
jsonResult
=
JSON
.
parse
(
cleartext
)
;
if
(
!
jsonResult
|
|
typeof
jsonResult
!
=
=
"
object
"
)
{
throw
new
Error
(
"
Decryption
failed
:
result
is
<
"
+
jsonResult
+
"
>
not
an
object
.
"
)
;
}
if
(
jsonResult
.
id
!
=
record
.
id
)
{
throw
new
Error
(
"
Record
id
mismatch
:
"
+
jsonResult
.
id
+
"
!
=
"
+
record
.
id
)
;
}
if
(
record
.
hasOwnProperty
(
"
last_modified
"
)
)
{
jsonResult
.
last_modified
=
record
.
last_modified
;
}
if
(
jsonResult
.
_status
=
=
"
deleted
"
)
{
jsonResult
.
deleted
=
true
;
}
return
jsonResult
;
}
)
;
}
getKeys
(
)
{
throw
new
Error
(
"
override
getKeys
in
a
subclass
"
)
;
}
}
EncryptionRemoteTransformer
.
prototype
.
_fxaService
=
fxAccounts
;
class
KeyRingEncryptionRemoteTransformer
extends
EncryptionRemoteTransformer
{
getKeys
(
)
{
const
self
=
this
;
return
Task
.
spawn
(
function
*
(
)
{
const
user
=
yield
self
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
user
)
{
throw
new
Error
(
"
user
isn
'
t
signed
in
to
FxA
;
can
'
t
sync
"
)
;
}
if
(
!
user
.
kB
)
{
throw
new
Error
(
"
user
doesn
'
t
have
kB
"
)
;
}
let
kB
=
Utils
.
hexToBytes
(
user
.
kB
)
;
let
keyMaterial
=
CryptoUtils
.
hkdf
(
kB
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
chrome
.
storage
.
sync
"
2
*
32
)
;
let
bundle
=
new
BulkKeyBundle
(
)
;
bundle
.
keyPair
=
[
keyMaterial
.
slice
(
0
32
)
keyMaterial
.
slice
(
32
64
)
]
;
return
bundle
;
}
)
;
}
encode
(
record
)
{
const
encodePromise
=
super
.
encode
(
record
)
;
return
Task
.
spawn
(
function
*
(
)
{
const
encoded
=
yield
encodePromise
;
encoded
.
kbHash
=
record
.
kbHash
;
return
encoded
;
}
)
;
}
decode
(
record
)
{
const
decodePromise
=
super
.
decode
(
record
)
;
return
Task
.
spawn
(
function
*
(
)
{
try
{
return
yield
decodePromise
;
}
catch
(
e
)
{
if
(
Utils
.
isHMACMismatch
(
e
)
)
{
const
currentKBHash
=
yield
ExtensionStorageSync
.
getKBHash
(
)
;
if
(
record
.
kbHash
!
=
currentKBHash
)
{
KeyRingEncryptionRemoteTransformer
.
throwOutdatedKB
(
currentKBHash
record
.
kbHash
)
;
}
}
throw
e
;
}
}
)
;
}
static
throwOutdatedKB
(
shouldBe
is
)
{
throw
new
Error
(
kB
hash
on
record
is
outdated
:
should
be
{
shouldBe
}
is
{
is
}
)
;
}
static
isOutdatedKB
(
exc
)
{
const
kbMessage
=
"
kB
hash
on
record
is
outdated
:
"
;
return
exc
&
&
exc
.
message
&
&
exc
.
message
.
indexOf
&
&
(
exc
.
message
.
indexOf
(
kbMessage
)
=
=
0
)
;
}
}
