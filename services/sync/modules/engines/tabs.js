var
EXPORTED_SYMBOLS
=
[
"
TabEngine
"
"
TabProvider
"
]
;
const
TABS_TTL
=
31622400
;
const
TAB_ENTRIES_LIMIT
=
5
;
const
STORAGE_VERSION
=
1
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
{
Log
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Log
.
sys
.
mjs
"
)
;
const
{
Store
SyncEngine
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
CryptoWrapper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
const
{
Svc
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
LOGIN_SUCCEEDED
SCORE_INCREMENT_SMALL
STATUS_OK
URI_LENGTH_MAX
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
SyncRecord
SyncTelemetry
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
telemetry
.
js
"
)
;
const
{
BridgedEngine
LogAdapter
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
bridged_engine
.
js
"
)
;
const
FAR_FUTURE
=
4102405200000
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
sys
.
mjs
"
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
lazy
{
NimbusFeatures
:
"
resource
:
/
/
nimbus
/
ExperimentAPI
.
jsm
"
TabsStore
:
"
resource
:
/
/
gre
/
modules
/
RustTabs
.
jsm
"
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
TABS_FILTERED_SCHEMES
"
"
services
.
sync
.
engine
.
tabs
.
filteredSchemes
"
"
"
null
val
=
>
{
return
new
Set
(
val
.
split
(
"
|
"
)
)
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
lazy
"
SYNC_AFTER_DELAY_MS
"
"
services
.
sync
.
syncedTabs
.
syncDelayAfterTabChange
"
0
)
;
function
TabEngine
(
service
)
{
BridgedEngine
.
call
(
this
"
Tabs
"
service
)
;
}
TabEngine
.
prototype
=
{
_trackerObj
:
TabTracker
syncPriority
:
3
async
prepareTheBridge
(
isQuickWrite
)
{
let
clientsEngine
=
this
.
service
.
clientsEngine
;
let
clientData
=
{
local_client_id
:
clientsEngine
.
localID
recent_clients
:
{
}
}
;
let
tabs
=
await
this
.
getTabsWithinPayloadSize
(
)
;
await
this
.
_rustStore
.
setLocalTabs
(
tabs
.
map
(
tab
=
>
{
tab
.
lastUsed
=
tab
.
lastUsed
*
1000
;
return
tab
;
}
)
)
;
for
(
let
remoteClient
of
clientsEngine
.
remoteClients
)
{
let
id
=
remoteClient
.
id
;
if
(
!
id
)
{
throw
new
Error
(
"
Remote
client
somehow
did
not
have
an
id
"
)
;
}
let
client
=
{
fxa_device_id
:
remoteClient
.
fxaDeviceId
device_type
:
clientsEngine
.
getClientType
(
id
)
device_name
:
clientsEngine
.
getClientName
(
id
)
}
;
clientData
.
recent_clients
[
id
]
=
client
;
}
clientData
.
recent_clients
[
clientsEngine
.
localID
]
=
{
fxa_device_id
:
await
clientsEngine
.
fxAccounts
.
device
.
getLocalId
(
)
device_name
:
clientsEngine
.
localName
device_type
:
clientsEngine
.
localType
}
;
if
(
isQuickWrite
)
{
await
this
.
setLastSync
(
FAR_FUTURE
)
;
await
this
.
_bridge
.
prepareForSync
(
JSON
.
stringify
(
clientData
)
)
;
return
;
}
if
(
(
await
this
.
getLastSync
(
)
)
=
=
=
FAR_FUTURE
)
{
await
this
.
_bridge
.
setLastSync
(
0
)
;
}
await
this
.
_bridge
.
prepareForSync
(
JSON
.
stringify
(
clientData
)
)
;
}
async
_syncStartup
(
)
{
await
super
.
_syncStartup
(
)
;
await
this
.
prepareTheBridge
(
)
;
}
async
initialize
(
)
{
await
SyncEngine
.
prototype
.
initialize
.
call
(
this
)
;
let
path
=
PathUtils
.
join
(
PathUtils
.
profileDir
"
synced
-
tabs
.
db
"
)
;
this
.
_rustStore
=
await
lazy
.
TabsStore
.
init
(
path
)
;
this
.
_bridge
=
await
this
.
_rustStore
.
bridgedEngine
(
)
;
this
.
_bridge
.
storageVersion
=
STORAGE_VERSION
;
this
.
_bridge
.
allowSkippedRecord
=
true
;
this
.
_log
.
info
(
"
Got
a
bridged
engine
!
"
)
;
this
.
_tracker
.
modified
=
true
;
}
async
getChangedIDs
(
)
{
let
changedIDs
=
{
}
;
if
(
this
.
_tracker
.
modified
)
{
changedIDs
[
this
.
service
.
clientsEngine
.
localID
]
=
0
;
}
return
changedIDs
;
}
async
getAllClients
(
)
{
let
remoteTabs
=
await
this
.
_rustStore
.
getAll
(
)
;
let
remoteClientTabs
=
[
]
;
for
(
let
remoteClient
of
this
.
service
.
clientsEngine
.
remoteClients
)
{
let
rustClient
=
remoteTabs
.
find
(
x
=
>
x
.
clientId
=
=
=
remoteClient
.
fxaDeviceId
)
;
if
(
!
rustClient
)
{
continue
;
}
let
client
=
{
tabs
:
rustClient
.
remoteTabs
.
map
(
tab
=
>
{
tab
.
lastUsed
=
tab
.
lastUsed
/
1000
;
return
tab
;
}
)
lastModified
:
rustClient
.
lastModified
/
1000
.
.
.
remoteClient
}
;
remoteClientTabs
.
push
(
client
)
;
}
return
remoteClientTabs
;
}
async
removeClientData
(
)
{
let
url
=
this
.
engineURL
+
"
/
"
+
this
.
service
.
clientsEngine
.
localID
;
await
this
.
service
.
resource
(
url
)
.
delete
(
)
;
}
async
trackRemainingChanges
(
)
{
if
(
this
.
_modified
.
count
(
)
>
0
)
{
this
.
_tracker
.
modified
=
true
;
}
}
async
getTabsWithinPayloadSize
(
)
{
let
tabs
=
await
TabProvider
.
getAllTabs
(
true
)
;
const
maxPayloadSize
=
this
.
service
.
getMaxRecordPayloadSize
(
)
;
let
records
=
Utils
.
tryFitItems
(
tabs
maxPayloadSize
)
;
if
(
records
.
length
!
=
tabs
.
length
)
{
this
.
_log
.
warn
(
Can
'
t
fit
all
tabs
in
sync
payload
:
have
{
tabs
.
length
}
but
can
only
fit
{
records
.
length
}
.
)
;
}
return
records
;
}
_engineLock
:
Utils
.
lock
_engineLocked
:
false
get
locked
(
)
{
return
this
.
_engineLocked
;
}
lock
(
)
{
if
(
this
.
_engineLocked
)
{
return
false
;
}
this
.
_engineLocked
=
true
;
return
true
;
}
unlock
(
)
{
this
.
_engineLocked
=
false
;
}
async
quickWrite
(
)
{
if
(
!
this
.
enabled
)
{
this
.
_log
.
info
(
"
Can
'
t
do
a
quick
-
sync
as
tabs
is
disabled
"
)
;
return
false
;
}
if
(
this
.
service
.
status
.
checkSetup
(
)
!
=
STATUS_OK
)
{
this
.
_log
.
info
(
"
Can
'
t
do
a
quick
-
sync
due
to
the
service
status
"
this
.
service
.
status
.
toString
(
)
)
;
return
false
;
}
if
(
!
this
.
service
.
serverConfiguration
)
{
this
.
_log
.
info
(
"
Can
'
t
do
a
quick
sync
before
the
first
full
sync
"
)
;
return
false
;
}
try
{
return
await
this
.
_engineLock
(
"
tabs
.
js
:
quickWrite
"
async
(
)
=
>
{
const
origLastSync
=
await
this
.
getLastSync
(
)
;
try
{
return
this
.
_doQuickWrite
(
)
;
}
finally
{
await
this
.
setLastSync
(
origLastSync
)
;
}
}
)
(
)
;
}
catch
(
ex
)
{
if
(
!
Utils
.
isLockException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
info
(
"
Can
'
t
do
a
quick
-
write
as
another
tab
sync
is
in
progress
"
)
;
return
false
;
}
}
async
_doQuickWrite
(
)
{
const
name
=
"
tabs
"
;
let
telemetryRecord
=
new
SyncRecord
(
SyncTelemetry
.
allowedEngines
"
quick
-
write
"
)
;
telemetryRecord
.
onEngineStart
(
name
)
;
try
{
Async
.
checkAppReady
(
)
;
await
this
.
prepareTheBridge
(
true
)
;
this
.
_tracker
.
clearChangedIDs
(
)
;
this
.
_tracker
.
resetScore
(
)
;
Async
.
checkAppReady
(
)
;
let
outgoing
=
await
this
.
_bridge
.
apply
(
)
;
let
mine
=
outgoing
[
0
]
;
this
.
_log
.
trace
(
"
outgoing
bso
"
mine
)
;
let
record
=
this
.
_recordObj
.
fromOutgoingBso
(
this
.
name
JSON
.
parse
(
mine
)
)
;
let
changeset
=
{
}
;
changeset
[
record
.
id
]
=
{
synced
:
false
record
}
;
this
.
_modified
.
replace
(
changeset
)
;
Async
.
checkAppReady
(
)
;
await
this
.
_uploadOutgoing
(
)
;
telemetryRecord
.
onEngineStop
(
name
null
)
;
return
true
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
quicksync
sync
failed
"
ex
)
;
telemetryRecord
.
onEngineStop
(
name
ex
)
;
return
false
;
}
finally
{
telemetryRecord
.
finished
(
null
)
;
SyncTelemetry
.
takeTelemetryRecord
(
telemetryRecord
)
;
}
}
async
_sync
(
)
{
try
{
await
this
.
_engineLock
(
"
tabs
.
js
:
fullSync
"
async
(
)
=
>
{
await
super
.
_sync
(
)
;
}
)
(
)
;
}
catch
(
ex
)
{
if
(
!
Utils
.
isLockException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
info
(
"
Can
'
t
do
full
tabs
sync
as
a
quick
-
write
is
currently
running
"
)
;
}
}
}
;
Object
.
setPrototypeOf
(
TabEngine
.
prototype
BridgedEngine
.
prototype
)
;
const
TabProvider
=
{
getWindowEnumerator
(
)
{
return
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
shouldSkipWindow
(
win
)
{
return
win
.
closed
|
|
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
;
}
async
getAllTabs
(
filter
)
{
let
allTabs
=
[
]
;
let
iconPromises
=
[
]
;
for
(
let
win
of
this
.
getWindowEnumerator
(
)
)
{
if
(
this
.
shouldSkipWindow
(
win
)
)
{
continue
;
}
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
if
(
!
tab
?
.
linkedBrowser
)
{
continue
;
}
let
acceptable
=
!
filter
?
url
=
>
url
:
url
=
>
url
&
&
!
lazy
.
TABS_FILTERED_SCHEMES
.
has
(
Services
.
io
.
extractScheme
(
url
)
)
;
let
url
=
tab
.
linkedBrowser
.
currentURI
?
.
spec
;
if
(
!
acceptable
(
url
)
)
{
continue
;
}
if
(
url
.
length
>
URI_LENGTH_MAX
)
{
this
.
_log
.
trace
(
"
Skipping
over
-
long
URL
.
"
)
;
continue
;
}
let
thisTab
=
{
title
:
tab
.
linkedBrowser
.
contentTitle
|
|
"
"
urlHistory
:
[
url
]
icon
:
"
"
lastUsed
:
Math
.
floor
(
(
tab
.
lastAccessed
|
|
0
)
/
1000
)
}
;
allTabs
.
push
(
thisTab
)
;
let
iconPromise
=
lazy
.
PlacesUtils
.
promiseFaviconData
(
url
)
.
then
(
iconData
=
>
{
thisTab
.
icon
=
iconData
.
uri
.
spec
;
}
)
.
catch
(
ex
=
>
{
this
.
_log
.
trace
(
Failed
to
fetch
favicon
for
{
url
}
thisTab
.
urlHistory
[
0
]
)
;
}
)
;
iconPromises
.
push
(
iconPromise
)
;
}
}
await
Promise
.
allSettled
(
iconPromises
)
;
return
allTabs
.
sort
(
function
(
a
b
)
{
return
b
.
lastUsed
-
a
.
lastUsed
;
}
)
;
}
}
;
function
TabTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
this
.
onTab
=
Utils
.
bind2
(
this
this
.
onTab
)
;
this
.
_unregisterListeners
=
Utils
.
bind2
(
this
this
.
_unregisterListeners
)
;
}
TabTracker
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
clearChangedIDs
(
)
{
this
.
modified
=
false
;
}
_topics
:
[
"
TabOpen
"
"
TabClose
"
]
_registerListenersForWindow
(
window
)
{
this
.
_log
.
trace
(
"
Registering
tab
listeners
in
window
"
)
;
for
(
let
topic
of
this
.
_topics
)
{
window
.
addEventListener
(
topic
this
.
onTab
)
;
}
window
.
addEventListener
(
"
unload
"
this
.
_unregisterListeners
)
;
if
(
window
.
gBrowser
)
{
window
.
gBrowser
.
addProgressListener
(
this
)
;
}
}
_unregisterListeners
(
event
)
{
this
.
_unregisterListenersForWindow
(
event
.
target
)
;
}
_unregisterListenersForWindow
(
window
)
{
this
.
_log
.
trace
(
"
Removing
tab
listeners
in
window
"
)
;
window
.
removeEventListener
(
"
unload
"
this
.
_unregisterListeners
)
;
for
(
let
topic
of
this
.
_topics
)
{
window
.
removeEventListener
(
topic
this
.
onTab
)
;
}
if
(
window
.
gBrowser
)
{
window
.
gBrowser
.
removeProgressListener
(
this
)
;
}
}
onStart
(
)
{
Svc
.
Obs
.
add
(
"
domwindowopened
"
this
.
asyncObserver
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_registerListenersForWindow
(
win
)
;
}
}
onStop
(
)
{
Svc
.
Obs
.
remove
(
"
domwindowopened
"
this
.
asyncObserver
)
;
for
(
let
win
of
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
)
{
this
.
_unregisterListenersForWindow
(
win
)
;
}
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
domwindowopened
"
:
let
onLoad
=
(
)
=
>
{
subject
.
removeEventListener
(
"
load
"
onLoad
)
;
this
.
_registerListenersForWindow
(
subject
)
;
}
;
subject
.
addEventListener
(
"
load
"
onLoad
)
;
break
;
}
}
onTab
(
event
)
{
if
(
event
.
originalTarget
.
linkedBrowser
)
{
let
browser
=
event
.
originalTarget
.
linkedBrowser
;
if
(
lazy
.
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
&
&
!
lazy
.
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
this
.
_log
.
trace
(
"
Ignoring
tab
event
from
private
browsing
.
"
)
;
return
;
}
}
this
.
_log
.
trace
(
"
onTab
event
:
"
+
event
.
type
)
;
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
this
.
callScheduleSync
(
SCORE_INCREMENT_SMALL
)
;
break
;
case
"
TabClose
"
:
const
tab
=
event
.
target
.
linkedBrowser
|
|
event
.
target
;
if
(
lazy
.
TABS_FILTERED_SCHEMES
.
has
(
tab
.
currentURI
.
scheme
)
)
{
return
;
}
this
.
callScheduleSync
(
SCORE_INCREMENT_SMALL
)
;
break
;
}
}
onLocationChange
(
webProgress
request
locationURI
flags
)
{
if
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_RELOAD
|
|
!
webProgress
.
isTopLevel
|
|
!
locationURI
)
{
return
;
}
this
.
callScheduleSync
(
)
;
}
callScheduleSync
(
scoreIncrement
)
{
this
.
modified
=
true
;
let
{
scheduler
}
=
this
.
engine
.
service
;
let
delayInMs
=
lazy
.
SYNC_AFTER_DELAY_MS
;
const
override
=
lazy
.
NimbusFeatures
.
syncAfterTabChange
.
getVariable
(
"
syncDelayAfterTabChangeOverride
"
)
;
if
(
override
)
{
delayInMs
=
lazy
.
NimbusFeatures
.
syncAfterTabChange
.
getVariable
(
"
syncDelayAfterTabChange
"
)
;
}
if
(
delayInMs
>
0
&
&
scheduler
.
numClients
>
1
)
{
if
(
this
.
tabsQuickWriteTimer
)
{
this
.
_log
.
debug
(
"
Detected
a
tab
change
but
a
quick
-
write
is
already
scheduled
"
)
;
return
;
}
this
.
_log
.
debug
(
"
Detected
a
tab
change
:
scheduling
a
quick
-
write
in
"
+
delayInMs
+
"
ms
"
)
;
CommonUtils
.
namedTimer
(
(
)
=
>
{
this
.
_log
.
trace
(
"
tab
quick
-
sync
timer
fired
.
"
)
;
this
.
engine
.
quickWrite
(
)
.
then
(
(
)
=
>
{
this
.
_log
.
trace
(
"
tab
quick
-
sync
done
.
"
)
;
}
)
.
catch
(
ex
=
>
{
this
.
_log
.
error
(
"
tab
quick
-
sync
failed
.
"
ex
)
;
}
)
;
}
delayInMs
this
"
tabsQuickWriteTimer
"
)
;
}
else
if
(
scoreIncrement
)
{
this
.
_log
.
debug
(
"
Detected
a
tab
change
but
conditions
aren
'
t
met
for
a
quick
write
-
bumping
score
"
)
;
this
.
score
+
=
scoreIncrement
;
}
else
{
this
.
_log
.
debug
(
"
Detected
a
tab
change
but
conditions
aren
'
t
met
for
a
quick
write
or
a
score
bump
"
)
;
}
}
}
;
Object
.
setPrototypeOf
(
TabTracker
.
prototype
Tracker
.
prototype
)
;
