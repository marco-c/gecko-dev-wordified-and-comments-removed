var
EXPORTED_SYMBOLS
=
[
"
TabEngine
"
"
TabSetRecord
"
]
;
const
TABS_TTL
=
1814400
;
const
TAB_ENTRIES_LIMIT
=
5
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
SessionStore
"
"
resource
:
/
/
/
modules
/
sessionstore
/
SessionStore
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
}
)
;
function
TabSetRecord
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
TabSetRecord
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
Tabs
"
ttl
:
TABS_TTL
}
;
Utils
.
deferGetSet
(
TabSetRecord
"
cleartext
"
[
"
clientName
"
"
tabs
"
]
)
;
function
TabEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Tabs
"
service
)
;
}
TabEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
TabStore
_trackerObj
:
TabTracker
_recordObj
:
TabSetRecord
hasSyncedThisSession
:
false
syncPriority
:
3
async
initialize
(
)
{
await
SyncEngine
.
prototype
.
initialize
.
call
(
this
)
;
await
this
.
_resetClient
(
)
;
}
async
getChangedIDs
(
)
{
let
changedIDs
=
{
}
;
if
(
this
.
_tracker
.
modified
)
changedIDs
[
this
.
service
.
clientsEngine
.
localID
]
=
0
;
return
changedIDs
;
}
getAllClients
(
)
{
return
this
.
_store
.
_remoteClients
;
}
getClientById
(
id
)
{
return
this
.
_store
.
_remoteClients
[
id
]
;
}
async
_resetClient
(
)
{
await
SyncEngine
.
prototype
.
_resetClient
.
call
(
this
)
;
await
this
.
_store
.
wipe
(
)
;
this
.
_tracker
.
modified
=
true
;
this
.
hasSyncedThisSession
=
false
;
}
async
removeClientData
(
)
{
let
url
=
this
.
engineURL
+
"
/
"
+
this
.
service
.
clientsEngine
.
localID
;
await
this
.
service
.
resource
(
url
)
.
delete
(
)
;
}
async
_reconcile
(
item
)
{
if
(
(
await
this
.
_store
.
itemExists
(
item
.
id
)
)
)
{
this
.
_log
.
trace
(
"
Ignoring
incoming
tab
item
because
of
its
id
:
"
+
item
.
id
)
;
return
false
;
}
return
SyncEngine
.
prototype
.
_reconcile
.
call
(
this
item
)
;
}
async
_syncFinish
(
)
{
this
.
hasSyncedThisSession
=
true
;
return
SyncEngine
.
prototype
.
_syncFinish
.
call
(
this
)
;
}
}
;
function
TabStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
TabStore
.
prototype
=
{
__proto__
:
Store
.
prototype
async
itemExists
(
id
)
{
return
id
=
=
this
.
engine
.
service
.
clientsEngine
.
localID
;
}
getWindowEnumerator
(
)
{
return
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
}
shouldSkipWindow
(
win
)
{
return
win
.
closed
|
|
PrivateBrowsingUtils
.
isWindowPrivate
(
win
)
;
}
getTabState
(
tab
)
{
return
JSON
.
parse
(
SessionStore
.
getTabState
(
tab
)
)
;
}
async
getAllTabs
(
filter
)
{
let
filteredUrls
=
new
RegExp
(
Svc
.
Prefs
.
get
(
"
engine
.
tabs
.
filteredUrls
"
)
"
i
"
)
;
let
allTabs
=
[
]
;
let
winEnum
=
this
.
getWindowEnumerator
(
)
;
while
(
winEnum
.
hasMoreElements
(
)
)
{
let
win
=
winEnum
.
getNext
(
)
;
if
(
this
.
shouldSkipWindow
(
win
)
)
{
continue
;
}
for
(
let
tab
of
win
.
gBrowser
.
tabs
)
{
let
tabState
=
this
.
getTabState
(
tab
)
;
if
(
!
tabState
|
|
!
tabState
.
entries
.
length
)
{
continue
;
}
let
acceptable
=
!
filter
?
(
url
)
=
>
url
:
(
url
)
=
>
url
&
&
!
filteredUrls
.
test
(
url
)
;
let
entries
=
tabState
.
entries
;
let
index
=
tabState
.
index
;
let
current
=
entries
[
index
-
1
]
;
if
(
!
acceptable
(
current
.
url
)
)
{
continue
;
}
if
(
current
.
url
.
length
>
URI_LENGTH_MAX
)
{
this
.
_log
.
trace
(
"
Skipping
over
-
long
URL
.
"
)
;
continue
;
}
let
candidates
=
(
entries
.
length
=
=
index
)
?
entries
:
entries
.
slice
(
0
index
)
;
let
urls
=
candidates
.
map
(
(
entry
)
=
>
entry
.
url
)
.
filter
(
acceptable
)
.
reverse
(
)
;
if
(
urls
.
length
>
TAB_ENTRIES_LIMIT
)
{
urls
.
length
=
TAB_ENTRIES_LIMIT
;
}
let
icon
=
"
"
;
try
{
let
iconData
=
await
PlacesUtils
.
promiseFaviconData
(
urls
[
0
]
)
;
icon
=
iconData
.
uri
.
spec
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
Failed
to
fetch
favicon
for
{
urls
[
0
]
}
ex
)
;
}
allTabs
.
push
(
{
title
:
current
.
title
|
|
"
"
urlHistory
:
urls
icon
lastUsed
:
Math
.
floor
(
(
tabState
.
lastAccessed
|
|
0
)
/
1000
)
}
)
;
}
}
return
allTabs
;
}
async
createRecord
(
id
collection
)
{
let
record
=
new
TabSetRecord
(
collection
id
)
;
record
.
clientName
=
this
.
engine
.
service
.
clientsEngine
.
localName
;
let
tabs
=
(
await
this
.
getAllTabs
(
true
)
)
.
sort
(
function
(
a
b
)
{
return
b
.
lastUsed
-
a
.
lastUsed
;
}
)
;
const
maxPayloadSize
=
this
.
engine
.
service
.
getMemcacheMaxRecordPayloadSize
(
)
;
let
records
=
Utils
.
tryFitItems
(
tabs
maxPayloadSize
)
;
if
(
records
.
length
!
=
tabs
.
length
)
{
this
.
_log
.
warn
(
Can
'
t
fit
all
tabs
in
sync
payload
:
have
{
tabs
.
length
}
but
can
only
fit
{
records
.
length
}
.
)
;
}
if
(
this
.
_log
.
level
<
=
Log
.
Level
.
Trace
)
{
records
.
forEach
(
tab
=
>
{
this
.
_log
.
trace
(
"
Wrapping
tab
:
"
tab
)
;
}
)
;
}
record
.
tabs
=
records
;
return
record
;
}
async
getAllIDs
(
)
{
let
ids
=
{
}
;
let
allWindowsArePrivate
=
false
;
let
wins
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
wins
.
hasMoreElements
(
)
)
{
if
(
PrivateBrowsingUtils
.
isWindowPrivate
(
wins
.
getNext
(
)
)
)
{
allWindowsArePrivate
=
true
;
}
else
{
allWindowsArePrivate
=
false
;
break
;
}
}
if
(
allWindowsArePrivate
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
return
ids
;
}
ids
[
this
.
engine
.
service
.
clientsEngine
.
localID
]
=
true
;
return
ids
;
}
async
wipe
(
)
{
this
.
_remoteClients
=
{
}
;
}
async
create
(
record
)
{
this
.
_log
.
debug
(
"
Adding
remote
tabs
from
"
+
record
.
clientName
)
;
this
.
_remoteClients
[
record
.
id
]
=
Object
.
assign
(
{
}
record
.
cleartext
{
lastModified
:
record
.
modified
}
)
;
}
async
update
(
record
)
{
this
.
_log
.
trace
(
"
Ignoring
tab
updates
as
local
ones
win
"
)
;
}
}
;
function
TabTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
this
.
onTab
=
Utils
.
bind2
(
this
this
.
onTab
)
;
this
.
_unregisterListeners
=
Utils
.
bind2
(
this
this
.
_unregisterListeners
)
;
}
TabTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
clearChangedIDs
(
)
{
this
.
modified
=
false
;
}
_topics
:
[
"
pageshow
"
"
TabOpen
"
"
TabClose
"
"
TabSelect
"
]
_registerListenersForWindow
(
window
)
{
this
.
_log
.
trace
(
"
Registering
tab
listeners
in
window
"
)
;
for
(
let
topic
of
this
.
_topics
)
{
window
.
addEventListener
(
topic
this
.
onTab
)
;
}
window
.
addEventListener
(
"
unload
"
this
.
_unregisterListeners
)
;
if
(
window
.
gBrowser
)
{
window
.
gBrowser
.
addProgressListener
(
this
)
;
}
}
_unregisterListeners
(
event
)
{
this
.
_unregisterListenersForWindow
(
event
.
target
)
;
}
_unregisterListenersForWindow
(
window
)
{
this
.
_log
.
trace
(
"
Removing
tab
listeners
in
window
"
)
;
window
.
removeEventListener
(
"
unload
"
this
.
_unregisterListeners
)
;
for
(
let
topic
of
this
.
_topics
)
{
window
.
removeEventListener
(
topic
this
.
onTab
)
;
}
if
(
window
.
gBrowser
)
{
window
.
gBrowser
.
removeProgressListener
(
this
)
;
}
}
onStart
(
)
{
Svc
.
Obs
.
add
(
"
domwindowopened
"
this
.
asyncObserver
)
;
let
wins
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
wins
.
hasMoreElements
(
)
)
{
this
.
_registerListenersForWindow
(
wins
.
getNext
(
)
)
;
}
}
onStop
(
)
{
Svc
.
Obs
.
remove
(
"
domwindowopened
"
this
.
asyncObserver
)
;
let
wins
=
Services
.
wm
.
getEnumerator
(
"
navigator
:
browser
"
)
;
while
(
wins
.
hasMoreElements
(
)
)
{
this
.
_unregisterListenersForWindow
(
wins
.
getNext
(
)
)
;
}
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
domwindowopened
"
:
let
onLoad
=
(
)
=
>
{
subject
.
removeEventListener
(
"
load
"
onLoad
)
;
this
.
_registerListenersForWindow
(
subject
)
;
}
;
subject
.
addEventListener
(
"
load
"
onLoad
)
;
break
;
}
}
onTab
(
event
)
{
if
(
event
.
originalTarget
.
linkedBrowser
)
{
let
browser
=
event
.
originalTarget
.
linkedBrowser
;
if
(
PrivateBrowsingUtils
.
isBrowserPrivate
(
browser
)
&
&
!
PrivateBrowsingUtils
.
permanentPrivateBrowsing
)
{
this
.
_log
.
trace
(
"
Ignoring
tab
event
from
private
browsing
.
"
)
;
return
;
}
}
this
.
_log
.
trace
(
"
onTab
event
:
"
+
event
.
type
)
;
this
.
modified
=
true
;
if
(
event
.
type
!
=
"
pageshow
"
|
|
Math
.
random
(
)
<
.
1
)
{
this
.
score
+
=
SCORE_INCREMENT_SMALL
;
}
}
onLocationChange
(
webProgress
request
location
flags
)
{
if
(
webProgress
.
isTopLevel
&
&
(
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
=
=
0
)
)
{
this
.
modified
=
true
;
}
}
}
;
