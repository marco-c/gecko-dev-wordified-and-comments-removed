this
.
EXPORTED_SYMBOLS
=
[
"
ClientEngine
"
"
ClientsRec
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
stringbundle
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
const
CLIENTS_TTL
=
1814400
;
const
CLIENTS_TTL_REFRESH
=
604800
;
const
STALE_CLIENT_REMOTE_AGE
=
604800
;
const
SUPPORTED_PROTOCOL_VERSIONS
=
[
"
1
.
1
"
"
1
.
5
"
]
;
function
hasDupeCommand
(
commands
action
)
{
if
(
!
commands
)
{
return
false
;
}
return
commands
.
some
(
other
=
>
other
.
command
=
=
action
.
command
&
&
Utils
.
deepEquals
(
other
.
args
action
.
args
)
)
;
}
this
.
ClientsRec
=
function
ClientsRec
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
ClientsRec
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
Clients
"
ttl
:
CLIENTS_TTL
}
;
Utils
.
deferGetSet
(
ClientsRec
"
cleartext
"
[
"
name
"
"
type
"
"
commands
"
"
version
"
"
protocols
"
"
formfactor
"
"
os
"
"
appPackage
"
"
application
"
"
device
"
]
)
;
this
.
ClientEngine
=
function
ClientEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Clients
"
service
)
;
this
.
_resetClient
(
)
;
}
ClientEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
ClientStore
_recordObj
:
ClientsRec
_trackerObj
:
ClientsTracker
get
enabled
(
)
{
return
true
;
}
get
lastRecordUpload
(
)
{
return
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
lastRecordUpload
"
0
)
;
}
set
lastRecordUpload
(
value
)
{
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastRecordUpload
"
Math
.
floor
(
value
)
)
;
}
get
remoteClients
(
)
{
return
Object
.
values
(
this
.
_store
.
_remoteClients
)
;
}
get
stats
(
)
{
let
stats
=
{
hasMobile
:
this
.
localType
=
=
DEVICE_TYPE_MOBILE
names
:
[
this
.
localName
]
numClients
:
1
}
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
{
name
type
}
=
this
.
_store
.
_remoteClients
[
id
]
;
stats
.
hasMobile
=
stats
.
hasMobile
|
|
type
=
=
DEVICE_TYPE_MOBILE
;
stats
.
names
.
push
(
name
)
;
stats
.
numClients
+
+
;
}
return
stats
;
}
get
deviceTypes
(
)
{
let
counts
=
new
Map
(
)
;
counts
.
set
(
this
.
localType
1
)
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
let
type
=
record
.
type
;
if
(
!
counts
.
has
(
type
)
)
{
counts
.
set
(
type
0
)
;
}
counts
.
set
(
type
counts
.
get
(
type
)
+
1
)
;
}
return
counts
;
}
get
localID
(
)
{
let
localID
=
Svc
.
Prefs
.
get
(
"
client
.
GUID
"
"
"
)
;
return
localID
=
=
"
"
?
this
.
localID
=
Utils
.
makeGUID
(
)
:
localID
;
}
set
localID
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
GUID
"
value
)
;
}
get
brandName
(
)
{
let
brand
=
new
StringBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
return
brand
.
get
(
"
brandShortName
"
)
;
}
get
localName
(
)
{
let
name
=
Utils
.
getDeviceName
(
)
;
Svc
.
Prefs
.
set
(
"
client
.
name
"
name
)
;
return
name
;
}
set
localName
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
name
"
value
)
;
fxAccounts
.
updateDeviceRegistration
(
)
.
catch
(
error
=
>
{
this
.
_log
.
warn
(
"
failed
to
update
fxa
device
registration
"
error
)
;
}
)
;
}
get
localType
(
)
{
return
Utils
.
getDeviceType
(
)
;
}
set
localType
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
type
"
value
)
;
}
remoteClientExists
(
id
)
{
return
!
!
this
.
_store
.
_remoteClients
[
id
]
;
}
getClientName
(
id
)
{
if
(
id
=
=
this
.
localID
)
{
return
this
.
localName
;
}
let
client
=
this
.
_store
.
_remoteClients
[
id
]
;
return
client
?
client
.
name
:
"
"
;
}
isMobile
:
function
isMobile
(
id
)
{
if
(
this
.
_store
.
_remoteClients
[
id
]
)
return
this
.
_store
.
_remoteClients
[
id
]
.
type
=
=
DEVICE_TYPE_MOBILE
;
return
false
;
}
_syncStartup
:
function
_syncStartup
(
)
{
if
(
Date
.
now
(
)
/
1000
-
this
.
lastRecordUpload
>
CLIENTS_TTL_REFRESH
)
{
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
this
.
lastRecordUpload
=
Date
.
now
(
)
/
1000
;
}
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
}
_processIncoming
(
)
{
this
.
lastSync
=
0
;
this
.
_incomingClients
=
{
}
;
try
{
SyncEngine
.
prototype
.
_processIncoming
.
call
(
this
)
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
if
(
!
this
.
_incomingClients
[
id
]
)
{
this
.
_log
.
info
(
Removing
local
state
for
deleted
client
{
id
}
)
;
this
.
_removeRemoteClient
(
id
)
;
}
}
delete
this
.
_incomingClients
[
this
.
localID
]
;
let
names
=
new
Set
(
[
this
.
localName
]
)
;
for
(
let
id
in
this
.
_incomingClients
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
!
names
.
has
(
record
.
name
)
)
{
names
.
add
(
record
.
name
)
;
continue
;
}
let
remoteAge
=
AsyncResource
.
serverTime
-
this
.
_incomingClients
[
id
]
;
if
(
remoteAge
>
STALE_CLIENT_REMOTE_AGE
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
id
}
with
age
{
remoteAge
}
)
;
this
.
_removeRemoteClient
(
id
)
;
}
}
}
finally
{
this
.
_incomingClients
=
null
;
}
}
_uploadOutgoing
(
)
{
this
.
_clearedCommands
=
null
;
SyncEngine
.
prototype
.
_uploadOutgoing
.
call
(
this
)
;
}
_syncFinish
(
)
{
for
(
let
[
deviceType
count
]
of
this
.
deviceTypes
)
{
let
hid
;
let
prefName
=
this
.
name
+
"
.
devices
.
"
;
switch
(
deviceType
)
{
case
"
desktop
"
:
hid
=
"
WEAVE_DEVICE_COUNT_DESKTOP
"
;
prefName
+
=
"
desktop
"
;
break
;
case
"
mobile
"
:
hid
=
"
WEAVE_DEVICE_COUNT_MOBILE
"
;
prefName
+
=
"
mobile
"
;
break
;
default
:
this
.
_log
.
warn
(
Unexpected
deviceType
"
{
deviceType
}
"
recording
device
telemetry
.
)
;
continue
;
}
Services
.
telemetry
.
getHistogramById
(
hid
)
.
add
(
count
)
;
Svc
.
Prefs
.
set
(
prefName
count
)
;
}
SyncEngine
.
prototype
.
_syncFinish
.
call
(
this
)
;
}
_reconcile
:
function
_reconcile
(
item
)
{
this
.
_incomingClients
[
item
.
id
]
=
item
.
modified
;
if
(
!
this
.
_store
.
itemExists
(
item
.
id
)
)
{
return
true
;
}
this
.
_store
.
update
(
item
)
;
return
false
;
}
_resetClient
(
)
{
this
.
_wipeClient
(
)
;
}
_wipeClient
:
function
_wipeClient
(
)
{
SyncEngine
.
prototype
.
_resetClient
.
call
(
this
)
;
delete
this
.
localCommands
;
this
.
_store
.
wipe
(
)
;
}
removeClientData
:
function
removeClientData
(
)
{
let
res
=
this
.
service
.
resource
(
this
.
engineURL
+
"
/
"
+
this
.
localID
)
;
res
.
delete
(
)
;
}
handleHMACMismatch
:
function
handleHMACMismatch
(
item
mayRetry
)
{
this
.
_log
.
debug
(
"
Handling
HMAC
mismatch
for
"
+
item
.
id
)
;
let
base
=
SyncEngine
.
prototype
.
handleHMACMismatch
.
call
(
this
item
mayRetry
)
;
if
(
base
!
=
SyncEngine
.
kRecoveryStrategy
.
error
)
return
base
;
this
.
_log
.
debug
(
"
Bad
client
record
detected
.
Scheduling
for
deletion
.
"
)
;
this
.
_deleteId
(
item
.
id
)
;
return
SyncEngine
.
kRecoveryStrategy
.
ignore
;
}
_commands
:
{
resetAll
:
{
args
:
0
desc
:
"
Clear
temporary
local
data
for
all
engines
"
}
resetEngine
:
{
args
:
1
desc
:
"
Clear
temporary
local
data
for
engine
"
}
wipeAll
:
{
args
:
0
desc
:
"
Delete
all
client
data
for
all
engines
"
}
wipeEngine
:
{
args
:
1
desc
:
"
Delete
all
client
data
for
engine
"
}
logout
:
{
args
:
0
desc
:
"
Log
out
client
"
}
displayURI
:
{
args
:
3
desc
:
"
Instruct
a
client
to
display
a
URI
"
}
}
clearCommands
:
function
clearCommands
(
)
{
if
(
!
this
.
_clearedCommands
)
{
this
.
_clearedCommands
=
[
]
;
}
this
.
_clearedCommands
=
this
.
_clearedCommands
.
concat
(
this
.
localCommands
)
;
delete
this
.
localCommands
;
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
}
_sendCommandToClient
:
function
sendCommandToClient
(
command
args
clientId
)
{
this
.
_log
.
trace
(
"
Sending
"
+
command
+
"
to
"
+
clientId
)
;
let
client
=
this
.
_store
.
_remoteClients
[
clientId
]
;
if
(
!
client
)
{
throw
new
Error
(
"
Unknown
remote
client
ID
:
'
"
+
clientId
+
"
'
.
"
)
;
}
let
action
=
{
command
:
command
args
:
args
}
;
if
(
!
client
.
commands
)
{
client
.
commands
=
[
action
]
;
}
else
if
(
!
hasDupeCommand
(
client
.
commands
action
)
)
{
client
.
commands
.
push
(
action
)
;
}
else
{
return
;
}
this
.
_log
.
trace
(
"
Client
"
+
clientId
+
"
got
a
new
action
:
"
+
[
command
args
]
)
;
this
.
_tracker
.
addChangedID
(
clientId
)
;
}
processIncomingCommands
:
function
processIncomingCommands
(
)
{
return
this
.
_notify
(
"
clients
:
process
-
commands
"
"
"
function
(
)
{
let
commands
=
this
.
localCommands
;
this
.
clearCommands
(
)
;
if
(
!
commands
)
{
return
true
;
}
let
URIsToDisplay
=
[
]
;
for
(
let
key
in
commands
)
{
let
{
command
args
}
=
commands
[
key
]
;
this
.
_log
.
debug
(
"
Processing
command
:
"
+
command
+
"
(
"
+
args
+
"
)
"
)
;
let
engines
=
[
args
[
0
]
]
;
switch
(
command
)
{
case
"
resetAll
"
:
engines
=
null
;
case
"
resetEngine
"
:
this
.
service
.
resetClient
(
engines
)
;
break
;
case
"
wipeAll
"
:
engines
=
null
;
case
"
wipeEngine
"
:
this
.
service
.
wipeClient
(
engines
)
;
break
;
case
"
logout
"
:
this
.
service
.
logout
(
)
;
return
false
;
case
"
displayURI
"
:
let
[
uri
clientId
title
]
=
args
;
URIsToDisplay
.
push
(
{
uri
clientId
title
}
)
;
break
;
default
:
this
.
_log
.
debug
(
"
Received
an
unknown
command
:
"
+
command
)
;
break
;
}
}
if
(
URIsToDisplay
.
length
)
{
this
.
_handleDisplayURIs
(
URIsToDisplay
)
;
}
return
true
;
}
)
(
)
;
}
sendCommand
:
function
sendCommand
(
command
args
clientId
)
{
let
commandData
=
this
.
_commands
[
command
]
;
if
(
!
commandData
)
{
this
.
_log
.
error
(
"
Unknown
command
to
send
:
"
+
command
)
;
return
;
}
else
if
(
!
args
|
|
args
.
length
!
=
commandData
.
args
)
{
this
.
_log
.
error
(
"
Expected
"
+
commandData
.
args
+
"
args
for
'
"
+
command
+
"
'
but
got
"
+
args
)
;
return
;
}
if
(
clientId
)
{
this
.
_sendCommandToClient
(
command
args
clientId
)
;
}
else
{
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
this
.
_sendCommandToClient
(
command
args
id
)
;
}
}
}
sendURIToClientForDisplay
:
function
sendURIToClientForDisplay
(
uri
clientId
title
)
{
this
.
_log
.
info
(
"
Sending
URI
to
client
:
"
+
uri
+
"
-
>
"
+
clientId
+
"
(
"
+
title
+
"
)
"
)
;
this
.
sendCommand
(
"
displayURI
"
[
uri
this
.
localID
title
]
clientId
)
;
this
.
_tracker
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
_handleDisplayURIs
:
function
_handleDisplayURIs
(
uris
)
{
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
clients
:
display
-
uris
"
uris
)
;
}
_removeRemoteClient
(
id
)
{
delete
this
.
_store
.
_remoteClients
[
id
]
;
this
.
_tracker
.
removeChangedID
(
id
)
;
}
}
;
function
ClientStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
ClientStore
.
prototype
=
{
__proto__
:
Store
.
prototype
create
(
record
)
{
this
.
update
(
record
)
}
update
:
function
update
(
record
)
{
if
(
record
.
id
=
=
this
.
engine
.
localID
)
{
this
.
_updateLocalRecord
(
record
)
;
}
else
{
this
.
_updateRemoteRecord
(
record
)
;
}
}
_updateLocalRecord
(
record
)
{
let
incomingCommands
=
record
.
commands
;
if
(
incomingCommands
)
{
incomingCommands
=
incomingCommands
.
filter
(
action
=
>
!
hasDupeCommand
(
this
.
engine
.
_clearedCommands
action
)
)
;
if
(
!
incomingCommands
.
length
)
{
incomingCommands
=
undefined
;
}
}
this
.
engine
.
localCommands
=
incomingCommands
;
}
_updateRemoteRecord
(
record
)
{
let
currentRecord
=
this
.
_remoteClients
[
record
.
id
]
;
if
(
!
currentRecord
|
|
!
currentRecord
.
commands
|
|
!
(
record
.
id
in
this
.
engine
.
_modified
)
)
{
this
.
_remoteClients
[
record
.
id
]
=
record
.
cleartext
;
return
;
}
for
(
let
action
of
currentRecord
.
commands
)
{
if
(
hasDupeCommand
(
record
.
cleartext
.
commands
action
)
)
{
continue
;
}
if
(
record
.
cleartext
.
commands
)
{
record
.
cleartext
.
commands
.
push
(
action
)
;
}
else
{
record
.
cleartext
.
commands
=
[
action
]
;
}
}
this
.
_remoteClients
[
record
.
id
]
=
record
.
cleartext
;
}
createRecord
:
function
createRecord
(
id
collection
)
{
let
record
=
new
ClientsRec
(
collection
id
)
;
if
(
id
=
=
this
.
engine
.
localID
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
fxAccounts
.
getDeviceId
(
)
.
then
(
id
=
>
cb
(
null
id
)
cb
)
;
try
{
record
.
fxaDeviceId
=
cb
.
wait
(
)
;
}
catch
(
error
)
{
this
.
_log
.
warn
(
"
failed
to
get
fxa
device
id
"
error
)
;
}
record
.
name
=
this
.
engine
.
localName
;
record
.
type
=
this
.
engine
.
localType
;
record
.
commands
=
this
.
engine
.
localCommands
;
record
.
version
=
Services
.
appinfo
.
version
;
record
.
protocols
=
SUPPORTED_PROTOCOL_VERSIONS
;
record
.
os
=
Services
.
appinfo
.
OS
;
record
.
appPackage
=
Services
.
appinfo
.
ID
;
record
.
application
=
this
.
engine
.
brandName
}
else
{
record
.
cleartext
=
this
.
_remoteClients
[
id
]
;
}
return
record
;
}
itemExists
(
id
)
{
return
id
in
this
.
getAllIDs
(
)
;
}
getAllIDs
:
function
getAllIDs
(
)
{
let
ids
=
{
}
;
ids
[
this
.
engine
.
localID
]
=
true
;
for
(
let
id
in
this
.
_remoteClients
)
ids
[
id
]
=
true
;
return
ids
;
}
wipe
:
function
wipe
(
)
{
this
.
_remoteClients
=
{
}
;
}
}
;
function
ClientsTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
start
-
tracking
"
this
)
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
stop
-
tracking
"
this
)
;
}
ClientsTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
_enabled
:
false
observe
:
function
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
weave
:
engine
:
start
-
tracking
"
:
if
(
!
this
.
_enabled
)
{
Svc
.
Prefs
.
observe
(
"
client
.
name
"
this
)
;
this
.
_enabled
=
true
;
}
break
;
case
"
weave
:
engine
:
stop
-
tracking
"
:
if
(
this
.
_enabled
)
{
Svc
.
Prefs
.
ignore
(
"
client
.
name
"
this
)
;
this
.
_enabled
=
false
;
}
break
;
case
"
nsPref
:
changed
"
:
this
.
_log
.
debug
(
"
client
.
name
preference
changed
"
)
;
this
.
addChangedID
(
Svc
.
Prefs
.
get
(
"
client
.
GUID
"
)
)
;
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
break
;
}
}
}
;
