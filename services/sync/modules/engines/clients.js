var
EXPORTED_SYMBOLS
=
[
"
ClientEngine
"
"
ClientsRec
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
DEVICE_TYPE_DESKTOP
DEVICE_TYPE_MOBILE
SCORE_INCREMENT_XLARGE
SINGLE_USER_THRESHOLD
SYNC_API_VERSION
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
const
{
Store
SyncEngine
Tracker
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
const
{
CryptoWrapper
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
const
{
Resource
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
const
{
Svc
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
getRepairRequestor
"
"
resource
:
/
/
services
-
sync
/
collection_repair
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
getRepairResponder
"
"
resource
:
/
/
services
-
sync
/
collection_repair
.
js
"
)
;
const
CLIENTS_TTL
=
1814400
;
const
CLIENTS_TTL_REFRESH
=
604800
;
const
STALE_CLIENT_REMOTE_AGE
=
604800
;
const
NOTIFY_TAB_SENT_TTL_SECS
=
1
*
3600
;
const
TIME_BETWEEN_FXA_DEVICES_FETCH_MS
=
10
*
1000
;
const
COLLECTION_MODIFIED_REASON_SENDTAB
=
"
sendtab
"
;
const
COLLECTION_MODIFIED_REASON_FIRSTSYNC
=
"
firstsync
"
;
const
SUPPORTED_PROTOCOL_VERSIONS
=
[
SYNC_API_VERSION
]
;
const
LAST_MODIFIED_ON_PROCESS_COMMAND_PREF
=
"
services
.
sync
.
clients
.
lastModifiedOnProcessCommands
"
;
function
hasDupeCommand
(
commands
action
)
{
if
(
!
commands
)
{
return
false
;
}
return
commands
.
some
(
other
=
>
other
.
command
=
=
action
.
command
&
&
Utils
.
deepEquals
(
other
.
args
action
.
args
)
)
;
}
function
ClientsRec
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
ClientsRec
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
Clients
"
ttl
:
CLIENTS_TTL
}
;
Utils
.
deferGetSet
(
ClientsRec
"
cleartext
"
[
"
name
"
"
type
"
"
commands
"
"
version
"
"
protocols
"
"
formfactor
"
"
os
"
"
appPackage
"
"
application
"
"
device
"
"
fxaDeviceId
"
]
)
;
function
ClientEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Clients
"
service
)
;
this
.
fxAccounts
=
fxAccounts
;
this
.
addClientCommandQueue
=
Async
.
asyncQueueCaller
(
this
.
_log
)
;
Utils
.
defineLazyIDProperty
(
this
"
localID
"
"
services
.
sync
.
client
.
GUID
"
)
;
}
ClientEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
ClientStore
_recordObj
:
ClientsRec
_trackerObj
:
ClientsTracker
allowSkippedRecord
:
false
_knownStaleFxADeviceIds
:
null
_lastDeviceCounts
:
null
async
initialize
(
)
{
await
this
.
resetLastSync
(
)
;
}
_localClientLastModified
:
0
get
_lastModifiedOnProcessCommands
(
)
{
return
Services
.
prefs
.
getIntPref
(
LAST_MODIFIED_ON_PROCESS_COMMAND_PREF
-
1
)
;
}
set
_lastModifiedOnProcessCommands
(
value
)
{
Services
.
prefs
.
setIntPref
(
LAST_MODIFIED_ON_PROCESS_COMMAND_PREF
value
)
;
}
get
isFirstSync
(
)
{
return
!
this
.
lastRecordUpload
;
}
get
enabled
(
)
{
return
true
;
}
get
lastRecordUpload
(
)
{
return
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
lastRecordUpload
"
0
)
;
}
set
lastRecordUpload
(
value
)
{
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastRecordUpload
"
Math
.
floor
(
value
)
)
;
}
get
fxaDevices
(
)
{
return
this
.
_fxaDevices
;
}
get
remoteClients
(
)
{
return
Object
.
values
(
this
.
_store
.
_remoteClients
)
.
filter
(
v
=
>
!
v
.
stale
)
;
}
remoteClient
(
id
)
{
let
client
=
this
.
_store
.
_remoteClients
[
id
]
;
return
client
&
&
!
client
.
stale
?
client
:
null
;
}
remoteClientExists
(
id
)
{
return
!
!
this
.
remoteClient
(
id
)
;
}
get
stats
(
)
{
let
stats
=
{
hasMobile
:
this
.
localType
=
=
DEVICE_TYPE_MOBILE
names
:
[
this
.
localName
]
numClients
:
1
}
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
{
name
type
stale
}
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
!
stale
)
{
stats
.
hasMobile
=
stats
.
hasMobile
|
|
type
=
=
DEVICE_TYPE_MOBILE
;
stats
.
names
.
push
(
name
)
;
stats
.
numClients
+
+
;
}
}
return
stats
;
}
get
deviceTypes
(
)
{
let
counts
=
new
Map
(
)
;
counts
.
set
(
this
.
localType
1
)
;
counts
.
set
(
DEVICE_TYPE_MOBILE
0
)
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
record
.
stale
)
{
continue
;
}
let
type
=
record
.
type
;
if
(
!
counts
.
has
(
type
)
)
{
counts
.
set
(
type
0
)
;
}
counts
.
set
(
type
counts
.
get
(
type
)
+
1
)
;
}
return
counts
;
}
get
brandName
(
)
{
let
brand
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
return
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
}
get
localName
(
)
{
return
Utils
.
getDeviceName
(
)
;
}
set
localName
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
name
"
value
)
;
this
.
fxAccounts
.
updateDeviceRegistration
(
)
.
catch
(
error
=
>
{
this
.
_log
.
warn
(
"
failed
to
update
fxa
device
registration
"
error
)
;
}
)
;
}
get
localType
(
)
{
return
Utils
.
getDeviceType
(
)
;
}
set
localType
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
type
"
value
)
;
}
getClientName
(
id
)
{
if
(
id
=
=
this
.
localID
)
{
return
this
.
localName
;
}
let
client
=
this
.
_store
.
_remoteClients
[
id
]
;
return
client
?
client
.
name
:
"
"
;
}
getClientFxaDeviceId
(
id
)
{
if
(
this
.
_store
.
_remoteClients
[
id
]
)
{
return
this
.
_store
.
_remoteClients
[
id
]
.
fxaDeviceId
;
}
return
null
;
}
getClientType
(
id
)
{
const
client
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
client
.
type
=
=
DEVICE_TYPE_DESKTOP
)
{
return
"
desktop
"
;
}
if
(
client
.
formfactor
&
&
client
.
formfactor
.
includes
(
"
tablet
"
)
)
{
return
"
tablet
"
;
}
return
"
phone
"
;
}
async
_readCommands
(
)
{
let
commands
=
await
Utils
.
jsonLoad
(
"
commands
"
this
)
;
return
commands
|
|
{
}
;
}
async
_saveCommands
(
commands
)
{
try
{
await
Utils
.
jsonSave
(
"
commands
"
this
commands
)
;
}
catch
(
error
)
{
this
.
_log
.
error
(
"
Failed
to
save
JSON
outgoing
commands
"
error
)
;
}
}
async
_prepareCommandsForUpload
(
)
{
try
{
await
Utils
.
jsonMove
(
"
commands
"
"
commands
-
syncing
"
this
)
;
}
catch
(
e
)
{
}
let
commands
=
await
Utils
.
jsonLoad
(
"
commands
-
syncing
"
this
)
;
return
commands
|
|
{
}
;
}
async
_deleteUploadedCommands
(
)
{
delete
this
.
_currentlySyncingCommands
;
try
{
await
Utils
.
jsonRemove
(
"
commands
-
syncing
"
this
)
;
}
catch
(
err
)
{
this
.
_log
.
error
(
"
Failed
to
delete
syncing
-
commands
file
"
err
)
;
}
}
async
getClientCommands
(
clientId
)
{
const
allCommands
=
await
this
.
_readCommands
(
)
;
return
allCommands
[
clientId
]
|
|
[
]
;
}
async
removeLocalCommand
(
command
)
{
await
this
.
_addClientCommand
(
this
.
localID
command
)
;
}
async
_addClientCommand
(
clientId
command
)
{
this
.
addClientCommandQueue
.
enqueueCall
(
async
(
)
=
>
{
try
{
const
localCommands
=
await
this
.
_readCommands
(
)
;
const
localClientCommands
=
localCommands
[
clientId
]
|
|
[
]
;
const
remoteClient
=
this
.
_store
.
_remoteClients
[
clientId
]
;
let
remoteClientCommands
=
[
]
;
if
(
remoteClient
&
&
remoteClient
.
commands
)
{
remoteClientCommands
=
remoteClient
.
commands
;
}
const
clientCommands
=
localClientCommands
.
concat
(
remoteClientCommands
)
;
if
(
hasDupeCommand
(
clientCommands
command
)
)
{
return
false
;
}
localCommands
[
clientId
]
=
localClientCommands
.
concat
(
command
)
;
await
this
.
_saveCommands
(
localCommands
)
;
return
true
;
}
catch
(
e
)
{
this
.
_log
.
error
(
e
)
;
return
false
;
}
}
)
;
return
this
.
addClientCommandQueue
.
promiseCallsComplete
(
)
;
}
async
_removeClientCommands
(
clientId
)
{
const
allCommands
=
await
this
.
_readCommands
(
)
;
delete
allCommands
[
clientId
]
;
await
this
.
_saveCommands
(
allCommands
)
;
}
async
updateKnownStaleClients
(
)
{
this
.
_log
.
debug
(
"
Updating
the
known
stale
clients
"
)
;
await
this
.
_fetchFxADevices
(
)
;
let
localFxADeviceId
=
await
fxAccounts
.
getDeviceId
(
)
;
let
clientList
=
Object
.
values
(
this
.
_store
.
_remoteClients
)
.
sort
(
(
a
b
)
=
>
b
.
serverLastModified
-
a
.
serverLastModified
)
;
let
seenDeviceIds
=
new
Set
(
[
localFxADeviceId
]
)
;
for
(
let
client
of
clientList
)
{
if
(
!
client
.
fxaDeviceId
)
{
continue
;
}
if
(
this
.
_knownStaleFxADeviceIds
.
includes
(
client
.
fxaDeviceId
)
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
client
.
id
}
-
in
known
stale
clients
list
)
;
client
.
stale
=
true
;
}
else
if
(
seenDeviceIds
.
has
(
client
.
fxaDeviceId
)
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
client
.
id
}
+
-
duplicate
device
id
{
client
.
fxaDeviceId
}
)
;
client
.
stale
=
true
;
}
else
{
seenDeviceIds
.
add
(
client
.
fxaDeviceId
)
;
}
}
}
async
_fetchFxADevices
(
)
{
const
now
=
new
Date
(
)
.
getTime
(
)
;
if
(
(
this
.
_lastFxADevicesFetch
|
|
0
)
+
TIME_BETWEEN_FXA_DEVICES_FETCH_MS
>
=
now
)
{
return
;
}
const
remoteClients
=
Object
.
values
(
this
.
remoteClients
)
;
try
{
this
.
_fxaDevices
=
await
this
.
fxAccounts
.
getDeviceList
(
)
;
for
(
const
device
of
this
.
_fxaDevices
)
{
device
.
clientRecord
=
remoteClients
.
find
(
c
=
>
c
.
fxaDeviceId
=
=
device
.
id
)
;
}
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Could
not
retrieve
the
FxA
device
list
"
e
)
;
this
.
_fxaDevices
=
[
]
;
}
this
.
_lastFxADevicesFetch
=
now
;
this
.
_log
.
debug
(
"
Refreshing
the
known
stale
clients
list
"
)
;
let
localClients
=
Object
.
values
(
this
.
_store
.
_remoteClients
)
.
filter
(
client
=
>
client
.
fxaDeviceId
)
.
map
(
client
=
>
client
.
fxaDeviceId
)
;
const
fxaClients
=
this
.
_fxaDevices
.
map
(
device
=
>
device
.
id
)
;
this
.
_knownStaleFxADeviceIds
=
Utils
.
arraySub
(
localClients
fxaClients
)
;
}
async
_syncStartup
(
)
{
if
(
Date
.
now
(
)
/
1000
-
this
.
lastRecordUpload
>
CLIENTS_TTL_REFRESH
)
{
await
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
}
return
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
}
async
_processIncoming
(
)
{
await
this
.
resetLastSync
(
)
;
this
.
_incomingClients
=
{
}
;
try
{
await
SyncEngine
.
prototype
.
_processIncoming
.
call
(
this
)
;
await
this
.
_fetchFxADevices
(
)
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
if
(
!
this
.
_incomingClients
[
id
]
)
{
this
.
_log
.
info
(
Removing
local
state
for
deleted
client
{
id
}
)
;
await
this
.
_removeRemoteClient
(
id
)
;
}
}
let
localFxADeviceId
=
await
fxAccounts
.
getDeviceId
(
)
;
this
.
_localClientLastModified
=
Math
.
round
(
this
.
_incomingClients
[
this
.
localID
]
)
;
delete
this
.
_incomingClients
[
this
.
localID
]
;
let
names
=
new
Set
(
[
this
.
localName
]
)
;
let
seenDeviceIds
=
new
Set
(
[
localFxADeviceId
]
)
;
let
idToLastModifiedList
=
Object
.
entries
(
this
.
_incomingClients
)
.
sort
(
(
a
b
)
=
>
b
[
1
]
-
a
[
1
]
)
;
for
(
let
[
id
serverLastModified
]
of
idToLastModifiedList
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
record
.
serverLastModified
=
serverLastModified
;
if
(
record
.
fxaDeviceId
&
&
this
.
_knownStaleFxADeviceIds
.
includes
(
record
.
fxaDeviceId
)
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
id
}
-
in
known
stale
clients
list
)
;
record
.
stale
=
true
;
}
if
(
!
names
.
has
(
record
.
name
)
)
{
if
(
record
.
fxaDeviceId
)
{
seenDeviceIds
.
add
(
record
.
fxaDeviceId
)
;
}
names
.
add
(
record
.
name
)
;
continue
;
}
let
remoteAge
=
Resource
.
serverTime
-
this
.
_incomingClients
[
id
]
;
if
(
remoteAge
>
STALE_CLIENT_REMOTE_AGE
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
id
}
with
age
{
remoteAge
}
)
;
record
.
stale
=
true
;
continue
;
}
if
(
record
.
fxaDeviceId
&
&
seenDeviceIds
.
has
(
record
.
fxaDeviceId
)
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
record
.
id
}
+
-
duplicate
device
id
{
record
.
fxaDeviceId
}
)
;
record
.
stale
=
true
;
}
else
if
(
record
.
fxaDeviceId
)
{
seenDeviceIds
.
add
(
record
.
fxaDeviceId
)
;
}
}
}
finally
{
this
.
_incomingClients
=
null
;
}
}
async
_uploadOutgoing
(
)
{
this
.
_currentlySyncingCommands
=
await
this
.
_prepareCommandsForUpload
(
)
;
const
clientWithPendingCommands
=
Object
.
keys
(
this
.
_currentlySyncingCommands
)
;
for
(
let
clientId
of
clientWithPendingCommands
)
{
if
(
this
.
_store
.
_remoteClients
[
clientId
]
|
|
this
.
localID
=
=
clientId
)
{
this
.
_modified
.
set
(
clientId
0
)
;
}
}
let
updatedIDs
=
this
.
_modified
.
ids
(
)
;
await
SyncEngine
.
prototype
.
_uploadOutgoing
.
call
(
this
)
;
let
lastSync
=
await
this
.
getLastSync
(
)
;
for
(
let
id
of
updatedIDs
)
{
if
(
id
=
=
this
.
localID
)
{
this
.
lastRecordUpload
=
lastSync
;
}
else
{
this
.
_store
.
_remoteClients
[
id
]
.
serverLastModified
=
lastSync
;
}
}
}
async
_onRecordsWritten
(
succeeded
failed
)
{
for
(
let
id
of
succeeded
)
{
const
commandChanges
=
this
.
_currentlySyncingCommands
[
id
]
;
if
(
id
=
=
this
.
localID
)
{
if
(
this
.
isFirstSync
)
{
this
.
_log
.
info
(
"
Uploaded
our
client
record
for
the
first
time
notifying
other
clients
.
"
)
;
this
.
_notifyClientRecordUploaded
(
)
;
}
if
(
this
.
localCommands
)
{
this
.
localCommands
=
this
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
commandChanges
command
)
)
;
}
}
else
{
const
clientRecord
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
!
commandChanges
|
|
!
clientRecord
)
{
this
.
_log
.
warn
(
"
No
command
/
No
record
changes
for
a
client
we
uploaded
"
)
;
continue
;
}
this
.
_store
.
_remoteClients
[
id
]
=
await
this
.
_store
.
createRecord
(
id
)
;
}
}
for
(
let
id
of
failed
)
{
const
commandChanges
=
this
.
_currentlySyncingCommands
[
id
]
;
if
(
!
commandChanges
)
{
continue
;
}
await
this
.
_addClientCommand
(
id
commandChanges
)
;
}
await
this
.
_deleteUploadedCommands
(
)
;
const
idsToNotify
=
succeeded
.
reduce
(
(
acc
id
)
=
>
{
if
(
id
=
=
this
.
localID
)
{
return
acc
;
}
const
fxaDeviceId
=
this
.
getClientFxaDeviceId
(
id
)
;
return
fxaDeviceId
?
acc
.
concat
(
fxaDeviceId
)
:
acc
;
}
[
]
)
;
if
(
idsToNotify
.
length
>
0
)
{
this
.
_notifyOtherClientsModified
(
idsToNotify
)
;
}
}
_notifyOtherClientsModified
(
ids
)
{
this
.
_notifyCollectionChanged
(
ids
NOTIFY_TAB_SENT_TTL_SECS
COLLECTION_MODIFIED_REASON_SENDTAB
)
;
}
_notifyClientRecordUploaded
(
)
{
this
.
_notifyCollectionChanged
(
null
0
COLLECTION_MODIFIED_REASON_FIRSTSYNC
)
;
}
async
_notifyCollectionChanged
(
ids
ttl
reason
)
{
const
message
=
{
version
:
1
command
:
"
sync
:
collection_changed
"
data
:
{
collections
:
[
"
clients
"
]
reason
}
}
;
let
excludedIds
=
null
;
if
(
!
ids
)
{
const
localFxADeviceId
=
await
fxAccounts
.
getDeviceId
(
)
;
excludedIds
=
[
localFxADeviceId
]
;
}
try
{
await
this
.
fxAccounts
.
notifyDevices
(
ids
excludedIds
message
ttl
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Could
not
notify
of
changes
in
the
collection
"
e
)
;
}
}
async
_syncFinish
(
)
{
let
deviceTypeCounts
=
this
.
deviceTypes
;
for
(
let
[
deviceType
count
]
of
deviceTypeCounts
)
{
let
hid
;
let
prefName
=
this
.
name
+
"
.
devices
.
"
;
switch
(
deviceType
)
{
case
DEVICE_TYPE_DESKTOP
:
hid
=
"
WEAVE_DEVICE_COUNT_DESKTOP
"
;
prefName
+
=
"
desktop
"
;
break
;
case
DEVICE_TYPE_MOBILE
:
hid
=
"
WEAVE_DEVICE_COUNT_MOBILE
"
;
prefName
+
=
"
mobile
"
;
break
;
default
:
this
.
_log
.
warn
(
Unexpected
deviceType
"
{
deviceType
}
"
recording
device
telemetry
.
)
;
continue
;
}
Services
.
telemetry
.
getHistogramById
(
hid
)
.
add
(
count
)
;
if
(
this
.
_lastDeviceCounts
=
=
null
|
|
this
.
_lastDeviceCounts
.
get
(
prefName
)
!
=
count
)
{
Svc
.
Prefs
.
set
(
prefName
count
)
;
}
}
this
.
_lastDeviceCounts
=
deviceTypeCounts
;
return
SyncEngine
.
prototype
.
_syncFinish
.
call
(
this
)
;
}
async
_reconcile
(
item
)
{
this
.
_incomingClients
[
item
.
id
]
=
item
.
modified
;
if
(
!
(
await
this
.
_store
.
itemExists
(
item
.
id
)
)
)
{
return
true
;
}
await
this
.
_store
.
update
(
item
)
;
return
false
;
}
async
_resetClient
(
)
{
await
this
.
_wipeClient
(
)
;
}
async
_wipeClient
(
)
{
await
SyncEngine
.
prototype
.
_resetClient
.
call
(
this
)
;
this
.
_knownStaleFxADeviceIds
=
null
;
delete
this
.
localCommands
;
await
this
.
_store
.
wipe
(
)
;
try
{
await
Utils
.
jsonRemove
(
"
commands
"
this
)
;
}
catch
(
err
)
{
this
.
_log
.
warn
(
"
Could
not
delete
commands
.
json
"
err
)
;
}
try
{
await
Utils
.
jsonRemove
(
"
commands
-
syncing
"
this
)
;
}
catch
(
err
)
{
this
.
_log
.
warn
(
"
Could
not
delete
commands
-
syncing
.
json
"
err
)
;
}
}
async
removeClientData
(
)
{
let
res
=
this
.
service
.
resource
(
this
.
engineURL
+
"
/
"
+
this
.
localID
)
;
await
res
.
delete
(
)
;
}
async
handleHMACMismatch
(
item
mayRetry
)
{
this
.
_log
.
debug
(
"
Handling
HMAC
mismatch
for
"
+
item
.
id
)
;
let
base
=
await
SyncEngine
.
prototype
.
handleHMACMismatch
.
call
(
this
item
mayRetry
)
;
if
(
base
!
=
SyncEngine
.
kRecoveryStrategy
.
error
)
{
return
base
;
}
this
.
_log
.
debug
(
"
Bad
client
record
detected
.
Scheduling
for
deletion
.
"
)
;
await
this
.
_deleteId
(
item
.
id
)
;
return
SyncEngine
.
kRecoveryStrategy
.
ignore
;
}
_commands
:
{
resetAll
:
{
args
:
0
importance
:
0
desc
:
"
Clear
temporary
local
data
for
all
engines
"
}
resetEngine
:
{
args
:
1
importance
:
0
desc
:
"
Clear
temporary
local
data
for
engine
"
}
wipeAll
:
{
args
:
0
importance
:
0
desc
:
"
Delete
all
client
data
for
all
engines
"
}
wipeEngine
:
{
args
:
1
importance
:
0
desc
:
"
Delete
all
client
data
for
engine
"
}
logout
:
{
args
:
0
importance
:
0
desc
:
"
Log
out
client
"
}
displayURI
:
{
args
:
3
importance
:
1
desc
:
"
Instruct
a
client
to
display
a
URI
"
}
repairRequest
:
{
args
:
1
importance
:
2
desc
:
"
Instruct
a
client
to
initiate
a
repair
"
}
repairResponse
:
{
args
:
1
importance
:
2
desc
:
"
Instruct
a
client
a
repair
request
is
complete
"
}
}
async
_sendCommandToClient
(
command
args
clientId
telemetryExtra
)
{
this
.
_log
.
trace
(
"
Sending
"
+
command
+
"
to
"
+
clientId
)
;
let
client
=
this
.
_store
.
_remoteClients
[
clientId
]
;
if
(
!
client
)
{
throw
new
Error
(
"
Unknown
remote
client
ID
:
'
"
+
clientId
+
"
'
.
"
)
;
}
if
(
client
.
stale
)
{
throw
new
Error
(
"
Stale
remote
client
ID
:
'
"
+
clientId
+
"
'
.
"
)
;
}
let
action
=
{
command
args
flowID
:
telemetryExtra
.
flowID
}
;
if
(
(
await
this
.
_addClientCommand
(
clientId
action
)
)
)
{
this
.
_log
.
trace
(
Client
{
clientId
}
got
a
new
action
[
command
args
]
)
;
await
this
.
_tracker
.
addChangedID
(
clientId
)
;
try
{
telemetryExtra
.
deviceID
=
this
.
service
.
identity
.
hashedDeviceID
(
clientId
)
;
}
catch
(
_
)
{
}
this
.
service
.
recordTelemetryEvent
(
"
sendcommand
"
command
undefined
telemetryExtra
)
;
}
else
{
this
.
_log
.
trace
(
Client
{
clientId
}
got
a
duplicate
action
[
command
args
]
)
;
}
}
async
processIncomingCommands
(
)
{
return
this
.
_notify
(
"
clients
:
process
-
commands
"
"
"
async
function
(
)
{
if
(
!
this
.
localCommands
|
|
(
this
.
_lastModifiedOnProcessCommands
=
=
this
.
_localClientLastModified
&
&
!
this
.
ignoreLastModifiedOnProcessCommands
)
)
{
return
true
;
}
this
.
_lastModifiedOnProcessCommands
=
this
.
_localClientLastModified
;
const
clearedCommands
=
await
this
.
_readCommands
(
)
[
this
.
localID
]
;
const
commands
=
this
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
clearedCommands
command
)
)
;
let
didRemoveCommand
=
false
;
let
URIsToDisplay
=
[
]
;
for
(
let
rawCommand
of
commands
)
{
let
shouldRemoveCommand
=
true
;
let
{
command
args
flowID
}
=
rawCommand
;
this
.
_log
.
debug
(
"
Processing
command
"
+
command
args
)
;
this
.
service
.
recordTelemetryEvent
(
"
processcommand
"
command
undefined
{
flowID
}
)
;
let
engines
=
[
args
[
0
]
]
;
switch
(
command
)
{
case
"
resetAll
"
:
engines
=
null
;
case
"
resetEngine
"
:
await
this
.
service
.
resetClient
(
engines
)
;
break
;
case
"
wipeAll
"
:
engines
=
null
;
case
"
wipeEngine
"
:
await
this
.
service
.
wipeClient
(
engines
)
;
break
;
case
"
logout
"
:
this
.
service
.
logout
(
)
;
return
false
;
case
"
displayURI
"
:
let
[
uri
clientId
title
]
=
args
;
URIsToDisplay
.
push
(
{
uri
clientId
title
}
)
;
break
;
case
"
repairResponse
"
:
{
let
response
=
args
[
0
]
;
let
requestor
=
getRepairRequestor
(
response
.
collection
)
;
if
(
!
requestor
)
{
this
.
_log
.
warn
(
"
repairResponse
for
unknown
collection
"
response
)
;
break
;
}
if
(
!
(
await
requestor
.
continueRepairs
(
response
)
)
)
{
this
.
_log
.
warn
(
"
repairResponse
couldn
'
t
continue
the
repair
"
response
)
;
}
break
;
}
case
"
repairRequest
"
:
{
let
request
=
args
[
0
]
;
let
responder
=
getRepairResponder
(
request
.
collection
)
;
if
(
!
responder
)
{
this
.
_log
.
warn
(
"
repairRequest
for
unknown
collection
"
request
)
;
break
;
}
try
{
if
(
(
await
responder
.
repair
(
request
rawCommand
)
)
)
{
shouldRemoveCommand
=
false
;
}
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
error
(
"
Failed
to
handle
a
repair
request
"
ex
)
;
}
break
;
}
default
:
this
.
_log
.
warn
(
"
Received
an
unknown
command
:
"
+
command
)
;
break
;
}
if
(
shouldRemoveCommand
)
{
await
this
.
removeLocalCommand
(
rawCommand
)
;
didRemoveCommand
=
true
;
}
}
if
(
didRemoveCommand
)
{
await
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
}
if
(
URIsToDisplay
.
length
)
{
this
.
_handleDisplayURIs
(
URIsToDisplay
)
;
}
return
true
;
}
)
(
)
;
}
async
sendCommand
(
command
args
clientId
=
null
telemetryExtra
=
{
}
)
{
let
commandData
=
this
.
_commands
[
command
]
;
if
(
!
commandData
)
{
this
.
_log
.
error
(
"
Unknown
command
to
send
:
"
+
command
)
;
return
;
}
else
if
(
!
args
|
|
args
.
length
!
=
commandData
.
args
)
{
this
.
_log
.
error
(
"
Expected
"
+
commandData
.
args
+
"
args
for
'
"
+
command
+
"
'
but
got
"
+
args
)
;
return
;
}
telemetryExtra
=
Object
.
assign
(
{
}
telemetryExtra
)
;
if
(
!
telemetryExtra
.
flowID
)
{
telemetryExtra
.
flowID
=
Utils
.
makeGUID
(
)
;
}
if
(
clientId
)
{
await
this
.
_sendCommandToClient
(
command
args
clientId
telemetryExtra
)
;
}
else
{
for
(
let
[
id
record
]
of
Object
.
entries
(
this
.
_store
.
_remoteClients
)
)
{
if
(
!
record
.
stale
)
{
await
this
.
_sendCommandToClient
(
command
args
id
telemetryExtra
)
;
}
}
}
}
async
sendURIToClientForDisplay
(
uri
clientId
title
)
{
this
.
_log
.
trace
(
"
Sending
URI
to
client
:
"
+
uri
+
"
-
>
"
+
clientId
+
"
(
"
+
title
+
"
)
"
)
;
await
this
.
sendCommand
(
"
displayURI
"
[
uri
this
.
localID
title
]
clientId
)
;
this
.
_tracker
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
_handleDisplayURIs
(
uris
)
{
uris
.
forEach
(
uri
=
>
{
uri
.
sender
=
{
id
:
uri
.
clientId
name
:
this
.
getClientName
(
uri
.
clientId
)
}
;
}
)
;
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
clients
:
display
-
uris
"
uris
)
;
}
async
_removeRemoteClient
(
id
)
{
delete
this
.
_store
.
_remoteClients
[
id
]
;
await
this
.
_tracker
.
removeChangedID
(
id
)
;
await
this
.
_removeClientCommands
(
id
)
;
this
.
_modified
.
delete
(
id
)
;
}
}
;
function
ClientStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
ClientStore
.
prototype
=
{
__proto__
:
Store
.
prototype
_remoteClients
:
{
}
async
create
(
record
)
{
await
this
.
update
(
record
)
;
}
async
update
(
record
)
{
if
(
record
.
id
=
=
this
.
engine
.
localID
)
{
this
.
engine
.
localCommands
=
record
.
commands
;
}
else
{
this
.
_remoteClients
[
record
.
id
]
=
record
.
cleartext
;
}
}
async
createRecord
(
id
collection
)
{
let
record
=
new
ClientsRec
(
collection
id
)
;
const
commandsChanges
=
this
.
engine
.
_currentlySyncingCommands
?
this
.
engine
.
_currentlySyncingCommands
[
id
]
:
[
]
;
if
(
id
=
=
this
.
engine
.
localID
)
{
try
{
record
.
fxaDeviceId
=
await
this
.
engine
.
fxAccounts
.
getDeviceId
(
)
;
}
catch
(
error
)
{
this
.
_log
.
warn
(
"
failed
to
get
fxa
device
id
"
error
)
;
}
record
.
name
=
this
.
engine
.
localName
;
record
.
type
=
this
.
engine
.
localType
;
record
.
version
=
Services
.
appinfo
.
version
;
record
.
protocols
=
SUPPORTED_PROTOCOL_VERSIONS
;
if
(
commandsChanges
&
&
commandsChanges
.
length
&
&
this
.
engine
.
localCommands
&
&
this
.
engine
.
localCommands
.
length
)
{
record
.
commands
=
this
.
engine
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
commandsChanges
command
)
)
;
}
record
.
os
=
Services
.
appinfo
.
OS
;
record
.
appPackage
=
Services
.
appinfo
.
ID
;
record
.
application
=
this
.
engine
.
brandName
;
}
else
{
record
.
cleartext
=
Object
.
assign
(
{
}
this
.
_remoteClients
[
id
]
)
;
delete
record
.
cleartext
.
serverLastModified
;
if
(
commandsChanges
&
&
commandsChanges
.
length
)
{
const
recordCommands
=
record
.
cleartext
.
commands
|
|
[
]
;
const
newCommands
=
commandsChanges
.
filter
(
command
=
>
!
hasDupeCommand
(
recordCommands
command
)
)
;
record
.
cleartext
.
commands
=
recordCommands
.
concat
(
newCommands
)
;
}
if
(
record
.
cleartext
.
stale
)
{
this
.
_log
.
error
(
Preparing
to
upload
record
{
id
}
that
we
consider
stale
)
;
delete
record
.
cleartext
.
stale
;
}
}
if
(
record
.
commands
)
{
const
maxPayloadSize
=
this
.
engine
.
service
.
getMemcacheMaxRecordPayloadSize
(
)
;
let
origOrder
=
new
Map
(
record
.
commands
.
map
(
(
c
i
)
=
>
[
c
i
]
)
)
;
let
commands
=
record
.
commands
.
slice
(
)
.
sort
(
(
a
b
)
=
>
{
let
infoA
=
this
.
engine
.
_commands
[
a
.
command
]
;
let
infoB
=
this
.
engine
.
_commands
[
b
.
command
]
;
let
importA
=
infoA
?
infoA
.
importance
:
0
;
let
importB
=
infoB
?
infoB
.
importance
:
0
;
let
importDelta
=
importA
-
importB
;
if
(
importDelta
!
=
0
)
{
return
importDelta
;
}
let
origIdxA
=
origOrder
.
get
(
a
)
;
let
origIdxB
=
origOrder
.
get
(
b
)
;
return
origIdxB
-
origIdxA
;
}
)
;
let
truncatedCommands
=
Utils
.
tryFitItems
(
commands
maxPayloadSize
)
;
if
(
truncatedCommands
.
length
!
=
record
.
commands
.
length
)
{
this
.
_log
.
warn
(
Removing
commands
from
client
{
id
}
(
from
{
record
.
commands
.
length
}
to
{
truncatedCommands
.
length
}
)
)
;
record
.
commands
=
truncatedCommands
.
sort
(
(
a
b
)
=
>
origOrder
.
get
(
a
)
-
origOrder
.
get
(
b
)
)
;
}
}
return
record
;
}
async
itemExists
(
id
)
{
return
id
in
(
await
this
.
getAllIDs
(
)
)
;
}
async
getAllIDs
(
)
{
let
ids
=
{
}
;
ids
[
this
.
engine
.
localID
]
=
true
;
for
(
let
id
in
this
.
_remoteClients
)
{
ids
[
id
]
=
true
;
}
return
ids
;
}
async
wipe
(
)
{
this
.
_remoteClients
=
{
}
;
}
}
;
function
ClientsTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
}
ClientsTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
_enabled
:
false
onStart
(
)
{
Svc
.
Obs
.
add
(
"
fxaccounts
:
new_device_id
"
this
.
asyncObserver
)
;
Svc
.
Prefs
.
observe
(
"
client
.
name
"
this
.
asyncObserver
)
;
}
onStop
(
)
{
Svc
.
Prefs
.
ignore
(
"
client
.
name
"
this
.
asyncObserver
)
;
Svc
.
Obs
.
remove
(
"
fxaccounts
:
new_device_id
"
this
.
asyncObserver
)
;
}
async
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
nsPref
:
changed
"
:
this
.
_log
.
debug
(
"
client
.
name
preference
changed
"
)
;
case
"
fxaccounts
:
new_device_id
"
:
await
this
.
addChangedID
(
this
.
engine
.
localID
)
;
this
.
score
+
=
SINGLE_USER_THRESHOLD
+
1
;
break
;
}
}
}
;
