this
.
EXPORTED_SYMBOLS
=
[
"
ClientEngine
"
"
ClientsRec
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
getRepairRequestor
"
"
resource
:
/
/
services
-
sync
/
collection_repair
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
getRepairResponder
"
"
resource
:
/
/
services
-
sync
/
collection_repair
.
js
"
)
;
const
CLIENTS_TTL
=
1814400
;
const
CLIENTS_TTL_REFRESH
=
604800
;
const
STALE_CLIENT_REMOTE_AGE
=
604800
;
const
SUPPORTED_PROTOCOL_VERSIONS
=
[
SYNC_API_VERSION
]
;
function
hasDupeCommand
(
commands
action
)
{
if
(
!
commands
)
{
return
false
;
}
return
commands
.
some
(
other
=
>
other
.
command
=
=
action
.
command
&
&
Utils
.
deepEquals
(
other
.
args
action
.
args
)
)
;
}
this
.
ClientsRec
=
function
ClientsRec
(
collection
id
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
}
ClientsRec
.
prototype
=
{
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
Clients
"
ttl
:
CLIENTS_TTL
}
;
Utils
.
deferGetSet
(
ClientsRec
"
cleartext
"
[
"
name
"
"
type
"
"
commands
"
"
version
"
"
protocols
"
"
formfactor
"
"
os
"
"
appPackage
"
"
application
"
"
device
"
"
fxaDeviceId
"
]
)
;
this
.
ClientEngine
=
function
ClientEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Clients
"
service
)
;
this
.
resetLastSync
(
)
;
this
.
fxAccounts
=
fxAccounts
;
}
ClientEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_storeObj
:
ClientStore
_recordObj
:
ClientsRec
_trackerObj
:
ClientsTracker
allowSkippedRecord
:
false
_knownStaleFxADeviceIds
:
null
get
enabled
(
)
{
return
true
;
}
get
lastRecordUpload
(
)
{
return
Svc
.
Prefs
.
get
(
this
.
name
+
"
.
lastRecordUpload
"
0
)
;
}
set
lastRecordUpload
(
value
)
{
Svc
.
Prefs
.
set
(
this
.
name
+
"
.
lastRecordUpload
"
Math
.
floor
(
value
)
)
;
}
get
remoteClients
(
)
{
return
Object
.
values
(
this
.
_store
.
_remoteClients
)
.
filter
(
v
=
>
!
v
.
stale
)
;
}
remoteClient
(
id
)
{
let
client
=
this
.
_store
.
_remoteClients
[
id
]
;
return
client
&
&
!
client
.
stale
?
client
:
null
;
}
remoteClientExists
(
id
)
{
return
!
!
this
.
remoteClient
(
id
)
;
}
get
stats
(
)
{
let
stats
=
{
hasMobile
:
this
.
localType
=
=
DEVICE_TYPE_MOBILE
names
:
[
this
.
localName
]
numClients
:
1
}
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
{
name
type
stale
}
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
!
stale
)
{
stats
.
hasMobile
=
stats
.
hasMobile
|
|
type
=
=
DEVICE_TYPE_MOBILE
;
stats
.
names
.
push
(
name
)
;
stats
.
numClients
+
+
;
}
}
return
stats
;
}
get
deviceTypes
(
)
{
let
counts
=
new
Map
(
)
;
counts
.
set
(
this
.
localType
1
)
;
counts
.
set
(
DEVICE_TYPE_MOBILE
0
)
;
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
record
.
stale
)
{
continue
;
}
let
type
=
record
.
type
;
if
(
!
counts
.
has
(
type
)
)
{
counts
.
set
(
type
0
)
;
}
counts
.
set
(
type
counts
.
get
(
type
)
+
1
)
;
}
return
counts
;
}
get
localID
(
)
{
let
localID
=
Svc
.
Prefs
.
get
(
"
client
.
GUID
"
"
"
)
;
return
localID
=
=
"
"
?
this
.
localID
=
Utils
.
makeGUID
(
)
:
localID
;
}
set
localID
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
GUID
"
value
)
;
}
get
brandName
(
)
{
let
brand
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
)
;
return
brand
.
GetStringFromName
(
"
brandShortName
"
)
;
}
get
localName
(
)
{
let
name
=
Utils
.
getDeviceName
(
)
;
Svc
.
Prefs
.
set
(
"
client
.
name
"
name
)
;
return
name
;
}
set
localName
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
name
"
value
)
;
this
.
fxAccounts
.
updateDeviceRegistration
(
)
.
catch
(
error
=
>
{
this
.
_log
.
warn
(
"
failed
to
update
fxa
device
registration
"
error
)
;
}
)
;
}
get
localType
(
)
{
return
Utils
.
getDeviceType
(
)
;
}
set
localType
(
value
)
{
Svc
.
Prefs
.
set
(
"
client
.
type
"
value
)
;
}
getClientName
(
id
)
{
if
(
id
=
=
this
.
localID
)
{
return
this
.
localName
;
}
let
client
=
this
.
_store
.
_remoteClients
[
id
]
;
return
client
?
client
.
name
:
"
"
;
}
getClientFxaDeviceId
(
id
)
{
if
(
this
.
_store
.
_remoteClients
[
id
]
)
{
return
this
.
_store
.
_remoteClients
[
id
]
.
fxaDeviceId
;
}
return
null
;
}
isMobile
:
function
isMobile
(
id
)
{
if
(
this
.
_store
.
_remoteClients
[
id
]
)
return
this
.
_store
.
_remoteClients
[
id
]
.
type
=
=
DEVICE_TYPE_MOBILE
;
return
false
;
}
_readCommands
(
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
Utils
.
jsonLoad
(
"
commands
"
this
commands
=
>
cb
(
null
commands
)
)
;
return
cb
.
wait
(
)
|
|
{
}
;
}
_saveCommands
(
commands
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
Utils
.
jsonSave
(
"
commands
"
this
commands
error
=
>
{
if
(
error
)
{
this
.
_log
.
error
(
"
Failed
to
save
JSON
outgoing
commands
"
error
)
;
}
cb
(
)
;
}
)
;
cb
.
wait
(
)
;
}
_prepareCommandsForUpload
(
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
Utils
.
jsonMove
(
"
commands
"
"
commands
-
syncing
"
this
)
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
Utils
.
jsonLoad
(
"
commands
-
syncing
"
this
commands
=
>
cb
(
null
commands
)
)
;
}
)
;
return
cb
.
wait
(
)
|
|
{
}
;
}
_deleteUploadedCommands
(
)
{
delete
this
.
_currentlySyncingCommands
;
Async
.
promiseSpinningly
(
Utils
.
jsonRemove
(
"
commands
-
syncing
"
this
)
.
catch
(
err
=
>
{
this
.
_log
.
error
(
"
Failed
to
delete
syncing
-
commands
file
"
err
)
;
}
)
)
;
}
getClientCommands
(
clientId
)
{
const
allCommands
=
this
.
_readCommands
(
)
;
return
allCommands
[
clientId
]
|
|
[
]
;
}
removeLocalCommand
(
command
)
{
this
.
_addClientCommand
(
this
.
localID
command
)
;
}
_addClientCommand
(
clientId
command
)
{
const
allCommands
=
this
.
_readCommands
(
)
;
const
clientCommands
=
allCommands
[
clientId
]
|
|
[
]
;
if
(
hasDupeCommand
(
clientCommands
command
)
)
{
return
false
;
}
allCommands
[
clientId
]
=
clientCommands
.
concat
(
command
)
;
this
.
_saveCommands
(
allCommands
)
;
return
true
;
}
_removeClientCommands
(
clientId
)
{
const
allCommands
=
this
.
_readCommands
(
)
;
delete
allCommands
[
clientId
]
;
this
.
_saveCommands
(
allCommands
)
;
}
_refreshKnownStaleClients
(
)
{
this
.
_log
.
debug
(
"
Refreshing
the
known
stale
clients
list
"
)
;
let
localClients
=
Object
.
values
(
this
.
_store
.
_remoteClients
)
.
filter
(
client
=
>
client
.
fxaDeviceId
)
.
map
(
client
=
>
client
.
fxaDeviceId
)
;
let
fxaClients
;
try
{
fxaClients
=
Async
.
promiseSpinningly
(
this
.
fxAccounts
.
getDeviceList
(
)
)
.
map
(
device
=
>
device
.
id
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
Could
not
retrieve
the
FxA
device
list
"
ex
)
;
this
.
_knownStaleFxADeviceIds
=
[
]
;
return
;
}
this
.
_knownStaleFxADeviceIds
=
Utils
.
arraySub
(
localClients
fxaClients
)
;
}
_syncStartup
(
)
{
this
.
isFirstSync
=
!
this
.
lastRecordUpload
;
if
(
Date
.
now
(
)
/
1000
-
this
.
lastRecordUpload
>
CLIENTS_TTL_REFRESH
)
{
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
this
.
lastRecordUpload
=
Date
.
now
(
)
/
1000
;
}
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
}
_processIncoming
(
)
{
this
.
lastSync
=
0
;
this
.
_incomingClients
=
{
}
;
try
{
SyncEngine
.
prototype
.
_processIncoming
.
call
(
this
)
;
if
(
!
this
.
_knownStaleFxADeviceIds
)
{
this
.
_refreshKnownStaleClients
(
)
;
}
for
(
let
id
in
this
.
_store
.
_remoteClients
)
{
if
(
!
this
.
_incomingClients
[
id
]
)
{
this
.
_log
.
info
(
Removing
local
state
for
deleted
client
{
id
}
)
;
this
.
_removeRemoteClient
(
id
)
;
}
}
delete
this
.
_incomingClients
[
this
.
localID
]
;
let
names
=
new
Set
(
[
this
.
localName
]
)
;
for
(
let
[
id
serverLastModified
]
of
Object
.
entries
(
this
.
_incomingClients
)
)
{
let
record
=
this
.
_store
.
_remoteClients
[
id
]
;
record
.
serverLastModified
=
serverLastModified
;
if
(
record
.
fxaDeviceId
&
&
this
.
_knownStaleFxADeviceIds
.
includes
(
record
.
fxaDeviceId
)
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
id
}
-
in
known
stale
clients
list
)
;
record
.
stale
=
true
;
}
if
(
!
names
.
has
(
record
.
name
)
)
{
names
.
add
(
record
.
name
)
;
continue
;
}
let
remoteAge
=
AsyncResource
.
serverTime
-
this
.
_incomingClients
[
id
]
;
if
(
remoteAge
>
STALE_CLIENT_REMOTE_AGE
)
{
this
.
_log
.
info
(
Hiding
stale
client
{
id
}
with
age
{
remoteAge
}
)
;
record
.
stale
=
true
;
}
}
}
finally
{
this
.
_incomingClients
=
null
;
}
}
_uploadOutgoing
(
)
{
this
.
_currentlySyncingCommands
=
this
.
_prepareCommandsForUpload
(
)
;
const
clientWithPendingCommands
=
Object
.
keys
(
this
.
_currentlySyncingCommands
)
;
for
(
let
clientId
of
clientWithPendingCommands
)
{
if
(
this
.
_store
.
_remoteClients
[
clientId
]
|
|
this
.
localID
=
=
clientId
)
{
this
.
_modified
.
set
(
clientId
0
)
;
}
}
let
updatedIDs
=
this
.
_modified
.
ids
(
)
;
SyncEngine
.
prototype
.
_uploadOutgoing
.
call
(
this
)
;
for
(
let
id
of
updatedIDs
)
{
if
(
id
!
=
this
.
localID
)
{
this
.
_store
.
_remoteClients
[
id
]
.
serverLastModified
=
this
.
lastSync
;
}
}
}
_onRecordsWritten
(
succeeded
failed
)
{
for
(
let
id
of
succeeded
)
{
const
commandChanges
=
this
.
_currentlySyncingCommands
[
id
]
;
if
(
id
=
=
this
.
localID
)
{
if
(
this
.
isFirstSync
)
{
this
.
_log
.
info
(
"
Uploaded
our
client
record
for
the
first
time
notifying
other
clients
.
"
)
;
this
.
_notifyCollectionChanged
(
)
;
}
if
(
this
.
localCommands
)
{
this
.
localCommands
=
this
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
commandChanges
command
)
)
;
}
}
else
{
const
clientRecord
=
this
.
_store
.
_remoteClients
[
id
]
;
if
(
!
commandChanges
|
|
!
clientRecord
)
{
this
.
_log
.
warn
(
"
No
command
/
No
record
changes
for
a
client
we
uploaded
"
)
;
continue
;
}
this
.
_store
.
_remoteClients
[
id
]
=
this
.
_store
.
createRecord
(
id
)
;
}
}
for
(
let
id
of
failed
)
{
const
commandChanges
=
this
.
_currentlySyncingCommands
[
id
]
;
if
(
!
commandChanges
)
{
continue
;
}
this
.
_addClientCommand
(
id
commandChanges
)
;
}
this
.
_deleteUploadedCommands
(
)
;
const
idsToNotify
=
succeeded
.
reduce
(
(
acc
id
)
=
>
{
if
(
id
=
=
this
.
localID
)
{
return
acc
;
}
const
fxaDeviceId
=
this
.
getClientFxaDeviceId
(
id
)
;
return
fxaDeviceId
?
acc
.
concat
(
fxaDeviceId
)
:
acc
;
}
[
]
)
;
if
(
idsToNotify
.
length
>
0
)
{
this
.
_notifyCollectionChanged
(
idsToNotify
NOTIFY_TAB_SENT_TTL_SECS
)
;
}
}
async
_notifyCollectionChanged
(
ids
=
null
ttl
=
0
)
{
const
message
=
{
version
:
1
command
:
"
sync
:
collection_changed
"
data
:
{
collections
:
[
"
clients
"
]
}
}
;
let
excludedIds
=
null
;
if
(
!
ids
)
{
const
localFxADeviceId
=
await
fxAccounts
.
getDeviceId
(
)
;
excludedIds
=
[
localFxADeviceId
]
;
}
try
{
await
this
.
fxAccounts
.
notifyDevices
(
ids
excludedIds
message
ttl
)
;
}
catch
(
e
)
{
this
.
_log
.
error
(
"
Could
not
notify
of
changes
in
the
collection
"
e
)
;
}
}
_syncFinish
(
)
{
for
(
let
[
deviceType
count
]
of
this
.
deviceTypes
)
{
let
hid
;
let
prefName
=
this
.
name
+
"
.
devices
.
"
;
switch
(
deviceType
)
{
case
DEVICE_TYPE_DESKTOP
:
hid
=
"
WEAVE_DEVICE_COUNT_DESKTOP
"
;
prefName
+
=
"
desktop
"
;
break
;
case
DEVICE_TYPE_MOBILE
:
hid
=
"
WEAVE_DEVICE_COUNT_MOBILE
"
;
prefName
+
=
"
mobile
"
;
break
;
default
:
this
.
_log
.
warn
(
Unexpected
deviceType
"
{
deviceType
}
"
recording
device
telemetry
.
)
;
continue
;
}
Services
.
telemetry
.
getHistogramById
(
hid
)
.
add
(
count
)
;
Svc
.
Prefs
.
set
(
prefName
count
)
;
}
SyncEngine
.
prototype
.
_syncFinish
.
call
(
this
)
;
}
_reconcile
:
function
_reconcile
(
item
)
{
this
.
_incomingClients
[
item
.
id
]
=
item
.
modified
;
if
(
!
this
.
_store
.
itemExists
(
item
.
id
)
)
{
return
true
;
}
this
.
_store
.
update
(
item
)
;
return
false
;
}
_resetClient
(
)
{
this
.
_wipeClient
(
)
;
}
_wipeClient
:
function
_wipeClient
(
)
{
SyncEngine
.
prototype
.
_resetClient
.
call
(
this
)
;
this
.
_knownStaleFxADeviceIds
=
null
;
delete
this
.
localCommands
;
this
.
_store
.
wipe
(
)
;
const
logRemoveError
=
err
=
>
this
.
_log
.
warn
(
"
Could
not
delete
json
file
"
err
)
;
Async
.
promiseSpinningly
(
Utils
.
jsonRemove
(
"
commands
"
this
)
.
catch
(
logRemoveError
)
.
then
(
Utils
.
jsonRemove
(
"
commands
-
syncing
"
this
)
.
catch
(
logRemoveError
)
)
)
;
}
async
removeClientData
(
)
{
let
res
=
this
.
service
.
resource
(
this
.
engineURL
+
"
/
"
+
this
.
localID
)
;
await
res
.
delete
(
)
;
}
handleHMACMismatch
:
function
handleHMACMismatch
(
item
mayRetry
)
{
this
.
_log
.
debug
(
"
Handling
HMAC
mismatch
for
"
+
item
.
id
)
;
let
base
=
SyncEngine
.
prototype
.
handleHMACMismatch
.
call
(
this
item
mayRetry
)
;
if
(
base
!
=
SyncEngine
.
kRecoveryStrategy
.
error
)
return
base
;
this
.
_log
.
debug
(
"
Bad
client
record
detected
.
Scheduling
for
deletion
.
"
)
;
this
.
_deleteId
(
item
.
id
)
;
return
SyncEngine
.
kRecoveryStrategy
.
ignore
;
}
_commands
:
{
resetAll
:
{
args
:
0
desc
:
"
Clear
temporary
local
data
for
all
engines
"
}
resetEngine
:
{
args
:
1
desc
:
"
Clear
temporary
local
data
for
engine
"
}
wipeAll
:
{
args
:
0
desc
:
"
Delete
all
client
data
for
all
engines
"
}
wipeEngine
:
{
args
:
1
desc
:
"
Delete
all
client
data
for
engine
"
}
logout
:
{
args
:
0
desc
:
"
Log
out
client
"
}
displayURI
:
{
args
:
3
desc
:
"
Instruct
a
client
to
display
a
URI
"
}
repairRequest
:
{
args
:
1
desc
:
"
Instruct
a
client
to
initiate
a
repair
"
}
repairResponse
:
{
args
:
1
desc
:
"
Instruct
a
client
a
repair
request
is
complete
"
}
}
_sendCommandToClient
(
command
args
clientId
telemetryExtra
)
{
this
.
_log
.
trace
(
"
Sending
"
+
command
+
"
to
"
+
clientId
)
;
let
client
=
this
.
_store
.
_remoteClients
[
clientId
]
;
if
(
!
client
)
{
throw
new
Error
(
"
Unknown
remote
client
ID
:
'
"
+
clientId
+
"
'
.
"
)
;
}
if
(
client
.
stale
)
{
throw
new
Error
(
"
Stale
remote
client
ID
:
'
"
+
clientId
+
"
'
.
"
)
;
}
let
action
=
{
command
args
flowID
:
telemetryExtra
.
flowID
}
;
if
(
this
.
_addClientCommand
(
clientId
action
)
)
{
this
.
_log
.
trace
(
Client
{
clientId
}
got
a
new
action
[
command
args
]
)
;
this
.
_tracker
.
addChangedID
(
clientId
)
;
try
{
telemetryExtra
.
deviceID
=
this
.
service
.
identity
.
hashedDeviceID
(
clientId
)
;
}
catch
(
_
)
{
}
this
.
service
.
recordTelemetryEvent
(
"
sendcommand
"
command
undefined
telemetryExtra
)
;
}
else
{
this
.
_log
.
trace
(
Client
{
clientId
}
got
a
duplicate
action
[
command
args
]
)
;
}
}
processIncomingCommands
:
function
processIncomingCommands
(
)
{
return
this
.
_notify
(
"
clients
:
process
-
commands
"
"
"
function
(
)
{
if
(
!
this
.
localCommands
)
{
return
true
;
}
const
clearedCommands
=
this
.
_readCommands
(
)
[
this
.
localID
]
;
const
commands
=
this
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
clearedCommands
command
)
)
;
let
didRemoveCommand
=
false
;
let
URIsToDisplay
=
[
]
;
for
(
let
rawCommand
of
commands
)
{
let
shouldRemoveCommand
=
true
;
let
{
command
args
flowID
}
=
rawCommand
;
this
.
_log
.
debug
(
"
Processing
command
"
+
command
args
)
;
this
.
service
.
recordTelemetryEvent
(
"
processcommand
"
command
undefined
{
flowID
}
)
;
let
engines
=
[
args
[
0
]
]
;
switch
(
command
)
{
case
"
resetAll
"
:
engines
=
null
;
case
"
resetEngine
"
:
this
.
service
.
resetClient
(
engines
)
;
break
;
case
"
wipeAll
"
:
engines
=
null
;
case
"
wipeEngine
"
:
this
.
service
.
wipeClient
(
engines
)
;
break
;
case
"
logout
"
:
this
.
service
.
logout
(
)
;
return
false
;
case
"
displayURI
"
:
let
[
uri
clientId
title
]
=
args
;
URIsToDisplay
.
push
(
{
uri
clientId
title
}
)
;
break
;
case
"
repairResponse
"
:
{
let
response
=
args
[
0
]
;
let
requestor
=
getRepairRequestor
(
response
.
collection
)
;
if
(
!
requestor
)
{
this
.
_log
.
warn
(
"
repairResponse
for
unknown
collection
"
response
)
;
break
;
}
if
(
!
requestor
.
continueRepairs
(
response
)
)
{
this
.
_log
.
warn
(
"
repairResponse
couldn
'
t
continue
the
repair
"
response
)
;
}
break
;
}
case
"
repairRequest
"
:
{
let
request
=
args
[
0
]
;
let
responder
=
getRepairResponder
(
request
.
collection
)
;
if
(
!
responder
)
{
this
.
_log
.
warn
(
"
repairRequest
for
unknown
collection
"
request
)
;
break
;
}
try
{
if
(
Async
.
promiseSpinningly
(
responder
.
repair
(
request
rawCommand
)
)
)
{
shouldRemoveCommand
=
false
;
}
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
error
(
"
Failed
to
handle
a
repair
request
"
ex
)
;
}
break
;
}
default
:
this
.
_log
.
warn
(
"
Received
an
unknown
command
:
"
+
command
)
;
break
;
}
if
(
shouldRemoveCommand
)
{
this
.
removeLocalCommand
(
rawCommand
)
;
didRemoveCommand
=
true
;
}
}
if
(
didRemoveCommand
)
{
this
.
_tracker
.
addChangedID
(
this
.
localID
)
;
}
if
(
URIsToDisplay
.
length
)
{
this
.
_handleDisplayURIs
(
URIsToDisplay
)
;
}
return
true
;
}
)
(
)
;
}
sendCommand
(
command
args
clientId
=
null
telemetryExtra
=
{
}
)
{
let
commandData
=
this
.
_commands
[
command
]
;
if
(
!
commandData
)
{
this
.
_log
.
error
(
"
Unknown
command
to
send
:
"
+
command
)
;
return
;
}
else
if
(
!
args
|
|
args
.
length
!
=
commandData
.
args
)
{
this
.
_log
.
error
(
"
Expected
"
+
commandData
.
args
+
"
args
for
'
"
+
command
+
"
'
but
got
"
+
args
)
;
return
;
}
telemetryExtra
=
Object
.
assign
(
{
}
telemetryExtra
)
;
if
(
!
telemetryExtra
.
flowID
)
{
telemetryExtra
.
flowID
=
Utils
.
makeGUID
(
)
;
}
if
(
clientId
)
{
this
.
_sendCommandToClient
(
command
args
clientId
telemetryExtra
)
;
}
else
{
for
(
let
[
id
record
]
of
Object
.
entries
(
this
.
_store
.
_remoteClients
)
)
{
if
(
!
record
.
stale
)
{
this
.
_sendCommandToClient
(
command
args
id
telemetryExtra
)
;
}
}
}
}
sendURIToClientForDisplay
:
function
sendURIToClientForDisplay
(
uri
clientId
title
)
{
this
.
_log
.
info
(
"
Sending
URI
to
client
:
"
+
uri
+
"
-
>
"
+
clientId
+
"
(
"
+
title
+
"
)
"
)
;
this
.
sendCommand
(
"
displayURI
"
[
uri
this
.
localID
title
]
clientId
)
;
this
.
_tracker
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
_handleDisplayURIs
:
function
_handleDisplayURIs
(
uris
)
{
Svc
.
Obs
.
notify
(
"
weave
:
engine
:
clients
:
display
-
uris
"
uris
)
;
}
_removeRemoteClient
(
id
)
{
delete
this
.
_store
.
_remoteClients
[
id
]
;
this
.
_tracker
.
removeChangedID
(
id
)
;
this
.
_removeClientCommands
(
id
)
;
this
.
_modified
.
delete
(
id
)
;
}
}
;
function
ClientStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
ClientStore
.
prototype
=
{
__proto__
:
Store
.
prototype
_remoteClients
:
{
}
create
(
record
)
{
this
.
update
(
record
)
;
}
update
:
function
update
(
record
)
{
if
(
record
.
id
=
=
this
.
engine
.
localID
)
{
this
.
engine
.
localCommands
=
record
.
commands
;
}
else
{
this
.
_remoteClients
[
record
.
id
]
=
record
.
cleartext
;
}
}
createRecord
:
function
createRecord
(
id
collection
)
{
let
record
=
new
ClientsRec
(
collection
id
)
;
const
commandsChanges
=
this
.
engine
.
_currentlySyncingCommands
?
this
.
engine
.
_currentlySyncingCommands
[
id
]
:
[
]
;
if
(
id
=
=
this
.
engine
.
localID
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
this
.
engine
.
fxAccounts
.
getDeviceId
(
)
.
then
(
id
=
>
cb
(
null
id
)
cb
)
;
try
{
record
.
fxaDeviceId
=
cb
.
wait
(
)
;
}
catch
(
error
)
{
this
.
_log
.
warn
(
"
failed
to
get
fxa
device
id
"
error
)
;
}
record
.
name
=
this
.
engine
.
localName
;
record
.
type
=
this
.
engine
.
localType
;
record
.
version
=
Services
.
appinfo
.
version
;
record
.
protocols
=
SUPPORTED_PROTOCOL_VERSIONS
;
if
(
commandsChanges
&
&
commandsChanges
.
length
&
&
this
.
engine
.
localCommands
&
&
this
.
engine
.
localCommands
.
length
)
{
record
.
commands
=
this
.
engine
.
localCommands
.
filter
(
command
=
>
!
hasDupeCommand
(
commandsChanges
command
)
)
;
}
record
.
os
=
Services
.
appinfo
.
OS
;
record
.
appPackage
=
Services
.
appinfo
.
ID
;
record
.
application
=
this
.
engine
.
brandName
}
else
{
record
.
cleartext
=
Object
.
assign
(
{
}
this
.
_remoteClients
[
id
]
)
;
delete
record
.
cleartext
.
serverLastModified
;
if
(
commandsChanges
&
&
commandsChanges
.
length
)
{
const
recordCommands
=
record
.
cleartext
.
commands
|
|
[
]
;
const
newCommands
=
commandsChanges
.
filter
(
command
=
>
!
hasDupeCommand
(
recordCommands
command
)
)
;
record
.
cleartext
.
commands
=
recordCommands
.
concat
(
newCommands
)
;
}
if
(
record
.
cleartext
.
stale
)
{
this
.
_log
.
error
(
Preparing
to
upload
record
{
id
}
that
we
consider
stale
)
;
delete
record
.
cleartext
.
stale
;
}
}
return
record
;
}
itemExists
(
id
)
{
return
id
in
this
.
getAllIDs
(
)
;
}
getAllIDs
:
function
getAllIDs
(
)
{
let
ids
=
{
}
;
ids
[
this
.
engine
.
localID
]
=
true
;
for
(
let
id
in
this
.
_remoteClients
)
ids
[
id
]
=
true
;
return
ids
;
}
wipe
:
function
wipe
(
)
{
this
.
_remoteClients
=
{
}
;
}
}
;
function
ClientsTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
start
-
tracking
"
this
)
;
Svc
.
Obs
.
add
(
"
weave
:
engine
:
stop
-
tracking
"
this
)
;
}
ClientsTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
_enabled
:
false
observe
:
function
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
weave
:
engine
:
start
-
tracking
"
:
if
(
!
this
.
_enabled
)
{
Svc
.
Prefs
.
observe
(
"
client
.
name
"
this
)
;
this
.
_enabled
=
true
;
}
break
;
case
"
weave
:
engine
:
stop
-
tracking
"
:
if
(
this
.
_enabled
)
{
Svc
.
Prefs
.
ignore
(
"
client
.
name
"
this
)
;
this
.
_enabled
=
false
;
}
break
;
case
"
nsPref
:
changed
"
:
this
.
_log
.
debug
(
"
client
.
name
preference
changed
"
)
;
this
.
addChangedID
(
Svc
.
Prefs
.
get
(
"
client
.
GUID
"
)
)
;
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
break
;
}
}
}
;
