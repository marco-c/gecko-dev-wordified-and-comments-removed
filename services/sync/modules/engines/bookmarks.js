var
EXPORTED_SYMBOLS
=
[
"
BookmarksEngine
"
"
PlacesItem
"
"
Bookmark
"
"
BookmarkFolder
"
"
BookmarkQuery
"
"
Livemark
"
"
BookmarkSeparator
"
"
BufferedBookmarksEngine
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
engines
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
SyncedBookmarksMirror
:
"
resource
:
/
/
gre
/
modules
/
SyncedBookmarksMirror
.
jsm
"
BookmarkValidator
:
"
resource
:
/
/
services
-
sync
/
bookmark_validator
.
js
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
PlacesBackups
:
"
resource
:
/
/
gre
/
modules
/
PlacesBackups
.
jsm
"
PlacesDBUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesDBUtils
.
jsm
"
PlacesSyncUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
PlacesUtils
:
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
Resource
:
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PlacesBundle
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
places
/
locale
/
places
.
properties
"
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
ANNOS_TO_TRACK
"
(
)
=
>
[
PlacesUtils
.
LMANNO_FEEDURI
PlacesUtils
.
LMANNO_SITEURI
]
)
;
const
PLACES_MAINTENANCE_INTERVAL_SECONDS
=
4
*
60
*
60
;
const
FOLDER_SORTINDEX
=
1000000
;
const
FORBIDDEN_INCOMING_IDS
=
[
"
pinned
"
"
places
"
"
readinglist
"
]
;
const
FORBIDDEN_INCOMING_PARENT_IDS
=
[
"
pinned
"
"
readinglist
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
IGNORED_SOURCES
"
(
)
=
>
[
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC
PlacesUtils
.
bookmarks
.
SOURCES
.
IMPORT
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE
PlacesUtils
.
bookmarks
.
SOURCES
.
RESTORE_ON_STARTUP
PlacesUtils
.
bookmarks
.
SOURCES
.
SYNC_REPARENT_REMOVED_FOLDER_CHILDREN
]
)
;
function
isSyncedRootNode
(
node
)
{
return
node
.
root
=
=
"
bookmarksMenuFolder
"
|
|
node
.
root
=
=
"
unfiledBookmarksFolder
"
|
|
node
.
root
=
=
"
toolbarFolder
"
|
|
node
.
root
=
=
"
mobileFolder
"
;
}
function
getTypeObject
(
type
)
{
switch
(
type
)
{
case
"
bookmark
"
:
return
Bookmark
;
case
"
query
"
:
return
BookmarkQuery
;
case
"
folder
"
:
return
BookmarkFolder
;
case
"
livemark
"
:
return
Livemark
;
case
"
separator
"
:
return
BookmarkSeparator
;
case
"
item
"
:
return
PlacesItem
;
}
return
null
;
}
function
PlacesItem
(
collection
id
type
)
{
CryptoWrapper
.
call
(
this
collection
id
)
;
this
.
type
=
type
|
|
"
item
"
;
}
PlacesItem
.
prototype
=
{
async
decrypt
(
keyBundle
)
{
let
clear
=
await
CryptoWrapper
.
prototype
.
decrypt
.
call
(
this
keyBundle
)
;
if
(
!
this
.
deleted
)
this
.
__proto__
=
this
.
getTypeObject
(
this
.
type
)
.
prototype
;
return
clear
;
}
getTypeObject
:
function
PlacesItem_getTypeObject
(
type
)
{
let
recordObj
=
getTypeObject
(
type
)
;
if
(
!
recordObj
)
{
throw
new
Error
(
"
Unknown
places
item
object
type
:
"
+
type
)
;
}
return
recordObj
;
}
__proto__
:
CryptoWrapper
.
prototype
_logName
:
"
Sync
.
Record
.
PlacesItem
"
toSyncBookmark
(
)
{
let
result
=
{
kind
:
this
.
type
recordId
:
this
.
id
parentRecordId
:
this
.
parentid
}
;
let
dateAdded
=
PlacesSyncUtils
.
bookmarks
.
ratchetTimestampBackwards
(
this
.
dateAdded
+
this
.
modified
*
1000
)
;
if
(
dateAdded
>
0
)
{
result
.
dateAdded
=
dateAdded
;
}
return
result
;
}
fromSyncBookmark
(
item
)
{
this
.
parentid
=
item
.
parentRecordId
;
this
.
parentName
=
item
.
parentTitle
;
if
(
item
.
dateAdded
)
{
this
.
dateAdded
=
item
.
dateAdded
;
}
}
}
;
Utils
.
deferGetSet
(
PlacesItem
"
cleartext
"
[
"
hasDupe
"
"
parentid
"
"
parentName
"
"
type
"
"
dateAdded
"
]
)
;
function
Bookmark
(
collection
id
type
)
{
PlacesItem
.
call
(
this
collection
id
type
|
|
"
bookmark
"
)
;
}
Bookmark
.
prototype
=
{
__proto__
:
PlacesItem
.
prototype
_logName
:
"
Sync
.
Record
.
Bookmark
"
toSyncBookmark
(
)
{
let
info
=
PlacesItem
.
prototype
.
toSyncBookmark
.
call
(
this
)
;
info
.
title
=
this
.
title
;
info
.
url
=
this
.
bmkUri
;
info
.
description
=
this
.
description
;
info
.
tags
=
this
.
tags
;
info
.
keyword
=
this
.
keyword
;
return
info
;
}
fromSyncBookmark
(
item
)
{
PlacesItem
.
prototype
.
fromSyncBookmark
.
call
(
this
item
)
;
this
.
title
=
item
.
title
;
this
.
bmkUri
=
item
.
url
.
href
;
this
.
description
=
item
.
description
;
this
.
tags
=
item
.
tags
;
this
.
keyword
=
item
.
keyword
;
}
}
;
Utils
.
deferGetSet
(
Bookmark
"
cleartext
"
[
"
title
"
"
bmkUri
"
"
description
"
"
tags
"
"
keyword
"
]
)
;
function
BookmarkQuery
(
collection
id
)
{
Bookmark
.
call
(
this
collection
id
"
query
"
)
;
}
BookmarkQuery
.
prototype
=
{
__proto__
:
Bookmark
.
prototype
_logName
:
"
Sync
.
Record
.
BookmarkQuery
"
toSyncBookmark
(
)
{
let
info
=
Bookmark
.
prototype
.
toSyncBookmark
.
call
(
this
)
;
info
.
folder
=
this
.
folderName
|
|
undefined
;
info
.
query
=
this
.
queryId
;
return
info
;
}
fromSyncBookmark
(
item
)
{
Bookmark
.
prototype
.
fromSyncBookmark
.
call
(
this
item
)
;
this
.
folderName
=
item
.
folder
|
|
undefined
;
this
.
queryId
=
item
.
query
;
}
}
;
Utils
.
deferGetSet
(
BookmarkQuery
"
cleartext
"
[
"
folderName
"
"
queryId
"
]
)
;
function
BookmarkFolder
(
collection
id
type
)
{
PlacesItem
.
call
(
this
collection
id
type
|
|
"
folder
"
)
;
}
BookmarkFolder
.
prototype
=
{
__proto__
:
PlacesItem
.
prototype
_logName
:
"
Sync
.
Record
.
Folder
"
toSyncBookmark
(
)
{
let
info
=
PlacesItem
.
prototype
.
toSyncBookmark
.
call
(
this
)
;
info
.
description
=
this
.
description
;
info
.
title
=
this
.
title
;
return
info
;
}
fromSyncBookmark
(
item
)
{
PlacesItem
.
prototype
.
fromSyncBookmark
.
call
(
this
item
)
;
this
.
title
=
item
.
title
;
this
.
description
=
item
.
description
;
this
.
children
=
item
.
childRecordIds
;
}
}
;
Utils
.
deferGetSet
(
BookmarkFolder
"
cleartext
"
[
"
description
"
"
title
"
"
children
"
]
)
;
function
Livemark
(
collection
id
)
{
BookmarkFolder
.
call
(
this
collection
id
"
livemark
"
)
;
}
Livemark
.
prototype
=
{
__proto__
:
BookmarkFolder
.
prototype
_logName
:
"
Sync
.
Record
.
Livemark
"
toSyncBookmark
(
)
{
let
info
=
BookmarkFolder
.
prototype
.
toSyncBookmark
.
call
(
this
)
;
info
.
feed
=
this
.
feedUri
;
info
.
site
=
this
.
siteUri
;
return
info
;
}
fromSyncBookmark
(
item
)
{
BookmarkFolder
.
prototype
.
fromSyncBookmark
.
call
(
this
item
)
;
this
.
feedUri
=
item
.
feed
.
href
;
if
(
item
.
site
)
{
this
.
siteUri
=
item
.
site
.
href
;
}
}
}
;
Utils
.
deferGetSet
(
Livemark
"
cleartext
"
[
"
siteUri
"
"
feedUri
"
]
)
;
function
BookmarkSeparator
(
collection
id
)
{
PlacesItem
.
call
(
this
collection
id
"
separator
"
)
;
}
BookmarkSeparator
.
prototype
=
{
__proto__
:
PlacesItem
.
prototype
_logName
:
"
Sync
.
Record
.
Separator
"
fromSyncBookmark
(
item
)
{
PlacesItem
.
prototype
.
fromSyncBookmark
.
call
(
this
item
)
;
this
.
pos
=
item
.
index
;
}
}
;
Utils
.
deferGetSet
(
BookmarkSeparator
"
cleartext
"
"
pos
"
)
;
function
BaseBookmarksEngine
(
service
)
{
SyncEngine
.
call
(
this
"
Bookmarks
"
service
)
;
}
BaseBookmarksEngine
.
prototype
=
{
__proto__
:
SyncEngine
.
prototype
_recordObj
:
PlacesItem
_trackerObj
:
BookmarksTracker
version
:
2
_defaultSort
:
"
index
"
syncPriority
:
4
allowSkippedRecord
:
false
_migratedSyncMetadata
:
false
async
_migrateSyncMetadata
(
{
migrateLastSync
=
true
}
=
{
}
)
{
if
(
this
.
_migratedSyncMetadata
)
{
return
;
}
let
shouldWipeRemote
=
await
PlacesSyncUtils
.
bookmarks
.
shouldWipeRemote
(
)
;
if
(
!
shouldWipeRemote
)
{
let
existingSyncID
=
await
super
.
getSyncID
(
)
;
if
(
existingSyncID
)
{
this
.
_log
.
debug
(
"
Migrating
existing
sync
ID
{
existingSyncID
}
from
"
+
"
prefs
"
{
existingSyncID
}
)
;
await
this
.
_ensureCurrentSyncID
(
existingSyncID
)
;
}
if
(
migrateLastSync
)
{
let
existingLastSync
=
await
super
.
getLastSync
(
)
;
if
(
existingLastSync
)
{
this
.
_log
.
debug
(
"
Migrating
existing
last
sync
time
"
+
"
{
existingLastSync
}
from
prefs
"
{
existingLastSync
}
)
;
await
PlacesSyncUtils
.
bookmarks
.
setLastSync
(
existingLastSync
)
;
}
}
}
this
.
_migratedSyncMetadata
=
true
;
}
_ensureCurrentSyncID
(
newSyncID
)
{
return
PlacesSyncUtils
.
bookmarks
.
ensureCurrentSyncId
(
newSyncID
)
;
}
async
ensureCurrentSyncID
(
newSyncID
)
{
let
shouldWipeRemote
=
await
PlacesSyncUtils
.
bookmarks
.
shouldWipeRemote
(
)
;
if
(
!
shouldWipeRemote
)
{
this
.
_log
.
debug
(
"
Checking
if
server
sync
ID
{
newSyncID
}
matches
"
+
"
existing
"
{
newSyncID
}
)
;
await
this
.
_ensureCurrentSyncID
(
newSyncID
)
;
await
super
.
ensureCurrentSyncID
(
newSyncID
)
;
return
newSyncID
;
}
this
.
_log
.
debug
(
"
Ignoring
server
sync
ID
{
newSyncID
}
after
restore
;
"
+
"
wiping
server
and
resetting
sync
ID
"
{
newSyncID
}
)
;
await
this
.
service
.
clientsEngine
.
sendCommand
(
"
wipeEngine
"
[
this
.
name
]
null
{
reason
:
"
bookmark
-
restore
"
}
)
;
let
assignedSyncID
=
await
this
.
resetSyncID
(
)
;
return
assignedSyncID
;
}
async
resetSyncID
(
)
{
await
this
.
_deleteServerCollection
(
)
;
return
this
.
resetLocalSyncID
(
)
;
}
async
resetLocalSyncID
(
)
{
let
newSyncID
=
await
PlacesSyncUtils
.
bookmarks
.
resetSyncId
(
)
;
this
.
_log
.
debug
(
"
Assigned
new
sync
ID
{
newSyncID
}
"
{
newSyncID
}
)
;
await
super
.
ensureCurrentSyncID
(
newSyncID
)
;
return
newSyncID
;
}
async
_sync
(
)
{
try
{
await
super
.
_sync
(
)
;
if
(
this
.
_ranMaintenanceOnLastSync
)
{
this
.
_ranMaintenanceOnLastSync
=
false
;
this
.
service
.
recordTelemetryEvent
(
"
maintenance
"
"
fix
"
"
bookmarks
"
)
;
}
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
|
|
ex
.
status
>
0
)
{
throw
ex
;
}
let
elapsedSinceMaintenance
=
Date
.
now
(
)
/
1000
-
Services
.
prefs
.
getIntPref
(
"
places
.
database
.
lastMaintenance
"
0
)
;
if
(
elapsedSinceMaintenance
>
=
PLACES_MAINTENANCE_INTERVAL_SECONDS
)
{
this
.
_log
.
error
(
"
Bookmark
sync
failed
{
elapsedSinceMaintenance
}
s
"
+
"
elapsed
since
last
run
;
running
Places
maintenance
"
{
elapsedSinceMaintenance
}
)
;
await
PlacesDBUtils
.
maintenanceOnIdle
(
)
;
this
.
_ranMaintenanceOnLastSync
=
true
;
this
.
service
.
recordTelemetryEvent
(
"
maintenance
"
"
run
"
"
bookmarks
"
)
;
}
else
{
this
.
_ranMaintenanceOnLastSync
=
false
;
}
throw
ex
;
}
}
async
_syncFinish
(
)
{
await
SyncEngine
.
prototype
.
_syncFinish
.
call
(
this
)
;
await
PlacesSyncUtils
.
bookmarks
.
ensureMobileQuery
(
)
;
}
async
_createRecord
(
id
)
{
if
(
this
.
_modified
.
isTombstone
(
id
)
)
{
return
this
.
_createTombstone
(
id
)
;
}
let
record
=
await
SyncEngine
.
prototype
.
_createRecord
.
call
(
this
id
)
;
if
(
record
.
deleted
)
{
this
.
_modified
.
setTombstone
(
record
.
id
)
;
}
return
record
;
}
async
pullAllChanges
(
)
{
return
this
.
pullNewChanges
(
)
;
}
async
trackRemainingChanges
(
)
{
let
changes
=
this
.
_modified
.
changes
;
await
PlacesSyncUtils
.
bookmarks
.
pushChanges
(
changes
)
;
}
_deleteId
(
id
)
{
this
.
_noteDeletedId
(
id
)
;
}
async
_resetClient
(
)
{
await
super
.
_resetClient
(
)
;
await
PlacesSyncUtils
.
bookmarks
.
reset
(
)
;
}
_shouldDeleteRemotely
(
incomingItem
)
{
return
FORBIDDEN_INCOMING_IDS
.
includes
(
incomingItem
.
id
)
|
|
FORBIDDEN_INCOMING_PARENT_IDS
.
includes
(
incomingItem
.
parentid
)
;
}
getValidator
(
)
{
return
new
BookmarkValidator
(
)
;
}
}
;
function
BookmarksEngine
(
service
)
{
BaseBookmarksEngine
.
apply
(
this
arguments
)
;
}
BookmarksEngine
.
prototype
=
{
__proto__
:
BaseBookmarksEngine
.
prototype
_storeObj
:
BookmarksStore
async
getSyncID
(
)
{
return
PlacesSyncUtils
.
bookmarks
.
getSyncId
(
)
;
}
async
getLastSync
(
)
{
let
lastSync
=
await
PlacesSyncUtils
.
bookmarks
.
getLastSync
(
)
;
return
lastSync
;
}
async
setLastSync
(
lastSync
)
{
await
PlacesSyncUtils
.
bookmarks
.
setLastSync
(
lastSync
)
;
await
super
.
setLastSync
(
lastSync
)
;
}
emptyChangeset
(
)
{
return
new
BookmarksChangeset
(
)
;
}
async
_buildGUIDMap
(
)
{
let
guidMap
=
{
}
;
let
tree
=
await
PlacesUtils
.
promiseBookmarksTree
(
"
"
)
;
function
*
walkBookmarksRoots
(
tree
)
{
for
(
let
child
of
tree
.
children
)
{
if
(
isSyncedRootNode
(
child
)
)
{
yield
*
Utils
.
walkTree
(
child
tree
)
;
}
}
}
let
maybeYield
=
Async
.
jankYielder
(
)
;
for
(
let
[
node
parent
]
of
walkBookmarksRoots
(
tree
)
)
{
await
maybeYield
(
)
;
let
{
guid
type
:
placeType
}
=
node
;
guid
=
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
let
key
;
switch
(
placeType
)
{
case
PlacesUtils
.
TYPE_X_MOZ_PLACE
:
key
=
"
b
"
+
node
.
uri
+
"
:
"
+
(
node
.
title
|
|
"
"
)
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_CONTAINER
:
key
=
"
f
"
+
(
node
.
title
|
|
"
"
)
;
break
;
case
PlacesUtils
.
TYPE_X_MOZ_PLACE_SEPARATOR
:
key
=
"
s
"
+
node
.
index
;
break
;
default
:
this
.
_log
.
error
(
"
Unknown
place
type
:
'
"
+
placeType
+
"
'
"
)
;
continue
;
}
let
parentName
=
parent
.
title
|
|
"
"
;
if
(
guidMap
[
parentName
]
=
=
null
)
guidMap
[
parentName
]
=
{
}
;
let
entry
=
{
guid
hasDupe
:
guidMap
[
parentName
]
[
key
]
!
=
null
}
;
guidMap
[
parentName
]
[
key
]
=
entry
;
this
.
_log
.
trace
(
"
Mapped
:
"
+
[
parentName
key
entry
entry
.
hasDupe
]
)
;
}
return
guidMap
;
}
async
_mapDupe
(
item
)
{
let
key
;
switch
(
item
.
type
)
{
case
"
query
"
:
case
"
bookmark
"
:
key
=
"
b
"
+
item
.
bmkUri
+
"
:
"
+
(
item
.
title
|
|
"
"
)
;
break
;
case
"
folder
"
:
case
"
livemark
"
:
key
=
"
f
"
+
(
item
.
title
|
|
"
"
)
;
break
;
case
"
separator
"
:
key
=
"
s
"
+
item
.
pos
;
break
;
default
:
return
undefined
;
}
let
guidMap
=
await
this
.
getGuidMap
(
)
;
let
parentName
=
item
.
parentName
|
|
"
"
;
this
.
_log
.
trace
(
"
Finding
mapping
:
"
+
parentName
+
"
"
+
key
)
;
let
parent
=
guidMap
[
parentName
]
;
if
(
!
parent
)
{
this
.
_log
.
trace
(
"
No
parent
=
>
no
dupe
.
"
)
;
return
undefined
;
}
let
dupe
=
parent
[
key
]
;
if
(
dupe
)
{
this
.
_log
.
trace
(
"
Mapped
dupe
"
dupe
)
;
return
dupe
;
}
this
.
_log
.
trace
(
"
No
dupe
found
for
key
"
+
key
+
"
.
"
)
;
return
undefined
;
}
async
_syncStartup
(
)
{
await
this
.
_migrateSyncMetadata
(
)
;
await
SyncEngine
.
prototype
.
_syncStartup
.
call
(
this
)
;
try
{
let
lastSync
=
await
this
.
getLastSync
(
)
;
if
(
!
lastSync
)
{
this
.
_log
.
debug
(
"
Bookmarks
backup
starting
.
"
)
;
await
PlacesBackups
.
create
(
null
true
)
;
this
.
_log
.
debug
(
"
Bookmarks
backup
done
.
"
)
;
}
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
Error
while
backing
up
bookmarks
but
continuing
with
sync
"
ex
)
;
}
this
.
_store
.
_childrenToOrder
=
{
}
;
this
.
_store
.
clearPendingDeletions
(
)
;
}
async
getGuidMap
(
)
{
if
(
this
.
_guidMap
)
{
return
this
.
_guidMap
;
}
try
{
return
this
.
_guidMap
=
await
this
.
_buildGUIDMap
(
)
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
warn
(
"
Error
while
building
GUID
map
skipping
all
other
incoming
items
"
ex
)
;
throw
{
code
:
SyncEngine
.
prototype
.
eEngineAbortApplyIncoming
cause
:
ex
}
;
}
}
async
_deletePending
(
)
{
let
newlyModified
=
await
this
.
_store
.
deletePending
(
)
;
if
(
newlyModified
)
{
this
.
_log
.
debug
(
"
Deleted
pending
items
"
newlyModified
)
;
this
.
_modified
.
insert
(
newlyModified
)
;
}
}
async
_shouldReviveRemotelyDeletedRecord
(
item
)
{
let
modifiedTimestamp
=
this
.
_modified
.
getModifiedTimestamp
(
item
.
id
)
;
if
(
!
modifiedTimestamp
)
{
this
.
_log
.
error
(
"
_shouldReviveRemotelyDeletedRecord
called
on
unmodified
item
:
"
+
item
.
id
)
;
return
false
;
}
let
newChanges
=
await
PlacesSyncUtils
.
bookmarks
.
touch
(
item
.
id
)
;
if
(
newChanges
)
{
this
.
_modified
.
insert
(
newChanges
)
;
return
true
;
}
return
false
;
}
async
_processIncoming
(
newitems
)
{
try
{
await
SyncEngine
.
prototype
.
_processIncoming
.
call
(
this
newitems
)
;
}
finally
{
await
this
.
_postProcessIncoming
(
)
;
}
}
async
_postProcessIncoming
(
)
{
await
this
.
_deletePending
(
)
;
await
this
.
_orderChildren
(
)
;
let
changes
=
this
.
_modified
.
changes
;
await
PlacesSyncUtils
.
bookmarks
.
markChangesAsSyncing
(
changes
)
;
}
async
_orderChildren
(
)
{
await
this
.
_store
.
_orderChildren
(
)
;
this
.
_store
.
_childrenToOrder
=
{
}
;
}
async
_syncCleanup
(
)
{
await
SyncEngine
.
prototype
.
_syncCleanup
.
call
(
this
)
;
delete
this
.
_guidMap
;
}
async
_createRecord
(
id
)
{
let
record
=
await
super
.
_createRecord
(
id
)
;
if
(
record
.
deleted
)
{
return
record
;
}
let
entry
=
await
this
.
_mapDupe
(
record
)
;
if
(
entry
!
=
null
&
&
entry
.
hasDupe
)
{
record
.
hasDupe
=
true
;
}
return
record
;
}
async
_findDupe
(
item
)
{
this
.
_log
.
trace
(
"
Finding
dupe
for
"
+
item
.
id
+
"
(
already
duped
:
"
+
item
.
hasDupe
+
"
)
.
"
)
;
if
(
item
.
hasDupe
)
{
this
.
_log
.
trace
(
item
.
id
+
"
already
a
dupe
:
not
finding
one
.
"
)
;
return
null
;
}
let
mapped
=
await
this
.
_mapDupe
(
item
)
;
this
.
_log
.
debug
(
item
.
id
+
"
mapped
to
"
mapped
)
;
return
mapped
?
mapped
.
guid
:
null
;
}
async
_switchItemToDupe
(
localDupeGUID
incomingItem
)
{
let
newChanges
=
await
PlacesSyncUtils
.
bookmarks
.
dedupe
(
localDupeGUID
incomingItem
.
id
incomingItem
.
parentid
)
;
this
.
_modified
.
insert
(
newChanges
)
;
}
beforeRecordDiscard
(
localRecord
remoteRecord
remoteIsNewer
)
{
if
(
localRecord
.
type
!
=
"
folder
"
|
|
remoteRecord
.
type
!
=
"
folder
"
)
{
return
;
}
let
newRecord
=
remoteIsNewer
?
remoteRecord
:
localRecord
;
let
newChildren
=
new
Set
(
newRecord
.
children
)
;
let
oldChildren
=
(
remoteIsNewer
?
localRecord
:
remoteRecord
)
.
children
;
let
missingChildren
=
oldChildren
?
oldChildren
.
filter
(
child
=
>
!
newChildren
.
has
(
child
)
)
:
[
]
;
let
order
=
newRecord
.
children
?
[
.
.
.
newRecord
.
children
.
.
.
missingChildren
]
:
missingChildren
;
this
.
_log
.
debug
(
"
Recording
children
of
"
+
localRecord
.
id
order
)
;
this
.
_store
.
_childrenToOrder
[
localRecord
.
id
]
=
order
;
}
}
;
function
BufferedBookmarksEngine
(
)
{
BaseBookmarksEngine
.
apply
(
this
arguments
)
;
}
BufferedBookmarksEngine
.
prototype
=
{
__proto__
:
BaseBookmarksEngine
.
prototype
_storeObj
:
BufferedBookmarksStore
overrideTelemetryName
:
"
bookmarks
-
buffered
"
_defaultSort
:
"
oldest
"
async
_syncStartup
(
)
{
await
this
.
_migrateSyncMetadata
(
{
migrateLastSync
:
false
}
)
;
await
super
.
_syncStartup
(
)
;
}
async
_ensureCurrentSyncID
(
newSyncID
)
{
await
super
.
_ensureCurrentSyncID
(
newSyncID
)
;
let
buf
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
await
buf
.
ensureCurrentSyncId
(
newSyncID
)
;
}
async
getSyncID
(
)
{
return
PlacesSyncUtils
.
bookmarks
.
getSyncId
(
)
;
}
async
resetLocalSyncID
(
)
{
let
newSyncID
=
await
super
.
resetLocalSyncID
(
)
;
let
buf
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
await
buf
.
ensureCurrentSyncId
(
newSyncID
)
;
return
newSyncID
;
}
async
getLastSync
(
)
{
let
mirror
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
return
mirror
.
getCollectionHighWaterMark
(
)
;
}
async
setLastSync
(
lastSync
)
{
let
mirror
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
await
mirror
.
setCollectionLastModified
(
lastSync
)
;
await
PlacesSyncUtils
.
bookmarks
.
setLastSync
(
lastSync
)
;
await
super
.
setLastSync
(
lastSync
)
;
}
emptyChangeset
(
)
{
return
new
BufferedBookmarksChangeset
(
)
;
}
async
_processIncoming
(
newitems
)
{
await
super
.
_processIncoming
(
newitems
)
;
let
buf
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
let
recordsToUpload
=
await
buf
.
apply
(
{
remoteTimeSeconds
:
Resource
.
serverTime
weakUpload
:
[
.
.
.
this
.
_needWeakUpload
.
keys
(
)
]
}
)
;
this
.
_needWeakUpload
.
clear
(
)
;
this
.
_modified
.
replace
(
recordsToUpload
)
;
}
async
_reconcile
(
item
)
{
return
true
;
}
async
_createRecord
(
id
)
{
let
record
=
await
this
.
_doCreateRecord
(
id
)
;
if
(
!
record
.
deleted
)
{
record
.
hasDupe
=
true
;
}
return
record
;
}
async
_doCreateRecord
(
id
)
{
if
(
this
.
_needWeakUpload
.
has
(
id
)
)
{
return
this
.
_store
.
createRecord
(
id
this
.
name
)
;
}
let
change
=
this
.
_modified
.
changes
[
id
]
;
if
(
!
change
)
{
this
.
_log
.
error
(
"
Creating
record
for
item
{
id
}
not
in
strong
"
+
"
changeset
"
{
id
}
)
;
throw
new
TypeError
(
"
Can
'
t
create
record
for
unchanged
item
"
)
;
}
let
record
=
this
.
_recordFromCleartext
(
id
change
.
cleartext
)
;
record
.
sortindex
=
await
this
.
_store
.
_calculateIndex
(
record
)
;
return
record
;
}
_recordFromCleartext
(
id
cleartext
)
{
let
recordObj
=
getTypeObject
(
cleartext
.
type
)
;
if
(
!
recordObj
)
{
this
.
_log
.
warn
(
"
Creating
record
for
item
{
id
}
with
unknown
type
{
type
}
"
{
id
type
:
cleartext
.
type
}
)
;
recordObj
=
PlacesItem
;
}
let
record
=
new
recordObj
(
this
.
name
id
)
;
record
.
cleartext
=
cleartext
;
return
record
;
}
async
pullChanges
(
)
{
return
{
}
;
}
async
_onRecordsWritten
(
succeeded
failed
serverModifiedTime
)
{
let
records
=
[
]
;
for
(
let
id
of
succeeded
)
{
let
change
=
this
.
_modified
.
changes
[
id
]
;
if
(
!
change
)
{
this
.
_log
.
info
(
"
Uploaded
record
not
in
strong
changeset
"
id
)
;
continue
;
}
if
(
!
change
.
synced
)
{
this
.
_log
.
info
(
"
Record
in
strong
changeset
not
uploaded
"
id
)
;
continue
;
}
let
cleartext
=
change
.
cleartext
;
if
(
!
cleartext
)
{
this
.
_log
.
error
(
"
Missing
Sync
record
cleartext
for
{
id
}
in
{
change
}
"
{
id
change
}
)
;
throw
new
TypeError
(
"
Missing
cleartext
for
uploaded
Sync
record
"
)
;
}
let
record
=
this
.
_recordFromCleartext
(
id
cleartext
)
;
record
.
modified
=
serverModifiedTime
;
records
.
push
(
record
)
;
}
let
buf
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
await
buf
.
store
(
records
{
needsMerge
:
false
}
)
;
}
async
_resetClient
(
)
{
await
super
.
_resetClient
(
)
;
let
buf
=
await
this
.
_store
.
ensureOpenMirror
(
)
;
await
buf
.
reset
(
)
;
}
async
finalize
(
)
{
await
super
.
finalize
(
)
;
await
this
.
_store
.
finalize
(
)
;
}
}
;
function
BaseBookmarksStore
(
name
engine
)
{
Store
.
call
(
this
name
engine
)
;
}
BaseBookmarksStore
.
prototype
=
{
__proto__
:
Store
.
prototype
async
createRecord
(
id
collection
)
{
let
item
=
await
PlacesSyncUtils
.
bookmarks
.
fetch
(
id
)
;
if
(
!
item
)
{
let
record
=
new
PlacesItem
(
collection
id
)
;
record
.
deleted
=
true
;
return
record
;
}
let
recordObj
=
getTypeObject
(
item
.
kind
)
;
if
(
!
recordObj
)
{
this
.
_log
.
warn
(
"
Unknown
item
type
cannot
serialize
:
"
+
item
.
kind
)
;
recordObj
=
PlacesItem
;
}
let
record
=
new
recordObj
(
collection
id
)
;
record
.
fromSyncBookmark
(
item
)
;
record
.
sortindex
=
await
this
.
_calculateIndex
(
record
)
;
return
record
;
}
async
_calculateIndex
(
record
)
{
if
(
record
.
type
=
=
"
folder
"
)
return
FOLDER_SORTINDEX
;
let
index
=
0
;
if
(
record
.
parentid
=
=
"
toolbar
"
)
index
+
=
150
;
if
(
record
.
bmkUri
!
=
null
)
{
let
frecency
=
await
PlacesSyncUtils
.
history
.
fetchURLFrecency
(
record
.
bmkUri
)
;
if
(
frecency
!
=
-
1
)
index
+
=
frecency
;
}
return
index
;
}
async
wipe
(
)
{
await
PlacesBackups
.
create
(
null
true
)
;
await
PlacesSyncUtils
.
bookmarks
.
wipe
(
)
;
}
}
;
function
BookmarksStore
(
)
{
BaseBookmarksStore
.
apply
(
this
arguments
)
;
this
.
_itemsToDelete
=
new
Set
(
)
;
}
BookmarksStore
.
prototype
=
{
__proto__
:
BaseBookmarksStore
.
prototype
async
itemExists
(
id
)
{
return
(
await
this
.
idForGUID
(
id
)
)
>
0
;
}
async
applyIncoming
(
record
)
{
this
.
_log
.
debug
(
"
Applying
record
"
+
record
.
id
)
;
let
isSpecial
=
PlacesSyncUtils
.
bookmarks
.
ROOTS
.
includes
(
record
.
id
)
;
if
(
record
.
deleted
)
{
if
(
isSpecial
)
{
this
.
_log
.
warn
(
"
Ignoring
deletion
for
special
record
"
+
record
.
id
)
;
return
;
}
await
Store
.
prototype
.
applyIncoming
.
call
(
this
record
)
;
return
;
}
if
(
isSpecial
&
&
record
.
children
)
{
this
.
_log
.
debug
(
"
Processing
special
node
:
"
+
record
.
id
)
;
this
.
_childrenToOrder
[
record
.
id
]
=
record
.
children
;
return
;
}
if
(
record
.
type
=
=
"
query
"
&
&
!
record
.
bmkUri
)
{
this
.
_log
.
warn
(
"
Skipping
malformed
query
bookmark
:
"
+
record
.
id
)
;
return
;
}
let
parentGUID
=
record
.
parentid
;
if
(
!
parentGUID
)
{
throw
new
Error
(
Record
{
record
.
id
}
has
invalid
parentid
:
{
parentGUID
}
)
;
}
this
.
_log
.
debug
(
"
Remote
parent
is
"
+
parentGUID
)
;
await
Store
.
prototype
.
applyIncoming
.
call
(
this
record
)
;
if
(
record
.
type
=
=
"
folder
"
&
&
record
.
children
)
{
this
.
_childrenToOrder
[
record
.
id
]
=
record
.
children
;
}
}
async
create
(
record
)
{
let
info
=
record
.
toSyncBookmark
(
)
;
let
item
=
await
PlacesSyncUtils
.
bookmarks
.
insert
(
info
)
;
if
(
item
)
{
this
.
_log
.
trace
(
Created
{
item
.
kind
}
{
item
.
recordId
}
under
{
item
.
parentRecordId
}
item
)
;
if
(
item
.
dateAdded
!
=
record
.
dateAdded
)
{
this
.
engine
.
addForWeakUpload
(
item
.
recordId
)
;
}
}
}
async
remove
(
record
)
{
this
.
_log
.
trace
(
Buffering
removal
of
item
"
{
record
.
id
}
"
.
)
;
this
.
_itemsToDelete
.
add
(
record
.
id
)
;
}
async
update
(
record
)
{
let
info
=
record
.
toSyncBookmark
(
)
;
let
item
=
await
PlacesSyncUtils
.
bookmarks
.
update
(
info
)
;
if
(
item
)
{
this
.
_log
.
trace
(
Updated
{
item
.
kind
}
{
item
.
recordId
}
under
{
item
.
parentRecordId
}
item
)
;
if
(
item
.
dateAdded
!
=
record
.
dateAdded
)
{
this
.
engine
.
addForWeakUpload
(
item
.
recordId
)
;
}
}
}
async
_orderChildren
(
)
{
for
(
let
id
in
this
.
_childrenToOrder
)
{
let
children
=
this
.
_childrenToOrder
[
id
]
;
try
{
await
PlacesSyncUtils
.
bookmarks
.
order
(
id
children
)
;
}
catch
(
ex
)
{
this
.
_log
.
debug
(
Could
not
order
children
for
{
id
}
ex
)
;
}
}
}
async
deletePending
(
)
{
let
guidsToUpdate
=
await
PlacesSyncUtils
.
bookmarks
.
remove
(
[
.
.
.
this
.
_itemsToDelete
]
)
;
this
.
clearPendingDeletions
(
)
;
return
guidsToUpdate
;
}
clearPendingDeletions
(
)
{
this
.
_itemsToDelete
.
clear
(
)
;
}
async
GUIDForId
(
id
)
{
let
guid
=
await
PlacesUtils
.
promiseItemGuid
(
id
)
;
return
PlacesSyncUtils
.
bookmarks
.
guidToRecordId
(
guid
)
;
}
async
idForGUID
(
guid
)
{
guid
=
PlacesSyncUtils
.
bookmarks
.
recordIdToGuid
(
guid
.
toString
(
)
)
;
try
{
return
await
PlacesUtils
.
promiseItemId
(
guid
)
;
}
catch
(
ex
)
{
return
-
1
;
}
}
async
wipe
(
)
{
this
.
clearPendingDeletions
(
)
;
await
super
.
wipe
(
)
;
}
}
;
function
BufferedBookmarksStore
(
)
{
BaseBookmarksStore
.
apply
(
this
arguments
)
;
}
BufferedBookmarksStore
.
prototype
=
{
__proto__
:
BaseBookmarksStore
.
prototype
_openMirrorPromise
:
null
_batchChunkSize
:
500
ensureOpenMirror
(
)
{
if
(
!
this
.
_openMirrorPromise
)
{
this
.
_openMirrorPromise
=
this
.
_openMirror
(
)
.
catch
(
err
=
>
{
this
.
_openMirrorPromise
=
null
;
throw
err
;
}
)
;
}
return
this
.
_openMirrorPromise
;
}
async
_openMirror
(
)
{
let
mirrorPath
=
OS
.
Path
.
join
(
OS
.
Constants
.
Path
.
profileDir
"
weave
"
"
bookmarks
.
sqlite
"
)
;
await
OS
.
File
.
makeDir
(
OS
.
Path
.
dirname
(
mirrorPath
)
{
from
:
OS
.
Constants
.
Path
.
profileDir
}
)
;
return
SyncedBookmarksMirror
.
open
(
{
path
:
mirrorPath
recordTelemetryEvent
:
(
object
method
value
extra
)
=
>
{
this
.
engine
.
service
.
recordTelemetryEvent
(
object
method
value
extra
)
;
}
}
)
;
}
async
applyIncomingBatch
(
records
)
{
let
buf
=
await
this
.
ensureOpenMirror
(
)
;
for
(
let
chunk
of
PlacesSyncUtils
.
chunkArray
(
records
this
.
_batchChunkSize
)
)
{
await
buf
.
store
(
chunk
)
;
}
return
[
]
;
}
async
applyIncoming
(
record
)
{
let
buf
=
await
this
.
ensureOpenMirror
(
)
;
await
buf
.
store
(
[
record
]
)
;
}
async
finalize
(
)
{
if
(
!
this
.
_openMirrorPromise
)
{
return
;
}
let
buf
=
await
this
.
_openMirrorPromise
;
await
buf
.
finalize
(
)
;
}
}
;
function
BookmarksTracker
(
name
engine
)
{
Tracker
.
call
(
this
name
engine
)
;
this
.
_batchDepth
=
0
;
this
.
_batchSawScoreIncrement
=
false
;
}
BookmarksTracker
.
prototype
=
{
__proto__
:
Tracker
.
prototype
get
ignoreAll
(
)
{
return
false
;
}
set
ignoreAll
(
value
)
{
}
persistChangedIDs
:
false
onStart
(
)
{
PlacesUtils
.
bookmarks
.
addObserver
(
this
true
)
;
Svc
.
Obs
.
add
(
"
bookmarks
-
restore
-
begin
"
this
)
;
Svc
.
Obs
.
add
(
"
bookmarks
-
restore
-
success
"
this
)
;
Svc
.
Obs
.
add
(
"
bookmarks
-
restore
-
failed
"
this
)
;
}
onStop
(
)
{
PlacesUtils
.
bookmarks
.
removeObserver
(
this
)
;
Svc
.
Obs
.
remove
(
"
bookmarks
-
restore
-
begin
"
this
)
;
Svc
.
Obs
.
remove
(
"
bookmarks
-
restore
-
success
"
this
)
;
Svc
.
Obs
.
remove
(
"
bookmarks
-
restore
-
failed
"
this
)
;
}
addChangedID
(
id
when
)
{
throw
new
Error
(
"
Don
'
t
add
IDs
to
the
bookmarks
tracker
"
)
;
}
removeChangedID
(
id
)
{
throw
new
Error
(
"
Don
'
t
remove
IDs
from
the
bookmarks
tracker
"
)
;
}
clearChangedIDs
(
)
{
}
async
getChangedIDs
(
)
{
return
PlacesSyncUtils
.
bookmarks
.
pullChanges
(
)
;
}
set
changedIDs
(
obj
)
{
throw
new
Error
(
"
Don
'
t
set
initial
changed
bookmark
IDs
"
)
;
}
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
bookmarks
-
restore
-
begin
"
:
this
.
_log
.
debug
(
"
Ignoring
changes
from
importing
bookmarks
.
"
)
;
break
;
case
"
bookmarks
-
restore
-
success
"
:
this
.
_log
.
debug
(
"
Tracking
all
items
on
successful
import
.
"
)
;
if
(
data
=
=
"
json
"
)
{
this
.
_log
.
debug
(
"
Restore
succeeded
:
wiping
server
and
other
clients
.
"
)
;
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
else
{
this
.
_log
.
debug
(
"
Import
succeeded
.
"
)
;
}
break
;
case
"
bookmarks
-
restore
-
failed
"
:
this
.
_log
.
debug
(
"
Tracking
all
items
on
failed
import
.
"
)
;
break
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsINavBookmarkObserver
Ci
.
nsINavBookmarkObserver_MOZILLA_1_9_1_ADDITIONS
Ci
.
nsISupportsWeakReference
]
)
_upScore
:
function
BMT__upScore
(
)
{
if
(
this
.
_batchDepth
=
=
0
)
{
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
}
else
{
this
.
_batchSawScoreIncrement
=
true
;
}
}
onItemAdded
:
function
BMT_onItemAdded
(
itemId
folder
index
itemType
uri
title
dateAdded
guid
parentGuid
source
)
{
if
(
IGNORED_SOURCES
.
includes
(
source
)
)
{
return
;
}
this
.
_log
.
trace
(
"
onItemAdded
:
"
+
itemId
)
;
this
.
_upScore
(
)
;
}
onItemRemoved
(
itemId
parentId
index
type
uri
guid
parentGuid
source
)
{
if
(
IGNORED_SOURCES
.
includes
(
source
)
)
{
return
;
}
this
.
_log
.
trace
(
"
onItemRemoved
:
"
+
itemId
)
;
this
.
_upScore
(
)
;
}
onItemChanged
:
function
BMT_onItemChanged
(
itemId
property
isAnno
value
lastModified
itemType
parentId
guid
parentGuid
oldValue
source
)
{
if
(
IGNORED_SOURCES
.
includes
(
source
)
)
{
return
;
}
if
(
isAnno
&
&
(
!
ANNOS_TO_TRACK
.
includes
(
property
)
)
)
return
;
if
(
property
=
=
"
favicon
"
)
return
;
this
.
_log
.
trace
(
"
onItemChanged
:
"
+
itemId
+
(
"
"
+
property
+
(
isAnno
?
"
(
anno
)
"
:
"
"
)
)
+
(
value
?
(
"
=
\
"
"
+
value
+
"
\
"
"
)
:
"
"
)
)
;
this
.
_upScore
(
)
;
}
onItemMoved
:
function
BMT_onItemMoved
(
itemId
oldParent
oldIndex
newParent
newIndex
itemType
guid
oldParentGuid
newParentGuid
source
)
{
if
(
IGNORED_SOURCES
.
includes
(
source
)
)
{
return
;
}
this
.
_log
.
trace
(
"
onItemMoved
:
"
+
itemId
)
;
this
.
_upScore
(
)
;
}
onBeginUpdateBatch
(
)
{
+
+
this
.
_batchDepth
;
}
onEndUpdateBatch
(
)
{
if
(
-
-
this
.
_batchDepth
=
=
=
0
&
&
this
.
_batchSawScoreIncrement
)
{
this
.
score
+
=
SCORE_INCREMENT_XLARGE
;
this
.
_batchSawScoreIncrement
=
false
;
}
}
onItemVisited
(
)
{
}
}
;
class
BufferedBookmarksChangeset
extends
Changeset
{
getModifiedTimestamp
(
id
)
{
throw
new
Error
(
"
Don
'
t
use
timestamps
to
resolve
bookmark
conflicts
"
)
;
}
has
(
id
)
{
throw
new
Error
(
"
Don
'
t
use
the
changeset
to
resolve
bookmark
conflicts
"
)
;
}
delete
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
change
.
synced
=
true
;
}
}
ids
(
)
{
let
results
=
new
Set
(
)
;
for
(
let
id
in
this
.
changes
)
{
if
(
!
this
.
changes
[
id
]
.
synced
)
{
results
.
add
(
id
)
;
}
}
return
[
.
.
.
results
]
;
}
}
class
BookmarksChangeset
extends
BufferedBookmarksChangeset
{
getModifiedTimestamp
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
return
change
.
synced
?
Number
.
NaN
:
change
.
modified
;
}
return
Number
.
NaN
;
}
has
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
return
!
change
.
synced
;
}
return
false
;
}
setTombstone
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
change
.
tombstone
=
true
;
}
}
isTombstone
(
id
)
{
let
change
=
this
.
changes
[
id
]
;
if
(
change
)
{
return
change
.
tombstone
;
}
return
false
;
}
}
