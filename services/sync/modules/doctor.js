"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Doctor
"
]
;
const
{
Log
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Log
.
sys
.
mjs
"
)
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
Observers
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
const
{
Service
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
service
.
js
"
)
;
const
{
Resource
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
const
{
Svc
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Doctor
"
)
;
var
Doctor
=
{
async
consult
(
recentlySyncedEngines
)
{
if
(
!
Services
.
telemetry
.
canRecordBase
)
{
log
.
info
(
"
Skipping
consultation
:
telemetry
reporting
is
disabled
"
)
;
return
;
}
let
engineInfos
=
this
.
_getEnginesToValidate
(
recentlySyncedEngines
)
;
await
this
.
_runValidators
(
engineInfos
)
;
}
_getEnginesToValidate
(
recentlySyncedEngines
)
{
let
result
=
{
}
;
for
(
let
e
of
recentlySyncedEngines
)
{
let
prefPrefix
=
engine
.
{
e
.
name
}
.
;
if
(
!
Svc
.
Prefs
.
get
(
prefPrefix
+
"
validation
.
enabled
"
false
)
)
{
log
.
info
(
Skipping
check
of
{
e
.
name
}
-
disabled
via
preferences
)
;
continue
;
}
let
lastValidation
=
Svc
.
Prefs
.
get
(
prefPrefix
+
"
validation
.
lastTime
"
0
)
;
let
validationInterval
=
Svc
.
Prefs
.
get
(
prefPrefix
+
"
validation
.
interval
"
)
;
let
nowSeconds
=
this
.
_now
(
)
;
if
(
nowSeconds
-
lastValidation
<
validationInterval
)
{
log
.
info
(
Skipping
validation
of
{
e
.
name
}
:
too
recent
since
last
validation
attempt
)
;
continue
;
}
Svc
.
Prefs
.
set
(
prefPrefix
+
"
validation
.
lastTime
"
Math
.
floor
(
nowSeconds
)
)
;
let
validationProbability
=
Svc
.
Prefs
.
get
(
prefPrefix
+
"
validation
.
percentageChance
"
0
)
/
100
.
0
;
if
(
validationProbability
<
Math
.
random
(
)
)
{
log
.
info
(
Skipping
validation
of
{
e
.
name
}
:
Probability
threshold
not
met
)
;
continue
;
}
let
maxRecords
=
Svc
.
Prefs
.
get
(
prefPrefix
+
"
validation
.
maxRecords
"
)
;
if
(
!
maxRecords
)
{
log
.
info
(
Skipping
validation
of
{
e
.
name
}
:
No
maxRecords
specified
)
;
continue
;
}
result
[
e
.
name
]
=
{
engine
:
e
maxRecords
}
;
}
return
result
;
}
async
_runValidators
(
engineInfos
)
{
if
(
!
Object
.
keys
(
engineInfos
)
.
length
)
{
log
.
info
(
"
Skipping
validation
:
no
engines
qualify
"
)
;
return
;
}
if
(
Object
.
values
(
engineInfos
)
.
filter
(
i
=
>
i
.
maxRecords
!
=
-
1
)
.
length
)
{
let
countInfo
=
await
this
.
_fetchCollectionCounts
(
)
;
for
(
let
[
engineName
recordCount
]
of
Object
.
entries
(
countInfo
)
)
{
if
(
engineName
in
engineInfos
)
{
engineInfos
[
engineName
]
.
recordCount
=
recordCount
;
}
}
}
for
(
let
[
engineName
{
engine
maxRecords
recordCount
}
]
of
Object
.
entries
(
engineInfos
)
)
{
if
(
maxRecords
>
=
0
&
&
recordCount
>
maxRecords
)
{
log
.
debug
(
Skipping
validation
for
{
engineName
}
because
+
the
number
of
records
(
{
recordCount
}
)
is
greater
+
than
the
maximum
allowed
(
{
maxRecords
}
)
.
)
;
continue
;
}
let
validator
=
engine
.
getValidator
(
)
;
if
(
!
validator
)
{
log
.
warn
(
engine
.
getValidator
returned
null
for
{
engineName
}
but
the
pref
that
controls
validation
is
enabled
.
)
;
continue
;
}
if
(
!
(
await
validator
.
canValidate
(
)
)
)
{
log
.
debug
(
Skipping
validation
for
{
engineName
}
because
validator
.
canValidate
(
)
is
false
)
;
continue
;
}
Services
.
console
.
logStringMessage
(
Sync
is
about
to
run
a
consistency
check
of
{
engine
.
name
}
.
This
may
be
slow
and
+
can
be
controlled
using
the
pref
"
services
.
sync
.
{
engine
.
name
}
.
validation
.
enabled
"
.
\
n
+
If
you
encounter
any
problems
because
of
this
please
file
a
bug
.
)
;
try
{
log
.
info
(
Running
validator
for
{
engine
.
name
}
)
;
let
result
=
await
validator
.
validate
(
engine
)
;
let
{
problems
version
duration
recordCount
}
=
result
;
Observers
.
notify
(
"
weave
:
engine
:
validate
:
finish
"
{
version
checked
:
recordCount
took
:
duration
problems
:
problems
?
problems
.
getSummary
(
true
)
:
null
}
engine
.
name
)
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
log
.
error
(
Failed
to
run
validation
on
{
engine
.
name
}
!
ex
)
;
Observers
.
notify
(
"
weave
:
engine
:
validate
:
error
"
ex
engine
.
name
)
;
}
}
}
async
_fetchCollectionCounts
(
)
{
let
collectionCountsURL
=
Service
.
userBaseURL
+
"
info
/
collection_counts
"
;
try
{
let
infoResp
=
await
Service
.
_fetchInfo
(
collectionCountsURL
)
;
if
(
!
infoResp
.
success
)
{
log
.
error
(
"
Can
'
t
fetch
collection
counts
:
request
to
info
/
collection_counts
responded
with
"
+
infoResp
.
status
)
;
return
{
}
;
}
return
infoResp
.
obj
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
log
.
error
(
"
Caught
error
when
fetching
counts
"
ex
)
;
return
{
}
;
}
}
_now
(
)
{
return
Resource
.
serverTime
;
}
}
;
