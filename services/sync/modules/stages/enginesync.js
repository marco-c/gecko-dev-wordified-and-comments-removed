var
EXPORTED_SYMBOLS
=
[
"
EngineSynchronizer
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Doctor
"
"
resource
:
/
/
services
-
sync
/
doctor
.
js
"
)
;
function
EngineSynchronizer
(
service
)
{
this
.
_log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Synchronizer
"
)
;
this
.
_log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
synchronizer
"
)
;
this
.
service
=
service
;
}
EngineSynchronizer
.
prototype
=
{
async
sync
(
engineNamesToSync
why
)
{
let
fastSync
=
why
&
&
why
=
=
"
sleep
"
;
let
startTime
=
Date
.
now
(
)
;
this
.
service
.
status
.
resetSync
(
)
;
let
reason
=
this
.
service
.
_checkSync
(
)
;
if
(
reason
)
{
if
(
reason
=
=
kSyncNetworkOffline
)
{
this
.
service
.
status
.
sync
=
LOGIN_FAILED_NETWORK_ERROR
;
}
reason
=
"
Can
'
t
sync
:
"
+
reason
;
throw
new
Error
(
reason
)
;
}
if
(
!
this
.
service
.
clusterURL
&
&
!
(
await
this
.
service
.
identity
.
setCluster
(
)
)
)
{
this
.
service
.
status
.
sync
=
NO_SYNC_NODE_FOUND
;
this
.
_log
.
info
(
"
No
cluster
URL
found
.
Cannot
sync
.
"
)
;
return
;
}
let
infoURL
=
this
.
service
.
infoURL
;
let
now
=
Math
.
floor
(
Date
.
now
(
)
/
1000
)
;
let
lastPing
=
Svc
.
Prefs
.
get
(
"
lastPing
"
0
)
;
if
(
now
-
lastPing
>
86400
)
{
infoURL
+
=
"
?
v
=
"
+
WEAVE_VERSION
;
Svc
.
Prefs
.
set
(
"
lastPing
"
now
)
;
}
let
engineManager
=
this
.
service
.
engineManager
;
let
info
=
await
this
.
service
.
_fetchInfo
(
infoURL
)
;
for
(
let
engine
of
[
this
.
service
.
clientsEngine
]
.
concat
(
engineManager
.
getAll
(
)
)
)
{
engine
.
lastModified
=
info
.
obj
[
engine
.
name
]
|
|
0
;
}
if
(
!
(
await
this
.
service
.
_remoteSetup
(
info
!
fastSync
)
)
)
{
throw
new
Error
(
"
Aborting
sync
remote
setup
failed
"
)
;
}
if
(
!
fastSync
)
{
this
.
_log
.
debug
(
"
Refreshing
client
list
.
"
)
;
if
(
!
(
await
this
.
_syncEngine
(
this
.
service
.
clientsEngine
)
)
)
{
this
.
_log
.
warn
(
"
Client
engine
sync
failed
.
Aborting
.
"
)
;
return
;
}
}
let
allowEnginesHint
=
false
;
switch
(
Svc
.
Prefs
.
get
(
"
firstSync
"
)
)
{
case
"
resetClient
"
:
await
this
.
service
.
resetClient
(
engineManager
.
enabledEngineNames
)
;
break
;
case
"
wipeClient
"
:
await
this
.
service
.
wipeClient
(
engineManager
.
enabledEngineNames
)
;
break
;
case
"
wipeRemote
"
:
await
this
.
service
.
wipeRemote
(
engineManager
.
enabledEngineNames
)
;
break
;
default
:
allowEnginesHint
=
true
;
break
;
}
if
(
!
fastSync
&
&
this
.
service
.
clientsEngine
.
localCommands
)
{
try
{
if
(
!
(
await
this
.
service
.
clientsEngine
.
processIncomingCommands
(
)
)
)
{
this
.
service
.
status
.
sync
=
ABORT_SYNC_COMMAND
;
throw
new
Error
(
"
Processed
command
aborted
sync
.
"
)
;
}
if
(
!
(
await
this
.
service
.
_remoteSetup
(
info
)
)
)
{
throw
new
Error
(
"
Remote
setup
failed
after
processing
commands
.
"
)
;
}
}
finally
{
await
this
.
_syncEngine
(
this
.
service
.
clientsEngine
)
;
}
}
try
{
await
this
.
_updateEnabledEngines
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
debug
(
"
Updating
enabled
engines
failed
"
ex
)
;
this
.
service
.
errorHandler
.
checkServerError
(
ex
)
;
throw
ex
;
}
await
this
.
service
.
engineManager
.
switchAlternatives
(
)
;
let
enginesToSync
;
if
(
allowEnginesHint
&
&
engineNamesToSync
)
{
this
.
_log
.
info
(
"
Syncing
specified
engines
"
engineNamesToSync
)
;
enginesToSync
=
engineManager
.
get
(
engineNamesToSync
)
.
filter
(
e
=
>
e
.
enabled
)
;
}
else
{
this
.
_log
.
info
(
"
Syncing
all
enabled
engines
.
"
)
;
enginesToSync
=
engineManager
.
getEnabled
(
)
;
}
try
{
let
enginesToValidate
=
[
]
;
for
(
let
engine
of
enginesToSync
)
{
if
(
!
(
await
this
.
_syncEngine
(
engine
)
)
|
|
this
.
service
.
status
.
enforceBackoff
)
{
this
.
_log
.
info
(
"
Aborting
sync
for
failure
in
"
+
engine
.
name
)
;
break
;
}
enginesToValidate
.
push
(
engine
)
;
}
if
(
!
this
.
service
.
clusterURL
)
{
this
.
_log
.
debug
(
"
Aborting
sync
no
cluster
URL
:
"
+
"
not
uploading
new
meta
/
global
.
"
)
;
return
;
}
let
meta
=
await
this
.
service
.
recordManager
.
get
(
this
.
service
.
metaURL
)
;
if
(
meta
.
isNew
|
|
meta
.
changed
)
{
this
.
_log
.
info
(
"
meta
/
global
changed
locally
:
reuploading
.
"
)
;
try
{
await
this
.
service
.
uploadMetaGlobal
(
meta
)
;
delete
meta
.
isNew
;
delete
meta
.
changed
;
}
catch
(
error
)
{
this
.
_log
.
error
(
"
Unable
to
upload
meta
/
global
.
Leaving
marked
as
new
.
"
)
;
}
}
if
(
!
fastSync
)
{
await
Doctor
.
consult
(
enginesToValidate
)
;
}
if
(
this
.
service
.
status
.
service
!
=
SYNC_FAILED_PARTIAL
)
{
this
.
service
.
status
.
sync
=
SYNC_SUCCEEDED
;
}
if
(
this
.
service
.
status
.
service
=
=
SYNC_FAILED_PARTIAL
|
|
this
.
service
.
status
.
service
=
=
STATUS_OK
)
{
Svc
.
Prefs
.
set
(
"
lastSync
"
new
Date
(
)
.
toString
(
)
)
;
}
}
finally
{
Svc
.
Prefs
.
reset
(
"
firstSync
"
)
;
let
syncTime
=
(
(
Date
.
now
(
)
-
startTime
)
/
1000
)
.
toFixed
(
2
)
;
let
dateStr
=
Utils
.
formatTimestamp
(
new
Date
(
)
)
;
this
.
_log
.
info
(
"
Sync
completed
at
"
+
dateStr
+
"
after
"
+
syncTime
+
"
secs
.
"
)
;
}
}
async
_syncEngine
(
engine
)
{
try
{
await
engine
.
sync
(
)
;
}
catch
(
e
)
{
if
(
e
.
status
=
=
401
)
{
return
false
;
}
if
(
Async
.
isShutdownException
(
e
)
)
{
this
.
_log
.
info
(
{
engine
.
name
}
was
interrupted
by
shutdown
;
no
other
engines
will
sync
)
;
return
false
;
}
}
return
true
;
}
async
_updateEnabledFromMeta
(
meta
numClients
engineManager
=
this
.
service
.
engineManager
)
{
this
.
_log
.
info
(
"
Updating
enabled
engines
:
"
+
numClients
+
"
clients
.
"
)
;
if
(
meta
.
isNew
|
|
!
meta
.
payload
.
engines
)
{
this
.
_log
.
debug
(
"
meta
/
global
isn
'
t
new
or
is
missing
engines
.
Not
updating
enabled
state
.
"
)
;
return
;
}
let
hasEnabledEngines
=
false
;
for
(
let
e
in
meta
.
payload
.
engines
)
{
if
(
e
!
=
"
clients
"
)
{
hasEnabledEngines
=
true
;
break
;
}
}
if
(
(
numClients
<
=
1
)
&
&
!
hasEnabledEngines
)
{
this
.
_log
.
info
(
"
One
client
and
no
enabled
engines
:
not
touching
local
engine
status
.
"
)
;
return
;
}
this
.
service
.
_ignorePrefObserver
=
true
;
let
enabled
=
engineManager
.
enabledEngineNames
;
let
toDecline
=
new
Set
(
)
;
let
toUndecline
=
new
Set
(
)
;
for
(
let
engineName
in
meta
.
payload
.
engines
)
{
if
(
engineName
=
=
"
clients
"
)
{
continue
;
}
let
index
=
enabled
.
indexOf
(
engineName
)
;
if
(
index
!
=
-
1
)
{
enabled
.
splice
(
index
1
)
;
continue
;
}
let
engine
=
engineManager
.
get
(
engineName
)
;
if
(
!
engine
)
{
continue
;
}
let
attemptedEnable
=
false
;
if
(
!
Svc
.
Prefs
.
get
(
"
engineStatusChanged
.
"
+
engine
.
prefName
false
)
)
{
this
.
_log
.
trace
(
"
Engine
"
+
engineName
+
"
was
enabled
.
Marking
as
non
-
declined
.
"
)
;
toUndecline
.
add
(
engineName
)
;
this
.
_log
.
trace
(
engineName
+
"
engine
was
enabled
remotely
.
"
)
;
engine
.
enabled
=
true
;
attemptedEnable
=
true
;
}
if
(
!
engine
.
enabled
)
{
this
.
_log
.
trace
(
"
Wiping
data
for
"
+
engineName
+
"
engine
.
"
)
;
await
engine
.
wipeServer
(
)
;
delete
meta
.
payload
.
engines
[
engineName
]
;
meta
.
changed
=
true
;
if
(
!
attemptedEnable
)
{
this
.
_log
.
trace
(
"
Engine
"
+
engineName
+
"
was
disabled
locally
.
Marking
as
declined
.
"
)
;
toDecline
.
add
(
engineName
)
;
}
}
}
for
(
let
engineName
of
enabled
)
{
let
engine
=
engineManager
.
get
(
engineName
)
;
if
(
Svc
.
Prefs
.
get
(
"
engineStatusChanged
.
"
+
engine
.
prefName
false
)
)
{
this
.
_log
.
trace
(
"
The
"
+
engineName
+
"
engine
was
enabled
locally
.
"
)
;
toUndecline
.
add
(
engineName
)
;
}
else
{
this
.
_log
.
trace
(
"
The
"
+
engineName
+
"
engine
was
disabled
remotely
.
"
)
;
try
{
engine
.
enabled
=
false
;
}
catch
(
e
)
{
this
.
_log
.
trace
(
"
Failed
to
disable
engine
"
+
engineName
)
;
}
}
}
engineManager
.
decline
(
toDecline
)
;
engineManager
.
undecline
(
toUndecline
)
;
Svc
.
Prefs
.
resetBranch
(
"
engineStatusChanged
.
"
)
;
this
.
service
.
_ignorePrefObserver
=
false
;
}
async
_updateEnabledEngines
(
)
{
let
meta
=
await
this
.
service
.
recordManager
.
get
(
this
.
service
.
metaURL
)
;
let
numClients
=
this
.
service
.
scheduler
.
numClients
;
let
engineManager
=
this
.
service
.
engineManager
;
await
this
.
_updateEnabledFromMeta
(
meta
numClients
engineManager
)
;
}
}
;
Object
.
freeze
(
EngineSynchronizer
.
prototype
)
;
