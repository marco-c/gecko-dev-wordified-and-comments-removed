"
use
strict
"
;
const
Cu
=
Components
.
utils
;
this
.
EXPORTED_SYMBOLS
=
[
"
BookmarkRepairRequestor
"
"
BookmarkRepairResponder
"
]
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PlacesSyncUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
collection_repair
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
resource
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
doctor
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
Engine
.
Bookmarks
.
Repair
"
)
;
const
PREF_BRANCH
=
"
services
.
sync
.
repairs
.
bookmarks
.
"
;
const
RESPONSE_INTERVAL_TIMEOUT
=
60
*
60
*
24
*
3
;
const
MAX_REQUESTED_IDS
=
1000
;
class
AbortRepairError
extends
Error
{
constructor
(
reason
)
{
super
(
)
;
this
.
reason
=
reason
;
}
}
const
STATE
=
Object
.
freeze
(
{
NOT_REPAIRING
:
"
"
NEED_NEW_CLIENT
:
"
repair
.
need
-
new
-
client
"
SENT_REQUEST
:
"
repair
.
sent
"
SENT_SECOND_REQUEST
:
"
repair
.
sent
-
again
"
FINISHED
:
"
repair
.
finished
"
ABORTED
:
"
repair
.
aborted
"
}
)
;
const
PREF
=
Object
.
freeze
(
{
REPAIR_ID
:
"
flowID
"
REPAIR_MISSING_IDS
:
"
ids
"
REPAIR_CURRENT_CLIENT
:
"
currentClient
"
REPAIR_PREVIOUS_CLIENTS
:
"
previousClients
"
REPAIR_WHEN
:
"
when
"
CURRENT_STATE
:
"
state
"
}
)
;
class
BookmarkRepairRequestor
extends
CollectionRepairRequestor
{
constructor
(
service
=
null
)
{
super
(
service
)
;
this
.
prefs
=
new
Preferences
(
PREF_BRANCH
)
;
}
get
STATE
(
)
{
return
STATE
;
}
anyClientsRepairing
(
flowID
)
{
return
Doctor
.
anyClientsRepairing
(
this
.
service
"
bookmarks
"
flowID
)
;
}
getProblemIDs
(
validationInfo
)
{
let
ids
=
new
Set
(
)
;
for
(
let
{
child
}
of
validationInfo
.
problems
.
missingChildren
|
|
[
]
)
{
ids
.
add
(
child
)
;
}
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
return
ids
;
}
for
(
let
{
parent
id
}
of
validationInfo
.
problems
.
orphans
|
|
[
]
)
{
ids
.
add
(
id
)
;
ids
.
add
(
parent
)
;
}
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
return
ids
;
}
for
(
let
{
parent
}
of
validationInfo
.
problems
.
deletedChildren
|
|
[
]
)
{
ids
.
add
(
parent
)
;
}
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
return
ids
;
}
for
(
let
{
child
}
of
validationInfo
.
problems
.
deletedParents
|
|
[
]
)
{
ids
.
add
(
child
)
;
}
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
return
ids
;
}
for
(
let
{
parent
child
}
of
validationInfo
.
problems
.
parentChildMismatches
|
|
[
]
)
{
ids
.
add
(
parent
)
;
ids
.
add
(
child
)
;
}
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
return
ids
;
}
for
(
let
{
parents
child
}
of
validationInfo
.
problems
.
multipleParents
|
|
[
]
)
{
for
(
let
parent
of
parents
)
{
ids
.
add
(
parent
)
;
}
ids
.
add
(
child
)
;
}
return
ids
;
}
startRepairs
(
validationInfo
flowID
)
{
if
(
this
.
_currentState
!
=
STATE
.
NOT_REPAIRING
)
{
log
.
info
(
Can
'
t
start
a
repair
-
repair
with
ID
{
this
.
_flowID
}
is
already
in
progress
)
;
return
false
;
}
if
(
this
.
anyClientsRepairing
(
)
)
{
log
.
info
(
"
Can
'
t
start
repair
since
other
clients
are
already
repairing
bookmarks
"
)
;
let
extra
=
{
flowID
reason
:
"
other
clients
repairing
"
}
;
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
aborted
"
undefined
extra
)
return
false
;
}
let
ids
=
this
.
getProblemIDs
(
validationInfo
)
;
if
(
ids
.
size
>
MAX_REQUESTED_IDS
)
{
log
.
info
(
"
Not
starting
a
repair
as
there
are
over
"
+
MAX_REQUESTED_IDS
+
"
problems
"
)
;
let
extra
=
{
flowID
reason
:
too
many
problems
:
{
ids
.
size
}
}
;
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
aborted
"
undefined
extra
)
return
false
;
}
if
(
ids
.
size
=
=
0
)
{
log
.
info
(
"
Not
starting
a
repair
as
there
are
no
problems
"
)
;
return
false
;
}
log
.
info
(
Starting
a
repair
looking
for
{
ids
.
size
}
missing
item
(
s
)
)
;
this
.
_flowID
=
flowID
;
this
.
_currentIDs
=
Array
.
from
(
ids
)
;
this
.
_currentState
=
STATE
.
NEED_NEW_CLIENT
;
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
started
"
undefined
{
flowID
numIDs
:
ids
.
size
.
toString
(
)
}
)
;
return
this
.
continueRepairs
(
)
;
}
continueRepairs
(
response
=
null
)
{
if
(
this
.
_currentState
=
=
STATE
.
NOT_REPAIRING
)
{
return
false
;
}
let
state
newState
;
let
abortReason
;
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
state
=
this
.
_currentState
;
log
.
info
(
"
continueRepairs
starting
with
state
"
state
)
;
try
{
newState
=
this
.
_continueRepairs
(
state
response
)
;
log
.
info
(
"
continueRepairs
has
next
state
"
newState
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
AbortRepairError
)
)
{
throw
ex
;
}
log
.
info
(
Repair
has
been
aborted
:
{
ex
.
reason
}
)
;
newState
=
STATE
.
ABORTED
;
abortReason
=
ex
.
reason
;
}
if
(
newState
=
=
STATE
.
ABORTED
)
{
break
;
}
this
.
_currentState
=
newState
;
Services
.
prefs
.
savePrefFile
(
null
)
;
if
(
state
=
=
newState
)
{
break
;
}
}
if
(
state
!
=
newState
)
{
log
.
error
(
"
continueRepairs
spun
without
getting
a
new
state
"
)
;
}
if
(
newState
=
=
STATE
.
FINISHED
|
|
newState
=
=
STATE
.
ABORTED
)
{
let
object
=
newState
=
=
STATE
.
FINISHED
?
"
finished
"
:
"
aborted
"
;
let
extra
=
{
flowID
:
this
.
_flowID
numIDs
:
this
.
_currentIDs
.
length
.
toString
(
)
}
;
if
(
abortReason
)
{
extra
.
reason
=
abortReason
;
}
this
.
service
.
recordTelemetryEvent
(
"
repair
"
object
undefined
extra
)
;
this
.
prefs
.
resetBranch
(
)
;
Services
.
prefs
.
savePrefFile
(
null
)
;
}
return
true
;
}
_continueRepairs
(
state
response
=
null
)
{
if
(
this
.
anyClientsRepairing
(
this
.
_flowID
)
)
{
throw
new
AbortRepairError
(
"
other
clients
repairing
"
)
;
}
switch
(
state
)
{
case
STATE
.
SENT_REQUEST
:
case
STATE
.
SENT_SECOND_REQUEST
:
let
flowID
=
this
.
_flowID
;
let
clientID
=
this
.
_currentRemoteClient
;
if
(
!
clientID
)
{
throw
new
AbortRepairError
(
In
state
{
state
}
but
have
no
client
IDs
listed
)
;
}
if
(
response
)
{
state
=
this
.
_handleResponse
(
state
response
)
;
break
;
}
let
client
=
this
.
service
.
clientsEngine
.
remoteClient
(
clientID
)
;
if
(
!
client
)
{
log
.
info
(
previously
requested
client
"
{
clientID
}
"
has
vanished
-
moving
to
next
step
)
;
state
=
STATE
.
NEED_NEW_CLIENT
;
let
extra
=
{
deviceID
:
this
.
service
.
identity
.
hashedDeviceID
(
clientID
)
flowID
}
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
abandon
"
"
missing
"
extra
)
;
break
;
}
if
(
this
.
_isCommandPending
(
clientID
flowID
)
)
{
let
lastRequestSent
=
this
.
prefs
.
get
(
PREF
.
REPAIR_WHEN
)
;
let
timeLeft
=
lastRequestSent
+
RESPONSE_INTERVAL_TIMEOUT
-
this
.
_now
(
)
;
if
(
timeLeft
<
=
0
)
{
log
.
info
(
previous
request
to
client
{
clientID
}
is
pending
but
has
taken
too
long
)
;
state
=
STATE
.
NEED_NEW_CLIENT
;
let
extra
=
{
deviceID
:
this
.
service
.
identity
.
hashedDeviceID
(
clientID
)
flowID
}
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
abandon
"
"
silent
"
extra
)
;
break
;
}
log
.
trace
(
previous
request
to
client
{
clientID
}
has
{
timeLeft
}
seconds
before
we
give
up
on
it
)
;
break
;
}
if
(
state
=
=
STATE
.
SENT_REQUEST
)
{
log
.
info
(
previous
request
to
client
{
clientID
}
was
removed
-
trying
a
second
time
)
;
state
=
STATE
.
SENT_SECOND_REQUEST
;
this
.
_writeRequest
(
clientID
)
;
}
else
{
log
.
info
(
previous
2
requests
to
client
{
clientID
}
were
removed
-
need
a
new
client
)
;
state
=
STATE
.
NEED_NEW_CLIENT
;
}
break
;
case
STATE
.
NEED_NEW_CLIENT
:
let
newClientID
=
this
.
_findNextClient
(
)
;
if
(
!
newClientID
)
{
state
=
STATE
.
FINISHED
;
break
;
}
this
.
_addToPreviousRemoteClients
(
this
.
_currentRemoteClient
)
;
this
.
_currentRemoteClient
=
newClientID
;
this
.
_writeRequest
(
newClientID
)
;
state
=
STATE
.
SENT_REQUEST
;
break
;
case
STATE
.
ABORTED
:
break
;
case
STATE
.
FINISHED
:
break
;
case
NOT_REPAIRING
:
log
.
trace
(
"
continue
repairs
called
but
no
repair
in
progress
.
"
)
;
break
;
default
:
log
.
error
(
continue
repairs
finds
itself
in
an
unknown
state
{
state
}
)
;
state
=
STATE
.
ABORTED
;
break
;
}
return
state
;
}
_handleResponse
(
state
response
)
{
let
clientID
=
this
.
_currentRemoteClient
;
let
flowID
=
this
.
_flowID
;
if
(
response
.
flowID
!
=
flowID
|
|
response
.
clientID
!
=
clientID
|
|
response
.
request
!
=
"
upload
"
)
{
log
.
info
(
"
got
a
response
to
a
different
repair
request
"
response
)
;
return
state
;
}
let
remainingIDs
=
Array
.
from
(
CommonUtils
.
difference
(
this
.
_currentIDs
response
.
ids
)
)
;
log
.
info
(
repair
response
from
{
clientID
}
provided
"
{
response
.
ids
}
"
remaining
now
"
{
remainingIDs
}
"
)
;
this
.
_currentIDs
=
remainingIDs
;
if
(
remainingIDs
.
length
)
{
state
=
STATE
.
NEED_NEW_CLIENT
;
}
else
{
state
=
STATE
.
FINISHED
;
}
let
extra
=
{
deviceID
:
this
.
service
.
identity
.
hashedDeviceID
(
clientID
)
flowID
numIDs
:
response
.
ids
.
length
.
toString
(
)
}
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
response
"
"
upload
"
extra
)
;
return
state
;
}
_writeRequest
(
clientID
)
{
log
.
trace
(
"
writing
repair
request
to
client
"
clientID
)
;
let
ids
=
this
.
_currentIDs
;
if
(
!
ids
)
{
throw
new
AbortRepairError
(
"
Attempting
to
write
a
request
but
there
are
no
IDs
"
)
;
}
let
flowID
=
this
.
_flowID
;
let
request
=
{
collection
:
"
bookmarks
"
request
:
"
upload
"
requestor
:
this
.
service
.
clientsEngine
.
localID
ids
flowID
}
this
.
service
.
clientsEngine
.
sendCommand
(
"
repairRequest
"
[
request
]
clientID
{
flowID
}
)
;
this
.
prefs
.
set
(
PREF
.
REPAIR_WHEN
Math
.
floor
(
this
.
_now
(
)
)
)
;
let
extra
=
{
deviceID
:
this
.
service
.
identity
.
hashedDeviceID
(
clientID
)
flowID
numIDs
:
ids
.
length
.
toString
(
)
}
this
.
service
.
recordTelemetryEvent
(
"
repair
"
"
request
"
"
upload
"
extra
)
;
}
_findNextClient
(
)
{
let
alreadyDone
=
this
.
_getPreviousRemoteClients
(
)
;
alreadyDone
.
push
(
this
.
_currentRemoteClient
)
;
let
remoteClients
=
this
.
service
.
clientsEngine
.
remoteClients
;
remoteClients
.
sort
(
(
a
b
)
=
>
b
.
serverLastModified
-
a
.
serverLastModified
)
;
for
(
let
client
of
remoteClients
)
{
log
.
trace
(
"
findNextClient
considering
"
client
)
;
if
(
alreadyDone
.
indexOf
(
client
.
id
)
=
=
-
1
&
&
this
.
_isSuitableClient
(
client
)
)
{
return
client
.
id
;
}
}
log
.
trace
(
"
findNextClient
found
no
client
"
)
;
return
null
;
}
_isSuitableClient
(
client
)
{
return
(
client
.
type
=
=
DEVICE_TYPE_DESKTOP
&
&
Services
.
vc
.
compare
(
client
.
version
53
)
>
0
)
;
}
_isCommandPending
(
clientID
flowID
)
{
let
commands
=
[
.
.
.
this
.
service
.
clientsEngine
.
getClientCommands
(
clientID
)
.
.
.
this
.
service
.
clientsEngine
.
remoteClient
(
clientID
)
.
commands
|
|
[
]
]
;
for
(
let
command
of
commands
)
{
if
(
command
.
command
!
=
"
repairRequest
"
|
|
command
.
args
.
length
!
=
1
)
{
continue
;
}
let
arg
=
command
.
args
[
0
]
;
if
(
arg
.
collection
=
=
"
bookmarks
"
&
&
arg
.
request
=
=
"
upload
"
&
&
arg
.
flowID
=
=
flowID
)
{
return
true
;
}
}
return
false
;
}
get
_currentState
(
)
{
return
this
.
prefs
.
get
(
PREF
.
CURRENT_STATE
STATE
.
NOT_REPAIRING
)
;
}
set
_currentState
(
newState
)
{
this
.
prefs
.
set
(
PREF
.
CURRENT_STATE
newState
)
;
}
get
_currentIDs
(
)
{
let
ids
=
this
.
prefs
.
get
(
PREF
.
REPAIR_MISSING_IDS
"
"
)
;
return
ids
.
length
?
ids
.
split
(
"
"
)
:
[
]
;
}
set
_currentIDs
(
arrayOfIDs
)
{
this
.
prefs
.
set
(
PREF
.
REPAIR_MISSING_IDS
arrayOfIDs
.
join
(
"
"
)
)
;
}
get
_currentRemoteClient
(
)
{
return
this
.
prefs
.
get
(
PREF
.
REPAIR_CURRENT_CLIENT
)
;
}
set
_currentRemoteClient
(
clientID
)
{
this
.
prefs
.
set
(
PREF
.
REPAIR_CURRENT_CLIENT
clientID
)
;
}
get
_flowID
(
)
{
return
this
.
prefs
.
get
(
PREF
.
REPAIR_ID
)
;
}
set
_flowID
(
val
)
{
this
.
prefs
.
set
(
PREF
.
REPAIR_ID
val
)
;
}
_getPreviousRemoteClients
(
)
{
let
alreadyDone
=
this
.
prefs
.
get
(
PREF
.
REPAIR_PREVIOUS_CLIENTS
"
"
)
;
return
alreadyDone
.
length
?
alreadyDone
.
split
(
"
"
)
:
[
]
;
}
_addToPreviousRemoteClients
(
clientID
)
{
let
arrayOfClientIDs
=
this
.
_getPreviousRemoteClients
(
)
;
arrayOfClientIDs
.
push
(
clientID
)
;
this
.
prefs
.
set
(
PREF
.
REPAIR_PREVIOUS_CLIENTS
arrayOfClientIDs
.
join
(
"
"
)
)
;
}
_now
(
)
{
return
AsyncResource
.
serverTime
;
}
}
class
BookmarkRepairResponder
extends
CollectionRepairResponder
{
async
repair
(
request
rawCommand
)
{
if
(
request
.
request
!
=
"
upload
"
)
{
this
.
_abortRepair
(
request
rawCommand
Don
'
t
understand
request
type
'
{
request
.
request
}
'
)
;
return
;
}
let
engine
=
this
.
service
.
engineManager
.
get
(
"
bookmarks
"
)
;
let
allIDs
=
new
Set
(
)
;
let
maybeToDelete
=
new
Set
(
)
;
let
toUpload
=
new
Set
(
)
;
let
results
=
await
PlacesSyncUtils
.
bookmarks
.
fetchSyncIdsForRepair
(
request
.
ids
)
;
for
(
let
{
syncId
:
id
syncable
}
of
results
)
{
allIDs
.
add
(
id
)
;
if
(
syncable
)
{
toUpload
.
add
(
id
)
;
}
else
{
log
.
debug
(
repair
request
to
upload
item
{
id
}
but
it
isn
'
t
under
a
syncable
root
)
;
maybeToDelete
.
add
(
id
)
;
}
}
if
(
log
.
level
<
=
Log
.
Level
.
Debug
)
{
let
missingItems
=
request
.
ids
.
filter
(
id
=
>
!
toUpload
.
has
(
id
)
&
&
!
maybeToDelete
.
has
(
id
)
)
;
if
(
missingItems
.
length
)
{
log
.
debug
(
"
repair
request
to
upload
items
that
don
'
t
exist
locally
"
missingItems
)
;
}
}
let
existsRemotely
=
new
Set
(
)
;
let
itemSource
=
engine
.
itemSource
(
)
;
itemSource
.
ids
=
Array
.
from
(
allIDs
)
;
log
.
trace
(
checking
the
server
for
items
itemSource
.
ids
)
;
for
(
let
remoteID
of
JSON
.
parse
(
itemSource
.
get
(
)
)
)
{
log
.
trace
(
the
server
has
"
{
remoteID
}
"
)
;
existsRemotely
.
add
(
remoteID
)
;
if
(
request
.
ids
.
indexOf
(
remoteID
)
=
=
-
1
)
{
toUpload
.
delete
(
remoteID
)
;
}
}
let
toDelete
=
CommonUtils
.
difference
(
maybeToDelete
existsRemotely
)
;
log
.
debug
(
repair
request
will
upload
{
toUpload
.
size
}
items
and
delete
{
toDelete
.
size
}
items
)
;
for
(
let
id
of
toUpload
)
{
engine
.
_modified
.
setWeak
(
id
{
tombstone
:
false
}
)
;
}
for
(
let
id
of
toDelete
)
{
engine
.
_modified
.
setWeak
(
id
{
tombstone
:
true
}
)
;
}
this
.
_currentState
=
{
request
rawCommand
toUpload
toDelete
}
if
(
toUpload
.
size
|
|
toDelete
.
size
)
{
Svc
.
Obs
.
add
(
"
weave
:
engine
:
sync
:
uploaded
"
this
.
onUploaded
this
)
;
let
eventExtra
=
{
flowID
:
request
.
flowID
numIDs
:
(
toUpload
.
size
+
toDelete
.
size
)
.
toString
(
)
}
;
this
.
service
.
recordTelemetryEvent
(
"
repairResponse
"
"
uploading
"
undefined
eventExtra
)
;
}
else
{
this
.
_finishRepair
(
)
;
}
}
onUploaded
(
subject
data
)
{
if
(
data
!
=
"
bookmarks
"
)
{
return
;
}
Svc
.
Obs
.
remove
(
"
weave
:
engine
:
sync
:
uploaded
"
this
.
onUploaded
this
)
;
log
.
debug
(
bookmarks
engine
has
uploaded
stuff
-
creating
a
repair
response
)
;
this
.
_finishRepair
(
)
;
}
_finishRepair
(
)
{
let
clientsEngine
=
this
.
service
.
clientsEngine
;
let
flowID
=
this
.
_currentState
.
request
.
flowID
;
let
response
=
{
request
:
this
.
_currentState
.
request
.
request
collection
:
"
bookmarks
"
clientID
:
clientsEngine
.
localID
flowID
ids
:
[
]
}
for
(
let
id
of
this
.
_currentState
.
toUpload
)
{
response
.
ids
.
push
(
id
)
;
}
for
(
let
id
of
this
.
_currentState
.
toDelete
)
{
response
.
ids
.
push
(
id
)
;
}
let
clientID
=
this
.
_currentState
.
request
.
requestor
;
clientsEngine
.
sendCommand
(
"
repairResponse
"
[
response
]
clientID
{
flowID
}
)
;
clientsEngine
.
removeLocalCommand
(
this
.
_currentState
.
rawCommand
)
;
let
eventExtra
=
{
flowID
numIDs
:
response
.
ids
.
length
.
toString
(
)
}
this
.
service
.
recordTelemetryEvent
(
"
repairResponse
"
"
finished
"
undefined
eventExtra
)
;
this
.
_currentState
=
null
;
}
_abortRepair
(
request
rawCommand
why
)
{
log
.
warn
(
aborting
repair
request
:
{
why
}
)
;
this
.
service
.
clientsEngine
.
removeLocalCommand
(
rawCommand
)
;
let
eventExtra
=
{
flowID
:
request
.
flowID
reason
:
why
}
;
this
.
service
.
recordTelemetryEvent
(
"
repairResponse
"
"
aborted
"
undefined
eventExtra
)
;
}
}
