"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserIDManager
"
"
AuthenticationError
"
]
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
common
/
tokenserverclient
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Weave
"
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BulkKeyBundle
"
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
BrowserIDManager
"
)
;
log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
identity
"
)
;
return
log
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
IGNORE_CACHED_AUTH_CREDENTIALS
"
"
services
.
sync
.
debug
.
ignoreCachedAuthCredentials
"
)
;
var
fxAccountsCommon
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
fxAccountsCommon
)
;
const
OBSERVER_TOPICS
=
[
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
]
;
this
.
telemetryHelper
=
{
STATES
:
{
SUCCESS
:
"
SUCCESS
"
NOTVERIFIED
:
"
NOTVERIFIED
"
REJECTED
:
"
REJECTED
"
}
PREFS
:
{
REJECTED_AT
:
"
identity
.
telemetry
.
loginRejectedAt
"
APPEARS_PERMANENTLY_REJECTED
:
"
identity
.
telemetry
.
loginAppearsPermanentlyRejected
"
LAST_RECORDED_STATE
:
"
identity
.
telemetry
.
lastRecordedState
"
}
NUM_MINUTES_TO_RECORD_REJECTED_TELEMETRY
:
20160
SCALAR
:
"
services
.
sync
.
sync_login_state_transitions
"
maybeRecordLoginState
(
status
)
{
try
{
this
.
_maybeRecordLoginState
(
status
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Failed
to
record
login
telemetry
"
ex
)
;
}
}
_maybeRecordLoginState
(
status
)
{
let
key
=
this
.
STATES
[
status
]
;
if
(
!
key
)
{
throw
new
Error
(
invalid
state
{
status
}
)
;
}
let
when
=
Svc
.
Prefs
.
get
(
this
.
PREFS
.
REJECTED_AT
)
;
let
howLong
=
when
?
this
.
nowInMinutes
(
)
-
when
:
0
;
let
isNewState
=
Svc
.
Prefs
.
get
(
this
.
PREFS
.
LAST_RECORDED_STATE
)
!
=
status
;
if
(
status
=
=
this
.
STATES
.
SUCCESS
)
{
if
(
isNewState
)
{
Services
.
telemetry
.
keyedScalarSet
(
this
.
SCALAR
key
true
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
LAST_RECORDED_STATE
status
)
;
}
if
(
when
)
{
if
(
!
Svc
.
Prefs
.
get
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
)
{
Services
.
telemetry
.
getHistogramById
(
"
WEAVE_LOGIN_FAILED_FOR
"
)
.
add
(
howLong
)
;
}
}
Svc
.
Prefs
.
reset
(
this
.
PREFS
.
REJECTED_AT
)
;
Svc
.
Prefs
.
reset
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
;
}
else
{
if
(
Svc
.
Prefs
.
get
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
)
{
return
;
}
if
(
isNewState
)
{
Services
.
telemetry
.
keyedScalarSet
(
this
.
SCALAR
key
true
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
LAST_RECORDED_STATE
status
)
;
}
if
(
howLong
>
this
.
NUM_MINUTES_TO_RECORD_REJECTED_TELEMETRY
)
{
Services
.
telemetry
.
getHistogramById
(
"
WEAVE_LOGIN_FAILED_FOR
"
)
.
add
(
howLong
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
true
)
;
}
if
(
!
Svc
.
Prefs
.
has
(
this
.
PREFS
.
REJECTED_AT
)
)
{
Svc
.
Prefs
.
set
(
this
.
PREFS
.
REJECTED_AT
this
.
nowInMinutes
(
)
)
;
}
}
}
nowInMinutes
(
)
{
return
Math
.
floor
(
Date
.
now
(
)
/
1000
/
60
)
;
}
}
;
function
deriveKeyBundle
(
kB
)
{
let
out
=
CryptoUtils
.
hkdf
(
kB
undefined
"
identity
.
mozilla
.
com
/
picl
/
v1
/
oldsync
"
2
*
32
)
;
let
bundle
=
new
BulkKeyBundle
(
)
;
bundle
.
keyPair
=
[
out
.
slice
(
0
32
)
out
.
slice
(
32
64
)
]
;
return
bundle
;
}
function
AuthenticationError
(
details
source
)
{
this
.
details
=
details
;
this
.
source
=
source
;
}
AuthenticationError
.
prototype
=
{
toString
(
)
{
return
"
AuthenticationError
(
"
+
this
.
details
+
"
)
"
;
}
}
;
this
.
BrowserIDManager
=
function
BrowserIDManager
(
)
{
this
.
_fxaService
=
fxAccounts
;
this
.
_tokenServerClient
=
new
TokenServerClient
(
)
;
this
.
_tokenServerClient
.
observerPrefix
=
"
weave
:
service
"
;
this
.
whenReadyToAuthenticate
=
null
;
this
.
_log
=
log
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_username
"
"
services
.
sync
.
username
"
)
;
}
;
this
.
BrowserIDManager
.
prototype
=
{
_fxaService
:
null
_tokenServerClient
:
null
_token
:
null
_signedInUser
:
null
_authFailureReason
:
null
_shouldHaveSyncKeyBundle
:
false
hashedUID
(
)
{
if
(
!
this
.
_hashedUID
)
{
throw
new
Error
(
"
hashedUID
:
Don
'
t
seem
to
have
previously
seen
a
token
"
)
;
}
return
this
.
_hashedUID
;
}
hashedDeviceID
(
deviceID
)
{
let
uid
=
this
.
hashedUID
(
)
;
return
Utils
.
sha256
(
deviceID
+
uid
)
;
}
deviceID
(
)
{
return
this
.
_signedInUser
&
&
this
.
_signedInUser
.
deviceId
;
}
initialize
(
)
{
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
addObserver
(
this
topic
)
;
}
}
ensureLoggedIn
(
)
{
if
(
!
this
.
_shouldHaveSyncKeyBundle
&
&
this
.
whenReadyToAuthenticate
)
{
return
this
.
whenReadyToAuthenticate
.
promise
;
}
if
(
this
.
_syncKeyBundle
)
{
return
Promise
.
resolve
(
)
;
}
if
(
Weave
.
Status
.
login
=
=
LOGIN_FAILED_LOGIN_REJECTED
)
{
return
Promise
.
reject
(
new
Error
(
"
User
needs
to
re
-
authenticate
"
)
)
;
}
this
.
initializeWithCurrentIdentity
(
)
;
return
this
.
whenReadyToAuthenticate
.
promise
;
}
finalize
(
)
{
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
}
this
.
resetCredentials
(
)
;
this
.
_signedInUser
=
null
;
}
initializeWithCurrentIdentity
(
isInitialSync
=
false
)
{
this
.
_log
.
trace
(
"
initializeWithCurrentIdentity
"
)
;
this
.
whenReadyToAuthenticate
=
PromiseUtils
.
defer
(
)
;
this
.
whenReadyToAuthenticate
.
promise
.
catch
(
err
=
>
{
this
.
_log
.
error
(
"
Could
not
authenticate
"
err
)
;
}
)
;
this
.
resetCredentials
(
)
;
this
.
_authFailureReason
=
null
;
return
this
.
_fxaService
.
getSignedInUser
(
)
.
then
(
accountData
=
>
{
if
(
!
accountData
)
{
this
.
_log
.
info
(
"
initializeWithCurrentIdentity
has
no
user
logged
in
"
)
;
this
.
_shouldHaveSyncKeyBundle
=
true
;
this
.
whenReadyToAuthenticate
.
reject
(
"
no
user
is
logged
in
"
)
;
return
;
}
this
.
username
=
accountData
.
email
;
this
.
_updateSignedInUser
(
accountData
)
;
this
.
_log
.
info
(
"
Waiting
for
user
to
be
verified
.
"
)
;
if
(
!
accountData
.
verified
)
{
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
NOTVERIFIED
)
;
}
this
.
_fxaService
.
whenVerified
(
accountData
)
.
then
(
accountData
=
>
{
this
.
_updateSignedInUser
(
accountData
)
;
this
.
_log
.
info
(
"
Starting
fetch
for
key
bundle
.
"
)
;
return
this
.
_fetchTokenForUser
(
)
;
}
)
.
then
(
token
=
>
{
this
.
_token
=
token
;
if
(
token
)
{
this
.
_hashedUID
=
token
.
hashed_fxa_uid
;
}
this
.
_shouldHaveSyncKeyBundle
=
true
;
this
.
whenReadyToAuthenticate
.
resolve
(
)
;
this
.
_log
.
info
(
"
Background
fetch
for
key
bundle
done
"
)
;
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
if
(
isInitialSync
)
{
this
.
_log
.
info
(
"
Doing
initial
sync
actions
"
)
;
Svc
.
Prefs
.
set
(
"
firstSync
"
"
resetClient
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
setup
-
complete
"
)
;
CommonUtils
.
nextTick
(
Weave
.
Service
.
sync
Weave
.
Service
)
;
}
}
)
.
catch
(
authErr
=
>
{
this
.
_log
.
error
(
"
Background
fetch
for
key
bundle
failed
"
authErr
)
;
this
.
_shouldHaveSyncKeyBundle
=
true
;
this
.
whenReadyToAuthenticate
.
reject
(
authErr
)
;
}
)
;
}
)
.
catch
(
err
=
>
{
this
.
_log
.
error
(
"
Processing
logged
in
account
"
err
)
;
}
)
;
}
_updateSignedInUser
(
userData
)
{
if
(
this
.
_signedInUser
&
&
this
.
_signedInUser
.
email
!
=
userData
.
email
)
{
throw
new
Error
(
"
Attempting
to
update
to
a
different
user
.
"
)
;
}
this
.
_signedInUser
=
userData
;
}
logout
(
)
{
this
.
_token
=
null
;
}
observe
(
subject
topic
data
)
{
this
.
_log
.
debug
(
"
observed
"
+
topic
)
;
switch
(
topic
)
{
case
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
:
{
if
(
Weave
.
Status
.
login
=
=
LOGIN_FAILED_LOGIN_REJECTED
)
{
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
}
let
firstLogin
=
!
this
.
username
;
this
.
initializeWithCurrentIdentity
(
firstLogin
)
;
if
(
!
firstLogin
)
{
this
.
whenReadyToAuthenticate
.
promise
.
then
(
(
)
=
>
{
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
setup
-
complete
"
)
;
return
Async
.
promiseYield
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Weave
.
Service
.
sync
(
)
;
}
)
.
catch
(
e
=
>
{
this
.
_log
.
warn
(
"
Failed
to
trigger
setup
complete
notification
"
e
)
;
}
)
;
}
}
break
;
case
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
:
Async
.
promiseSpinningly
(
Weave
.
Service
.
startOver
(
)
)
;
break
;
case
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
:
this
.
resetCredentials
(
)
;
this
.
_ensureValidToken
(
)
.
catch
(
err
=
>
this
.
_log
.
error
(
"
Error
while
fetching
a
new
token
"
err
)
)
;
break
;
}
}
_sha256
(
message
)
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
return
CryptoUtils
.
digestBytes
(
message
hasher
)
;
}
_computeXClientState
(
kBbytes
)
{
return
CommonUtils
.
bytesAsHex
(
this
.
_sha256
(
kBbytes
)
.
slice
(
0
16
)
false
)
;
}
_now
(
)
{
return
this
.
_fxaService
.
now
(
)
;
}
get
_localtimeOffsetMsec
(
)
{
return
this
.
_fxaService
.
localtimeOffsetMsec
;
}
get
syncKeyBundle
(
)
{
return
this
.
_syncKeyBundle
;
}
get
username
(
)
{
return
this
.
_username
;
}
set
username
(
value
)
{
if
(
value
)
{
value
=
value
.
toLowerCase
(
)
;
if
(
value
=
=
this
.
username
)
{
return
;
}
Svc
.
Prefs
.
set
(
"
username
"
value
)
;
}
else
{
Svc
.
Prefs
.
reset
(
"
username
"
)
;
}
this
.
_log
.
info
(
"
Username
changed
.
Removing
stored
credentials
.
"
)
;
this
.
resetCredentials
(
)
;
}
resetCredentials
(
)
{
this
.
resetSyncKeyBundle
(
)
;
this
.
_token
=
null
;
this
.
_hashedUID
=
null
;
Weave
.
Service
.
clusterURL
=
null
;
}
resetSyncKeyBundle
(
)
{
this
.
_syncKeyBundle
=
null
;
this
.
_shouldHaveSyncKeyBundle
=
false
;
}
prefetchMigrationSentinel
(
service
)
{
}
_getSyncCredentialsHosts
(
)
{
return
Utils
.
getSyncCredentialsHostsFxA
(
)
;
}
deleteSyncCredentials
(
)
{
for
(
let
host
of
this
.
_getSyncCredentialsHosts
(
)
)
{
let
logins
=
Services
.
logins
.
findLogins
(
{
}
host
"
"
"
"
)
;
for
(
let
login
of
logins
)
{
Services
.
logins
.
removeLogin
(
login
)
;
}
}
}
get
currentAuthState
(
)
{
if
(
this
.
_authFailureReason
)
{
this
.
_log
.
info
(
"
currentAuthState
returning
"
+
this
.
_authFailureReason
+
"
due
to
previous
failure
"
)
;
return
this
.
_authFailureReason
;
}
if
(
!
this
.
username
)
{
return
LOGIN_FAILED_NO_USERNAME
;
}
return
STATUS_OK
;
}
_canFetchKeys
(
)
{
let
userData
=
this
.
_signedInUser
;
return
userData
&
&
(
userData
.
keyFetchToken
|
|
(
userData
.
kA
&
&
userData
.
kB
)
)
;
}
unlockAndVerifyAuthState
(
)
{
if
(
this
.
_canFetchKeys
(
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
already
has
(
or
can
fetch
)
sync
keys
"
)
;
return
Promise
.
resolve
(
STATUS_OK
)
;
}
if
(
!
Utils
.
ensureMPUnlocked
(
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
:
user
declined
to
unlock
master
-
password
"
)
;
return
Promise
.
resolve
(
MASTER_PASSWORD_LOCKED
)
;
}
return
this
.
_fxaService
.
getSignedInUser
(
)
.
then
(
accountData
=
>
{
this
.
_updateSignedInUser
(
accountData
)
;
let
result
;
if
(
this
.
_canFetchKeys
(
)
)
{
result
=
STATUS_OK
;
}
else
{
result
=
LOGIN_FAILED_LOGIN_REJECTED
;
}
log
.
debug
(
"
unlockAndVerifyAuthState
re
-
fetched
credentials
and
is
returning
"
result
)
;
return
result
;
}
)
;
}
hasValidToken
(
)
{
if
(
IGNORE_CACHED_AUTH_CREDENTIALS
)
{
return
false
;
}
if
(
!
this
.
_token
)
{
return
false
;
}
if
(
this
.
_token
.
expiration
<
this
.
_now
(
)
)
{
return
false
;
}
return
true
;
}
get
_tokenServerUrl
(
)
{
let
url
=
Svc
.
Prefs
.
get
(
"
tokenServerURI
"
)
;
if
(
!
url
)
{
url
=
Services
.
prefs
.
getCharPref
(
"
identity
.
sync
.
tokenserver
.
uri
"
)
;
}
while
(
url
.
endsWith
(
"
/
"
)
)
{
url
=
url
.
slice
(
0
-
1
)
;
}
return
url
;
}
_fetchTokenForUser
(
)
{
let
tokenServerURI
=
this
.
_tokenServerUrl
;
let
log
=
this
.
_log
;
let
client
=
this
.
_tokenServerClient
;
let
fxa
=
this
.
_fxaService
;
let
userData
=
this
.
_signedInUser
;
if
(
!
this
.
_canFetchKeys
(
)
)
{
log
.
info
(
"
Unable
to
fetch
keys
(
master
-
password
locked
?
)
so
aborting
token
fetch
"
)
;
return
Promise
.
resolve
(
null
)
;
}
let
maybeFetchKeys
=
(
)
=
>
{
if
(
userData
.
kA
&
&
userData
.
kB
)
{
return
null
;
}
log
.
info
(
"
Fetching
new
keys
"
)
;
return
this
.
_fxaService
.
getKeys
(
)
.
then
(
newUserData
=
>
{
userData
=
newUserData
;
this
.
_updateSignedInUser
(
userData
)
;
}
)
;
}
;
let
getToken
=
assertion
=
>
{
log
.
debug
(
"
Getting
a
token
"
)
;
let
deferred
=
PromiseUtils
.
defer
(
)
;
let
cb
=
function
(
err
token
)
{
if
(
err
)
{
return
deferred
.
reject
(
err
)
;
}
log
.
debug
(
"
Successfully
got
a
sync
token
"
)
;
return
deferred
.
resolve
(
token
)
;
}
;
let
kBbytes
=
CommonUtils
.
hexToBytes
(
userData
.
kB
)
;
let
headers
=
{
"
X
-
Client
-
State
"
:
this
.
_computeXClientState
(
kBbytes
)
}
;
client
.
getTokenFromBrowserIDAssertion
(
tokenServerURI
assertion
cb
headers
)
;
return
deferred
.
promise
;
}
;
let
getAssertion
=
(
)
=
>
{
log
.
info
(
"
Getting
an
assertion
from
"
tokenServerURI
)
;
let
audience
=
Services
.
io
.
newURI
(
tokenServerURI
)
.
prePath
;
return
fxa
.
getAssertion
(
audience
)
;
}
;
return
fxa
.
whenVerified
(
this
.
_signedInUser
)
.
then
(
(
)
=
>
maybeFetchKeys
(
)
)
.
then
(
(
)
=
>
getAssertion
(
)
)
.
then
(
assertion
=
>
getToken
(
assertion
)
)
.
catch
(
err
=
>
{
if
(
!
err
.
response
|
|
err
.
response
.
status
!
=
=
401
)
{
return
Promise
.
reject
(
err
)
;
}
log
.
warn
(
"
Token
server
returned
401
refreshing
certificate
and
retrying
token
fetch
"
)
;
return
fxa
.
invalidateCertificate
(
)
.
then
(
(
)
=
>
getAssertion
(
)
)
.
then
(
assertion
=
>
getToken
(
assertion
)
)
;
}
)
.
then
(
token
=
>
{
token
.
expiration
=
this
.
_now
(
)
+
(
token
.
duration
*
1000
)
*
0
.
80
;
if
(
!
this
.
_syncKeyBundle
)
{
this
.
_syncKeyBundle
=
deriveKeyBundle
(
CommonUtils
.
hexToBytes
(
userData
.
kB
)
)
;
}
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
SUCCESS
)
;
return
token
;
}
)
.
catch
(
err
=
>
{
if
(
err
.
response
&
&
err
.
response
.
status
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
tokenserver
"
)
;
}
else
if
(
err
.
code
&
&
err
.
code
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
hawkclient
"
)
;
}
else
if
(
err
.
message
=
=
fxAccountsCommon
.
ERROR_AUTH_ERROR
)
{
err
=
new
AuthenticationError
(
err
"
fxaccounts
"
)
;
}
if
(
err
instanceof
AuthenticationError
)
{
this
.
_log
.
error
(
"
Authentication
error
in
_fetchTokenForUser
"
err
)
;
this
.
_authFailureReason
=
LOGIN_FAILED_LOGIN_REJECTED
;
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
REJECTED
)
;
}
else
{
this
.
_log
.
error
(
"
Non
-
authentication
error
in
_fetchTokenForUser
"
err
)
;
this
.
_authFailureReason
=
LOGIN_FAILED_NETWORK_ERROR
;
}
this
.
_shouldHaveSyncKeyBundle
=
true
;
Weave
.
Status
.
login
=
this
.
_authFailureReason
;
throw
err
;
}
)
;
}
_ensureValidToken
(
)
{
if
(
this
.
hasValidToken
(
)
)
{
this
.
_log
.
debug
(
"
_ensureValidToken
already
has
one
"
)
;
return
Promise
.
resolve
(
)
;
}
const
notifyStateChanged
=
(
)
=
>
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
login
:
change
"
)
;
this
.
_token
=
null
;
return
this
.
_fetchTokenForUser
(
)
.
then
(
token
=
>
{
this
.
_token
=
token
;
if
(
token
)
{
this
.
_hashedUID
=
token
.
hashed_fxa_uid
;
}
notifyStateChanged
(
)
;
}
error
=
>
{
notifyStateChanged
(
)
;
throw
error
;
}
)
;
}
getResourceAuthenticator
(
)
{
return
this
.
_getAuthenticationHeader
.
bind
(
this
)
;
}
_getAuthenticationHeader
(
httpObject
method
)
{
let
cb
=
Async
.
makeSpinningCallback
(
)
;
this
.
_ensureValidToken
(
)
.
then
(
cb
cb
)
;
try
{
cb
.
wait
(
)
;
}
catch
(
ex
)
{
if
(
Async
.
isShutdownException
(
ex
)
)
{
throw
ex
;
}
this
.
_log
.
error
(
"
Failed
to
fetch
a
token
for
authentication
"
ex
)
;
return
null
;
}
if
(
!
this
.
_token
)
{
return
null
;
}
let
credentials
=
{
algorithm
:
"
sha256
"
id
:
this
.
_token
.
id
key
:
this
.
_token
.
key
}
;
method
=
method
|
|
httpObject
.
method
;
let
options
=
{
now
:
this
.
_now
(
)
localtimeOffsetMsec
:
this
.
_localtimeOffsetMsec
credentials
}
;
let
headerValue
=
CryptoUtils
.
computeHAWK
(
httpObject
.
uri
method
options
)
;
return
{
headers
:
{
authorization
:
headerValue
.
field
}
}
;
}
createClusterManager
(
service
)
{
return
new
BrowserIDClusterManager
(
service
)
;
}
loginStatusFromVerification404
(
)
{
return
LOGIN_FAILED_NETWORK_ERROR
;
}
}
;
function
BrowserIDClusterManager
(
service
)
{
this
.
_log
=
log
;
this
.
service
=
service
;
}
BrowserIDClusterManager
.
prototype
=
{
get
identity
(
)
{
return
this
.
service
.
identity
;
}
setCluster
(
)
{
let
cluster
=
this
.
_findCluster
(
)
;
this
.
_log
.
debug
(
"
Cluster
value
=
"
+
cluster
)
;
if
(
cluster
=
=
null
)
{
return
false
;
}
cluster
=
cluster
.
toString
(
)
;
if
(
cluster
=
=
this
.
service
.
clusterURL
)
{
return
false
;
}
this
.
_log
.
debug
(
"
Setting
cluster
to
"
+
cluster
)
;
this
.
service
.
clusterURL
=
cluster
;
return
true
;
}
_findCluster
(
)
{
let
endPointFromIdentityToken
=
(
)
=
>
{
if
(
!
this
.
identity
.
_token
)
{
throw
new
Error
(
"
Can
'
t
get
a
cluster
URL
as
we
can
'
t
fetch
keys
.
"
)
;
}
let
endpoint
=
this
.
identity
.
_token
.
endpoint
;
if
(
!
endpoint
.
endsWith
(
"
/
"
)
)
{
endpoint
+
=
"
/
"
;
}
log
.
debug
(
"
_findCluster
returning
"
+
endpoint
)
;
return
endpoint
;
}
;
let
promiseClusterURL
=
(
)
=
>
{
return
this
.
identity
.
whenReadyToAuthenticate
.
promise
.
then
(
(
)
=
>
{
if
(
this
.
service
.
clusterURL
)
{
log
.
debug
(
"
_findCluster
has
a
pre
-
existing
clusterURL
so
discarding
the
current
token
"
)
;
this
.
identity
.
_token
=
null
;
}
return
this
.
identity
.
_ensureValidToken
(
)
;
}
)
.
then
(
endPointFromIdentityToken
)
;
}
;
let
cb
=
Async
.
makeSpinningCallback
(
)
;
promiseClusterURL
(
)
.
then
(
function
(
clusterURL
)
{
cb
(
null
clusterURL
)
;
}
)
.
catch
(
err
=
>
{
log
.
info
(
"
Failed
to
fetch
the
cluster
URL
"
err
)
;
if
(
err
instanceof
AuthenticationError
)
{
cb
(
null
null
)
;
}
else
{
cb
(
err
)
;
}
}
)
;
return
cb
.
wait
(
)
;
}
getUserBaseURL
(
)
{
return
this
.
service
.
clusterURL
;
}
}
;
