"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserIDManager
"
"
AuthenticationError
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
fxAccounts
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
TokenServerClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
tokenserverclient
.
js
"
)
;
const
{
CryptoUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
{
Svc
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
LOGIN_FAILED_LOGIN_REJECTED
LOGIN_FAILED_NETWORK_ERROR
LOGIN_FAILED_NO_USERNAME
LOGIN_SUCCEEDED
MASTER_PASSWORD_LOCKED
STATUS_OK
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Weave
"
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BulkKeyBundle
"
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
BrowserIDManager
"
)
;
log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
identity
"
)
;
return
log
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
IGNORE_CACHED_AUTH_CREDENTIALS
"
"
services
.
sync
.
debug
.
ignoreCachedAuthCredentials
"
)
;
var
fxAccountsCommon
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
fxAccountsCommon
)
;
const
OBSERVER_TOPICS
=
[
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
fxAccountsCommon
.
ONVERIFIED_NOTIFICATION
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
"
weave
:
connected
"
]
;
function
AuthenticationError
(
details
source
)
{
this
.
details
=
details
;
this
.
source
=
source
;
}
AuthenticationError
.
prototype
=
{
toString
(
)
{
return
"
AuthenticationError
(
"
+
this
.
details
+
"
)
"
;
}
}
;
function
BrowserIDManager
(
)
{
this
.
_fxaService
=
fxAccounts
;
this
.
_tokenServerClient
=
new
TokenServerClient
(
)
;
this
.
_tokenServerClient
.
observerPrefix
=
"
weave
:
service
"
;
this
.
_log
=
log
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_username
"
"
services
.
sync
.
username
"
)
;
this
.
asyncObserver
=
Async
.
asyncObserver
(
this
log
)
;
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
addObserver
(
this
.
asyncObserver
topic
)
;
}
}
this
.
BrowserIDManager
.
prototype
=
{
_fxaService
:
null
_tokenServerClient
:
null
_token
:
null
_userUid
:
null
hashedUID
(
)
{
if
(
!
this
.
_hashedUID
)
{
throw
new
Error
(
"
hashedUID
:
Don
'
t
seem
to
have
previously
seen
a
token
"
)
;
}
return
this
.
_hashedUID
;
}
hashedDeviceID
(
deviceID
)
{
let
uid
=
this
.
hashedUID
(
)
;
return
Utils
.
sha256
(
deviceID
+
uid
)
;
}
finalize
(
)
{
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
removeObserver
(
this
.
asyncObserver
topic
)
;
}
this
.
resetCredentials
(
)
;
this
.
_userUid
=
null
;
}
async
getSignedInUser
(
)
{
let
data
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
data
)
{
this
.
_userUid
=
null
;
return
null
;
}
if
(
this
.
_userUid
=
=
null
)
{
this
.
_userUid
=
data
.
uid
;
}
else
if
(
this
.
_userUid
!
=
data
.
uid
)
{
throw
new
Error
(
"
The
signed
in
user
has
changed
"
)
;
}
return
data
;
}
logout
(
)
{
this
.
_token
=
null
;
}
async
observe
(
subject
topic
data
)
{
this
.
_log
.
debug
(
"
observed
"
+
topic
)
;
if
(
!
this
.
username
)
{
this
.
_log
.
info
(
"
Sync
is
not
configured
so
ignoring
the
notification
"
)
;
return
;
}
switch
(
topic
)
{
case
"
weave
:
connected
"
:
case
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
:
{
this
.
_log
.
info
(
"
Sync
has
been
connected
to
a
logged
in
user
"
)
;
this
.
resetCredentials
(
)
;
let
accountData
=
await
this
.
getSignedInUser
(
)
;
if
(
!
accountData
.
verified
)
{
this
.
_log
.
info
(
"
The
user
is
not
verified
"
)
;
break
;
}
}
case
fxAccountsCommon
.
ONVERIFIED_NOTIFICATION
:
{
this
.
_log
.
info
(
"
The
user
became
verified
"
)
;
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
let
isFirstSync
=
!
Weave
.
Service
.
locked
&
&
!
Svc
.
Prefs
.
get
(
"
client
.
syncID
"
null
)
;
if
(
isFirstSync
)
{
this
.
_log
.
info
(
"
Doing
initial
sync
actions
"
)
;
Svc
.
Prefs
.
set
(
"
firstSync
"
"
resetClient
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
setup
-
complete
"
)
;
}
if
(
!
Svc
.
Prefs
.
get
(
"
testing
.
tps
"
false
)
)
{
Weave
.
Service
.
sync
(
{
why
:
"
login
"
}
)
;
}
break
;
}
case
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
:
Weave
.
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
this
.
_log
.
trace
(
"
startOver
completed
"
)
;
}
)
.
catch
(
err
=
>
{
this
.
_log
.
warn
(
"
Failed
to
reset
sync
"
err
)
;
}
)
;
break
;
case
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
:
this
.
resetCredentials
(
)
;
break
;
}
}
_now
(
)
{
return
this
.
_fxaService
.
_internal
.
now
(
)
;
}
get
_localtimeOffsetMsec
(
)
{
return
this
.
_fxaService
.
_internal
.
localtimeOffsetMsec
;
}
get
syncKeyBundle
(
)
{
return
this
.
_syncKeyBundle
;
}
get
username
(
)
{
return
this
.
_username
;
}
set
username
(
value
)
{
throw
new
Error
(
"
don
'
t
set
the
username
"
)
;
}
resetCredentials
(
)
{
this
.
_syncKeyBundle
=
null
;
this
.
_token
=
null
;
this
.
_hashedUID
=
null
;
Weave
.
Service
.
clusterURL
=
null
;
}
prefetchMigrationSentinel
(
service
)
{
}
async
unlockAndVerifyAuthState
(
)
{
let
data
=
await
this
.
getSignedInUser
(
)
;
if
(
!
data
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
has
no
FxA
user
"
)
;
return
LOGIN_FAILED_NO_USERNAME
;
}
if
(
!
this
.
username
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
finds
that
sync
isn
'
t
configured
"
)
;
return
LOGIN_FAILED_NO_USERNAME
;
}
if
(
!
data
.
verified
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
has
an
unverified
user
"
)
;
return
LOGIN_FAILED_LOGIN_REJECTED
;
}
if
(
await
this
.
_fxaService
.
keys
.
canGetKeys
(
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
already
has
(
or
can
fetch
)
sync
keys
"
)
;
return
STATUS_OK
;
}
if
(
!
Utils
.
ensureMPUnlocked
(
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
:
user
declined
to
unlock
master
-
password
"
)
;
return
MASTER_PASSWORD_LOCKED
;
}
let
result
;
if
(
await
this
.
_fxaService
.
keys
.
canGetKeys
(
)
)
{
result
=
STATUS_OK
;
}
else
{
result
=
LOGIN_FAILED_LOGIN_REJECTED
;
}
log
.
debug
(
"
unlockAndVerifyAuthState
re
-
fetched
credentials
and
is
returning
"
result
)
;
return
result
;
}
_hasValidToken
(
)
{
if
(
IGNORE_CACHED_AUTH_CREDENTIALS
)
{
return
false
;
}
if
(
!
this
.
_token
)
{
return
false
;
}
if
(
this
.
_token
.
expiration
<
this
.
_now
(
)
)
{
return
false
;
}
return
true
;
}
get
_tokenServerUrl
(
)
{
let
url
=
Svc
.
Prefs
.
get
(
"
tokenServerURI
"
)
;
if
(
!
url
)
{
url
=
Services
.
prefs
.
getCharPref
(
"
identity
.
sync
.
tokenserver
.
uri
"
)
;
}
while
(
url
.
endsWith
(
"
/
"
)
)
{
url
=
url
.
slice
(
0
-
1
)
;
}
return
url
;
}
async
_fetchTokenForUser
(
)
{
const
fxa
=
this
.
_fxaService
;
if
(
!
(
await
fxa
.
keys
.
canGetKeys
(
)
)
)
{
this
.
_log
.
info
(
"
Unable
to
fetch
keys
(
master
-
password
locked
?
)
so
aborting
token
fetch
"
)
;
throw
new
Error
(
"
Can
'
t
fetch
a
token
as
we
can
'
t
get
keys
"
)
;
}
let
getToken
=
async
keys
=
>
{
this
.
_log
.
info
(
"
Getting
an
assertion
from
"
this
.
_tokenServerUrl
)
;
const
audience
=
Services
.
io
.
newURI
(
this
.
_tokenServerUrl
)
.
prePath
;
const
assertion
=
await
fxa
.
_internal
.
getAssertion
(
audience
)
;
this
.
_log
.
debug
(
"
Getting
a
token
"
)
;
const
headers
=
{
"
X
-
Client
-
State
"
:
keys
.
kXCS
}
;
const
token
=
await
this
.
_tokenServerClient
.
getTokenFromBrowserIDAssertion
(
this
.
_tokenServerUrl
assertion
headers
)
;
this
.
_log
.
trace
(
"
Successfully
got
a
token
"
)
;
return
token
;
}
;
try
{
let
token
;
let
keys
;
try
{
this
.
_log
.
info
(
"
Getting
keys
"
)
;
keys
=
await
fxa
.
keys
.
getKeys
(
)
;
token
=
await
getToken
(
keys
)
;
}
catch
(
err
)
{
if
(
!
err
.
response
|
|
err
.
response
.
status
!
=
=
401
)
{
throw
err
;
}
this
.
_log
.
warn
(
"
Token
server
returned
401
refreshing
certificate
and
retrying
token
fetch
"
)
;
await
fxa
.
_internal
.
invalidateCertificate
(
)
;
keys
=
await
fxa
.
keys
.
getKeys
(
)
;
token
=
await
getToken
(
keys
)
;
}
token
.
expiration
=
this
.
_now
(
)
+
token
.
duration
*
1000
*
0
.
8
;
if
(
!
this
.
_syncKeyBundle
)
{
this
.
_syncKeyBundle
=
BulkKeyBundle
.
fromHexKey
(
keys
.
kSync
)
;
}
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
this
.
_token
=
token
;
return
token
;
}
catch
(
caughtErr
)
{
let
err
=
caughtErr
;
if
(
err
.
response
&
&
err
.
response
.
status
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
tokenserver
"
)
;
}
else
if
(
err
.
code
&
&
err
.
code
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
hawkclient
"
)
;
}
else
if
(
err
.
message
=
=
fxAccountsCommon
.
ERROR_AUTH_ERROR
)
{
err
=
new
AuthenticationError
(
err
"
fxaccounts
"
)
;
}
if
(
err
instanceof
AuthenticationError
)
{
this
.
_log
.
error
(
"
Authentication
error
in
_fetchTokenForUser
"
err
)
;
Weave
.
Status
.
login
=
LOGIN_FAILED_LOGIN_REJECTED
;
}
else
{
this
.
_log
.
error
(
"
Non
-
authentication
error
in
_fetchTokenForUser
"
err
)
;
Weave
.
Status
.
login
=
LOGIN_FAILED_NETWORK_ERROR
;
}
throw
err
;
}
}
async
_ensureValidToken
(
forceNewToken
=
false
)
{
let
signedInUser
=
await
this
.
getSignedInUser
(
)
;
if
(
!
signedInUser
)
{
throw
new
Error
(
"
no
user
is
logged
in
"
)
;
}
if
(
!
signedInUser
.
verified
)
{
throw
new
Error
(
"
user
is
not
verified
"
)
;
}
await
this
.
asyncObserver
.
promiseObserversComplete
(
)
;
if
(
!
forceNewToken
&
&
this
.
_hasValidToken
(
)
)
{
this
.
_log
.
trace
(
"
_ensureValidToken
already
has
one
"
)
;
return
this
.
_token
;
}
if
(
!
this
.
_ensureValidTokenPromise
)
{
this
.
_ensureValidTokenPromise
=
this
.
__ensureValidToken
(
)
.
finally
(
(
)
=
>
{
this
.
_ensureValidTokenPromise
=
null
;
}
)
;
}
return
this
.
_ensureValidTokenPromise
;
}
async
__ensureValidToken
(
)
{
this
.
_token
=
null
;
try
{
let
token
=
await
this
.
_fetchTokenForUser
(
)
;
this
.
_token
=
token
;
this
.
_hashedUID
=
token
.
hashed_fxa_uid
;
return
token
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
login
:
change
"
)
;
}
}
getResourceAuthenticator
(
)
{
return
this
.
_getAuthenticationHeader
.
bind
(
this
)
;
}
async
_getAuthenticationHeader
(
httpObject
method
)
{
try
{
await
this
.
_ensureValidToken
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
Failed
to
fetch
a
token
for
authentication
"
ex
)
;
return
null
;
}
if
(
!
this
.
_token
)
{
return
null
;
}
let
credentials
=
{
id
:
this
.
_token
.
id
key
:
this
.
_token
.
key
}
;
method
=
method
|
|
httpObject
.
method
;
let
options
=
{
now
:
this
.
_now
(
)
localtimeOffsetMsec
:
this
.
_localtimeOffsetMsec
credentials
}
;
let
headerValue
=
await
CryptoUtils
.
computeHAWK
(
httpObject
.
uri
method
options
)
;
return
{
headers
:
{
authorization
:
headerValue
.
field
}
}
;
}
async
setCluster
(
)
{
let
cluster
=
await
this
.
_findCluster
(
)
;
this
.
_log
.
debug
(
"
Cluster
value
=
"
+
cluster
)
;
if
(
cluster
=
=
null
)
{
return
false
;
}
cluster
=
cluster
.
toString
(
)
;
if
(
cluster
=
=
Weave
.
Service
.
clusterURL
)
{
return
false
;
}
this
.
_log
.
debug
(
"
Setting
cluster
to
"
+
cluster
)
;
Weave
.
Service
.
clusterURL
=
cluster
;
return
true
;
}
async
_findCluster
(
)
{
try
{
let
forceNewToken
=
false
;
if
(
Weave
.
Service
.
clusterURL
)
{
this
.
_log
.
debug
(
"
_findCluster
has
a
pre
-
existing
clusterURL
so
fetching
a
new
token
token
"
)
;
forceNewToken
=
true
;
}
let
token
=
await
this
.
_ensureValidToken
(
forceNewToken
)
;
let
endpoint
=
token
.
endpoint
;
if
(
!
endpoint
.
endsWith
(
"
/
"
)
)
{
endpoint
+
=
"
/
"
;
}
this
.
_log
.
debug
(
"
_findCluster
returning
"
+
endpoint
)
;
return
endpoint
;
}
catch
(
err
)
{
this
.
_log
.
info
(
"
Failed
to
fetch
the
cluster
URL
"
err
)
;
if
(
err
instanceof
AuthenticationError
)
{
return
null
;
}
throw
err
;
}
}
}
;
