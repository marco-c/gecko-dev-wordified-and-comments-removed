"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
BrowserIDManager
"
"
AuthenticationError
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
fxAccounts
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
const
{
Async
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
const
{
TokenServerClient
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
tokenserverclient
.
js
"
)
;
const
{
CryptoUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
crypto
/
utils
.
js
"
)
;
const
{
Svc
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
LOGIN_FAILED_LOGIN_REJECTED
LOGIN_FAILED_NETWORK_ERROR
LOGIN_FAILED_NO_USERNAME
LOGIN_SUCCEEDED
MASTER_PASSWORD_LOCKED
STATUS_OK
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
constants
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Weave
"
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
BulkKeyBundle
"
"
resource
:
/
/
services
-
sync
/
keys
.
js
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
fxAccounts
"
"
resource
:
/
/
gre
/
modules
/
FxAccounts
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
log
"
function
(
)
{
let
log
=
Log
.
repository
.
getLogger
(
"
Sync
.
BrowserIDManager
"
)
;
log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
identity
"
)
;
return
log
;
}
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
IGNORE_CACHED_AUTH_CREDENTIALS
"
"
services
.
sync
.
debug
.
ignoreCachedAuthCredentials
"
)
;
var
fxAccountsCommon
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FxAccountsCommon
.
js
"
fxAccountsCommon
)
;
const
OBSERVER_TOPICS
=
[
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
fxAccountsCommon
.
ONVERIFIED_NOTIFICATION
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
]
;
var
telemetryHelper
=
{
STATES
:
{
SUCCESS
:
"
SUCCESS
"
NOTVERIFIED
:
"
NOTVERIFIED
"
REJECTED
:
"
REJECTED
"
}
PREFS
:
{
REJECTED_AT
:
"
identity
.
telemetry
.
loginRejectedAt
"
APPEARS_PERMANENTLY_REJECTED
:
"
identity
.
telemetry
.
loginAppearsPermanentlyRejected
"
LAST_RECORDED_STATE
:
"
identity
.
telemetry
.
lastRecordedState
"
}
NUM_MINUTES_TO_RECORD_REJECTED_TELEMETRY
:
20160
SCALAR
:
"
services
.
sync
.
sync_login_state_transitions
"
maybeRecordLoginState
(
status
)
{
try
{
this
.
_maybeRecordLoginState
(
status
)
;
}
catch
(
ex
)
{
log
.
error
(
"
Failed
to
record
login
telemetry
"
ex
)
;
}
}
_maybeRecordLoginState
(
status
)
{
let
key
=
this
.
STATES
[
status
]
;
if
(
!
key
)
{
throw
new
Error
(
invalid
state
{
status
}
)
;
}
let
when
=
Svc
.
Prefs
.
get
(
this
.
PREFS
.
REJECTED_AT
)
;
let
howLong
=
when
?
this
.
nowInMinutes
(
)
-
when
:
0
;
let
isNewState
=
Svc
.
Prefs
.
get
(
this
.
PREFS
.
LAST_RECORDED_STATE
)
!
=
status
;
if
(
status
=
=
this
.
STATES
.
SUCCESS
)
{
if
(
isNewState
)
{
Services
.
telemetry
.
keyedScalarSet
(
this
.
SCALAR
key
true
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
LAST_RECORDED_STATE
status
)
;
}
if
(
when
)
{
if
(
!
Svc
.
Prefs
.
get
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
)
{
Services
.
telemetry
.
getHistogramById
(
"
WEAVE_LOGIN_FAILED_FOR
"
)
.
add
(
howLong
)
;
}
}
Svc
.
Prefs
.
reset
(
this
.
PREFS
.
REJECTED_AT
)
;
Svc
.
Prefs
.
reset
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
;
}
else
{
if
(
Svc
.
Prefs
.
get
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
)
)
{
return
;
}
if
(
isNewState
)
{
Services
.
telemetry
.
keyedScalarSet
(
this
.
SCALAR
key
true
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
LAST_RECORDED_STATE
status
)
;
}
if
(
howLong
>
this
.
NUM_MINUTES_TO_RECORD_REJECTED_TELEMETRY
)
{
Services
.
telemetry
.
getHistogramById
(
"
WEAVE_LOGIN_FAILED_FOR
"
)
.
add
(
howLong
)
;
Svc
.
Prefs
.
set
(
this
.
PREFS
.
APPEARS_PERMANENTLY_REJECTED
true
)
;
}
if
(
!
Svc
.
Prefs
.
has
(
this
.
PREFS
.
REJECTED_AT
)
)
{
Svc
.
Prefs
.
set
(
this
.
PREFS
.
REJECTED_AT
this
.
nowInMinutes
(
)
)
;
}
}
}
nowInMinutes
(
)
{
return
Math
.
floor
(
Date
.
now
(
)
/
1000
/
60
)
;
}
}
;
function
AuthenticationError
(
details
source
)
{
this
.
details
=
details
;
this
.
source
=
source
;
}
AuthenticationError
.
prototype
=
{
toString
(
)
{
return
"
AuthenticationError
(
"
+
this
.
details
+
"
)
"
;
}
}
;
function
BrowserIDManager
(
)
{
this
.
_fxaService
=
fxAccounts
;
this
.
_tokenServerClient
=
new
TokenServerClient
(
)
;
this
.
_tokenServerClient
.
observerPrefix
=
"
weave
:
service
"
;
this
.
_log
=
log
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
_username
"
"
services
.
sync
.
username
"
)
;
this
.
asyncObserver
=
Async
.
asyncObserver
(
this
log
)
;
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
addObserver
(
this
.
asyncObserver
topic
)
;
}
}
this
.
BrowserIDManager
.
prototype
=
{
_fxaService
:
null
_tokenServerClient
:
null
_token
:
null
_signedInUser
:
null
hashedUID
(
)
{
if
(
!
this
.
_hashedUID
)
{
throw
new
Error
(
"
hashedUID
:
Don
'
t
seem
to
have
previously
seen
a
token
"
)
;
}
return
this
.
_hashedUID
;
}
hashedDeviceID
(
deviceID
)
{
let
uid
=
this
.
hashedUID
(
)
;
return
Utils
.
sha256
(
deviceID
+
uid
)
;
}
finalize
(
)
{
for
(
let
topic
of
OBSERVER_TOPICS
)
{
Services
.
obs
.
removeObserver
(
this
.
asyncObserver
topic
)
;
}
this
.
resetCredentials
(
)
;
this
.
_signedInUser
=
null
;
}
_updateSignedInUser
(
userData
)
{
if
(
this
.
_signedInUser
&
&
this
.
_signedInUser
.
uid
!
=
userData
.
uid
)
{
throw
new
Error
(
"
Attempting
to
update
to
a
different
user
.
"
)
;
}
this
.
_signedInUser
=
userData
;
}
logout
(
)
{
this
.
_token
=
null
;
}
async
observe
(
subject
topic
data
)
{
this
.
_log
.
debug
(
"
observed
"
+
topic
)
;
switch
(
topic
)
{
case
fxAccountsCommon
.
ONLOGIN_NOTIFICATION
:
{
this
.
_log
.
info
(
"
A
user
has
logged
in
"
)
;
this
.
resetCredentials
(
)
;
let
accountData
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
this
.
_updateSignedInUser
(
accountData
)
;
if
(
!
accountData
.
verified
)
{
this
.
_log
.
info
(
"
The
user
is
not
verified
"
)
;
break
;
}
}
case
fxAccountsCommon
.
ONVERIFIED_NOTIFICATION
:
{
this
.
_log
.
info
(
"
The
user
became
verified
"
)
;
let
accountData
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
this
.
username
=
accountData
.
email
;
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
let
isFirstSync
=
!
Weave
.
Service
.
locked
&
&
!
Svc
.
Prefs
.
get
(
"
client
.
syncID
"
null
)
;
if
(
isFirstSync
)
{
this
.
_log
.
info
(
"
Doing
initial
sync
actions
"
)
;
Svc
.
Prefs
.
set
(
"
firstSync
"
"
resetClient
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
setup
-
complete
"
)
;
}
if
(
!
Svc
.
Prefs
.
get
(
"
testing
.
tps
"
false
)
)
{
Weave
.
Service
.
sync
(
{
why
:
"
login
"
}
)
;
}
break
;
}
case
fxAccountsCommon
.
ONLOGOUT_NOTIFICATION
:
Weave
.
Service
.
startOver
(
)
.
then
(
(
)
=
>
{
this
.
_log
.
trace
(
"
startOver
completed
"
)
;
}
)
.
catch
(
err
=
>
{
this
.
_log
.
warn
(
"
Failed
to
reset
sync
"
err
)
;
}
)
;
break
;
case
fxAccountsCommon
.
ON_ACCOUNT_STATE_CHANGE_NOTIFICATION
:
this
.
resetCredentials
(
)
;
break
;
}
}
_now
(
)
{
return
this
.
_fxaService
.
now
(
)
;
}
get
_localtimeOffsetMsec
(
)
{
return
this
.
_fxaService
.
localtimeOffsetMsec
;
}
get
syncKeyBundle
(
)
{
return
this
.
_syncKeyBundle
;
}
get
username
(
)
{
return
this
.
_username
;
}
set
username
(
value
)
{
if
(
value
)
{
value
=
value
.
toLowerCase
(
)
;
if
(
value
=
=
this
.
username
)
{
return
;
}
Svc
.
Prefs
.
set
(
"
username
"
value
)
;
}
else
{
Svc
.
Prefs
.
reset
(
"
username
"
)
;
}
this
.
_log
.
info
(
"
Username
changed
.
Removing
stored
credentials
.
"
)
;
this
.
resetCredentials
(
)
;
}
resetCredentials
(
)
{
this
.
_syncKeyBundle
=
null
;
this
.
_token
=
null
;
this
.
_hashedUID
=
null
;
Weave
.
Service
.
clusterURL
=
null
;
}
prefetchMigrationSentinel
(
service
)
{
}
deleteSyncCredentials
(
)
{
for
(
let
host
of
Utils
.
getSyncCredentialsHosts
(
)
)
{
let
logins
=
Services
.
logins
.
findLogins
(
{
}
host
"
"
"
"
)
;
for
(
let
login
of
logins
)
{
Services
.
logins
.
removeLogin
(
login
)
;
}
}
}
async
unlockAndVerifyAuthState
(
)
{
let
data
=
await
this
.
_fxaService
.
getSignedInUser
(
)
;
if
(
!
data
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
has
no
user
"
)
;
return
LOGIN_FAILED_NO_USERNAME
;
}
if
(
!
data
.
verified
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
has
an
unverified
user
"
)
;
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
NOTVERIFIED
)
;
return
LOGIN_FAILED_LOGIN_REJECTED
;
}
this
.
_updateSignedInUser
(
data
)
;
if
(
(
await
this
.
_fxaService
.
canGetKeys
(
)
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
already
has
(
or
can
fetch
)
sync
keys
"
)
;
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
SUCCESS
)
;
return
STATUS_OK
;
}
if
(
!
Utils
.
ensureMPUnlocked
(
)
)
{
log
.
debug
(
"
unlockAndVerifyAuthState
:
user
declined
to
unlock
master
-
password
"
)
;
return
MASTER_PASSWORD_LOCKED
;
}
this
.
_updateSignedInUser
(
await
this
.
_fxaService
.
getSignedInUser
(
)
)
;
let
result
;
if
(
(
await
this
.
_fxaService
.
canGetKeys
(
)
)
)
{
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
SUCCESS
)
;
result
=
STATUS_OK
;
}
else
{
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
REJECTED
)
;
result
=
LOGIN_FAILED_LOGIN_REJECTED
;
}
log
.
debug
(
"
unlockAndVerifyAuthState
re
-
fetched
credentials
and
is
returning
"
result
)
;
return
result
;
}
_hasValidToken
(
)
{
if
(
IGNORE_CACHED_AUTH_CREDENTIALS
)
{
return
false
;
}
if
(
!
this
.
_token
)
{
return
false
;
}
if
(
this
.
_token
.
expiration
<
this
.
_now
(
)
)
{
return
false
;
}
return
true
;
}
get
_tokenServerUrl
(
)
{
let
url
=
Svc
.
Prefs
.
get
(
"
tokenServerURI
"
)
;
if
(
!
url
)
{
url
=
Services
.
prefs
.
getCharPref
(
"
identity
.
sync
.
tokenserver
.
uri
"
)
;
}
while
(
url
.
endsWith
(
"
/
"
)
)
{
url
=
url
.
slice
(
0
-
1
)
;
}
return
url
;
}
async
_fetchTokenForUser
(
)
{
if
(
!
this
.
_signedInUser
.
verified
)
{
throw
new
Error
(
"
User
is
not
verified
"
)
;
}
if
(
!
(
await
this
.
_fxaService
.
canGetKeys
(
)
)
)
{
this
.
_log
.
info
(
"
Unable
to
fetch
keys
(
master
-
password
locked
?
)
so
aborting
token
fetch
"
)
;
throw
new
Error
(
"
Can
'
t
fetch
a
token
as
we
can
'
t
get
keys
"
)
;
}
let
getToken
=
async
(
)
=
>
{
this
.
_log
.
info
(
"
Getting
an
assertion
from
"
this
.
_tokenServerUrl
)
;
const
audience
=
Services
.
io
.
newURI
(
this
.
_tokenServerUrl
)
.
prePath
;
const
assertion
=
await
this
.
_fxaService
.
getAssertion
(
audience
)
;
this
.
_log
.
debug
(
"
Getting
a
token
"
)
;
const
headers
=
{
"
X
-
Client
-
State
"
:
this
.
_signedInUser
.
kXCS
}
;
const
token
=
await
this
.
_tokenServerClient
.
getTokenFromBrowserIDAssertion
(
this
.
_tokenServerUrl
assertion
headers
)
;
this
.
_log
.
trace
(
"
Successfully
got
a
token
"
)
;
return
token
;
}
;
let
token
;
try
{
try
{
this
.
_log
.
info
(
"
Getting
keys
"
)
;
this
.
_updateSignedInUser
(
await
this
.
_fxaService
.
getKeys
(
)
)
;
token
=
await
getToken
(
)
;
}
catch
(
err
)
{
if
(
!
err
.
response
|
|
err
.
response
.
status
!
=
=
401
)
{
throw
err
;
}
this
.
_log
.
warn
(
"
Token
server
returned
401
refreshing
certificate
and
retrying
token
fetch
"
)
;
await
this
.
_fxaService
.
invalidateCertificate
(
)
;
token
=
await
getToken
(
)
;
}
token
.
expiration
=
this
.
_now
(
)
+
(
token
.
duration
*
1000
)
*
0
.
80
;
if
(
!
this
.
_syncKeyBundle
)
{
this
.
_syncKeyBundle
=
BulkKeyBundle
.
fromHexKey
(
this
.
_signedInUser
.
kSync
)
;
}
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
SUCCESS
)
;
Weave
.
Status
.
login
=
LOGIN_SUCCEEDED
;
this
.
_token
=
token
;
return
token
;
}
catch
(
caughtErr
)
{
let
err
=
caughtErr
;
if
(
err
.
response
&
&
err
.
response
.
status
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
tokenserver
"
)
;
}
else
if
(
err
.
code
&
&
err
.
code
=
=
=
401
)
{
err
=
new
AuthenticationError
(
err
"
hawkclient
"
)
;
}
else
if
(
err
.
message
=
=
fxAccountsCommon
.
ERROR_AUTH_ERROR
)
{
err
=
new
AuthenticationError
(
err
"
fxaccounts
"
)
;
}
if
(
err
instanceof
AuthenticationError
)
{
this
.
_log
.
error
(
"
Authentication
error
in
_fetchTokenForUser
"
err
)
;
Weave
.
Status
.
login
=
LOGIN_FAILED_LOGIN_REJECTED
;
telemetryHelper
.
maybeRecordLoginState
(
telemetryHelper
.
STATES
.
REJECTED
)
;
}
else
{
this
.
_log
.
error
(
"
Non
-
authentication
error
in
_fetchTokenForUser
"
err
)
;
Weave
.
Status
.
login
=
LOGIN_FAILED_NETWORK_ERROR
;
}
throw
err
;
}
}
async
_ensureValidToken
(
forceNewToken
=
false
)
{
if
(
!
this
.
_signedInUser
)
{
throw
new
Error
(
"
no
user
is
logged
in
"
)
;
}
if
(
!
this
.
_signedInUser
.
verified
)
{
throw
new
Error
(
"
user
is
not
verified
"
)
;
}
await
this
.
asyncObserver
.
promiseObserversComplete
(
)
;
if
(
!
forceNewToken
&
&
this
.
_hasValidToken
(
)
)
{
this
.
_log
.
trace
(
"
_ensureValidToken
already
has
one
"
)
;
return
this
.
_token
;
}
if
(
!
this
.
_ensureValidTokenPromise
)
{
this
.
_ensureValidTokenPromise
=
this
.
__ensureValidToken
(
)
.
finally
(
(
)
=
>
{
this
.
_ensureValidTokenPromise
=
null
;
}
)
;
}
return
this
.
_ensureValidTokenPromise
;
}
async
__ensureValidToken
(
)
{
this
.
_token
=
null
;
try
{
let
token
=
await
this
.
_fetchTokenForUser
(
)
;
this
.
_token
=
token
;
this
.
_hashedUID
=
token
.
hashed_fxa_uid
;
return
token
;
}
finally
{
Services
.
obs
.
notifyObservers
(
null
"
weave
:
service
:
login
:
change
"
)
;
}
}
getResourceAuthenticator
(
)
{
return
this
.
_getAuthenticationHeader
.
bind
(
this
)
;
}
async
_getAuthenticationHeader
(
httpObject
method
)
{
try
{
await
this
.
_ensureValidToken
(
)
;
}
catch
(
ex
)
{
this
.
_log
.
error
(
"
Failed
to
fetch
a
token
for
authentication
"
ex
)
;
return
null
;
}
if
(
!
this
.
_token
)
{
return
null
;
}
let
credentials
=
{
id
:
this
.
_token
.
id
key
:
this
.
_token
.
key
}
;
method
=
method
|
|
httpObject
.
method
;
let
options
=
{
now
:
this
.
_now
(
)
localtimeOffsetMsec
:
this
.
_localtimeOffsetMsec
credentials
}
;
let
headerValue
=
await
CryptoUtils
.
computeHAWK
(
httpObject
.
uri
method
options
)
;
return
{
headers
:
{
authorization
:
headerValue
.
field
}
}
;
}
async
setCluster
(
)
{
let
cluster
=
await
this
.
_findCluster
(
)
;
this
.
_log
.
debug
(
"
Cluster
value
=
"
+
cluster
)
;
if
(
cluster
=
=
null
)
{
return
false
;
}
cluster
=
cluster
.
toString
(
)
;
if
(
cluster
=
=
Weave
.
Service
.
clusterURL
)
{
return
false
;
}
this
.
_log
.
debug
(
"
Setting
cluster
to
"
+
cluster
)
;
Weave
.
Service
.
clusterURL
=
cluster
;
return
true
;
}
async
_findCluster
(
)
{
try
{
let
forceNewToken
=
false
;
if
(
Weave
.
Service
.
clusterURL
)
{
this
.
_log
.
debug
(
"
_findCluster
has
a
pre
-
existing
clusterURL
so
fetching
a
new
token
token
"
)
;
forceNewToken
=
true
;
}
let
token
=
await
this
.
_ensureValidToken
(
forceNewToken
)
;
let
endpoint
=
token
.
endpoint
;
if
(
!
endpoint
.
endsWith
(
"
/
"
)
)
{
endpoint
+
=
"
/
"
;
}
this
.
_log
.
debug
(
"
_findCluster
returning
"
+
endpoint
)
;
return
endpoint
;
}
catch
(
err
)
{
this
.
_log
.
info
(
"
Failed
to
fetch
the
cluster
URL
"
err
)
;
if
(
err
instanceof
AuthenticationError
)
{
return
null
;
}
throw
err
;
}
}
}
;
