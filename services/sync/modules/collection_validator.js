"
use
strict
"
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
record
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
services
-
sync
/
main
.
js
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
CollectionValidator
"
"
CollectionProblemData
"
]
;
class
CollectionProblemData
{
constructor
(
)
{
this
.
missingIDs
=
0
;
this
.
duplicates
=
[
]
;
this
.
clientMissing
=
[
]
;
this
.
serverMissing
=
[
]
;
this
.
serverDeleted
=
[
]
;
this
.
serverUnexpected
=
[
]
;
this
.
differences
=
[
]
;
}
getSummary
(
)
{
return
[
{
name
:
"
clientMissing
"
count
:
this
.
clientMissing
.
length
}
{
name
:
"
serverMissing
"
count
:
this
.
serverMissing
.
length
}
{
name
:
"
serverDeleted
"
count
:
this
.
serverDeleted
.
length
}
{
name
:
"
serverUnexpected
"
count
:
this
.
serverUnexpected
.
length
}
{
name
:
"
differences
"
count
:
this
.
differences
.
length
}
{
name
:
"
missingIDs
"
count
:
this
.
missingIDs
}
{
name
:
"
duplicates
"
count
:
this
.
duplicates
.
length
}
]
;
}
}
class
CollectionValidator
{
constructor
(
name
idProp
props
)
{
this
.
name
=
name
;
this
.
props
=
props
;
this
.
idProp
=
idProp
;
}
emptyProblemData
(
)
{
return
new
CollectionProblemData
(
)
;
}
getServerItems
(
engine
)
{
let
collection
=
engine
.
itemSource
(
)
;
let
collectionKey
=
engine
.
service
.
collectionKeys
.
keyForCollection
(
engine
.
name
)
;
collection
.
full
=
true
;
let
items
=
[
]
;
collection
.
recordHandler
=
function
(
item
)
{
item
.
decrypt
(
collectionKey
)
;
items
.
push
(
item
.
cleartext
)
;
}
;
let
resp
=
collection
.
getBatched
(
)
;
if
(
!
resp
.
success
)
{
throw
resp
;
}
return
items
;
}
getClientItems
(
)
{
return
Promise
.
reject
(
"
Must
implement
"
)
;
}
normalizeClientItem
(
item
)
{
return
Cu
.
cloneInto
(
item
{
}
)
;
}
normalizeServerItem
(
item
)
{
return
item
;
}
clientUnderstands
(
item
)
{
return
true
;
}
syncedByClient
(
item
)
{
return
true
;
}
getDifferences
(
client
server
)
{
let
differences
=
[
]
;
for
(
let
prop
of
this
.
props
)
{
let
clientProp
=
client
[
prop
]
;
let
serverProp
=
server
[
prop
]
;
if
(
(
clientProp
|
|
"
"
)
!
=
=
(
serverProp
|
|
"
"
)
)
{
differences
.
push
(
prop
)
;
}
}
return
differences
;
}
compareClientWithServer
(
clientItems
serverItems
)
{
clientItems
=
clientItems
.
map
(
item
=
>
this
.
normalizeClientItem
(
item
)
)
;
serverItems
=
serverItems
.
map
(
item
=
>
this
.
normalizeServerItem
(
item
)
)
;
let
problems
=
this
.
emptyProblemData
(
)
;
let
seenServer
=
new
Map
(
)
;
let
serverDeleted
=
new
Set
(
)
;
let
allRecords
=
new
Map
(
)
;
for
(
let
record
of
serverItems
)
{
let
id
=
record
[
this
.
idProp
]
;
if
(
!
id
)
{
+
+
problems
.
missingIDs
;
continue
;
}
if
(
record
.
deleted
)
{
serverDeleted
.
add
(
record
)
;
}
else
{
let
possibleDupe
=
seenServer
.
get
(
id
)
;
if
(
possibleDupe
)
{
problems
.
duplicates
.
push
(
id
)
;
}
else
{
seenServer
.
set
(
id
record
)
;
allRecords
.
set
(
id
{
server
:
record
client
:
null
}
)
;
}
record
.
understood
=
this
.
clientUnderstands
(
record
)
;
}
}
let
recordPairs
=
[
]
;
let
seenClient
=
new
Map
(
)
;
for
(
let
record
of
clientItems
)
{
let
id
=
record
[
this
.
idProp
]
;
record
.
shouldSync
=
this
.
syncedByClient
(
record
)
;
seenClient
.
set
(
id
record
)
;
let
combined
=
allRecords
.
get
(
id
)
;
if
(
combined
)
{
combined
.
client
=
record
;
}
else
{
allRecords
.
set
(
id
{
client
:
record
server
:
null
}
)
;
}
}
for
(
let
[
id
{
server
client
}
]
of
allRecords
)
{
if
(
!
client
&
&
!
server
)
{
throw
new
Error
(
"
Impossible
:
no
client
or
server
record
for
"
+
id
)
;
}
else
if
(
server
&
&
!
client
)
{
if
(
server
.
understood
)
{
problems
.
clientMissing
.
push
(
id
)
;
}
}
else
if
(
client
&
&
!
server
)
{
if
(
client
.
shouldSync
)
{
problems
.
serverMissing
.
push
(
id
)
;
}
}
else
{
if
(
!
client
.
shouldSync
)
{
if
(
!
problems
.
serverUnexpected
.
includes
(
id
)
)
{
problems
.
serverUnexpected
.
push
(
id
)
;
}
continue
;
}
let
differences
=
this
.
getDifferences
(
client
server
)
;
if
(
differences
&
&
differences
.
length
)
{
problems
.
differences
.
push
(
{
id
differences
}
)
;
}
}
}
return
{
problemData
:
problems
clientRecords
:
clientItems
records
:
serverItems
deletedRecords
:
[
.
.
.
serverDeleted
]
}
;
}
}
