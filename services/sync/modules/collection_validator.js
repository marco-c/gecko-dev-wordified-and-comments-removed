"
use
strict
"
;
ChromeUtils
.
defineModuleGetter
(
this
"
Async
"
"
resource
:
/
/
services
-
common
/
async
.
js
"
)
;
var
EXPORTED_SYMBOLS
=
[
"
CollectionValidator
"
"
CollectionProblemData
"
]
;
class
CollectionProblemData
{
constructor
(
)
{
this
.
missingIDs
=
0
;
this
.
clientDuplicates
=
[
]
;
this
.
duplicates
=
[
]
;
this
.
clientMissing
=
[
]
;
this
.
serverMissing
=
[
]
;
this
.
serverDeleted
=
[
]
;
this
.
serverUnexpected
=
[
]
;
this
.
differences
=
[
]
;
}
getSummary
(
)
{
return
[
{
name
:
"
clientMissing
"
count
:
this
.
clientMissing
.
length
}
{
name
:
"
serverMissing
"
count
:
this
.
serverMissing
.
length
}
{
name
:
"
serverDeleted
"
count
:
this
.
serverDeleted
.
length
}
{
name
:
"
serverUnexpected
"
count
:
this
.
serverUnexpected
.
length
}
{
name
:
"
differences
"
count
:
this
.
differences
.
length
}
{
name
:
"
missingIDs
"
count
:
this
.
missingIDs
}
{
name
:
"
clientDuplicates
"
count
:
this
.
clientDuplicates
.
length
}
{
name
:
"
duplicates
"
count
:
this
.
duplicates
.
length
}
]
;
}
}
class
CollectionValidator
{
constructor
(
name
idProp
props
)
{
this
.
name
=
name
;
this
.
props
=
props
;
this
.
idProp
=
idProp
;
this
.
ignoresMissingClients
=
false
;
}
emptyProblemData
(
)
{
return
new
CollectionProblemData
(
)
;
}
async
getServerItems
(
engine
)
{
let
collection
=
engine
.
itemSource
(
)
;
let
collectionKey
=
engine
.
service
.
collectionKeys
.
keyForCollection
(
engine
.
name
)
;
collection
.
full
=
true
;
let
result
=
await
collection
.
getBatched
(
)
;
if
(
!
result
.
response
.
success
)
{
throw
result
.
response
;
}
let
maybeYield
=
Async
.
jankYielder
(
)
;
let
cleartexts
=
[
]
;
for
(
let
record
of
result
.
records
)
{
await
maybeYield
(
)
;
await
record
.
decrypt
(
collectionKey
)
;
cleartexts
.
push
(
record
.
cleartext
)
;
}
return
cleartexts
;
}
getClientItems
(
)
{
return
Promise
.
reject
(
"
Must
implement
"
)
;
}
async
canValidate
(
)
{
return
true
;
}
normalizeClientItem
(
item
)
{
return
Cu
.
cloneInto
(
item
{
}
)
;
}
async
normalizeServerItem
(
item
)
{
return
item
;
}
clientUnderstands
(
item
)
{
return
true
;
}
async
syncedByClient
(
item
)
{
return
true
;
}
getDifferences
(
client
server
)
{
let
differences
=
[
]
;
for
(
let
prop
of
this
.
props
)
{
let
clientProp
=
client
[
prop
]
;
let
serverProp
=
server
[
prop
]
;
if
(
(
clientProp
|
|
"
"
)
!
=
=
(
serverProp
|
|
"
"
)
)
{
differences
.
push
(
prop
)
;
}
}
return
differences
;
}
async
compareClientWithServer
(
clientItems
serverItems
)
{
let
maybeYield
=
Async
.
jankYielder
(
)
;
const
clientRecords
=
[
]
;
for
(
let
item
of
clientItems
)
{
await
maybeYield
(
)
;
clientRecords
.
push
(
this
.
normalizeClientItem
(
item
)
)
;
}
const
serverRecords
=
[
]
;
for
(
let
item
of
serverItems
)
{
await
maybeYield
(
)
;
serverRecords
.
push
(
(
await
this
.
normalizeServerItem
(
item
)
)
)
;
}
let
problems
=
this
.
emptyProblemData
(
)
;
let
seenServer
=
new
Map
(
)
;
let
serverDeleted
=
new
Set
(
)
;
let
allRecords
=
new
Map
(
)
;
for
(
let
record
of
serverRecords
)
{
let
id
=
record
[
this
.
idProp
]
;
if
(
!
id
)
{
+
+
problems
.
missingIDs
;
continue
;
}
if
(
record
.
deleted
)
{
serverDeleted
.
add
(
record
)
;
}
else
{
let
serverHasPossibleDupe
=
seenServer
.
has
(
id
)
;
if
(
serverHasPossibleDupe
)
{
problems
.
duplicates
.
push
(
id
)
;
}
else
{
seenServer
.
set
(
id
record
)
;
allRecords
.
set
(
id
{
server
:
record
client
:
null
}
)
;
}
record
.
understood
=
this
.
clientUnderstands
(
record
)
;
}
}
let
seenClient
=
new
Map
(
)
;
for
(
let
record
of
clientRecords
)
{
let
id
=
record
[
this
.
idProp
]
;
record
.
shouldSync
=
await
this
.
syncedByClient
(
record
)
;
let
clientHasPossibleDupe
=
seenClient
.
has
(
id
)
;
if
(
clientHasPossibleDupe
&
&
record
.
shouldSync
)
{
problems
.
clientDuplicates
.
push
(
id
)
;
continue
;
}
seenClient
.
set
(
id
record
)
;
let
combined
=
allRecords
.
get
(
id
)
;
if
(
combined
)
{
combined
.
client
=
record
;
}
else
{
allRecords
.
set
(
id
{
client
:
record
server
:
null
}
)
;
}
}
for
(
let
[
id
{
server
client
}
]
of
allRecords
)
{
if
(
!
client
&
&
!
server
)
{
throw
new
Error
(
"
Impossible
:
no
client
or
server
record
for
"
+
id
)
;
}
else
if
(
server
&
&
!
client
)
{
if
(
!
this
.
ignoresMissingClients
&
&
server
.
understood
)
{
problems
.
clientMissing
.
push
(
id
)
;
}
}
else
if
(
client
&
&
!
server
)
{
if
(
client
.
shouldSync
)
{
problems
.
serverMissing
.
push
(
id
)
;
}
}
else
{
if
(
!
client
.
shouldSync
)
{
if
(
!
problems
.
serverUnexpected
.
includes
(
id
)
)
{
problems
.
serverUnexpected
.
push
(
id
)
;
}
continue
;
}
let
differences
=
this
.
getDifferences
(
client
server
)
;
if
(
differences
&
&
differences
.
length
)
{
problems
.
differences
.
push
(
{
id
differences
}
)
;
}
}
}
return
{
problemData
:
problems
clientRecords
records
:
serverRecords
deletedRecords
:
[
.
.
.
serverDeleted
]
}
;
}
async
validate
(
engine
)
{
let
start
=
Cu
.
now
(
)
;
let
clientItems
=
await
this
.
getClientItems
(
)
;
let
serverItems
=
await
this
.
getServerItems
(
engine
)
;
let
serverRecordCount
=
serverItems
.
length
;
let
result
=
await
this
.
compareClientWithServer
(
clientItems
serverItems
)
;
let
end
=
Cu
.
now
(
)
;
let
duration
=
end
-
start
;
engine
.
_log
.
debug
(
Validated
{
this
.
name
}
in
{
duration
}
ms
)
;
engine
.
_log
.
debug
(
Problem
summary
)
;
for
(
let
{
name
count
}
of
result
.
problemData
.
getSummary
(
)
)
{
engine
.
_log
.
debug
(
{
name
}
:
{
count
}
)
;
}
return
{
duration
version
:
this
.
version
problems
:
result
.
problemData
recordCount
:
serverRecordCount
}
;
}
}
CollectionValidator
.
prototype
.
version
=
0
;
