var
EXPORTED_SYMBOLS
=
[
"
Resource
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Log
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
{
Observers
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
observers
.
js
"
)
;
const
{
CommonUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
common
/
utils
.
js
"
)
;
const
{
Utils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
services
-
sync
/
util
.
js
"
)
;
const
{
setTimeout
clearTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGlobalGetters
(
this
[
"
fetch
"
"
Headers
"
"
Request
"
]
)
;
function
Resource
(
uri
)
{
this
.
_log
=
Log
.
repository
.
getLogger
(
this
.
_logName
)
;
this
.
_log
.
manageLevelFromPref
(
"
services
.
sync
.
log
.
logger
.
network
.
resources
"
)
;
this
.
uri
=
uri
;
this
.
_headers
=
{
}
;
}
Resource
.
serverTime
=
null
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
Resource
"
SEND_VERSION_INFO
"
"
services
.
sync
.
sendVersionInfo
"
true
)
;
Resource
.
prototype
=
{
_logName
:
"
Sync
.
Resource
"
authenticator
:
null
ABORT_TIMEOUT
:
300000
get
headers
(
)
{
return
this
.
_headers
;
}
set
headers
(
_
)
{
throw
new
Error
(
"
headers
can
'
t
be
mutated
directly
.
Please
use
setHeader
.
"
)
;
}
setHeader
(
header
value
)
{
this
.
_headers
[
header
.
toLowerCase
(
)
]
=
value
;
}
get
uri
(
)
{
return
this
.
_uri
;
}
set
uri
(
value
)
{
if
(
typeof
value
=
=
"
string
"
)
{
this
.
_uri
=
CommonUtils
.
makeURI
(
value
)
;
}
else
{
this
.
_uri
=
value
;
}
}
get
spec
(
)
{
if
(
this
.
_uri
)
{
return
this
.
_uri
.
spec
;
}
return
null
;
}
async
_buildHeaders
(
method
)
{
const
headers
=
new
Headers
(
this
.
_headers
)
;
if
(
Resource
.
SEND_VERSION_INFO
)
{
headers
.
append
(
"
user
-
agent
"
Utils
.
userAgent
)
;
}
if
(
this
.
authenticator
)
{
const
result
=
await
this
.
authenticator
(
this
method
)
;
if
(
result
&
&
result
.
headers
)
{
for
(
const
[
k
v
]
of
Object
.
entries
(
result
.
headers
)
)
{
headers
.
append
(
k
.
toLowerCase
(
)
v
)
;
}
}
}
else
{
this
.
_log
.
debug
(
"
No
authenticator
found
.
"
)
;
}
if
(
(
"
PUT
"
=
=
method
|
|
"
POST
"
=
=
method
)
&
&
!
headers
.
has
(
"
content
-
type
"
)
)
{
headers
.
append
(
"
content
-
type
"
"
text
/
plain
"
)
;
}
if
(
this
.
_log
.
level
<
=
Log
.
Level
.
Trace
)
{
for
(
const
[
k
v
]
of
headers
)
{
if
(
k
=
=
"
authorization
"
|
|
k
=
=
"
x
-
client
-
state
"
)
{
this
.
_log
.
trace
(
HTTP
Header
{
k
}
:
*
*
*
*
*
(
suppressed
)
)
;
}
else
{
this
.
_log
.
trace
(
HTTP
Header
{
k
}
:
{
v
}
)
;
}
}
}
if
(
!
headers
.
has
(
"
accept
"
)
)
{
headers
.
append
(
"
accept
"
"
application
/
json
;
q
=
0
.
9
*
/
*
;
q
=
0
.
2
"
)
;
}
return
headers
;
}
async
_createRequest
(
method
data
signal
)
{
const
headers
=
await
this
.
_buildHeaders
(
method
)
;
const
init
=
{
cache
:
"
no
-
store
"
headers
method
signal
mozErrors
:
true
}
;
if
(
data
)
{
if
(
!
(
typeof
data
=
=
"
string
"
|
|
data
instanceof
String
)
)
{
data
=
JSON
.
stringify
(
data
)
;
}
this
.
_log
.
debug
(
{
method
}
Length
:
{
data
.
length
}
)
;
this
.
_log
.
trace
(
{
method
}
Body
:
{
data
}
)
;
init
.
body
=
data
;
}
return
new
Request
(
this
.
uri
.
spec
init
)
;
}
async
_doRequest
(
method
data
=
null
)
{
const
controller
=
new
AbortController
(
)
;
const
request
=
await
this
.
_createRequest
(
method
data
controller
.
signal
)
;
const
responsePromise
=
fetch
(
request
)
;
let
didTimeout
=
false
;
const
timeoutId
=
setTimeout
(
(
)
=
>
{
didTimeout
=
true
;
this
.
_log
.
error
(
Request
timed
out
after
{
this
.
ABORT_TIMEOUT
}
ms
.
Aborting
.
)
;
controller
.
abort
(
)
;
}
this
.
ABORT_TIMEOUT
)
;
let
response
;
try
{
response
=
await
responsePromise
;
}
catch
(
e
)
{
this
.
_log
.
warn
(
{
method
}
request
to
{
this
.
uri
.
spec
}
failed
e
)
;
if
(
!
didTimeout
)
{
throw
e
;
}
throw
Components
.
Exception
(
"
Request
aborted
(
timeout
)
"
Cr
.
NS_ERROR_NET_TIMEOUT
)
;
}
finally
{
clearTimeout
(
timeoutId
)
;
}
return
this
.
_processResponse
(
response
method
)
;
}
async
_processResponse
(
response
method
)
{
const
data
=
await
response
.
text
(
)
;
this
.
_logResponse
(
response
method
data
)
;
this
.
_processResponseHeaders
(
response
)
;
const
ret
=
{
data
url
:
response
.
url
status
:
response
.
status
success
:
response
.
ok
headers
:
{
}
}
;
for
(
const
[
k
v
]
of
response
.
headers
)
{
ret
.
headers
[
k
]
=
v
;
}
XPCOMUtils
.
defineLazyGetter
(
ret
"
obj
"
(
)
=
>
{
try
{
return
JSON
.
parse
(
ret
.
data
)
;
}
catch
(
ex
)
{
this
.
_log
.
warn
(
"
Got
exception
parsing
response
body
"
ex
)
;
this
.
_log
.
debug
(
"
Parse
fail
:
Response
body
starts
"
(
ret
.
data
+
"
"
)
.
slice
(
0
100
)
)
;
throw
ex
;
}
}
)
;
return
ret
;
}
_logResponse
(
response
method
data
)
{
const
{
status
ok
:
success
url
}
=
response
;
this
.
_log
.
debug
(
{
method
}
{
success
?
"
success
"
:
"
fail
"
}
{
status
}
{
url
}
)
;
if
(
this
.
_log
.
level
<
=
Log
.
Level
.
Trace
)
{
this
.
_log
.
trace
(
{
method
}
body
data
)
;
}
if
(
!
success
)
{
this
.
_log
.
warn
(
{
method
}
request
to
{
url
}
failed
with
status
{
status
}
)
;
}
}
_processResponseHeaders
(
{
headers
ok
:
success
}
)
{
if
(
headers
.
has
(
"
x
-
weave
-
timestamp
"
)
)
{
Resource
.
serverTime
=
parseFloat
(
headers
.
get
(
"
x
-
weave
-
timestamp
"
)
)
;
}
if
(
headers
.
has
(
"
x
-
weave
-
backoff
"
)
)
{
let
backoff
=
headers
.
get
(
"
x
-
weave
-
backoff
"
)
;
this
.
_log
.
debug
(
Got
X
-
Weave
-
Backoff
:
{
backoff
}
)
;
Observers
.
notify
(
"
weave
:
service
:
backoff
:
interval
"
parseInt
(
backoff
10
)
)
;
}
if
(
success
&
&
headers
.
has
(
"
x
-
weave
-
quota
-
remaining
"
)
)
{
Observers
.
notify
(
"
weave
:
service
:
quota
:
remaining
"
parseInt
(
headers
.
get
(
"
x
-
weave
-
quota
-
remaining
"
)
10
)
)
;
}
}
get
(
)
{
return
this
.
_doRequest
(
"
GET
"
)
;
}
put
(
data
)
{
return
this
.
_doRequest
(
"
PUT
"
data
)
;
}
post
(
data
)
{
return
this
.
_doRequest
(
"
POST
"
data
)
;
}
delete
(
)
{
return
this
.
_doRequest
(
"
DELETE
"
)
;
}
}
;
