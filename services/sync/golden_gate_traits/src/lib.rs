use
std
:
:
{
error
:
:
Error
fmt
sync
:
:
Mutex
sync
:
:
MutexGuard
sync
:
:
PoisonError
}
;
pub
trait
BridgedEngine
{
type
Error
;
fn
initialize
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
fn
last_sync
(
&
self
)
-
>
Result
<
i64
Self
:
:
Error
>
;
fn
set_last_sync
(
&
self
last_sync_millis
:
i64
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
sync_id
(
&
self
)
-
>
Result
<
Option
<
String
>
Self
:
:
Error
>
;
fn
reset_sync_id
(
&
self
)
-
>
Result
<
String
Self
:
:
Error
>
;
fn
ensure_current_sync_id
(
&
self
new_sync_id
:
&
str
)
-
>
Result
<
String
Self
:
:
Error
>
;
fn
store_incoming
(
&
self
incoming_cleartexts
:
&
[
String
]
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
apply
(
&
self
signal
:
&
dyn
Interruptee
)
-
>
Result
<
Vec
<
String
>
Self
:
:
Error
>
;
fn
set_uploaded
(
&
self
server_modified_millis
:
i64
ids
:
&
[
String
]
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
sync_finished
(
&
self
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
reset
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
wipe
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
;
fn
finalize
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
Ok
(
(
)
)
}
}
pub
trait
Interruptee
{
fn
was_interrupted
(
&
self
)
-
>
bool
;
fn
err_if_interrupted
(
&
self
)
-
>
Result
<
(
)
Interrupted
>
{
if
self
.
was_interrupted
(
)
{
Err
(
Interrupted
)
}
else
{
Ok
(
(
)
)
}
}
}
#
[
derive
(
Clone
Copy
Debug
Eq
Hash
PartialEq
)
]
pub
struct
Interrupted
;
impl
Error
for
Interrupted
{
}
impl
fmt
:
:
Display
for
Interrupted
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
"
The
operation
was
interrupted
"
.
fmt
(
f
)
}
}
impl
<
E
>
BridgedEngine
for
Mutex
<
E
>
where
E
:
BridgedEngine
E
:
:
Error
:
for
<
'
a
>
From
<
PoisonError
<
MutexGuard
<
'
a
E
>
>
>
{
type
Error
=
E
:
:
Error
;
fn
initialize
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
initialize
(
)
}
fn
last_sync
(
&
self
)
-
>
Result
<
i64
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
last_sync
(
)
}
fn
set_last_sync
(
&
self
millis
:
i64
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
set_last_sync
(
millis
)
}
fn
store_incoming
(
&
self
incoming_cleartexts
:
&
[
String
]
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
store_incoming
(
incoming_cleartexts
signal
)
}
fn
apply
(
&
self
signal
:
&
dyn
Interruptee
)
-
>
Result
<
Vec
<
String
>
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
apply
(
signal
)
}
fn
set_uploaded
(
&
self
server_modified_millis
:
i64
ids
:
&
[
String
]
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
set_uploaded
(
server_modified_millis
ids
signal
)
}
fn
sync_finished
(
&
self
signal
:
&
dyn
Interruptee
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
sync_finished
(
signal
)
}
fn
reset
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
reset
(
)
}
fn
wipe
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
wipe
(
)
}
fn
finalize
(
&
self
)
-
>
Result
<
(
)
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
finalize
(
)
}
fn
sync_id
(
&
self
)
-
>
Result
<
Option
<
String
>
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
sync_id
(
)
}
fn
reset_sync_id
(
&
self
)
-
>
Result
<
String
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
reset_sync_id
(
)
}
fn
ensure_current_sync_id
(
&
self
new_sync_id
:
&
str
)
-
>
Result
<
String
Self
:
:
Error
>
{
self
.
lock
(
)
?
.
ensure_current_sync_id
(
new_sync_id
)
}
}
