#
include
"
ContentPrincipal
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
pratom
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIStandardURL
.
h
"
#
include
"
nsIURIWithSpecialOrigin
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
json
/
json
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
json
/
json
.
h
"
using
namespace
mozilla
;
static
inline
ExtensionPolicyService
&
EPS
(
)
{
return
ExtensionPolicyService
:
:
GetSingleton
(
)
;
}
NS_IMPL_CLASSINFO
(
ContentPrincipal
nullptr
nsIClassInfo
:
:
MAIN_THREAD_ONLY
NS_PRINCIPAL_CID
)
NS_IMPL_QUERY_INTERFACE_CI
(
ContentPrincipal
nsIPrincipal
nsISerializable
)
NS_IMPL_CI_INTERFACE_GETTER
(
ContentPrincipal
nsIPrincipal
nsISerializable
)
ContentPrincipal
:
:
ContentPrincipal
(
)
:
BasePrincipal
(
eContentPrincipal
)
{
}
ContentPrincipal
:
:
~
ContentPrincipal
(
)
{
}
nsresult
ContentPrincipal
:
:
Init
(
nsIURI
*
aURI
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aOriginNoSuffix
)
{
NS_ENSURE_ARG
(
aURI
)
;
bool
hasFlag
;
Unused
<
<
hasFlag
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_INHERITS_SECURITY_CONTEXT
&
hasFlag
)
)
&
&
!
hasFlag
)
;
mURI
=
aURI
;
FinishInit
(
aOriginNoSuffix
aOriginAttributes
)
;
return
NS_OK
;
}
nsresult
ContentPrincipal
:
:
Init
(
ContentPrincipal
*
aOther
const
OriginAttributes
&
aOriginAttributes
)
{
NS_ENSURE_ARG
(
aOther
)
;
mURI
=
aOther
-
>
mURI
;
FinishInit
(
aOther
aOriginAttributes
)
;
mDomain
=
aOther
-
>
mDomain
;
mAddon
=
aOther
-
>
mAddon
;
return
NS_OK
;
}
nsresult
ContentPrincipal
:
:
GetScriptLocation
(
nsACString
&
aStr
)
{
return
mURI
-
>
GetSpec
(
aStr
)
;
}
nsresult
ContentPrincipal
:
:
GenerateOriginNoSuffixFromURI
(
nsIURI
*
aURI
nsACString
&
aOriginNoSuffix
)
{
if
(
!
aURI
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
origin
=
NS_GetInnermostURI
(
aURI
)
;
if
(
!
origin
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
NS_IsAboutBlank
(
origin
)
"
The
inner
URI
for
about
:
blank
must
be
moz
-
safe
-
about
:
blank
"
)
;
if
(
!
nsScriptSecurityManager
:
:
GetStrictFileOriginPolicy
(
)
&
&
NS_URIIsLocalFile
(
origin
)
)
{
aOriginNoSuffix
.
AssignLiteral
(
"
file
:
/
/
UNIVERSAL_FILE_URI_ORIGIN
"
)
;
return
NS_OK
;
}
nsresult
rv
;
#
if
IS_ORIGIN_IS_FULL_SPEC_DEFINED
bool
fullSpec
=
false
;
rv
=
NS_URIChainHasFlags
(
origin
nsIProtocolHandler
:
:
ORIGIN_IS_FULL_SPEC
&
fullSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
fullSpec
)
{
return
origin
-
>
GetAsciiSpec
(
aOriginNoSuffix
)
;
}
#
endif
bool
isBehaved
;
if
(
(
NS_SUCCEEDED
(
origin
-
>
SchemeIs
(
"
about
"
&
isBehaved
)
)
&
&
isBehaved
)
|
|
(
NS_SUCCEEDED
(
origin
-
>
SchemeIs
(
"
moz
-
safe
-
about
"
&
isBehaved
)
)
&
&
isBehaved
&
&
!
StringBeginsWith
(
origin
-
>
GetSpecOrDefault
(
)
NS_LITERAL_CSTRING
(
"
moz
-
safe
-
about
:
blank
"
)
)
)
)
{
rv
=
origin
-
>
GetAsciiSpec
(
aOriginNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
pos
=
aOriginNoSuffix
.
FindChar
(
'
?
'
)
;
int32_t
hashPos
=
aOriginNoSuffix
.
FindChar
(
'
#
'
)
;
if
(
hashPos
!
=
kNotFound
&
&
(
pos
=
=
kNotFound
|
|
hashPos
<
pos
)
)
{
pos
=
hashPos
;
}
if
(
pos
!
=
kNotFound
)
{
aOriginNoSuffix
.
Truncate
(
pos
)
;
}
if
(
NS_WARN_IF
(
aOriginNoSuffix
.
FindChar
(
'
^
'
0
)
!
=
-
1
)
)
{
aOriginNoSuffix
.
Truncate
(
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
blobPrincipal
;
if
(
dom
:
:
BlobURLProtocolHandler
:
:
GetBlobURLPrincipal
(
origin
getter_AddRefs
(
blobPrincipal
)
)
)
{
MOZ_ASSERT
(
blobPrincipal
)
;
return
blobPrincipal
-
>
GetOriginNoSuffix
(
aOriginNoSuffix
)
;
}
nsCOMPtr
<
nsIStandardURL
>
standardURL
=
do_QueryInterface
(
origin
)
;
if
(
!
standardURL
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
hostPort
;
bool
isChrome
=
false
;
rv
=
origin
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isChrome
)
{
rv
=
origin
-
>
GetAsciiHostPort
(
hostPort
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
hostPort
.
IsEmpty
(
)
)
{
rv
=
origin
-
>
GetScheme
(
aOriginNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOriginNoSuffix
.
AppendLiteral
(
"
:
/
/
"
)
;
aOriginNoSuffix
.
Append
(
hostPort
)
;
return
NS_OK
;
}
rv
=
aURI
-
>
GetAsciiSpec
(
aOriginNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
pos
=
aOriginNoSuffix
.
FindChar
(
'
?
'
)
;
int32_t
hashPos
=
aOriginNoSuffix
.
FindChar
(
'
#
'
)
;
if
(
hashPos
!
=
kNotFound
&
&
(
pos
=
=
kNotFound
|
|
hashPos
<
pos
)
)
{
pos
=
hashPos
;
}
if
(
pos
!
=
kNotFound
)
{
aOriginNoSuffix
.
Truncate
(
pos
)
;
}
return
NS_OK
;
}
bool
ContentPrincipal
:
:
SubsumesInternal
(
nsIPrincipal
*
aOther
BasePrincipal
:
:
DocumentDomainConsideration
aConsideration
)
{
MOZ_ASSERT
(
aOther
)
;
if
(
aOther
=
=
this
)
{
return
true
;
}
nsresult
rv
;
if
(
aConsideration
=
=
ConsiderDocumentDomain
)
{
nsCOMPtr
<
nsIURI
>
thisDomain
otherDomain
;
GetDomain
(
getter_AddRefs
(
thisDomain
)
)
;
aOther
-
>
GetDomain
(
getter_AddRefs
(
otherDomain
)
)
;
if
(
thisDomain
|
|
otherDomain
)
{
bool
isMatch
=
nsScriptSecurityManager
:
:
SecurityCompareURIs
(
thisDomain
otherDomain
)
;
#
ifdef
DEBUG
if
(
isMatch
)
{
nsAutoCString
thisSiteOrigin
otherSiteOrigin
;
MOZ_ALWAYS_SUCCEEDS
(
GetSiteOrigin
(
thisSiteOrigin
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
aOther
-
>
GetSiteOrigin
(
otherSiteOrigin
)
)
;
MOZ_ASSERT
(
thisSiteOrigin
=
=
otherSiteOrigin
"
SubsumesConsideringDomain
passed
with
mismatched
siteOrigin
!
"
)
;
}
#
endif
return
isMatch
;
}
}
nsCOMPtr
<
nsIURI
>
otherURI
;
rv
=
aOther
-
>
GetURI
(
getter_AddRefs
(
otherURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
nsScriptSecurityManager
:
:
SecurityCompareURIs
(
mURI
otherURI
)
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
GetURI
(
nsIURI
*
*
aURI
)
{
NS_ADDREF
(
*
aURI
=
mURI
)
;
return
NS_OK
;
}
bool
ContentPrincipal
:
:
MayLoadInternal
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
#
if
defined
(
MOZ_THUNDERBIRD
)
|
|
defined
(
MOZ_SUITE
)
nsCOMPtr
<
nsIURIWithSpecialOrigin
>
uriWithSpecialOrigin
=
do_QueryInterface
(
aURI
)
;
if
(
uriWithSpecialOrigin
)
{
nsCOMPtr
<
nsIURI
>
origin
;
nsresult
rv
=
uriWithSpecialOrigin
-
>
GetOrigin
(
getter_AddRefs
(
origin
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
origin
)
;
OriginAttributes
attrs
;
RefPtr
<
BasePrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
origin
attrs
)
;
return
nsIPrincipal
:
:
Subsumes
(
principal
)
;
}
#
endif
nsCOMPtr
<
nsIPrincipal
>
blobPrincipal
;
if
(
dom
:
:
BlobURLProtocolHandler
:
:
GetBlobURLPrincipal
(
aURI
getter_AddRefs
(
blobPrincipal
)
)
)
{
MOZ_ASSERT
(
blobPrincipal
)
;
return
nsIPrincipal
:
:
Subsumes
(
blobPrincipal
)
;
}
if
(
AddonAllowsLoad
(
aURI
)
)
{
return
true
;
}
if
(
nsScriptSecurityManager
:
:
SecurityCompareURIs
(
mURI
aURI
)
)
{
return
true
;
}
if
(
nsScriptSecurityManager
:
:
GetStrictFileOriginPolicy
(
)
&
&
NS_URIIsLocalFile
(
aURI
)
&
&
NS_RelaxStrictFileOriginPolicy
(
aURI
mURI
)
)
{
return
true
;
}
return
false
;
}
uint32_t
ContentPrincipal
:
:
GetHashValue
(
)
{
MOZ_ASSERT
(
mURI
"
Need
a
principal
URI
"
)
;
return
nsScriptSecurityManager
:
:
HashPrincipalByOrigin
(
this
)
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
GetDomain
(
nsIURI
*
*
aDomain
)
{
if
(
!
mDomain
)
{
*
aDomain
=
nullptr
;
return
NS_OK
;
}
NS_ADDREF
(
*
aDomain
=
mDomain
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
SetDomain
(
nsIURI
*
aDomain
)
{
MOZ_ASSERT
(
aDomain
)
;
mDomain
=
aDomain
;
SetHasExplicitDomain
(
)
;
auto
cb
=
[
]
(
JSContext
*
void
*
JS
:
:
Handle
<
JS
:
:
Realm
*
>
aRealm
)
{
JS
:
:
Compartment
*
comp
=
JS
:
:
GetCompartmentForRealm
(
aRealm
)
;
xpc
:
:
SetCompartmentChangedDocumentDomain
(
comp
)
;
}
;
JSPrincipals
*
principals
=
nsJSPrincipals
:
:
get
(
static_cast
<
nsIPrincipal
*
>
(
this
)
)
;
AutoSafeJSContext
cx
;
JS
:
:
IterateRealmsWithPrincipals
(
cx
principals
nullptr
cb
)
;
return
NS_OK
;
}
static
nsresult
GetSpecialBaseDomain
(
const
nsCOMPtr
<
nsIURI
>
&
aURI
bool
*
aHandled
nsACString
&
aBaseDomain
)
{
*
aHandled
=
false
;
if
(
NS_URIIsLocalFile
(
aURI
)
)
{
if
(
!
nsScriptSecurityManager
:
:
GetStrictFileOriginPolicy
(
)
)
{
*
aHandled
=
true
;
aBaseDomain
.
AssignLiteral
(
"
UNIVERSAL_FILE_URI_ORIGIN
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aURI
)
;
if
(
url
)
{
*
aHandled
=
true
;
return
url
-
>
GetFilePath
(
aBaseDomain
)
;
}
}
bool
hasNoRelativeFlag
;
nsresult
rv
=
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_NORELATIVE
&
hasNoRelativeFlag
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
hasNoRelativeFlag
)
{
*
aHandled
=
true
;
return
aURI
-
>
GetSpec
(
aBaseDomain
)
;
}
bool
isBehaved
;
if
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
indexeddb
"
&
isBehaved
)
)
&
&
isBehaved
)
{
*
aHandled
=
true
;
return
aURI
-
>
GetSpec
(
aBaseDomain
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
GetBaseDomain
(
nsACString
&
aBaseDomain
)
{
bool
handled
;
nsresult
rv
=
GetSpecialBaseDomain
(
mURI
&
handled
aBaseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
;
if
(
!
thirdPartyUtil
)
{
return
NS_ERROR_FAILURE
;
}
return
thirdPartyUtil
-
>
GetBaseDomain
(
mURI
aBaseDomain
)
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
GetSiteOrigin
(
nsACString
&
aSiteOrigin
)
{
nsAutoCString
baseDomain
;
bool
handled
;
nsresult
rv
=
GetSpecialBaseDomain
(
mURI
&
handled
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
handled
)
{
return
GetOrigin
(
aSiteOrigin
)
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
NS_ERROR_FAILURE
;
}
bool
gotBaseDomain
=
false
;
rv
=
tldService
-
>
GetBaseDomain
(
mURI
0
baseDomain
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gotBaseDomain
=
true
;
}
else
{
if
(
rv
!
=
NS_ERROR_HOST_IS_IP_ADDRESS
&
&
rv
!
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIURI
>
siteUri
;
NS_MutateURI
mutator
(
mURI
)
;
mutator
.
SetUserPass
(
EmptyCString
(
)
)
.
SetPort
(
-
1
)
;
if
(
gotBaseDomain
)
{
mutator
.
SetHost
(
baseDomain
)
;
}
rv
=
mutator
.
Finalize
(
siteUri
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
failed
to
create
siteUri
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateOriginNoSuffixFromURI
(
siteUri
aSiteOrigin
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
failed
to
create
siteOriginNoSuffix
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
suffix
;
rv
=
GetOriginSuffix
(
suffix
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
failed
to
create
suffix
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aSiteOrigin
.
Append
(
suffix
)
;
return
NS_OK
;
}
nsresult
ContentPrincipal
:
:
GetSiteIdentifier
(
SiteIdentifier
&
aSite
)
{
nsCString
siteOrigin
;
nsresult
rv
=
GetSiteOrigin
(
siteOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
BasePrincipal
>
principal
=
CreateContentPrincipal
(
siteOrigin
)
;
if
(
!
principal
)
{
NS_WARNING
(
"
could
not
instantiate
content
principal
"
)
;
return
NS_ERROR_FAILURE
;
}
aSite
.
Init
(
principal
)
;
return
NS_OK
;
}
WebExtensionPolicy
*
ContentPrincipal
:
:
AddonPolicy
(
)
{
if
(
!
mAddon
.
isSome
(
)
)
{
NS_ENSURE_TRUE
(
mURI
nullptr
)
;
bool
isMozExt
;
if
(
NS_SUCCEEDED
(
mURI
-
>
SchemeIs
(
"
moz
-
extension
"
&
isMozExt
)
)
&
&
isMozExt
)
{
mAddon
.
emplace
(
EPS
(
)
.
GetByURL
(
mURI
.
get
(
)
)
)
;
}
else
{
mAddon
.
emplace
(
nullptr
)
;
}
}
return
mAddon
.
value
(
)
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
GetAddonId
(
nsAString
&
aAddonId
)
{
auto
policy
=
AddonPolicy
(
)
;
if
(
policy
)
{
policy
-
>
GetId
(
aAddonId
)
;
}
else
{
aAddonId
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
Read
(
nsIObjectInputStream
*
aStream
)
{
nsCOMPtr
<
nsISupports
>
supports
;
nsCOMPtr
<
nsIURI
>
principalURI
;
nsresult
rv
=
NS_ReadOptionalObject
(
aStream
true
getter_AddRefs
(
supports
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
principalURI
=
do_QueryInterface
(
supports
)
;
bool
isAbout
=
false
;
if
(
NS_SUCCEEDED
(
principalURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
&
&
isAbout
)
{
nsAutoCString
spec
;
principalURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
NS_NewURI
(
getter_AddRefs
(
principalURI
)
spec
)
NS_ERROR_FAILURE
)
;
}
nsCOMPtr
<
nsIURI
>
domain
;
rv
=
NS_ReadOptionalObject
(
aStream
true
getter_AddRefs
(
supports
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
domain
=
do_QueryInterface
(
supports
)
;
nsAutoCString
suffix
;
rv
=
aStream
-
>
ReadCString
(
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
attrs
;
bool
ok
=
attrs
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
ok
NS_ERROR_FAILURE
)
;
Unused
<
<
NS_ReadOptionalObject
(
aStream
true
getter_AddRefs
(
supports
)
)
;
nsAutoCString
originNoSuffix
;
rv
=
GenerateOriginNoSuffixFromURI
(
principalURI
originNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
Init
(
principalURI
attrs
originNoSuffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDomain
=
domain
;
if
(
mDomain
)
{
SetHasExplicitDomain
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentPrincipal
:
:
Write
(
nsIObjectOutputStream
*
aStream
)
{
MOZ_RELEASE_ASSERT
(
false
"
Old
style
serialization
is
removed
"
)
;
return
NS_OK
;
}
nsresult
ContentPrincipal
:
:
PopulateJSONObject
(
Json
:
:
Value
&
aObject
)
{
nsAutoCString
principalURI
;
nsresult
rv
=
mURI
-
>
GetSpec
(
principalURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aObject
[
std
:
:
to_string
(
eURI
)
]
=
principalURI
.
get
(
)
;
if
(
mDomain
)
{
nsAutoCString
domainStr
;
rv
=
mDomain
-
>
GetSpec
(
domainStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aObject
[
std
:
:
to_string
(
eDomain
)
]
=
domainStr
.
get
(
)
;
}
nsAutoCString
suffix
;
OriginAttributesRef
(
)
.
CreateSuffix
(
suffix
)
;
if
(
suffix
.
Length
(
)
>
0
)
{
aObject
[
std
:
:
to_string
(
eSuffix
)
]
=
suffix
.
get
(
)
;
}
return
NS_OK
;
}
already_AddRefed
<
BasePrincipal
>
ContentPrincipal
:
:
FromProperties
(
nsTArray
<
ContentPrincipal
:
:
KeyVal
>
&
aFields
)
{
MOZ_ASSERT
(
aFields
.
Length
(
)
=
=
eMax
+
1
"
Must
have
all
the
keys
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
principalURI
;
nsCOMPtr
<
nsIURI
>
domain
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
OriginAttributes
attrs
;
for
(
const
auto
&
field
:
aFields
)
{
switch
(
field
.
key
)
{
case
ContentPrincipal
:
:
eURI
:
if
(
!
field
.
valueWasSerialized
)
{
MOZ_ASSERT
(
false
"
Content
principals
require
a
principal
URI
in
serialized
JSON
"
)
;
return
nullptr
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
principalURI
)
field
.
value
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
{
bool
isAbout
=
NS_SUCCEEDED
(
principalURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
&
&
isAbout
;
if
(
isAbout
)
{
nsAutoCString
spec
;
principalURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
principalURI
)
spec
)
)
)
{
return
nullptr
;
}
}
}
break
;
case
ContentPrincipal
:
:
eDomain
:
if
(
field
.
valueWasSerialized
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
domain
)
field
.
value
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
break
;
case
ContentPrincipal
:
:
eSuffix
:
if
(
field
.
valueWasSerialized
)
{
bool
ok
=
attrs
.
PopulateFromSuffix
(
field
.
value
)
;
if
(
!
ok
)
{
return
nullptr
;
}
}
break
;
}
}
nsAutoCString
originNoSuffix
;
rv
=
ContentPrincipal
:
:
GenerateOriginNoSuffixFromURI
(
principalURI
originNoSuffix
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
RefPtr
<
ContentPrincipal
>
principal
=
new
ContentPrincipal
(
)
;
rv
=
principal
-
>
Init
(
principalURI
attrs
originNoSuffix
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
principal
-
>
mDomain
=
domain
;
if
(
principal
-
>
mDomain
)
{
principal
-
>
SetHasExplicitDomain
(
)
;
}
return
principal
.
forget
(
)
;
}
