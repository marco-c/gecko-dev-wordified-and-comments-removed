#
include
"
DomainPolicy
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
using
namespace
dom
;
NS_IMPL_ISUPPORTS
(
DomainPolicy
nsIDomainPolicy
)
static
nsresult
BroadcastDomainSetChange
(
DomainSetType
aSetType
DomainSetChangeType
aChangeType
nsIURI
*
aDomain
=
nullptr
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
DomainPolicy
should
only
be
exposed
to
the
chrome
process
.
"
)
;
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
if
(
!
parents
.
Length
(
)
)
{
return
NS_OK
;
}
for
(
uint32_t
i
=
0
;
i
<
parents
.
Length
(
)
;
i
+
+
)
{
Unused
<
<
parents
[
i
]
-
>
SendDomainSetChanged
(
aSetType
aChangeType
aDomain
)
;
}
return
NS_OK
;
}
DomainPolicy
:
:
DomainPolicy
(
)
:
mBlocklist
(
new
DomainSet
(
BLOCKLIST
)
)
mSuperBlocklist
(
new
DomainSet
(
SUPER_BLOCKLIST
)
)
mAllowlist
(
new
DomainSet
(
ALLOWLIST
)
)
mSuperAllowlist
(
new
DomainSet
(
SUPER_ALLOWLIST
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
BroadcastDomainSetChange
(
NO_TYPE
ACTIVATE_POLICY
)
;
}
}
DomainPolicy
:
:
~
DomainPolicy
(
)
{
MOZ_ASSERT
(
!
mBlocklist
&
&
!
mSuperBlocklist
&
&
!
mAllowlist
&
&
!
mSuperAllowlist
)
;
}
NS_IMETHODIMP
DomainPolicy
:
:
GetBlocklist
(
nsIDomainSet
*
*
aSet
)
{
nsCOMPtr
<
nsIDomainSet
>
set
=
mBlocklist
.
get
(
)
;
set
.
forget
(
aSet
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DomainPolicy
:
:
GetSuperBlocklist
(
nsIDomainSet
*
*
aSet
)
{
nsCOMPtr
<
nsIDomainSet
>
set
=
mSuperBlocklist
.
get
(
)
;
set
.
forget
(
aSet
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DomainPolicy
:
:
GetAllowlist
(
nsIDomainSet
*
*
aSet
)
{
nsCOMPtr
<
nsIDomainSet
>
set
=
mAllowlist
.
get
(
)
;
set
.
forget
(
aSet
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DomainPolicy
:
:
GetSuperAllowlist
(
nsIDomainSet
*
*
aSet
)
{
nsCOMPtr
<
nsIDomainSet
>
set
=
mSuperAllowlist
.
get
(
)
;
set
.
forget
(
aSet
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DomainPolicy
:
:
Deactivate
(
)
{
mBlocklist
-
>
Clear
(
)
;
mSuperBlocklist
-
>
Clear
(
)
;
mAllowlist
-
>
Clear
(
)
;
mSuperAllowlist
-
>
Clear
(
)
;
mBlocklist
=
nullptr
;
mSuperBlocklist
=
nullptr
;
mAllowlist
=
nullptr
;
mSuperAllowlist
=
nullptr
;
nsScriptSecurityManager
*
ssm
=
nsScriptSecurityManager
:
:
GetScriptSecurityManager
(
)
;
if
(
ssm
)
{
ssm
-
>
DeactivateDomainPolicy
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
BroadcastDomainSetChange
(
NO_TYPE
DEACTIVATE_POLICY
)
;
}
return
NS_OK
;
}
void
DomainPolicy
:
:
CloneDomainPolicy
(
DomainPolicyClone
*
aClone
)
{
aClone
-
>
active
(
)
=
true
;
mBlocklist
-
>
CloneSet
(
&
aClone
-
>
blocklist
(
)
)
;
mSuperBlocklist
-
>
CloneSet
(
&
aClone
-
>
superBlocklist
(
)
)
;
mAllowlist
-
>
CloneSet
(
&
aClone
-
>
allowlist
(
)
)
;
mSuperAllowlist
-
>
CloneSet
(
&
aClone
-
>
superAllowlist
(
)
)
;
}
static
void
CopyURIs
(
const
nsTArray
<
RefPtr
<
nsIURI
>
>
&
aDomains
nsIDomainSet
*
aSet
)
{
for
(
uint32_t
i
=
0
;
i
<
aDomains
.
Length
(
)
;
i
+
+
)
{
if
(
NS_WARN_IF
(
!
aDomains
[
i
]
)
)
{
continue
;
}
aSet
-
>
Add
(
aDomains
[
i
]
)
;
}
}
void
DomainPolicy
:
:
ApplyClone
(
const
DomainPolicyClone
*
aClone
)
{
CopyURIs
(
aClone
-
>
blocklist
(
)
mBlocklist
)
;
CopyURIs
(
aClone
-
>
allowlist
(
)
mAllowlist
)
;
CopyURIs
(
aClone
-
>
superBlocklist
(
)
mSuperBlocklist
)
;
CopyURIs
(
aClone
-
>
superAllowlist
(
)
mSuperAllowlist
)
;
}
static
already_AddRefed
<
nsIURI
>
GetCanonicalClone
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIURI
>
clone
;
nsresult
rv
=
NS_MutateURI
(
aURI
)
.
SetUserPass
(
"
"
_ns
)
.
SetPathQueryRef
(
"
"
_ns
)
.
Finalize
(
clone
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
clone
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS
(
DomainSet
nsIDomainSet
)
NS_IMETHODIMP
DomainSet
:
:
Add
(
nsIURI
*
aDomain
)
{
nsCOMPtr
<
nsIURI
>
clone
=
GetCanonicalClone
(
aDomain
)
;
NS_ENSURE_TRUE
(
clone
NS_ERROR_FAILURE
)
;
mHashTable
.
Insert
(
clone
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
BroadcastDomainSetChange
(
mType
ADD_DOMAIN
aDomain
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DomainSet
:
:
Remove
(
nsIURI
*
aDomain
)
{
nsCOMPtr
<
nsIURI
>
clone
=
GetCanonicalClone
(
aDomain
)
;
NS_ENSURE_TRUE
(
clone
NS_ERROR_FAILURE
)
;
mHashTable
.
Remove
(
clone
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
BroadcastDomainSetChange
(
mType
REMOVE_DOMAIN
aDomain
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DomainSet
:
:
Clear
(
)
{
mHashTable
.
Clear
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
BroadcastDomainSetChange
(
mType
CLEAR_DOMAINS
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DomainSet
:
:
Contains
(
nsIURI
*
aDomain
bool
*
aContains
)
{
*
aContains
=
false
;
nsCOMPtr
<
nsIURI
>
clone
=
GetCanonicalClone
(
aDomain
)
;
NS_ENSURE_TRUE
(
clone
NS_ERROR_FAILURE
)
;
*
aContains
=
mHashTable
.
Contains
(
clone
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DomainSet
:
:
ContainsSuperDomain
(
nsIURI
*
aDomain
bool
*
aContains
)
{
*
aContains
=
false
;
nsCOMPtr
<
nsIURI
>
clone
=
GetCanonicalClone
(
aDomain
)
;
NS_ENSURE_TRUE
(
clone
NS_ERROR_FAILURE
)
;
nsAutoCString
domain
;
nsresult
rv
=
clone
-
>
GetHost
(
domain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
true
)
{
if
(
mHashTable
.
Contains
(
clone
)
)
{
*
aContains
=
true
;
return
NS_OK
;
}
int32_t
index
=
domain
.
Find
(
"
.
"
)
;
if
(
index
=
=
kNotFound
)
break
;
domain
.
Assign
(
Substring
(
domain
index
+
1
)
)
;
rv
=
NS_MutateURI
(
clone
)
.
SetHost
(
domain
)
.
Finalize
(
clone
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
DomainSet
:
:
CloneSet
(
nsTArray
<
RefPtr
<
nsIURI
>
>
*
aDomains
)
{
AppendToArray
(
*
aDomains
mHashTable
)
;
}
}
