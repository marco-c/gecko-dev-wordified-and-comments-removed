#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
URLSearchParams
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsURLHelper
.
h
"
static
const
char
kSourceChar
=
'
:
'
;
static
const
char
kSanitizedChar
=
'
+
'
;
namespace
mozilla
{
using
dom
:
:
URLParams
;
static
void
MakeTopLevelInfo
(
const
nsACString
&
aScheme
const
nsACString
&
aHost
int32_t
aPort
bool
aUseSite
nsAString
&
aTopLevelInfo
)
{
if
(
!
aUseSite
)
{
aTopLevelInfo
.
Assign
(
NS_ConvertUTF8toUTF16
(
aHost
)
)
;
return
;
}
nsAutoCString
site
;
site
.
AssignLiteral
(
"
(
"
)
;
site
.
Append
(
aScheme
)
;
site
.
Append
(
"
"
)
;
site
.
Append
(
aHost
)
;
if
(
aPort
!
=
-
1
)
{
site
.
Append
(
"
"
)
;
site
.
AppendInt
(
aPort
)
;
}
site
.
AppendLiteral
(
"
)
"
)
;
aTopLevelInfo
.
Assign
(
NS_ConvertUTF8toUTF16
(
site
)
)
;
}
static
void
MakeTopLevelInfo
(
const
nsACString
&
aScheme
const
nsACString
&
aHost
bool
aUseSite
nsAString
&
aTopLevelInfo
)
{
MakeTopLevelInfo
(
aScheme
aHost
-
1
aUseSite
aTopLevelInfo
)
;
}
static
void
PopulateTopLevelInfoFromURI
(
const
bool
aIsTopLevelDocument
nsIURI
*
aURI
bool
aIsFirstPartyEnabled
bool
aForced
bool
aUseSite
nsString
OriginAttributes
:
:
*
aTarget
OriginAttributes
&
aOriginAttributes
)
{
nsresult
rv
;
if
(
!
aURI
)
{
return
;
}
if
(
(
!
aIsFirstPartyEnabled
|
|
!
aIsTopLevelDocument
)
&
&
!
aForced
)
{
return
;
}
nsAString
&
topLevelInfo
=
aOriginAttributes
.
*
aTarget
;
nsAutoCString
scheme
;
rv
=
aURI
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
scheme
.
EqualsLiteral
(
"
about
"
)
)
{
MakeTopLevelInfo
(
scheme
NS_LITERAL_CSTRING
(
ABOUT_URI_FIRST_PARTY_DOMAIN
)
aUseSite
topLevelInfo
)
;
return
;
}
if
(
scheme
.
EqualsLiteral
(
"
moz
-
extension
"
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
blobPrincipal
;
if
(
dom
:
:
BlobURLProtocolHandler
:
:
GetBlobURLPrincipal
(
aURI
getter_AddRefs
(
blobPrincipal
)
)
)
{
MOZ_ASSERT
(
blobPrincipal
)
;
topLevelInfo
=
blobPrincipal
-
>
OriginAttributesRef
(
)
.
*
aTarget
;
return
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
tldService
)
;
NS_ENSURE_TRUE_VOID
(
tldService
)
;
nsAutoCString
baseDomain
;
rv
=
tldService
-
>
GetBaseDomain
(
aURI
0
baseDomain
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MakeTopLevelInfo
(
scheme
baseDomain
aUseSite
topLevelInfo
)
;
return
;
}
bool
isIpAddress
=
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
)
;
bool
isInsufficientDomainLevels
=
(
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
;
int32_t
port
;
rv
=
aURI
-
>
GetPort
(
&
port
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoCString
host
;
rv
=
aURI
-
>
GetHost
(
host
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
isIpAddress
)
{
nsAutoCString
ipAddr
;
if
(
net_IsValidIPv6Addr
(
host
)
)
{
ipAddr
.
AssignLiteral
(
"
[
"
)
;
ipAddr
.
Append
(
host
)
;
ipAddr
.
AppendLiteral
(
"
]
"
)
;
}
else
{
ipAddr
=
host
;
}
MakeTopLevelInfo
(
scheme
ipAddr
port
aUseSite
topLevelInfo
)
;
return
;
}
if
(
aUseSite
)
{
MakeTopLevelInfo
(
scheme
host
port
aUseSite
topLevelInfo
)
;
return
;
}
if
(
isInsufficientDomainLevels
)
{
nsAutoCString
publicSuffix
;
rv
=
tldService
-
>
GetPublicSuffix
(
aURI
publicSuffix
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MakeTopLevelInfo
(
scheme
publicSuffix
port
aUseSite
topLevelInfo
)
;
return
;
}
}
}
void
OriginAttributes
:
:
SetFirstPartyDomain
(
const
bool
aIsTopLevelDocument
nsIURI
*
aURI
bool
aForced
)
{
PopulateTopLevelInfoFromURI
(
aIsTopLevelDocument
aURI
IsFirstPartyEnabled
(
)
aForced
StaticPrefs
:
:
privacy_firstparty_isolate_use_site
(
)
&
OriginAttributes
:
:
mFirstPartyDomain
*
this
)
;
}
void
OriginAttributes
:
:
SetFirstPartyDomain
(
const
bool
aIsTopLevelDocument
const
nsACString
&
aDomain
)
{
SetFirstPartyDomain
(
aIsTopLevelDocument
NS_ConvertUTF8toUTF16
(
aDomain
)
)
;
}
void
OriginAttributes
:
:
SetFirstPartyDomain
(
const
bool
aIsTopLevelDocument
const
nsAString
&
aDomain
bool
aForced
)
{
if
(
(
!
IsFirstPartyEnabled
(
)
|
|
!
aIsTopLevelDocument
)
&
&
!
aForced
)
{
return
;
}
mFirstPartyDomain
=
aDomain
;
}
void
OriginAttributes
:
:
SetPartitionKey
(
nsIURI
*
aURI
)
{
PopulateTopLevelInfoFromURI
(
false
aURI
IsFirstPartyEnabled
(
)
true
StaticPrefs
:
:
privacy_dynamic_firstparty_use_site
(
)
&
OriginAttributes
:
:
mPartitionKey
*
this
)
;
}
void
OriginAttributes
:
:
SetPartitionKey
(
const
nsACString
&
aDomain
)
{
SetPartitionKey
(
NS_ConvertUTF8toUTF16
(
aDomain
)
)
;
}
void
OriginAttributes
:
:
SetPartitionKey
(
const
nsAString
&
aDomain
)
{
mPartitionKey
=
aDomain
;
}
void
OriginAttributes
:
:
CreateSuffix
(
nsACString
&
aStr
)
const
{
URLParams
params
;
nsAutoString
value
;
if
(
mInIsolatedMozBrowser
)
{
params
.
Set
(
NS_LITERAL_STRING
(
"
inBrowser
"
)
NS_LITERAL_STRING
(
"
1
"
)
)
;
}
if
(
mUserContextId
!
=
nsIScriptSecurityManager
:
:
DEFAULT_USER_CONTEXT_ID
)
{
value
.
Truncate
(
)
;
value
.
AppendInt
(
mUserContextId
)
;
params
.
Set
(
NS_LITERAL_STRING
(
"
userContextId
"
)
value
)
;
}
if
(
mPrivateBrowsingId
)
{
value
.
Truncate
(
)
;
value
.
AppendInt
(
mPrivateBrowsingId
)
;
params
.
Set
(
NS_LITERAL_STRING
(
"
privateBrowsingId
"
)
value
)
;
}
if
(
!
mFirstPartyDomain
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedFirstPartyDomain
(
mFirstPartyDomain
)
;
sanitizedFirstPartyDomain
.
ReplaceChar
(
kSourceChar
kSanitizedChar
)
;
params
.
Set
(
NS_LITERAL_STRING
(
"
firstPartyDomain
"
)
sanitizedFirstPartyDomain
)
;
}
if
(
!
mGeckoViewSessionContextId
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedGeckoViewUserContextId
(
mGeckoViewSessionContextId
)
;
sanitizedGeckoViewUserContextId
.
ReplaceChar
(
dom
:
:
quota
:
:
QuotaManager
:
:
kReplaceChars
kSanitizedChar
)
;
params
.
Set
(
NS_LITERAL_STRING
(
"
geckoViewUserContextId
"
)
sanitizedGeckoViewUserContextId
)
;
}
if
(
!
mPartitionKey
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedPartitionKey
(
mPartitionKey
)
;
sanitizedPartitionKey
.
ReplaceChar
(
kSourceChar
kSanitizedChar
)
;
params
.
Set
(
NS_LITERAL_STRING
(
"
partitionKey
"
)
sanitizedPartitionKey
)
;
}
aStr
.
Truncate
(
)
;
params
.
Serialize
(
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
aStr
.
AppendLiteral
(
"
^
"
)
;
aStr
.
Append
(
NS_ConvertUTF16toUTF8
(
value
)
)
;
}
#
ifdef
DEBUG
nsAutoCString
str
;
str
.
Assign
(
aStr
)
;
MOZ_ASSERT
(
str
.
FindCharInSet
(
dom
:
:
quota
:
:
QuotaManager
:
:
kReplaceChars
)
=
=
kNotFound
)
;
#
endif
}
void
OriginAttributes
:
:
CreateAnonymizedSuffix
(
nsACString
&
aStr
)
const
{
OriginAttributes
attrs
=
*
this
;
if
(
!
attrs
.
mFirstPartyDomain
.
IsEmpty
(
)
)
{
attrs
.
mFirstPartyDomain
.
AssignLiteral
(
"
_anonymizedFirstPartyDomain_
"
)
;
}
if
(
!
attrs
.
mPartitionKey
.
IsEmpty
(
)
)
{
attrs
.
mPartitionKey
.
AssignLiteral
(
"
_anonymizedPartitionKey_
"
)
;
}
attrs
.
CreateSuffix
(
aStr
)
;
}
namespace
{
class
MOZ_STACK_CLASS
PopulateFromSuffixIterator
final
:
public
URLParams
:
:
ForEachIterator
{
public
:
explicit
PopulateFromSuffixIterator
(
OriginAttributes
*
aOriginAttributes
)
:
mOriginAttributes
(
aOriginAttributes
)
{
MOZ_ASSERT
(
aOriginAttributes
)
;
mOriginAttributes
-
>
mPrivateBrowsingId
=
nsIScriptSecurityManager
:
:
DEFAULT_PRIVATE_BROWSING_ID
;
}
bool
URLParamsIterator
(
const
nsAString
&
aName
const
nsAString
&
aValue
)
override
{
if
(
aName
.
EqualsLiteral
(
"
inBrowser
"
)
)
{
if
(
!
aValue
.
EqualsLiteral
(
"
1
"
)
)
{
return
false
;
}
mOriginAttributes
-
>
mInIsolatedMozBrowser
=
true
;
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
addonId
"
)
|
|
aName
.
EqualsLiteral
(
"
appId
"
)
)
{
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
userContextId
"
)
)
{
nsresult
rv
;
int64_t
val
=
aValue
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
val
<
=
UINT32_MAX
false
)
;
mOriginAttributes
-
>
mUserContextId
=
static_cast
<
uint32_t
>
(
val
)
;
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
privateBrowsingId
"
)
)
{
nsresult
rv
;
int64_t
val
=
aValue
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
val
>
=
0
&
&
val
<
=
UINT32_MAX
false
)
;
mOriginAttributes
-
>
mPrivateBrowsingId
=
static_cast
<
uint32_t
>
(
val
)
;
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
firstPartyDomain
"
)
)
{
MOZ_RELEASE_ASSERT
(
mOriginAttributes
-
>
mFirstPartyDomain
.
IsEmpty
(
)
)
;
nsAutoString
firstPartyDomain
(
aValue
)
;
firstPartyDomain
.
ReplaceChar
(
kSanitizedChar
kSourceChar
)
;
mOriginAttributes
-
>
mFirstPartyDomain
.
Assign
(
firstPartyDomain
)
;
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
geckoViewUserContextId
"
)
)
{
MOZ_RELEASE_ASSERT
(
mOriginAttributes
-
>
mGeckoViewSessionContextId
.
IsEmpty
(
)
)
;
mOriginAttributes
-
>
mGeckoViewSessionContextId
.
Assign
(
aValue
)
;
return
true
;
}
if
(
aName
.
EqualsLiteral
(
"
partitionKey
"
)
)
{
MOZ_RELEASE_ASSERT
(
mOriginAttributes
-
>
mPartitionKey
.
IsEmpty
(
)
)
;
nsAutoString
partitionKey
(
aValue
)
;
partitionKey
.
ReplaceChar
(
kSanitizedChar
kSourceChar
)
;
mOriginAttributes
-
>
mPartitionKey
.
Assign
(
partitionKey
)
;
return
true
;
}
return
false
;
}
private
:
OriginAttributes
*
mOriginAttributes
;
}
;
}
bool
OriginAttributes
:
:
PopulateFromSuffix
(
const
nsACString
&
aStr
)
{
if
(
aStr
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
aStr
[
0
]
!
=
'
^
'
)
{
return
false
;
}
PopulateFromSuffixIterator
iterator
(
this
)
;
return
URLParams
:
:
Parse
(
Substring
(
aStr
1
aStr
.
Length
(
)
-
1
)
iterator
)
;
}
bool
OriginAttributes
:
:
PopulateFromOrigin
(
const
nsACString
&
aOrigin
nsACString
&
aOriginNoSuffix
)
{
nsCString
origin
(
aOrigin
)
;
int32_t
pos
=
origin
.
RFindChar
(
'
^
'
)
;
if
(
pos
=
=
kNotFound
)
{
aOriginNoSuffix
=
origin
;
return
true
;
}
aOriginNoSuffix
=
Substring
(
origin
0
pos
)
;
return
PopulateFromSuffix
(
Substring
(
origin
pos
)
)
;
}
void
OriginAttributes
:
:
SyncAttributesWithPrivateBrowsing
(
bool
aInPrivateBrowsing
)
{
mPrivateBrowsingId
=
aInPrivateBrowsing
?
1
:
0
;
}
bool
OriginAttributes
:
:
IsPrivateBrowsing
(
const
nsACString
&
aOrigin
)
{
nsAutoCString
dummy
;
OriginAttributes
attrs
;
if
(
NS_WARN_IF
(
!
attrs
.
PopulateFromOrigin
(
aOrigin
dummy
)
)
)
{
return
false
;
}
return
!
!
attrs
.
mPrivateBrowsingId
;
}
}
