#
ifndef
mozilla_TextServicesDocument_h
#
define
mozilla_TextServicesDocument_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIEditActionListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIEditor
;
class
nsINode
;
class
nsISelectionController
;
class
nsRange
;
namespace
mozilla
{
class
EditorBase
;
class
FilteredContentIterator
;
class
OffsetEntry
;
namespace
dom
{
class
AbstractRange
;
class
Document
;
class
Element
;
class
StaticRange
;
}
;
class
TextServicesDocument
final
:
public
nsIEditActionListener
{
private
:
enum
class
IteratorStatus
:
uint8_t
{
eDone
=
0
eValid
ePrev
eNext
}
;
RefPtr
<
dom
:
:
Document
>
mDocument
;
nsCOMPtr
<
nsISelectionController
>
mSelCon
;
RefPtr
<
EditorBase
>
mEditorBase
;
RefPtr
<
FilteredContentIterator
>
mFilteredIter
;
nsCOMPtr
<
nsIContent
>
mPrevTextBlock
;
nsCOMPtr
<
nsIContent
>
mNextTextBlock
;
nsTArray
<
UniquePtr
<
OffsetEntry
>
>
mOffsetTable
;
RefPtr
<
nsRange
>
mExtent
;
Maybe
<
size_t
>
mSelStartIndex
;
Maybe
<
size_t
>
mSelEndIndex
;
Maybe
<
uint32_t
>
mSelectionStartOffsetInTextInBlock
;
Maybe
<
uint32_t
>
mSelectionEndOffsetInTextInBlock
;
uint32_t
mTxtSvcFilterType
;
IteratorStatus
mIteratorStatus
;
protected
:
virtual
~
TextServicesDocument
(
)
=
default
;
public
:
TextServicesDocument
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
TextServicesDocument
)
nsresult
InitWithEditor
(
nsIEditor
*
aEditor
)
;
nsresult
SetExtent
(
const
dom
:
:
AbstractRange
*
aAbstractRange
)
;
nsresult
ExpandRangeToWordBoundaries
(
dom
:
:
StaticRange
*
aStaticRange
)
;
nsresult
SetFilterType
(
uint32_t
aFilterType
)
;
nsresult
GetCurrentTextBlock
(
nsAString
&
aStr
)
;
nsresult
FirstBlock
(
)
;
enum
class
BlockSelectionStatus
{
eBlockNotFound
=
0
eBlockOutside
eBlockInside
eBlockContains
eBlockPartial
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
LastSelectedBlock
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
nsresult
PrevBlock
(
)
;
nsresult
NextBlock
(
)
;
nsresult
IsDone
(
bool
*
aIsDone
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelection
(
uint32_t
aOffset
uint32_t
aLength
)
;
nsresult
ScrollSelectionIntoView
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertText
(
const
nsAString
&
aText
)
;
NS_DECL_NSIEDITACTIONLISTENER
void
DidDeleteNode
(
nsINode
*
aChild
)
;
void
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
private
:
static
nsresult
GetRangeEndPoints
(
const
dom
:
:
AbstractRange
*
aAbstractRange
nsINode
*
*
aStartContainer
uint32_t
*
aStartOffset
nsINode
*
*
aEndContainer
uint32_t
*
aEndOffset
)
;
nsresult
CreateFilteredContentIterator
(
const
dom
:
:
AbstractRange
*
aAbstractRange
FilteredContentIterator
*
*
aFilteredIter
)
;
dom
:
:
Element
*
GetDocumentContentRootNode
(
)
const
;
already_AddRefed
<
nsRange
>
CreateDocumentContentRange
(
)
;
already_AddRefed
<
nsRange
>
CreateDocumentContentRootToNodeOffsetRange
(
nsINode
*
aParent
uint32_t
aOffset
bool
aToStart
)
;
nsresult
CreateDocumentContentIterator
(
FilteredContentIterator
*
*
aFilteredIter
)
;
nsresult
AdjustContentIterator
(
)
;
static
nsresult
FirstTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
;
static
nsresult
LastTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
;
static
nsresult
FirstTextNodeInCurrentBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
static
nsresult
FirstTextNodeInPrevBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
static
nsresult
FirstTextNodeInNextBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
nsresult
GetFirstTextNodeInPrevBlock
(
nsIContent
*
*
aContent
)
;
nsresult
GetFirstTextNodeInNextBlock
(
nsIContent
*
*
aContent
)
;
static
bool
IsBlockNode
(
nsIContent
*
aContent
)
;
static
bool
DidSkip
(
FilteredContentIterator
*
aFilteredIter
)
;
static
void
ClearDidSkip
(
FilteredContentIterator
*
aFilteredIter
)
;
static
bool
HasSameBlockNodeParent
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionInternal
(
uint32_t
aOffset
uint32_t
aLength
bool
aDoUpdate
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetCollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
nsresult
GetUncollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
bool
SelectionIsCollapsed
(
)
const
;
bool
SelectionIsValid
(
)
const
;
static
nsresult
CreateOffsetTable
(
nsTArray
<
UniquePtr
<
OffsetEntry
>
>
*
aOffsetTable
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
nsRange
*
aIterRange
nsAString
*
aStr
)
;
static
nsresult
NodeHasOffsetEntry
(
nsTArray
<
UniquePtr
<
OffsetEntry
>
>
*
aOffsetTable
nsINode
*
aNode
bool
*
aHasEntry
size_t
*
aEntryIndex
)
;
nsresult
RemoveInvalidOffsetEntries
(
)
;
nsresult
SplitOffsetEntry
(
size_t
aTableIndex
uint32_t
aOffsetIntoEntry
)
;
static
nsresult
FindWordBounds
(
nsTArray
<
UniquePtr
<
OffsetEntry
>
>
*
aOffsetTable
nsString
*
aBlockStr
nsINode
*
aNode
uint32_t
aNodeOffset
nsINode
*
*
aWordStartNode
uint32_t
*
aWordStartOffset
nsINode
*
*
aWordEndNode
uint32_t
*
aWordEndOffset
)
;
}
;
}
#
endif
