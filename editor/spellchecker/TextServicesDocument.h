#
ifndef
mozilla_TextServicesDocument_h
#
define
mozilla_TextServicesDocument_h
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIEditActionListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIEditor
;
class
nsINode
;
class
nsISelectionController
;
class
nsRange
;
namespace
mozilla
{
class
EditorBase
;
class
FilteredContentIterator
;
class
OffsetEntry
;
namespace
dom
{
class
AbstractRange
;
class
Document
;
class
Element
;
class
StaticRange
;
}
;
class
TextServicesDocument
final
:
public
nsIEditActionListener
{
private
:
enum
class
IteratorStatus
:
uint8_t
{
eDone
=
0
eValid
ePrev
eNext
}
;
class
OffsetEntryArray
final
:
public
nsTArray
<
UniquePtr
<
OffsetEntry
>
>
{
public
:
Result
<
IteratorStatus
nsresult
>
Init
(
FilteredContentIterator
&
aFilteredIter
IteratorStatus
aIteratorStatus
nsRange
*
aIterRange
nsAString
*
aAllTextInBlock
=
nullptr
)
;
Maybe
<
size_t
>
FirstIndexOf
(
const
dom
:
:
Text
&
aTextNode
)
const
;
Result
<
EditorDOMRangeInTexts
nsresult
>
FindWordRange
(
nsAString
&
aAllTextInBlock
const
EditorRawDOMPoint
&
aStartPointToScan
)
;
nsresult
SplitElementAt
(
size_t
aIndex
uint32_t
aOffsetInTextNode
)
;
void
RemoveInvalidElements
(
)
;
nsresult
WillDeleteSelection
(
)
;
OffsetEntry
*
DidDeleteSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DidInsertText
(
dom
:
:
Selection
*
aSelection
const
nsAString
&
aInsertedString
)
;
Result
<
EditorRawDOMRangeInTexts
nsresult
>
WillSetSelection
(
uint32_t
aOffsetInTextInBlock
uint32_t
aLength
)
;
class
Selection
final
{
public
:
size_t
StartIndex
(
)
const
{
MOZ_ASSERT
(
IsIndexesSet
(
)
)
;
return
*
mStartIndex
;
}
size_t
EndIndex
(
)
const
{
MOZ_ASSERT
(
IsIndexesSet
(
)
)
;
return
*
mEndIndex
;
}
uint32_t
StartOffsetInTextInBlock
(
)
const
{
MOZ_ASSERT
(
IsSet
(
)
)
;
return
*
mStartOffsetInTextInBlock
;
}
uint32_t
EndOffsetInTextInBlock
(
)
const
{
MOZ_ASSERT
(
IsSet
(
)
)
;
return
*
mEndOffsetInTextInBlock
;
}
uint32_t
LengthInTextInBlock
(
)
const
{
MOZ_ASSERT
(
IsSet
(
)
)
;
return
*
mEndOffsetInTextInBlock
-
*
mStartOffsetInTextInBlock
;
}
bool
IsCollapsed
(
)
{
return
!
IsSet
(
)
|
|
(
IsInSameElement
(
)
&
&
StartOffsetInTextInBlock
(
)
=
=
EndOffsetInTextInBlock
(
)
)
;
}
bool
IsIndexesSet
(
)
const
{
return
mStartIndex
.
isSome
(
)
&
&
mEndIndex
.
isSome
(
)
;
}
bool
IsSet
(
)
const
{
return
IsIndexesSet
(
)
&
&
mStartOffsetInTextInBlock
.
isSome
(
)
&
&
mEndOffsetInTextInBlock
.
isSome
(
)
;
}
bool
IsInSameElement
(
)
const
{
return
IsIndexesSet
(
)
&
&
StartIndex
(
)
=
=
EndIndex
(
)
;
}
void
Reset
(
)
{
mStartIndex
.
reset
(
)
;
mEndIndex
.
reset
(
)
;
mStartOffsetInTextInBlock
.
reset
(
)
;
mEndOffsetInTextInBlock
.
reset
(
)
;
}
void
SetIndex
(
size_t
aIndex
)
{
mEndIndex
=
mStartIndex
=
Some
(
aIndex
)
;
}
void
Set
(
size_t
aIndex
uint32_t
aOffsetInTextInBlock
)
{
mEndIndex
=
mStartIndex
=
Some
(
aIndex
)
;
mStartOffsetInTextInBlock
=
mEndOffsetInTextInBlock
=
Some
(
aOffsetInTextInBlock
)
;
}
void
SetIndexes
(
size_t
aStartIndex
size_t
aEndIndex
)
{
mStartIndex
=
Some
(
aStartIndex
)
;
mEndIndex
=
Some
(
aEndIndex
)
;
}
void
Set
(
size_t
aStartIndex
size_t
aEndIndex
uint32_t
aStartOffsetInTextInBlock
uint32_t
aEndOffsetInTextInBlock
)
{
mStartIndex
=
Some
(
aStartIndex
)
;
mEndIndex
=
Some
(
aEndIndex
)
;
mStartOffsetInTextInBlock
=
Some
(
aStartOffsetInTextInBlock
)
;
mEndOffsetInTextInBlock
=
Some
(
aEndOffsetInTextInBlock
)
;
}
void
CollapseToStart
(
)
{
MOZ_ASSERT
(
mStartIndex
.
isSome
(
)
)
;
MOZ_ASSERT
(
mStartOffsetInTextInBlock
.
isSome
(
)
)
;
mEndIndex
=
mStartIndex
;
mEndOffsetInTextInBlock
=
mStartOffsetInTextInBlock
;
}
private
:
Maybe
<
size_t
>
mStartIndex
;
Maybe
<
size_t
>
mEndIndex
;
Maybe
<
uint32_t
>
mStartOffsetInTextInBlock
;
Maybe
<
uint32_t
>
mEndOffsetInTextInBlock
;
}
;
Selection
mSelection
;
}
;
RefPtr
<
dom
:
:
Document
>
mDocument
;
nsCOMPtr
<
nsISelectionController
>
mSelCon
;
RefPtr
<
EditorBase
>
mEditorBase
;
RefPtr
<
FilteredContentIterator
>
mFilteredIter
;
nsCOMPtr
<
nsIContent
>
mPrevTextBlock
;
nsCOMPtr
<
nsIContent
>
mNextTextBlock
;
OffsetEntryArray
mOffsetTable
;
RefPtr
<
nsRange
>
mExtent
;
uint32_t
mTxtSvcFilterType
;
IteratorStatus
mIteratorStatus
;
protected
:
virtual
~
TextServicesDocument
(
)
=
default
;
public
:
TextServicesDocument
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
TextServicesDocument
)
nsresult
InitWithEditor
(
nsIEditor
*
aEditor
)
;
nsresult
SetExtent
(
const
dom
:
:
AbstractRange
*
aAbstractRange
)
;
nsresult
ExpandRangeToWordBoundaries
(
dom
:
:
StaticRange
*
aStaticRange
)
;
nsresult
SetFilterType
(
uint32_t
aFilterType
)
;
nsresult
GetCurrentTextBlock
(
nsAString
&
aStr
)
;
nsresult
FirstBlock
(
)
;
enum
class
BlockSelectionStatus
{
eBlockNotFound
=
0
eBlockOutside
eBlockInside
eBlockContains
eBlockPartial
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
LastSelectedBlock
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
nsresult
PrevBlock
(
)
;
nsresult
NextBlock
(
)
;
nsresult
IsDone
(
bool
*
aIsDone
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelection
(
uint32_t
aOffset
uint32_t
aLength
)
;
nsresult
ScrollSelectionIntoView
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertText
(
const
nsAString
&
aText
)
;
NS_DECL_NSIEDITACTIONLISTENER
void
DidDeleteContent
(
const
nsIContent
&
aChildContent
)
;
void
DidJoinNodes
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
)
;
private
:
static
nsresult
GetRangeEndPoints
(
const
dom
:
:
AbstractRange
*
aAbstractRange
nsINode
*
*
aStartContainer
uint32_t
*
aStartOffset
nsINode
*
*
aEndContainer
uint32_t
*
aEndOffset
)
;
nsresult
CreateFilteredContentIterator
(
const
dom
:
:
AbstractRange
*
aAbstractRange
FilteredContentIterator
*
*
aFilteredIter
)
;
dom
:
:
Element
*
GetDocumentContentRootNode
(
)
const
;
already_AddRefed
<
nsRange
>
CreateDocumentContentRange
(
)
;
already_AddRefed
<
nsRange
>
CreateDocumentContentRootToNodeOffsetRange
(
nsINode
*
aParent
uint32_t
aOffset
bool
aToStart
)
;
nsresult
CreateDocumentContentIterator
(
FilteredContentIterator
*
*
aFilteredIter
)
;
nsresult
AdjustContentIterator
(
)
;
static
nsresult
FirstTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
;
static
nsresult
LastTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
;
static
nsresult
FirstTextNodeInCurrentBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
static
nsresult
FirstTextNodeInPrevBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
static
nsresult
FirstTextNodeInNextBlock
(
FilteredContentIterator
*
aFilteredIter
)
;
nsresult
GetFirstTextNodeInPrevBlock
(
nsIContent
*
*
aContent
)
;
nsresult
GetFirstTextNodeInNextBlock
(
nsIContent
*
*
aContent
)
;
static
bool
IsBlockNode
(
nsIContent
*
aContent
)
;
static
bool
DidSkip
(
FilteredContentIterator
*
aFilteredIter
)
;
static
void
ClearDidSkip
(
FilteredContentIterator
*
aFilteredIter
)
;
static
bool
HasSameBlockNodeParent
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionInternal
(
uint32_t
aOffset
uint32_t
aLength
bool
aDoUpdate
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetCollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
nsresult
GetUncollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
;
}
;
}
#
endif
