#
include
"
TextServicesDocument
.
h
"
#
include
"
FilteredContentIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsComposeTxtSrvFilter
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorSpellCheck
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
using
namespace
dom
;
class
OffsetEntry
final
{
public
:
OffsetEntry
(
Text
&
aTextNode
uint32_t
aOffsetInTextInBlock
uint32_t
aLength
)
:
mTextNode
(
aTextNode
)
mOffsetInTextNode
(
0
)
mOffsetInTextInBlock
(
aOffsetInTextInBlock
)
mLength
(
aLength
)
mIsInsertedText
(
false
)
mIsValid
(
true
)
{
}
uint32_t
EndOffsetInTextNode
(
)
const
{
return
mOffsetInTextNode
+
mLength
;
}
bool
OffsetInTextNodeIsInRangeOrEndOffset
(
uint32_t
aOffsetInTextNode
)
const
{
return
aOffsetInTextNode
>
=
mOffsetInTextNode
&
&
aOffsetInTextNode
<
=
EndOffsetInTextNode
(
)
;
}
uint32_t
EndOffsetInTextInBlock
(
)
const
{
return
mOffsetInTextInBlock
+
mLength
;
}
OwningNonNull
<
Text
>
mTextNode
;
uint32_t
mOffsetInTextNode
;
uint32_t
mOffsetInTextInBlock
;
uint32_t
mLength
;
bool
mIsInsertedText
;
bool
mIsValid
;
}
;
TextServicesDocument
:
:
TextServicesDocument
(
)
:
mTxtSvcFilterType
(
0
)
mIteratorStatus
(
IteratorStatus
:
:
eDone
)
{
}
TextServicesDocument
:
:
~
TextServicesDocument
(
)
{
ClearOffsetTable
(
&
mOffsetTable
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextServicesDocument
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextServicesDocument
)
NS_INTERFACE_MAP_BEGIN
(
TextServicesDocument
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditActionListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditActionListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
TextServicesDocument
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
TextServicesDocument
mDocument
mSelCon
mEditorBase
mFilteredIter
mPrevTextBlock
mNextTextBlock
mExtent
)
nsresult
TextServicesDocument
:
:
InitWithEditor
(
nsIEditor
*
aEditor
)
{
nsCOMPtr
<
nsISelectionController
>
selCon
;
NS_ENSURE_TRUE
(
aEditor
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
aEditor
-
>
GetSelectionController
(
getter_AddRefs
(
selCon
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
selCon
|
|
(
mSelCon
&
&
selCon
!
=
mSelCon
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mSelCon
)
{
mSelCon
=
selCon
;
}
RefPtr
<
Document
>
doc
=
aEditor
-
>
AsEditorBase
(
)
-
>
GetDocument
(
)
;
if
(
!
doc
|
|
(
mDocument
&
&
doc
!
=
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDocument
)
{
mDocument
=
doc
;
rv
=
CreateDocumentContentIterator
(
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstBlock
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mEditorBase
=
aEditor
-
>
AsEditorBase
(
)
;
rv
=
aEditor
-
>
AddEditActionListener
(
this
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
SetExtent
(
const
AbstractRange
*
aAbstractRange
)
{
MOZ_ASSERT
(
aAbstractRange
)
;
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
mExtent
=
nsRange
:
:
Create
(
aAbstractRange
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
mExtent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CreateFilteredContentIterator
(
mExtent
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstBlock
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
FirstBlock
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
ExpandRangeToWordBoundaries
(
StaticRange
*
aStaticRange
)
{
MOZ_ASSERT
(
aStaticRange
)
;
nsCOMPtr
<
nsINode
>
rngStartNode
rngEndNode
;
uint32_t
rngStartOffset
rngEndOffset
;
nsresult
rv
=
GetRangeEndPoints
(
aStaticRange
getter_AddRefs
(
rngStartNode
)
&
rngStartOffset
getter_AddRefs
(
rngEndNode
)
&
rngEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
rv
=
CreateFilteredContentIterator
(
aStaticRange
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
IteratorStatus
iterStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstTextNode
(
filteredIter
&
iterStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
iterStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
nsINode
*
firstText
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
firstText
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
LastTextNode
(
filteredIter
&
iterStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
iterStatus
=
=
IteratorStatus
:
:
eDone
)
{
NS_ASSERTION
(
false
"
Found
a
first
without
a
last
!
"
)
;
return
NS_ERROR_FAILURE
;
}
nsINode
*
lastText
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
lastText
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rngStartNode
!
=
firstText
)
{
rngStartNode
=
firstText
;
rngStartOffset
=
0
;
}
if
(
rngEndNode
!
=
lastText
)
{
rngEndNode
=
lastText
;
rngEndOffset
=
lastText
-
>
Length
(
)
;
}
RefPtr
<
FilteredContentIterator
>
docFilteredIter
;
rv
=
CreateDocumentContentIterator
(
getter_AddRefs
(
docFilteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
docFilteredIter
-
>
PositionAt
(
firstText
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iterStatus
=
IteratorStatus
:
:
eValid
;
nsTArray
<
OffsetEntry
*
>
offsetTable
;
nsAutoString
blockStr
;
rv
=
CreateOffsetTable
(
&
offsetTable
docFilteredIter
&
iterStatus
nullptr
&
blockStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
ClearOffsetTable
(
&
offsetTable
)
;
return
rv
;
}
nsCOMPtr
<
nsINode
>
wordStartNode
wordEndNode
;
uint32_t
wordStartOffset
wordEndOffset
;
rv
=
FindWordBounds
(
&
offsetTable
&
blockStr
rngStartNode
rngStartOffset
getter_AddRefs
(
wordStartNode
)
&
wordStartOffset
getter_AddRefs
(
wordEndNode
)
&
wordEndOffset
)
;
ClearOffsetTable
(
&
offsetTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rngStartNode
=
wordStartNode
;
rngStartOffset
=
wordStartOffset
;
rv
=
docFilteredIter
-
>
PositionAt
(
lastText
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iterStatus
=
IteratorStatus
:
:
eValid
;
rv
=
CreateOffsetTable
(
&
offsetTable
docFilteredIter
&
iterStatus
nullptr
&
blockStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
ClearOffsetTable
(
&
offsetTable
)
;
return
rv
;
}
rv
=
FindWordBounds
(
&
offsetTable
&
blockStr
rngEndNode
rngEndOffset
getter_AddRefs
(
wordStartNode
)
&
wordStartOffset
getter_AddRefs
(
wordEndNode
)
&
wordEndOffset
)
;
ClearOffsetTable
(
&
offsetTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
rngEndNode
!
=
wordStartNode
|
|
rngEndOffset
!
=
wordStartOffset
|
|
(
rngEndNode
=
=
rngStartNode
&
&
rngEndOffset
=
=
rngStartOffset
)
)
{
rngEndNode
=
wordEndNode
;
rngEndOffset
=
wordEndOffset
;
}
rv
=
aStaticRange
-
>
SetStartAndEnd
(
rngStartNode
rngStartOffset
rngEndNode
rngEndOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
update
the
given
range
"
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
SetFilterType
(
uint32_t
aFilterType
)
{
mTxtSvcFilterType
=
aFilterType
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
GetCurrentTextBlock
(
nsAString
&
aStr
)
{
aStr
.
Truncate
(
)
;
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
nsresult
rv
=
CreateOffsetTable
(
&
mOffsetTable
mFilteredIter
&
mIteratorStatus
mExtent
&
aStr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
nsresult
rv
=
FirstTextNode
(
mFilteredIter
&
mIteratorStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
mPrevTextBlock
=
nullptr
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
LastSelectedBlock
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
NS_ENSURE_TRUE
(
aSelStatus
&
&
aSelOffset
&
&
aSelLength
NS_ERROR_NULL_POINTER
)
;
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockNotFound
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
if
(
!
mSelCon
|
|
!
mFilteredIter
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
const
nsRange
>
range
;
nsCOMPtr
<
nsINode
>
parent
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
!
range
)
{
return
NS_ERROR_FAILURE
;
}
parent
=
range
-
>
GetStartContainer
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
parent
-
>
IsText
(
)
)
{
rv
=
mFilteredIter
-
>
PositionAt
(
parent
-
>
AsText
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
rv
=
CreateOffsetTable
(
&
mOffsetTable
mFilteredIter
&
mIteratorStatus
mExtent
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aSelStatus
=
=
BlockSelectionStatus
:
:
eBlockContains
)
{
rv
=
SetSelectionInternal
(
*
aSelOffset
*
aSelLength
false
)
;
}
}
else
{
range
=
CreateDocumentContentRootToNodeOffsetRange
(
parent
range
-
>
StartOffset
(
)
false
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
range
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
First
(
)
;
Text
*
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
currentNode
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
currentNode
-
>
IsText
(
)
)
{
textNode
=
currentNode
-
>
AsText
(
)
;
break
;
}
}
if
(
!
textNode
)
{
return
NS_OK
;
}
rv
=
mFilteredIter
-
>
PositionAt
(
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
rv
=
CreateOffsetTable
(
&
mOffsetTable
mFilteredIter
&
mIteratorStatus
mExtent
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
rv
;
}
const
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
Selection
is
not
collapsed
so
the
range
count
should
be
1
or
larger
"
)
;
for
(
uint32_t
i
=
rangeCount
;
i
>
0
;
i
-
-
)
{
range
=
selection
-
>
GetRangeAt
(
i
-
1
IgnoreErrors
(
)
)
;
if
(
!
range
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
Last
(
)
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
if
(
filteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
filteredIter
-
>
GetCurrentNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
rv
=
CreateOffsetTable
(
&
mOffsetTable
mFilteredIter
&
mIteratorStatus
mExtent
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
}
}
range
=
selection
-
>
GetRangeAt
(
rangeCount
-
1
IgnoreErrors
(
)
)
;
if
(
!
range
)
{
return
NS_ERROR_FAILURE
;
}
parent
=
range
-
>
GetEndContainer
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
range
=
CreateDocumentContentRootToNodeOffsetRange
(
parent
range
-
>
EndOffset
(
)
false
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
range
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
First
(
)
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
if
(
filteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
filteredIter
-
>
GetCurrentNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
rv
=
CreateOffsetTable
(
&
mOffsetTable
mFilteredIter
&
mIteratorStatus
mExtent
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextServicesDocument
:
:
GetSelection
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
PrevBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
switch
(
mIteratorStatus
)
{
case
IteratorStatus
:
:
eValid
:
case
IteratorStatus
:
:
eNext
:
{
nsresult
rv
=
FirstTextNodeInPrevBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
if
(
mFilteredIter
-
>
IsDone
(
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
}
case
IteratorStatus
:
:
ePrev
:
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
default
:
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
break
;
}
nsresult
rv
=
NS_OK
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
GetFirstTextNodeInPrevBlock
(
getter_AddRefs
(
mPrevTextBlock
)
)
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
NextBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
switch
(
mIteratorStatus
)
{
case
IteratorStatus
:
:
eValid
:
{
nsresult
rv
=
FirstTextNodeInNextBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
if
(
mFilteredIter
-
>
IsDone
(
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
}
case
IteratorStatus
:
:
eNext
:
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
case
IteratorStatus
:
:
ePrev
:
default
:
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
break
;
}
nsresult
rv
=
NS_OK
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
GetFirstTextNodeInPrevBlock
(
getter_AddRefs
(
mPrevTextBlock
)
)
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
IsDone
(
bool
*
aIsDone
)
{
NS_ENSURE_TRUE
(
aIsDone
NS_ERROR_NULL_POINTER
)
;
*
aIsDone
=
false
;
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
*
aIsDone
=
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
SetSelection
(
uint32_t
aOffset
uint32_t
aLength
)
{
NS_ENSURE_TRUE
(
mSelCon
NS_ERROR_FAILURE
)
;
return
SetSelectionInternal
(
aOffset
aLength
true
)
;
}
nsresult
TextServicesDocument
:
:
ScrollSelectionIntoView
(
)
{
NS_ENSURE_TRUE
(
mSelCon
NS_ERROR_FAILURE
)
;
nsresult
rv
=
mSelCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
DeleteSelection
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
SelectionIsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
SelectionIsCollapsed
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
origStartNode
origEndNode
;
uint32_t
origStartOffset
=
0
origEndOffset
=
0
;
if
(
mExtent
)
{
nsresult
rv
=
GetRangeEndPoints
(
mExtent
getter_AddRefs
(
origStartNode
)
&
origStartOffset
getter_AddRefs
(
origEndNode
)
&
origEndOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
OffsetEntry
*
entry
*
newEntry
;
for
(
size_t
i
=
*
mSelStartIndex
;
i
<
=
*
mSelEndIndex
;
i
+
+
)
{
entry
=
mOffsetTable
[
i
]
;
if
(
i
=
=
*
mSelStartIndex
)
{
uint32_t
selLength
;
if
(
entry
-
>
mIsInsertedText
)
{
selLength
=
0
;
}
else
{
selLength
=
entry
-
>
EndOffsetInTextInBlock
(
)
-
*
mSelStartOffset
;
}
if
(
selLength
>
0
)
{
if
(
*
mSelStartOffset
>
entry
-
>
mOffsetInTextInBlock
)
{
nsresult
rv
=
SplitOffsetEntry
(
i
selLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
+
+
(
*
mSelStartIndex
)
;
+
+
(
*
mSelEndIndex
)
;
entry
=
mOffsetTable
[
+
+
i
]
;
}
if
(
*
mSelStartIndex
<
*
mSelEndIndex
)
{
entry
-
>
mIsValid
=
false
;
}
}
}
if
(
i
=
=
*
mSelEndIndex
)
{
if
(
entry
-
>
mIsInsertedText
)
{
entry
-
>
mIsValid
=
false
;
}
else
{
uint32_t
selLength
=
*
mSelEndOffset
-
entry
-
>
mOffsetInTextInBlock
;
if
(
selLength
>
0
)
{
if
(
*
mSelEndOffset
<
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
nsresult
rv
=
SplitOffsetEntry
(
i
entry
-
>
mLength
-
selLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
newEntry
=
mOffsetTable
[
i
+
1
]
;
newEntry
-
>
mOffsetInTextNode
=
entry
-
>
mOffsetInTextNode
;
}
if
(
*
mSelEndOffset
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
entry
-
>
mIsValid
=
false
;
}
}
}
}
if
(
i
!
=
*
mSelStartIndex
&
&
i
!
=
*
mSelEndIndex
)
{
entry
-
>
mIsValid
=
false
;
}
}
AdjustContentIterator
(
)
;
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
nsresult
rv
=
editorBase
-
>
DeleteSelectionAsAction
(
nsIEditor
:
:
ePrevious
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
origStartNode
&
&
origEndNode
)
{
nsCOMPtr
<
nsINode
>
curStartNode
curEndNode
;
uint32_t
curStartOffset
=
0
curEndOffset
=
0
;
rv
=
GetRangeEndPoints
(
mExtent
getter_AddRefs
(
curStartNode
)
&
curStartOffset
getter_AddRefs
(
curEndNode
)
&
curEndOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
origStartNode
!
=
curStartNode
|
|
origEndNode
!
=
curEndNode
)
{
nsCOMPtr
<
nsIContent
>
curContent
;
if
(
mIteratorStatus
!
=
IteratorStatus
:
:
eDone
)
{
curContent
=
mFilteredIter
-
>
GetCurrentNode
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
}
rv
=
CreateFilteredContentIterator
(
mExtent
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curContent
)
{
rv
=
mFilteredIter
-
>
PositionAt
(
curContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
}
}
}
entry
=
nullptr
;
for
(
size_t
i
=
*
mSelStartIndex
+
1
;
!
entry
&
&
i
>
0
;
i
-
-
)
{
entry
=
mOffsetTable
[
i
-
1
]
;
if
(
!
entry
-
>
mIsValid
)
{
entry
=
nullptr
;
}
else
{
mSelStartIndex
=
mSelEndIndex
=
Some
(
i
-
1
)
;
mSelStartOffset
=
mSelEndOffset
=
Some
(
entry
-
>
EndOffsetInTextInBlock
(
)
)
;
}
}
for
(
size_t
i
=
*
mSelEndIndex
;
!
entry
&
&
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
entry
=
mOffsetTable
[
i
]
;
if
(
!
entry
-
>
mIsValid
)
{
entry
=
nullptr
;
}
else
{
mSelStartIndex
=
mSelEndIndex
=
Some
(
i
)
;
mSelStartOffset
=
mSelEndOffset
=
Some
(
entry
-
>
mOffsetInTextInBlock
)
;
}
}
if
(
entry
)
{
SetSelection
(
*
mSelStartOffset
0
)
;
}
else
{
mSelStartIndex
.
reset
(
)
;
mSelEndIndex
.
reset
(
)
;
mSelStartOffset
.
reset
(
)
;
mSelEndOffset
.
reset
(
)
;
}
return
RemoveInvalidOffsetEntries
(
)
;
}
nsresult
TextServicesDocument
:
:
InsertText
(
const
nsAString
&
aText
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
SelectionIsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
collapsedSelection
=
SelectionIsCollapsed
(
)
;
uint32_t
savedSelOffset
=
*
mSelStartOffset
;
uint32_t
savedSelLength
=
*
mSelEndOffset
-
*
mSelStartOffset
;
if
(
!
collapsedSelection
)
{
nsresult
rv
=
SetSelection
(
*
mSelStartOffset
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
AutoTransactionBatchExternal
treatAsOneTransaction
(
editorBase
)
;
nsresult
rv
=
editorBase
-
>
InsertTextAsAction
(
aText
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InsertTextAsAction
(
)
failed
"
)
;
return
rv
;
}
uint32_t
strLength
=
aText
.
Length
(
)
;
OffsetEntry
*
const
entry
=
mOffsetTable
[
*
mSelStartIndex
]
;
OwningNonNull
<
Text
>
const
textNodeAtStartEntry
=
entry
-
>
mTextNode
;
NS_ASSERTION
(
(
entry
-
>
mIsValid
)
"
Invalid
insertion
point
!
"
)
;
if
(
entry
-
>
mOffsetInTextInBlock
=
=
*
mSelStartOffset
)
{
if
(
entry
-
>
mIsInsertedText
)
{
entry
-
>
mLength
+
=
strLength
;
}
else
{
OffsetEntry
*
itEntry
=
new
OffsetEntry
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextInBlock
strLength
)
;
itEntry
-
>
mIsInsertedText
=
true
;
itEntry
-
>
mOffsetInTextNode
=
entry
-
>
mOffsetInTextNode
;
mOffsetTable
.
InsertElementAt
(
*
mSelStartIndex
itEntry
)
;
}
}
else
if
(
entry
-
>
EndOffsetInTextInBlock
(
)
=
=
*
mSelStartOffset
)
{
uint32_t
nextIndex
=
*
mSelStartIndex
+
1
;
OffsetEntry
*
itEntry
=
nullptr
;
if
(
mOffsetTable
.
Length
(
)
>
nextIndex
)
{
itEntry
=
mOffsetTable
[
nextIndex
]
;
if
(
!
itEntry
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
itEntry
-
>
mIsInsertedText
|
|
itEntry
-
>
mOffsetInTextInBlock
!
=
*
mSelStartOffset
)
{
itEntry
=
0
;
}
}
if
(
!
itEntry
)
{
itEntry
=
new
OffsetEntry
(
entry
-
>
mTextNode
*
mSelStartOffset
0
)
;
itEntry
-
>
mOffsetInTextNode
=
entry
-
>
EndOffsetInTextNode
(
)
;
itEntry
-
>
mIsInsertedText
=
true
;
mOffsetTable
.
InsertElementAt
(
nextIndex
itEntry
)
;
}
itEntry
-
>
mLength
+
=
strLength
;
mSelStartIndex
=
mSelEndIndex
=
Some
(
nextIndex
)
;
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
rv
;
}
OwningNonNull
<
Text
>
textNode
=
itEntry
-
>
mTextNode
;
rv
=
selection
-
>
CollapseInLimiter
(
textNode
itEntry
-
>
EndOffsetInTextNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
if
(
entry
-
>
EndOffsetInTextInBlock
(
)
>
*
mSelStartOffset
)
{
nsresult
rv
=
SplitOffsetEntry
(
*
mSelStartIndex
entry
-
>
EndOffsetInTextInBlock
(
)
-
*
mSelStartOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
OffsetEntry
*
itEntry
=
new
OffsetEntry
(
entry
-
>
mTextNode
*
mSelStartOffset
strLength
)
;
itEntry
-
>
mIsInsertedText
=
true
;
itEntry
-
>
mOffsetInTextNode
=
entry
-
>
EndOffsetInTextNode
(
)
;
mOffsetTable
.
InsertElementAt
(
+
+
(
*
mSelStartIndex
)
itEntry
)
;
mSelEndIndex
=
mSelStartIndex
;
}
for
(
size_t
i
=
*
mSelStartIndex
+
1
;
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
if
(
entry
-
>
mTextNode
!
=
textNodeAtStartEntry
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mOffsetInTextNode
+
=
strLength
;
}
}
if
(
!
collapsedSelection
)
{
nsresult
rv
=
SetSelection
(
savedSelOffset
savedSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
DeleteSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
void
TextServicesDocument
:
:
DidDeleteNode
(
nsINode
*
aChild
)
{
if
(
NS_WARN_IF
(
!
mFilteredIter
)
)
{
return
;
}
size_t
nodeIndex
=
0
;
bool
hasEntry
=
false
;
nsresult
rv
=
NodeHasOffsetEntry
(
&
mOffsetTable
aChild
&
hasEntry
&
nodeIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
hasEntry
)
{
return
;
}
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
&
&
node
=
=
aChild
&
&
mIteratorStatus
!
=
IteratorStatus
:
:
eDone
)
{
NS_ERROR
(
"
DeleteNode
called
for
current
iterator
node
.
"
)
;
}
const
size_t
tableLength
=
mOffsetTable
.
Length
(
)
;
while
(
nodeIndex
<
tableLength
)
{
OffsetEntry
*
const
entry
=
mOffsetTable
[
nodeIndex
]
;
if
(
!
entry
)
{
return
;
}
if
(
entry
-
>
mTextNode
=
=
aChild
)
{
entry
-
>
mIsValid
=
false
;
}
nodeIndex
+
+
;
}
}
void
TextServicesDocument
:
:
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
aLeftNode
.
IsText
(
)
|
|
!
aRightNode
.
IsText
(
)
)
{
return
;
}
size_t
leftIndex
=
0
;
bool
leftHasEntry
=
false
;
nsresult
rv
=
NodeHasOffsetEntry
(
&
mOffsetTable
aLeftNode
.
AsText
(
)
&
leftHasEntry
&
leftIndex
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
leftHasEntry
)
{
return
;
}
size_t
rightIndex
=
0
;
bool
rightHasEntry
=
false
;
rv
=
NodeHasOffsetEntry
(
&
mOffsetTable
aRightNode
.
AsText
(
)
&
rightHasEntry
&
rightIndex
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
rightHasEntry
)
{
return
;
}
NS_ASSERTION
(
leftIndex
<
rightIndex
"
Indexes
out
of
order
.
"
)
;
if
(
leftIndex
>
rightIndex
)
{
return
;
}
NS_ASSERTION
(
mOffsetTable
[
rightIndex
]
-
>
mOffsetInTextNode
=
=
0
"
Unexpected
offset
value
for
rightIndex
.
"
)
;
uint32_t
nodeLength
=
aLeftNode
.
AsText
(
)
-
>
Length
(
)
;
for
(
uint32_t
i
=
leftIndex
;
i
<
rightIndex
;
i
+
+
)
{
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
if
(
entry
-
>
mTextNode
!
=
aLeftNode
.
AsText
(
)
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mTextNode
=
aRightNode
.
AsText
(
)
;
}
}
for
(
uint32_t
i
=
rightIndex
;
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
if
(
entry
-
>
mTextNode
!
=
aRightNode
.
AsText
(
)
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mOffsetInTextNode
+
=
nodeLength
;
}
}
if
(
mFilteredIter
-
>
GetCurrentNode
(
)
=
=
aLeftNode
.
AsText
(
)
)
{
mFilteredIter
-
>
PositionAt
(
aRightNode
.
AsText
(
)
)
;
}
}
nsresult
TextServicesDocument
:
:
CreateFilteredContentIterator
(
const
AbstractRange
*
aAbstractRange
FilteredContentIterator
*
*
aFilteredIter
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aFilteredIter
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aFilteredIter
=
nullptr
;
UniquePtr
<
nsComposeTxtSrvFilter
>
composeFilter
;
switch
(
mTxtSvcFilterType
)
{
case
nsIEditorSpellCheck
:
:
FILTERTYPE_NORMAL
:
composeFilter
=
nsComposeTxtSrvFilter
:
:
CreateNormalFilter
(
)
;
break
;
case
nsIEditorSpellCheck
:
:
FILTERTYPE_MAIL
:
composeFilter
=
nsComposeTxtSrvFilter
:
:
CreateMailFilter
(
)
;
break
;
}
RefPtr
<
FilteredContentIterator
>
filter
=
new
FilteredContentIterator
(
std
:
:
move
(
composeFilter
)
)
;
nsresult
rv
=
filter
-
>
Init
(
aAbstractRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filter
.
forget
(
aFilteredIter
)
;
return
NS_OK
;
}
Element
*
TextServicesDocument
:
:
GetDocumentContentRootNode
(
)
const
{
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
nullptr
;
}
if
(
mDocument
-
>
IsHTMLOrXHTML
(
)
)
{
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsXULElement
(
)
)
{
return
mDocument
-
>
GetDocumentElement
(
)
;
}
return
mDocument
-
>
GetBody
(
)
;
}
return
mDocument
-
>
GetDocumentElement
(
)
;
}
already_AddRefed
<
nsRange
>
TextServicesDocument
:
:
CreateDocumentContentRange
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetDocumentContentRootNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
node
)
;
IgnoredErrorResult
ignoredError
;
range
-
>
SelectNodeContents
(
*
node
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
SelectNodeContents
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
TextServicesDocument
:
:
CreateDocumentContentRootToNodeOffsetRange
(
nsINode
*
aParent
uint32_t
aOffset
bool
aToStart
)
{
if
(
NS_WARN_IF
(
!
aParent
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
bodyNode
=
GetDocumentContentRootNode
(
)
;
if
(
NS_WARN_IF
(
!
bodyNode
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
startNode
;
nsCOMPtr
<
nsINode
>
endNode
;
uint32_t
startOffset
endOffset
;
if
(
aToStart
)
{
startNode
=
bodyNode
;
startOffset
=
0
;
endNode
=
aParent
;
endOffset
=
aOffset
;
}
else
{
startNode
=
aParent
;
startOffset
=
aOffset
;
endNode
=
bodyNode
;
endOffset
=
endNode
?
endNode
-
>
GetChildCount
(
)
:
0
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startNode
startOffset
endNode
endOffset
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
to
create
new
valid
range
"
)
;
return
range
.
forget
(
)
;
}
nsresult
TextServicesDocument
:
:
CreateDocumentContentIterator
(
FilteredContentIterator
*
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
nsRange
>
range
=
CreateDocumentContentRange
(
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
*
aFilteredIter
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
return
CreateFilteredContentIterator
(
range
aFilteredIter
)
;
}
nsresult
TextServicesDocument
:
:
AdjustContentIterator
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
Text
*
prevValidTextNode
=
nullptr
;
Text
*
nextValidTextNode
=
nullptr
;
bool
foundEntry
=
false
;
const
size_t
tableLength
=
mOffsetTable
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
tableLength
&
&
!
nextValidTextNode
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
if
(
entry
-
>
mTextNode
=
=
node
)
{
if
(
entry
-
>
mIsValid
)
{
return
NS_OK
;
}
foundEntry
=
true
;
}
if
(
entry
-
>
mIsValid
)
{
if
(
!
foundEntry
)
{
prevValidTextNode
=
entry
-
>
mTextNode
;
}
else
{
nextValidTextNode
=
entry
-
>
mTextNode
;
}
}
}
Text
*
validTextNode
=
nullptr
;
if
(
prevValidTextNode
)
{
validTextNode
=
prevValidTextNode
;
}
else
if
(
nextValidTextNode
)
{
validTextNode
=
nextValidTextNode
;
}
if
(
validTextNode
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
validTextNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
return
rv
;
}
if
(
mNextTextBlock
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
mNextTextBlock
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eNext
;
}
else
if
(
mPrevTextBlock
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
mPrevTextBlock
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
ePrev
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
return
NS_OK
;
}
bool
TextServicesDocument
:
:
DidSkip
(
FilteredContentIterator
*
aFilteredIter
)
{
return
aFilteredIter
&
&
aFilteredIter
-
>
DidSkip
(
)
;
}
void
TextServicesDocument
:
:
ClearDidSkip
(
FilteredContentIterator
*
aFilteredIter
)
{
if
(
aFilteredIter
)
{
aFilteredIter
-
>
ClearDidSkip
(
)
;
}
}
bool
TextServicesDocument
:
:
IsBlockNode
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
NS_ERROR
(
"
How
did
a
null
pointer
get
passed
to
IsBlockNode
?
"
)
;
return
false
;
}
nsAtom
*
atom
=
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
return
(
nsGkAtoms
:
:
a
!
=
atom
&
&
nsGkAtoms
:
:
address
!
=
atom
&
&
nsGkAtoms
:
:
big
!
=
atom
&
&
nsGkAtoms
:
:
b
!
=
atom
&
&
nsGkAtoms
:
:
cite
!
=
atom
&
&
nsGkAtoms
:
:
code
!
=
atom
&
&
nsGkAtoms
:
:
dfn
!
=
atom
&
&
nsGkAtoms
:
:
em
!
=
atom
&
&
nsGkAtoms
:
:
font
!
=
atom
&
&
nsGkAtoms
:
:
i
!
=
atom
&
&
nsGkAtoms
:
:
kbd
!
=
atom
&
&
nsGkAtoms
:
:
nobr
!
=
atom
&
&
nsGkAtoms
:
:
s
!
=
atom
&
&
nsGkAtoms
:
:
samp
!
=
atom
&
&
nsGkAtoms
:
:
small
!
=
atom
&
&
nsGkAtoms
:
:
spacer
!
=
atom
&
&
nsGkAtoms
:
:
span
!
=
atom
&
&
nsGkAtoms
:
:
strike
!
=
atom
&
&
nsGkAtoms
:
:
strong
!
=
atom
&
&
nsGkAtoms
:
:
sub
!
=
atom
&
&
nsGkAtoms
:
:
sup
!
=
atom
&
&
nsGkAtoms
:
:
tt
!
=
atom
&
&
nsGkAtoms
:
:
u
!
=
atom
&
&
nsGkAtoms
:
:
var
!
=
atom
&
&
nsGkAtoms
:
:
wbr
!
=
atom
)
;
}
bool
TextServicesDocument
:
:
HasSameBlockNodeParent
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
{
nsIContent
*
p1
=
aContent1
-
>
GetParent
(
)
;
nsIContent
*
p2
=
aContent2
-
>
GetParent
(
)
;
if
(
p1
=
=
p2
)
{
return
true
;
}
while
(
p1
&
&
!
IsBlockNode
(
p1
)
)
{
p1
=
p1
-
>
GetParent
(
)
;
}
while
(
p2
&
&
!
IsBlockNode
(
p2
)
)
{
p2
=
p2
-
>
GetParent
(
)
;
}
return
p1
=
=
p2
;
}
nsresult
TextServicesDocument
:
:
SetSelectionInternal
(
uint32_t
aOffset
uint32_t
aLength
bool
aDoUpdate
)
{
if
(
NS_WARN_IF
(
!
mSelCon
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Text
>
startTextNode
;
uint32_t
startNodeOffset
=
0
;
for
(
size_t
i
=
0
;
!
startTextNode
&
&
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
if
(
entry
-
>
mIsValid
)
{
if
(
entry
-
>
mIsInsertedText
)
{
if
(
entry
-
>
mOffsetInTextInBlock
=
=
aOffset
)
{
startTextNode
=
entry
-
>
mTextNode
;
startNodeOffset
=
entry
-
>
EndOffsetInTextNode
(
)
;
}
}
else
if
(
aOffset
>
=
entry
-
>
mOffsetInTextInBlock
)
{
bool
foundEntry
=
false
;
if
(
aOffset
<
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
foundEntry
=
true
;
}
else
if
(
aOffset
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
if
(
i
+
1
<
mOffsetTable
.
Length
(
)
)
{
OffsetEntry
*
nextEntry
=
mOffsetTable
[
i
+
1
]
;
if
(
!
nextEntry
-
>
mIsValid
|
|
nextEntry
-
>
mOffsetInTextInBlock
!
=
aOffset
)
{
foundEntry
=
true
;
}
}
}
if
(
foundEntry
)
{
startTextNode
=
entry
-
>
mTextNode
;
startNodeOffset
=
entry
-
>
mOffsetInTextNode
+
aOffset
-
entry
-
>
mOffsetInTextInBlock
;
}
}
if
(
startTextNode
)
{
mSelStartIndex
=
Some
(
i
)
;
mSelStartOffset
=
Some
(
aOffset
)
;
}
}
}
NS_ENSURE_TRUE
(
startTextNode
NS_ERROR_FAILURE
)
;
RefPtr
<
Selection
>
selection
;
if
(
aDoUpdate
)
{
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
aLength
)
{
if
(
aDoUpdate
)
{
nsresult
rv
=
selection
-
>
CollapseInLimiter
(
startTextNode
startNodeOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mSelEndIndex
=
mSelStartIndex
;
mSelEndOffset
=
mSelStartOffset
;
return
NS_OK
;
}
RefPtr
<
Text
>
endTextNode
;
uint32_t
endNodeOffset
=
0
;
uint32_t
endOffset
=
aOffset
+
aLength
;
for
(
uint32_t
i
=
mOffsetTable
.
Length
(
)
;
!
endTextNode
&
&
i
>
0
;
i
-
-
)
{
const
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
-
1
]
;
if
(
entry
-
>
mIsValid
)
{
if
(
entry
-
>
mIsInsertedText
)
{
if
(
entry
-
>
mOffsetInTextInBlock
=
=
endNodeOffset
)
{
endTextNode
=
entry
-
>
mTextNode
;
endNodeOffset
=
entry
-
>
EndOffsetInTextNode
(
)
;
}
}
else
if
(
endOffset
>
=
entry
-
>
mOffsetInTextInBlock
&
&
endOffset
<
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
endTextNode
=
entry
-
>
mTextNode
;
endNodeOffset
=
entry
-
>
mOffsetInTextNode
+
endOffset
-
entry
-
>
mOffsetInTextInBlock
;
}
if
(
endTextNode
)
{
mSelEndIndex
=
Some
(
i
-
1
)
;
mSelEndOffset
=
Some
(
endOffset
)
;
}
}
}
if
(
!
aDoUpdate
)
{
return
NS_OK
;
}
if
(
!
endTextNode
)
{
nsresult
rv
=
selection
-
>
CollapseInLimiter
(
startTextNode
startNodeOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
return
rv
;
}
ErrorResult
error
;
selection
-
>
SetStartAndEndInLimiter
(
RawRangeBoundary
(
startTextNode
startNodeOffset
)
RawRangeBoundary
(
endTextNode
endNodeOffset
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
selection
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
TextServicesDocument
:
:
GetSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
NS_ENSURE_TRUE
(
aSelStatus
&
&
aSelOffset
&
&
aSelLength
NS_ERROR_NULL_POINTER
)
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockNotFound
;
*
aSelOffset
=
UINT32_MAX
;
*
aSelLength
=
UINT32_MAX
;
NS_ENSURE_TRUE
(
mDocument
&
&
mSelCon
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
return
GetCollapsedSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
return
GetUncollapsedSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
nsresult
TextServicesDocument
:
:
GetCollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockOutside
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
const
uint32_t
tableCount
=
mOffsetTable
.
Length
(
)
;
if
(
!
tableCount
)
{
return
NS_OK
;
}
OffsetEntry
*
eStart
=
mOffsetTable
[
0
]
;
OffsetEntry
*
eEnd
;
if
(
tableCount
>
1
)
{
eEnd
=
mOffsetTable
[
tableCount
-
1
]
;
}
else
{
eEnd
=
eStart
;
}
const
uint32_t
eStartOffset
=
eStart
-
>
mOffsetInTextNode
;
const
uint32_t
eEndOffset
=
eEnd
-
>
EndOffsetInTextNode
(
)
;
RefPtr
<
const
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
nsCOMPtr
<
nsINode
>
parent
=
range
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
parent
)
;
uint32_t
offset
=
range
-
>
StartOffset
(
)
;
const
Maybe
<
int32_t
>
e1s1
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eStartOffset
)
parent
AssertedCast
<
int32_t
>
(
offset
)
)
;
const
Maybe
<
int32_t
>
e2s1
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eEndOffset
)
parent
AssertedCast
<
int32_t
>
(
offset
)
)
;
if
(
NS_WARN_IF
(
!
e1s1
)
|
|
NS_WARN_IF
(
!
e2s1
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
e1s1
>
0
|
|
*
e2s1
<
0
)
{
return
NS_OK
;
}
if
(
parent
-
>
IsText
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
if
(
entry
-
>
mTextNode
=
=
parent
-
>
AsText
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
offset
)
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
offset
-
entry
-
>
mOffsetInTextNode
)
;
*
aSelLength
=
0
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
range
=
nsRange
:
:
Create
(
eStart
-
>
mTextNode
eStartOffset
eEnd
-
>
mTextNode
eEndOffset
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIContent
*
saveNode
;
if
(
parent
-
>
HasChildren
(
)
)
{
nsIContent
*
content
=
range
-
>
GetChildAtStartOffset
(
)
;
if
(
content
&
&
parent
-
>
GetFirstChild
(
)
!
=
content
)
{
content
=
content
-
>
GetPreviousSibling
(
)
;
}
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
nsresult
rv
=
filteredIter
-
>
PositionAt
(
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
saveNode
=
content
;
}
else
{
NS_ENSURE_TRUE
(
parent
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIContent
>
content
=
parent
-
>
AsContent
(
)
;
nsresult
rv
=
filteredIter
-
>
PositionAt
(
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
saveNode
=
content
;
}
Text
*
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
nsINode
*
current
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
current
-
>
IsText
(
)
)
{
textNode
=
current
-
>
AsText
(
)
;
break
;
}
}
if
(
textNode
)
{
offset
=
textNode
-
>
TextLength
(
)
;
}
else
{
nsresult
rv
=
filteredIter
-
>
PositionAt
(
saveNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
current
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
current
-
>
IsText
(
)
)
{
textNode
=
current
-
>
AsText
(
)
;
break
;
}
}
NS_ENSURE_TRUE
(
textNode
NS_ERROR_FAILURE
)
;
offset
=
0
;
}
for
(
size_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
mOffsetTable
[
i
]
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
if
(
entry
-
>
mTextNode
=
=
textNode
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
offset
)
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
offset
-
entry
-
>
mOffsetInTextNode
)
;
*
aSelLength
=
0
;
return
SetSelectionInternal
(
*
aSelOffset
*
aSelLength
true
)
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
TextServicesDocument
:
:
GetUncollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
RefPtr
<
const
nsRange
>
range
;
OffsetEntry
*
entry
;
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
startContainer
endContainer
;
const
size_t
tableCount
=
mOffsetTable
.
Length
(
)
;
OffsetEntry
*
eStart
=
mOffsetTable
[
0
]
;
OffsetEntry
*
eEnd
;
if
(
tableCount
>
1
)
{
eEnd
=
mOffsetTable
[
tableCount
-
1
]
;
}
else
{
eEnd
=
eStart
;
}
const
uint32_t
eStartOffset
=
eStart
-
>
mOffsetInTextNode
;
const
uint32_t
eEndOffset
=
eEnd
-
>
EndOffsetInTextNode
(
)
;
const
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
)
;
Maybe
<
int32_t
>
e1s2
;
Maybe
<
int32_t
>
e2s1
;
uint32_t
startOffset
endOffset
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
range
=
selection
-
>
GetRangeAt
(
i
IgnoreErrors
(
)
)
;
NS_ENSURE_STATE
(
range
)
;
nsresult
rv
=
GetRangeEndPoints
(
range
getter_AddRefs
(
startContainer
)
&
startOffset
getter_AddRefs
(
endContainer
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
e1s2
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eStartOffset
)
endContainer
AssertedCast
<
int32_t
>
(
endOffset
)
)
;
if
(
NS_WARN_IF
(
!
e1s2
)
)
{
return
NS_ERROR_FAILURE
;
}
e2s1
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eEndOffset
)
startContainer
AssertedCast
<
int32_t
>
(
startOffset
)
)
;
if
(
NS_WARN_IF
(
!
e2s1
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
e1s2
<
=
0
&
&
*
e2s1
>
=
0
)
{
break
;
}
}
if
(
rangeCount
<
1
|
|
*
e1s2
>
0
|
|
*
e2s1
<
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockOutside
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
return
NS_OK
;
}
const
Maybe
<
int32_t
>
e1s1
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eStartOffset
)
startContainer
AssertedCast
<
int32_t
>
(
startOffset
)
)
;
if
(
NS_WARN_IF
(
!
e1s1
)
)
{
return
NS_ERROR_FAILURE
;
}
const
Maybe
<
int32_t
>
e2s2
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
AssertedCast
<
int32_t
>
(
eEndOffset
)
endContainer
AssertedCast
<
int32_t
>
(
endOffset
)
)
;
if
(
NS_WARN_IF
(
!
e2s2
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rangeCount
>
1
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockPartial
;
}
else
if
(
*
e1s1
>
0
&
&
*
e2s2
<
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockInside
;
}
else
if
(
*
e1s1
<
=
0
&
&
*
e2s2
>
=
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
}
else
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockPartial
;
}
nsCOMPtr
<
nsINode
>
p1
p2
;
uint32_t
o1
o2
;
if
(
*
e1s1
>
=
0
)
{
p1
=
eStart
-
>
mTextNode
;
o1
=
eStartOffset
;
}
else
{
p1
=
startContainer
;
o1
=
startOffset
;
}
if
(
*
e2s2
<
=
0
)
{
p2
=
eEnd
-
>
mTextNode
;
o2
=
eEndOffset
;
}
else
{
p2
=
endContainer
;
o2
=
endOffset
;
}
range
=
nsRange
:
:
Create
(
p1
o1
p2
o2
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContent
>
content
;
filteredIter
-
>
First
(
)
;
if
(
!
p1
-
>
IsText
(
)
)
{
bool
found
=
false
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
node
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsText
(
)
)
{
p1
=
node
-
>
AsText
(
)
;
o1
=
0
;
found
=
true
;
break
;
}
}
NS_ENSURE_TRUE
(
found
NS_ERROR_FAILURE
)
;
}
filteredIter
-
>
Last
(
)
;
if
(
!
p2
-
>
IsText
(
)
)
{
bool
found
=
false
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
nsINode
*
node
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsText
(
)
)
{
p2
=
node
-
>
AsText
(
)
;
o2
=
p2
-
>
AsText
(
)
-
>
Length
(
)
;
found
=
true
;
break
;
}
}
NS_ENSURE_TRUE
(
found
NS_ERROR_FAILURE
)
;
}
bool
found
=
false
;
*
aSelLength
=
0
;
for
(
size_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
entry
=
mOffsetTable
[
i
]
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
if
(
!
found
)
{
if
(
entry
-
>
mTextNode
=
=
p1
.
get
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o1
)
)
{
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
o1
-
entry
-
>
mOffsetInTextNode
)
;
if
(
p1
=
=
p2
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o2
)
)
{
*
aSelLength
=
o2
-
o1
;
break
;
}
*
aSelLength
=
entry
-
>
EndOffsetInTextNode
(
)
-
o1
;
found
=
true
;
}
}
else
{
if
(
entry
-
>
mTextNode
=
=
p2
.
get
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o2
)
)
{
*
aSelLength
+
=
o2
-
entry
-
>
mOffsetInTextNode
;
break
;
}
*
aSelLength
+
=
entry
-
>
mLength
;
}
}
return
NS_OK
;
}
bool
TextServicesDocument
:
:
SelectionIsCollapsed
(
)
const
{
return
!
SelectionIsValid
(
)
|
|
(
*
mSelStartIndex
=
=
*
mSelEndIndex
&
&
*
mSelStartOffset
=
=
*
mSelEndOffset
)
;
}
bool
TextServicesDocument
:
:
SelectionIsValid
(
)
const
{
return
mSelStartIndex
.
isSome
(
)
&
&
mSelEndIndex
.
isSome
(
)
&
&
mSelStartOffset
.
isSome
(
)
&
&
mSelEndOffset
.
isSome
(
)
;
}
nsresult
TextServicesDocument
:
:
GetRangeEndPoints
(
const
AbstractRange
*
aAbstractRange
nsINode
*
*
aStartContainer
uint32_t
*
aStartOffset
nsINode
*
*
aEndContainer
uint32_t
*
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aStartContainer
)
|
|
NS_WARN_IF
(
!
aEndContainer
)
|
|
NS_WARN_IF
(
!
aEndOffset
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsINode
>
startContainer
=
aAbstractRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startContainer
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
endContainer
=
aAbstractRange
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endContainer
)
)
{
return
NS_ERROR_FAILURE
;
}
startContainer
.
forget
(
aStartContainer
)
;
endContainer
.
forget
(
aEndContainer
)
;
*
aStartOffset
=
aAbstractRange
-
>
StartOffset
(
)
;
*
aEndOffset
=
aAbstractRange
-
>
EndOffset
(
)
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
for
(
aFilteredIter
-
>
First
(
)
;
!
aFilteredIter
-
>
IsDone
(
)
;
aFilteredIter
-
>
Next
(
)
)
{
if
(
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
break
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
LastTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
for
(
aFilteredIter
-
>
Last
(
)
;
!
aFilteredIter
-
>
IsDone
(
)
;
aFilteredIter
-
>
Prev
(
)
)
{
if
(
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
break
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInCurrentBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
ClearDidSkip
(
aFilteredIter
)
;
RefPtr
<
Text
>
lastTextNode
;
while
(
!
aFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
lastTextNode
&
&
IsBlockNode
(
content
)
)
{
break
;
}
if
(
content
&
&
content
-
>
IsText
(
)
)
{
if
(
lastTextNode
&
&
!
HasSameBlockNodeParent
(
content
-
>
AsText
(
)
lastTextNode
)
)
{
break
;
}
lastTextNode
=
content
-
>
AsText
(
)
;
}
aFilteredIter
-
>
Prev
(
)
;
if
(
DidSkip
(
aFilteredIter
)
)
{
break
;
}
}
if
(
lastTextNode
)
{
aFilteredIter
-
>
PositionAt
(
lastTextNode
)
;
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInPrevBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
FirstTextNodeInCurrentBlock
(
aFilteredIter
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
aFilteredIter
-
>
Prev
(
)
;
if
(
aFilteredIter
-
>
IsDone
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
FirstTextNodeInCurrentBlock
(
aFilteredIter
)
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInNextBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
bool
crossedBlockBoundary
=
false
;
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
ClearDidSkip
(
aFilteredIter
)
;
RefPtr
<
Text
>
previousTextNode
;
while
(
!
aFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
content
&
&
content
-
>
IsText
(
)
)
{
if
(
crossedBlockBoundary
|
|
(
previousTextNode
&
&
!
HasSameBlockNodeParent
(
previousTextNode
content
-
>
AsText
(
)
)
)
)
{
break
;
}
previousTextNode
=
content
-
>
AsText
(
)
;
}
else
if
(
!
crossedBlockBoundary
&
&
IsBlockNode
(
content
)
)
{
crossedBlockBoundary
=
true
;
}
aFilteredIter
-
>
Next
(
)
;
if
(
!
crossedBlockBoundary
&
&
DidSkip
(
aFilteredIter
)
)
{
crossedBlockBoundary
=
true
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
GetFirstTextNodeInPrevBlock
(
nsIContent
*
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
*
aContent
=
0
;
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
nsresult
rv
=
FirstTextNodeInPrevBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mFilteredIter
-
>
PositionAt
(
node
)
;
return
rv
;
}
if
(
!
mFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
current
=
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
current
.
forget
(
aContent
)
;
}
return
mFilteredIter
-
>
PositionAt
(
node
)
;
}
nsresult
TextServicesDocument
:
:
GetFirstTextNodeInNextBlock
(
nsIContent
*
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
*
aContent
=
0
;
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
nsresult
rv
=
FirstTextNodeInNextBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mFilteredIter
-
>
PositionAt
(
node
)
;
return
rv
;
}
if
(
!
mFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
current
=
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
current
.
forget
(
aContent
)
;
}
return
mFilteredIter
-
>
PositionAt
(
node
)
;
}
nsresult
TextServicesDocument
:
:
CreateOffsetTable
(
nsTArray
<
OffsetEntry
*
>
*
aOffsetTable
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
nsRange
*
aIterRange
nsAString
*
aStr
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
ClearOffsetTable
(
aOffsetTable
)
;
if
(
aStr
)
{
aStr
-
>
Truncate
(
)
;
}
if
(
*
aIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
rngStartNode
rngEndNode
;
uint32_t
rngStartOffset
=
0
rngEndOffset
=
0
;
if
(
aIterRange
)
{
nsresult
rv
=
GetRangeEndPoints
(
aIterRange
getter_AddRefs
(
rngStartNode
)
&
rngStartOffset
getter_AddRefs
(
rngEndNode
)
&
rngEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
FirstTextNodeInCurrentBlock
(
aFilteredIter
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ClearDidSkip
(
aFilteredIter
)
;
uint32_t
offset
=
0
;
RefPtr
<
Text
>
firstTextNode
previousTextNode
;
while
(
!
aFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
content
&
&
content
-
>
IsText
(
)
)
{
if
(
previousTextNode
&
&
!
HasSameBlockNodeParent
(
previousTextNode
content
-
>
AsText
(
)
)
)
{
break
;
}
nsString
str
;
content
-
>
AsText
(
)
-
>
GetNodeValue
(
str
)
;
OffsetEntry
*
entry
=
new
OffsetEntry
(
*
content
-
>
AsText
(
)
offset
str
.
Length
(
)
)
;
aOffsetTable
-
>
AppendElement
(
entry
)
;
uint32_t
startOffset
=
0
;
uint32_t
endOffset
=
str
.
Length
(
)
;
bool
adjustStr
=
false
;
if
(
entry
-
>
mTextNode
=
=
rngStartNode
)
{
entry
-
>
mOffsetInTextNode
=
startOffset
=
rngStartOffset
;
adjustStr
=
true
;
}
if
(
entry
-
>
mTextNode
=
=
rngEndNode
)
{
endOffset
=
rngEndOffset
;
adjustStr
=
true
;
}
if
(
adjustStr
)
{
entry
-
>
mLength
=
endOffset
-
startOffset
;
str
=
Substring
(
str
startOffset
entry
-
>
mLength
)
;
}
offset
+
=
str
.
Length
(
)
;
if
(
aStr
)
{
if
(
!
firstTextNode
)
{
*
aStr
=
str
;
}
else
{
*
aStr
+
=
str
;
}
}
previousTextNode
=
content
-
>
AsText
(
)
;
if
(
!
firstTextNode
)
{
firstTextNode
=
content
-
>
AsText
(
)
;
}
}
else
if
(
IsBlockNode
(
content
)
)
{
break
;
}
aFilteredIter
-
>
Next
(
)
;
if
(
DidSkip
(
aFilteredIter
)
)
{
break
;
}
}
if
(
firstTextNode
)
{
aFilteredIter
-
>
PositionAt
(
firstTextNode
)
;
}
else
{
*
aIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
RemoveInvalidOffsetEntries
(
)
{
for
(
size_t
i
=
0
;
i
<
mOffsetTable
.
Length
(
)
;
)
{
OffsetEntry
*
entry
=
mOffsetTable
[
i
]
;
if
(
!
entry
-
>
mIsValid
)
{
mOffsetTable
.
RemoveElementAt
(
i
)
;
if
(
mSelStartIndex
.
isSome
(
)
&
&
*
mSelStartIndex
>
=
i
)
{
NS_ASSERTION
(
i
!
=
*
mSelStartIndex
"
Invalid
selection
index
.
"
)
;
-
-
(
*
mSelStartIndex
)
;
-
-
(
*
mSelEndIndex
)
;
}
}
else
{
i
+
+
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
ClearOffsetTable
(
nsTArray
<
OffsetEntry
*
>
*
aOffsetTable
)
{
for
(
size_t
i
=
0
;
i
<
aOffsetTable
-
>
Length
(
)
;
i
+
+
)
{
delete
aOffsetTable
-
>
ElementAt
(
i
)
;
}
aOffsetTable
-
>
Clear
(
)
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
SplitOffsetEntry
(
size_t
aTableIndex
uint32_t
aOffsetIntoEntry
)
{
OffsetEntry
*
entry
=
mOffsetTable
[
aTableIndex
]
;
NS_ASSERTION
(
(
aOffsetIntoEntry
>
0
)
"
aOffsetIntoEntry
=
=
0
"
)
;
NS_ASSERTION
(
(
aOffsetIntoEntry
<
entry
-
>
mLength
)
"
aOffsetIntoEntry
>
=
mLength
"
)
;
if
(
aOffsetIntoEntry
<
1
|
|
aOffsetIntoEntry
>
=
entry
-
>
mLength
)
{
return
NS_ERROR_FAILURE
;
}
const
uint32_t
oldLength
=
entry
-
>
mLength
-
aOffsetIntoEntry
;
OffsetEntry
*
newEntry
=
new
OffsetEntry
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextInBlock
+
oldLength
aOffsetIntoEntry
)
;
mOffsetTable
.
InsertElementAt
(
aTableIndex
+
1
newEntry
)
;
entry
-
>
mLength
=
oldLength
;
newEntry
-
>
mOffsetInTextNode
=
entry
-
>
mOffsetInTextNode
+
oldLength
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
NodeHasOffsetEntry
(
nsTArray
<
OffsetEntry
*
>
*
aOffsetTable
nsINode
*
aNode
bool
*
aHasEntry
size_t
*
aEntryIndex
)
{
NS_ENSURE_TRUE
(
aNode
&
&
aHasEntry
&
&
aEntryIndex
NS_ERROR_NULL_POINTER
)
;
for
(
size_t
i
=
0
;
i
<
aOffsetTable
-
>
Length
(
)
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
(
*
aOffsetTable
)
[
i
]
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
if
(
entry
-
>
mTextNode
=
=
aNode
)
{
*
aHasEntry
=
true
;
*
aEntryIndex
=
i
;
return
NS_OK
;
}
}
*
aHasEntry
=
false
;
*
aEntryIndex
=
SIZE_MAX
;
return
NS_OK
;
}
#
define
IS_NBSP_CHAR
(
c
)
(
(
(
unsigned
char
)
0xa0
)
=
=
(
c
)
)
nsresult
TextServicesDocument
:
:
FindWordBounds
(
nsTArray
<
OffsetEntry
*
>
*
aOffsetTable
nsString
*
aBlockStr
nsINode
*
aNode
uint32_t
aNodeOffset
nsINode
*
*
aWordStartNode
uint32_t
*
aWordStartOffset
nsINode
*
*
aWordEndNode
uint32_t
*
aWordEndOffset
)
{
if
(
aWordStartNode
)
{
*
aWordStartNode
=
nullptr
;
}
if
(
aWordStartOffset
)
{
*
aWordStartOffset
=
0
;
}
if
(
aWordEndNode
)
{
*
aWordEndNode
=
nullptr
;
}
if
(
aWordEndOffset
)
{
*
aWordEndOffset
=
0
;
}
size_t
entryIndex
=
0
;
bool
hasEntry
=
false
;
nsresult
rv
=
NodeHasOffsetEntry
(
aOffsetTable
aNode
&
hasEntry
&
entryIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
hasEntry
NS_ERROR_FAILURE
)
;
OffsetEntry
*
entry
=
(
*
aOffsetTable
)
[
entryIndex
]
;
uint32_t
strOffset
=
entry
-
>
mOffsetInTextInBlock
+
aNodeOffset
-
entry
-
>
mOffsetInTextNode
;
const
char16_t
*
str
=
aBlockStr
-
>
get
(
)
;
uint32_t
strLen
=
aBlockStr
-
>
Length
(
)
;
mozilla
:
:
intl
:
:
WordBreaker
*
wordBreaker
=
nsContentUtils
:
:
WordBreaker
(
)
;
mozilla
:
:
intl
:
:
WordRange
res
=
wordBreaker
-
>
FindWord
(
str
strLen
strOffset
)
;
if
(
res
.
mBegin
>
strLen
)
{
return
str
?
NS_ERROR_ILLEGAL_VALUE
:
NS_ERROR_NULL_POINTER
;
}
while
(
res
.
mBegin
<
=
res
.
mEnd
&
&
IS_NBSP_CHAR
(
str
[
res
.
mBegin
]
)
)
{
res
.
mBegin
+
+
;
}
if
(
str
[
res
.
mEnd
]
=
=
(
unsigned
char
)
0x20
)
{
uint32_t
realEndWord
=
res
.
mEnd
-
1
;
while
(
realEndWord
>
res
.
mBegin
&
&
IS_NBSP_CHAR
(
str
[
realEndWord
]
)
)
{
realEndWord
-
-
;
}
if
(
realEndWord
<
res
.
mEnd
-
1
)
{
res
.
mEnd
=
realEndWord
+
1
;
}
}
size_t
lastIndex
=
aOffsetTable
-
>
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
=
lastIndex
;
i
+
+
)
{
const
OffsetEntry
*
const
entry
=
(
*
aOffsetTable
)
[
i
]
;
if
(
entry
-
>
mOffsetInTextInBlock
<
=
res
.
mBegin
&
&
(
res
.
mBegin
<
entry
-
>
EndOffsetInTextInBlock
(
)
|
|
(
res
.
mBegin
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
&
&
i
=
=
lastIndex
)
)
)
{
if
(
aWordStartNode
)
{
*
aWordStartNode
=
entry
-
>
mTextNode
;
NS_IF_ADDREF
(
*
aWordStartNode
)
;
}
if
(
aWordStartOffset
)
{
*
aWordStartOffset
=
entry
-
>
mOffsetInTextNode
+
res
.
mBegin
-
entry
-
>
mOffsetInTextInBlock
;
}
if
(
!
aWordEndNode
&
&
!
aWordEndOffset
)
{
break
;
}
}
if
(
entry
-
>
mOffsetInTextInBlock
<
=
res
.
mEnd
&
&
res
.
mEnd
<
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
if
(
res
.
mBegin
=
=
res
.
mEnd
&
&
res
.
mEnd
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
&
&
i
!
=
lastIndex
)
{
continue
;
}
if
(
aWordEndNode
)
{
*
aWordEndNode
=
entry
-
>
mTextNode
;
NS_IF_ADDREF
(
*
aWordEndNode
)
;
}
if
(
aWordEndOffset
)
{
*
aWordEndOffset
=
entry
-
>
mOffsetInTextNode
+
res
.
mEnd
-
entry
-
>
mOffsetInTextInBlock
;
}
break
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidDeleteNode
(
nsINode
*
aChild
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
NS_OK
;
}
DidDeleteNode
(
aChild
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidJoinNodes
(
nsINode
*
aLeftNode
nsINode
*
aRightNode
nsINode
*
aParent
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aLeftNode
)
|
|
NS_WARN_IF
(
!
aRightNode
)
)
{
return
NS_OK
;
}
DidJoinNodes
(
*
aLeftNode
*
aRightNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidInsertText
(
CharacterData
*
aTextNode
int32_t
aOffset
const
nsAString
&
aString
nsresult
aResult
)
{
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
WillDeleteText
(
CharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
WillDeleteRanges
(
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRangesToDelete
)
{
return
NS_OK
;
}
}
