#
include
"
TextServicesDocument
.
h
"
#
include
"
FilteredContentIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditHelpers
.
h
"
#
include
"
mozilla
/
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsComposeTxtSrvFilter
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorSpellCheck
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
using
namespace
dom
;
class
OffsetEntry
final
{
public
:
OffsetEntry
(
)
=
delete
;
OffsetEntry
(
Text
&
aTextNode
uint32_t
aOffsetInTextInBlock
uint32_t
aLength
)
:
mTextNode
(
aTextNode
)
mOffsetInTextNode
(
0
)
mOffsetInTextInBlock
(
aOffsetInTextInBlock
)
mLength
(
aLength
)
mIsInsertedText
(
false
)
mIsValid
(
true
)
{
}
uint32_t
EndOffsetInTextNode
(
)
const
{
return
mOffsetInTextNode
+
mLength
;
}
bool
OffsetInTextNodeIsInRangeOrEndOffset
(
uint32_t
aOffsetInTextNode
)
const
{
return
aOffsetInTextNode
>
=
mOffsetInTextNode
&
&
aOffsetInTextNode
<
=
EndOffsetInTextNode
(
)
;
}
uint32_t
EndOffsetInTextInBlock
(
)
const
{
return
mOffsetInTextInBlock
+
mLength
;
}
bool
OffsetInTextInBlockIsInRangeOrEndOffset
(
uint32_t
aOffsetInTextInBlock
)
const
{
return
aOffsetInTextInBlock
>
=
mOffsetInTextInBlock
&
&
aOffsetInTextInBlock
<
=
EndOffsetInTextInBlock
(
)
;
}
OwningNonNull
<
Text
>
mTextNode
;
uint32_t
mOffsetInTextNode
;
uint32_t
mOffsetInTextInBlock
;
uint32_t
mLength
;
bool
mIsInsertedText
;
bool
mIsValid
;
}
;
template
<
typename
ElementType
>
struct
MOZ_STACK_CLASS
ArrayLengthMutationGuard
final
{
ArrayLengthMutationGuard
(
)
=
delete
;
explicit
ArrayLengthMutationGuard
(
const
nsTArray
<
ElementType
>
&
aArray
)
:
mArray
(
aArray
)
mOldLength
(
aArray
.
Length
(
)
)
{
}
~
ArrayLengthMutationGuard
(
)
{
if
(
mArray
.
Length
(
)
!
=
mOldLength
)
{
MOZ_CRASH
(
"
The
array
length
was
changed
unexpectedly
"
)
;
}
}
private
:
const
nsTArray
<
ElementType
>
&
mArray
;
size_t
mOldLength
;
}
;
#
define
LockOffsetEntryArrayLengthInDebugBuild
(
aName
aArray
)
\
DebugOnly
<
ArrayLengthMutationGuard
<
UniquePtr
<
OffsetEntry
>
>
>
const
aName
=
\
ArrayLengthMutationGuard
<
UniquePtr
<
OffsetEntry
>
>
(
aArray
)
;
TextServicesDocument
:
:
TextServicesDocument
(
)
:
mTxtSvcFilterType
(
0
)
mIteratorStatus
(
IteratorStatus
:
:
eDone
)
{
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextServicesDocument
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextServicesDocument
)
NS_INTERFACE_MAP_BEGIN
(
TextServicesDocument
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditActionListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditActionListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
TextServicesDocument
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
TextServicesDocument
mDocument
mSelCon
mEditorBase
mFilteredIter
mPrevTextBlock
mNextTextBlock
mExtent
)
nsresult
TextServicesDocument
:
:
InitWithEditor
(
nsIEditor
*
aEditor
)
{
nsCOMPtr
<
nsISelectionController
>
selCon
;
NS_ENSURE_TRUE
(
aEditor
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
aEditor
-
>
GetSelectionController
(
getter_AddRefs
(
selCon
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
selCon
|
|
(
mSelCon
&
&
selCon
!
=
mSelCon
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mSelCon
)
{
mSelCon
=
selCon
;
}
RefPtr
<
Document
>
doc
=
aEditor
-
>
AsEditorBase
(
)
-
>
GetDocument
(
)
;
if
(
!
doc
|
|
(
mDocument
&
&
doc
!
=
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDocument
)
{
mDocument
=
doc
;
rv
=
CreateDocumentContentIterator
(
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstBlock
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mEditorBase
=
aEditor
-
>
AsEditorBase
(
)
;
rv
=
aEditor
-
>
AddEditActionListener
(
this
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
SetExtent
(
const
AbstractRange
*
aAbstractRange
)
{
MOZ_ASSERT
(
aAbstractRange
)
;
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
mExtent
=
nsRange
:
:
Create
(
aAbstractRange
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
mExtent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CreateFilteredContentIterator
(
mExtent
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstBlock
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
FirstBlock
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
ExpandRangeToWordBoundaries
(
StaticRange
*
aStaticRange
)
{
MOZ_ASSERT
(
aStaticRange
)
;
nsCOMPtr
<
nsINode
>
rngStartNode
rngEndNode
;
uint32_t
rngStartOffset
rngEndOffset
;
nsresult
rv
=
GetRangeEndPoints
(
aStaticRange
getter_AddRefs
(
rngStartNode
)
&
rngStartOffset
getter_AddRefs
(
rngEndNode
)
&
rngEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
rv
=
CreateFilteredContentIterator
(
aStaticRange
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
IteratorStatus
iterStatus
=
IteratorStatus
:
:
eDone
;
rv
=
FirstTextNode
(
filteredIter
&
iterStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
iterStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
nsINode
*
firstText
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
firstText
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
LastTextNode
(
filteredIter
&
iterStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
iterStatus
=
=
IteratorStatus
:
:
eDone
)
{
NS_ASSERTION
(
false
"
Found
a
first
without
a
last
!
"
)
;
return
NS_ERROR_FAILURE
;
}
nsINode
*
lastText
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
lastText
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rngStartNode
!
=
firstText
)
{
rngStartNode
=
firstText
;
rngStartOffset
=
0
;
}
if
(
rngEndNode
!
=
lastText
)
{
rngEndNode
=
lastText
;
rngEndOffset
=
lastText
-
>
Length
(
)
;
}
RefPtr
<
FilteredContentIterator
>
docFilteredIter
;
rv
=
CreateDocumentContentIterator
(
getter_AddRefs
(
docFilteredIter
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
docFilteredIter
-
>
PositionAt
(
firstText
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iterStatus
=
IteratorStatus
:
:
eValid
;
OffsetEntryArray
offsetTable
;
nsAutoString
blockStr
;
Result
<
IteratorStatus
nsresult
>
result
=
offsetTable
.
Init
(
*
docFilteredIter
IteratorStatus
:
:
eValid
nullptr
&
blockStr
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
unwrapErr
(
)
;
}
Result
<
EditorDOMRangeInTexts
nsresult
>
maybeWordRange
=
offsetTable
.
FindWordRange
(
blockStr
EditorRawDOMPoint
(
rngStartNode
rngStartOffset
)
)
;
offsetTable
.
Clear
(
)
;
if
(
maybeWordRange
.
isErr
(
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntryArray
:
:
FindWordRange
(
)
failed
"
)
;
return
maybeWordRange
.
unwrapErr
(
)
;
}
rngStartNode
=
maybeWordRange
.
inspect
(
)
.
StartRef
(
)
.
GetContainerAs
<
Text
>
(
)
;
rngStartOffset
=
maybeWordRange
.
inspect
(
)
.
StartRef
(
)
.
Offset
(
)
;
rv
=
docFilteredIter
-
>
PositionAt
(
lastText
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
result
=
offsetTable
.
Init
(
*
docFilteredIter
IteratorStatus
:
:
eValid
nullptr
&
blockStr
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
unwrapErr
(
)
;
}
maybeWordRange
=
offsetTable
.
FindWordRange
(
blockStr
EditorRawDOMPoint
(
rngEndNode
rngEndOffset
)
)
;
offsetTable
.
Clear
(
)
;
if
(
maybeWordRange
.
isErr
(
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntryArray
:
:
FindWordRange
(
)
failed
"
)
;
return
maybeWordRange
.
unwrapErr
(
)
;
}
if
(
rngEndNode
!
=
maybeWordRange
.
inspect
(
)
.
StartRef
(
)
.
GetContainerAs
<
Text
>
(
)
|
|
rngEndOffset
!
=
maybeWordRange
.
inspect
(
)
.
StartRef
(
)
.
Offset
(
)
|
|
(
rngEndNode
=
=
rngStartNode
&
&
rngEndOffset
=
=
rngStartOffset
)
)
{
rngEndNode
=
maybeWordRange
.
inspect
(
)
.
EndRef
(
)
.
GetContainerAs
<
Text
>
(
)
;
rngEndOffset
=
maybeWordRange
.
inspect
(
)
.
EndRef
(
)
.
Offset
(
)
;
}
rv
=
aStaticRange
-
>
SetStartAndEnd
(
rngStartNode
rngStartOffset
rngEndNode
rngEndOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
update
the
given
range
"
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
SetFilterType
(
uint32_t
aFilterType
)
{
mTxtSvcFilterType
=
aFilterType
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
GetCurrentTextBlock
(
nsAString
&
aStr
)
{
aStr
.
Truncate
(
)
;
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
Result
<
IteratorStatus
nsresult
>
result
=
mOffsetTable
.
Init
(
*
mFilteredIter
mIteratorStatus
mExtent
&
aStr
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
OffsetEntryArray
:
:
Init
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
mIteratorStatus
=
result
.
unwrap
(
)
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
nsresult
rv
=
FirstTextNode
(
mFilteredIter
&
mIteratorStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
mPrevTextBlock
=
nullptr
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
LastSelectedBlock
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
NS_ENSURE_TRUE
(
aSelStatus
&
&
aSelOffset
&
&
aSelLength
NS_ERROR_NULL_POINTER
)
;
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockNotFound
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
if
(
!
mSelCon
|
|
!
mFilteredIter
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
const
nsRange
>
range
;
nsCOMPtr
<
nsINode
>
parent
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
!
range
)
{
return
NS_ERROR_FAILURE
;
}
parent
=
range
-
>
GetStartContainer
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
parent
-
>
IsText
(
)
)
{
rv
=
mFilteredIter
-
>
PositionAt
(
parent
-
>
AsText
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Result
<
IteratorStatus
nsresult
>
result
=
mOffsetTable
.
Init
(
*
mFilteredIter
IteratorStatus
:
:
eValid
mExtent
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
OffsetEntryArray
:
:
Init
(
)
failed
"
)
;
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
return
result
.
unwrapErr
(
)
;
}
mIteratorStatus
=
result
.
unwrap
(
)
;
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aSelStatus
=
=
BlockSelectionStatus
:
:
eBlockContains
)
{
rv
=
SetSelectionInternal
(
*
aSelOffset
*
aSelLength
false
)
;
}
}
else
{
range
=
CreateDocumentContentRootToNodeOffsetRange
(
parent
range
-
>
StartOffset
(
)
false
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
range
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
First
(
)
;
Text
*
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
currentNode
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
currentNode
-
>
IsText
(
)
)
{
textNode
=
currentNode
-
>
AsText
(
)
;
break
;
}
}
if
(
!
textNode
)
{
return
NS_OK
;
}
rv
=
mFilteredIter
-
>
PositionAt
(
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Result
<
IteratorStatus
nsresult
>
result
=
mOffsetTable
.
Init
(
*
mFilteredIter
IteratorStatus
:
:
eValid
mExtent
nullptr
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
OffsetEntryArray
:
:
Init
(
)
failed
"
)
;
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
return
result
.
unwrapErr
(
)
;
}
mIteratorStatus
=
result
.
inspect
(
)
;
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
rv
;
}
const
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
Selection
is
not
collapsed
so
the
range
count
should
be
1
or
larger
"
)
;
for
(
const
uint32_t
i
:
Reversed
(
IntegerRange
(
rangeCount
)
)
)
{
MOZ_ASSERT
(
selection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
!
range
)
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
Last
(
)
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
if
(
filteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
filteredIter
-
>
GetCurrentNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
Result
<
IteratorStatus
nsresult
>
result
=
mOffsetTable
.
Init
(
*
mFilteredIter
IteratorStatus
:
:
eValid
mExtent
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
OffsetEntryArray
:
:
Init
(
)
failed
"
)
;
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
return
result
.
unwrapErr
(
)
;
}
mIteratorStatus
=
result
.
unwrap
(
)
;
return
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
}
}
range
=
rangeCount
>
0
?
selection
-
>
GetRangeAt
(
rangeCount
-
1
)
:
nullptr
;
if
(
!
range
)
{
return
NS_ERROR_FAILURE
;
}
parent
=
range
-
>
GetEndContainer
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
range
=
CreateDocumentContentRootToNodeOffsetRange
(
parent
range
-
>
EndOffset
(
)
false
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
range
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filteredIter
-
>
First
(
)
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
if
(
filteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
filteredIter
-
>
GetCurrentNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
FirstTextNodeInCurrentBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Result
<
IteratorStatus
nsresult
>
result
=
mOffsetTable
.
Init
(
*
mFilteredIter
IteratorStatus
:
:
eValid
mExtent
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
OffsetEntryArray
:
:
Init
(
)
failed
"
)
;
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
return
result
.
unwrapErr
(
)
;
}
mIteratorStatus
=
result
.
unwrap
(
)
;
rv
=
GetSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextServicesDocument
:
:
GetSelection
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
PrevBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
switch
(
mIteratorStatus
)
{
case
IteratorStatus
:
:
eValid
:
case
IteratorStatus
:
:
eNext
:
{
nsresult
rv
=
FirstTextNodeInPrevBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
if
(
mFilteredIter
-
>
IsDone
(
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
}
case
IteratorStatus
:
:
ePrev
:
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
default
:
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
break
;
}
nsresult
rv
=
NS_OK
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
GetFirstTextNodeInPrevBlock
(
getter_AddRefs
(
mPrevTextBlock
)
)
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
NextBlock
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
switch
(
mIteratorStatus
)
{
case
IteratorStatus
:
:
eValid
:
{
nsresult
rv
=
FirstTextNodeInNextBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
if
(
mFilteredIter
-
>
IsDone
(
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
}
case
IteratorStatus
:
:
eNext
:
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
break
;
case
IteratorStatus
:
:
ePrev
:
default
:
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
break
;
}
nsresult
rv
=
NS_OK
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eValid
)
{
GetFirstTextNodeInPrevBlock
(
getter_AddRefs
(
mPrevTextBlock
)
)
;
rv
=
GetFirstTextNodeInNextBlock
(
getter_AddRefs
(
mNextTextBlock
)
)
;
}
else
{
mPrevTextBlock
=
nullptr
;
mNextTextBlock
=
nullptr
;
}
return
rv
;
}
nsresult
TextServicesDocument
:
:
IsDone
(
bool
*
aIsDone
)
{
NS_ENSURE_TRUE
(
aIsDone
NS_ERROR_NULL_POINTER
)
;
*
aIsDone
=
false
;
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
*
aIsDone
=
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
SetSelection
(
uint32_t
aOffset
uint32_t
aLength
)
{
NS_ENSURE_TRUE
(
mSelCon
NS_ERROR_FAILURE
)
;
return
SetSelectionInternal
(
aOffset
aLength
true
)
;
}
nsresult
TextServicesDocument
:
:
ScrollSelectionIntoView
(
)
{
NS_ENSURE_TRUE
(
mSelCon
NS_ERROR_FAILURE
)
;
nsresult
rv
=
mSelCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
return
rv
;
}
nsresult
TextServicesDocument
:
:
OffsetEntryArray
:
:
WillDeleteSelection
(
)
{
MOZ_ASSERT
(
mSelection
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
mSelection
.
IsCollapsed
(
)
)
;
for
(
size_t
i
=
mSelection
.
StartIndex
(
)
;
i
<
=
mSelection
.
EndIndex
(
)
;
i
+
+
)
{
OffsetEntry
*
entry
=
ElementAt
(
i
)
.
get
(
)
;
if
(
i
=
=
mSelection
.
StartIndex
(
)
)
{
uint32_t
selLength
;
if
(
entry
-
>
mIsInsertedText
)
{
selLength
=
0
;
}
else
{
selLength
=
entry
-
>
EndOffsetInTextInBlock
(
)
-
mSelection
.
StartOffsetInTextInBlock
(
)
;
}
if
(
selLength
>
0
)
{
if
(
mSelection
.
StartOffsetInTextInBlock
(
)
>
entry
-
>
mOffsetInTextInBlock
)
{
nsresult
rv
=
SplitElementAt
(
i
selLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
selLength
was
invalid
for
the
OffsetEntry
"
)
;
return
rv
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
StartIndex
(
)
+
1
<
Length
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
EndIndex
(
)
+
1
<
Length
(
)
)
;
mSelection
.
SetIndexes
(
mSelection
.
StartIndex
(
)
+
1
mSelection
.
EndIndex
(
)
+
1
)
;
entry
=
ElementAt
(
+
+
i
)
.
get
(
)
;
}
if
(
mSelection
.
StartIndex
(
)
<
mSelection
.
EndIndex
(
)
)
{
entry
-
>
mIsValid
=
false
;
}
}
}
if
(
i
=
=
mSelection
.
EndIndex
(
)
)
{
if
(
entry
-
>
mIsInsertedText
)
{
entry
-
>
mIsValid
=
false
;
}
else
{
const
uint32_t
selLength
=
mSelection
.
EndOffsetInTextInBlock
(
)
-
entry
-
>
mOffsetInTextInBlock
;
if
(
selLength
)
{
if
(
mSelection
.
EndOffsetInTextInBlock
(
)
<
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
nsresult
rv
=
SplitElementAt
(
i
entry
-
>
mLength
-
selLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
entry
-
>
mLength
-
selLength
was
invalid
for
the
OffsetEntry
"
)
;
return
rv
;
}
ElementAt
(
i
+
1
)
-
>
mOffsetInTextNode
=
entry
-
>
mOffsetInTextNode
;
}
if
(
mSelection
.
EndOffsetInTextInBlock
(
)
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
entry
-
>
mIsValid
=
false
;
}
}
}
}
if
(
i
!
=
mSelection
.
StartIndex
(
)
&
&
i
!
=
mSelection
.
EndIndex
(
)
)
{
entry
-
>
mIsValid
=
false
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
DeleteSelection
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mOffsetTable
.
mSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mOffsetTable
.
mSelection
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
origStartNode
origEndNode
;
uint32_t
origStartOffset
=
0
origEndOffset
=
0
;
if
(
mExtent
)
{
nsresult
rv
=
GetRangeEndPoints
(
mExtent
getter_AddRefs
(
origStartNode
)
&
origStartOffset
getter_AddRefs
(
origEndNode
)
&
origEndOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
NS_FAILED
(
mOffsetTable
.
WillDeleteSelection
(
)
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntryTable
:
:
WillDeleteSelection
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
AdjustContentIterator
(
)
;
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
nsresult
rv
=
editorBase
-
>
DeleteSelectionAsAction
(
nsIEditor
:
:
ePrevious
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
origStartNode
&
&
origEndNode
)
{
nsCOMPtr
<
nsINode
>
curStartNode
curEndNode
;
uint32_t
curStartOffset
=
0
curEndOffset
=
0
;
rv
=
GetRangeEndPoints
(
mExtent
getter_AddRefs
(
curStartNode
)
&
curStartOffset
getter_AddRefs
(
curEndNode
)
&
curEndOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
origStartNode
!
=
curStartNode
|
|
origEndNode
!
=
curEndNode
)
{
nsCOMPtr
<
nsIContent
>
curContent
;
if
(
mIteratorStatus
!
=
IteratorStatus
:
:
eDone
)
{
curContent
=
mFilteredIter
-
>
GetCurrentNode
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
}
rv
=
CreateFilteredContentIterator
(
mExtent
getter_AddRefs
(
mFilteredIter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
curContent
)
{
rv
=
mFilteredIter
-
>
PositionAt
(
curContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
}
}
}
OffsetEntry
*
entry
=
mOffsetTable
.
DidDeleteSelection
(
)
;
if
(
entry
)
{
SetSelection
(
mOffsetTable
.
mSelection
.
StartOffsetInTextInBlock
(
)
0
)
;
}
mOffsetTable
.
RemoveInvalidElements
(
)
;
return
NS_OK
;
}
OffsetEntry
*
TextServicesDocument
:
:
OffsetEntryArray
:
:
DidDeleteSelection
(
)
{
MOZ_ASSERT
(
mSelection
.
IsSet
(
)
)
;
OffsetEntry
*
entry
=
nullptr
;
for
(
size_t
i
=
mSelection
.
StartIndex
(
)
+
1
;
!
entry
&
&
i
>
0
;
i
-
-
)
{
entry
=
ElementAt
(
i
-
1
)
.
get
(
)
;
if
(
!
entry
-
>
mIsValid
)
{
entry
=
nullptr
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
i
-
1
<
Length
(
)
)
;
mSelection
.
Set
(
i
-
1
entry
-
>
EndOffsetInTextInBlock
(
)
)
;
}
}
for
(
size_t
i
=
mSelection
.
EndIndex
(
)
;
!
entry
&
&
i
<
Length
(
)
;
i
+
+
)
{
entry
=
ElementAt
(
i
)
.
get
(
)
;
if
(
!
entry
-
>
mIsValid
)
{
entry
=
nullptr
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
i
<
Length
(
)
)
;
mSelection
.
Set
(
i
entry
-
>
mOffsetInTextInBlock
)
;
}
}
if
(
!
entry
)
{
mSelection
.
Reset
(
)
;
}
return
entry
;
}
nsresult
TextServicesDocument
:
:
InsertText
(
const
nsAString
&
aText
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mOffsetTable
.
mSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
bool
wasSelectionCollapsed
=
mOffsetTable
.
mSelection
.
IsCollapsed
(
)
;
const
uint32_t
savedSelOffset
=
mOffsetTable
.
mSelection
.
StartOffsetInTextInBlock
(
)
;
const
uint32_t
savedSelLength
=
mOffsetTable
.
mSelection
.
LengthInTextInBlock
(
)
;
if
(
!
wasSelectionCollapsed
)
{
nsresult
rv
=
SetSelection
(
mOffsetTable
.
mSelection
.
StartOffsetInTextInBlock
(
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
AutoTransactionBatchExternal
treatAsOneTransaction
(
editorBase
)
;
nsresult
rv
=
editorBase
-
>
InsertTextAsAction
(
aText
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InsertTextAsAction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
rv
=
mOffsetTable
.
DidInsertText
(
selection
aText
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntry
:
:
DidInsertText
(
)
failed
"
)
;
return
rv
;
}
if
(
!
wasSelectionCollapsed
)
{
nsresult
rv
=
SetSelection
(
savedSelOffset
savedSelLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
DeleteSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
OffsetEntryArray
:
:
DidInsertText
(
dom
:
:
Selection
*
aSelection
const
nsAString
&
aInsertedString
)
{
MOZ_ASSERT
(
mSelection
.
IsSet
(
)
)
;
OffsetEntry
*
entry
=
ElementAt
(
mSelection
.
StartIndex
(
)
)
.
get
(
)
;
OwningNonNull
<
Text
>
const
textNodeAtStartEntry
=
entry
-
>
mTextNode
;
NS_ASSERTION
(
(
entry
-
>
mIsValid
)
"
Invalid
insertion
point
!
"
)
;
if
(
entry
-
>
mOffsetInTextInBlock
=
=
mSelection
.
StartOffsetInTextInBlock
(
)
)
{
if
(
entry
-
>
mIsInsertedText
)
{
entry
-
>
mLength
+
=
aInsertedString
.
Length
(
)
;
}
else
{
UniquePtr
<
OffsetEntry
>
newInsertedTextEntry
=
MakeUnique
<
OffsetEntry
>
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextInBlock
aInsertedString
.
Length
(
)
)
;
newInsertedTextEntry
-
>
mIsInsertedText
=
true
;
newInsertedTextEntry
-
>
mOffsetInTextNode
=
entry
-
>
mOffsetInTextNode
;
InsertElementAt
(
mSelection
.
StartIndex
(
)
std
:
:
move
(
newInsertedTextEntry
)
)
;
}
}
else
if
(
entry
-
>
EndOffsetInTextInBlock
(
)
=
=
mSelection
.
EndOffsetInTextInBlock
(
)
)
{
uint32_t
nextIndex
=
mSelection
.
StartIndex
(
)
+
1
;
OffsetEntry
*
insertedTextEntry
=
nullptr
;
if
(
Length
(
)
>
nextIndex
)
{
insertedTextEntry
=
ElementAt
(
nextIndex
)
.
get
(
)
;
if
(
!
insertedTextEntry
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
insertedTextEntry
-
>
mIsInsertedText
|
|
insertedTextEntry
-
>
mOffsetInTextInBlock
!
=
mSelection
.
StartOffsetInTextInBlock
(
)
)
{
insertedTextEntry
=
nullptr
;
}
}
if
(
!
insertedTextEntry
)
{
UniquePtr
<
OffsetEntry
>
newInsertedTextEntry
=
MakeUnique
<
OffsetEntry
>
(
entry
-
>
mTextNode
mSelection
.
StartOffsetInTextInBlock
(
)
0
)
;
newInsertedTextEntry
-
>
mOffsetInTextNode
=
entry
-
>
EndOffsetInTextNode
(
)
;
newInsertedTextEntry
-
>
mIsInsertedText
=
true
;
insertedTextEntry
=
InsertElementAt
(
nextIndex
std
:
:
move
(
newInsertedTextEntry
)
)
-
>
get
(
)
;
}
insertedTextEntry
-
>
mLength
+
=
aInsertedString
.
Length
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
nextIndex
<
Length
(
)
)
;
mSelection
.
SetIndex
(
nextIndex
)
;
if
(
!
aSelection
)
{
return
NS_OK
;
}
OwningNonNull
<
Text
>
textNode
=
insertedTextEntry
-
>
mTextNode
;
nsresult
rv
=
aSelection
-
>
CollapseInLimiter
(
textNode
insertedTextEntry
-
>
EndOffsetInTextNode
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Selection
:
:
CollapseInLimiter
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
entry
-
>
EndOffsetInTextInBlock
(
)
>
mSelection
.
StartOffsetInTextInBlock
(
)
)
{
nsresult
rv
=
SplitElementAt
(
mSelection
.
StartIndex
(
)
entry
-
>
EndOffsetInTextInBlock
(
)
-
mSelection
.
StartOffsetInTextInBlock
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
entry
-
>
EndOffsetInTextInBlock
(
)
-
"
"
mSelection
.
StartOffsetInTextInBlock
(
)
was
invalid
for
the
"
"
OffsetEntry
"
)
;
return
rv
;
}
UniquePtr
<
OffsetEntry
>
&
insertedTextEntry
=
*
InsertElementAt
(
mSelection
.
StartIndex
(
)
+
1
MakeUnique
<
OffsetEntry
>
(
entry
-
>
mTextNode
mSelection
.
StartOffsetInTextInBlock
(
)
aInsertedString
.
Length
(
)
)
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
insertedTextEntry
-
>
mIsInsertedText
=
true
;
insertedTextEntry
-
>
mOffsetInTextNode
=
entry
-
>
EndOffsetInTextNode
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
StartIndex
(
)
+
1
<
Length
(
)
)
;
mSelection
.
SetIndex
(
mSelection
.
StartIndex
(
)
+
1
)
;
}
for
(
size_t
i
=
mSelection
.
StartIndex
(
)
+
1
;
i
<
Length
(
)
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
ElementAt
(
i
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
if
(
entry
-
>
mTextNode
!
=
textNodeAtStartEntry
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mOffsetInTextNode
+
=
aInsertedString
.
Length
(
)
;
}
}
return
NS_OK
;
}
void
TextServicesDocument
:
:
DidDeleteContent
(
const
nsIContent
&
aChildContent
)
{
if
(
NS_WARN_IF
(
!
mFilteredIter
)
|
|
!
aChildContent
.
IsText
(
)
)
{
return
;
}
Maybe
<
size_t
>
maybeNodeIndex
=
mOffsetTable
.
FirstIndexOf
(
*
aChildContent
.
AsText
(
)
)
;
if
(
maybeNodeIndex
.
isNothing
(
)
)
{
return
;
}
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
&
&
node
=
=
&
aChildContent
&
&
mIteratorStatus
!
=
IteratorStatus
:
:
eDone
)
{
NS_ERROR
(
"
DeleteNode
called
for
current
iterator
node
.
"
)
;
}
for
(
size_t
nodeIndex
=
*
maybeNodeIndex
;
nodeIndex
<
mOffsetTable
.
Length
(
)
;
nodeIndex
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
nodeIndex
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
!
entry
)
{
return
;
}
if
(
entry
-
>
mTextNode
=
=
&
aChildContent
)
{
entry
-
>
mIsValid
=
false
;
}
}
}
void
TextServicesDocument
:
:
DidJoinContents
(
const
EditorRawDOMPoint
&
aJoinedPoint
const
nsIContent
&
aRemovedContent
JoinNodesDirection
aJoinNodesDirection
)
{
if
(
!
aJoinedPoint
.
IsInTextNode
(
)
|
|
!
aRemovedContent
.
IsText
(
)
)
{
return
;
}
Maybe
<
size_t
>
maybeRemovedIndex
=
mOffsetTable
.
FirstIndexOf
(
*
aRemovedContent
.
AsText
(
)
)
;
if
(
maybeRemovedIndex
.
isNothing
(
)
)
{
return
;
}
Maybe
<
size_t
>
maybeJoinedIndex
=
mOffsetTable
.
FirstIndexOf
(
*
aJoinedPoint
.
ContainerAs
<
Text
>
(
)
)
;
if
(
maybeJoinedIndex
.
isNothing
(
)
)
{
return
;
}
const
size_t
removedIndex
=
*
maybeRemovedIndex
;
const
size_t
joinedIndex
=
*
maybeJoinedIndex
;
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
)
{
if
(
MOZ_UNLIKELY
(
removedIndex
>
joinedIndex
)
)
{
NS_ASSERTION
(
removedIndex
<
joinedIndex
"
Indexes
out
of
order
.
"
)
;
return
;
}
NS_ASSERTION
(
mOffsetTable
[
joinedIndex
]
-
>
mOffsetInTextNode
=
=
0
"
Unexpected
offset
value
for
joinedIndex
.
"
)
;
}
else
{
if
(
MOZ_UNLIKELY
(
joinedIndex
>
removedIndex
)
)
{
NS_ASSERTION
(
joinedIndex
<
removedIndex
"
Indexes
out
of
order
.
"
)
;
return
;
}
NS_ASSERTION
(
mOffsetTable
[
removedIndex
]
-
>
mOffsetInTextNode
=
=
0
"
Unexpected
offset
value
for
rightIndex
.
"
)
;
}
const
uint32_t
movedTextDataLength
=
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
?
aJoinedPoint
.
Offset
(
)
:
aJoinedPoint
.
ContainerAs
<
Text
>
(
)
-
>
TextDataLength
(
)
-
aJoinedPoint
.
Offset
(
)
;
for
(
uint32_t
i
=
removedIndex
;
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
entry
-
>
mTextNode
!
=
aRemovedContent
.
AsText
(
)
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mTextNode
=
aJoinedPoint
.
ContainerAs
<
Text
>
(
)
;
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
RightNodeIntoLeftNode
)
{
entry
-
>
mOffsetInTextNode
+
=
movedTextDataLength
;
}
}
}
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
)
{
for
(
uint32_t
i
=
joinedIndex
;
i
<
mOffsetTable
.
Length
(
)
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
entry
-
>
mTextNode
!
=
aJoinedPoint
.
ContainerAs
<
Text
>
(
)
)
{
break
;
}
if
(
entry
-
>
mIsValid
)
{
entry
-
>
mOffsetInTextNode
+
=
movedTextDataLength
;
}
}
}
if
(
mFilteredIter
-
>
GetCurrentNode
(
)
=
=
aRemovedContent
.
AsText
(
)
)
{
mFilteredIter
-
>
PositionAt
(
aJoinedPoint
.
ContainerAs
<
Text
>
(
)
)
;
}
}
nsresult
TextServicesDocument
:
:
CreateFilteredContentIterator
(
const
AbstractRange
*
aAbstractRange
FilteredContentIterator
*
*
aFilteredIter
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aFilteredIter
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aFilteredIter
=
nullptr
;
UniquePtr
<
nsComposeTxtSrvFilter
>
composeFilter
;
switch
(
mTxtSvcFilterType
)
{
case
nsIEditorSpellCheck
:
:
FILTERTYPE_NORMAL
:
composeFilter
=
nsComposeTxtSrvFilter
:
:
CreateNormalFilter
(
)
;
break
;
case
nsIEditorSpellCheck
:
:
FILTERTYPE_MAIL
:
composeFilter
=
nsComposeTxtSrvFilter
:
:
CreateMailFilter
(
)
;
break
;
}
RefPtr
<
FilteredContentIterator
>
filter
=
new
FilteredContentIterator
(
std
:
:
move
(
composeFilter
)
)
;
nsresult
rv
=
filter
-
>
Init
(
aAbstractRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
filter
.
forget
(
aFilteredIter
)
;
return
NS_OK
;
}
Element
*
TextServicesDocument
:
:
GetDocumentContentRootNode
(
)
const
{
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
nullptr
;
}
if
(
mDocument
-
>
IsHTMLOrXHTML
(
)
)
{
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsXULElement
(
)
)
{
return
mDocument
-
>
GetDocumentElement
(
)
;
}
return
mDocument
-
>
GetBody
(
)
;
}
return
mDocument
-
>
GetDocumentElement
(
)
;
}
already_AddRefed
<
nsRange
>
TextServicesDocument
:
:
CreateDocumentContentRange
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetDocumentContentRootNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
node
)
;
IgnoredErrorResult
ignoredError
;
range
-
>
SelectNodeContents
(
*
node
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
SelectNodeContents
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
TextServicesDocument
:
:
CreateDocumentContentRootToNodeOffsetRange
(
nsINode
*
aParent
uint32_t
aOffset
bool
aToStart
)
{
if
(
NS_WARN_IF
(
!
aParent
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
bodyNode
=
GetDocumentContentRootNode
(
)
;
if
(
NS_WARN_IF
(
!
bodyNode
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
startNode
;
nsCOMPtr
<
nsINode
>
endNode
;
uint32_t
startOffset
endOffset
;
if
(
aToStart
)
{
startNode
=
bodyNode
;
startOffset
=
0
;
endNode
=
aParent
;
endOffset
=
aOffset
;
}
else
{
startNode
=
aParent
;
startOffset
=
aOffset
;
endNode
=
bodyNode
;
endOffset
=
endNode
?
endNode
-
>
GetChildCount
(
)
:
0
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startNode
startOffset
endNode
endOffset
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
to
create
new
valid
range
"
)
;
return
range
.
forget
(
)
;
}
nsresult
TextServicesDocument
:
:
CreateDocumentContentIterator
(
FilteredContentIterator
*
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
nsRange
>
range
=
CreateDocumentContentRange
(
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
*
aFilteredIter
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
return
CreateFilteredContentIterator
(
range
aFilteredIter
)
;
}
nsresult
TextServicesDocument
:
:
AdjustContentIterator
(
)
{
NS_ENSURE_TRUE
(
mFilteredIter
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
Text
*
prevValidTextNode
=
nullptr
;
Text
*
nextValidTextNode
=
nullptr
;
bool
foundEntry
=
false
;
const
size_t
tableLength
=
mOffsetTable
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
tableLength
&
&
!
nextValidTextNode
;
i
+
+
)
{
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
entry
-
>
mTextNode
=
=
node
)
{
if
(
entry
-
>
mIsValid
)
{
return
NS_OK
;
}
foundEntry
=
true
;
}
if
(
entry
-
>
mIsValid
)
{
if
(
!
foundEntry
)
{
prevValidTextNode
=
entry
-
>
mTextNode
;
}
else
{
nextValidTextNode
=
entry
-
>
mTextNode
;
}
}
}
Text
*
validTextNode
=
nullptr
;
if
(
prevValidTextNode
)
{
validTextNode
=
prevValidTextNode
;
}
else
if
(
nextValidTextNode
)
{
validTextNode
=
nextValidTextNode
;
}
if
(
validTextNode
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
validTextNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
return
rv
;
}
if
(
mNextTextBlock
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
mNextTextBlock
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
eNext
;
}
else
if
(
mPrevTextBlock
)
{
nsresult
rv
=
mFilteredIter
-
>
PositionAt
(
mPrevTextBlock
)
;
if
(
NS_FAILED
(
rv
)
)
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
return
rv
;
}
mIteratorStatus
=
IteratorStatus
:
:
ePrev
;
}
else
{
mIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
return
NS_OK
;
}
bool
TextServicesDocument
:
:
DidSkip
(
FilteredContentIterator
*
aFilteredIter
)
{
return
aFilteredIter
&
&
aFilteredIter
-
>
DidSkip
(
)
;
}
void
TextServicesDocument
:
:
ClearDidSkip
(
FilteredContentIterator
*
aFilteredIter
)
{
if
(
aFilteredIter
)
{
aFilteredIter
-
>
ClearDidSkip
(
)
;
}
}
bool
TextServicesDocument
:
:
HasSameBlockNodeParent
(
Text
&
aTextNode1
Text
&
aTextNode2
)
{
if
(
aTextNode1
.
GetParent
(
)
=
=
aTextNode2
.
GetParent
(
)
)
{
return
true
;
}
const
Element
*
editableBlockElementOrInlineEditingHost1
=
HTMLEditUtils
:
:
GetAncestorElement
(
aTextNode1
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
;
const
Element
*
editableBlockElementOrInlineEditingHost2
=
HTMLEditUtils
:
:
GetAncestorElement
(
aTextNode2
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
;
return
editableBlockElementOrInlineEditingHost1
&
&
editableBlockElementOrInlineEditingHost1
=
=
editableBlockElementOrInlineEditingHost2
;
}
Result
<
EditorRawDOMRangeInTexts
nsresult
>
TextServicesDocument
:
:
OffsetEntryArray
:
:
WillSetSelection
(
uint32_t
aOffsetInTextInBlock
uint32_t
aLength
)
{
EditorRawDOMPointInText
newStart
;
for
(
size_t
i
=
0
;
!
newStart
.
IsSet
(
)
&
&
i
<
Length
(
)
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
ElementAt
(
i
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
if
(
entry
-
>
mIsValid
)
{
if
(
entry
-
>
mIsInsertedText
)
{
if
(
entry
-
>
mOffsetInTextInBlock
=
=
aOffsetInTextInBlock
)
{
newStart
.
Set
(
entry
-
>
mTextNode
entry
-
>
EndOffsetInTextNode
(
)
)
;
}
}
else
if
(
aOffsetInTextInBlock
>
=
entry
-
>
mOffsetInTextInBlock
)
{
bool
foundEntry
=
false
;
if
(
aOffsetInTextInBlock
<
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
foundEntry
=
true
;
}
else
if
(
aOffsetInTextInBlock
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
if
(
i
+
1
<
Length
(
)
)
{
const
UniquePtr
<
OffsetEntry
>
&
nextEntry
=
ElementAt
(
i
+
1
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
if
(
!
nextEntry
-
>
mIsValid
|
|
nextEntry
-
>
mOffsetInTextInBlock
!
=
aOffsetInTextInBlock
)
{
foundEntry
=
true
;
}
}
}
if
(
foundEntry
)
{
newStart
.
Set
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextNode
+
aOffsetInTextInBlock
-
entry
-
>
mOffsetInTextInBlock
)
;
}
}
if
(
newStart
.
IsSet
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
i
<
Length
(
)
)
;
mSelection
.
Set
(
i
aOffsetInTextInBlock
)
;
}
}
}
if
(
NS_WARN_IF
(
!
newStart
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aLength
)
{
mSelection
.
CollapseToStart
(
)
;
return
EditorRawDOMRangeInTexts
(
newStart
)
;
}
EditorRawDOMPointInText
newEnd
;
const
uint32_t
endOffset
=
aOffsetInTextInBlock
+
aLength
;
for
(
uint32_t
i
=
Length
(
)
;
!
newEnd
.
IsSet
(
)
&
&
i
>
0
;
i
-
-
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
ElementAt
(
i
-
1
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
if
(
entry
-
>
mIsValid
)
{
if
(
entry
-
>
mIsInsertedText
)
{
if
(
entry
-
>
mOffsetInTextInBlock
=
=
(
newEnd
.
IsSet
(
)
?
newEnd
.
Offset
(
)
:
0
)
)
{
newEnd
.
Set
(
entry
-
>
mTextNode
entry
-
>
EndOffsetInTextNode
(
)
)
;
}
}
else
if
(
entry
-
>
OffsetInTextInBlockIsInRangeOrEndOffset
(
endOffset
)
)
{
newEnd
.
Set
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextNode
+
endOffset
-
entry
-
>
mOffsetInTextInBlock
)
;
}
if
(
newEnd
.
IsSet
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
StartIndex
(
)
<
Length
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
i
-
1
<
Length
(
)
)
;
mSelection
.
Set
(
mSelection
.
StartIndex
(
)
i
-
1
mSelection
.
StartOffsetInTextInBlock
(
)
endOffset
)
;
}
}
}
return
newEnd
.
IsSet
(
)
?
EditorRawDOMRangeInTexts
(
newStart
newEnd
)
:
EditorRawDOMRangeInTexts
(
newStart
)
;
}
nsresult
TextServicesDocument
:
:
SetSelectionInternal
(
uint32_t
aOffsetInTextInBlock
uint32_t
aLength
bool
aDoUpdate
)
{
if
(
NS_WARN_IF
(
!
mSelCon
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
Result
<
EditorRawDOMRangeInTexts
nsresult
>
newSelectionRange
=
mOffsetTable
.
WillSetSelection
(
aOffsetInTextInBlock
aLength
)
;
if
(
newSelectionRange
.
isErr
(
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntryArray
:
:
WillSetSelection
(
)
failed
"
)
;
return
newSelectionRange
.
unwrapErr
(
)
;
}
if
(
!
aDoUpdate
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
newSelectionRange
.
inspect
(
)
.
Collapsed
(
)
)
{
nsresult
rv
=
selection
-
>
CollapseInLimiter
(
newSelectionRange
.
inspect
(
)
.
StartRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
CollapseInLimiter
(
)
failed
"
)
;
return
rv
;
}
ErrorResult
error
;
selection
-
>
SetStartAndEndInLimiter
(
newSelectionRange
.
inspect
(
)
.
StartRef
(
)
newSelectionRange
.
inspect
(
)
.
EndRef
(
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SetStartAndEndInLimiter
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
TextServicesDocument
:
:
GetSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
NS_ENSURE_TRUE
(
aSelStatus
&
&
aSelOffset
&
&
aSelLength
NS_ERROR_NULL_POINTER
)
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockNotFound
;
*
aSelOffset
=
UINT32_MAX
;
*
aSelLength
=
UINT32_MAX
;
NS_ENSURE_TRUE
(
mDocument
&
&
mSelCon
NS_ERROR_FAILURE
)
;
if
(
mIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
return
GetCollapsedSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
return
GetUncollapsedSelection
(
aSelStatus
aSelOffset
aSelLength
)
;
}
nsresult
TextServicesDocument
:
:
GetCollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockOutside
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
const
uint32_t
tableCount
=
mOffsetTable
.
Length
(
)
;
if
(
!
tableCount
)
{
return
NS_OK
;
}
UniquePtr
<
OffsetEntry
>
&
eStart
=
mOffsetTable
[
0
]
;
UniquePtr
<
OffsetEntry
>
&
eEnd
=
tableCount
>
1
?
mOffsetTable
[
tableCount
-
1
]
:
eStart
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
const
uint32_t
eStartOffset
=
eStart
-
>
mOffsetInTextNode
;
const
uint32_t
eEndOffset
=
eEnd
-
>
EndOffsetInTextNode
(
)
;
RefPtr
<
const
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
nsCOMPtr
<
nsINode
>
parent
=
range
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
parent
)
;
uint32_t
offset
=
range
-
>
StartOffset
(
)
;
const
Maybe
<
int32_t
>
e1s1
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
eStartOffset
parent
offset
)
;
const
Maybe
<
int32_t
>
e2s1
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
eEndOffset
parent
offset
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
e1s1
)
|
|
NS_WARN_IF
(
!
e2s1
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
e1s1
>
0
|
|
*
e2s1
<
0
)
{
return
NS_OK
;
}
if
(
parent
-
>
IsText
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
entry
-
>
mTextNode
=
=
parent
-
>
AsText
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
offset
)
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
offset
-
entry
-
>
mOffsetInTextNode
)
;
*
aSelLength
=
0
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
range
=
nsRange
:
:
Create
(
eStart
-
>
mTextNode
eStartOffset
eEnd
-
>
mTextNode
eEndOffset
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIContent
*
saveNode
;
if
(
parent
-
>
HasChildren
(
)
)
{
nsIContent
*
content
=
range
-
>
GetChildAtStartOffset
(
)
;
if
(
content
&
&
parent
-
>
GetFirstChild
(
)
!
=
content
)
{
content
=
content
-
>
GetPreviousSibling
(
)
;
}
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
nsresult
rv
=
filteredIter
-
>
PositionAt
(
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
saveNode
=
content
;
}
else
{
NS_ENSURE_TRUE
(
parent
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIContent
>
content
=
parent
-
>
AsContent
(
)
;
nsresult
rv
=
filteredIter
-
>
PositionAt
(
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
saveNode
=
content
;
}
Text
*
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
nsINode
*
current
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
current
-
>
IsText
(
)
)
{
textNode
=
current
-
>
AsText
(
)
;
break
;
}
}
if
(
textNode
)
{
offset
=
textNode
-
>
TextLength
(
)
;
}
else
{
nsresult
rv
=
filteredIter
-
>
PositionAt
(
saveNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
textNode
=
nullptr
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
current
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
current
-
>
IsText
(
)
)
{
textNode
=
current
-
>
AsText
(
)
;
break
;
}
}
NS_ENSURE_TRUE
(
textNode
NS_ERROR_FAILURE
)
;
offset
=
0
;
}
for
(
size_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
entry
-
>
mTextNode
=
=
textNode
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
offset
)
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
offset
-
entry
-
>
mOffsetInTextNode
)
;
*
aSelLength
=
0
;
return
SetSelectionInternal
(
*
aSelOffset
*
aSelLength
true
)
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
TextServicesDocument
:
:
GetUncollapsedSelection
(
BlockSelectionStatus
*
aSelStatus
uint32_t
*
aSelOffset
uint32_t
*
aSelLength
)
{
RefPtr
<
const
nsRange
>
range
;
RefPtr
<
Selection
>
selection
=
mSelCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
startContainer
endContainer
;
const
size_t
tableCount
=
mOffsetTable
.
Length
(
)
;
UniquePtr
<
OffsetEntry
>
&
eStart
=
mOffsetTable
[
0
]
;
UniquePtr
<
OffsetEntry
>
&
eEnd
=
tableCount
>
1
?
mOffsetTable
[
tableCount
-
1
]
:
eStart
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
const
uint32_t
eStartOffset
=
eStart
-
>
mOffsetInTextNode
;
const
uint32_t
eEndOffset
=
eEnd
-
>
EndOffsetInTextNode
(
)
;
const
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
)
;
Maybe
<
int32_t
>
e1s2
;
Maybe
<
int32_t
>
e2s1
;
uint32_t
startOffset
endOffset
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
selection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
GetRangeEndPoints
(
range
getter_AddRefs
(
startContainer
)
&
startOffset
getter_AddRefs
(
endContainer
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
e1s2
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
eStartOffset
endContainer
endOffset
)
;
if
(
NS_WARN_IF
(
!
e1s2
)
)
{
return
NS_ERROR_FAILURE
;
}
e2s1
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
eEndOffset
startContainer
startOffset
)
;
if
(
NS_WARN_IF
(
!
e2s1
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
e1s2
<
=
0
&
&
*
e2s1
>
=
0
)
{
break
;
}
}
if
(
rangeCount
<
1
|
|
*
e1s2
>
0
|
|
*
e2s1
<
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockOutside
;
*
aSelOffset
=
*
aSelLength
=
UINT32_MAX
;
return
NS_OK
;
}
const
Maybe
<
int32_t
>
e1s1
=
nsContentUtils
:
:
ComparePoints
(
eStart
-
>
mTextNode
eStartOffset
startContainer
startOffset
)
;
if
(
NS_WARN_IF
(
!
e1s1
)
)
{
return
NS_ERROR_FAILURE
;
}
const
Maybe
<
int32_t
>
e2s2
=
nsContentUtils
:
:
ComparePoints
(
eEnd
-
>
mTextNode
eEndOffset
endContainer
endOffset
)
;
if
(
NS_WARN_IF
(
!
e2s2
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rangeCount
>
1
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockPartial
;
}
else
if
(
*
e1s1
>
0
&
&
*
e2s2
<
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockInside
;
}
else
if
(
*
e1s1
<
=
0
&
&
*
e2s2
>
=
0
)
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockContains
;
}
else
{
*
aSelStatus
=
BlockSelectionStatus
:
:
eBlockPartial
;
}
nsCOMPtr
<
nsINode
>
p1
p2
;
uint32_t
o1
o2
;
if
(
*
e1s1
>
=
0
)
{
p1
=
eStart
-
>
mTextNode
;
o1
=
eStartOffset
;
}
else
{
p1
=
startContainer
;
o1
=
startOffset
;
}
if
(
*
e2s2
<
=
0
)
{
p2
=
eEnd
-
>
mTextNode
;
o2
=
eEndOffset
;
}
else
{
p2
=
endContainer
;
o2
=
endOffset
;
}
range
=
nsRange
:
:
Create
(
p1
o1
p2
o2
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
FilteredContentIterator
>
filteredIter
;
nsresult
rv
=
CreateFilteredContentIterator
(
range
getter_AddRefs
(
filteredIter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContent
>
content
;
filteredIter
-
>
First
(
)
;
if
(
!
p1
-
>
IsText
(
)
)
{
bool
found
=
false
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Next
(
)
)
{
nsINode
*
node
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsText
(
)
)
{
p1
=
node
-
>
AsText
(
)
;
o1
=
0
;
found
=
true
;
break
;
}
}
NS_ENSURE_TRUE
(
found
NS_ERROR_FAILURE
)
;
}
filteredIter
-
>
Last
(
)
;
if
(
!
p2
-
>
IsText
(
)
)
{
bool
found
=
false
;
for
(
;
!
filteredIter
-
>
IsDone
(
)
;
filteredIter
-
>
Prev
(
)
)
{
nsINode
*
node
=
filteredIter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsText
(
)
)
{
p2
=
node
-
>
AsText
(
)
;
o2
=
p2
-
>
AsText
(
)
-
>
Length
(
)
;
found
=
true
;
break
;
}
}
NS_ENSURE_TRUE
(
found
NS_ERROR_FAILURE
)
;
}
bool
found
=
false
;
*
aSelLength
=
0
;
for
(
size_t
i
=
0
;
i
<
tableCount
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
mOffsetTable
[
i
]
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
mOffsetTable
)
;
if
(
!
found
)
{
if
(
entry
-
>
mTextNode
=
=
p1
.
get
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o1
)
)
{
*
aSelOffset
=
entry
-
>
mOffsetInTextInBlock
+
(
o1
-
entry
-
>
mOffsetInTextNode
)
;
if
(
p1
=
=
p2
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o2
)
)
{
*
aSelLength
=
o2
-
o1
;
break
;
}
*
aSelLength
=
entry
-
>
EndOffsetInTextNode
(
)
-
o1
;
found
=
true
;
}
}
else
{
if
(
entry
-
>
mTextNode
=
=
p2
.
get
(
)
&
&
entry
-
>
OffsetInTextNodeIsInRangeOrEndOffset
(
o2
)
)
{
*
aSelLength
+
=
o2
-
entry
-
>
mOffsetInTextNode
;
break
;
}
*
aSelLength
+
=
entry
-
>
mLength
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
GetRangeEndPoints
(
const
AbstractRange
*
aAbstractRange
nsINode
*
*
aStartContainer
uint32_t
*
aStartOffset
nsINode
*
*
aEndContainer
uint32_t
*
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aStartContainer
)
|
|
NS_WARN_IF
(
!
aEndContainer
)
|
|
NS_WARN_IF
(
!
aEndOffset
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsINode
>
startContainer
=
aAbstractRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startContainer
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
endContainer
=
aAbstractRange
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endContainer
)
)
{
return
NS_ERROR_FAILURE
;
}
startContainer
.
forget
(
aStartContainer
)
;
endContainer
.
forget
(
aEndContainer
)
;
*
aStartOffset
=
aAbstractRange
-
>
StartOffset
(
)
;
*
aEndOffset
=
aAbstractRange
-
>
EndOffset
(
)
;
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
for
(
aFilteredIter
-
>
First
(
)
;
!
aFilteredIter
-
>
IsDone
(
)
;
aFilteredIter
-
>
Next
(
)
)
{
if
(
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
break
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
LastTextNode
(
FilteredContentIterator
*
aFilteredIter
IteratorStatus
*
aIteratorStatus
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eDone
;
}
for
(
aFilteredIter
-
>
Last
(
)
;
!
aFilteredIter
-
>
IsDone
(
)
;
aFilteredIter
-
>
Prev
(
)
)
{
if
(
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
if
(
aIteratorStatus
)
{
*
aIteratorStatus
=
IteratorStatus
:
:
eValid
;
}
break
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInCurrentBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
ClearDidSkip
(
aFilteredIter
)
;
RefPtr
<
Text
>
lastTextNode
;
while
(
!
aFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
lastTextNode
&
&
content
&
&
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
)
{
break
;
}
if
(
content
&
&
content
-
>
IsText
(
)
)
{
if
(
lastTextNode
&
&
!
TextServicesDocument
:
:
HasSameBlockNodeParent
(
*
content
-
>
AsText
(
)
*
lastTextNode
)
)
{
break
;
}
lastTextNode
=
content
-
>
AsText
(
)
;
}
aFilteredIter
-
>
Prev
(
)
;
if
(
DidSkip
(
aFilteredIter
)
)
{
break
;
}
}
if
(
lastTextNode
)
{
aFilteredIter
-
>
PositionAt
(
lastTextNode
)
;
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInPrevBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
FirstTextNodeInCurrentBlock
(
aFilteredIter
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
aFilteredIter
-
>
Prev
(
)
;
if
(
aFilteredIter
-
>
IsDone
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
FirstTextNodeInCurrentBlock
(
aFilteredIter
)
;
}
nsresult
TextServicesDocument
:
:
FirstTextNodeInNextBlock
(
FilteredContentIterator
*
aFilteredIter
)
{
bool
crossedBlockBoundary
=
false
;
NS_ENSURE_TRUE
(
aFilteredIter
NS_ERROR_NULL_POINTER
)
;
ClearDidSkip
(
aFilteredIter
)
;
RefPtr
<
Text
>
previousTextNode
;
while
(
!
aFilteredIter
-
>
IsDone
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
)
{
if
(
content
-
>
IsText
(
)
)
{
if
(
crossedBlockBoundary
|
|
(
previousTextNode
&
&
!
TextServicesDocument
:
:
HasSameBlockNodeParent
(
*
previousTextNode
*
content
-
>
AsText
(
)
)
)
)
{
break
;
}
previousTextNode
=
content
-
>
AsText
(
)
;
}
else
if
(
!
crossedBlockBoundary
&
&
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
)
{
crossedBlockBoundary
=
true
;
}
}
aFilteredIter
-
>
Next
(
)
;
if
(
!
crossedBlockBoundary
&
&
DidSkip
(
aFilteredIter
)
)
{
crossedBlockBoundary
=
true
;
}
}
return
NS_OK
;
}
nsresult
TextServicesDocument
:
:
GetFirstTextNodeInPrevBlock
(
nsIContent
*
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
*
aContent
=
0
;
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
nsresult
rv
=
FirstTextNodeInPrevBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mFilteredIter
-
>
PositionAt
(
node
)
;
return
rv
;
}
if
(
!
mFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
current
=
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
current
.
forget
(
aContent
)
;
}
return
mFilteredIter
-
>
PositionAt
(
node
)
;
}
nsresult
TextServicesDocument
:
:
GetFirstTextNodeInNextBlock
(
nsIContent
*
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
*
aContent
=
0
;
nsINode
*
node
=
mFilteredIter
-
>
GetCurrentNode
(
)
;
nsresult
rv
=
FirstTextNodeInNextBlock
(
mFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
mFilteredIter
-
>
PositionAt
(
node
)
;
return
rv
;
}
if
(
!
mFilteredIter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
current
=
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
?
mFilteredIter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
;
current
.
forget
(
aContent
)
;
}
return
mFilteredIter
-
>
PositionAt
(
node
)
;
}
Result
<
TextServicesDocument
:
:
IteratorStatus
nsresult
>
TextServicesDocument
:
:
OffsetEntryArray
:
:
Init
(
FilteredContentIterator
&
aFilteredIter
IteratorStatus
aIteratorStatus
nsRange
*
aIterRange
nsAString
*
aAllTextInBlock
)
{
Clear
(
)
;
if
(
aAllTextInBlock
)
{
aAllTextInBlock
-
>
Truncate
(
)
;
}
if
(
aIteratorStatus
=
=
IteratorStatus
:
:
eDone
)
{
return
IteratorStatus
:
:
eDone
;
}
nsCOMPtr
<
nsINode
>
rngStartNode
rngEndNode
;
uint32_t
rngStartOffset
=
0
rngEndOffset
=
0
;
if
(
aIterRange
)
{
nsresult
rv
=
TextServicesDocument
:
:
GetRangeEndPoints
(
aIterRange
getter_AddRefs
(
rngStartNode
)
&
rngStartOffset
getter_AddRefs
(
rngEndNode
)
&
rngEndOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
GetRangeEndPoints
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
nsresult
rv
=
TextServicesDocument
:
:
FirstTextNodeInCurrentBlock
(
&
aFilteredIter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
FirstTextNodeInCurrentBlock
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
TextServicesDocument
:
:
ClearDidSkip
(
&
aFilteredIter
)
;
uint32_t
offset
=
0
;
RefPtr
<
Text
>
firstTextNode
previousTextNode
;
while
(
!
aFilteredIter
.
IsDone
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
content
=
aFilteredIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
?
aFilteredIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
:
nullptr
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
if
(
content
-
>
IsText
(
)
)
{
if
(
previousTextNode
&
&
!
TextServicesDocument
:
:
HasSameBlockNodeParent
(
*
previousTextNode
*
content
-
>
AsText
(
)
)
)
{
break
;
}
nsString
str
;
content
-
>
AsText
(
)
-
>
GetNodeValue
(
str
)
;
UniquePtr
<
OffsetEntry
>
&
entry
=
*
AppendElement
(
MakeUnique
<
OffsetEntry
>
(
*
content
-
>
AsText
(
)
offset
str
.
Length
(
)
)
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
uint32_t
startOffset
=
0
;
uint32_t
endOffset
=
str
.
Length
(
)
;
bool
adjustStr
=
false
;
if
(
entry
-
>
mTextNode
=
=
rngStartNode
)
{
entry
-
>
mOffsetInTextNode
=
startOffset
=
rngStartOffset
;
adjustStr
=
true
;
}
if
(
entry
-
>
mTextNode
=
=
rngEndNode
)
{
endOffset
=
rngEndOffset
;
adjustStr
=
true
;
}
if
(
adjustStr
)
{
entry
-
>
mLength
=
endOffset
-
startOffset
;
str
=
Substring
(
str
startOffset
entry
-
>
mLength
)
;
}
offset
+
=
str
.
Length
(
)
;
if
(
aAllTextInBlock
)
{
if
(
!
firstTextNode
)
{
*
aAllTextInBlock
=
str
;
}
else
{
*
aAllTextInBlock
+
=
str
;
}
}
previousTextNode
=
content
-
>
AsText
(
)
;
if
(
!
firstTextNode
)
{
firstTextNode
=
content
-
>
AsText
(
)
;
}
}
}
aFilteredIter
.
Next
(
)
;
if
(
TextServicesDocument
:
:
DidSkip
(
&
aFilteredIter
)
)
{
break
;
}
}
if
(
firstTextNode
)
{
aFilteredIter
.
PositionAt
(
firstTextNode
)
;
return
aIteratorStatus
;
}
return
IteratorStatus
:
:
eDone
;
}
void
TextServicesDocument
:
:
OffsetEntryArray
:
:
RemoveInvalidElements
(
)
{
for
(
size_t
i
=
0
;
i
<
Length
(
)
;
)
{
if
(
ElementAt
(
i
)
-
>
mIsValid
)
{
i
+
+
;
continue
;
}
RemoveElementAt
(
i
)
;
if
(
!
mSelection
.
IsSet
(
)
)
{
continue
;
}
if
(
mSelection
.
StartIndex
(
)
=
=
i
)
{
NS_ASSERTION
(
false
"
What
should
we
do
in
this
case
?
"
)
;
mSelection
.
Reset
(
)
;
}
else
if
(
mSelection
.
StartIndex
(
)
>
i
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
StartIndex
(
)
-
1
<
Length
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
EndIndex
(
)
-
1
<
Length
(
)
)
;
mSelection
.
SetIndexes
(
mSelection
.
StartIndex
(
)
-
1
mSelection
.
EndIndex
(
)
-
1
)
;
}
else
if
(
mSelection
.
EndIndex
(
)
>
=
i
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSelection
.
EndIndex
(
)
-
1
<
Length
(
)
)
;
mSelection
.
SetIndexes
(
mSelection
.
StartIndex
(
)
mSelection
.
EndIndex
(
)
-
1
)
;
}
}
}
nsresult
TextServicesDocument
:
:
OffsetEntryArray
:
:
SplitElementAt
(
size_t
aIndex
uint32_t
aOffsetInTextNode
)
{
OffsetEntry
*
leftEntry
=
ElementAt
(
aIndex
)
.
get
(
)
;
MOZ_ASSERT
(
leftEntry
)
;
NS_ASSERTION
(
(
aOffsetInTextNode
>
0
)
"
aOffsetInTextNode
=
=
0
"
)
;
NS_ASSERTION
(
(
aOffsetInTextNode
<
leftEntry
-
>
mLength
)
"
aOffsetInTextNode
>
=
mLength
"
)
;
if
(
aOffsetInTextNode
<
1
|
|
aOffsetInTextNode
>
=
leftEntry
-
>
mLength
)
{
return
NS_ERROR_FAILURE
;
}
const
uint32_t
oldLength
=
leftEntry
-
>
mLength
-
aOffsetInTextNode
;
UniquePtr
<
OffsetEntry
>
&
rightEntry
=
*
InsertElementAt
(
aIndex
+
1
MakeUnique
<
OffsetEntry
>
(
leftEntry
-
>
mTextNode
leftEntry
-
>
mOffsetInTextInBlock
+
oldLength
aOffsetInTextNode
)
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
leftEntry
-
>
mLength
=
oldLength
;
rightEntry
-
>
mOffsetInTextNode
=
leftEntry
-
>
mOffsetInTextNode
+
oldLength
;
return
NS_OK
;
}
Maybe
<
size_t
>
TextServicesDocument
:
:
OffsetEntryArray
:
:
FirstIndexOf
(
const
Text
&
aTextNode
)
const
{
for
(
size_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
if
(
ElementAt
(
i
)
-
>
mTextNode
=
=
&
aTextNode
)
{
return
Some
(
i
)
;
}
}
return
Nothing
(
)
;
}
#
define
IS_NBSP_CHAR
(
c
)
(
(
(
unsigned
char
)
0xa0
)
=
=
(
c
)
)
Result
<
EditorDOMRangeInTexts
nsresult
>
TextServicesDocument
:
:
OffsetEntryArray
:
:
FindWordRange
(
nsAString
&
aAllTextInBlock
const
EditorRawDOMPoint
&
aStartPointToScan
)
{
MOZ_ASSERT
(
aStartPointToScan
.
IsInTextNode
(
)
)
;
Maybe
<
size_t
>
maybeEntryIndex
=
FirstIndexOf
(
*
aStartPointToScan
.
ContainerAs
<
Text
>
(
)
)
;
if
(
NS_WARN_IF
(
maybeEntryIndex
.
isNothing
(
)
)
)
{
NS_WARNING
(
"
TextServicesDocument
:
:
OffsetEntryArray
:
:
FirstIndexOf
(
)
didn
'
t
find
"
"
entries
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
UniquePtr
<
OffsetEntry
>
&
entry
=
ElementAt
(
*
maybeEntryIndex
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
uint32_t
strOffset
=
entry
-
>
mOffsetInTextInBlock
+
aStartPointToScan
.
Offset
(
)
-
entry
-
>
mOffsetInTextNode
;
const
char16_t
*
str
=
aAllTextInBlock
.
BeginReading
(
)
;
uint32_t
strLen
=
aAllTextInBlock
.
Length
(
)
;
intl
:
:
WordRange
res
=
intl
:
:
WordBreaker
:
:
FindWord
(
str
strLen
strOffset
)
;
if
(
res
.
mBegin
=
=
res
.
mEnd
)
{
return
Err
(
str
?
NS_ERROR_ILLEGAL_VALUE
:
NS_ERROR_NULL_POINTER
)
;
}
while
(
res
.
mBegin
<
=
res
.
mEnd
&
&
IS_NBSP_CHAR
(
str
[
res
.
mBegin
]
)
)
{
res
.
mBegin
+
+
;
}
if
(
str
[
res
.
mEnd
]
=
=
static_cast
<
char16_t
>
(
0x20
)
)
{
uint32_t
realEndWord
=
res
.
mEnd
-
1
;
while
(
realEndWord
>
res
.
mBegin
&
&
IS_NBSP_CHAR
(
str
[
realEndWord
]
)
)
{
realEndWord
-
-
;
}
if
(
realEndWord
<
res
.
mEnd
-
1
)
{
res
.
mEnd
=
realEndWord
+
1
;
}
}
EditorDOMPointInText
wordStart
wordEnd
;
size_t
lastIndex
=
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
=
lastIndex
;
i
+
+
)
{
const
UniquePtr
<
OffsetEntry
>
&
entry
=
ElementAt
(
i
)
;
LockOffsetEntryArrayLengthInDebugBuild
(
observer
*
this
)
;
if
(
entry
-
>
mOffsetInTextInBlock
<
=
res
.
mBegin
&
&
(
res
.
mBegin
<
entry
-
>
EndOffsetInTextInBlock
(
)
|
|
(
res
.
mBegin
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
&
&
i
=
=
lastIndex
)
)
)
{
wordStart
.
Set
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextNode
+
res
.
mBegin
-
entry
-
>
mOffsetInTextInBlock
)
;
}
if
(
entry
-
>
mOffsetInTextInBlock
<
=
res
.
mEnd
&
&
res
.
mEnd
<
=
entry
-
>
EndOffsetInTextInBlock
(
)
)
{
if
(
res
.
mBegin
=
=
res
.
mEnd
&
&
res
.
mEnd
=
=
entry
-
>
EndOffsetInTextInBlock
(
)
&
&
i
!
=
lastIndex
)
{
continue
;
}
wordEnd
.
Set
(
entry
-
>
mTextNode
entry
-
>
mOffsetInTextNode
+
res
.
mEnd
-
entry
-
>
mOffsetInTextInBlock
)
;
break
;
}
}
return
EditorDOMRangeInTexts
(
wordStart
wordEnd
)
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidDeleteNode
(
nsINode
*
aChild
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
|
|
NS_WARN_IF
(
!
aChild
)
|
|
!
aChild
-
>
IsContent
(
)
)
{
return
NS_OK
;
}
DidDeleteContent
(
*
aChild
-
>
AsContent
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidJoinContents
(
const
EditorRawDOMPoint
&
aJoinedPoint
const
nsINode
*
aRemovedNode
bool
aLeftNodeWasRemoved
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aJoinedPoint
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aRemovedNode
-
>
IsContent
(
)
)
)
)
{
return
NS_OK
;
}
DidJoinContents
(
aJoinedPoint
*
aRemovedNode
-
>
AsContent
(
)
aLeftNodeWasRemoved
?
JoinNodesDirection
:
:
LeftNodeIntoRightNode
:
JoinNodesDirection
:
:
RightNodeIntoLeftNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
DidInsertText
(
CharacterData
*
aTextNode
int32_t
aOffset
const
nsAString
&
aString
nsresult
aResult
)
{
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
WillDeleteText
(
CharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
return
NS_OK
;
}
NS_IMETHODIMP
TextServicesDocument
:
:
WillDeleteRanges
(
const
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRangesToDelete
)
{
return
NS_OK
;
}
#
undef
LockOffsetEntryArrayLengthInDebugBuild
}
