#
include
"
EditorSpellCheck
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
TextServicesDocument
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
intl
/
Locale
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
intl
/
OSPreferences
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
mozSpellChecker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentPrefService2
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
intl
:
:
LocaleService
;
using
intl
:
:
OSPreferences
;
static
mozilla
:
:
LazyLogModule
sEditorSpellChecker
(
"
EditorSpellChecker
"
)
;
class
UpdateDictionaryHolder
{
private
:
EditorSpellCheck
*
mSpellCheck
;
public
:
explicit
UpdateDictionaryHolder
(
EditorSpellCheck
*
esc
)
:
mSpellCheck
(
esc
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
BeginUpdateDictionary
(
)
;
}
}
~
UpdateDictionaryHolder
(
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
EndUpdateDictionary
(
)
;
}
}
}
;
#
define
CPS_PREF_NAME
u
"
spellcheck
.
lang
"
_ns
static
nsIURI
*
GetDocumentURI
(
EditorBase
*
aEditor
)
{
MOZ_ASSERT
(
aEditor
)
;
Document
*
doc
=
aEditor
-
>
AsEditorBase
(
)
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
return
doc
-
>
GetDocumentURI
(
)
;
}
static
nsILoadContext
*
GetLoadContext
(
nsIEditor
*
aEditor
)
{
Document
*
doc
=
aEditor
-
>
AsEditorBase
(
)
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
return
doc
-
>
GetLoadContext
(
)
;
}
static
nsCString
DictionariesToString
(
const
nsTArray
<
nsCString
>
&
aDictionaries
)
{
nsCString
asString
;
for
(
const
auto
&
dictionary
:
aDictionaries
)
{
asString
.
Append
(
dictionary
)
;
asString
.
Append
(
'
'
)
;
}
return
asString
;
}
static
void
StringToDictionaries
(
const
nsCString
&
aString
nsTArray
<
nsCString
>
&
aDictionaries
)
{
nsTArray
<
nsCString
>
asDictionaries
;
for
(
const
nsACString
&
token
:
nsCCharSeparatedTokenizer
(
aString
'
'
)
.
ToRange
(
)
)
{
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
aDictionaries
.
AppendElement
(
token
)
;
}
}
class
DictionaryFetcher
final
:
public
nsIContentPrefCallback2
{
public
:
NS_DECL_ISUPPORTS
DictionaryFetcher
(
EditorSpellCheck
*
aSpellCheck
nsIEditorSpellCheckCallback
*
aCallback
uint32_t
aGroup
)
:
mCallback
(
aCallback
)
mGroup
(
aGroup
)
mSpellCheck
(
aSpellCheck
)
{
}
NS_IMETHOD
Fetch
(
nsIEditor
*
aEditor
)
;
NS_IMETHOD
HandleResult
(
nsIContentPref
*
aPref
)
override
{
nsCOMPtr
<
nsIVariant
>
value
;
nsresult
rv
=
aPref
-
>
GetValue
(
getter_AddRefs
(
value
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCString
asString
;
value
-
>
GetAsACString
(
asString
)
;
StringToDictionaries
(
asString
mDictionaries
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
reason
)
override
{
mSpellCheck
-
>
DictionaryFetched
(
this
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleError
(
nsresult
error
)
override
{
return
NS_OK
;
}
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
uint32_t
mGroup
;
RefPtr
<
nsAtom
>
mRootContentLang
;
RefPtr
<
nsAtom
>
mRootDocContentLang
;
nsTArray
<
nsCString
>
mDictionaries
;
private
:
~
DictionaryFetcher
(
)
{
}
RefPtr
<
EditorSpellCheck
>
mSpellCheck
;
}
;
NS_IMPL_ISUPPORTS
(
DictionaryFetcher
nsIContentPrefCallback2
)
class
ContentPrefInitializerRunnable
final
:
public
Runnable
{
public
:
ContentPrefInitializerRunnable
(
nsIEditor
*
aEditor
nsIContentPrefCallback2
*
aCallback
)
:
Runnable
(
"
ContentPrefInitializerRunnable
"
)
mEditorBase
(
aEditor
-
>
AsEditorBase
(
)
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mEditorBase
-
>
Destroyed
(
)
)
{
mCallback
-
>
HandleError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
contentPrefService
)
)
{
mCallback
-
>
HandleError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
docUri
=
GetDocumentURI
(
mEditorBase
)
;
if
(
NS_WARN_IF
(
!
docUri
)
)
{
mCallback
-
>
HandleError
(
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsAutoCString
docUriSpec
;
nsresult
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mCallback
-
>
HandleError
(
rv
)
;
return
NS_OK
;
}
rv
=
contentPrefService
-
>
GetByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
GetLoadContext
(
mEditorBase
)
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mCallback
-
>
HandleError
(
rv
)
;
return
NS_OK
;
}
return
NS_OK
;
}
private
:
RefPtr
<
EditorBase
>
mEditorBase
;
nsCOMPtr
<
nsIContentPrefCallback2
>
mCallback
;
}
;
NS_IMETHODIMP
DictionaryFetcher
:
:
Fetch
(
nsIEditor
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ContentPrefInitializerRunnable
(
aEditor
this
)
;
NS_DispatchToCurrentThreadQueue
(
runnable
.
forget
(
)
1000
EventQueuePriority
:
:
Idle
)
;
return
NS_OK
;
}
static
nsresult
StoreCurrentDictionaries
(
EditorBase
*
aEditorBase
const
nsTArray
<
nsCString
>
&
aDictionaries
)
{
NS_ENSURE_ARG_POINTER
(
aEditorBase
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
=
GetDocumentURI
(
aEditorBase
)
;
if
(
NS_WARN_IF
(
!
docUri
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsVariant
>
prefValue
=
new
nsVariant
(
)
;
nsCString
asString
=
DictionariesToString
(
aDictionaries
)
;
prefValue
-
>
SetAsAString
(
NS_ConvertUTF8toUTF16
(
asString
)
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
return
contentPrefService
-
>
Set
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
prefValue
GetLoadContext
(
aEditorBase
)
nullptr
)
;
}
static
nsresult
ClearCurrentDictionaries
(
EditorBase
*
aEditorBase
)
{
NS_ENSURE_ARG_POINTER
(
aEditorBase
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
=
GetDocumentURI
(
aEditorBase
)
;
if
(
NS_WARN_IF
(
!
docUri
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
return
contentPrefService
-
>
RemoveByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
GetLoadContext
(
aEditorBase
)
nullptr
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
EditorSpellCheck
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
EditorSpellCheck
)
NS_INTERFACE_MAP_BEGIN
(
EditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
EditorSpellCheck
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
EditorSpellCheck
mEditor
mSpellChecker
)
EditorSpellCheck
:
:
EditorSpellCheck
(
)
:
mTxtSrvFilterType
(
0
)
mSuggestedWordIndex
(
0
)
mDictionaryFetcherGroup
(
0
)
mUpdateDictionaryRunning
(
false
)
{
}
EditorSpellCheck
:
:
~
EditorSpellCheck
(
)
{
mSpellChecker
=
nullptr
;
}
mozSpellChecker
*
EditorSpellCheck
:
:
GetSpellChecker
(
)
{
return
mSpellChecker
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
CanSpellCheck
(
bool
*
aCanSpellCheck
)
{
RefPtr
<
mozSpellChecker
>
spellChecker
=
mSpellChecker
;
if
(
!
spellChecker
)
{
spellChecker
=
mozSpellChecker
:
:
Create
(
)
;
MOZ_ASSERT
(
spellChecker
)
;
}
nsTArray
<
nsCString
>
dictList
;
nsresult
rv
=
spellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aCanSpellCheck
=
!
dictList
.
IsEmpty
(
)
;
return
NS_OK
;
}
class
CallbackCaller
final
:
public
Runnable
{
public
:
explicit
CallbackCaller
(
nsIEditorSpellCheckCallback
*
aCallback
)
:
mozilla
:
:
Runnable
(
"
CallbackCaller
"
)
mCallback
(
aCallback
)
{
}
~
CallbackCaller
(
)
{
Run
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mCallback
)
{
mCallback
-
>
EditorSpellCheckDone
(
)
;
mCallback
=
nullptr
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
}
;
NS_IMETHODIMP
EditorSpellCheck
:
:
InitSpellChecker
(
nsIEditor
*
aEditor
bool
aEnableSelectionChecking
nsIEditorSpellCheckCallback
*
aCallback
)
{
NS_ENSURE_TRUE
(
aEditor
NS_ERROR_NULL_POINTER
)
;
mEditor
=
aEditor
-
>
AsEditorBase
(
)
;
RefPtr
<
Document
>
doc
=
mEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
new
TextServicesDocument
(
)
;
textServicesDocument
-
>
SetFilterType
(
mTxtSrvFilterType
)
;
mSpellChecker
=
mozSpellChecker
:
:
Create
(
)
;
MOZ_ASSERT
(
mSpellChecker
)
;
rv
=
mSpellChecker
-
>
SetDocument
(
textServicesDocument
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
textServicesDocument
-
>
InitWithEditor
(
aEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEnableSelectionChecking
)
{
RefPtr
<
Selection
>
selection
;
aEditor
-
>
GetSelection
(
getter_AddRefs
(
selection
)
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selection
-
>
RangeCount
(
)
)
{
RefPtr
<
const
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
if
(
!
range
-
>
Collapsed
(
)
)
{
RefPtr
<
StaticRange
>
staticRange
=
StaticRange
:
:
Create
(
range
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
staticRange
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
textServicesDocument
-
>
ExpandRangeToWordBoundaries
(
staticRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
textServicesDocument
-
>
SetExtent
(
staticRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
rv
=
UpdateCurrentDictionary
(
aCallback
)
;
if
(
NS_FAILED
(
rv
)
&
&
aCallback
)
{
RefPtr
<
CallbackCaller
>
caller
=
new
CallbackCaller
(
aCallback
)
;
rv
=
doc
-
>
Dispatch
(
caller
.
forget
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
GetNextMisspelledWord
(
nsAString
&
aNextMisspelledWord
)
{
MOZ_LOG
(
sEditorSpellChecker
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
RefPtr
<
mozSpellChecker
>
spellChecker
(
mSpellChecker
)
;
return
spellChecker
-
>
NextMisspelledWord
(
aNextMisspelledWord
mSuggestedWordList
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
GetSuggestedWord
(
nsAString
&
aSuggestedWord
)
{
if
(
mSuggestedWordIndex
<
static_cast
<
int32_t
>
(
mSuggestedWordList
.
Length
(
)
)
)
{
aSuggestedWord
=
mSuggestedWordList
[
mSuggestedWordIndex
]
;
mSuggestedWordIndex
+
+
;
}
else
{
aSuggestedWord
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
CheckCurrentWord
(
const
nsAString
&
aSuggestedWord
bool
*
aIsMisspelled
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
return
mSpellChecker
-
>
CheckWord
(
aSuggestedWord
aIsMisspelled
&
mSuggestedWordList
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
Suggest
(
const
nsAString
&
aSuggestedWord
uint32_t
aCount
JSContext
*
aCx
Promise
*
*
aPromise
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
mSpellChecker
-
>
Suggest
(
aSuggestedWord
aCount
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
promise
]
(
const
CopyableTArray
<
nsString
>
&
aSuggestions
)
{
promise
-
>
MaybeResolve
(
aSuggestions
)
;
}
[
promise
]
(
nsresult
aError
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
RefPtr
<
CheckWordPromise
>
EditorSpellCheck
:
:
CheckCurrentWordsNoSuggest
(
const
nsTArray
<
nsString
>
&
aSuggestedWords
)
{
if
(
NS_WARN_IF
(
!
mSpellChecker
)
)
{
return
CheckWordPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_INITIALIZED
__func__
)
;
}
return
mSpellChecker
-
>
CheckWords
(
aSuggestedWords
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
ReplaceWord
(
const
nsAString
&
aMisspelledWord
const
nsAString
&
aReplaceWord
bool
aAllOccurrences
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
mozSpellChecker
>
spellChecker
(
mSpellChecker
)
;
return
spellChecker
-
>
Replace
(
aMisspelledWord
aReplaceWord
aAllOccurrences
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
IgnoreWordAllOccurrences
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
IgnoreAll
(
aWord
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
AddWordToDictionary
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
AddWordToPersonalDictionary
(
aWord
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
RemoveWordFromDictionary
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
RemoveWordFromPersonalDictionary
(
aWord
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
GetDictionaryList
(
nsTArray
<
nsCString
>
&
aList
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
GetDictionaryList
(
&
aList
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
GetCurrentDictionaries
(
nsTArray
<
nsCString
>
&
aDictionaries
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
GetCurrentDictionaries
(
aDictionaries
)
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
SetCurrentDictionaries
(
const
nsTArray
<
nsCString
>
&
aDictionaries
JSContext
*
aCx
Promise
*
*
aPromise
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
EditorSpellCheck
>
kungFuDeathGrip
=
this
;
if
(
!
mUpdateDictionaryRunning
)
{
mDictionaryFetcherGroup
+
+
;
uint32_t
flags
=
0
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIEditor
:
:
eEditorMailMask
)
)
{
bool
contentPrefMatchesUserPref
=
true
;
if
(
!
aDictionaries
.
IsEmpty
(
)
)
{
if
(
aDictionaries
.
Length
(
)
!
=
mPreferredLangs
.
Length
(
)
)
{
contentPrefMatchesUserPref
=
false
;
}
else
{
for
(
const
auto
&
dictName
:
aDictionaries
)
{
if
(
mPreferredLangs
.
IndexOf
(
dictName
)
=
=
nsTArray
<
nsCString
>
:
:
NoIndex
)
{
contentPrefMatchesUserPref
=
false
;
break
;
}
}
}
}
if
(
!
contentPrefMatchesUserPref
)
{
StoreCurrentDictionaries
(
mEditor
aDictionaries
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Writing
content
preferences
for
|
%
s
|
\
n
"
DictionariesToString
(
aDictionaries
)
.
Data
(
)
)
;
#
endif
}
else
{
ClearCurrentDictionaries
(
mEditor
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Clearing
content
preferences
for
|
%
s
|
\
n
"
DictionariesToString
(
aDictionaries
)
.
Data
(
)
)
;
#
endif
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCString
asString
=
DictionariesToString
(
aDictionaries
)
;
Preferences
:
:
SetCString
(
"
spellchecker
.
dictionary
"
asString
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Possibly
storing
spellchecker
.
dictionary
|
%
s
|
\
n
"
asString
.
Data
(
)
)
;
#
endif
}
}
else
{
MOZ_ASSERT
(
flags
&
nsIEditor
:
:
eEditorMailMask
)
;
nsCOMPtr
<
nsIContent
>
anonymousDivOrEditingHost
;
if
(
HTMLEditor
*
htmlEditor
=
mEditor
-
>
GetAsHTMLEditor
(
)
)
{
anonymousDivOrEditingHost
=
htmlEditor
-
>
ComputeEditingHost
(
)
;
}
else
{
anonymousDivOrEditingHost
=
mEditor
-
>
GetRoot
(
)
;
}
RefPtr
<
Document
>
ownerDoc
=
anonymousDivOrEditingHost
-
>
OwnerDoc
(
)
;
Document
*
parentDoc
=
ownerDoc
-
>
GetInProcessParentDocument
(
)
;
if
(
parentDoc
)
{
parentDoc
-
>
SetHeaderData
(
nsGkAtoms
:
:
headerContentLanguage
NS_ConvertUTF8toUTF16
(
DictionariesToString
(
aDictionaries
)
)
)
;
}
}
}
nsIGlobalObject
*
globalObject
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
globalObject
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
mSpellChecker
-
>
SetCurrentDictionaries
(
aDictionaries
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
(
nsresult
aError
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
)
;
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
UninitSpellChecker
(
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
mDictionaryFetcherGroup
+
+
;
mSpellChecker
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
SetFilterType
(
uint32_t
aFilterType
)
{
mTxtSrvFilterType
=
aFilterType
;
return
NS_OK
;
}
nsresult
EditorSpellCheck
:
:
DeleteSuggestedWordList
(
)
{
mSuggestedWordList
.
Clear
(
)
;
mSuggestedWordIndex
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorSpellCheck
:
:
UpdateCurrentDictionary
(
nsIEditorSpellCheckCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
!
mSpellChecker
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
RefPtr
<
EditorSpellCheck
>
kungFuDeathGrip
=
this
;
const
RefPtr
<
Element
>
rootEditableElement
=
[
]
(
const
EditorBase
&
aEditorBase
)
-
>
Element
*
{
if
(
!
aEditorBase
.
IsHTMLEditor
(
)
)
{
return
aEditorBase
.
GetRoot
(
)
;
}
if
(
aEditorBase
.
IsMailEditor
(
)
)
{
Element
*
const
editingHost
=
aEditorBase
.
AsHTMLEditor
(
)
-
>
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
nullptr
;
}
Document
*
parentDoc
=
editingHost
-
>
OwnerDoc
(
)
-
>
GetInProcessParentDocument
(
)
;
if
(
!
parentDoc
)
{
return
editingHost
;
}
return
parentDoc
-
>
GetDocumentElement
(
)
;
}
return
aEditorBase
.
AsHTMLEditor
(
)
-
>
GetFocusedElement
(
)
;
}
(
*
mEditor
)
;
if
(
!
rootEditableElement
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DictionaryFetcher
>
fetcher
=
new
DictionaryFetcher
(
this
aCallback
mDictionaryFetcherGroup
)
;
fetcher
-
>
mRootContentLang
=
rootEditableElement
-
>
GetLang
(
)
;
RefPtr
<
Document
>
doc
=
rootEditableElement
-
>
GetComposedDoc
(
)
;
NS_ENSURE_STATE
(
doc
)
;
fetcher
-
>
mRootDocContentLang
=
doc
-
>
GetContentLanguage
(
)
;
rv
=
fetcher
-
>
Fetch
(
mEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
EditorSpellCheck
:
:
BuildDictionaryList
(
const
nsACString
&
aDictName
const
nsTArray
<
nsCString
>
&
aDictList
enum
dictCompare
aCompareType
nsTArray
<
nsCString
>
&
aOutList
)
{
for
(
const
auto
&
dictStr
:
aDictList
)
{
bool
equals
=
false
;
switch
(
aCompareType
)
{
case
DICT_NORMAL_COMPARE
:
equals
=
aDictName
.
Equals
(
dictStr
)
;
break
;
case
DICT_COMPARE_CASE_INSENSITIVE
:
equals
=
aDictName
.
Equals
(
dictStr
nsCaseInsensitiveCStringComparator
)
;
break
;
case
DICT_COMPARE_DASHMATCH
:
equals
=
nsStyleUtil
:
:
DashMatchCompare
(
NS_ConvertUTF8toUTF16
(
dictStr
)
NS_ConvertUTF8toUTF16
(
aDictName
)
nsCaseInsensitiveStringComparator
)
;
break
;
}
if
(
equals
)
{
if
(
aOutList
.
IndexOf
(
dictStr
)
=
=
nsTArray
<
nsCString
>
:
:
NoIndex
)
{
aOutList
.
AppendElement
(
dictStr
)
;
}
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
|
%
s
|
.
\
n
"
dictStr
.
get
(
)
)
;
#
endif
return
true
;
}
}
return
false
;
}
nsresult
EditorSpellCheck
:
:
DictionaryFetched
(
DictionaryFetcher
*
aFetcher
)
{
MOZ_ASSERT
(
aFetcher
)
;
RefPtr
<
EditorSpellCheck
>
kungFuDeathGrip
=
this
;
BeginUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mGroup
<
mDictionaryFetcherGroup
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
NS_OK
;
}
nsCString
contentLangs
;
mPreferredLangs
.
Clear
(
)
;
if
(
aFetcher
-
>
mRootContentLang
)
{
aFetcher
-
>
mRootContentLang
-
>
ToUTF8String
(
contentLangs
)
;
}
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLangs
(
element
)
|
%
s
|
\
n
"
contentLangs
.
get
(
)
)
;
#
endif
if
(
!
contentLangs
.
IsEmpty
(
)
)
{
mPreferredLangs
.
AppendElement
(
contentLangs
)
;
}
else
{
if
(
aFetcher
-
>
mRootDocContentLang
)
{
aFetcher
-
>
mRootDocContentLang
-
>
ToUTF8String
(
contentLangs
)
;
}
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLangs
(
content
-
language
)
|
%
s
|
\
n
"
contentLangs
.
get
(
)
)
;
#
endif
StringToDictionaries
(
contentLangs
mPreferredLangs
)
;
}
AutoTArray
<
nsCString
8
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
rv
;
}
nsAutoCString
dictName
;
uint32_t
flags
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIEditor
:
:
eEditorMailMask
)
)
{
if
(
!
aFetcher
-
>
mDictionaries
.
IsEmpty
(
)
)
{
RefPtr
<
EditorSpellCheck
>
self
=
this
;
RefPtr
<
DictionaryFetcher
>
fetcher
=
aFetcher
;
mSpellChecker
-
>
SetCurrentDictionaries
(
aFetcher
-
>
mDictionaries
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Assigned
from
content
preferences
|
%
s
|
\
n
"
DictionariesToString
(
fetcher
-
>
mDictionaries
)
.
Data
(
)
)
;
#
endif
self
-
>
DeleteSuggestedWordList
(
)
;
self
-
>
EndUpdateDictionary
(
)
;
if
(
fetcher
-
>
mCallback
)
{
fetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
}
[
self
fetcher
]
(
nsresult
aError
)
{
if
(
aError
=
=
NS_ERROR_ABORT
)
{
return
;
}
ClearCurrentDictionaries
(
self
-
>
mEditor
)
;
self
-
>
SetFallbackDictionary
(
fetcher
)
;
}
)
;
return
NS_OK
;
}
}
SetFallbackDictionary
(
aFetcher
)
;
return
NS_OK
;
}
void
EditorSpellCheck
:
:
SetDictionarySucceeded
(
DictionaryFetcher
*
aFetcher
)
{
DeleteSuggestedWordList
(
)
;
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
}
void
EditorSpellCheck
:
:
SetFallbackDictionary
(
DictionaryFetcher
*
aFetcher
)
{
MOZ_ASSERT
(
mUpdateDictionaryRunning
)
;
AutoTArray
<
nsCString
6
>
tryDictList
;
AutoTArray
<
nsCString
8
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
;
}
nsAutoCString
prefDictionariesAsString
;
Preferences
:
:
GetLocalizedCString
(
"
spellchecker
.
dictionary
"
prefDictionariesAsString
)
;
nsTArray
<
nsCString
>
prefDictionaries
;
StringToDictionaries
(
prefDictionariesAsString
prefDictionaries
)
;
nsAutoCString
appLocaleStr
;
for
(
const
auto
&
dictName
:
mPreferredLangs
)
{
if
(
BuildDictionaryList
(
dictName
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
from
element
/
doc
|
%
s
|
\
n
"
dictName
.
get
(
)
)
;
#
endif
continue
;
}
mozilla
:
:
intl
:
:
Locale
loc
;
if
(
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
dictName
loc
)
.
isOk
(
)
&
&
loc
.
Canonicalize
(
)
.
isOk
(
)
)
{
Span
<
const
char
>
language
=
loc
.
Language
(
)
.
Span
(
)
;
nsAutoCString
langCode
(
language
.
data
(
)
language
.
size
(
)
)
;
bool
didAppend
=
false
;
for
(
const
auto
&
dictionary
:
prefDictionaries
)
{
if
(
nsStyleUtil
:
:
DashMatchCompare
(
NS_ConvertUTF8toUTF16
(
dictionary
)
NS_ConvertUTF8toUTF16
(
langCode
)
nsTDefaultStringComparator
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
preference
value
|
%
s
|
since
it
matches
language
"
"
code
\
n
"
dictionary
.
Data
(
)
)
;
#
endif
if
(
BuildDictionaryList
(
dictionary
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
)
{
didAppend
=
true
;
break
;
}
}
}
if
(
didAppend
)
{
continue
;
}
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsBCP47
(
appLocaleStr
)
;
if
(
!
appLocaleStr
.
IsEmpty
(
)
)
{
mozilla
:
:
intl
:
:
Locale
appLoc
;
auto
result
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
appLocaleStr
appLoc
)
;
if
(
result
.
isOk
(
)
&
&
appLoc
.
Canonicalize
(
)
.
isOk
(
)
&
&
loc
.
Language
(
)
.
Span
(
)
=
=
appLoc
.
Language
(
)
.
Span
(
)
)
{
if
(
BuildDictionaryList
(
appLocaleStr
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
)
{
continue
;
}
}
}
nsAutoCString
sysLocaleStr
;
OSPreferences
:
:
GetInstance
(
)
-
>
GetSystemLocale
(
sysLocaleStr
)
;
if
(
!
sysLocaleStr
.
IsEmpty
(
)
)
{
mozilla
:
:
intl
:
:
Locale
sysLoc
;
auto
result
=
mozilla
:
:
intl
:
:
LocaleParser
:
:
TryParse
(
sysLocaleStr
sysLoc
)
;
if
(
result
.
isOk
(
)
&
&
sysLoc
.
Canonicalize
(
)
.
isOk
(
)
&
&
loc
.
Language
(
)
.
Span
(
)
=
=
sysLoc
.
Language
(
)
.
Span
(
)
)
{
if
(
BuildDictionaryList
(
sysLocaleStr
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
)
{
continue
;
}
}
}
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
to
find
match
for
language
code
|
%
s
|
\
n
"
langCode
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
langCode
dictList
DICT_COMPARE_DASHMATCH
tryDictList
)
;
}
}
RefPtr
<
EditorSpellCheck
>
self
=
this
;
RefPtr
<
DictionaryFetcher
>
fetcher
=
aFetcher
;
RefPtr
<
GenericPromise
>
promise
;
if
(
tryDictList
.
IsEmpty
(
)
)
{
promise
=
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_INVALID_ARG
__func__
)
;
}
else
{
promise
=
mSpellChecker
-
>
SetCurrentDictionaries
(
tryDictList
)
;
}
promise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
self
-
>
SetDictionarySucceeded
(
fetcher
)
;
}
[
prefDictionaries
=
prefDictionaries
.
Clone
(
)
dictList
=
dictList
.
Clone
(
)
self
fetcher
]
(
)
{
AutoTArray
<
nsCString
6
>
tryDictList
;
nsAutoCString
appLocaleStr
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsBCP47
(
appLocaleStr
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
locale
|
%
s
|
\
n
"
appLocaleStr
.
get
(
)
)
;
#
endif
self
-
>
BuildDictionaryList
(
appLocaleStr
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
nsTArray
<
nsCString
>
currentDictionaries
;
self
-
>
GetCurrentDictionaries
(
currentDictionaries
)
;
if
(
!
currentDictionaries
.
IsEmpty
(
)
&
&
tryDictList
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Retrieved
current
dict
|
%
s
|
\
n
"
DictionariesToString
(
currentDictionaries
)
.
Data
(
)
)
;
#
endif
self
-
>
EndUpdateDictionary
(
)
;
if
(
fetcher
-
>
mCallback
)
{
fetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
;
}
char
*
env_lang
=
getenv
(
"
LANG
"
)
;
if
(
env_lang
)
{
nsAutoCString
lang
(
env_lang
)
;
int32_t
dot_pos
=
lang
.
FindChar
(
'
.
'
)
;
if
(
dot_pos
!
=
-
1
)
{
lang
=
Substring
(
lang
0
dot_pos
)
;
}
int32_t
underScore
=
lang
.
FindChar
(
'
_
'
)
;
if
(
underScore
!
=
-
1
)
{
lang
.
Replace
(
underScore
1
'
-
'
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
LANG
from
environment
|
%
s
|
\
n
"
lang
.
get
(
)
)
;
#
endif
self
-
>
BuildDictionaryList
(
lang
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
}
}
if
(
!
dictList
.
IsEmpty
(
)
)
{
self
-
>
BuildDictionaryList
(
dictList
[
0
]
dictList
DICT_NORMAL_COMPARE
tryDictList
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
first
of
list
|
%
s
|
\
n
"
dictList
[
0
]
.
get
(
)
)
;
#
endif
}
if
(
!
prefDictionaries
.
IsEmpty
(
)
)
{
self
-
>
mSpellChecker
-
>
SetCurrentDictionaries
(
prefDictionaries
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
self
-
>
SetDictionarySucceeded
(
fetcher
)
;
}
[
tryDictList
=
tryDictList
.
Clone
(
)
self
fetcher
]
(
)
{
self
-
>
mSpellChecker
-
>
SetCurrentDictionaryFromList
(
tryDictList
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
self
-
>
SetDictionarySucceeded
(
fetcher
)
;
}
)
;
}
)
;
}
else
{
self
-
>
mSpellChecker
-
>
SetCurrentDictionaryFromList
(
tryDictList
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
self
-
>
SetDictionarySucceeded
(
fetcher
)
;
}
)
;
}
}
)
;
}
}
