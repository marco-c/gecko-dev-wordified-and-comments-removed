#
ifndef
mozilla_TextEditor_h
#
define
mozilla_TextEditor_h
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIDocumentEncoder
;
class
nsIOutputStream
;
class
nsIPrincipal
;
class
nsISelectionController
;
class
nsITransferable
;
namespace
mozilla
{
class
DeleteNodeTransaction
;
class
InsertNodeTransaction
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
Selection
;
}
class
TextEditor
final
:
public
EditorBase
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
TextEditor
EditorBase
)
TextEditor
(
)
;
static
TextEditor
*
GetFrom
(
nsIEditor
*
aEditor
)
{
return
aEditor
?
aEditor
-
>
GetAsTextEditor
(
)
:
nullptr
;
}
static
const
TextEditor
*
GetFrom
(
const
nsIEditor
*
aEditor
)
{
return
aEditor
?
aEditor
-
>
GetAsTextEditor
(
)
:
nullptr
;
}
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_IMETHOD
GetTextLength
(
int32_t
*
aCount
)
final
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
Paste
(
int32_t
aClipboardType
)
final
{
const
nsresult
rv
=
TextEditor
:
:
PasteAsAction
(
aClipboardType
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PasteAsAction
(
)
failed
"
)
;
return
rv
;
}
using
EditorBase
:
:
CanCopy
;
using
EditorBase
:
:
CanCut
;
using
EditorBase
:
:
CanPaste
;
MOZ_CAN_RUN_SCRIPT
nsresult
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
final
;
bool
IsEmpty
(
)
const
final
;
bool
CanPaste
(
int32_t
aClipboardType
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
bool
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
final
;
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
int32_t
MaxTextLength
(
)
const
{
return
mMaxTextLength
;
}
void
SetMaxTextLength
(
int32_t
aLength
)
{
mMaxTextLength
=
aLength
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsAction
(
const
nsAString
&
aString
AllowBeforeInputEventCancelable
aAllowBeforeInputEventCancelable
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
nsresult
ComputeTextValue
(
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
ComputeValueInternal
(
u
"
text
/
plain
"
_ns
aDocumentEncoderFlags
aOutputString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
bool
IsAllMasked
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
=
=
UINT32_MAX
&
&
mUnmaskedLength
=
=
0
;
}
uint32_t
UnmaskedStart
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
;
}
uint32_t
UnmaskedLength
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedLength
;
}
uint32_t
UnmaskedEnd
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
+
mUnmaskedLength
;
}
bool
IsMaskingPassword
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mIsMaskingPassword
;
}
static
char16_t
PasswordMask
(
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
final
;
using
EditorBase
:
:
RemoveAttributeOrEquivalent
;
using
EditorBase
:
:
SetAttributeOrEquivalent
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsSubAction
(
const
nsAString
&
aString
)
;
void
MaybeDoAutoPasswordMasking
(
)
{
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
MaskAllCharacters
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetUnmaskRange
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
false
false
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeAndNotify
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
true
false
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
MaskAllCharacters
(
)
{
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
false
true
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
MaskAllCharactersAndNotify
(
)
{
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
true
true
)
;
}
void
WillDeleteText
(
uint32_t
aCurrentLength
uint32_t
aRemoveStartOffset
uint32_t
aRemoveLength
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DidInsertText
(
uint32_t
aNewLength
uint32_t
aInsertedOffset
uint32_t
aInsertedLength
)
;
protected
:
EditActionResult
MaybeTruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
InsertLineFeedCharacterAtSelection
(
)
;
void
HandleNewLinesInStringForSingleLineEditor
(
nsString
&
aString
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertDroppedDataTransferAsAction
(
AutoEditActionDataSetter
&
aEditActionData
dom
:
:
DataTransfer
&
aDataTransfer
const
EditorDOMPoint
&
aDroppedAt
dom
:
:
Document
*
aSrcDocument
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
final
;
EditActionResult
ComputeValueFromTextNodeAndBRElement
(
nsAString
&
aValue
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
SetTextWithoutTransaction
(
const
nsAString
&
aValue
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
EnsureCaretNotAtEndOfTextNode
(
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnEndHandlingTopLevelEditSubAction
(
)
final
;
nsresult
HandleInlineSpellCheckAfterEdit
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
GetSpellCheckRestartPoint
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HandleInlineSpellCheck
(
GetSpellCheckRestartPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
spellcheck
"
)
;
ClearSpellCheckRestartPoint
(
)
;
return
rv
;
}
protected
:
virtual
~
TextEditor
(
)
;
bool
CanEchoPasswordNow
(
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
SelectEntireDocument
(
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertWithQuotationsAsSubAction
(
const
nsAString
&
aQuotedText
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextFromTransferable
(
nsITransferable
*
transferable
)
;
bool
IsCopyToClipboardAllowedInternal
(
)
const
final
;
already_AddRefed
<
Element
>
GetInputEventTargetElement
(
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeInternal
(
uint32_t
aStart
uint32_t
aLength
uint32_t
aTimeout
bool
aNotify
bool
aForceStartMasking
)
;
protected
:
nsCOMPtr
<
nsITimer
>
mMaskTimer
;
int32_t
mMaxTextLength
;
uint32_t
mUnmaskedStart
;
uint32_t
mUnmaskedLength
;
bool
mIsMaskingPassword
;
friend
class
DeleteNodeTransaction
;
friend
class
EditorBase
;
friend
class
InsertNodeTransaction
;
}
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTextEditor
(
)
)
;
return
static_cast
<
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTextEditor
(
)
)
;
return
static_cast
<
const
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
GetAsTextEditor
(
)
{
return
AsEditorBase
(
)
-
>
IsTextEditor
(
)
?
AsTextEditor
(
)
:
nullptr
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
GetAsTextEditor
(
)
const
{
return
AsEditorBase
(
)
-
>
IsTextEditor
(
)
?
AsTextEditor
(
)
:
nullptr
;
}
#
endif
