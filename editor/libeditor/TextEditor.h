#
ifndef
mozilla_TextEditor_h
#
define
mozilla_TextEditor_h
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
TextControlState
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIDocumentEncoder
;
class
nsIOutputStream
;
class
nsIPrincipal
;
class
nsISelectionController
;
class
nsITransferable
;
namespace
mozilla
{
namespace
dom
{
class
Selection
;
}
class
TextEditor
final
:
public
EditorBase
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
TextEditor
EditorBase
)
TextEditor
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
Init
(
Document
&
aDocument
Element
&
aAnonymousDivElement
nsISelectionController
&
aSelectionController
uint32_t
aFlags
UniquePtr
<
PasswordMaskData
>
&
&
aPasswordMaskData
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PostCreate
(
)
;
MOZ_CAN_RUN_SCRIPT
void
ReinitializeSelection
(
Element
&
aElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT_BOUNDARY
UniquePtr
<
PasswordMaskData
>
PreDestroy
(
)
;
static
TextEditor
*
GetFrom
(
nsIEditor
*
aEditor
)
{
return
aEditor
?
aEditor
-
>
GetAsTextEditor
(
)
:
nullptr
;
}
static
const
TextEditor
*
GetFrom
(
const
nsIEditor
*
aEditor
)
{
return
aEditor
?
aEditor
-
>
GetAsTextEditor
(
)
:
nullptr
;
}
static
void
MaskString
(
nsString
&
aString
const
dom
:
:
Text
&
aTextNode
uint32_t
aStartOffsetInString
uint32_t
aStartOffsetInText
)
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
EndOfDocument
(
)
final
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
InsertLineBreak
(
)
final
;
NS_IMETHOD
GetTextLength
(
uint32_t
*
aCount
)
final
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
Paste
(
int32_t
aClipboardType
)
final
{
const
nsresult
rv
=
TextEditor
:
:
PasteAsAction
(
aClipboardType
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PasteAsAction
(
)
failed
"
)
;
return
rv
;
}
using
EditorBase
:
:
CanCopy
;
using
EditorBase
:
:
CanCut
;
using
EditorBase
:
:
CanPaste
;
bool
IsEmpty
(
)
const
final
;
bool
CanPaste
(
int32_t
aClipboardType
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
bool
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
final
;
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnFocus
(
const
nsINode
&
aOriginalEventTargetNode
)
final
;
nsresult
OnBlur
(
const
dom
:
:
EventTarget
*
aEventTarget
)
final
;
int32_t
MaxTextLength
(
)
const
{
return
mMaxTextLength
;
}
void
SetMaxTextLength
(
int32_t
aLength
)
{
mMaxTextLength
=
aLength
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsAction
(
const
nsAString
&
aString
AllowBeforeInputEventCancelable
aAllowBeforeInputEventCancelable
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
final
;
nsresult
ComputeTextValue
(
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
ComputeValueInternal
(
u
"
text
/
plain
"
_ns
aDocumentEncoderFlags
aOutputString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
MOZ_ALWAYS_INLINE
bool
IsAllMasked
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
!
mPasswordMaskData
|
|
mPasswordMaskData
-
>
IsAllMasked
(
)
;
}
MOZ_ALWAYS_INLINE
uint32_t
UnmaskedStart
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mPasswordMaskData
?
mPasswordMaskData
-
>
mUnmaskedStart
:
UINT32_MAX
;
}
MOZ_ALWAYS_INLINE
uint32_t
UnmaskedLength
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mPasswordMaskData
?
mPasswordMaskData
-
>
mUnmaskedLength
:
0
;
}
MOZ_ALWAYS_INLINE
uint32_t
UnmaskedEnd
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mPasswordMaskData
?
mPasswordMaskData
-
>
UnmaskedEnd
(
)
:
UINT32_MAX
;
}
bool
IsMaskingPassword
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mPasswordMaskData
&
&
mPasswordMaskData
-
>
mIsMaskingPassword
;
}
static
char16_t
PasswordMask
(
)
;
bool
EchoingPasswordPrevented
(
)
const
{
return
mPasswordMaskData
&
&
mPasswordMaskData
-
>
mEchoingPasswordPrevented
;
}
void
PreventToEchoPassword
(
)
{
if
(
mPasswordMaskData
)
{
mPasswordMaskData
-
>
mEchoingPasswordPrevented
=
true
;
}
}
void
AllowToEchoPassword
(
)
{
if
(
mPasswordMaskData
)
{
mPasswordMaskData
-
>
mEchoingPasswordPrevented
=
false
;
}
}
dom
:
:
Text
*
GetTextNode
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
GetRoot
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
GetRoot
(
)
-
>
GetFirstChild
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
GetRoot
(
)
-
>
GetFirstChild
(
)
-
>
IsText
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
GetRoot
(
)
|
|
!
GetRoot
(
)
-
>
GetFirstChild
(
)
)
)
{
return
nullptr
;
}
return
GetRoot
(
)
-
>
GetFirstChild
(
)
-
>
GetAsText
(
)
;
}
const
dom
:
:
Text
*
GetTextNode
(
)
const
{
return
const_cast
<
TextEditor
*
>
(
this
)
-
>
GetTextNode
(
)
;
}
protected
:
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
final
;
using
EditorBase
:
:
RemoveAttributeOrEquivalent
;
using
EditorBase
:
:
SetAttributeOrEquivalent
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertLineBreakAsSubAction
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsSubAction
(
const
nsAString
&
aString
)
;
void
MaybeDoAutoPasswordMasking
(
)
{
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
MaskAllCharacters
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetUnmaskRange
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
false
false
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeAndNotify
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
true
false
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
MaskAllCharacters
(
)
{
if
(
!
mPasswordMaskData
)
{
return
NS_OK
;
}
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
false
true
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
MaskAllCharactersAndNotify
(
)
{
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
true
true
)
;
}
void
WillDeleteText
(
uint32_t
aCurrentLength
uint32_t
aRemoveStartOffset
uint32_t
aRemoveLength
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DidInsertText
(
uint32_t
aNewLength
uint32_t
aInsertedOffset
uint32_t
aInsertedLength
)
;
protected
:
Result
<
EditActionResult
nsresult
>
MaybeTruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
InsertLineFeedCharacterAtSelection
(
)
;
void
HandleNewLinesInStringForSingleLineEditor
(
nsString
&
aString
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
SelectionHandling
aSelectionHandling
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertDroppedDataTransferAsAction
(
AutoEditActionDataSetter
&
aEditActionData
dom
:
:
DataTransfer
&
aDataTransfer
const
EditorDOMPoint
&
aDroppedAt
nsIPrincipal
*
aSourcePrincipal
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
final
;
Result
<
EditActionResult
nsresult
>
ComputeValueFromTextNodeAndBRElement
(
nsAString
&
aValue
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
SetTextWithoutTransaction
(
const
nsAString
&
aValue
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
EnsureCaretNotAtEndOfTextNode
(
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnEndHandlingTopLevelEditSubAction
(
)
final
;
nsresult
HandleInlineSpellCheckAfterEdit
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
GetSpellCheckRestartPoint
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HandleInlineSpellCheck
(
GetSpellCheckRestartPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
spellcheck
"
)
;
ClearSpellCheckRestartPoint
(
)
;
return
rv
;
}
protected
:
virtual
~
TextEditor
(
)
;
bool
CanEchoPasswordNow
(
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InitEditorContentAndSelection
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
CollapseSelectionToEndOfTextNode
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SelectEntireDocument
(
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertWithQuotationsAsSubAction
(
const
nsAString
&
aQuotedText
)
final
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextFromTransferable
(
nsITransferable
*
transferable
)
;
bool
IsCopyToClipboardAllowedInternal
(
)
const
final
;
already_AddRefed
<
Element
>
GetInputEventTargetElement
(
)
const
final
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeInternal
(
uint32_t
aStart
uint32_t
aLength
uint32_t
aTimeout
bool
aNotify
bool
aForceStartMasking
)
;
MOZ_ALWAYS_INLINE
bool
HasAutoMaskingTimer
(
)
const
{
return
mPasswordMaskData
&
&
mPasswordMaskData
-
>
mTimer
;
}
protected
:
UniquePtr
<
PasswordMaskData
>
mPasswordMaskData
;
int32_t
mMaxTextLength
=
-
1
;
friend
class
DeleteNodeTransaction
;
friend
class
EditorBase
;
friend
class
InsertNodeTransaction
;
}
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTextEditor
(
)
)
;
return
static_cast
<
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTextEditor
(
)
)
;
return
static_cast
<
const
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
GetAsTextEditor
(
)
{
return
AsEditorBase
(
)
-
>
IsTextEditor
(
)
?
AsTextEditor
(
)
:
nullptr
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
GetAsTextEditor
(
)
const
{
return
AsEditorBase
(
)
-
>
IsTextEditor
(
)
?
AsTextEditor
(
)
:
nullptr
;
}
#
endif
