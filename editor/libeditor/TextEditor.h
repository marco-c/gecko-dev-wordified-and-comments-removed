#
ifndef
mozilla_TextEditor_h
#
define
mozilla_TextEditor_h
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIDocumentEncoder
;
class
nsIOutputStream
;
class
nsISelectionController
;
class
nsITransferable
;
namespace
mozilla
{
class
AutoEditInitRulesTrigger
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
DragEvent
;
class
Selection
;
}
class
TextEditor
:
public
EditorBase
public
nsIPlaintextEditor
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
TextEditor
EditorBase
)
TextEditor
(
)
;
NS_DECL_NSIPLAINTEXTEDITOR
NS_IMETHOD
GetDocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
override
;
NS_IMETHOD
DeleteSelection
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
override
;
NS_IMETHOD
SetDocumentCharacterSet
(
const
nsACString
&
characterSet
)
override
;
NS_IMETHOD
Undo
(
uint32_t
aCount
)
final
;
NS_IMETHOD
Redo
(
uint32_t
aCount
)
final
;
NS_IMETHOD
Cut
(
)
override
;
NS_IMETHOD
CanCut
(
bool
*
aCanCut
)
override
;
NS_IMETHOD
Copy
(
)
override
;
NS_IMETHOD
CanCopy
(
bool
*
aCanCopy
)
override
;
NS_IMETHOD
CanDelete
(
bool
*
aCanDelete
)
override
;
NS_IMETHOD
CanPaste
(
int32_t
aSelectionType
bool
*
aCanPaste
)
override
;
NS_IMETHOD
PasteTransferable
(
nsITransferable
*
aTransferable
)
override
;
NS_IMETHOD
OutputToString
(
const
nsAString
&
aFormatType
uint32_t
aFlags
nsAString
&
aOutputString
)
override
;
virtual
bool
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
;
virtual
nsresult
Init
(
nsIDocument
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aValue
)
override
;
nsresult
IsEmpty
(
bool
*
aIsEmpty
)
const
;
bool
IsEmpty
(
)
const
{
bool
isEmpty
=
false
;
nsresult
rv
=
IsEmpty
(
&
isEmpty
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Checking
whether
the
editor
is
empty
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
isEmpty
;
}
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
override
;
virtual
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
override
;
nsresult
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
)
;
nsresult
InsertTextAsAction
(
const
nsAString
&
aStringToInsert
)
;
virtual
nsresult
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
)
;
nsresult
DeleteSelectionAsAction
(
EDirection
aDirection
EStripWrappers
aStripWrappers
)
;
int32_t
MaxTextLength
(
)
const
{
return
mMaxTextLength
;
}
void
SetMaxTextLength
(
int32_t
aLength
)
{
mMaxTextLength
=
aLength
;
}
nsresult
SetText
(
const
nsAString
&
aString
)
;
nsresult
ReplaceTextAsAction
(
const
nsAString
&
aString
nsRange
*
aReplaceRange
=
nullptr
)
;
nsresult
OnInputParagraphSeparator
(
)
;
nsresult
OnCompositionStart
(
WidgetCompositionEvent
&
aCompositionStartEvent
)
;
nsresult
OnCompositionChange
(
WidgetCompositionEvent
&
aCompositionChangeEvent
)
;
void
OnCompositionEnd
(
WidgetCompositionEvent
&
aCompositionEndEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnDrop
(
dom
:
:
DragEvent
*
aDropEvent
)
;
nsresult
ComputeTextValue
(
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
{
return
ComputeValueInternal
(
NS_LITERAL_STRING
(
"
text
/
plain
"
)
aDocumentEncoderFlags
aOutputString
)
;
}
protected
:
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
override
;
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
override
;
using
EditorBase
:
:
RemoveAttributeOrEquivalent
;
using
EditorBase
:
:
SetAttributeOrEquivalent
;
nsresult
InsertTextAsSubAction
(
const
nsAString
&
aStringToInsert
)
;
nsresult
DeleteSelectionAsSubAction
(
EDirection
aDirection
EStripWrappers
aStripWrappers
)
;
virtual
nsresult
DeleteSelectionWithTransaction
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
;
nsresult
SetTextAsSubAction
(
const
nsAString
&
aString
)
;
nsresult
ReplaceSelectionAsSubAction
(
const
nsAString
&
aString
)
;
template
<
typename
PT
typename
CT
>
already_AddRefed
<
Element
>
InsertBrElementWithTransaction
(
Selection
&
aSelection
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
EDirection
aSelect
=
eNone
)
;
nsresult
ExtendSelectionForDelete
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
*
aAction
)
;
static
void
GetDefaultEditorPrefs
(
int32_t
&
aNewLineHandling
int32_t
&
aCaretStyle
)
;
protected
:
virtual
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
override
;
virtual
void
OnEndHandlingTopLevelEditSubAction
(
)
override
;
void
BeginEditorInit
(
)
;
nsresult
EndEditorInit
(
)
;
protected
:
virtual
~
TextEditor
(
)
;
int32_t
WrapWidth
(
)
const
{
return
mWrapColumn
;
}
virtual
nsresult
SelectEntireDocument
(
Selection
*
aSelection
)
override
;
nsresult
OnInputText
(
const
nsAString
&
aStringToInsert
)
;
nsresult
InsertParagraphSeparatorAsAction
(
)
;
nsresult
InsertTextAt
(
const
nsAString
&
aStringToInsert
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
;
virtual
nsresult
InsertFromDataTransfer
(
dom
:
:
DataTransfer
*
aDataTransfer
int32_t
aIndex
nsIDocument
*
aSourceDoc
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
override
;
nsresult
InsertWithQuotationsAsSubAction
(
const
nsAString
&
aQuotedText
)
;
bool
IsSafeToInsertData
(
nsIDocument
*
aSourceDoc
)
;
virtual
nsresult
InitRules
(
)
;
already_AddRefed
<
nsIDocumentEncoder
>
GetAndInitDocEncoder
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
const
nsACString
&
aCharset
)
const
;
nsresult
ComputeValueInternal
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
;
virtual
nsresult
PrepareTransferable
(
nsITransferable
*
*
transferable
)
;
nsresult
InsertTextFromTransferable
(
nsITransferable
*
transferable
)
;
already_AddRefed
<
Element
>
DeleteSelectionAndCreateElement
(
nsAtom
&
aTag
)
;
nsresult
DeleteSelectionAndPrepareToCreateNode
(
)
;
nsresult
SharedOutputString
(
uint32_t
aFlags
bool
*
aIsCollapsed
nsAString
&
aResult
)
;
enum
PasswordFieldAllowed
{
ePasswordFieldAllowed
ePasswordFieldNotAllowed
}
;
bool
CanCutOrCopy
(
PasswordFieldAllowed
aPasswordFieldAllowed
)
;
bool
FireClipboardEvent
(
EventMessage
aEventMessage
int32_t
aSelectionType
bool
*
aActionTaken
=
nullptr
)
;
bool
UpdateMetaCharset
(
nsIDocument
&
aDocument
const
nsACString
&
aCharacterSet
)
;
bool
EnsureComposition
(
WidgetCompositionEvent
&
aCompositionEvent
)
;
virtual
already_AddRefed
<
nsIContent
>
GetInputEventTargetContent
(
)
override
;
protected
:
mutable
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedDocumentEncoder
;
mutable
nsString
mCachedDocumentEncoderType
;
int32_t
mWrapColumn
;
int32_t
mMaxTextLength
;
int32_t
mInitTriggerCounter
;
int32_t
mNewlineHandling
;
int32_t
mCaretStyle
;
friend
class
AutoEditInitRulesTrigger
;
friend
class
TextEditRules
;
}
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
{
return
static_cast
<
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
const
{
return
static_cast
<
const
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
#
endif
