#
ifndef
mozilla_TextEditor_h
#
define
mozilla_TextEditor_h
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nscore
.
h
"
class
nsIContent
;
class
nsIDocumentEncoder
;
class
nsIOutputStream
;
class
nsIPrincipal
;
class
nsISelectionController
;
class
nsITransferable
;
namespace
mozilla
{
class
DeleteNodeTransaction
;
class
InsertNodeTransaction
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
DragEvent
;
class
Selection
;
}
class
TextEditor
:
public
EditorBase
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
TextEditor
EditorBase
)
TextEditor
(
)
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_IMETHOD
GetDocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
SetDocumentCharacterSet
(
const
nsACString
&
characterSet
)
override
;
NS_IMETHOD
GetTextLength
(
int32_t
*
aCount
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
UndoAsAction
(
uint32_t
aCount
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RedoAsAction
(
uint32_t
aCount
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
CutAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
bool
AreClipboardCommandsUnconditionallyEnabled
(
)
const
;
bool
IsCutCommandEnabled
(
)
const
;
NS_IMETHOD
Copy
(
)
override
;
bool
IsCopyCommandEnabled
(
)
const
;
bool
IsCopyToClipboardAllowed
(
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
false
;
}
return
IsCopyToClipboardAllowedInternal
(
)
;
}
bool
CanDeleteSelection
(
)
const
;
virtual
bool
CanPaste
(
int32_t
aClipboardType
)
const
;
using
EditorBase
:
:
CanCopy
;
using
EditorBase
:
:
CanCut
;
using
EditorBase
:
:
CanPaste
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
NS_IMETHOD
OutputToString
(
const
nsAString
&
aFormatType
uint32_t
aFlags
nsAString
&
aOutputString
)
override
;
virtual
bool
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aValue
)
override
;
virtual
bool
IsEmpty
(
)
const
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
override
;
virtual
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
const
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
int32_t
MaxTextLength
(
)
const
{
return
mMaxTextLength
;
}
void
SetMaxTextLength
(
int32_t
aLength
)
{
mMaxTextLength
=
aLength
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsAction
(
const
nsAString
&
aString
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ReplaceTextAsAction
(
const
nsAString
&
aString
nsRange
*
aReplaceRange
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
nsresult
OnCompositionStart
(
WidgetCompositionEvent
&
aCompositionStartEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnCompositionChange
(
WidgetCompositionEvent
&
aCompositionChangeEvent
)
;
MOZ_CAN_RUN_SCRIPT
void
OnCompositionEnd
(
WidgetCompositionEvent
&
aCompositionEndEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnDrop
(
dom
:
:
DragEvent
*
aDropEvent
)
;
nsresult
ComputeTextValue
(
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
ComputeValueInternal
(
u
"
text
/
plain
"
_ns
aDocumentEncoderFlags
aOutputString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
bool
IsAllMasked
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
=
=
UINT32_MAX
&
&
mUnmaskedLength
=
=
0
;
}
uint32_t
UnmaskedStart
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
;
}
uint32_t
UnmaskedLength
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedLength
;
}
uint32_t
UnmaskedEnd
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mUnmaskedStart
+
mUnmaskedLength
;
}
bool
IsMaskingPassword
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mIsMaskingPassword
;
}
static
char16_t
PasswordMask
(
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
override
;
using
EditorBase
:
:
RemoveAttributeOrEquivalent
;
using
EditorBase
:
:
SetAttributeOrEquivalent
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectionByDragAsAction
(
bool
aDispatchInputEvent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextAsSubAction
(
const
nsAString
&
aString
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ReplaceSelectionAsSubAction
(
const
nsAString
&
aString
)
;
void
MaybeDoAutoPasswordMasking
(
)
{
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
MaskAllCharacters
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetUnmaskRange
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
false
false
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeAndNotify
(
uint32_t
aStart
uint32_t
aLength
=
UINT32_MAX
uint32_t
aTimeout
=
0
)
{
return
SetUnmaskRangeInternal
(
aStart
aLength
aTimeout
true
false
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
MaskAllCharacters
(
)
{
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
false
true
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
MaskAllCharactersAndNotify
(
)
{
return
SetUnmaskRangeInternal
(
UINT32_MAX
0
0
true
true
)
;
}
void
WillDeleteText
(
uint32_t
aCurrentLength
uint32_t
aRemoveStartOffset
uint32_t
aRemoveLength
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DidInsertText
(
uint32_t
aNewLength
uint32_t
aInsertedOffset
uint32_t
aInsertedLength
)
;
protected
:
EditActionResult
MaybeTruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
InsertLineFeedCharacterAtSelection
(
)
;
void
HandleNewLinesInStringForSingleLineEditor
(
nsString
&
aString
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
virtual
EditActionResult
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
override
;
EditActionResult
ComputeValueFromTextNodeAndPaddingBRElement
(
nsAString
&
aValue
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
SetTextWithoutTransaction
(
const
nsAString
&
aValue
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
EnsurePaddingBRElementInMultilineEditor
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
EnsureCaretNotAtEndOfTextNode
(
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
virtual
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
OnEndHandlingTopLevelEditSubAction
(
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
EnsurePaddingBRElementForEmptyEditor
(
)
;
nsresult
HandleInlineSpellCheckAfterEdit
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
GetSpellCheckRestartPoint
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HandleInlineSpellCheck
(
GetSpellCheckRestartPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
spellcheck
"
)
;
ClearSpellCheckRestartPoint
(
)
;
return
rv
;
}
protected
:
virtual
~
TextEditor
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InitEditorContentAndSelection
(
)
;
bool
CanEchoPasswordNow
(
)
const
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SelectEntireDocument
(
)
override
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
OnInputText
(
const
nsAString
&
aStringToInsert
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PrepareToInsertContent
(
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextAt
(
const
nsAString
&
aStringToInsert
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InsertWithQuotationsAsSubAction
(
const
nsAString
&
aQuotedText
)
;
bool
IsSafeToInsertData
(
const
Document
*
aSourceDoc
)
const
;
already_AddRefed
<
nsIDocumentEncoder
>
GetAndInitDocEncoder
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
const
nsACString
&
aCharset
)
const
;
nsresult
ComputeValueInternal
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
;
virtual
nsresult
PrepareTransferable
(
nsITransferable
*
*
transferable
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextFromTransferable
(
nsITransferable
*
transferable
)
;
nsresult
SharedOutputString
(
uint32_t
aFlags
bool
*
aIsCollapsed
nsAString
&
aResult
)
const
;
bool
IsCopyToClipboardAllowedInternal
(
)
const
;
bool
FireClipboardEvent
(
EventMessage
aEventMessage
int32_t
aSelectionType
bool
*
aActionTaken
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
bool
UpdateMetaCharset
(
Document
&
aDocument
const
nsACString
&
aCharacterSet
)
;
bool
EnsureComposition
(
WidgetCompositionEvent
&
aCompositionEvent
)
;
virtual
already_AddRefed
<
Element
>
GetInputEventTargetElement
(
)
const
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetUnmaskRangeInternal
(
uint32_t
aStart
uint32_t
aLength
uint32_t
aTimeout
bool
aNotify
bool
aForceStartMasking
)
;
protected
:
mutable
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedDocumentEncoder
;
nsCOMPtr
<
nsITimer
>
mMaskTimer
;
mutable
nsString
mCachedDocumentEncoderType
;
int32_t
mMaxTextLength
;
uint32_t
mUnmaskedStart
;
uint32_t
mUnmaskedLength
;
bool
mIsMaskingPassword
;
friend
class
DeleteNodeTransaction
;
friend
class
EditorBase
;
friend
class
InsertNodeTransaction
;
}
;
}
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
{
return
static_cast
<
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
const
mozilla
:
:
TextEditor
*
nsIEditor
:
:
AsTextEditor
(
)
const
{
return
static_cast
<
const
mozilla
:
:
TextEditor
*
>
(
this
)
;
}
#
endif
