#
ifndef
mozilla_SelectionState_h
#
define
mozilla_SelectionState_h
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsCycleCollectionTraversalCallback
;
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
class
Selection
;
class
Text
;
}
struct
RangeItem
final
{
RangeItem
(
)
:
mStartOffset
(
0
)
mEndOffset
(
0
)
{
}
private
:
~
RangeItem
(
)
=
default
;
public
:
void
StoreRange
(
const
nsRange
&
aRange
)
;
void
StoreRange
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aEndPoint
.
IsSet
(
)
)
;
mStartContainer
=
aStartPoint
.
GetContainer
(
)
;
mStartOffset
=
aStartPoint
.
Offset
(
)
;
mEndContainer
=
aEndPoint
.
GetContainer
(
)
;
mEndOffset
=
aEndPoint
.
Offset
(
)
;
}
void
Clear
(
)
{
mStartContainer
=
mEndContainer
=
nullptr
;
mStartOffset
=
mEndOffset
=
0
;
}
already_AddRefed
<
nsRange
>
GetRange
(
)
const
;
[
[
nodiscard
]
]
nsINode
*
GetRoot
(
)
const
;
[
[
nodiscard
]
]
bool
Collapsed
(
)
const
{
return
mStartContainer
=
=
mEndContainer
&
&
mStartOffset
=
=
mEndOffset
;
}
[
[
nodiscard
]
]
bool
IsPositioned
(
)
const
{
return
mStartContainer
&
&
mEndContainer
;
}
[
[
nodiscard
]
]
bool
Equals
(
const
RangeItem
&
aOther
)
const
{
return
mStartContainer
=
=
aOther
.
mStartContainer
&
&
mEndContainer
=
=
aOther
.
mEndContainer
&
&
mStartOffset
=
=
aOther
.
mStartOffset
&
&
mEndOffset
=
=
aOther
.
mEndOffset
;
}
template
<
typename
EditorDOMPointType
=
EditorDOMPoint
>
EditorDOMPointType
StartPoint
(
)
const
{
return
EditorDOMPointType
(
mStartContainer
mStartOffset
)
;
}
template
<
typename
EditorDOMPointType
=
EditorDOMPoint
>
EditorDOMPointType
EndPoint
(
)
const
{
return
EditorDOMPointType
(
mEndContainer
mEndOffset
)
;
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
RangeItem
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
RangeItem
)
nsCOMPtr
<
nsINode
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
uint32_t
mStartOffset
;
uint32_t
mEndOffset
;
}
;
class
SelectionState
final
{
public
:
SelectionState
(
)
=
default
;
explicit
SelectionState
(
const
AutoClonedSelectionRangeArray
&
aRanges
)
;
[
[
nodiscard
]
]
bool
IsCollapsed
(
)
const
{
if
(
mArray
.
Length
(
)
!
=
1
)
{
return
false
;
}
return
mArray
[
0
]
-
>
Collapsed
(
)
;
}
void
RemoveAllRanges
(
)
{
mArray
.
Clear
(
)
;
mDirection
=
eDirNext
;
}
[
[
nodiscard
]
]
uint32_t
RangeCount
(
)
const
{
return
mArray
.
Length
(
)
;
}
void
SaveSelection
(
dom
:
:
Selection
&
aSelection
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RestoreSelection
(
dom
:
:
Selection
&
aSelection
)
;
void
ApplyTo
(
AutoClonedSelectionRangeArray
&
aRanges
)
;
[
[
nodiscard
]
]
bool
HasOnlyCollapsedRange
(
)
const
{
if
(
mArray
.
Length
(
)
!
=
1
)
{
return
false
;
}
if
(
!
mArray
[
0
]
-
>
IsPositioned
(
)
|
|
!
mArray
[
0
]
-
>
Collapsed
(
)
)
{
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
Equals
(
const
SelectionState
&
aOther
)
const
;
[
[
nodiscard
]
]
nsINode
*
GetCommonRootNode
(
)
const
{
nsINode
*
rootNode
=
nullptr
;
for
(
const
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
nsINode
*
newRootNode
=
rangeItem
-
>
GetRoot
(
)
;
if
(
!
newRootNode
|
|
(
rootNode
&
&
rootNode
!
=
newRootNode
)
)
{
return
nullptr
;
}
rootNode
=
newRootNode
;
}
return
rootNode
;
}
private
:
CopyableAutoTArray
<
RefPtr
<
RangeItem
>
1
>
mArray
;
nsDirection
mDirection
=
eDirNext
;
friend
class
RangeUpdater
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
SelectionState
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
SelectionState
&
)
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
SelectionState
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mArray
aName
aFlags
)
;
}
inline
void
ImplCycleCollectionUnlink
(
SelectionState
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mArray
)
;
}
class
MOZ_STACK_CLASS
RangeUpdater
final
{
public
:
RangeUpdater
(
)
;
void
RegisterRangeItem
(
RangeItem
&
aRangeItem
)
;
void
DropRangeItem
(
RangeItem
&
aRangeItem
)
;
void
RegisterSelectionState
(
SelectionState
&
aSelectionState
)
;
void
DropSelectionState
(
SelectionState
&
aSelectionState
)
;
template
<
typename
PT
typename
CT
>
nsresult
SelAdjCreateNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
;
template
<
typename
PT
typename
CT
>
nsresult
SelAdjInsertNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
;
void
SelAdjDeleteNode
(
nsINode
&
aNode
)
;
nsresult
SelAdjSplitNode
(
nsIContent
&
aOriginalContent
uint32_t
aSplitOffset
nsIContent
&
aNewContent
)
;
nsresult
SelAdjJoinNodes
(
const
EditorRawDOMPoint
&
aStartOfRightContent
const
nsIContent
&
aRemovedContent
const
EditorDOMPoint
&
aOldPointAtRightContent
)
;
void
SelAdjInsertText
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aInsertedLength
)
;
void
SelAdjDeleteText
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aDeletedLength
)
;
void
SelAdjReplaceText
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aReplacedLength
uint32_t
aInsertedLength
)
;
void
WillReplaceContainer
(
)
{
NS_WARNING_ASSERTION
(
!
mLocked
"
Has
already
been
locked
"
)
;
mLocked
=
true
;
}
void
DidReplaceContainer
(
const
dom
:
:
Element
&
aRemovedElement
dom
:
:
Element
&
aInsertedElement
)
;
void
WillRemoveContainer
(
)
{
NS_WARNING_ASSERTION
(
!
mLocked
"
Has
already
been
locked
"
)
;
mLocked
=
true
;
}
void
DidRemoveContainer
(
const
dom
:
:
Element
&
aRemovedElement
nsINode
&
aRemovedElementContainerNode
uint32_t
aOldOffsetOfRemovedElement
uint32_t
aOldChildCountOfRemovedElement
)
;
void
WillInsertContainer
(
)
{
NS_WARNING_ASSERTION
(
!
mLocked
"
Has
already
been
locked
"
)
;
mLocked
=
true
;
}
void
DidInsertContainer
(
)
{
NS_WARNING_ASSERTION
(
mLocked
"
Not
locked
"
)
;
mLocked
=
false
;
}
template
<
typename
PT
typename
CT
>
struct
SimpleEditorDOMPointBase
{
SimpleEditorDOMPointBase
(
)
=
default
;
SimpleEditorDOMPointBase
(
const
nsINode
*
aContainer
const
nsIContent
*
aChild
uint32_t
aOffset
)
:
mContainer
(
const_cast
<
nsINode
*
>
(
aContainer
)
)
mChild
(
const_cast
<
nsIContent
*
>
(
aChild
)
)
mOffset
(
Some
(
aOffset
)
)
{
}
SimpleEditorDOMPointBase
(
const
nsIContent
*
aChild
uint32_t
aOffset
)
:
mContainer
(
aChild
-
>
GetParentNode
(
)
)
mChild
(
const_cast
<
nsIContent
*
>
(
aChild
)
)
mOffset
(
Some
(
aOffset
)
)
{
}
SimpleEditorDOMPointBase
(
const
nsINode
*
aContainer
const
nsIContent
*
aChild
)
:
mContainer
(
const_cast
<
nsINode
*
>
(
aContainer
)
)
mChild
(
const_cast
<
nsIContent
*
>
(
aChild
)
)
{
}
explicit
SimpleEditorDOMPointBase
(
const
nsIContent
*
aChild
)
:
mContainer
(
aChild
-
>
GetParentNode
(
)
)
mChild
(
const_cast
<
nsIContent
*
>
(
aChild
)
)
{
}
uint32_t
Offset
(
)
const
{
if
(
!
mOffset
&
&
mContainer
)
{
mOffset
=
mContainer
-
>
ComputeIndexOf
(
mChild
)
;
}
return
mOffset
.
valueOr
(
0
)
;
}
nsIContent
*
GetNextSiblingOfChild
(
)
const
{
return
mChild
-
>
GetNextSibling
(
)
;
}
PT
mContainer
;
CT
mChild
;
mutable
Maybe
<
uint32_t
>
mOffset
;
}
;
using
SimpleEditorDOMPoint
=
SimpleEditorDOMPointBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
;
using
SimpleEditorRawDOMPoint
=
SimpleEditorDOMPointBase
<
nsINode
*
nsIContent
*
>
;
void
DidMoveNodes
(
const
nsTArray
<
SimpleEditorDOMPoint
>
&
aOldPoints
const
SimpleEditorDOMPoint
&
aExpectedDestination
const
nsTArray
<
SimpleEditorDOMPoint
>
&
aNewPoints
)
;
private
:
nsTArray
<
RefPtr
<
RangeItem
>
>
mArray
;
bool
mLocked
;
}
;
class
MOZ_STACK_CLASS
AutoTrackDOMPoint
final
{
public
:
AutoTrackDOMPoint
(
)
=
delete
;
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
CaretPoint
*
aCaretPoint
)
;
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
nsCOMPtr
<
nsINode
>
*
aNode
uint32_t
*
aOffset
)
:
mRangeUpdater
(
aRangeUpdater
)
mNode
(
aNode
)
mOffset
(
aOffset
)
mRangeItem
(
do_AddRef
(
new
RangeItem
(
)
)
)
mWasConnected
(
aNode
&
&
(
*
aNode
)
-
>
IsInComposedDoc
(
)
)
{
mRangeItem
-
>
mStartContainer
=
*
mNode
;
mRangeItem
-
>
mEndContainer
=
*
mNode
;
mRangeItem
-
>
mStartOffset
=
*
mOffset
;
mRangeItem
-
>
mEndOffset
=
*
mOffset
;
mDocument
=
(
*
mNode
)
-
>
OwnerDoc
(
)
;
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
}
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
EditorDOMPoint
*
aPoint
)
:
mRangeUpdater
(
aRangeUpdater
)
mNode
(
nullptr
)
mOffset
(
nullptr
)
mPoint
(
Some
(
aPoint
-
>
IsSet
(
)
?
aPoint
:
nullptr
)
)
mRangeItem
(
do_AddRef
(
new
RangeItem
(
)
)
)
mWasConnected
(
aPoint
&
&
aPoint
-
>
IsInComposedDoc
(
)
)
{
if
(
!
aPoint
-
>
IsSet
(
)
)
{
mIsTracking
=
false
;
return
;
}
mRangeItem
-
>
mStartContainer
=
aPoint
-
>
GetContainer
(
)
;
mRangeItem
-
>
mEndContainer
=
aPoint
-
>
GetContainer
(
)
;
mRangeItem
-
>
mStartOffset
=
aPoint
-
>
Offset
(
)
;
mRangeItem
-
>
mEndOffset
=
aPoint
-
>
Offset
(
)
;
mDocument
=
aPoint
-
>
GetContainer
(
)
-
>
OwnerDoc
(
)
;
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
}
~
AutoTrackDOMPoint
(
)
{
FlushAndStopTracking
(
)
;
}
void
FlushAndStopTracking
(
)
{
if
(
!
mIsTracking
)
{
return
;
}
mIsTracking
=
false
;
if
(
mPoint
.
isSome
(
)
)
{
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
if
(
NS_WARN_IF
(
!
mRangeItem
-
>
mStartContainer
)
)
{
mPoint
.
ref
(
)
-
>
Clear
(
)
;
return
;
}
if
(
NS_WARN_IF
(
mWasConnected
&
&
!
mRangeItem
-
>
mStartContainer
-
>
IsInComposedDoc
(
)
)
|
|
NS_WARN_IF
(
mRangeItem
-
>
mStartContainer
-
>
OwnerDoc
(
)
!
=
mDocument
)
)
{
mPoint
.
ref
(
)
-
>
Clear
(
)
;
return
;
}
if
(
NS_WARN_IF
(
mRangeItem
-
>
mStartContainer
-
>
Length
(
)
<
mRangeItem
-
>
mStartOffset
)
)
{
mPoint
.
ref
(
)
-
>
SetToEndOf
(
mRangeItem
-
>
mStartContainer
)
;
return
;
}
mPoint
.
ref
(
)
-
>
Set
(
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
)
;
return
;
}
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
*
mNode
=
mRangeItem
-
>
mStartContainer
;
*
mOffset
=
mRangeItem
-
>
mStartOffset
;
if
(
!
(
*
mNode
)
)
{
return
;
}
if
(
NS_WARN_IF
(
mWasConnected
&
&
!
(
*
mNode
)
-
>
IsInComposedDoc
(
)
)
|
|
NS_WARN_IF
(
(
*
mNode
)
-
>
OwnerDoc
(
)
!
=
mDocument
)
)
{
*
mNode
=
nullptr
;
*
mOffset
=
0
;
}
}
void
StopTracking
(
)
{
mIsTracking
=
false
;
}
private
:
RangeUpdater
&
mRangeUpdater
;
nsCOMPtr
<
nsINode
>
*
mNode
;
uint32_t
*
mOffset
;
Maybe
<
EditorDOMPoint
*
>
mPoint
;
OwningNonNull
<
RangeItem
>
mRangeItem
;
RefPtr
<
dom
:
:
Document
>
mDocument
;
bool
mIsTracking
=
true
;
bool
mWasConnected
;
}
;
class
MOZ_STACK_CLASS
AutoTrackDOMRange
final
{
public
:
AutoTrackDOMRange
(
)
=
delete
;
AutoTrackDOMRange
(
RangeUpdater
&
aRangeUpdater
EditorDOMPoint
*
aStartPoint
EditorDOMPoint
*
aEndPoint
)
:
mRangeRefPtr
(
nullptr
)
mRangeOwningNonNull
(
nullptr
)
{
mStartPointTracker
.
emplace
(
aRangeUpdater
aStartPoint
)
;
mEndPointTracker
.
emplace
(
aRangeUpdater
aEndPoint
)
;
}
AutoTrackDOMRange
(
RangeUpdater
&
aRangeUpdater
EditorDOMRange
*
aRange
)
:
mRangeRefPtr
(
nullptr
)
mRangeOwningNonNull
(
nullptr
)
{
mStartPointTracker
.
emplace
(
aRangeUpdater
const_cast
<
EditorDOMPoint
*
>
(
&
aRange
-
>
StartRef
(
)
)
)
;
mEndPointTracker
.
emplace
(
aRangeUpdater
const_cast
<
EditorDOMPoint
*
>
(
&
aRange
-
>
EndRef
(
)
)
)
;
}
AutoTrackDOMRange
(
RangeUpdater
&
aRangeUpdater
const
RefPtr
<
nsRange
>
*
aRange
)
:
mStartPoint
(
(
*
aRange
)
-
>
StartRef
(
)
)
mEndPoint
(
(
*
aRange
)
-
>
EndRef
(
)
)
mRangeRefPtr
(
aRange
)
mRangeOwningNonNull
(
nullptr
)
{
mStartPointTracker
.
emplace
(
aRangeUpdater
&
mStartPoint
)
;
mEndPointTracker
.
emplace
(
aRangeUpdater
&
mEndPoint
)
;
}
AutoTrackDOMRange
(
RangeUpdater
&
aRangeUpdater
const
OwningNonNull
<
nsRange
>
*
aRange
)
:
mStartPoint
(
(
*
aRange
)
-
>
StartRef
(
)
)
mEndPoint
(
(
*
aRange
)
-
>
EndRef
(
)
)
mRangeRefPtr
(
nullptr
)
mRangeOwningNonNull
(
aRange
)
{
mStartPointTracker
.
emplace
(
aRangeUpdater
&
mStartPoint
)
;
mEndPointTracker
.
emplace
(
aRangeUpdater
&
mEndPoint
)
;
}
~
AutoTrackDOMRange
(
)
{
FlushAndStopTracking
(
)
;
}
void
FlushAndStopTracking
(
)
{
if
(
!
mStartPointTracker
&
&
!
mEndPointTracker
)
{
return
;
}
mStartPointTracker
.
reset
(
)
;
mEndPointTracker
.
reset
(
)
;
if
(
!
mRangeRefPtr
&
&
!
mRangeOwningNonNull
)
{
return
;
}
if
(
mRangeRefPtr
)
{
if
(
!
mStartPoint
.
IsSet
(
)
|
|
!
mEndPoint
.
IsSet
(
)
)
{
(
*
mRangeRefPtr
)
-
>
Reset
(
)
;
return
;
}
(
*
mRangeRefPtr
)
-
>
SetStartAndEnd
(
mStartPoint
.
ToRawRangeBoundary
(
)
mEndPoint
.
ToRawRangeBoundary
(
)
)
;
return
;
}
if
(
mRangeOwningNonNull
)
{
if
(
!
mStartPoint
.
IsSet
(
)
|
|
!
mEndPoint
.
IsSet
(
)
)
{
(
*
mRangeOwningNonNull
)
-
>
Reset
(
)
;
return
;
}
(
*
mRangeOwningNonNull
)
-
>
SetStartAndEnd
(
mStartPoint
.
ToRawRangeBoundary
(
)
mEndPoint
.
ToRawRangeBoundary
(
)
)
;
return
;
}
}
void
StopTracking
(
)
{
if
(
mStartPointTracker
)
{
mStartPointTracker
-
>
StopTracking
(
)
;
}
if
(
mEndPointTracker
)
{
mEndPointTracker
-
>
StopTracking
(
)
;
}
}
void
StopTrackingStartBoundary
(
)
{
MOZ_ASSERT
(
!
mRangeRefPtr
"
StopTrackingStartBoundary
(
)
is
not
available
when
tracking
"
"
RefPtr
<
nsRange
>
"
)
;
MOZ_ASSERT
(
!
mRangeOwningNonNull
"
StopTrackingStartBoundary
(
)
is
not
available
when
tracking
"
"
OwningNonNull
<
nsRange
>
"
)
;
if
(
!
mStartPointTracker
)
{
return
;
}
mStartPointTracker
-
>
StopTracking
(
)
;
}
void
StopTrackingEndBoundary
(
)
{
MOZ_ASSERT
(
!
mRangeRefPtr
"
StopTrackingEndBoundary
(
)
is
not
available
when
tracking
"
"
RefPtr
<
nsRange
>
"
)
;
MOZ_ASSERT
(
!
mRangeOwningNonNull
"
StopTrackingEndBoundary
(
)
is
not
available
when
tracking
"
"
OwningNonNull
<
nsRange
>
"
)
;
if
(
!
mEndPointTracker
)
{
return
;
}
mEndPointTracker
-
>
StopTracking
(
)
;
}
private
:
Maybe
<
AutoTrackDOMPoint
>
mStartPointTracker
;
Maybe
<
AutoTrackDOMPoint
>
mEndPointTracker
;
EditorDOMPoint
mStartPoint
;
EditorDOMPoint
mEndPoint
;
const
RefPtr
<
nsRange
>
*
mRangeRefPtr
;
const
OwningNonNull
<
nsRange
>
*
mRangeOwningNonNull
;
}
;
class
MOZ_STACK_CLASS
AutoTrackDOMMoveNodeResult
final
{
public
:
AutoTrackDOMMoveNodeResult
(
)
=
delete
;
AutoTrackDOMMoveNodeResult
(
RangeUpdater
&
aRangeUpdater
MoveNodeResult
*
aMoveNodeResult
)
;
void
FlushAndStopTracking
(
)
{
mTrackCaretPoint
.
FlushAndStopTracking
(
)
;
mTrackNextInsertionPoint
.
FlushAndStopTracking
(
)
;
mTrackMovedContentRange
.
FlushAndStopTracking
(
)
;
}
void
StopTracking
(
)
{
mTrackCaretPoint
.
StopTracking
(
)
;
mTrackNextInsertionPoint
.
StopTracking
(
)
;
mTrackMovedContentRange
.
StopTracking
(
)
;
}
private
:
AutoTrackDOMPoint
mTrackCaretPoint
;
AutoTrackDOMPoint
mTrackNextInsertionPoint
;
AutoTrackDOMRange
mTrackMovedContentRange
;
}
;
class
MOZ_STACK_CLASS
AutoTrackDOMDeleteRangeResult
final
{
public
:
AutoTrackDOMDeleteRangeResult
(
)
=
delete
;
AutoTrackDOMDeleteRangeResult
(
RangeUpdater
&
aRangeUpdater
DeleteRangeResult
*
aDeleteRangeResult
)
;
void
FlushAndStopTracking
(
)
{
mTrackCaretPoint
.
FlushAndStopTracking
(
)
;
mTrackDeleteRange
.
FlushAndStopTracking
(
)
;
}
void
StopTracking
(
)
{
mTrackCaretPoint
.
StopTracking
(
)
;
mTrackDeleteRange
.
StopTracking
(
)
;
}
private
:
AutoTrackDOMPoint
mTrackCaretPoint
;
AutoTrackDOMRange
mTrackDeleteRange
;
}
;
class
MOZ_STACK_CLASS
AutoTrackLineBreak
final
{
public
:
AutoTrackLineBreak
(
)
=
delete
;
AutoTrackLineBreak
(
RangeUpdater
&
aRangeUpdater
EditorLineBreak
*
aLineBreak
)
;
void
FlushAndStopTracking
(
)
;
void
StopTracking
(
)
{
mTracker
.
StopTracking
(
)
;
}
private
:
EditorLineBreak
*
mLineBreak
;
EditorDOMPoint
mPoint
;
AutoTrackDOMPoint
mTracker
;
}
;
class
MOZ_STACK_CLASS
AutoReplaceContainerSelNotify
final
{
public
:
AutoReplaceContainerSelNotify
(
)
=
delete
;
MOZ_CAN_RUN_SCRIPT
AutoReplaceContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
dom
:
:
Element
&
aOriginalElement
dom
:
:
Element
&
aNewElement
)
:
mRangeUpdater
(
aRangeUpdater
)
mOriginalElement
(
aOriginalElement
)
mNewElement
(
aNewElement
)
{
mRangeUpdater
.
WillReplaceContainer
(
)
;
}
~
AutoReplaceContainerSelNotify
(
)
{
mRangeUpdater
.
DidReplaceContainer
(
mOriginalElement
mNewElement
)
;
}
private
:
RangeUpdater
&
mRangeUpdater
;
dom
:
:
Element
&
mOriginalElement
;
dom
:
:
Element
&
mNewElement
;
}
;
class
MOZ_STACK_CLASS
AutoRemoveContainerSelNotify
final
{
public
:
AutoRemoveContainerSelNotify
(
)
=
delete
;
AutoRemoveContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
const
EditorRawDOMPoint
&
aAtRemovingElement
)
:
mRangeUpdater
(
aRangeUpdater
)
mRemovingElement
(
*
aAtRemovingElement
.
GetChild
(
)
-
>
AsElement
(
)
)
mParentNode
(
*
aAtRemovingElement
.
GetContainer
(
)
)
mOffsetInParent
(
aAtRemovingElement
.
Offset
(
)
)
mChildCountOfRemovingElement
(
mRemovingElement
-
>
GetChildCount
(
)
)
{
MOZ_ASSERT
(
aAtRemovingElement
.
IsSet
(
)
)
;
mRangeUpdater
.
WillRemoveContainer
(
)
;
}
~
AutoRemoveContainerSelNotify
(
)
{
mRangeUpdater
.
DidRemoveContainer
(
mRemovingElement
mParentNode
mOffsetInParent
mChildCountOfRemovingElement
)
;
}
private
:
RangeUpdater
&
mRangeUpdater
;
OwningNonNull
<
dom
:
:
Element
>
mRemovingElement
;
OwningNonNull
<
nsINode
>
mParentNode
;
uint32_t
mOffsetInParent
;
uint32_t
mChildCountOfRemovingElement
;
}
;
class
MOZ_STACK_CLASS
AutoInsertContainerSelNotify
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
public
:
AutoInsertContainerSelNotify
(
)
=
delete
;
explicit
AutoInsertContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
)
:
mRangeUpdater
(
aRangeUpdater
)
{
mRangeUpdater
.
WillInsertContainer
(
)
;
}
~
AutoInsertContainerSelNotify
(
)
{
mRangeUpdater
.
DidInsertContainer
(
)
;
}
}
;
class
MOZ_STACK_CLASS
AutoMoveNodeSelNotify
final
{
public
:
using
SimpleEditorDOMPoint
=
RangeUpdater
:
:
SimpleEditorDOMPoint
;
AutoMoveNodeSelNotify
(
)
=
delete
;
explicit
AutoMoveNodeSelNotify
(
RangeUpdater
&
aRangeUpdater
const
EditorRawDOMPoint
&
aExpectedDestination
)
:
mRangeUpdater
(
aRangeUpdater
)
mExpectedDestination
(
aExpectedDestination
.
GetContainer
(
)
nullptr
aExpectedDestination
.
Offset
(
)
)
{
}
AutoMoveNodeSelNotify
(
RangeUpdater
&
aRangeUpdater
nsIContent
&
aContent
const
EditorRawDOMPoint
&
aExpectedDestination
)
:
mRangeUpdater
(
aRangeUpdater
)
mExpectedDestination
(
aExpectedDestination
.
GetContainer
(
)
nullptr
aExpectedDestination
.
Offset
(
)
)
{
if
(
aContent
.
GetParentNode
(
)
)
{
mOldPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
aContent
.
ComputeIndexInParentNode
(
)
.
valueOr
(
0
)
)
)
;
return
;
}
mOldPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
)
)
;
}
void
AppendContentWhichWillBeMoved
(
nsIContent
&
aContent
)
{
if
(
!
mOldPoints
.
IsEmpty
(
)
&
&
mOldPoints
.
LastElement
(
)
.
GetNextSiblingOfChild
(
)
=
=
&
aContent
)
{
mOldPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
mOldPoints
.
LastElement
(
)
.
Offset
(
)
+
1
)
)
;
return
;
}
if
(
aContent
.
GetParentNode
(
)
)
{
mOldPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
aContent
.
ComputeIndexInParentNode
(
)
.
valueOr
(
0
)
)
)
;
return
;
}
mOldPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
)
)
;
}
void
DidMoveContent
(
nsIContent
&
aContent
)
{
if
(
!
mNewPoints
.
IsEmpty
(
)
&
&
mNewPoints
.
LastElement
(
)
.
GetNextSiblingOfChild
(
)
=
=
&
aContent
)
{
mNewPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
mNewPoints
.
LastElement
(
)
.
Offset
(
)
+
1
)
)
;
return
;
}
mNewPoints
.
AppendElement
(
SimpleEditorDOMPoint
(
&
aContent
)
)
;
}
~
AutoMoveNodeSelNotify
(
)
{
mRangeUpdater
.
DidMoveNodes
(
mOldPoints
mExpectedDestination
mNewPoints
)
;
}
[
[
nodiscard
]
]
size_t
MovingContentCount
(
)
const
{
return
mOldPoints
.
Length
(
)
;
}
[
[
nodiscard
]
]
nsIContent
*
GetContentAt
(
size_t
index
)
const
{
return
mOldPoints
[
index
]
.
mChild
;
}
private
:
RangeUpdater
&
mRangeUpdater
;
SimpleEditorDOMPoint
mExpectedDestination
;
AutoTArray
<
SimpleEditorDOMPoint
12
>
mOldPoints
;
AutoTArray
<
SimpleEditorDOMPoint
12
>
mNewPoints
;
}
;
}
#
endif
