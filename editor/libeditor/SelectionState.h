#
ifndef
mozilla_SelectionState_h
#
define
mozilla_SelectionState_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsCycleCollectionTraversalCallback
;
class
nsIDOMCharacterData
;
class
nsRange
;
namespace
mozilla
{
class
RangeUpdater
;
namespace
dom
{
class
Selection
;
class
Text
;
}
struct
RangeItem
final
{
RangeItem
(
)
;
private
:
~
RangeItem
(
)
;
public
:
void
StoreRange
(
nsRange
*
aRange
)
;
already_AddRefed
<
nsRange
>
GetRange
(
)
;
NS_INLINE_DECL_REFCOUNTING
(
RangeItem
)
void
Unlink
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCallback
uint32_t
aFlags
)
;
nsCOMPtr
<
nsINode
>
mStartContainer
;
int32_t
mStartOffset
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
int32_t
mEndOffset
;
}
;
inline
void
ImplCycleCollectionUnlink
(
RangeItem
&
aItem
)
{
aItem
.
Unlink
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
RangeItem
&
aItem
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aItem
.
Traverse
(
aCallback
aFlags
)
;
}
inline
void
ImplCycleCollectionUnlink
(
RefPtr
<
RangeItem
>
&
aItem
)
{
aItem
-
>
Unlink
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
RefPtr
<
RangeItem
>
&
aItem
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aItem
-
>
Traverse
(
aCallback
aFlags
)
;
}
class
SelectionState
final
{
public
:
SelectionState
(
)
;
~
SelectionState
(
)
;
void
SaveSelection
(
dom
:
:
Selection
*
aSel
)
;
nsresult
RestoreSelection
(
dom
:
:
Selection
*
aSel
)
;
bool
IsCollapsed
(
)
;
bool
IsEqual
(
SelectionState
*
aSelState
)
;
void
MakeEmpty
(
)
;
bool
IsEmpty
(
)
;
private
:
AutoTArray
<
RefPtr
<
RangeItem
>
1
>
mArray
;
friend
class
RangeUpdater
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
SelectionState
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
SelectionState
&
)
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
SelectionState
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mArray
aName
aFlags
)
;
}
inline
void
ImplCycleCollectionUnlink
(
SelectionState
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mArray
)
;
}
class
RangeUpdater
final
{
public
:
RangeUpdater
(
)
;
~
RangeUpdater
(
)
;
void
RegisterRangeItem
(
RangeItem
*
aRangeItem
)
;
void
DropRangeItem
(
RangeItem
*
aRangeItem
)
;
nsresult
RegisterSelectionState
(
SelectionState
&
aSelState
)
;
nsresult
DropSelectionState
(
SelectionState
&
aSelState
)
;
nsresult
SelAdjCreateNode
(
nsINode
*
aParent
int32_t
aPosition
)
;
nsresult
SelAdjInsertNode
(
nsINode
*
aParent
int32_t
aPosition
)
;
void
SelAdjDeleteNode
(
nsINode
*
aNode
)
;
nsresult
SelAdjSplitNode
(
nsIContent
&
aOldRightNode
int32_t
aOffset
nsIContent
*
aNewLeftNode
)
;
nsresult
SelAdjJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
nsINode
&
aParent
int32_t
aOffset
int32_t
aOldLeftNodeLength
)
;
void
SelAdjInsertText
(
dom
:
:
Text
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
;
nsresult
SelAdjDeleteText
(
nsIContent
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
;
nsresult
SelAdjDeleteText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
;
nsresult
WillReplaceContainer
(
)
;
nsresult
DidReplaceContainer
(
dom
:
:
Element
*
aOriginalNode
dom
:
:
Element
*
aNewNode
)
;
nsresult
WillRemoveContainer
(
)
;
nsresult
DidRemoveContainer
(
nsINode
*
aNode
nsINode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
;
nsresult
DidRemoveContainer
(
nsIDOMNode
*
aNode
nsIDOMNode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
;
nsresult
WillInsertContainer
(
)
;
nsresult
DidInsertContainer
(
)
;
void
WillMoveNode
(
)
;
void
DidMoveNode
(
nsINode
*
aOldParent
int32_t
aOldOffset
nsINode
*
aNewParent
int32_t
aNewOffset
)
;
private
:
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
RangeUpdater
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
RangeUpdater
&
aField
)
;
nsTArray
<
RefPtr
<
RangeItem
>
>
mArray
;
bool
mLock
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
RangeUpdater
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mArray
aName
aFlags
)
;
}
inline
void
ImplCycleCollectionUnlink
(
RangeUpdater
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mArray
)
;
}
class
MOZ_STACK_CLASS
AutoTrackDOMPoint
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
nsCOMPtr
<
nsINode
>
*
mNode
;
nsCOMPtr
<
nsIDOMNode
>
*
mDOMNode
;
int32_t
*
mOffset
;
RefPtr
<
RangeItem
>
mRangeItem
;
public
:
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
)
:
mRangeUpdater
(
aRangeUpdater
)
mNode
(
aNode
)
mDOMNode
(
nullptr
)
mOffset
(
aOffset
)
{
mRangeItem
=
new
RangeItem
(
)
;
mRangeItem
-
>
mStartContainer
=
*
mNode
;
mRangeItem
-
>
mEndContainer
=
*
mNode
;
mRangeItem
-
>
mStartOffset
=
*
mOffset
;
mRangeItem
-
>
mEndOffset
=
*
mOffset
;
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
}
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
nsCOMPtr
<
nsIDOMNode
>
*
aNode
int32_t
*
aOffset
)
:
mRangeUpdater
(
aRangeUpdater
)
mNode
(
nullptr
)
mDOMNode
(
aNode
)
mOffset
(
aOffset
)
{
mRangeItem
=
new
RangeItem
(
)
;
mRangeItem
-
>
mStartContainer
=
do_QueryInterface
(
*
mDOMNode
)
;
mRangeItem
-
>
mEndContainer
=
do_QueryInterface
(
*
mDOMNode
)
;
mRangeItem
-
>
mStartOffset
=
*
mOffset
;
mRangeItem
-
>
mEndOffset
=
*
mOffset
;
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
}
~
AutoTrackDOMPoint
(
)
{
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
if
(
mNode
)
{
*
mNode
=
mRangeItem
-
>
mStartContainer
;
}
else
{
*
mDOMNode
=
GetAsDOMNode
(
mRangeItem
-
>
mStartContainer
)
;
}
*
mOffset
=
mRangeItem
-
>
mStartOffset
;
}
}
;
class
MOZ_STACK_CLASS
AutoReplaceContainerSelNotify
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
dom
:
:
Element
*
mOriginalElement
;
dom
:
:
Element
*
mNewElement
;
public
:
AutoReplaceContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
dom
:
:
Element
*
aOriginalElement
dom
:
:
Element
*
aNewElement
)
:
mRangeUpdater
(
aRangeUpdater
)
mOriginalElement
(
aOriginalElement
)
mNewElement
(
aNewElement
)
{
mRangeUpdater
.
WillReplaceContainer
(
)
;
}
~
AutoReplaceContainerSelNotify
(
)
{
mRangeUpdater
.
DidReplaceContainer
(
mOriginalElement
mNewElement
)
;
}
}
;
class
MOZ_STACK_CLASS
AutoRemoveContainerSelNotify
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
nsIDOMNode
*
mNode
;
nsIDOMNode
*
mParent
;
int32_t
mOffset
;
uint32_t
mNodeOrigLen
;
public
:
AutoRemoveContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
nsINode
*
aNode
nsINode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
:
mRangeUpdater
(
aRangeUpdater
)
mNode
(
aNode
-
>
AsDOMNode
(
)
)
mParent
(
aParent
-
>
AsDOMNode
(
)
)
mOffset
(
aOffset
)
mNodeOrigLen
(
aNodeOrigLen
)
{
mRangeUpdater
.
WillRemoveContainer
(
)
;
}
~
AutoRemoveContainerSelNotify
(
)
{
mRangeUpdater
.
DidRemoveContainer
(
mNode
mParent
mOffset
mNodeOrigLen
)
;
}
}
;
class
MOZ_STACK_CLASS
AutoInsertContainerSelNotify
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
public
:
explicit
AutoInsertContainerSelNotify
(
RangeUpdater
&
aRangeUpdater
)
:
mRangeUpdater
(
aRangeUpdater
)
{
mRangeUpdater
.
WillInsertContainer
(
)
;
}
~
AutoInsertContainerSelNotify
(
)
{
mRangeUpdater
.
DidInsertContainer
(
)
;
}
}
;
class
MOZ_STACK_CLASS
AutoMoveNodeSelNotify
final
{
private
:
RangeUpdater
&
mRangeUpdater
;
nsINode
*
mOldParent
;
nsINode
*
mNewParent
;
int32_t
mOldOffset
;
int32_t
mNewOffset
;
public
:
AutoMoveNodeSelNotify
(
RangeUpdater
&
aRangeUpdater
nsINode
*
aOldParent
int32_t
aOldOffset
nsINode
*
aNewParent
int32_t
aNewOffset
)
:
mRangeUpdater
(
aRangeUpdater
)
mOldParent
(
aOldParent
)
mNewParent
(
aNewParent
)
mOldOffset
(
aOldOffset
)
mNewOffset
(
aNewOffset
)
{
MOZ_ASSERT
(
aOldParent
)
;
MOZ_ASSERT
(
aNewParent
)
;
mRangeUpdater
.
WillMoveNode
(
)
;
}
~
AutoMoveNodeSelNotify
(
)
{
mRangeUpdater
.
DidMoveNode
(
mOldParent
mOldOffset
mNewParent
mNewOffset
)
;
}
}
;
}
#
endif
