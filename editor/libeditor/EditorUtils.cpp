#
include
"
EditorUtils
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditor
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
namespace
mozilla
{
using
namespace
dom
;
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
)
{
if
(
aOutPoint
)
{
aOutPoint
-
>
Clear
(
)
;
}
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
if
(
aOutPoint
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
}
return
true
;
}
}
return
false
;
}
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
{
MOZ_ASSERT
(
aOutPoint
)
;
aOutPoint
-
>
Clear
(
)
;
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
return
true
;
}
}
return
false
;
}
Maybe
<
std
:
:
pair
<
StyleWhiteSpaceCollapse
StyleTextWrapMode
>
>
EditorUtils
:
:
GetComputedWhiteSpaceStyles
(
const
nsIContent
&
aContent
)
{
if
(
MOZ_UNLIKELY
(
!
aContent
.
IsElement
(
)
&
&
!
aContent
.
GetParentElement
(
)
)
)
{
return
Nothing
(
)
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aContent
.
IsElement
(
)
?
aContent
.
AsElement
(
)
:
aContent
.
GetParentElement
(
)
)
;
if
(
NS_WARN_IF
(
!
elementStyle
)
)
{
return
Nothing
(
)
;
}
const
auto
*
styleText
=
elementStyle
-
>
StyleText
(
)
;
return
Some
(
std
:
:
pair
(
styleText
-
>
mWhiteSpaceCollapse
styleText
-
>
mTextWrapMode
)
)
;
}
bool
EditorUtils
:
:
IsWhiteSpacePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
;
}
bool
EditorUtils
:
:
IsNewLinePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
NewlineIsSignificantStyle
(
)
;
}
bool
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
mWhiteSpaceCollapse
=
=
StyleWhiteSpaceCollapse
:
:
PreserveBreaks
;
}
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
EditorUtils
:
:
CreateTransferableForPlainText
(
const
Document
&
aDocument
)
{
nsresult
rv
;
nsCOMPtr
<
nsITransferable
>
transferable
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
do_CreateInstance
(
)
failed
to
create
nsITransferable
instance
"
)
;
return
Err
(
rv
)
;
}
if
(
!
transferable
)
{
NS_WARNING
(
"
do_CreateInstance
(
)
returned
nullptr
but
ignored
"
)
;
return
nsCOMPtr
<
nsITransferable
>
(
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
transferable
-
>
Init
(
aDocument
.
GetLoadContext
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
Init
(
)
failed
but
ignored
"
)
;
rvIgnored
=
transferable
-
>
AddDataFlavor
(
kTextMime
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
AddDataFlavor
(
kTextMime
)
failed
but
ignored
"
)
;
rvIgnored
=
transferable
-
>
AddDataFlavor
(
kMozTextInternal
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
AddDataFlavor
(
kMozTextInternal
)
failed
but
ignored
"
)
;
return
transferable
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleASCIISpace
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsCharASCIISpace
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleNBSP
(
)
const
{
return
IsCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsCharASCIISpaceOrNBSP
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleASCIISpace
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsPreviousCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsPreviousCharASCIISpace
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleNBSP
(
)
const
{
return
IsPreviousCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsPreviousCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsPreviousCharASCIISpaceOrNBSP
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleASCIISpace
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsNextCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsNextCharASCIISpace
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleNBSP
(
)
const
{
return
IsNextCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
)
{
return
false
;
}
if
(
IsNextCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
return
IsNextCharASCIISpaceOrNBSP
(
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharPreformattedNewLine
(
)
const
{
return
IsCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharPreformattedNewLine
(
)
const
{
return
IsPreviousCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsPreviousCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharPreformattedNewLine
(
)
const
{
return
IsNextCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsNextCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAs
<
Text
>
(
)
)
;
}
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsContainerEditableRoot
(
)
const
{
if
(
MOZ_UNLIKELY
(
!
mParent
)
|
|
MOZ_UNLIKELY
(
!
mParent
-
>
IsEditable
(
)
)
|
|
NS_WARN_IF
(
mParent
-
>
IsInNativeAnonymousSubtree
(
)
)
)
{
return
false
;
}
return
HTMLEditUtils
:
:
ElementIsEditableRoot
(
*
mParent
)
;
}
NS_INSTANTIATE_EDITOR_DOM_RANGE_CONST_METHOD
(
nsINode
*
GetClosestCommonInclusiveAncestor
)
;
template
<
typename
EditorDOMPointType
>
nsINode
*
EditorDOMRangeBase
<
EditorDOMPointType
>
:
:
GetClosestCommonInclusiveAncestor
(
)
const
{
if
(
NS_WARN_IF
(
!
IsPositioned
(
)
)
)
{
return
nullptr
;
}
return
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
mStart
.
GetContainer
(
)
mEnd
.
GetContainer
(
)
)
;
}
nsresult
CaretPoint
:
:
SuggestCaretPointTo
(
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
const
{
mHandledCaretPoint
=
true
;
if
(
!
mCaretPoint
.
IsSet
(
)
)
{
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
)
{
return
NS_OK
;
}
NS_WARNING
(
"
There
was
no
suggestion
to
put
caret
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
&
&
!
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aEditorBase
.
CollapseSelectionTo
(
mCaretPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
&
&
NS_FAILED
(
rv
)
?
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
:
rv
;
}
bool
CaretPoint
:
:
CopyCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
const
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
mHandledCaretPoint
=
true
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
&
&
!
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
return
false
;
}
aPointToPutCaret
=
mCaretPoint
;
return
true
;
}
bool
CaretPoint
:
:
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
mHandledCaretPoint
=
true
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
&
&
!
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
}
