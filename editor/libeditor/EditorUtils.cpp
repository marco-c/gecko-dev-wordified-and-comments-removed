#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsINode
.
h
"
class
nsISupports
;
class
nsRange
;
namespace
mozilla
{
using
namespace
dom
;
EditActionResult
&
EditActionResult
:
:
operator
|
=
(
const
MoveNodeResult
&
aMoveNodeResult
)
{
mHandled
|
=
aMoveNodeResult
.
Handled
(
)
;
if
(
mRv
=
=
aMoveNodeResult
.
Rv
(
)
)
{
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aMoveNodeResult
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
return
*
this
;
}
if
(
aMoveNodeResult
.
Rv
(
)
=
=
NS_ERROR_NOT_INITIALIZED
)
{
return
*
this
;
}
if
(
Failed
(
)
|
|
aMoveNodeResult
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
return
*
this
;
}
mRv
=
NS_OK
;
return
*
this
;
}
DOMIterator
:
:
DOMIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
mIter
(
&
mPostOrderIter
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
DebugOnly
<
nsresult
>
rv
=
mIter
-
>
Init
(
&
aNode
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
DOMIterator
:
:
Init
(
nsRange
&
aRange
)
{
return
mIter
-
>
Init
(
&
aRange
)
;
}
nsresult
DOMIterator
:
:
Init
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
{
return
mIter
-
>
Init
(
aStartRef
aEndRef
)
;
}
DOMIterator
:
:
DOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
)
:
mIter
(
&
mPostOrderIter
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
void
DOMIterator
:
:
AppendList
(
const
BoolDomIterFunctor
&
functor
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
const
{
for
(
;
!
mIter
-
>
IsDone
(
)
;
mIter
-
>
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
mIter
-
>
GetCurrentNode
(
)
;
if
(
functor
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
)
;
}
}
}
DOMSubtreeIterator
:
:
DOMSubtreeIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
)
:
DOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_TO_PARENT
)
{
mIter
=
&
mSubtreeIter
;
}
nsresult
DOMSubtreeIterator
:
:
Init
(
nsRange
&
aRange
)
{
return
mIter
-
>
Init
(
&
aRange
)
;
}
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
)
{
if
(
aOutPoint
)
{
aOutPoint
-
>
Clear
(
)
;
}
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
if
(
aOutPoint
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
}
return
true
;
}
}
return
false
;
}
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
{
MOZ_ASSERT
(
aOutPoint
)
;
aOutPoint
-
>
Clear
(
)
;
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
return
true
;
}
}
return
false
;
}
void
EditorUtils
:
:
MaskString
(
nsString
&
aString
Text
*
aText
uint32_t
aStartOffsetInString
uint32_t
aStartOffsetInText
)
{
MOZ_ASSERT
(
aText
-
>
HasFlag
(
NS_MAYBE_MASKED
)
)
;
MOZ_ASSERT
(
aStartOffsetInString
=
=
0
|
|
aStartOffsetInText
=
=
0
)
;
uint32_t
unmaskStart
=
UINT32_MAX
unmaskLength
=
0
;
TextEditor
*
textEditor
=
nsContentUtils
:
:
GetTextEditorFromAnonymousNodeWithoutCreation
(
aText
)
;
if
(
textEditor
&
&
textEditor
-
>
UnmaskedLength
(
)
>
0
)
{
unmaskStart
=
textEditor
-
>
UnmaskedStart
(
)
;
unmaskLength
=
textEditor
-
>
UnmaskedLength
(
)
;
if
(
aStartOffsetInText
>
=
unmaskStart
+
unmaskLength
)
{
unmaskLength
=
0
;
unmaskStart
=
UINT32_MAX
;
}
else
{
if
(
aStartOffsetInText
>
unmaskStart
)
{
unmaskLength
=
unmaskStart
+
unmaskLength
-
aStartOffsetInText
;
unmaskStart
=
0
;
}
else
{
unmaskStart
-
=
aStartOffsetInText
;
}
unmaskStart
+
=
aStartOffsetInString
;
}
}
const
char16_t
kPasswordMask
=
TextEditor
:
:
PasswordMask
(
)
;
for
(
uint32_t
i
=
aStartOffsetInString
;
i
<
aString
.
Length
(
)
;
+
+
i
)
{
bool
isSurrogatePair
=
NS_IS_HIGH_SURROGATE
(
aString
.
CharAt
(
i
)
)
&
&
i
<
aString
.
Length
(
)
-
1
&
&
NS_IS_LOW_SURROGATE
(
aString
.
CharAt
(
i
+
1
)
)
;
if
(
i
<
unmaskStart
|
|
i
>
=
unmaskStart
+
unmaskLength
)
{
if
(
isSurrogatePair
)
{
aString
.
SetCharAt
(
kPasswordMask
i
)
;
aString
.
SetCharAt
(
kPasswordMask
i
+
1
)
;
}
else
{
aString
.
SetCharAt
(
kPasswordMask
i
)
;
}
}
if
(
isSurrogatePair
)
{
+
+
i
;
}
}
}
}
