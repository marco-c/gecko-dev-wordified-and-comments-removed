#
include
"
EditorUtils
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditor
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsTextFragment
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
EditActionResult
&
EditActionResult
:
:
operator
|
=
(
const
MoveNodeResult
&
aMoveNodeResult
)
{
mHandled
|
=
aMoveNodeResult
.
Handled
(
)
;
if
(
mRv
=
=
aMoveNodeResult
.
inspectErr
(
)
)
{
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aMoveNodeResult
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
return
*
this
;
}
if
(
aMoveNodeResult
.
NotInitialized
(
)
)
{
return
*
this
;
}
if
(
Failed
(
)
|
|
aMoveNodeResult
.
isErr
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
return
*
this
;
}
mRv
=
NS_OK
;
return
*
this
;
}
bool
AutoRangeArray
:
:
IsEditableRange
(
const
dom
:
:
AbstractRange
&
aRange
const
Element
&
aEditingHost
)
{
EditorRawDOMPoint
atStart
(
aRange
.
StartRef
(
)
)
;
const
bool
isStartEditable
=
atStart
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atStart
.
ContainerAsContent
(
)
EditorUtils
:
:
EditorType
:
:
HTML
)
&
&
!
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
atStart
.
ContainerAsContent
(
)
)
;
if
(
!
isStartEditable
)
{
return
false
;
}
if
(
aRange
.
GetStartContainer
(
)
!
=
aRange
.
GetEndContainer
(
)
)
{
EditorRawDOMPoint
atEnd
(
aRange
.
EndRef
(
)
)
;
const
bool
isEndEditable
=
atEnd
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atEnd
.
ContainerAsContent
(
)
EditorUtils
:
:
EditorType
:
:
HTML
)
&
&
!
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
atEnd
.
ContainerAsContent
(
)
)
;
if
(
!
isEndEditable
)
{
return
false
;
}
if
(
atStart
.
ContainerAsContent
(
)
!
=
atEnd
.
ContainerAsContent
(
)
&
&
atStart
.
ContainerAsContent
(
)
-
>
GetEditingHost
(
)
!
=
atEnd
.
ContainerAsContent
(
)
-
>
GetEditingHost
(
)
)
{
return
false
;
}
}
nsINode
*
commonAncestor
=
aRange
.
GetClosestCommonInclusiveAncestor
(
)
;
return
commonAncestor
&
&
commonAncestor
-
>
IsContent
(
)
&
&
commonAncestor
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
;
}
void
AutoRangeArray
:
:
EnsureOnlyEditableRanges
(
const
Element
&
aEditingHost
)
{
for
(
size_t
i
=
mRanges
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
const
OwningNonNull
<
nsRange
>
&
range
=
mRanges
[
i
-
1
]
;
if
(
!
AutoRangeArray
:
:
IsEditableRange
(
range
aEditingHost
)
)
{
mRanges
.
RemoveElementAt
(
i
-
1
)
;
}
}
mAnchorFocusRange
=
mRanges
.
IsEmpty
(
)
?
nullptr
:
mRanges
.
LastElement
(
)
.
get
(
)
;
}
void
AutoRangeArray
:
:
EnsureRangesInTextNode
(
const
Text
&
aTextNode
)
{
auto
GetOffsetInTextNode
=
[
&
aTextNode
]
(
const
nsINode
*
aNode
uint32_t
aOffset
)
-
>
uint32_t
{
MOZ_DIAGNOSTIC_ASSERT
(
aNode
)
;
if
(
aNode
=
=
&
aTextNode
)
{
return
aOffset
;
}
const
nsIContent
*
anonymousDivElement
=
aTextNode
.
GetParent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
anonymousDivElement
)
;
MOZ_DIAGNOSTIC_ASSERT
(
anonymousDivElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
anonymousDivElement
-
>
GetFirstChild
(
)
=
=
&
aTextNode
)
;
if
(
aNode
=
=
anonymousDivElement
&
&
aOffset
=
=
0u
)
{
return
0u
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aNode
-
>
IsInclusiveDescendantOf
(
anonymousDivElement
)
)
;
return
aTextNode
.
TextDataLength
(
)
;
}
;
for
(
uint32_t
i
:
IntegerRange
(
mRanges
.
Length
(
)
)
)
{
const
OwningNonNull
<
nsRange
>
&
range
=
mRanges
[
i
]
;
if
(
MOZ_LIKELY
(
range
-
>
GetStartContainer
(
)
=
=
&
aTextNode
&
&
range
-
>
GetEndContainer
(
)
=
=
&
aTextNode
)
)
{
continue
;
}
range
-
>
SetStartAndEnd
(
const_cast
<
Text
*
>
(
&
aTextNode
)
GetOffsetInTextNode
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
)
const_cast
<
Text
*
>
(
&
aTextNode
)
GetOffsetInTextNode
(
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
)
;
}
if
(
MOZ_UNLIKELY
(
mRanges
.
Length
(
)
>
=
2
)
)
{
for
(
uint32_t
i
:
Reversed
(
IntegerRange
(
mRanges
.
Length
(
)
-
1u
)
)
)
{
MOZ_ASSERT
(
mRanges
[
i
]
-
>
EndOffset
(
)
<
mRanges
[
i
+
1
]
-
>
StartOffset
(
)
)
;
if
(
MOZ_UNLIKELY
(
mRanges
[
i
]
-
>
EndOffset
(
)
>
=
mRanges
[
i
+
1
]
-
>
StartOffset
(
)
)
)
{
const
uint32_t
newEndOffset
=
mRanges
[
i
+
1
]
-
>
EndOffset
(
)
;
mRanges
.
RemoveElementAt
(
i
+
1
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
newEndOffset
>
mRanges
[
i
]
-
>
EndOffset
(
)
)
)
)
{
mRanges
[
i
]
-
>
SetStartAndEnd
(
const_cast
<
Text
*
>
(
&
aTextNode
)
mRanges
[
i
]
-
>
StartOffset
(
)
const_cast
<
Text
*
>
(
&
aTextNode
)
newEndOffset
)
;
}
}
}
}
}
Result
<
nsIEditor
:
:
EDirection
nsresult
>
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
const
EditorBase
&
aEditorBase
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
aEditorBase
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mAnchorFocusRange
)
;
MOZ_ASSERT
(
mAnchorFocusRange
-
>
IsPositioned
(
)
)
;
MOZ_ASSERT
(
mAnchorFocusRange
-
>
StartRef
(
)
.
IsSet
(
)
)
;
MOZ_ASSERT
(
mAnchorFocusRange
-
>
EndRef
(
)
.
IsSet
(
)
)
;
if
(
!
EditorUtils
:
:
IsFrameSelectionRequiredToExtendSelection
(
aDirectionAndAmount
*
this
)
)
{
return
aDirectionAndAmount
;
}
if
(
NS_WARN_IF
(
!
aEditorBase
.
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
aEditorBase
.
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
-
>
StartRef
(
)
=
=
mAnchorFocusRange
-
>
StartRef
(
)
)
;
MOZ_ASSERT
(
aEditorBase
.
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
-
>
EndRef
(
)
=
=
mAnchorFocusRange
-
>
EndRef
(
)
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
aEditorBase
.
SelectionRef
(
)
.
GetFrameSelection
(
)
;
if
(
NS_WARN_IF
(
!
frameSelection
)
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
RefPtr
<
Element
>
editingHost
;
if
(
aEditorBase
.
IsHTMLEditor
(
)
)
{
editingHost
=
aEditorBase
.
AsHTMLEditor
(
)
-
>
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
Result
<
RefPtr
<
nsRange
>
nsresult
>
result
(
NS_ERROR_UNEXPECTED
)
;
nsIEditor
:
:
EDirection
directionAndAmountResult
=
aDirectionAndAmount
;
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNextWord
:
result
=
frameSelection
-
>
CreateRangeExtendedToNextWordBoundary
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
CreateRangeExtendedToNextWordBoundary
(
)
failed
"
)
;
directionAndAmountResult
=
nsIEditor
:
:
eNone
;
break
;
case
nsIEditor
:
:
ePreviousWord
:
result
=
frameSelection
-
>
CreateRangeExtendedToPreviousWordBoundary
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
CreateRangeExtendedToPreviousWordBoundary
(
)
"
"
failed
"
)
;
directionAndAmountResult
=
nsIEditor
:
:
eNone
;
break
;
case
nsIEditor
:
:
eNext
:
result
=
frameSelection
-
>
CreateRangeExtendedToNextGraphemeClusterBoundary
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
"
"
CreateRangeExtendedToNextGraphemeClusterBoundary
(
)
"
"
failed
"
)
;
break
;
case
nsIEditor
:
:
ePrevious
:
{
const
auto
atStartOfSelection
=
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMPoint
insertionPoint
=
aEditorBase
.
FindBetterInsertionPoint
(
atStartOfSelection
)
;
if
(
MOZ_UNLIKELY
(
!
insertionPoint
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
return
aDirectionAndAmount
;
}
if
(
!
insertionPoint
.
IsInTextNode
(
)
)
{
return
aDirectionAndAmount
;
}
const
nsTextFragment
*
data
=
&
insertionPoint
.
GetContainerAsText
(
)
-
>
TextFragment
(
)
;
uint32_t
offset
=
insertionPoint
.
Offset
(
)
;
if
(
!
(
offset
>
1
&
&
data
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
offset
-
1
)
)
&
&
!
(
offset
>
0
&
&
gfxFontUtils
:
:
IsVarSelector
(
data
-
>
CharAt
(
offset
-
1
)
)
)
)
{
return
aDirectionAndAmount
;
}
result
=
frameSelection
-
>
CreateRangeExtendedToPreviousCharacterBoundary
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
"
"
CreateRangeExtendedToPreviousGraphemeClusterBoundary
(
)
failed
"
)
;
break
;
}
case
nsIEditor
:
:
eToBeginningOfLine
:
result
=
frameSelection
-
>
CreateRangeExtendedToPreviousHardLineBreak
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
CreateRangeExtendedToPreviousHardLineBreak
(
)
"
"
failed
"
)
;
directionAndAmountResult
=
nsIEditor
:
:
eNone
;
break
;
case
nsIEditor
:
:
eToEndOfLine
:
result
=
frameSelection
-
>
CreateRangeExtendedToNextHardLineBreak
<
nsRange
>
(
)
;
if
(
NS_WARN_IF
(
aEditorBase
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
nsFrameSelection
:
:
CreateRangeExtendedToNextHardLineBreak
(
)
failed
"
)
;
directionAndAmountResult
=
nsIEditor
:
:
eNext
;
break
;
default
:
return
aDirectionAndAmount
;
}
if
(
result
.
isErr
(
)
)
{
return
Err
(
result
.
inspectErr
(
)
)
;
}
RefPtr
<
nsRange
>
extendedRange
(
result
.
unwrap
(
)
.
forget
(
)
)
;
if
(
!
extendedRange
|
|
NS_WARN_IF
(
!
extendedRange
-
>
IsPositioned
(
)
)
)
{
NS_WARNING
(
"
Failed
to
extend
the
range
but
ignored
"
)
;
return
directionAndAmountResult
;
}
if
(
aEditorBase
.
IsHTMLEditor
(
)
&
&
!
AutoRangeArray
:
:
IsEditableRange
(
*
extendedRange
*
editingHost
)
)
{
return
aDirectionAndAmount
;
}
if
(
NS_WARN_IF
(
!
frameSelection
-
>
IsValidSelectionPoint
(
extendedRange
-
>
GetStartContainer
(
)
)
)
|
|
NS_WARN_IF
(
!
frameSelection
-
>
IsValidSelectionPoint
(
extendedRange
-
>
GetEndContainer
(
)
)
)
)
{
NS_WARNING
(
"
A
range
was
extended
to
outer
of
selection
limiter
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
DebugOnly
<
bool
>
found
=
false
;
for
(
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
if
(
range
=
=
mAnchorFocusRange
)
{
range
=
*
extendedRange
;
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
found
)
;
mAnchorFocusRange
.
swap
(
extendedRange
)
;
return
directionAndAmountResult
;
}
Result
<
bool
nsresult
>
AutoRangeArray
:
:
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
IfSelectingOnlyOneAtomicContent
aIfSelectingOnlyOneAtomicContent
const
Element
*
aEditingHost
)
{
if
(
IsCollapsed
(
)
)
{
return
false
;
}
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
break
;
default
:
return
false
;
}
bool
changed
=
false
;
for
(
auto
&
range
:
mRanges
)
{
MOZ_ASSERT
(
!
range
-
>
IsInSelection
(
)
"
Changing
range
in
selection
may
cause
running
script
"
)
;
Result
<
bool
nsresult
>
result
=
WSRunScanner
:
:
ShrinkRangeIfStartsFromOrEndsAfterAtomicContent
(
aHTMLEditor
range
aEditingHost
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ShrinkRangeIfStartsFromOrEndsAfterAtomicContent
(
)
"
"
failed
"
)
;
return
Err
(
result
.
inspectErr
(
)
)
;
}
changed
|
=
result
.
inspect
(
)
;
}
if
(
mRanges
.
Length
(
)
=
=
1
&
&
aIfSelectingOnlyOneAtomicContent
=
=
IfSelectingOnlyOneAtomicContent
:
:
Collapse
)
{
MOZ_ASSERT
(
mRanges
[
0
]
.
get
(
)
=
=
mAnchorFocusRange
.
get
(
)
)
;
if
(
mAnchorFocusRange
-
>
GetStartContainer
(
)
=
=
mAnchorFocusRange
-
>
GetEndContainer
(
)
&
&
mAnchorFocusRange
-
>
GetChildAtStartOffset
(
)
&
&
mAnchorFocusRange
-
>
StartRef
(
)
.
GetNextSiblingOfChildAtOffset
(
)
=
=
mAnchorFocusRange
-
>
GetChildAtEndOffset
(
)
)
{
mAnchorFocusRange
-
>
Collapse
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
)
;
changed
=
true
;
}
}
return
changed
;
}
void
AutoRangeArray
:
:
UpdatePointsToSelectAllChildrenIfCollapsedInEmptyBlockElement
(
EditorDOMPoint
&
aStartPoint
EditorDOMPoint
&
aEndPoint
const
Element
&
aEditingHost
)
{
if
(
aStartPoint
!
=
aEndPoint
)
{
return
;
}
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
;
}
Element
*
const
maybeNonEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aStartPoint
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
!
maybeNonEditableBlockElement
)
{
return
;
}
if
(
aEditingHost
.
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
maybeNonEditableBlockElement
)
)
{
aStartPoint
.
Set
(
maybeNonEditableBlockElement
0u
)
;
aEndPoint
.
SetToEndOf
(
maybeNonEditableBlockElement
)
;
}
}
static
EditorDOMPoint
GetPointAtFirstContentOfLineOrParentBlockIfFirstContentOfBlock
(
const
EditorDOMPoint
&
aPointInLine
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
aPointInLine
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPointInLine
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
EditorDOMPoint
atLastPreformattedNewLine
=
HTMLEditUtils
:
:
GetPreviousPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
point
)
;
if
(
atLastPreformattedNewLine
.
IsSet
(
)
)
{
return
atLastPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
constexpr
HTMLEditUtils
:
:
WalkTreeOptions
ignoreNonEditableNodeAndStopAtBlockBoundary
{
HTMLEditUtils
:
:
WalkTreeOption
:
:
IgnoreNonEditableNode
HTMLEditUtils
:
:
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
previousEditableContent
&
&
previousEditableContent
-
>
GetParentNode
(
)
&
&
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
previousEditableContent
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
;
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
EditorDOMPoint
atLastPreformattedNewLine
=
HTMLEditUtils
:
:
GetPreviousPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
EditorRawDOMPoint
:
:
AtEndOf
(
*
previousEditableContent
)
)
;
if
(
atLastPreformattedNewLine
.
IsSet
(
)
)
{
return
atLastPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
Set
(
previousEditableContent
)
;
}
for
(
nsIContent
*
nearContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainerParent
(
)
;
nearContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
;
if
(
!
point
.
GetContainerParent
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
&
&
(
blockLevelAction
|
|
!
point
.
GetContainer
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
return
point
;
}
static
EditorDOMPoint
GetPointAfterFollowingLineBreakOrAtFollowingBlock
(
const
EditorDOMPoint
&
aPointInLine
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
aPointInLine
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPointInLine
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
NS_WARN_IF
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
return
point
;
}
EditorDOMPoint
atNextPreformattedNewLine
=
HTMLEditUtils
:
:
GetInclusiveNextPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
point
)
;
if
(
atNextPreformattedNewLine
.
IsSet
(
)
)
{
Element
*
maybeNonEditableBlockElement
=
nullptr
;
if
(
HTMLEditUtils
:
:
IsInvisiblePreformattedNewLine
(
atNextPreformattedNewLine
&
maybeNonEditableBlockElement
)
&
&
maybeNonEditableBlockElement
)
{
if
(
maybeNonEditableBlockElement
=
=
&
aEditingHost
|
|
!
maybeNonEditableBlockElement
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
if
(
atNextPreformattedNewLine
.
ContainerAsText
(
)
-
>
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
return
EditorDOMPoint
(
maybeNonEditableBlockElement
)
;
}
return
atNextPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
point
.
IsSet
(
)
"
Failed
to
set
to
after
the
text
node
"
)
;
}
constexpr
HTMLEditUtils
:
:
WalkTreeOptions
ignoreNonEditableNodeAndStopAtBlockBoundary
{
HTMLEditUtils
:
:
WalkTreeOption
:
:
IgnoreNonEditableNode
HTMLEditUtils
:
:
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
nextEditableContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
nextEditableContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
&
&
nextEditableContent
-
>
GetParent
(
)
;
nextEditableContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
EditorDOMPoint
atFirstPreformattedNewLine
=
HTMLEditUtils
:
:
GetInclusiveNextPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
EditorRawDOMPoint
(
nextEditableContent
0
)
)
;
if
(
atFirstPreformattedNewLine
.
IsSet
(
)
)
{
Element
*
maybeNonEditableBlockElement
=
nullptr
;
if
(
HTMLEditUtils
:
:
IsInvisiblePreformattedNewLine
(
atFirstPreformattedNewLine
&
maybeNonEditableBlockElement
)
&
&
maybeNonEditableBlockElement
)
{
if
(
maybeNonEditableBlockElement
=
=
&
aEditingHost
|
|
!
maybeNonEditableBlockElement
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
if
(
atFirstPreformattedNewLine
.
ContainerAsText
(
)
-
>
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
return
EditorDOMPoint
(
maybeNonEditableBlockElement
)
;
}
return
atFirstPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
SetAfter
(
nextEditableContent
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
nextEditableContent
)
)
{
break
;
}
}
for
(
nsIContent
*
nearContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainerParent
(
)
;
nearContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
&
&
!
point
.
GetContainerParent
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
break
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
}
return
point
;
}
void
AutoRangeArray
:
:
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
{
bool
removeSomeRanges
=
false
;
for
(
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
if
(
MOZ_UNLIKELY
(
!
range
-
>
IsPositioned
(
)
)
)
{
removeSomeRanges
=
true
;
continue
;
}
if
(
MOZ_UNLIKELY
(
range
-
>
GetStartContainer
(
)
-
>
IsInNativeAnonymousSubtree
(
)
|
|
range
-
>
GetEndContainer
(
)
-
>
IsInNativeAnonymousSubtree
(
)
)
)
{
EditorRawDOMRange
rawRange
(
range
)
;
if
(
!
rawRange
.
EnsureNotInNativeAnonymousSubtree
(
)
)
{
range
-
>
Reset
(
)
;
removeSomeRanges
=
true
;
continue
;
}
if
(
NS_FAILED
(
range
-
>
SetStartAndEnd
(
rawRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
rawRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
|
|
MOZ_UNLIKELY
(
!
range
-
>
IsPositioned
(
)
)
)
{
range
-
>
Reset
(
)
;
removeSomeRanges
=
true
;
continue
;
}
}
if
(
NS_FAILED
(
ExtendRangeToWrapStartAndEndLinesContainingBoundaries
(
range
aEditSubAction
aEditingHost
)
)
)
{
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
removeSomeRanges
=
true
;
}
}
}
if
(
removeSomeRanges
)
{
for
(
size_t
i
:
Reversed
(
IntegerRange
(
mRanges
.
Length
(
)
)
)
)
{
if
(
!
mRanges
[
i
]
-
>
IsPositioned
(
)
)
{
mRanges
.
RemoveElementAt
(
i
)
;
}
}
}
}
nsresult
AutoRangeArray
:
:
ExtendRangeToWrapStartAndEndLinesContainingBoundaries
(
nsRange
&
aRange
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
EditorRawDOMPoint
(
aRange
.
StartRef
(
)
)
.
IsInNativeAnonymousSubtree
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
EditorRawDOMPoint
(
aRange
.
EndRef
(
)
)
.
IsInNativeAnonymousSubtree
(
)
)
;
if
(
NS_WARN_IF
(
!
aRange
.
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorDOMPoint
startPoint
(
aRange
.
StartRef
(
)
)
endPoint
(
aRange
.
EndRef
(
)
)
;
AutoRangeArray
:
:
UpdatePointsToSelectAllChildrenIfCollapsedInEmptyBlockElement
(
startPoint
endPoint
aEditingHost
)
;
startPoint
=
GetPointAtFirstContentOfLineOrParentBlockIfFirstContentOfBlock
(
startPoint
aEditSubAction
aEditingHost
)
;
if
(
!
startPoint
.
GetChildOrContainerIfDataNode
(
)
|
|
!
startPoint
.
GetChildOrContainerIfDataNode
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
endPoint
=
GetPointAfterFollowingLineBreakOrAtFollowingBlock
(
endPoint
aEditingHost
)
;
const
EditorDOMPoint
lastRawPoint
=
endPoint
.
IsStartOfContainer
(
)
?
endPoint
:
endPoint
.
PreviousPoint
(
)
;
if
(
!
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
|
|
!
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
)
{
if
(
aOutPoint
)
{
aOutPoint
-
>
Clear
(
)
;
}
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
if
(
aOutPoint
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
}
return
true
;
}
}
return
false
;
}
bool
EditorUtils
:
:
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
{
MOZ_ASSERT
(
aOutPoint
)
;
aOutPoint
-
>
Clear
(
)
;
if
(
&
aNode
=
=
&
aParent
)
{
return
false
;
}
for
(
const
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
GetParentNode
(
)
=
=
&
aParent
)
{
MOZ_ASSERT
(
node
-
>
IsContent
(
)
)
;
aOutPoint
-
>
Set
(
node
-
>
AsContent
(
)
)
;
return
true
;
}
}
return
false
;
}
void
EditorUtils
:
:
MaskString
(
nsString
&
aString
const
Text
&
aTextNode
uint32_t
aStartOffsetInString
uint32_t
aStartOffsetInText
)
{
MOZ_ASSERT
(
aTextNode
.
HasFlag
(
NS_MAYBE_MASKED
)
)
;
MOZ_ASSERT
(
aStartOffsetInString
=
=
0
|
|
aStartOffsetInText
=
=
0
)
;
uint32_t
unmaskStart
=
UINT32_MAX
unmaskLength
=
0
;
TextEditor
*
textEditor
=
nsContentUtils
:
:
GetTextEditorFromAnonymousNodeWithoutCreation
(
&
aTextNode
)
;
if
(
textEditor
&
&
textEditor
-
>
UnmaskedLength
(
)
>
0
)
{
unmaskStart
=
textEditor
-
>
UnmaskedStart
(
)
;
unmaskLength
=
textEditor
-
>
UnmaskedLength
(
)
;
if
(
aStartOffsetInText
>
=
unmaskStart
+
unmaskLength
)
{
unmaskLength
=
0
;
unmaskStart
=
UINT32_MAX
;
}
else
{
if
(
aStartOffsetInText
>
unmaskStart
)
{
unmaskLength
=
unmaskStart
+
unmaskLength
-
aStartOffsetInText
;
unmaskStart
=
0
;
}
else
{
unmaskStart
-
=
aStartOffsetInText
;
}
unmaskStart
+
=
aStartOffsetInString
;
}
}
const
char16_t
kPasswordMask
=
TextEditor
:
:
PasswordMask
(
)
;
for
(
uint32_t
i
=
aStartOffsetInString
;
i
<
aString
.
Length
(
)
;
+
+
i
)
{
bool
isSurrogatePair
=
NS_IS_HIGH_SURROGATE
(
aString
.
CharAt
(
i
)
)
&
&
i
<
aString
.
Length
(
)
-
1
&
&
NS_IS_LOW_SURROGATE
(
aString
.
CharAt
(
i
+
1
)
)
;
if
(
i
<
unmaskStart
|
|
i
>
=
unmaskStart
+
unmaskLength
)
{
if
(
isSurrogatePair
)
{
aString
.
SetCharAt
(
kPasswordMask
i
)
;
aString
.
SetCharAt
(
kPasswordMask
i
+
1
)
;
}
else
{
aString
.
SetCharAt
(
kPasswordMask
i
)
;
}
}
if
(
isSurrogatePair
)
{
+
+
i
;
}
}
}
bool
EditorUtils
:
:
IsWhiteSpacePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
;
}
bool
EditorUtils
:
:
IsNewLinePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
NewlineIsSignificantStyle
(
)
;
}
bool
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
const
nsIContent
&
aContent
)
{
Element
*
element
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleText
(
)
-
>
mWhiteSpace
=
=
StyleWhiteSpace
:
:
PreLine
;
}
bool
EditorUtils
:
:
IsPointInSelection
(
const
Selection
&
aSelection
const
nsINode
&
aParentNode
uint32_t
aOffset
)
{
if
(
aSelection
.
IsCollapsed
(
)
)
{
return
false
;
}
const
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
.
RangeCount
(
)
=
=
rangeCount
)
;
RefPtr
<
const
nsRange
>
range
=
aSelection
.
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
)
{
continue
;
}
IgnoredErrorResult
ignoredError
;
bool
nodeIsInSelection
=
range
-
>
IsPointInRange
(
aParentNode
aOffset
ignoredError
)
&
&
!
ignoredError
.
Failed
(
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
IsPointInRange
(
)
failed
"
)
;
if
(
nodeIsInSelection
)
{
return
true
;
}
}
return
false
;
}
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
EditorUtils
:
:
CreateTransferableForPlainText
(
const
Document
&
aDocument
)
{
nsresult
rv
;
nsCOMPtr
<
nsITransferable
>
transferable
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
do_CreateInstance
(
)
failed
to
create
nsITransferable
instance
"
)
;
return
Err
(
rv
)
;
}
if
(
!
transferable
)
{
NS_WARNING
(
"
do_CreateInstance
(
)
returned
nullptr
but
ignored
"
)
;
return
nsCOMPtr
<
nsITransferable
>
(
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
transferable
-
>
Init
(
aDocument
.
GetLoadContext
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
Init
(
)
failed
but
ignored
"
)
;
rvIgnored
=
transferable
-
>
AddDataFlavor
(
kUnicodeMime
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
AddDataFlavor
(
kUnicodeMime
)
failed
but
ignored
"
)
;
rvIgnored
=
transferable
-
>
AddDataFlavor
(
kMozTextInternal
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITransferable
:
:
AddDataFlavor
(
kMozTextInternal
)
failed
but
ignored
"
)
;
return
transferable
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleASCIISpace
(
)
const
{
if
(
IsCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsCharASCIISpace
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleNBSP
(
)
const
{
return
IsCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
IsCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsCharASCIISpaceOrNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleASCIISpace
(
)
const
{
if
(
IsPreviousCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsPreviousCharASCIISpace
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleNBSP
(
)
const
{
return
IsPreviousCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
IsPreviousCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsPreviousCharASCIISpaceOrNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleASCIISpace
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleASCIISpace
(
)
const
{
if
(
IsNextCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsNextCharASCIISpace
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleNBSP
(
)
const
{
return
IsNextCharNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharCollapsibleASCIISpaceOrNBSP
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharCollapsibleASCIISpaceOrNBSP
(
)
const
{
if
(
IsNextCharNewLine
(
)
)
{
return
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
return
IsNextCharASCIISpaceOrNBSP
(
)
&
&
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharPreformattedNewLine
(
)
const
{
return
IsCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharPreformattedNewLine
(
)
const
{
return
IsPreviousCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsPreviousCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsPreviousCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsPreviousCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharPreformattedNewLine
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharPreformattedNewLine
(
)
const
{
return
IsNextCharNewLine
(
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
bool
IsNextCharPreformattedNewLineCollapsedWithWhiteSpaces
)
;
template
<
typename
PT
typename
CT
>
bool
EditorDOMPointBase
<
PT
CT
>
:
:
IsNextCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
{
return
IsNextCharNewLine
(
)
&
&
EditorUtils
:
:
IsOnlyNewLinePreformatted
(
*
ContainerAsText
(
)
)
;
}
NS_INSTANTIATE_CREATE_NODE_RESULT_CONST_METHOD
(
nsresult
SuggestCaretPointTo
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
template
<
typename
NodeType
>
nsresult
CreateNodeResultBase
<
NodeType
>
:
:
SuggestCaretPointTo
(
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
const
{
mHandledCaretPoint
=
true
;
if
(
!
mCaretPoint
.
IsSet
(
)
)
{
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
)
{
return
NS_OK
;
}
NS_WARNING
(
"
There
was
no
suggestion
to
put
caret
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
&
&
!
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aEditorBase
.
CollapseSelectionTo
(
mCaretPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
&
&
NS_FAILED
(
rv
)
?
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
:
rv
;
}
NS_INSTANTIATE_CREATE_NODE_RESULT_METHOD
(
bool
MoveCaretPointTo
EditorDOMPoint
&
aPointToPutCaret
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
template
<
typename
NodeType
>
bool
CreateNodeResultBase
<
NodeType
>
:
:
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
EditorBase
&
aEditorBase
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
mHandledCaretPoint
=
true
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
&
&
!
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
}
