#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
using
ChildBlockBoundary
=
HTMLEditUtils
:
:
ChildBlockBoundary
;
nsresult
HTMLEditor
:
:
SetInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aProperty
aAttribute
true
)
aPrincipal
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
No
)
;
nsAtom
*
property
=
&
aProperty
;
nsAtom
*
attribute
=
aAttribute
;
nsAutoString
value
(
aValue
)
;
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sub
nullptr
RemoveRelatedElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sub
"
"
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sup
nullptr
RemoveRelatedElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sup
"
"
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
else
if
(
!
aPrincipal
)
{
if
(
&
aProperty
=
=
nsGkAtoms
:
:
tt
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
RemoveRelatedElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
font
"
"
nsGkAtoms
:
:
face
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
font
&
&
aAttribute
=
=
nsGkAtoms
:
:
face
)
{
if
(
!
value
.
LowerCaseEqualsASCII
(
"
tt
"
)
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
tt
nullptr
RemoveRelatedElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
tt
"
"
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
else
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
RemoveRelatedElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
font
"
"
nsGkAtoms
:
:
face
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
property
=
nsGkAtoms
:
:
tt
;
attribute
=
nullptr
;
value
.
Truncate
(
)
;
}
}
}
rv
=
SetInlinePropertyInternal
(
MOZ_KnownLive
(
*
property
)
MOZ_KnownLive
(
attribute
)
value
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
if
(
NS_WARN_IF
(
!
property
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
true
)
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetInlinePropertyInternal
(
*
property
MOZ_KnownLive
(
attribute
)
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyInternal
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aAttributeValue
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
mTypeInState
-
>
SetProp
(
&
aProperty
aAttribute
aAttributeValue
)
;
return
NS_OK
;
}
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoSelectionRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
startOfRange
(
range
-
>
StartRef
(
)
)
;
EditorDOMPoint
endOfRange
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
&
&
startOfRange
.
IsInTextNode
(
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
startOfRange
.
GetContainerAsText
(
)
)
startOfRange
.
Offset
(
)
endOfRange
.
Offset
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
startOfRange
.
GetContainerAsText
(
)
)
startOfRange
.
Offset
(
)
startOfRange
.
GetContainer
(
)
-
>
Length
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
content
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
}
if
(
endOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
endOfRange
.
GetContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
endOfRange
.
GetContainerAsText
(
)
)
0
endOfRange
.
Offset
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
bool
HTMLEditor
:
:
IsSimpleModifiableNode
(
nsIContent
*
aContent
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
)
{
MOZ_ASSERT
(
aProperty
)
;
MOZ_ASSERT_IF
(
aAttribute
aValue
)
;
RefPtr
<
dom
:
:
Element
>
element
=
Element
:
:
FromNodeOrNull
(
aContent
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
false
;
}
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
!
element
-
>
GetAttrCount
(
)
&
&
!
aAttribute
)
{
return
true
;
}
if
(
!
element
-
>
GetAttrCount
(
)
&
&
(
(
aProperty
=
=
nsGkAtoms
:
:
b
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
strong
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
i
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
em
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
strike
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
s
)
)
)
)
{
return
true
;
}
if
(
aAttribute
)
{
nsString
attrValue
;
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
IsOnlyAttribute
(
element
aAttribute
)
&
&
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
attrValue
)
&
&
attrValue
.
Equals
(
*
aValue
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
element
aProperty
aAttribute
)
|
|
!
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
|
|
element
-
>
GetAttrCount
(
)
!
=
1
|
|
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
)
{
return
false
;
}
RefPtr
<
Element
>
newSpanElement
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
if
(
!
newSpanElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
failed
"
)
;
return
false
;
}
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
newSpanElement
aProperty
aAttribute
aValue
true
)
;
nsCOMPtr
<
nsStyledElement
>
styledNewSpanElement
=
do_QueryInterface
(
newSpanElement
)
;
if
(
!
styledNewSpanElement
)
{
return
false
;
}
nsCOMPtr
<
nsStyledElement
>
styledElement
=
do_QueryInterface
(
element
)
;
if
(
!
styledElement
)
{
return
false
;
}
return
CSSEditUtils
:
:
DoStyledElementsHaveSameStyle
(
*
styledNewSpanElement
*
styledElement
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
aText
.
GetParentNode
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aText
.
GetParentNode
(
)
aProperty
)
)
{
return
NS_OK
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aText
&
aProperty
aAttribute
)
)
{
nsAutoString
value
(
aValue
)
;
if
(
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aText
&
aProperty
aAttribute
value
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aText
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aText
;
EditorDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
if
(
aAttribute
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
SetInlinePropertyOnNode
(
*
textNodeForTheRange
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aContent
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
nsGkAtoms
:
:
span
aContent
)
)
{
if
(
aContent
.
HasChildren
(
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aContent
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
&
&
!
IsEmptyTextNode
(
*
child
)
)
{
arrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
node
)
aProperty
aAttribute
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
previousSibling
=
GetPriorHTMLSibling
(
&
aContent
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
GetNextHTMLSibling
(
&
aContent
)
;
if
(
IsSimpleModifiableNode
(
previousSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aContent
*
previousSibling
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
rv
=
JoinNodesWithTransaction
(
*
previousSibling
*
nextSibling
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aContent
EditorDOMPoint
(
nextSibling
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
&
aProperty
aAttribute
)
)
{
nsAutoString
value
(
aValue
)
;
if
(
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aContent
&
aProperty
aAttribute
value
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aContent
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
bool
useCSS
=
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
&
aProperty
aAttribute
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
|
|
aValue
.
EqualsLiteral
(
"
-
moz
-
editor
-
invert
-
value
"
)
;
if
(
useCSS
)
{
RefPtr
<
Element
>
spanElement
;
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aContent
.
AsElement
(
)
-
>
GetAttrCount
(
)
)
{
spanElement
=
aContent
.
AsElement
(
)
;
}
else
{
spanElement
=
InsertContainerWithTransaction
(
aContent
*
nsGkAtoms
:
:
span
)
;
if
(
!
spanElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
nsGkAtoms
:
:
span
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
spanElement
&
aProperty
aAttribute
&
aValue
false
)
;
return
NS_OK
;
}
if
(
aContent
.
IsHTMLElement
(
&
aProperty
)
)
{
if
(
NS_WARN_IF
(
!
aAttribute
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
newContainerElement
=
InsertContainerWithTransaction
(
aContent
aProperty
aAttribute
?
*
aAttribute
:
*
nsGkAtoms
:
:
_empty
aValue
)
;
NS_WARNING_ASSERTION
(
newContainerElement
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
newContainerElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNode
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIContent
>
previousSibling
=
aNode
.
GetPreviousSibling
(
)
nextSibling
=
aNode
.
GetNextSibling
(
)
;
if
(
NS_WARN_IF
(
!
aNode
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
OwningNonNull
<
nsINode
>
parent
=
*
aNode
.
GetParentNode
(
)
;
if
(
aNode
.
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
aNode
.
AsElement
(
)
)
&
aProperty
aAttribute
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
rv
;
}
}
if
(
aNode
.
GetParentNode
(
)
)
{
nsresult
rv
=
SetInlinePropertyOnNodeImpl
(
aNode
aProperty
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
previousSibling
&
&
previousSibling
-
>
GetParentNode
(
)
!
=
parent
)
|
|
NS_WARN_IF
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parent
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
nodesToSet
;
for
(
nsIContent
*
content
=
previousSibling
?
previousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
content
&
&
content
!
=
nextSibling
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
nodesToSet
.
AppendElement
(
*
content
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
nodesToSet
)
{
nsresult
rv
=
SetInlinePropertyOnNodeImpl
(
MOZ_KnownLive
(
content
)
aProperty
aAttribute
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
SplitRangeOffResult
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAtRangeEdges
(
const
EditorDOMPoint
&
aStartOfRange
const
EditorDOMPoint
&
aEndOfRange
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndOfRange
.
IsSet
(
)
)
)
{
return
SplitRangeOffResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
startOfRange
(
aStartOfRange
)
;
EditorDOMPoint
endOfRange
(
aEndOfRange
)
;
SplitNodeResult
resultAtStart
(
NS_ERROR_NOT_INITIALIZED
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
endOfRange
)
;
resultAtStart
=
SplitAncestorStyledInlineElementsAt
(
startOfRange
aProperty
aAttribute
)
;
if
(
resultAtStart
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
SplitRangeOffResult
(
resultAtStart
.
Rv
(
)
)
;
}
if
(
resultAtStart
.
Handled
(
)
)
{
startOfRange
=
resultAtStart
.
SplitPoint
(
)
;
if
(
!
startOfRange
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
didn
'
t
return
"
"
split
point
"
)
;
return
SplitRangeOffResult
(
NS_ERROR_FAILURE
)
;
}
}
}
SplitNodeResult
resultAtEnd
(
NS_ERROR_NOT_INITIALIZED
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
startOfRange
)
;
resultAtEnd
=
SplitAncestorStyledInlineElementsAt
(
endOfRange
aProperty
aAttribute
)
;
if
(
resultAtEnd
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
SplitRangeOffResult
(
resultAtEnd
.
Rv
(
)
)
;
}
if
(
resultAtEnd
.
Handled
(
)
)
{
endOfRange
=
resultAtEnd
.
SplitPoint
(
)
;
if
(
!
endOfRange
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
didn
'
t
return
"
"
split
point
"
)
;
return
SplitRangeOffResult
(
NS_ERROR_FAILURE
)
;
}
}
}
return
SplitRangeOffResult
(
startOfRange
resultAtStart
endOfRange
resultAtEnd
)
;
}
SplitNodeResult
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
const
EditorDOMPoint
&
aPointToSplit
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
if
(
NS_WARN_IF
(
!
aPointToSplit
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
bool
useCSS
=
aProperty
!
=
nsGkAtoms
:
:
tt
|
|
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfParents
;
for
(
nsIContent
*
content
:
aPointToSplit
.
GetContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
!
content
-
>
GetParent
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
-
>
GetParent
(
)
EditorType
:
:
HTML
)
)
{
break
;
}
arrayOfParents
.
AppendElement
(
*
content
)
;
}
SplitNodeResult
result
(
aPointToSplit
)
;
MOZ_ASSERT
(
!
result
.
Handled
(
)
)
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfParents
)
{
bool
isSetByCSS
=
false
;
if
(
useCSS
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
aProperty
aAttribute
)
)
{
nsAutoString
firstValue
;
isSetByCSS
=
CSSEditUtils
:
:
IsSpecifiedCSSEquivalentToHTMLInlineStyleSet
(
*
content
aProperty
aAttribute
firstValue
)
;
}
if
(
!
isSetByCSS
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
if
(
aProperty
)
{
if
(
!
content
-
>
IsHTMLElement
(
aProperty
)
&
&
!
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
content
)
)
)
{
continue
;
}
}
else
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
*
content
-
>
AsElement
(
)
)
)
{
continue
;
}
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
content
)
result
.
SplitPoint
(
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
;
}
MOZ_ASSERT
(
splitNodeResult
.
Handled
(
)
)
;
result
=
SplitNodeResult
(
splitNodeResult
.
GetPreviousNode
(
)
splitNodeResult
.
GetNextNode
(
)
)
;
MOZ_ASSERT
(
result
.
Handled
(
)
)
;
}
return
result
;
}
EditResult
HTMLEditor
:
:
ClearStyleAt
(
const
EditorDOMPoint
&
aPoint
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditResult
(
NS_ERROR_INVALID_ARG
)
;
}
SplitNodeResult
splitResult
=
SplitAncestorStyledInlineElementsAt
(
aPoint
aProperty
aAttribute
)
;
if
(
splitResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
EditResult
(
splitResult
.
Rv
(
)
)
;
}
if
(
!
splitResult
.
Handled
(
)
)
{
return
EditResult
(
aPoint
)
;
}
if
(
splitResult
.
GetPreviousNode
(
)
&
&
IsEmptyNode
(
*
splitResult
.
GetPreviousNode
(
)
false
true
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetPreviousNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditResult
(
rv
)
;
}
}
if
(
!
splitResult
.
GetNextNode
(
)
)
{
MOZ_ASSERT
(
IsCSSEnabled
(
)
)
;
return
EditResult
(
aPoint
)
;
}
nsIContent
*
firstLeafChildOfNextNode
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
splitResult
.
GetNextNode
(
)
ChildBlockBoundary
:
:
Ignore
)
;
EditorDOMPoint
atStartOfNextNode
(
firstLeafChildOfNextNode
?
firstLeafChildOfNextNode
:
splitResult
.
GetNextNode
(
)
0
)
;
RefPtr
<
HTMLBRElement
>
brElement
;
if
(
!
atStartOfNextNode
.
IsInContentNode
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
atStartOfNextNode
.
ContainerAsContent
(
)
)
)
{
brElement
=
HTMLBRElement
:
:
FromNode
(
atStartOfNextNode
.
GetContainer
(
)
)
;
if
(
!
atStartOfNextNode
.
GetContainerParentAsContent
(
)
)
{
NS_WARNING
(
"
atStartOfNextNode
was
in
an
orphan
node
"
)
;
return
EditResult
(
NS_ERROR_FAILURE
)
;
}
atStartOfNextNode
.
Set
(
atStartOfNextNode
.
GetContainerParent
(
)
0
)
;
}
SplitNodeResult
splitResultAtStartOfNextNode
=
SplitAncestorStyledInlineElementsAt
(
atStartOfNextNode
aProperty
aAttribute
)
;
if
(
splitResultAtStartOfNextNode
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
EditResult
(
splitResultAtStartOfNextNode
.
Rv
(
)
)
;
}
if
(
splitResultAtStartOfNextNode
.
Handled
(
)
&
&
splitResultAtStartOfNextNode
.
GetNextNode
(
)
&
&
IsEmptyNode
(
*
splitResultAtStartOfNextNode
.
GetNextNode
(
)
false
true
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetNextNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditResult
(
rv
)
;
}
}
if
(
NS_WARN_IF
(
!
splitResultAtStartOfNextNode
.
Handled
(
)
)
|
|
!
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
)
{
return
EditResult
(
EditorDOMPoint
(
splitResult
.
SplitPoint
(
)
.
GetContainer
(
)
splitResultAtStartOfNextNode
.
SplitPoint
(
)
.
Offset
(
)
)
)
;
}
nsIContent
*
firstLeafChildOfPreviousNode
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
ChildBlockBoundary
:
:
Ignore
)
;
EditorDOMPoint
pointToPutCaret
(
firstLeafChildOfPreviousNode
?
firstLeafChildOfPreviousNode
:
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
0
)
;
if
(
brElement
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
brElement
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
EditResult
(
rv
)
;
}
pointToPutCaret
.
Set
(
pointToPutCaret
.
GetContainer
(
)
0
)
;
}
if
(
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
-
>
IsElement
(
)
)
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
-
>
AsElement
(
)
)
aProperty
aAttribute
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
EditResult
(
rv
)
;
}
}
return
EditResult
(
pointToPutCaret
)
;
}
nsresult
HTMLEditor
:
:
RemoveStyleInside
(
Element
&
aElement
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
RefPtr
<
nsIContent
>
child
=
aElement
.
GetFirstChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
nextSibling
=
child
-
>
GetNextSibling
(
)
;
if
(
child
-
>
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
aProperty
aAttribute
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
rv
;
}
}
child
=
ToRefPtr
(
std
:
:
move
(
nextSibling
)
)
;
}
bool
removeHTMLStyle
=
false
;
if
(
aProperty
)
{
removeHTMLStyle
=
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aProperty
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
&
aElement
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
name
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aElement
)
)
;
}
else
if
(
EditorUtils
:
:
IsEditableContent
(
aElement
EditorType
:
:
HTML
)
)
{
removeHTMLStyle
=
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
aElement
)
;
}
if
(
removeHTMLStyle
)
{
if
(
!
aAttribute
)
{
if
(
aProperty
&
&
(
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
)
)
{
RefPtr
<
Element
>
spanElement
=
InsertContainerWithTransaction
(
aElement
*
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
spanElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
nsGkAtoms
:
:
span
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
style
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CloneAttributeWithTransaction
(
nsGkAtoms
:
:
style
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
_class
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CloneAttributeWithTransaction
(
nsGkAtoms
:
:
_class
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
aElement
.
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
if
(
IsOnlyAttribute
(
&
aElement
aAttribute
)
)
{
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
aElement
*
aAttribute
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aElement
aProperty
aAttribute
)
&
&
CSSEditUtils
:
:
HaveSpecifiedCSSEquivalentStyles
(
aElement
aProperty
aAttribute
)
)
{
if
(
nsCOMPtr
<
nsStyledElement
>
styledElement
=
do_QueryInterface
(
&
aElement
)
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
*
styledElement
aProperty
aAttribute
nullptr
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
span
nsGkAtoms
:
:
font
)
&
&
!
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
aElement
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
but
ignored
"
)
;
}
}
if
(
aProperty
=
=
nsGkAtoms
:
:
font
&
&
aAttribute
=
=
nsGkAtoms
:
:
size
&
&
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
)
)
{
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsOnlyAttribute
(
const
Element
*
aElement
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
aElement
)
;
uint32_t
attrCount
=
aElement
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
aElement
-
>
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
false
;
}
if
(
name
-
>
LocalName
(
)
!
=
aAttribute
)
{
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
u
"
_moz
"
_ns
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
{
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
newRangeStart
(
aRange
.
StartRef
(
)
)
;
for
(
Element
*
element
:
aRange
.
GetStartContainer
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
continue
;
}
newRangeStart
.
Set
(
element
)
;
break
;
}
if
(
!
newRangeStart
.
GetContainerAsContent
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
reached
root
"
"
element
from
start
container
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newRangeEnd
(
aRange
.
EndRef
(
)
)
;
for
(
Element
*
element
:
aRange
.
GetEndContainer
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
continue
;
}
newRangeEnd
.
SetAfter
(
element
)
;
break
;
}
if
(
!
newRangeEnd
.
GetContainerAsContent
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
reached
root
"
"
element
from
end
container
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newRangeStart
=
=
aRange
.
StartRef
(
)
&
&
newRangeEnd
=
=
aRange
.
EndRef
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
newRangeStart
.
ToRawRangeBoundary
(
)
newRangeEnd
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
PromoteInlineRange
(
nsRange
&
aRange
)
{
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
newRangeStart
(
aRange
.
StartRef
(
)
)
;
for
(
nsIContent
*
content
:
aRange
.
GetStartContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
MOZ_ASSERT
(
newRangeStart
.
GetContainer
(
)
=
=
content
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
!
IsStartOfContainerOrBeforeFirstEditableChild
(
newRangeStart
)
)
{
break
;
}
newRangeStart
.
Set
(
content
)
;
}
if
(
!
newRangeStart
.
GetContainerAsContent
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
reached
root
element
from
start
"
"
container
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newRangeEnd
(
aRange
.
EndRef
(
)
)
;
for
(
nsIContent
*
content
:
aRange
.
GetEndContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
MOZ_ASSERT
(
newRangeEnd
.
GetContainer
(
)
=
=
content
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
!
IsEndOfContainerOrEqualsOrAfterLastEditableChild
(
newRangeEnd
)
)
{
break
;
}
newRangeEnd
.
SetAfter
(
content
)
;
}
if
(
!
newRangeEnd
.
GetContainerAsContent
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
reached
root
element
from
end
"
"
container
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newRangeStart
=
=
aRange
.
StartRef
(
)
&
&
newRangeEnd
=
=
aRange
.
EndRef
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
newRangeStart
.
ToRawRangeBoundary
(
)
newRangeEnd
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
IsStartOfContainerOrBeforeFirstEditableChild
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
)
{
return
true
;
}
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
false
;
}
nsIContent
*
firstEditableChild
=
GetFirstEditableChild
(
*
aPoint
.
GetContainer
(
)
)
;
if
(
!
firstEditableChild
)
{
return
true
;
}
return
EditorRawDOMPoint
(
firstEditableChild
)
.
Offset
(
)
>
=
aPoint
.
Offset
(
)
;
}
bool
HTMLEditor
:
:
IsEndOfContainerOrEqualsOrAfterLastEditableChild
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
IsEndOfContainer
(
)
)
{
return
true
;
}
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
false
;
}
nsIContent
*
lastEditableChild
=
GetLastEditableChild
(
*
aPoint
.
GetContainer
(
)
)
;
if
(
!
lastEditableChild
)
{
return
true
;
}
return
EditorRawDOMPoint
(
lastEditableChild
)
.
Offset
(
)
<
aPoint
.
Offset
(
)
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyBase
(
nsAtom
&
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
*
aAny
=
false
;
*
aAll
=
true
;
*
aFirst
=
false
;
bool
first
=
true
;
bool
isCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
range
)
{
bool
firstNodeInRange
=
true
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
collapsedNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
collapsedNode
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isSet
theSetting
;
nsString
tOutString
;
if
(
aAttribute
)
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aHTMLProperty
aAttribute
&
tOutString
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
}
else
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aHTMLProperty
)
;
}
if
(
isSet
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
theSetting
;
return
NS_OK
;
}
if
(
collapsedNode
-
>
IsContent
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
collapsedNode
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
tOutString
.
Assign
(
*
aValue
)
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
MOZ_KnownLive
(
*
collapsedNode
-
>
AsContent
(
)
)
&
aHTMLProperty
aAttribute
tOutString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
NS_OK
;
}
isSet
=
IsTextPropertySetByContent
(
collapsedNode
&
aHTMLProperty
aAttribute
aValue
outValue
)
;
*
aFirst
=
*
aAny
=
*
aAll
=
isSet
;
return
NS_OK
;
}
nsAutoString
firstValue
theValue
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
PostContentIterator
postOrderIter
;
DebugOnly
<
nsresult
>
rvIgnored
=
postOrderIter
.
Init
(
range
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
initialize
post
-
order
content
iterator
"
)
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
!
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
content
-
>
IsText
(
)
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
IsEmptyTextNode
(
*
content
)
)
)
{
continue
;
}
if
(
content
-
>
GetAsText
(
)
)
{
if
(
!
isCollapsed
&
&
first
&
&
firstNodeInRange
)
{
firstNodeInRange
=
false
;
if
(
range
-
>
StartOffset
(
)
=
=
content
-
>
Length
(
)
)
{
continue
;
}
}
else
if
(
content
=
=
endNode
&
&
!
endOffset
)
{
continue
;
}
}
else
if
(
content
-
>
IsElement
(
)
)
{
continue
;
}
bool
isSet
=
false
;
bool
useTextDecoration
=
&
aHTMLProperty
=
=
nsGkAtoms
:
:
u
|
|
&
aHTMLProperty
=
=
nsGkAtoms
:
:
strike
;
if
(
first
)
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
firstValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
content
&
aHTMLProperty
aAttribute
firstValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aHTMLProperty
aAttribute
aValue
&
firstValue
)
;
}
*
aFirst
=
isSet
;
first
=
false
;
if
(
outValue
)
{
*
outValue
=
firstValue
;
}
}
else
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
theValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
content
&
aHTMLProperty
aAttribute
theValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aHTMLProperty
aAttribute
aValue
&
theValue
)
;
}
if
(
firstValue
!
=
theValue
&
&
(
!
useTextDecoration
|
|
*
aFirst
!
=
isSet
)
)
{
*
aAll
=
false
;
}
}
if
(
isSet
)
{
*
aAny
=
true
;
}
else
{
*
aAll
=
false
;
}
}
}
if
(
!
*
aAny
)
{
*
aAll
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlineProperty
(
const
nsAString
&
aHTMLProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aHTMLProperty
)
;
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
nsresult
rv
=
GetInlineProperty
(
property
MOZ_KnownLive
(
attribute
)
aValue
aFirst
aAny
aAll
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlineProperty
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlineProperty
(
nsAtom
*
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
const
{
if
(
NS_WARN_IF
(
!
aHTMLProperty
)
|
|
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
!
aValue
.
IsEmpty
(
)
?
&
aValue
:
nullptr
;
nsresult
rv
=
GetInlinePropertyBase
(
*
aHTMLProperty
aAttribute
val
aFirst
aAny
aAll
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
const
nsAString
&
aHTMLProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aHTMLProperty
)
;
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
nsresult
rv
=
GetInlinePropertyWithAttrValue
(
property
MOZ_KnownLive
(
attribute
)
aValue
aFirst
aAny
aAll
outValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
nsAtom
*
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
if
(
NS_WARN_IF
(
!
aHTMLProperty
)
|
|
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
!
aValue
.
IsEmpty
(
)
?
&
aValue
:
nullptr
;
nsresult
rv
=
GetInlinePropertyBase
(
*
aHTMLProperty
aAttribute
val
aFirst
aAny
aAll
&
outValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveAllInlinePropertiesAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAllInlineStyleProperties
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveAllTextProperties
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
rv
=
RemoveInlinePropertyInternal
(
nullptr
nullptr
RemoveRelatedElements
:
:
No
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nullptr
"
"
nullptr
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyAsAction
(
nsStaticAtom
&
aHTMLProperty
nsStaticAtom
*
aAttribute
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aHTMLProperty
aAttribute
false
)
aPrincipal
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
EmptyString
(
)
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
EmptyString
(
)
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
EmptyString
(
)
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RemoveInlinePropertyInternal
(
&
aHTMLProperty
aAttribute
RemoveRelatedElements
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
"
"
RemoveRelatedElements
:
:
Yes
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
)
{
nsStaticAtom
*
property
=
NS_GetStaticAtom
(
aProperty
)
;
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
false
)
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
EmptyString
(
)
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
EmptyString
(
)
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
EmptyString
(
)
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RemoveInlinePropertyInternal
(
MOZ_KnownLive
(
property
)
MOZ_KnownLive
(
attribute
)
RemoveRelatedElements
:
:
No
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
"
"
RemoveRelatedElements
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsStaticAtom
*
aProperty
nsStaticAtom
*
aAttribute
RemoveRelatedElements
aRemoveRelatedElements
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
struct
HTMLStyle
final
{
nsStaticAtom
*
mProperty
=
nullptr
;
nsStaticAtom
*
mAttribute
=
nullptr
;
explicit
HTMLStyle
(
nsStaticAtom
*
aProperty
nsStaticAtom
*
aAttribute
=
nullptr
)
:
mProperty
(
aProperty
)
mAttribute
(
aAttribute
)
{
}
}
;
AutoTArray
<
HTMLStyle
3
>
removeStyles
;
if
(
aRemoveRelatedElements
=
=
RemoveRelatedElements
:
:
Yes
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
b
)
{
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
strong
)
)
;
}
else
if
(
aProperty
=
=
nsGkAtoms
:
:
i
)
{
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
em
)
)
;
}
else
if
(
aProperty
=
=
nsGkAtoms
:
:
strike
)
{
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
s
)
)
;
}
else
if
(
aProperty
=
=
nsGkAtoms
:
:
font
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
big
)
)
;
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
small
)
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
face
&
&
!
GetEditActionPrincipal
(
)
)
{
removeStyles
.
AppendElement
(
HTMLStyle
(
nsGkAtoms
:
:
tt
)
)
;
}
}
}
removeStyles
.
AppendElement
(
HTMLStyle
(
aProperty
aAttribute
)
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
if
(
removeStyles
[
0
]
.
mProperty
)
{
for
(
HTMLStyle
&
style
:
removeStyles
)
{
MOZ_ASSERT
(
style
.
mProperty
)
;
if
(
style
.
mProperty
=
=
nsGkAtoms
:
:
href
|
|
style
.
mProperty
=
=
nsGkAtoms
:
:
name
)
{
mTypeInState
-
>
ClearProp
(
nsGkAtoms
:
:
a
nullptr
)
;
}
else
{
mTypeInState
-
>
ClearProp
(
style
.
mProperty
style
.
mAttribute
)
;
}
}
}
else
{
mTypeInState
-
>
ClearAllProps
(
)
;
}
return
NS_OK
;
}
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
for
(
HTMLStyle
&
style
:
removeStyles
)
{
AutoSelectionRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
if
(
style
.
mProperty
=
=
nsGkAtoms
:
:
name
)
{
nsresult
rv
=
PromoteRangeIfStartsOrEndsInNamedAnchor
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
return
rv
;
}
}
SplitRangeOffResult
splitRangeOffResult
=
SplitAncestorStyledInlineElementsAtRangeEdges
(
EditorDOMPoint
(
range
-
>
StartRef
(
)
)
EditorDOMPoint
(
range
-
>
EndRef
(
)
)
MOZ_KnownLive
(
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
)
;
if
(
splitRangeOffResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAtRangeEdges
(
)
"
"
failed
"
)
;
return
splitRangeOffResult
.
Rv
(
)
;
}
const
EditorDOMPoint
&
startOfRange
(
splitRangeOffResult
.
SplitPointAtStart
(
)
)
;
const
EditorDOMPoint
&
endOfRange
(
splitRangeOffResult
.
SplitPointAtEnd
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
nsresult
rv
=
range
-
>
SetStartAndEnd
(
startOfRange
.
ToRawRangeBoundary
(
)
endOfRange
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
&
&
startOfRange
.
IsInTextNode
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
continue
;
}
arrayOfContents
.
AppendElement
(
*
startOfRange
.
ContainerAsText
(
)
)
;
}
else
if
(
startOfRange
.
IsInTextNode
(
)
&
&
endOfRange
.
IsInTextNode
(
)
&
&
startOfRange
.
GetContainer
(
)
-
>
GetNextSibling
(
)
=
=
endOfRange
.
GetContainer
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
startOfRange
.
ContainerAsText
(
)
)
;
}
if
(
EditorUtils
:
:
IsEditableContent
(
*
endOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
endOfRange
.
ContainerAsText
(
)
)
;
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
continue
;
}
}
else
{
if
(
startOfRange
.
IsInTextNode
(
)
&
&
!
startOfRange
.
IsStartOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
startOfRange
.
ContainerAsText
(
)
)
;
}
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startOfRange
.
GetContainer
(
)
!
=
endOfRange
.
GetContainer
(
)
&
&
endOfRange
.
IsInTextNode
(
)
&
&
!
endOfRange
.
IsEndOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
endOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
endOfRange
.
ContainerAsText
(
)
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
if
(
content
-
>
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
MOZ_KnownLive
(
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
rv
;
}
}
bool
isRemovable
=
IsRemovableParentStyleWithNewSpanElement
(
MOZ_KnownLive
(
content
)
MOZ_KnownLive
(
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
isRemovable
)
{
continue
;
}
if
(
!
content
-
>
IsText
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
content
)
MOZ_KnownLive
(
*
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
-
moz
-
editor
-
invert
-
value
)
"
"
failed
but
ignored
"
)
;
continue
;
}
uint32_t
startOffset
=
content
=
=
startOfRange
.
GetContainer
(
)
?
startOfRange
.
Offset
(
)
:
0
;
uint32_t
endOffset
=
content
=
=
endOfRange
.
GetContainer
(
)
?
endOfRange
.
Offset
(
)
:
content
-
>
Length
(
)
;
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
content
-
>
AsText
(
)
)
startOffset
endOffset
MOZ_KnownLive
(
*
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
"
)
;
return
rv
;
}
}
if
(
style
.
mProperty
&
&
CSSEditUtils
:
:
IsCSSInvertible
(
*
style
.
mProperty
style
.
mAttribute
)
)
{
AutoTArray
<
OwningNonNull
<
Text
>
32
>
leafTextNodes
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
if
(
content
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
content
-
>
AsElement
(
)
leafTextNodes
)
;
}
}
for
(
OwningNonNull
<
Text
>
&
textNode
:
leafTextNodes
)
{
bool
isRemovable
=
IsRemovableParentStyleWithNewSpanElement
(
MOZ_KnownLive
(
textNode
)
MOZ_KnownLive
(
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
isRemovable
)
{
continue
;
}
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
textNode
)
0
textNode
-
>
TextLength
(
)
MOZ_KnownLive
(
*
style
.
mProperty
)
MOZ_KnownLive
(
style
.
mAttribute
)
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
"
)
;
return
rv
;
}
}
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
bool
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
nsIContent
&
aContent
nsAtom
*
aHTMLProperty
nsAtom
*
aAttribute
)
const
{
if
(
!
aHTMLProperty
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSInvertible
(
*
aHTMLProperty
aAttribute
)
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
aHTMLProperty
aAttribute
)
)
{
return
false
;
}
nsAutoString
emptyString
;
bool
isSet
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aContent
aHTMLProperty
aAttribute
emptyString
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
false
:
isSet
;
}
void
HTMLEditor
:
:
CollectEditableLeafTextNodes
(
Element
&
aElement
nsTArray
<
OwningNonNull
<
Text
>
>
&
aLeafTextNodes
)
const
{
for
(
nsIContent
*
child
=
aElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
child
-
>
AsElement
(
)
aLeafTextNodes
)
;
continue
;
}
if
(
child
-
>
IsText
(
)
)
{
aLeafTextNodes
.
AppendElement
(
*
child
-
>
AsText
(
)
)
;
}
}
}
nsresult
HTMLEditor
:
:
IncreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIncrementFontSize
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RelativeFontChange
(
FontSize
:
:
incr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RelativeFontChange
(
FontSize
:
:
incr
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DecreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDecrementFontSize
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RelativeFontChange
(
FontSize
:
:
decr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RelativeFontChange
(
FontSize
:
:
decr
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RelativeFontChange
(
FontSize
aDir
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsAtom
&
atom
=
aDir
=
=
FontSize
:
:
incr
?
*
nsGkAtoms
:
:
big
:
*
nsGkAtoms
:
:
small
;
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
const
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
|
|
NS_WARN_IF
(
!
firstRange
-
>
GetStartContainer
(
)
)
)
{
return
NS_OK
;
}
OwningNonNull
<
nsINode
>
selectedNode
=
*
firstRange
-
>
GetStartContainer
(
)
;
if
(
selectedNode
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
!
selectedNode
-
>
GetParentNode
(
)
)
)
{
return
NS_OK
;
}
selectedNode
=
*
selectedNode
-
>
GetParentNode
(
)
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
selectedNode
atom
)
)
{
return
NS_OK
;
}
mTypeInState
-
>
SetProp
(
&
atom
nullptr
EmptyString
(
)
)
;
return
NS_OK
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoSelectionRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
MOZ_ASSERT
(
startNode
)
;
MOZ_ASSERT
(
endNode
)
;
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsText
(
)
)
{
nsresult
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
startNode
-
>
GetAsText
(
)
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
else
{
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfContents
;
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
if
(
NS_WARN_IF
(
!
subtreeIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
nsIContent
>
content
=
*
subtreeIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
content
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aDir
=
=
FontSize
:
:
incr
?
+
1
:
-
1
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnNode
(
)
failed
"
)
;
return
rv
;
}
}
}
if
(
startNode
-
>
IsText
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
startNode
-
>
AsText
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
startNode
-
>
AsText
(
)
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
if
(
endNode
-
>
IsText
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
endNode
-
>
AsText
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
endNode
-
>
AsText
(
)
)
0
range
-
>
EndOffset
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
FontSize
aDir
Text
&
aTextNode
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
!
aTextNode
.
GetParentNode
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aTextNode
.
GetParentNode
(
)
*
nsGkAtoms
:
:
big
)
)
{
return
NS_OK
;
}
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aTextNode
.
Length
(
)
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aTextNode
;
EditorDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
nsAtom
*
nodeType
=
aDir
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorDOMPoint
(
sibling
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
textNodeForTheRange
MOZ_KnownLive
(
*
nodeType
)
)
;
NS_WARNING_ASSERTION
(
newElement
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
newElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeHelper
(
int32_t
aSizeChange
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
font
)
&
&
aNode
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
size
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnNode
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeHelper
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnNode
(
int32_t
aSizeChange
nsIContent
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsAtom
*
atom
;
if
(
aSizeChange
=
=
1
)
{
atom
=
nsGkAtoms
:
:
big
;
}
else
{
atom
=
nsGkAtoms
:
:
small
;
}
if
(
(
aSizeChange
=
=
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
|
|
(
aSizeChange
=
=
-
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
big
)
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeHelper
(
)
failed
"
)
;
return
rv
;
}
rv
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
aNode
-
>
AsElement
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
atom
*
aNode
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeHelper
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
aNode
*
sibling
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
sibling
=
GetNextHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNodeWithTransaction
(
*
aNode
EditorDOMPoint
(
sibling
0
)
)
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
aNode
MOZ_KnownLive
(
*
atom
)
)
;
NS_WARNING_ASSERTION
(
newElement
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
newElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnNode
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontFaceState
(
bool
*
aMixed
nsAString
&
outFace
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
outFace
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
nullptr
&
first
&
any
&
all
&
outFace
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
tt
nullptr
nullptr
&
first
&
any
&
all
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
tt
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
outFace
.
AssignLiteral
(
"
tt
"
)
;
}
if
(
!
any
)
{
outFace
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetFontColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
aOutColor
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
nullptr
&
first
&
any
&
all
&
aOutColor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
if
(
!
any
)
{
aOutColor
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetIsCSSEnabled
(
bool
*
aIsCSSEnabled
)
{
*
aIsCSSEnabled
=
IsCSSEnabled
(
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
Element
&
aElement
)
{
return
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
_class
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
id
)
;
}
}
