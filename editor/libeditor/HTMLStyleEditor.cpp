#
include
"
ErrorList
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
AutoRangeArray
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
PendingStyles
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
template
nsresult
HTMLEditor
:
:
SetInlinePropertiesAsSubAction
(
const
AutoTArray
<
EditorInlineStyleAndValue
1
>
&
aStylesToSet
)
;
template
nsresult
HTMLEditor
:
:
SetInlinePropertiesAsSubAction
(
const
AutoTArray
<
EditorInlineStyleAndValue
32
>
&
aStylesToSet
)
;
nsresult
HTMLEditor
:
:
SetInlinePropertyAsAction
(
nsStaticAtom
&
aProperty
nsStaticAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aProperty
aAttribute
true
)
aPrincipal
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
No
__FUNCTION__
)
;
nsStaticAtom
*
property
=
&
aProperty
;
nsStaticAtom
*
attribute
=
aAttribute
;
nsString
value
(
aValue
)
;
AutoTArray
<
EditorInlineStyle
1
>
stylesToRemove
;
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
stylesToRemove
.
AppendElement
(
EditorInlineStyle
(
*
nsGkAtoms
:
:
sub
)
)
;
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
stylesToRemove
.
AppendElement
(
EditorInlineStyle
(
*
nsGkAtoms
:
:
sup
)
)
;
}
else
if
(
!
aPrincipal
)
{
if
(
&
aProperty
=
=
nsGkAtoms
:
:
tt
)
{
stylesToRemove
.
AppendElement
(
EditorInlineStyle
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
)
;
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
font
&
&
aAttribute
=
=
nsGkAtoms
:
:
face
)
{
if
(
!
value
.
LowerCaseEqualsASCII
(
"
tt
"
)
)
{
stylesToRemove
.
AppendElement
(
EditorInlineStyle
(
*
nsGkAtoms
:
:
tt
)
)
;
}
else
{
stylesToRemove
.
AppendElement
(
EditorInlineStyle
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
)
;
property
=
nsGkAtoms
:
:
tt
;
attribute
=
nullptr
;
value
.
Truncate
(
)
;
}
}
}
if
(
!
stylesToRemove
.
IsEmpty
(
)
)
{
nsresult
rv
=
RemoveInlinePropertiesAsSubAction
(
stylesToRemove
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
rv
;
}
}
AutoTArray
<
EditorInlineStyleAndValue
1
>
styleToSet
;
styleToSet
.
AppendElement
(
attribute
?
EditorInlineStyleAndValue
(
*
property
*
attribute
std
:
:
move
(
value
)
)
:
EditorInlineStyleAndValue
(
*
property
)
)
;
rv
=
SetInlinePropertiesAsSubAction
(
styleToSet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
nsStaticAtom
*
property
=
NS_GetStaticAtom
(
aProperty
)
;
if
(
NS_WARN_IF
(
!
property
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
true
)
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoTArray
<
EditorInlineStyleAndValue
1
>
styleToSet
;
styleToSet
.
AppendElement
(
attribute
?
EditorInlineStyleAndValue
(
*
property
*
attribute
aValue
)
:
EditorInlineStyleAndValue
(
*
property
)
)
;
rv
=
SetInlinePropertiesAsSubAction
(
styleToSet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
template
<
size_t
N
>
nsresult
HTMLEditor
:
:
SetInlinePropertiesAsSubAction
(
const
AutoTArray
<
EditorInlineStyleAndValue
N
>
&
aStylesToSet
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aStylesToSet
.
IsEmpty
(
)
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
mPendingStylesToApplyToNewContent
-
>
PreserveStyles
(
aStylesToSet
)
;
return
NS_OK
;
}
if
(
IsInPlaintextMode
(
)
)
{
return
NS_OK
;
}
{
Result
<
EditActionResult
nsresult
>
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
if
(
result
.
inspect
(
)
.
Canceled
(
)
)
{
return
NS_OK
;
}
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
for
(
const
EditorInlineStyleAndValue
&
styleToSet
:
aStylesToSet
)
{
MOZ_ALWAYS_TRUE
(
selectionRanges
.
SaveAndTrackRanges
(
*
this
)
)
;
for
(
const
OwningNonNull
<
nsRange
>
&
selectionRange
:
selectionRanges
.
Ranges
(
)
)
{
nsresult
rv
=
PromoteInlineRange
(
*
selectionRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
return
rv
;
}
EditorDOMRange
range
(
selectionRange
)
;
if
(
NS_WARN_IF
(
!
range
.
IsPositioned
(
)
)
)
{
continue
;
}
if
(
range
.
InSameContainer
(
)
&
&
range
.
StartRef
(
)
.
IsInTextNode
(
)
)
{
Result
<
SplitRangeOffFromNodeResult
nsresult
>
wrapTextInStyledElementResult
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
range
.
StartRef
(
)
.
Offset
(
)
range
.
EndRef
(
)
.
Offset
(
)
MOZ_KnownLive
(
styleToSet
.
HTMLPropertyRef
(
)
)
MOZ_KnownLive
(
styleToSet
.
mAttribute
)
styleToSet
.
mAttributeValue
)
;
if
(
MOZ_UNLIKELY
(
wrapTextInStyledElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
)
failed
"
)
;
return
wrapTextInStyledElementResult
.
unwrapErr
(
)
;
}
wrapTextInStyledElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContentsAroundRange
;
{
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
range
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContentsAroundRange
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
}
if
(
range
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
Result
<
SplitRangeOffFromNodeResult
nsresult
>
wrapTextInStyledElementResult
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
range
.
StartRef
(
)
.
Offset
(
)
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextDataLength
(
)
MOZ_KnownLive
(
styleToSet
.
HTMLPropertyRef
(
)
)
MOZ_KnownLive
(
styleToSet
.
mAttribute
)
styleToSet
.
mAttributeValue
)
;
if
(
MOZ_UNLIKELY
(
wrapTextInStyledElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
)
failed
"
)
;
return
wrapTextInStyledElementResult
.
unwrapErr
(
)
;
}
wrapTextInStyledElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
for
(
auto
&
content
:
arrayOfContentsAroundRange
)
{
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
content
)
MOZ_KnownLive
(
styleToSet
.
HTMLPropertyRef
(
)
)
MOZ_KnownLive
(
styleToSet
.
mAttribute
)
styleToSet
.
mAttributeValue
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
setStyleResult
.
unwrapErr
(
)
;
}
}
if
(
range
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
range
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
Result
<
SplitRangeOffFromNodeResult
nsresult
>
wrapTextInStyledElementResult
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
range
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
)
0
range
.
EndRef
(
)
.
Offset
(
)
MOZ_KnownLive
(
styleToSet
.
HTMLPropertyRef
(
)
)
MOZ_KnownLive
(
styleToSet
.
mAttribute
)
styleToSet
.
mAttributeValue
)
;
if
(
MOZ_UNLIKELY
(
wrapTextInStyledElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
)
failed
"
)
;
return
wrapTextInStyledElementResult
.
unwrapErr
(
)
;
}
wrapTextInStyledElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
MOZ_ASSERT
(
selectionRanges
.
HasSavedRanges
(
)
)
;
selectionRanges
.
RestoreFromSavedRanges
(
)
;
}
MOZ_ASSERT
(
!
selectionRanges
.
HasSavedRanges
(
)
)
;
nsresult
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
rv
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
Element
&
aElement
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
)
{
MOZ_ASSERT
(
aProperty
)
;
MOZ_ASSERT_IF
(
aAttribute
aValue
)
;
if
(
aElement
.
IsHTMLElement
(
aProperty
)
&
&
!
aElement
.
GetAttrCount
(
)
&
&
!
aAttribute
)
{
return
true
;
}
if
(
!
aElement
.
GetAttrCount
(
)
&
&
(
(
aProperty
=
=
nsGkAtoms
:
:
b
&
&
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
strong
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
i
&
&
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
em
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
strike
&
&
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
s
)
)
)
)
{
return
true
;
}
if
(
aAttribute
)
{
nsString
attrValue
;
if
(
aElement
.
IsHTMLElement
(
aProperty
)
&
&
IsOnlyAttribute
(
&
aElement
aAttribute
)
&
&
aElement
.
GetAttr
(
kNameSpaceID_None
aAttribute
attrValue
)
&
&
attrValue
.
Equals
(
*
aValue
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aElement
aProperty
aAttribute
)
|
|
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
|
|
aElement
.
GetAttrCount
(
)
!
=
1
|
|
!
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
)
{
return
false
;
}
RefPtr
<
Element
>
newSpanElement
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
if
(
!
newSpanElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
failed
"
)
;
return
false
;
}
nsStyledElement
*
styledNewSpanElement
=
nsStyledElement
:
:
FromNode
(
newSpanElement
)
;
if
(
!
styledNewSpanElement
)
{
return
false
;
}
Result
<
int32_t
nsresult
>
result
=
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithoutTransaction
(
*
this
MOZ_KnownLive
(
*
styledNewSpanElement
)
aProperty
aAttribute
aValue
)
;
if
(
result
.
isErr
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
How
did
you
destroy
this
editor
?
"
)
;
if
(
NS_WARN_IF
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
return
false
;
}
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
;
if
(
!
styledElement
)
{
return
false
;
}
return
CSSEditUtils
:
:
DoStyledElementsHaveSameStyle
(
*
styledNewSpanElement
*
styledElement
)
;
}
Result
<
SplitRangeOffFromNodeResult
nsresult
>
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
aText
.
GetParentNode
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aText
.
GetParentNode
(
)
aProperty
)
)
{
return
SplitRangeOffFromNodeResult
(
nullptr
&
aText
nullptr
)
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
SplitRangeOffFromNodeResult
(
nullptr
&
aText
nullptr
)
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aText
&
aProperty
aAttribute
)
)
{
nsAutoString
value
(
aValue
)
;
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
aText
&
aProperty
aAttribute
value
)
;
if
(
MOZ_UNLIKELY
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
propagateErr
(
)
;
}
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
)
{
return
SplitRangeOffFromNodeResult
(
nullptr
&
aText
nullptr
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
aText
aProperty
aAttribute
&
aValue
)
)
{
return
SplitRangeOffFromNodeResult
(
nullptr
&
aText
nullptr
)
;
}
SplitNodeResult
splitAtEndResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
atEnd
(
&
aText
aEndOffset
)
;
if
(
atEnd
.
IsEndOfContainer
(
)
)
{
return
SplitNodeResult
:
:
NotHandled
(
atEnd
GetSplitNodeDirection
(
)
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeWithTransaction
(
atEnd
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
;
}
if
(
MOZ_UNLIKELY
(
!
splitNodeResult
.
HasCaretPointSuggestion
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
suggest
caret
"
"
point
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
return
splitNodeResult
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
splitAtEndResult
.
isErr
(
)
)
)
{
return
Err
(
splitAtEndResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
splitAtEndResult
.
UnwrapCaretPoint
(
)
;
SplitNodeResult
splitAtStartResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
atStart
(
splitAtEndResult
.
DidSplit
(
)
?
splitAtEndResult
.
GetPreviousContent
(
)
:
&
aText
aStartOffset
)
;
if
(
atStart
.
IsStartOfContainer
(
)
)
{
return
SplitNodeResult
:
:
NotHandled
(
atStart
GetSplitNodeDirection
(
)
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeWithTransaction
(
atStart
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
;
}
if
(
MOZ_UNLIKELY
(
!
splitNodeResult
.
HasCaretPointSuggestion
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
suggest
caret
"
"
point
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
return
splitNodeResult
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
splitAtStartResult
.
isErr
(
)
)
)
{
return
Err
(
splitAtStartResult
.
unwrapErr
(
)
)
;
}
if
(
splitAtStartResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
splitAtStartResult
.
UnwrapCaretPoint
(
)
;
}
MOZ_ASSERT_IF
(
splitAtStartResult
.
DidSplit
(
)
splitAtStartResult
.
GetPreviousContent
(
)
-
>
IsText
(
)
)
;
MOZ_ASSERT_IF
(
splitAtStartResult
.
DidSplit
(
)
splitAtStartResult
.
GetNextContent
(
)
-
>
IsText
(
)
)
;
MOZ_ASSERT_IF
(
splitAtEndResult
.
DidSplit
(
)
splitAtEndResult
.
GetPreviousContent
(
)
-
>
IsText
(
)
)
;
MOZ_ASSERT_IF
(
splitAtEndResult
.
DidSplit
(
)
splitAtEndResult
.
GetNextContent
(
)
-
>
IsText
(
)
)
;
Text
*
const
leftTextNode
=
splitAtStartResult
.
DidSplit
(
)
?
Text
:
:
FromNode
(
splitAtStartResult
.
GetPreviousContent
(
)
)
:
nullptr
;
Text
*
const
middleTextNode
=
splitAtStartResult
.
DidSplit
(
)
?
Text
:
:
FromNode
(
splitAtStartResult
.
GetNextContent
(
)
)
:
(
splitAtEndResult
.
DidSplit
(
)
?
Text
:
:
FromNode
(
splitAtEndResult
.
GetPreviousContent
(
)
)
:
&
aText
)
;
Text
*
const
rightTextNode
=
splitAtEndResult
.
DidSplit
(
)
?
Text
:
:
FromNode
(
splitAtEndResult
.
GetNextContent
(
)
)
:
nullptr
;
if
(
aAttribute
)
{
nsIContent
*
sibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
*
middleTextNode
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsElement
(
)
)
{
OwningNonNull
<
Element
>
element
(
*
sibling
-
>
AsElement
(
)
)
;
Result
<
bool
nsresult
>
result
=
ElementIsGoodContainerForTheStyle
(
element
&
aProperty
aAttribute
&
aValue
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
)
failed
"
)
;
return
result
.
propagateErr
(
)
;
}
if
(
result
.
inspect
(
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveTextNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
middleTextNode
)
element
)
;
if
(
MOZ_UNLIKELY
(
moveTextNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveTextNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveTextNodeResult
=
moveTextNodeResult
.
unwrap
(
)
;
unwrappedMoveTextNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
SplitRangeOffFromNodeResult
(
leftTextNode
middleTextNode
rightTextNode
std
:
:
move
(
pointToPutCaret
)
)
;
}
}
sibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
middleTextNode
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsElement
(
)
)
{
OwningNonNull
<
Element
>
element
(
*
sibling
-
>
AsElement
(
)
)
;
Result
<
bool
nsresult
>
result
=
ElementIsGoodContainerForTheStyle
(
element
&
aProperty
aAttribute
&
aValue
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
)
failed
"
)
;
return
result
.
propagateErr
(
)
;
}
if
(
result
.
inspect
(
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveTextNodeResult
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
middleTextNode
)
EditorDOMPoint
(
sibling
0u
)
)
;
if
(
MOZ_UNLIKELY
(
moveTextNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveTextNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveTextNodeResult
=
moveTextNodeResult
.
unwrap
(
)
;
unwrappedMoveTextNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
SplitRangeOffFromNodeResult
(
leftTextNode
middleTextNode
rightTextNode
std
:
:
move
(
pointToPutCaret
)
)
;
}
}
}
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
middleTextNode
)
aProperty
aAttribute
aValue
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
setStyleResult
.
propagateErr
(
)
;
}
return
SplitRangeOffFromNodeResult
(
leftTextNode
middleTextNode
rightTextNode
setStyleResult
.
unwrap
(
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aContent
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
nsGkAtoms
:
:
span
aContent
)
)
{
if
(
!
aContent
.
HasChildren
(
)
)
{
return
EditorDOMPoint
(
)
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfContents
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aContent
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
&
&
(
!
child
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
child
-
>
AsText
(
)
)
)
)
{
arrayOfContents
.
AppendElement
(
*
child
)
;
}
}
EditorDOMPoint
pointToPutCaret
;
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
Result
<
EditorDOMPoint
nsresult
>
setInlinePropertyResult
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
content
)
aProperty
aAttribute
aValue
)
;
if
(
MOZ_UNLIKELY
(
setInlinePropertyResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
setInlinePropertyResult
;
}
if
(
setInlinePropertyResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
setInlinePropertyResult
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
nsCOMPtr
<
nsIContent
>
previousSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
previousSibling
&
&
previousSibling
-
>
IsElement
(
)
)
{
OwningNonNull
<
Element
>
previousElement
(
*
previousSibling
-
>
AsElement
(
)
)
;
Result
<
bool
nsresult
>
canMoveIntoPreviousSibling
=
ElementIsGoodContainerForTheStyle
(
previousElement
&
aProperty
aAttribute
&
aValue
)
;
if
(
canMoveIntoPreviousSibling
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
)
failed
"
)
;
return
canMoveIntoPreviousSibling
.
propagateErr
(
)
;
}
if
(
canMoveIntoPreviousSibling
.
inspect
(
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveNodeResult
=
MoveNodeToEndWithTransaction
(
aContent
*
previousSibling
)
;
if
(
MOZ_UNLIKELY
(
moveNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveNodeResult
=
moveNodeResult
.
unwrap
(
)
;
if
(
!
nextSibling
|
|
!
nextSibling
-
>
IsElement
(
)
)
{
return
unwrappedMoveNodeResult
.
UnwrapCaretPoint
(
)
;
}
OwningNonNull
<
Element
>
nextElement
(
*
nextSibling
-
>
AsElement
(
)
)
;
Result
<
bool
nsresult
>
canMoveIntoNextSibling
=
ElementIsGoodContainerForTheStyle
(
nextElement
&
aProperty
aAttribute
&
aValue
)
;
if
(
canMoveIntoNextSibling
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
)
failed
"
)
;
unwrappedMoveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
return
canMoveIntoNextSibling
.
propagateErr
(
)
;
}
if
(
!
canMoveIntoNextSibling
.
inspect
(
)
)
{
return
unwrappedMoveNodeResult
.
UnwrapCaretPoint
(
)
;
}
unwrappedMoveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
JoinNodesResult
joinNodesResult
=
JoinNodesWithTransaction
(
*
previousSibling
*
nextSibling
)
;
if
(
joinNodesResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
joinNodesResult
.
Rv
(
)
)
;
}
return
joinNodesResult
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
}
}
if
(
nextSibling
&
&
nextSibling
-
>
IsElement
(
)
)
{
OwningNonNull
<
Element
>
nextElement
(
*
nextSibling
-
>
AsElement
(
)
)
;
Result
<
bool
nsresult
>
canMoveIntoNextSibling
=
ElementIsGoodContainerForTheStyle
(
nextElement
&
aProperty
aAttribute
&
aValue
)
;
if
(
canMoveIntoNextSibling
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ElementIsGoodContainerForTheStyle
(
)
failed
"
)
;
return
canMoveIntoNextSibling
.
propagateErr
(
)
;
}
if
(
canMoveIntoNextSibling
.
inspect
(
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveNodeResult
=
MoveNodeWithTransaction
(
aContent
EditorDOMPoint
(
nextElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
moveNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
propagateErr
(
)
;
}
return
moveNodeResult
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
;
}
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
&
aProperty
aAttribute
)
)
{
nsAutoString
value
(
aValue
)
;
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
aContent
&
aProperty
aAttribute
value
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
propagateErr
(
)
;
}
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
)
{
return
EditorDOMPoint
(
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
aContent
aProperty
aAttribute
&
aValue
)
)
{
return
EditorDOMPoint
(
)
;
}
auto
ShouldUseCSS
=
[
&
]
(
)
{
return
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
&
aProperty
aAttribute
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
|
|
aValue
.
EqualsLiteral
(
"
-
moz
-
editor
-
invert
-
value
"
)
;
}
;
if
(
ShouldUseCSS
(
)
)
{
RefPtr
<
Element
>
spanElement
;
EditorDOMPoint
pointToPutCaret
;
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aContent
.
AsElement
(
)
-
>
GetAttrCount
(
)
)
{
spanElement
=
aContent
.
AsElement
(
)
;
}
else
{
Result
<
CreateElementResult
nsresult
>
wrapInSpanElementResult
=
InsertContainerWithTransaction
(
aContent
*
nsGkAtoms
:
:
span
)
;
if
(
MOZ_UNLIKELY
(
wrapInSpanElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
nsGkAtoms
:
:
span
)
"
"
failed
"
)
;
return
wrapInSpanElementResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedWrapInSpanElementResult
=
wrapInSpanElementResult
.
unwrap
(
)
;
MOZ_ASSERT
(
unwrappedWrapInSpanElementResult
.
GetNewNode
(
)
)
;
unwrappedWrapInSpanElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
spanElement
=
unwrappedWrapInSpanElementResult
.
UnwrapNewNode
(
)
;
}
if
(
nsStyledElement
*
spanStyledElement
=
nsStyledElement
:
:
FromNode
(
spanElement
)
)
{
Result
<
int32_t
nsresult
>
result
=
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
*
this
MOZ_KnownLive
(
*
spanStyledElement
)
&
aProperty
aAttribute
&
aValue
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
failed
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
}
}
return
pointToPutCaret
;
}
if
(
aContent
.
IsHTMLElement
(
&
aProperty
)
)
{
if
(
NS_WARN_IF
(
!
aAttribute
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
*
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditorDOMPoint
(
)
;
}
Result
<
CreateElementResult
nsresult
>
wrapWithNewElementToFormatResult
=
InsertContainerWithTransaction
(
aContent
aProperty
aAttribute
?
*
aAttribute
:
*
nsGkAtoms
:
:
_empty
aValue
)
;
if
(
MOZ_UNLIKELY
(
wrapWithNewElementToFormatResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
wrapWithNewElementToFormatResult
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
wrapWithNewElementToFormatResult
.
inspect
(
)
.
GetNewNode
(
)
)
;
return
wrapWithNewElementToFormatResult
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SetInlinePropertyOnNode
(
nsIContent
&
aContent
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
NS_WARN_IF
(
!
aContent
.
GetParentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
OwningNonNull
<
nsINode
>
parent
=
*
aContent
.
GetParentNode
(
)
;
nsCOMPtr
<
nsIContent
>
previousSibling
=
aContent
.
GetPreviousSibling
(
)
nextSibling
=
aContent
.
GetNextSibling
(
)
;
EditorDOMPoint
pointToPutCaret
;
if
(
aContent
.
IsElement
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
removeStyleResult
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
&
aProperty
aAttribute
SpecifiedStyle
:
:
Preserve
)
;
if
(
MOZ_UNLIKELY
(
removeStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
removeStyleResult
.
propagateErr
(
)
;
}
if
(
removeStyleResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
removeStyleResult
.
unwrap
(
)
;
}
}
if
(
aContent
.
GetParentNode
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNodeImpl
(
aContent
aProperty
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
setStyleResult
.
isOk
(
)
"
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
)
failed
"
)
;
return
setStyleResult
;
}
if
(
NS_WARN_IF
(
previousSibling
&
&
previousSibling
-
>
GetParentNode
(
)
!
=
parent
)
|
|
NS_WARN_IF
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parent
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
nodesToSet
;
for
(
nsIContent
*
content
=
previousSibling
?
previousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
content
&
&
content
!
=
nextSibling
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
nodesToSet
.
AppendElement
(
*
content
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
nodesToSet
)
{
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNodeImpl
(
MOZ_KnownLive
(
content
)
aProperty
aAttribute
aValue
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
)
failed
"
)
;
return
setStyleResult
;
}
if
(
setStyleResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
setStyleResult
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
Result
<
SplitRangeOffResult
nsresult
>
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAtRangeEdges
(
const
EditorDOMRange
&
aRange
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aRange
.
IsPositioned
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRange
range
(
aRange
)
;
SplitNodeResult
resultAtStart
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
AutoTrackDOMRange
tracker
(
RangeUpdaterRef
(
)
&
range
)
;
SplitNodeResult
result
=
SplitAncestorStyledInlineElementsAt
(
range
.
StartRef
(
)
aProperty
aAttribute
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
SplitNodeResult
(
result
.
unwrapErr
(
)
)
;
}
tracker
.
FlushAndStopTracking
(
)
;
if
(
result
.
Handled
(
)
)
{
auto
startOfRange
=
result
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
startOfRange
.
IsSet
(
)
)
{
result
.
IgnoreCaretPointSuggestion
(
)
;
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
didn
'
t
return
"
"
split
point
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
range
.
SetStart
(
std
:
:
move
(
startOfRange
)
)
;
}
return
result
;
}
(
)
;
if
(
resultAtStart
.
isErr
(
)
)
{
return
Err
(
resultAtStart
.
unwrapErr
(
)
)
;
}
SplitNodeResult
resultAtEnd
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
AutoTrackDOMRange
tracker
(
RangeUpdaterRef
(
)
&
range
)
;
SplitNodeResult
result
=
SplitAncestorStyledInlineElementsAt
(
range
.
EndRef
(
)
aProperty
aAttribute
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
SplitNodeResult
(
result
.
unwrapErr
(
)
)
;
}
tracker
.
FlushAndStopTracking
(
)
;
if
(
result
.
Handled
(
)
)
{
auto
endOfRange
=
result
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
endOfRange
.
IsSet
(
)
)
{
result
.
IgnoreCaretPointSuggestion
(
)
;
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
didn
'
t
return
"
"
split
point
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
range
.
SetEnd
(
std
:
:
move
(
endOfRange
)
)
;
}
return
result
;
}
(
)
;
if
(
resultAtEnd
.
isErr
(
)
)
{
resultAtStart
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
resultAtEnd
.
unwrapErr
(
)
)
;
}
return
SplitRangeOffResult
(
std
:
:
move
(
range
)
std
:
:
move
(
resultAtStart
)
std
:
:
move
(
resultAtEnd
)
)
;
}
SplitNodeResult
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
const
EditorDOMPoint
&
aPointToSplit
nsAtom
*
aProperty
nsAtom
*
aAttribute
SplitAtEdges
aSplitAtEdges
)
{
if
(
NS_WARN_IF
(
!
aPointToSplit
.
IsInContentNode
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
bool
useCSS
=
aProperty
!
=
nsGkAtoms
:
:
tt
|
|
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfParents
;
for
(
nsIContent
*
content
:
aPointToSplit
.
GetContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
!
content
-
>
GetParent
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
-
>
GetParent
(
)
EditorType
:
:
HTML
)
)
{
break
;
}
arrayOfParents
.
AppendElement
(
*
content
)
;
}
SplitNodeResult
result
=
SplitNodeResult
:
:
NotHandled
(
aPointToSplit
GetSplitNodeDirection
(
)
)
;
MOZ_ASSERT
(
!
result
.
Handled
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfParents
)
{
bool
isSetByCSS
=
false
;
if
(
useCSS
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
aProperty
aAttribute
)
)
{
nsAutoString
firstValue
;
Result
<
bool
nsresult
>
isSpecifiedByCSSOrError
=
CSSEditUtils
:
:
IsSpecifiedCSSEquivalentToHTMLInlineStyleSet
(
*
this
*
content
aProperty
aAttribute
firstValue
)
;
if
(
isSpecifiedByCSSOrError
.
isErr
(
)
)
{
result
.
IgnoreCaretPointSuggestion
(
)
;
NS_WARNING
(
"
CSSEditUtils
:
:
IsSpecifiedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
SplitNodeResult
(
isSpecifiedByCSSOrError
.
unwrapErr
(
)
)
;
}
isSetByCSS
=
isSpecifiedByCSSOrError
.
unwrap
(
)
;
}
if
(
!
isSetByCSS
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
if
(
aProperty
)
{
if
(
!
content
-
>
IsHTMLElement
(
aProperty
)
&
&
!
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
content
)
)
)
{
continue
;
}
}
else
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
*
content
-
>
AsElement
(
)
)
)
{
continue
;
}
}
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
content
)
result
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
aSplitAtEdges
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
splitNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
!
splitNodeResult
.
Handled
(
)
)
{
continue
;
}
result
=
splitNodeResult
.
ToHandledResult
(
)
;
MOZ_ASSERT
(
result
.
Handled
(
)
)
;
}
return
pointToPutCaret
.
IsSet
(
)
?
SplitNodeResult
(
std
:
:
move
(
result
)
std
:
:
move
(
pointToPutCaret
)
)
:
std
:
:
move
(
result
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
ClearStyleAt
(
const
EditorDOMPoint
&
aPoint
nsAtom
*
aProperty
nsAtom
*
aAttribute
SpecifiedStyle
aSpecifiedStyle
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToPutCaret
(
aPoint
)
;
SplitNodeResult
splitResult
=
SplitAncestorStyledInlineElementsAt
(
aPoint
aProperty
aAttribute
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
Err
(
splitResult
.
unwrapErr
(
)
)
;
}
splitResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
!
splitResult
.
Handled
(
)
)
{
return
pointToPutCaret
;
}
if
(
splitResult
.
GetPreviousContent
(
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
splitResult
.
GetPreviousContent
(
)
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetPreviousContent
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
!
splitResult
.
GetNextContent
(
)
)
{
return
pointToPutCaret
;
}
nsIContent
*
firstLeafChildOfNextNode
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
splitResult
.
GetNextContent
(
)
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
EditorDOMPoint
atStartOfNextNode
(
firstLeafChildOfNextNode
?
firstLeafChildOfNextNode
:
splitResult
.
GetNextContent
(
)
0
)
;
RefPtr
<
HTMLBRElement
>
brElement
;
if
(
!
atStartOfNextNode
.
IsInContentNode
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
atStartOfNextNode
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
brElement
=
HTMLBRElement
:
:
FromNode
(
atStartOfNextNode
.
GetContainer
(
)
)
;
if
(
!
atStartOfNextNode
.
GetContainerParentAs
<
nsIContent
>
(
)
)
{
NS_WARNING
(
"
atStartOfNextNode
was
in
an
orphan
node
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
atStartOfNextNode
.
Set
(
atStartOfNextNode
.
GetContainerParent
(
)
0
)
;
}
SplitNodeResult
splitResultAtStartOfNextNode
=
SplitAncestorStyledInlineElementsAt
(
atStartOfNextNode
aProperty
aAttribute
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitResultAtStartOfNextNode
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
Err
(
splitResultAtStartOfNextNode
.
unwrapErr
(
)
)
;
}
splitResultAtStartOfNextNode
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
splitResultAtStartOfNextNode
.
Handled
(
)
&
&
splitResultAtStartOfNextNode
.
GetNextContent
(
)
)
{
bool
seenBR
=
false
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
&
seenBR
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
seenBR
&
&
!
brElement
)
{
brElement
=
HTMLEditUtils
:
:
GetFirstBRElement
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
-
>
AsElement
(
)
)
;
}
}
}
if
(
NS_WARN_IF
(
!
splitResultAtStartOfNextNode
.
Handled
(
)
)
|
|
!
splitResultAtStartOfNextNode
.
GetPreviousContent
(
)
)
{
const
EditorRawDOMPoint
&
splitPoint
=
splitResult
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
const
EditorRawDOMPoint
&
splitPointAtStartOfNextNode
=
splitResultAtStartOfNextNode
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
return
EditorDOMPoint
(
splitPoint
.
GetContainer
(
)
splitPointAtStartOfNextNode
.
Offset
(
)
)
;
}
nsIContent
*
firstLeafChildOfPreviousNode
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
splitResultAtStartOfNextNode
.
GetPreviousContent
(
)
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
pointToPutCaret
.
Set
(
firstLeafChildOfPreviousNode
?
firstLeafChildOfPreviousNode
:
splitResultAtStartOfNextNode
.
GetPreviousContent
(
)
0
)
;
if
(
brElement
)
{
{
Result
<
MoveNodeResult
nsresult
>
moveBRElementResult
=
MoveNodeWithTransaction
(
*
brElement
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
moveBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveBRElementResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveBRElementResult
=
moveBRElementResult
.
unwrap
(
)
;
unwrappedMoveBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
if
(
splitResultAtStartOfNextNode
.
GetNextContent
(
)
&
&
splitResultAtStartOfNextNode
.
GetNextContent
(
)
-
>
IsInComposedDoc
(
)
)
{
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
4
>
emptyInlineContainerElements
;
HTMLEditUtils
:
:
CollectEmptyInlineContainerDescendants
(
*
splitResultAtStartOfNextNode
.
GetNextContent
(
)
-
>
AsElement
(
)
emptyInlineContainerElements
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
emptyInlineContainerElement
:
emptyInlineContainerElements
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyInlineContainerElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
}
pointToPutCaret
.
Set
(
pointToPutCaret
.
GetContainer
(
)
0
)
;
}
if
(
Element
*
previousElementOfSplitPoint
=
Element
:
:
FromNode
(
splitResultAtStartOfNextNode
.
GetPreviousContent
(
)
)
)
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
EditorDOMPoint
nsresult
>
removeStyleResult
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
previousElementOfSplitPoint
)
aProperty
aAttribute
aSpecifiedStyle
)
;
if
(
MOZ_UNLIKELY
(
removeStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
removeStyleResult
;
}
}
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
RemoveStyleInside
(
Element
&
aElement
nsAtom
*
aProperty
nsAtom
*
aAttribute
SpecifiedStyle
aSpecifiedStyle
)
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfChildContents
;
HTMLEditor
:
:
GetChildNodesOf
(
aElement
arrayOfChildContents
)
;
EditorDOMPoint
pointToPutCaret
;
for
(
const
OwningNonNull
<
nsIContent
>
&
child
:
arrayOfChildContents
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
Result
<
EditorDOMPoint
nsresult
>
removeStyleResult
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
aProperty
aAttribute
aSpecifiedStyle
)
;
if
(
MOZ_UNLIKELY
(
removeStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
removeStyleResult
;
}
if
(
removeStyleResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
removeStyleResult
.
unwrap
(
)
;
}
}
auto
ShouldRemoveHTMLStyle
=
[
&
]
(
)
{
if
(
aProperty
)
{
return
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aProperty
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
&
aElement
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
name
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aElement
)
)
;
}
if
(
EditorUtils
:
:
IsEditableContent
(
aElement
EditorType
:
:
HTML
)
)
{
return
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
aElement
)
;
}
return
false
;
}
;
if
(
ShouldRemoveHTMLStyle
(
)
)
{
if
(
!
aAttribute
)
{
if
(
aProperty
&
&
aSpecifiedStyle
!
=
SpecifiedStyle
:
:
Discard
&
&
(
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
)
)
{
Result
<
CreateElementResult
nsresult
>
wrapInSpanElementResult
=
InsertContainerWithTransaction
(
aElement
*
nsGkAtoms
:
:
span
)
;
if
(
wrapInSpanElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
nsGkAtoms
:
:
span
)
"
"
failed
"
)
;
return
wrapInSpanElementResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedWrapInSpanElementResult
=
wrapInSpanElementResult
.
unwrap
(
)
;
MOZ_ASSERT
(
unwrappedWrapInSpanElementResult
.
GetNewNode
(
)
)
;
unwrappedWrapInSpanElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
const
RefPtr
<
Element
>
spanElement
=
unwrappedWrapInSpanElementResult
.
UnwrapNewNode
(
)
;
nsresult
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
style
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CloneAttributeWithTransaction
(
nsGkAtoms
:
:
style
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
_class
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CloneAttributeWithTransaction
(
nsGkAtoms
:
:
_class
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
}
Result
<
EditorDOMPoint
nsresult
>
unwrapElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapElementResult
.
propagateErr
(
)
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
unwrapElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapElementResult
.
unwrap
(
)
;
}
}
else
if
(
aElement
.
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
if
(
IsOnlyAttribute
(
&
aElement
aAttribute
)
)
{
Result
<
EditorDOMPoint
nsresult
>
unwrapElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapElementResult
.
propagateErr
(
)
;
}
if
(
unwrapElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapElementResult
.
unwrap
(
)
;
}
}
else
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
aElement
*
aAttribute
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aElement
aProperty
aAttribute
)
)
{
Result
<
bool
nsresult
>
elementHasSpecifiedCSSEquivalentStylesOrError
=
CSSEditUtils
:
:
HaveSpecifiedCSSEquivalentStyles
(
*
this
aElement
aProperty
aAttribute
)
;
if
(
elementHasSpecifiedCSSEquivalentStylesOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
HaveSpecifiedCSSEquivalentStyles
(
)
failed
"
)
;
return
elementHasSpecifiedCSSEquivalentStylesOrError
.
propagateErr
(
)
;
}
if
(
elementHasSpecifiedCSSEquivalentStylesOrError
.
unwrap
(
)
)
{
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsresult
rv
=
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
*
this
MOZ_KnownLive
(
*
styledElement
)
aProperty
aAttribute
nullptr
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
destroyed
the
editor
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
span
nsGkAtoms
:
:
font
)
&
&
!
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
aElement
)
)
{
Result
<
EditorDOMPoint
nsresult
>
unwrapSpanOrFontElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapSpanOrFontElementResult
.
isErr
(
)
&
&
unwrapSpanOrFontElementResult
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
unwrapSpanOrFontElementResult
.
isOk
(
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
MOZ_LIKELY
(
unwrapSpanOrFontElementResult
.
isOk
(
)
)
&
&
unwrapSpanOrFontElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapSpanOrFontElementResult
.
unwrap
(
)
;
}
}
}
}
if
(
aProperty
!
=
nsGkAtoms
:
:
font
|
|
aAttribute
!
=
nsGkAtoms
:
:
size
|
|
!
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
)
)
{
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
unwrapBigOrSmallElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
NS_WARNING_ASSERTION
(
unwrapBigOrSmallElementResult
.
isOk
(
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapBigOrSmallElementResult
;
}
bool
HTMLEditor
:
:
IsOnlyAttribute
(
const
Element
*
aElement
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
aElement
)
;
uint32_t
attrCount
=
aElement
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
aElement
-
>
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
false
;
}
if
(
name
-
>
LocalName
(
)
!
=
aAttribute
)
{
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
u
"
_moz
"
_ns
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
{
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
newRangeStart
(
aRange
.
StartRef
(
)
)
;
for
(
Element
*
element
:
aRange
.
GetStartContainer
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
continue
;
}
newRangeStart
.
Set
(
element
)
;
break
;
}
if
(
!
newRangeStart
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
reached
root
"
"
element
from
start
container
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newRangeEnd
(
aRange
.
EndRef
(
)
)
;
for
(
Element
*
element
:
aRange
.
GetEndContainer
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
continue
;
}
newRangeEnd
.
SetAfter
(
element
)
;
break
;
}
if
(
!
newRangeEnd
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
reached
root
"
"
element
from
end
container
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newRangeStart
=
=
aRange
.
StartRef
(
)
&
&
newRangeEnd
=
=
aRange
.
EndRef
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
newRangeStart
.
ToRawRangeBoundary
(
)
newRangeEnd
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
PromoteInlineRange
(
nsRange
&
aRange
)
{
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
newRangeStart
(
aRange
.
StartRef
(
)
)
;
for
(
nsIContent
*
content
:
aRange
.
GetStartContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
MOZ_ASSERT
(
newRangeStart
.
GetContainer
(
)
=
=
content
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
!
IsStartOfContainerOrBeforeFirstEditableChild
(
newRangeStart
)
)
{
break
;
}
newRangeStart
.
Set
(
content
)
;
}
if
(
!
newRangeStart
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
reached
root
element
from
start
"
"
container
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newRangeEnd
(
aRange
.
EndRef
(
)
)
;
for
(
nsIContent
*
content
:
aRange
.
GetEndContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
MOZ_ASSERT
(
newRangeEnd
.
GetContainer
(
)
=
=
content
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
!
IsEndOfContainerOrEqualsOrAfterLastEditableChild
(
newRangeEnd
)
)
{
break
;
}
newRangeEnd
.
SetAfter
(
content
)
;
}
if
(
!
newRangeEnd
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
reached
root
element
from
end
"
"
container
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newRangeStart
=
=
aRange
.
StartRef
(
)
&
&
newRangeEnd
=
=
aRange
.
EndRef
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
newRangeStart
.
ToRawRangeBoundary
(
)
newRangeEnd
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
IsStartOfContainerOrBeforeFirstEditableChild
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
)
{
return
true
;
}
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
false
;
}
nsIContent
*
firstEditableChild
=
HTMLEditUtils
:
:
GetFirstChild
(
*
aPoint
.
GetContainer
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableChild
)
{
return
true
;
}
return
EditorRawDOMPoint
(
firstEditableChild
)
.
Offset
(
)
>
=
aPoint
.
Offset
(
)
;
}
bool
HTMLEditor
:
:
IsEndOfContainerOrEqualsOrAfterLastEditableChild
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
IsEndOfContainer
(
)
)
{
return
true
;
}
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
false
;
}
nsIContent
*
lastEditableChild
=
HTMLEditUtils
:
:
GetLastChild
(
*
aPoint
.
GetContainer
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
lastEditableChild
)
{
return
true
;
}
return
EditorRawDOMPoint
(
lastEditableChild
)
.
Offset
(
)
<
aPoint
.
Offset
(
)
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyBase
(
nsStaticAtom
&
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
*
aAny
=
false
;
*
aAll
=
true
;
*
aFirst
=
false
;
bool
first
=
true
;
bool
isCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
range
)
{
bool
firstNodeInRange
=
true
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
collapsedNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
collapsedNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsString
tOutString
;
const
PendingStyleState
styleState
=
[
&
]
(
)
{
if
(
aAttribute
)
{
auto
state
=
mPendingStylesToApplyToNewContent
-
>
GetStyleState
(
aHTMLProperty
aAttribute
&
tOutString
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
state
;
}
return
mPendingStylesToApplyToNewContent
-
>
GetStyleState
(
aHTMLProperty
)
;
}
(
)
;
if
(
styleState
!
=
PendingStyleState
:
:
NotUpdated
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
(
styleState
=
=
PendingStyleState
:
:
BeingPreserved
)
;
return
NS_OK
;
}
if
(
collapsedNode
-
>
IsContent
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
collapsedNode
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
tOutString
.
Assign
(
*
aValue
)
;
}
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
MOZ_KnownLive
(
*
collapsedNode
-
>
AsContent
(
)
)
&
aHTMLProperty
aAttribute
tOutString
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrapErr
(
)
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
NS_OK
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
collapsedNode
-
>
IsContent
(
)
&
&
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
*
collapsedNode
-
>
AsContent
(
)
aHTMLProperty
aAttribute
aValue
outValue
)
;
return
NS_OK
;
}
nsAutoString
firstValue
theValue
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
PostContentIterator
postOrderIter
;
DebugOnly
<
nsresult
>
rvIgnored
=
postOrderIter
.
Init
(
range
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
initialize
post
-
order
content
iterator
"
)
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
!
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
content
-
>
IsText
(
)
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
content
-
>
AsText
(
)
)
)
)
{
continue
;
}
if
(
content
-
>
GetAsText
(
)
)
{
if
(
!
isCollapsed
&
&
first
&
&
firstNodeInRange
)
{
firstNodeInRange
=
false
;
if
(
range
-
>
StartOffset
(
)
=
=
content
-
>
Length
(
)
)
{
continue
;
}
}
else
if
(
content
=
=
endNode
&
&
!
endOffset
)
{
continue
;
}
}
else
if
(
content
-
>
IsElement
(
)
)
{
continue
;
}
bool
isSet
=
false
;
bool
useTextDecoration
=
&
aHTMLProperty
=
=
nsGkAtoms
:
:
u
|
|
&
aHTMLProperty
=
=
nsGkAtoms
:
:
strike
;
if
(
first
)
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
firstValue
.
Assign
(
*
aValue
)
;
}
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
*
content
&
aHTMLProperty
aAttribute
firstValue
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrapErr
(
)
;
}
isSet
=
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
;
}
else
{
isSet
=
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
*
content
aHTMLProperty
aAttribute
aValue
&
firstValue
)
;
}
*
aFirst
=
isSet
;
first
=
false
;
if
(
outValue
)
{
*
outValue
=
firstValue
;
}
}
else
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aHTMLProperty
aAttribute
)
)
{
if
(
aValue
)
{
theValue
.
Assign
(
*
aValue
)
;
}
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
*
content
&
aHTMLProperty
aAttribute
theValue
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrapErr
(
)
;
}
isSet
=
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
;
}
else
{
isSet
=
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
*
content
aHTMLProperty
aAttribute
aValue
&
theValue
)
;
}
if
(
firstValue
!
=
theValue
&
&
(
!
useTextDecoration
|
|
*
aFirst
!
=
isSet
)
)
{
*
aAll
=
false
;
}
}
if
(
isSet
)
{
*
aAny
=
true
;
}
else
{
*
aAll
=
false
;
}
}
}
if
(
!
*
aAny
)
{
*
aAll
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetInlineProperty
(
nsStaticAtom
&
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
const
{
if
(
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
!
aValue
.
IsEmpty
(
)
?
&
aValue
:
nullptr
;
nsresult
rv
=
GetInlinePropertyBase
(
aHTMLProperty
aAttribute
val
aFirst
aAny
aAll
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
const
nsAString
&
aHTMLProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
nsStaticAtom
*
property
=
NS_GetStaticAtom
(
aHTMLProperty
)
;
if
(
NS_WARN_IF
(
!
property
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
nsresult
rv
=
GetInlinePropertyWithAttrValue
(
MOZ_KnownLive
(
*
property
)
MOZ_KnownLive
(
attribute
)
aValue
aFirst
aAny
aAll
outValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
nsStaticAtom
&
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
if
(
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
!
aValue
.
IsEmpty
(
)
?
&
aValue
:
nullptr
;
nsresult
rv
=
GetInlinePropertyBase
(
aHTMLProperty
aAttribute
val
aFirst
aAny
aAll
&
outValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveAllInlinePropertiesAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAllInlineStyleProperties
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveAllTextProperties
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoTArray
<
EditorInlineStyle
1
>
removeAllInlineStyles
;
removeAllInlineStyles
.
AppendElement
(
EditorInlineStyle
:
:
RemoveAllStyles
(
)
)
;
rv
=
RemoveInlinePropertiesAsSubAction
(
removeAllInlineStyles
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyAsAction
(
nsStaticAtom
&
aHTMLProperty
nsStaticAtom
*
aAttribute
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aHTMLProperty
aAttribute
false
)
aPrincipal
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
u
"
"
_ns
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
u
"
"
_ns
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
u
"
"
_ns
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoTArray
<
EditorInlineStyle
8
>
removeInlineStyleAndRelatedElements
;
AppendInlineStyleAndRelatedStyle
(
EditorInlineStyle
(
aHTMLProperty
aAttribute
)
removeInlineStyleAndRelatedElements
)
;
rv
=
RemoveInlinePropertiesAsSubAction
(
removeInlineStyleAndRelatedElements
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
)
{
nsStaticAtom
*
property
=
NS_GetStaticAtom
(
aProperty
)
;
nsStaticAtom
*
attribute
=
EditorUtils
:
:
GetAttributeAtom
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
false
)
)
;
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
u
"
"
_ns
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
u
"
"
_ns
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
u
"
"
_ns
)
;
break
;
default
:
break
;
}
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoTArray
<
EditorInlineStyle
1
>
removeOneInlineStyle
;
removeOneInlineStyle
.
AppendElement
(
EditorInlineStyle
(
*
property
attribute
)
)
;
rv
=
RemoveInlinePropertiesAsSubAction
(
removeOneInlineStyle
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveInlinePropertiesAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
void
HTMLEditor
:
:
AppendInlineStyleAndRelatedStyle
(
const
EditorInlineStyle
&
aStyleToRemove
nsTArray
<
EditorInlineStyle
>
&
aStylesToRemove
)
const
{
if
(
aStyleToRemove
.
mHTMLProperty
=
=
nsGkAtoms
:
:
b
)
{
EditorInlineStyle
strong
(
*
nsGkAtoms
:
:
strong
)
;
if
(
!
aStylesToRemove
.
Contains
(
strong
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
strong
)
)
;
}
}
else
if
(
aStyleToRemove
.
mHTMLProperty
=
=
nsGkAtoms
:
:
i
)
{
EditorInlineStyle
em
(
*
nsGkAtoms
:
:
em
)
;
if
(
!
aStylesToRemove
.
Contains
(
em
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
em
)
)
;
}
}
else
if
(
aStyleToRemove
.
mHTMLProperty
=
=
nsGkAtoms
:
:
strike
)
{
EditorInlineStyle
s
(
*
nsGkAtoms
:
:
s
)
;
if
(
!
aStylesToRemove
.
Contains
(
s
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
s
)
)
;
}
}
else
if
(
aStyleToRemove
.
mHTMLProperty
=
=
nsGkAtoms
:
:
font
)
{
if
(
aStyleToRemove
.
mAttribute
=
=
nsGkAtoms
:
:
size
)
{
EditorInlineStyle
big
(
*
nsGkAtoms
:
:
big
)
small
(
*
nsGkAtoms
:
:
small
)
;
if
(
!
aStylesToRemove
.
Contains
(
big
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
big
)
)
;
}
if
(
!
aStylesToRemove
.
Contains
(
small
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
small
)
)
;
}
}
else
if
(
aStyleToRemove
.
mAttribute
=
=
nsGkAtoms
:
:
face
&
&
!
GetEditActionPrincipal
(
)
)
{
EditorInlineStyle
tt
(
*
nsGkAtoms
:
:
tt
)
;
if
(
!
aStylesToRemove
.
Contains
(
tt
)
)
{
aStylesToRemove
.
AppendElement
(
std
:
:
move
(
tt
)
)
;
}
}
}
if
(
!
aStylesToRemove
.
Contains
(
aStyleToRemove
)
)
{
aStylesToRemove
.
AppendElement
(
aStyleToRemove
)
;
}
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertiesAsSubAction
(
const
nsTArray
<
EditorInlineStyle
>
&
aStylesToRemove
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aStylesToRemove
.
IsEmpty
(
)
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
mPendingStylesToApplyToNewContent
-
>
ClearStyles
(
aStylesToRemove
)
;
return
NS_OK
;
}
if
(
IsInPlaintextMode
(
)
)
{
return
NS_OK
;
}
{
Result
<
EditActionResult
nsresult
>
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
if
(
result
.
inspect
(
)
.
Canceled
(
)
)
{
return
NS_OK
;
}
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
for
(
const
EditorInlineStyle
&
styleToRemove
:
aStylesToRemove
)
{
MOZ_ALWAYS_TRUE
(
selectionRanges
.
SaveAndTrackRanges
(
*
this
)
)
;
const
bool
isCSSInvertibleStyle
=
styleToRemove
.
mHTMLProperty
&
&
CSSEditUtils
:
:
IsCSSInvertible
(
*
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
)
;
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
selectionRanges
.
Ranges
(
)
)
{
if
(
styleToRemove
.
mHTMLProperty
=
=
nsGkAtoms
:
:
name
)
{
nsresult
rv
=
PromoteRangeIfStartsOrEndsInNamedAnchor
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
)
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
return
rv
;
}
}
Result
<
SplitRangeOffResult
nsresult
>
splitRangeOffResult
=
SplitAncestorStyledInlineElementsAtRangeEdges
(
EditorDOMRange
(
range
)
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
)
;
if
(
MOZ_UNLIKELY
(
splitRangeOffResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAtRangeEdges
(
)
"
"
failed
"
)
;
return
splitRangeOffResult
.
unwrapErr
(
)
;
}
splitRangeOffResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
const
EditorDOMRange
&
splitRange
=
splitRangeOffResult
.
inspect
(
)
.
RangeRef
(
)
;
if
(
NS_WARN_IF
(
!
splitRange
.
IsPositioned
(
)
)
)
{
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContentsToInvertStyle
;
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContentsAroundRange
;
if
(
splitRange
.
InSameContainer
(
)
&
&
splitRange
.
StartRef
(
)
.
IsInTextNode
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
continue
;
}
arrayOfContentsAroundRange
.
AppendElement
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
;
}
else
if
(
splitRange
.
IsInTextNodes
(
)
&
&
splitRange
.
InAdjacentSiblings
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
continue
;
}
arrayOfContentsAroundRange
.
AppendElement
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
;
arrayOfContentsAroundRange
.
AppendElement
(
*
splitRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
)
;
}
else
{
if
(
splitRange
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
!
splitRange
.
StartRef
(
)
.
IsStartOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContentsAroundRange
.
AppendElement
(
*
splitRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
;
}
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
splitRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
splitRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContentsAroundRange
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
!
splitRange
.
InSameContainer
(
)
&
&
splitRange
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
!
splitRange
.
EndRef
(
)
.
IsEndOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
splitRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContentsAroundRange
.
AppendElement
(
*
splitRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
)
;
}
}
if
(
isCSSInvertibleStyle
)
{
arrayOfContentsToInvertStyle
.
SetCapacity
(
arrayOfContentsAroundRange
.
Length
(
)
)
;
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContentsAroundRange
)
{
if
(
content
-
>
IsElement
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
removeStyleResult
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
SpecifiedStyle
:
:
Preserve
)
;
if
(
MOZ_UNLIKELY
(
removeStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveStyleInside
(
)
failed
"
)
;
return
removeStyleResult
.
unwrapErr
(
)
;
}
if
(
!
content
-
>
GetParentNode
(
)
)
{
continue
;
}
}
if
(
isCSSInvertibleStyle
)
{
arrayOfContentsToInvertStyle
.
AppendElement
(
content
)
;
}
Result
<
bool
nsresult
>
isRemovableParentStyleOrError
=
IsRemovableParentStyleWithNewSpanElement
(
MOZ_KnownLive
(
content
)
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
)
;
if
(
MOZ_UNLIKELY
(
isRemovableParentStyleOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
)
"
"
failed
"
)
;
return
isRemovableParentStyleOrError
.
unwrapErr
(
)
;
}
if
(
!
isRemovableParentStyleOrError
.
unwrap
(
)
)
{
continue
;
}
if
(
!
content
-
>
IsText
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
content
)
*
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
setStyleResult
.
unwrapErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
but
ignored
"
)
;
}
continue
;
}
uint32_t
startOffset
=
content
=
=
splitRange
.
StartRef
(
)
.
GetContainer
(
)
?
splitRange
.
StartRef
(
)
.
Offset
(
)
:
0
;
uint32_t
endOffset
=
content
=
=
splitRange
.
EndRef
(
)
.
GetContainer
(
)
?
splitRange
.
EndRef
(
)
.
Offset
(
)
:
content
-
>
Length
(
)
;
Result
<
SplitRangeOffFromNodeResult
nsresult
>
wrapTextInStyledElementResult
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
content
-
>
AsText
(
)
)
startOffset
endOffset
*
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
wrapTextInStyledElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
"
)
;
return
wrapTextInStyledElementResult
.
unwrapErr
(
)
;
}
SplitRangeOffFromNodeResult
unwrappedWrapTextInStyledElementResult
=
wrapTextInStyledElementResult
.
unwrap
(
)
;
unwrappedWrapTextInStyledElementResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
isCSSInvertibleStyle
)
{
MOZ_ASSERT
(
unwrappedWrapTextInStyledElementResult
.
GetMiddleContentAs
<
Text
>
(
)
)
;
if
(
Text
*
textNode
=
unwrappedWrapTextInStyledElementResult
.
GetMiddleContentAs
<
Text
>
(
)
)
{
if
(
textNode
!
=
content
)
{
arrayOfContentsToInvertStyle
.
ReplaceElementAt
(
arrayOfContentsToInvertStyle
.
Length
(
)
-
1
OwningNonNull
<
nsIContent
>
(
*
textNode
)
)
;
}
}
}
}
}
if
(
arrayOfContentsToInvertStyle
.
IsEmpty
(
)
)
{
continue
;
}
MOZ_ASSERT
(
isCSSInvertibleStyle
)
;
AutoTArray
<
OwningNonNull
<
Text
>
32
>
leafTextNodes
;
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContentsToInvertStyle
)
{
if
(
content
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
content
-
>
AsElement
(
)
leafTextNodes
)
;
}
}
for
(
const
OwningNonNull
<
Text
>
&
textNode
:
leafTextNodes
)
{
Result
<
bool
nsresult
>
isRemovableParentStyleOrError
=
IsRemovableParentStyleWithNewSpanElement
(
MOZ_KnownLive
(
textNode
)
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
)
;
if
(
isRemovableParentStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
)
"
"
failed
"
)
;
return
isRemovableParentStyleOrError
.
unwrapErr
(
)
;
}
if
(
!
isRemovableParentStyleOrError
.
unwrap
(
)
)
{
continue
;
}
Result
<
SplitRangeOffFromNodeResult
nsresult
>
wrapTextInStyledElementResult
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
textNode
)
0
textNode
-
>
TextLength
(
)
*
styleToRemove
.
mHTMLProperty
styleToRemove
.
mAttribute
u
"
-
moz
-
editor
-
invert
-
value
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
wrapTextInStyledElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
-
moz
-
editor
-
invert
-
"
"
value
)
failed
"
)
;
return
wrapTextInStyledElementResult
.
unwrapErr
(
)
;
}
wrapTextInStyledElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
MOZ_ASSERT
(
selectionRanges
.
HasSavedRanges
(
)
)
;
selectionRanges
.
RestoreFromSavedRanges
(
)
;
}
MOZ_ASSERT
(
!
selectionRanges
.
HasSavedRanges
(
)
)
;
nsresult
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
rv
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
nsIContent
&
aContent
nsAtom
*
aHTMLProperty
nsAtom
*
aAttribute
)
const
{
if
(
!
aHTMLProperty
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSInvertible
(
*
aHTMLProperty
aAttribute
)
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
aHTMLProperty
aAttribute
)
)
{
return
false
;
}
nsAutoString
emptyString
;
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
this
aContent
aHTMLProperty
aAttribute
emptyString
)
;
NS_WARNING_ASSERTION
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isOk
(
)
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
;
}
void
HTMLEditor
:
:
CollectEditableLeafTextNodes
(
Element
&
aElement
nsTArray
<
OwningNonNull
<
Text
>
>
&
aLeafTextNodes
)
const
{
for
(
nsIContent
*
child
=
aElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
child
-
>
AsElement
(
)
aLeafTextNodes
)
;
continue
;
}
if
(
child
-
>
IsText
(
)
)
{
aLeafTextNodes
.
AppendElement
(
*
child
-
>
AsText
(
)
)
;
}
}
}
nsresult
HTMLEditor
:
:
IncreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIncrementFontSize
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
IncrementOrDecrementFontSizeAsSubAction
(
FontSize
:
:
incr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
IncrementOrDecrementFontSizeAsSubAction
(
"
"
FontSize
:
:
incr
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DecreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDecrementFontSize
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
IncrementOrDecrementFontSizeAsSubAction
(
FontSize
:
:
decr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
IncrementOrDecrementFontSizeAsSubAction
(
"
"
FontSize
:
:
decr
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
IncrementOrDecrementFontSizeAsSubAction
(
FontSize
aIncrementOrDecrement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsStaticAtom
&
bigOrSmallTagName
=
aIncrementOrDecrement
=
=
FontSize
:
:
incr
?
*
nsGkAtoms
:
:
big
:
*
nsGkAtoms
:
:
small
;
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
const
auto
firstRangeStartPoint
=
EditorBase
:
:
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
firstRangeStartPoint
.
IsSet
(
)
)
)
{
return
NS_OK
;
}
Element
*
element
=
firstRangeStartPoint
.
GetContainerOrContainerParentElement
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
element
bigOrSmallTagName
)
)
{
return
NS_OK
;
}
mPendingStylesToApplyToNewContent
-
>
PreserveStyle
(
bigOrSmallTagName
nullptr
u
"
"
_ns
)
;
return
NS_OK
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
MOZ_ALWAYS_TRUE
(
selectionRanges
.
SaveAndTrackRanges
(
*
this
)
)
;
for
(
const
OwningNonNull
<
nsRange
>
&
domRange
:
selectionRanges
.
Ranges
(
)
)
{
if
(
NS_FAILED
(
PromoteInlineRange
(
*
domRange
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
PromoteInlineRange
(
)
failed
"
)
;
continue
;
}
EditorDOMRange
range
(
domRange
)
;
if
(
NS_WARN_IF
(
!
range
.
IsPositioned
(
)
)
)
{
continue
;
}
if
(
range
.
InSameContainer
(
)
&
&
range
.
StartRef
(
)
.
IsInTextNode
(
)
)
{
Result
<
CreateElementResult
nsresult
>
wrapInBigOrSmallElementResult
=
SetFontSizeOnTextNode
(
MOZ_KnownLive
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
range
.
StartRef
(
)
.
Offset
(
)
range
.
EndRef
(
)
.
Offset
(
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
wrapInBigOrSmallElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOnTextNode
(
)
failed
"
)
;
return
wrapInBigOrSmallElementResult
.
unwrapErr
(
)
;
}
wrapInBigOrSmallElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
continue
;
}
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
range
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfContents
;
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
if
(
NS_WARN_IF
(
!
subtreeIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
nsIContent
>
content
=
*
subtreeIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
content
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
Result
<
EditorDOMPoint
nsresult
>
fontChangeOnNodeResult
=
SetFontSizeWithBigOrSmallElement
(
MOZ_KnownLive
(
content
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
fontChangeOnNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeWithBigOrSmallElement
(
)
failed
"
)
;
return
fontChangeOnNodeResult
.
unwrapErr
(
)
;
}
}
}
if
(
range
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
!
range
.
StartRef
(
)
.
IsEndOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
Result
<
CreateElementResult
nsresult
>
wrapInBigOrSmallElementResult
=
SetFontSizeOnTextNode
(
MOZ_KnownLive
(
*
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
range
.
StartRef
(
)
.
Offset
(
)
range
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextDataLength
(
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
wrapInBigOrSmallElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOnTextNode
(
)
failed
"
)
;
return
wrapInBigOrSmallElementResult
.
unwrapErr
(
)
;
}
wrapInBigOrSmallElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
range
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
!
range
.
EndRef
(
)
.
IsStartOfContainer
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
range
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
EditorType
:
:
HTML
)
)
{
Result
<
CreateElementResult
nsresult
>
wrapInBigOrSmallElementResult
=
SetFontSizeOnTextNode
(
MOZ_KnownLive
(
*
range
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
)
0u
range
.
EndRef
(
)
.
Offset
(
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
wrapInBigOrSmallElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOnTextNode
(
)
failed
"
)
;
return
wrapInBigOrSmallElementResult
.
unwrapErr
(
)
;
}
wrapInBigOrSmallElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
MOZ_ASSERT
(
selectionRanges
.
HasSavedRanges
(
)
)
;
selectionRanges
.
RestoreFromSavedRanges
(
)
;
nsresult
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
rv
;
}
Result
<
CreateElementResult
nsresult
>
HTMLEditor
:
:
SetFontSizeOnTextNode
(
Text
&
aTextNode
uint32_t
aStartOffset
uint32_t
aEndOffset
FontSize
aIncrementOrDecrement
)
{
if
(
aStartOffset
=
=
aEndOffset
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
if
(
!
aTextNode
.
GetParentNode
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aTextNode
.
GetParentNode
(
)
*
nsGkAtoms
:
:
big
)
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
aEndOffset
=
std
:
:
min
(
aTextNode
.
Length
(
)
aEndOffset
)
;
RefPtr
<
Text
>
textNodeForTheRange
=
&
aTextNode
;
EditorDOMPoint
pointToPutCaret
;
{
auto
pointToPutCaretOrError
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
EditorDOMPoint
nsresult
>
{
EditorDOMPoint
pointToPutCaret
;
EditorDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
SplitNodeResult
splitAtEndResult
=
SplitNodeWithTransaction
(
atEnd
)
;
if
(
splitAtEndResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
splitAtEndResult
.
unwrapErr
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitAtEndResult
.
HasCaretPointSuggestion
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
suggest
caret
"
"
point
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
splitAtEndResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
}
)
;
MOZ_ASSERT_IF
(
AllowsTransactionsToChangeSelection
(
)
pointToPutCaret
.
IsSet
(
)
)
;
textNodeForTheRange
=
Text
:
:
FromNodeOrNull
(
splitAtEndResult
.
GetPreviousContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
textNodeForTheRange
)
;
splitAtEndResult
.
IgnoreCaretPointSuggestion
(
)
;
}
EditorDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
SplitNodeResult
splitAtStartResult
=
SplitNodeWithTransaction
(
atStart
)
;
if
(
splitAtStartResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
splitAtStartResult
.
unwrapErr
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitAtStartResult
.
HasCaretPointSuggestion
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
suggest
caret
"
"
point
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
splitAtStartResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
}
)
;
MOZ_ASSERT_IF
(
AllowsTransactionsToChangeSelection
(
)
pointToPutCaret
.
IsSet
(
)
)
;
textNodeForTheRange
=
Text
:
:
FromNodeOrNull
(
splitAtStartResult
.
GetNextContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
textNodeForTheRange
)
;
splitAtStartResult
.
IgnoreCaretPointSuggestion
(
)
;
}
return
pointToPutCaret
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
return
pointToPutCaretOrError
.
propagateErr
(
)
;
}
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
nsStaticAtom
*
const
bigOrSmallTagName
=
aIncrementOrDecrement
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
nsCOMPtr
<
nsIContent
>
sibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
*
textNodeForTheRange
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
bigOrSmallTagName
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveTextNodeResult
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
if
(
MOZ_UNLIKELY
(
moveTextNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveTextNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveTextNodeResult
=
moveTextNodeResult
.
unwrap
(
)
;
unwrappedMoveTextNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
sibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
textNodeForTheRange
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
bigOrSmallTagName
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveTextNodeResult
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorDOMPoint
(
sibling
0u
)
)
;
if
(
MOZ_UNLIKELY
(
moveTextNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveTextNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveTextNodeResult
=
moveTextNodeResult
.
unwrap
(
)
;
unwrappedMoveTextNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
CreateElementResult
nsresult
>
wrapTextInBigOrSmallElementResult
=
InsertContainerWithTransaction
(
*
textNodeForTheRange
MOZ_KnownLive
(
*
bigOrSmallTagName
)
)
;
if
(
wrapTextInBigOrSmallElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
wrapTextInBigOrSmallElementResult
;
}
CreateElementResult
unwrappedWrapTextInBigOrSmallElementResult
=
wrapTextInBigOrSmallElementResult
.
unwrap
(
)
;
unwrappedWrapTextInBigOrSmallElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CreateElementResult
(
unwrappedWrapTextInBigOrSmallElementResult
.
UnwrapNewNode
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SetFontSizeOfFontElementChildren
(
nsIContent
&
aContent
FontSize
aIncrementOrDecrement
)
{
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
font
)
&
&
aContent
.
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
size
)
)
{
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfContents
;
HTMLEditor
:
:
GetChildNodesOf
(
aContent
arrayOfContents
)
;
for
(
const
auto
&
child
:
arrayOfContents
)
{
Result
<
EditorDOMPoint
nsresult
>
setFontSizeOfChildResult
=
SetFontSizeWithBigOrSmallElement
(
MOZ_KnownLive
(
child
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
setFontSizeOfChildResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
WrapContentInBigOrSmallElement
(
)
failed
"
)
;
return
setFontSizeOfChildResult
;
}
if
(
setFontSizeOfChildResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
setFontSizeOfChildResult
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfContents
;
HTMLEditor
:
:
GetChildNodesOf
(
aContent
arrayOfContents
)
;
for
(
const
auto
&
child
:
arrayOfContents
)
{
Result
<
EditorDOMPoint
nsresult
>
fontSizeChangeResult
=
SetFontSizeOfFontElementChildren
(
MOZ_KnownLive
(
child
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
fontSizeChangeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOfFontElementChildren
(
)
failed
"
)
;
return
fontSizeChangeResult
;
}
if
(
fontSizeChangeResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
fontSizeChangeResult
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SetFontSizeWithBigOrSmallElement
(
nsIContent
&
aContent
FontSize
aIncrementOrDecrement
)
{
nsStaticAtom
*
const
bigOrSmallTagName
=
aIncrementOrDecrement
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
if
(
(
aIncrementOrDecrement
=
=
FontSize
:
:
incr
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
|
|
(
aIncrementOrDecrement
=
=
FontSize
:
:
decr
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
big
)
)
)
{
Result
<
EditorDOMPoint
nsresult
>
fontSizeChangeOfDescendantsResult
=
SetFontSizeOfFontElementChildren
(
aContent
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
fontSizeChangeOfDescendantsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOfFontElementChildren
(
)
failed
"
)
;
return
fontSizeChangeOfDescendantsResult
;
}
EditorDOMPoint
pointToPutCaret
=
fontSizeChangeOfDescendantsResult
.
unwrap
(
)
;
Result
<
EditorDOMPoint
nsresult
>
unwrapBigOrSmallElementResult
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapBigOrSmallElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapBigOrSmallElementResult
;
}
if
(
unwrapBigOrSmallElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapBigOrSmallElementResult
.
unwrap
(
)
;
}
return
pointToPutCaret
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
bigOrSmallTagName
aContent
)
)
{
Result
<
EditorDOMPoint
nsresult
>
fontSizeChangeOfDescendantsResult
=
SetFontSizeOfFontElementChildren
(
aContent
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
fontSizeChangeOfDescendantsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOfFontElementChildren
(
)
failed
"
)
;
return
fontSizeChangeOfDescendantsResult
;
}
EditorDOMPoint
pointToPutCaret
=
fontSizeChangeOfDescendantsResult
.
unwrap
(
)
;
nsCOMPtr
<
nsIContent
>
sibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
bigOrSmallTagName
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveNodeResult
=
MoveNodeToEndWithTransaction
(
aContent
*
sibling
)
;
if
(
MOZ_UNLIKELY
(
moveNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveNodeResult
=
moveNodeResult
.
unwrap
(
)
;
unwrappedMoveNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
pointToPutCaret
;
}
sibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
bigOrSmallTagName
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveNodeResult
=
MoveNodeWithTransaction
(
aContent
EditorDOMPoint
(
sibling
0u
)
)
;
if
(
MOZ_UNLIKELY
(
moveNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
propagateErr
(
)
;
}
MoveNodeResult
unwrappedMoveNodeResult
=
moveNodeResult
.
unwrap
(
)
;
unwrappedMoveNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
pointToPutCaret
;
}
Result
<
CreateElementResult
nsresult
>
wrapInBigOrSmallElementResult
=
InsertContainerWithTransaction
(
aContent
MOZ_KnownLive
(
*
bigOrSmallTagName
)
)
;
if
(
MOZ_UNLIKELY
(
wrapInBigOrSmallElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
Err
(
wrapInBigOrSmallElementResult
.
unwrapErr
(
)
)
;
}
CreateElementResult
unwrappedWrapInBigOrSmallElementResult
=
wrapInBigOrSmallElementResult
.
unwrap
(
)
;
MOZ_ASSERT
(
unwrappedWrapInBigOrSmallElementResult
.
GetNewNode
(
)
)
;
unwrappedWrapInBigOrSmallElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
pointToPutCaret
;
}
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfContents
;
HTMLEditor
:
:
GetChildNodesOf
(
aContent
arrayOfContents
)
;
for
(
const
auto
&
child
:
arrayOfContents
)
{
Result
<
EditorDOMPoint
nsresult
>
setFontSizeOfChildResult
=
SetFontSizeWithBigOrSmallElement
(
MOZ_KnownLive
(
child
)
aIncrementOrDecrement
)
;
if
(
MOZ_UNLIKELY
(
setFontSizeOfChildResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeWithBigOrSmallElement
(
)
failed
"
)
;
return
setFontSizeOfChildResult
;
}
if
(
setFontSizeOfChildResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
setFontSizeOfChildResult
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontFaceState
(
bool
*
aMixed
nsAString
&
outFace
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
outFace
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
nullptr
&
first
&
any
&
all
&
outFace
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
tt
nullptr
nullptr
&
first
&
any
&
all
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
tt
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
outFace
.
AssignLiteral
(
"
tt
"
)
;
}
if
(
!
any
)
{
outFace
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetFontColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
aOutColor
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
nullptr
&
first
&
any
&
all
&
aOutColor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
if
(
!
any
)
{
aOutColor
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetIsCSSEnabled
(
bool
*
aIsCSSEnabled
)
{
*
aIsCSSEnabled
=
IsCSSEnabled
(
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
Element
&
aElement
)
{
return
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
_class
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
id
)
;
}
}
