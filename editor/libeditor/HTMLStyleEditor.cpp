#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
bool
HTMLEditor
:
:
IsEmptyTextNode
(
nsINode
&
aNode
)
{
bool
isEmptyTextNode
=
false
;
return
EditorBase
:
:
IsTextNode
(
&
aNode
)
&
&
NS_SUCCEEDED
(
IsEmptyNode
(
&
aNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
AutoTransactionBatch
treatAsOneTransaction
(
*
this
)
;
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sub
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sup
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
SetInlinePropertyInternal
(
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
if
(
NS_WARN_IF
(
!
property
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
SetInlinePropertyInternal
(
*
property
attribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyInternal
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
NS_WARN_IF
(
!
mRules
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selection
-
>
IsCollapsed
(
)
)
{
mTypeInState
-
>
SetProp
(
&
aProperty
aAttribute
aValue
)
;
return
NS_OK
;
}
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
bool
cancel
handled
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eSetTextProperty
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
cancel
&
&
!
handled
)
{
AutoRangeArray
arrayOfRanges
(
selection
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
startNode
&
&
startNode
=
=
endNode
&
&
startNode
-
>
GetAsText
(
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsContent
(
)
&
&
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startNode
&
&
startNode
-
>
GetAsText
(
)
&
&
IsEditable
(
startNode
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
SetInlinePropertyOnNode
(
*
node
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
endNode
&
&
endNode
-
>
GetAsText
(
)
&
&
IsEditable
(
endNode
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
endNode
-
>
GetAsText
(
)
0
range
-
>
EndOffset
(
)
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
if
(
cancel
)
{
return
NS_OK
;
}
rv
=
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsSimpleModifiableNode
(
nsIContent
*
aContent
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
)
{
MOZ_ASSERT
(
aProperty
)
;
MOZ_ASSERT_IF
(
aAttribute
aValue
)
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aContent
)
;
if
(
!
element
)
{
return
false
;
}
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
!
element
-
>
GetAttrCount
(
)
&
&
!
aAttribute
)
{
return
true
;
}
if
(
!
element
-
>
GetAttrCount
(
)
&
&
(
(
aProperty
=
=
nsGkAtoms
:
:
b
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
strong
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
i
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
em
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
strike
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
s
)
)
)
)
{
return
true
;
}
if
(
aAttribute
)
{
nsString
attrValue
;
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
IsOnlyAttribute
(
element
aAttribute
)
&
&
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
attrValue
)
&
&
attrValue
.
Equals
(
*
aValue
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
element
aProperty
aAttribute
)
|
|
!
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
|
|
element
-
>
GetAttrCount
(
)
!
=
1
|
|
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
newSpan
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
NS_ASSERTION
(
newSpan
"
CreateHTMLContent
failed
"
)
;
NS_ENSURE_TRUE
(
newSpan
false
)
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
newSpan
aProperty
aAttribute
aValue
true
)
;
return
CSSEditUtils
:
:
ElementsSameStyle
(
newSpan
element
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
Text
&
aText
int32_t
aStartOffset
int32_t
aEndOffset
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
aText
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aText
.
GetParentNode
(
)
aProperty
)
)
{
return
NS_OK
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aText
&
aProperty
aAttribute
)
)
{
if
(
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aText
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aText
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aText
;
EditorRawDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorRawDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
if
(
aAttribute
)
{
nsIContent
*
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
return
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
return
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorRawDOMPoint
(
sibling
0
)
)
;
}
}
return
SetInlinePropertyOnNode
(
*
textNodeForTheRange
aProperty
aAttribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
TagCanContain
(
*
nsGkAtoms
:
:
span
aNode
)
)
{
if
(
aNode
.
HasChildren
(
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
child
)
&
&
!
IsEmptyTextNode
(
*
child
)
)
{
arrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
node
aProperty
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
previousSibling
=
GetPriorHTMLSibling
(
&
aNode
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
GetNextHTMLSibling
(
&
aNode
)
;
if
(
IsSimpleModifiableNode
(
previousSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aNode
*
previousSibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
rv
=
JoinNodesWithTransaction
(
*
previousSibling
*
nextSibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aNode
EditorRawDOMPoint
(
nextSibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
{
if
(
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aNode
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aNode
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
bool
useCSS
=
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
;
if
(
useCSS
)
{
RefPtr
<
dom
:
:
Element
>
tmp
;
if
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aNode
.
AsElement
(
)
-
>
GetAttrCount
(
)
)
{
tmp
=
aNode
.
AsElement
(
)
;
}
else
{
tmp
=
InsertContainerWithTransaction
(
aNode
*
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
!
tmp
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
tmp
&
aProperty
aAttribute
&
aValue
false
)
;
return
NS_OK
;
}
if
(
aNode
.
IsHTMLElement
(
&
aProperty
)
)
{
if
(
NS_WARN_IF
(
!
aAttribute
)
)
{
return
NS_ERROR_FAILURE
;
}
return
SetAttributeWithTransaction
(
*
aNode
.
AsElement
(
)
*
aAttribute
aValue
)
;
}
RefPtr
<
Element
>
tmp
=
InsertContainerWithTransaction
(
aNode
aProperty
aAttribute
?
*
aAttribute
:
*
nsGkAtoms
:
:
_empty
aValue
)
;
if
(
NS_WARN_IF
(
!
tmp
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNode
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIContent
>
previousSibling
=
aNode
.
GetPreviousSibling
(
)
nextSibling
=
aNode
.
GetNextSibling
(
)
;
NS_ENSURE_STATE
(
aNode
.
GetParentNode
(
)
)
;
OwningNonNull
<
nsINode
>
parent
=
*
aNode
.
GetParentNode
(
)
;
nsresult
rv
=
RemoveStyleInside
(
aNode
&
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aNode
.
GetParentNode
(
)
)
{
return
SetInlinePropertyOnNodeImpl
(
aNode
aProperty
aAttribute
aValue
)
;
}
if
(
(
previousSibling
&
&
previousSibling
-
>
GetParentNode
(
)
!
=
parent
)
|
|
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsTArray
<
OwningNonNull
<
nsIContent
>
>
nodesToSet
;
nsCOMPtr
<
nsIContent
>
cur
=
previousSibling
?
previousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
for
(
;
cur
&
&
cur
!
=
nextSibling
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
cur
)
)
{
nodesToSet
.
AppendElement
(
*
cur
)
;
}
}
for
(
auto
&
node
:
nodesToSet
)
{
rv
=
SetInlinePropertyOnNodeImpl
(
node
aProperty
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitStyleAboveRange
(
nsRange
*
inRange
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
NS_ENSURE_TRUE
(
inRange
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
startNode
=
inRange
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
inRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
inRange
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
inRange
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
origStartNode
=
startNode
;
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
nsresult
rv
=
SplitStyleAbovePoint
(
address_of
(
startNode
)
&
startOffset
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
SplitStyleAbovePoint
(
address_of
(
endNode
)
&
endOffset
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
inRange
-
>
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitStyleAbovePoint
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsAtom
*
aProperty
nsAtom
*
aAttribute
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
)
{
NS_ENSURE_TRUE
(
aNode
&
&
*
aNode
&
&
aOffset
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
(
*
aNode
)
-
>
IsContent
(
)
NS_OK
)
;
if
(
aOutLeftNode
)
{
*
aOutLeftNode
=
nullptr
;
}
if
(
aOutRightNode
)
{
*
aOutRightNode
=
nullptr
;
}
nsCOMPtr
<
nsIContent
>
node
=
(
*
aNode
)
-
>
AsContent
(
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
bool
isSet
;
while
(
!
IsBlockNode
(
node
)
&
&
node
-
>
GetParent
(
)
&
&
IsEditable
(
node
-
>
GetParent
(
)
)
)
{
isSet
=
false
;
if
(
useCSS
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
node
aProperty
aAttribute
)
)
{
nsAutoString
firstValue
;
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
node
aProperty
aAttribute
firstValue
CSSEditUtils
:
:
eSpecified
)
;
}
if
(
(
aProperty
&
&
node
-
>
IsHTMLElement
(
aProperty
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
node
)
)
|
|
(
!
aProperty
&
&
NodeIsProperty
(
*
node
)
)
|
|
isSet
)
{
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
node
EditorRawDOMPoint
(
*
aNode
*
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
Failed
to
split
the
node
"
)
;
EditorRawDOMPoint
atRightNode
(
splitNodeResult
.
SplitPoint
(
)
)
;
*
aNode
=
atRightNode
.
GetContainer
(
)
;
*
aOffset
=
atRightNode
.
Offset
(
)
;
if
(
aOutLeftNode
)
{
NS_IF_ADDREF
(
*
aOutLeftNode
=
splitNodeResult
.
GetPreviousNode
(
)
)
;
}
if
(
aOutRightNode
)
{
NS_IF_ADDREF
(
*
aOutRightNode
=
splitNodeResult
.
GetNextNode
(
)
)
;
}
}
node
=
node
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ClearStyle
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
nsCOMPtr
<
nsIContent
>
leftNode
rightNode
;
nsresult
rv
=
SplitStyleAbovePoint
(
aNode
aOffset
aProperty
aAttribute
getter_AddRefs
(
leftNode
)
getter_AddRefs
(
rightNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
leftNode
)
{
bool
bIsEmptyNode
;
IsEmptyNode
(
leftNode
&
bIsEmptyNode
false
true
)
;
if
(
bIsEmptyNode
)
{
rv
=
DeleteNodeWithTransaction
(
*
leftNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
rightNode
)
{
nsCOMPtr
<
nsINode
>
secondSplitParent
=
GetLeftmostChild
(
rightNode
)
;
if
(
!
secondSplitParent
)
{
secondSplitParent
=
rightNode
;
}
nsCOMPtr
<
Element
>
savedBR
;
if
(
!
IsContainer
(
secondSplitParent
)
)
{
if
(
TextEditUtils
:
:
IsBreak
(
secondSplitParent
)
)
{
savedBR
=
do_QueryInterface
(
secondSplitParent
)
;
NS_ENSURE_STATE
(
savedBR
)
;
}
secondSplitParent
=
secondSplitParent
-
>
GetParentNode
(
)
;
}
*
aOffset
=
0
;
rv
=
SplitStyleAbovePoint
(
address_of
(
secondSplitParent
)
aOffset
aProperty
aAttribute
getter_AddRefs
(
leftNode
)
getter_AddRefs
(
rightNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rightNode
)
{
bool
bIsEmptyNode
;
IsEmptyNode
(
rightNode
&
bIsEmptyNode
false
true
)
;
if
(
bIsEmptyNode
)
{
rv
=
DeleteNodeWithTransaction
(
*
rightNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
leftNode
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
newSelParent
=
GetLeftmostChild
(
leftNode
)
;
if
(
!
newSelParent
)
{
newSelParent
=
leftNode
;
}
if
(
savedBR
)
{
rv
=
MoveNodeWithTransaction
(
*
savedBR
EditorRawDOMPoint
(
newSelParent
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
int32_t
newSelOffset
=
0
;
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
address_of
(
newSelParent
)
&
newSelOffset
)
;
rv
=
RemoveStyleInside
(
*
leftNode
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
*
aNode
=
newSelParent
;
*
aOffset
=
newSelOffset
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
NodeIsProperty
(
nsINode
&
aNode
)
{
return
IsContainer
(
&
aNode
)
&
&
IsEditable
(
&
aNode
)
&
&
!
IsBlockNode
(
&
aNode
)
&
&
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
a
)
;
}
nsresult
HTMLEditor
:
:
RemoveStyleInside
(
nsIContent
&
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
bool
aChildrenOnly
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
next
=
child
-
>
GetNextSibling
(
)
;
nsresult
rv
=
RemoveStyleInside
(
*
child
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
next
.
forget
(
)
;
}
if
(
!
aChildrenOnly
&
&
(
(
aProperty
&
&
aNode
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aProperty
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
&
aNode
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
name
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aNode
)
)
|
|
(
!
aProperty
&
&
NodeIsProperty
(
aNode
)
)
)
)
{
if
(
!
aAttribute
)
{
bool
hasStyleAttr
=
aNode
.
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
;
bool
hasClassAttr
=
aNode
.
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
;
if
(
aProperty
&
&
(
hasStyleAttr
|
|
hasClassAttr
)
)
{
RefPtr
<
Element
>
spanNode
=
InsertContainerWithTransaction
(
aNode
*
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
!
spanNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
style
*
spanNode
*
aNode
.
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
_class
*
spanNode
*
aNode
.
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
*
aNode
.
AsElement
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aNode
.
IsElement
(
)
)
{
if
(
aNode
.
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
if
(
IsOnlyAttribute
(
aNode
.
AsElement
(
)
aAttribute
)
)
{
nsresult
rv
=
RemoveContainerWithTransaction
(
*
aNode
.
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
aNode
.
AsElement
(
)
*
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
}
if
(
!
aChildrenOnly
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aNode
aProperty
aAttribute
)
)
{
if
(
aNode
.
IsElement
(
)
)
{
bool
hasAttribute
=
CSSEditUtils
:
:
HaveCSSEquivalentStyles
(
aNode
aProperty
aAttribute
CSSEditUtils
:
:
eSpecified
)
;
if
(
hasAttribute
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aNode
.
AsElement
(
)
aProperty
aAttribute
nullptr
false
)
;
RemoveElementIfNoStyleOrIdOrClass
(
*
aNode
.
AsElement
(
)
)
;
}
}
}
if
(
aChildrenOnly
)
{
return
NS_OK
;
}
if
(
aProperty
=
=
nsGkAtoms
:
:
font
&
&
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
big
)
|
|
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
return
RemoveContainerWithTransaction
(
*
aNode
.
AsElement
(
)
)
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsOnlyAttribute
(
const
Element
*
aElement
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
aElement
)
;
uint32_t
attrCount
=
aElement
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
aElement
-
>
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
false
;
}
if
(
name
-
>
LocalName
(
)
!
=
aAttribute
)
{
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
NS_LITERAL_STRING
(
"
_moz
"
)
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
startNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
startNode
=
parent
-
>
GetParentNode
(
)
;
startOffset
=
startNode
?
startNode
-
>
ComputeIndexOf
(
parent
)
:
-
1
;
}
parent
=
endNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
endNode
=
parent
-
>
GetParentNode
(
)
;
endOffset
=
endNode
?
endNode
-
>
ComputeIndexOf
(
parent
)
+
1
:
0
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PromoteInlineRange
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
while
(
startNode
&
&
!
startNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
startNode
)
&
&
IsAtFrontOfNode
(
*
startNode
startOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
startNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
startOffset
=
parent
-
>
ComputeIndexOf
(
startNode
)
;
startNode
=
parent
;
}
while
(
endNode
&
&
!
endNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
endNode
)
&
&
IsAtEndOfNode
(
*
endNode
endOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
endNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
endOffset
=
1
+
parent
-
>
ComputeIndexOf
(
endNode
)
;
endNode
=
parent
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsAtFrontOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
!
aOffset
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
firstNode
=
GetFirstEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
firstNode
true
)
;
if
(
aNode
.
ComputeIndexOf
(
firstNode
)
<
aOffset
)
{
return
false
;
}
return
true
;
}
bool
HTMLEditor
:
:
IsAtEndOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
aOffset
=
=
(
int32_t
)
aNode
.
Length
(
)
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
lastNode
=
GetLastEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
lastNode
true
)
;
if
(
aNode
.
ComputeIndexOf
(
lastNode
)
<
aOffset
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyBase
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
)
{
*
aAny
=
false
;
*
aAll
=
true
;
*
aFirst
=
false
;
bool
first
=
true
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
bool
isCollapsed
=
selection
-
>
IsCollapsed
(
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
range
)
{
bool
firstNodeInRange
=
true
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
collapsedNode
=
range
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
collapsedNode
NS_ERROR_FAILURE
)
;
bool
isSet
theSetting
;
nsString
tOutString
;
if
(
aAttribute
)
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
aAttribute
&
tOutString
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
}
else
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
)
;
}
if
(
isSet
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
theSetting
;
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
collapsedNode
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
tOutString
.
Assign
(
*
aValue
)
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
collapsedNode
&
aProperty
aAttribute
tOutString
CSSEditUtils
:
:
eComputed
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
NS_OK
;
}
isSet
=
IsTextPropertySetByContent
(
collapsedNode
&
aProperty
aAttribute
aValue
outValue
)
;
*
aFirst
=
*
aAny
=
*
aAll
=
isSet
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsAutoString
firstValue
theValue
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
for
(
iter
-
>
Init
(
range
)
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
if
(
!
iter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
iter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
content
-
>
GetAsText
(
)
&
&
(
!
IsEditable
(
content
)
|
|
IsEmptyTextNode
(
*
content
)
)
)
{
continue
;
}
if
(
content
-
>
GetAsText
(
)
)
{
if
(
!
isCollapsed
&
&
first
&
&
firstNodeInRange
)
{
firstNodeInRange
=
false
;
if
(
range
-
>
StartOffset
(
)
=
=
content
-
>
Length
(
)
)
{
continue
;
}
}
else
if
(
content
=
=
endNode
&
&
!
endOffset
)
{
continue
;
}
}
else
if
(
content
-
>
IsElement
(
)
)
{
continue
;
}
bool
isSet
=
false
;
if
(
first
)
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
firstValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
firstValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
firstValue
)
;
}
*
aFirst
=
isSet
;
first
=
false
;
if
(
outValue
)
{
*
outValue
=
firstValue
;
}
}
else
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
theValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
theValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
theValue
)
;
}
if
(
firstValue
!
=
theValue
)
{
*
aAll
=
false
;
}
}
if
(
isSet
)
{
*
aAny
=
true
;
}
else
{
*
aAll
=
false
;
}
}
}
if
(
!
*
aAny
)
{
*
aAll
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
GetInlineProperty
(
property
attribute
aValue
aFirst
aAny
aAll
)
;
}
nsresult
HTMLEditor
:
:
GetInlineProperty
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
{
NS_ENSURE_TRUE
(
aProperty
&
&
aFirst
&
&
aAny
&
&
aAll
NS_ERROR_NULL_POINTER
)
;
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
return
GetInlinePropertyBase
(
*
aProperty
aAttribute
val
aFirst
aAny
aAll
nullptr
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
GetInlinePropertyWithAttrValue
(
property
attribute
aValue
aFirst
aAny
aAll
outValue
)
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
NS_ENSURE_TRUE
(
aProperty
&
&
aFirst
&
&
aAny
&
&
aAll
NS_ERROR_NULL_POINTER
)
;
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
return
GetInlinePropertyBase
(
*
aProperty
aAttribute
val
aFirst
aAny
aAll
&
outValue
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveAllInlineProperties
(
)
{
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eRemoveAllTextProperties
nsIEditor
:
:
eNext
)
;
nsresult
rv
=
RemoveInlinePropertyInternal
(
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
RemoveInlinePropertyInternal
(
property
attribute
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
if
(
NS_WARN_IF
(
!
mRules
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selection
-
>
IsCollapsed
(
)
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
href
|
|
aProperty
=
=
nsGkAtoms
:
:
name
)
{
aProperty
=
nsGkAtoms
:
:
a
;
}
if
(
aProperty
)
{
mTypeInState
-
>
ClearProp
(
aProperty
aAttribute
)
;
}
else
{
mTypeInState
-
>
ClearAllProps
(
)
;
}
return
NS_OK
;
}
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eRemoveTextProperty
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
bool
cancel
handled
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eRemoveTextProperty
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
cancel
&
&
!
handled
)
{
AutoRangeArray
arrayOfRanges
(
selection
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
name
)
{
rv
=
PromoteRangeIfStartsOrEndsInNamedAnchor
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
SplitStyleAboveRange
(
range
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
startNode
&
&
startNode
=
=
endNode
&
&
startNode
-
>
GetAsText
(
)
)
{
if
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
startNode
aProperty
aAttribute
)
)
{
if
(
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
startNode
aProperty
aAttribute
EmptyString
(
)
CSSEditUtils
:
:
eComputed
)
)
{
if
(
CSSEditUtils
:
:
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
NS_NAMED_LITERAL_STRING
(
value
"
-
moz
-
editor
-
invert
-
value
"
)
;
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
*
aProperty
aAttribute
value
)
;
}
}
}
}
else
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
iter
-
>
Init
(
range
)
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
IsEditable
(
node
)
&
&
node
-
>
IsContent
(
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
RemoveStyleInside
(
node
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
node
aProperty
aAttribute
)
&
&
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
node
aProperty
aAttribute
EmptyString
(
)
CSSEditUtils
:
:
eComputed
)
&
&
CSSEditUtils
:
:
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
NS_NAMED_LITERAL_STRING
(
value
"
-
moz
-
editor
-
invert
-
value
"
)
;
SetInlinePropertyOnNode
(
node
*
aProperty
aAttribute
value
)
;
}
}
}
}
}
if
(
cancel
)
{
return
NS_OK
;
}
rv
=
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IncreaseFontSize
(
)
{
return
RelativeFontChange
(
FontSize
:
:
incr
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DecreaseFontSize
(
)
{
return
RelativeFontChange
(
FontSize
:
:
decr
)
;
}
nsresult
HTMLEditor
:
:
RelativeFontChange
(
FontSize
aDir
)
{
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
nsAtom
&
atom
=
aDir
=
=
FontSize
:
:
incr
?
*
nsGkAtoms
:
:
big
:
*
nsGkAtoms
:
:
small
;
NS_ENSURE_TRUE
(
selection
-
>
RangeCount
(
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
NS_OK
)
;
OwningNonNull
<
nsINode
>
selectedNode
=
*
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
if
(
IsTextNode
(
selectedNode
)
)
{
NS_ENSURE_TRUE
(
selectedNode
-
>
GetParentNode
(
)
NS_OK
)
;
selectedNode
=
*
selectedNode
-
>
GetParentNode
(
)
;
}
if
(
!
CanContainTag
(
selectedNode
atom
)
)
{
return
NS_OK
;
}
mTypeInState
-
>
SetProp
(
&
atom
nullptr
EmptyString
(
)
)
;
return
NS_OK
;
}
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eSetTextProperty
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
arrayOfRanges
(
selection
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
startNode
=
=
endNode
&
&
IsTextNode
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
NS_ENSURE_TRUE
(
iter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
nsIContent
>
node
=
*
iter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
node
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
RelativeFontChangeOnNode
(
aDir
=
=
FontSize
:
:
incr
?
+
1
:
-
1
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
IsTextNode
(
startNode
)
&
&
IsEditable
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsTextNode
(
endNode
)
&
&
IsEditable
(
endNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
endNode
-
>
GetAsText
(
)
0
range
-
>
EndOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
FontSize
aDir
Text
&
aTextNode
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
!
aTextNode
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aTextNode
.
GetParentNode
(
)
*
nsGkAtoms
:
:
big
)
)
{
return
NS_OK
;
}
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aTextNode
.
Length
(
)
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aTextNode
;
EditorRawDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorRawDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
nsAtom
*
nodeType
=
aDir
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorRawDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
textNodeForTheRange
*
nodeType
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeHelper
(
int32_t
aSizeChange
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
font
)
&
&
aNode
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
size
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnNode
(
int32_t
aSizeChange
nsIContent
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsAtom
*
atom
;
if
(
aSizeChange
=
=
1
)
{
atom
=
nsGkAtoms
:
:
big
;
}
else
{
atom
=
nsGkAtoms
:
:
small
;
}
if
(
(
aSizeChange
=
=
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
|
|
(
aSizeChange
=
=
-
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
big
)
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveContainerWithTransaction
(
*
aNode
-
>
AsElement
(
)
)
;
}
if
(
TagCanContain
(
*
atom
*
aNode
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIContent
*
sibling
=
GetPriorHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNodeToEndWithTransaction
(
*
aNode
*
sibling
)
;
}
sibling
=
GetNextHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNodeWithTransaction
(
*
aNode
EditorRawDOMPoint
(
sibling
0
)
)
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
aNode
*
atom
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontFaceState
(
bool
*
aMixed
nsAString
&
outFace
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_FAILURE
)
;
*
aMixed
=
true
;
outFace
.
Truncate
(
)
;
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
nullptr
&
first
&
any
&
all
&
outFace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
tt
nullptr
nullptr
&
first
&
any
&
all
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
any
&
&
!
all
)
{
return
rv
;
}
if
(
all
)
{
*
aMixed
=
false
;
outFace
.
AssignLiteral
(
"
tt
"
)
;
}
if
(
!
any
)
{
outFace
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetFontColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
aOutColor
.
Truncate
(
)
;
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
nullptr
&
first
&
any
&
all
&
aOutColor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
if
(
!
any
)
{
aOutColor
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetIsCSSEnabled
(
bool
*
aIsCSSEnabled
)
{
*
aIsCSSEnabled
=
IsCSSEnabled
(
)
;
return
NS_OK
;
}
static
bool
HasNonEmptyAttribute
(
Element
*
aElement
nsAtom
*
aName
)
{
MOZ_ASSERT
(
aElement
)
;
nsAutoString
value
;
return
aElement
-
>
GetAttr
(
kNameSpaceID_None
aName
value
)
&
&
!
value
.
IsEmpty
(
)
;
}
bool
HTMLEditor
:
:
HasStyleOrIdOrClass
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
return
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
style
)
|
|
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
_class
)
|
|
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
id
)
;
}
nsresult
HTMLEditor
:
:
RemoveElementIfNoStyleOrIdOrClass
(
Element
&
aElement
)
{
if
(
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
font
)
)
|
|
HasStyleOrIdOrClass
(
&
aElement
)
)
{
return
NS_OK
;
}
return
RemoveContainerWithTransaction
(
aElement
)
;
}
}
