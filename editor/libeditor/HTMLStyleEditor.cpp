#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
static
already_AddRefed
<
nsAtom
>
AtomizeAttribute
(
const
nsAString
&
aAttribute
)
{
if
(
aAttribute
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
NS_Atomize
(
aAttribute
)
;
}
bool
HTMLEditor
:
:
IsEmptyTextNode
(
nsINode
&
aNode
)
const
{
bool
isEmptyTextNode
=
false
;
return
EditorBase
:
:
IsTextNode
(
&
aNode
)
&
&
NS_SUCCEEDED
(
IsEmptyNode
(
&
aNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aProperty
aAttribute
true
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
AutoTransactionBatch
treatAsOneTransaction
(
*
this
)
;
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sub
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
else
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
nsresult
rv
=
RemoveInlinePropertyInternal
(
nsGkAtoms
:
:
sup
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
nsresult
rv
=
SetInlinePropertyInternal
(
aProperty
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
if
(
NS_WARN_IF
(
!
property
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsAtom
>
attribute
=
AtomizeAttribute
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
true
)
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eSetFontFamilyProperty
:
MOZ_ASSERT
(
!
aValue
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aValue
)
;
break
;
case
EditAction
:
:
eSetColorProperty
:
case
EditAction
:
:
eSetBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
aValue
)
;
break
;
default
:
break
;
}
nsresult
rv
=
SetInlinePropertyInternal
(
*
property
attribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyInternal
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aAttributeValue
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
mTypeInState
-
>
SetProp
(
&
aProperty
aAttribute
aAttributeValue
)
;
return
NS_OK
;
}
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EditorDOMPoint
startOfRange
(
range
-
>
StartRef
(
)
)
;
EditorDOMPoint
endOfRange
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
&
&
startOfRange
.
IsInTextNode
(
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
startOfRange
.
GetContainerAsText
(
)
)
startOfRange
.
Offset
(
)
endOfRange
.
Offset
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
IsEditable
(
node
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startOfRange
.
IsInTextNode
(
)
&
&
IsEditable
(
startOfRange
.
GetContainer
(
)
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
startOfRange
.
GetContainerAsText
(
)
)
startOfRange
.
Offset
(
)
startOfRange
.
GetContainer
(
)
-
>
Length
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
*
content
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
endOfRange
.
IsInTextNode
(
)
&
&
IsEditable
(
endOfRange
.
GetContainer
(
)
)
)
{
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
endOfRange
.
GetContainerAsText
(
)
)
0
endOfRange
.
Offset
(
)
aProperty
aAttribute
aAttributeValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
bool
HTMLEditor
:
:
IsSimpleModifiableNode
(
nsIContent
*
aContent
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
)
{
MOZ_ASSERT
(
aProperty
)
;
MOZ_ASSERT_IF
(
aAttribute
aValue
)
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aContent
)
;
if
(
!
element
)
{
return
false
;
}
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
!
element
-
>
GetAttrCount
(
)
&
&
!
aAttribute
)
{
return
true
;
}
if
(
!
element
-
>
GetAttrCount
(
)
&
&
(
(
aProperty
=
=
nsGkAtoms
:
:
b
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
strong
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
i
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
em
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
strike
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
s
)
)
)
)
{
return
true
;
}
if
(
aAttribute
)
{
nsString
attrValue
;
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
IsOnlyAttribute
(
element
aAttribute
)
&
&
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
attrValue
)
&
&
attrValue
.
Equals
(
*
aValue
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
element
aProperty
aAttribute
)
|
|
!
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
|
|
element
-
>
GetAttrCount
(
)
!
=
1
|
|
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
newSpan
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
NS_ASSERTION
(
newSpan
"
CreateHTMLContent
failed
"
)
;
NS_ENSURE_TRUE
(
newSpan
false
)
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
newSpan
aProperty
aAttribute
aValue
true
)
;
return
CSSEditUtils
:
:
ElementsSameStyle
(
newSpan
element
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
aText
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aText
.
GetParentNode
(
)
aProperty
)
)
{
return
NS_OK
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aText
&
aProperty
aAttribute
)
)
{
if
(
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aText
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aText
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aText
;
EditorDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
if
(
aAttribute
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
SetInlinePropertyOnNode
(
*
textNodeForTheRange
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
TagCanContain
(
*
nsGkAtoms
:
:
span
aNode
)
)
{
if
(
aNode
.
HasChildren
(
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
child
)
&
&
!
IsEmptyTextNode
(
*
child
)
)
{
arrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
node
aProperty
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
previousSibling
=
GetPriorHTMLSibling
(
&
aNode
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
GetNextHTMLSibling
(
&
aNode
)
;
if
(
IsSimpleModifiableNode
(
previousSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aNode
*
previousSibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
rv
=
JoinNodesWithTransaction
(
*
previousSibling
*
nextSibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aNode
EditorDOMPoint
(
nextSibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
{
if
(
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aNode
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aNode
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
bool
useCSS
=
(
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
|
|
aValue
.
EqualsLiteral
(
"
-
moz
-
editor
-
invert
-
value
"
)
;
if
(
useCSS
)
{
RefPtr
<
Element
>
spanElement
;
if
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aNode
.
AsElement
(
)
-
>
GetAttrCount
(
)
)
{
spanElement
=
aNode
.
AsElement
(
)
;
}
else
{
spanElement
=
InsertContainerWithTransaction
(
aNode
*
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
!
spanElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
spanElement
&
aProperty
aAttribute
&
aValue
false
)
;
return
NS_OK
;
}
if
(
aNode
.
IsHTMLElement
(
&
aProperty
)
)
{
if
(
NS_WARN_IF
(
!
aAttribute
)
)
{
return
NS_ERROR_FAILURE
;
}
return
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
aNode
.
AsElement
(
)
)
*
aAttribute
aValue
)
;
}
RefPtr
<
Element
>
tmp
=
InsertContainerWithTransaction
(
aNode
aProperty
aAttribute
?
*
aAttribute
:
*
nsGkAtoms
:
:
_empty
aValue
)
;
if
(
NS_WARN_IF
(
!
tmp
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNode
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIContent
>
previousSibling
=
aNode
.
GetPreviousSibling
(
)
nextSibling
=
aNode
.
GetNextSibling
(
)
;
NS_ENSURE_STATE
(
aNode
.
GetParentNode
(
)
)
;
OwningNonNull
<
nsINode
>
parent
=
*
aNode
.
GetParentNode
(
)
;
if
(
aNode
.
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
aNode
.
AsElement
(
)
)
&
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aNode
.
GetParentNode
(
)
)
{
return
SetInlinePropertyOnNodeImpl
(
aNode
aProperty
aAttribute
aValue
)
;
}
if
(
(
previousSibling
&
&
previousSibling
-
>
GetParentNode
(
)
!
=
parent
)
|
|
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsTArray
<
OwningNonNull
<
nsIContent
>
>
nodesToSet
;
nsCOMPtr
<
nsIContent
>
cur
=
previousSibling
?
previousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
for
(
;
cur
&
&
cur
!
=
nextSibling
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
cur
)
)
{
nodesToSet
.
AppendElement
(
*
cur
)
;
}
}
for
(
auto
&
node
:
nodesToSet
)
{
nsresult
rv
=
SetInlinePropertyOnNodeImpl
(
node
aProperty
aAttribute
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
SplitRangeOffResult
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAtRangeEdges
(
const
EditorDOMPoint
&
aStartOfRange
const
EditorDOMPoint
&
aEndOfRange
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndOfRange
.
IsSet
(
)
)
)
{
return
SplitRangeOffResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
startOfRange
(
aStartOfRange
)
;
EditorDOMPoint
endOfRange
(
aEndOfRange
)
;
SplitNodeResult
resultAtStart
(
NS_ERROR_NOT_INITIALIZED
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
endOfRange
)
;
resultAtStart
=
SplitAncestorStyledInlineElementsAt
(
startOfRange
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
resultAtStart
.
Failed
(
)
)
)
{
return
SplitRangeOffResult
(
resultAtStart
.
Rv
(
)
)
;
}
if
(
resultAtStart
.
Handled
(
)
)
{
startOfRange
=
resultAtStart
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
)
{
return
SplitRangeOffResult
(
NS_ERROR_FAILURE
)
;
}
}
}
SplitNodeResult
resultAtEnd
(
NS_ERROR_NOT_INITIALIZED
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
startOfRange
)
;
resultAtEnd
=
SplitAncestorStyledInlineElementsAt
(
endOfRange
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
resultAtEnd
.
Failed
(
)
)
)
{
return
SplitRangeOffResult
(
resultAtEnd
.
Rv
(
)
)
;
}
if
(
resultAtEnd
.
Handled
(
)
)
{
endOfRange
=
resultAtEnd
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
return
SplitRangeOffResult
(
NS_ERROR_FAILURE
)
;
}
}
}
return
SplitRangeOffResult
(
startOfRange
resultAtStart
endOfRange
resultAtEnd
)
;
}
SplitNodeResult
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
const
EditorDOMPoint
&
aPointToSplit
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
if
(
NS_WARN_IF
(
!
aPointToSplit
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
bool
useCSS
=
aProperty
!
=
nsGkAtoms
:
:
tt
|
|
IsCSSEnabled
(
)
;
SplitNodeResult
result
(
aPointToSplit
)
;
MOZ_ASSERT
(
!
result
.
Handled
(
)
)
;
for
(
nsCOMPtr
<
nsIContent
>
content
=
aPointToSplit
.
GetContainerAsContent
(
)
;
!
IsBlockNode
(
content
)
&
&
content
-
>
GetParent
(
)
&
&
IsEditable
(
content
-
>
GetParent
(
)
)
;
content
=
content
-
>
GetParent
(
)
)
{
bool
isSetByCSS
=
false
;
if
(
useCSS
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
aProperty
aAttribute
)
)
{
nsAutoString
firstValue
;
isSetByCSS
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
content
aProperty
aAttribute
firstValue
CSSEditUtils
:
:
eSpecified
)
;
}
if
(
!
isSetByCSS
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
if
(
aProperty
)
{
if
(
!
content
-
>
IsHTMLElement
(
aProperty
)
&
&
!
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
content
)
)
)
{
continue
;
}
}
else
if
(
!
IsEditable
(
content
)
|
|
!
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
*
content
-
>
AsElement
(
)
)
)
{
continue
;
}
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
content
result
.
SplitPoint
(
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
;
}
MOZ_ASSERT
(
splitNodeResult
.
Handled
(
)
)
;
result
=
SplitNodeResult
(
splitNodeResult
.
GetPreviousNode
(
)
splitNodeResult
.
GetNextNode
(
)
)
;
MOZ_ASSERT
(
result
.
Handled
(
)
)
;
}
return
result
;
}
EditResult
HTMLEditor
:
:
ClearStyleAt
(
const
EditorDOMPoint
&
aPoint
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditResult
(
NS_ERROR_INVALID_ARG
)
;
}
SplitNodeResult
splitResult
=
SplitAncestorStyledInlineElementsAt
(
aPoint
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
splitResult
.
Failed
(
)
)
)
{
return
EditResult
(
splitResult
.
Rv
(
)
)
;
}
if
(
!
splitResult
.
Handled
(
)
)
{
return
EditResult
(
aPoint
)
;
}
if
(
splitResult
.
GetPreviousNode
(
)
)
{
bool
isEmpty
=
false
;
IsEmptyNode
(
splitResult
.
GetPreviousNode
(
)
&
isEmpty
false
true
)
;
if
(
isEmpty
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetPreviousNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditResult
(
rv
)
;
}
}
}
if
(
!
splitResult
.
GetNextNode
(
)
)
{
MOZ_ASSERT
(
IsCSSEnabled
(
)
)
;
return
EditResult
(
aPoint
)
;
}
nsIContent
*
leftmostChildOfNextNode
=
GetLeftmostChild
(
splitResult
.
GetNextNode
(
)
)
;
EditorDOMPoint
atStartOfNextNode
(
leftmostChildOfNextNode
?
leftmostChildOfNextNode
:
splitResult
.
GetNextNode
(
)
0
)
;
RefPtr
<
HTMLBRElement
>
brElement
;
if
(
!
IsContainer
(
atStartOfNextNode
.
GetContainer
(
)
)
)
{
brElement
=
HTMLBRElement
:
:
FromNode
(
atStartOfNextNode
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfNextNode
.
GetContainerParentAsContent
(
)
)
)
{
return
EditResult
(
NS_ERROR_FAILURE
)
;
}
atStartOfNextNode
.
Set
(
atStartOfNextNode
.
GetContainerParent
(
)
0
)
;
}
SplitNodeResult
splitResultAtStartOfNextNode
=
SplitAncestorStyledInlineElementsAt
(
atStartOfNextNode
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
splitResultAtStartOfNextNode
.
Failed
(
)
)
)
{
return
EditResult
(
splitResultAtStartOfNextNode
.
Rv
(
)
)
;
}
if
(
splitResultAtStartOfNextNode
.
Handled
(
)
&
&
splitResultAtStartOfNextNode
.
GetNextNode
(
)
)
{
bool
isEmpty
=
false
;
IsEmptyNode
(
splitResultAtStartOfNextNode
.
GetNextNode
(
)
&
isEmpty
false
true
)
;
if
(
isEmpty
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetNextNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditResult
(
rv
)
;
}
}
}
if
(
NS_WARN_IF
(
!
splitResultAtStartOfNextNode
.
Handled
(
)
)
|
|
!
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
)
{
return
EditResult
(
EditorDOMPoint
(
splitResult
.
SplitPoint
(
)
.
GetContainer
(
)
splitResultAtStartOfNextNode
.
SplitPoint
(
)
.
Offset
(
)
)
)
;
}
nsIContent
*
leftmostChild
=
GetLeftmostChild
(
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
)
;
EditorDOMPoint
pointToPutCaret
(
leftmostChild
?
leftmostChild
:
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
0
)
;
if
(
brElement
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
brElement
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditResult
(
rv
)
;
}
pointToPutCaret
.
Set
(
pointToPutCaret
.
GetContainer
(
)
0
)
;
}
if
(
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
-
>
IsElement
(
)
)
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
splitResultAtStartOfNextNode
.
GetPreviousNode
(
)
-
>
AsElement
(
)
)
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditResult
(
rv
)
;
}
}
return
EditResult
(
pointToPutCaret
)
;
}
nsresult
HTMLEditor
:
:
RemoveStyleInside
(
Element
&
aElement
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
RefPtr
<
nsIContent
>
child
=
aElement
.
GetFirstChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
nextSibling
=
child
-
>
GetNextSibling
(
)
;
if
(
child
-
>
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
child
=
nextSibling
.
forget
(
)
;
}
bool
removeHTMLStyle
=
false
;
if
(
aProperty
)
{
removeHTMLStyle
=
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aProperty
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
&
aElement
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
name
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aElement
)
)
;
}
else
if
(
IsEditable
(
&
aElement
)
)
{
removeHTMLStyle
=
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
aElement
)
;
}
if
(
removeHTMLStyle
)
{
if
(
!
aAttribute
)
{
if
(
aProperty
&
&
(
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
)
)
{
RefPtr
<
Element
>
spanElement
=
InsertContainerWithTransaction
(
aElement
*
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
spanElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
style
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CloneAttributeWithTransaction
(
*
nsGkAtoms
:
:
_class
*
spanElement
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
aElement
.
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
if
(
IsOnlyAttribute
(
&
aElement
aAttribute
)
)
{
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
aElement
*
aAttribute
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aElement
aProperty
aAttribute
)
&
&
CSSEditUtils
:
:
HaveCSSEquivalentStyles
(
aElement
aProperty
aAttribute
CSSEditUtils
:
:
eSpecified
)
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
&
aElement
aProperty
aAttribute
nullptr
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
span
nsGkAtoms
:
:
font
)
&
&
!
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
aElement
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
RemoveContainerWithTransaction
(
)
failed
but
ignored
"
)
;
}
}
if
(
aProperty
=
=
nsGkAtoms
:
:
font
&
&
aAttribute
=
=
nsGkAtoms
:
:
size
&
&
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
)
)
{
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsOnlyAttribute
(
const
Element
*
aElement
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
aElement
)
;
uint32_t
attrCount
=
aElement
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
aElement
-
>
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
false
;
}
if
(
name
-
>
LocalName
(
)
!
=
aAttribute
)
{
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
NS_LITERAL_STRING
(
"
_moz
"
)
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
startNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
startNode
=
parent
-
>
GetParentNode
(
)
;
startOffset
=
startNode
?
startNode
-
>
ComputeIndexOf
(
parent
)
:
-
1
;
}
parent
=
endNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
endNode
=
parent
-
>
GetParentNode
(
)
;
endOffset
=
endNode
?
endNode
-
>
ComputeIndexOf
(
parent
)
+
1
:
0
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PromoteInlineRange
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
while
(
startNode
&
&
!
startNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
startNode
)
&
&
IsAtFrontOfNode
(
*
startNode
startOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
startNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
startOffset
=
parent
-
>
ComputeIndexOf
(
startNode
)
;
startNode
=
parent
;
}
while
(
endNode
&
&
!
endNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
endNode
)
&
&
IsAtEndOfNode
(
*
endNode
endOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
endNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
endOffset
=
1
+
parent
-
>
ComputeIndexOf
(
endNode
)
;
endNode
=
parent
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsAtFrontOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
!
aOffset
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
firstNode
=
GetFirstEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
firstNode
true
)
;
if
(
aNode
.
ComputeIndexOf
(
firstNode
)
<
aOffset
)
{
return
false
;
}
return
true
;
}
bool
HTMLEditor
:
:
IsAtEndOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
aOffset
=
=
(
int32_t
)
aNode
.
Length
(
)
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
lastNode
=
GetLastEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
lastNode
true
)
;
if
(
aNode
.
ComputeIndexOf
(
lastNode
)
<
aOffset
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyBase
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
*
aAny
=
false
;
*
aAll
=
true
;
*
aFirst
=
false
;
bool
first
=
true
;
bool
isCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
range
)
{
bool
firstNodeInRange
=
true
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
collapsedNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
collapsedNode
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isSet
theSetting
;
nsString
tOutString
;
if
(
aAttribute
)
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
aAttribute
&
tOutString
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
}
else
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
)
;
}
if
(
isSet
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
theSetting
;
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
collapsedNode
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
tOutString
.
Assign
(
*
aValue
)
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
collapsedNode
&
aProperty
aAttribute
tOutString
CSSEditUtils
:
:
eComputed
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
NS_OK
;
}
isSet
=
IsTextPropertySetByContent
(
collapsedNode
&
aProperty
aAttribute
aValue
outValue
)
;
*
aFirst
=
*
aAny
=
*
aAll
=
isSet
;
return
NS_OK
;
}
nsAutoString
firstValue
theValue
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
PostContentIterator
postOrderIter
;
DebugOnly
<
nsresult
>
rvIgnored
=
postOrderIter
.
Init
(
range
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
initialize
post
-
order
content
iterator
"
)
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
!
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
content
-
>
GetAsText
(
)
&
&
(
!
IsEditable
(
content
)
|
|
IsEmptyTextNode
(
*
content
)
)
)
{
continue
;
}
if
(
content
-
>
GetAsText
(
)
)
{
if
(
!
isCollapsed
&
&
first
&
&
firstNodeInRange
)
{
firstNodeInRange
=
false
;
if
(
range
-
>
StartOffset
(
)
=
=
content
-
>
Length
(
)
)
{
continue
;
}
}
else
if
(
content
=
=
endNode
&
&
!
endOffset
)
{
continue
;
}
}
else
if
(
content
-
>
IsElement
(
)
)
{
continue
;
}
bool
isSet
=
false
;
if
(
first
)
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
firstValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
firstValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
firstValue
)
;
}
*
aFirst
=
isSet
;
first
=
false
;
if
(
outValue
)
{
*
outValue
=
firstValue
;
}
}
else
{
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
theValue
.
Assign
(
*
aValue
)
;
}
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
theValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
theValue
)
;
}
if
(
firstValue
!
=
theValue
)
{
*
aAll
=
false
;
}
}
if
(
isSet
)
{
*
aAny
=
true
;
}
else
{
*
aAll
=
false
;
}
}
}
if
(
!
*
aAny
)
{
*
aAll
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
AtomizeAttribute
(
aAttribute
)
;
return
GetInlineProperty
(
property
attribute
aValue
aFirst
aAny
aAll
)
;
}
nsresult
HTMLEditor
:
:
GetInlineProperty
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
const
{
if
(
NS_WARN_IF
(
!
aProperty
)
|
|
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
nsresult
rv
=
GetInlinePropertyBase
(
*
aProperty
aAttribute
val
aFirst
aAny
aAll
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
AtomizeAttribute
(
aAttribute
)
;
return
GetInlinePropertyWithAttrValue
(
property
attribute
aValue
aFirst
aAny
aAll
outValue
)
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
if
(
NS_WARN_IF
(
!
aProperty
)
|
|
NS_WARN_IF
(
!
aFirst
)
|
|
NS_WARN_IF
(
!
aAny
)
|
|
NS_WARN_IF
(
!
aAll
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
nsresult
rv
=
GetInlinePropertyBase
(
*
aProperty
aAttribute
val
aFirst
aAny
aAll
&
outValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveAllInlineProperties
(
)
{
nsresult
rv
=
RemoveAllInlinePropertiesAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
all
inline
styles
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveAllInlinePropertiesAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAllInlineStyleProperties
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveAllTextProperties
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
RemoveInlinePropertyInternal
(
nullptr
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
aProperty
aAttribute
false
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
EmptyString
(
)
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
EmptyString
(
)
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
EmptyString
(
)
)
;
break
;
default
:
break
;
}
nsresult
rv
=
RemoveInlinePropertyInternal
(
&
aProperty
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInlineProperty
(
const
nsAString
&
aProperty
const
nsAString
&
aAttribute
)
{
RefPtr
<
nsAtom
>
property
=
NS_Atomize
(
aProperty
)
;
RefPtr
<
nsAtom
>
attribute
=
AtomizeAttribute
(
aAttribute
)
;
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForFormatText
(
*
property
attribute
false
)
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
editActionData
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eRemoveFontFamilyProperty
:
MOZ_ASSERT
(
!
EmptyString
(
)
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
EmptyString
(
)
)
;
break
;
case
EditAction
:
:
eRemoveColorProperty
:
case
EditAction
:
:
eRemoveBackgroundColorPropertyInline
:
editActionData
.
SetColorData
(
EmptyString
(
)
)
;
break
;
default
:
break
;
}
nsresult
rv
=
RemoveInlinePropertyInternal
(
property
attribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveInlinePropertyInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyInternal
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
href
|
|
aProperty
=
=
nsGkAtoms
:
:
name
)
{
aProperty
=
nsGkAtoms
:
:
a
;
}
if
(
aProperty
)
{
mTypeInState
-
>
ClearProp
(
aProperty
aAttribute
)
;
}
else
{
mTypeInState
-
>
ClearAllProps
(
)
;
}
return
NS_OK
;
}
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
name
)
{
nsresult
rv
=
PromoteRangeIfStartsOrEndsInNamedAnchor
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
SplitRangeOffResult
splitRangeOffResult
=
SplitAncestorStyledInlineElementsAtRangeEdges
(
EditorDOMPoint
(
range
-
>
StartRef
(
)
)
EditorDOMPoint
(
range
-
>
EndRef
(
)
)
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
splitRangeOffResult
.
Failed
(
)
)
)
{
return
splitRangeOffResult
.
Rv
(
)
;
}
EditorDOMPoint
startOfRange
(
splitRangeOffResult
.
SplitPointAtStart
(
)
)
;
EditorDOMPoint
endOfRange
(
splitRangeOffResult
.
SplitPointAtEnd
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
nsresult
rv
=
range
-
>
SetStartAndEnd
(
startOfRange
.
ToRawRangeBoundary
(
)
endOfRange
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
&
&
startOfRange
.
IsInTextNode
(
)
)
{
if
(
!
IsEditable
(
startOfRange
.
GetContainer
(
)
)
)
{
continue
;
}
arrayOfContents
.
AppendElement
(
*
startOfRange
.
GetContainerAsText
(
)
)
;
}
else
if
(
startOfRange
.
IsInTextNode
(
)
&
&
endOfRange
.
IsInTextNode
(
)
&
&
startOfRange
.
GetContainer
(
)
-
>
GetNextSibling
(
)
=
=
endOfRange
.
GetContainer
(
)
)
{
if
(
IsEditable
(
startOfRange
.
GetContainer
(
)
)
)
{
arrayOfContents
.
AppendElement
(
*
startOfRange
.
GetContainerAsText
(
)
)
;
}
if
(
IsEditable
(
endOfRange
.
GetContainer
(
)
)
)
{
arrayOfContents
.
AppendElement
(
*
endOfRange
.
GetContainerAsText
(
)
)
;
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
continue
;
}
}
else
{
if
(
startOfRange
.
IsInTextNode
(
)
&
&
!
startOfRange
.
IsStartOfContainer
(
)
&
&
IsEditable
(
startOfRange
.
GetContainer
(
)
)
)
{
arrayOfContents
.
AppendElement
(
*
startOfRange
.
GetContainerAsText
(
)
)
;
}
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
IsEditable
(
node
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startOfRange
.
GetContainer
(
)
!
=
endOfRange
.
GetContainer
(
)
&
&
endOfRange
.
IsInTextNode
(
)
&
&
!
endOfRange
.
IsEndOfContainer
(
)
&
&
IsEditable
(
endOfRange
.
GetContainer
(
)
)
)
{
arrayOfContents
.
AppendElement
(
*
endOfRange
.
GetContainerAsText
(
)
)
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
content
-
>
IsElement
(
)
)
{
nsresult
rv
=
RemoveStyleInside
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aProperty
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
!
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
content
aProperty
aAttribute
)
)
{
continue
;
}
if
(
!
content
-
>
IsText
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetInlinePropertyOnNode
(
content
*
aProperty
aAttribute
NS_LITERAL_STRING
(
"
-
moz
-
editor
-
invert
-
value
"
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
SetInlinePropertyOnNode
(
)
"
"
failed
but
ignored
"
)
;
continue
;
}
uint32_t
startOffset
=
content
=
=
startOfRange
.
GetContainer
(
)
?
startOfRange
.
Offset
(
)
:
0
;
uint32_t
endOffset
=
content
=
=
endOfRange
.
GetContainer
(
)
?
endOfRange
.
Offset
(
)
:
content
-
>
Length
(
)
;
nsresult
rv
=
SetInlinePropertyOnTextNode
(
MOZ_KnownLive
(
*
content
-
>
AsText
(
)
)
startOffset
endOffset
*
aProperty
aAttribute
NS_LITERAL_STRING
(
"
-
moz
-
editor
-
invert
-
value
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aProperty
&
&
CSSEditUtils
:
:
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
AutoTArray
<
OwningNonNull
<
Text
>
32
>
leafTextNodes
;
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
content
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
content
-
>
AsElement
(
)
leafTextNodes
)
;
}
}
for
(
auto
&
textNode
:
leafTextNodes
)
{
if
(
!
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
textNode
aProperty
aAttribute
)
)
{
continue
;
}
nsresult
rv
=
SetInlinePropertyOnTextNode
(
textNode
0
textNode
-
>
TextLength
(
)
*
aProperty
aAttribute
NS_LITERAL_STRING
(
"
-
moz
-
editor
-
invert
-
value
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
bool
HTMLEditor
:
:
IsRemovableParentStyleWithNewSpanElement
(
nsIContent
&
aContent
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
{
if
(
!
aProperty
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
return
false
;
}
if
(
!
CSSEditUtils
:
:
IsCSSEditableProperty
(
&
aContent
aProperty
aAttribute
)
)
{
return
false
;
}
return
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aContent
aProperty
aAttribute
EmptyString
(
)
CSSEditUtils
:
:
eComputed
)
;
}
void
HTMLEditor
:
:
CollectEditableLeafTextNodes
(
Element
&
aElement
nsTArray
<
OwningNonNull
<
Text
>
>
&
aLeafTextNodes
)
const
{
for
(
nsIContent
*
child
=
aElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
CollectEditableLeafTextNodes
(
*
child
-
>
AsElement
(
)
aLeafTextNodes
)
;
continue
;
}
if
(
child
-
>
IsText
(
)
)
{
aLeafTextNodes
.
AppendElement
(
*
child
-
>
AsText
(
)
)
;
}
}
}
NS_IMETHODIMP
HTMLEditor
:
:
IncreaseFontSize
(
)
{
nsresult
rv
=
IncreaseFontSizeAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
increase
font
size
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
IncreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIncrementFontSize
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RelativeFontChange
(
FontSize
:
:
incr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DecreaseFontSize
(
)
{
nsresult
rv
=
DecreaseFontSizeAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
decrease
font
size
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DecreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDecrementFontSize
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RelativeFontChange
(
FontSize
:
:
decr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChange
(
FontSize
aDir
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
CommitComposition
(
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsAtom
&
atom
=
aDir
=
=
FontSize
:
:
incr
?
*
nsGkAtoms
:
:
big
:
*
nsGkAtoms
:
:
small
;
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
|
|
NS_WARN_IF
(
!
firstRange
-
>
GetStartContainer
(
)
)
)
{
return
NS_OK
;
}
OwningNonNull
<
nsINode
>
selectedNode
=
*
firstRange
-
>
GetStartContainer
(
)
;
if
(
IsTextNode
(
selectedNode
)
)
{
if
(
NS_WARN_IF
(
!
selectedNode
-
>
GetParentNode
(
)
)
)
{
return
NS_OK
;
}
selectedNode
=
*
selectedNode
-
>
GetParentNode
(
)
;
}
if
(
!
CanContainTag
(
selectedNode
atom
)
)
{
return
NS_OK
;
}
mTypeInState
-
>
SetProp
(
&
atom
nullptr
EmptyString
(
)
)
;
return
NS_OK
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetTextProperty
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
startNode
=
=
endNode
&
&
IsTextNode
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
startNode
-
>
GetAsText
(
)
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
ContentSubtreeIterator
subtreeIter
;
rv
=
subtreeIter
.
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
if
(
NS_WARN_IF
(
!
subtreeIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
nsIContent
>
node
=
*
subtreeIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
node
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
RelativeFontChangeOnNode
(
aDir
=
=
FontSize
:
:
incr
?
+
1
:
-
1
node
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
IsTextNode
(
startNode
)
&
&
IsEditable
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
startNode
-
>
GetAsText
(
)
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsTextNode
(
endNode
)
&
&
IsEditable
(
endNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
MOZ_KnownLive
(
*
endNode
-
>
GetAsText
(
)
)
0
range
-
>
EndOffset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
FontSize
aDir
Text
&
aTextNode
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
!
aTextNode
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aTextNode
.
GetParentNode
(
)
*
nsGkAtoms
:
:
big
)
)
{
return
NS_OK
;
}
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aTextNode
.
Length
(
)
;
}
nsCOMPtr
<
nsIContent
>
textNodeForTheRange
=
&
aTextNode
;
EditorDOMPoint
atEnd
(
textNodeForTheRange
aEndOffset
)
;
if
(
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
textNodeForTheRange
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atStart
(
textNodeForTheRange
aStartOffset
)
;
if
(
!
atStart
.
IsStartOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStart
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
Unused
<
<
newLeftNode
;
}
nsAtom
*
nodeType
=
aDir
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
textNodeForTheRange
*
sibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
sibling
=
GetNextHTMLSibling
(
textNodeForTheRange
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
textNodeForTheRange
EditorDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
textNodeForTheRange
MOZ_KnownLive
(
*
nodeType
)
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeHelper
(
int32_t
aSizeChange
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
font
)
&
&
aNode
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
size
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnNode
(
int32_t
aSizeChange
nsIContent
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsAtom
*
atom
;
if
(
aSizeChange
=
=
1
)
{
atom
=
nsGkAtoms
:
:
big
;
}
else
{
atom
=
nsGkAtoms
:
:
small
;
}
if
(
(
aSizeChange
=
=
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
|
|
(
aSizeChange
=
=
-
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
big
)
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
aNode
-
>
AsElement
(
)
)
)
;
}
if
(
TagCanContain
(
*
atom
*
aNode
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNodeToEndWithTransaction
(
*
aNode
*
sibling
)
;
}
sibling
=
GetNextHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNodeWithTransaction
(
*
aNode
EditorDOMPoint
(
sibling
0
)
)
;
}
RefPtr
<
Element
>
newElement
=
InsertContainerWithTransaction
(
*
aNode
MOZ_KnownLive
(
*
atom
)
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontFaceState
(
bool
*
aMixed
nsAString
&
outFace
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
outFace
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
nullptr
&
first
&
any
&
all
&
outFace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
tt
nullptr
nullptr
&
first
&
any
&
all
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
all
)
{
*
aMixed
=
false
;
outFace
.
AssignLiteral
(
"
tt
"
)
;
}
if
(
!
any
)
{
outFace
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetFontColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
aOutColor
.
Truncate
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
nullptr
&
first
&
any
&
all
&
aOutColor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
if
(
!
any
)
{
aOutColor
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetIsCSSEnabled
(
bool
*
aIsCSSEnabled
)
{
*
aIsCSSEnabled
=
IsCSSEnabled
(
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
HasStyleOrIdOrClassAttribute
(
Element
&
aElement
)
{
return
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
style
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
_class
)
|
|
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
id
)
;
}
}
