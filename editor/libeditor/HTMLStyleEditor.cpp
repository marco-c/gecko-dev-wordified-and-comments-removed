#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorIMESupport
.
h
"
#
include
"
nsIEditRules
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
static
bool
IsEmptyTextNode
(
HTMLEditor
*
aThis
nsINode
*
aNode
)
{
bool
isEmptyTextNode
=
false
;
return
EditorBase
:
:
IsTextNode
(
aNode
)
&
&
NS_SUCCEEDED
(
aThis
-
>
IsEmptyNode
(
aNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddDefaultProperty
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
nsString
outValue
;
int32_t
index
;
nsString
attr
(
aAttribute
)
;
if
(
TypeInState
:
:
FindPropInList
(
aProperty
attr
&
outValue
mDefaultStyles
index
)
)
{
PropItem
*
item
=
mDefaultStyles
[
index
]
;
item
-
>
value
=
aValue
;
}
else
{
nsString
value
(
aValue
)
;
PropItem
*
propItem
=
new
PropItem
(
aProperty
attr
value
)
;
mDefaultStyles
.
AppendElement
(
propItem
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveDefaultProperty
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
nsString
outValue
;
int32_t
index
;
nsString
attr
(
aAttribute
)
;
if
(
TypeInState
:
:
FindPropInList
(
aProperty
attr
&
outValue
mDefaultStyles
index
)
)
{
delete
mDefaultStyles
[
index
]
;
mDefaultStyles
.
RemoveElementAt
(
index
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveAllDefaultProperties
(
)
{
size_t
defcon
=
mDefaultStyles
.
Length
(
)
;
for
(
size_t
j
=
0
;
j
<
defcon
;
j
+
+
)
{
delete
mDefaultStyles
[
j
]
;
}
mDefaultStyles
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetInlineProperty
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
NS_ENSURE_TRUE
(
aProperty
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
ForceCompositionEnd
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
if
(
selection
-
>
Collapsed
(
)
)
{
mTypeInState
-
>
SetProp
(
aProperty
aAttribute
aValue
)
;
return
NS_OK
;
}
AutoEditBatch
batchIt
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertElement
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontSpazMySelection
(
this
)
;
bool
cancel
handled
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
setTextProperty
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cancel
&
&
!
handled
)
{
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
rangeIdx
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
rangeIdx
)
;
rv
=
PromoteInlineRange
(
*
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartParent
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndParent
(
)
;
if
(
startNode
&
&
startNode
=
=
endNode
&
&
startNode
-
>
GetAsText
(
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
*
aProperty
&
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsContent
(
)
&
&
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
if
(
startNode
&
&
startNode
-
>
GetAsText
(
)
&
&
IsEditable
(
startNode
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
*
aProperty
&
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
SetInlinePropertyOnNode
(
*
node
*
aProperty
&
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
endNode
&
&
endNode
-
>
GetAsText
(
)
&
&
IsEditable
(
endNode
)
)
{
rv
=
SetInlinePropertyOnTextNode
(
*
endNode
-
>
GetAsText
(
)
0
range
-
>
EndOffset
(
)
*
aProperty
&
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
if
(
!
cancel
)
{
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsSimpleModifiableNode
(
nsIContent
*
aContent
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
const
nsAString
*
aValue
)
{
MOZ_ASSERT
(
aProperty
)
;
MOZ_ASSERT_IF
(
aAttribute
aValue
)
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aContent
)
;
if
(
!
element
)
{
return
false
;
}
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
!
element
-
>
GetAttrCount
(
)
&
&
(
!
aAttribute
|
|
aAttribute
-
>
IsEmpty
(
)
)
)
{
return
true
;
}
if
(
!
element
-
>
GetAttrCount
(
)
&
&
(
(
aProperty
=
=
nsGkAtoms
:
:
b
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
strong
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
i
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
em
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
strike
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
s
)
)
)
)
{
return
true
;
}
if
(
aAttribute
&
&
!
aAttribute
-
>
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
NS_Atomize
(
*
aAttribute
)
;
MOZ_ASSERT
(
atom
)
;
nsString
attrValue
;
if
(
element
-
>
IsHTMLElement
(
aProperty
)
&
&
IsOnlyAttribute
(
element
*
aAttribute
)
&
&
element
-
>
GetAttr
(
kNameSpaceID_None
atom
attrValue
)
&
&
attrValue
.
Equals
(
*
aValue
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
}
if
(
!
mCSSEditUtils
-
>
IsCSSEditableProperty
(
element
aProperty
aAttribute
)
|
|
!
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
|
|
element
-
>
GetAttrCount
(
)
!
=
1
|
|
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
newSpan
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
NS_ASSERTION
(
newSpan
"
CreateHTMLContent
failed
"
)
;
NS_ENSURE_TRUE
(
newSpan
false
)
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
newSpan
aProperty
aAttribute
aValue
true
)
;
return
mCSSEditUtils
-
>
ElementsSameStyle
(
newSpan
element
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnTextNode
(
Text
&
aText
int32_t
aStartOffset
int32_t
aEndOffset
nsIAtom
&
aProperty
const
nsAString
*
aAttribute
const
nsAString
&
aValue
)
{
if
(
!
aText
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aText
.
GetParentNode
(
)
aProperty
)
)
{
return
NS_OK
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
mCSSEditUtils
-
>
IsCSSEditableProperty
(
&
aText
&
aProperty
aAttribute
)
)
{
if
(
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aText
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aText
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
ErrorResult
rv
;
RefPtr
<
Text
>
text
=
&
aText
;
if
(
uint32_t
(
aEndOffset
)
!
=
aText
.
Length
(
)
)
{
text
=
SplitNode
(
aText
aEndOffset
rv
)
-
>
GetAsText
(
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
if
(
aStartOffset
)
{
SplitNode
(
*
text
aStartOffset
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
if
(
aAttribute
)
{
nsIContent
*
sibling
=
GetPriorHTMLSibling
(
text
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
return
MoveNode
(
text
sibling
-
1
)
;
}
sibling
=
GetNextHTMLSibling
(
text
)
;
if
(
IsSimpleModifiableNode
(
sibling
&
aProperty
aAttribute
&
aValue
)
)
{
return
MoveNode
(
text
sibling
0
)
;
}
}
return
SetInlinePropertyOnNode
(
*
text
aProperty
aAttribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aNode
nsIAtom
&
aProperty
const
nsAString
*
aAttribute
const
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIAtom
>
attrAtom
=
aAttribute
?
NS_Atomize
(
*
aAttribute
)
:
nullptr
;
if
(
!
TagCanContain
(
*
nsGkAtoms
:
:
span
aNode
)
)
{
if
(
aNode
.
HasChildren
(
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
child
)
&
&
!
IsEmptyTextNode
(
this
child
)
)
{
arrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
node
aProperty
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
previousSibling
=
GetPriorHTMLSibling
(
&
aNode
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
GetNextHTMLSibling
(
&
aNode
)
;
if
(
IsSimpleModifiableNode
(
previousSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNode
(
&
aNode
previousSibling
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
rv
=
JoinNodes
(
*
previousSibling
*
nextSibling
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
if
(
IsSimpleModifiableNode
(
nextSibling
&
aProperty
aAttribute
&
aValue
)
)
{
nsresult
rv
=
MoveNode
(
&
aNode
nextSibling
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
mCSSEditUtils
-
>
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
{
if
(
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aNode
&
aProperty
aAttribute
aValue
CSSEditUtils
:
:
eComputed
)
)
{
return
NS_OK
;
}
}
else
if
(
IsTextPropertySetByContent
(
&
aNode
&
aProperty
aAttribute
&
aValue
)
)
{
return
NS_OK
;
}
bool
useCSS
=
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
-
>
IsCSSEditableProperty
(
&
aNode
&
aProperty
aAttribute
)
)
|
|
aAttribute
-
>
EqualsLiteral
(
"
bgcolor
"
)
;
if
(
useCSS
)
{
nsCOMPtr
<
dom
:
:
Element
>
tmp
;
if
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aNode
.
AsElement
(
)
-
>
GetAttrCount
(
)
)
{
tmp
=
aNode
.
AsElement
(
)
;
}
else
{
tmp
=
InsertContainerAbove
(
&
aNode
nsGkAtoms
:
:
span
)
;
NS_ENSURE_STATE
(
tmp
)
;
}
int32_t
count
;
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
tmp
-
>
AsDOMNode
(
)
&
aProperty
aAttribute
&
aValue
&
count
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
aNode
.
IsHTMLElement
(
&
aProperty
)
)
{
nsCOMPtr
<
nsIDOMElement
>
elem
=
do_QueryInterface
(
&
aNode
)
;
return
SetAttribute
(
elem
*
aAttribute
aValue
)
;
}
nsCOMPtr
<
Element
>
tmp
=
InsertContainerAbove
(
&
aNode
&
aProperty
attrAtom
&
aValue
)
;
NS_ENSURE_STATE
(
tmp
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetInlinePropertyOnNode
(
nsIContent
&
aNode
nsIAtom
&
aProperty
const
nsAString
*
aAttribute
const
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIContent
>
previousSibling
=
aNode
.
GetPreviousSibling
(
)
nextSibling
=
aNode
.
GetNextSibling
(
)
;
NS_ENSURE_STATE
(
aNode
.
GetParentNode
(
)
)
;
OwningNonNull
<
nsINode
>
parent
=
*
aNode
.
GetParentNode
(
)
;
nsresult
rv
=
RemoveStyleInside
(
aNode
&
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aNode
.
GetParentNode
(
)
)
{
return
SetInlinePropertyOnNodeImpl
(
aNode
aProperty
aAttribute
aValue
)
;
}
if
(
(
previousSibling
&
&
previousSibling
-
>
GetParentNode
(
)
!
=
parent
)
|
|
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsTArray
<
OwningNonNull
<
nsIContent
>
>
nodesToSet
;
nsCOMPtr
<
nsIContent
>
cur
=
previousSibling
?
previousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
for
(
;
cur
&
&
cur
!
=
nextSibling
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
cur
)
)
{
nodesToSet
.
AppendElement
(
*
cur
)
;
}
}
for
(
auto
&
node
:
nodesToSet
)
{
rv
=
SetInlinePropertyOnNodeImpl
(
node
aProperty
aAttribute
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitStyleAboveRange
(
nsRange
*
inRange
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
)
{
NS_ENSURE_TRUE
(
inRange
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
startNode
=
inRange
-
>
GetStartParent
(
)
;
int32_t
startOffset
=
inRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
inRange
-
>
GetEndParent
(
)
;
int32_t
endOffset
=
inRange
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
origStartNode
=
startNode
;
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
nsresult
rv
=
SplitStyleAbovePoint
(
address_of
(
startNode
)
&
startOffset
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
SplitStyleAbovePoint
(
address_of
(
endNode
)
&
endOffset
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
inRange
-
>
SetStart
(
startNode
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
inRange
-
>
SetEnd
(
endNode
endOffset
)
;
}
nsresult
HTMLEditor
:
:
SplitStyleAbovePoint
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
)
{
NS_ENSURE_TRUE
(
aNode
&
&
*
aNode
&
&
aOffset
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
(
*
aNode
)
-
>
IsContent
(
)
NS_OK
)
;
OwningNonNull
<
nsIContent
>
node
=
*
(
*
aNode
)
-
>
AsContent
(
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
bool
isSet
;
while
(
!
IsBlockNode
(
node
)
&
&
node
-
>
GetParent
(
)
&
&
IsEditable
(
node
-
>
GetParent
(
)
)
)
{
isSet
=
false
;
if
(
useCSS
&
&
mCSSEditUtils
-
>
IsCSSEditableProperty
(
node
aProperty
aAttribute
)
)
{
nsAutoString
firstValue
;
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
GetAsDOMNode
(
node
)
aProperty
aAttribute
isSet
firstValue
CSSEditUtils
:
:
eSpecified
)
;
}
if
(
(
aProperty
&
&
node
-
>
IsHTMLElement
(
aProperty
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
node
)
)
|
|
(
!
aProperty
&
&
NodeIsProperty
(
node
)
)
|
|
isSet
)
{
int32_t
offset
=
SplitNodeDeep
(
*
node
*
(
*
aNode
)
-
>
AsContent
(
)
*
aOffset
EmptyContainers
:
:
yes
aOutLeftNode
aOutRightNode
)
;
NS_ENSURE_TRUE
(
offset
!
=
-
1
NS_ERROR_FAILURE
)
;
*
aNode
=
node
-
>
GetParent
(
)
;
*
aOffset
=
offset
;
}
node
=
node
-
>
GetParent
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ClearStyle
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
)
{
nsCOMPtr
<
nsIContent
>
leftNode
rightNode
;
nsresult
rv
=
SplitStyleAbovePoint
(
aNode
aOffset
aProperty
aAttribute
getter_AddRefs
(
leftNode
)
getter_AddRefs
(
rightNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
leftNode
)
{
bool
bIsEmptyNode
;
IsEmptyNode
(
leftNode
&
bIsEmptyNode
false
true
)
;
if
(
bIsEmptyNode
)
{
rv
=
DeleteNode
(
leftNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
rightNode
)
{
nsCOMPtr
<
nsINode
>
secondSplitParent
=
GetLeftmostChild
(
rightNode
)
;
if
(
!
secondSplitParent
)
{
secondSplitParent
=
rightNode
;
}
nsCOMPtr
<
Element
>
savedBR
;
if
(
!
IsContainer
(
secondSplitParent
)
)
{
if
(
TextEditUtils
:
:
IsBreak
(
secondSplitParent
)
)
{
savedBR
=
do_QueryInterface
(
secondSplitParent
)
;
NS_ENSURE_STATE
(
savedBR
)
;
}
secondSplitParent
=
secondSplitParent
-
>
GetParentNode
(
)
;
}
*
aOffset
=
0
;
rv
=
SplitStyleAbovePoint
(
address_of
(
secondSplitParent
)
aOffset
aProperty
aAttribute
getter_AddRefs
(
leftNode
)
getter_AddRefs
(
rightNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
newSelParent
=
GetLeftmostChild
(
leftNode
)
;
if
(
!
newSelParent
)
{
newSelParent
=
leftNode
;
}
if
(
savedBR
)
{
rv
=
MoveNode
(
savedBR
newSelParent
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
bIsEmptyNode
;
IsEmptyNode
(
rightNode
&
bIsEmptyNode
false
true
)
;
if
(
bIsEmptyNode
)
{
rv
=
DeleteNode
(
rightNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
newSelOffset
=
0
;
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
address_of
(
newSelParent
)
&
newSelOffset
)
;
rv
=
RemoveStyleInside
(
*
leftNode
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
*
aNode
=
newSelParent
;
*
aOffset
=
newSelOffset
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
NodeIsProperty
(
nsINode
&
aNode
)
{
return
IsContainer
(
&
aNode
)
&
&
IsEditable
(
&
aNode
)
&
&
!
IsBlockNode
(
&
aNode
)
&
&
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
a
)
;
}
nsresult
HTMLEditor
:
:
ApplyDefaultProperties
(
)
{
size_t
defcon
=
mDefaultStyles
.
Length
(
)
;
for
(
size_t
j
=
0
;
j
<
defcon
;
j
+
+
)
{
PropItem
*
propItem
=
mDefaultStyles
[
j
]
;
NS_ENSURE_TRUE
(
propItem
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
SetInlineProperty
(
propItem
-
>
tag
propItem
-
>
attr
propItem
-
>
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveStyleInside
(
nsIContent
&
aNode
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
const
bool
aChildrenOnly
)
{
if
(
aNode
.
GetAsText
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
next
=
child
-
>
GetNextSibling
(
)
;
nsresult
rv
=
RemoveStyleInside
(
*
child
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
next
.
forget
(
)
;
}
if
(
!
aChildrenOnly
&
&
(
(
aProperty
&
&
aNode
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aProperty
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
href
&
&
HTMLEditUtils
:
:
IsLink
(
&
aNode
)
)
|
|
(
aProperty
=
=
nsGkAtoms
:
:
name
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aNode
)
)
|
|
(
!
aProperty
&
&
NodeIsProperty
(
aNode
)
)
)
)
{
if
(
!
aAttribute
|
|
aAttribute
-
>
IsEmpty
(
)
)
{
NS_NAMED_LITERAL_STRING
(
styleAttr
"
style
"
)
;
NS_NAMED_LITERAL_STRING
(
classAttr
"
class
"
)
;
bool
hasStyleAttr
=
aNode
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
)
;
bool
hasClassAttr
=
aNode
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
;
if
(
aProperty
&
&
(
hasStyleAttr
|
|
hasClassAttr
)
)
{
nsCOMPtr
<
Element
>
spanNode
=
InsertContainerAbove
(
&
aNode
nsGkAtoms
:
:
span
)
;
NS_ENSURE_STATE
(
spanNode
)
;
nsresult
rv
=
CloneAttribute
(
styleAttr
spanNode
-
>
AsDOMNode
(
)
aNode
.
AsDOMNode
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CloneAttribute
(
classAttr
spanNode
-
>
AsDOMNode
(
)
aNode
.
AsDOMNode
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
RemoveContainer
(
&
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIAtom
>
attribute
=
NS_Atomize
(
*
aAttribute
)
;
if
(
aNode
.
HasAttr
(
kNameSpaceID_None
attribute
)
)
{
if
(
IsOnlyAttribute
(
&
aNode
*
aAttribute
)
)
{
nsresult
rv
=
RemoveContainer
(
&
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsCOMPtr
<
nsIDOMElement
>
elem
=
do_QueryInterface
(
&
aNode
)
;
NS_ENSURE_TRUE
(
elem
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
RemoveAttribute
(
elem
*
aAttribute
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
}
if
(
!
aChildrenOnly
&
&
mCSSEditUtils
-
>
IsCSSEditableProperty
(
&
aNode
aProperty
aAttribute
)
)
{
nsAutoString
propertyValue
;
bool
isSet
=
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aNode
aProperty
aAttribute
propertyValue
CSSEditUtils
:
:
eSpecified
)
;
if
(
isSet
&
&
aNode
.
IsElement
(
)
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aNode
.
AsElement
(
)
aProperty
aAttribute
&
propertyValue
false
)
;
RemoveElementIfNoStyleOrIdOrClass
(
*
aNode
.
AsElement
(
)
)
;
}
}
if
(
aChildrenOnly
)
{
return
NS_OK
;
}
if
(
aProperty
=
=
nsGkAtoms
:
:
font
&
&
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
big
)
|
|
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
&
&
aAttribute
&
&
aAttribute
-
>
LowerCaseEqualsLiteral
(
"
size
"
)
)
{
return
RemoveContainer
(
&
aNode
)
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsOnlyAttribute
(
const
nsIContent
*
aContent
const
nsAString
&
aAttribute
)
{
MOZ_ASSERT
(
aContent
)
;
uint32_t
attrCount
=
aContent
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
aContent
-
>
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
false
;
}
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
attrString
.
Equals
(
aAttribute
nsCaseInsensitiveStringComparator
(
)
)
&
&
!
StringBeginsWith
(
attrString
NS_LITERAL_STRING
(
"
_moz
"
)
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartParent
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndParent
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
startNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
startNode
=
parent
-
>
GetParentNode
(
)
;
startOffset
=
startNode
?
startNode
-
>
IndexOf
(
parent
)
:
-
1
;
}
parent
=
endNode
;
while
(
parent
&
&
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
!
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
parent
=
parent
-
>
GetParentNode
(
)
;
}
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
parent
)
)
{
endNode
=
parent
-
>
GetParentNode
(
)
;
endOffset
=
endNode
?
endNode
-
>
IndexOf
(
parent
)
+
1
:
0
;
}
nsresult
rv
=
aRange
.
SetStart
(
startNode
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aRange
.
SetEnd
(
endNode
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PromoteInlineRange
(
nsRange
&
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartParent
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndParent
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
while
(
startNode
&
&
!
startNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
startNode
)
&
&
IsAtFrontOfNode
(
*
startNode
startOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
startNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
startOffset
=
parent
-
>
IndexOf
(
startNode
)
;
startNode
=
parent
;
}
while
(
endNode
&
&
!
endNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
IsEditable
(
endNode
)
&
&
IsAtEndOfNode
(
*
endNode
endOffset
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
endNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
endOffset
=
1
+
parent
-
>
IndexOf
(
endNode
)
;
endNode
=
parent
;
}
nsresult
rv
=
aRange
.
SetStart
(
startNode
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aRange
.
SetEnd
(
endNode
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsAtFrontOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
!
aOffset
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
firstNode
=
GetFirstEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
firstNode
true
)
;
if
(
aNode
.
IndexOf
(
firstNode
)
<
aOffset
)
{
return
false
;
}
return
true
;
}
bool
HTMLEditor
:
:
IsAtEndOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
{
if
(
aOffset
=
=
(
int32_t
)
aNode
.
Length
(
)
)
{
return
true
;
}
if
(
IsTextNode
(
&
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
lastNode
=
GetLastEditableChild
(
aNode
)
;
NS_ENSURE_TRUE
(
lastNode
true
)
;
if
(
aNode
.
IndexOf
(
lastNode
)
<
aOffset
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditor
:
:
GetInlinePropertyBase
(
nsIAtom
&
aProperty
const
nsAString
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
bool
aCheckDefaults
)
{
*
aAny
=
false
;
*
aAll
=
true
;
*
aFirst
=
false
;
bool
first
=
true
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
range
)
{
bool
firstNodeInRange
=
true
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
collapsedNode
=
range
-
>
GetStartParent
(
)
;
NS_ENSURE_TRUE
(
collapsedNode
NS_ERROR_FAILURE
)
;
bool
isSet
theSetting
;
nsString
tOutString
;
if
(
aAttribute
)
{
nsString
tString
(
*
aAttribute
)
;
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
tString
&
tOutString
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
}
else
{
mTypeInState
-
>
GetTypingState
(
isSet
theSetting
&
aProperty
)
;
}
if
(
isSet
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
theSetting
;
return
NS_OK
;
}
if
(
mCSSEditUtils
-
>
IsCSSEditableProperty
(
collapsedNode
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
tOutString
.
Assign
(
*
aValue
)
;
}
*
aFirst
=
*
aAny
=
*
aAll
=
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
collapsedNode
&
aProperty
aAttribute
tOutString
CSSEditUtils
:
:
eComputed
)
;
if
(
outValue
)
{
outValue
-
>
Assign
(
tOutString
)
;
}
return
NS_OK
;
}
isSet
=
IsTextPropertySetByContent
(
collapsedNode
&
aProperty
aAttribute
aValue
outValue
)
;
*
aFirst
=
*
aAny
=
*
aAll
=
isSet
;
if
(
!
isSet
&
&
aCheckDefaults
)
{
int32_t
index
;
if
(
aAttribute
&
&
TypeInState
:
:
FindPropInList
(
&
aProperty
*
aAttribute
outValue
mDefaultStyles
index
)
)
{
*
aFirst
=
*
aAny
=
*
aAll
=
true
;
if
(
outValue
)
{
outValue
-
>
Assign
(
mDefaultStyles
[
index
]
-
>
value
)
;
}
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsAutoString
firstValue
theValue
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndParent
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
for
(
iter
-
>
Init
(
range
)
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
if
(
!
iter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
iter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
if
(
content
-
>
GetAsText
(
)
&
&
(
!
IsEditable
(
content
)
|
|
IsEmptyTextNode
(
this
content
)
)
)
{
continue
;
}
if
(
content
-
>
GetAsText
(
)
)
{
if
(
!
isCollapsed
&
&
first
&
&
firstNodeInRange
)
{
firstNodeInRange
=
false
;
if
(
range
-
>
StartOffset
(
)
=
=
(
int32_t
)
content
-
>
Length
(
)
)
{
continue
;
}
}
else
if
(
content
=
=
endNode
&
&
!
endOffset
)
{
continue
;
}
}
else
if
(
content
-
>
IsElement
(
)
)
{
continue
;
}
bool
isSet
=
false
;
if
(
first
)
{
if
(
mCSSEditUtils
-
>
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
firstValue
.
Assign
(
*
aValue
)
;
}
isSet
=
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
firstValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
firstValue
)
;
}
*
aFirst
=
isSet
;
first
=
false
;
if
(
outValue
)
{
*
outValue
=
firstValue
;
}
}
else
{
if
(
mCSSEditUtils
-
>
IsCSSEditableProperty
(
content
&
aProperty
aAttribute
)
)
{
if
(
aValue
)
{
theValue
.
Assign
(
*
aValue
)
;
}
isSet
=
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
content
&
aProperty
aAttribute
theValue
CSSEditUtils
:
:
eComputed
)
;
}
else
{
isSet
=
IsTextPropertySetByContent
(
content
&
aProperty
aAttribute
aValue
&
theValue
)
;
}
if
(
firstValue
!
=
theValue
)
{
*
aAll
=
false
;
}
}
if
(
isSet
)
{
*
aAny
=
true
;
}
else
{
*
aAll
=
false
;
}
}
}
if
(
!
*
aAny
)
{
*
aAll
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlineProperty
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
{
NS_ENSURE_TRUE
(
aProperty
&
&
aFirst
&
&
aAny
&
&
aAll
NS_ERROR_NULL_POINTER
)
;
const
nsAString
*
att
=
nullptr
;
if
(
!
aAttribute
.
IsEmpty
(
)
)
att
=
&
aAttribute
;
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
return
GetInlinePropertyBase
(
*
aProperty
att
val
aFirst
aAny
aAll
nullptr
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetInlinePropertyWithAttrValue
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
{
NS_ENSURE_TRUE
(
aProperty
&
&
aFirst
&
&
aAny
&
&
aAll
NS_ERROR_NULL_POINTER
)
;
const
nsAString
*
att
=
nullptr
;
if
(
!
aAttribute
.
IsEmpty
(
)
)
att
=
&
aAttribute
;
const
nsAString
*
val
=
nullptr
;
if
(
!
aValue
.
IsEmpty
(
)
)
val
=
&
aValue
;
return
GetInlinePropertyBase
(
*
aProperty
att
val
aFirst
aAny
aAll
&
outValue
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveAllInlineProperties
(
)
{
AutoEditBatch
batchIt
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
resetTextProperties
nsIEditor
:
:
eNext
)
;
nsresult
rv
=
RemoveInlinePropertyImpl
(
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ApplyDefaultProperties
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInlineProperty
(
nsIAtom
*
aProperty
const
nsAString
&
aAttribute
)
{
return
RemoveInlinePropertyImpl
(
aProperty
&
aAttribute
)
;
}
nsresult
HTMLEditor
:
:
RemoveInlinePropertyImpl
(
nsIAtom
*
aProperty
const
nsAString
*
aAttribute
)
{
MOZ_ASSERT_IF
(
aProperty
aAttribute
)
;
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
ForceCompositionEnd
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
if
(
selection
-
>
Collapsed
(
)
)
{
if
(
aProperty
=
=
nsGkAtoms
:
:
href
|
|
aProperty
=
=
nsGkAtoms
:
:
name
)
{
aProperty
=
nsGkAtoms
:
:
a
;
}
if
(
aProperty
)
{
mTypeInState
-
>
ClearProp
(
aProperty
*
aAttribute
)
;
}
else
{
mTypeInState
-
>
ClearAllProps
(
)
;
}
return
NS_OK
;
}
AutoEditBatch
batchIt
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
removeTextProperty
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontSpazMySelection
(
this
)
;
bool
cancel
handled
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
removeTextProperty
)
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cancel
&
&
!
handled
)
{
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
OwningNonNull
<
nsRange
>
range
=
*
selection
-
>
GetRangeAt
(
rangeIdx
)
;
if
(
aProperty
=
=
nsGkAtoms
:
:
name
)
{
rv
=
PromoteRangeIfStartsOrEndsInNamedAnchor
(
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
PromoteInlineRange
(
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
SplitStyleAboveRange
(
range
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartParent
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndParent
(
)
;
if
(
startNode
&
&
startNode
=
=
endNode
&
&
startNode
-
>
GetAsText
(
)
)
{
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
-
>
IsCSSEditableProperty
(
startNode
aProperty
aAttribute
)
)
{
if
(
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
startNode
aProperty
aAttribute
EmptyString
(
)
CSSEditUtils
:
:
eComputed
)
)
{
if
(
mCSSEditUtils
-
>
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
NS_NAMED_LITERAL_STRING
(
value
"
-
moz
-
editor
-
invert
-
value
"
)
;
SetInlinePropertyOnTextNode
(
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
*
aProperty
aAttribute
value
)
;
}
}
}
}
else
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
iter
-
>
Init
(
range
)
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
-
>
GetCurrentNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
IsEditable
(
node
)
&
&
node
-
>
IsContent
(
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
RemoveStyleInside
(
node
aProperty
aAttribute
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
-
>
IsCSSEditableProperty
(
node
aProperty
aAttribute
)
&
&
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
node
aProperty
aAttribute
EmptyString
(
)
CSSEditUtils
:
:
eComputed
)
&
&
mCSSEditUtils
-
>
IsCSSInvertible
(
*
aProperty
aAttribute
)
)
{
NS_NAMED_LITERAL_STRING
(
value
"
-
moz
-
editor
-
invert
-
value
"
)
;
SetInlinePropertyOnNode
(
node
*
aProperty
aAttribute
value
)
;
}
}
}
}
}
if
(
!
cancel
)
{
rv
=
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IncreaseFontSize
(
)
{
return
RelativeFontChange
(
FontSize
:
:
incr
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DecreaseFontSize
(
)
{
return
RelativeFontChange
(
FontSize
:
:
decr
)
;
}
nsresult
HTMLEditor
:
:
RelativeFontChange
(
FontSize
aDir
)
{
ForceCompositionEnd
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
selection
-
>
Collapsed
(
)
)
{
nsIAtom
&
atom
=
aDir
=
=
FontSize
:
:
incr
?
*
nsGkAtoms
:
:
big
:
*
nsGkAtoms
:
:
small
;
NS_ENSURE_TRUE
(
selection
-
>
RangeCount
(
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartParent
(
)
NS_OK
)
;
OwningNonNull
<
nsINode
>
selectedNode
=
*
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartParent
(
)
;
if
(
IsTextNode
(
selectedNode
)
)
{
NS_ENSURE_TRUE
(
selectedNode
-
>
GetParentNode
(
)
NS_OK
)
;
selectedNode
=
*
selectedNode
-
>
GetParentNode
(
)
;
}
if
(
!
CanContainTag
(
selectedNode
atom
)
)
{
return
NS_OK
;
}
mTypeInState
-
>
SetProp
(
&
atom
EmptyString
(
)
EmptyString
(
)
)
;
return
NS_OK
;
}
AutoEditBatch
batchIt
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
setTextProperty
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontSpazMySelection
(
this
)
;
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
rangeIdx
)
;
nsresult
rv
=
PromoteInlineRange
(
*
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartParent
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndParent
(
)
;
if
(
startNode
=
=
endNode
&
&
IsTextNode
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
range
-
>
EndOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsTArray
<
OwningNonNull
<
nsIContent
>
>
arrayOfNodes
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
NS_ENSURE_TRUE
(
iter
-
>
GetCurrentNode
(
)
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
nsIContent
>
node
=
*
iter
-
>
GetCurrentNode
(
)
-
>
AsContent
(
)
;
if
(
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
node
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
RelativeFontChangeOnNode
(
aDir
=
=
FontSize
:
:
incr
?
+
1
:
-
1
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
IsTextNode
(
startNode
)
&
&
IsEditable
(
startNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
startNode
-
>
GetAsText
(
)
range
-
>
StartOffset
(
)
startNode
-
>
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsTextNode
(
endNode
)
&
&
IsEditable
(
endNode
)
)
{
rv
=
RelativeFontChangeOnTextNode
(
aDir
*
endNode
-
>
GetAsText
(
)
0
range
-
>
EndOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
FontSize
aDir
Text
&
aTextNode
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
if
(
!
aTextNode
.
GetParentNode
(
)
|
|
!
CanContainTag
(
*
aTextNode
.
GetParentNode
(
)
*
nsGkAtoms
:
:
big
)
)
{
return
NS_OK
;
}
OwningNonNull
<
nsIContent
>
node
=
aTextNode
;
if
(
aEndOffset
=
=
-
1
)
{
aEndOffset
=
aTextNode
.
Length
(
)
;
}
ErrorResult
rv
;
if
(
(
uint32_t
)
aEndOffset
!
=
aTextNode
.
Length
(
)
)
{
node
=
SplitNode
(
node
aEndOffset
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
if
(
aStartOffset
)
{
SplitNode
(
node
aStartOffset
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
nsIAtom
*
nodeType
=
aDir
=
=
FontSize
:
:
incr
?
nsGkAtoms
:
:
big
:
nsGkAtoms
:
:
small
;
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
node
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNode
(
node
sibling
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
sibling
=
GetNextHTMLSibling
(
node
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
nodeType
)
)
{
nsresult
rv
=
MoveNode
(
node
sibling
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newElement
=
InsertContainerAbove
(
node
nodeType
)
;
NS_ENSURE_STATE
(
newElement
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeHelper
(
int32_t
aSizeChange
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
font
)
&
&
aNode
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
size
)
)
{
for
(
uint32_t
i
=
aNode
-
>
GetChildCount
(
)
;
i
-
-
;
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
aNode
-
>
GetChildAt
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
for
(
uint32_t
i
=
aNode
-
>
GetChildCount
(
)
;
i
-
-
;
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
-
>
GetChildAt
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RelativeFontChangeOnNode
(
int32_t
aSizeChange
nsIContent
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
aSizeChange
!
=
1
&
&
aSizeChange
!
=
-
1
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsIAtom
*
atom
;
if
(
aSizeChange
=
=
1
)
{
atom
=
nsGkAtoms
:
:
big
;
}
else
{
atom
=
nsGkAtoms
:
:
small
;
}
if
(
(
aSizeChange
=
=
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
small
)
)
|
|
(
aSizeChange
=
=
-
1
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
big
)
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
RemoveContainer
(
aNode
)
;
}
if
(
TagCanContain
(
*
atom
*
aNode
)
)
{
nsresult
rv
=
RelativeFontChangeHelper
(
aSizeChange
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIContent
*
sibling
=
GetPriorHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNode
(
aNode
sibling
-
1
)
;
}
sibling
=
GetNextHTMLSibling
(
aNode
)
;
if
(
sibling
&
&
sibling
-
>
IsHTMLElement
(
atom
)
)
{
return
MoveNode
(
aNode
sibling
0
)
;
}
nsCOMPtr
<
Element
>
newElement
=
InsertContainerAbove
(
aNode
atom
)
;
NS_ENSURE_STATE
(
newElement
)
;
return
NS_OK
;
}
for
(
uint32_t
i
=
aNode
-
>
GetChildCount
(
)
;
i
-
-
;
)
{
nsresult
rv
=
RelativeFontChangeOnNode
(
aSizeChange
aNode
-
>
GetChildAt
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontFaceState
(
bool
*
aMixed
nsAString
&
outFace
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_FAILURE
)
;
*
aMixed
=
true
;
outFace
.
Truncate
(
)
;
bool
first
any
all
;
NS_NAMED_LITERAL_STRING
(
attr
"
face
"
)
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
&
attr
nullptr
&
first
&
any
&
all
&
outFace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
tt
nullptr
nullptr
&
first
&
any
&
all
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
any
&
&
!
all
)
{
return
rv
;
}
if
(
all
)
{
*
aMixed
=
false
;
outFace
.
AssignLiteral
(
"
tt
"
)
;
}
if
(
!
any
)
{
outFace
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFontColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
true
;
aOutColor
.
Truncate
(
)
;
NS_NAMED_LITERAL_STRING
(
colorStr
"
color
"
)
;
bool
first
any
all
;
nsresult
rv
=
GetInlinePropertyBase
(
*
nsGkAtoms
:
:
font
&
colorStr
nullptr
&
first
&
any
&
all
&
aOutColor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
any
&
&
!
all
)
{
return
NS_OK
;
}
if
(
all
)
{
*
aMixed
=
false
;
return
NS_OK
;
}
if
(
!
any
)
{
aOutColor
.
Truncate
(
)
;
*
aMixed
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetIsCSSEnabled
(
bool
*
aIsCSSEnabled
)
{
*
aIsCSSEnabled
=
IsCSSEnabled
(
)
;
return
NS_OK
;
}
static
bool
HasNonEmptyAttribute
(
Element
*
aElement
nsIAtom
*
aName
)
{
MOZ_ASSERT
(
aElement
)
;
nsAutoString
value
;
return
aElement
-
>
GetAttr
(
kNameSpaceID_None
aName
value
)
&
&
!
value
.
IsEmpty
(
)
;
}
bool
HTMLEditor
:
:
HasStyleOrIdOrClass
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
return
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
style
)
|
|
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
_class
)
|
|
HasNonEmptyAttribute
(
aElement
nsGkAtoms
:
:
id
)
;
}
nsresult
HTMLEditor
:
:
RemoveElementIfNoStyleOrIdOrClass
(
Element
&
aElement
)
{
if
(
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
font
)
)
|
|
HasStyleOrIdOrClass
(
&
aElement
)
)
{
return
NS_OK
;
}
return
RemoveContainer
(
&
aElement
)
;
}
}
