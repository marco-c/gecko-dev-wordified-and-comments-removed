#
include
"
PlaceholderTransaction
.
h
"
#
include
<
utility
>
#
include
"
CompositionTransaction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
using
namespace
dom
;
PlaceholderTransaction
:
:
PlaceholderTransaction
(
EditorBase
&
aEditorBase
nsAtom
*
aName
Maybe
<
SelectionState
>
&
&
aSelState
)
:
mEditorBase
(
&
aEditorBase
)
mForwarding
(
nullptr
)
mCompositionTransaction
(
nullptr
)
mStartSel
(
*
std
:
:
move
(
aSelState
)
)
mAbsorb
(
true
)
mCommitted
(
false
)
{
mName
=
aName
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
PlaceholderTransaction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEditorBase
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStartSel
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEndSel
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEditorBase
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStartSel
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEndSel
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PlaceholderTransaction
)
NS_INTERFACE_MAP_ENTRY
(
nsIAbsorbingTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditAggregateTransaction
)
NS_IMPL_ADDREF_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_RELEASE_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMETHODIMP
PlaceholderTransaction
:
:
DoTransaction
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
UndoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
EditAggregateTransaction
:
:
UndoTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditAggregateTransaction
:
:
UndoTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
mStartSel
.
RestoreSelection
(
*
selection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SelectionState
:
:
RestoreSelection
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
RedoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
EditAggregateTransaction
:
:
RedoTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditAggregateTransaction
:
:
RedoTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
mEndSel
.
RestoreSelection
(
*
selection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SelectionState
:
:
RestoreSelection
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
Merge
(
nsITransaction
*
aTransaction
bool
*
aDidMerge
)
{
if
(
NS_WARN_IF
(
!
aDidMerge
)
|
|
NS_WARN_IF
(
!
aTransaction
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aDidMerge
=
false
;
if
(
mForwarding
)
{
MOZ_ASSERT_UNREACHABLE
(
"
tried
to
merge
into
a
placeholder
that
was
in
"
"
forwarding
mode
!
"
)
;
return
NS_ERROR_FAILURE
;
}
EditTransactionBase
*
editTransactionBase
=
reinterpret_cast
<
EditTransactionBase
*
>
(
aTransaction
)
;
if
(
mAbsorb
)
{
RefPtr
<
CompositionTransaction
>
otherTransaction
=
do_QueryObject
(
aTransaction
)
;
if
(
otherTransaction
)
{
if
(
!
mCompositionTransaction
)
{
mCompositionTransaction
=
otherTransaction
;
DebugOnly
<
nsresult
>
rvIgnored
=
AppendChild
(
editTransactionBase
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditAggregateTransaction
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
}
else
{
bool
didMerge
;
mCompositionTransaction
-
>
Merge
(
otherTransaction
&
didMerge
)
;
if
(
!
didMerge
)
{
mCompositionTransaction
=
otherTransaction
;
DebugOnly
<
nsresult
>
rvIgnored
=
AppendChild
(
editTransactionBase
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditAggregateTransaction
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
}
}
}
else
{
nsCOMPtr
<
nsIAbsorbingTransaction
>
absorbingTransaction
=
do_QueryInterface
(
editTransactionBase
)
;
if
(
!
absorbingTransaction
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
AppendChild
(
editTransactionBase
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditAggregateTransaction
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
}
}
*
aDidMerge
=
true
;
return
NS_OK
;
}
if
(
mCommitted
|
|
(
mName
.
get
(
)
!
=
nsGkAtoms
:
:
TypingTxnName
&
&
mName
.
get
(
)
!
=
nsGkAtoms
:
:
IMETxnName
&
&
mName
.
get
(
)
!
=
nsGkAtoms
:
:
DeleteTxnName
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIAbsorbingTransaction
>
absorbingTransaction
=
do_QueryInterface
(
editTransactionBase
)
;
if
(
!
absorbingTransaction
)
{
return
NS_OK
;
}
RefPtr
<
nsAtom
>
otherTransactionName
;
DebugOnly
<
nsresult
>
rvIgnored
=
absorbingTransaction
-
>
GetTxnName
(
getter_AddRefs
(
otherTransactionName
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIAbsorbingTransaction
:
:
GetTxnName
(
)
failed
but
ignored
"
)
;
if
(
!
otherTransactionName
|
|
otherTransactionName
!
=
mName
)
{
return
NS_OK
;
}
if
(
!
absorbingTransaction
-
>
StartSelectionEquals
(
mEndSel
)
)
{
return
NS_OK
;
}
mAbsorb
=
true
;
absorbingTransaction
-
>
ForwardEndBatchTo
(
this
)
;
rvIgnored
=
RememberEndingSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
PlaceholderTransaction
:
:
RememberEndingSelection
(
)
failed
but
"
"
ignored
"
)
;
*
aDidMerge
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
GetTxnName
(
nsAtom
*
*
aName
)
{
nsresult
rv
=
GetName
(
aName
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditAggregationTransaction
:
:
GetName
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP_
(
bool
)
PlaceholderTransaction
:
:
StartSelectionEquals
(
SelectionState
&
aSelectionState
)
{
return
mStartSel
.
IsCollapsed
(
)
&
&
aSelectionState
.
IsCollapsed
(
)
&
&
mStartSel
.
Equals
(
aSelectionState
)
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
EndPlaceHolderBatch
(
)
{
mAbsorb
=
false
;
if
(
mForwarding
)
{
nsCOMPtr
<
nsIAbsorbingTransaction
>
forwardingTransaction
=
do_QueryReferent
(
mForwarding
)
;
if
(
forwardingTransaction
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
forwardingTransaction
-
>
EndPlaceHolderBatch
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIAbsorbingTransaction
:
:
EndPlaceHolderBatch
(
)
failed
but
ignored
"
)
;
}
}
nsresult
rv
=
RememberEndingSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PlaceholderTransaction
:
:
RememberEndingSelection
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP_
(
void
)
PlaceholderTransaction
:
:
ForwardEndBatchTo
(
nsIAbsorbingTransaction
*
aForwardingAddress
)
{
mForwarding
=
do_GetWeakReference
(
aForwardingAddress
)
;
}
NS_IMETHODIMP_
(
void
)
PlaceholderTransaction
:
:
Commit
(
)
{
mCommitted
=
true
;
}
nsresult
PlaceholderTransaction
:
:
RememberEndingSelection
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
mEndSel
.
SaveSelection
(
*
selection
)
;
return
NS_OK
;
}
}
