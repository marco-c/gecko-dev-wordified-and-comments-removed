#
include
"
PlaceholderTransaction
.
h
"
#
include
"
CompositionTransaction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
using
namespace
dom
;
PlaceholderTransaction
:
:
PlaceholderTransaction
(
EditorBase
&
aEditorBase
nsAtom
*
aName
Maybe
<
SelectionState
>
&
&
aSelState
)
:
mEditorBase
(
&
aEditorBase
)
mForwarding
(
nullptr
)
mCompositionTransaction
(
nullptr
)
mStartSel
(
*
std
:
:
move
(
aSelState
)
)
mAbsorb
(
true
)
mCommitted
(
false
)
{
mName
=
aName
;
}
PlaceholderTransaction
:
:
~
PlaceholderTransaction
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
PlaceholderTransaction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEditorBase
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStartSel
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEndSel
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEditorBase
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStartSel
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEndSel
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PlaceholderTransaction
)
NS_INTERFACE_MAP_ENTRY
(
nsIAbsorbingTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditAggregateTransaction
)
NS_IMPL_ADDREF_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMPL_RELEASE_INHERITED
(
PlaceholderTransaction
EditAggregateTransaction
)
NS_IMETHODIMP
PlaceholderTransaction
:
:
DoTransaction
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
UndoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
EditAggregateTransaction
:
:
UndoTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
return
mStartSel
.
RestoreSelection
(
selection
)
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
RedoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
EditAggregateTransaction
:
:
RedoTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
return
mEndSel
.
RestoreSelection
(
selection
)
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
Merge
(
nsITransaction
*
aTransaction
bool
*
aDidMerge
)
{
NS_ENSURE_TRUE
(
aDidMerge
&
&
aTransaction
NS_ERROR_NULL_POINTER
)
;
*
aDidMerge
=
false
;
if
(
mForwarding
)
{
MOZ_ASSERT_UNREACHABLE
(
"
tried
to
merge
into
a
placeholder
that
was
in
"
"
forwarding
mode
!
"
)
;
return
NS_ERROR_FAILURE
;
}
EditTransactionBase
*
editTransactionBase
=
(
EditTransactionBase
*
)
aTransaction
;
nsCOMPtr
<
nsIAbsorbingTransaction
>
absorbingTransaction
=
do_QueryObject
(
editTransactionBase
)
;
if
(
mAbsorb
)
{
RefPtr
<
CompositionTransaction
>
otherTransaction
=
do_QueryObject
(
aTransaction
)
;
if
(
otherTransaction
)
{
if
(
!
mCompositionTransaction
)
{
mCompositionTransaction
=
otherTransaction
;
AppendChild
(
editTransactionBase
)
;
}
else
{
bool
didMerge
;
mCompositionTransaction
-
>
Merge
(
otherTransaction
&
didMerge
)
;
if
(
!
didMerge
)
{
mCompositionTransaction
=
otherTransaction
;
AppendChild
(
editTransactionBase
)
;
}
}
}
else
if
(
!
absorbingTransaction
)
{
AppendChild
(
editTransactionBase
)
;
}
*
aDidMerge
=
true
;
}
else
{
if
(
(
mName
.
get
(
)
=
=
nsGkAtoms
:
:
TypingTxnName
|
|
mName
.
get
(
)
=
=
nsGkAtoms
:
:
IMETxnName
|
|
mName
.
get
(
)
=
=
nsGkAtoms
:
:
DeleteTxnName
)
&
&
!
mCommitted
)
{
if
(
absorbingTransaction
)
{
RefPtr
<
nsAtom
>
atom
;
absorbingTransaction
-
>
GetTxnName
(
getter_AddRefs
(
atom
)
)
;
if
(
atom
&
&
atom
=
=
mName
)
{
bool
isSame
;
absorbingTransaction
-
>
StartSelectionEquals
(
&
mEndSel
&
isSame
)
;
if
(
isSame
)
{
mAbsorb
=
true
;
absorbingTransaction
-
>
ForwardEndBatchTo
(
this
)
;
RememberEndingSelection
(
)
;
*
aDidMerge
=
true
;
}
}
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
GetTxnName
(
nsAtom
*
*
aName
)
{
return
GetName
(
aName
)
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
StartSelectionEquals
(
SelectionState
*
aSelState
bool
*
aResult
)
{
NS_ENSURE_TRUE
(
aResult
&
&
aSelState
NS_ERROR_NULL_POINTER
)
;
if
(
!
mStartSel
.
IsCollapsed
(
)
|
|
!
aSelState
-
>
IsCollapsed
(
)
)
{
*
aResult
=
false
;
return
NS_OK
;
}
*
aResult
=
mStartSel
.
IsEqual
(
aSelState
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
EndPlaceHolderBatch
(
)
{
mAbsorb
=
false
;
if
(
mForwarding
)
{
nsCOMPtr
<
nsIAbsorbingTransaction
>
plcTxn
=
do_QueryReferent
(
mForwarding
)
;
if
(
plcTxn
)
{
plcTxn
-
>
EndPlaceHolderBatch
(
)
;
}
}
return
RememberEndingSelection
(
)
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
ForwardEndBatchTo
(
nsIAbsorbingTransaction
*
aForwardingAddress
)
{
mForwarding
=
do_GetWeakReference
(
aForwardingAddress
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PlaceholderTransaction
:
:
Commit
(
)
{
mCommitted
=
true
;
return
NS_OK
;
}
nsresult
PlaceholderTransaction
:
:
RememberEndingSelection
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
mEndSel
.
SaveSelection
(
selection
)
;
return
NS_OK
;
}
}
