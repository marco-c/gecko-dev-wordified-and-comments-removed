#
include
"
TextEditor
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
\
if
(
IsReadonly
(
)
)
{
\
return
EditActionCanceled
(
NS_OK
)
;
\
}
void
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aTopLevelEditSubAction
aDirectionOfTopLevelEditSubAction
aRv
)
;
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
aTopLevelEditSubAction
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
aDirectionOfTopLevelEditSubAction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
;
}
if
(
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eSetText
)
{
SetSpellCheckRestartPoint
(
EditorDOMPoint
(
mRootElement
0
)
)
;
return
;
}
if
(
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
point
=
FindBetterInsertionPoint
(
EditorRawDOMPoint
(
SelectionRef
(
)
.
AnchorRef
(
)
)
)
;
NS_WARNING_ASSERTION
(
point
.
IsSet
(
)
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
if
(
point
.
IsSet
(
)
)
{
SetSpellCheckRestartPoint
(
point
)
;
return
;
}
}
if
(
SelectionRef
(
)
.
AnchorRef
(
)
.
IsSet
(
)
)
{
SetSpellCheckRestartPoint
(
EditorRawDOMPoint
(
SelectionRef
(
)
.
AnchorRef
(
)
)
)
;
}
}
nsresult
TextEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
;
while
(
true
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
rv
=
NS_ERROR_EDITOR_DESTROYED
;
break
;
}
if
(
NS_FAILED
(
rv
=
HandleInlineSpellCheckAfterEdit
(
)
)
)
{
NS_WARNING
(
"
TextEditor
:
:
HandleInlineSpellCheckAfterEdit
(
)
failed
"
)
;
break
;
}
if
(
!
IsSingleLineEditor
(
)
&
&
NS_FAILED
(
rv
=
EnsurePaddingBRElementInMultilineEditor
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
EnsurePaddingBRElementInMultilineEditor
(
)
failed
"
)
;
break
;
}
rv
=
EnsureCaretNotAtEndOfTextNode
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
break
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
EnsureCaretNotAtEndOfTextNode
(
)
failed
but
ignored
"
)
;
rv
=
NS_OK
;
break
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
GetTopLevelEditSubAction
(
)
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
eNone
)
;
return
rv
;
}
nsresult
TextEditor
:
:
InsertLineBreakAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertLineBreak
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
InsertLineFeedCharacterAtSelection
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
InsertLineFeedCharacterAtSelection
(
)
failed
but
ignored
"
)
;
return
result
.
Rv
(
)
;
}
EditActionResult
TextEditor
:
:
InsertLineFeedCharacterAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
if
(
mMaxTextLength
>
=
0
)
{
nsAutoString
insertionString
(
u
"
\
n
"
_ns
)
;
EditActionResult
result
=
MaybeTruncateInsertionStringForMaxLength
(
insertionString
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
Handled
(
)
)
{
return
EditActionCanceled
(
)
;
}
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
pointAfterInsertedLineFeed
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
u
"
\
n
"
_ns
pointToInsert
&
pointAfterInsertedLineFeed
)
;
if
(
!
pointAfterInsertedLineFeed
.
IsSet
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
\
\
n
)
didn
'
t
return
position
of
"
"
inserted
linefeed
"
)
;
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
InsertTextWithTransaction
(
\
\
n
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
!
pointAfterInsertedLineFeed
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterInsertedLineFeed
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
rv
=
SelectionRef
(
)
.
CollapseInLimiter
(
pointAfterInsertedLineFeed
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Selection
:
:
CollapseInLimiter
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
EditorRawDOMPoint
endPoint
(
EditorBase
:
:
GetEndPoint
(
SelectionRef
(
)
)
)
;
if
(
endPoint
=
=
pointAfterInsertedLineFeed
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
TextEditor
:
:
EnsureCaretNotAtEndOfTextNode
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CollapseSelectionToEnd
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
void
TextEditor
:
:
HandleNewLinesInStringForSingleLineEditor
(
nsString
&
aString
)
const
{
static
const
char16_t
kLF
=
static_cast
<
char16_t
>
(
'
\
n
'
)
;
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aString
.
FindChar
(
static_cast
<
uint16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
int32_t
firstLF
=
aString
.
FindChar
(
kLF
0
)
;
if
(
firstLF
=
=
kNotFound
)
{
return
;
}
switch
(
mNewlineHandling
)
{
case
nsIEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
LFSTR
false
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIEditor
:
:
eNewlinesStrip
:
aString
.
StripChar
(
kLF
)
;
break
;
case
nsIEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
offset
=
0
;
while
(
firstLF
=
=
offset
)
{
offset
+
+
;
firstLF
=
aString
.
FindChar
(
kLF
offset
)
;
}
if
(
firstLF
>
0
)
{
aString
.
Truncate
(
firstLF
)
;
}
if
(
offset
>
0
)
{
aString
.
Cut
(
0
offset
)
;
}
break
;
}
case
nsIEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
LFSTR
true
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsAutoString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextLF
=
!
offset
?
firstLF
:
aString
.
FindChar
(
kLF
offset
)
;
if
(
nextLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
{
-
-
wsBegin
;
}
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
{
+
+
offset
;
}
}
aString
=
result
;
break
;
}
case
nsIEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
LFSTR
true
true
)
;
break
;
}
}
EditActionResult
TextEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
SelectionHandling
aSelectionHandling
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
MOZ_ASSERT_IF
(
aSelectionHandling
=
=
SelectionHandling
:
:
Ignore
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
UndefineCaretBidiLevel
(
)
;
if
(
aInsertionString
.
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
return
EditActionCanceled
(
)
;
}
nsAutoString
insertionString
(
aInsertionString
)
;
if
(
mMaxTextLength
>
=
0
)
{
EditActionResult
result
=
MaybeTruncateInsertionStringForMaxLength
(
insertionString
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
)
failed
"
)
;
return
result
.
MarkAsHandled
(
)
;
}
if
(
result
.
Handled
(
)
&
&
insertionString
.
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
return
EditActionCanceled
(
)
;
}
}
uint32_t
start
=
0
;
if
(
IsPasswordEditor
(
)
)
{
if
(
GetComposition
(
)
&
&
!
GetComposition
(
)
-
>
String
(
)
.
IsEmpty
(
)
)
{
start
=
GetComposition
(
)
-
>
XPOffsetInTextNode
(
)
;
}
else
{
uint32_t
end
=
0
;
nsContentUtils
:
:
GetSelectionInTextControl
(
&
SelectionRef
(
)
GetRoot
(
)
start
end
)
;
}
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
aSelectionHandling
=
=
SelectionHandling
:
:
Delete
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
MaybeDoAutoPasswordMasking
(
)
;
if
(
IsSingleLineEditor
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
insertionString
)
;
HandleNewLinesInStringForSingleLineEditor
(
insertionString
)
;
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSetAndValid
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
!
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
FindBetterInsertionPoint
(
atStartOfSelection
)
;
NS_WARNING_ASSERTION
(
compositionStartPoint
.
IsSet
(
)
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
InsertTextWithTransaction
(
*
document
insertionString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
else
{
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
pointAfterStringInserted
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
insertionString
atStartOfSelection
&
pointAfterStringInserted
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
pointAfterStringInserted
.
IsSet
(
)
)
{
bool
endsWithLF
=
!
insertionString
.
IsEmpty
(
)
&
&
insertionString
.
Last
(
)
=
=
nsCRT
:
:
LF
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
endsWithLF
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
pointAfterStringInserted
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterStringInserted
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
ignoredError
=
IgnoredErrorResult
(
)
;
SelectionRef
(
)
.
CollapseInLimiter
(
pointAfterStringInserted
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseInLimiter
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
&
&
CanEchoPasswordNow
(
)
)
{
nsresult
rv
=
SetUnmaskRangeAndNotify
(
start
insertionString
.
Length
(
)
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetUnmaskRangeAndNotify
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
TextEditor
:
:
SetTextWithoutTransaction
(
const
nsAString
&
aValue
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsIMEComposing
(
)
)
;
MOZ_ASSERT
(
!
IsUndoRedoEnabled
(
)
)
;
MOZ_ASSERT
(
GetEditAction
(
)
!
=
EditAction
:
:
eReplaceText
)
;
MOZ_ASSERT
(
mMaxTextLength
<
0
)
;
MOZ_ASSERT
(
aValue
.
FindChar
(
static_cast
<
char16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
MaybeDoAutoPasswordMasking
(
)
;
RefPtr
<
Element
>
anonymousDivElement
=
GetRoot
(
)
;
RefPtr
<
Text
>
textNode
=
Text
:
:
FromNodeOrNull
(
anonymousDivElement
-
>
GetFirstChild
(
)
)
;
MOZ_ASSERT
(
textNode
)
;
if
(
!
IsSingleLineEditor
(
)
)
{
if
(
!
textNode
-
>
GetNextSibling
(
)
|
|
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
textNode
-
>
GetNextSibling
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
}
nsAutoString
sanitizedValue
(
aValue
)
;
if
(
IsSingleLineEditor
(
)
&
&
!
IsPasswordEditor
(
)
)
{
HandleNewLinesInStringForSingleLineEditor
(
sanitizedValue
)
;
}
nsresult
rv
=
SetTextNodeWithoutTransaction
(
sanitizedValue
*
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetTextNodeWithoutTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
TextEditor
:
:
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
if
(
IsEmpty
(
)
)
{
return
EditActionCanceled
(
)
;
}
EditActionResult
result
=
HandleDeleteSelectionInternal
(
aDirectionAndAmount
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
HandleDeleteSelectionInternal
(
eNoStrip
)
failed
"
)
;
return
result
;
}
EditActionResult
TextEditor
:
:
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
SelectionBatcher
selectionBatcher
(
SelectionRef
(
)
)
;
AutoHideSelectionChanges
hideSelection
(
SelectionRef
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
MaskAllCharacters
(
)
;
}
else
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
nsIEditor
:
:
eNoStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteSelectionWithTransaction
(
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
AutoCaretBidiLevelManager
bidiLevelManager
(
*
this
aDirectionAndAmount
selectionStartPoint
)
;
if
(
bidiLevelManager
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
AutoCaretBidiLevelManager
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
bidiLevelManager
.
MaybeUpdateCaretBidiLevel
(
*
this
)
;
if
(
bidiLevelManager
.
Canceled
(
)
)
{
return
EditActionCanceled
(
)
;
}
}
AutoRangeArray
rangesToDelete
(
SelectionRef
(
)
)
;
Result
<
nsIEditor
:
:
EDirection
nsresult
>
result
=
rangesToDelete
.
ExtendAnchorFocusRangeFor
(
*
this
aDirectionAndAmount
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
)
failed
"
)
;
return
EditActionResult
(
result
.
unwrapErr
(
)
)
;
}
if
(
const
Text
*
theTextNode
=
GetTextNode
(
)
)
{
rangesToDelete
.
EnsureRangesInTextNode
(
*
theTextNode
)
;
}
nsresult
rv
=
DeleteRangesWithTransaction
(
result
.
unwrap
(
)
nsIEditor
:
:
eNoStrip
rangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteRangesWithTransaction
(
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
TextEditor
:
:
ComputeValueFromTextNodeAndBRElement
(
nsAString
&
aValue
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsHTMLEditor
(
)
)
;
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
!
anonymousDivElement
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
Text
*
textNode
=
Text
:
:
FromNodeOrNull
(
anonymousDivElement
-
>
GetFirstChild
(
)
)
;
MOZ_ASSERT
(
textNode
)
;
if
(
!
textNode
-
>
Length
(
)
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
nsIContent
*
firstChildExceptText
=
textNode
-
>
GetNextSibling
(
)
;
bool
isInput
=
IsSingleLineEditor
(
)
;
bool
isTextarea
=
!
isInput
;
if
(
NS_WARN_IF
(
isInput
&
&
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChildExceptText
)
&
&
!
firstChildExceptText
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollbar
)
)
)
{
return
EditActionIgnored
(
)
;
}
textNode
-
>
GetData
(
aValue
)
;
return
EditActionHandled
(
)
;
}
EditActionResult
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mMaxTextLength
>
=
0
)
;
if
(
IsIMEComposing
(
)
)
{
return
EditActionIgnored
(
)
;
}
switch
(
GetEditAction
(
)
)
{
case
EditAction
:
:
ePaste
:
case
EditAction
:
:
ePasteAsQuotation
:
case
EditAction
:
:
eDrop
:
case
EditAction
:
:
eReplaceText
:
if
(
!
GetEditActionPrincipal
(
)
)
{
if
(
!
StaticPrefs
:
:
editor_truncate_user_pastes
(
)
)
{
return
EditActionIgnored
(
)
;
}
}
[
[
fallthrough
]
]
;
default
:
break
;
}
uint32_t
currentLength
=
UINT32_MAX
;
nsresult
rv
=
GetTextLength
(
&
currentLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
GetTextLength
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
uint32_t
selectionStart
selectionEnd
;
nsContentUtils
:
:
GetSelectionInTextControl
(
&
SelectionRef
(
)
GetRoot
(
)
selectionStart
selectionEnd
)
;
TextComposition
*
composition
=
GetComposition
(
)
;
const
uint32_t
kOldCompositionStringLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
uint32_t
kSelectionLength
=
selectionEnd
-
selectionStart
;
const
uint32_t
kNewLength
=
currentLength
-
kSelectionLength
-
kOldCompositionStringLength
;
if
(
kNewLength
>
=
AssertedCast
<
uint32_t
>
(
mMaxTextLength
)
)
{
aInsertionString
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
if
(
aInsertionString
.
Length
(
)
+
kNewLength
<
=
AssertedCast
<
uint32_t
>
(
mMaxTextLength
)
)
{
return
EditActionIgnored
(
)
;
}
int32_t
newInsertionStringLength
=
mMaxTextLength
-
kNewLength
;
MOZ_ASSERT
(
newInsertionStringLength
>
0
)
;
char16_t
maybeHighSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
-
1
)
;
char16_t
maybeLowSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
)
;
if
(
NS_IS_SURROGATE_PAIR
(
maybeHighSurrogate
maybeLowSurrogate
)
)
{
newInsertionStringLength
-
-
;
}
aInsertionString
.
Truncate
(
newInsertionStringLength
)
;
return
EditActionHandled
(
)
;
}
bool
TextEditor
:
:
CanEchoPasswordNow
(
)
const
{
if
(
!
LookAndFeel
:
:
GetEchoPassword
(
)
|
|
EchoingPasswordPrevented
(
)
)
{
return
false
;
}
return
GetEditAction
(
)
!
=
EditAction
:
:
eDrop
&
&
GetEditAction
(
)
!
=
EditAction
:
:
ePaste
;
}
}
