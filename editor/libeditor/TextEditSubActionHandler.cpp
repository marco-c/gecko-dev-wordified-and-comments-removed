#
include
"
TextEditor
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
\
if
(
IsReadonly
(
)
)
{
\
return
EditActionCanceled
(
NS_OK
)
;
\
}
nsresult
TextEditor
:
:
InitEditorContentAndSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
nsresult
rv
=
CollapseSelectionToEnd
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToEnd
(
)
failed
"
)
;
return
rv
;
}
}
if
(
IsPlaintextEditor
(
)
&
&
!
IsSingleLineEditor
(
)
)
{
nsresult
rv
=
EnsurePaddingBRElementInMultilineEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
EnsurePaddingBRElementInMultilineEditor
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
void
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aTopLevelEditSubAction
aDirectionOfTopLevelEditSubAction
aRv
)
;
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
aTopLevelEditSubAction
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
aDirectionOfTopLevelEditSubAction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
;
}
if
(
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eSetText
)
{
SetSpellCheckRestartPoint
(
EditorDOMPoint
(
mRootElement
0
)
)
;
return
;
}
if
(
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
point
=
FindBetterInsertionPoint
(
EditorRawDOMPoint
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
)
;
NS_WARNING_ASSERTION
(
point
.
IsSet
(
)
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
if
(
point
.
IsSet
(
)
)
{
SetSpellCheckRestartPoint
(
point
)
;
return
;
}
}
if
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
.
IsSet
(
)
)
{
SetSpellCheckRestartPoint
(
EditorRawDOMPoint
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
)
;
}
}
nsresult
TextEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
nsresult
rv
;
while
(
true
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
rv
=
NS_ERROR_EDITOR_DESTROYED
;
break
;
}
if
(
NS_FAILED
(
rv
=
HandleInlineSpellCheckAfterEdit
(
)
)
)
{
NS_WARNING
(
"
TextEditor
:
:
HandleInlineSpellCheckAfterEdit
(
)
failed
"
)
;
break
;
}
if
(
NS_FAILED
(
rv
=
EnsurePaddingBRElementForEmptyEditor
(
)
)
)
{
NS_WARNING
(
"
TextEditor
:
:
EnsurePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
break
;
}
if
(
!
IsSingleLineEditor
(
)
&
&
NS_FAILED
(
rv
=
EnsurePaddingBRElementInMultilineEditor
(
)
)
)
{
NS_WARNING
(
"
TextEditor
:
:
EnsurePaddingBRElementInMultilineEditor
(
)
failed
"
)
;
break
;
}
rv
=
EnsureCaretNotAtEndOfTextNode
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
break
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
EnsureCaretNotAtEndOfTextNode
(
)
failed
but
ignored
"
)
;
rv
=
NS_OK
;
break
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
GetTopLevelEditSubAction
(
)
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
eNone
)
;
return
rv
;
}
EditActionResult
TextEditor
:
:
InsertLineFeedCharacterAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
if
(
mMaxTextLength
>
=
0
)
{
nsAutoString
insertionString
(
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
EditActionResult
result
=
MaybeTruncateInsertionStringForMaxLength
(
insertionString
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
Handled
(
)
)
{
return
EditActionCanceled
(
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
pointAfterInsertedLineFeed
;
rv
=
InsertTextWithTransaction
(
*
document
NS_LITERAL_STRING
(
"
\
n
"
)
pointToInsert
&
pointAfterInsertedLineFeed
)
;
if
(
!
pointAfterInsertedLineFeed
.
IsSet
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
\
\
n
)
didn
'
t
return
position
of
"
"
inserted
linefeed
"
)
;
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
InsertTextWithTransaction
(
\
\
n
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
!
pointAfterInsertedLineFeed
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterInsertedLineFeed
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterInsertedLineFeed
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
EditorRawDOMPoint
endPoint
(
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
endPoint
=
=
pointAfterInsertedLineFeed
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
TextEditor
:
:
EnsureCaretNotAtEndOfTextNode
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsPlaintextEditor
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CollapseSelectionToEnd
(
)
failed
but
ignored
"
)
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
selectionStartPoint
.
IsInTextNode
(
)
|
|
!
selectionStartPoint
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
anonymousDivElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
parentNode
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
if
(
parentNode
!
=
anonymousDivElement
)
{
return
NS_OK
;
}
nsIContent
*
nextContent
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetNextSibling
(
)
;
if
(
!
nextContent
|
|
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextContent
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
afterStartContainer
(
EditorRawDOMPoint
:
:
After
(
*
selectionStartPoint
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
!
afterStartContainer
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterStartContainer
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
ignoredError
.
StealNSResult
(
)
;
}
void
TextEditor
:
:
HandleNewLinesInStringForSingleLineEditor
(
nsString
&
aString
)
const
{
static
const
char16_t
kLF
=
static_cast
<
char16_t
>
(
'
\
n
'
)
;
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsPlaintextEditor
(
)
)
;
MOZ_ASSERT
(
aString
.
FindChar
(
static_cast
<
uint16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
int32_t
firstLF
=
aString
.
FindChar
(
kLF
0
)
;
if
(
firstLF
=
=
kNotFound
)
{
return
;
}
switch
(
mNewlineHandling
)
{
case
nsIEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
LFSTR
false
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIEditor
:
:
eNewlinesStrip
:
aString
.
StripChar
(
kLF
)
;
break
;
case
nsIEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
offset
=
0
;
while
(
firstLF
=
=
offset
)
{
offset
+
+
;
firstLF
=
aString
.
FindChar
(
kLF
offset
)
;
}
if
(
firstLF
>
0
)
{
aString
.
Truncate
(
firstLF
)
;
}
if
(
offset
>
0
)
{
aString
.
Cut
(
0
offset
)
;
}
break
;
}
case
nsIEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
LFSTR
true
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsAutoString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextLF
=
!
offset
?
firstLF
:
aString
.
FindChar
(
kLF
offset
)
;
if
(
nextLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
{
-
-
wsBegin
;
}
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
{
+
+
offset
;
}
}
aString
=
result
;
break
;
}
case
nsIEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
LFSTR
true
true
)
;
break
;
}
}
EditActionResult
TextEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsTextEditor
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
UndefineCaretBidiLevel
(
)
;
if
(
aInsertionString
.
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
return
EditActionCanceled
(
)
;
}
nsAutoString
insertionString
(
aInsertionString
)
;
if
(
mMaxTextLength
>
=
0
)
{
EditActionResult
result
=
MaybeTruncateInsertionStringForMaxLength
(
insertionString
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
)
failed
"
)
;
return
result
.
MarkAsHandled
(
)
;
}
if
(
result
.
Handled
(
)
&
&
insertionString
.
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
return
EditActionCanceled
(
)
;
}
}
uint32_t
start
=
0
;
if
(
IsPasswordEditor
(
)
)
{
if
(
GetComposition
(
)
&
&
!
GetComposition
(
)
-
>
String
(
)
.
IsEmpty
(
)
)
{
start
=
GetComposition
(
)
-
>
XPOffsetInTextNode
(
)
;
}
else
{
uint32_t
end
=
0
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
GetRoot
(
)
start
end
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
MaybeDoAutoPasswordMasking
(
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSingleLineEditor
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
insertionString
)
;
HandleNewLinesInStringForSingleLineEditor
(
insertionString
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSetAndValid
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
!
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_NOT_INITIALIZED
)
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
FindBetterInsertionPoint
(
atStartOfSelection
)
;
NS_WARNING_ASSERTION
(
compositionStartPoint
.
IsSet
(
)
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
InsertTextWithTransaction
(
*
document
insertionString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
else
{
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
pointAfterStringInserted
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
insertionString
atStartOfSelection
&
pointAfterStringInserted
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
pointAfterStringInserted
.
IsSet
(
)
)
{
bool
endsWithLF
=
!
insertionString
.
IsEmpty
(
)
&
&
insertionString
.
Last
(
)
=
=
nsCRT
:
:
LF
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
endsWithLF
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
pointAfterStringInserted
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterStringInserted
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
ignoredError
=
IgnoredErrorResult
(
)
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterStringInserted
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
&
&
CanEchoPasswordNow
(
)
)
{
nsresult
rv
=
SetUnmaskRangeAndNotify
(
start
insertionString
.
Length
(
)
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetUnmaskRangeAndNotify
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
TextEditor
:
:
SetTextWithoutTransaction
(
const
nsAString
&
aValue
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
MOZ_ASSERT
(
IsPlaintextEditor
(
)
)
;
MOZ_ASSERT
(
!
IsIMEComposing
(
)
)
;
MOZ_ASSERT
(
!
IsUndoRedoEnabled
(
)
)
;
MOZ_ASSERT
(
GetEditAction
(
)
!
=
EditAction
:
:
eReplaceText
)
;
MOZ_ASSERT
(
mMaxTextLength
<
0
)
;
MOZ_ASSERT
(
aValue
.
FindChar
(
static_cast
<
char16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
MaybeDoAutoPasswordMasking
(
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
RefPtr
<
Element
>
anonymousDivElement
=
GetRoot
(
)
;
nsIContent
*
firstChild
=
anonymousDivElement
-
>
GetFirstChild
(
)
;
if
(
IsSingleLineEditor
(
)
)
{
if
(
firstChild
&
&
(
!
firstChild
-
>
IsText
(
)
|
|
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
}
else
{
if
(
!
firstChild
)
{
return
EditActionIgnored
(
)
;
}
if
(
firstChild
-
>
IsText
(
)
)
{
if
(
!
firstChild
-
>
GetNextSibling
(
)
|
|
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
}
else
if
(
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChild
)
)
{
return
EditActionIgnored
(
)
;
}
}
nsAutoString
sanitizedValue
(
aValue
)
;
if
(
IsSingleLineEditor
(
)
&
&
!
IsPasswordEditor
(
)
)
{
HandleNewLinesInStringForSingleLineEditor
(
sanitizedValue
)
;
}
if
(
!
firstChild
|
|
!
firstChild
-
>
IsText
(
)
)
{
if
(
sanitizedValue
.
IsEmpty
(
)
)
{
return
EditActionHandled
(
)
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionIgnored
(
)
;
}
RefPtr
<
nsTextNode
>
newTextNode
=
CreateTextNode
(
sanitizedValue
)
;
if
(
!
newTextNode
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateTextNode
(
)
failed
"
)
;
return
EditActionIgnored
(
)
;
}
nsresult
rv
=
InsertNodeWithTransaction
(
*
newTextNode
EditorDOMPoint
(
anonymousDivElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
RefPtr
<
Text
>
textNode
=
firstChild
-
>
GetAsText
(
)
;
if
(
MOZ_UNLIKELY
(
!
textNode
)
)
{
NS_WARNING
(
"
The
first
child
was
not
a
text
node
"
)
;
return
EditActionIgnored
(
)
;
}
rv
=
SetTextNodeWithoutTransaction
(
sanitizedValue
*
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetTextNodeWithoutTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
sanitizedValue
.
IsEmpty
(
)
&
&
!
textNode
-
>
Length
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
textNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePoisition
(
true
)
failed
"
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
TextEditor
:
:
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY
if
(
mPaddingBRElementForEmptyEditor
)
{
return
EditActionCanceled
(
)
;
}
EditActionResult
result
=
HandleDeleteSelectionInternal
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
HandleDeleteSelectionInternal
(
)
failed
"
)
;
return
result
;
}
EditActionResult
TextEditor
:
:
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
SelectionBatcher
selectionBatcher
(
SelectionRefPtr
(
)
)
;
AutoHideSelectionChanges
hideSelection
(
SelectionRefPtr
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
MaskAllCharacters
(
)
;
}
else
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteSelectionWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
result
=
SetCaretBidiLevelForDeletion
(
selectionStartPoint
aDirectionAndAmount
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
EditorBase
:
:
SetCaretBidiLevelForDeletion
(
)
failed
"
)
;
return
result
;
}
}
nsresult
rv
=
ExtendSelectionForDelete
(
&
aDirectionAndAmount
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
ExtendSelectionForDelete
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteSelectionWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
TextEditor
:
:
ComputeValueFromTextNodeAndPaddingBRElement
(
nsAString
&
aValue
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
mPaddingBRElementForEmptyEditor
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
if
(
AsHTMLEditor
(
)
)
{
return
EditActionIgnored
(
)
;
}
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
!
anonymousDivElement
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
nsIContent
*
textNodeOrPaddingBRElement
=
anonymousDivElement
-
>
GetFirstChild
(
)
;
if
(
!
textNodeOrPaddingBRElement
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
Text
*
textNode
=
textNodeOrPaddingBRElement
-
>
GetAsText
(
)
;
if
(
!
textNode
)
{
aValue
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
nsIContent
*
firstChildExceptText
=
textNode
?
textNodeOrPaddingBRElement
-
>
GetNextSibling
(
)
:
textNodeOrPaddingBRElement
;
bool
isInput
=
IsSingleLineEditor
(
)
;
bool
isTextarea
=
!
isInput
;
if
(
NS_WARN_IF
(
isInput
&
&
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChildExceptText
)
&
&
!
firstChildExceptText
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollbar
)
)
)
{
return
EditActionIgnored
(
)
;
}
textNode
-
>
GetData
(
aValue
)
;
return
EditActionHandled
(
)
;
}
nsresult
TextEditor
:
:
EnsurePaddingBRElementInMultilineEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsPlaintextEditor
(
)
)
;
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
anonymousDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
anonymousDivElement
-
>
GetLastChild
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
HTMLBRElement
>
brElement
=
HTMLBRElement
:
:
FromNode
(
anonymousDivElement
-
>
GetLastChild
(
)
)
;
if
(
!
brElement
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorDOMPoint
endOfAnonymousDiv
(
EditorDOMPoint
:
:
AtEndOf
(
*
anonymousDivElement
)
)
;
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfAnonymousDiv
)
;
NS_WARNING_ASSERTION
(
createPaddingBRResult
.
Succeeded
(
)
"
EditorBase
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
if
(
!
brElement
-
>
IsPaddingForEmptyEditor
(
)
)
{
return
NS_OK
;
}
brElement
-
>
UnsetFlags
(
NS_PADDING_FOR_EMPTY_EDITOR
)
;
brElement
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_LAST_LINE
)
;
return
NS_OK
;
}
EditActionResult
TextEditor
:
:
MaybeTruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mMaxTextLength
>
=
0
)
;
if
(
!
IsPlaintextEditor
(
)
|
|
IsIMEComposing
(
)
)
{
return
EditActionIgnored
(
)
;
}
switch
(
GetEditAction
(
)
)
{
case
EditAction
:
:
ePaste
:
case
EditAction
:
:
ePasteAsQuotation
:
case
EditAction
:
:
eDrop
:
case
EditAction
:
:
eReplaceText
:
if
(
!
GetEditActionPrincipal
(
)
)
{
if
(
!
StaticPrefs
:
:
editor_truncate_user_pastes
(
)
)
{
return
EditActionIgnored
(
)
;
}
}
[
[
fallthrough
]
]
;
default
:
break
;
}
int32_t
currentLength
=
INT32_MAX
;
nsresult
rv
=
GetTextLength
(
&
currentLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
GetTextLength
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
uint32_t
selectionStart
selectionEnd
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
GetRoot
(
)
selectionStart
selectionEnd
)
;
TextComposition
*
composition
=
GetComposition
(
)
;
const
uint32_t
kOldCompositionStringLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
uint32_t
kSelectionLength
=
selectionEnd
-
selectionStart
;
const
uint32_t
kNewLength
=
currentLength
-
kSelectionLength
-
kOldCompositionStringLength
;
if
(
kNewLength
>
=
static_cast
<
uint32_t
>
(
mMaxTextLength
)
)
{
aInsertionString
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
if
(
aInsertionString
.
Length
(
)
+
kNewLength
<
=
static_cast
<
uint32_t
>
(
mMaxTextLength
)
)
{
return
EditActionIgnored
(
)
;
}
int32_t
newInsertionStringLength
=
mMaxTextLength
-
kNewLength
;
MOZ_ASSERT
(
newInsertionStringLength
>
0
)
;
char16_t
maybeHighSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
-
1
)
;
char16_t
maybeLowSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
)
;
if
(
NS_IS_SURROGATE_PAIR
(
maybeHighSurrogate
maybeLowSurrogate
)
)
{
newInsertionStringLength
-
-
;
}
aInsertionString
.
Truncate
(
newInsertionStringLength
)
;
return
EditActionHandled
(
)
;
}
bool
TextEditor
:
:
CanEchoPasswordNow
(
)
const
{
if
(
!
LookAndFeel
:
:
GetEchoPassword
(
)
|
|
(
mFlags
&
nsIEditor
:
:
eEditorDontEchoPassword
)
)
{
return
false
;
}
return
GetEditAction
(
)
!
=
EditAction
:
:
eDrop
&
&
GetEditAction
(
)
!
=
EditAction
:
:
ePaste
;
}
}
