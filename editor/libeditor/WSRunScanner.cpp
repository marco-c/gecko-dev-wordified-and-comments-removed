#
include
"
WSRunScanner
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointInText
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPointInText
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointInText
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPointInText
&
aPoint
)
const
;
template
EditorDOMPoint
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorRawDOMPoint
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorDOMPoint
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorRawDOMPoint
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPoint
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorRawDOMPoint
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointInText
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInComposedDoc
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsSet
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInComposedDoc
(
)
)
)
{
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
WSType
:
:
InUncomposedDoc
mBlockInlineCheck
)
;
}
if
(
!
TextFragmentDataAtStartRef
(
)
.
IsInitialized
(
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
TextFragmentDataAtStartRef
(
)
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
visibleWhiteSpaces
.
IsInitialized
(
)
&
&
visibleWhiteSpaces
.
StartRef
(
)
.
IsBefore
(
aPoint
)
)
{
if
(
aPoint
.
GetChild
(
)
&
&
!
aPoint
.
GetChild
(
)
-
>
IsEditable
(
)
)
{
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
*
aPoint
.
GetChild
(
)
WSType
:
:
SpecialContent
mBlockInlineCheck
)
;
}
const
auto
atPreviousChar
=
GetPreviousEditableCharPoint
<
EditorRawDOMPointInText
>
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsContainerEmpty
(
)
)
{
MOZ_ASSERT
(
!
atPreviousChar
.
IsEndOfContainer
(
)
)
;
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
atPreviousChar
.
template
NextPoint
<
EditorDOMPoint
>
(
)
atPreviousChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
?
WSType
:
:
CollapsibleWhiteSpaces
:
atPreviousChar
.
IsCharPreformattedNewLine
(
)
?
WSType
:
:
PreformattedLineBreak
:
WSType
:
:
NonCollapsibleCharacters
mBlockInlineCheck
)
;
}
}
if
(
NS_WARN_IF
(
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
=
=
WSType
:
:
UnexpectedError
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
switch
(
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
)
{
case
WSType
:
:
CollapsibleWhiteSpaces
:
case
WSType
:
:
NonCollapsibleCharacters
:
case
WSType
:
:
PreformattedLineBreak
:
MOZ_ASSERT
(
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
.
IsSet
(
)
)
;
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
mBlockInlineCheck
)
;
default
:
break
;
}
if
(
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
!
=
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
.
GetContainer
(
)
)
{
if
(
NS_WARN_IF
(
!
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
*
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
mBlockInlineCheck
)
;
}
if
(
NS_WARN_IF
(
!
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
.
IsSet
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Backward
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
mBlockInlineCheck
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInComposedDoc
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsSet
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInComposedDoc
(
)
)
)
{
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
WSType
:
:
InUncomposedDoc
mBlockInlineCheck
)
;
}
if
(
!
TextFragmentDataAtStartRef
(
)
.
IsInitialized
(
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
TextFragmentDataAtStartRef
(
)
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
visibleWhiteSpaces
.
IsInitialized
(
)
&
&
aPoint
.
EqualsOrIsBefore
(
visibleWhiteSpaces
.
EndRef
(
)
)
)
{
if
(
aPoint
.
GetChild
(
)
&
&
!
aPoint
.
GetChild
(
)
-
>
IsEditable
(
)
)
{
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
*
aPoint
.
GetChild
(
)
WSType
:
:
SpecialContent
mBlockInlineCheck
)
;
}
const
auto
atNextChar
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPoint
>
(
aPoint
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsContainerEmpty
(
)
)
{
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
atNextChar
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
?
WSType
:
:
CollapsibleWhiteSpaces
:
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharPreformattedNewLine
(
)
?
WSType
:
:
PreformattedLineBreak
:
WSType
:
:
NonCollapsibleCharacters
mBlockInlineCheck
)
;
}
}
if
(
NS_WARN_IF
(
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
=
=
WSType
:
:
UnexpectedError
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
switch
(
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
)
{
case
WSType
:
:
CollapsibleWhiteSpaces
:
case
WSType
:
:
NonCollapsibleCharacters
:
case
WSType
:
:
PreformattedLineBreak
:
MOZ_ASSERT
(
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
.
IsSet
(
)
)
;
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
mBlockInlineCheck
)
;
default
:
break
;
}
if
(
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
!
=
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
.
GetContainer
(
)
)
{
if
(
NS_WARN_IF
(
!
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
*
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
mBlockInlineCheck
)
;
}
if
(
NS_WARN_IF
(
!
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
.
IsSet
(
)
)
)
{
return
WSScanResult
:
:
Error
(
)
;
}
return
WSScanResult
(
WSScanResult
:
:
ScanDirection
:
:
Forward
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
mBlockInlineCheck
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointType
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
:
mEditingHost
(
aEditingHost
)
mBlockInlineCheck
(
aBlockInlineCheck
)
{
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
aPoint
was
invalid
"
)
;
return
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
aPoint
was
in
Document
or
DocumentFragment
"
)
;
return
;
}
mScanStartPoint
=
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
;
}
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
aBlockInlineCheck
)
;
if
(
!
editableBlockElementOrInlineEditingHost
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
HTMLEditUtils
:
:
"
"
ClosestEditableBlockElementOrInlineEditingHost
)
couldn
'
t
find
"
"
editing
host
"
)
;
return
;
}
mStart
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
aBlockInlineCheck
)
;
MOZ_ASSERT_IF
(
mStart
.
IsNonCollapsibleCharacters
(
)
!
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsPreformattedLineBreak
(
)
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
mEnd
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
aBlockInlineCheck
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsNonCollapsibleCharacters
(
)
!
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsPreformattedLineBreak
(
)
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
std
:
:
min
(
aPoint
.
Offset
(
)
textFragment
.
GetLength
(
)
)
;
i
;
i
-
-
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
-
1
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
-
1
)
NoBreakingSpaceData
:
:
Scanning
:
:
Backward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
-
1
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineElement
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEditableBlockParentOrTopmostEditableInlineElement
.
IsEditable
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
aPoint
aNBSPData
aBlockInlineCheck
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
nsIContent
*
previousLeafContentOrBlock
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineElement
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aBlockInlineCheck
aEditingHost
)
;
if
(
!
previousLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineElement
)
HTMLEditUtils
:
:
IsBlockElement
(
aEditableBlockParentOrTopmostEditableInlineElement
aBlockInlineCheck
)
?
WSType
:
:
CurrentBlockBoundary
:
WSType
:
:
InlineEditingHostBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousLeafContentOrBlock
aBlockInlineCheck
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
IsText
(
)
|
|
!
previousLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
previousLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
AsText
(
)
-
>
TextLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
EditorDOMPointInText
:
:
AtEndOf
(
*
previousLeafContentOrBlock
-
>
AsText
(
)
)
aNBSPData
aBlockInlineCheck
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
aPoint
.
Offset
(
)
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
NoBreakingSpaceData
:
:
Scanning
:
:
Forward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineElement
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEditableBlockParentOrTopmostEditableInlineElement
.
IsEditable
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
aPoint
aNBSPData
aBlockInlineCheck
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
nsIContent
*
nextLeafContentOrBlock
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineElement
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aBlockInlineCheck
aEditingHost
)
;
if
(
!
nextLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineElement
)
HTMLEditUtils
:
:
IsBlockElement
(
aEditableBlockParentOrTopmostEditableInlineElement
aBlockInlineCheck
)
?
WSType
:
:
CurrentBlockBoundary
:
WSType
:
:
InlineEditingHostBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextLeafContentOrBlock
aBlockInlineCheck
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
IsText
(
)
|
|
!
nextLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
nextLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
AsText
(
)
-
>
TextFragment
(
)
.
GetLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aNBSPData
aBlockInlineCheck
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
nextLeafContentOrBlock
-
>
AsText
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleLeadingWhiteSpaceRangeRef
(
)
const
{
if
(
mLeadingWhiteSpaceRange
.
isSome
(
)
)
{
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
&
&
!
StartsFromInlineEditingHostBoundary
(
)
)
{
mLeadingWhiteSpaceRange
.
emplace
(
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mNBSPData
.
FirstPointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleTrailingWhiteSpaceRangeRef
(
)
const
{
if
(
mTrailingWhiteSpaceRange
.
isSome
(
)
)
{
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
EndsByBlockBoundary
(
)
&
&
!
EndsByInlineEditingHostBoundary
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
GetContainer
(
)
=
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
Offset
(
)
=
=
mEnd
.
PointRef
(
)
.
Offset
(
)
-
1
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
!
mNBSPData
.
LastPointRef
(
)
.
IsEndOfContainer
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mNBSPData
.
LastPointRef
(
)
.
NextPoint
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
EditorDOMRangeInTexts
WSRunScanner
:
:
TextFragmentData
:
:
GetNonCollapsedRangeInTexts
(
const
EditorDOMRange
&
aRange
)
const
{
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
IsInTextNodes
(
)
)
{
return
aRange
.
GetAsInTexts
(
)
;
}
const
auto
firstPoint
=
aRange
.
StartRef
(
)
.
IsInTextNode
(
)
?
aRange
.
StartRef
(
)
.
AsInText
(
)
:
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aRange
.
StartRef
(
)
)
;
if
(
!
firstPoint
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
endPoint
;
if
(
aRange
.
EndRef
(
)
.
IsInTextNode
(
)
)
{
endPoint
=
aRange
.
EndRef
(
)
.
AsInText
(
)
;
}
else
{
endPoint
=
GetPreviousEditableCharPoint
(
aRange
.
EndRef
(
)
)
;
if
(
endPoint
.
IsSet
(
)
&
&
endPoint
.
IsAtLastContent
(
)
)
{
MOZ_ALWAYS_TRUE
(
endPoint
.
AdvanceOffset
(
)
)
;
}
}
if
(
!
endPoint
.
IsSet
(
)
|
|
firstPoint
=
=
endPoint
)
{
return
EditorDOMRangeInTexts
(
)
;
}
return
EditorDOMRangeInTexts
(
firstPoint
endPoint
)
;
}
const
WSRunScanner
:
:
VisibleWhiteSpacesData
&
WSRunScanner
:
:
TextFragmentData
:
:
VisibleWhiteSpacesDataRef
(
)
const
{
if
(
mVisibleWhiteSpacesData
.
isSome
(
)
)
{
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
{
const
bool
mayHaveInvisibleLeadingSpace
=
!
StartsFromNonCollapsibleCharacters
(
)
&
&
!
StartsFromSpecialContent
(
)
;
const
bool
mayHaveInvisibleTrailingWhiteSpace
=
!
EndsByNonCollapsibleCharacters
(
)
&
&
!
EndsBySpecialContent
(
)
&
&
!
EndsByBRElement
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
;
if
(
!
mayHaveInvisibleLeadingSpace
&
&
!
mayHaveInvisibleTrailingWhiteSpace
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveLeadingWhiteSpaces
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveLeadingWhiteSpaces
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveTrailingWhiteSpaces
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveTrailingWhiteSpaces
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
&
&
!
StartsFromInlineEditingHostBoundary
(
)
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
=
Some
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
|
|
StartsFromInlineEditingHostBoundary
(
)
)
;
MOZ_ASSERT
(
maybeHaveLeadingWhiteSpaces
)
;
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFromLeadingWhiteSpaces
(
)
;
if
(
!
EndsByBlockBoundary
(
)
&
&
!
EndsByInlineEditingHostBoundary
(
)
)
{
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
EndsByBlockBoundary
(
)
|
|
EndsByInlineEditingHostBoundary
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtEndOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtStartToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
aTextFragmentDataAtStartToDelete
.
ScanStartRef
(
)
;
const
EditorDOMPoint
&
endToDelete
=
mScanStartPoint
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
EndRef
(
)
.
EqualsOrIsBefore
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
endToDelete
)
;
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
endToDelete
)
;
return
ReplaceRangeData
(
invisibleTrailingWhiteSpaceRangeAtEnd
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtEnd
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtEnd
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
=
nonPreformattedVisibleWhiteSpacesAtEnd
.
ComparePoint
(
endToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
StartOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
MiddleOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtStartToDelete
.
FollowingContentMayBecomeFirstVisibleContent
(
startToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
auto
nextCharOfStartOfEnd
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
endToDelete
)
;
if
(
!
nextCharOfStartOfEnd
.
IsSet
(
)
|
|
nextCharOfStartOfEnd
.
IsEndOfContainer
(
)
|
|
!
nextCharOfStartOfEnd
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
nextCharOfStartOfEnd
.
IsStartOfContainer
(
)
|
|
nextCharOfStartOfEnd
.
IsPreviousCharCollapsibleASCIISpace
(
)
)
{
nextCharOfStartOfEnd
=
aTextFragmentDataAtStartToDelete
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
aTextFragmentDataAtStartToDelete
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
nextCharOfStartOfEnd
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtStartOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtEndToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
mScanStartPoint
;
const
EditorDOMPoint
&
endToDelete
=
aTextFragmentDataAtEndToDelete
.
ScanStartRef
(
)
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
startToDelete
.
EqualsOrIsBefore
(
StartRef
(
)
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
startToDelete
)
;
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
return
ReplaceRangeData
(
invisibleLeadingWhiteSpaceRangeAtStart
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtStart
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtStart
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
=
nonPreformattedVisibleWhiteSpacesAtStart
.
ComparePoint
(
startToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
MiddleOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
EndOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtEndToDelete
.
PrecedingContentMayBecomeInvisible
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
startToDelete
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
child
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
child
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
child
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
child
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
Set
(
leafContent
0
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsEndOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetEndReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
mBlockInlineCheck
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
nextContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
)
{
if
(
!
nextContent
-
>
IsText
(
)
|
|
!
nextContent
-
>
IsEditable
(
)
)
{
if
(
nextContent
=
=
GetEndReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
nextContent
-
>
AsText
(
)
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
previousChild
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetPreviousSiblingOfChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
previousChild
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousChild
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
previousChild
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
SetToEndOf
(
leafContent
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsStartOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
-
1
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetStartReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
mBlockInlineCheck
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
)
{
if
(
!
previousContent
-
>
IsText
(
)
|
|
!
previousContent
-
>
IsEditable
(
)
)
{
if
(
previousContent
=
=
GetStartReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
previousContent
-
>
AsText
(
)
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
?
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
-
1
:
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
{
EditorDOMPoint
atLastCharOfTextNode
(
&
aTextNode
AssertedCast
<
uint32_t
>
(
std
:
:
max
<
int64_t
>
(
static_cast
<
int64_t
>
(
aTextNode
.
Length
(
)
)
-
1
0
)
)
)
;
if
(
!
atLastCharOfTextNode
.
IsContainerEmpty
(
)
&
&
!
atLastCharOfTextNode
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
aTextNode
)
;
}
TextFragmentData
textFragmentData
(
atLastCharOfTextNode
aAncestorLimiter
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
EditorDOMRange
&
invisibleWhiteSpaceRange
=
textFragmentData
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
!
invisibleWhiteSpaceRange
.
IsPositioned
(
)
|
|
invisibleWhiteSpaceRange
.
Collapsed
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
aTextNode
)
;
}
return
invisibleWhiteSpaceRange
.
StartRef
(
)
.
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
{
EditorDOMPoint
atStartOfTextNode
(
&
aTextNode
0
)
;
if
(
!
atStartOfTextNode
.
IsContainerEmpty
(
)
&
&
atStartOfTextNode
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
atStartOfTextNode
.
To
<
EditorDOMPointType
>
(
)
;
}
TextFragmentData
textFragmentData
(
atStartOfTextNode
aAncestorLimiter
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
EditorDOMRange
&
invisibleWhiteSpaceRange
=
textFragmentData
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
!
invisibleWhiteSpaceRange
.
IsPositioned
(
)
|
|
invisibleWhiteSpaceRange
.
Collapsed
(
)
)
{
return
atStartOfTextNode
.
To
<
EditorDOMPointType
>
(
)
;
}
return
invisibleWhiteSpaceRange
.
EndRef
(
)
.
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanFollowingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtNextVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtNextVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
&
&
aAtNextVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanNextNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanFollowingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
aPoint
)
;
if
(
!
nextVisibleCharOffset
.
isSome
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atNextVisibleChar
(
aPoint
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanFollowingWhiteSpaces
(
atNextVisibleChar
)
)
{
return
atNextVisibleChar
;
}
hasSeenPreformattedNewLine
|
=
atNextVisibleChar
.
IsCharPreformattedNewLine
(
)
;
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
atNextVisibleChar
)
;
if
(
nextVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsAtLastContent
(
)
)
{
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
afterLastWhiteSpace
=
EditorDOMPointInText
:
:
AtEndOf
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
;
for
(
EditorDOMPointInText
atEndOfPreviousTextNode
=
afterLastWhiteSpace
;
;
)
{
const
auto
atStartOfNextTextNode
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atEndOfPreviousTextNode
)
;
if
(
!
atStartOfNextTextNode
.
IsSet
(
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atStartOfNextTextNode
.
IsContainerEmpty
(
)
)
{
atEndOfPreviousTextNode
=
atStartOfNextTextNode
;
continue
;
}
if
(
!
atStartOfNextTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanFollowingWhiteSpaces
(
atStartOfNextTextNode
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
atStartOfNextTextNode
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
afterLastWhiteSpace
=
atEndOfPreviousTextNode
=
EditorDOMPointInText
:
:
AtEndOf
(
*
atStartOfNextTextNode
.
ContainerAs
<
Text
>
(
)
)
;
}
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanPrecedingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtPreviousVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtPreviousVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
&
&
aAtPreviousVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanPreviousNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanPrecedingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
aPoint
)
;
if
(
previousVisibleCharOffset
.
isNothing
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atPreviousVisibleCharacter
(
aPoint
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanPrecedingWhiteSpaces
(
atPreviousVisibleCharacter
)
)
{
return
atPreviousVisibleCharacter
.
NextPoint
(
)
;
}
hasSeenPreformattedNewLine
|
=
atPreviousVisibleCharacter
.
IsCharPreformattedNewLine
(
)
;
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
atPreviousVisibleCharacter
)
;
if
(
previousVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
+
1
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsStartOfContainer
(
)
)
{
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
atLastWhiteSpace
=
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
0u
)
;
for
(
EditorDOMPointInText
atStartOfPreviousTextNode
=
atLastWhiteSpace
;
;
)
{
const
EditorDOMPointInText
atLastCharOfPreviousTextNode
=
GetPreviousEditableCharPoint
(
atStartOfPreviousTextNode
)
;
if
(
!
atLastCharOfPreviousTextNode
.
IsSet
(
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atLastCharOfPreviousTextNode
.
IsContainerEmpty
(
)
)
{
atStartOfPreviousTextNode
=
atLastCharOfPreviousTextNode
;
continue
;
}
if
(
!
atLastCharOfPreviousTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanPrecedingWhiteSpaces
(
atLastCharOfPreviousTextNode
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
atLastCharOfPreviousTextNode
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
atLastWhiteSpace
=
atStartOfPreviousTextNode
=
EditorDOMPointInText
(
atLastCharOfPreviousTextNode
.
ContainerAs
<
Text
>
(
)
0u
)
;
}
}
char16_t
WSRunScanner
:
:
GetCharAt
(
Text
*
aTextNode
uint32_t
aOffset
)
const
{
if
(
NS_WARN_IF
(
!
aTextNode
)
|
|
NS_WARN_IF
(
aOffset
>
=
aTextNode
-
>
TextDataLength
(
)
)
)
{
return
0
;
}
return
aTextNode
-
>
TextFragment
(
)
.
CharAt
(
aOffset
)
;
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
EndOfFragment
"
Previous
char
of
aPoint
should
be
in
the
visible
white
-
spaces
"
)
;
const
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
aPointToInsert
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
|
|
atPreviousChar
.
IsEndOfContainer
(
)
|
|
!
atPreviousChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
EditorDOMPointInText
atPreviousCharOfPreviousChar
=
GetPreviousEditableCharPoint
(
atPreviousChar
)
;
if
(
atPreviousCharOfPreviousChar
.
IsSet
(
)
)
{
if
(
atPreviousChar
.
ContainerAs
<
Text
>
(
)
!
=
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atPreviousCharOfPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousChar
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
StartsFromNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
StartsFromSpecialContent
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
StartOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
"
Inclusive
next
char
of
aPointToInsert
should
be
in
the
visible
"
"
white
-
spaces
"
)
;
auto
atNextChar
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPointToInsert
)
;
if
(
!
atNextChar
.
IsSet
(
)
|
|
NS_WARN_IF
(
atNextChar
.
IsEndOfContainer
(
)
)
|
|
!
atNextChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
auto
atNextCharOfNextCharOfNBSP
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atNextChar
.
NextPoint
<
EditorRawDOMPointInText
>
(
)
)
;
if
(
atNextCharOfNextCharOfNBSP
.
IsSet
(
)
)
{
if
(
atNextChar
.
ContainerAs
<
Text
>
(
)
!
=
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atNextCharOfNextCharOfNBSP
.
IsEndOfContainer
(
)
&
&
atNextCharOfNextCharOfNBSP
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
EndsByNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
EndsBySpecialContent
(
)
&
&
!
visibleWhiteSpaces
.
EndsByBRElement
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
EditorDOMRangeInTexts
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
const
TextFragmentData
&
aStart
const
TextFragmentData
&
aEnd
)
{
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEnd
.
ScanStartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
EqualsOrIsBefore
(
aEnd
.
ScanStartRef
(
)
)
)
;
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
IsInTextNode
(
)
)
;
MOZ_ASSERT
(
aEnd
.
ScanStartRef
(
)
.
IsInTextNode
(
)
)
;
const
EditorDOMRange
&
invisibleLeadingWhiteSpaceRange
=
aStart
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
EditorDOMRange
&
invisibleTrailingWhiteSpaceRange
=
aEnd
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
const
bool
hasInvisibleLeadingWhiteSpaces
=
invisibleLeadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpaceRange
.
Collapsed
(
)
;
const
bool
hasInvisibleTrailingWhiteSpaces
=
invisibleLeadingWhiteSpaceRange
!
=
invisibleTrailingWhiteSpaceRange
&
&
invisibleTrailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
invisibleTrailingWhiteSpaceRange
.
Collapsed
(
)
;
EditorDOMRangeInTexts
result
(
aStart
.
ScanStartRef
(
)
.
AsInText
(
)
aEnd
.
ScanStartRef
(
)
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
if
(
!
hasInvisibleLeadingWhiteSpaces
&
&
!
hasInvisibleTrailingWhiteSpaces
)
{
return
result
;
}
MOZ_ASSERT_IF
(
hasInvisibleLeadingWhiteSpaces
&
&
hasInvisibleTrailingWhiteSpaces
invisibleLeadingWhiteSpaceRange
.
StartRef
(
)
.
IsBefore
(
invisibleTrailingWhiteSpaceRange
.
StartRef
(
)
)
)
;
const
EditorDOMPoint
&
aroundFirstInvisibleWhiteSpace
=
hasInvisibleLeadingWhiteSpaces
?
invisibleLeadingWhiteSpaceRange
.
StartRef
(
)
:
invisibleTrailingWhiteSpaceRange
.
StartRef
(
)
;
if
(
aroundFirstInvisibleWhiteSpace
.
IsBefore
(
result
.
StartRef
(
)
)
)
{
if
(
aroundFirstInvisibleWhiteSpace
.
IsInTextNode
(
)
)
{
result
.
SetStart
(
aroundFirstInvisibleWhiteSpace
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
}
else
{
const
auto
atFirstInvisibleWhiteSpace
=
hasInvisibleLeadingWhiteSpaces
?
aStart
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aroundFirstInvisibleWhiteSpace
)
:
aEnd
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aroundFirstInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
atFirstInvisibleWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
atFirstInvisibleWhiteSpace
.
EqualsOrIsBefore
(
result
.
StartRef
(
)
)
)
;
result
.
SetStart
(
atFirstInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
}
}
MOZ_ASSERT_IF
(
hasInvisibleLeadingWhiteSpaces
&
&
hasInvisibleTrailingWhiteSpaces
invisibleLeadingWhiteSpaceRange
.
EndRef
(
)
.
IsBefore
(
invisibleTrailingWhiteSpaceRange
.
EndRef
(
)
)
)
;
const
EditorDOMPoint
&
afterLastInvisibleWhiteSpace
=
hasInvisibleTrailingWhiteSpaces
?
invisibleTrailingWhiteSpaceRange
.
EndRef
(
)
:
invisibleLeadingWhiteSpaceRange
.
EndRef
(
)
;
if
(
afterLastInvisibleWhiteSpace
.
EqualsOrIsBefore
(
result
.
EndRef
(
)
)
)
{
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
if
(
afterLastInvisibleWhiteSpace
.
IsInTextNode
(
)
)
{
result
.
SetEnd
(
afterLastInvisibleWhiteSpace
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
const
auto
atLastInvisibleWhiteSpace
=
hasInvisibleTrailingWhiteSpaces
?
aEnd
.
GetPreviousEditableCharPoint
(
afterLastInvisibleWhiteSpace
)
:
aStart
.
GetPreviousEditableCharPoint
(
afterLastInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
atLastInvisibleWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
atLastInvisibleWhiteSpace
.
IsContainerEmpty
(
)
|
|
atLastInvisibleWhiteSpace
.
IsAtLastContent
(
)
)
;
MOZ_ASSERT
(
result
.
EndRef
(
)
.
EqualsOrIsBefore
(
atLastInvisibleWhiteSpace
)
)
;
result
.
SetEnd
(
atLastInvisibleWhiteSpace
.
IsEndOfContainer
(
)
?
atLastInvisibleWhiteSpace
:
atLastInvisibleWhiteSpace
.
NextPoint
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
Result
<
EditorDOMRangeInTexts
nsresult
>
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
TextFragmentData
textFragmentDataAtCaret
(
aPoint
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtCaret
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPointInText
atPreviousChar
=
textFragmentDataAtCaret
.
GetPreviousEditableCharPoint
(
aPoint
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
atPreviousChar
.
IsEndOfContainer
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
atNextChar
=
atPreviousChar
.
NextPoint
(
)
;
if
(
!
atPreviousChar
.
IsStartOfContainer
(
)
)
{
if
(
atPreviousChar
.
IsCharLowSurrogateFollowingHighSurrogate
(
)
)
{
atPreviousChar
=
atPreviousChar
.
PreviousPoint
(
)
;
}
else
if
(
atPreviousChar
.
IsCharHighSurrogateFollowedByLowSurrogate
(
)
)
{
atNextChar
=
atNextChar
.
NextPoint
(
)
;
}
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
atPreviousChar
.
IsCharCollapsibleASCIISpace
(
)
|
|
atPreviousChar
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
const
EditorDOMPointInText
startToDelete
=
textFragmentDataAtCaret
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousChar
nsIEditor
:
:
ePrevious
)
;
if
(
!
startToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMPointInText
endToDelete
=
textFragmentDataAtCaret
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousChar
nsIEditor
:
:
ePrevious
)
;
if
(
!
endToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rangeToDelete
=
EditorDOMRangeInTexts
(
startToDelete
endToDelete
)
;
}
else
{
rangeToDelete
=
EditorDOMRangeInTexts
(
atPreviousChar
atNextChar
)
;
}
if
(
rangeToDelete
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
TextFragmentData
textFragmentDataAtStart
=
rangeToDelete
.
StartRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
StartRef
(
)
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
textFragmentDataAtCaret
;
TextFragmentData
textFragmentDataAtEnd
=
rangeToDelete
.
EndRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
EndRef
(
)
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
textFragmentDataAtCaret
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRangeInTexts
extendedRangeToDelete
=
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
textFragmentDataAtStart
textFragmentDataAtEnd
)
;
MOZ_ASSERT
(
extendedRangeToDelete
.
IsPositionedAndValid
(
)
)
;
return
extendedRangeToDelete
.
IsPositioned
(
)
?
extendedRangeToDelete
:
rangeToDelete
;
}
Result
<
EditorDOMRangeInTexts
nsresult
>
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
TextFragmentData
textFragmentDataAtCaret
(
aPoint
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtCaret
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
auto
atCaret
=
textFragmentDataAtCaret
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPoint
)
;
if
(
!
atCaret
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
!
atCaret
.
IsEndOfContainer
(
)
&
&
atCaret
.
IsCharLowSurrogateFollowingHighSurrogate
(
)
)
{
atCaret
=
atCaret
.
NextPoint
(
)
;
}
if
(
atCaret
.
IsEndOfContainer
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
atNextChar
=
atCaret
.
NextPoint
(
)
;
if
(
atCaret
.
IsCharHighSurrogateFollowedByLowSurrogate
(
)
)
{
atNextChar
=
atNextChar
.
NextPoint
(
)
;
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
atCaret
.
IsCharCollapsibleASCIISpace
(
)
|
|
atCaret
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
const
EditorDOMPointInText
startToDelete
=
textFragmentDataAtCaret
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atCaret
nsIEditor
:
:
eNext
)
;
if
(
!
startToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMPointInText
endToDelete
=
textFragmentDataAtCaret
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atCaret
nsIEditor
:
:
eNext
)
;
if
(
!
endToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rangeToDelete
=
EditorDOMRangeInTexts
(
startToDelete
endToDelete
)
;
}
else
{
rangeToDelete
=
EditorDOMRangeInTexts
(
atCaret
atNextChar
)
;
}
if
(
rangeToDelete
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
TextFragmentData
textFragmentDataAtStart
=
rangeToDelete
.
StartRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
StartRef
(
)
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
textFragmentDataAtCaret
;
TextFragmentData
textFragmentDataAtEnd
=
rangeToDelete
.
EndRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
EndRef
(
)
&
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
textFragmentDataAtCaret
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRangeInTexts
extendedRangeToDelete
=
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
textFragmentDataAtStart
textFragmentDataAtEnd
)
;
MOZ_ASSERT
(
extendedRangeToDelete
.
IsPositionedAndValid
(
)
)
;
return
extendedRangeToDelete
.
IsPositioned
(
)
?
extendedRangeToDelete
:
rangeToDelete
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangesForDeletingAtomicContent
(
Element
*
aEditingHost
const
nsIContent
&
aAtomicContent
)
{
if
(
aAtomicContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
TextFragmentData
textFragmentDataAfterBRElement
(
EditorDOMPoint
:
:
After
(
aAtomicContent
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAfterBRElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
followingInvisibleWhiteSpaces
=
textFragmentDataAfterBRElement
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAfterBRElement
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
return
followingInvisibleWhiteSpaces
.
IsPositioned
(
)
&
&
!
followingInvisibleWhiteSpaces
.
Collapsed
(
)
?
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
:
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aAtomicContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
TextFragmentData
textFragmentDataBeforeAtomicContent
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataBeforeAtomicContent
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
precedingInvisibleWhiteSpaces
=
textFragmentDataBeforeAtomicContent
.
GetNonCollapsedRangeInTexts
(
textFragmentDataBeforeAtomicContent
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
TextFragmentData
textFragmentDataAfterAtomicContent
(
EditorDOMPoint
:
:
After
(
aAtomicContent
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAfterAtomicContent
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
followingInvisibleWhiteSpaces
=
textFragmentDataAfterAtomicContent
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAfterAtomicContent
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
.
IsSet
(
)
&
&
followingInvisibleWhiteSpaces
.
EndRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
;
}
if
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
if
(
followingInvisibleWhiteSpaces
.
EndRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
;
}
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangeForDeletingBlockElementBoundaries
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aLeftBlockElement
const
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aPointContainingTheOtherBlock
)
{
MOZ_ASSERT
(
&
aLeftBlockElement
!
=
&
aRightBlockElement
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
IsSet
(
)
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
|
|
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
aRightBlockElement
.
IsInclusiveDescendantOf
(
aPointContainingTheOtherBlock
.
GetChild
(
)
)
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
aLeftBlockElement
.
IsInclusiveDescendantOf
(
aPointContainingTheOtherBlock
.
GetChild
(
)
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
!
aRightBlockElement
.
IsInclusiveDescendantOf
(
&
aLeftBlockElement
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
!
aLeftBlockElement
.
IsInclusiveDescendantOf
(
&
aRightBlockElement
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
EditorRawDOMPoint
(
const_cast
<
Element
*
>
(
&
aLeftBlockElement
)
)
.
IsBefore
(
EditorRawDOMPoint
(
const_cast
<
Element
*
>
(
&
aRightBlockElement
)
)
)
)
;
const
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
EditorDOMRange
range
;
TextFragmentData
textFragmentDataAtEndOfLeftBlockElement
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
?
aPointContainingTheOtherBlock
:
EditorDOMPoint
:
:
AtEndOf
(
const_cast
<
Element
&
>
(
aLeftBlockElement
)
)
editingHost
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEndOfLeftBlockElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
if
(
textFragmentDataAtEndOfLeftBlockElement
.
StartsFromInvisibleBRElement
(
)
)
{
range
.
SetStart
(
EditorDOMPoint
(
textFragmentDataAtEndOfLeftBlockElement
.
StartReasonBRElementPtr
(
)
)
)
;
}
else
{
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
textFragmentDataAtEndOfLeftBlockElement
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
range
.
SetStart
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
else
{
range
.
SetStart
(
textFragmentDataAtEndOfLeftBlockElement
.
ScanStartRef
(
)
)
;
}
}
TextFragmentData
textFragmentDataAtStartOfRightBlockElement
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
&
&
!
aPointContainingTheOtherBlock
.
IsEndOfContainer
(
)
?
aPointContainingTheOtherBlock
.
NextPoint
(
)
:
EditorDOMPoint
(
const_cast
<
Element
*
>
(
&
aRightBlockElement
)
0u
)
editingHost
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStartOfRightBlockElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
textFragmentDataAtStartOfRightBlockElement
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
range
.
SetEnd
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
else
{
range
.
SetEnd
(
textFragmentDataAtStartOfRightBlockElement
.
ScanStartRef
(
)
)
;
}
return
range
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangeContainingInvisibleWhiteSpacesAtRangeBoundaries
(
Element
*
aEditingHost
const
EditorDOMRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
MOZ_ASSERT
(
aRange
.
EndRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRange
.
StartRef
(
)
.
IsSetAndValid
(
)
)
;
EditorDOMRange
result
;
TextFragmentData
textFragmentDataAtStart
(
aRange
.
StartRef
(
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtStart
=
textFragmentDataAtStart
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtStart
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtStart
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtStart
.
Collapsed
(
)
)
{
result
.
SetStart
(
invisibleLeadingWhiteSpacesAtStart
.
StartRef
(
)
)
;
}
else
{
const
EditorDOMRangeInTexts
invisibleTrailingWhiteSpacesAtStart
=
textFragmentDataAtStart
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtStart
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleTrailingWhiteSpacesAtStart
.
IsPositioned
(
)
&
&
!
invisibleTrailingWhiteSpacesAtStart
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpacesAtStart
.
StartRef
(
)
.
EqualsOrIsBefore
(
aRange
.
StartRef
(
)
)
)
;
result
.
SetStart
(
invisibleTrailingWhiteSpacesAtStart
.
StartRef
(
)
)
;
}
else
if
(
!
aRange
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
(
textFragmentDataAtStart
.
StartsFromBlockBoundary
(
)
|
|
textFragmentDataAtStart
.
StartsFromInlineEditingHostBoundary
(
)
)
&
&
textFragmentDataAtStart
.
EndRef
(
)
.
IsInTextNode
(
)
)
{
result
.
SetStart
(
textFragmentDataAtStart
.
EndRef
(
)
)
;
}
}
if
(
!
result
.
StartRef
(
)
.
IsSet
(
)
)
{
result
.
SetStart
(
aRange
.
StartRef
(
)
)
;
}
TextFragmentData
textFragmentDataAtEnd
(
aRange
.
EndRef
(
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtEnd
=
textFragmentDataAtEnd
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtEnd
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtEnd
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtEnd
.
Collapsed
(
)
)
{
result
.
SetEnd
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
;
}
else
{
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtEnd
=
textFragmentDataAtEnd
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtEnd
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtEnd
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtEnd
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
aRange
.
EndRef
(
)
.
EqualsOrIsBefore
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
)
;
result
.
SetEnd
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
;
}
else
if
(
!
aRange
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
(
textFragmentDataAtEnd
.
EndsByBlockBoundary
(
)
|
|
textFragmentDataAtEnd
.
EndsByInlineEditingHostBoundary
(
)
)
&
&
textFragmentDataAtEnd
.
StartRef
(
)
.
IsInTextNode
(
)
)
{
result
.
SetEnd
(
EditorDOMPoint
:
:
AtEndOf
(
*
textFragmentDataAtEnd
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
)
;
}
}
if
(
!
result
.
EndRef
(
)
.
IsSet
(
)
)
{
result
.
SetEnd
(
aRange
.
EndRef
(
)
)
;
}
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
Result
<
bool
nsresult
>
WSRunScanner
:
:
ShrinkRangeIfStartsFromOrEndsAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
const
Element
*
aEditingHost
)
{
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
!
aRange
.
IsInAnySelection
(
)
"
Changing
range
in
selection
may
cause
running
script
"
)
;
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aRange
.
GetStartContainer
(
)
-
>
IsContent
(
)
|
|
!
aRange
.
GetEndContainer
(
)
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRange
.
GetStartContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRange
.
GetEndContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
false
;
}
nsIContent
*
startContent
=
nullptr
;
if
(
aRange
.
GetStartContainer
(
)
&
&
aRange
.
GetStartContainer
(
)
-
>
IsText
(
)
&
&
aRange
.
GetStartContainer
(
)
-
>
AsText
(
)
-
>
Length
(
)
=
=
aRange
.
StartOffset
(
)
)
{
TextFragmentData
textFragmentDataAtStart
(
EditorRawDOMPoint
(
aRange
.
StartRef
(
)
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
textFragmentDataAtStart
.
EndsByVisibleBRElement
(
)
)
{
startContent
=
textFragmentDataAtStart
.
EndReasonBRElementPtr
(
)
;
}
else
if
(
textFragmentDataAtStart
.
EndsBySpecialContent
(
)
|
|
(
textFragmentDataAtStart
.
EndsByOtherBlockElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
*
textFragmentDataAtStart
.
EndReasonOtherBlockElementPtr
(
)
)
)
)
{
startContent
=
textFragmentDataAtStart
.
GetEndReasonContent
(
)
;
}
}
nsIContent
*
endContent
=
nullptr
;
if
(
aRange
.
GetEndContainer
(
)
&
&
aRange
.
GetEndContainer
(
)
-
>
IsText
(
)
&
&
!
aRange
.
EndOffset
(
)
)
{
TextFragmentData
textFragmentDataAtEnd
(
EditorRawDOMPoint
(
aRange
.
EndRef
(
)
)
aEditingHost
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
textFragmentDataAtEnd
.
StartsFromVisibleBRElement
(
)
)
{
endContent
=
textFragmentDataAtEnd
.
StartReasonBRElementPtr
(
)
;
}
else
if
(
textFragmentDataAtEnd
.
StartsFromSpecialContent
(
)
|
|
(
textFragmentDataAtEnd
.
StartsFromOtherBlockElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
*
textFragmentDataAtEnd
.
StartReasonOtherBlockElementPtr
(
)
)
)
)
{
endContent
=
textFragmentDataAtEnd
.
GetStartReasonContent
(
)
;
}
}
if
(
!
startContent
&
&
!
endContent
)
{
return
false
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startContent
?
RangeBoundary
(
startContent
-
>
GetParentNode
(
)
startContent
-
>
GetPreviousSibling
(
)
)
:
aRange
.
StartRef
(
)
endContent
?
RangeBoundary
(
endContent
-
>
GetParentNode
(
)
endContent
)
:
aRange
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
true
;
}
}
