#
include
"
EditorEventListener
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
TextEditor
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
class
nsPresContext
;
namespace
mozilla
{
using
namespace
dom
;
MOZ_CAN_RUN_SCRIPT
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
Document
*
doc
=
static_cast
<
Document
*
>
(
aData
)
;
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
!
root
)
{
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
root
-
>
GetControllerForCommand
(
commandStr
false
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
if
(
NS_WARN_IF
(
NS_FAILED
(
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
)
)
)
{
return
;
}
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
EditorEventListener
:
:
EditorEventListener
(
)
:
mEditorBase
(
nullptr
)
mCommitText
(
false
)
mInTransaction
(
false
)
mMouseDownOrUpConsumedByIME
(
false
)
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
mHaveBidiKeyboards
(
false
)
mShouldSwitchTextDirection
(
false
)
mSwitchToRTL
(
false
)
#
endif
{
}
EditorEventListener
:
:
~
EditorEventListener
(
)
{
if
(
mEditorBase
)
{
NS_WARNING
(
"
We
'
ve
not
been
uninstalled
yet
"
)
;
Disconnect
(
)
;
}
}
nsresult
EditorEventListener
:
:
Connect
(
EditorBase
*
aEditorBase
)
{
if
(
NS_WARN_IF
(
!
aEditorBase
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
)
{
bool
haveBidiKeyboards
=
false
;
bidiKeyboard
-
>
GetHaveBidiKeyboards
(
&
haveBidiKeyboards
)
;
mHaveBidiKeyboards
=
haveBidiKeyboards
;
}
#
endif
mEditorBase
=
aEditorBase
;
nsresult
rv
=
InstallToEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorEventListener
:
:
InstallToEditor
(
)
failed
"
)
;
Disconnect
(
)
;
}
return
rv
;
}
nsresult
EditorEventListener
:
:
InstallToEditor
(
)
{
MOZ_ASSERT
(
mEditorBase
"
The
caller
must
set
mEditorBase
"
)
;
EventTarget
*
eventTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
eventTarget
)
)
{
return
NS_ERROR_FAILURE
;
}
EventListenerManager
*
eventListenerManager
=
eventTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
NS_WARN_IF
(
!
eventListenerManager
)
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
dragover
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
dragleave
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
drop
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
mousedown
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
mouseup
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
click
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
auxclick
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
blur
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
focus
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
text
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
compositionstart
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
AddEventListenerByType
(
this
u
"
compositionend
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
Disconnect
(
)
{
if
(
DetachedFromEditor
(
)
)
{
return
;
}
UninstallFromEditor
(
)
;
const
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
mEditorBase
=
nullptr
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsIContent
*
focusedContent
=
fm
-
>
GetFocusedElement
(
)
;
mozilla
:
:
dom
:
:
Element
*
root
=
editorBase
-
>
GetRoot
(
)
;
if
(
focusedContent
&
&
root
&
&
focusedContent
-
>
IsInclusiveDescendantOf
(
root
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
editorBase
-
>
FinalizeSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
FinalizeSelection
(
)
failed
but
ignored
"
)
;
}
}
}
void
EditorEventListener
:
:
UninstallFromEditor
(
)
{
CleanupDragDropCaret
(
)
;
EventTarget
*
eventTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
eventTarget
)
)
{
return
;
}
EventListenerManager
*
eventListenerManager
=
eventTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
NS_WARN_IF
(
!
eventListenerManager
)
)
{
return
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
dragover
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
dragleave
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
drop
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
mousedown
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
mouseup
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
click
"
_ns
TrustedEventsAtCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
auxclick
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
blur
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
focus
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
text
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
compositionstart
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
eventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
compositionend
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
PresShell
*
EditorEventListener
:
:
GetPresShell
(
)
const
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
return
mEditorBase
-
>
GetPresShell
(
)
;
}
nsPresContext
*
EditorEventListener
:
:
GetPresContext
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
bool
EditorEventListener
:
:
EditorHasFocus
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
const
Element
*
focusedElement
=
mEditorBase
-
>
GetFocusedElement
(
)
;
return
focusedElement
&
&
focusedElement
-
>
IsInComposedDoc
(
)
;
}
NS_IMPL_ISUPPORTS
(
EditorEventListener
nsIDOMEventListener
)
bool
EditorEventListener
:
:
DetachedFromEditor
(
)
const
{
return
!
mEditorBase
;
}
bool
EditorEventListener
:
:
DetachedFromEditorOrDefaultPrevented
(
WidgetEvent
*
aWidgetEvent
)
const
{
return
NS_WARN_IF
(
!
aWidgetEvent
)
|
|
DetachedFromEditor
(
)
|
|
aWidgetEvent
-
>
DefaultPrevented
(
)
;
}
bool
EditorEventListener
:
:
EnsureCommitComposition
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
editorBase
-
>
CommitComposition
(
)
;
return
!
DetachedFromEditor
(
)
;
}
NS_IMETHODIMP
EditorEventListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
switch
(
internalEvent
-
>
mMessage
)
{
case
eDragOver
:
case
eDrop
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
nsresult
rv
=
DragOverOrDrop
(
dragEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
DragOverOrDrop
(
)
failed
"
)
;
return
rv
;
}
case
eDragLeave
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
nsresult
rv
=
DragLeave
(
dragEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
DragLeave
(
)
failed
"
)
;
return
rv
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
case
eKeyDown
:
{
nsresult
rv
=
KeyDown
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
KeyDown
(
)
failed
"
)
;
return
rv
;
}
case
eKeyUp
:
{
nsresult
rv
=
KeyUp
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
KeyUp
(
)
failed
"
)
;
return
rv
;
}
#
endif
case
eKeyPress
:
{
nsresult
rv
=
KeyPress
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
KeyPress
(
)
failed
"
)
;
return
rv
;
}
case
eMouseDown
:
{
mMouseDownOrUpConsumedByIME
=
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
;
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
RefPtr
<
MouseEvent
>
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
NS_WARN_IF
(
!
mouseEvent
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MouseDown
(
mouseEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
MouseDown
(
)
failed
"
)
;
return
rv
;
}
case
eMouseUp
:
{
if
(
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
)
{
mMouseDownOrUpConsumedByIME
=
true
;
}
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
RefPtr
<
MouseEvent
>
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
NS_WARN_IF
(
!
mouseEvent
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MouseUp
(
mouseEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
MouseUp
(
)
failed
"
)
;
return
rv
;
}
case
eMouseClick
:
{
WidgetMouseEvent
*
widgetMouseEvent
=
internalEvent
-
>
AsMouseEvent
(
)
;
if
(
widgetMouseEvent
-
>
mButton
!
=
MouseButton
:
:
ePrimary
)
{
return
NS_OK
;
}
[
[
fallthrough
]
]
;
}
case
eMouseAuxClick
:
{
WidgetMouseEvent
*
widgetMouseEvent
=
internalEvent
-
>
AsMouseEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetMouseEvent
)
)
{
return
NS_OK
;
}
if
(
mMouseDownOrUpConsumedByIME
)
{
mMouseDownOrUpConsumedByIME
=
false
;
widgetMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
nsresult
rv
=
MouseClick
(
widgetMouseEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
MouseClick
(
)
failed
"
)
;
return
rv
;
}
case
eFocus
:
{
const
InternalFocusEvent
*
focusEvent
=
internalEvent
-
>
AsFocusEvent
(
)
;
if
(
NS_WARN_IF
(
!
focusEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Focus
(
*
focusEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
Focus
(
)
failed
"
)
;
return
rv
;
}
case
eBlur
:
{
const
InternalFocusEvent
*
blurEvent
=
internalEvent
-
>
AsFocusEvent
(
)
;
if
(
NS_WARN_IF
(
!
blurEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Blur
(
*
blurEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
Blur
(
)
failed
"
)
;
return
rv
;
}
case
eCompositionChange
:
{
nsresult
rv
=
HandleChangeComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
HandleChangeComposition
(
)
failed
"
)
;
return
rv
;
}
case
eCompositionStart
:
{
nsresult
rv
=
HandleStartComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorEventListener
:
:
HandleStartComposition
(
)
failed
"
)
;
return
rv
;
}
case
eCompositionEnd
:
{
HandleEndComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
return
NS_OK
;
}
default
:
break
;
}
#
ifdef
DEBUG
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
nsPrintfCString
assertMessage
(
"
Editor
doesn
'
t
handle
\
"
%
s
\
"
event
"
"
because
its
internal
event
doesn
'
t
have
proper
message
"
NS_ConvertUTF16toUTF8
(
eventType
)
.
get
(
)
)
;
NS_ASSERTION
(
false
assertMessage
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
bool
IsCtrlShiftPressed
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
bool
&
isRTL
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
!
aKeyboardEvent
-
>
IsControl
(
)
)
{
return
false
;
}
switch
(
aKeyboardEvent
-
>
mLocation
)
{
case
eKeyLocationRight
:
isRTL
=
true
;
break
;
case
eKeyLocationLeft
:
isRTL
=
false
;
break
;
default
:
return
false
;
}
if
(
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
false
;
}
return
true
;
}
nsresult
EditorEventListener
:
:
KeyUp
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
|
|
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_CONTROL
)
&
&
mShouldSwitchTextDirection
&
&
editorBase
-
>
IsInPlaintextMode
(
)
)
{
editorBase
-
>
SwitchTextDirectionTo
(
mSwitchToRTL
?
EditorBase
:
:
TextDirection
:
:
eRTL
:
EditorBase
:
:
TextDirection
:
:
eLTR
)
;
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
KeyDown
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
)
{
bool
switchToRTL
;
if
(
IsCtrlShiftPressed
(
aKeyboardEvent
switchToRTL
)
)
{
mShouldSwitchTextDirection
=
true
;
mSwitchToRTL
=
switchToRTL
;
}
}
else
if
(
aKeyboardEvent
-
>
mKeyCode
!
=
NS_VK_CONTROL
)
{
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
#
endif
nsresult
EditorEventListener
:
:
KeyPress
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aKeyboardEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
RefPtr
<
Document
>
document
=
editorBase
-
>
GetDocument
(
)
;
if
(
!
document
)
{
return
NS_OK
;
}
document
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
editorBase
-
>
Destroyed
(
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
editorBase
-
>
HandleKeyPressEvent
(
aKeyboardEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
if
(
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
if
(
!
ShouldHandleNativeKeyBindings
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
nsIWidget
*
widget
=
aKeyboardEvent
-
>
mWidget
;
if
(
!
widget
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
NS_OK
;
}
widget
=
presContext
-
>
GetNearestWidget
(
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
NS_OK
;
}
}
RefPtr
<
Document
>
doc
=
editorBase
-
>
GetDocument
(
)
;
AutoRestore
<
nsCOMPtr
<
nsIWidget
>
>
saveWidget
(
aKeyboardEvent
-
>
mWidget
)
;
aKeyboardEvent
-
>
mWidget
=
widget
;
if
(
aKeyboardEvent
-
>
ExecuteEditCommands
(
NativeKeyBindingsType
:
:
RichTextEditor
DoCommandCallback
doc
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
MouseClick
(
WidgetMouseEvent
*
aMouseClickEvent
)
{
if
(
NS_WARN_IF
(
!
aMouseClickEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
if
(
editorBase
-
>
IsReadonly
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aMouseClickEvent
)
)
{
return
NS_OK
;
}
if
(
EditorHasFocus
(
)
)
{
if
(
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
)
{
RefPtr
<
Element
>
focusedElement
=
mEditorBase
-
>
GetFocusedElement
(
)
;
IMEStateManager
:
:
OnClickInEditor
(
*
presContext
focusedElement
*
aMouseClickEvent
)
;
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
}
}
if
(
DetachedFromEditorOrDefaultPrevented
(
aMouseClickEvent
)
)
{
return
NS_OK
;
}
if
(
!
EnsureCommitComposition
(
)
)
{
return
NS_OK
;
}
if
(
aMouseClickEvent
-
>
mButton
!
=
MouseButton
:
:
eMiddle
|
|
!
WidgetMouseEvent
:
:
IsMiddleClickPasteEnabled
(
)
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_OK
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
aMouseClickEvent
-
>
DefaultPrevented
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
RefPtr
<
EventStateManager
>
esm
=
presContext
-
>
EventStateManager
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
esm
-
>
HandleMiddleClickPaste
(
presShell
aMouseClickEvent
&
status
editorBase
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EventStateManager
:
:
HandleMiddleClickPaste
(
)
failed
but
ignored
"
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
aMouseClickEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
bool
EditorEventListener
:
:
NotifyIMEOfMouseButtonEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
if
(
!
EditorHasFocus
(
)
)
{
return
false
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
false
;
}
RefPtr
<
Element
>
focusedElement
=
mEditorBase
-
>
GetFocusedElement
(
)
;
return
IMEStateManager
:
:
OnMouseButtonEventInEditor
(
*
presContext
focusedElement
*
aMouseEvent
)
;
}
nsresult
EditorEventListener
:
:
MouseDown
(
MouseEvent
*
aMouseEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
Unused
<
<
EnsureCommitComposition
(
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
RefuseToDropAndHideCaret
(
DragEvent
*
aDragEvent
)
{
MOZ_ASSERT
(
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mInSystemGroup
)
;
aDragEvent
-
>
PreventDefault
(
)
;
aDragEvent
-
>
StopImmediatePropagation
(
)
;
DataTransfer
*
dataTransfer
=
aDragEvent
-
>
GetDataTransfer
(
)
;
if
(
dataTransfer
)
{
dataTransfer
-
>
SetDropEffectInt
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
}
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
false
)
;
}
}
nsresult
EditorEventListener
:
:
DragOverOrDrop
(
DragEvent
*
aDragEvent
)
{
MOZ_ASSERT
(
aDragEvent
)
;
MOZ_ASSERT
(
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mMessage
=
=
eDrop
|
|
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mMessage
=
=
eDragOver
)
;
if
(
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mMessage
=
=
eDrop
)
{
CleanupDragDropCaret
(
)
;
MOZ_ASSERT
(
!
mCaret
)
;
}
else
{
InitializeDragDropCaret
(
)
;
MOZ_ASSERT
(
mCaret
)
;
}
if
(
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
WidgetEventPtr
(
)
)
)
{
return
NS_OK
;
}
int32_t
dropOffset
=
-
1
;
nsCOMPtr
<
nsIContent
>
dropParentContent
=
aDragEvent
-
>
GetRangeParentContentAndOffset
(
&
dropOffset
)
;
if
(
NS_WARN_IF
(
!
dropParentContent
)
|
|
NS_WARN_IF
(
dropOffset
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
DetachedFromEditor
(
)
)
{
RefuseToDropAndHideCaret
(
aDragEvent
)
;
return
NS_OK
;
}
bool
notEditable
=
!
dropParentContent
-
>
IsEditable
(
)
|
|
mEditorBase
-
>
IsReadonly
(
)
;
if
(
mCaret
&
&
(
IsFileControlTextBox
(
)
|
|
notEditable
)
)
{
mCaret
-
>
SetVisible
(
false
)
;
}
if
(
IsFileControlTextBox
(
)
)
{
return
NS_OK
;
}
if
(
notEditable
)
{
if
(
mEditorBase
-
>
IsTextEditor
(
)
)
{
RefuseToDropAndHideCaret
(
aDragEvent
)
;
return
NS_OK
;
}
return
NS_OK
;
}
if
(
!
DragEventHasSupportingData
(
aDragEvent
)
)
{
RefuseToDropAndHideCaret
(
aDragEvent
)
;
return
NS_OK
;
}
if
(
!
CanInsertAtDropPosition
(
aDragEvent
)
)
{
RefuseToDropAndHideCaret
(
aDragEvent
)
;
return
NS_OK
;
}
aDragEvent
-
>
PreventDefault
(
)
;
aDragEvent
-
>
StopImmediatePropagation
(
)
;
if
(
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mMessage
=
=
eDrop
)
{
RefPtr
<
EditorBase
>
editorBase
=
mEditorBase
;
nsresult
rv
=
editorBase
-
>
HandleDropEvent
(
aDragEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
HandleDropEvent
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
mMessage
=
=
eDragOver
)
;
DataTransfer
*
dataTransfer
=
aDragEvent
-
>
GetDataTransfer
(
)
;
if
(
dataTransfer
&
&
dataTransfer
-
>
DropEffectInt
(
)
=
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
{
nsCOMPtr
<
nsINode
>
dragSource
=
dataTransfer
-
>
GetMozSourceNode
(
)
;
if
(
dragSource
&
&
!
dragSource
-
>
IsEditable
(
)
)
{
dataTransfer
-
>
SetDropEffectInt
(
nsContentUtils
:
:
FilterDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
dataTransfer
-
>
EffectAllowedInt
(
)
)
)
;
}
}
if
(
!
mCaret
)
{
return
NS_OK
;
}
mCaret
-
>
SetVisible
(
true
)
;
mCaret
-
>
SetCaretPosition
(
dropParentContent
dropOffset
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
InitializeDragDropCaret
(
)
{
if
(
mCaret
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
;
}
mCaret
=
new
nsCaret
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mCaret
-
>
Init
(
presShell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsCaret
:
:
Init
(
)
failed
but
ignored
"
)
;
mCaret
-
>
SetCaretReadOnly
(
true
)
;
mCaret
-
>
SetVisibilityDuringSelection
(
true
)
;
presShell
-
>
SetCaret
(
mCaret
)
;
}
void
EditorEventListener
:
:
CleanupDragDropCaret
(
)
{
if
(
!
mCaret
)
{
return
;
}
mCaret
-
>
SetVisible
(
false
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
RestoreCaret
(
)
;
}
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
nsresult
EditorEventListener
:
:
DragLeave
(
DragEvent
*
aDragEvent
)
{
NS_WARNING_ASSERTION
(
!
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
DefaultPrevented
(
)
"
eDragLeave
shouldn
'
t
be
cancelable
"
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
CleanupDragDropCaret
(
)
;
return
NS_OK
;
}
bool
EditorEventListener
:
:
DragEventHasSupportingData
(
DragEvent
*
aDragEvent
)
const
{
MOZ_ASSERT
(
!
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
WidgetEventPtr
(
)
)
)
;
MOZ_ASSERT
(
aDragEvent
-
>
GetDataTransfer
(
)
)
;
DataTransfer
*
dataTransfer
=
aDragEvent
-
>
GetDataTransfer
(
)
;
if
(
!
dataTransfer
)
{
NS_WARNING
(
"
No
data
transfer
returned
"
)
;
return
false
;
}
return
dataTransfer
-
>
HasType
(
NS_LITERAL_STRING_FROM_CSTRING
(
kTextMime
)
)
|
|
dataTransfer
-
>
HasType
(
NS_LITERAL_STRING_FROM_CSTRING
(
kMozTextInternal
)
)
|
|
(
!
mEditorBase
-
>
IsInPlaintextMode
(
)
&
&
(
dataTransfer
-
>
HasType
(
NS_LITERAL_STRING_FROM_CSTRING
(
kHTMLMime
)
)
|
|
dataTransfer
-
>
HasType
(
NS_LITERAL_STRING_FROM_CSTRING
(
kFileMime
)
)
)
)
;
}
bool
EditorEventListener
:
:
CanInsertAtDropPosition
(
DragEvent
*
aDragEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
WidgetEventPtr
(
)
)
)
;
MOZ_ASSERT
(
!
mEditorBase
-
>
IsReadonly
(
)
)
;
MOZ_ASSERT
(
DragEventHasSupportingData
(
aDragEvent
)
)
;
DataTransfer
*
dataTransfer
=
aDragEvent
-
>
GetDataTransfer
(
)
;
if
(
NS_WARN_IF
(
!
dataTransfer
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
sourceNode
=
dataTransfer
-
>
GetMozSourceNode
(
)
;
if
(
!
sourceNode
)
{
return
true
;
}
RefPtr
<
Document
>
targetDocument
=
mEditorBase
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
targetDocument
)
)
{
return
false
;
}
RefPtr
<
Document
>
sourceDocument
=
sourceNode
-
>
OwnerDoc
(
)
;
if
(
targetDocument
!
=
sourceDocument
)
{
return
true
;
}
if
(
BrowserParent
:
:
GetFrom
(
nsIContent
:
:
FromNode
(
sourceNode
)
)
)
{
return
true
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
false
;
}
if
(
selection
-
>
IsCollapsed
(
)
)
{
return
true
;
}
int32_t
dropOffset
=
-
1
;
nsCOMPtr
<
nsIContent
>
dropParentContent
=
aDragEvent
-
>
GetRangeParentContentAndOffset
(
&
dropOffset
)
;
if
(
!
dropParentContent
|
|
NS_WARN_IF
(
dropOffset
<
0
)
|
|
NS_WARN_IF
(
DetachedFromEditor
(
)
)
)
{
return
false
;
}
return
!
EditorUtils
:
:
IsPointInSelection
(
*
selection
*
dropParentContent
dropOffset
)
;
}
nsresult
EditorEventListener
:
:
HandleStartComposition
(
WidgetCompositionEvent
*
aCompositionStartEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionStartEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionStartEvent
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
aCompositionStartEvent
-
>
DefaultPrevented
(
)
"
eCompositionStart
shouldn
'
t
be
cancelable
"
)
;
nsresult
rv
=
editorBase
-
>
OnCompositionStart
(
*
aCompositionStartEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
OnCompositionStart
(
)
failed
"
)
;
return
rv
;
}
nsresult
EditorEventListener
:
:
HandleChangeComposition
(
WidgetCompositionEvent
*
aCompositionChangeEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionChangeEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
aCompositionChangeEvent
-
>
DefaultPrevented
(
)
"
eCompositionChange
event
shouldn
'
t
be
cancelable
"
)
;
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionChangeEvent
)
)
{
return
NS_OK
;
}
if
(
editorBase
-
>
IsReadonly
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
editorBase
-
>
OnCompositionChange
(
*
aCompositionChangeEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
OnCompositionChange
(
)
failed
"
)
;
return
rv
;
}
void
EditorEventListener
:
:
HandleEndComposition
(
WidgetCompositionEvent
*
aCompositionEndEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionEndEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionEndEvent
)
)
{
return
;
}
MOZ_ASSERT
(
!
aCompositionEndEvent
-
>
DefaultPrevented
(
)
"
eCompositionEnd
shouldn
'
t
be
cancelable
"
)
;
editorBase
-
>
OnCompositionEnd
(
*
aCompositionEndEvent
)
;
}
nsresult
EditorEventListener
:
:
Focus
(
const
InternalFocusEvent
&
aFocusEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
originalEventTargetNode
=
nsINode
:
:
FromEventTargetOrNull
(
aFocusEvent
.
GetOriginalDOMEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
!
originalEventTargetNode
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
originalEventTargetNode
-
>
IsDocument
(
)
)
{
if
(
!
originalEventTargetNode
-
>
IsInDesignMode
(
)
)
{
return
NS_OK
;
}
}
else
if
(
NS_WARN_IF
(
!
originalEventTargetNode
-
>
IsContent
(
)
)
)
{
return
NS_OK
;
}
const
OwningNonNull
<
EditorBase
>
editorBase
(
*
mEditorBase
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
editorBase
-
>
OnFocus
(
*
originalEventTargetNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnFocus
(
)
failed
"
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Blur
(
const
InternalFocusEvent
&
aBlurEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
mEditorBase
-
>
OnBlur
(
aBlurEvent
.
mTarget
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnBlur
(
)
failed
"
)
;
return
NS_OK
;
}
bool
EditorEventListener
:
:
IsFileControlTextBox
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
Element
*
rootElement
=
editorBase
-
>
GetRoot
(
)
;
if
(
!
rootElement
|
|
!
rootElement
-
>
ChromeOnlyAccess
(
)
)
{
return
false
;
}
nsIContent
*
parent
=
rootElement
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
parent
)
;
return
formControl
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputFile
;
}
bool
EditorEventListener
:
:
ShouldHandleNativeKeyBindings
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
aKeyboardEvent
-
>
GetDOMEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
!
targetContent
)
)
{
return
false
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
HTMLEditor
:
:
GetFrom
(
mEditorBase
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
if
(
htmlEditor
-
>
IsInDesignMode
(
)
)
{
return
true
;
}
nsIContent
*
editingHost
=
htmlEditor
-
>
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
return
targetContent
-
>
IsInclusiveDescendantOf
(
editingHost
)
;
}
}
