#
include
"
EditorEventListener
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsID
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMDragEvent
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMKeyEvent
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorIMESupport
.
h
"
#
include
"
nsIEditorMailSupport
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
class
nsPresContext
;
namespace
mozilla
{
using
namespace
dom
;
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
nsIDocument
*
doc
=
static_cast
<
nsIDocument
*
>
(
aData
)
;
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
!
root
)
{
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
root
-
>
GetControllerForCommand
(
commandStr
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
nsresult
rv
=
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
EditorEventListener
:
:
EditorEventListener
(
)
:
mEditorBase
(
nullptr
)
mCommitText
(
false
)
mInTransaction
(
false
)
mMouseDownOrUpConsumedByIME
(
false
)
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
mHaveBidiKeyboards
(
false
)
mShouldSwitchTextDirection
(
false
)
mSwitchToRTL
(
false
)
#
endif
{
}
EditorEventListener
:
:
~
EditorEventListener
(
)
{
if
(
mEditorBase
)
{
NS_WARNING
(
"
We
'
re
not
uninstalled
"
)
;
Disconnect
(
)
;
}
}
nsresult
EditorEventListener
:
:
Connect
(
EditorBase
*
aEditorBase
)
{
NS_ENSURE_ARG
(
aEditorBase
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
)
{
bool
haveBidiKeyboards
=
false
;
bidiKeyboard
-
>
GetHaveBidiKeyboards
(
&
haveBidiKeyboards
)
;
mHaveBidiKeyboards
=
haveBidiKeyboards
;
}
#
endif
mEditorBase
=
aEditorBase
;
nsresult
rv
=
InstallToEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Disconnect
(
)
;
}
return
rv
;
}
nsresult
EditorEventListener
:
:
InstallToEditor
(
)
{
NS_PRECONDITION
(
mEditorBase
"
The
caller
must
set
mEditorBase
"
)
;
nsCOMPtr
<
EventTarget
>
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
NS_ENSURE_TRUE
(
piTarget
NS_ERROR_FAILURE
)
;
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
NS_ENSURE_STATE
(
elmP
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
Disconnect
(
)
{
if
(
!
mEditorBase
)
{
return
;
}
UninstallFromEditor
(
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
nsIDOMElement
>
domFocus
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
domFocus
)
)
;
nsCOMPtr
<
nsINode
>
focusedElement
=
do_QueryInterface
(
domFocus
)
;
mozilla
:
:
dom
:
:
Element
*
root
=
mEditorBase
-
>
GetRoot
(
)
;
if
(
focusedElement
&
&
root
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedElement
root
)
)
{
mEditorBase
-
>
FinalizeSelection
(
)
;
}
}
mEditorBase
=
nullptr
;
}
void
EditorEventListener
:
:
UninstallFromEditor
(
)
{
nsCOMPtr
<
EventTarget
>
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
if
(
!
piTarget
)
{
return
;
}
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
elmP
)
{
return
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
already_AddRefed
<
nsIPresShell
>
EditorEventListener
:
:
GetPresShell
(
)
{
NS_PRECONDITION
(
mEditorBase
"
The
caller
must
check
whether
this
is
connected
to
an
editor
"
)
;
return
mEditorBase
-
>
GetPresShell
(
)
;
}
nsPresContext
*
EditorEventListener
:
:
GetPresContext
(
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
nsIContent
*
EditorEventListener
:
:
GetFocusedRootContent
(
)
{
NS_ENSURE_TRUE
(
mEditorBase
nullptr
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsIDocument
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
composedDoc
nullptr
)
;
if
(
composedDoc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
nullptr
;
}
return
focusedContent
;
}
bool
EditorEventListener
:
:
EditorHasFocus
(
)
{
NS_PRECONDITION
(
mEditorBase
"
The
caller
must
check
whether
this
is
connected
to
an
editor
"
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
false
;
}
nsIDocument
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
return
!
!
composedDoc
;
}
NS_IMPL_ISUPPORTS
(
EditorEventListener
nsIDOMEventListener
)
NS_IMETHODIMP
EditorEventListener
:
:
HandleEvent
(
nsIDOMEvent
*
aEvent
)
{
NS_ENSURE_TRUE
(
mEditorBase
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIEditor
>
kungFuDeathGrip
=
mEditorBase
;
Unused
<
<
kungFuDeathGrip
;
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
switch
(
internalEvent
-
>
mMessage
)
{
case
eDragEnter
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragEnter
(
dragEvent
)
;
}
case
eDragOver
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragOver
(
dragEvent
)
;
}
case
eDragExit
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragExit
(
dragEvent
)
;
}
case
eDrop
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
Drop
(
dragEvent
)
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
case
eKeyDown
:
{
nsCOMPtr
<
nsIDOMKeyEvent
>
keyEvent
=
do_QueryInterface
(
aEvent
)
;
return
KeyDown
(
keyEvent
)
;
}
case
eKeyUp
:
{
nsCOMPtr
<
nsIDOMKeyEvent
>
keyEvent
=
do_QueryInterface
(
aEvent
)
;
return
KeyUp
(
keyEvent
)
;
}
#
endif
case
eKeyPress
:
{
nsCOMPtr
<
nsIDOMKeyEvent
>
keyEvent
=
do_QueryInterface
(
aEvent
)
;
return
KeyPress
(
keyEvent
)
;
}
case
eMouseDown
:
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
mMouseDownOrUpConsumedByIME
=
NotifyIMEOfMouseButtonEvent
(
mouseEvent
)
;
return
mMouseDownOrUpConsumedByIME
?
NS_OK
:
MouseDown
(
mouseEvent
)
;
}
case
eMouseUp
:
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
if
(
NotifyIMEOfMouseButtonEvent
(
mouseEvent
)
)
{
mMouseDownOrUpConsumedByIME
=
true
;
}
return
mMouseDownOrUpConsumedByIME
?
NS_OK
:
MouseUp
(
mouseEvent
)
;
}
case
eMouseClick
:
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
if
(
mMouseDownOrUpConsumedByIME
)
{
mMouseDownOrUpConsumedByIME
=
false
;
mouseEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
return
MouseClick
(
mouseEvent
)
;
}
case
eFocus
:
return
Focus
(
aEvent
)
;
case
eBlur
:
return
Blur
(
aEvent
)
;
case
eCompositionChange
:
return
HandleText
(
aEvent
)
;
case
eCompositionStart
:
return
HandleStartComposition
(
aEvent
)
;
case
eCompositionEnd
:
HandleEndComposition
(
aEvent
)
;
return
NS_OK
;
default
:
break
;
}
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
focus
"
)
)
{
return
Focus
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
blur
"
)
)
{
return
Blur
(
aEvent
)
;
}
#
ifdef
DEBUG
nsPrintfCString
assertMessage
(
"
Editor
doesn
'
t
handle
\
"
%
s
\
"
event
"
"
because
its
internal
event
doesn
'
t
have
proper
message
"
NS_ConvertUTF16toUTF8
(
eventType
)
.
get
(
)
)
;
NS_ASSERTION
(
false
assertMessage
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
namespace
{
bool
IsCtrlShiftPressed
(
nsIDOMKeyEvent
*
aEvent
bool
&
isRTL
)
{
WidgetKeyboardEvent
*
keyboardEvent
=
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyboardEvent
"
DOM
key
event
'
s
internal
event
must
be
WidgetKeyboardEvent
"
)
;
if
(
!
keyboardEvent
-
>
IsControl
(
)
)
{
return
false
;
}
uint32_t
location
=
keyboardEvent
-
>
mLocation
;
if
(
location
=
=
nsIDOMKeyEvent
:
:
DOM_KEY_LOCATION_RIGHT
)
{
isRTL
=
true
;
}
else
if
(
location
=
=
nsIDOMKeyEvent
:
:
DOM_KEY_LOCATION_LEFT
)
{
isRTL
=
false
;
}
else
{
return
false
;
}
if
(
keyboardEvent
-
>
IsAlt
(
)
|
|
keyboardEvent
-
>
IsOS
(
)
)
{
return
false
;
}
return
true
;
}
}
nsresult
EditorEventListener
:
:
KeyUp
(
nsIDOMKeyEvent
*
aKeyEvent
)
{
NS_ENSURE_TRUE
(
aKeyEvent
NS_OK
)
;
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
uint32_t
keyCode
=
0
;
aKeyEvent
-
>
GetKeyCode
(
&
keyCode
)
;
if
(
(
keyCode
=
=
nsIDOMKeyEvent
:
:
DOM_VK_SHIFT
|
|
keyCode
=
=
nsIDOMKeyEvent
:
:
DOM_VK_CONTROL
)
&
&
mShouldSwitchTextDirection
&
&
mEditorBase
-
>
IsPlaintextEditor
(
)
)
{
mEditorBase
-
>
SwitchTextDirectionTo
(
mSwitchToRTL
?
nsIPlaintextEditor
:
:
eEditorRightToLeft
:
nsIPlaintextEditor
:
:
eEditorLeftToRight
)
;
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
KeyDown
(
nsIDOMKeyEvent
*
aKeyEvent
)
{
NS_ENSURE_TRUE
(
aKeyEvent
NS_OK
)
;
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
uint32_t
keyCode
=
0
;
aKeyEvent
-
>
GetKeyCode
(
&
keyCode
)
;
if
(
keyCode
=
=
nsIDOMKeyEvent
:
:
DOM_VK_SHIFT
)
{
bool
switchToRTL
;
if
(
IsCtrlShiftPressed
(
aKeyEvent
switchToRTL
)
)
{
mShouldSwitchTextDirection
=
true
;
mSwitchToRTL
=
switchToRTL
;
}
}
else
if
(
keyCode
!
=
nsIDOMKeyEvent
:
:
DOM_VK_CONTROL
)
{
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
#
endif
nsresult
EditorEventListener
:
:
KeyPress
(
nsIDOMKeyEvent
*
aKeyEvent
)
{
NS_ENSURE_TRUE
(
aKeyEvent
NS_OK
)
;
if
(
!
mEditorBase
-
>
IsAcceptableInputEvent
(
aKeyEvent
-
>
AsEvent
(
)
)
)
{
return
NS_OK
;
}
bool
defaultPrevented
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
if
(
defaultPrevented
)
{
return
NS_OK
;
}
nsresult
rv
=
mEditorBase
-
>
HandleKeyPressEvent
(
aKeyEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
if
(
defaultPrevented
)
{
return
NS_OK
;
}
if
(
!
ShouldHandleNativeKeyBindings
(
aKeyEvent
)
)
{
return
NS_OK
;
}
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyEvent
"
DOM
key
event
'
s
internal
event
must
be
WidgetKeyboardEvent
"
)
;
nsIWidget
*
widget
=
keyEvent
-
>
mWidget
;
if
(
!
widget
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
nsPresContext
*
pc
=
ps
?
ps
-
>
GetPresContext
(
)
:
nullptr
;
widget
=
pc
?
pc
-
>
GetNearestWidget
(
)
:
nullptr
;
NS_ENSURE_TRUE
(
widget
NS_OK
)
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mEditorBase
-
>
GetDocument
(
)
;
bool
handled
=
widget
-
>
ExecuteNativeKeyBinding
(
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
*
keyEvent
DoCommandCallback
doc
)
;
if
(
handled
)
{
aKeyEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
MouseClick
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
if
(
mEditorBase
-
>
IsReadonly
(
)
|
|
mEditorBase
-
>
IsDisabled
(
)
|
|
!
mEditorBase
-
>
IsAcceptableInputEvent
(
aMouseEvent
-
>
AsEvent
(
)
)
)
{
return
NS_OK
;
}
if
(
EditorHasFocus
(
)
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
IMEStateManager
:
:
OnClickInEditor
(
presContext
GetFocusedRootContent
(
)
aMouseEvent
)
;
}
}
bool
preventDefault
;
nsresult
rv
=
aMouseEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
preventDefault
)
;
if
(
NS_FAILED
(
rv
)
|
|
preventDefault
)
{
return
rv
;
}
mEditorBase
-
>
ForceCompositionEnd
(
)
;
int16_t
button
=
-
1
;
aMouseEvent
-
>
GetButton
(
&
button
)
;
if
(
button
=
=
1
)
{
return
HandleMiddleClickPaste
(
aMouseEvent
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
HandleMiddleClickPaste
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
if
(
!
Preferences
:
:
GetBool
(
"
middlemouse
.
paste
"
false
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
if
(
NS_FAILED
(
aMouseEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
offset
=
0
;
if
(
NS_FAILED
(
aMouseEvent
-
>
GetRangeOffset
(
&
offset
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
selection
)
{
selection
-
>
Collapse
(
parent
offset
)
;
}
bool
ctrlKey
=
false
;
aMouseEvent
-
>
GetCtrlKey
(
&
ctrlKey
)
;
nsCOMPtr
<
nsIEditorMailSupport
>
mailEditor
;
if
(
ctrlKey
)
{
mailEditor
=
do_QueryObject
(
mEditorBase
)
;
}
nsresult
rv
;
int32_t
clipboard
=
nsIClipboard
:
:
kGlobalClipboard
;
nsCOMPtr
<
nsIClipboard
>
clipboardService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
selectionSupported
;
rv
=
clipboardService
-
>
SupportsSelectionClipboard
(
&
selectionSupported
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
selectionSupported
)
{
clipboard
=
nsIClipboard
:
:
kSelectionClipboard
;
}
}
if
(
mailEditor
)
{
mailEditor
-
>
PasteAsQuotation
(
clipboard
)
;
}
else
{
mEditorBase
-
>
Paste
(
clipboard
)
;
}
aMouseEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
aMouseEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
bool
EditorEventListener
:
:
NotifyIMEOfMouseButtonEvent
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
if
(
!
EditorHasFocus
(
)
)
{
return
false
;
}
bool
defaultPrevented
;
nsresult
rv
=
aMouseEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
defaultPrevented
)
{
return
false
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
false
)
;
return
IMEStateManager
:
:
OnMouseButtonEventInEditor
(
presContext
GetFocusedRootContent
(
)
aMouseEvent
)
;
}
nsresult
EditorEventListener
:
:
MouseDown
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
mEditorBase
-
>
ForceCompositionEnd
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
HandleText
(
nsIDOMEvent
*
aTextEvent
)
{
if
(
!
mEditorBase
-
>
IsAcceptableInputEvent
(
aTextEvent
)
)
{
return
NS_OK
;
}
if
(
mEditorBase
-
>
IsReadonly
(
)
|
|
mEditorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
return
mEditorBase
-
>
UpdateIMEComposition
(
aTextEvent
)
;
}
nsresult
EditorEventListener
:
:
DragEnter
(
nsIDOMDragEvent
*
aDragEvent
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_OK
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_OK
)
;
if
(
!
mCaret
)
{
mCaret
=
new
nsCaret
(
)
;
mCaret
-
>
Init
(
presShell
)
;
mCaret
-
>
SetCaretReadOnly
(
true
)
;
mCaret
-
>
SetVisibilityDuringSelection
(
true
)
;
}
presShell
-
>
SetCaret
(
mCaret
)
;
return
DragOver
(
aDragEvent
)
;
}
nsresult
EditorEventListener
:
:
DragOver
(
nsIDOMDragEvent
*
aDragEvent
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_OK
)
;
nsCOMPtr
<
nsIDOMNode
>
parent
;
bool
defaultPrevented
;
aDragEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
if
(
defaultPrevented
)
{
return
NS_OK
;
}
aDragEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsIContent
>
dropParent
=
do_QueryInterface
(
parent
)
;
NS_ENSURE_TRUE
(
dropParent
NS_ERROR_FAILURE
)
;
if
(
dropParent
-
>
IsEditable
(
)
&
&
CanDrop
(
aDragEvent
)
)
{
aDragEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
if
(
!
mCaret
)
{
return
NS_OK
;
}
int32_t
offset
=
0
;
nsresult
rv
=
aDragEvent
-
>
GetRangeOffset
(
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCaret
-
>
SetVisible
(
true
)
;
mCaret
-
>
SetCaretPosition
(
parent
offset
)
;
return
NS_OK
;
}
if
(
!
IsFileControlTextBox
(
)
)
{
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
}
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
false
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
CleanupDragDropCaret
(
)
{
if
(
!
mCaret
)
{
return
;
}
mCaret
-
>
SetVisible
(
false
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
RestoreCaret
(
)
;
}
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
nsresult
EditorEventListener
:
:
DragExit
(
nsIDOMDragEvent
*
aDragEvent
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_OK
)
;
CleanupDragDropCaret
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Drop
(
nsIDOMDragEvent
*
aDragEvent
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_OK
)
;
CleanupDragDropCaret
(
)
;
bool
defaultPrevented
;
aDragEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
if
(
defaultPrevented
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
aDragEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsIContent
>
dropParent
=
do_QueryInterface
(
parent
)
;
NS_ENSURE_TRUE
(
dropParent
NS_ERROR_FAILURE
)
;
if
(
!
dropParent
-
>
IsEditable
(
)
|
|
!
CanDrop
(
aDragEvent
)
)
{
if
(
(
mEditorBase
-
>
IsReadonly
(
)
|
|
mEditorBase
-
>
IsDisabled
(
)
)
&
&
!
IsFileControlTextBox
(
)
)
{
return
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
}
return
NS_OK
;
}
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
aDragEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
return
mEditorBase
-
>
InsertFromDrop
(
aDragEvent
-
>
AsEvent
(
)
)
;
}
bool
EditorEventListener
:
:
CanDrop
(
nsIDOMDragEvent
*
aEvent
)
{
if
(
mEditorBase
-
>
IsReadonly
(
)
|
|
mEditorBase
-
>
IsDisabled
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMDataTransfer
>
domDataTransfer
;
aEvent
-
>
GetDataTransfer
(
getter_AddRefs
(
domDataTransfer
)
)
;
nsCOMPtr
<
DataTransfer
>
dataTransfer
=
do_QueryInterface
(
domDataTransfer
)
;
NS_ENSURE_TRUE
(
dataTransfer
false
)
;
nsTArray
<
nsString
>
types
;
dataTransfer
-
>
GetTypes
(
types
)
;
if
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kTextMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kMozTextInternal
)
)
&
&
(
mEditorBase
-
>
IsPlaintextEditor
(
)
|
|
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kHTMLMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kFileMime
)
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMNode
>
sourceNode
;
dataTransfer
-
>
GetMozSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMDocument
>
domdoc
=
mEditorBase
-
>
GetDOMDocument
(
)
;
NS_ENSURE_TRUE
(
domdoc
false
)
;
nsCOMPtr
<
nsIDOMDocument
>
sourceDoc
;
nsresult
rv
=
sourceNode
-
>
GetOwnerDocument
(
getter_AddRefs
(
sourceDoc
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
domdoc
!
=
sourceDoc
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
sourceContent
=
do_QueryInterface
(
sourceNode
)
;
TabParent
*
tp
=
TabParent
:
:
GetFrom
(
sourceContent
)
;
if
(
tp
)
{
return
true
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
false
;
}
if
(
selection
-
>
Collapsed
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
rv
=
aEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
parent
)
{
return
false
;
}
int32_t
offset
=
0
;
rv
=
aEvent
-
>
GetRangeOffset
(
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
!
range
)
{
continue
;
}
bool
inRange
=
true
;
range
-
>
IsPointInRange
(
parent
offset
&
inRange
)
;
if
(
inRange
)
{
return
false
;
}
}
return
true
;
}
nsresult
EditorEventListener
:
:
HandleStartComposition
(
nsIDOMEvent
*
aCompositionEvent
)
{
if
(
!
mEditorBase
-
>
IsAcceptableInputEvent
(
aCompositionEvent
)
)
{
return
NS_OK
;
}
WidgetCompositionEvent
*
compositionStart
=
aCompositionEvent
-
>
WidgetEventPtr
(
)
-
>
AsCompositionEvent
(
)
;
return
mEditorBase
-
>
BeginIMEComposition
(
compositionStart
)
;
}
void
EditorEventListener
:
:
HandleEndComposition
(
nsIDOMEvent
*
aCompositionEvent
)
{
if
(
!
mEditorBase
-
>
IsAcceptableInputEvent
(
aCompositionEvent
)
)
{
return
;
}
mEditorBase
-
>
EndIMEComposition
(
)
;
}
nsresult
EditorEventListener
:
:
Focus
(
nsIDOMEvent
*
aEvent
)
{
NS_ENSURE_TRUE
(
aEvent
NS_OK
)
;
if
(
mEditorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
SpellCheckIfNeeded
(
)
;
if
(
!
mEditorBase
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
;
aEvent
-
>
GetTarget
(
getter_AddRefs
(
target
)
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_UNEXPECTED
)
;
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
&
&
!
node
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
NS_OK
;
}
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
nsCOMPtr
<
nsIContent
>
editableRoot
=
mEditorBase
-
>
FindSelectionRoot
(
node
)
;
if
(
editableRoot
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
nsCOMPtr
<
nsIDOMElement
>
element
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
element
)
)
;
if
(
!
SameCOMIdentity
(
element
target
)
)
{
return
NS_OK
;
}
}
}
mEditorBase
-
>
OnFocus
(
target
)
;
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_OK
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
OnFocusInEditor
(
ps
-
>
GetPresContext
(
)
focusedContent
mEditorBase
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Blur
(
nsIDOMEvent
*
aEvent
)
{
NS_ENSURE_TRUE
(
aEvent
NS_OK
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
nsCOMPtr
<
nsIDOMElement
>
element
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
element
)
)
;
if
(
!
element
)
{
mEditorBase
-
>
FinalizeSelection
(
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
SpellCheckIfNeeded
(
)
{
uint32_t
currentFlags
=
0
;
mEditorBase
-
>
GetFlags
(
&
currentFlags
)
;
if
(
currentFlags
&
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
)
{
currentFlags
^
=
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
;
mEditorBase
-
>
SetFlags
(
currentFlags
)
;
}
}
bool
EditorEventListener
:
:
IsFileControlTextBox
(
)
{
Element
*
root
=
mEditorBase
-
>
GetRoot
(
)
;
if
(
!
root
|
|
!
root
-
>
ChromeOnlyAccess
(
)
)
{
return
false
;
}
nsIContent
*
parent
=
root
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
parent
)
;
return
formControl
-
>
GetType
(
)
=
=
NS_FORM_INPUT_FILE
;
}
bool
EditorEventListener
:
:
ShouldHandleNativeKeyBindings
(
nsIDOMKeyEvent
*
aKeyEvent
)
{
nsCOMPtr
<
nsIDOMEventTarget
>
target
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetTarget
(
getter_AddRefs
(
target
)
)
;
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
if
(
!
targetContent
)
{
return
false
;
}
nsCOMPtr
<
nsIHTMLEditor
>
htmlEditor
=
do_QueryInterface
(
static_cast
<
nsIEditor
*
>
(
mEditorBase
)
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mEditorBase
-
>
GetDocument
(
)
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
nsIContent
*
editingHost
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
targetContent
editingHost
)
;
}
}
