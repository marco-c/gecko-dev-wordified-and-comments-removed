#
include
"
EditorEventListener
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsID
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
class
nsPresContext
;
namespace
mozilla
{
using
namespace
dom
;
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
Document
*
doc
=
static_cast
<
Document
*
>
(
aData
)
;
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
!
root
)
{
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
root
-
>
GetControllerForCommand
(
commandStr
false
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
nsresult
rv
=
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
EditorEventListener
:
:
EditorEventListener
(
)
:
mEditorBase
(
nullptr
)
mCommitText
(
false
)
mInTransaction
(
false
)
mMouseDownOrUpConsumedByIME
(
false
)
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
mHaveBidiKeyboards
(
false
)
mShouldSwitchTextDirection
(
false
)
mSwitchToRTL
(
false
)
#
endif
{
}
EditorEventListener
:
:
~
EditorEventListener
(
)
{
if
(
mEditorBase
)
{
NS_WARNING
(
"
We
'
re
not
uninstalled
"
)
;
Disconnect
(
)
;
}
}
nsresult
EditorEventListener
:
:
Connect
(
EditorBase
*
aEditorBase
)
{
NS_ENSURE_ARG
(
aEditorBase
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
)
{
bool
haveBidiKeyboards
=
false
;
bidiKeyboard
-
>
GetHaveBidiKeyboards
(
&
haveBidiKeyboards
)
;
mHaveBidiKeyboards
=
haveBidiKeyboards
;
}
#
endif
mEditorBase
=
aEditorBase
;
nsresult
rv
=
InstallToEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Disconnect
(
)
;
}
return
rv
;
}
nsresult
EditorEventListener
:
:
InstallToEditor
(
)
{
MOZ_ASSERT
(
mEditorBase
"
The
caller
must
set
mEditorBase
"
)
;
EventTarget
*
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
NS_ENSURE_TRUE
(
piTarget
NS_ERROR_FAILURE
)
;
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
NS_ENSURE_STATE
(
elmP
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
Disconnect
(
)
{
if
(
DetachedFromEditor
(
)
)
{
return
;
}
UninstallFromEditor
(
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsIContent
*
focusedContent
=
fm
-
>
GetFocusedElement
(
)
;
mozilla
:
:
dom
:
:
Element
*
root
=
mEditorBase
-
>
GetRoot
(
)
;
if
(
focusedContent
&
&
root
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedContent
root
)
)
{
mEditorBase
-
>
FinalizeSelection
(
)
;
}
}
mEditorBase
=
nullptr
;
}
void
EditorEventListener
:
:
UninstallFromEditor
(
)
{
CleanupDragDropCaret
(
)
;
nsCOMPtr
<
EventTarget
>
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
if
(
!
piTarget
)
{
return
;
}
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
elmP
)
{
return
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
nsIPresShell
*
EditorEventListener
:
:
GetPresShell
(
)
const
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
return
mEditorBase
-
>
GetPresShell
(
)
;
}
nsPresContext
*
EditorEventListener
:
:
GetPresContext
(
)
const
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
nsIContent
*
EditorEventListener
:
:
GetFocusedRootContent
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
Document
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
composedDoc
nullptr
)
;
if
(
composedDoc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
nullptr
;
}
return
focusedContent
;
}
bool
EditorEventListener
:
:
EditorHasFocus
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
false
;
}
Document
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
return
!
!
composedDoc
;
}
NS_IMPL_ISUPPORTS
(
EditorEventListener
nsIDOMEventListener
)
bool
EditorEventListener
:
:
DetachedFromEditor
(
)
const
{
return
!
mEditorBase
;
}
bool
EditorEventListener
:
:
DetachedFromEditorOrDefaultPrevented
(
WidgetEvent
*
aWidgetEvent
)
const
{
return
NS_WARN_IF
(
!
aWidgetEvent
)
|
|
DetachedFromEditor
(
)
|
|
aWidgetEvent
-
>
DefaultPrevented
(
)
;
}
bool
EditorEventListener
:
:
EnsureCommitComposition
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
editorBase
-
>
CommitComposition
(
)
;
return
!
DetachedFromEditor
(
)
;
}
NS_IMETHODIMP
EditorEventListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
switch
(
internalEvent
-
>
mMessage
)
{
case
eDragEnter
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
return
DragEnter
(
dragEvent
)
;
}
case
eDragOver
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
return
DragOver
(
dragEvent
)
;
}
case
eDragExit
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
return
DragExit
(
dragEvent
)
;
}
case
eDrop
:
{
RefPtr
<
DragEvent
>
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
return
Drop
(
dragEvent
)
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
case
eKeyDown
:
{
return
KeyDown
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
}
case
eKeyUp
:
return
KeyUp
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
#
endif
case
eKeyPress
:
return
KeyPress
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
case
eMouseDown
:
{
mMouseDownOrUpConsumedByIME
=
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
;
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
RefPtr
<
MouseEvent
>
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
return
NS_WARN_IF
(
!
mouseEvent
)
?
NS_OK
:
MouseDown
(
mouseEvent
)
;
}
case
eMouseUp
:
{
if
(
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
)
{
mMouseDownOrUpConsumedByIME
=
true
;
}
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
RefPtr
<
MouseEvent
>
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
return
NS_WARN_IF
(
!
mouseEvent
)
?
NS_OK
:
MouseUp
(
mouseEvent
)
;
}
case
eMouseClick
:
{
WidgetMouseEvent
*
widgetMouseEvent
=
internalEvent
-
>
AsMouseEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetMouseEvent
)
)
{
return
NS_OK
;
}
if
(
mMouseDownOrUpConsumedByIME
)
{
mMouseDownOrUpConsumedByIME
=
false
;
widgetMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
return
MouseClick
(
widgetMouseEvent
)
;
}
case
eFocus
:
return
Focus
(
internalEvent
-
>
AsFocusEvent
(
)
)
;
case
eBlur
:
return
Blur
(
internalEvent
-
>
AsFocusEvent
(
)
)
;
case
eCompositionChange
:
return
HandleChangeComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
case
eCompositionStart
:
return
HandleStartComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
case
eCompositionEnd
:
HandleEndComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
return
NS_OK
;
default
:
break
;
}
#
ifdef
DEBUG
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
nsPrintfCString
assertMessage
(
"
Editor
doesn
'
t
handle
\
"
%
s
\
"
event
"
"
because
its
internal
event
doesn
'
t
have
proper
message
"
NS_ConvertUTF16toUTF8
(
eventType
)
.
get
(
)
)
;
NS_ASSERTION
(
false
assertMessage
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
bool
IsCtrlShiftPressed
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
bool
&
isRTL
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
!
aKeyboardEvent
-
>
IsControl
(
)
)
{
return
false
;
}
switch
(
aKeyboardEvent
-
>
mLocation
)
{
case
eKeyLocationRight
:
isRTL
=
true
;
break
;
case
eKeyLocationLeft
:
isRTL
=
false
;
break
;
default
:
return
false
;
}
if
(
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
false
;
}
return
true
;
}
nsresult
EditorEventListener
:
:
KeyUp
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
|
|
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_CONTROL
)
&
&
mShouldSwitchTextDirection
&
&
editorBase
-
>
IsPlaintextEditor
(
)
)
{
editorBase
-
>
SwitchTextDirectionTo
(
mSwitchToRTL
?
EditorBase
:
:
TextDirection
:
:
eRTL
:
EditorBase
:
:
TextDirection
:
:
eLTR
)
;
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
KeyDown
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
)
{
bool
switchToRTL
;
if
(
IsCtrlShiftPressed
(
aKeyboardEvent
switchToRTL
)
)
{
mShouldSwitchTextDirection
=
true
;
mSwitchToRTL
=
switchToRTL
;
}
}
else
if
(
aKeyboardEvent
-
>
mKeyCode
!
=
NS_VK_CONTROL
)
{
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
#
endif
nsresult
EditorEventListener
:
:
KeyPress
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aKeyboardEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
nsresult
rv
=
editorBase
-
>
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
if
(
!
ShouldHandleNativeKeyBindings
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
nsIWidget
*
widget
=
aKeyboardEvent
-
>
mWidget
;
if
(
!
widget
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
nsPresContext
*
pc
=
ps
?
ps
-
>
GetPresContext
(
)
:
nullptr
;
widget
=
pc
?
pc
-
>
GetNearestWidget
(
)
:
nullptr
;
NS_ENSURE_TRUE
(
widget
NS_OK
)
;
}
RefPtr
<
Document
>
doc
=
editorBase
-
>
GetDocument
(
)
;
AutoRestore
<
nsCOMPtr
<
nsIWidget
>
>
saveWidget
(
aKeyboardEvent
-
>
mWidget
)
;
aKeyboardEvent
-
>
mWidget
=
widget
;
if
(
aKeyboardEvent
-
>
ExecuteEditCommands
(
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
DoCommandCallback
doc
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
MouseClick
(
WidgetMouseEvent
*
aMouseClickEvent
)
{
if
(
NS_WARN_IF
(
!
aMouseClickEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
TextEditor
>
textEditor
=
mEditorBase
-
>
AsTextEditor
(
)
;
if
(
textEditor
-
>
IsReadonly
(
)
|
|
textEditor
-
>
IsDisabled
(
)
|
|
!
textEditor
-
>
IsAcceptableInputEvent
(
aMouseClickEvent
)
)
{
return
NS_OK
;
}
if
(
EditorHasFocus
(
)
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
IMEStateManager
:
:
OnClickInEditor
(
presContext
GetFocusedRootContent
(
)
aMouseClickEvent
)
;
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
}
}
if
(
DetachedFromEditorOrDefaultPrevented
(
aMouseClickEvent
)
)
{
return
NS_OK
;
}
if
(
!
EnsureCommitComposition
(
)
)
{
return
NS_OK
;
}
if
(
aMouseClickEvent
-
>
button
!
=
WidgetMouseEventBase
:
:
eMiddleButton
|
|
!
WidgetMouseEvent
:
:
IsMiddleClickPasteEnabled
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_OK
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
aMouseClickEvent
-
>
DefaultPrevented
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
RefPtr
<
EventStateManager
>
esm
=
presContext
-
>
EventStateManager
(
)
;
DebugOnly
<
nsresult
>
rv
=
esm
-
>
HandleMiddleClickPaste
(
presShell
aMouseClickEvent
&
status
textEditor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
paste
for
the
middle
button
click
"
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
aMouseClickEvent
-
>
StopImmediatePropagation
(
)
;
aMouseClickEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
bool
EditorEventListener
:
:
NotifyIMEOfMouseButtonEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
if
(
!
EditorHasFocus
(
)
)
{
return
false
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
false
)
;
return
IMEStateManager
:
:
OnMouseButtonEventInEditor
(
presContext
GetFocusedRootContent
(
)
aMouseEvent
)
;
}
nsresult
EditorEventListener
:
:
MouseDown
(
MouseEvent
*
aMouseEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
Unused
<
<
EnsureCommitComposition
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
DragEnter
(
DragEvent
*
aDragEvent
)
{
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_OK
)
;
if
(
!
mCaret
)
{
mCaret
=
new
nsCaret
(
)
;
mCaret
-
>
Init
(
presShell
)
;
mCaret
-
>
SetCaretReadOnly
(
true
)
;
mCaret
-
>
SetVisibilityDuringSelection
(
true
)
;
}
presShell
-
>
SetCaret
(
mCaret
)
;
return
DragOver
(
aDragEvent
)
;
}
nsresult
EditorEventListener
:
:
DragOver
(
DragEvent
*
aDragEvent
)
{
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
WidgetEventPtr
(
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
parent
=
aDragEvent
-
>
GetRangeParent
(
)
;
nsCOMPtr
<
nsIContent
>
dropParent
=
do_QueryInterface
(
parent
)
;
NS_ENSURE_TRUE
(
dropParent
NS_ERROR_FAILURE
)
;
if
(
dropParent
-
>
IsEditable
(
)
&
&
CanDrop
(
aDragEvent
)
)
{
aDragEvent
-
>
PreventDefault
(
)
;
if
(
!
mCaret
)
{
return
NS_OK
;
}
int32_t
offset
=
aDragEvent
-
>
RangeOffset
(
)
;
mCaret
-
>
SetVisible
(
true
)
;
mCaret
-
>
SetCaretPosition
(
dropParent
offset
)
;
return
NS_OK
;
}
if
(
!
IsFileControlTextBox
(
)
)
{
aDragEvent
-
>
StopPropagation
(
)
;
}
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
false
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
CleanupDragDropCaret
(
)
{
if
(
!
mCaret
)
{
return
;
}
mCaret
-
>
SetVisible
(
false
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
RestoreCaret
(
)
;
}
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
nsresult
EditorEventListener
:
:
DragExit
(
DragEvent
*
aDragEvent
)
{
NS_WARNING_ASSERTION
(
!
aDragEvent
-
>
WidgetEventPtr
(
)
-
>
DefaultPrevented
(
)
"
eDragExit
shouldn
'
t
be
cancelable
"
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
CleanupDragDropCaret
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Drop
(
DragEvent
*
aDragEvent
)
{
CleanupDragDropCaret
(
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
WidgetEventPtr
(
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
dropParentNode
=
aDragEvent
-
>
GetRangeParent
(
)
;
nsIContent
*
dropParentContent
=
nsIContent
:
:
FromNodeOrNull
(
dropParentNode
)
;
if
(
NS_WARN_IF
(
!
dropParentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
dropParentContent
-
>
IsEditable
(
)
|
|
!
CanDrop
(
aDragEvent
)
)
{
if
(
(
mEditorBase
-
>
IsReadonly
(
)
|
|
mEditorBase
-
>
IsDisabled
(
)
)
&
&
!
IsFileControlTextBox
(
)
)
{
aDragEvent
-
>
StopPropagation
(
)
;
}
return
NS_OK
;
}
aDragEvent
-
>
StopPropagation
(
)
;
aDragEvent
-
>
PreventDefault
(
)
;
RefPtr
<
TextEditor
>
textEditor
=
mEditorBase
-
>
AsTextEditor
(
)
;
nsresult
rv
=
textEditor
-
>
OnDrop
(
aDragEvent
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
EditorEventListener
:
:
CanDrop
(
DragEvent
*
aEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditorOrDefaultPrevented
(
aEvent
-
>
WidgetEventPtr
(
)
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
)
{
return
false
;
}
RefPtr
<
DataTransfer
>
dataTransfer
=
aEvent
-
>
GetDataTransfer
(
)
;
NS_ENSURE_TRUE
(
dataTransfer
false
)
;
nsTArray
<
nsString
>
types
;
dataTransfer
-
>
GetTypes
(
types
CallerType
:
:
System
)
;
if
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kTextMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kMozTextInternal
)
)
&
&
(
editorBase
-
>
IsPlaintextEditor
(
)
|
|
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kHTMLMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kFileMime
)
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
sourceNode
=
dataTransfer
-
>
GetMozSourceNode
(
)
;
if
(
!
sourceNode
)
{
return
true
;
}
RefPtr
<
Document
>
domdoc
=
editorBase
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
domdoc
false
)
;
RefPtr
<
Document
>
sourceDoc
=
sourceNode
-
>
OwnerDoc
(
)
;
if
(
domdoc
!
=
sourceDoc
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
sourceContent
=
do_QueryInterface
(
sourceNode
)
;
TabParent
*
tp
=
TabParent
:
:
GetFrom
(
sourceContent
)
;
if
(
tp
)
{
return
true
;
}
RefPtr
<
Selection
>
selection
=
editorBase
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
false
;
}
if
(
selection
-
>
IsCollapsed
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsINode
>
parent
=
aEvent
-
>
GetRangeParent
(
)
;
if
(
!
parent
)
{
return
false
;
}
int32_t
offset
=
aEvent
-
>
RangeOffset
(
)
;
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
!
range
)
{
continue
;
}
IgnoredErrorResult
rv
;
bool
inRange
=
range
-
>
IsPointInRange
(
*
parent
offset
rv
)
;
if
(
!
rv
.
Failed
(
)
&
&
inRange
)
{
return
false
;
}
}
return
true
;
}
nsresult
EditorEventListener
:
:
HandleStartComposition
(
WidgetCompositionEvent
*
aCompositionStartEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionStartEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionStartEvent
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
aCompositionStartEvent
-
>
DefaultPrevented
(
)
"
eCompositionStart
shouldn
'
t
be
cancelable
"
)
;
TextEditor
*
textEditor
=
editorBase
-
>
AsTextEditor
(
)
;
return
textEditor
-
>
OnCompositionStart
(
*
aCompositionStartEvent
)
;
}
nsresult
EditorEventListener
:
:
HandleChangeComposition
(
WidgetCompositionEvent
*
aCompositionChangeEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionChangeEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
aCompositionChangeEvent
-
>
DefaultPrevented
(
)
"
eCompositionChange
event
shouldn
'
t
be
cancelable
"
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionChangeEvent
)
)
{
return
NS_OK
;
}
if
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
RefPtr
<
TextEditor
>
textEditor
=
editorBase
-
>
AsTextEditor
(
)
;
return
textEditor
-
>
OnCompositionChange
(
*
aCompositionChangeEvent
)
;
}
void
EditorEventListener
:
:
HandleEndComposition
(
WidgetCompositionEvent
*
aCompositionEndEvent
)
{
if
(
NS_WARN_IF
(
!
aCompositionEndEvent
)
)
{
return
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionEndEvent
)
)
{
return
;
}
MOZ_ASSERT
(
!
aCompositionEndEvent
-
>
DefaultPrevented
(
)
"
eCompositionEnd
shouldn
'
t
be
cancelable
"
)
;
RefPtr
<
TextEditor
>
textEditor
=
editorBase
-
>
AsTextEditor
(
)
;
textEditor
-
>
OnCompositionEnd
(
*
aCompositionEndEvent
)
;
}
nsresult
EditorEventListener
:
:
Focus
(
InternalFocusEvent
*
aFocusEvent
)
{
if
(
NS_WARN_IF
(
!
aFocusEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
editorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
SpellCheckIfNeeded
(
)
;
if
(
!
editorBase
)
{
return
NS_OK
;
}
EventTarget
*
target
=
aFocusEvent
-
>
GetOriginalDOMEventTarget
(
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_UNEXPECTED
)
;
if
(
node
-
>
IsDocument
(
)
&
&
!
node
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
NS_OK
;
}
if
(
node
-
>
IsContent
(
)
)
{
nsIContent
*
content
=
node
-
>
AsContent
(
)
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
nsCOMPtr
<
nsIContent
>
editableRoot
=
editorBase
-
>
FindSelectionRoot
(
content
)
;
if
(
editableRoot
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
nsIContent
*
focusedContent
=
fm
-
>
GetFocusedElement
(
)
;
if
(
!
focusedContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
originalTargetAsContent
=
do_QueryInterface
(
aFocusEvent
-
>
GetOriginalDOMEventTarget
(
)
)
;
if
(
!
SameCOMIdentity
(
focusedContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
originalTargetAsContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
)
{
return
NS_OK
;
}
}
}
editorBase
-
>
OnFocus
(
target
)
;
if
(
DetachedFromEditorOrDefaultPrevented
(
aFocusEvent
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_OK
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
editorBase
-
>
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
OnFocusInEditor
(
ps
-
>
GetPresContext
(
)
focusedContent
*
editorBase
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Blur
(
InternalFocusEvent
*
aBlurEvent
)
{
if
(
NS_WARN_IF
(
!
aBlurEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
Element
*
focusedElement
=
fm
-
>
GetFocusedElement
(
)
;
if
(
!
focusedElement
)
{
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
editorBase
-
>
FinalizeSelection
(
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
SpellCheckIfNeeded
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
editorBase
-
>
ShouldSkipSpellCheck
(
)
)
{
editorBase
-
>
RemoveFlags
(
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
)
;
}
}
bool
EditorEventListener
:
:
IsFileControlTextBox
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
Element
*
root
=
editorBase
-
>
GetRoot
(
)
;
if
(
!
root
|
|
!
root
-
>
ChromeOnlyAccess
(
)
)
{
return
false
;
}
nsIContent
*
parent
=
root
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
parent
)
;
return
formControl
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_FILE
;
}
bool
EditorEventListener
:
:
ShouldHandleNativeKeyBindings
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
aKeyboardEvent
-
>
GetDOMEventTarget
(
)
)
;
if
(
!
targetContent
)
{
return
false
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
HTMLEditor
*
htmlEditor
=
editorBase
-
>
AsHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
RefPtr
<
Document
>
doc
=
editorBase
-
>
GetDocument
(
)
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
nsIContent
*
editingHost
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
targetContent
editingHost
)
;
}
}
