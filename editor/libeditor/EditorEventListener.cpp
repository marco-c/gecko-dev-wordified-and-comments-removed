#
include
"
EditorEventListener
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsID
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMDragEvent
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorMailSupport
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
class
nsPresContext
;
namespace
mozilla
{
using
namespace
dom
;
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
nsIDocument
*
doc
=
static_cast
<
nsIDocument
*
>
(
aData
)
;
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
!
root
)
{
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
root
-
>
GetControllerForCommand
(
commandStr
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
nsresult
rv
=
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
EditorEventListener
:
:
EditorEventListener
(
)
:
mEditorBase
(
nullptr
)
mCommitText
(
false
)
mInTransaction
(
false
)
mMouseDownOrUpConsumedByIME
(
false
)
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
mHaveBidiKeyboards
(
false
)
mShouldSwitchTextDirection
(
false
)
mSwitchToRTL
(
false
)
#
endif
{
}
EditorEventListener
:
:
~
EditorEventListener
(
)
{
if
(
mEditorBase
)
{
NS_WARNING
(
"
We
'
re
not
uninstalled
"
)
;
Disconnect
(
)
;
}
}
nsresult
EditorEventListener
:
:
Connect
(
EditorBase
*
aEditorBase
)
{
NS_ENSURE_ARG
(
aEditorBase
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
)
{
bool
haveBidiKeyboards
=
false
;
bidiKeyboard
-
>
GetHaveBidiKeyboards
(
&
haveBidiKeyboards
)
;
mHaveBidiKeyboards
=
haveBidiKeyboards
;
}
#
endif
mEditorBase
=
aEditorBase
;
nsresult
rv
=
InstallToEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
Disconnect
(
)
;
}
return
rv
;
}
nsresult
EditorEventListener
:
:
InstallToEditor
(
)
{
NS_PRECONDITION
(
mEditorBase
"
The
caller
must
set
mEditorBase
"
)
;
nsCOMPtr
<
EventTarget
>
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
NS_ENSURE_TRUE
(
piTarget
NS_ERROR_FAILURE
)
;
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
NS_ENSURE_STATE
(
elmP
)
;
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
return
NS_OK
;
}
void
EditorEventListener
:
:
Disconnect
(
)
{
if
(
DetachedFromEditor
(
)
)
{
return
;
}
UninstallFromEditor
(
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
nsIDOMElement
>
domFocus
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
domFocus
)
)
;
nsCOMPtr
<
nsINode
>
focusedElement
=
do_QueryInterface
(
domFocus
)
;
mozilla
:
:
dom
:
:
Element
*
root
=
mEditorBase
-
>
GetRoot
(
)
;
if
(
focusedElement
&
&
root
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedElement
root
)
)
{
mEditorBase
-
>
FinalizeSelection
(
)
;
}
}
mEditorBase
=
nullptr
;
}
void
EditorEventListener
:
:
UninstallFromEditor
(
)
{
nsCOMPtr
<
EventTarget
>
piTarget
=
mEditorBase
-
>
GetDOMEventTarget
(
)
;
if
(
!
piTarget
)
{
return
;
}
EventListenerManager
*
elmP
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
elmP
)
{
return
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
#
endif
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragenter
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragover
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
dragexit
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
drop
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousedown
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mouseup
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
click
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
blur
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
focus
"
)
TrustedEventsAtCapture
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
text
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionstart
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
elmP
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
compositionend
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
already_AddRefed
<
nsIPresShell
>
EditorEventListener
:
:
GetPresShell
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
return
mEditorBase
-
>
GetPresShell
(
)
;
}
nsPresContext
*
EditorEventListener
:
:
GetPresContext
(
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
nsIContent
*
EditorEventListener
:
:
GetFocusedRootContent
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsIDocument
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
composedDoc
nullptr
)
;
if
(
composedDoc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
nullptr
;
}
return
focusedContent
;
}
bool
EditorEventListener
:
:
EditorHasFocus
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
mEditorBase
-
>
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
false
;
}
nsIDocument
*
composedDoc
=
focusedContent
-
>
GetComposedDoc
(
)
;
return
!
!
composedDoc
;
}
NS_IMPL_ISUPPORTS
(
EditorEventListener
nsIDOMEventListener
)
bool
EditorEventListener
:
:
DetachedFromEditor
(
)
const
{
return
!
mEditorBase
;
}
bool
EditorEventListener
:
:
DetachedFromEditorOrDefaultPrevented
(
WidgetEvent
*
aWidgetEvent
)
const
{
return
NS_WARN_IF
(
!
aWidgetEvent
)
|
|
DetachedFromEditor
(
)
|
|
aWidgetEvent
-
>
DefaultPrevented
(
)
;
}
bool
EditorEventListener
:
:
EnsureCommitCompoisition
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
editorBase
-
>
ForceCompositionEnd
(
)
;
return
!
DetachedFromEditor
(
)
;
}
NS_IMETHODIMP
EditorEventListener
:
:
HandleEvent
(
nsIDOMEvent
*
aEvent
)
{
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
switch
(
internalEvent
-
>
mMessage
)
{
case
eDragEnter
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragEnter
(
dragEvent
)
;
}
case
eDragOver
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragOver
(
dragEvent
)
;
}
case
eDragExit
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
DragExit
(
dragEvent
)
;
}
case
eDrop
:
{
nsCOMPtr
<
nsIDOMDragEvent
>
dragEvent
=
do_QueryInterface
(
aEvent
)
;
return
Drop
(
dragEvent
)
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
case
eKeyDown
:
{
return
KeyDown
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
}
case
eKeyUp
:
return
KeyUp
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
#
endif
case
eKeyPress
:
return
KeyPress
(
internalEvent
-
>
AsKeyboardEvent
(
)
)
;
case
eMouseDown
:
{
mMouseDownOrUpConsumedByIME
=
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
;
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
return
NS_WARN_IF
(
!
mouseEvent
)
?
NS_OK
:
MouseDown
(
mouseEvent
)
;
}
case
eMouseUp
:
{
if
(
NotifyIMEOfMouseButtonEvent
(
internalEvent
-
>
AsMouseEvent
(
)
)
)
{
mMouseDownOrUpConsumedByIME
=
true
;
}
if
(
mMouseDownOrUpConsumedByIME
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
return
NS_WARN_IF
(
!
mouseEvent
)
?
NS_OK
:
MouseUp
(
mouseEvent
)
;
}
case
eMouseClick
:
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aEvent
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_OK
)
;
if
(
mMouseDownOrUpConsumedByIME
)
{
mMouseDownOrUpConsumedByIME
=
false
;
mouseEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
return
MouseClick
(
mouseEvent
)
;
}
case
eFocus
:
return
Focus
(
internalEvent
-
>
AsFocusEvent
(
)
)
;
case
eBlur
:
return
Blur
(
internalEvent
-
>
AsFocusEvent
(
)
)
;
case
eCompositionChange
:
return
HandleChangeComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
case
eCompositionStart
:
return
HandleStartComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
case
eCompositionEnd
:
HandleEndComposition
(
internalEvent
-
>
AsCompositionEvent
(
)
)
;
return
NS_OK
;
default
:
break
;
}
#
ifdef
DEBUG
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
nsPrintfCString
assertMessage
(
"
Editor
doesn
'
t
handle
\
"
%
s
\
"
event
"
"
because
its
internal
event
doesn
'
t
have
proper
message
"
NS_ConvertUTF16toUTF8
(
eventType
)
.
get
(
)
)
;
NS_ASSERTION
(
false
assertMessage
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
#
ifdef
HANDLE_NATIVE_TEXT_DIRECTION_SWITCH
bool
IsCtrlShiftPressed
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
bool
&
isRTL
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
!
aKeyboardEvent
-
>
IsControl
(
)
)
{
return
false
;
}
switch
(
aKeyboardEvent
-
>
mLocation
)
{
case
eKeyLocationRight
:
isRTL
=
true
;
break
;
case
eKeyLocationLeft
:
isRTL
=
false
;
break
;
default
:
return
false
;
}
if
(
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
false
;
}
return
true
;
}
nsresult
EditorEventListener
:
:
KeyUp
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
|
|
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_CONTROL
)
&
&
mShouldSwitchTextDirection
&
&
editorBase
-
>
IsPlaintextEditor
(
)
)
{
editorBase
-
>
SwitchTextDirectionTo
(
mSwitchToRTL
?
nsIPlaintextEditor
:
:
eEditorRightToLeft
:
nsIPlaintextEditor
:
:
eEditorLeftToRight
)
;
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
KeyDown
(
const
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
mHaveBidiKeyboards
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_SHIFT
)
{
bool
switchToRTL
;
if
(
IsCtrlShiftPressed
(
aKeyboardEvent
switchToRTL
)
)
{
mShouldSwitchTextDirection
=
true
;
mSwitchToRTL
=
switchToRTL
;
}
}
else
if
(
aKeyboardEvent
-
>
mKeyCode
!
=
NS_VK_CONTROL
)
{
mShouldSwitchTextDirection
=
false
;
}
return
NS_OK
;
}
#
endif
nsresult
EditorEventListener
:
:
KeyPress
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
!
editorBase
-
>
IsAcceptableInputEvent
(
aKeyboardEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
nsresult
rv
=
editorBase
-
>
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
DetachedFromEditorOrDefaultPrevented
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
if
(
!
ShouldHandleNativeKeyBindings
(
aKeyboardEvent
)
)
{
return
NS_OK
;
}
nsIWidget
*
widget
=
aKeyboardEvent
-
>
mWidget
;
if
(
!
widget
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
nsPresContext
*
pc
=
ps
?
ps
-
>
GetPresContext
(
)
:
nullptr
;
widget
=
pc
?
pc
-
>
GetNearestWidget
(
)
:
nullptr
;
NS_ENSURE_TRUE
(
widget
NS_OK
)
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
editorBase
-
>
GetDocument
(
)
;
AutoRestore
<
nsCOMPtr
<
nsIWidget
>
>
saveWidget
(
aKeyboardEvent
-
>
mWidget
)
;
aKeyboardEvent
-
>
mWidget
=
widget
;
if
(
aKeyboardEvent
-
>
ExecuteEditCommands
(
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
DoCommandCallback
doc
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
MouseClick
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
if
(
NS_WARN_IF
(
!
aMouseEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
WidgetMouseEvent
*
clickEvent
=
aMouseEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
if
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
clickEvent
)
)
{
return
NS_OK
;
}
if
(
EditorHasFocus
(
)
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
IMEStateManager
:
:
OnClickInEditor
(
presContext
GetFocusedRootContent
(
)
clickEvent
)
;
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
}
}
if
(
DetachedFromEditorOrDefaultPrevented
(
clickEvent
)
)
{
return
NS_OK
;
}
if
(
!
EnsureCommitCompoisition
(
)
)
{
return
NS_OK
;
}
if
(
clickEvent
-
>
button
=
=
1
)
{
return
HandleMiddleClickPaste
(
aMouseEvent
)
;
}
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
HandleMiddleClickPaste
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
WidgetMouseEvent
*
clickEvent
=
aMouseEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
MOZ_ASSERT
(
!
DetachedFromEditorOrDefaultPrevented
(
clickEvent
)
)
;
if
(
!
Preferences
:
:
GetBool
(
"
middlemouse
.
paste
"
false
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
if
(
NS_FAILED
(
aMouseEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
offset
=
0
;
if
(
NS_FAILED
(
aMouseEvent
-
>
GetRangeOffset
(
&
offset
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
RefPtr
<
Selection
>
selection
=
editorBase
-
>
GetSelection
(
)
;
if
(
selection
)
{
selection
-
>
Collapse
(
parent
offset
)
;
}
nsCOMPtr
<
nsIEditorMailSupport
>
mailEditor
;
if
(
clickEvent
-
>
IsControl
(
)
)
{
mailEditor
=
do_QueryObject
(
editorBase
)
;
}
nsresult
rv
;
int32_t
clipboard
=
nsIClipboard
:
:
kGlobalClipboard
;
nsCOMPtr
<
nsIClipboard
>
clipboardService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
selectionSupported
;
rv
=
clipboardService
-
>
SupportsSelectionClipboard
(
&
selectionSupported
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
selectionSupported
)
{
clipboard
=
nsIClipboard
:
:
kSelectionClipboard
;
}
}
if
(
mailEditor
)
{
mailEditor
-
>
PasteAsQuotation
(
clipboard
)
;
}
else
{
editorBase
-
>
Paste
(
clipboard
)
;
}
clickEvent
-
>
StopPropagation
(
)
;
clickEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
bool
EditorEventListener
:
:
NotifyIMEOfMouseButtonEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
if
(
!
EditorHasFocus
(
)
)
{
return
false
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
false
)
;
return
IMEStateManager
:
:
OnMouseButtonEventInEditor
(
presContext
GetFocusedRootContent
(
)
aMouseEvent
)
;
}
nsresult
EditorEventListener
:
:
MouseDown
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
Unused
<
<
EnsureCommitCompoisition
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
HandleChangeComposition
(
WidgetCompositionEvent
*
aCompositionChangeEvent
)
{
MOZ_ASSERT
(
!
aCompositionChangeEvent
-
>
DefaultPrevented
(
)
"
eCompositionChange
event
shouldn
'
t
be
cancelable
"
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionChangeEvent
)
)
{
return
NS_OK
;
}
if
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
return
editorBase
-
>
UpdateIMEComposition
(
aCompositionChangeEvent
)
;
}
nsresult
EditorEventListener
:
:
DragEnter
(
nsIDOMDragEvent
*
aDragEvent
)
{
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_OK
)
;
if
(
!
mCaret
)
{
mCaret
=
new
nsCaret
(
)
;
mCaret
-
>
Init
(
presShell
)
;
mCaret
-
>
SetCaretReadOnly
(
true
)
;
mCaret
-
>
SetVisibilityDuringSelection
(
true
)
;
}
presShell
-
>
SetCaret
(
mCaret
)
;
return
DragOver
(
aDragEvent
)
;
}
nsresult
EditorEventListener
:
:
DragOver
(
nsIDOMDragEvent
*
aDragEvent
)
{
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
aDragEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsIContent
>
dropParent
=
do_QueryInterface
(
parent
)
;
NS_ENSURE_TRUE
(
dropParent
NS_ERROR_FAILURE
)
;
if
(
dropParent
-
>
IsEditable
(
)
&
&
CanDrop
(
aDragEvent
)
)
{
aDragEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
if
(
!
mCaret
)
{
return
NS_OK
;
}
int32_t
offset
=
0
;
nsresult
rv
=
aDragEvent
-
>
GetRangeOffset
(
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCaret
-
>
SetVisible
(
true
)
;
mCaret
-
>
SetCaretPosition
(
parent
offset
)
;
return
NS_OK
;
}
if
(
!
IsFileControlTextBox
(
)
)
{
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
}
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
false
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
CleanupDragDropCaret
(
)
{
if
(
!
mCaret
)
{
return
;
}
mCaret
-
>
SetVisible
(
false
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
RestoreCaret
(
)
;
}
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
nsresult
EditorEventListener
:
:
DragExit
(
nsIDOMDragEvent
*
aDragEvent
)
{
NS_WARNING_ASSERTION
(
!
aDragEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
DefaultPrevented
(
)
"
eDragExit
shouldn
'
t
be
cancelable
"
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
CleanupDragDropCaret
(
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Drop
(
nsIDOMDragEvent
*
aDragEvent
)
{
CleanupDragDropCaret
(
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
)
|
|
DetachedFromEditorOrDefaultPrevented
(
aDragEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
aDragEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsIContent
>
dropParent
=
do_QueryInterface
(
parent
)
;
NS_ENSURE_TRUE
(
dropParent
NS_ERROR_FAILURE
)
;
if
(
!
dropParent
-
>
IsEditable
(
)
|
|
!
CanDrop
(
aDragEvent
)
)
{
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
)
&
&
!
IsFileControlTextBox
(
)
)
{
return
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
}
return
NS_OK
;
}
aDragEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
aDragEvent
-
>
AsEvent
(
)
-
>
PreventDefault
(
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
return
editorBase
-
>
InsertFromDrop
(
aDragEvent
-
>
AsEvent
(
)
)
;
}
bool
EditorEventListener
:
:
CanDrop
(
nsIDOMDragEvent
*
aEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditorOrDefaultPrevented
(
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
editorBase
-
>
IsReadonly
(
)
|
|
editorBase
-
>
IsDisabled
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMDataTransfer
>
domDataTransfer
;
aEvent
-
>
GetDataTransfer
(
getter_AddRefs
(
domDataTransfer
)
)
;
nsCOMPtr
<
DataTransfer
>
dataTransfer
=
do_QueryInterface
(
domDataTransfer
)
;
NS_ENSURE_TRUE
(
dataTransfer
false
)
;
nsTArray
<
nsString
>
types
;
dataTransfer
-
>
GetTypes
(
types
CallerType
:
:
System
)
;
if
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kTextMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kMozTextInternal
)
)
&
&
(
editorBase
-
>
IsPlaintextEditor
(
)
|
|
(
!
types
.
Contains
(
NS_LITERAL_STRING
(
kHTMLMime
)
)
&
&
!
types
.
Contains
(
NS_LITERAL_STRING
(
kFileMime
)
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMNode
>
sourceNode
;
dataTransfer
-
>
GetMozSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMDocument
>
domdoc
=
editorBase
-
>
GetDOMDocument
(
)
;
NS_ENSURE_TRUE
(
domdoc
false
)
;
nsCOMPtr
<
nsIDOMDocument
>
sourceDoc
;
nsresult
rv
=
sourceNode
-
>
GetOwnerDocument
(
getter_AddRefs
(
sourceDoc
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
domdoc
!
=
sourceDoc
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
sourceContent
=
do_QueryInterface
(
sourceNode
)
;
TabParent
*
tp
=
TabParent
:
:
GetFrom
(
sourceContent
)
;
if
(
tp
)
{
return
true
;
}
RefPtr
<
Selection
>
selection
=
editorBase
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
false
;
}
if
(
selection
-
>
Collapsed
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
rv
=
aEvent
-
>
GetRangeParent
(
getter_AddRefs
(
parent
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
parent
)
{
return
false
;
}
int32_t
offset
=
0
;
rv
=
aEvent
-
>
GetRangeOffset
(
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
!
range
)
{
continue
;
}
bool
inRange
=
true
;
range
-
>
IsPointInRange
(
parent
offset
&
inRange
)
;
if
(
inRange
)
{
return
false
;
}
}
return
true
;
}
nsresult
EditorEventListener
:
:
HandleStartComposition
(
WidgetCompositionEvent
*
aCompositionStartEvent
)
{
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionStartEvent
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
aCompositionStartEvent
-
>
DefaultPrevented
(
)
"
eCompositionStart
shouldn
'
t
be
cancelable
"
)
;
return
editorBase
-
>
BeginIMEComposition
(
aCompositionStartEvent
)
;
}
void
EditorEventListener
:
:
HandleEndComposition
(
WidgetCompositionEvent
*
aCompositionEndEvent
)
{
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
DetachedFromEditor
(
)
|
|
!
editorBase
-
>
IsAcceptableInputEvent
(
aCompositionEndEvent
)
)
{
return
;
}
MOZ_ASSERT
(
!
aCompositionEndEvent
-
>
DefaultPrevented
(
)
"
eCompositionEnd
shouldn
'
t
be
cancelable
"
)
;
editorBase
-
>
EndIMEComposition
(
)
;
}
nsresult
EditorEventListener
:
:
Focus
(
InternalFocusEvent
*
aFocusEvent
)
{
if
(
NS_WARN_IF
(
!
aFocusEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
if
(
editorBase
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
SpellCheckIfNeeded
(
)
;
if
(
!
editorBase
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
aFocusEvent
-
>
GetDOMEventTarget
(
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_UNEXPECTED
)
;
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
&
&
!
node
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
NS_OK
;
}
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
nsCOMPtr
<
nsIContent
>
editableRoot
=
editorBase
-
>
FindSelectionRoot
(
node
)
;
if
(
editableRoot
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
nsCOMPtr
<
nsIDOMElement
>
element
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
element
)
)
;
if
(
!
element
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
originalTarget
=
aFocusEvent
-
>
GetOriginalDOMEventTarget
(
)
;
nsCOMPtr
<
nsIContent
>
originalTargetAsContent
=
do_QueryInterface
(
originalTarget
)
;
nsCOMPtr
<
nsIContent
>
focusedElementAsContent
=
do_QueryInterface
(
element
)
;
if
(
!
SameCOMIdentity
(
focusedElementAsContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
originalTargetAsContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
)
{
return
NS_OK
;
}
}
}
editorBase
-
>
OnFocus
(
target
)
;
if
(
DetachedFromEditorOrDefaultPrevented
(
aFocusEvent
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_OK
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
editorBase
-
>
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
OnFocusInEditor
(
ps
-
>
GetPresContext
(
)
focusedContent
*
editorBase
)
;
return
NS_OK
;
}
nsresult
EditorEventListener
:
:
Blur
(
InternalFocusEvent
*
aBlurEvent
)
{
if
(
NS_WARN_IF
(
!
aBlurEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_OK
)
;
nsCOMPtr
<
nsIDOMElement
>
element
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
element
)
)
;
if
(
!
element
)
{
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
editorBase
-
>
FinalizeSelection
(
)
;
}
return
NS_OK
;
}
void
EditorEventListener
:
:
SpellCheckIfNeeded
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
uint32_t
currentFlags
=
0
;
editorBase
-
>
GetFlags
(
&
currentFlags
)
;
if
(
currentFlags
&
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
)
{
currentFlags
^
=
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
;
editorBase
-
>
SetFlags
(
currentFlags
)
;
}
}
bool
EditorEventListener
:
:
IsFileControlTextBox
(
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
Element
*
root
=
editorBase
-
>
GetRoot
(
)
;
if
(
!
root
|
|
!
root
-
>
ChromeOnlyAccess
(
)
)
{
return
false
;
}
nsIContent
*
parent
=
root
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
parent
)
;
return
formControl
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_FILE
;
}
bool
EditorEventListener
:
:
ShouldHandleNativeKeyBindings
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
!
DetachedFromEditor
(
)
)
;
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
aKeyboardEvent
-
>
GetDOMEventTarget
(
)
;
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
if
(
!
targetContent
)
{
return
false
;
}
RefPtr
<
EditorBase
>
editorBase
(
mEditorBase
)
;
HTMLEditor
*
htmlEditor
=
editorBase
-
>
AsHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
editorBase
-
>
GetDocument
(
)
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
nsIContent
*
editingHost
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
targetContent
editingHost
)
;
}
}
