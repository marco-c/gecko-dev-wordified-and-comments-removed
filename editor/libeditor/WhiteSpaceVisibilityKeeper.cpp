#
include
"
WhiteSpaceVisibilityKeeper
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditorNestedClasses
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
template
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
const
Element
&
aEditingHost
)
;
template
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aScanStartPoint
const
Element
&
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
const
Element
&
aSplittingBlockElement
)
{
if
(
NS_WARN_IF
(
!
aPointToSplit
.
IsInContentNodeAndValidInComposedDoc
(
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
aPointToSplit
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
for
(
nsIContent
*
content
:
aPointToSplit
.
ContainerAs
<
nsIContent
>
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
content
=
=
&
aSplittingBlockElement
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsSplittableNode
(
*
content
)
)
{
break
;
}
pointToSplit
.
Set
(
content
)
;
}
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
aHTMLEditor
pointToSplit
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
else
{
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
aHTMLEditor
pointToSplit
{
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
}
)
;
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
)
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
-
>
IsInclusiveDescendantOf
(
&
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
pointToSplit
;
}
Result
<
MoveNodeResult
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aAtRightBlockChild
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
)
)
;
MOZ_ASSERT
(
&
aRightBlockElement
=
=
aAtRightBlockChild
.
GetContainer
(
)
)
;
OwningNonNull
<
Element
>
rightBlockElement
=
aRightBlockElement
;
EditorDOMPoint
afterRightBlockChild
=
aAtRightBlockChild
.
NextPoint
(
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
)
{
EditorDOMPoint
leftBlockContainingPointInRightBlockElement
;
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
&
leftBlockContainingPointInRightBlockElement
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
moving
the
left
block
element
outside
the
right
block
element
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
leftBlockContainingPointInRightBlockElement
!
=
aAtRightBlockChild
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
changing
the
left
block
element
in
the
right
block
element
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
aRightBlockElement
EditorType
:
:
HTML
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
making
the
right
block
element
non
-
editable
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
aLeftBlockElement
EditorType
:
:
HTML
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
making
the
left
block
element
non
-
editable
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
afterRightBlockChild
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
afterRightBlockChild
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
else
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
{
AutoTrackDOMPoint
trackAfterRightBlockChild
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
afterRightBlockChild
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
aHTMLEditor
afterRightBlockChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
trackAfterRightBlockChild
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
afterRightBlockChild
.
GetContainer
(
)
!
=
&
aRightBlockElement
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
AutoTrackDOMPoint
trackAfterRightBlockChild
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
afterRightBlockChild
)
;
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
afterRightBlockChild
{
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
{
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
}
if
(
afterRightBlockChild
.
GetContainerAs
<
Element
>
(
)
)
{
rightBlockElement
=
*
afterRightBlockChild
.
ContainerAs
<
Element
>
(
)
;
}
else
if
(
NS_WARN_IF
(
!
afterRightBlockChild
.
GetContainerParentAs
<
Element
>
(
)
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
else
{
rightBlockElement
=
*
afterRightBlockChild
.
GetContainerParentAs
<
Element
>
(
)
;
}
auto
atStartOfRightText
=
[
&
]
(
)
-
>
EditorDOMPoint
{
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
return
EditorDOMPoint
(
)
;
}
const
EditorRawDOMPointInText
atFirstChar
=
WSRunScanner
(
Scan
:
:
All
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
.
GetInclusiveNextCharPoint
<
EditorRawDOMPointInText
>
(
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
)
;
if
(
atFirstChar
.
IsSet
(
)
&
&
atFirstChar
.
IsCharASCIISpaceOrNBSP
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atFirstChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
atFirstChar
.
To
<
EditorDOMPoint
>
(
)
;
}
return
EditorDOMPoint
(
)
;
}
(
)
;
AutoTrackDOMPoint
trackStartOfRightText
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atStartOfRightText
)
;
const
RefPtr
<
HTMLBRElement
>
invisibleBRElementAtEndOfLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementAtEndOfLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
auto
moveContentResult
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
MoveNodeResult
nsresult
>
{
if
(
NS_WARN_IF
(
aListElementTagName
.
isSome
(
)
)
)
{
return
MoveNodeResult
:
:
HandledResult
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
NS_ASSERTION
(
rightBlockElement
=
=
afterRightBlockChild
.
GetContainer
(
)
"
The
relation
is
not
guaranteed
but
assumed
"
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
EditorDOMPoint
(
rightBlockElement
afterRightBlockChild
.
Offset
(
)
)
aEditingHost
)
;
#
endif
HTMLEditor
:
:
AutoMoveOneLineHandler
lineMoverToEndOfLeftBlock
(
aLeftBlockElement
)
;
nsresult
rv
=
lineMoverToEndOfLeftBlock
.
Prepare
(
aHTMLEditor
EditorDOMPoint
(
rightBlockElement
afterRightBlockChild
.
Offset
(
)
)
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Prepare
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
MoveNodeResult
moveResult
=
MoveNodeResult
:
:
IgnoredResult
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
AutoTrackDOMMoveNodeResult
trackMoveResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
moveResult
)
;
Result
<
MoveNodeResult
nsresult
>
moveFirstLineResult
=
lineMoverToEndOfLeftBlock
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
moveFirstLineResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Run
(
)
failed
"
)
;
return
moveFirstLineResult
.
propagateErr
(
)
;
}
trackMoveResult
.
FlushAndStopTracking
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
moveResult
|
=
moveFirstLineResult
.
unwrap
(
)
;
afterRightBlockChild
.
Clear
(
)
;
return
std
:
:
move
(
moveResult
)
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
moveContentResult
.
isErr
(
)
)
)
{
return
moveContentResult
;
}
MoveNodeResult
unwrappedMoveContentResult
=
moveContentResult
.
unwrap
(
)
;
trackStartOfRightText
.
FlushAndStopTracking
(
)
;
if
(
atStartOfRightText
.
IsInTextNode
(
)
&
&
atStartOfRightText
.
IsSetAndValidInComposedDoc
(
)
&
&
atStartOfRightText
.
IsMiddleOfContainer
(
)
)
{
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
Result
<
EditorDOMPoint
nsresult
>
startOfRightTextOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
aHTMLEditor
atStartOfRightText
.
AsInText
(
)
)
;
if
(
MOZ_UNLIKELY
(
startOfRightTextOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
)
failed
"
)
;
return
startOfRightTextOrError
.
propagateErr
(
)
;
}
}
if
(
!
invisibleBRElementAtEndOfLeftBlockElement
|
|
!
invisibleBRElementAtEndOfLeftBlockElement
-
>
IsInComposedDoc
(
)
)
{
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementAtEndOfLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
unwrappedMoveContentResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
}
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
Result
<
MoveNodeResult
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aAtLeftBlockChild
nsIContent
&
aLeftContentInBlock
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
)
)
;
MOZ_ASSERT
(
&
aLeftBlockElement
=
=
&
aLeftContentInBlock
|
|
EditorUtils
:
:
IsDescendantOf
(
aLeftContentInBlock
aLeftBlockElement
)
)
;
MOZ_ASSERT
(
&
aLeftBlockElement
=
=
aAtLeftBlockChild
.
GetContainer
(
)
)
;
OwningNonNull
<
Element
>
originalLeftBlockElement
=
aLeftBlockElement
;
OwningNonNull
<
Element
>
leftBlockElement
=
aLeftBlockElement
;
EditorDOMPoint
atLeftBlockChild
(
aAtLeftBlockChild
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
)
{
EditorDOMPoint
rightBlockContainingPointInLeftBlockElement
;
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
&
rightBlockContainingPointInLeftBlockElement
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
moving
the
right
block
element
outside
the
left
block
"
"
element
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
rightBlockContainingPointInLeftBlockElement
!
=
aAtLeftBlockChild
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
changing
the
right
block
element
position
in
the
left
"
"
block
element
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
aLeftBlockElement
EditorType
:
:
HTML
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
making
the
left
block
element
non
-
editable
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
aRightBlockElement
EditorType
:
:
HTML
)
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
making
the
right
block
element
non
-
editable
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atLeftBlockChild
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
(
atLeftBlockChild
.
GetContainer
(
)
atLeftBlockChild
.
Offset
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
atLeftBlockChild
.
IsSetAndValid
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
caused
unexpected
DOM
tree
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
else
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atLeftBlockChild
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
tracker
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atLeftBlockChild
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atLeftBlockChild
)
;
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
{
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
aHTMLEditor
atLeftBlockChild
{
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
tracker
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atLeftBlockChild
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
Element
*
nearestAncestor
=
atLeftBlockChild
.
GetContainerOrContainerParentElement
(
)
)
{
leftBlockElement
=
*
nearestAncestor
;
}
else
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
auto
atStartOfRightText
=
[
&
]
(
)
-
>
EditorDOMPoint
{
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
return
EditorDOMPoint
(
)
;
}
const
EditorRawDOMPointInText
atFirstChar
=
WSRunScanner
(
Scan
:
:
All
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
.
GetInclusiveNextCharPoint
<
EditorRawDOMPointInText
>
(
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
)
;
if
(
atFirstChar
.
IsSet
(
)
&
&
atFirstChar
.
IsCharASCIISpaceOrNBSP
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atFirstChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
atFirstChar
.
To
<
EditorDOMPoint
>
(
)
;
}
return
EditorDOMPoint
(
)
;
}
(
)
;
AutoTrackDOMPoint
trackStartOfRightText
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atStartOfRightText
)
;
const
RefPtr
<
HTMLBRElement
>
invisibleBRElementBeforeLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
atLeftBlockChild
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementBeforeLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
auto
moveContentResult
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
MoveNodeResult
nsresult
>
{
if
(
aListElementTagName
.
isSome
(
)
)
{
MOZ_ASSERT
(
originalLeftBlockElement
=
=
atLeftBlockChild
.
GetContainer
(
)
"
This
is
not
guaranteed
but
assumed
"
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
rightBlockHasContent
=
aHTMLEditor
.
CanMoveChildren
(
aRightBlockElement
aLeftBlockElement
)
;
#
endif
MoveNodeResult
moveResult
=
MoveNodeResult
:
:
IgnoredResult
(
EditorDOMPoint
(
atLeftBlockChild
.
GetContainer
(
)
atLeftBlockChild
.
Offset
(
)
)
)
;
AutoTrackDOMMoveNodeResult
trackMoveResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
moveResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
Result
<
MoveNodeResult
nsresult
>
moveChildrenResult
=
aHTMLEditor
.
MoveChildrenWithTransaction
(
aRightBlockElement
moveResult
.
NextInsertionPointRef
(
)
HTMLEditor
:
:
PreserveWhiteSpaceStyle
:
:
No
HTMLEditor
:
:
RemoveIfCommentNode
:
:
Yes
)
;
if
(
MOZ_UNLIKELY
(
moveChildrenResult
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
moveChildrenResult
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
moveChildrenResult
;
}
NS_WARNING
(
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
but
ignored
"
)
;
}
else
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
rightBlockHasContent
.
isErr
(
)
)
;
if
(
rightBlockHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveChildrenResult
.
inspect
(
)
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
children
"
)
;
}
else
{
NS_ASSERTION
(
moveChildrenResult
.
inspect
(
)
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
children
"
)
;
}
#
endif
trackMoveResult
.
FlushAndStopTracking
(
)
;
moveResult
|
=
moveChildrenResult
.
unwrap
(
)
;
}
atLeftBlockChild
.
Clear
(
)
;
return
std
:
:
move
(
moveResult
)
;
}
EditorDOMPoint
pointToMoveFirstLineContent
;
if
(
&
aLeftContentInBlock
=
=
leftBlockElement
)
{
pointToMoveFirstLineContent
=
atLeftBlockChild
;
MOZ_ASSERT
(
pointToMoveFirstLineContent
.
GetContainer
(
)
=
=
&
aLeftBlockElement
)
;
}
else
{
if
(
NS_WARN_IF
(
!
aLeftContentInBlock
.
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
pointToMoveFirstLineContent
.
SetAfter
(
&
aLeftContentInBlock
)
;
if
(
NS_WARN_IF
(
!
pointToMoveFirstLineContent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
MOZ_ASSERT
(
pointToMoveFirstLineContent
.
IsSetAndValid
(
)
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
#
endif
if
(
&
aLeftContentInBlock
!
=
&
aEditingHost
)
{
Result
<
SplitNodeResult
nsresult
>
splitNodeResult
=
aHTMLEditor
.
SplitAncestorStyledInlineElementsAt
(
pointToMoveFirstLineContent
EditorInlineStyle
:
:
RemoveAllStyles
(
)
HTMLEditor
:
:
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
splitNodeResult
.
propagateErr
(
)
;
}
SplitNodeResult
unwrappedSplitNodeResult
=
splitNodeResult
.
unwrap
(
)
;
nsresult
rv
=
unwrappedSplitNodeResult
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
!
unwrappedSplitNodeResult
.
DidSplit
(
)
)
{
for
(
EditorDOMPoint
parentPoint
=
pointToMoveFirstLineContent
;
pointToMoveFirstLineContent
.
IsEndOfContainer
(
)
&
&
pointToMoveFirstLineContent
.
IsInContentNode
(
)
;
pointToMoveFirstLineContent
=
EditorDOMPoint
:
:
After
(
*
pointToMoveFirstLineContent
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
if
(
pointToMoveFirstLineContent
.
GetContainer
(
)
=
=
&
aLeftBlockElement
|
|
NS_WARN_IF
(
pointToMoveFirstLineContent
.
GetContainer
(
)
=
=
&
aEditingHost
)
)
{
break
;
}
}
if
(
NS_WARN_IF
(
!
pointToMoveFirstLineContent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
else
if
(
unwrappedSplitNodeResult
.
Handled
(
)
)
{
if
(
nsIContent
*
nextContentAtSplitPoint
=
unwrappedSplitNodeResult
.
GetNextContent
(
)
)
{
pointToMoveFirstLineContent
.
Set
(
nextContentAtSplitPoint
)
;
if
(
NS_WARN_IF
(
!
pointToMoveFirstLineContent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
else
{
pointToMoveFirstLineContent
=
unwrappedSplitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToMoveFirstLineContent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToMoveFirstLineContent
.
IsSetAndValid
(
)
)
;
}
MoveNodeResult
moveResult
=
MoveNodeResult
:
:
IgnoredResult
(
pointToMoveFirstLineContent
)
;
HTMLEditor
:
:
AutoMoveOneLineHandler
lineMoverToPoint
(
pointToMoveFirstLineContent
)
;
nsresult
rv
=
lineMoverToPoint
.
Prepare
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Prepare
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
AutoTrackDOMMoveNodeResult
trackMoveResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
moveResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
Result
<
MoveNodeResult
nsresult
>
moveFirstLineResult
=
lineMoverToPoint
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
moveFirstLineResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Run
(
)
failed
"
)
;
return
moveFirstLineResult
.
propagateErr
(
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
trackMoveResult
.
FlushAndStopTracking
(
)
;
moveResult
|
=
moveFirstLineResult
.
unwrap
(
)
;
return
std
:
:
move
(
moveResult
)
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
moveContentResult
.
isErr
(
)
)
)
{
return
moveContentResult
;
}
MoveNodeResult
unwrappedMoveContentResult
=
moveContentResult
.
unwrap
(
)
;
trackStartOfRightText
.
FlushAndStopTracking
(
)
;
if
(
atStartOfRightText
.
IsInTextNode
(
)
&
&
atStartOfRightText
.
IsSetAndValidInComposedDoc
(
)
&
&
atStartOfRightText
.
IsMiddleOfContainer
(
)
)
{
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
Result
<
EditorDOMPoint
nsresult
>
startOfRightTextOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
aHTMLEditor
atStartOfRightText
.
AsInText
(
)
)
;
if
(
MOZ_UNLIKELY
(
startOfRightTextOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
)
failed
"
)
;
return
startOfRightTextOrError
.
propagateErr
(
)
;
}
}
if
(
!
invisibleBRElementBeforeLeftBlockElement
|
|
!
invisibleBRElementBeforeLeftBlockElement
-
>
IsInComposedDoc
(
)
)
{
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
{
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementBeforeLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
unwrappedMoveContentResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
}
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
Result
<
MoveNodeResult
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
)
)
;
MOZ_ASSERT
(
!
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
)
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
aHTMLEditor
EditorDOMRange
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
EditorDOMPoint
(
&
aRightBlockElement
0
)
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
else
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
{
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
{
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
)
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
}
auto
atStartOfRightText
=
[
&
]
(
)
-
>
EditorDOMPoint
{
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
return
EditorDOMPoint
(
)
;
}
const
EditorRawDOMPointInText
atFirstChar
=
WSRunScanner
(
Scan
:
:
All
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
.
GetInclusiveNextCharPoint
<
EditorRawDOMPointInText
>
(
EditorRawDOMPoint
(
&
aRightBlockElement
0u
)
)
;
if
(
atFirstChar
.
IsSet
(
)
&
&
atFirstChar
.
IsCharASCIISpaceOrNBSP
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atFirstChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
atFirstChar
.
To
<
EditorDOMPoint
>
(
)
;
}
return
EditorDOMPoint
(
)
;
}
(
)
;
AutoTrackDOMPoint
trackStartOfRightText
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atStartOfRightText
)
;
const
RefPtr
<
HTMLBRElement
>
invisibleBRElementAtEndOfLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementAtEndOfLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
auto
moveContentResult
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
MoveNodeResult
nsresult
>
{
if
(
aListElementTagName
.
isSome
(
)
|
|
(
aLeftBlockElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aRightBlockElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
EditorUtils
:
:
GetComputedWhiteSpaceStyles
(
aLeftBlockElement
)
=
=
EditorUtils
:
:
GetComputedWhiteSpaceStyles
(
aRightBlockElement
)
)
)
{
MoveNodeResult
moveResult
=
MoveNodeResult
:
:
IgnoredResult
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
AutoTrackDOMMoveNodeResult
trackMoveResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
moveResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
EditorDOMPoint
atFirstChildOfRightNode
;
nsresult
rv
=
aHTMLEditor
.
JoinNearestEditableNodesWithTransaction
(
aLeftBlockElement
aRightBlockElement
&
atFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
if
(
aListElementTagName
.
isSome
(
)
&
&
atFirstChildOfRightNode
.
IsSet
(
)
)
{
Result
<
CreateElementResult
nsresult
>
convertListTypeResult
=
aHTMLEditor
.
ChangeListElementType
(
aRightBlockElement
MOZ_KnownLive
(
*
aListElementTagName
.
ref
(
)
)
*
nsGkAtoms
:
:
li
)
;
if
(
MOZ_UNLIKELY
(
convertListTypeResult
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
convertListTypeResult
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
but
ignored
"
)
;
}
else
{
convertListTypeResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
trackMoveResult
.
FlushAndStopTracking
(
)
;
moveResult
|
=
MoveNodeResult
:
:
HandledResult
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
return
std
:
:
move
(
moveResult
)
;
}
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
#
endif
MoveNodeResult
moveResult
=
MoveNodeResult
:
:
IgnoredResult
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
HTMLEditor
:
:
AutoMoveOneLineHandler
lineMoverToEndOfLeftBlock
(
aLeftBlockElement
)
;
nsresult
rv
=
lineMoverToEndOfLeftBlock
.
Prepare
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Prepare
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
AutoTrackDOMMoveNodeResult
trackMoveResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
moveResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
Result
<
MoveNodeResult
nsresult
>
moveFirstLineResult
=
lineMoverToEndOfLeftBlock
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
moveFirstLineResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
Run
(
)
failed
"
)
;
return
moveFirstLineResult
.
propagateErr
(
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveFirstLineResult
.
inspect
(
)
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
trackMoveResult
.
FlushAndStopTracking
(
)
;
moveResult
|
=
moveFirstLineResult
.
unwrap
(
)
;
return
std
:
:
move
(
moveResult
)
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
moveContentResult
.
isErr
(
)
)
)
{
return
moveContentResult
;
}
MoveNodeResult
unwrappedMoveContentResult
=
moveContentResult
.
unwrap
(
)
;
trackStartOfRightText
.
FlushAndStopTracking
(
)
;
if
(
atStartOfRightText
.
IsInTextNode
(
)
&
&
atStartOfRightText
.
IsSetAndValidInComposedDoc
(
)
&
&
atStartOfRightText
.
IsMiddleOfContainer
(
)
)
{
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
Result
<
EditorDOMPoint
nsresult
>
startOfRightTextOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
aHTMLEditor
atStartOfRightText
.
AsInText
(
)
)
;
if
(
MOZ_UNLIKELY
(
startOfRightTextOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
)
failed
"
)
;
return
startOfRightTextOrError
.
propagateErr
(
)
;
}
}
if
(
!
invisibleBRElementAtEndOfLeftBlockElement
|
|
!
invisibleBRElementAtEndOfLeftBlockElement
-
>
IsInComposedDoc
(
)
)
{
unwrappedMoveContentResult
.
ForceToMarkAsHandled
(
)
;
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
{
AutoTrackDOMMoveNodeResult
trackMoveContentResult
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
unwrappedMoveContentResult
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementAtEndOfLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
unwrappedMoveContentResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
}
return
std
:
:
move
(
unwrappedMoveContentResult
)
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPoint
.
IsEndOfContainer
(
)
)
;
if
(
!
aPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
return
aPoint
.
To
<
EditorDOMPoint
>
(
)
;
}
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedWhiteSpaces
=
aHTMLEditor
.
GetNormalizedStringAt
(
aPoint
)
.
GetMinimizedData
(
*
aPoint
.
ContainerAs
<
Text
>
(
)
)
;
if
(
!
normalizedWhiteSpaces
.
ReplaceLength
(
)
)
{
return
aPoint
.
To
<
EditorDOMPoint
>
(
)
;
}
const
OwningNonNull
<
Text
>
textNode
=
*
aPoint
.
ContainerAs
<
Text
>
(
)
;
Result
<
InsertTextResult
nsresult
>
insertTextResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
textNode
normalizedWhiteSpaces
)
;
if
(
MOZ_UNLIKELY
(
insertTextResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
insertTextResultOrError
.
propagateErr
(
)
;
}
return
insertTextResultOrError
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
NormalizeOptions
aOptions
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
aPoint
.
IsInTextNode
(
)
!
aPoint
.
IsMiddleOfContainer
(
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
NormalizeOption
:
:
HandleOnlyFollowingWhiteSpaces
)
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
const
RefPtr
<
Element
>
colsetBlockElement
=
aPoint
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
nullptr
;
EditorDOMPoint
afterLastVisibleThing
(
aPoint
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
unnecessaryContents
;
for
(
nsIContent
*
previousContent
=
aPoint
.
IsInTextNode
(
)
&
&
aPoint
.
IsEndOfContainer
(
)
?
aPoint
.
ContainerAs
<
Text
>
(
)
:
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
EditorRawDOMPoint
(
previousContent
)
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
break
;
}
const
RefPtr
<
Text
>
precedingTextNode
=
Text
:
:
FromNode
(
previousContent
)
;
if
(
!
precedingTextNode
&
&
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
previousContent
)
)
{
afterLastVisibleThing
.
SetAfter
(
previousContent
)
;
break
;
}
if
(
!
precedingTextNode
|
|
!
precedingTextNode
-
>
TextDataLength
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
previousContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
previousContent
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
const
auto
atLastChar
=
EditorRawDOMPointInText
:
:
AtLastContentOf
(
*
precedingTextNode
)
;
if
(
!
atLastChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
afterLastVisibleThing
.
SetAfter
(
precedingTextNode
)
;
break
;
}
if
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
)
&
&
atLastChar
.
IsCharNBSP
(
)
)
{
afterLastVisibleThing
.
SetAfter
(
precedingTextNode
)
;
break
;
}
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
replaceData
=
aHTMLEditor
.
GetNormalizedStringAt
(
atLastChar
.
AsInText
(
)
)
.
GetMinimizedData
(
*
precedingTextNode
)
;
if
(
!
replaceData
.
ReplaceLength
(
)
)
{
afterLastVisibleThing
.
SetAfter
(
precedingTextNode
)
;
break
;
}
if
(
replaceData
.
ReplaceLength
(
)
=
=
precedingTextNode
-
>
TextDataLength
(
)
&
&
replaceData
.
mNormalizedString
.
IsEmpty
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
precedingTextNode
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
precedingTextNode
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
Result
<
InsertTextResult
nsresult
>
replaceWhiteSpacesResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
*
precedingTextNode
replaceData
)
;
if
(
MOZ_UNLIKELY
(
replaceWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
InsertTextResult
replaceWhiteSpacesResult
=
replaceWhiteSpacesResultOrError
.
unwrap
(
)
;
replaceWhiteSpacesResult
.
IgnoreCaretPointSuggestion
(
)
;
afterLastVisibleThing
=
replaceWhiteSpacesResult
.
EndOfInsertedTextRef
(
)
;
}
AutoTrackDOMPoint
trackAfterLastVisibleThing
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
afterLastVisibleThing
)
;
for
(
const
auto
&
contentToDelete
:
unnecessaryContents
)
{
if
(
MOZ_UNLIKELY
(
!
contentToDelete
-
>
IsInComposedDoc
(
)
)
)
{
continue
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
contentToDelete
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
trackAfterLastVisibleThing
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
afterLastVisibleThing
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
std
:
:
move
(
afterLastVisibleThing
)
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
NormalizeOptions
aOptions
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
aPoint
.
IsInTextNode
(
)
!
aPoint
.
IsMiddleOfContainer
(
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
NormalizeOption
:
:
HandleOnlyPrecedingWhiteSpaces
)
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
const
RefPtr
<
Element
>
colsetBlockElement
=
aPoint
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
nullptr
;
EditorDOMPoint
atFirstVisibleThing
(
aPoint
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
unnecessaryContents
;
for
(
nsIContent
*
nextContent
=
aPoint
.
IsInTextNode
(
)
&
&
aPoint
.
IsStartOfContainer
(
)
?
aPoint
.
ContainerAs
<
Text
>
(
)
:
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
EditorRawDOMPoint
:
:
After
(
*
nextContent
)
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
break
;
}
const
RefPtr
<
Text
>
followingTextNode
=
Text
:
:
FromNode
(
nextContent
)
;
if
(
!
followingTextNode
&
&
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
nextContent
)
)
{
atFirstVisibleThing
.
Set
(
nextContent
)
;
break
;
}
if
(
!
followingTextNode
|
|
!
followingTextNode
-
>
TextDataLength
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
nextContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
nextContent
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
const
auto
atFirstChar
=
EditorRawDOMPointInText
(
followingTextNode
0u
)
;
if
(
!
atFirstChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
atFirstVisibleThing
.
Set
(
followingTextNode
)
;
break
;
}
if
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
)
&
&
atFirstChar
.
IsCharNBSP
(
)
)
{
atFirstVisibleThing
.
Set
(
followingTextNode
)
;
break
;
}
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
replaceData
=
aHTMLEditor
.
GetNormalizedStringAt
(
atFirstChar
.
AsInText
(
)
)
.
GetMinimizedData
(
*
followingTextNode
)
;
if
(
!
replaceData
.
ReplaceLength
(
)
)
{
atFirstVisibleThing
.
Set
(
followingTextNode
)
;
break
;
}
if
(
replaceData
.
ReplaceLength
(
)
=
=
followingTextNode
-
>
TextDataLength
(
)
&
&
replaceData
.
mNormalizedString
.
IsEmpty
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
followingTextNode
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
followingTextNode
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
Result
<
InsertTextResult
nsresult
>
replaceWhiteSpacesResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
*
followingTextNode
replaceData
)
;
if
(
MOZ_UNLIKELY
(
replaceWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
replaceWhiteSpacesResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
atFirstVisibleThing
.
Set
(
followingTextNode
0u
)
;
break
;
}
AutoTrackDOMPoint
trackAtFirstVisibleThing
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atFirstVisibleThing
)
;
for
(
const
auto
&
contentToDelete
:
unnecessaryContents
)
{
if
(
MOZ_UNLIKELY
(
!
contentToDelete
-
>
IsInComposedDoc
(
)
)
)
{
continue
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
contentToDelete
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
trackAtFirstVisibleThing
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atFirstVisibleThing
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
std
:
:
move
(
atFirstVisibleThing
)
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aPointToSplit
NormalizeOptions
aOptions
)
{
MOZ_ASSERT
(
aPointToSplit
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPointToSplit
.
ContainerAs
<
Text
>
(
)
)
)
{
return
aPointToSplit
.
To
<
EditorDOMPoint
>
(
)
;
}
const
OwningNonNull
<
Text
>
textNode
=
*
aPointToSplit
.
ContainerAs
<
Text
>
(
)
;
if
(
!
textNode
-
>
TextDataLength
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
textNode
)
)
{
return
EditorDOMPoint
(
)
;
}
const
nsCOMPtr
<
nsINode
>
parentNode
=
textNode
-
>
GetParentNode
(
)
;
const
nsCOMPtr
<
nsIContent
>
nextSibling
=
textNode
-
>
GetNextSibling
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parentNode
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
EditorDOMPoint
(
nextSibling
)
;
}
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
replacePrecedingWhiteSpacesData
=
aPointToSplit
.
IsStartOfContainer
(
)
|
|
aOptions
.
contains
(
NormalizeOption
:
:
HandleOnlyFollowingWhiteSpaces
)
|
|
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
)
&
&
aPointToSplit
.
IsPreviousCharNBSP
(
)
)
?
HTMLEditor
:
:
ReplaceWhiteSpacesData
(
)
:
aHTMLEditor
.
GetPrecedingNormalizedStringToSplitAt
(
aPointToSplit
)
;
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
replaceFollowingWhiteSpaceData
=
aPointToSplit
.
IsEndOfContainer
(
)
|
|
aOptions
.
contains
(
NormalizeOption
:
:
HandleOnlyPrecedingWhiteSpaces
)
|
|
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
)
&
&
aPointToSplit
.
IsCharNBSP
(
)
)
?
HTMLEditor
:
:
ReplaceWhiteSpacesData
(
)
:
aHTMLEditor
.
GetFollowingNormalizedStringToSplitAt
(
aPointToSplit
)
;
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
replaceWhiteSpacesData
=
(
replacePrecedingWhiteSpacesData
+
replaceFollowingWhiteSpaceData
)
.
GetMinimizedData
(
*
textNode
)
;
if
(
!
replaceWhiteSpacesData
.
ReplaceLength
(
)
)
{
return
aPointToSplit
.
To
<
EditorDOMPoint
>
(
)
;
}
if
(
replaceWhiteSpacesData
.
mNormalizedString
.
IsEmpty
(
)
&
&
replaceWhiteSpacesData
.
ReplaceLength
(
)
=
=
textNode
-
>
TextDataLength
(
)
)
{
const
nsCOMPtr
<
nsINode
>
parentNode
=
textNode
-
>
GetParentNode
(
)
;
const
nsCOMPtr
<
nsIContent
>
nextSibling
=
textNode
-
>
GetNextSibling
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
textNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parentNode
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
EditorDOMPoint
(
nextSibling
)
;
}
Result
<
InsertTextResult
nsresult
>
replaceWhiteSpacesResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
textNode
replaceWhiteSpacesData
)
;
if
(
MOZ_UNLIKELY
(
replaceWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
replaceWhiteSpacesResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
const
uint32_t
offsetToSplit
=
aPointToSplit
.
Offset
(
)
-
replacePrecedingWhiteSpacesData
.
ReplaceLength
(
)
+
replacePrecedingWhiteSpacesData
.
mNormalizedString
.
Length
(
)
;
if
(
NS_WARN_IF
(
textNode
-
>
TextDataLength
(
)
<
offsetToSplit
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
EditorDOMPoint
(
textNode
offsetToSplit
)
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
NormalizeOptions
aOptions
)
{
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
if
(
!
aPointToSplit
.
IsInComposedDoc
(
)
)
{
return
aPointToSplit
;
}
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
{
AutoTrackDOMPoint
trackPointToSplit
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
pointToSplit
)
;
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
)
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
pointToSplit
.
IsInTextNode
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
aHTMLEditor
pointToSplit
.
AsInText
(
)
aOptions
)
;
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
)
"
"
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
.
To
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
pointToSplit
.
IsMiddleOfContainer
(
)
)
{
return
pointToSplit
;
}
}
const
RefPtr
<
Element
>
closestBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
AutoTArray
<
OwningNonNull
<
Text
>
3
>
precedingTextNodes
followingTextNodes
;
if
(
!
pointToSplit
.
IsInTextNode
(
)
|
|
pointToSplit
.
IsStartOfContainer
(
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
pointToSplit
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
)
{
if
(
auto
*
const
textNode
=
Text
:
:
FromNode
(
previousContent
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
textNode
)
&
&
textNode
-
>
TextDataLength
(
)
)
{
break
;
}
if
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
)
&
&
textNode
-
>
TextFragment
(
)
.
SafeLastChar
(
)
=
=
HTMLEditUtils
:
:
kNBSP
)
{
break
;
}
precedingTextNodes
.
AppendElement
(
*
textNode
)
;
if
(
textNode
-
>
TextIsOnlyWhitespace
(
)
)
{
continue
;
}
break
;
}
if
(
auto
*
const
element
=
Element
:
:
FromNode
(
previousContent
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
element
)
)
{
break
;
}
}
}
}
if
(
!
pointToSplit
.
IsInTextNode
(
)
|
|
pointToSplit
.
IsEndOfContainer
(
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
pointToSplit
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
nextContent
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
)
{
if
(
auto
*
const
textNode
=
Text
:
:
FromNode
(
nextContent
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
textNode
)
&
&
textNode
-
>
TextDataLength
(
)
)
{
break
;
}
if
(
aOptions
.
contains
(
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
)
&
&
textNode
-
>
TextFragment
(
)
.
SafeFirstChar
(
)
=
=
HTMLEditUtils
:
:
kNBSP
)
{
break
;
}
followingTextNodes
.
AppendElement
(
*
textNode
)
;
if
(
textNode
-
>
TextIsOnlyWhitespace
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
textNode
)
)
{
continue
;
}
break
;
}
if
(
auto
*
const
element
=
Element
:
:
FromNode
(
nextContent
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
element
)
)
{
break
;
}
}
}
}
AutoTrackDOMPoint
trackPointToSplit
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
for
(
const
auto
&
textNode
:
precedingTextNodes
)
{
Result
<
EditorDOMPoint
nsresult
>
normalizeWhiteSpacesResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
aHTMLEditor
EditorDOMPointInText
:
:
AtEndOf
(
textNode
)
aOptions
)
;
if
(
MOZ_UNLIKELY
(
normalizeWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
)
"
"
failed
"
)
;
return
normalizeWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
if
(
normalizeWhiteSpacesResultOrError
.
inspect
(
)
.
IsInTextNode
(
)
&
&
!
normalizeWhiteSpacesResultOrError
.
inspect
(
)
.
IsStartOfContainer
(
)
)
{
break
;
}
}
for
(
const
auto
&
textNode
:
followingTextNodes
)
{
Result
<
EditorDOMPoint
nsresult
>
normalizeWhiteSpacesResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
aHTMLEditor
EditorDOMPointInText
(
textNode
0u
)
aOptions
)
;
if
(
MOZ_UNLIKELY
(
normalizeWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
)
"
"
failed
"
)
;
return
normalizeWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
if
(
normalizeWhiteSpacesResultOrError
.
inspect
(
)
.
IsInTextNode
(
)
&
&
!
normalizeWhiteSpacesResultOrError
.
inspect
(
)
.
IsEndOfContainer
(
)
)
{
break
;
}
}
trackPointToSplit
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
std
:
:
move
(
pointToSplit
)
;
}
Result
<
EditorDOMRange
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeSurroundingWhiteSpacesToJoin
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRangeToDelete
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
!
aRangeToDelete
.
Collapsed
(
)
)
;
if
(
aRangeToDelete
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
aRangeToDelete
.
InSameContainer
(
)
)
{
const
RefPtr
<
Text
>
textNode
=
aRangeToDelete
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
;
Result
<
EditorDOMRange
nsresult
>
rangeToDeleteOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeSurroundingWhiteSpacesToDeleteCharacters
(
aHTMLEditor
*
textNode
aRangeToDelete
.
StartRef
(
)
.
Offset
(
)
aRangeToDelete
.
EndRef
(
)
.
Offset
(
)
-
aRangeToDelete
.
StartRef
(
)
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
rangeToDeleteOrError
.
isOk
(
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
NormalizeSurroundingWhiteSpacesToDeleteCharacters
(
)
failed
"
)
;
return
rangeToDeleteOrError
;
}
EditorDOMRange
rangeToDelete
(
aRangeToDelete
)
;
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
const
WSScanResult
nextThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
Scan
:
:
All
rangeToDelete
.
StartRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextThing
.
ReachedLineBoundary
(
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
aHTMLEditor
nextThing
.
PointAtReachedContent
<
EditorDOMPoint
>
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
}
else
{
Result
<
EditorDOMPoint
nsresult
>
deleteInvisibleLeadingWhiteSpaceResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
rangeToDelete
.
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
deleteInvisibleLeadingWhiteSpaceResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
)
"
"
failed
"
)
;
return
deleteInvisibleLeadingWhiteSpaceResultOrError
.
propagateErr
(
)
;
}
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
rangeToDelete
.
IsPositionedAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
rangeToDelete
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
rangeToDelete
.
EndRef
(
)
.
IsMiddleOfContainer
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
aHTMLEditor
rangeToDelete
.
EndRef
(
)
.
AsInText
(
)
{
NormalizeOption
:
:
HandleOnlyFollowingWhiteSpaces
}
)
;
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
"
"
)
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
EditorDOMPoint
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
;
if
(
pointToSplit
.
IsSet
(
)
&
&
pointToSplit
!
=
rangeToDelete
.
EndRef
(
)
)
{
MOZ_ASSERT
(
rangeToDelete
.
StartRef
(
)
.
EqualsOrIsBefore
(
pointToSplit
)
)
;
rangeToDelete
.
SetEnd
(
std
:
:
move
(
pointToSplit
)
)
;
}
}
else
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
rangeToDelete
.
EndRef
(
)
{
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
rangeToDelete
.
IsPositionedAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
MOZ_UNLIKELY
(
rangeToDelete
.
Collapsed
(
)
)
)
{
return
rangeToDelete
;
}
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
Result
<
EditorDOMPoint
nsresult
>
deleteInvisibleTrailingWhiteSpaceResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
rangeToDelete
.
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
deleteInvisibleTrailingWhiteSpaceResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
)
failed
"
)
;
return
deleteInvisibleTrailingWhiteSpaceResultOrError
.
propagateErr
(
)
;
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
rangeToDelete
.
IsPositionedAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
rangeToDelete
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
rangeToDelete
.
StartRef
(
)
.
IsMiddleOfContainer
(
)
)
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
aHTMLEditor
rangeToDelete
.
StartRef
(
)
.
AsInText
(
)
{
NormalizeOption
:
:
HandleOnlyPrecedingWhiteSpaces
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitTextNodeAt
(
)
"
"
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
EditorDOMPoint
pointToSplit
=
afterLastVisibleThingOrError
.
unwrap
(
)
;
if
(
pointToSplit
.
IsSet
(
)
&
&
pointToSplit
!
=
rangeToDelete
.
StartRef
(
)
)
{
MOZ_ASSERT
(
pointToSplit
.
EqualsOrIsBefore
(
rangeToDelete
.
EndRef
(
)
)
)
;
rangeToDelete
.
SetStart
(
std
:
:
move
(
pointToSplit
)
)
;
}
}
return
rangeToDelete
;
}
Result
<
EditorDOMRange
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
NormalizeSurroundingWhiteSpacesToDeleteCharacters
(
HTMLEditor
&
aHTMLEditor
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aOffset
<
=
aTextNode
.
TextDataLength
(
)
)
;
MOZ_ASSERT
(
aOffset
+
aLength
<
=
aTextNode
.
TextDataLength
(
)
)
;
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedWhiteSpacesData
=
aHTMLEditor
.
GetSurroundingNormalizedStringToDelete
(
aTextNode
aOffset
aLength
)
;
EditorDOMRange
rangeToDelete
(
EditorDOMPoint
(
&
aTextNode
aOffset
)
EditorDOMPoint
(
&
aTextNode
aOffset
+
aLength
)
)
;
if
(
!
normalizedWhiteSpacesData
.
ReplaceLength
(
)
)
{
return
rangeToDelete
;
}
MOZ_ASSERT
(
normalizedWhiteSpacesData
.
mNewOffsetAfterReplace
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
normalizedWhiteSpacesData
.
mNewOffsetAfterReplace
>
=
normalizedWhiteSpacesData
.
mReplaceStartOffset
)
;
MOZ_ASSERT
(
normalizedWhiteSpacesData
.
mNewOffsetAfterReplace
<
=
normalizedWhiteSpacesData
.
mReplaceEndOffset
)
;
#
ifdef
DEBUG
{
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedPrecedingWhiteSpacesData
=
normalizedWhiteSpacesData
.
PreviousDataOfNewOffset
(
aOffset
)
;
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedFollowingWhiteSpacesData
=
normalizedWhiteSpacesData
.
NextDataOfNewOffset
(
aOffset
+
aLength
)
;
MOZ_ASSERT
(
normalizedPrecedingWhiteSpacesData
.
ReplaceLength
(
)
+
aLength
+
normalizedFollowingWhiteSpacesData
.
ReplaceLength
(
)
=
=
normalizedWhiteSpacesData
.
ReplaceLength
(
)
)
;
MOZ_ASSERT
(
normalizedPrecedingWhiteSpacesData
.
mNormalizedString
.
Length
(
)
+
normalizedFollowingWhiteSpacesData
.
mNormalizedString
.
Length
(
)
=
=
normalizedWhiteSpacesData
.
mNormalizedString
.
Length
(
)
)
;
}
#
endif
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedPrecedingWhiteSpacesData
=
normalizedWhiteSpacesData
.
PreviousDataOfNewOffset
(
aOffset
)
.
GetMinimizedData
(
aTextNode
)
;
const
HTMLEditor
:
:
ReplaceWhiteSpacesData
normalizedFollowingWhiteSpacesData
=
normalizedWhiteSpacesData
.
NextDataOfNewOffset
(
aOffset
+
aLength
)
.
GetMinimizedData
(
aTextNode
)
;
if
(
normalizedFollowingWhiteSpacesData
.
ReplaceLength
(
)
)
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
Result
<
InsertTextResult
nsresult
>
replaceFollowingWhiteSpacesResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
aTextNode
normalizedFollowingWhiteSpacesData
)
;
if
(
MOZ_UNLIKELY
(
replaceFollowingWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceFollowingWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
rangeToDelete
.
IsPositioned
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
normalizedPrecedingWhiteSpacesData
.
ReplaceLength
(
)
)
{
AutoTrackDOMRange
trackRangeToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
rangeToDelete
)
;
Result
<
InsertTextResult
nsresult
>
replacePrecedingWhiteSpacesResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
aTextNode
normalizedPrecedingWhiteSpacesData
)
;
if
(
MOZ_UNLIKELY
(
replacePrecedingWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replacePrecedingWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
trackRangeToDelete
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
rangeToDelete
.
IsPositioned
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
return
std
:
:
move
(
rangeToDelete
)
;
}
Result
<
CreateLineBreakResult
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
InsertLineBreak
(
LineBreakType
aLineBreakType
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToInsert
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
const
TextFragmentData
textFragmentDataAtInsertionPoint
(
Scan
:
:
EditableNodes
aPointToInsert
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtInsertionPoint
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRange
invisibleLeadingWhiteSpaceRangeOfNewLine
=
textFragmentDataAtInsertionPoint
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
EditorDOMRange
invisibleTrailingWhiteSpaceRangeOfCurrentLine
=
textFragmentDataAtInsertionPoint
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpaces
=
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
|
|
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
?
Some
(
textFragmentDataAtInsertionPoint
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWhiteSpaces
.
isSome
(
)
&
&
visibleWhiteSpaces
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpaces
.
ref
(
)
.
ComparePoint
(
aPointToInsert
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
atNBSPReplaceableWithSP
;
if
(
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
&
&
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
)
{
atNBSPReplaceableWithSP
=
textFragmentDataAtInsertionPoint
.
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
pointToInsert
)
.
To
<
EditorDOMPoint
>
(
)
;
}
{
if
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
=
=
pointToInsert
)
;
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackEndOfLineNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeOfNewLine
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
else
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
const
auto
atNextCharOfInsertionPoint
=
textFragmentDataAtInsertionPoint
.
GetInclusiveNextCharPoint
<
EditorDOMPointInText
>
(
pointToInsert
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atNextCharOfInsertionPoint
.
IsSet
(
)
&
&
!
atNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
&
&
atNextCharOfInsertionPoint
.
IsCharCollapsibleASCIISpace
(
)
)
{
const
auto
atPreviousCharOfNextCharOfInsertionPoint
=
textFragmentDataAtInsertionPoint
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atNextCharOfInsertionPoint
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsSet
(
)
|
|
atPreviousCharOfNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackEndOfLineNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeOfNewLine
)
;
const
auto
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtInsertionPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointInText
>
(
atNextCharOfInsertionPoint
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atNextCharOfInsertionPoint
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
ReplaceTextAndRemoveEmptyTextNodes
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
}
if
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
=
=
pointToInsert
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Clear
(
)
;
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
else
if
(
atNBSPReplaceableWithSP
.
IsInTextNode
(
)
)
{
const
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
atNBSPReplaceableWithSP
.
AsInText
(
)
;
if
(
!
atNBSPReplacedWithASCIIWhiteSpace
.
IsEndOfContainer
(
)
&
&
atNBSPReplacedWithASCIIWhiteSpace
.
IsCharNBSP
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
Result
<
InsertTextResult
nsresult
>
replaceTextResult
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
failed
"
)
;
return
replaceTextResult
.
propagateErr
(
)
;
}
replaceTextResult
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Clear
(
)
;
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
}
}
else
{
Result
<
EditorDOMPoint
nsresult
>
normalizeSurroundingWhiteSpacesResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
aHTMLEditor
aPointToInsert
{
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
}
)
;
if
(
MOZ_UNLIKELY
(
normalizeSurroundingWhiteSpacesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
)
failed
"
)
;
return
normalizeSurroundingWhiteSpacesResultOrError
.
propagateErr
(
)
;
}
pointToInsert
=
normalizeSurroundingWhiteSpacesResultOrError
.
unwrap
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
aHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
aLineBreakType
pointToInsert
)
;
NS_WARNING_ASSERTION
(
insertBRElementResultOrError
.
isOk
(
)
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
aLineBreakType
eNone
)
failed
"
)
;
return
insertBRElementResultOrError
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInContentNode
(
)
)
;
const
RefPtr
<
Element
>
colsetBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
EditorDOMPoint
atFirstInvisibleWhiteSpace
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
unnecessaryContents
;
for
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
EditorRawDOMPoint
:
:
After
(
*
nextContent
)
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
break
;
}
const
RefPtr
<
Text
>
followingTextNode
=
Text
:
:
FromNode
(
nextContent
)
;
if
(
!
followingTextNode
&
&
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
nextContent
)
)
{
break
;
}
if
(
!
followingTextNode
|
|
!
followingTextNode
-
>
TextDataLength
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
nextContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
nextContent
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
const
EditorRawDOMPointInText
atFirstChar
(
followingTextNode
0u
)
;
if
(
!
atFirstChar
.
IsCharCollapsibleASCIISpace
(
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
followingTextNode
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
followingTextNode
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
followingTextNode
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
Result
<
EditorDOMPoint
nsresult
>
startOfTextOrError
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
(
followingTextNode
0u
)
)
;
if
(
MOZ_UNLIKELY
(
startOfTextOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
startOfTextOrError
.
unwrapErr
(
)
;
}
break
;
}
for
(
const
auto
&
contentToDelete
:
unnecessaryContents
)
{
if
(
MOZ_UNLIKELY
(
!
contentToDelete
-
>
IsInComposedDoc
(
)
)
)
{
continue
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
contentToDelete
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInContentNode
(
)
)
;
const
RefPtr
<
Element
>
colsetBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
EditorDOMPoint
atFirstInvisibleWhiteSpace
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
unnecessaryContents
;
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
EditorRawDOMPoint
(
previousContent
)
{
HTMLEditUtils
:
:
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
colsetBlockElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
break
;
}
const
RefPtr
<
Text
>
precedingTextNode
=
Text
:
:
FromNode
(
previousContent
)
;
if
(
!
precedingTextNode
&
&
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
previousContent
)
)
{
break
;
}
if
(
!
precedingTextNode
|
|
!
precedingTextNode
-
>
TextDataLength
(
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
previousContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
previousContent
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
const
auto
atLastChar
=
EditorRawDOMPointInText
:
:
AtLastContentOf
(
*
precedingTextNode
)
;
if
(
!
atLastChar
.
IsCharCollapsibleASCIISpace
(
)
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
precedingTextNode
)
)
{
nsIContent
*
emptyInlineContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
precedingTextNode
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
emptyInlineContent
)
{
emptyInlineContent
=
precedingTextNode
;
}
unnecessaryContents
.
AppendElement
(
*
emptyInlineContent
)
;
continue
;
}
Result
<
EditorDOMPoint
nsresult
>
endOfTextOrResult
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
*
precedingTextNode
)
)
;
if
(
MOZ_UNLIKELY
(
endOfTextOrResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
endOfTextOrResult
.
unwrapErr
(
)
;
}
break
;
}
for
(
const
auto
&
contentToDelete
:
Reversed
(
unnecessaryContents
)
)
{
if
(
MOZ_UNLIKELY
(
!
contentToDelete
-
>
IsInComposedDoc
(
)
)
)
{
continue
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
contentToDelete
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
aPoint
.
IsInTextNode
(
)
&
&
(
!
aPoint
.
IsStartOfContainer
(
)
&
&
!
aPoint
.
IsPreviousCharASCIISpace
(
)
)
&
&
(
!
aPoint
.
IsEndOfContainer
(
)
&
&
!
aPoint
.
IsCharCollapsibleASCIISpace
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
const
Element
*
const
closestBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
!
closestBlockElement
)
)
{
return
EditorDOMPoint
(
)
;
}
const
TextFragmentData
textFragmentDataForLeadingWhiteSpaces
(
Scan
:
:
EditableNodes
aPoint
.
IsStartOfContainer
(
)
&
&
aPoint
.
GetContainer
(
)
=
=
closestBlockElement
?
aPoint
:
aPoint
.
PreviousPointOrParentPoint
<
EditorDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataForLeadingWhiteSpaces
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
{
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
textFragmentDataForLeadingWhiteSpaces
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
leadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
leadingWhiteSpaceRange
.
Collapsed
(
)
)
{
EditorDOMPoint
endOfLeadingWhiteSpaces
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
AutoTrackDOMPoint
trackEndOfLeadingWhiteSpaces
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
endOfLeadingWhiteSpaces
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
leadingWhiteSpaceRange
.
StartRef
(
)
leadingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
"
"
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
if
(
!
leadingWhiteSpaceRange
.
InSameContainer
(
)
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
IsInComposedDoc
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
IsInComposedDoc
(
)
&
&
!
leadingWhiteSpaceRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextDataLength
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
leadingWhiteSpaceRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
trackEndOfLeadingWhiteSpaces
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
endOfLeadingWhiteSpaces
.
IsSetAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
endOfLeadingWhiteSpaces
;
}
}
const
TextFragmentData
textFragmentData
=
textFragmentDataForLeadingWhiteSpaces
.
ScanStartRef
(
)
=
=
aPoint
?
textFragmentDataForLeadingWhiteSpaces
:
TextFragmentData
(
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
closestBlockElement
)
;
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
textFragmentData
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
trailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
trailingWhiteSpaceRange
.
Collapsed
(
)
)
{
EditorDOMPoint
startOfTrailingWhiteSpaces
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
AutoTrackDOMPoint
trackStartOfTrailingWhiteSpaces
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startOfTrailingWhiteSpaces
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
trailingWhiteSpaceRange
.
StartRef
(
)
trailingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
"
"
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
if
(
!
trailingWhiteSpaceRange
.
InSameContainer
(
)
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
IsInComposedDoc
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
IsInComposedDoc
(
)
&
&
!
trailingWhiteSpaceRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextDataLength
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
trailingWhiteSpaceRange
.
EndRef
(
)
.
ContainerAs
<
Text
>
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
trackStartOfTrailingWhiteSpaces
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
startOfTrailingWhiteSpaces
.
IsSetAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
startOfTrailingWhiteSpaces
;
}
const
auto
atCollapsibleASCIISpace
=
[
&
]
(
)
-
>
EditorDOMPointInText
{
const
auto
point
=
textFragmentData
.
GetInclusiveNextCharPoint
<
EditorDOMPointInText
>
(
textFragmentData
.
ScanStartRef
(
)
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
point
.
IsSet
(
)
&
&
!
point
.
IsEndOfContainer
(
)
&
&
point
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
point
;
}
const
auto
prevPoint
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
textFragmentData
.
ScanStartRef
(
)
IgnoreNonEditableNodes
:
:
Yes
)
;
return
prevPoint
.
IsSet
(
)
&
&
!
prevPoint
.
IsEndOfContainer
(
)
&
&
prevPoint
.
IsCharCollapsibleASCIISpace
(
)
?
prevPoint
:
EditorDOMPointInText
(
)
;
}
(
)
;
if
(
!
atCollapsibleASCIISpace
.
IsSet
(
)
)
{
return
EditorDOMPoint
(
)
;
}
const
auto
firstCollapsibleASCIISpacePoint
=
textFragmentData
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointInText
>
(
atCollapsibleASCIISpace
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
No
)
;
const
auto
endOfCollapsibleASCIISpacePoint
=
textFragmentData
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointInText
>
(
atCollapsibleASCIISpace
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
No
)
;
if
(
firstCollapsibleASCIISpacePoint
.
NextPoint
(
)
=
=
endOfCollapsibleASCIISpacePoint
)
{
return
EditorDOMPoint
(
)
;
}
Result
<
CaretPoint
nsresult
>
deleteTextResultOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
firstCollapsibleASCIISpacePoint
.
NextPoint
(
)
endOfCollapsibleASCIISpacePoint
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
Remove
)
;
if
(
MOZ_UNLIKELY
(
deleteTextResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
deleteTextResultOrError
.
propagateErr
(
)
;
}
return
deleteTextResultOrError
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
;
}
Result
<
InsertTextResult
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
InsertTextOrInsertOrUpdateCompositionString
(
HTMLEditor
&
aHTMLEditor
const
nsAString
&
aStringToInsert
const
EditorDOMRange
&
aRangeToBeReplaced
InsertTextTo
aInsertTextTo
InsertTextFor
aPurpose
)
{
MOZ_ASSERT
(
aRangeToBeReplaced
.
StartRef
(
)
.
IsInContentNode
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorBase
:
:
InsertingTextForExtantComposition
(
aPurpose
)
aRangeToBeReplaced
.
Collapsed
(
)
)
;
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aRangeToBeReplaced
.
Collapsed
(
)
)
;
return
InsertTextResult
(
)
;
}
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
const
TextFragmentData
textFragmentDataAtStart
(
Scan
:
:
EditableNodes
aRangeToBeReplaced
.
StartRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
isInsertionPointEqualsOrIsBeforeStartOfText
=
aRangeToBeReplaced
.
StartRef
(
)
.
EqualsOrIsBefore
(
textFragmentDataAtStart
.
StartRef
(
)
)
;
TextFragmentData
textFragmentDataAtEnd
=
aRangeToBeReplaced
.
Collapsed
(
)
?
textFragmentDataAtStart
:
TextFragmentData
(
Scan
:
:
EditableNodes
aRangeToBeReplaced
.
EndRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
isInsertionPointEqualsOrAfterEndOfText
=
textFragmentDataAtEnd
.
EndRef
(
)
.
EqualsOrIsBefore
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
textFragmentDataAtStart
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
aRangeToBeReplaced
.
StartRef
(
)
)
;
const
bool
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
=
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
;
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
textFragmentDataAtEnd
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
const
bool
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
=
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpacesAtStart
=
!
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
?
Some
(
textFragmentDataAtStart
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtStart
=
visibleWhiteSpacesAtStart
.
isSome
(
)
&
&
visibleWhiteSpacesAtStart
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpacesAtStart
.
ref
(
)
.
ComparePoint
(
aRangeToBeReplaced
.
StartRef
(
)
)
:
PointPosition
:
:
NotInSameDOMTree
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpacesAtEnd
=
!
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
?
Some
(
textFragmentDataAtEnd
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtEnd
=
visibleWhiteSpacesAtEnd
.
isSome
(
)
&
&
visibleWhiteSpacesAtEnd
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpacesAtEnd
.
ref
(
)
.
ComparePoint
(
aRangeToBeReplaced
.
EndRef
(
)
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
pointToPutCaret
;
EditorDOMPoint
pointToInsert
(
aRangeToBeReplaced
.
StartRef
(
)
)
;
EditorDOMPoint
atNBSPReplaceableWithSP
;
if
(
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
&
&
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
)
{
atNBSPReplaceableWithSP
=
textFragmentDataAtStart
.
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
pointToInsert
)
.
To
<
EditorDOMPoint
>
(
)
;
}
nsAutoString
theString
(
aStringToInsert
)
;
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackPrecedingNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackInvisibleLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeAtStart
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
pointToInsert
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeAtEnd
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
textFragmentDataAtEnd
.
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
if
(
atNBSPReplacedWithASCIIWhiteSpace
.
IsSet
(
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackPrecedingNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackInvisibleLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeAtStart
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
Result
<
InsertTextResult
nsresult
>
replaceTextResult
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceTextResult
.
propagateErr
(
)
;
}
replaceTextResult
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
=
=
pointToInsert
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeAtStart
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeAtStart
.
Clear
(
)
;
}
}
else
if
(
atNBSPReplaceableWithSP
.
IsInTextNode
(
)
)
{
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
atNBSPReplaceableWithSP
.
AsInText
(
)
;
if
(
!
atNBSPReplacedWithASCIIWhiteSpace
.
IsEndOfContainer
(
)
&
&
atNBSPReplacedWithASCIIWhiteSpace
.
IsCharNBSP
(
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
Result
<
InsertTextResult
nsresult
>
replaceTextResult
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
failed
"
)
;
return
replaceTextResult
.
propagateErr
(
)
;
}
replaceTextResult
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeAtStart
.
Clear
(
)
;
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
!
theString
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
|
|
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
const
bool
isNewLineCollapsible
=
!
pointToInsert
.
IsInContentNode
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
auto
IsCollapsibleChar
=
[
&
isNewLineCollapsible
]
(
char16_t
aChar
)
-
>
bool
{
return
nsCRT
:
:
IsAsciiSpace
(
aChar
)
&
&
(
isNewLineCollapsible
|
|
aChar
!
=
HTMLEditUtils
:
:
kNewLine
)
;
}
;
if
(
IsCollapsibleChar
(
theString
[
0
]
)
)
{
if
(
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
{
const
auto
atPreviousChar
=
textFragmentDataAtStart
.
GetPreviousCharPoint
<
EditorRawDOMPointInText
>
(
pointToInsert
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
}
else
if
(
(
textFragmentDataAtStart
.
StartsFromHardLineBreak
(
)
|
|
textFragmentDataAtStart
.
StartsFromInlineEditingHostBoundary
(
)
)
&
&
isInsertionPointEqualsOrIsBeforeStartOfText
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
}
const
uint32_t
lastCharIndex
=
theString
.
Length
(
)
-
1
;
if
(
IsCollapsibleChar
(
theString
[
lastCharIndex
]
)
)
{
if
(
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
if
(
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
MiddleOfFragment
)
{
const
auto
atNextChar
=
textFragmentDataAtEnd
.
GetInclusiveNextCharPoint
<
EditorRawDOMPointInText
>
(
pointToInsert
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
}
else
if
(
(
textFragmentDataAtEnd
.
EndsByBlockBoundary
(
)
|
|
textFragmentDataAtEnd
.
EndsByInlineEditingHostBoundary
(
)
)
&
&
isInsertionPointEqualsOrAfterEndOfText
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
}
enum
class
PreviousChar
{
NonCollapsibleChar
CollapsibleChar
PreformattedNewLine
}
;
PreviousChar
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
for
(
uint32_t
i
=
0
;
i
<
=
lastCharIndex
;
i
+
+
)
{
if
(
IsCollapsibleChar
(
theString
[
i
]
)
)
{
if
(
previousChar
=
=
PreviousChar
:
:
CollapsibleChar
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
-
1
)
;
continue
;
}
if
(
previousChar
=
=
PreviousChar
:
:
PreformattedNewLine
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
)
;
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
continue
;
}
previousChar
=
PreviousChar
:
:
CollapsibleChar
;
continue
;
}
if
(
theString
[
i
]
!
=
HTMLEditUtils
:
:
kNewLine
)
{
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
continue
;
}
MOZ_ASSERT
(
!
isNewLineCollapsible
)
;
if
(
previousChar
=
=
PreviousChar
:
:
CollapsibleChar
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
-
1
)
;
}
previousChar
=
PreviousChar
:
:
PreformattedNewLine
;
}
}
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
InsertTextResult
nsresult
>
insertTextResult
=
aHTMLEditor
.
InsertTextWithTransaction
(
theString
pointToInsert
aInsertTextTo
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
insertTextResult
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
if
(
insertTextResult
.
inspect
(
)
.
HasCaretPointSuggestion
(
)
)
{
return
insertTextResult
;
}
return
InsertTextResult
(
insertTextResult
.
unwrap
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
NS_WARN_IF
(
!
aRangeToBeReplaced
.
StartRef
(
)
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToInsert
=
aHTMLEditor
.
ComputePointToInsertText
(
aRangeToBeReplaced
.
StartRef
(
)
aInsertTextTo
)
;
MOZ_ASSERT
(
pointToInsert
.
IsInContentNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aRangeToBeReplaced
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
)
;
if
(
!
EditorBase
:
:
InsertingTextForExtantComposition
(
aPurpose
)
&
&
isWhiteSpaceCollapsible
&
&
pointToInsert
.
IsInContentNode
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
Result
<
EditorDOMPoint
nsresult
>
deletePointOfInvisibleWhiteSpacesAtStartOrError
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
aHTMLEditor
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
deletePointOfInvisibleWhiteSpacesAtStartOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpaces
(
)
failed
"
)
;
return
deletePointOfInvisibleWhiteSpacesAtStartOrError
.
propagateErr
(
)
;
}
trackPointToInsert
.
FlushAndStopTracking
(
)
;
const
EditorDOMPoint
deletePointOfInvisibleWhiteSpacesAtStart
=
deletePointOfInvisibleWhiteSpacesAtStartOrError
.
unwrap
(
)
;
if
(
NS_WARN_IF
(
deletePointOfInvisibleWhiteSpacesAtStart
.
IsSet
(
)
&
&
!
pointToInsert
.
IsSetAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
EditorBase
:
:
InsertingTextForStartingComposition
(
aPurpose
)
&
&
pointToInsert
.
IsInTextNode
(
)
)
{
const
auto
whiteSpaceOffset
=
[
&
]
(
)
-
>
Maybe
<
uint32_t
>
{
if
(
!
pointToInsert
.
IsEndOfContainer
(
)
&
&
pointToInsert
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
return
Some
(
pointToInsert
.
Offset
(
)
)
;
}
if
(
!
pointToInsert
.
IsStartOfContainer
(
)
&
&
pointToInsert
.
IsPreviousCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
return
Some
(
pointToInsert
.
Offset
(
)
-
1u
)
;
}
return
Nothing
(
)
;
}
(
)
;
if
(
whiteSpaceOffset
.
isSome
(
)
)
{
Maybe
<
AutoTrackDOMPoint
>
trackPointToInsert
;
if
(
pointToInsert
.
Offset
(
)
!
=
*
whiteSpaceOffset
)
{
trackPointToInsert
.
emplace
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
}
Result
<
EditorDOMPoint
nsresult
>
pointToInsertOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
aHTMLEditor
EditorDOMPointInText
(
pointToInsert
.
ContainerAs
<
Text
>
(
)
*
whiteSpaceOffset
)
)
;
if
(
MOZ_UNLIKELY
(
pointToInsertOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAt
(
)
failed
"
)
;
return
pointToInsertOrError
.
propagateErr
(
)
;
}
if
(
trackPointToInsert
.
isSome
(
)
)
{
trackPointToInsert
.
reset
(
)
;
}
else
{
pointToInsert
=
pointToInsertOrError
.
unwrap
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
HTMLEditor
:
:
NormalizedStringToInsertText
insertTextData
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
{
if
(
!
isWhiteSpaceCollapsible
)
{
return
HTMLEditor
:
:
NormalizedStringToInsertText
(
aStringToInsert
pointToInsert
)
;
}
if
(
pointToInsert
.
IsInTextNode
(
)
&
&
!
EditorBase
:
:
InsertingTextForComposition
(
aPurpose
)
)
{
return
aHTMLEditor
.
NormalizeWhiteSpacesToInsertText
(
pointToInsert
aStringToInsert
HTMLEditor
:
:
NormalizeSurroundingWhiteSpaces
:
:
Yes
)
.
GetMinimizedData
(
*
pointToInsert
.
ContainerAs
<
Text
>
(
)
)
;
}
return
aHTMLEditor
.
NormalizeWhiteSpacesToInsertText
(
pointToInsert
aStringToInsert
EditorBase
:
:
InsertingTextForComposition
(
aPurpose
)
?
HTMLEditor
:
:
NormalizeSurroundingWhiteSpaces
:
:
No
:
HTMLEditor
:
:
NormalizeSurroundingWhiteSpaces
:
:
Yes
)
;
}
(
)
;
MOZ_ASSERT_IF
(
insertTextData
.
ReplaceLength
(
)
pointToInsert
.
IsInTextNode
(
)
)
;
Result
<
InsertTextResult
nsresult
>
insertOrReplaceTextResultOrError
=
aHTMLEditor
.
InsertOrReplaceTextWithTransaction
(
pointToInsert
insertTextData
)
;
if
(
MOZ_UNLIKELY
(
insertOrReplaceTextResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
insertOrReplaceTextResultOrError
;
}
if
(
aPurpose
!
=
InsertTextFor
:
:
CompositionEnd
&
&
aPurpose
!
=
InsertTextFor
:
:
CompositionStartAndEnd
)
{
return
insertOrReplaceTextResultOrError
;
}
InsertTextResult
insertOrReplaceTextResult
=
insertOrReplaceTextResultOrError
.
unwrap
(
)
;
const
EditorDOMPointInText
endOfCommitString
=
insertOrReplaceTextResult
.
EndOfInsertedTextRef
(
)
.
GetAsInText
(
)
;
if
(
!
endOfCommitString
.
IsSet
(
)
|
|
endOfCommitString
.
IsContainerEmpty
(
)
)
{
return
std
:
:
move
(
insertOrReplaceTextResult
)
;
}
if
(
NS_WARN_IF
(
endOfCommitString
.
Offset
(
)
<
insertTextData
.
mNormalizedString
.
Length
(
)
)
)
{
insertOrReplaceTextResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
const
EditorDOMPointInText
startOfCommitString
(
endOfCommitString
.
ContainerAs
<
Text
>
(
)
endOfCommitString
.
Offset
(
)
-
insertTextData
.
mNormalizedString
.
Length
(
)
)
;
MOZ_ASSERT
(
insertOrReplaceTextResult
.
EndOfInsertedTextRef
(
)
=
=
insertOrReplaceTextResult
.
CaretPointRef
(
)
)
;
EditorDOMPoint
pointToPutCaret
=
insertOrReplaceTextResult
.
UnwrapCaretPoint
(
)
;
if
(
endOfCommitString
.
IsMiddleOfContainer
(
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesWithoutDeletingInvisibleWhiteSpaces
(
aHTMLEditor
endOfCommitString
.
PreviousPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
NormalizeVisibleWhiteSpacesWithoutDeletingInvisibleWhiteSpaces
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSetAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
!
startOfCommitString
.
IsStartOfContainer
(
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesWithoutDeletingInvisibleWhiteSpaces
(
aHTMLEditor
startOfCommitString
.
PreviousPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
NormalizeVisibleWhiteSpacesWithoutDeletingInvisibleWhiteSpaces
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSetAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
EditorDOMPoint
endOfCommitStringAfterNormalized
=
pointToPutCaret
;
return
InsertTextResult
(
std
:
:
move
(
endOfCommitStringAfterNormalized
)
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
)
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesWithoutDeletingInvisibleWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPoint
.
IsEndOfContainer
(
)
)
;
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
ContainerAs
<
Text
>
(
)
)
)
{
return
NS_OK
;
}
Text
&
textNode
=
*
aPoint
.
ContainerAs
<
Text
>
(
)
;
const
bool
isNewLinePreformatted
=
EditorUtils
:
:
IsNewLinePreformatted
(
textNode
)
;
const
auto
IsCollapsibleChar
=
[
&
]
(
char16_t
aChar
)
{
return
aChar
=
=
HTMLEditUtils
:
:
kNewLine
?
!
isNewLinePreformatted
:
nsCRT
:
:
IsAsciiSpace
(
aChar
)
;
}
;
const
auto
IsCollapsibleCharOrNBSP
=
[
&
]
(
char16_t
aChar
)
{
return
aChar
=
=
HTMLEditUtils
:
:
kNBSP
|
|
IsCollapsibleChar
(
aChar
)
;
}
;
const
auto
whiteSpaceOffset
=
[
&
]
(
)
-
>
Maybe
<
uint32_t
>
{
if
(
IsCollapsibleCharOrNBSP
(
aPoint
.
Char
(
)
)
)
{
return
Some
(
aPoint
.
Offset
(
)
)
;
}
if
(
!
aPoint
.
IsAtLastContent
(
)
&
&
IsCollapsibleCharOrNBSP
(
aPoint
.
NextChar
(
)
)
)
{
return
Some
(
aPoint
.
Offset
(
)
+
1u
)
;
}
return
Nothing
(
)
;
}
(
)
;
if
(
whiteSpaceOffset
.
isNothing
(
)
)
{
return
NS_OK
;
}
const
uint32_t
firstOffset
=
[
&
]
(
)
{
for
(
const
uint32_t
offset
:
Reversed
(
IntegerRange
(
*
whiteSpaceOffset
)
)
)
{
if
(
!
IsCollapsibleCharOrNBSP
(
textNode
.
TextFragment
(
)
.
CharAt
(
offset
)
)
)
{
return
offset
+
1u
;
}
}
return
0u
;
}
(
)
;
const
uint32_t
endOffset
=
[
&
]
(
)
{
for
(
const
uint32_t
offset
:
IntegerRange
(
*
whiteSpaceOffset
+
1
textNode
.
TextDataLength
(
)
)
)
{
if
(
!
IsCollapsibleCharOrNBSP
(
textNode
.
TextFragment
(
)
.
CharAt
(
offset
)
)
)
{
return
offset
;
}
}
return
textNode
.
TextDataLength
(
)
;
}
(
)
;
nsAutoString
normalizedString
;
const
char16_t
precedingChar
=
!
firstOffset
?
static_cast
<
char16_t
>
(
0
)
:
textNode
.
TextFragment
(
)
.
CharAt
(
firstOffset
-
1u
)
;
const
char16_t
followingChar
=
endOffset
=
=
textNode
.
TextDataLength
(
)
?
static_cast
<
char16_t
>
(
0
)
:
textNode
.
TextFragment
(
)
.
CharAt
(
endOffset
)
;
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
normalizedString
endOffset
-
firstOffset
!
firstOffset
?
HTMLEditor
:
:
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
CharPointType
:
:
TextEnd
)
:
HTMLEditor
:
:
CharPointData
:
:
InSameTextNode
(
precedingChar
=
=
HTMLEditUtils
:
:
kNewLine
?
HTMLEditor
:
:
CharPointType
:
:
PreformattedLineBreak
:
HTMLEditor
:
:
CharPointType
:
:
VisibleChar
)
endOffset
=
=
textNode
.
TextDataLength
(
)
?
HTMLEditor
:
:
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
CharPointType
:
:
TextEnd
)
:
HTMLEditor
:
:
CharPointData
:
:
InSameTextNode
(
followingChar
=
=
HTMLEditUtils
:
:
kNewLine
?
HTMLEditor
:
:
CharPointType
:
:
PreformattedLineBreak
:
HTMLEditor
:
:
CharPointType
:
:
VisibleChar
)
)
;
MOZ_ASSERT
(
normalizedString
.
Length
(
)
=
=
endOffset
-
firstOffset
)
;
const
OwningNonNull
<
Text
>
text
(
textNode
)
;
Result
<
InsertTextResult
nsresult
>
normalizeWhiteSpaceSequenceResultOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
text
firstOffset
endOffset
-
firstOffset
normalizedString
)
;
if
(
MOZ_UNLIKELY
(
normalizeWhiteSpaceSequenceResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
normalizeWhiteSpaceSequenceResultOrError
.
unwrapErr
(
)
;
}
normalizeWhiteSpaceSequenceResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
Result
<
CaretPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
const
TextFragmentData
textFragmentDataAtDeletion
(
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtDeletion
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
auto
atPreviousCharOfStart
=
textFragmentDataAtDeletion
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
aPoint
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
)
{
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
if
(
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
|
|
atPreviousCharOfStart
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
auto
startToDelete
=
textFragmentDataAtDeletion
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPoint
>
(
atPreviousCharOfStart
nsIEditor
:
:
ePrevious
IgnoreNonEditableNodes
:
:
Yes
)
;
auto
endToDelete
=
textFragmentDataAtDeletion
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPoint
>
(
atPreviousCharOfStart
nsIEditor
:
:
ePrevious
IgnoreNonEditableNodes
:
:
Yes
)
;
EditorDOMPoint
pointToPutCaret
;
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
atPreviousCharOfStart
.
IsCharCollapsibleNBSP
(
)
)
{
auto
startToDelete
=
atPreviousCharOfStart
.
To
<
EditorDOMPoint
>
(
)
;
auto
endToDelete
=
startToDelete
.
NextPoint
<
EditorDOMPoint
>
(
)
;
EditorDOMPoint
pointToPutCaret
;
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
atPreviousCharOfStart
atPreviousCharOfStart
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
caretPointOrError
.
isOk
(
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
Result
<
CaretPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
const
TextFragmentData
textFragmentDataAtDeletion
(
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtDeletion
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
auto
atNextCharOfStart
=
textFragmentDataAtDeletion
.
GetInclusiveNextCharPoint
<
EditorDOMPointInText
>
(
aPoint
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
!
atNextCharOfStart
.
IsSet
(
)
|
|
atNextCharOfStart
.
IsEndOfContainer
(
)
)
{
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
if
(
atNextCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
|
|
atNextCharOfStart
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
auto
startToDelete
=
textFragmentDataAtDeletion
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPoint
>
(
atNextCharOfStart
nsIEditor
:
:
eNext
IgnoreNonEditableNodes
:
:
Yes
)
;
auto
endToDelete
=
textFragmentDataAtDeletion
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPoint
>
(
atNextCharOfStart
nsIEditor
:
:
eNext
IgnoreNonEditableNodes
:
:
Yes
)
;
EditorDOMPoint
pointToPutCaret
;
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
atNextCharOfStart
.
IsCharCollapsibleNBSP
(
)
)
{
auto
startToDelete
=
atNextCharOfStart
.
To
<
EditorDOMPoint
>
(
)
;
auto
endToDelete
=
startToDelete
.
NextPoint
<
EditorDOMPoint
>
(
)
;
EditorDOMPoint
pointToPutCaret
;
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
atNextCharOfStart
atNextCharOfStart
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
caretPointOrError
.
isOk
(
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
Result
<
CaretPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContentToDelete
const
EditorDOMPoint
&
aCaretPoint
const
Element
&
aEditingHost
)
{
EditorDOMPoint
atContent
(
&
aContentToDelete
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
Deleting
content
node
was
an
orphan
node
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
aContentToDelete
)
)
{
NS_WARNING
(
"
Deleting
content
node
wasn
'
t
removable
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
aHTMLEditor
EditorDOMRange
(
atContent
atContent
.
NextPoint
(
)
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
else
{
MOZ_ASSERT
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContentToDelete
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
AutoTrackDOMPoint
trackAtContent
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atContent
)
;
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
aHTMLEditor
EditorDOMPoint
(
aContentToDelete
.
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
aContentToDelete
.
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
aHTMLEditor
EditorDOMPoint
:
:
After
(
*
aContentToDelete
.
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
EnsureNoInvisibleWhiteSpacesAfter
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
aContentToDelete
.
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
pointToPutCaret
.
IsInContentNode
(
)
)
{
if
(
pointToPutCaret
.
IsBefore
(
EditorRawDOMPoint
(
&
aContentToDelete
)
)
)
{
WSScanResult
nextThingOfCaretPoint
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
Scan
:
:
All
pointToPutCaret
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextThingOfCaretPoint
.
ReachedBRElement
(
)
|
|
nextThingOfCaretPoint
.
ReachedPreformattedLineBreak
(
)
)
{
nextThingOfCaretPoint
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
Scan
:
:
All
nextThingOfCaretPoint
.
PointAfterReachedContent
<
EditorRawDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
}
if
(
nextThingOfCaretPoint
.
ReachedBlockBoundary
(
)
)
{
const
EditorDOMPoint
atBlockBoundary
=
nextThingOfCaretPoint
.
ReachedCurrentBlockBoundary
(
)
?
EditorDOMPoint
:
:
AtEndOf
(
*
nextThingOfCaretPoint
.
ElementPtr
(
)
)
:
EditorDOMPoint
(
nextThingOfCaretPoint
.
ElementPtr
(
)
)
;
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
aHTMLEditor
atBlockBoundary
{
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
if
(
NS_WARN_IF
(
!
aContentToDelete
.
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
else
if
(
EditorRawDOMPoint
:
:
After
(
aContentToDelete
)
.
EqualsOrIsBefore
(
pointToPutCaret
)
)
{
const
WSScanResult
previousThingOfCaretPoint
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
Scan
:
:
All
pointToPutCaret
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
previousThingOfCaretPoint
.
ReachedBlockBoundary
(
)
)
{
const
EditorDOMPoint
atBlockBoundary
=
previousThingOfCaretPoint
.
ReachedCurrentBlockBoundary
(
)
?
EditorDOMPoint
(
previousThingOfCaretPoint
.
ElementPtr
(
)
0u
)
:
EditorDOMPoint
(
previousThingOfCaretPoint
.
ElementPtr
(
)
)
;
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
atBlockBoundary
{
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
)
"
"
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
if
(
NS_WARN_IF
(
!
aContentToDelete
.
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
}
trackAtContent
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
else
{
const
WSScanResult
nextThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
Scan
:
:
All
EditorRawDOMPoint
:
:
After
(
aContentToDelete
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextThing
.
ReachedLineBoundary
(
)
)
{
AutoTrackDOMPoint
trackAtContent
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atContent
)
;
Result
<
EditorDOMPoint
nsresult
>
afterLastVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
aHTMLEditor
atContent
{
}
)
;
if
(
MOZ_UNLIKELY
(
afterLastVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
)
"
"
failed
"
)
;
return
afterLastVisibleThingOrError
.
propagateErr
(
)
;
}
trackAtContent
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
{
AutoTrackDOMPoint
trackAtContent
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atContent
)
;
Result
<
EditorDOMPoint
nsresult
>
atFirstVisibleThingOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesAfter
(
aHTMLEditor
atContent
.
NextPoint
(
)
{
}
)
;
if
(
MOZ_UNLIKELY
(
atFirstVisibleThingOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesBefore
(
)
failed
"
)
;
return
atFirstVisibleThingOrError
.
propagateErr
(
)
;
}
trackAtContent
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContentToDelete
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContentToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
!
aCaretPoint
.
IsInTextNode
(
)
|
|
!
previousEditableSibling
|
|
!
previousEditableSibling
-
>
IsText
(
)
)
{
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
previousEditableSibling
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
aCaretPoint
.
GetContainer
(
)
!
=
nextEditableSibling
)
{
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
JoinNearestEditableNodesWithTransaction
(
*
previousEditableSibling
MOZ_KnownLive
(
*
aCaretPoint
.
ContainerAs
<
Text
>
(
)
)
&
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
!
pointToPutCaret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
didn
'
t
return
"
"
right
node
position
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
JoinNodesResult
nsresult
>
joinTextNodesResultOrError
=
aHTMLEditor
.
JoinTextNodesWithNormalizeWhiteSpaces
(
MOZ_KnownLive
(
*
previousEditableSibling
-
>
AsText
(
)
)
MOZ_KnownLive
(
*
aCaretPoint
.
ContainerAs
<
Text
>
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
joinTextNodesResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinTextNodesWithNormalizeWhiteSpaces
(
)
failed
"
)
;
return
joinTextNodesResultOrError
.
propagateErr
(
)
;
}
return
CaretPoint
(
joinTextNodesResultOrError
.
unwrap
(
)
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
)
;
}
Result
<
CaretPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRangeToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
if
(
NS_WARN_IF
(
!
aRangeToDelete
.
IsPositionedAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aRangeToDelete
.
IsInContentNodes
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMRange
rangeToDelete
(
aRangeToDelete
)
;
bool
mayBecomeUnexpectedDOMTree
=
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
;
TextFragmentData
textFragmentDataAtStart
(
Scan
:
:
EditableNodes
rangeToDelete
.
StartRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
TextFragmentData
textFragmentDataAtEnd
(
Scan
:
:
EditableNodes
rangeToDelete
.
EndRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
ReplaceRangeData
replaceRangeDataAtEnd
=
textFragmentDataAtEnd
.
GetReplaceRangeDataAtEndOfDeletionRange
(
textFragmentDataAtStart
)
;
EditorDOMPoint
pointToPutCaret
;
if
(
replaceRangeDataAtEnd
.
IsSet
(
)
&
&
!
replaceRangeDataAtEnd
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
rangeToDelete
.
EndRef
(
)
.
EqualsOrIsBefore
(
replaceRangeDataAtEnd
.
EndRef
(
)
)
)
;
MOZ_ASSERT_IF
(
rangeToDelete
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
!
rangeToDelete
.
EndRef
(
)
.
IsEndOfContainer
(
)
replaceRangeDataAtEnd
.
StartRef
(
)
.
EqualsOrIsBefore
(
rangeToDelete
.
EndRef
(
)
)
)
;
MOZ_ASSERT_IF
(
rangeToDelete
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
rangeToDelete
.
EndRef
(
)
.
IsEndOfContainer
(
)
replaceRangeDataAtEnd
.
StartRef
(
)
.
EqualsOrIsBefore
(
rangeToDelete
.
EndRef
(
)
)
|
|
replaceRangeDataAtEnd
.
StartRef
(
)
.
IsStartOfContainer
(
)
)
;
MOZ_ASSERT
(
rangeToDelete
.
StartRef
(
)
.
EqualsOrIsBefore
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
)
;
if
(
!
replaceRangeDataAtEnd
.
HasReplaceString
(
)
)
{
EditorDOMPoint
startToDelete
(
aRangeToDelete
.
StartRef
(
)
)
;
EditorDOMPoint
endToDelete
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffsetOfStart
(
startToDelete
)
;
AutoEditorDOMPointChildInvalidator
lockOffsetOfEnd
(
endToDelete
)
;
AutoTrackDOMPoint
trackStartToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startToDelete
)
;
AutoTrackDOMPoint
trackEndToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
endToDelete
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
replaceRangeDataAtEnd
.
StartRef
(
)
replaceRangeDataAtEnd
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
if
(
mayBecomeUnexpectedDOMTree
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
rangeToDelete
.
SetStartAndEnd
(
startToDelete
endToDelete
)
;
}
else
{
MOZ_ASSERT
(
replaceRangeDataAtEnd
.
RangeRef
(
)
.
IsInTextNodes
(
)
)
;
EditorDOMPoint
startToDelete
(
aRangeToDelete
.
StartRef
(
)
)
;
EditorDOMPoint
endToDelete
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
;
{
AutoTrackDOMPoint
trackStartToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startToDelete
)
;
AutoTrackDOMPoint
trackEndToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
endToDelete
)
;
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
replaceRangeDataAtEnd
.
RangeRef
(
)
.
AsInTexts
(
)
replaceRangeDataAtEnd
.
ReplaceStringRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAtEndOfDeletingRange
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
mayBecomeUnexpectedDOMTree
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
rangeToDelete
.
SetStartAndEnd
(
startToDelete
endToDelete
)
;
}
if
(
mayBecomeUnexpectedDOMTree
)
{
if
(
&
aEditingHost
!
=
aHTMLEditor
.
ComputeEditingHost
(
)
)
{
NS_WARNING
(
"
Active
editing
host
was
changed
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
rangeToDelete
.
IsInContentNodes
(
)
)
{
NS_WARNING
(
"
The
modified
range
was
not
in
content
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
textFragmentDataAtStart
=
TextFragmentData
(
Scan
:
:
EditableNodes
rangeToDelete
.
StartRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
textFragmentDataAtEnd
=
TextFragmentData
(
Scan
:
:
EditableNodes
rangeToDelete
.
EndRef
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
}
}
ReplaceRangeData
replaceRangeDataAtStart
=
textFragmentDataAtStart
.
GetReplaceRangeDataAtStartOfDeletionRange
(
textFragmentDataAtEnd
)
;
if
(
!
replaceRangeDataAtStart
.
IsSet
(
)
|
|
replaceRangeDataAtStart
.
Collapsed
(
)
)
{
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
!
replaceRangeDataAtStart
.
HasReplaceString
(
)
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
replaceRangeDataAtStart
.
StartRef
(
)
replaceRangeDataAtStart
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
MOZ_ASSERT
(
replaceRangeDataAtStart
.
RangeRef
(
)
.
IsInTextNodes
(
)
)
;
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
replaceRangeDataAtStart
.
RangeRef
(
)
.
AsInTexts
(
)
replaceRangeDataAtStart
.
ReplaceStringRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAtStartOfDeletingRange
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
const
TextFragmentData
textFragmentDataAtSplitPoint
(
Scan
:
:
EditableNodes
aPointToSplit
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtSplitPoint
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
textFragmentDataAtSplitPoint
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
IsInitialized
(
)
)
{
return
NS_OK
;
}
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWhiteSpaces
.
ComparePoint
(
aPointToSplit
)
;
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
auto
atNextCharOfStart
=
textFragmentDataAtSplitPoint
.
GetInclusiveNextCharPoint
<
EditorDOMPointInText
>
(
pointToSplit
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atNextCharOfStart
.
IsSet
(
)
&
&
!
atNextCharOfStart
.
IsEndOfContainer
(
)
&
&
atNextCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
pointToSplit
)
;
AutoTrackDOMPoint
trackSplitPoint
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
if
(
atNextCharOfStart
.
IsStartOfContainer
(
)
|
|
atNextCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atNextCharOfStart
=
textFragmentDataAtSplitPoint
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointInText
>
(
atNextCharOfStart
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
}
const
auto
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtSplitPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointInText
>
(
atNextCharOfStart
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atNextCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
{
auto
atPreviousCharOfStart
=
textFragmentDataAtSplitPoint
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
pointToSplit
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
textFragmentDataAtSplitPoint
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointInText
>
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
}
const
auto
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtSplitPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointInText
>
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRangeInTexts
&
aRangeToReplace
const
nsAString
&
aReplaceString
)
{
MOZ_ASSERT
(
aRangeToReplace
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
StartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
EndRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
StartRef
(
)
.
IsBefore
(
aRangeToReplace
.
EndRef
(
)
)
)
;
{
Result
<
InsertTextResult
nsresult
>
caretPointOrError
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
aRangeToReplace
.
InSameContainer
(
)
?
aRangeToReplace
.
EndRef
(
)
.
Offset
(
)
-
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
:
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextLength
(
)
-
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
aReplaceString
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
aRangeToReplace
.
InSameContainer
(
)
)
{
return
NS_OK
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
aRangeToReplace
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
template
<
typename
EditorDOMPointType
>
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInContentNode
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
;
const
TextFragmentData
textFragmentData
(
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
textFragmentData
.
FoundNoBreakingWhiteSpaces
(
)
)
{
return
NS_OK
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
textFragmentData
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
IsInitialized
(
)
)
{
return
NS_OK
;
}
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
const
EditorDOMPoint
&
atEndOfVisibleWhiteSpaces
=
visibleWhiteSpaces
.
EndRef
(
)
;
auto
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
|
|
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleNBSP
(
)
)
{
return
NS_OK
;
}
auto
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atPreviousCharOfEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
bool
isPreviousCharCollapsibleASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
;
const
bool
maybeNBSPFollowsVisibleContent
=
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
isPreviousCharCollapsibleASCIIWhiteSpace
)
|
|
(
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
(
visibleWhiteSpaces
.
StartsFromNonCollapsibleCharacters
(
)
|
|
visibleWhiteSpaces
.
StartsFromSpecialContent
(
)
)
)
;
bool
followedByVisibleContent
=
visibleWhiteSpaces
.
EndsByNonCollapsibleCharacters
(
)
|
|
visibleWhiteSpaces
.
EndsBySpecialContent
(
)
;
bool
followedByBRElement
=
visibleWhiteSpaces
.
EndsByBRElement
(
)
;
bool
followedByPreformattedLineBreak
=
visibleWhiteSpaces
.
EndsByPreformattedLineBreak
(
)
;
if
(
maybeNBSPFollowsVisibleContent
|
|
isPreviousCharCollapsibleASCIIWhiteSpace
)
{
if
(
(
visibleWhiteSpaces
.
EndsByBlockBoundary
(
)
|
|
visibleWhiteSpaces
.
EndsByInlineEditingHostBoundary
(
)
)
&
&
aPoint
.
IsInContentNode
(
)
)
{
bool
insertBRElement
=
HTMLEditUtils
:
:
IsBlockElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
insertBRElement
)
{
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
const
Element
*
editableBlockElement
=
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
:
nullptr
;
insertBRElement
=
!
!
editableBlockElement
;
}
if
(
insertBRElement
)
{
if
(
NS_WARN_IF
(
!
atEndOfVisibleWhiteSpaces
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
Maybe
<
LineBreakType
>
lineBreakType
=
aHTMLEditor
.
GetPreferredLineBreakType
(
*
atEndOfVisibleWhiteSpaces
.
ContainerAs
<
nsIContent
>
(
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
lineBreakType
.
isNothing
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
aHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
*
lineBreakType
atEndOfVisibleWhiteSpaces
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertLineBreak
(
"
"
WithTransaction
:
:
Yes
%
s
)
failed
"
ToString
(
*
lineBreakType
)
.
c_str
(
)
)
.
get
(
)
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
Handled
(
)
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atPreviousCharOfEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
isPreviousCharCollapsibleASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
;
followedByBRElement
=
true
;
followedByVisibleContent
=
followedByPreformattedLineBreak
=
false
;
}
}
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
)
{
return
NS_OK
;
}
if
(
maybeNBSPFollowsVisibleContent
&
&
(
followedByVisibleContent
|
|
followedByBRElement
)
&
&
!
visibleWhiteSpaces
.
StartsFromPreformattedLineBreak
(
)
)
{
MOZ_ASSERT
(
!
followedByPreformattedLineBreak
)
;
Result
<
InsertTextResult
nsresult
>
replaceTextResult
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
atPreviousCharOfEndOfVisibleWhiteSpaces
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceTextResult
.
propagateErr
(
)
;
}
replaceTextResult
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
}
if
(
maybeNBSPFollowsVisibleContent
|
|
!
isPreviousCharCollapsibleASCIIWhiteSpace
|
|
!
(
followedByVisibleContent
|
|
followedByBRElement
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
)
;
const
auto
atFirstASCIIWhiteSpace
=
textFragmentData
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointInText
>
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
uint32_t
numberOfASCIIWhiteSpacesInStartNode
=
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
?
atPreviousCharOfEndOfVisibleWhiteSpaces
.
Offset
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
:
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
-
>
Length
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
;
uint32_t
replaceLengthInStartNode
=
numberOfASCIIWhiteSpacesInStartNode
+
(
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
?
1
:
0
)
;
Result
<
InsertTextResult
nsresult
>
replaceTextResult
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atFirstASCIIWhiteSpace
.
Offset
(
)
replaceLengthInStartNode
textFragmentData
.
StartsFromPreformattedLineBreak
(
)
&
&
textFragmentData
.
EndsByPreformattedLineBreak
(
)
?
u
"
\
x00A0
\
x00A0
"
_ns
:
(
textFragmentData
.
EndsByPreformattedLineBreak
(
)
?
u
"
\
x00A0
"
_ns
:
u
"
\
x00A0
"
_ns
)
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
replaceTextResult
.
propagateErr
(
)
;
}
replaceTextResult
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
if
(
atFirstASCIIWhiteSpace
.
GetContainer
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
GetContainer
(
)
)
{
return
NS_OK
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atPreviousCharOfEndOfVisibleWhiteSpaces
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
const
EditorDOMPoint
&
atEndOfVisibleWhiteSpaces
=
visibleWhiteSpaces
.
EndRef
(
)
;
const
auto
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
|
|
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleNBSP
(
)
|
|
visibleWhiteSpaces
.
EndsByPreformattedLineBreak
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
startToDelete
endToDelete
;
const
auto
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousCharPoint
<
EditorDOMPointInText
>
(
atPreviousCharOfEndOfVisibleWhiteSpaces
IgnoreNonEditableNodes
:
:
Yes
)
;
if
(
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharNBSP
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
)
{
startToDelete
=
textFragmentData
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointInText
>
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
nsIEditor
:
:
eNone
IgnoreNonEditableNodes
:
:
Yes
)
;
endToDelete
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
;
}
else
{
startToDelete
=
endToDelete
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
NextPoint
(
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
HTMLEditor
:
:
DeleteDirection
:
:
Forward
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpace
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
Result
<
CaretPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
const
TextFragmentData
textFragmentData
(
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
textFragmentData
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
textFragmentData
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
EditorDOMPoint
pointToPutCaret
;
DebugOnly
<
bool
>
leadingWhiteSpacesDeleted
=
false
;
if
(
leadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
leadingWhiteSpaceRange
.
Collapsed
(
)
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
leadingWhiteSpaceRange
.
StartRef
(
)
leadingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
leadingWhiteSpacesDeleted
=
true
;
}
if
(
trailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
trailingWhiteSpaceRange
.
Collapsed
(
)
&
&
leadingWhiteSpaceRange
!
=
trailingWhiteSpaceRange
)
{
NS_ASSERTION
(
!
leadingWhiteSpacesDeleted
"
We
'
re
trying
to
remove
trailing
white
-
spaces
with
maybe
"
"
outdated
range
"
)
;
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
trailingWhiteSpaceRange
.
StartRef
(
)
trailingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
}
