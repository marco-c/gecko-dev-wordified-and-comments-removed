#
ifndef
WSRunScanner_h
#
define
WSRunScanner_h
#
include
"
EditorBase
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
namespace
mozilla
{
class
MOZ_STACK_CLASS
WSScanResult
final
{
private
:
using
Element
=
dom
:
:
Element
;
using
HTMLBRElement
=
dom
:
:
HTMLBRElement
;
using
Text
=
dom
:
:
Text
;
enum
class
WSType
:
uint8_t
{
NotInitialized
UnexpectedError
InUncomposedDoc
LeadingWhiteSpaces
TrailingWhiteSpaces
CollapsibleWhiteSpaces
NonCollapsibleCharacters
SpecialContent
BRElement
PreformattedLineBreak
OtherBlockBoundary
CurrentBlockBoundary
InlineEditingHostBoundary
}
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
WSType
&
aType
)
{
switch
(
aType
)
{
case
WSType
:
:
NotInitialized
:
return
aStream
<
<
"
WSType
:
:
NotInitialized
"
;
case
WSType
:
:
UnexpectedError
:
return
aStream
<
<
"
WSType
:
:
UnexpectedError
"
;
case
WSType
:
:
InUncomposedDoc
:
return
aStream
<
<
"
WSType
:
:
InUncomposedDoc
"
;
case
WSType
:
:
LeadingWhiteSpaces
:
return
aStream
<
<
"
WSType
:
:
LeadingWhiteSpaces
"
;
case
WSType
:
:
TrailingWhiteSpaces
:
return
aStream
<
<
"
WSType
:
:
TrailingWhiteSpaces
"
;
case
WSType
:
:
CollapsibleWhiteSpaces
:
return
aStream
<
<
"
WSType
:
:
CollapsibleWhiteSpaces
"
;
case
WSType
:
:
NonCollapsibleCharacters
:
return
aStream
<
<
"
WSType
:
:
NonCollapsibleCharacters
"
;
case
WSType
:
:
SpecialContent
:
return
aStream
<
<
"
WSType
:
:
SpecialContent
"
;
case
WSType
:
:
BRElement
:
return
aStream
<
<
"
WSType
:
:
BRElement
"
;
case
WSType
:
:
PreformattedLineBreak
:
return
aStream
<
<
"
WSType
:
:
PreformattedLineBreak
"
;
case
WSType
:
:
OtherBlockBoundary
:
return
aStream
<
<
"
WSType
:
:
OtherBlockBoundary
"
;
case
WSType
:
:
CurrentBlockBoundary
:
return
aStream
<
<
"
WSType
:
:
CurrentBlockBoundary
"
;
case
WSType
:
:
InlineEditingHostBoundary
:
return
aStream
<
<
"
WSType
:
:
InlineEditingHostBoundary
"
;
}
return
aStream
<
<
"
<
Illegal
value
>
"
;
}
friend
class
WSRunScanner
;
explicit
WSScanResult
(
WSType
aReason
)
:
mReason
(
aReason
)
{
MOZ_ASSERT
(
mReason
=
=
WSType
:
:
UnexpectedError
|
|
mReason
=
=
WSType
:
:
NotInitialized
)
;
}
public
:
WSScanResult
(
)
=
delete
;
enum
class
ScanDirection
:
bool
{
Backward
Forward
}
;
MOZ_NEVER_INLINE_DEBUG
WSScanResult
(
ScanDirection
aScanDirection
nsIContent
&
aContent
WSType
aReason
BlockInlineCheck
aBlockInlineCheck
)
:
mContent
(
&
aContent
)
mReason
(
aReason
)
mDirection
(
aScanDirection
)
{
MOZ_ASSERT
(
aReason
!
=
WSType
:
:
CollapsibleWhiteSpaces
&
&
aReason
!
=
WSType
:
:
NonCollapsibleCharacters
&
&
aReason
!
=
WSType
:
:
PreformattedLineBreak
)
;
AssertIfInvalidData
(
aBlockInlineCheck
)
;
}
MOZ_NEVER_INLINE_DEBUG
WSScanResult
(
ScanDirection
aScanDirection
const
EditorDOMPoint
&
aPoint
WSType
aReason
BlockInlineCheck
aBlockInlineCheck
)
:
mContent
(
aPoint
.
GetContainerAs
<
nsIContent
>
(
)
)
mOffset
(
Some
(
aPoint
.
Offset
(
)
)
)
mReason
(
aReason
)
mDirection
(
aScanDirection
)
{
AssertIfInvalidData
(
aBlockInlineCheck
)
;
}
static
WSScanResult
Error
(
)
{
return
WSScanResult
(
WSType
:
:
UnexpectedError
)
;
}
MOZ_NEVER_INLINE_DEBUG
void
AssertIfInvalidData
(
BlockInlineCheck
aBlockInlineCheck
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mReason
=
=
WSType
:
:
UnexpectedError
|
|
mReason
=
=
WSType
:
:
InUncomposedDoc
|
|
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
BRElement
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
|
|
mReason
=
=
WSType
:
:
SpecialContent
|
|
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
|
|
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
UnexpectedError
!
mContent
)
;
MOZ_ASSERT_IF
(
mReason
!
=
WSType
:
:
UnexpectedError
mContent
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
InUncomposedDoc
!
mContent
-
>
IsInComposedDoc
(
)
)
;
MOZ_ASSERT_IF
(
mContent
&
&
!
mContent
-
>
IsInComposedDoc
(
)
mReason
=
=
WSType
:
:
InUncomposedDoc
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
mContent
-
>
IsText
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
mContent
-
>
AsText
(
)
-
>
TextDataLength
(
)
>
0
)
;
MOZ_ASSERT_IF
(
mDirection
=
=
ScanDirection
:
:
Backward
&
&
(
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
)
*
mOffset
>
0
)
;
MOZ_ASSERT_IF
(
mDirection
=
=
ScanDirection
:
:
Forward
&
&
(
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
|
|
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
)
*
mOffset
<
mContent
-
>
AsText
(
)
-
>
TextDataLength
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
BRElement
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
PreformattedLineBreak
EditorUtils
:
:
IsNewLinePreformatted
(
*
mContent
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
SpecialContent
(
mContent
-
>
IsText
(
)
&
&
!
mContent
-
>
IsEditable
(
)
)
|
|
(
!
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
aBlockInlineCheck
)
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
OtherBlockBoundary
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
aBlockInlineCheck
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
CurrentBlockBoundary
mContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
CurrentBlockBoundary
mContent
-
>
IsEditable
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
CurrentBlockBoundary
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
aBlockInlineCheck
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
mContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
mContent
-
>
IsEditable
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
!
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
aBlockInlineCheck
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
!
mContent
-
>
GetParentElement
(
)
|
|
!
mContent
-
>
GetParentElement
(
)
-
>
IsEditable
(
)
)
;
#
endif
}
bool
Failed
(
)
const
{
return
mReason
=
=
WSType
:
:
NotInitialized
|
|
mReason
=
=
WSType
:
:
UnexpectedError
;
}
nsIContent
*
GetContent
(
)
const
{
return
mContent
;
}
[
[
nodiscard
]
]
bool
ContentIsElement
(
)
const
{
return
mContent
&
&
mContent
-
>
IsElement
(
)
;
}
[
[
nodiscard
]
]
bool
ContentIsText
(
)
const
{
return
mContent
&
&
mContent
-
>
IsText
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
ElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsElement
(
)
)
;
return
mContent
-
>
AsElement
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
BRElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
return
static_cast
<
HTMLBRElement
*
>
(
mContent
.
get
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
Text
*
TextPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsText
(
)
)
;
return
mContent
-
>
AsText
(
)
;
}
bool
IsContentEditable
(
)
const
{
return
mContent
&
&
mContent
-
>
IsEditable
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
uint32_t
Offset_Deprecated
(
)
const
{
NS_ASSERTION
(
mOffset
.
isSome
(
)
"
Retrieved
non
-
meaningful
offset
"
)
;
return
mOffset
.
valueOr
(
0
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
Point_Deprecated
(
)
const
{
NS_ASSERTION
(
mOffset
.
isSome
(
)
"
Retrieved
non
-
meaningful
point
"
)
;
return
EditorDOMPointType
(
mContent
mOffset
.
valueOr
(
0
)
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
PointAtReachedContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
switch
(
mReason
)
{
case
WSType
:
:
CollapsibleWhiteSpaces
:
case
WSType
:
:
NonCollapsibleCharacters
:
case
WSType
:
:
PreformattedLineBreak
:
MOZ_DIAGNOSTIC_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mDirection
=
=
ScanDirection
:
:
Forward
?
EditorDOMPointType
(
mContent
mOffset
.
valueOr
(
0
)
)
:
EditorDOMPointType
(
mContent
std
:
:
max
(
mOffset
.
valueOr
(
1
)
1u
)
-
1
)
;
default
:
return
EditorDOMPointType
(
mContent
)
;
}
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
PointAfterReachedContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
return
PointAtReachedContent
<
EditorDOMPointType
>
(
)
.
template
NextPointOrAfterContainer
<
EditorDOMPointType
>
(
)
;
}
bool
ReachedSpecialContent
(
)
const
{
return
mReason
=
=
WSType
:
:
SpecialContent
;
}
bool
InVisibleOrCollapsibleCharacters
(
)
const
{
return
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
|
|
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
;
}
bool
InCollapsibleWhiteSpaces
(
)
const
{
return
mReason
=
=
WSType
:
:
CollapsibleWhiteSpaces
;
}
bool
InNonCollapsibleCharacters
(
)
const
{
return
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
;
}
bool
ReachedBRElement
(
)
const
{
return
mReason
=
=
WSType
:
:
BRElement
;
}
bool
ReachedVisibleBRElement
(
)
const
{
return
ReachedBRElement
(
)
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
BRElementPtr
(
)
)
;
}
bool
ReachedInvisibleBRElement
(
)
const
{
return
ReachedBRElement
(
)
&
&
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
BRElementPtr
(
)
)
;
}
bool
ReachedPreformattedLineBreak
(
)
const
{
return
mReason
=
=
WSType
:
:
PreformattedLineBreak
;
}
bool
ReachedHRElement
(
)
const
{
return
mContent
&
&
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
;
}
bool
ReachedBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
ReachedCurrentBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
;
}
bool
ReachedOtherBlockElement
(
)
const
{
return
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
ReachedNonEditableOtherBlockElement
(
)
const
{
return
ReachedOtherBlockElement
(
)
&
&
!
GetContent
(
)
-
>
IsEditable
(
)
;
}
[
[
nodiscard
]
]
bool
ReachedInlineEditingHostBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
;
}
bool
ReachedSomethingNonTextContent
(
)
const
{
return
!
InVisibleOrCollapsibleCharacters
(
)
;
}
[
[
nodiscard
]
]
bool
ReachedLineBoundary
(
)
const
{
switch
(
mReason
)
{
case
WSType
:
:
CurrentBlockBoundary
:
case
WSType
:
:
OtherBlockBoundary
:
case
WSType
:
:
BRElement
:
case
WSType
:
:
PreformattedLineBreak
:
return
true
;
default
:
return
ReachedHRElement
(
)
;
}
}
private
:
nsCOMPtr
<
nsIContent
>
mContent
;
Maybe
<
uint32_t
>
mOffset
;
WSType
mReason
;
ScanDirection
mDirection
=
ScanDirection
:
:
Backward
;
}
;
class
MOZ_STACK_CLASS
WSRunScanner
final
{
private
:
using
Element
=
dom
:
:
Element
;
using
HTMLBRElement
=
dom
:
:
HTMLBRElement
;
using
Text
=
dom
:
:
Text
;
public
:
using
WSType
=
WSScanResult
:
:
WSType
;
enum
class
IgnoreNonEditableNodes
:
bool
{
No
Yes
}
;
enum
class
StopAtNonEditableNode
:
bool
{
No
Yes
}
;
enum
class
Scan
:
bool
{
All
EditableNodes
}
;
[
[
nodiscard
]
]
constexpr
static
IgnoreNonEditableNodes
ShouldIgnoreNonEditableSiblingsOrDescendants
(
Scan
aScan
)
{
return
static_cast
<
IgnoreNonEditableNodes
>
(
static_cast
<
bool
>
(
aScan
)
)
;
}
[
[
nodiscard
]
]
constexpr
static
StopAtNonEditableNode
ShouldStopAtNonEditableNode
(
Scan
aScan
)
{
return
static_cast
<
StopAtNonEditableNode
>
(
static_cast
<
bool
>
(
aScan
)
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
(
Scan
aScanMode
const
EditorDOMPointType
&
aScanStartPoint
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
:
mScanStartPoint
(
aScanStartPoint
.
template
To
<
EditorDOMPoint
>
(
)
)
mTextFragmentDataAtStart
(
aScanMode
mScanStartPoint
aBlockInlineCheck
aAncestorLimiter
)
mBlockInlineCheck
(
aBlockInlineCheck
)
mScanMode
(
aScanMode
)
{
}
template
<
typename
PT
typename
CT
>
WSScanResult
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
static
WSScanResult
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
const
Element
*
aEditingHost
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
)
{
return
WSRunScanner
(
Scan
:
:
EditableNodes
aPoint
aBlockInlineCheck
aEditingHost
)
.
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
static
WSScanResult
ScanPreviousVisibleNodeOrBlockBoundary
(
const
Element
*
aEditingHost
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
)
{
return
WSRunScanner
(
Scan
:
:
EditableNodes
aPoint
aBlockInlineCheck
aEditingHost
)
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
static
EditorDOMPointType
GetInclusiveNextCharPoint
(
Scan
aScanMode
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
&
&
(
aScanMode
!
=
Scan
:
:
EditableNodes
|
|
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
)
{
return
EditorDOMPointType
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
)
;
}
return
WSRunScanner
(
aScanMode
aPoint
aBlockInlineCheck
aAncestorLimiter
)
.
GetInclusiveNextCharPoint
<
EditorDOMPointType
>
(
aPoint
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
static
EditorDOMPointType
GetPreviousCharPoint
(
Scan
aScanMode
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
&
&
(
aScanMode
!
=
Scan
:
:
EditableNodes
|
|
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
)
{
return
EditorDOMPointType
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
-
1
)
;
}
return
WSRunScanner
(
aScanMode
aPoint
aBlockInlineCheck
aAncestorLimiter
)
.
GetPreviousCharPoint
<
EditorDOMPointType
>
(
aPoint
)
;
}
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetAfterLastVisiblePoint
(
Text
&
aTextNode
)
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetFirstVisiblePoint
(
Text
&
aTextNode
)
;
static
Result
<
EditorDOMRangeInTexts
nsresult
>
GetRangeInTextNodesToForwardDeleteFrom
(
const
EditorDOMPoint
&
aPoint
)
;
static
Result
<
EditorDOMRangeInTexts
nsresult
>
GetRangeInTextNodesToBackspaceFrom
(
const
EditorDOMPoint
&
aPoint
)
;
static
EditorDOMRange
GetRangesForDeletingAtomicContent
(
const
nsIContent
&
aAtomicContent
)
;
static
EditorDOMRange
GetRangeForDeletingBlockElementBoundaries
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aLeftBlockElement
const
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aPointContainingTheOtherBlock
)
;
static
Result
<
bool
nsresult
>
ShrinkRangeIfStartsFromOrEndsAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
)
;
static
EditorDOMRange
GetRangeContainingInvisibleWhiteSpacesAtRangeBoundaries
(
const
EditorDOMRange
&
aRange
)
;
template
<
typename
EditorDOMPointType
>
MOZ_NEVER_INLINE_DEBUG
static
HTMLBRElement
*
GetPrecedingBRElementUnlessVisibleContentFound
(
const
Element
*
aEditingHost
const
EditorDOMPointType
&
aPoint
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
)
{
return
nullptr
;
}
TextFragmentData
textFragmentData
(
Scan
:
:
EditableNodes
aPoint
aBlockInlineCheck
aEditingHost
)
;
return
textFragmentData
.
StartsFromBRElement
(
)
?
textFragmentData
.
StartReasonBRElementPtr
(
)
:
nullptr
;
}
const
EditorDOMPoint
&
ScanStartRef
(
)
const
{
return
mScanStartPoint
;
}
nsIContent
*
GetStartReasonContent
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
;
}
nsIContent
*
GetEndReasonContent
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
;
}
bool
StartsFromNonCollapsibleCharacters
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromNonCollapsibleCharacters
(
)
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromSpecialContent
(
)
;
}
bool
StartsFromBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromBRElement
(
)
;
}
bool
StartsFromVisibleBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromVisibleBRElement
(
)
;
}
bool
StartsFromInvisibleBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromInvisibleBRElement
(
)
;
}
bool
StartsFromPreformattedLineBreak
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromPreformattedLineBreak
(
)
;
}
bool
StartsFromCurrentBlockBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromCurrentBlockBoundary
(
)
;
}
bool
StartsFromOtherBlockElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromOtherBlockElement
(
)
;
}
bool
StartsFromBlockBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromBlockBoundary
(
)
;
}
bool
StartsFromInlineEditingHostBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromInlineEditingHostBoundary
(
)
;
}
bool
StartsFromHardLineBreak
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartsFromHardLineBreak
(
)
;
}
bool
EndsByNonCollapsibleCharacters
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByNonCollapsibleCharacters
(
)
;
}
bool
EndsBySpecialContent
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsBySpecialContent
(
)
;
}
bool
EndsByBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByBRElement
(
)
;
}
bool
EndsByVisibleBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByVisibleBRElement
(
)
;
}
bool
EndsByInvisibleBRElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByInvisibleBRElement
(
)
;
}
bool
EndsByPreformattedLineBreak
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByPreformattedLineBreak
(
)
;
}
bool
EndsByCurrentBlockBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByCurrentBlockBoundary
(
)
;
}
bool
EndsByOtherBlockElement
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByOtherBlockElement
(
)
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByBlockBoundary
(
)
;
}
bool
EndsByInlineEditingHostBoundary
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndsByInlineEditingHostBoundary
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
StartReasonOtherBlockElementPtr
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartReasonOtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
StartReasonBRElementPtr
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
StartReasonBRElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
EndReasonOtherBlockElementPtr
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndReasonOtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
EndReasonBRElementPtr
(
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
EndReasonBRElementPtr
(
)
;
}
protected
:
using
EditorType
=
EditorBase
:
:
EditorType
;
class
TextFragmentData
;
class
MOZ_STACK_CLASS
VisibleWhiteSpacesData
final
{
public
:
bool
IsInitialized
(
)
const
{
return
mLeftWSType
!
=
WSType
:
:
NotInitialized
|
|
mRightWSType
!
=
WSType
:
:
NotInitialized
;
}
EditorDOMPoint
StartRef
(
)
const
{
return
mStartPoint
;
}
EditorDOMPoint
EndRef
(
)
const
{
return
mEndPoint
;
}
bool
StartsFromNonCollapsibleCharacters
(
)
const
{
return
mLeftWSType
=
=
WSType
:
:
NonCollapsibleCharacters
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
mLeftWSType
=
=
WSType
:
:
SpecialContent
;
}
bool
StartsFromPreformattedLineBreak
(
)
const
{
return
mLeftWSType
=
=
WSType
:
:
PreformattedLineBreak
;
}
bool
EndsByNonCollapsibleCharacters
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
NonCollapsibleCharacters
;
}
bool
EndsByTrailingWhiteSpaces
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
TrailingWhiteSpaces
;
}
bool
EndsBySpecialContent
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
SpecialContent
;
}
bool
EndsByBRElement
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
BRElement
;
}
bool
EndsByPreformattedLineBreak
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
PreformattedLineBreak
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mRightWSType
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
EndsByInlineEditingHostBoundary
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
InlineEditingHostBoundary
;
}
enum
class
PointPosition
{
BeforeStartOfFragment
StartOfFragment
MiddleOfFragment
EndOfFragment
AfterEndOfFragment
NotInSameDOMTree
}
;
template
<
typename
EditorDOMPointType
>
PointPosition
ComparePoint
(
const
EditorDOMPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
StartRef
(
)
=
=
aPoint
)
{
return
PointPosition
:
:
StartOfFragment
;
}
if
(
EndRef
(
)
=
=
aPoint
)
{
return
PointPosition
:
:
EndOfFragment
;
}
const
bool
startIsBeforePoint
=
StartRef
(
)
.
IsBefore
(
aPoint
)
;
const
bool
pointIsBeforeEnd
=
aPoint
.
IsBefore
(
EndRef
(
)
)
;
if
(
startIsBeforePoint
&
&
pointIsBeforeEnd
)
{
return
PointPosition
:
:
MiddleOfFragment
;
}
if
(
startIsBeforePoint
)
{
return
PointPosition
:
:
AfterEndOfFragment
;
}
if
(
pointIsBeforeEnd
)
{
return
PointPosition
:
:
BeforeStartOfFragment
;
}
return
PointPosition
:
:
NotInSameDOMTree
;
}
private
:
friend
class
WSRunScanner
:
:
TextFragmentData
;
VisibleWhiteSpacesData
(
)
:
mLeftWSType
(
WSType
:
:
NotInitialized
)
mRightWSType
(
WSType
:
:
NotInitialized
)
{
}
template
<
typename
EditorDOMPointType
>
void
SetStartPoint
(
const
EditorDOMPointType
&
aStartPoint
)
{
mStartPoint
=
aStartPoint
;
}
template
<
typename
EditorDOMPointType
>
void
SetEndPoint
(
const
EditorDOMPointType
&
aEndPoint
)
{
mEndPoint
=
aEndPoint
;
}
void
SetStartFrom
(
WSType
aLeftWSType
)
{
mLeftWSType
=
aLeftWSType
;
}
void
SetStartFromLeadingWhiteSpaces
(
)
{
mLeftWSType
=
WSType
:
:
LeadingWhiteSpaces
;
}
void
SetEndBy
(
WSType
aRightWSType
)
{
mRightWSType
=
aRightWSType
;
}
void
SetEndByTrailingWhiteSpaces
(
)
{
mRightWSType
=
WSType
:
:
TrailingWhiteSpaces
;
}
EditorDOMPoint
mStartPoint
;
EditorDOMPoint
mEndPoint
;
WSType
mLeftWSType
mRightWSType
;
}
;
using
PointPosition
=
VisibleWhiteSpacesData
:
:
PointPosition
;
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
GetInclusiveNextCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
GetInclusiveNextCharPoint
<
EditorDOMPointType
>
(
aPoint
ShouldIgnoreNonEditableSiblingsOrDescendants
(
mScanMode
)
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
GetPreviousCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
TextFragmentDataAtStartRef
(
)
.
GetPreviousCharPoint
<
EditorDOMPointType
>
(
aPoint
ShouldIgnoreNonEditableSiblingsOrDescendants
(
mScanMode
)
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
return
TextFragmentDataAtStartRef
(
)
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointType
>
(
aPointAtASCIIWhiteSpace
aDirectionToDelete
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
return
TextFragmentDataAtStartRef
(
)
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointType
>
(
aPointAtASCIIWhiteSpace
aDirectionToDelete
)
;
}
class
MOZ_STACK_CLASS
TextFragmentData
final
{
private
:
class
NoBreakingSpaceData
;
class
MOZ_STACK_CLASS
BoundaryData
final
{
public
:
using
NoBreakingSpaceData
=
WSRunScanner
:
:
TextFragmentData
:
:
NoBreakingSpaceData
;
template
<
typename
EditorDOMPointType
>
static
BoundaryData
ScanCollapsibleWhiteSpaceStartFrom
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
StopAtNonEditableNode
aStopAtNonEditableNode
const
Element
&
aAncestorLimiter
)
;
template
<
typename
EditorDOMPointType
>
static
BoundaryData
ScanCollapsibleWhiteSpaceEndFrom
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
StopAtNonEditableNode
aStopAtNonEditableNode
const
Element
&
aAncestorLimiter
)
;
BoundaryData
(
)
=
default
;
template
<
typename
EditorDOMPointType
>
BoundaryData
(
const
EditorDOMPointType
&
aPoint
nsIContent
&
aReasonContent
WSType
aReason
)
:
mReasonContent
(
&
aReasonContent
)
mPoint
(
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
)
mReason
(
aReason
)
{
}
bool
Initialized
(
)
const
{
return
mReasonContent
&
&
mPoint
.
IsSet
(
)
;
}
nsIContent
*
GetReasonContent
(
)
const
{
return
mReasonContent
;
}
const
EditorDOMPoint
&
PointRef
(
)
const
{
return
mPoint
;
}
WSType
RawReason
(
)
const
{
return
mReason
;
}
bool
IsNonCollapsibleCharacters
(
)
const
{
return
mReason
=
=
WSType
:
:
NonCollapsibleCharacters
;
}
bool
IsSpecialContent
(
)
const
{
return
mReason
=
=
WSType
:
:
SpecialContent
;
}
bool
IsBRElement
(
)
const
{
return
mReason
=
=
WSType
:
:
BRElement
;
}
bool
IsPreformattedLineBreak
(
)
const
{
return
mReason
=
=
WSType
:
:
PreformattedLineBreak
;
}
bool
IsCurrentBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
;
}
bool
IsOtherBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
IsBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
IsInlineEditingHostBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
InlineEditingHostBoundary
;
}
bool
IsHardLineBreak
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
|
|
mReason
=
=
WSType
:
:
BRElement
|
|
mReason
=
=
WSType
:
:
PreformattedLineBreak
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
OtherBlockElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mReasonContent
-
>
IsElement
(
)
)
;
return
mReasonContent
-
>
AsElement
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
BRElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mReasonContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
return
static_cast
<
HTMLBRElement
*
>
(
mReasonContent
.
get
(
)
)
;
}
private
:
template
<
typename
EditorDOMPointType
>
static
Maybe
<
BoundaryData
>
ScanCollapsibleWhiteSpaceStartInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
;
template
<
typename
EditorDOMPointType
>
static
Maybe
<
BoundaryData
>
ScanCollapsibleWhiteSpaceEndInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
;
nsCOMPtr
<
nsIContent
>
mReasonContent
;
EditorDOMPoint
mPoint
;
WSType
mReason
=
WSType
:
:
NotInitialized
;
}
;
class
MOZ_STACK_CLASS
NoBreakingSpaceData
final
{
public
:
enum
class
Scanning
{
Forward
Backward
}
;
void
NotifyNBSP
(
const
EditorDOMPointInText
&
aPoint
Scanning
aScanningDirection
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsCharNBSP
(
)
)
;
if
(
!
mFirst
.
IsSet
(
)
|
|
aScanningDirection
=
=
Scanning
:
:
Backward
)
{
mFirst
=
aPoint
;
}
if
(
!
mLast
.
IsSet
(
)
|
|
aScanningDirection
=
=
Scanning
:
:
Forward
)
{
mLast
=
aPoint
;
}
}
const
EditorDOMPointInText
&
FirstPointRef
(
)
const
{
return
mFirst
;
}
const
EditorDOMPointInText
&
LastPointRef
(
)
const
{
return
mLast
;
}
bool
FoundNBSP
(
)
const
{
MOZ_ASSERT
(
mFirst
.
IsSet
(
)
=
=
mLast
.
IsSet
(
)
)
;
return
mFirst
.
IsSet
(
)
;
}
private
:
EditorDOMPointInText
mFirst
;
EditorDOMPointInText
mLast
;
}
;
public
:
TextFragmentData
(
)
=
delete
;
template
<
typename
EditorDOMPointType
>
TextFragmentData
(
Scan
aScanMode
const
EditorDOMPointType
&
aPoint
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
bool
IsInitialized
(
)
const
{
return
mStart
.
Initialized
(
)
&
&
mEnd
.
Initialized
(
)
;
}
nsIContent
*
GetStartReasonContent
(
)
const
{
return
mStart
.
GetReasonContent
(
)
;
}
nsIContent
*
GetEndReasonContent
(
)
const
{
return
mEnd
.
GetReasonContent
(
)
;
}
bool
StartsFromNonCollapsibleCharacters
(
)
const
{
return
mStart
.
IsNonCollapsibleCharacters
(
)
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
mStart
.
IsSpecialContent
(
)
;
}
bool
StartsFromBRElement
(
)
const
{
return
mStart
.
IsBRElement
(
)
;
}
bool
StartsFromVisibleBRElement
(
)
const
{
return
StartsFromBRElement
(
)
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
GetStartReasonContent
(
)
)
;
}
bool
StartsFromInvisibleBRElement
(
)
const
{
return
StartsFromBRElement
(
)
&
&
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
GetStartReasonContent
(
)
)
;
}
bool
StartsFromPreformattedLineBreak
(
)
const
{
return
mStart
.
IsPreformattedLineBreak
(
)
;
}
bool
StartsFromCurrentBlockBoundary
(
)
const
{
return
mStart
.
IsCurrentBlockBoundary
(
)
;
}
bool
StartsFromOtherBlockElement
(
)
const
{
return
mStart
.
IsOtherBlockBoundary
(
)
;
}
bool
StartsFromBlockBoundary
(
)
const
{
return
mStart
.
IsBlockBoundary
(
)
;
}
bool
StartsFromInlineEditingHostBoundary
(
)
const
{
return
mStart
.
IsInlineEditingHostBoundary
(
)
;
}
bool
StartsFromHardLineBreak
(
)
const
{
return
mStart
.
IsHardLineBreak
(
)
;
}
bool
EndsByNonCollapsibleCharacters
(
)
const
{
return
mEnd
.
IsNonCollapsibleCharacters
(
)
;
}
bool
EndsBySpecialContent
(
)
const
{
return
mEnd
.
IsSpecialContent
(
)
;
}
bool
EndsByBRElement
(
)
const
{
return
mEnd
.
IsBRElement
(
)
;
}
bool
EndsByVisibleBRElement
(
)
const
{
return
EndsByBRElement
(
)
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
GetEndReasonContent
(
)
)
;
}
bool
EndsByInvisibleBRElement
(
)
const
{
return
EndsByBRElement
(
)
&
&
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
GetEndReasonContent
(
)
)
;
}
bool
EndsByPreformattedLineBreak
(
)
const
{
return
mEnd
.
IsPreformattedLineBreak
(
)
;
}
bool
EndsByInvisiblePreformattedLineBreak
(
)
const
{
return
mEnd
.
IsPreformattedLineBreak
(
)
&
&
HTMLEditUtils
:
:
IsInvisiblePreformattedNewLine
(
mEnd
.
PointRef
(
)
)
;
}
bool
EndsByCurrentBlockBoundary
(
)
const
{
return
mEnd
.
IsCurrentBlockBoundary
(
)
;
}
bool
EndsByOtherBlockElement
(
)
const
{
return
mEnd
.
IsOtherBlockBoundary
(
)
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
mEnd
.
IsBlockBoundary
(
)
;
}
bool
EndsByInlineEditingHostBoundary
(
)
const
{
return
mEnd
.
IsInlineEditingHostBoundary
(
)
;
}
WSType
StartRawReason
(
)
const
{
return
mStart
.
RawReason
(
)
;
}
WSType
EndRawReason
(
)
const
{
return
mEnd
.
RawReason
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
StartReasonOtherBlockElementPtr
(
)
const
{
return
mStart
.
OtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
StartReasonBRElementPtr
(
)
const
{
return
mStart
.
BRElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
Element
*
EndReasonOtherBlockElementPtr
(
)
const
{
return
mEnd
.
OtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
HTMLBRElement
*
EndReasonBRElementPtr
(
)
const
{
return
mEnd
.
BRElementPtr
(
)
;
}
const
EditorDOMPoint
&
StartRef
(
)
const
{
return
mStart
.
PointRef
(
)
;
}
const
EditorDOMPoint
&
EndRef
(
)
const
{
return
mEnd
.
PointRef
(
)
;
}
const
EditorDOMPoint
&
ScanStartRef
(
)
const
{
return
mScanStartPoint
;
}
bool
FoundNoBreakingWhiteSpaces
(
)
const
{
return
mNBSPData
.
FoundNBSP
(
)
;
}
const
EditorDOMPointInText
&
FirstNBSPPointRef
(
)
const
{
return
mNBSPData
.
FirstPointRef
(
)
;
}
const
EditorDOMPointInText
&
LastNBSPPointRef
(
)
const
{
return
mNBSPData
.
LastPointRef
(
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetInclusiveNextCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
const
nsIContent
*
aFollowingLimiterContent
=
nullptr
)
;
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
[
[
nodiscard
]
]
EditorDOMPointType
GetInclusiveNextCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
)
const
{
return
GetInclusiveNextCharPoint
<
EditorDOMPointType
>
(
aPoint
mBlockInlineCheck
aIgnoreNonEditableNodes
GetEndReasonContent
(
)
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetPreviousCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
BlockInlineCheck
aBlockInlineCheck
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
const
nsIContent
*
aPrecedingLimiterContent
=
nullptr
)
;
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
[
[
nodiscard
]
]
EditorDOMPointType
GetPreviousCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
)
const
{
return
GetPreviousCharPoint
<
EditorDOMPointType
>
(
aPoint
mBlockInlineCheck
aIgnoreNonEditableNodes
GetStartReasonContent
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
BlockInlineCheck
aBlockInlineCheck
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
const
nsIContent
*
aFollowingLimiterContent
=
nullptr
)
;
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
EditorDOMPointType
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
)
const
{
return
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPointType
>
(
aPointAtASCIIWhiteSpace
aDirectionToDelete
mBlockInlineCheck
aIgnoreNonEditableNodes
GetEndReasonContent
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
BlockInlineCheck
aBlockInlineCheck
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
const
nsIContent
*
aPrecedingLimiterContent
=
nullptr
)
;
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
EditorDOMPointType
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
IgnoreNonEditableNodes
aIgnoreNonEditableNodes
)
const
{
return
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPointType
>
(
aPointAtASCIIWhiteSpace
aDirectionToDelete
mBlockInlineCheck
aIgnoreNonEditableNodes
GetStartReasonContent
(
)
)
;
}
EditorDOMRangeInTexts
GetNonCollapsedRangeInTexts
(
const
EditorDOMRange
&
aRange
)
const
;
const
EditorDOMRange
&
InvisibleLeadingWhiteSpaceRangeRef
(
)
const
;
const
EditorDOMRange
&
InvisibleTrailingWhiteSpaceRangeRef
(
)
const
;
template
<
typename
EditorDOMPointType
>
EditorDOMRange
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
const
EditorDOMPointType
&
aPointToSplit
)
const
{
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
!
trailingWhiteSpaceRange
.
IsPositioned
(
)
)
{
return
trailingWhiteSpaceRange
;
}
if
(
aPointToSplit
.
IsBefore
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
if
(
aPointToSplit
.
EqualsOrIsBefore
(
trailingWhiteSpaceRange
.
EndRef
(
)
)
)
{
return
EditorDOMRange
(
trailingWhiteSpaceRange
.
StartRef
(
)
aPointToSplit
)
;
}
return
EditorDOMRange
(
trailingWhiteSpaceRange
.
EndRef
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMRange
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
const
EditorDOMPointType
&
aPointToSplit
)
const
{
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
!
leadingWhiteSpaceRange
.
IsPositioned
(
)
)
{
return
leadingWhiteSpaceRange
;
}
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsBefore
(
aPointToSplit
)
)
{
return
EditorDOMRange
(
)
;
}
if
(
leadingWhiteSpaceRange
.
StartRef
(
)
.
EqualsOrIsBefore
(
aPointToSplit
)
)
{
return
EditorDOMRange
(
aPointToSplit
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
return
EditorDOMRange
(
leadingWhiteSpaceRange
.
StartRef
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
bool
FollowingContentMayBecomeFirstVisibleContent
(
const
EditorDOMPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
mStart
.
IsHardLineBreak
(
)
&
&
!
mStart
.
IsInlineEditingHostBoundary
(
)
)
{
return
false
;
}
if
(
aPoint
.
EqualsOrIsBefore
(
mStart
.
PointRef
(
)
)
)
{
return
true
;
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
!
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
return
false
;
}
if
(
aPoint
.
EqualsOrIsBefore
(
leadingWhiteSpaceRange
.
StartRef
(
)
)
)
{
return
true
;
}
if
(
!
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
return
false
;
}
return
aPoint
.
EqualsOrIsBefore
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
bool
PrecedingContentMayBecomeInvisible
(
const
EditorDOMPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
mEnd
.
IsBlockBoundary
(
)
|
|
mEnd
.
IsInlineEditingHostBoundary
(
)
)
{
return
true
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
IsInitialized
(
)
)
{
return
false
;
}
if
(
!
visibleWhiteSpaces
.
StartRef
(
)
.
IsSet
(
)
)
{
return
true
;
}
if
(
!
visibleWhiteSpaces
.
StartRef
(
)
.
EqualsOrIsBefore
(
aPoint
)
)
{
return
false
;
}
if
(
visibleWhiteSpaces
.
EndsByTrailingWhiteSpaces
(
)
)
{
return
true
;
}
if
(
visibleWhiteSpaces
.
StartRef
(
)
=
=
visibleWhiteSpaces
.
EndRef
(
)
)
{
return
true
;
}
return
aPoint
.
IsBefore
(
visibleWhiteSpaces
.
EndRef
(
)
)
;
}
EditorDOMPointInText
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
;
EditorDOMPointInText
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
;
ReplaceRangeData
GetReplaceRangeDataAtEndOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtStartToDelete
)
const
;
ReplaceRangeData
GetReplaceRangeDataAtStartOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtEndToDelete
)
const
;
const
VisibleWhiteSpacesData
&
VisibleWhiteSpacesDataRef
(
)
const
;
private
:
EditorDOMPoint
mScanStartPoint
;
BoundaryData
mStart
;
BoundaryData
mEnd
;
NoBreakingSpaceData
mNBSPData
;
mutable
Maybe
<
EditorDOMRange
>
mLeadingWhiteSpaceRange
;
mutable
Maybe
<
EditorDOMRange
>
mTrailingWhiteSpaceRange
;
mutable
Maybe
<
VisibleWhiteSpacesData
>
mVisibleWhiteSpacesData
;
BlockInlineCheck
mBlockInlineCheck
;
Scan
mScanMode
;
}
;
const
TextFragmentData
&
TextFragmentDataAtStartRef
(
)
const
{
return
mTextFragmentDataAtStart
;
}
EditorDOMPoint
mScanStartPoint
;
private
:
static
EditorDOMRangeInTexts
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
const
TextFragmentData
&
aStart
const
TextFragmentData
&
aEnd
)
;
TextFragmentData
mTextFragmentDataAtStart
;
const
BlockInlineCheck
mBlockInlineCheck
;
const
Scan
mScanMode
;
friend
class
WhiteSpaceVisibilityKeeper
;
}
;
}
#
endif
