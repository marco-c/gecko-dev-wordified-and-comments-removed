#
ifndef
mozilla_EditorBase_h
#
define
mozilla_EditorBase_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nscore
.
h
"
class
mozInlineSpellChecker
;
class
nsAtom
;
class
nsIContent
;
class
nsIDocumentStateListener
;
class
nsIEditActionListener
;
class
nsIEditorObserver
;
class
nsINode
;
class
nsIPresShell
;
class
nsISupports
;
class
nsITransaction
;
class
nsITransactionListener
;
class
nsIWidget
;
class
nsRange
;
namespace
mozilla
{
class
AutoSelectionRestorer
;
class
AutoTopLevelEditSubActionNotifier
;
class
AutoTransactionsConserveSelection
;
class
AutoUpdateViewBatch
;
class
ChangeAttributeTransaction
;
class
CompositionTransaction
;
class
CreateElementTransaction
;
class
CSSEditUtils
;
class
DeleteNodeTransaction
;
class
DeleteRangeTransaction
;
class
DeleteTextTransaction
;
class
EditAggregateTransaction
;
class
EditorEventListener
;
class
EditTransactionBase
;
class
ErrorResult
;
class
HTMLEditor
;
class
HTMLEditUtils
;
class
IMEContentObserver
;
class
InsertNodeTransaction
;
class
InsertTextTransaction
;
class
JoinNodeTransaction
;
class
PlaceholderTransaction
;
class
SplitNodeResult
;
class
SplitNodeTransaction
;
class
TextComposition
;
class
TextEditor
;
class
TextEditRules
;
class
TextInputListener
;
class
TextServicesDocument
;
class
TypeInState
;
class
WSRunObject
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
DataTransfer
;
class
DragEvent
;
class
Element
;
class
EventTarget
;
class
Text
;
}
namespace
widget
{
struct
IMEState
;
}
template
<
class
T
class
Base
=
nsISupports
>
class
CachedWeakPtr
final
{
public
:
CachedWeakPtr
<
T
Base
>
(
)
:
mCache
(
nullptr
)
{
}
explicit
CachedWeakPtr
<
T
Base
>
(
T
*
aObject
)
{
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
aObject
)
)
;
mCache
=
aObject
;
}
explicit
CachedWeakPtr
<
T
Base
>
(
const
nsCOMPtr
<
T
>
&
aOther
)
{
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
aOther
.
get
(
)
)
)
;
mCache
=
aOther
;
}
explicit
CachedWeakPtr
<
T
Base
>
(
already_AddRefed
<
T
>
&
aOther
)
{
RefPtr
<
T
>
other
=
aOther
;
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
other
.
get
(
)
)
)
;
mCache
=
other
;
}
CachedWeakPtr
<
T
Base
>
&
operator
=
(
T
*
aObject
)
{
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
aObject
)
)
;
mCache
=
aObject
;
return
*
this
;
}
CachedWeakPtr
<
T
Base
>
&
operator
=
(
const
nsCOMPtr
<
T
>
&
aOther
)
{
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
aOther
.
get
(
)
)
)
;
mCache
=
aOther
;
return
*
this
;
}
CachedWeakPtr
<
T
Base
>
&
operator
=
(
already_AddRefed
<
T
>
&
aOther
)
{
RefPtr
<
T
>
other
=
aOther
;
mWeakPtr
=
do_GetWeakReference
(
static_cast
<
Base
*
>
(
other
.
get
(
)
)
)
;
mCache
=
other
;
return
*
this
;
}
bool
IsAlive
(
)
const
{
return
mWeakPtr
&
&
mWeakPtr
-
>
IsAlive
(
)
;
}
explicit
operator
bool
(
)
const
{
return
mWeakPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
get
(
)
const
{
if
(
mCache
&
&
!
mWeakPtr
-
>
IsAlive
(
)
)
{
const_cast
<
CachedWeakPtr
<
T
Base
>
*
>
(
this
)
-
>
mCache
=
nullptr
;
}
return
mCache
;
}
private
:
nsWeakPtr
mWeakPtr
;
T
*
MOZ_NON_OWNING_REF
mCache
;
}
;
#
define
kMOZEditorBogusNodeAttrAtom
nsGkAtoms
:
:
mozeditorbogusnode
#
define
kMOZEditorBogusNodeValue
NS_LITERAL_STRING
(
"
TRUE
"
)
enum
class
SplitAtEdges
{
eDoNotCreateEmptyContainer
eAllowToCreateEmptyContainer
}
;
class
EditorBase
:
public
nsIEditor
public
nsISelectionListener
public
nsSupportsWeakReference
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
EditorBase
nsIEditor
)
NS_DECL_NSIEDITOR
NS_DECL_NSISELECTIONLISTENER
EditorBase
(
)
;
virtual
nsresult
Init
(
nsIDocument
&
doc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
;
nsresult
PostCreate
(
)
;
virtual
void
PreDestroy
(
bool
aDestroyingFrames
)
;
bool
IsInitialized
(
)
const
{
return
!
!
mDocument
;
}
bool
Destroyed
(
)
const
{
return
mDidPreDestroy
;
}
nsIDocument
*
GetDocument
(
)
const
{
return
mDocument
;
}
nsIPresShell
*
GetPresShell
(
)
const
{
return
mDocument
?
mDocument
-
>
GetShell
(
)
:
nullptr
;
}
nsPresContext
*
GetPresContext
(
)
const
{
nsIPresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
already_AddRefed
<
nsIWidget
>
GetWidget
(
)
;
nsISelectionController
*
GetSelectionController
(
)
const
{
if
(
mSelectionController
)
{
return
mSelectionController
;
}
if
(
!
mDocument
)
{
return
nullptr
;
}
nsIPresShell
*
presShell
=
mDocument
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsISelectionController
*
sc
=
static_cast
<
PresShell
*
>
(
presShell
)
;
return
sc
;
}
nsresult
GetSelection
(
SelectionType
aSelectionType
Selection
*
*
aSelection
)
const
;
Selection
*
GetSelection
(
SelectionType
aSelectionType
=
SelectionType
:
:
eNormal
)
const
{
nsISelectionController
*
sc
=
GetSelectionController
(
)
;
if
(
!
sc
)
{
return
nullptr
;
}
Selection
*
selection
=
sc
-
>
GetSelection
(
ToRawSelectionType
(
aSelectionType
)
)
;
return
selection
;
}
Element
*
GetRoot
(
)
const
{
return
mRootElement
;
}
RangeUpdater
&
RangeUpdaterRef
(
)
{
return
mRangeUpdater
;
}
void
SetTextInputListener
(
TextInputListener
*
aTextInputListener
)
;
void
SetIMEContentObserver
(
IMEContentObserver
*
aIMEContentObserver
)
;
TextComposition
*
GetComposition
(
)
const
;
virtual
nsresult
GetPreferredIMEState
(
widget
:
:
IMEState
*
aState
)
;
bool
IsIMEComposing
(
)
const
;
nsresult
CommitComposition
(
)
;
nsresult
ToggleTextDirection
(
)
;
enum
class
TextDirection
{
eLTR
eRTL
}
;
void
SwitchTextDirectionTo
(
TextDirection
aTextDirection
)
;
nsresult
FinalizeSelection
(
)
;
bool
IsSelectionEditable
(
)
;
size_t
NumberOfUndoItems
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfUndoItems
(
)
:
0
;
}
size_t
NumberOfRedoItems
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfRedoItems
(
)
:
0
;
}
int32_t
NumberOfMaximumTransactions
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfMaximumTransactions
(
)
:
0
;
}
bool
IsUndoRedoEnabled
(
)
const
{
return
mTransactionManager
&
&
mTransactionManager
-
>
NumberOfMaximumTransactions
(
)
;
}
bool
CanUndo
(
)
const
{
return
IsUndoRedoEnabled
(
)
&
&
NumberOfUndoItems
(
)
>
0
;
}
bool
CanRedo
(
)
const
{
return
IsUndoRedoEnabled
(
)
&
&
NumberOfRedoItems
(
)
>
0
;
}
bool
EnableUndoRedo
(
int32_t
aMaxTransactionCount
=
-
1
)
{
if
(
!
mTransactionManager
)
{
mTransactionManager
=
new
TransactionManager
(
)
;
}
return
mTransactionManager
-
>
EnableUndoRedo
(
aMaxTransactionCount
)
;
}
bool
DisableUndoRedo
(
)
{
if
(
!
mTransactionManager
)
{
return
true
;
}
return
mTransactionManager
-
>
DisableUndoRedo
(
)
;
}
bool
ClearUndoRedo
(
)
{
if
(
!
mTransactionManager
)
{
return
true
;
}
return
mTransactionManager
-
>
ClearUndoRedo
(
)
;
}
bool
AddTransactionListener
(
nsITransactionListener
&
aListener
)
{
if
(
!
mTransactionManager
)
{
return
false
;
}
return
mTransactionManager
-
>
AddTransactionListener
(
aListener
)
;
}
bool
RemoveTransactionListener
(
nsITransactionListener
&
aListener
)
{
if
(
!
mTransactionManager
)
{
return
false
;
}
return
mTransactionManager
-
>
RemoveTransactionListener
(
aListener
)
;
}
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
;
virtual
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
=
0
;
uint32_t
Flags
(
)
const
{
return
mFlags
;
}
nsresult
AddFlags
(
uint32_t
aFlags
)
{
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
kOldFlags
|
aFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
nsresult
RemoveFlags
(
uint32_t
aFlags
)
{
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
kOldFlags
&
~
aFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
nsresult
AddAndRemoveFlags
(
uint32_t
aAddingFlags
uint32_t
aRemovingFlags
)
{
MOZ_ASSERT
(
!
(
aAddingFlags
&
aRemovingFlags
)
"
Same
flags
are
specified
both
adding
and
removing
"
)
;
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
(
kOldFlags
|
aAddingFlags
)
&
~
aRemovingFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
bool
IsPlaintextEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorPlaintextMask
)
!
=
0
;
}
bool
IsSingleLineEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorSingleLineMask
)
!
=
0
;
}
bool
IsPasswordEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorPasswordMask
)
!
=
0
;
}
bool
IsRightToLeft
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorRightToLeft
)
!
=
0
;
}
bool
IsLeftToRight
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorLeftToRight
)
!
=
0
;
}
bool
IsReadonly
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
!
=
0
;
}
bool
IsDisabled
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorDisabledMask
)
!
=
0
;
}
bool
IsInputFiltered
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorFilterInputMask
)
!
=
0
;
}
bool
IsMailEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
!
=
0
;
}
bool
IsWrapHackEnabled
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorEnableWrapHackMask
)
!
=
0
;
}
bool
IsFormWidget
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorWidgetMask
)
!
=
0
;
}
bool
NoCSS
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorNoCSSMask
)
!
=
0
;
}
bool
IsInteractionAllowed
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorAllowInteraction
)
!
=
0
;
}
bool
DontEchoPassword
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorDontEchoPassword
)
!
=
0
;
}
bool
ShouldSkipSpellCheck
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
)
!
=
0
;
}
bool
IsTabbable
(
)
const
{
return
IsSingleLineEditor
(
)
|
|
IsPasswordEditor
(
)
|
|
IsFormWidget
(
)
|
|
IsInteractionAllowed
(
)
;
}
bool
HasIndependentSelection
(
)
const
{
return
!
!
mSelectionController
;
}
bool
IsModifiable
(
)
const
{
return
!
IsReadonly
(
)
;
}
bool
IsInEditSubAction
(
)
const
{
return
mIsInEditSubAction
;
}
void
SuppressDispatchingInputEvent
(
bool
aSuppress
)
{
mDispatchInputEvent
=
!
aSuppress
;
}
bool
IsSuppressingDispatchingInputEvent
(
)
const
{
return
!
mDispatchInputEvent
;
}
bool
OutputsMozDirty
(
)
const
{
return
!
IsInteractionAllowed
(
)
|
|
IsMailEditor
(
)
;
}
virtual
nsIContent
*
GetFocusedContent
(
)
;
virtual
already_AddRefed
<
nsIContent
>
GetFocusedContentForIME
(
)
;
virtual
bool
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
;
virtual
already_AddRefed
<
nsIContent
>
FindSelectionRoot
(
nsINode
*
aNode
)
;
void
OnFocus
(
dom
:
:
EventTarget
*
aFocusEventTarget
)
;
void
SyncRealTimeSpell
(
)
;
void
ReinitializeSelection
(
Element
&
aElement
)
;
protected
:
virtual
nsresult
InsertTextWithTransaction
(
nsIDocument
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
=
nullptr
)
;
nsresult
InsertTextIntoTextNodeWithTransaction
(
const
nsAString
&
aStringToInsert
Text
&
aTextNode
int32_t
aOffset
bool
aSuppressIME
=
false
)
;
nsresult
SetTextImpl
(
Selection
&
aSelection
const
nsAString
&
aString
Text
&
aTextNode
)
;
nsresult
DeleteNodeWithTransaction
(
nsINode
&
aNode
)
;
template
<
typename
PT
typename
CT
>
nsresult
InsertNodeWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
;
already_AddRefed
<
Element
>
ReplaceContainerWithTransaction
(
Element
&
aOldContainer
nsAtom
&
aTagName
)
{
return
ReplaceContainerWithTransactionInternal
(
aOldContainer
aTagName
*
nsGkAtoms
:
:
_empty
EmptyString
(
)
false
)
;
}
already_AddRefed
<
Element
>
ReplaceContainerAndCloneAttributesWithTransaction
(
Element
&
aOldContainer
nsAtom
&
aTagName
)
{
return
ReplaceContainerWithTransactionInternal
(
aOldContainer
aTagName
*
nsGkAtoms
:
:
_empty
EmptyString
(
)
true
)
;
}
already_AddRefed
<
Element
>
ReplaceContainerWithTransaction
(
Element
&
aOldContainer
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
{
return
ReplaceContainerWithTransactionInternal
(
aOldContainer
aTagName
aAttribute
aAttributeValue
false
)
;
}
void
CloneAttributesWithTransaction
(
Element
&
aDestElement
Element
&
aSourceElement
)
;
nsresult
RemoveContainerWithTransaction
(
Element
&
aElement
)
;
already_AddRefed
<
Element
>
InsertContainerWithTransaction
(
nsIContent
&
aContent
nsAtom
&
aTagName
)
{
return
InsertContainerWithTransactionInternal
(
aContent
aTagName
*
nsGkAtoms
:
:
_empty
EmptyString
(
)
)
;
}
already_AddRefed
<
Element
>
InsertContainerWithTransaction
(
nsIContent
&
aContent
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
{
return
InsertContainerWithTransactionInternal
(
aContent
aTagName
aAttribute
aAttributeValue
)
;
}
template
<
typename
PT
typename
CT
>
already_AddRefed
<
nsIContent
>
SplitNodeWithTransaction
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
ErrorResult
&
aResult
)
;
nsresult
JoinNodesWithTransaction
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
template
<
typename
PT
typename
CT
>
nsresult
MoveNodeWithTransaction
(
nsIContent
&
aContent
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
;
nsresult
MoveNodeToEndWithTransaction
(
nsIContent
&
aContent
nsINode
&
aNewContainer
)
{
EditorRawDOMPoint
pointToInsert
;
pointToInsert
.
SetToEndOf
(
&
aNewContainer
)
;
return
MoveNodeWithTransaction
(
aContent
pointToInsert
)
;
}
void
MoveAllChildren
(
nsINode
&
aContainer
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
;
void
MovePreviousSiblings
(
nsIContent
&
aChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
;
void
MoveChildren
(
nsIContent
&
aFirstChild
nsIContent
&
aLastChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
;
nsresult
CloneAttributeWithTransaction
(
nsAtom
&
aAttribute
Element
&
aDestElement
Element
&
aSourceElement
)
;
nsresult
RemoveAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
)
;
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
=
0
;
nsresult
SetAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
const
nsAString
&
aValue
)
;
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
=
0
;
already_AddRefed
<
Element
>
CreateHTMLContent
(
nsAtom
*
aTag
)
;
static
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
nsIDocument
&
aDocument
const
nsAString
&
aData
)
;
template
<
typename
PT
typename
CT
>
already_AddRefed
<
Element
>
CreateNodeWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
;
already_AddRefed
<
EditAggregateTransaction
>
CreateTxnForDeleteSelection
(
EDirection
aAction
nsINode
*
*
aNode
int32_t
*
aOffset
int32_t
*
aLength
)
;
already_AddRefed
<
EditTransactionBase
>
CreateTxnForDeleteRange
(
nsRange
*
aRangeToDelete
EDirection
aAction
nsINode
*
*
aRemovingNode
int32_t
*
aOffset
int32_t
*
aLength
)
;
nsresult
DeleteTextWithTransaction
(
dom
:
:
CharacterData
&
aCharacterData
uint32_t
aOffset
uint32_t
aLength
)
;
already_AddRefed
<
Element
>
ReplaceContainerWithTransactionInternal
(
Element
&
aElement
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
bool
aCloneAllAttributes
)
;
already_AddRefed
<
Element
>
InsertContainerWithTransactionInternal
(
nsIContent
&
aContent
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
;
void
DoSplitNode
(
const
EditorDOMPoint
&
aStartOfRightNode
nsIContent
&
aNewLeftNode
ErrorResult
&
aError
)
;
nsresult
DoJoinNodes
(
nsINode
*
aNodeToKeep
nsINode
*
aNodeToJoin
nsINode
*
aParent
)
;
template
<
typename
PT
typename
CT
>
SplitNodeResult
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorDOMPointBase
<
PT
CT
>
&
aDeepestStartOfRightNode
SplitAtEdges
aSplitAtEdges
)
;
EditorDOMPoint
JoinNodesDeepWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
;
nsresult
DoTransaction
(
Selection
*
aSelection
nsITransaction
*
aTxn
)
;
virtual
bool
IsBlockNode
(
nsINode
*
aNode
)
;
static
nsINode
*
GetNodeLocation
(
nsINode
*
aChild
int32_t
*
aOffset
)
;
nsIContent
*
GetPreviousNode
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
false
true
false
)
;
}
nsIContent
*
GetPreviousElementOrText
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
false
false
false
)
;
}
nsIContent
*
GetPreviousEditableNode
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
true
true
false
)
;
}
nsIContent
*
GetPreviousNodeInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
false
true
true
)
;
}
nsIContent
*
GetPreviousElementOrTextInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
false
false
true
)
;
}
nsIContent
*
GetPreviousEditableNodeInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
{
return
GetPreviousNodeInternal
(
aPoint
true
true
true
)
;
}
nsIContent
*
GetPreviousNode
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
false
true
false
)
;
}
nsIContent
*
GetPreviousElementOrText
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
false
false
false
)
;
}
nsIContent
*
GetPreviousEditableNode
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
true
true
false
)
;
}
nsIContent
*
GetPreviousNodeInBlock
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
false
true
true
)
;
}
nsIContent
*
GetPreviousElementOrTextInBlock
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
false
false
true
)
;
}
nsIContent
*
GetPreviousEditableNodeInBlock
(
nsINode
&
aNode
)
{
return
GetPreviousNodeInternal
(
aNode
true
true
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
false
true
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextElementOrText
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
false
false
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
true
true
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
false
true
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextElementOrTextInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
false
false
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextNodeInternal
(
aPoint
true
true
true
)
;
}
nsIContent
*
GetNextNode
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
false
true
false
)
;
}
nsIContent
*
GetNextElementOrText
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
false
false
false
)
;
}
nsIContent
*
GetNextEditableNode
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
true
true
false
)
;
}
nsIContent
*
GetNextNodeInBlock
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
false
true
true
)
;
}
nsIContent
*
GetNextElementOrTextInBlock
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
false
false
true
)
;
}
nsIContent
*
GetNextEditableNodeInBlock
(
nsINode
&
aNode
)
{
return
GetNextNodeInternal
(
aNode
true
true
true
)
;
}
nsIContent
*
GetRightmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
=
false
)
;
nsIContent
*
GetLeftmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
=
false
)
;
bool
CanContain
(
nsINode
&
aParent
nsIContent
&
aChild
)
const
;
bool
CanContainTag
(
nsINode
&
aParent
nsAtom
&
aTag
)
const
;
bool
TagCanContain
(
nsAtom
&
aParentTag
nsIContent
&
aChild
)
const
;
virtual
bool
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
const
;
bool
IsRoot
(
nsINode
*
inNode
)
const
;
bool
IsEditorRoot
(
nsINode
*
aNode
)
const
;
bool
IsDescendantOfRoot
(
nsINode
*
inNode
)
const
;
bool
IsDescendantOfEditorRoot
(
nsINode
*
aNode
)
const
;
virtual
bool
IsContainer
(
nsINode
*
aNode
)
;
bool
IsEditable
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
if
(
!
aNode
-
>
IsContent
(
)
|
|
IsMozEditorBogusNode
(
aNode
)
|
|
!
IsModifiableNode
(
*
aNode
)
)
{
return
false
;
}
switch
(
aNode
-
>
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
return
mIsHTMLEditorClass
?
aNode
-
>
IsEditable
(
)
:
true
;
case
nsINode
:
:
TEXT_NODE
:
return
true
;
default
:
return
false
;
}
}
bool
IsElementOrText
(
const
nsINode
&
aNode
)
const
{
if
(
!
aNode
.
IsContent
(
)
|
|
IsMozEditorBogusNode
(
&
aNode
)
)
{
return
false
;
}
return
aNode
.
NodeType
(
)
=
=
nsINode
:
:
ELEMENT_NODE
|
|
aNode
.
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
;
}
bool
IsMozEditorBogusNode
(
const
nsINode
*
aNode
)
const
{
return
aNode
&
&
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
eCaseMatters
)
;
}
uint32_t
CountEditableChildren
(
nsINode
*
aNode
)
;
nsINode
*
GetFirstEditableNode
(
nsINode
*
aRoot
)
;
bool
ShouldHandleIMEComposition
(
)
const
;
virtual
bool
AreNodesSameType
(
nsIContent
*
aNode1
nsIContent
*
aNode2
)
;
static
bool
IsTextNode
(
nsINode
*
aNode
)
{
return
aNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
;
}
bool
IsModifiableNode
(
const
nsINode
&
aNode
)
const
;
static
nsIContent
*
GetNodeAtRangeOffsetPoint
(
nsINode
*
aContainer
int32_t
aOffset
)
{
return
GetNodeAtRangeOffsetPoint
(
RawRangeBoundary
(
aContainer
aOffset
)
)
;
}
static
nsIContent
*
GetNodeAtRangeOffsetPoint
(
const
RawRangeBoundary
&
aPoint
)
;
static
EditorRawDOMPoint
GetStartPoint
(
Selection
*
aSelection
)
;
static
EditorRawDOMPoint
GetEndPoint
(
Selection
*
aSelection
)
;
static
nsresult
GetEndChildNode
(
Selection
*
aSelection
nsIContent
*
*
aEndNode
)
;
nsresult
CollapseSelectionToEnd
(
Selection
*
aSelection
)
;
nsresult
CreateRange
(
nsINode
*
aStartContainer
int32_t
aStartOffset
nsINode
*
aEndContainer
int32_t
aEndOffset
nsRange
*
*
aRange
)
;
static
bool
IsPreformatted
(
nsINode
*
aNode
)
;
inline
bool
AllowsTransactionsToChangeSelection
(
)
const
{
return
mAllowsTransactionsToChangeSelection
;
}
inline
void
MakeThisAllowTransactionsToChangeSelection
(
bool
aAllow
)
{
mAllowsTransactionsToChangeSelection
=
aAllow
;
}
nsresult
HandleInlineSpellCheck
(
EditSubAction
aEditSubAction
Selection
&
aSelection
nsINode
*
previousSelectedNode
uint32_t
previousSelectedOffset
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
virtual
Element
*
GetEditorRoot
(
)
const
;
Element
*
GetExposedRoot
(
)
const
;
virtual
bool
IsActiveInDOMWindow
(
)
;
int32_t
GetIMESelectionStartOffsetIn
(
nsINode
*
aTextNode
)
;
EditorRawDOMPoint
FindBetterInsertionPoint
(
const
EditorRawDOMPoint
&
aPoint
)
;
void
HideCaret
(
bool
aHide
)
;
protected
:
virtual
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
;
virtual
void
OnEndHandlingTopLevelEditSubAction
(
)
;
bool
ArePreservingSelection
(
)
;
void
PreserveSelectionAcrossActions
(
Selection
*
aSel
)
;
nsresult
RestorePreservedSelection
(
Selection
*
aSel
)
;
void
StopPreservingSelection
(
)
;
void
BeginPlaceholderTransaction
(
nsAtom
*
aTransactionName
)
;
void
EndPlaceholderTransaction
(
)
;
void
BeginUpdateViewBatch
(
)
;
void
EndUpdateViewBatch
(
)
;
protected
:
virtual
~
EditorBase
(
)
;
nsresult
GetDocumentCharsetInternal
(
nsACString
&
aCharset
)
const
;
virtual
nsresult
SelectAllInternal
(
)
;
nsresult
DetermineCurrentDirection
(
)
;
void
FireInputEvent
(
)
;
void
DoAfterDoTransaction
(
nsITransaction
*
aTxn
)
;
void
DoAfterUndoTransaction
(
)
;
void
DoAfterRedoTransaction
(
)
;
enum
TDocumentListenerNotification
{
eDocumentCreated
eDocumentToBeDestroyed
eDocumentStateChanged
}
;
nsresult
NotifyDocumentListeners
(
TDocumentListenerNotification
aNotificationType
)
;
virtual
nsresult
SelectEntireDocument
(
Selection
*
aSelection
)
;
nsresult
ScrollSelectionIntoView
(
bool
aScrollToAnchor
)
;
nsIContent
*
FindNextLeafNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
bNoBlockCrossing
)
;
nsIContent
*
FindNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
aEditableNode
bool
aFindAnyDataNode
bool
bNoBlockCrossing
)
;
nsIContent
*
GetPreviousNodeInternal
(
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
;
nsIContent
*
GetPreviousNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
;
nsIContent
*
GetNextNodeInternal
(
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
bNoBlockCrossing
)
;
nsIContent
*
GetNextNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
;
virtual
nsresult
InstallEventListeners
(
)
;
virtual
void
CreateEventListeners
(
)
;
virtual
void
RemoveEventListeners
(
)
;
virtual
already_AddRefed
<
nsIContent
>
GetInputEventTargetContent
(
)
=
0
;
bool
GetDesiredSpellCheckState
(
)
;
bool
CanEnableSpellCheck
(
)
{
return
!
IsPasswordEditor
(
)
&
&
!
IsReadonly
(
)
&
&
!
IsDisabled
(
)
&
&
!
ShouldSkipSpellCheck
(
)
;
}
virtual
void
InitializeSelectionAncestorLimit
(
Selection
&
aSelection
nsIContent
&
aAncestorLimit
)
;
static
int32_t
GetChildOffset
(
nsINode
*
aChild
nsINode
*
aParent
)
;
nsresult
AppendNodeToSelectionAsRange
(
nsINode
*
aNode
)
;
nsresult
ClearSelection
(
)
;
nsresult
InitializeSelection
(
dom
:
:
EventTarget
*
aFocusEventTarget
)
;
virtual
nsresult
InsertFromDataTransfer
(
dom
:
:
DataTransfer
*
aDataTransfer
int32_t
aIndex
nsIDocument
*
aSourceDoc
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
=
0
;
enum
NotificationForEditorObservers
{
eNotifyEditorObserversOfEnd
eNotifyEditorObserversOfBefore
eNotifyEditorObserversOfCancel
}
;
void
NotifyEditorObservers
(
NotificationForEditorObservers
aNotification
)
;
private
:
nsCOMPtr
<
nsISelectionController
>
mSelectionController
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
nsresult
SetTextDirectionTo
(
TextDirection
aTextDirection
)
;
protected
:
enum
Tristate
{
eTriUnset
eTriFalse
eTriTrue
}
;
nsCString
mContentMIMEType
;
RefPtr
<
mozInlineSpellChecker
>
mInlineSpellChecker
;
RefPtr
<
TextServicesDocument
>
mTextServicesDocument
;
RefPtr
<
TransactionManager
>
mTransactionManager
;
RefPtr
<
Element
>
mRootElement
;
nsCOMPtr
<
dom
:
:
EventTarget
>
mEventTarget
;
RefPtr
<
EditorEventListener
>
mEventListener
;
RefPtr
<
PlaceholderTransaction
>
mPlaceholderTransaction
;
nsAtom
*
mPlaceholderName
;
mozilla
:
:
Maybe
<
SelectionState
>
mSelState
;
RefPtr
<
TextComposition
>
mComposition
;
RefPtr
<
TextEditRules
>
mRules
;
RefPtr
<
TextInputListener
>
mTextInputListener
;
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditActionListener
>
5
>
AutoActionListenerArray
;
AutoActionListenerArray
mActionListeners
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditorObserver
>
3
>
AutoEditorObserverArray
;
AutoEditorObserverArray
mEditorObservers
;
typedef
AutoTArray
<
OwningNonNull
<
nsIDocumentStateListener
>
1
>
AutoDocumentStateListenerArray
;
AutoDocumentStateListenerArray
mDocStateListeners
;
SelectionState
mSavedSel
;
RangeUpdater
mRangeUpdater
;
uint32_t
mModCount
;
uint32_t
mFlags
;
int32_t
mUpdateCount
;
int32_t
mPlaceholderBatch
;
EditSubAction
mTopLevelEditSubAction
;
EDirection
mDirection
;
int8_t
mDocDirtyState
;
uint8_t
mSpellcheckCheckboxState
;
bool
mAllowsTransactionsToChangeSelection
;
bool
mDidPreDestroy
;
bool
mDidPostCreate
;
bool
mDispatchInputEvent
;
bool
mIsInEditSubAction
;
bool
mHidingCaret
;
bool
mSpellCheckerDictionaryUpdated
;
bool
mIsHTMLEditorClass
;
friend
class
AutoPlaceholderBatch
;
friend
class
AutoSelectionRestorer
;
friend
class
AutoTopLevelEditSubActionNotifier
;
friend
class
AutoTransactionsConserveSelection
;
friend
class
AutoUpdateViewBatch
;
friend
class
CompositionTransaction
;
friend
class
CreateElementTransaction
;
friend
class
CSSEditUtils
;
friend
class
DeleteNodeTransaction
;
friend
class
DeleteRangeTransaction
;
friend
class
DeleteTextTransaction
;
friend
class
HTMLEditRules
;
friend
class
HTMLEditUtils
;
friend
class
InsertNodeTransaction
;
friend
class
InsertTextTransaction
;
friend
class
JoinNodeTransaction
;
friend
class
SplitNodeTransaction
;
friend
class
TextEditRules
;
friend
class
TypeInState
;
friend
class
WSRunObject
;
friend
class
nsIEditor
;
}
;
}
mozilla
:
:
EditorBase
*
nsIEditor
:
:
AsEditorBase
(
)
{
return
static_cast
<
mozilla
:
:
EditorBase
*
>
(
this
)
;
}
const
mozilla
:
:
EditorBase
*
nsIEditor
:
:
AsEditorBase
(
)
const
{
return
static_cast
<
const
mozilla
:
:
EditorBase
*
>
(
this
)
;
}
#
endif
