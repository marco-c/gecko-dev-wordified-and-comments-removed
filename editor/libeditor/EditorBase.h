#
ifndef
mozilla_EditorBase_h
#
define
mozilla_EditorBase_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nscore
.
h
"
class
nsIAtom
;
class
nsIContent
;
class
nsIDOMDocument
;
class
nsIDOMEvent
;
class
nsIDOMEventListener
;
class
nsIDOMEventTarget
;
class
nsIDOMNode
;
class
nsIDocumentStateListener
;
class
nsIEditActionListener
;
class
nsIEditorObserver
;
class
nsIInlineSpellChecker
;
class
nsINode
;
class
nsIPresShell
;
class
nsISupports
;
class
nsITransaction
;
class
nsIWidget
;
class
nsRange
;
class
nsString
;
class
nsTransactionManager
;
enum
class
EditAction
:
int32_t
{
ignore
=
-
1
none
=
0
undo
redo
insertNode
createNode
deleteNode
splitNode
joinNode
deleteText
=
1003
insertText
=
2000
insertIMEText
=
2001
deleteSelection
=
2002
setTextProperty
=
2003
removeTextProperty
=
2004
outputText
=
2005
setText
=
2006
insertBreak
=
3000
makeList
=
3001
indent
=
3002
outdent
=
3003
align
=
3004
makeBasicBlock
=
3005
removeList
=
3006
makeDefListItem
=
3007
insertElement
=
3008
insertQuotation
=
3009
htmlPaste
=
3012
loadHTML
=
3013
resetTextProperties
=
3014
setAbsolutePosition
=
3015
removeAbsolutePosition
=
3016
decreaseZIndex
=
3017
increaseZIndex
=
3018
}
;
inline
bool
operator
!
(
const
EditAction
&
aOp
)
{
return
aOp
=
=
EditAction
:
:
none
;
}
namespace
mozilla
{
class
AddStyleSheetTransaction
;
class
AutoRules
;
class
AutoSelectionRestorer
;
class
AutoTransactionsConserveSelection
;
class
ChangeAttributeTransaction
;
class
CompositionTransaction
;
class
CreateElementTransaction
;
class
DeleteNodeTransaction
;
class
DeleteTextTransaction
;
class
EditAggregateTransaction
;
class
EditTransactionBase
;
class
ErrorResult
;
class
HTMLEditor
;
class
InsertNodeTransaction
;
class
InsertTextTransaction
;
class
JoinNodeTransaction
;
class
PlaceholderTransaction
;
class
RemoveStyleSheetTransaction
;
class
SetTextTransaction
;
class
SplitNodeTransaction
;
class
TextComposition
;
class
TextEditor
;
struct
EditorDOMPoint
;
namespace
dom
{
class
DataTransfer
;
class
Element
;
class
EventTarget
;
class
Selection
;
class
Text
;
}
namespace
widget
{
struct
IMEState
;
}
template
<
class
T
>
class
CachedWeakPtr
final
{
public
:
CachedWeakPtr
<
T
>
(
)
:
mCache
(
nullptr
)
{
}
CachedWeakPtr
<
T
>
&
operator
=
(
T
*
aObject
)
{
mWeakPtr
=
do_GetWeakReference
(
aObject
)
;
mCache
=
aObject
;
return
*
this
;
}
CachedWeakPtr
<
T
>
&
operator
=
(
const
nsCOMPtr
<
T
>
&
aOther
)
{
mWeakPtr
=
do_GetWeakReference
(
aOther
)
;
mCache
=
aOther
;
return
*
this
;
}
CachedWeakPtr
<
T
>
&
operator
=
(
already_AddRefed
<
T
>
&
aOther
)
{
nsCOMPtr
<
T
>
other
=
aOther
;
mWeakPtr
=
do_GetWeakReference
(
other
)
;
mCache
=
other
;
return
*
this
;
}
bool
IsAlive
(
)
const
{
return
mWeakPtr
&
&
mWeakPtr
-
>
IsAlive
(
)
;
}
explicit
operator
bool
(
)
const
{
return
mWeakPtr
;
}
operator
T
*
(
)
const
{
return
get
(
)
;
}
T
*
get
(
)
const
{
if
(
mCache
&
&
!
mWeakPtr
-
>
IsAlive
(
)
)
{
const_cast
<
CachedWeakPtr
<
T
>
*
>
(
this
)
-
>
mCache
=
nullptr
;
}
return
mCache
;
}
private
:
nsWeakPtr
mWeakPtr
;
T
*
MOZ_NON_OWNING_REF
mCache
;
}
;
#
define
kMOZEditorBogusNodeAttrAtom
nsGkAtoms
:
:
mozeditorbogusnode
#
define
kMOZEditorBogusNodeValue
NS_LITERAL_STRING
(
"
TRUE
"
)
class
EditorBase
:
public
nsIEditor
public
nsSupportsWeakReference
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
enum
IterDirection
{
kIterForward
kIterBackward
}
;
EditorBase
(
)
;
virtual
TextEditor
*
AsTextEditor
(
)
=
0
;
virtual
const
TextEditor
*
AsTextEditor
(
)
const
=
0
;
virtual
HTMLEditor
*
AsHTMLEditor
(
)
=
0
;
virtual
const
HTMLEditor
*
AsHTMLEditor
(
)
const
=
0
;
protected
:
virtual
~
EditorBase
(
)
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
EditorBase
nsIEditor
)
bool
IsInitialized
(
)
const
{
return
!
!
mDocumentWeak
;
}
already_AddRefed
<
nsIDOMDocument
>
GetDOMDocument
(
)
;
already_AddRefed
<
nsIDocument
>
GetDocument
(
)
;
already_AddRefed
<
nsIPresShell
>
GetPresShell
(
)
;
already_AddRefed
<
nsIWidget
>
GetWidget
(
)
;
enum
NotificationForEditorObservers
{
eNotifyEditorObserversOfEnd
eNotifyEditorObserversOfBefore
eNotifyEditorObserversOfCancel
}
;
void
NotifyEditorObservers
(
NotificationForEditorObservers
aNotification
)
;
NS_DECL_NSIEDITOR
public
:
virtual
bool
IsModifiableNode
(
nsINode
*
aNode
)
;
virtual
nsresult
InsertTextImpl
(
const
nsAString
&
aStringToInsert
nsCOMPtr
<
nsINode
>
*
aInOutNode
int32_t
*
aInOutOffset
nsIDocument
*
aDoc
)
;
nsresult
InsertTextIntoTextNodeImpl
(
const
nsAString
&
aStringToInsert
Text
&
aTextNode
int32_t
aOffset
bool
aSuppressIME
=
false
)
;
nsresult
SetTextImpl
(
const
nsAString
&
aString
Text
&
aTextNode
)
;
NS_IMETHOD
DeleteSelectionImpl
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
;
already_AddRefed
<
Element
>
DeleteSelectionAndCreateElement
(
nsIAtom
&
aTag
)
;
nsresult
DeleteNode
(
nsINode
*
aNode
)
;
nsresult
InsertNode
(
nsIContent
&
aNode
nsINode
&
aParent
int32_t
aPosition
)
;
enum
ECloneAttributes
{
eDontCloneAttributes
eCloneAttributes
}
;
already_AddRefed
<
Element
>
ReplaceContainer
(
Element
*
aOldContainer
nsIAtom
*
aNodeType
nsIAtom
*
aAttribute
=
nullptr
const
nsAString
*
aValue
=
nullptr
ECloneAttributes
aCloneAttributes
=
eDontCloneAttributes
)
;
void
CloneAttributes
(
Element
*
aDest
Element
*
aSource
)
;
nsresult
RemoveContainer
(
nsIContent
*
aNode
)
;
already_AddRefed
<
Element
>
InsertContainerAbove
(
nsIContent
*
aNode
nsIAtom
*
aNodeType
nsIAtom
*
aAttribute
=
nullptr
const
nsAString
*
aValue
=
nullptr
)
;
nsIContent
*
SplitNode
(
nsIContent
&
aNode
int32_t
aOffset
ErrorResult
&
aResult
)
;
nsresult
JoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
nsresult
MoveNode
(
nsIContent
*
aNode
nsINode
*
aParent
int32_t
aOffset
)
;
nsresult
CloneAttribute
(
nsIAtom
*
aAttribute
Element
*
aDestElement
Element
*
aSourceElement
)
;
nsresult
RemoveAttribute
(
Element
*
aElement
nsIAtom
*
aAttribute
)
;
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsIAtom
*
aAttribute
bool
aSuppressTransaction
)
=
0
;
nsresult
SetAttribute
(
Element
*
aElement
nsIAtom
*
aAttribute
const
nsAString
&
aValue
)
;
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsIAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
=
0
;
already_AddRefed
<
Element
>
CreateHTMLContent
(
nsIAtom
*
aTag
)
;
virtual
nsresult
BeginIMEComposition
(
WidgetCompositionEvent
*
aEvent
)
;
virtual
nsresult
UpdateIMEComposition
(
WidgetCompositionEvent
*
aCompositionChangeEvet
)
=
0
;
void
EndIMEComposition
(
)
;
void
SwitchTextDirectionTo
(
uint32_t
aDirection
)
;
protected
:
nsresult
DetermineCurrentDirection
(
)
;
void
FireInputEvent
(
)
;
already_AddRefed
<
ChangeAttributeTransaction
>
CreateTxnForSetAttribute
(
Element
&
aElement
nsIAtom
&
aAttribute
const
nsAString
&
aValue
)
;
already_AddRefed
<
ChangeAttributeTransaction
>
CreateTxnForRemoveAttribute
(
Element
&
aElement
nsIAtom
&
aAttribute
)
;
already_AddRefed
<
CreateElementTransaction
>
CreateTxnForCreateElement
(
nsIAtom
&
aTag
nsINode
&
aParent
int32_t
aPosition
)
;
already_AddRefed
<
Element
>
CreateNode
(
nsIAtom
*
aTag
nsINode
*
aParent
int32_t
aPosition
)
;
already_AddRefed
<
InsertNodeTransaction
>
CreateTxnForInsertNode
(
nsIContent
&
aNode
nsINode
&
aParent
int32_t
aOffset
)
;
already_AddRefed
<
DeleteNodeTransaction
>
CreateTxnForDeleteNode
(
nsINode
*
aNode
)
;
already_AddRefed
<
EditAggregateTransaction
>
CreateTxnForDeleteSelection
(
EDirection
aAction
nsINode
*
*
aNode
int32_t
*
aOffset
int32_t
*
aLength
)
;
already_AddRefed
<
EditTransactionBase
>
CreateTxnForDeleteRange
(
nsRange
*
aRangeToDelete
EDirection
aAction
nsINode
*
*
aRemovingNode
int32_t
*
aOffset
int32_t
*
aLength
)
;
already_AddRefed
<
mozilla
:
:
InsertTextTransaction
>
CreateTxnForInsertText
(
const
nsAString
&
aStringToInsert
Text
&
aTextNode
int32_t
aOffset
)
;
already_AddRefed
<
SetTextTransaction
>
CreateTxnForSetText
(
const
nsAString
&
aString
Text
&
aTextNode
)
;
already_AddRefed
<
mozilla
:
:
CompositionTransaction
>
CreateTxnForComposition
(
const
nsAString
&
aStringToInsert
)
;
already_AddRefed
<
mozilla
:
:
AddStyleSheetTransaction
>
CreateTxnForAddStyleSheet
(
StyleSheet
*
aSheet
)
;
already_AddRefed
<
mozilla
:
:
RemoveStyleSheetTransaction
>
CreateTxnForRemoveStyleSheet
(
StyleSheet
*
aSheet
)
;
nsresult
DeleteText
(
nsGenericDOMDataNode
&
aElement
uint32_t
aOffset
uint32_t
aLength
)
;
already_AddRefed
<
DeleteTextTransaction
>
CreateTxnForDeleteText
(
nsGenericDOMDataNode
&
aElement
uint32_t
aOffset
uint32_t
aLength
)
;
already_AddRefed
<
DeleteTextTransaction
>
CreateTxnForDeleteCharacter
(
nsGenericDOMDataNode
&
aData
uint32_t
aOffset
EDirection
aDirection
)
;
already_AddRefed
<
SplitNodeTransaction
>
CreateTxnForSplitNode
(
nsIContent
&
aNode
uint32_t
aOffset
)
;
already_AddRefed
<
JoinNodeTransaction
>
CreateTxnForJoinNode
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
nsresult
DeleteSelectionAndPrepareToCreateNode
(
)
;
void
DoAfterDoTransaction
(
nsITransaction
*
aTxn
)
;
void
DoAfterUndoTransaction
(
)
;
void
DoAfterRedoTransaction
(
)
;
enum
TDocumentListenerNotification
{
eDocumentCreated
eDocumentToBeDestroyed
eDocumentStateChanged
}
;
nsresult
NotifyDocumentListeners
(
TDocumentListenerNotification
aNotificationType
)
;
virtual
nsresult
SelectEntireDocument
(
Selection
*
aSelection
)
;
nsresult
ScrollSelectionIntoView
(
bool
aScrollToAnchor
)
;
virtual
bool
IsBlockNode
(
nsINode
*
aNode
)
;
nsIContent
*
FindNextLeafNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
bNoBlockCrossing
)
;
virtual
nsresult
InstallEventListeners
(
)
;
virtual
void
CreateEventListeners
(
)
;
virtual
void
RemoveEventListeners
(
)
;
bool
GetDesiredSpellCheckState
(
)
;
bool
CanEnableSpellCheck
(
)
{
return
!
IsPasswordEditor
(
)
&
&
!
IsReadonly
(
)
&
&
!
IsDisabled
(
)
&
&
!
ShouldSkipSpellCheck
(
)
;
}
bool
EnsureComposition
(
WidgetCompositionEvent
*
aCompositionEvent
)
;
already_AddRefed
<
nsISelectionController
>
GetSelectionController
(
)
;
nsresult
GetSelection
(
SelectionType
aSelectionType
nsISelection
*
*
aSelection
)
;
public
:
NS_IMETHOD
StartOperation
(
EditAction
opID
nsIEditor
:
:
EDirection
aDirection
)
;
NS_IMETHOD
EndOperation
(
)
;
bool
ArePreservingSelection
(
)
;
void
PreserveSelectionAcrossActions
(
Selection
*
aSel
)
;
nsresult
RestorePreservedSelection
(
Selection
*
aSel
)
;
void
StopPreservingSelection
(
)
;
nsresult
SplitNodeImpl
(
nsIContent
&
aExistingRightNode
int32_t
aOffset
nsIContent
&
aNewLeftNode
)
;
nsresult
JoinNodesImpl
(
nsINode
*
aNodeToKeep
nsINode
*
aNodeToJoin
nsINode
*
aParent
)
;
static
int32_t
GetChildOffset
(
nsIDOMNode
*
aChild
nsIDOMNode
*
aParent
)
;
static
already_AddRefed
<
nsIDOMNode
>
GetNodeLocation
(
nsIDOMNode
*
aChild
int32_t
*
outOffset
)
;
static
nsINode
*
GetNodeLocation
(
nsINode
*
aChild
int32_t
*
aOffset
)
;
static
nsresult
GetLengthOfDOMNode
(
nsIDOMNode
*
aNode
uint32_t
&
aCount
)
;
nsIContent
*
GetPriorNode
(
nsINode
*
aCurrentNode
bool
aEditableNode
bool
aNoBlockCrossing
=
false
)
;
nsIContent
*
GetPriorNode
(
nsINode
*
aParentNode
int32_t
aOffset
bool
aEditableNode
bool
aNoBlockCrossing
=
false
)
;
nsIContent
*
GetNextNode
(
nsINode
*
aCurrentNode
bool
aEditableNode
bool
bNoBlockCrossing
=
false
)
;
nsIContent
*
GetNextNode
(
nsINode
*
aParentNode
int32_t
aOffset
bool
aEditableNode
bool
aNoBlockCrossing
=
false
)
;
nsIContent
*
FindNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
aEditableNode
bool
bNoBlockCrossing
)
;
nsIContent
*
GetRightmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
=
false
)
;
nsIContent
*
GetLeftmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
=
false
)
;
static
inline
bool
NodeIsType
(
nsIDOMNode
*
aNode
nsIAtom
*
aTag
)
{
return
GetTag
(
aNode
)
=
=
aTag
;
}
bool
CanContain
(
nsINode
&
aParent
nsIContent
&
aChild
)
;
bool
CanContainTag
(
nsINode
&
aParent
nsIAtom
&
aTag
)
;
bool
TagCanContain
(
nsIAtom
&
aParentTag
nsIContent
&
aChild
)
;
virtual
bool
TagCanContainTag
(
nsIAtom
&
aParentTag
nsIAtom
&
aChildTag
)
;
bool
IsRoot
(
nsIDOMNode
*
inNode
)
;
bool
IsRoot
(
nsINode
*
inNode
)
;
bool
IsEditorRoot
(
nsINode
*
aNode
)
;
bool
IsDescendantOfRoot
(
nsIDOMNode
*
inNode
)
;
bool
IsDescendantOfRoot
(
nsINode
*
inNode
)
;
bool
IsDescendantOfEditorRoot
(
nsINode
*
aNode
)
;
virtual
bool
IsContainer
(
nsINode
*
aNode
)
;
virtual
bool
IsContainer
(
nsIDOMNode
*
aNode
)
;
bool
IsEditable
(
nsIDOMNode
*
aNode
)
;
virtual
bool
IsEditable
(
nsINode
*
aNode
)
;
bool
IsMozEditorBogusNode
(
nsINode
*
aNode
)
;
uint32_t
CountEditableChildren
(
nsINode
*
aNode
)
;
nsINode
*
GetFirstEditableNode
(
nsINode
*
aRoot
)
;
TextComposition
*
GetComposition
(
)
const
;
bool
IsIMEComposing
(
)
const
;
bool
ShouldHandleIMEComposition
(
)
const
;
static
nsresult
GetTagString
(
nsIDOMNode
*
aNode
nsAString
&
outString
)
;
static
nsIAtom
*
GetTag
(
nsIDOMNode
*
aNode
)
;
bool
NodesSameType
(
nsIDOMNode
*
aNode1
nsIDOMNode
*
aNode2
)
;
virtual
bool
AreNodesSameType
(
nsIContent
*
aNode1
nsIContent
*
aNode2
)
;
static
bool
IsTextNode
(
nsIDOMNode
*
aNode
)
;
static
bool
IsTextNode
(
nsINode
*
aNode
)
;
static
nsCOMPtr
<
nsIDOMNode
>
GetChildAt
(
nsIDOMNode
*
aParent
int32_t
aOffset
)
;
static
nsIContent
*
GetNodeAtRangeOffsetPoint
(
nsIDOMNode
*
aParentOrNode
int32_t
aOffset
)
;
static
nsresult
GetStartNodeAndOffset
(
Selection
*
aSelection
nsIDOMNode
*
*
outStartNode
int32_t
*
outStartOffset
)
;
static
nsresult
GetStartNodeAndOffset
(
Selection
*
aSelection
nsINode
*
*
aStartNode
int32_t
*
aStartOffset
)
;
static
nsresult
GetEndNodeAndOffset
(
Selection
*
aSelection
nsIDOMNode
*
*
outEndNode
int32_t
*
outEndOffset
)
;
static
nsresult
GetEndNodeAndOffset
(
Selection
*
aSelection
nsINode
*
*
aEndNode
int32_t
*
aEndOffset
)
;
#
if
DEBUG_JOE
static
void
DumpNode
(
nsIDOMNode
*
aNode
int32_t
indent
=
0
)
;
#
endif
Selection
*
GetSelection
(
SelectionType
aSelectionType
=
SelectionType
:
:
eNormal
)
;
nsresult
CreateRange
(
nsIDOMNode
*
aStartParent
int32_t
aStartOffset
nsIDOMNode
*
aEndParent
int32_t
aEndOffset
nsRange
*
*
aRange
)
;
nsresult
AppendNodeToSelectionAsRange
(
nsIDOMNode
*
aNode
)
;
nsresult
ClearSelection
(
)
;
nsresult
IsPreformatted
(
nsIDOMNode
*
aNode
bool
*
aResult
)
;
enum
class
EmptyContainers
{
no
yes
}
;
int32_t
SplitNodeDeep
(
nsIContent
&
aNode
nsIContent
&
aSplitPointParent
int32_t
aSplitPointOffset
EmptyContainers
aEmptyContainers
=
EmptyContainers
:
:
yes
nsIContent
*
*
outLeftNode
=
nullptr
nsIContent
*
*
outRightNode
=
nullptr
)
;
EditorDOMPoint
JoinNodeDeep
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
;
nsresult
GetString
(
const
nsAString
&
name
nsAString
&
value
)
;
void
BeginUpdateViewBatch
(
)
;
virtual
nsresult
EndUpdateViewBatch
(
)
;
bool
GetShouldTxnSetSelection
(
)
;
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
;
nsresult
HandleInlineSpellCheck
(
EditAction
action
Selection
*
aSelection
nsIDOMNode
*
previousSelectedNode
int32_t
previousSelectedOffset
nsIDOMNode
*
aStartNode
int32_t
aStartOffset
nsIDOMNode
*
aEndNode
int32_t
aEndOffset
)
;
virtual
already_AddRefed
<
dom
:
:
EventTarget
>
GetDOMEventTarget
(
)
=
0
;
Element
*
GetRoot
(
)
;
virtual
Element
*
GetEditorRoot
(
)
;
Element
*
GetExposedRoot
(
)
;
bool
IsPlaintextEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorPlaintextMask
)
!
=
0
;
}
bool
IsSingleLineEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorSingleLineMask
)
!
=
0
;
}
bool
IsPasswordEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorPasswordMask
)
!
=
0
;
}
bool
IsReadonly
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
!
=
0
;
}
bool
IsDisabled
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorDisabledMask
)
!
=
0
;
}
bool
IsInputFiltered
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorFilterInputMask
)
!
=
0
;
}
bool
IsMailEditor
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
!
=
0
;
}
bool
IsWrapHackEnabled
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorEnableWrapHackMask
)
!
=
0
;
}
bool
IsFormWidget
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorWidgetMask
)
!
=
0
;
}
bool
NoCSS
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorNoCSSMask
)
!
=
0
;
}
bool
IsInteractionAllowed
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorAllowInteraction
)
!
=
0
;
}
bool
DontEchoPassword
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorDontEchoPassword
)
!
=
0
;
}
bool
ShouldSkipSpellCheck
(
)
const
{
return
(
mFlags
&
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
)
!
=
0
;
}
bool
IsTabbable
(
)
const
{
return
IsSingleLineEditor
(
)
|
|
IsPasswordEditor
(
)
|
|
IsFormWidget
(
)
|
|
IsInteractionAllowed
(
)
;
}
bool
HasIndependentSelection
(
)
const
{
return
!
!
mSelectionControllerWeak
;
}
bool
IsModifiable
(
)
const
{
return
!
IsReadonly
(
)
;
}
virtual
already_AddRefed
<
nsIContent
>
GetInputEventTargetContent
(
)
=
0
;
virtual
already_AddRefed
<
nsIContent
>
GetFocusedContent
(
)
;
virtual
already_AddRefed
<
nsIContent
>
GetFocusedContentForIME
(
)
;
virtual
bool
IsActiveInDOMWindow
(
)
;
virtual
bool
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
;
virtual
already_AddRefed
<
nsIContent
>
FindSelectionRoot
(
nsINode
*
aNode
)
;
nsresult
InitializeSelection
(
nsIDOMEventTarget
*
aFocusEventTarget
)
;
void
OnFocus
(
nsIDOMEventTarget
*
aFocusEventTarget
)
;
virtual
nsresult
InsertFromDataTransfer
(
dom
:
:
DataTransfer
*
aDataTransfer
int32_t
aIndex
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
=
0
;
virtual
nsresult
InsertFromDrop
(
nsIDOMEvent
*
aDropEvent
)
=
0
;
int32_t
GetIMESelectionStartOffsetIn
(
nsINode
*
aTextNode
)
;
void
FindBetterInsertionPoint
(
nsCOMPtr
<
nsIDOMNode
>
&
aNode
int32_t
&
aOffset
)
;
void
FindBetterInsertionPoint
(
nsCOMPtr
<
nsINode
>
&
aNode
int32_t
&
aOffset
)
;
void
HideCaret
(
bool
aHide
)
;
private
:
CachedWeakPtr
<
nsISelectionController
>
mSelectionControllerWeak
;
CachedWeakPtr
<
nsIDocument
>
mDocumentWeak
;
protected
:
enum
Tristate
{
eTriUnset
eTriFalse
eTriTrue
}
;
nsCString
mContentMIMEType
;
nsCOMPtr
<
nsIInlineSpellChecker
>
mInlineSpellChecker
;
RefPtr
<
nsTransactionManager
>
mTxnMgr
;
nsCOMPtr
<
Element
>
mRootElement
;
RefPtr
<
Text
>
mIMETextNode
;
nsCOMPtr
<
dom
:
:
EventTarget
>
mEventTarget
;
nsCOMPtr
<
nsIDOMEventListener
>
mEventListener
;
WeakPtr
<
PlaceholderTransaction
>
mPlaceholderTransactionWeak
;
nsIAtom
*
mPlaceholderName
;
mozilla
:
:
UniquePtr
<
SelectionState
>
mSelState
;
RefPtr
<
TextComposition
>
mComposition
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditActionListener
>
5
>
AutoActionListenerArray
;
AutoActionListenerArray
mActionListeners
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditorObserver
>
3
>
AutoEditorObserverArray
;
AutoEditorObserverArray
mEditorObservers
;
typedef
AutoTArray
<
OwningNonNull
<
nsIDocumentStateListener
>
1
>
AutoDocumentStateListenerArray
;
AutoDocumentStateListenerArray
mDocStateListeners
;
SelectionState
mSavedSel
;
RangeUpdater
mRangeUpdater
;
uint32_t
mModCount
;
uint32_t
mFlags
;
int32_t
mUpdateCount
;
int32_t
mPlaceholderBatch
;
EditAction
mAction
;
uint32_t
mIMETextOffset
;
uint32_t
mIMETextLength
;
EDirection
mDirection
;
int8_t
mDocDirtyState
;
uint8_t
mSpellcheckCheckboxState
;
bool
mShouldTxnSetSelection
;
bool
mDidPreDestroy
;
bool
mDidPostCreate
;
bool
mDispatchInputEvent
;
bool
mIsInEditAction
;
bool
mHidingCaret
;
bool
mSpellCheckerDictionaryUpdated
;
friend
bool
NSCanUnload
(
nsISupports
*
serviceMgr
)
;
friend
class
AutoRules
;
friend
class
AutoSelectionRestorer
;
friend
class
AutoTransactionsConserveSelection
;
friend
class
RangeUpdater
;
}
;
}
#
endif
