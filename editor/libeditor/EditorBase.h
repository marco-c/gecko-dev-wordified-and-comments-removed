#
ifndef
mozilla_EditorBase_h
#
define
mozilla_EditorBase_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TypeInState
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nscore
.
h
"
class
mozInlineSpellChecker
;
class
nsAtom
;
class
nsCaret
;
class
nsIContent
;
class
nsIDocumentStateListener
;
class
nsIEditActionListener
;
class
nsIEditorObserver
;
class
nsINode
;
class
nsIPrincipal
;
class
nsISupports
;
class
nsITransferable
;
class
nsITransaction
;
class
nsITransactionListener
;
class
nsIWidget
;
class
nsRange
;
namespace
mozilla
{
class
AlignStateAtSelection
;
class
AutoRangeArray
;
class
AutoSelectionRestorer
;
class
AutoTopLevelEditSubActionNotifier
;
class
AutoTransactionBatch
;
class
AutoTransactionsConserveSelection
;
class
AutoUpdateViewBatch
;
class
ChangeAttributeTransaction
;
class
CompositionTransaction
;
class
CreateElementTransaction
;
class
CSSEditUtils
;
class
DeleteNodeTransaction
;
class
DeleteRangeTransaction
;
class
DeleteTextTransaction
;
class
EditActionResult
;
class
EditAggregateTransaction
;
class
EditorEventListener
;
class
EditTransactionBase
;
class
ErrorResult
;
class
HTMLEditor
;
class
HTMLEditUtils
;
class
IMEContentObserver
;
class
InsertNodeTransaction
;
class
InsertTextTransaction
;
class
JoinNodeTransaction
;
class
ListElementSelectionState
;
class
ListItemElementSelectionState
;
class
ParagraphStateAtSelection
;
class
PlaceholderTransaction
;
class
PresShell
;
class
ReplaceTextTransaction
;
class
SplitNodeResult
;
class
SplitNodeTransaction
;
class
TextComposition
;
class
TextEditor
;
class
TextInputListener
;
class
TextServicesDocument
;
class
TypeInState
;
class
WhiteSpaceVisibilityKeeper
;
template
<
typename
NodeType
>
class
CreateNodeResultBase
;
typedef
CreateNodeResultBase
<
dom
:
:
Element
>
CreateElementResult
;
namespace
dom
{
class
AbstractRange
;
class
DataTransfer
;
class
DragEvent
;
class
Element
;
class
EventTarget
;
class
HTMLBRElement
;
}
namespace
widget
{
struct
IMEState
;
}
class
EditorBase
:
public
nsIEditor
public
nsISelectionListener
public
nsSupportsWeakReference
{
public
:
typedef
dom
:
:
Document
Document
;
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
enum
class
EditorType
{
Text
HTML
}
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
EditorBase
nsIEditor
)
NS_DECL_NSIEDITOR
NS_DECL_NSISELECTIONLISTENER
EditorBase
(
)
;
bool
IsTextEditor
(
)
const
{
return
!
mIsHTMLEditorClass
;
}
bool
IsHTMLEditor
(
)
const
{
return
mIsHTMLEditorClass
;
}
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
Init
(
Document
&
doc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PostCreate
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
void
PreDestroy
(
bool
aDestroyingFrames
)
;
bool
IsInitialized
(
)
const
{
return
!
!
mDocument
;
}
bool
Destroyed
(
)
const
{
return
mDidPreDestroy
;
}
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
nsPIDOMWindowOuter
*
GetWindow
(
)
const
{
return
mDocument
?
mDocument
-
>
GetWindow
(
)
:
nullptr
;
}
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
{
return
mDocument
?
mDocument
-
>
GetInnerWindow
(
)
:
nullptr
;
}
bool
MaybeHasMutationEventListeners
(
uint32_t
aMutationEventType
=
0xFFFFFFFF
)
const
{
if
(
IsTextEditor
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
return
true
;
#
else
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
return
window
?
window
-
>
HasMutationListeners
(
aMutationEventType
)
:
false
;
#
endif
}
PresShell
*
GetPresShell
(
)
const
{
return
mDocument
?
mDocument
-
>
GetPresShell
(
)
:
nullptr
;
}
nsPresContext
*
GetPresContext
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
already_AddRefed
<
nsCaret
>
GetCaret
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
nullptr
;
}
return
presShell
-
>
GetCaret
(
)
;
}
already_AddRefed
<
nsIWidget
>
GetWidget
(
)
;
nsISelectionController
*
GetSelectionController
(
)
const
{
if
(
mSelectionController
)
{
return
mSelectionController
;
}
if
(
!
mDocument
)
{
return
nullptr
;
}
return
mDocument
-
>
GetPresShell
(
)
;
}
nsresult
GetSelection
(
SelectionType
aSelectionType
Selection
*
*
aSelection
)
const
;
Selection
*
GetSelection
(
SelectionType
aSelectionType
=
SelectionType
:
:
eNormal
)
const
{
if
(
aSelectionType
=
=
SelectionType
:
:
eNormal
&
&
IsEditActionDataAvailable
(
)
)
{
return
SelectionRefPtr
(
)
.
get
(
)
;
}
nsISelectionController
*
sc
=
GetSelectionController
(
)
;
if
(
!
sc
)
{
return
nullptr
;
}
Selection
*
selection
=
sc
-
>
GetSelection
(
ToRawSelectionType
(
aSelectionType
)
)
;
return
selection
;
}
Element
*
GetRoot
(
)
const
{
return
mRootElement
;
}
void
SetTextInputListener
(
TextInputListener
*
aTextInputListener
)
;
void
SetIMEContentObserver
(
IMEContentObserver
*
aIMEContentObserver
)
;
TextComposition
*
GetComposition
(
)
const
;
virtual
nsresult
GetPreferredIMEState
(
widget
:
:
IMEState
*
aState
)
;
bool
IsIMEComposing
(
)
const
;
nsresult
CommitComposition
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ToggleTextDirectionAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
enum
class
TextDirection
{
eLTR
eRTL
}
;
MOZ_CAN_RUN_SCRIPT
void
SwitchTextDirectionTo
(
TextDirection
aTextDirection
)
;
nsresult
FinalizeSelection
(
)
;
bool
IsSelectionEditable
(
)
;
size_t
NumberOfUndoItems
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfUndoItems
(
)
:
0
;
}
size_t
NumberOfRedoItems
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfRedoItems
(
)
:
0
;
}
int32_t
NumberOfMaximumTransactions
(
)
const
{
return
mTransactionManager
?
mTransactionManager
-
>
NumberOfMaximumTransactions
(
)
:
0
;
}
bool
IsUndoRedoEnabled
(
)
const
{
return
mTransactionManager
&
&
mTransactionManager
-
>
NumberOfMaximumTransactions
(
)
;
}
bool
CanUndo
(
)
const
{
return
IsUndoRedoEnabled
(
)
&
&
NumberOfUndoItems
(
)
>
0
;
}
bool
CanRedo
(
)
const
{
return
IsUndoRedoEnabled
(
)
&
&
NumberOfRedoItems
(
)
>
0
;
}
bool
EnableUndoRedo
(
int32_t
aMaxTransactionCount
=
-
1
)
{
if
(
!
mTransactionManager
)
{
mTransactionManager
=
new
TransactionManager
(
)
;
}
return
mTransactionManager
-
>
EnableUndoRedo
(
aMaxTransactionCount
)
;
}
bool
DisableUndoRedo
(
)
{
if
(
!
mTransactionManager
)
{
return
true
;
}
return
mTransactionManager
-
>
DisableUndoRedo
(
)
;
}
bool
ClearUndoRedo
(
)
{
if
(
!
mTransactionManager
)
{
return
true
;
}
return
mTransactionManager
-
>
ClearUndoRedo
(
)
;
}
bool
AddTransactionListener
(
nsITransactionListener
&
aListener
)
{
if
(
!
mTransactionManager
)
{
return
false
;
}
return
mTransactionManager
-
>
AddTransactionListener
(
aListener
)
;
}
bool
RemoveTransactionListener
(
nsITransactionListener
&
aListener
)
{
if
(
!
mTransactionManager
)
{
return
false
;
}
return
mTransactionManager
-
>
RemoveTransactionListener
(
aListener
)
;
}
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
;
virtual
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
const
=
0
;
void
SetWrapColumn
(
int32_t
aWrapColumn
)
{
mWrapColumn
=
aWrapColumn
;
}
uint32_t
Flags
(
)
const
{
return
mFlags
;
}
nsresult
AddFlags
(
uint32_t
aFlags
)
{
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
kOldFlags
|
aFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
nsresult
RemoveFlags
(
uint32_t
aFlags
)
{
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
kOldFlags
&
~
aFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
nsresult
AddAndRemoveFlags
(
uint32_t
aAddingFlags
uint32_t
aRemovingFlags
)
{
MOZ_ASSERT
(
!
(
aAddingFlags
&
aRemovingFlags
)
"
Same
flags
are
specified
both
adding
and
removing
"
)
;
const
uint32_t
kOldFlags
=
Flags
(
)
;
const
uint32_t
kNewFlags
=
(
(
kOldFlags
|
aAddingFlags
)
&
~
aRemovingFlags
)
;
if
(
kNewFlags
=
=
kOldFlags
)
{
return
NS_OK
;
}
return
SetFlags
(
kNewFlags
)
;
}
bool
IsPlaintextEditor
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorPlaintextMask
)
!
=
0
;
}
bool
IsSingleLineEditor
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorSingleLineMask
)
!
=
0
;
}
bool
IsPasswordEditor
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorPasswordMask
)
!
=
0
;
}
bool
IsRightToLeft
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorRightToLeft
)
!
=
0
;
}
bool
IsLeftToRight
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorLeftToRight
)
!
=
0
;
}
bool
IsReadonly
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorReadonlyMask
)
!
=
0
;
}
bool
IsInputFiltered
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorFilterInputMask
)
!
=
0
;
}
bool
IsMailEditor
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorMailMask
)
!
=
0
;
}
bool
IsWrapHackEnabled
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorEnableWrapHackMask
)
!
=
0
;
}
bool
IsFormWidget
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorWidgetMask
)
!
=
0
;
}
bool
NoCSS
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorNoCSSMask
)
!
=
0
;
}
bool
IsInteractionAllowed
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorAllowInteraction
)
!
=
0
;
}
bool
ShouldSkipSpellCheck
(
)
const
{
return
(
mFlags
&
nsIEditor
:
:
eEditorSkipSpellCheck
)
!
=
0
;
}
bool
IsTabbable
(
)
const
{
return
IsSingleLineEditor
(
)
|
|
IsPasswordEditor
(
)
|
|
IsFormWidget
(
)
|
|
IsInteractionAllowed
(
)
;
}
bool
HasIndependentSelection
(
)
const
{
return
!
!
mSelectionController
;
}
bool
IsModifiable
(
)
const
{
return
!
IsReadonly
(
)
;
}
bool
IsInEditSubAction
(
)
const
{
return
mIsInEditSubAction
;
}
void
SuppressDispatchingInputEvent
(
bool
aSuppress
)
{
mDispatchInputEvent
=
!
aSuppress
;
}
bool
IsSuppressingDispatchingInputEvent
(
)
const
{
return
!
mDispatchInputEvent
;
}
bool
OutputsMozDirty
(
)
const
{
return
!
IsInteractionAllowed
(
)
|
|
IsMailEditor
(
)
;
}
virtual
nsIContent
*
GetFocusedContent
(
)
const
;
virtual
nsIContent
*
GetFocusedContentForIME
(
)
const
;
virtual
bool
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
const
;
virtual
Element
*
FindSelectionRoot
(
nsINode
*
aNode
)
const
;
MOZ_CAN_RUN_SCRIPT
void
OnFocus
(
nsINode
&
aFocusEventTargetNode
)
;
void
SyncRealTimeSpell
(
)
;
MOZ_CAN_RUN_SCRIPT
void
ReinitializeSelection
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextAsAction
(
const
nsAString
&
aStringToInsert
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectionAsAction
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
protected
:
class
AutoEditActionDataSetter
;
struct
MOZ_STACK_CLASS
TopLevelEditSubActionData
final
{
friend
class
AutoEditActionDataSetter
;
RefPtr
<
Element
>
mNewBlockElement
;
RefPtr
<
RangeItem
>
mSelectedRange
;
RefPtr
<
nsRange
>
mChangedRange
;
Maybe
<
AutoStyleCacheArray
>
mCachedInlineStyles
;
bool
mDidDeleteSelection
;
bool
mDidExplicitlySetInterLine
;
bool
mDidDeleteNonCollapsedRange
;
bool
mDidDeleteEmptyParentBlocks
;
bool
mRestoreContentEditableCount
;
bool
mDidNormalizeWhitespaces
;
void
DidCreateElement
(
EditorBase
&
aEditorBase
Element
&
aNewElement
)
;
void
DidInsertContent
(
EditorBase
&
aEditorBase
nsIContent
&
aNewContent
)
;
void
WillDeleteContent
(
EditorBase
&
aEditorBase
nsIContent
&
aRemovingContent
)
;
void
DidSplitContent
(
EditorBase
&
aEditorBase
nsIContent
&
aExistingRightContent
nsIContent
&
aNewLeftContent
)
;
void
WillJoinContents
(
EditorBase
&
aEditorBase
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
;
void
DidJoinContents
(
EditorBase
&
aEditorBase
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
;
void
DidInsertText
(
EditorBase
&
aEditorBase
const
EditorRawDOMPoint
&
aInsertionBegin
const
EditorRawDOMPoint
&
aInsertionEnd
)
;
void
DidDeleteText
(
EditorBase
&
aEditorBase
const
EditorRawDOMPoint
&
aStartInTextNode
)
;
void
WillDeleteRange
(
EditorBase
&
aEditorBase
const
EditorRawDOMPoint
&
aStart
const
EditorRawDOMPoint
&
aEnd
)
;
private
:
void
Clear
(
)
{
mDidExplicitlySetInterLine
=
false
;
if
(
!
mSelectedRange
)
{
return
;
}
mNewBlockElement
=
nullptr
;
mSelectedRange
-
>
Clear
(
)
;
mChangedRange
-
>
Reset
(
)
;
if
(
mCachedInlineStyles
.
isSome
(
)
)
{
mCachedInlineStyles
-
>
Clear
(
)
;
}
mDidDeleteSelection
=
false
;
mDidDeleteNonCollapsedRange
=
false
;
mDidDeleteEmptyParentBlocks
=
false
;
mRestoreContentEditableCount
=
false
;
mDidNormalizeWhitespaces
=
false
;
}
nsresult
AddNodeToChangedRange
(
const
HTMLEditor
&
aHTMLEditor
nsINode
&
aNode
)
;
nsresult
AddPointToChangedRange
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aPoint
)
;
nsresult
AddRangeToChangedRange
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aStart
const
EditorRawDOMPoint
&
aEnd
)
;
TopLevelEditSubActionData
(
)
=
default
;
TopLevelEditSubActionData
(
const
TopLevelEditSubActionData
&
aOther
)
=
delete
;
}
;
struct
MOZ_STACK_CLASS
EditSubActionData
final
{
uint32_t
mJoinedLeftNodeLength
;
bool
mAdjustChangedRangeFromListener
;
private
:
void
Clear
(
)
{
mJoinedLeftNodeLength
=
0
;
mAdjustChangedRangeFromListener
=
true
;
}
friend
EditorBase
;
}
;
protected
:
enum
class
SettingDataTransfer
{
eWithFormat
eWithoutFormat
}
;
class
MOZ_STACK_CLASS
AutoEditActionDataSetter
final
{
public
:
AutoEditActionDataSetter
(
const
EditorBase
&
aEditorBase
EditAction
aEditAction
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
~
AutoEditActionDataSetter
(
)
;
void
UpdateEditAction
(
EditAction
aEditAction
)
{
MOZ_ASSERT
(
!
mHasTriedToDispatchBeforeInputEvent
"
It
'
s
too
late
to
update
EditAction
since
this
may
have
"
"
already
dispatched
a
beforeinput
event
"
)
;
mEditAction
=
aEditAction
;
}
[
[
nodiscard
]
]
bool
CanHandle
(
)
const
{
#
ifdef
DEBUG
mHasCanHandleChecked
=
true
;
#
endif
return
mSelection
&
&
mEditorBase
.
IsInitialized
(
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
{
if
(
NS_WARN_IF
(
!
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
MaybeDispatchBeforeInputEvent
(
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeDispatchBeforeInputEvent
(
)
;
void
MarkAsBeforeInputHasBeenDispatched
(
)
{
MOZ_ASSERT
(
!
HasTriedToDispatchBeforeInputEvent
(
)
)
;
MOZ_ASSERT
(
mEditAction
=
=
EditAction
:
:
ePaste
|
|
mEditAction
=
=
EditAction
:
:
ePasteAsQuotation
|
|
mEditAction
=
=
EditAction
:
:
eDrop
)
;
mHasTriedToDispatchBeforeInputEvent
=
true
;
}
bool
NeedsToDispatchBeforeInputEvent
(
)
const
{
return
!
HasTriedToDispatchBeforeInputEvent
(
)
&
&
NeedsBeforeInputEventHandling
(
mEditAction
)
&
&
IsBeforeInputEventEnabled
(
)
;
}
bool
HasTriedToDispatchBeforeInputEvent
(
)
const
{
return
mHasTriedToDispatchBeforeInputEvent
;
}
bool
IsCanceled
(
)
const
{
return
mBeforeInputEventCanceled
;
}
const
RefPtr
<
Selection
>
&
SelectionRefPtr
(
)
const
{
MOZ_ASSERT
(
!
mSelection
|
|
(
mSelection
-
>
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
)
;
return
mSelection
;
}
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mPrincipal
;
}
EditAction
GetEditAction
(
)
const
{
return
mEditAction
;
}
template
<
typename
PT
typename
CT
>
void
SetSpellCheckRestartPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
mSpellCheckRestartPoint
=
EditorDOMPoint
(
aPoint
.
GetContainer
(
)
aPoint
.
Offset
(
)
)
;
}
void
ClearSpellCheckRestartPoint
(
)
{
mSpellCheckRestartPoint
.
Clear
(
)
;
}
const
EditorDOMPoint
&
GetSpellCheckRestartPoint
(
)
const
{
return
mSpellCheckRestartPoint
;
}
void
SetData
(
const
nsAString
&
aData
)
{
MOZ_ASSERT
(
!
mHasTriedToDispatchBeforeInputEvent
"
It
'
s
too
late
to
set
data
since
this
may
have
already
"
"
dispatched
a
beforeinput
event
"
)
;
mData
=
aData
;
}
const
nsString
&
GetData
(
)
const
{
return
mData
;
}
void
SetColorData
(
const
nsAString
&
aData
)
;
void
InitializeDataTransfer
(
dom
:
:
DataTransfer
*
aDataTransfer
)
;
void
InitializeDataTransfer
(
nsITransferable
*
aTransferable
)
;
void
InitializeDataTransfer
(
const
nsAString
&
aString
)
;
void
InitializeDataTransferWithClipboard
(
SettingDataTransfer
aSettingDataTransfer
int32_t
aClipboardType
)
;
dom
:
:
DataTransfer
*
GetDataTransfer
(
)
const
{
return
mDataTransfer
;
}
void
AppendTargetRange
(
dom
:
:
StaticRange
&
aTargetRange
)
;
void
Abort
(
)
{
mAborted
=
true
;
}
bool
IsAborted
(
)
const
{
return
mAborted
;
}
void
SetTopLevelEditSubAction
(
EditSubAction
aEditSubAction
EDirection
aDirection
=
eNone
)
{
mTopLevelEditSubAction
=
aEditSubAction
;
TopLevelEditSubActionDataRef
(
)
.
Clear
(
)
;
switch
(
mTopLevelEditSubAction
)
{
case
EditSubAction
:
:
eInsertNode
:
case
EditSubAction
:
:
eCreateNode
:
case
EditSubAction
:
:
eSplitNode
:
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eSetTextProperty
:
case
EditSubAction
:
:
eRemoveTextProperty
:
case
EditSubAction
:
:
eRemoveAllTextProperties
:
case
EditSubAction
:
:
eSetText
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertQuotation
:
case
EditSubAction
:
:
eInsertQuotedText
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eSetPositionToStatic
:
case
EditSubAction
:
:
eDecreaseZIndex
:
case
EditSubAction
:
:
eIncreaseZIndex
:
MOZ_ASSERT
(
aDirection
=
=
eNext
)
;
mDirectionOfTopLevelEditSubAction
=
eNext
;
break
;
case
EditSubAction
:
:
eJoinNodes
:
case
EditSubAction
:
:
eDeleteText
:
MOZ_ASSERT
(
aDirection
=
=
ePrevious
)
;
mDirectionOfTopLevelEditSubAction
=
ePrevious
;
break
;
case
EditSubAction
:
:
eUndo
:
case
EditSubAction
:
:
eRedo
:
case
EditSubAction
:
:
eComputeTextToOutput
:
case
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
case
EditSubAction
:
:
eNone
:
MOZ_ASSERT
(
aDirection
=
=
eNone
)
;
mDirectionOfTopLevelEditSubAction
=
eNone
;
break
;
case
EditSubAction
:
:
eReplaceHeadWithHTMLSource
:
mDirectionOfTopLevelEditSubAction
=
eNone
;
break
;
case
EditSubAction
:
:
eDeleteNode
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
mDirectionOfTopLevelEditSubAction
=
aDirection
;
break
;
}
}
EditSubAction
GetTopLevelEditSubAction
(
)
const
{
MOZ_ASSERT
(
CanHandle
(
)
)
;
return
mTopLevelEditSubAction
;
}
EDirection
GetDirectionOfTopLevelEditSubAction
(
)
const
{
return
mDirectionOfTopLevelEditSubAction
;
}
const
TopLevelEditSubActionData
&
TopLevelEditSubActionDataRef
(
)
const
{
return
mParentData
?
mParentData
-
>
TopLevelEditSubActionDataRef
(
)
:
mTopLevelEditSubActionData
;
}
TopLevelEditSubActionData
&
TopLevelEditSubActionDataRef
(
)
{
return
mParentData
?
mParentData
-
>
TopLevelEditSubActionDataRef
(
)
:
mTopLevelEditSubActionData
;
}
const
EditSubActionData
&
EditSubActionDataRef
(
)
const
{
return
mEditSubActionData
;
}
EditSubActionData
&
EditSubActionDataRef
(
)
{
return
mEditSubActionData
;
}
SelectionState
&
SavedSelectionRef
(
)
{
return
mParentData
?
mParentData
-
>
SavedSelectionRef
(
)
:
mSavedSelection
;
}
const
SelectionState
&
SavedSelectionRef
(
)
const
{
return
mParentData
?
mParentData
-
>
SavedSelectionRef
(
)
:
mSavedSelection
;
}
RangeUpdater
&
RangeUpdaterRef
(
)
{
return
mParentData
?
mParentData
-
>
RangeUpdaterRef
(
)
:
mRangeUpdater
;
}
const
RangeUpdater
&
RangeUpdaterRef
(
)
const
{
return
mParentData
?
mParentData
-
>
RangeUpdaterRef
(
)
:
mRangeUpdater
;
}
void
UpdateSelectionCache
(
Selection
&
aSelection
)
{
MOZ_ASSERT
(
aSelection
.
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
;
AutoEditActionDataSetter
*
actionData
=
this
;
while
(
actionData
)
{
if
(
actionData
-
>
mSelection
)
{
actionData
-
>
mSelection
=
&
aSelection
;
}
actionData
=
actionData
-
>
mParentData
;
}
}
private
:
bool
IsBeforeInputEventEnabled
(
)
const
;
static
bool
NeedsBeforeInputEventHandling
(
EditAction
aEditAction
)
{
MOZ_ASSERT
(
aEditAction
!
=
EditAction
:
:
eNone
)
;
switch
(
aEditAction
)
{
case
EditAction
:
:
eNone
:
case
EditAction
:
:
eNotEditing
:
case
EditAction
:
:
eUnknown
:
case
EditAction
:
:
eHidePassword
:
case
EditAction
:
:
eStartComposition
:
case
EditAction
:
:
eEnableOrDisableCSS
:
case
EditAction
:
:
eEnableOrDisableAbsolutePositionEditor
:
case
EditAction
:
:
eEnableOrDisableResizer
:
case
EditAction
:
:
eEnableOrDisableInlineTableEditingUI
:
case
EditAction
:
:
eSetWrapWidth
:
case
EditAction
:
:
eRewrap
:
case
EditAction
:
:
eResizingElement
:
case
EditAction
:
:
eMovingElement
:
case
EditAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
return
false
;
default
:
return
true
;
}
}
EditorBase
&
mEditorBase
;
RefPtr
<
Selection
>
mSelection
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
AutoEditActionDataSetter
*
mParentData
;
SelectionState
mSavedSelection
;
RangeUpdater
mRangeUpdater
;
nsString
mData
;
RefPtr
<
dom
:
:
DataTransfer
>
mDataTransfer
;
OwningNonNullStaticRangeArray
mTargetRanges
;
EditorDOMPoint
mSpellCheckRestartPoint
;
TopLevelEditSubActionData
mTopLevelEditSubActionData
;
EditSubActionData
mEditSubActionData
;
EditAction
mEditAction
;
EditSubAction
mTopLevelEditSubAction
;
EDirection
mDirectionOfTopLevelEditSubAction
;
bool
mAborted
;
bool
mHasTriedToDispatchBeforeInputEvent
;
bool
mBeforeInputEventCanceled
;
#
ifdef
DEBUG
mutable
bool
mHasCanHandleChecked
=
false
;
#
endif
AutoEditActionDataSetter
(
)
=
delete
;
AutoEditActionDataSetter
(
const
AutoEditActionDataSetter
&
aOther
)
=
delete
;
}
;
void
UpdateEditActionData
(
const
nsAString
&
aData
)
{
mEditActionData
-
>
SetData
(
aData
)
;
}
protected
:
bool
IsEditActionCanceled
(
)
const
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
IsCanceled
(
)
;
}
bool
NeedsToDispatchBeforeInputEvent
(
)
const
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
NeedsToDispatchBeforeInputEvent
(
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeDispatchBeforeInputEvent
(
)
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
MaybeDispatchBeforeInputEvent
(
)
;
}
void
MarkAsBeforeInputHasBeenDispatched
(
)
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
MarkAsBeforeInputHasBeenDispatched
(
)
;
}
bool
HasTriedToDispatchBeforeInputEvent
(
)
const
{
return
mEditActionData
&
&
mEditActionData
-
>
HasTriedToDispatchBeforeInputEvent
(
)
;
}
bool
IsEditActionDataAvailable
(
)
const
{
return
mEditActionData
&
&
mEditActionData
-
>
CanHandle
(
)
;
}
bool
IsTopLevelEditSubActionDataAvailable
(
)
const
{
return
mEditActionData
&
&
!
!
GetTopLevelEditSubAction
(
)
;
}
bool
IsEditActionAborted
(
)
const
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
IsAborted
(
)
;
}
const
RefPtr
<
Selection
>
&
SelectionRefPtr
(
)
const
{
MOZ_ASSERT
(
mEditActionData
)
;
MOZ_ASSERT
(
mEditActionData
-
>
SelectionRefPtr
(
)
-
>
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
;
return
mEditActionData
-
>
SelectionRefPtr
(
)
;
}
nsIPrincipal
*
GetEditActionPrincipal
(
)
const
{
MOZ_ASSERT
(
mEditActionData
)
;
return
mEditActionData
-
>
GetPrincipal
(
)
;
}
EditAction
GetEditAction
(
)
const
{
return
mEditActionData
?
mEditActionData
-
>
GetEditAction
(
)
:
EditAction
:
:
eNone
;
}
const
nsString
&
GetInputEventData
(
)
const
{
return
mEditActionData
?
mEditActionData
-
>
GetData
(
)
:
VoidString
(
)
;
}
dom
:
:
DataTransfer
*
GetInputEventDataTransfer
(
)
const
{
return
mEditActionData
?
mEditActionData
-
>
GetDataTransfer
(
)
:
nullptr
;
}
EditSubAction
GetTopLevelEditSubAction
(
)
const
{
return
mEditActionData
?
mEditActionData
-
>
GetTopLevelEditSubAction
(
)
:
EditSubAction
:
:
eNone
;
}
EDirection
GetDirectionOfTopLevelEditSubAction
(
)
const
{
return
mEditActionData
?
mEditActionData
-
>
GetDirectionOfTopLevelEditSubAction
(
)
:
eNone
;
}
SelectionState
&
SavedSelectionRef
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
SavedSelectionRef
(
)
;
}
const
SelectionState
&
SavedSelectionRef
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
SavedSelectionRef
(
)
;
}
RangeUpdater
&
RangeUpdaterRef
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
RangeUpdaterRef
(
)
;
}
const
RangeUpdater
&
RangeUpdaterRef
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
RangeUpdaterRef
(
)
;
}
template
<
typename
PT
typename
CT
>
void
SetSpellCheckRestartPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
SetSpellCheckRestartPoint
(
aPoint
)
;
}
void
ClearSpellCheckRestartPoint
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
ClearSpellCheckRestartPoint
(
)
;
}
const
EditorDOMPoint
&
GetSpellCheckRestartPoint
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
GetSpellCheckRestartPoint
(
)
;
}
const
TopLevelEditSubActionData
&
TopLevelEditSubActionDataRef
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
TopLevelEditSubActionDataRef
(
)
;
}
TopLevelEditSubActionData
&
TopLevelEditSubActionDataRef
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
TopLevelEditSubActionDataRef
(
)
;
}
const
EditSubActionData
&
EditSubActionDataRef
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
EditSubActionDataRef
(
)
;
}
EditSubActionData
&
EditSubActionDataRef
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
return
mEditActionData
-
>
EditSubActionDataRef
(
)
;
}
EditorRawDOMPoint
GetCompositionStartPoint
(
)
const
;
EditorRawDOMPoint
GetCompositionEndPoint
(
)
const
;
bool
IsSelectionRangeContainerNotContent
(
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextAsSubAction
(
const
nsAString
&
aStringToInsert
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextIntoTextNodeWithTransaction
(
const
nsAString
&
aStringToInsert
const
EditorDOMPointInText
&
aPointToInsert
bool
aSuppressIME
=
false
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SetTextNodeWithoutTransaction
(
const
nsAString
&
aString
Text
&
aTextNode
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteNodeWithTransaction
(
nsIContent
&
aContent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertNodeWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
CreateElementResult
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
)
;
MOZ_CAN_RUN_SCRIPT
void
CloneAttributesWithTransaction
(
Element
&
aDestElement
Element
&
aSourceElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
CloneAttributeWithTransaction
(
nsAtom
&
aAttribute
Element
&
aDestElement
Element
&
aSourceElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
=
0
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
const
nsAString
&
aValue
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
=
0
;
already_AddRefed
<
Element
>
CreateHTMLContent
(
const
nsAtom
*
aTag
)
;
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
const
nsAString
&
aData
)
;
MOZ_CAN_RUN_SCRIPT
void
DoInsertText
(
dom
:
:
Text
&
aText
uint32_t
aOffset
const
nsAString
&
aStringToInsert
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
DoDeleteText
(
dom
:
:
Text
&
aText
uint32_t
aOffset
uint32_t
aCount
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
DoReplaceText
(
dom
:
:
Text
&
aText
uint32_t
aOffset
uint32_t
aCount
const
nsAString
&
aStringToInsert
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
DoSetText
(
dom
:
:
Text
&
aText
const
nsAString
&
aStringToSet
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Element
>
CreateNodeWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aPointToInsert
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTextWithTransaction
(
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MarkElementDirty
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DoTransactionInternal
(
nsITransaction
*
aTransaction
)
;
nsIContent
*
GetPreviousNode
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
false
true
false
)
;
}
nsIContent
*
GetPreviousElementOrText
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
false
false
false
)
;
}
nsIContent
*
GetPreviousEditableNode
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
true
true
false
)
;
}
nsIContent
*
GetPreviousNodeInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
false
true
true
)
;
}
nsIContent
*
GetPreviousElementOrTextInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
false
false
true
)
;
}
nsIContent
*
GetPreviousEditableNodeInBlock
(
const
EditorRawDOMPoint
&
aPoint
)
const
{
return
GetPreviousNodeInternal
(
aPoint
true
true
true
)
;
}
nsIContent
*
GetPreviousNode
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
false
true
false
)
;
}
nsIContent
*
GetPreviousElementOrText
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
false
false
false
)
;
}
nsIContent
*
GetPreviousEditableNode
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
true
true
false
)
;
}
nsIContent
*
GetPreviousNodeInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
false
true
true
)
;
}
nsIContent
*
GetPreviousElementOrTextInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
false
false
true
)
;
}
nsIContent
*
GetPreviousEditableNodeInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetPreviousNodeInternal
(
aNode
true
true
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
false
true
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextElementOrText
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
false
false
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
true
true
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
false
true
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextElementOrTextInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
false
false
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextNodeInternal
(
aPoint
true
true
true
)
;
}
nsIContent
*
GetNextNode
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
false
true
false
)
;
}
nsIContent
*
GetNextElementOrText
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
false
false
false
)
;
}
nsIContent
*
GetNextEditableNode
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
true
true
false
)
;
}
nsIContent
*
GetNextNodeInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
false
true
true
)
;
}
nsIContent
*
GetNextElementOrTextInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
false
false
true
)
;
}
nsIContent
*
GetNextEditableNodeInBlock
(
const
nsINode
&
aNode
)
const
{
return
GetNextNodeInternal
(
aNode
true
true
true
)
;
}
bool
IsRoot
(
const
nsINode
*
inNode
)
const
;
bool
IsEditorRoot
(
const
nsINode
*
aNode
)
const
;
bool
IsDescendantOfRoot
(
const
nsINode
*
inNode
)
const
;
bool
IsDescendantOfEditorRoot
(
const
nsINode
*
aNode
)
const
;
uint32_t
CountEditableChildren
(
nsINode
*
aNode
)
;
nsINode
*
GetFirstEditableNode
(
nsINode
*
aRoot
)
;
bool
ShouldHandleIMEComposition
(
)
const
;
static
nsIContent
*
GetNodeAtRangeOffsetPoint
(
nsINode
*
aContainer
int32_t
aOffset
)
{
return
GetNodeAtRangeOffsetPoint
(
RawRangeBoundary
(
aContainer
aOffset
)
)
;
}
static
nsIContent
*
GetNodeAtRangeOffsetPoint
(
const
RawRangeBoundary
&
aPoint
)
;
static
EditorRawDOMPoint
GetStartPoint
(
const
Selection
&
aSelection
)
;
static
EditorRawDOMPoint
GetEndPoint
(
const
Selection
&
aSelection
)
;
static
nsresult
GetEndChildNode
(
const
Selection
&
aSelection
nsIContent
*
*
aEndNode
)
;
nsresult
CollapseSelectionToEnd
(
)
const
;
inline
bool
AllowsTransactionsToChangeSelection
(
)
const
{
return
mAllowsTransactionsToChangeSelection
;
}
inline
void
MakeThisAllowTransactionsToChangeSelection
(
bool
aAllow
)
{
mAllowsTransactionsToChangeSelection
=
aAllow
;
}
nsresult
HandleInlineSpellCheck
(
const
EditorDOMPoint
&
aPreviouslySelectedStart
const
dom
:
:
AbstractRange
*
aRange
=
nullptr
)
;
virtual
Element
*
GetEditorRoot
(
)
const
;
Element
*
GetExposedRoot
(
)
const
;
virtual
bool
IsActiveInDOMWindow
(
)
const
;
EditorRawDOMPoint
FindBetterInsertionPoint
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
void
HideCaret
(
bool
aHide
)
;
protected
:
class
MOZ_RAII
AutoCaretBidiLevelManager
final
{
public
:
template
<
typename
PT
typename
CT
>
AutoCaretBidiLevelManager
(
const
EditorBase
&
aEditorBase
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPointBase
<
PT
CT
>
&
aPointAtCaret
)
;
bool
Failed
(
)
const
{
return
mFailed
;
}
bool
Canceled
(
)
const
{
return
mCanceled
;
}
void
MaybeUpdateCaretBidiLevel
(
const
EditorBase
&
aEditorBase
)
const
;
private
:
Maybe
<
nsBidiLevel
>
mNewCaretBidiLevel
;
bool
mFailed
=
false
;
bool
mCanceled
=
false
;
}
;
void
UndefineCaretBidiLevel
(
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectionAsSubAction
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
virtual
EditActionResult
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
=
0
;
protected
:
MOZ_CAN_RUN_SCRIPT
virtual
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
OnEndHandlingTopLevelEditSubAction
(
)
;
void
OnStartToHandleEditSubAction
(
)
{
EditSubActionDataRef
(
)
.
Clear
(
)
;
}
void
OnEndHandlingEditSubAction
(
)
{
EditSubActionDataRef
(
)
.
Clear
(
)
;
}
bool
ArePreservingSelection
(
)
;
void
PreserveSelectionAcrossActions
(
)
;
nsresult
RestorePreservedSelection
(
)
;
void
StopPreservingSelection
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
BeginPlaceholderTransaction
(
nsStaticAtom
&
aTransactionName
)
;
enum
class
ScrollSelectionIntoView
{
No
Yes
}
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
EndPlaceholderTransaction
(
ScrollSelectionIntoView
aScrollSelectionIntoView
)
;
void
BeginUpdateViewBatch
(
)
;
MOZ_CAN_RUN_SCRIPT
void
EndUpdateViewBatch
(
)
;
MOZ_CAN_RUN_SCRIPT
void
BeginTransactionInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
void
EndTransactionInternal
(
)
;
protected
:
virtual
~
EditorBase
(
)
;
MOZ_ALWAYS_INLINE
EditorType
GetEditorType
(
)
const
{
return
mIsHTMLEditorClass
?
EditorType
:
:
HTML
:
EditorType
:
:
Text
;
}
int32_t
WrapWidth
(
)
const
{
return
mWrapColumn
;
}
static
inline
nsresult
ToGenericNSResult
(
nsresult
aRv
)
{
switch
(
aRv
)
{
case
NS_ERROR_EDITOR_DESTROYED
:
return
NS_OK
;
case
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
:
return
NS_OK
;
case
NS_ERROR_EDITOR_ACTION_CANCELED
:
return
NS_SUCCESS_DOM_NO_OPERATION
;
default
:
return
aRv
;
}
}
nsresult
GetDocumentCharsetInternal
(
nsACString
&
aCharset
)
const
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SelectAllInternal
(
)
;
nsresult
DetermineCurrentDirection
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DispatchInputEvent
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DoAfterDoTransaction
(
nsITransaction
*
aTransaction
)
;
MOZ_CAN_RUN_SCRIPT
void
DoAfterUndoTransaction
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DoAfterRedoTransaction
(
)
;
enum
TDocumentListenerNotification
{
eDocumentCreated
eDocumentToBeDestroyed
eDocumentStateChanged
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
NotifyDocumentListeners
(
TDocumentListenerNotification
aNotificationType
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SelectEntireDocument
(
)
=
0
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
ScrollSelectionFocusIntoView
(
)
;
nsIContent
*
FindNextLeafNode
(
const
nsINode
*
aCurrentNode
bool
aGoForward
bool
bNoBlockCrossing
)
const
;
nsIContent
*
FindNode
(
const
nsINode
*
aCurrentNode
bool
aGoForward
bool
aEditableNode
bool
aFindAnyDataNode
bool
bNoBlockCrossing
)
const
;
nsIContent
*
GetPreviousNodeInternal
(
const
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
const
;
nsIContent
*
GetPreviousNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
const
;
nsIContent
*
GetNextNodeInternal
(
const
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
const
;
nsIContent
*
GetNextNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
const
;
virtual
nsresult
InstallEventListeners
(
)
;
virtual
void
CreateEventListeners
(
)
;
virtual
void
RemoveEventListeners
(
)
;
virtual
already_AddRefed
<
Element
>
GetInputEventTargetElement
(
)
const
=
0
;
bool
GetDesiredSpellCheckState
(
)
;
bool
CanEnableSpellCheck
(
)
{
return
!
IsPasswordEditor
(
)
&
&
!
IsReadonly
(
)
&
&
!
ShouldSkipSpellCheck
(
)
;
}
virtual
void
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
const
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
AppendNodeToSelectionAsRange
(
nsINode
*
aNode
)
;
nsresult
ClearSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InitializeSelection
(
nsINode
&
aFocusEventTarget
)
;
enum
NotificationForEditorObservers
{
eNotifyEditorObserversOfEnd
eNotifyEditorObserversOfBefore
eNotifyEditorObserversOfCancel
}
;
MOZ_CAN_RUN_SCRIPT
void
NotifyEditorObservers
(
NotificationForEditorObservers
aNotification
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertLineBreakAsSubAction
(
)
;
enum
class
HowToHandleCollapsedRange
{
Ignore
ExtendBackward
ExtendForward
}
;
static
HowToHandleCollapsedRange
HowToHandleCollapsedRangeFor
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNone
:
return
HowToHandleCollapsedRange
:
:
Ignore
;
case
nsIEditor
:
:
ePrevious
:
return
HowToHandleCollapsedRange
:
:
ExtendBackward
;
case
nsIEditor
:
:
eNext
:
return
HowToHandleCollapsedRange
:
:
ExtendForward
;
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
case
nsIEditor
:
:
eToEndOfLine
:
return
HowToHandleCollapsedRange
:
:
Ignore
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
nsIEditor
:
:
EDirection
value
"
)
;
return
HowToHandleCollapsedRange
:
:
Ignore
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectionWithTransaction
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteRangesWithTransaction
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
AutoRangeArray
&
aRangesToDelete
)
;
already_AddRefed
<
EditAggregateTransaction
>
CreateTransactionForDeleteSelection
(
HowToHandleCollapsedRange
aHowToHandleCollapsedRange
const
AutoRangeArray
&
aRangesToDelete
)
;
already_AddRefed
<
EditTransactionBase
>
CreateTransactionForCollapsedRange
(
const
nsRange
&
aCollapsedRange
HowToHandleCollapsedRange
aHowToHandleCollapsedRange
)
;
Tuple
<
EditorDOMPointInText
EditorDOMPointInText
>
ComputeInsertedRange
(
const
EditorDOMPointInText
&
aInsertedPoint
const
nsAString
&
aInsertedString
)
const
;
private
:
nsCOMPtr
<
nsISelectionController
>
mSelectionController
;
RefPtr
<
Document
>
mDocument
;
AutoEditActionDataSetter
*
mEditActionData
;
nsresult
SetTextDirectionTo
(
TextDirection
aTextDirection
)
;
protected
:
class
MOZ_RAII
AutoTransactionBatch
final
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
AutoTransactionBatch
(
EditorBase
&
aEditorBase
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_KnownLive
(
mEditorBase
)
.
BeginTransactionInternal
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoTransactionBatch
(
)
{
MOZ_KnownLive
(
mEditorBase
)
.
EndTransactionInternal
(
)
;
}
protected
:
EditorBase
&
mEditorBase
;
}
;
class
MOZ_RAII
AutoPlaceholderBatch
final
{
public
:
AutoPlaceholderBatch
(
EditorBase
&
aEditorBase
ScrollSelectionIntoView
aScrollSelectionIntoView
)
:
mEditorBase
(
aEditorBase
)
mScrollSelectionIntoView
(
aScrollSelectionIntoView
)
{
mEditorBase
-
>
BeginPlaceholderTransaction
(
*
nsGkAtoms
:
:
_empty
)
;
}
AutoPlaceholderBatch
(
EditorBase
&
aEditorBase
nsStaticAtom
&
aTransactionName
ScrollSelectionIntoView
aScrollSelectionIntoView
)
:
mEditorBase
(
aEditorBase
)
mScrollSelectionIntoView
(
aScrollSelectionIntoView
)
{
mEditorBase
-
>
BeginPlaceholderTransaction
(
aTransactionName
)
;
}
~
AutoPlaceholderBatch
(
)
{
mEditorBase
-
>
EndPlaceholderTransaction
(
mScrollSelectionIntoView
)
;
}
protected
:
OwningNonNull
<
EditorBase
>
mEditorBase
;
ScrollSelectionIntoView
mScrollSelectionIntoView
;
}
;
class
MOZ_RAII
AutoSelectionRestorer
final
{
public
:
explicit
AutoSelectionRestorer
(
EditorBase
&
aEditorBase
)
;
~
AutoSelectionRestorer
(
)
;
void
Abort
(
)
;
protected
:
EditorBase
*
mEditorBase
;
}
;
class
MOZ_RAII
AutoEditSubActionNotifier
final
{
public
:
MOZ_CAN_RUN_SCRIPT
AutoEditSubActionNotifier
(
EditorBase
&
aEditorBase
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
ErrorResult
&
aRv
)
:
mEditorBase
(
aEditorBase
)
mIsTopLevel
(
true
)
{
if
(
!
mEditorBase
.
GetTopLevelEditSubAction
(
)
)
{
MOZ_KnownLive
(
mEditorBase
)
.
OnStartToHandleTopLevelEditSubAction
(
aEditSubAction
aDirection
aRv
)
;
}
else
{
mIsTopLevel
=
false
;
}
mEditorBase
.
OnStartToHandleEditSubAction
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoEditSubActionNotifier
(
)
{
mEditorBase
.
OnEndHandlingEditSubAction
(
)
;
if
(
mIsTopLevel
)
{
MOZ_KnownLive
(
mEditorBase
)
.
OnEndHandlingTopLevelEditSubAction
(
)
;
}
}
protected
:
EditorBase
&
mEditorBase
;
bool
mIsTopLevel
;
}
;
class
MOZ_RAII
AutoTransactionsConserveSelection
final
{
public
:
explicit
AutoTransactionsConserveSelection
(
EditorBase
&
aEditorBase
)
:
mEditorBase
(
aEditorBase
)
mAllowedTransactionsToChangeSelection
(
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
mEditorBase
.
MakeThisAllowTransactionsToChangeSelection
(
false
)
;
}
~
AutoTransactionsConserveSelection
(
)
{
mEditorBase
.
MakeThisAllowTransactionsToChangeSelection
(
mAllowedTransactionsToChangeSelection
)
;
}
protected
:
EditorBase
&
mEditorBase
;
bool
mAllowedTransactionsToChangeSelection
;
}
;
class
MOZ_RAII
AutoUpdateViewBatch
final
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
AutoUpdateViewBatch
(
EditorBase
&
aEditorBase
)
:
mEditorBase
(
aEditorBase
)
{
mEditorBase
.
BeginUpdateViewBatch
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoUpdateViewBatch
(
)
{
MOZ_KnownLive
(
mEditorBase
)
.
EndUpdateViewBatch
(
)
;
}
protected
:
EditorBase
&
mEditorBase
;
}
;
protected
:
enum
Tristate
{
eTriUnset
eTriFalse
eTriTrue
}
;
nsCString
mContentMIMEType
;
RefPtr
<
mozInlineSpellChecker
>
mInlineSpellChecker
;
RefPtr
<
TextServicesDocument
>
mTextServicesDocument
;
RefPtr
<
TransactionManager
>
mTransactionManager
;
RefPtr
<
Element
>
mRootElement
;
RefPtr
<
dom
:
:
HTMLBRElement
>
mPaddingBRElementForEmptyEditor
;
nsCOMPtr
<
dom
:
:
EventTarget
>
mEventTarget
;
RefPtr
<
EditorEventListener
>
mEventListener
;
RefPtr
<
PlaceholderTransaction
>
mPlaceholderTransaction
;
nsStaticAtom
*
mPlaceholderName
;
mozilla
:
:
Maybe
<
SelectionState
>
mSelState
;
RefPtr
<
TextComposition
>
mComposition
;
RefPtr
<
TextInputListener
>
mTextInputListener
;
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditActionListener
>
2
>
AutoActionListenerArray
;
AutoActionListenerArray
mActionListeners
;
typedef
AutoTArray
<
OwningNonNull
<
nsIEditorObserver
>
0
>
AutoEditorObserverArray
;
AutoEditorObserverArray
mEditorObservers
;
typedef
AutoTArray
<
OwningNonNull
<
nsIDocumentStateListener
>
1
>
AutoDocumentStateListenerArray
;
AutoDocumentStateListenerArray
mDocStateListeners
;
uint32_t
mModCount
;
uint32_t
mFlags
;
int32_t
mUpdateCount
;
int32_t
mPlaceholderBatch
;
int32_t
mWrapColumn
;
int32_t
mNewlineHandling
;
int32_t
mCaretStyle
;
int8_t
mDocDirtyState
;
uint8_t
mSpellcheckCheckboxState
;
bool
mInitSucceeded
;
bool
mAllowsTransactionsToChangeSelection
;
bool
mDidPreDestroy
;
bool
mDidPostCreate
;
bool
mDispatchInputEvent
;
bool
mIsInEditSubAction
;
bool
mHidingCaret
;
bool
mSpellCheckerDictionaryUpdated
;
bool
mIsHTMLEditorClass
;
friend
class
AlignStateAtSelection
;
friend
class
AutoRangeArray
;
friend
class
CompositionTransaction
;
friend
class
CreateElementTransaction
;
friend
class
CSSEditUtils
;
friend
class
DeleteNodeTransaction
;
friend
class
DeleteRangeTransaction
;
friend
class
DeleteTextTransaction
;
friend
class
HTMLEditUtils
;
friend
class
InsertNodeTransaction
;
friend
class
InsertTextTransaction
;
friend
class
JoinNodeTransaction
;
friend
class
ListElementSelectionState
;
friend
class
ListItemElementSelectionState
;
friend
class
ParagraphStateAtSelection
;
friend
class
ReplaceTextTransaction
;
friend
class
SplitNodeTransaction
;
friend
class
TypeInState
;
friend
class
WhiteSpaceVisibilityKeeper
;
friend
class
WSRunScanner
;
friend
class
nsIEditor
;
}
;
}
mozilla
:
:
EditorBase
*
nsIEditor
:
:
AsEditorBase
(
)
{
return
static_cast
<
mozilla
:
:
EditorBase
*
>
(
this
)
;
}
const
mozilla
:
:
EditorBase
*
nsIEditor
:
:
AsEditorBase
(
)
const
{
return
static_cast
<
const
mozilla
:
:
EditorBase
*
>
(
this
)
;
}
#
endif
