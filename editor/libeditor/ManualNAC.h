#
ifndef
mozilla_ManualNAC_h
#
define
mozilla_ManualNAC_h
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
using
ManualNACArray
=
AutoTArray
<
RefPtr
<
dom
:
:
Element
>
16
>
;
class
ManualNACPtr
final
{
public
:
ManualNACPtr
(
)
=
default
;
MOZ_IMPLICIT
ManualNACPtr
(
decltype
(
nullptr
)
)
{
}
explicit
ManualNACPtr
(
already_AddRefed
<
dom
:
:
Element
>
aNewNAC
)
:
mPtr
(
aNewNAC
)
{
if
(
!
mPtr
)
{
return
;
}
nsIContent
*
parentContent
=
mPtr
-
>
GetParent
(
)
;
auto
nac
=
static_cast
<
ManualNACArray
*
>
(
parentContent
-
>
GetProperty
(
nsGkAtoms
:
:
manualNACProperty
)
)
;
if
(
!
nac
)
{
nac
=
new
ManualNACArray
(
)
;
parentContent
-
>
SetProperty
(
nsGkAtoms
:
:
manualNACProperty
nac
nsINode
:
:
DeleteProperty
<
ManualNACArray
>
)
;
}
nac
-
>
AppendElement
(
mPtr
)
;
}
ManualNACPtr
(
ManualNACPtr
&
&
aOther
)
:
mPtr
(
std
:
:
move
(
aOther
.
mPtr
)
)
{
}
ManualNACPtr
(
ManualNACPtr
&
aOther
)
=
delete
;
ManualNACPtr
&
operator
=
(
ManualNACPtr
&
&
aOther
)
{
mPtr
=
std
:
:
move
(
aOther
.
mPtr
)
;
return
*
this
;
}
ManualNACPtr
&
operator
=
(
ManualNACPtr
&
aOther
)
=
delete
;
~
ManualNACPtr
(
)
{
Reset
(
)
;
}
void
Reset
(
)
{
if
(
!
mPtr
)
{
return
;
}
RefPtr
<
dom
:
:
Element
>
ptr
=
std
:
:
move
(
mPtr
)
;
RemoveContentFromNACArray
(
ptr
)
;
}
static
bool
IsManualNAC
(
nsIContent
*
aAnonContent
)
{
MOZ_ASSERT
(
aAnonContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
MOZ_ASSERT
(
aAnonContent
-
>
IsInComposedDoc
(
)
)
;
auto
*
nac
=
static_cast
<
ManualNACArray
*
>
(
aAnonContent
-
>
GetParent
(
)
-
>
GetProperty
(
nsGkAtoms
:
:
manualNACProperty
)
)
;
return
nac
&
&
nac
-
>
Contains
(
aAnonContent
)
;
}
static
void
RemoveContentFromNACArray
(
nsIContent
*
aAnonymousContent
)
{
nsIContent
*
parentContent
=
aAnonymousContent
-
>
GetParent
(
)
;
if
(
!
parentContent
)
{
NS_WARNING
(
"
Potentially
leaking
manual
NAC
"
)
;
return
;
}
auto
*
nac
=
static_cast
<
ManualNACArray
*
>
(
parentContent
-
>
GetProperty
(
nsGkAtoms
:
:
manualNACProperty
)
)
;
if
(
nac
)
{
nac
-
>
RemoveElement
(
aAnonymousContent
)
;
if
(
nac
-
>
IsEmpty
(
)
)
{
parentContent
-
>
RemoveProperty
(
nsGkAtoms
:
:
manualNACProperty
)
;
}
}
aAnonymousContent
-
>
UnbindFromTree
(
)
;
}
dom
:
:
Element
*
get
(
)
const
{
return
mPtr
.
get
(
)
;
}
dom
:
:
Element
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
operator
dom
:
:
Element
*
(
)
const
&
{
return
get
(
)
;
}
private
:
RefPtr
<
dom
:
:
Element
>
mPtr
;
}
;
}
inline
void
ImplCycleCollectionUnlink
(
mozilla
:
:
ManualNACPtr
&
field
)
{
field
.
Reset
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
callback
const
mozilla
:
:
ManualNACPtr
&
field
const
char
*
name
uint32_t
flags
=
0
)
{
CycleCollectionNoteChild
(
callback
field
.
get
(
)
name
flags
)
;
}
#
endif
