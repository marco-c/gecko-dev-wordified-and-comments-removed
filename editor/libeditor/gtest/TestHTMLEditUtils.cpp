#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
using
AncestorTypes
=
HTMLEditUtils
:
:
AncestorTypes
;
using
EditablePointOption
=
HTMLEditUtils
:
:
EditablePointOption
;
using
EditablePointOptions
=
HTMLEditUtils
:
:
EditablePointOptions
;
static
already_AddRefed
<
Document
>
CreateHTMLDoc
(
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
data
:
text
/
html
"
)
;
RefPtr
<
BasePrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
uri
OriginAttributes
(
)
)
;
MOZ_RELEASE_ASSERT
(
principal
)
;
nsCOMPtr
<
Document
>
doc
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewDOMDocument
(
getter_AddRefs
(
doc
)
u
"
"
_ns
u
"
"
_ns
nullptr
uri
uri
principal
LoadedAsData
:
:
No
nullptr
DocumentFlavor
:
:
HTML
)
)
;
MOZ_RELEASE_ASSERT
(
doc
)
;
RefPtr
<
Element
>
html
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
html
)
;
html
-
>
SetInnerHTMLTrusted
(
u
"
<
html
>
<
head
>
<
/
head
>
<
body
>
<
/
body
>
<
/
html
>
"
_ns
principal
IgnoreErrors
(
)
)
;
doc
-
>
AppendChild
(
*
html
IgnoreErrors
(
)
)
;
return
doc
.
forget
(
)
;
}
struct
MOZ_STACK_CLASS
DeepestEditablePointTest
final
{
const
char16_t
*
const
mInnerHTML
;
const
char
*
const
mContentSelector
;
const
EditablePointOptions
mOptions
;
const
char
*
const
mExpectedContainerSelector
;
const
char16_t
*
const
mExpectedTextData
;
const
uint32_t
mExpectedOffset
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
DeepestEditablePointTest
&
aTest
)
{
return
aStream
<
<
"
Scan
\
"
"
<
<
aTest
.
mContentSelector
<
<
"
\
"
with
options
=
"
<
<
ToString
(
aTest
.
mOptions
)
.
c_str
(
)
<
<
"
in
\
"
"
<
<
NS_ConvertUTF16toUTF8
(
aTest
.
mInnerHTML
)
.
get
(
)
<
<
"
\
"
"
;
}
}
;
TEST
(
HTMLEditUtilsTest
GetDeepestEditableStartPointOf
)
{
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
br
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
img
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
hr
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
p
>
abc
<
/
p
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
p
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
/
span
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
!
-
-
comment
-
-
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
!
-
-
comment
-
-
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtComment
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
b
>
<
span
style
=
\
"
display
:
"
u
"
inline
-
block
\
"
>
def
<
/
span
>
<
/
b
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
>
b
"
{
}
"
div
[
contenteditable
]
>
div
>
b
>
span
"
u
"
def
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
td
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtTableElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtAnyTableElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
}
"
div
[
contenteditable
]
td
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
EditablePointOption
:
:
StopAtTableElement
}
"
div
[
contenteditable
]
td
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
EditablePointOption
:
:
StopAtAnyTableElement
}
"
div
[
contenteditable
]
table
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
li
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
ul
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
li
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
ol
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
dt
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
dl
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
dd
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
dl
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
0
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
const
nsIContent
*
const
expectedContainer
=
[
&
]
(
)
-
>
const
nsIContent
*
{
const
Element
*
const
containerElement
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedContainerSelector
)
IgnoreErrors
(
)
)
;
if
(
!
testData
.
mExpectedTextData
)
{
return
containerElement
;
}
for
(
const
nsIContent
*
child
=
containerElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
const
auto
*
text
=
Text
:
:
FromNodeOrNull
(
child
)
)
{
nsAutoString
data
;
text
-
>
GetData
(
data
)
;
if
(
data
.
Equals
(
testData
.
mExpectedTextData
)
)
{
return
text
;
}
}
}
return
nullptr
;
}
(
)
;
MOZ_RELEASE_ASSERT
(
expectedContainer
)
;
const
EditorRawDOMPoint
result
=
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorRawDOMPoint
>
(
*
content
testData
.
mOptions
)
;
EXPECT_EQ
(
result
.
GetContainer
(
)
expectedContainer
)
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
.
GetContainer
(
)
}
)
<
<
"
)
"
;
EXPECT_EQ
(
result
.
Offset
(
)
testData
.
mExpectedOffset
)
<
<
testData
;
}
}
TEST
(
HTMLEditUtilsTest
GetDeepestEditableEndPointOf
)
{
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
br
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
img
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
hr
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
p
>
abc
<
/
p
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
p
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
6
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
abc
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
}
"
div
[
contenteditable
]
>
div
>
span
"
u
"
abc
"
6
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
span
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
>
span
"
nullptr
0
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
!
-
-
comment
-
-
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
>
div
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
abc
<
!
-
-
comment
-
-
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtComment
}
"
div
[
contenteditable
]
>
div
"
nullptr
2
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
b
>
<
span
style
=
\
"
display
:
"
u
"
inline
-
block
\
"
>
abc
<
/
span
>
<
/
b
>
def
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
>
b
"
{
}
"
div
[
contenteditable
]
>
div
>
b
>
span
"
u
"
abc
"
3
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
td
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtTableElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtAnyTableElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
}
"
div
[
contenteditable
]
td
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
EditablePointOption
:
:
StopAtTableElement
}
"
div
[
contenteditable
]
td
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
table
>
<
td
>
<
br
>
<
/
table
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
table
"
{
EditablePointOption
:
:
StopAtAnyTableElement
}
"
div
[
contenteditable
]
table
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
li
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
ul
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ul
>
<
li
>
<
br
>
<
/
li
>
<
/
ul
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
li
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
ol
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
ol
>
<
li
>
<
br
>
<
/
li
>
<
/
ol
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
dt
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
dl
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dt
>
<
br
>
<
/
dt
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
}
"
div
[
contenteditable
]
dd
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListItemElement
}
"
div
[
contenteditable
]
dl
"
nullptr
1
}
DeepestEditablePointTest
{
u
"
<
div
contenteditable
>
<
div
>
<
dl
>
<
dd
>
<
br
>
<
/
dd
>
<
/
dl
>
<
/
div
>
<
/
div
>
"
"
div
[
contenteditable
]
>
div
"
{
EditablePointOption
:
:
StopAtListElement
}
"
div
[
contenteditable
]
>
div
"
nullptr
1
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
const
nsIContent
*
const
expectedContainer
=
[
&
]
(
)
-
>
const
nsIContent
*
{
const
Element
*
const
containerElement
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedContainerSelector
)
IgnoreErrors
(
)
)
;
if
(
!
testData
.
mExpectedTextData
)
{
return
containerElement
;
}
for
(
const
nsIContent
*
child
=
containerElement
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
const
auto
*
text
=
Text
:
:
FromNodeOrNull
(
child
)
)
{
nsAutoString
data
;
text
-
>
GetData
(
data
)
;
if
(
data
.
Equals
(
testData
.
mExpectedTextData
)
)
{
return
text
;
}
}
}
return
nullptr
;
}
(
)
;
MOZ_RELEASE_ASSERT
(
expectedContainer
)
;
const
EditorRawDOMPoint
result
=
HTMLEditUtils
:
:
GetDeepestEditableEndPointOf
<
EditorRawDOMPoint
>
(
*
content
testData
.
mOptions
)
;
EXPECT_EQ
(
result
.
GetContainer
(
)
expectedContainer
)
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
.
GetContainer
(
)
}
)
<
<
"
)
"
;
EXPECT_EQ
(
result
.
Offset
(
)
testData
.
mExpectedOffset
)
<
<
testData
;
}
}
struct
MOZ_STACK_CLASS
AncestorElementTest
final
{
const
char16_t
*
const
mInnerHTML
;
const
char
*
const
mContentSelector
;
const
AncestorTypes
mAncestorTypes
;
const
char
*
const
mAncestorLimiterSelector
;
const
char
*
const
mExpectedSelectorForAncestor
;
const
char
*
const
mExpectedSelectorForInclusiveAncestor
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AncestorElementTest
&
aTest
)
{
return
aStream
<
<
"
Scan
from
\
"
"
<
<
aTest
.
mContentSelector
<
<
"
\
"
with
ancestor
types
=
"
<
<
ToString
(
aTest
.
mAncestorTypes
)
.
c_str
(
)
<
<
"
in
\
"
"
<
<
NS_ConvertUTF16toUTF8
(
aTest
.
mInnerHTML
)
.
get
(
)
<
<
"
\
"
"
;
}
}
;
TEST
(
HTMLEditUtilsTest
GetAncestorElement_ClosestBlockElement
)
{
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
div
>
<
span
>
<
br
>
"
u
"
<
/
span
>
<
/
div
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
>
span
>
div
>
span
"
{
AncestorType
:
:
ClosestBlockElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
>
span
>
div
"
"
[
contenteditable
]
>
div
>
span
>
div
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
div
>
<
span
>
<
br
>
"
u
"
<
/
span
>
<
/
div
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
>
span
>
div
"
{
AncestorType
:
:
ClosestBlockElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
"
"
[
contenteditable
]
>
div
>
span
>
div
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
"
{
AncestorType
:
:
ClosestBlockElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
span
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
span
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
span
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
span
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
}
"
[
contenteditable
]
"
nullptr
nullptr
}
AncestorElementTest
{
u
"
<
div
>
<
span
contenteditable
>
<
br
>
<
/
span
>
"
"
[
contenteditable
]
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
div
"
nullptr
"
[
contenteditable
]
"
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForInclusiveAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForInclusiveAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetInclusiveAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
}
}
TEST
(
HTMLEditUtilsTest
GetAncestorElement_MostDistantInlineElementInBlock
)
{
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
EditableElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
>
span
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
i
>
<
div
>
<
u
>
<
s
>
<
br
>
"
u
"
<
/
s
>
<
/
u
>
<
/
div
>
<
/
i
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
s
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
}
"
[
contenteditable
]
"
"
[
contenteditable
]
u
"
"
[
contenteditable
]
u
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
i
>
<
div
>
<
u
>
<
s
>
<
br
>
"
u
"
<
/
s
>
<
/
u
>
<
/
div
>
<
/
i
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
u
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
}
"
[
contenteditable
]
"
nullptr
"
[
contenteditable
]
u
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
i
>
<
div
>
<
u
>
<
s
>
<
br
>
"
u
"
<
/
s
>
<
/
u
>
<
/
div
>
<
/
i
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
div
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
}
"
[
contenteditable
]
"
"
[
contenteditable
]
b
"
nullptr
}
AncestorElementTest
{
u
"
<
s
>
<
span
contenteditable
>
<
b
>
<
i
>
<
br
>
<
/
i
>
<
/
b
>
<
/
span
>
<
/
s
>
"
"
[
contenteditable
]
i
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
s
>
<
span
contenteditable
>
<
b
>
<
i
>
<
br
>
<
/
i
>
<
/
b
>
<
/
span
>
<
/
s
>
"
"
[
contenteditable
]
i
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
s
>
<
span
contenteditable
>
<
b
>
<
i
>
<
br
>
<
/
i
>
<
/
b
>
<
/
span
>
<
/
s
>
"
"
[
contenteditable
]
i
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
EditableElement
}
nullptr
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForInclusiveAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForInclusiveAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetInclusiveAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
}
}
TEST
(
HTMLEditUtilsTest
GetAncestorElement_ButtonElement
)
{
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
button
>
<
span
>
<
br
>
<
/
span
>
<
/
button
>
<
/
div
>
"
"
[
contenteditable
]
>
button
>
span
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
ClosestButtonElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
button
"
"
[
contenteditable
]
>
button
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
button
>
<
br
>
<
/
button
>
<
/
div
>
"
"
[
contenteditable
]
>
button
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
ClosestButtonElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
>
button
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
button
>
<
i
>
<
br
>
"
u
"
<
/
i
>
<
/
button
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
button
>
i
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
StopAtClosestButtonElement
}
"
[
contenteditable
]
"
nullptr
"
[
contenteditable
]
button
>
i
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
button
>
<
i
>
<
u
>
<
br
>
"
u
"
<
/
u
>
<
/
i
>
<
/
button
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
button
>
i
>
u
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
StopAtClosestButtonElement
}
"
[
contenteditable
]
"
"
i
"
"
i
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
button
>
<
i
>
<
br
>
"
u
"
<
/
i
>
<
/
button
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
button
>
i
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
ClosestButtonElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
button
"
"
[
contenteditable
]
button
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
b
>
<
button
>
<
br
>
<
/
button
>
<
/
b
>
<
/
div
>
"
"
[
contenteditable
]
>
b
>
button
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
ClosestButtonElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
b
"
"
[
contenteditable
]
>
b
>
button
"
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForInclusiveAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForInclusiveAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetInclusiveAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
}
}
TEST
(
HTMLEditUtilsTest
GetAncestorElement_IgnoreHRElement
)
{
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
hr
>
<
/
div
>
"
"
[
contenteditable
]
>
hr
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
IgnoreHRElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
button
>
<
hr
>
<
/
button
>
<
/
div
>
"
"
[
contenteditable
]
>
button
>
hr
"
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
ClosestButtonElement
AncestorType
:
:
IgnoreHRElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
button
"
"
[
contenteditable
]
>
button
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
span
>
<
hr
>
<
/
span
>
<
/
div
>
"
"
[
contenteditable
]
>
span
>
hr
"
{
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
IgnoreHRElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
span
"
"
[
contenteditable
]
>
span
"
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForInclusiveAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForInclusiveAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetInclusiveAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
}
}
TEST
(
HTMLEditUtilsTest
GetAncestorElement_ClosestContainerElement
)
{
using
AncestorType
=
HTMLEditUtils
:
:
AncestorType
;
const
RefPtr
<
Document
>
doc
=
CreateHTMLDoc
(
)
;
const
RefPtr
<
nsGenericHTMLElement
>
body
=
doc
-
>
GetBody
(
)
;
MOZ_RELEASE_ASSERT
(
body
)
;
for
(
const
auto
&
testData
:
{
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
>
span
>
br
"
{
AncestorType
:
:
ClosestContainerElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
>
span
"
"
[
contenteditable
]
>
div
>
span
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
>
span
"
{
AncestorType
:
:
ClosestContainerElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
"
"
[
contenteditable
]
>
div
>
span
"
}
AncestorElementTest
{
u
"
<
div
contenteditable
>
<
div
>
<
span
>
<
br
>
<
/
span
>
<
/
div
>
<
/
div
>
"
"
[
contenteditable
]
>
div
"
{
AncestorType
:
:
ClosestContainerElement
}
"
[
contenteditable
]
"
"
[
contenteditable
]
"
"
[
contenteditable
]
>
div
"
}
AncestorElementTest
{
u
"
<
br
contenteditable
>
"
"
br
[
contenteditable
]
"
{
AncestorType
:
:
ClosestContainerElement
}
"
br
[
contenteditable
]
"
nullptr
nullptr
}
AncestorElementTest
{
u
"
<
br
contenteditable
>
"
"
br
[
contenteditable
]
"
{
AncestorType
:
:
ClosestContainerElement
AncestorType
:
:
ReturnAncestorLimiterIfNoProperAncestor
}
"
br
[
contenteditable
]
"
nullptr
"
br
[
contenteditable
]
"
}
}
)
{
body
-
>
SetInnerHTMLTrusted
(
nsDependentString
(
testData
.
mInnerHTML
)
doc
-
>
NodePrincipal
(
)
IgnoreErrors
(
)
)
;
const
Element
*
const
content
=
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
;
MOZ_RELEASE_ASSERT
(
content
)
;
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
{
const
Element
*
const
expectedElement
=
testData
.
mExpectedSelectorForInclusiveAncestor
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mExpectedSelectorForInclusiveAncestor
)
IgnoreErrors
(
)
)
:
nullptr
;
const
Element
*
const
result
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mContentSelector
)
IgnoreErrors
(
)
)
testData
.
mAncestorTypes
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
testData
.
mAncestorLimiterSelector
?
body
-
>
QuerySelector
(
nsDependentCString
(
testData
.
mAncestorLimiterSelector
)
IgnoreErrors
(
)
)
:
nullptr
)
;
EXPECT_EQ
(
result
expectedElement
)
<
<
"
GetInclusiveAncestorElement
:
"
<
<
testData
<
<
"
(
Got
:
"
<
<
ToString
(
RefPtr
{
result
}
)
<
<
"
)
"
;
}
}
}
}
