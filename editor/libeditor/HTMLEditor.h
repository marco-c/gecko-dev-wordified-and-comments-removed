#
ifndef
mozilla_HTMLEditor_h
#
define
mozilla_HTMLEditor_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
ManualNAC
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIEditorMailSupport
.
h
"
#
include
"
nsIEditorStyleSheets
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsIHTMLInlineTableEditor
.
h
"
#
include
"
nsIHTMLObjectResizer
.
h
"
#
include
"
nsITableEditor
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsTArray
.
h
"
class
nsDocumentFragment
;
class
nsHTMLDocument
;
class
nsITransferable
;
class
nsIClipboard
;
class
nsTableWrapperFrame
;
class
nsRange
;
namespace
mozilla
{
class
AutoSelectionSetterAfterTableEdit
;
class
AutoSetTemporaryAncestorLimiter
;
class
EditActionResult
;
class
EmptyEditableFunctor
;
class
MoveNodeResult
;
class
ResizerSelectionListener
;
class
SplitRangeOffFromNodeResult
;
class
WSRunObject
;
enum
class
EditSubAction
:
int32_t
;
struct
PropItem
;
template
<
class
T
>
class
OwningNonNull
;
namespace
dom
{
class
AbstractRange
;
class
Blob
;
class
DocumentFragment
;
class
Event
;
class
MouseEvent
;
class
StaticRange
;
}
namespace
widget
{
struct
IMEState
;
}
enum
class
ParagraphSeparator
{
div
p
br
}
;
class
HTMLEditor
final
:
public
TextEditor
public
nsIHTMLEditor
public
nsIHTMLObjectResizer
public
nsIHTMLAbsPosEditor
public
nsITableEditor
public
nsIHTMLInlineTableEditor
public
nsIEditorStyleSheets
public
nsStubMutationObserver
public
nsIEditorMailSupport
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLEditor
TextEditor
)
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIHTMLEDITOR
NS_DECL_NSIHTMLOBJECTRESIZER
NS_DECL_NSIHTMLABSPOSEDITOR
NS_DECL_NSIHTMLINLINETABLEEDITOR
NS_DECL_NSIEDITORSTYLESHEETS
NS_DECL_NSIEDITORMAILSUPPORT
NS_DECL_NSITABLEEDITOR
NS_DECL_NSISELECTIONLISTENER
HTMLEditor
(
)
;
nsHTMLDocument
*
GetHTMLDocument
(
)
const
;
MOZ_CAN_RUN_SCRIPT
virtual
void
PreDestroy
(
bool
aDestroyingFrames
)
override
;
bool
GetReturnInParagraphCreatesNewParagraph
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aValue
)
override
;
NS_IMETHOD
BeginningOfDocument
(
)
override
;
NS_IMETHOD
SetFlags
(
uint32_t
aFlags
)
override
;
virtual
bool
CanPaste
(
int32_t
aClipboardType
)
const
override
;
using
EditorBase
:
:
CanPaste
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
=
nullptr
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
DeleteNode
(
nsINode
*
aNode
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
InsertLineBreak
(
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
override
;
virtual
nsIContent
*
GetFocusedContent
(
)
override
;
virtual
already_AddRefed
<
nsIContent
>
GetFocusedContentForIME
(
)
override
;
virtual
bool
IsActiveInDOMWindow
(
)
override
;
virtual
dom
:
:
EventTarget
*
GetDOMEventTarget
(
)
override
;
virtual
Element
*
FindSelectionRoot
(
nsINode
*
aNode
)
const
override
;
virtual
bool
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
override
;
virtual
nsresult
GetPreferredIMEState
(
widget
:
:
IMEState
*
aState
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteNoFormattingAsAction
(
int32_t
aSelectionType
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
=
nullptr
)
override
;
virtual
bool
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
override
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertParagraphSeparatorAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertElementAtSelectionAsAction
(
Element
*
aElement
bool
aDeleteSelection
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertLinkAroundSelectionAsAction
(
Element
*
aAnchorElement
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Element
>
CreateElementWithDefaults
(
const
nsAtom
&
aTagName
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
IndentAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OutdentAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetParagraphFormatAsAction
(
const
nsAString
&
aParagraphFormat
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
AlignAsAction
(
const
nsAString
&
aAlignType
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveListAsAction
(
const
nsAString
&
aListType
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
enum
class
SelectAllOfCurrentList
{
Yes
No
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MakeOrChangeListAsAction
(
nsAtom
&
aListElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnMouseDown
(
int32_t
aX
int32_t
aY
Element
*
aTarget
dom
:
:
Event
*
aMouseEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnMouseUp
(
int32_t
aX
int32_t
aY
Element
*
aTarget
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnMouseMove
(
dom
:
:
MouseEvent
*
aMouseEvent
)
;
bool
IsCSSEnabled
(
)
const
{
return
mCSSAware
&
&
mCSSEditUtils
&
&
mCSSEditUtils
-
>
IsCSSPrefChecked
(
)
;
}
MOZ_CAN_RUN_SCRIPT
void
EnableObjectResizer
(
bool
aEnable
)
{
if
(
mIsObjectResizingEnabled
=
=
aEnable
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableResizer
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
mIsObjectResizingEnabled
=
aEnable
;
RefreshEditingUI
(
)
;
}
bool
IsObjectResizerEnabled
(
)
const
{
return
mIsObjectResizingEnabled
;
}
Element
*
GetResizerTarget
(
)
const
{
return
mResizedObject
;
}
MOZ_CAN_RUN_SCRIPT
void
EnableInlineTableEditor
(
bool
aEnable
)
{
if
(
mIsInlineTableEditingEnabled
=
=
aEnable
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableInlineTableEditingUI
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
mIsInlineTableEditingEnabled
=
aEnable
;
RefreshEditingUI
(
)
;
}
bool
IsInlineTableEditorEnabled
(
)
const
{
return
mIsInlineTableEditingEnabled
;
}
MOZ_CAN_RUN_SCRIPT
void
EnableAbsolutePositionEditor
(
bool
aEnable
)
{
if
(
mIsAbsolutelyPositioningEnabled
=
=
aEnable
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableAbsolutePositionEditor
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
mIsAbsolutelyPositioningEnabled
=
aEnable
;
RefreshEditingUI
(
)
;
}
bool
IsAbsolutePositionEditorEnabled
(
)
const
{
return
mIsAbsolutelyPositioningEnabled
;
}
already_AddRefed
<
Element
>
GetAbsolutelyPositionedSelectionContainer
(
)
const
;
Element
*
GetPositionedElement
(
)
const
{
return
mAbsolutelyPositionedObject
;
}
nsresult
SetSelectionToAbsoluteOrStaticAsAction
(
bool
aEnabled
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
int32_t
GetZIndex
(
Element
&
aElement
)
;
nsresult
AddZIndexAsAction
(
int32_t
aChange
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetBackgroundColorAsAction
(
const
nsAString
&
aColor
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
nsresult
GetInlineProperty
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
)
const
;
nsresult
GetInlinePropertyWithAttrValue
(
nsAtom
*
aProperty
nsAtom
*
aAttr
const
nsAString
&
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
&
outValue
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveInlinePropertyAsAction
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveAllInlinePropertiesAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
IncreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DecreaseFontSizeAsAction
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
nsresult
GetFontColorState
(
bool
*
aIsMixed
nsAString
&
aColor
)
;
void
SetComposerCommandsUpdater
(
ComposerCommandsUpdater
*
aComposerCommandsUpdater
)
{
MOZ_ASSERT
(
!
aComposerCommandsUpdater
|
|
!
mComposerCommandsUpdater
|
|
aComposerCommandsUpdater
=
=
mComposerCommandsUpdater
)
;
mComposerCommandsUpdater
=
aComposerCommandsUpdater
;
}
nsStaticAtom
&
DefaultParagraphSeparatorTagName
(
)
const
{
return
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
mDefaultParagraphSeparator
)
;
}
ParagraphSeparator
GetDefaultParagraphSeparator
(
)
const
{
return
mDefaultParagraphSeparator
;
}
void
SetDefaultParagraphSeparator
(
ParagraphSeparator
aSep
)
{
mDefaultParagraphSeparator
=
aSep
;
}
static
nsStaticAtom
&
ToParagraphSeparatorTagName
(
ParagraphSeparator
aSeparator
)
{
switch
(
aSeparator
)
{
case
ParagraphSeparator
:
:
div
:
return
*
nsGkAtoms
:
:
div
;
case
ParagraphSeparator
:
:
p
:
return
*
nsGkAtoms
:
:
p
;
case
ParagraphSeparator
:
:
br
:
return
*
nsGkAtoms
:
:
br
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
New
paragraph
separator
isn
'
t
handled
here
"
)
;
return
*
nsGkAtoms
:
:
div
;
}
}
MOZ_CAN_RUN_SCRIPT
nsresult
DoInlineTableEditingAction
(
const
Element
&
aUIAnonymousElement
)
;
Element
*
GetElementOrParentByTagName
(
const
nsAtom
&
aTagName
nsINode
*
aNode
)
const
;
Element
*
GetActiveEditingHost
(
)
const
;
void
NotifyEditingHostMaybeChanged
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertAsQuotation
(
const
nsAString
&
aQuotedText
nsINode
*
*
aNodeInserted
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextWithQuotations
(
const
nsAString
&
aStringToInsert
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertHTMLAsAction
(
const
nsAString
&
aInString
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Element
>
InsertBRElementWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
EDirection
aSelect
=
eNone
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
DeleteSelectionWithTransaction
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteNodeWithTransaction
(
nsINode
&
aNode
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTextWithTransaction
(
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DeleteParentBlocksWithTransactionIfEmpty
(
const
EditorDOMPoint
&
aPoint
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
=
nullptr
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
CopyLastEditableChildStylesWithTransaction
(
Element
&
aPreviousBlock
Element
&
aNewBlock
RefPtr
<
Element
>
*
aNewBrElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveBlockContainerWithTransaction
(
Element
&
aElement
)
;
virtual
Element
*
GetEditorRoot
(
)
const
override
;
using
EditorBase
:
:
IsEditable
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
override
;
using
EditorBase
:
:
RemoveAttributeOrEquivalent
;
using
EditorBase
:
:
SetAttributeOrEquivalent
;
static
Element
*
GetBlockNodeParent
(
nsINode
*
aNode
nsINode
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetBlock
(
nsINode
&
aNode
nsINode
*
aAncestorLimiter
=
nullptr
)
;
Element
*
GetSelectionContainerElement
(
)
const
;
already_AddRefed
<
Element
>
GetFirstSelectedTableCellElement
(
ErrorResult
&
aRv
)
const
;
already_AddRefed
<
Element
>
GetNextSelectedTableCellElement
(
ErrorResult
&
aRv
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTableCellContentsWithTransaction
(
)
;
static
void
IsNextCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
=
nullptr
int32_t
*
outOffset
=
0
)
;
static
void
IsPrevCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
=
nullptr
int32_t
*
outOffset
=
0
)
;
static
bool
NodeIsBlockStatic
(
const
nsINode
&
aElement
)
;
static
bool
NodeIsInlineStatic
(
const
nsINode
&
aElement
)
{
return
!
NodeIsBlockStatic
(
aElement
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
SetPositionToAbsoluteOrStatic
(
Element
&
aElement
bool
aEnabled
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RelativeChangeElementZIndex
(
Element
&
aElement
int32_t
aChange
int32_t
*
aReturn
)
;
virtual
bool
IsBlockNode
(
nsINode
*
aNode
)
const
override
;
using
EditorBase
:
:
IsBlockNode
;
virtual
bool
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
const
override
;
virtual
bool
IsContainer
(
nsINode
*
aNode
)
const
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
CollapseAdjacentTextNodes
(
nsRange
*
aRange
)
;
bool
IsInVisibleTextFrames
(
dom
:
:
Text
&
aText
)
const
;
bool
IsVisibleTextNode
(
Text
&
aText
)
const
;
nsresult
IsEmptyNode
(
nsINode
*
aNode
bool
*
outIsEmptyBlock
bool
aSingleBRDoesntCount
=
false
bool
aListOrCellNotEmpty
=
false
bool
aSafeToAskFrames
=
false
)
const
;
nsresult
IsEmptyNodeImpl
(
nsINode
*
aNode
bool
*
outIsEmptyBlock
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
bool
*
aSeenBR
)
const
;
static
bool
HasAttributes
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
uint32_t
attrCount
=
aElement
-
>
GetAttrCount
(
)
;
return
attrCount
>
1
|
|
(
1
=
=
attrCount
&
&
!
aElement
-
>
GetAttrNameAt
(
0
)
-
>
Equals
(
nsGkAtoms
:
:
mozdirty
)
)
;
}
static
bool
IsTextPropertySetByContent
(
nsINode
*
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
nsAString
*
outValue
=
nullptr
)
;
static
dom
:
:
Element
*
GetLinkElement
(
nsINode
*
aNode
)
;
bool
IsVisibleBRElement
(
nsINode
*
aNode
)
;
enum
class
FontSize
{
incr
decr
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
RelativeFontChangeOnTextNode
(
FontSize
aDir
Text
&
aTextNode
int32_t
aStartOffset
int32_t
aEndOffset
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetInlinePropertyOnNode
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SplitStyleAbovePoint
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsAtom
*
aProperty
nsAtom
*
aAttribute
nsIContent
*
*
aOutLeftNode
=
nullptr
nsIContent
*
*
aOutRightNode
=
nullptr
)
;
nsIContent
*
GetPriorHTMLSibling
(
nsINode
*
aNode
)
;
nsIContent
*
GetNextHTMLSibling
(
nsINode
*
aNode
)
;
nsIContent
*
GetPreviousHTMLElementOrText
(
nsINode
&
aNode
)
{
return
GetPreviousHTMLElementOrTextInternal
(
aNode
false
)
;
}
nsIContent
*
GetPreviousHTMLElementOrTextInBlock
(
nsINode
&
aNode
)
{
return
GetPreviousHTMLElementOrTextInternal
(
aNode
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousHTMLElementOrText
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetPreviousHTMLElementOrTextInternal
(
aPoint
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousHTMLElementOrTextInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetPreviousHTMLElementOrTextInternal
(
aPoint
true
)
;
}
nsIContent
*
GetPreviousHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
;
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
;
nsIContent
*
GetPreviousEditableHTMLNode
(
nsINode
&
aNode
)
{
return
GetPreviousEditableHTMLNodeInternal
(
aNode
false
)
;
}
nsIContent
*
GetPreviousEditableHTMLNodeInBlock
(
nsINode
&
aNode
)
{
return
GetPreviousEditableHTMLNodeInternal
(
aNode
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousEditableHTMLNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetPreviousEditableHTMLNodeInternal
(
aPoint
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousEditableHTMLNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetPreviousEditableHTMLNodeInternal
(
aPoint
true
)
;
}
nsIContent
*
GetPreviousEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
;
template
<
typename
PT
typename
CT
>
nsIContent
*
GetPreviousEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
;
nsIContent
*
GetNextHTMLElementOrText
(
nsINode
&
aNode
)
{
return
GetNextHTMLElementOrTextInternal
(
aNode
false
)
;
}
nsIContent
*
GetNextHTMLElementOrTextInBlock
(
nsINode
&
aNode
)
{
return
GetNextHTMLElementOrTextInternal
(
aNode
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextHTMLElementOrText
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextHTMLElementOrTextInternal
(
aPoint
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextHTMLElementOrTextInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
GetNextHTMLElementOrTextInternal
(
aPoint
true
)
;
}
nsIContent
*
GetNextHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
;
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
;
nsIContent
*
GetNextEditableHTMLNode
(
nsINode
&
aNode
)
const
{
return
GetNextEditableHTMLNodeInternal
(
aNode
false
)
;
}
nsIContent
*
GetNextEditableHTMLNodeInBlock
(
nsINode
&
aNode
)
const
{
return
GetNextEditableHTMLNodeInternal
(
aNode
true
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableHTMLNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextEditableHTMLNodeInternal
(
aPoint
false
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableHTMLNodeInBlock
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
return
GetNextEditableHTMLNodeInternal
(
aPoint
true
)
;
}
nsIContent
*
GetNextEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
;
template
<
typename
PT
typename
CT
>
nsIContent
*
GetNextEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
;
bool
IsFirstEditableChild
(
nsINode
*
aNode
)
const
;
bool
IsLastEditableChild
(
nsINode
*
aNode
)
const
;
nsIContent
*
GetFirstEditableChild
(
nsINode
&
aNode
)
const
;
nsIContent
*
GetLastEditableChild
(
nsINode
&
aNode
)
const
;
nsIContent
*
GetFirstEditableLeaf
(
nsINode
&
aNode
)
;
nsIContent
*
GetLastEditableLeaf
(
nsINode
&
aNode
)
;
nsresult
GetInlinePropertyBase
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
bool
*
aFirst
bool
*
aAny
bool
*
aAll
nsAString
*
outValue
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
ClearStyle
(
nsCOMPtr
<
nsINode
>
*
aNode
int32_t
*
aOffset
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetPositionToAbsolute
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetPositionToStatic
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
OnModifyDocument
(
)
;
protected
:
EditActionResult
CanHandleHTMLEditSubAction
(
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillInsert
(
bool
*
aCancel
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillInsertText
(
EditSubAction
aEditSubAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
GetInlineStyles
(
nsINode
&
aNode
AutoStyleCacheArray
&
aStyleCacheArray
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
CacheInlineStyles
(
nsINode
&
aNode
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
ReapplyCachedStyles
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
CreateStyleForInsertText
(
dom
:
:
AbstractRange
&
aAbstractRange
)
;
Element
*
GetMostAncestorMailCiteElement
(
nsINode
&
aNode
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
SplitMailCiteElements
(
const
EditorDOMPoint
&
aPointToSplit
)
;
bool
CanContainParagraph
(
Element
&
aElement
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertBRElement
(
const
EditorDOMPoint
&
aInsertToBreak
)
;
nsIContent
*
GetMostAncestorInlineElement
(
nsINode
&
aNode
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitParentInlineElementsAtRangeEdges
(
RangeItem
&
aRangeItem
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitParentInlineElementsAtRangeEdges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitElementsAtEveryBRElement
(
nsIContent
&
aMostAncestorToBeSplit
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MaybeSplitElementsAtEveryBRElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
EditSubAction
aEditSubAction
)
;
enum
class
CollectListChildren
{
No
Yes
}
;
enum
class
CollectTableChildren
{
No
Yes
}
;
enum
class
CollectNonEditableNodes
{
No
Yes
}
;
size_t
CollectChildren
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
size_t
aIndexToInsertChildren
CollectListChildren
aCollectListChildren
CollectTableChildren
aCollectTableChildren
CollectNonEditableNodes
aCollectNonEditableNodes
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitInlinesAndCollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitTextNodesAtRangeEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
;
nsresult
CollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
;
enum
class
ScanDirection
{
Backward
Forward
}
;
template
<
typename
PT
typename
RT
>
static
EditorDOMPoint
GetWhiteSpaceEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
ScanDirection
aScanDirection
)
;
template
<
typename
PT
typename
RT
>
EditorDOMPoint
GetCurrentHardLineStartPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
EditSubAction
aEditSubAction
)
;
template
<
typename
PT
typename
RT
>
EditorDOMPoint
GetCurrentHardLineEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
)
;
already_AddRefed
<
nsRange
>
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
dom
:
:
AbstractRange
&
aAbstractRange
)
;
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
;
void
GetSelectionRangesExtendedToIncludeAdjuscentWhiteSpaces
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
)
;
already_AddRefed
<
nsRange
>
CreateRangeExtendedToHardLineStartAndEnd
(
const
dom
:
:
AbstractRange
&
aAbstractRange
EditSubAction
aEditSubAction
)
;
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
EditSubAction
aEditSubAction
)
;
void
GetSelectionRangesExtendedToHardLineStartAndEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
EditSubAction
aEditSubAction
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
AutoTArray
<
RefPtr
<
nsRange
>
4
>
extendedSelectionRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
extendedSelectionRanges
aEditSubAction
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
extendedSelectionRanges
aOutArrayOfNodes
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SplitInlinesAndCollectEditTargetNodes
(
)
failed
"
)
;
return
rv
;
}
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitInlinesAndCollectEditTargetNodesInOneHardLine
(
const
EditorDOMPoint
&
aPointInOneHardLine
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
if
(
NS_WARN_IF
(
!
aPointInOneHardLine
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsRange
>
oneLineRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
aPointInOneHardLine
.
ToRawRangeBoundary
(
)
aPointInOneHardLine
.
ToRawRangeBoundary
(
)
aEditSubAction
)
;
if
(
!
oneLineRange
)
{
ErrorResult
error
;
oneLineRange
=
nsRange
:
:
Create
(
aPointInOneHardLine
.
ToRawRangeBoundary
(
)
aPointInOneHardLine
.
ToRawRangeBoundary
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
AutoTArray
<
RefPtr
<
nsRange
>
1
>
arrayOfLineRanges
;
arrayOfLineRanges
.
AppendElement
(
oneLineRange
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfLineRanges
aOutArrayOfNodes
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SplitInlinesAndCollectEditTargetNodes
(
)
failed
"
)
;
return
rv
;
}
nsresult
CollectEditTargetNodesInExtendedSelectionRanges
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
AutoTArray
<
RefPtr
<
nsRange
>
4
>
extendedSelectionRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
extendedSelectionRanges
aEditSubAction
)
;
nsresult
rv
=
CollectEditTargetNodes
(
extendedSelectionRanges
aOutArrayOfNodes
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CollectEditTargetNodes
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
void
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
;
static
void
GetChildNodesOf
(
nsINode
&
aParentNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aChildNodes
)
{
MOZ_ASSERT
(
aChildNodes
.
IsEmpty
(
)
)
;
aChildNodes
.
SetCapacity
(
aParentNode
.
GetChildCount
(
)
)
;
for
(
nsIContent
*
childContent
=
aParentNode
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
aChildNodes
.
AppendElement
(
*
childContent
)
;
}
}
Element
*
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
nsINode
&
aNode
)
;
Element
*
GetParentListElementAtSelection
(
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
bool
IsEmptyInineNode
(
nsINode
&
aNode
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditor
:
:
NodeIsInlineStatic
(
aNode
)
|
|
!
IsContainer
(
&
aNode
)
)
{
return
false
;
}
bool
isEmpty
=
true
;
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
return
isEmpty
;
}
bool
IsEmptyOneHardLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
)
const
{
if
(
NS_WARN_IF
(
!
aArrayOfNodes
.
Length
(
)
)
)
{
return
true
;
}
bool
brElementHasFound
=
false
;
for
(
auto
&
node
:
aArrayOfNodes
)
{
if
(
!
IsEditable
(
node
)
)
{
continue
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
brElementHasFound
)
{
return
false
;
}
brElementHasFound
=
true
;
continue
;
}
if
(
!
IsEmptyInineNode
(
node
)
)
{
return
false
;
}
}
return
true
;
}
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitNodeResult
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aStartOfDeepestRightNode
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
Element
&
aBlockElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MoveNodesIntoNewBlockquoteElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
RemoveBlockContainerElements
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
CreateOrChangeBlockContainerElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
FormatBlockContainerWithTransaction
(
nsAtom
&
aBlockType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
const
EditorDOMPoint
&
aPointToInsert
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertBRElementIfEmptyBlockElement
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
enum
class
IgnoreSingleBR
{
Yes
No
}
;
bool
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
const
;
template
<
typename
PT
typename
CT
>
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aBRNode
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleInsertParagraphInParagraph
(
Element
&
aParentDivOrP
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleInsertParagraphInHeadingElement
(
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleInsertParagraphInListItemElement
(
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
;
Element
*
GetNearestAncestorListItemElement
(
nsIContent
&
aContent
)
const
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
InsertParagraphSeparatorAsSubAction
(
)
;
static
bool
NodesInDifferentTableElements
(
nsINode
&
aNode1
nsINode
&
aNode2
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
CreateElementResult
ChangeListElementType
(
Element
&
aListElement
nsAtom
&
aListType
nsAtom
&
aItemType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
ChangeSelectedHardLinesToList
(
nsAtom
&
aListElementTagName
nsAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
MakeOrChangeListAndListItemAsSubAction
(
nsAtom
&
aListElementOrListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DeleteNodeIfInvisibleAndEditableTextNode
(
nsINode
&
aNode
)
;
template
<
typename
PT
typename
CT
>
Element
*
GetInvisibleBRElementAt
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
MoveNodeResult
MoveNodeOrChildren
(
nsIContent
&
aNode
const
EditorDOMPoint
&
aPointToInsert
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
MoveNodeResult
MoveChildren
(
Element
&
aElement
const
EditorDOMPoint
&
aPointToInsert
)
;
enum
class
MoveToEndOfContainer
{
Yes
No
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
MoveNodeResult
MoveOneHardLineContents
(
const
EditorDOMPoint
&
aPointInHardLine
const
EditorDOMPoint
&
aPointToInsert
MoveToEndOfContainer
aMoveToEndOfContainer
=
MoveToEndOfContainer
:
:
No
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
TryToJoinBlocksWithTransaction
(
nsIContent
&
aLeftContentInBlock
nsIContent
&
aRightContentInBlock
)
;
EditorDOMPoint
GetGoodCaretPointFor
(
nsIContent
&
aContent
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
MaybeDeleteTopMostEmptyAncestor
(
nsIContent
&
aStartContent
Element
&
aEditingHostElement
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
already_AddRefed
<
dom
:
:
StaticRange
>
GetExtendedRangeToIncludeInvisibleNodes
(
const
dom
:
:
AbstractRange
&
aAbstractRange
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
WSRunObject
&
aWSRunObjectAtCaret
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteCollapsedSelectionAtTextNode
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteCollapsedSelectionAtAtomicContent
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
WSRunObject
&
aWSRunObjectAtCaret
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
WSRunObject
&
aWSRunObjectAtCaret
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DeleteUnnecessaryNodesAndCollapseSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteAroundCollapsedSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
enum
class
SelectionWasCollapsed
{
Yes
No
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteNonCollapsedSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
SelectionWasCollapsed
aSelectionWasCollapsed
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DeleteElementsExceptTableRelatedElements
(
nsINode
&
aNode
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
;
enum
class
LiftUpFromAllParentListElements
{
Yes
No
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
LiftUpListItemElement
(
dom
:
:
Element
&
aListItemElement
LiftUpFromAllParentListElements
aLiftUpFromAllParentListElements
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DestroyListStructureRecursively
(
Element
&
aListElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
RemoveListAtSelectionAsSubAction
(
)
;
enum
class
ChangeMargin
{
Increase
Decrease
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
ChangeMarginStart
(
Element
&
aElement
ChangeMargin
aChangeMargin
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleCSSIndentAtSelectionInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleHTMLIndentAtSelectionInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleCSSIndentAtSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
HandleHTMLIndentAtSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleIndentAtSelection
(
)
;
enum
class
BlockIndentedWith
{
CSS
HTML
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOutdent
BlockIndentedWith
aBlockIndentedWith
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
HandleOutdentAtSelectionInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
HandleOutdentAtSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignBlockContentsWithDivElement
(
dom
:
:
Element
&
aBlockElement
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignContentsInAllTableCellsAndListItems
(
dom
:
:
Element
&
aElement
const
nsAString
&
aAlignType
)
;
static
void
MakeTransitionList
(
const
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
EnsureHardLineBeginsWithFirstChildOf
(
dom
:
:
Element
&
aRemovingContainerElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
EnsureHardLineEndsWithLastChildOf
(
dom
:
:
Element
&
aRemovingContainerElement
)
;
enum
class
EditTarget
{
OnlyDescendantsExceptTable
NodeAndDescendantsExceptTable
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
RemoveAlignFromDescendants
(
Element
&
aElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
SetBlockElementAlign
(
Element
&
aBlockOrHRElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
AlignContentsAtSelectionWithEmptyDivElement
(
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignNodesAndDescendants
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
AlignAsSubAction
(
const
nsAString
&
aAlignType
)
;
bool
StartOrEndOfSelectionRangesIsIn
(
nsIContent
&
aContent
)
const
;
template
<
typename
PT
typename
CT
>
nsIContent
*
FindNearEditableContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AdjustCaretPositionAndEnsurePaddingBRElement
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
EnsureSelectionInBodyOrDocumentElement
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
protected
:
virtual
void
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
void
OnEndHandlingTopLevelEditSubAction
(
)
override
;
protected
:
virtual
~
HTMLEditor
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SelectAllInternal
(
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
SelectContentInternal
(
nsIContent
&
aContentToSelect
)
;
nsresult
CollapseSelectionAfter
(
Element
&
aElement
)
;
Element
*
GetElementOrParentByTagNameAtSelection
(
const
nsAtom
&
aTagName
)
const
;
Element
*
GetElementOrParentByTagNameInternal
(
const
nsAtom
&
aTagName
nsINode
&
aNode
)
const
;
already_AddRefed
<
Element
>
GetSelectedElement
(
const
nsAtom
*
aTagName
ErrorResult
&
aRv
)
;
Element
*
GetFirstTableRowElement
(
Element
&
aTableOrElementInTable
ErrorResult
&
aRv
)
const
;
Element
*
GetNextTableRowElement
(
Element
&
aTableRowElement
ErrorResult
&
aRv
)
const
;
struct
CellAndIndexes
;
struct
CellData
;
struct
MOZ_STACK_CLASS
CellIndexes
final
{
int32_t
mRow
;
int32_t
mColumn
;
CellIndexes
(
Element
&
aCellElement
ErrorResult
&
aRv
)
:
mRow
(
-
1
)
mColumn
(
-
1
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
Update
(
aCellElement
aRv
)
;
}
void
Update
(
Element
&
aCellElement
ErrorResult
&
aRv
)
;
CellIndexes
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
ErrorResult
&
aRv
)
:
mRow
(
-
1
)
mColumn
(
-
1
)
{
Update
(
aHTMLEditor
aSelection
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
ErrorResult
&
aRv
)
;
bool
operator
=
=
(
const
CellIndexes
&
aOther
)
const
{
return
mRow
=
=
aOther
.
mRow
&
&
mColumn
=
=
aOther
.
mColumn
;
}
bool
operator
!
=
(
const
CellIndexes
&
aOther
)
const
{
return
mRow
!
=
aOther
.
mRow
|
|
mColumn
!
=
aOther
.
mColumn
;
}
private
:
CellIndexes
(
)
:
mRow
(
-
1
)
mColumn
(
-
1
)
{
}
friend
struct
CellAndIndexes
;
friend
struct
CellData
;
}
;
struct
MOZ_STACK_CLASS
CellAndIndexes
final
{
RefPtr
<
Element
>
mElement
;
CellIndexes
mIndexes
;
CellAndIndexes
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
ErrorResult
&
aRv
)
{
Update
(
aHTMLEditor
aSelection
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
ErrorResult
&
aRv
)
;
}
;
struct
MOZ_STACK_CLASS
CellData
final
{
RefPtr
<
Element
>
mElement
;
CellIndexes
mCurrent
;
CellIndexes
mFirst
;
int32_t
mRowSpan
;
int32_t
mColSpan
;
int32_t
mEffectiveRowSpan
;
int32_t
mEffectiveColSpan
;
bool
mIsSelected
;
CellData
(
)
:
mRowSpan
(
-
1
)
mColSpan
(
-
1
)
mEffectiveRowSpan
(
-
1
)
mEffectiveColSpan
(
-
1
)
mIsSelected
(
false
)
{
}
CellData
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
ErrorResult
&
aRv
)
{
Update
(
aHTMLEditor
aTableElement
aRowIndex
aColumnIndex
aRv
)
;
}
CellData
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableElement
const
CellIndexes
&
aIndexes
ErrorResult
&
aRv
)
{
Update
(
aHTMLEditor
aTableElement
aIndexes
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
ErrorResult
&
aRv
)
{
mCurrent
.
mRow
=
aRowIndex
;
mCurrent
.
mColumn
=
aColumnIndex
;
Update
(
aHTMLEditor
aTableElement
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableElement
const
CellIndexes
&
aIndexes
ErrorResult
&
aRv
)
{
mCurrent
=
aIndexes
;
Update
(
aHTMLEditor
aTableElement
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableElement
ErrorResult
&
aRv
)
;
bool
FailedOrNotFound
(
)
const
{
return
!
mElement
;
}
bool
IsSpannedFromOtherRowOrColumn
(
)
const
{
return
mElement
&
&
mCurrent
!
=
mFirst
;
}
bool
IsSpannedFromOtherColumn
(
)
const
{
return
mElement
&
&
mCurrent
.
mColumn
!
=
mFirst
.
mColumn
;
}
bool
IsSpannedFromOtherRow
(
)
const
{
return
mElement
&
&
mCurrent
.
mRow
!
=
mFirst
.
mRow
;
}
int32_t
NextColumnIndex
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mCurrent
.
mColumn
+
mEffectiveColSpan
;
}
int32_t
NextRowIndex
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mCurrent
.
mRow
+
mEffectiveRowSpan
;
}
int32_t
LastColumnIndex
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
NextColumnIndex
(
)
-
1
;
}
int32_t
LastRowIndex
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
NextRowIndex
(
)
-
1
;
}
int32_t
NumberOfPrecedingColmuns
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mCurrent
.
mColumn
-
mFirst
.
mColumn
;
}
int32_t
NumberOfPrecedingRows
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mCurrent
.
mRow
-
mFirst
.
mRow
;
}
int32_t
NumberOfFollowingColumns
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mEffectiveColSpan
-
1
;
}
int32_t
NumberOfFollowingRows
(
)
const
{
if
(
NS_WARN_IF
(
FailedOrNotFound
(
)
)
)
{
return
-
1
;
}
return
mEffectiveRowSpan
-
1
;
}
}
;
struct
MOZ_STACK_CLASS
TableSize
final
{
int32_t
mRowCount
;
int32_t
mColumnCount
;
TableSize
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableOrElementInTable
ErrorResult
&
aRv
)
:
mRowCount
(
-
1
)
mColumnCount
(
-
1
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
Update
(
aHTMLEditor
aTableOrElementInTable
aRv
)
;
}
void
Update
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableOrElementInTable
ErrorResult
&
aRv
)
;
bool
IsEmpty
(
)
const
{
return
!
mRowCount
|
|
!
mColumnCount
;
}
}
;
Element
*
GetTableCellElementAt
(
Element
&
aTableElement
const
CellIndexes
&
aCellIndexes
)
const
{
return
GetTableCellElementAt
(
aTableElement
aCellIndexes
.
mRow
aCellIndexes
.
mColumn
)
;
}
Element
*
GetTableCellElementAt
(
Element
&
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
)
const
;
already_AddRefed
<
Element
>
GetSelectedOrParentTableElement
(
ErrorResult
&
aRv
bool
*
aIsCellSelected
=
nullptr
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteInternal
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertAsCitedQuotationInternal
(
const
nsAString
&
aQuotedText
const
nsAString
&
aCitation
bool
aInsertHTML
nsINode
*
*
aNodeInserted
)
;
MOZ_CAN_RUN_SCRIPT
EditorDOMPoint
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertBrElementAtSelectionWithTransaction
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTextWithQuotationsInternal
(
const
nsAString
&
aStringToInsert
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
IndentAsSubAction
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
EditActionResult
OutdentAsSubAction
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
LoadHTML
(
const
nsAString
&
aInputString
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetInlinePropertyInternal
(
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveInlinePropertyInternal
(
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ReplaceHeadContentsWithSourceWithTransaction
(
const
nsAString
&
aSourceToInsert
)
;
nsresult
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
;
nsresult
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
outColor
)
;
nsresult
GetLastCellInRow
(
nsINode
*
aRowNode
nsINode
*
*
aCellNode
)
;
static
nsresult
GetCellFromRange
(
nsRange
*
aRange
Element
*
*
aCell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetCSSBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetHTMLBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
;
virtual
void
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
SelectEntireDocument
(
)
override
;
void
CollapseSelectionToDeepestNonTableFirstChild
(
nsINode
*
aNode
)
;
bool
EnableExistingStyleSheet
(
const
nsAString
&
aURL
)
;
StyleSheet
*
GetStyleSheetForURL
(
const
nsAString
&
aURL
)
;
nsresult
AddNewStyleSheetToList
(
const
nsAString
&
aURL
StyleSheet
*
aStyleSheet
)
;
already_AddRefed
<
StyleSheet
>
RemoveStyleSheetFromList
(
const
nsAString
&
aURL
)
;
nsresult
AddOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
;
nsresult
RemoveOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
;
void
EnableStyleSheetInternal
(
const
nsAString
&
aURL
bool
aEnable
)
;
nsresult
MaybeCollapseSelectionAtFirstEditableNode
(
bool
aIgnoreIfSelectionInEditingHost
)
;
class
BlobReader
final
{
typedef
EditorBase
:
:
AutoEditActionDataSetter
AutoEditActionDataSetter
;
public
:
BlobReader
(
dom
:
:
BlobImpl
*
aBlob
HTMLEditor
*
aHTMLEditor
bool
aIsSafe
Document
*
aSourceDoc
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
BlobReader
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
BlobReader
)
MOZ_CAN_RUN_SCRIPT
nsresult
OnResult
(
const
nsACString
&
aResult
)
;
nsresult
OnError
(
const
nsAString
&
aErrorName
)
;
private
:
~
BlobReader
(
)
{
}
RefPtr
<
dom
:
:
BlobImpl
>
mBlob
;
RefPtr
<
HTMLEditor
>
mHTMLEditor
;
nsCOMPtr
<
Document
>
mSourceDoc
;
EditorDOMPoint
mPointToInsert
;
EditAction
mEditAction
;
bool
mIsSafe
;
bool
mDoDeleteSelection
;
}
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InitRules
(
)
override
;
virtual
void
CreateEventListeners
(
)
override
;
virtual
nsresult
InstallEventListeners
(
)
override
;
virtual
void
RemoveEventListeners
(
)
override
;
bool
ShouldReplaceRootElement
(
)
;
void
NotifyRootChanged
(
)
;
Element
*
GetBodyElement
(
)
;
already_AddRefed
<
nsINode
>
GetFocusedNode
(
)
;
virtual
already_AddRefed
<
Element
>
GetInputEventTargetElement
(
)
override
;
bool
SetCaretInTableCell
(
dom
:
:
Element
*
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
TabInTable
(
bool
inIsShift
bool
*
outHandled
)
;
enum
class
InsertPosition
{
eBeforeSelectedCell
eAfterSelectedCell
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTableCellsWithTransaction
(
int32_t
aNumberOfCellsToInsert
InsertPosition
aInsertPosition
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTableColumnsWithTransaction
(
int32_t
aNumberOfColumnsToInsert
InsertPosition
aInsertPosition
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertTableRowsWithTransaction
(
int32_t
aNumberOfRowsToInsert
InsertPosition
aInsertPosition
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertCell
(
Element
*
aCell
int32_t
aRowSpan
int32_t
aColSpan
bool
aAfter
bool
aIsHeader
Element
*
*
aNewCell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectedTableColumnsWithTransaction
(
int32_t
aNumberOfColumnsToDelete
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTableColumnWithTransaction
(
Element
&
aTableElement
int32_t
aColumnIndex
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteSelectedTableRowsWithTransaction
(
int32_t
aNumberOfRowsToDelete
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTableRowWithTransaction
(
Element
&
aTableElement
int32_t
aRowIndex
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTableCellWithTransaction
(
int32_t
aNumberOfCellsToDelete
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteAllChildrenWithTransaction
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
MergeCells
(
RefPtr
<
Element
>
aTargetCell
RefPtr
<
Element
>
aCellToMerge
bool
aDeleteCellToMerge
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTableElementAndChildrenWithTransaction
(
Element
&
aTableElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetColSpan
(
Element
*
aCell
int32_t
aColSpan
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetRowSpan
(
Element
*
aCell
int32_t
aRowSpan
)
;
static
nsTableWrapperFrame
*
GetTableFrame
(
Element
*
aTable
)
;
int32_t
GetNumberOfCellsInRow
(
Element
&
aTableElement
int32_t
aRowIndex
)
;
bool
AllCellsInRowSelected
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aNumberOfColumns
)
;
bool
AllCellsInColumnSelected
(
Element
*
aTable
int32_t
aColIndex
int32_t
aNumberOfRows
)
;
bool
IsEmptyCell
(
Element
*
aCell
)
;
nsresult
GetCellContext
(
Element
*
*
aTable
Element
*
*
aCell
nsINode
*
*
aCellParent
int32_t
*
aCellOffset
int32_t
*
aRowIndex
int32_t
*
aColIndex
)
;
nsresult
GetCellSpansAt
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
&
aActualRowSpan
int32_t
&
aActualColSpan
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SplitCellIntoColumns
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aColSpanLeft
int32_t
aColSpanRight
Element
*
*
aNewCell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SplitCellIntoRows
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aRowSpanAbove
int32_t
aRowSpanBelow
Element
*
*
aNewCell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
CopyCellBackgroundColor
(
Element
*
aDestCell
Element
*
aSourceCell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
FixBadRowSpan
(
Element
*
aTable
int32_t
aRowIndex
int32_t
&
aNewRowCount
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
FixBadColSpan
(
Element
*
aTable
int32_t
aColIndex
int32_t
&
aNewColCount
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
NormalizeTableInternal
(
Element
&
aTableOrElementInTable
)
;
nsresult
SetSelectionAtDocumentStart
(
)
;
static
Element
*
GetEnclosingTable
(
nsINode
*
aNode
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PasteAsPlaintextQuotation
(
int32_t
aSelectionType
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertAsPlaintextQuotation
(
const
nsAString
&
aQuotedText
bool
aAddCites
nsINode
*
*
aNodeInserted
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertObject
(
const
nsACString
&
aType
nsISupports
*
aObject
bool
aIsSafe
Document
*
aSourceDoc
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
;
virtual
nsresult
PrepareTransferable
(
nsITransferable
*
*
transferable
)
override
;
nsresult
PrepareHTMLTransferable
(
nsITransferable
*
*
transferable
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertFromTransferable
(
nsITransferable
*
transferable
Document
*
aSourceDoc
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
bool
havePrivateHTMLFlavor
bool
aDoDeleteSelection
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertFromDataTransfer
(
dom
:
:
DataTransfer
*
aDataTransfer
int32_t
aIndex
Document
*
aSourceDoc
const
EditorDOMPoint
&
aDroppedAt
bool
aDoDeleteSelection
)
;
bool
HavePrivateHTMLFlavor
(
nsIClipboard
*
clipboard
)
;
nsresult
ParseCFHTML
(
nsCString
&
aCfhtml
char16_t
*
*
aStuffToPaste
char16_t
*
*
aCfcontext
)
;
nsresult
StripFormattingNodes
(
nsIContent
&
aNode
bool
aOnlyList
=
false
)
;
nsresult
CreateDOMFragmentFromPaste
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
nsCOMPtr
<
nsINode
>
*
outFragNode
nsCOMPtr
<
nsINode
>
*
outStartNode
nsCOMPtr
<
nsINode
>
*
outEndNode
int32_t
*
outStartOffset
int32_t
*
outEndOffset
bool
aTrustedInput
)
;
nsresult
ParseFragment
(
const
nsAString
&
aStr
nsAtom
*
aContextLocalName
Document
*
aTargetDoc
dom
:
:
DocumentFragment
*
*
aFragment
bool
aTrustedInput
)
;
void
CreateListOfNodesToPaste
(
dom
:
:
DocumentFragment
&
aFragment
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outNodeList
nsINode
*
aStartContainer
int32_t
aStartOffset
nsINode
*
aEndContainer
int32_t
aEndOffset
)
;
enum
class
StartOrEnd
{
start
end
}
;
void
GetListAndTableParents
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeList
nsTArray
<
OwningNonNull
<
Element
>
>
&
outArray
)
;
int32_t
DiscoverPartialListsAndTables
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aPasteNodes
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListsAndTables
)
;
nsINode
*
ScanForListAndTableStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodes
Element
&
aListOrTable
)
;
void
ReplaceOrphanedStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListAndTableArray
int32_t
aHighWaterMark
)
;
EditorRawDOMPoint
GetBetterInsertionPointFor
(
nsINode
&
aNodeToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MakeDefinitionListItemWithTransaction
(
nsAtom
&
aTagName
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
FormatBlockContainerAsSubAction
(
nsAtom
&
aTagName
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RelativeFontChange
(
FontSize
aDir
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RelativeFontChangeOnNode
(
int32_t
aSizeChange
nsIContent
*
aNode
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RelativeFontChangeHelper
(
int32_t
aSizeChange
nsINode
*
aNode
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetInlinePropertyOnTextNode
(
Text
&
aData
int32_t
aStartOffset
int32_t
aEndOffset
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
;
nsresult
PromoteInlineRange
(
nsRange
&
aRange
)
;
nsresult
PromoteRangeIfStartsOrEndsInNamedAnchor
(
nsRange
&
aRange
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SplitStyleAboveRange
(
nsRange
*
aRange
nsAtom
*
aProperty
nsAtom
*
aAttribute
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveStyleInside
(
nsIContent
&
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
bool
aChildrenOnly
=
false
)
;
bool
IsAtFrontOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
;
bool
IsAtEndOfNode
(
nsINode
&
aNode
int32_t
aOffset
)
;
bool
IsOnlyAttribute
(
const
Element
*
aElement
nsAtom
*
aAttribute
)
;
bool
HasStyleOrIdOrClass
(
Element
*
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RemoveElementIfNoStyleOrIdOrClass
(
Element
&
aElement
)
;
bool
OurWindowHasFocus
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DoInsertHTMLWithContext
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
const
nsAString
&
aFlavor
Document
*
aSourceDoc
const
EditorDOMPoint
&
aPointToInsert
bool
aDeleteSelection
bool
aTrustedInput
bool
aClearStyle
=
true
)
;
MOZ_CAN_RUN_SCRIPT
void
SetTopAndLeft
(
Element
&
aElement
int32_t
aX
int32_t
aY
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionAfterTableEdit
(
Element
*
aTable
int32_t
aRow
int32_t
aCol
int32_t
aDirection
bool
aSelected
)
;
void
RemoveListenerAndDeleteRef
(
const
nsAString
&
aEvent
nsIDOMEventListener
*
aListener
bool
aUseCapture
ManualNACPtr
aElement
PresShell
*
aPresShell
)
;
void
DeleteRefToAnonymousNode
(
ManualNACPtr
aContent
PresShell
*
aPresShell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RefreshEditingUI
(
)
;
nsresult
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
;
nsresult
GetPositionAndDimensions
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
int32_t
&
aW
int32_t
&
aH
int32_t
&
aBorderLeft
int32_t
&
aBorderTop
int32_t
&
aMarginLeft
int32_t
&
aMarginTop
)
;
bool
IsInObservedSubtree
(
nsIContent
*
aChild
)
;
void
UpdateRootElement
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetAllResizersPosition
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ShowResizersInternal
(
Element
&
aResizedElement
)
;
nsresult
HideResizersInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RefreshResizersInternal
(
)
;
ManualNACPtr
CreateResizer
(
int16_t
aLocation
nsIContent
&
aParentContent
)
;
MOZ_CAN_RUN_SCRIPT
void
SetAnonymousElementPosition
(
int32_t
aX
int32_t
aY
Element
*
aResizer
)
;
ManualNACPtr
CreateShadow
(
nsIContent
&
aParentContent
Element
&
aOriginalObject
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetShadowPosition
(
Element
&
aShadowElement
Element
&
aElement
int32_t
aElementLeft
int32_t
aElementTop
)
;
ManualNACPtr
CreateResizingInfo
(
nsIContent
&
aParentContent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetResizingInfoPosition
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
)
;
enum
class
ResizeAt
{
eX
eY
eWidth
eHeight
}
;
int32_t
GetNewResizingIncrement
(
int32_t
aX
int32_t
aY
ResizeAt
aResizeAt
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
StartResizing
(
Element
*
aHandle
)
;
int32_t
GetNewResizingX
(
int32_t
aX
int32_t
aY
)
;
int32_t
GetNewResizingY
(
int32_t
aX
int32_t
aY
)
;
int32_t
GetNewResizingWidth
(
int32_t
aX
int32_t
aY
)
;
int32_t
GetNewResizingHeight
(
int32_t
aX
int32_t
aY
)
;
void
HideShadowAndInfo
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetFinalSize
(
int32_t
aX
int32_t
aY
)
;
void
SetResizeIncrements
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
bool
aPreserveRatio
)
;
void
HideAnonymousEditingUIs
(
)
;
void
HideAnonymousEditingUIsIfUnnecessary
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetZIndex
(
Element
&
aElement
int32_t
aZorder
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ShowGrabberInternal
(
Element
&
aElement
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RefreshGrabberInternal
(
)
;
void
HideGrabberInternal
(
)
;
bool
CreateGrabberInternal
(
nsIContent
&
aParentContent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
StartMoving
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetFinalPosition
(
int32_t
aX
int32_t
aY
)
;
void
AddPositioningOffset
(
int32_t
&
aX
int32_t
&
aY
)
;
void
SnapToGrid
(
int32_t
&
newX
int32_t
&
newY
)
;
nsresult
GrabberClicked
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
EndMoving
(
)
;
nsresult
GetTemporaryStyleForFocusedPositionedElement
(
Element
&
aElement
nsAString
&
aReturn
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ShowInlineTableEditingUIInternal
(
Element
&
aCellElement
)
;
void
HideInlineTableEditingUIInternal
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RefreshInlineTableEditingUIInternal
(
)
;
bool
IsEmptyTextNode
(
nsINode
&
aNode
)
const
;
MOZ_CAN_RUN_SCRIPT
bool
IsSimpleModifiableNode
(
nsIContent
*
aContent
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetInlinePropertyOnNodeImpl
(
nsIContent
&
aNode
nsAtom
&
aProperty
nsAtom
*
aAttribute
const
nsAString
&
aValue
)
;
typedef
enum
{
eInserted
eAppended
}
InsertedOrAppended
;
void
DoContentInserted
(
nsIContent
*
aChild
InsertedOrAppended
)
;
ManualNACPtr
CreateAnonymousElement
(
nsAtom
*
aTag
nsIContent
&
aParentContent
const
nsAString
&
aAnonClass
bool
aIsCreatedHidden
)
;
static
nsresult
SlurpBlob
(
dom
:
:
Blob
*
aBlob
nsPIDOMWindowOuter
*
aWindow
BlobReader
*
aBlobReader
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
OnModifyDocumentInternal
(
)
;
already_AddRefed
<
RangeItem
>
GetSelectedRangeItemForTopLevelEditSubAction
(
)
const
{
if
(
!
mSelectedRangeForTopLevelEditSubAction
)
{
mSelectedRangeForTopLevelEditSubAction
=
new
RangeItem
(
)
;
}
return
do_AddRef
(
mSelectedRangeForTopLevelEditSubAction
)
;
}
already_AddRefed
<
nsRange
>
GetChangedRangeForTopLevelEditSubAction
(
)
const
{
if
(
!
mChangedRangeForTopLevelEditSubAction
)
{
mChangedRangeForTopLevelEditSubAction
=
new
nsRange
(
GetDocument
(
)
)
;
}
return
do_AddRef
(
mChangedRangeForTopLevelEditSubAction
)
;
}
protected
:
RefPtr
<
TypeInState
>
mTypeInState
;
RefPtr
<
ComposerCommandsUpdater
>
mComposerCommandsUpdater
;
mutable
RefPtr
<
RangeItem
>
mSelectedRangeForTopLevelEditSubAction
;
mutable
RefPtr
<
nsRange
>
mChangedRangeForTopLevelEditSubAction
;
bool
mCRInParagraphCreatesParagraph
;
bool
mCSSAware
;
UniquePtr
<
CSSEditUtils
>
mCSSEditUtils
;
mutable
uint32_t
mSelectedCellIndex
;
nsString
mLastStyleSheetURL
;
nsString
mLastOverrideStyleSheetURL
;
nsTArray
<
nsString
>
mStyleSheetURLs
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mStyleSheets
;
bool
mIsObjectResizingEnabled
;
bool
mIsResizing
;
bool
mPreserveRatio
;
bool
mResizedObjectIsAnImage
;
bool
mIsAbsolutelyPositioningEnabled
;
bool
mResizedObjectIsAbsolutelyPositioned
;
bool
mGrabberClicked
;
bool
mIsMoving
;
bool
mSnapToGridEnabled
;
bool
mIsInlineTableEditingEnabled
;
ManualNACPtr
mTopLeftHandle
;
ManualNACPtr
mTopHandle
;
ManualNACPtr
mTopRightHandle
;
ManualNACPtr
mLeftHandle
;
ManualNACPtr
mRightHandle
;
ManualNACPtr
mBottomLeftHandle
;
ManualNACPtr
mBottomHandle
;
ManualNACPtr
mBottomRightHandle
;
RefPtr
<
Element
>
mActivatedHandle
;
ManualNACPtr
mResizingShadow
;
ManualNACPtr
mResizingInfo
;
RefPtr
<
Element
>
mResizedObject
;
int32_t
mOriginalX
;
int32_t
mOriginalY
;
int32_t
mResizedObjectX
;
int32_t
mResizedObjectY
;
int32_t
mResizedObjectWidth
;
int32_t
mResizedObjectHeight
;
int32_t
mResizedObjectMarginLeft
;
int32_t
mResizedObjectMarginTop
;
int32_t
mResizedObjectBorderLeft
;
int32_t
mResizedObjectBorderTop
;
int32_t
mXIncrementFactor
;
int32_t
mYIncrementFactor
;
int32_t
mWidthIncrementFactor
;
int32_t
mHeightIncrementFactor
;
int8_t
mInfoXIncrement
;
int8_t
mInfoYIncrement
;
int32_t
mPositionedObjectX
;
int32_t
mPositionedObjectY
;
int32_t
mPositionedObjectWidth
;
int32_t
mPositionedObjectHeight
;
int32_t
mPositionedObjectMarginLeft
;
int32_t
mPositionedObjectMarginTop
;
int32_t
mPositionedObjectBorderLeft
;
int32_t
mPositionedObjectBorderTop
;
RefPtr
<
Element
>
mAbsolutelyPositionedObject
;
ManualNACPtr
mGrabber
;
ManualNACPtr
mPositioningShadow
;
int32_t
mGridSize
;
RefPtr
<
Element
>
mInlineEditedCell
;
ManualNACPtr
mAddColumnBeforeButton
;
ManualNACPtr
mRemoveColumnButton
;
ManualNACPtr
mAddColumnAfterButton
;
ManualNACPtr
mAddRowBeforeButton
;
ManualNACPtr
mRemoveRowButton
;
ManualNACPtr
mAddRowAfterButton
;
void
AddMouseClickListener
(
Element
*
aElement
)
;
void
RemoveMouseClickListener
(
Element
*
aElement
)
;
bool
mDisabledLinkHandling
=
false
;
bool
mOldLinkHandlingEnabled
=
false
;
ParagraphSeparator
mDefaultParagraphSeparator
;
friend
class
AutoSelectionSetterAfterTableEdit
;
friend
class
AutoSetTemporaryAncestorLimiter
;
friend
class
CSSEditUtils
;
friend
class
EditorBase
;
friend
class
EmptyEditableFunctor
;
friend
class
HTMLEditRules
;
friend
class
SlurpBlobEventListener
;
friend
class
TextEditor
;
friend
class
WSRunObject
;
friend
class
WSRunScanner
;
}
;
}
mozilla
:
:
HTMLEditor
*
nsIEditor
:
:
AsHTMLEditor
(
)
{
return
static_cast
<
mozilla
:
:
EditorBase
*
>
(
this
)
-
>
mIsHTMLEditorClass
?
static_cast
<
mozilla
:
:
HTMLEditor
*
>
(
this
)
:
nullptr
;
}
const
mozilla
:
:
HTMLEditor
*
nsIEditor
:
:
AsHTMLEditor
(
)
const
{
return
static_cast
<
const
mozilla
:
:
EditorBase
*
>
(
this
)
-
>
mIsHTMLEditorClass
?
static_cast
<
const
mozilla
:
:
HTMLEditor
*
>
(
this
)
:
nullptr
;
}
#
endif
