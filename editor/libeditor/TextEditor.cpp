#
include
"
mozilla
/
TextEditor
.
h
"
#
include
<
algorithm
>
#
include
"
EditAggregateTransaction
.
h
"
#
include
"
InternetCiter
.
h
"
#
include
"
gfxFontUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextServicesDocument
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAbsorbingTransaction
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
class
nsIOutputStream
;
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
TextEditor
:
:
TextEditor
(
)
:
mMaxTextLength
(
-
1
)
#
ifdef
XP_WIN
mCaretStyle
(
1
)
#
else
mCaretStyle
(
0
)
#
endif
mUnmaskedStart
(
UINT32_MAX
)
mUnmaskedLength
(
0
)
mIsMaskingPassword
(
true
)
{
static_assert
(
sizeof
(
TextEditor
)
<
=
512
"
TextEditor
instance
should
be
allocatable
in
the
quantum
class
bins
"
)
;
GetDefaultEditorPrefs
(
mNewlineHandling
mCaretStyle
)
;
}
TextEditor
:
:
~
TextEditor
(
)
{
RemoveEventListeners
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
TextEditor
EditorBase
)
if
(
tmp
-
>
mMaskTimer
)
{
tmp
-
>
mMaskTimer
-
>
Cancel
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCachedDocumentEncoder
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMaskTimer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
TextEditor
EditorBase
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCachedDocumentEncoder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMaskTimer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
TextEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
TextEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TextEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_END_INHERITING
(
EditorBase
)
nsresult
TextEditor
:
:
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
{
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
MOZ_ASSERT
(
!
mInitSucceeded
"
TextEditor
:
:
Init
(
)
called
again
without
calling
PreDestroy
(
)
?
"
)
;
nsresult
rv
=
EditorBase
:
:
Init
(
aDoc
aRoot
aSelCon
aFlags
aInitialValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
mInitSucceeded
"
TextEditor
:
:
Init
(
)
shouldn
'
t
be
nested
"
)
;
mInitSucceeded
=
true
;
rv
=
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
mInitSucceeded
=
false
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
ClearUndoRedo
(
)
;
EnableUndoRedo
(
)
;
return
NS_OK
;
}
static
int32_t
sNewlineHandlingPref
=
-
1
sCaretStylePref
=
-
1
;
static
void
EditorPrefsChangedCallback
(
const
char
*
aPrefName
void
*
)
{
if
(
!
nsCRT
:
:
strcmp
(
aPrefName
"
editor
.
singleLine
.
pasteNewlines
"
)
)
{
sNewlineHandlingPref
=
Preferences
:
:
GetInt
(
"
editor
.
singleLine
.
pasteNewlines
"
nsIEditor
:
:
eNewlinesPasteToFirst
)
;
if
(
NS_WARN_IF
(
sNewlineHandlingPref
<
nsIEditor
:
:
eNewlinesPasteIntact
|
|
sNewlineHandlingPref
>
nsIEditor
:
:
eNewlinesStripSurroundingWhitespace
)
)
{
sNewlineHandlingPref
=
nsIEditor
:
:
eNewlinesPasteToFirst
;
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aPrefName
"
layout
.
selection
.
caret_style
"
)
)
{
sCaretStylePref
=
Preferences
:
:
GetInt
(
"
layout
.
selection
.
caret_style
"
#
ifdef
XP_WIN
1
)
;
if
(
!
sCaretStylePref
)
{
sCaretStylePref
=
1
;
}
#
else
0
)
;
#
endif
}
}
void
TextEditor
:
:
GetDefaultEditorPrefs
(
int32_t
&
aNewlineHandling
int32_t
&
aCaretStyle
)
{
if
(
sNewlineHandlingPref
=
=
-
1
)
{
Preferences
:
:
RegisterCallbackAndCall
(
EditorPrefsChangedCallback
"
editor
.
singleLine
.
pasteNewlines
"
)
;
Preferences
:
:
RegisterCallbackAndCall
(
EditorPrefsChangedCallback
"
layout
.
selection
.
caret_style
"
)
;
}
aNewlineHandling
=
sNewlineHandlingPref
;
aCaretStyle
=
sCaretStylePref
;
}
NS_IMETHODIMP
TextEditor
:
:
SetDocumentCharacterSet
(
const
nsACString
&
characterSet
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetCharacterSet
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
EditorBase
:
:
SetDocumentCharacterSet
(
characterSet
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetDocumentCharacterSet
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
UpdateMetaCharset
(
*
document
characterSet
)
)
{
return
NS_OK
;
}
RefPtr
<
nsContentList
>
headElementList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
head
"
)
)
;
if
(
NS_WARN_IF
(
!
headElementList
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
primaryHeadElement
=
headElementList
-
>
Item
(
0
)
;
if
(
NS_WARN_IF
(
!
primaryHeadElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
metaElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
meta
EditorDOMPoint
(
primaryHeadElement
0
)
)
;
if
(
!
metaElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
meta
)
failed
but
"
"
ignored
"
)
;
return
NS_OK
;
}
if
(
characterSet
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
NS_OK
;
rvIgnored
=
metaElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
httpEquiv
NS_LITERAL_STRING
(
"
Content
-
Type
"
)
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
httpEquiv
Content
-
Type
)
"
"
failed
but
ignored
"
)
;
rvIgnored
=
metaElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
content
NS_LITERAL_STRING
(
"
text
/
html
;
charset
=
"
)
+
NS_ConvertASCIItoUTF16
(
characterSet
)
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
content
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
bool
TextEditor
:
:
UpdateMetaCharset
(
Document
&
aDocument
const
nsACString
&
aCharacterSet
)
{
RefPtr
<
nsContentList
>
metaElementList
=
aDocument
.
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
meta
"
)
)
;
if
(
NS_WARN_IF
(
!
metaElementList
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
metaElementList
-
>
Length
(
true
)
;
+
+
i
)
{
RefPtr
<
Element
>
metaElement
=
metaElementList
-
>
Item
(
i
)
-
>
AsElement
(
)
;
MOZ_ASSERT
(
metaElement
)
;
nsAutoString
currentValue
;
metaElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
httpEquiv
currentValue
)
;
if
(
!
FindInReadable
(
NS_LITERAL_STRING
(
"
content
-
type
"
)
currentValue
nsCaseInsensitiveStringComparator
(
)
)
)
{
continue
;
}
metaElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
content
currentValue
)
;
NS_NAMED_LITERAL_STRING
(
charsetEquals
"
charset
=
"
)
;
nsAString
:
:
const_iterator
originalStart
start
end
;
originalStart
=
currentValue
.
BeginReading
(
start
)
;
currentValue
.
EndReading
(
end
)
;
if
(
!
FindInReadable
(
charsetEquals
start
end
nsCaseInsensitiveStringComparator
(
)
)
)
{
continue
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
metaElement
*
nsGkAtoms
:
:
content
Substring
(
originalStart
start
)
+
charsetEquals
+
NS_ConvertASCIItoUTF16
(
aCharacterSet
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
content
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
return
false
;
}
nsresult
TextEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
IsReadonly
(
)
)
{
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_BACK
:
{
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
DeleteSelectionAsAction
(
nsIEditor
:
:
ePrevious
nsIEditor
:
:
eStrip
)
;
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
case
NS_VK_DELETE
:
{
if
(
aKeyboardEvent
-
>
IsShift
(
)
|
|
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteSelectionAsAction
(
nsIEditor
:
:
eNext
nsIEditor
:
:
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
DeleteSelectionAsAction
(
)
failed
but
ignored
"
)
;
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
case
NS_VK_TAB
:
{
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
|
|
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsresult
rv
=
OnInputText
(
NS_LITERAL_STRING
(
"
\
t
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
OnInputText
(
\
\
t
)
failed
"
)
;
return
rv
;
}
case
NS_VK_RETURN
:
{
if
(
!
aKeyboardEvent
-
>
IsInputtingLineBreak
(
)
)
{
return
NS_OK
;
}
if
(
!
IsSingleLineEditor
(
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
}
nsresult
rv
=
InsertLineBreakAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertLineBreakAsAction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
aKeyboardEvent
-
>
IsInputtingText
(
)
)
{
return
NS_OK
;
}
char16_t
charCode
=
static_cast
<
char16_t
>
(
aKeyboardEvent
-
>
mCharCode
)
=
=
nsCRT
:
:
CR
?
nsCRT
:
:
LF
:
static_cast
<
char16_t
>
(
aKeyboardEvent
-
>
mCharCode
)
;
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
charCode
)
;
nsresult
rv
=
OnInputText
(
str
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
OnInputText
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
OnInputText
(
const
nsAString
&
aStringToInsert
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertText
)
;
MOZ_ASSERT
(
!
aStringToInsert
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aStringToInsert
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
)
;
rv
=
InsertTextAsSubAction
(
aStringToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLineBreak
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
)
;
rv
=
InsertLineBreakAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertLineBreakAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
static
bool
UseFrameSelectionToExtendSelection
(
nsIEditor
:
:
EDirection
aAction
const
Selection
&
aSelection
)
{
bool
bCollapsed
=
aSelection
.
IsCollapsed
(
)
;
return
(
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
(
aAction
=
=
nsIEditor
:
:
eNext
&
&
bCollapsed
)
|
|
(
aAction
=
=
nsIEditor
:
:
ePrevious
&
&
bCollapsed
)
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
;
}
nsresult
TextEditor
:
:
ExtendSelectionForDelete
(
nsIEditor
:
:
EDirection
*
aAction
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
UseFrameSelectionToExtendSelection
(
*
aAction
*
SelectionRefPtr
(
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISelectionController
>
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
*
aAction
)
{
case
eNextWord
:
{
nsresult
rv
=
selectionController
-
>
WordExtendForDelete
(
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
WordExtendForDelete
(
true
)
failed
"
)
;
*
aAction
=
eNone
;
return
rv
;
}
case
ePreviousWord
:
{
nsresult
rv
=
selectionController
-
>
WordExtendForDelete
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
WordExtendForDelete
(
false
)
failed
"
)
;
*
aAction
=
eNone
;
return
rv
;
}
case
eNext
:
{
nsresult
rv
=
selectionController
-
>
CharacterExtendForDelete
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
CharacterExtendForDelete
(
)
failed
"
)
;
return
rv
;
}
case
ePrevious
:
{
EditorRawDOMPoint
atStartOfSelection
=
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
insertionPoint
=
FindBetterInsertionPoint
(
atStartOfSelection
)
;
if
(
!
insertionPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
FindBetterInsertionPoint
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
insertionPoint
.
IsInTextNode
(
)
)
{
const
nsTextFragment
*
data
=
&
insertionPoint
.
GetContainerAsText
(
)
-
>
TextFragment
(
)
;
uint32_t
offset
=
insertionPoint
.
Offset
(
)
;
if
(
(
offset
>
1
&
&
data
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
offset
-
1
)
)
|
|
(
offset
>
0
&
&
gfxFontUtils
:
:
IsVarSelector
(
data
-
>
CharAt
(
offset
-
1
)
)
)
)
{
nsresult
rv
=
selectionController
-
>
CharacterExtendForBackspace
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
CharacterExtendForBackspace
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
case
eToBeginningOfLine
:
{
nsresult
rv
=
selectionController
-
>
IntraLineMove
(
false
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
IntraLineMove
(
false
true
)
failed
"
)
;
*
aAction
=
eNone
;
return
rv
;
}
case
eToEndOfLine
:
{
nsresult
rv
=
selectionController
-
>
IntraLineMove
(
true
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
IntraLineMove
(
true
true
)
failed
"
)
;
*
aAction
=
eNext
;
return
rv
;
}
default
:
return
NS_OK
;
}
}
NS_IMETHODIMP
TextEditor
:
:
DeleteSelection
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
{
nsresult
rv
=
DeleteSelectionAsAction
(
aAction
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
DeleteSelectionAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
DeleteSelectionAsAction
(
EDirection
aDirection
EStripWrappers
aStripWrappers
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
NS_ASSERTION
(
!
mPlaceholderBatch
"
Should
be
called
only
when
this
is
the
only
edit
action
of
the
"
"
operation
"
"
unless
mutation
event
listener
nests
some
operations
"
)
;
EditAction
editAction
=
EditAction
:
:
eDeleteSelection
;
switch
(
aDirection
)
{
case
nsIEditor
:
:
ePrevious
:
editAction
=
EditAction
:
:
eDeleteBackward
;
break
;
case
nsIEditor
:
:
eNext
:
editAction
=
EditAction
:
:
eDeleteForward
;
break
;
case
nsIEditor
:
:
ePreviousWord
:
editAction
=
EditAction
:
:
eDeleteWordBackward
;
break
;
case
nsIEditor
:
:
eNextWord
:
editAction
=
EditAction
:
:
eDeleteWordForward
;
break
;
case
nsIEditor
:
:
eToBeginningOfLine
:
editAction
=
EditAction
:
:
eDeleteToBeginningOfSoftLine
;
break
;
case
nsIEditor
:
:
eToEndOfLine
:
editAction
=
EditAction
:
:
eDeleteToEndOfSoftLine
;
break
;
}
AutoEditActionDataSetter
editActionData
(
*
this
editAction
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
switch
(
aDirection
)
{
case
eNextWord
:
case
ePreviousWord
:
case
eToBeginningOfLine
:
case
eToEndOfLine
:
{
if
(
mCaretStyle
!
=
1
)
{
aDirection
=
eNone
;
break
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
CollapseToStart
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
CollapseToStart
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
error
.
StealNSResult
(
)
)
;
}
break
;
}
default
:
break
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
switch
(
editAction
)
{
case
EditAction
:
:
eDeleteWordBackward
:
case
EditAction
:
:
eDeleteToBeginningOfSoftLine
:
editActionData
.
UpdateEditAction
(
EditAction
:
:
eDeleteBackward
)
;
break
;
case
EditAction
:
:
eDeleteWordForward
:
case
EditAction
:
:
eDeleteToEndOfSoftLine
:
editActionData
.
UpdateEditAction
(
EditAction
:
:
eDeleteForward
)
;
break
;
default
:
break
;
}
}
if
(
UseFrameSelectionToExtendSelection
(
aDirection
*
SelectionRefPtr
(
)
)
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
DeleteTxnName
)
;
rv
=
DeleteSelectionAsSubAction
(
aDirection
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
DeleteSelectionAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
DeleteSelectionAsSubAction
(
EDirection
aDirectionAndAmount
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteSelectedContent
aDirectionAndAmount
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
HandleDeleteSelection
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
HandleDeleteSelection
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
EditorDOMPoint
atNewStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atNewStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atNewStartOfSelection
.
IsInTextNode
(
)
&
&
!
atNewStartOfSelection
.
GetContainer
(
)
-
>
Length
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
atNewStartOfSelection
.
ContainerAsText
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
)
{
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
nsresult
TextEditor
:
:
DeleteSelectionWithTransaction
(
EDirection
aDirection
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
RefPtr
<
EditAggregateTransaction
>
deleteSelectionTransaction
;
nsCOMPtr
<
nsINode
>
deleteNode
;
int32_t
deleteCharOffset
=
0
deleteCharLength
=
0
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
|
|
aDirection
!
=
eNone
)
{
deleteSelectionTransaction
=
CreateTxnForDeleteSelection
(
aDirection
getter_AddRefs
(
deleteNode
)
&
deleteCharOffset
&
deleteCharLength
)
;
if
(
!
deleteSelectionTransaction
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateTxnForDeleteSelection
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
CharacterData
>
deleteCharData
=
CharacterData
:
:
FromNodeOrNull
(
deleteNode
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteSelectedContent
aDirection
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
AsHTMLEditor
(
)
)
{
if
(
!
deleteNode
)
{
TopLevelEditSubActionDataRef
(
)
.
WillDeleteRange
(
*
this
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
}
else
if
(
!
deleteCharData
)
{
MOZ_ASSERT
(
deleteNode
-
>
IsContent
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
WillDeleteContent
(
*
this
*
deleteNode
-
>
AsContent
(
)
)
;
}
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
if
(
!
deleteNode
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
WillDeleteSelection
(
SelectionRefPtr
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
WillDeleteSelection
(
)
failed
but
ignored
"
)
;
}
}
else
if
(
deleteCharData
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
WillDeleteText
(
deleteCharData
deleteCharOffset
1
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
WillDeleteText
(
)
failed
but
ignored
"
)
;
}
}
}
nsresult
rv
=
DoTransactionInternal
(
deleteSelectionTransaction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
if
(
AsHTMLEditor
(
)
&
&
deleteCharData
)
{
MOZ_ASSERT
(
deleteNode
)
;
TopLevelEditSubActionDataRef
(
)
.
DidDeleteText
(
*
this
EditorRawDOMPoint
(
deleteNode
)
)
;
}
if
(
mTextServicesDocument
&
&
NS_SUCCEEDED
(
rv
)
&
&
deleteNode
&
&
!
deleteCharData
)
{
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
mTextServicesDocument
;
textServicesDocument
-
>
DidDeleteNode
(
deleteNode
)
;
}
AutoActionListenerArray
listeners
(
mActionListeners
)
;
if
(
!
deleteNode
)
{
for
(
auto
&
listener
:
mActionListeners
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidDeleteSelection
(
SelectionRefPtr
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidDeleteSelection
(
)
failed
but
ignored
"
)
;
}
}
else
if
(
deleteCharData
)
{
for
(
auto
&
listener
:
mActionListeners
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidDeleteText
(
deleteCharData
deleteCharOffset
1
rv
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidDeleteText
(
)
failed
but
ignored
"
)
;
}
}
else
{
for
(
auto
&
listener
:
mActionListeners
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidDeleteNode
(
deleteNode
rv
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidDeleteNode
(
)
failed
but
ignored
"
)
;
}
}
return
rv
;
}
already_AddRefed
<
Element
>
TextEditor
:
:
DeleteSelectionAndCreateElement
(
nsAtom
&
aTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
failed
"
)
;
return
nullptr
;
}
EditorDOMPoint
pointToInsert
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newElement
=
CreateNodeWithTransaction
(
aTag
pointToInsert
)
;
if
(
!
newElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
EditorRawDOMPoint
afterNewElement
(
EditorRawDOMPoint
:
:
After
(
newElement
)
)
;
MOZ_ASSERT
(
afterNewElement
.
IsSetAndValid
(
)
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterNewElement
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
nullptr
;
}
return
newElement
.
forget
(
)
;
}
nsresult
TextEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
DeleteSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
&
&
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
"
Selection
not
collapsed
after
delete
"
)
;
}
EditorDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
|
|
!
atAnchor
.
IsInDataNode
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
atAnchor
.
GetContainerParent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atAnchor
.
IsStartOfContainer
(
)
)
{
EditorRawDOMPoint
atAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchorContainer
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atAnchorContainer
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
atAnchor
.
IsEndOfContainer
(
)
)
{
EditorRawDOMPoint
afterAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
afterAnchorContainer
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterAnchorContainer
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atAnchor
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atRightNode
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atRightNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atRightNode
.
IsSetAndValid
(
)
)
;
SelectionRefPtr
(
)
-
>
Collapse
(
atRightNode
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
TextEditor
:
:
SetTextAsAction
(
const
nsAString
&
aString
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aString
.
FindChar
(
nsCRT
:
:
CR
)
=
=
kNotFound
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetText
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
rv
=
SetTextAsSubAction
(
aString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetTextAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
ReplaceTextAsAction
(
const
nsAString
&
aString
nsRange
*
aReplaceRange
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aString
.
FindChar
(
nsCRT
:
:
CR
)
=
=
kNotFound
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eReplaceText
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
AsHTMLEditor
(
)
)
{
editActionData
.
SetData
(
aString
)
;
}
else
{
editActionData
.
InitializeDataTransfer
(
aString
)
;
RefPtr
<
StaticRange
>
targetRange
;
if
(
aReplaceRange
)
{
targetRange
=
StaticRange
:
:
Create
(
aReplaceRange
-
>
GetStartContainer
(
)
aReplaceRange
-
>
StartOffset
(
)
aReplaceRange
-
>
GetEndContainer
(
)
aReplaceRange
-
>
EndOffset
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
"
StaticRange
:
:
Create
(
)
failed
"
)
;
}
else
{
Element
*
editingHost
=
AsHTMLEditor
(
)
-
>
GetActiveEditingHost
(
)
;
NS_WARNING_ASSERTION
(
editingHost
"
No
active
editing
host
no
target
ranges
"
)
;
if
(
editingHost
)
{
targetRange
=
StaticRange
:
:
Create
(
editingHost
0
editingHost
editingHost
-
>
Length
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
"
StaticRange
:
:
Create
(
)
failed
"
)
;
}
}
if
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
)
{
editActionData
.
AppendTargetRange
(
*
targetRange
)
;
}
}
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
aReplaceRange
)
{
nsresult
rv
=
SetTextAsSubAction
(
aString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetTextAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
aString
.
IsEmpty
(
)
&
&
aReplaceRange
-
>
Collapsed
(
)
)
{
NS_WARNING
(
"
Setting
value
was
empty
and
replaced
range
was
empty
"
)
;
return
NS_OK
;
}
AutoUpdateViewBatch
preventSelectionChangeEvent
(
*
this
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
RemoveAllRanges
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
aReplaceRange
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
rv
=
ReplaceSelectionAsSubAction
(
aString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
ReplaceSelectionAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
SetTextAsSubAction
(
const
nsAString
&
aString
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
IsPlaintextEditor
(
)
&
&
!
IsIMEComposing
(
)
&
&
!
IsUndoRedoEnabled
(
)
&
&
GetEditAction
(
)
!
=
EditAction
:
:
eReplaceText
&
&
mMaxTextLength
<
0
)
{
EditActionResult
result
=
SetTextWithoutTransaction
(
aString
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
|
|
result
.
Handled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
SetTextWithoutTransaction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
}
{
AutoUpdateViewBatch
preventSelectionChangeEvent
(
*
this
)
;
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
IsEmpty
(
)
)
{
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
rootElement
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
}
else
{
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
rootElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
but
ignored
"
)
;
rv
=
error
.
StealNSResult
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
ReplaceSelectionAsSubAction
(
aString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
ReplaceSelectionAsSubAction
(
)
failed
but
ignored
"
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
nsresult
TextEditor
:
:
ReplaceSelectionAsSubAction
(
const
nsAString
&
aString
)
{
if
(
aString
.
IsEmpty
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
InsertTextAsSubAction
(
aString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
return
rv
;
}
bool
TextEditor
:
:
EnsureComposition
(
WidgetCompositionEvent
&
aCompositionEvent
)
{
if
(
mComposition
)
{
return
true
;
}
mComposition
=
IMEStateManager
:
:
GetTextCompositionFor
(
&
aCompositionEvent
)
;
if
(
!
mComposition
)
{
return
false
;
}
mComposition
-
>
StartHandlingComposition
(
this
)
;
return
true
;
}
nsresult
TextEditor
:
:
OnCompositionStart
(
WidgetCompositionEvent
&
aCompositionStartEvent
)
{
if
(
mComposition
)
{
NS_WARNING
(
"
There
was
a
composition
at
receiving
compositionstart
event
"
)
;
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eStartComposition
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EnsureComposition
(
aCompositionStartEvent
)
;
NS_WARNING_ASSERTION
(
mComposition
"
Failed
to
get
TextComposition
instance
?
"
)
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
OnCompositionChange
(
WidgetCompositionEvent
&
aCompositionChangeEvent
)
{
MOZ_ASSERT
(
aCompositionChangeEvent
.
mMessage
=
=
eCompositionChange
"
The
event
should
be
eCompositionChange
"
)
;
if
(
!
mComposition
)
{
NS_WARNING
(
"
There
is
no
composition
but
receiving
compositionchange
event
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eUpdateComposition
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aCompositionChangeEvent
.
mData
.
IsEmpty
(
)
&
&
mComposition
-
>
String
(
)
.
IsEmpty
(
)
&
&
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
editActionData
.
UpdateEditAction
(
EditAction
:
:
eDeleteByComposition
)
;
}
if
(
ToInputType
(
editActionData
.
GetEditAction
(
)
)
!
=
EditorInputType
:
:
eDeleteByComposition
)
{
MOZ_ASSERT
(
ToInputType
(
editActionData
.
GetEditAction
(
)
)
=
=
EditorInputType
:
:
eInsertCompositionText
)
;
MOZ_ASSERT
(
!
aCompositionChangeEvent
.
mData
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aCompositionChangeEvent
.
mData
)
;
}
if
(
AsHTMLEditor
(
)
&
&
mComposition
-
>
GetContainerTextNode
(
)
)
{
RefPtr
<
StaticRange
>
targetRange
=
StaticRange
:
:
Create
(
mComposition
-
>
GetContainerTextNode
(
)
mComposition
-
>
XPOffsetInTextNode
(
)
mComposition
-
>
GetContainerTextNode
(
)
mComposition
-
>
XPEndOffsetInTextNode
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
"
StaticRange
:
:
Create
(
)
failed
"
)
;
if
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
)
{
editActionData
.
AppendTargetRange
(
*
targetRange
)
;
}
}
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
rv
!
=
NS_ERROR_EDITOR_ACTION_CANCELED
&
&
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
EnsureComposition
(
aCompositionChangeEvent
)
)
{
NS_WARNING
(
"
TextEditor
:
:
EnsureComposition
(
)
failed
"
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
GetPresShell
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
!
mPlaceholderBatch
"
UpdateIMEComposition
(
)
must
be
called
without
place
holder
batch
"
)
;
TextComposition
:
:
CompositionChangeEventHandlingMarker
compositionChangeEventHandlingMarker
(
mComposition
&
aCompositionChangeEvent
)
;
RefPtr
<
nsCaret
>
caret
=
GetCaret
(
)
;
{
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
IMETxnName
)
;
MOZ_ASSERT
(
mIsInEditSubAction
"
AutoPlaceholderBatch
should
'
ve
notified
the
observes
of
before
-
edit
"
)
;
nsString
data
(
aCompositionChangeEvent
.
mData
)
;
if
(
!
AsTextEditor
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
data
)
;
}
rv
=
InsertTextAsSubAction
(
data
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
if
(
caret
)
{
caret
-
>
SetSelection
(
SelectionRefPtr
(
)
)
;
}
}
if
(
!
aCompositionChangeEvent
.
IsFollowedByCompositionEnd
(
)
)
{
NotifyEditorObservers
(
eNotifyEditorObserversOfEnd
)
;
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
void
TextEditor
:
:
OnCompositionEnd
(
WidgetCompositionEvent
&
aCompositionEndEvent
)
{
if
(
!
mComposition
)
{
NS_WARNING
(
"
There
is
no
composition
but
receiving
compositionend
event
"
)
;
return
;
}
EditAction
editAction
=
aCompositionEndEvent
.
mData
.
IsEmpty
(
)
?
EditAction
:
:
eCancelComposition
:
EditAction
:
:
eCommitComposition
;
AutoEditActionDataSetter
editActionData
(
*
this
editAction
)
;
if
(
ToInputType
(
editAction
)
!
=
EditorInputType
:
:
eDeleteCompositionText
)
{
MOZ_ASSERT
(
ToInputType
(
editAction
)
=
=
EditorInputType
:
:
eInsertCompositionText
|
|
ToInputType
(
editAction
)
=
=
EditorInputType
:
:
eInsertFromComposition
)
;
MOZ_ASSERT
(
!
aCompositionEndEvent
.
mData
.
IsVoid
(
)
)
;
editActionData
.
SetData
(
aCompositionEndEvent
.
mData
)
;
}
if
(
mTransactionManager
)
{
nsCOMPtr
<
nsITransaction
>
txn
=
mTransactionManager
-
>
PeekUndoStack
(
)
;
nsCOMPtr
<
nsIAbsorbingTransaction
>
plcTxn
=
do_QueryInterface
(
txn
)
;
if
(
plcTxn
)
{
plcTxn
-
>
Commit
(
)
;
}
}
DebugOnly
<
nsresult
>
rvIgnored
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
MOZ_ASSERT
(
rvIgnored
!
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
Why
beforeinput
event
was
canceled
in
this
case
?
"
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rvIgnored
)
"
MaybeDispatchBeforeInputEvent
(
)
should
just
mark
the
instance
as
"
"
handled
it
"
)
;
HideCaret
(
false
)
;
mComposition
-
>
EndHandlingComposition
(
this
)
;
mComposition
=
nullptr
;
NotifyEditorObservers
(
eNotifyEditorObserversOfEnd
)
;
}
already_AddRefed
<
Element
>
TextEditor
:
:
GetInputEventTargetElement
(
)
const
{
nsCOMPtr
<
Element
>
target
=
do_QueryInterface
(
mEventTarget
)
;
return
target
.
forget
(
)
;
}
bool
TextEditor
:
:
IsEmpty
(
)
const
{
if
(
mPaddingBRElementForEmptyEditor
)
{
return
true
;
}
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
!
anonymousDivElement
)
{
return
true
;
}
return
!
anonymousDivElement
-
>
GetFirstChild
(
)
|
|
!
anonymousDivElement
-
>
GetFirstChild
(
)
-
>
IsText
(
)
|
|
!
anonymousDivElement
-
>
GetFirstChild
(
)
-
>
Length
(
)
;
}
NS_IMETHODIMP
TextEditor
:
:
GetDocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
{
MOZ_ASSERT
(
aDocumentIsEmpty
)
;
*
aDocumentIsEmpty
=
IsEmpty
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextEditor
:
:
GetTextLength
(
int32_t
*
aCount
)
{
MOZ_ASSERT
(
aCount
)
;
*
aCount
=
0
;
if
(
IsEmpty
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
totalLength
=
0
;
PostContentIterator
postOrderIter
;
DebugOnly
<
nsresult
>
rvIgnored
=
postOrderIter
.
Init
(
rootElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
PostContentIterator
:
:
Init
(
)
failed
but
ignored
"
)
;
EditorType
editorType
=
GetEditorType
(
)
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
nsINode
*
currentNode
=
postOrderIter
.
GetCurrentNode
(
)
;
if
(
currentNode
&
&
currentNode
-
>
IsText
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
currentNode
-
>
AsText
(
)
editorType
)
)
{
totalLength
+
=
currentNode
-
>
Length
(
)
;
}
}
*
aCount
=
totalLength
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
UndoAsAction
(
uint32_t
aCount
nsIPrincipal
*
aPrincipal
)
{
if
(
aCount
=
=
0
|
|
IsReadonly
(
)
)
{
return
NS_OK
;
}
if
(
!
CanUndo
(
)
)
{
return
NS_OK
;
}
if
(
GetComposition
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eUndo
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoUpdateViewBatch
preventSelectionChangeEvent
(
*
this
)
;
NotifyEditorObservers
(
eNotifyEditorObserversOfBefore
)
;
if
(
NS_WARN_IF
(
!
CanUndo
(
)
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
NS_OK
;
{
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eUndo
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
"
"
failed
but
ignored
"
)
;
RefPtr
<
TransactionManager
>
transactionManager
(
mTransactionManager
)
;
for
(
uint32_t
i
=
0
;
i
<
aCount
;
+
+
i
)
{
if
(
NS_FAILED
(
transactionManager
-
>
Undo
(
)
)
)
{
NS_WARNING
(
"
TransactionManager
:
:
Undo
(
)
failed
"
)
;
break
;
}
DoAfterUndoTransaction
(
)
;
}
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
NS_WARNING
(
"
Failed
to
handle
padding
BR
Element
due
to
no
root
element
"
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
nsIContent
*
leftMostChild
=
GetLeftmostChild
(
mRootElement
)
;
if
(
leftMostChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
leftMostChild
)
)
{
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
leftMostChild
)
;
}
else
{
mPaddingBRElementForEmptyEditor
=
nullptr
;
}
}
}
NotifyEditorObservers
(
eNotifyEditorObserversOfEnd
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
RedoAsAction
(
uint32_t
aCount
nsIPrincipal
*
aPrincipal
)
{
if
(
aCount
=
=
0
|
|
IsReadonly
(
)
)
{
return
NS_OK
;
}
if
(
!
CanRedo
(
)
)
{
return
NS_OK
;
}
if
(
GetComposition
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRedo
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoUpdateViewBatch
preventSelectionChangeEvent
(
*
this
)
;
NotifyEditorObservers
(
eNotifyEditorObserversOfBefore
)
;
if
(
NS_WARN_IF
(
!
CanRedo
(
)
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
NS_OK
;
{
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRedo
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
"
"
failed
but
ignored
"
)
;
RefPtr
<
TransactionManager
>
transactionManager
(
mTransactionManager
)
;
for
(
uint32_t
i
=
0
;
i
<
aCount
;
+
+
i
)
{
if
(
NS_FAILED
(
transactionManager
-
>
Redo
(
)
)
)
{
NS_WARNING
(
"
TransactionManager
:
:
Redo
(
)
failed
"
)
;
break
;
}
DoAfterRedoTransaction
(
)
;
}
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
NS_WARNING
(
"
Failed
to
handle
padding
BR
element
due
to
no
root
element
"
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
nsCOMPtr
<
nsIHTMLCollection
>
nodeList
=
mRootElement
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
br
"
)
)
;
MOZ_ASSERT
(
nodeList
)
;
Element
*
brElement
=
nodeList
-
>
Length
(
)
=
=
1
?
nodeList
-
>
Item
(
0
)
:
nullptr
;
if
(
brElement
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
brElement
)
)
{
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
brElement
)
;
}
else
{
mPaddingBRElementForEmptyEditor
=
nullptr
;
}
}
}
NotifyEditorObservers
(
eNotifyEditorObserversOfEnd
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
bool
TextEditor
:
:
IsCopyToClipboardAllowedInternal
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
false
;
}
if
(
!
IsSingleLineEditor
(
)
|
|
!
IsPasswordEditor
(
)
)
{
return
true
;
}
if
(
IsAllMasked
(
)
|
|
IsMaskingPassword
(
)
|
|
mUnmaskedLength
=
=
0
)
{
return
false
;
}
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
>
1
)
{
return
false
;
}
uint32_t
selectionStart
=
0
selectionEnd
=
0
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
mRootElement
selectionStart
selectionEnd
)
;
return
mUnmaskedStart
<
=
selectionStart
&
&
UnmaskedEnd
(
)
>
=
selectionEnd
;
}
bool
TextEditor
:
:
FireClipboardEvent
(
EventMessage
aEventMessage
int32_t
aSelectionType
bool
*
aActionTaken
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
aEventMessage
=
=
ePaste
)
{
CommitComposition
(
)
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
false
;
}
if
(
!
nsCopySupport
:
:
FireClipboardEvent
(
aEventMessage
aSelectionType
presShell
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
aActionTaken
)
)
{
return
false
;
}
return
!
mDidPreDestroy
;
}
nsresult
TextEditor
:
:
CutAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eCut
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
actionTaken
=
false
;
if
(
!
FireClipboardEvent
(
eCut
nsIClipboard
:
:
kGlobalClipboard
&
actionTaken
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
actionTaken
?
NS_OK
:
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
}
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
DeleteTxnName
)
;
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
DeleteSelectionAsSubAction
(
)
failed
but
ignored
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
bool
TextEditor
:
:
IsCutCommandEnabled
(
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
document
&
&
document
-
>
IsHTMLOrXHTML
(
)
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
document
)
)
{
return
true
;
}
return
IsModifiable
(
)
&
&
IsCopyToClipboardAllowedInternal
(
)
;
}
NS_IMETHODIMP
TextEditor
:
:
Copy
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eCopy
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
bool
actionTaken
=
false
;
FireClipboardEvent
(
eCopy
nsIClipboard
:
:
kGlobalClipboard
&
actionTaken
)
;
return
EditorBase
:
:
ToGenericNSResult
(
actionTaken
?
NS_OK
:
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
}
bool
TextEditor
:
:
IsCopyCommandEnabled
(
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
document
&
&
document
-
>
IsHTMLOrXHTML
(
)
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
document
)
)
{
return
true
;
}
return
IsCopyToClipboardAllowedInternal
(
)
;
}
bool
TextEditor
:
:
CanDeleteSelection
(
)
const
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
false
;
}
return
IsModifiable
(
)
&
&
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
}
already_AddRefed
<
nsIDocumentEncoder
>
TextEditor
:
:
GetAndInitDocEncoder
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
const
nsACString
&
aCharset
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIDocumentEncoder
>
docEncoder
;
if
(
!
mCachedDocumentEncoder
|
|
!
mCachedDocumentEncoderType
.
Equals
(
aFormatType
)
)
{
nsAutoCString
formatType
;
LossyAppendUTF16toASCII
(
aFormatType
formatType
)
;
docEncoder
=
do_createDocumentEncoder
(
PromiseFlatCString
(
formatType
)
.
get
(
)
)
;
if
(
NS_WARN_IF
(
!
docEncoder
)
)
{
return
nullptr
;
}
mCachedDocumentEncoder
=
docEncoder
;
mCachedDocumentEncoderType
=
aFormatType
;
}
else
{
docEncoder
=
mCachedDocumentEncoder
;
}
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
Need
a
document
"
)
;
nsresult
rv
=
docEncoder
-
>
NativeInit
(
doc
aFormatType
aDocumentEncoderFlags
|
nsIDocumentEncoder
:
:
RequiresReinitAfterOutput
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsIDocumentEncoder
:
:
NativeInit
(
)
failed
"
)
;
return
nullptr
;
}
if
(
!
aCharset
.
IsEmpty
(
)
&
&
!
aCharset
.
EqualsLiteral
(
"
null
"
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
docEncoder
-
>
SetCharset
(
aCharset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIDocumentEncoder
:
:
SetCharset
(
)
failed
but
ignored
"
)
;
}
const
int32_t
wrapWidth
=
std
:
:
max
(
WrapWidth
(
)
0
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
docEncoder
-
>
SetWrapColumn
(
wrapWidth
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIDocumentEncoder
:
:
SetWrapColumn
(
)
failed
but
ignored
"
)
;
if
(
aDocumentEncoderFlags
&
nsIDocumentEncoder
:
:
OutputSelectionOnly
)
{
if
(
NS_FAILED
(
docEncoder
-
>
SetSelection
(
SelectionRefPtr
(
)
)
)
)
{
NS_WARNING
(
"
nsIDocumentEncoder
:
:
SetSelection
(
)
failed
"
)
;
return
nullptr
;
}
}
else
{
dom
:
:
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
nullptr
;
}
if
(
!
rootElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
if
(
NS_FAILED
(
docEncoder
-
>
SetContainerNode
(
rootElement
)
)
)
{
NS_WARNING
(
"
nsIDocumentEncoder
:
:
SetContainerNode
(
)
failed
"
)
;
return
nullptr
;
}
}
}
return
docEncoder
.
forget
(
)
;
}
NS_IMETHODIMP
TextEditor
:
:
OutputToString
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
ComputeValueInternal
(
aFormatType
aDocumentEncoderFlags
aOutputString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
ComputeValueInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
ComputeValueInternal
(
const
nsAString
&
aFormatType
uint32_t
aDocumentEncoderFlags
nsAString
&
aOutputString
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
aFormatType
.
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
)
{
if
(
!
(
aDocumentEncoderFlags
&
(
nsIDocumentEncoder
:
:
OutputSelectionOnly
|
nsIDocumentEncoder
:
:
OutputWrap
)
)
)
{
EditActionResult
result
=
ComputeValueFromTextNodeAndPaddingBRElement
(
aOutputString
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
|
|
result
.
Handled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
TextEditor
:
:
ComputeValueFromTextNodeAndPaddingBRElement
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
}
}
nsAutoCString
charset
;
nsresult
rv
=
GetDocumentCharsetInternal
(
charset
)
;
if
(
NS_FAILED
(
rv
)
|
|
charset
.
IsEmpty
(
)
)
{
charset
.
AssignLiteral
(
"
windows
-
1252
"
)
;
}
nsCOMPtr
<
nsIDocumentEncoder
>
encoder
=
GetAndInitDocEncoder
(
aFormatType
aDocumentEncoderFlags
charset
)
;
if
(
!
encoder
)
{
NS_WARNING
(
"
TextEditor
:
:
GetAndInitDocEncoder
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
encoder
-
>
EncodeToString
(
aOutputString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsIDocumentEncoder
:
:
EncodeToString
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
PasteAsQuotationAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aClipboardType
=
=
nsIClipboard
:
:
kGlobalClipboard
|
|
aClipboardType
=
=
nsIClipboard
:
:
kSelectionClipboard
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePasteAsQuotation
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
nsIClipboard
service
"
)
;
return
rv
;
}
nsCOMPtr
<
nsITransferable
>
trans
;
rv
=
PrepareTransferable
(
getter_AddRefs
(
trans
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
PrepareTransferable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
trans
)
{
return
NS_OK
;
}
clipboard
-
>
GetData
(
trans
aClipboardType
)
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
nsAutoCString
flav
;
rv
=
trans
-
>
GetAnyTransferData
(
flav
getter_AddRefs
(
genericDataObj
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsITransferable
:
:
GetAnyTransferData
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
flav
.
EqualsLiteral
(
kUnicodeMime
)
&
&
!
flav
.
EqualsLiteral
(
kMozTextInternal
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISupportsString
>
text
=
do_QueryInterface
(
genericDataObj
)
;
if
(
!
text
)
{
return
NS_OK
;
}
nsString
stuffToPaste
;
DebugOnly
<
nsresult
>
rvIgnored
=
text
-
>
GetData
(
stuffToPaste
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsISupportsString
:
:
GetData
(
)
failed
but
ignored
"
)
;
if
(
stuffToPaste
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
editActionData
.
SetData
(
stuffToPaste
)
;
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
stuffToPaste
)
;
}
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
rv
=
InsertWithQuotationsAsSubAction
(
stuffToPaste
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertWithQuotationsAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
InsertWithQuotationsAsSubAction
(
const
nsAString
&
aQuotedText
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
IsReadonly
(
)
)
{
return
NS_OK
;
}
nsString
quotedStuff
;
nsresult
rv
=
InternetCiter
:
:
GetCiteString
(
aQuotedText
quotedStuff
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InternetCiter
:
:
GetCiteString
(
)
failed
"
)
;
return
rv
;
}
if
(
!
aQuotedText
.
IsEmpty
(
)
&
&
(
aQuotedText
.
Last
(
)
!
=
char16_t
(
'
\
n
'
)
)
)
{
quotedStuff
.
Append
(
char16_t
(
'
\
n
'
)
)
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MaybeDoAutoPasswordMasking
(
)
;
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
rv
=
InsertTextAsSubAction
(
quotedStuff
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
SharedOutputString
(
uint32_t
aFlags
bool
*
aIsCollapsed
nsAString
&
aResult
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
*
aIsCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
if
(
!
*
aIsCollapsed
)
{
aFlags
|
=
nsIDocumentEncoder
:
:
OutputSelectionOnly
;
}
nsresult
rv
=
ComputeValueInternal
(
NS_LITERAL_STRING
(
"
text
/
plain
"
)
aFlags
aResult
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
ComputeValueInternal
(
text
/
plain
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
SelectEntireDocument
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
Element
*
anonymousDivElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
anonymousDivElement
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsEmpty
(
)
)
{
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
anonymousDivElement
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
childNode
;
nsresult
rv
=
EditorBase
:
:
GetEndChildNode
(
*
SelectionRefPtr
(
)
getter_AddRefs
(
childNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
GetEndChildNode
(
)
failed
"
)
;
return
rv
;
}
if
(
childNode
)
{
childNode
=
childNode
-
>
GetPreviousSibling
(
)
;
}
if
(
childNode
&
&
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
childNode
)
)
{
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetStartAndEndInLimiter
(
RawRangeBoundary
(
anonymousDivElement
0u
)
EditorRawDOMPoint
(
childNode
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SetStartAndEndInLimiter
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
anonymousDivElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
EventTarget
*
TextEditor
:
:
GetDOMEventTarget
(
)
const
{
return
mEventTarget
;
}
nsresult
TextEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
if
(
NS_WARN_IF
(
!
aElement
)
|
|
NS_WARN_IF
(
!
aAttribute
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetAttribute
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
if
(
NS_WARN_IF
(
!
aElement
)
|
|
NS_WARN_IF
(
!
aAttribute
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAttribute
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
EnsurePaddingBRElementForEmptyEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
if
(
mPaddingBRElementForEmptyEditor
)
{
return
NS_OK
;
}
if
(
IsSingleLineEditor
(
)
)
{
nsresult
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
childCount
=
mRootElement
-
>
GetChildCount
(
)
;
if
(
childCount
=
=
0
)
{
nsresult
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
childCount
>
1
)
{
return
NS_OK
;
}
RefPtr
<
HTMLBRElement
>
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
mRootElement
-
>
GetFirstChild
(
)
)
;
if
(
!
brElement
|
|
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brElement
)
)
{
return
NS_OK
;
}
mPaddingBRElementForEmptyEditor
=
std
:
:
move
(
brElement
)
;
mPaddingBRElementForEmptyEditor
-
>
UnsetFlags
(
NS_PADDING_FOR_EMPTY_LAST_LINE
)
;
mPaddingBRElementForEmptyEditor
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_EDITOR
)
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
SetUnmaskRangeInternal
(
uint32_t
aStart
uint32_t
aLength
uint32_t
aTimeout
bool
aNotify
bool
aForceStartMasking
)
{
mIsMaskingPassword
=
aForceStartMasking
|
|
aTimeout
!
=
0
;
if
(
!
IsAllMasked
(
)
)
{
mUnmaskedLength
=
0
;
if
(
mMaskTimer
)
{
mMaskTimer
-
>
Cancel
(
)
;
}
}
if
(
!
IsPasswordEditor
(
)
)
{
if
(
mMaskTimer
)
{
mMaskTimer
=
nullptr
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
Text
*
text
=
Text
:
:
FromNodeOrNull
(
rootElement
-
>
GetFirstChild
(
)
)
;
if
(
!
text
)
{
return
aStart
>
0
&
&
aStart
!
=
UINT32_MAX
?
NS_ERROR_INVALID_ARG
:
NS_OK
;
}
if
(
aStart
<
UINT32_MAX
)
{
uint32_t
valueLength
=
text
-
>
Length
(
)
;
if
(
aStart
>
=
valueLength
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
nsTextFragment
*
textFragment
=
text
-
>
GetText
(
)
;
if
(
textFragment
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
aStart
)
)
{
mUnmaskedStart
=
aStart
-
1
;
if
(
aLength
>
0
)
{
+
+
aLength
;
}
}
else
{
mUnmaskedStart
=
aStart
;
}
mUnmaskedLength
=
std
:
:
min
(
valueLength
-
mUnmaskedStart
aLength
)
;
if
(
UnmaskedEnd
(
)
<
valueLength
&
&
textFragment
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
UnmaskedEnd
(
)
)
)
{
+
+
mUnmaskedLength
;
}
if
(
!
mMaskTimer
&
&
aLength
&
&
aTimeout
&
&
mUnmaskedLength
)
{
mMaskTimer
=
NS_NewTimer
(
)
;
}
}
else
{
if
(
NS_WARN_IF
(
aLength
!
=
0
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mUnmaskedStart
=
UINT32_MAX
;
mUnmaskedLength
=
0
;
}
if
(
aNotify
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
RefPtr
<
PresShell
>
presShell
=
document
-
>
GetObservingPresShell
(
)
)
{
nsAutoScriptBlocker
blockRunningScript
;
uint32_t
valueLength
=
text
-
>
Length
(
)
;
CharacterDataChangeInfo
changeInfo
=
{
false
0
valueLength
valueLength
nullptr
}
;
presShell
-
>
CharacterDataChanged
(
text
changeInfo
)
;
}
nsresult
rv
=
ScrollSelectionFocusIntoView
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
IsAllMasked
(
)
&
&
aTimeout
!
=
0
)
{
MOZ_ASSERT
(
mMaskTimer
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mMaskTimer
-
>
InitWithCallback
(
this
aTimeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsITimer
:
:
InitWithCallback
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
char16_t
TextEditor
:
:
PasswordMask
(
)
{
char16_t
ret
=
LookAndFeel
:
:
GetPasswordCharacter
(
)
;
if
(
!
ret
)
{
ret
=
'
*
'
;
}
return
ret
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
TextEditor
:
:
Notify
(
nsITimer
*
aTimer
)
{
if
(
!
IsPasswordEditor
(
)
)
{
return
NS_OK
;
}
if
(
IsAllMasked
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eHidePassword
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
MaskAllCharactersAndNotify
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
MaskAllCharactersAndNotify
(
)
failed
"
)
;
if
(
StaticPrefs
:
:
editor_password_testing_mask_delay
(
)
)
{
if
(
RefPtr
<
Element
>
target
=
GetInputEventTargetElement
(
)
)
{
RefPtr
<
Document
>
document
=
target
-
>
OwnerDoc
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchTrustedEvent
(
document
target
NS_LITERAL_STRING
(
"
MozLastInputMasked
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsContentUtils
:
:
DispatchTrustedEvent
(
"
"
MozLastInputMasked
)
failed
but
ignored
"
)
;
}
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
TextEditor
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
TextEditor
"
)
;
return
NS_OK
;
}
void
TextEditor
:
:
WillDeleteText
(
uint32_t
aCurrentLength
uint32_t
aRemoveStartOffset
uint32_t
aRemoveLength
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
IsPasswordEditor
(
)
|
|
IsAllMasked
(
)
)
{
return
;
}
if
(
mIsMaskingPassword
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
MaskAllCharacters
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
MaskAllCharacters
(
)
failed
but
ignored
"
)
;
return
;
}
if
(
aRemoveStartOffset
<
mUnmaskedStart
)
{
if
(
aRemoveStartOffset
+
aRemoveLength
<
=
mUnmaskedStart
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetUnmaskRange
(
mUnmaskedStart
-
aRemoveLength
mUnmaskedLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
SetUnmaskRange
(
)
failed
but
ignored
"
)
;
return
;
}
if
(
aRemoveStartOffset
+
aRemoveLength
<
UnmaskedEnd
(
)
)
{
uint32_t
unmaskedLengthInRemovingRange
=
aRemoveStartOffset
+
aRemoveLength
-
mUnmaskedStart
;
DebugOnly
<
nsresult
>
rvIgnored
=
SetUnmaskRange
(
aRemoveStartOffset
mUnmaskedLength
-
unmaskedLengthInRemovingRange
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
SetUnmaskRange
(
)
failed
but
ignored
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SetUnmaskRange
(
aRemoveStartOffset
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
SetUnmaskRange
(
)
failed
but
ignored
"
)
;
return
;
}
if
(
aRemoveStartOffset
<
UnmaskedEnd
(
)
)
{
if
(
aRemoveStartOffset
+
aRemoveLength
<
=
UnmaskedEnd
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetUnmaskRange
(
mUnmaskedStart
mUnmaskedLength
-
aRemoveLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
SetUnmaskRange
(
)
failed
but
ignored
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SetUnmaskRange
(
mUnmaskedStart
aRemoveStartOffset
-
mUnmaskedStart
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TextEditor
:
:
SetUnmaskRange
(
)
failed
but
ignored
"
)
;
return
;
}
}
nsresult
TextEditor
:
:
DidInsertText
(
uint32_t
aNewLength
uint32_t
aInsertedOffset
uint32_t
aInsertedLength
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
IsPasswordEditor
(
)
|
|
IsAllMasked
(
)
)
{
return
NS_OK
;
}
if
(
mIsMaskingPassword
)
{
nsresult
rv
=
MaskAllCharactersAndNotify
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
MaskAllCharacters
(
)
failed
"
)
;
return
rv
;
}
if
(
aInsertedOffset
<
mUnmaskedStart
)
{
nsresult
rv
=
SetUnmaskRangeAndNotify
(
aInsertedOffset
UnmaskedEnd
(
)
+
aInsertedLength
-
aInsertedOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetUnmaskRangeAndNotify
(
)
failed
"
)
;
return
rv
;
}
if
(
aInsertedOffset
<
=
UnmaskedEnd
(
)
)
{
nsresult
rv
=
SetUnmaskRangeAndNotify
(
mUnmaskedStart
mUnmaskedLength
+
aInsertedLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetUnmaskRangeAndNotify
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetUnmaskRangeAndNotify
(
mUnmaskedStart
aInsertedOffset
+
aInsertedLength
-
mUnmaskedStart
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetUnmaskRangeAndNotify
(
)
failed
"
)
;
return
rv
;
}
}
