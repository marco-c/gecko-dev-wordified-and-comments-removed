#
ifndef
mozilla_HTMLEditUtils_h
#
define
mozilla_HTMLEditUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsTArray
.
h
"
class
nsAtom
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
CollectChildrenOption
{
IgnoreNonEditableChildren
CollectListChildren
CollectTableChildren
}
;
class
HTMLEditUtils
final
{
using
AbstractRange
=
dom
:
:
AbstractRange
;
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
using
Text
=
dom
:
:
Text
;
public
:
static
constexpr
char16_t
kNewLine
=
'
\
n
'
;
static
constexpr
char16_t
kCarriageReturn
=
'
\
r
'
;
static
constexpr
char16_t
kTab
=
'
\
t
'
;
static
constexpr
char16_t
kSpace
=
'
'
;
static
constexpr
char16_t
kNBSP
=
0x00A0
;
static
constexpr
char16_t
kGreaterThan
=
'
>
'
;
static
bool
IsSimplyEditableNode
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsEditable
(
)
;
}
static
bool
IsNeverElementContentsEditableByUser
(
const
nsIContent
&
aContent
)
{
return
aContent
.
IsElement
(
)
&
&
(
!
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
|
|
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
applet
nsGkAtoms
:
:
colgroup
nsGkAtoms
:
:
frameset
nsGkAtoms
:
:
head
nsGkAtoms
:
:
html
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
picture
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
;
}
static
bool
IsNonEditableReplacedContent
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
select
nsGkAtoms
:
:
option
nsGkAtoms
:
:
optgroup
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
IsRemovableNode
(
const
nsIContent
&
aContent
)
{
return
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
aContent
)
|
|
aContent
.
IsRootOfNativeAnonymousSubtree
(
)
|
|
(
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
)
;
}
static
bool
IsRemovableFromParentNode
(
const
nsIContent
&
aContent
)
{
return
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
aContent
)
|
|
aContent
.
IsRootOfNativeAnonymousSubtree
(
)
|
|
(
aContent
.
IsEditable
(
)
&
&
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
)
;
}
enum
class
StyleDifference
{
Ignore
CompareIfElements
CompareIfSpanElements
}
;
static
bool
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
StyleDifference
aStyleDifference
)
;
static
bool
IsBlockElement
(
const
nsIContent
&
aContent
)
;
static
bool
IsInlineElement
(
const
nsIContent
&
aContent
)
{
return
!
IsBlockElement
(
aContent
)
;
}
static
bool
IsInlineStyle
(
nsINode
*
aNode
)
;
static
bool
IsDisplayOutsideInline
(
const
Element
&
aElement
)
;
static
bool
IsRemovableInlineStyleElement
(
Element
&
aElement
)
;
static
bool
IsFormatNode
(
const
nsINode
*
aNode
)
;
static
bool
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
;
static
bool
IsHeader
(
nsINode
&
aNode
)
;
static
bool
IsListItem
(
const
nsINode
*
aNode
)
;
static
bool
IsTable
(
nsINode
*
aNode
)
;
static
bool
IsTableRow
(
nsINode
*
aNode
)
;
static
bool
IsAnyTableElement
(
const
nsINode
*
aNode
)
;
static
bool
IsAnyTableElementButNotTable
(
nsINode
*
aNode
)
;
static
bool
IsTableCell
(
const
nsINode
*
aNode
)
;
static
bool
IsTableCellOrCaption
(
nsINode
&
aNode
)
;
static
bool
IsAnyListElement
(
const
nsINode
*
aNode
)
;
static
bool
IsPre
(
const
nsINode
*
aNode
)
;
static
bool
IsImage
(
nsINode
*
aNode
)
;
static
bool
IsLink
(
nsINode
*
aNode
)
;
static
bool
IsNamedAnchor
(
const
nsINode
*
aNode
)
;
static
bool
IsMozDiv
(
nsINode
*
aNode
)
;
static
bool
IsMailCite
(
const
Element
&
aElement
)
;
static
bool
IsFormWidget
(
const
nsINode
*
aNode
)
;
static
bool
SupportsAlignAttr
(
nsINode
&
aNode
)
;
static
bool
CanNodeContain
(
const
nsINode
&
aParent
const
nsIContent
&
aChild
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChild
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsINode
&
aParent
nsAtom
&
aChildNodeName
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChildNodeName
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
const
nsIContent
&
aChild
)
{
switch
(
aChild
.
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
aParentNodeName
*
aChild
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
nsAtom
&
aChildNodeName
)
{
nsHTMLTag
childTagEnum
;
if
(
&
aChildNodeName
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildNodeName
)
;
}
nsHTMLTag
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentNodeName
)
;
return
HTMLEditUtils
:
:
CanNodeContain
(
parentTagEnum
childTagEnum
)
;
}
static
bool
CanElementContainParagraph
(
const
Element
&
aElement
)
{
if
(
HTMLEditUtils
:
:
CanNodeContain
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsContainerNode
(
const
nsIContent
&
aContent
)
{
nsHTMLTag
tagEnum
;
if
(
aContent
.
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aContent
.
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
tagEnum
)
;
}
static
bool
IsSplittableNode
(
const
nsIContent
&
aContent
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorUtils
:
:
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
aContent
)
)
{
return
false
;
}
if
(
aContent
.
IsElement
(
)
)
{
return
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
&
&
!
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
html
)
;
}
return
aContent
.
IsText
(
)
&
&
aContent
.
Length
(
)
>
0
;
}
static
bool
IsNonListSingleLineContainer
(
const
nsINode
&
aNode
)
;
static
bool
IsSingleLineContainer
(
const
nsINode
&
aNode
)
;
static
bool
IsVisibleTextNode
(
const
Text
&
aText
)
;
static
bool
IsInVisibleTextFrames
(
nsPresContext
*
aPresContext
const
Text
&
aText
)
;
static
bool
IsVisibleBRElement
(
const
nsIContent
&
aContent
)
{
if
(
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
)
{
return
IsVisibleBRElement
(
*
brElement
)
;
}
return
false
;
}
static
bool
IsVisibleBRElement
(
const
dom
:
:
HTMLBRElement
&
aBRElement
)
{
return
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aBRElement
WalkTreeDirection
:
:
Forward
)
;
}
static
bool
IsInvisibleBRElement
(
const
nsIContent
&
aContent
)
{
if
(
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
)
{
return
IsInvisibleBRElement
(
*
brElement
)
;
}
return
false
;
}
static
bool
IsInvisibleBRElement
(
const
dom
:
:
HTMLBRElement
&
aBRElement
)
{
return
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
aBRElement
)
;
}
template
<
typename
EditorDOMPointType
>
static
bool
IsVisiblePreformattedNewLine
(
const
EditorDOMPointType
&
aPoint
Element
*
*
aFollowingBlockElement
=
nullptr
)
{
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
nullptr
;
}
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
aPoint
.
IsCharPreformattedNewLine
(
)
)
{
return
false
;
}
if
(
!
aPoint
.
IsAtLastContent
(
)
)
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
ContainerAsText
(
)
)
)
{
return
true
;
}
const
nsTextFragment
&
textFragment
=
aPoint
.
ContainerAsText
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
offset
=
aPoint
.
Offset
(
)
+
1
;
offset
<
textFragment
.
GetLength
(
)
;
+
+
offset
)
{
char16_t
ch
=
textFragment
.
CharAt
(
AssertedCast
<
int32_t
>
(
offset
)
)
;
if
(
nsCRT
:
:
IsAsciiSpace
(
ch
)
&
&
ch
!
=
HTMLEditUtils
:
:
kNewLine
)
{
continue
;
}
return
true
;
}
}
Element
*
followingBlockElement
=
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
*
aPoint
.
ContainerAsText
(
)
WalkTreeDirection
:
:
Forward
)
;
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
followingBlockElement
;
}
return
!
followingBlockElement
;
}
template
<
typename
EditorDOMPointType
>
static
bool
IsInvisiblePreformattedNewLine
(
const
EditorDOMPointType
&
aPoint
Element
*
*
aFollowingBlockElement
=
nullptr
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
aPoint
.
IsCharPreformattedNewLine
(
)
)
{
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
nullptr
;
}
return
false
;
}
return
!
IsVisiblePreformattedNewLine
(
aPoint
aFollowingBlockElement
)
;
}
static
bool
ShouldInsertLinefeedCharacter
(
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
enum
class
EmptyCheckOption
{
TreatSingleBRElementAsVisible
TreatListItemAsVisible
TreatTableCellAsVisible
IgnoreEditableState
SafeToAskLayout
}
;
using
EmptyCheckOptions
=
EnumSet
<
EmptyCheckOption
uint32_t
>
;
static
bool
IsEmptyNode
(
nsPresContext
*
aPresContext
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
=
{
}
bool
*
aSeenBR
=
nullptr
)
;
static
bool
IsEmptyNode
(
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
=
{
}
bool
*
aSeenBR
=
nullptr
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
)
;
return
IsEmptyNode
(
nullptr
aNode
aOptions
aSeenBR
)
;
}
static
bool
IsEmptyInlineContainer
(
const
nsIContent
&
aContent
const
EmptyCheckOptions
&
aOptions
)
{
return
HTMLEditUtils
:
:
IsInlineElement
(
aContent
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
aContent
aOptions
)
;
}
static
bool
IsEmptyBlockElement
(
const
Element
&
aElement
const
EmptyCheckOptions
&
aOptions
)
{
return
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
aOptions
)
;
}
static
bool
IsEmptyOneHardLine
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
if
(
NS_WARN_IF
(
aArrayOfContents
.
IsEmpty
(
)
)
)
{
return
true
;
}
bool
brElementHasFound
=
false
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
brElementHasFound
)
{
return
false
;
}
brElementHasFound
=
true
;
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
PT
typename
CT
>
static
bool
IsPointAtEdgeOfLink
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
return
false
;
}
if
(
!
aPoint
.
IsStartOfContainer
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
false
;
}
bool
maybeStartOfAnchor
=
aPoint
.
IsStartOfContainer
(
)
;
for
(
EditorRawDOMPoint
point
(
aPoint
.
ContainerAsContent
(
)
)
;
point
.
IsSet
(
)
&
&
(
maybeStartOfAnchor
?
point
.
IsStartOfContainer
(
)
:
point
.
IsAtLastContent
(
)
)
;
point
=
point
.
ParentPoint
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
point
.
GetContainer
(
)
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
point
.
ContainerAsElement
(
)
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
static
bool
IsContentInclusiveDescendantOfLink
(
nsIContent
&
aContent
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
element
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
element
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
template
<
typename
EditorDOMRangeType
>
static
bool
IsRangeEntirelyInLink
(
const
EditorDOMRangeType
&
aRange
Element
*
*
aFoundLinkElement
=
nullptr
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
nsINode
*
commonAncestorNode
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
aRange
.
StartRef
(
)
.
GetContainer
(
)
aRange
.
EndRef
(
)
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
commonAncestorNode
)
|
|
!
commonAncestorNode
-
>
IsContent
(
)
)
{
return
false
;
}
return
IsContentInclusiveDescendantOfLink
(
*
commonAncestorNode
-
>
AsContent
(
)
aFoundLinkElement
)
;
}
enum
class
WalkTreeOption
{
IgnoreNonEditableNode
IgnoreDataNodeExceptText
IgnoreWhiteSpaceOnlyText
StopAtBlockBoundary
}
;
using
WalkTreeOptions
=
EnumSet
<
WalkTreeOption
>
;
static
nsIContent
*
GetPreviousContent
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aNode
=
=
aAncestorLimiter
|
|
(
aAncestorLimiter
&
&
!
aNode
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
aNode
WalkTreeDirection
:
:
Backward
aOptions
aAncestorLimiter
)
;
}
static
nsIContent
*
GetNextContent
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aNode
=
=
aAncestorLimiter
|
|
(
aAncestorLimiter
&
&
!
aNode
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
aNode
WalkTreeDirection
:
:
Forward
aOptions
aAncestorLimiter
)
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetPreviousContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
;
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetNextContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
nsIContent
*
GetPreviousSibling
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
for
(
nsIContent
*
sibling
=
aContent
.
GetPreviousSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetPreviousSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
sibling
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
)
)
{
return
nullptr
;
}
return
sibling
;
}
return
nullptr
;
}
static
nsIContent
*
GetNextSibling
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
for
(
nsIContent
*
sibling
=
aContent
.
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
sibling
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
)
)
{
return
nullptr
;
}
return
sibling
;
}
return
nullptr
;
}
static
nsIContent
*
GetLastChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
)
{
for
(
nsIContent
*
child
=
aNode
.
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
)
)
{
return
nullptr
;
}
return
child
;
}
return
nullptr
;
}
static
nsIContent
*
GetFirstChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
)
{
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
)
)
{
return
nullptr
;
}
return
child
;
}
return
nullptr
;
}
static
bool
IsLastChild
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
nsINode
*
parentNode
=
aContent
.
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
false
;
}
return
HTMLEditUtils
:
:
GetLastChild
(
*
parentNode
aOptions
)
=
=
&
aContent
;
}
static
bool
IsFirstChild
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
nsINode
*
parentNode
=
aContent
.
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
false
;
}
return
HTMLEditUtils
:
:
GetFirstChild
(
*
parentNode
aOptions
)
=
=
&
aContent
;
}
enum
class
WalkTreeDirection
{
Forward
Backward
}
;
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetAdjacentContentToPutCaret
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
WalkTreeDirection
aWalkTreeDirection
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
editableContent
=
nullptr
;
if
(
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Backward
)
{
editableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
aPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
;
if
(
!
editableContent
)
{
return
nullptr
;
}
}
else
{
editableContent
=
HTMLEditUtils
:
:
GetNextContent
(
aPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
while
(
editableContent
&
&
!
editableContent
-
>
IsText
(
)
&
&
!
editableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsImage
(
editableContent
)
)
{
if
(
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Backward
)
{
editableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
else
{
editableContent
=
HTMLEditUtils
:
:
GetNextContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
}
if
(
(
!
aPoint
.
IsInContentNode
(
)
&
&
!
!
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
editableContent
)
)
|
|
(
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
editableContent
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
aPoint
.
ContainerAsContent
(
)
)
)
)
{
return
nullptr
;
}
return
editableContent
;
}
enum
class
LeafNodeType
{
OnlyLeafNode
LeafNodeOrChildBlock
LeafNodeOrNonEditableNode
OnlyEditableLeafNode
}
;
using
LeafNodeTypes
=
EnumSet
<
LeafNodeType
>
;
static
nsIContent
*
GetLastLeafContent
(
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
aNode
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
aNode
.
AsElement
(
)
)
)
{
return
nullptr
;
}
for
(
nsIContent
*
content
=
aNode
.
GetLastChild
(
)
;
content
;
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
content
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aAncestorLimiter
)
;
continue
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
|
|
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
content
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aNode
.
IsEditable
(
)
&
&
!
content
-
>
IsEditable
(
)
)
{
return
content
;
}
content
=
content
-
>
GetLastChild
(
)
;
}
return
nullptr
;
}
static
nsIContent
*
GetFirstLeafContent
(
const
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
aNode
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
aNode
.
AsElement
(
)
)
)
{
return
nullptr
;
}
for
(
nsIContent
*
content
=
aNode
.
GetFirstChild
(
)
;
content
;
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
content
=
HTMLEditUtils
:
:
GetNextContent
(
*
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aAncestorLimiter
)
;
continue
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
|
|
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
content
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aNode
.
IsEditable
(
)
&
&
!
content
-
>
IsEditable
(
)
)
{
return
content
;
}
content
=
content
-
>
GetFirstChild
(
)
;
}
return
nullptr
;
}
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
nsIContent
&
aStartContent
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
nextContent
=
aStartContent
.
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
if
(
parentElement
=
=
aAncestorLimiter
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
nextContent
=
parentElement
-
>
GetNextSibling
(
)
;
if
(
nextContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
nextContent
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartContent
.
IsEditable
(
)
&
&
!
nextContent
-
>
IsEditable
(
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
nextContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
nextContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsText
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
ContainerAsContent
(
)
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
aStartPoint
.
GetChild
(
)
;
if
(
!
nextContent
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartPoint
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
nextContent
-
>
IsEditable
(
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
nextContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
nextContent
;
}
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
nsIContent
&
aStartContent
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
previousContent
=
aStartContent
.
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
if
(
parentElement
=
=
aAncestorLimiter
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
previousContent
=
parentElement
-
>
GetPreviousSibling
(
)
;
if
(
previousContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
previousContent
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartContent
.
IsEditable
(
)
&
&
!
previousContent
-
>
IsEditable
(
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
previousContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsText
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
ContainerAsContent
(
)
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
aStartPoint
.
IsStartOfContainer
(
)
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
previousContent
=
aStartPoint
.
GetPreviousSiblingOfChild
(
)
;
if
(
NS_WARN_IF
(
!
previousContent
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartPoint
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
previousContent
-
>
IsEditable
(
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
previousContent
;
}
enum
class
InvisibleWhiteSpaces
{
Ignore
Preserve
}
;
enum
class
TableBoundary
{
Ignore
NoCrossTableElement
NoCrossAnyTableElement
}
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
enum
class
AncestorType
{
ClosestBlockElement
MostDistantInlineElementInBlock
EditableElement
IgnoreHRElement
}
;
using
AncestorTypes
=
EnumSet
<
AncestorType
>
;
constexpr
static
AncestorTypes
ClosestEditableBlockElementOrInlineEditingHost
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
EditableElement
}
;
constexpr
static
AncestorTypes
ClosestBlockElement
=
{
AncestorType
:
:
ClosestBlockElement
}
;
constexpr
static
AncestorTypes
ClosestEditableBlockElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
}
;
constexpr
static
AncestorTypes
ClosestEditableBlockElementExceptHRElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
IgnoreHRElement
AncestorType
:
:
EditableElement
}
;
static
Element
*
GetAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetInclusiveAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetClosestAncestorTableElement
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
GetParent
(
)
)
{
return
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
static
Element
*
GetInclusiveAncestorAnyTableElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
parent
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
parent
)
)
{
return
parent
;
}
}
return
nullptr
;
}
static
Element
*
GetClosestAncestorAnyListElement
(
const
nsIContent
&
aContent
)
;
static
Element
*
GetClosestAncestorListItemElement
(
const
nsIContent
&
aContent
const
Element
*
aAncestorLimit
=
nullptr
)
{
MOZ_ASSERT_IF
(
aAncestorLimit
aContent
.
IsInclusiveDescendantOf
(
aAncestorLimit
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
&
aContent
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
parentElement
)
)
{
return
parentElement
;
}
if
(
parentElement
=
=
aAncestorLimit
)
{
return
nullptr
;
}
}
return
nullptr
;
}
template
<
typename
EditorDOMRangeType
>
static
EditorDOMRangeType
GetRangeSelectingAllContentInAllListItems
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
Element
*
firstListItem
=
HTMLEditUtils
:
:
GetFirstListItemElement
(
aListElement
)
;
Element
*
lastListItem
=
HTMLEditUtils
:
:
GetLastListItemElement
(
aListElement
)
;
MOZ_ASSERT_IF
(
firstListItem
lastListItem
)
;
MOZ_ASSERT_IF
(
!
firstListItem
!
lastListItem
)
;
if
(
!
firstListItem
|
|
!
lastListItem
)
{
return
EditorDOMRangeType
(
)
;
}
return
EditorDOMRangeType
(
typename
EditorDOMRangeType
:
:
PointType
(
firstListItem
-
>
GetFirstChild
(
)
&
&
firstListItem
-
>
GetFirstChild
(
)
-
>
IsText
(
)
?
firstListItem
-
>
GetFirstChild
(
)
:
static_cast
<
nsIContent
*
>
(
firstListItem
)
0u
)
EditorDOMRangeType
:
:
PointType
:
:
AtEndOf
(
lastListItem
-
>
GetLastChild
(
)
&
&
lastListItem
-
>
GetLastChild
(
)
-
>
IsText
(
)
?
*
lastListItem
-
>
GetFirstChild
(
)
:
static_cast
<
nsIContent
&
>
(
*
lastListItem
)
)
)
;
}
static
Element
*
GetFirstListItemElement
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
for
(
nsIContent
*
maybeFirstListItem
=
aListElement
.
GetFirstChild
(
)
;
maybeFirstListItem
;
maybeFirstListItem
=
maybeFirstListItem
-
>
GetNextNode
(
&
aListElement
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
maybeFirstListItem
)
)
{
return
maybeFirstListItem
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
static
Element
*
GetLastListItemElement
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
for
(
nsIContent
*
maybeLastListItem
=
aListElement
.
GetLastChild
(
)
;
maybeLastListItem
;
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
maybeLastListItem
)
)
{
return
maybeLastListItem
-
>
AsElement
(
)
;
}
if
(
maybeLastListItem
-
>
HasChildren
(
)
)
{
maybeLastListItem
=
maybeLastListItem
-
>
GetLastChild
(
)
;
continue
;
}
if
(
maybeLastListItem
-
>
GetPreviousSibling
(
)
)
{
maybeLastListItem
=
maybeLastListItem
-
>
GetPreviousSibling
(
)
;
continue
;
}
for
(
Element
*
parent
=
maybeLastListItem
-
>
GetParentElement
(
)
;
parent
;
parent
=
parent
-
>
GetParentElement
(
)
)
{
maybeLastListItem
=
nullptr
;
if
(
parent
=
=
&
aListElement
)
{
return
nullptr
;
}
if
(
parent
-
>
GetPreviousSibling
(
)
)
{
maybeLastListItem
=
parent
-
>
GetPreviousSibling
(
)
;
break
;
}
}
}
return
nullptr
;
}
static
Element
*
GetFirstTableCellElementChild
(
const
Element
&
aTableRowElement
)
{
MOZ_ASSERT
(
aTableRowElement
.
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
firstElementChild
=
aTableRowElement
.
GetFirstElementChild
(
)
;
return
firstElementChild
&
&
HTMLEditUtils
:
:
IsTableCell
(
firstElementChild
)
?
firstElementChild
:
nullptr
;
}
static
Element
*
GetLastTableCellElementChild
(
const
Element
&
aTableRowElement
)
{
MOZ_ASSERT
(
aTableRowElement
.
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
lastElementChild
=
aTableRowElement
.
GetLastElementChild
(
)
;
return
lastElementChild
&
&
HTMLEditUtils
:
:
IsTableCell
(
lastElementChild
)
?
lastElementChild
:
nullptr
;
}
static
Element
*
GetPreviousTableCellElementSibling
(
const
nsIContent
&
aChildOfTableRow
)
{
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
previousElementSibling
=
aChildOfTableRow
.
GetPreviousElementSibling
(
)
;
return
previousElementSibling
&
&
HTMLEditUtils
:
:
IsTableCell
(
previousElementSibling
)
?
previousElementSibling
:
nullptr
;
}
static
Element
*
GetNextTableCellElementSibling
(
const
nsIContent
&
aChildOfTableRow
)
{
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
nextElementSibling
=
aChildOfTableRow
.
GetNextElementSibling
(
)
;
return
nextElementSibling
&
&
HTMLEditUtils
:
:
IsTableCell
(
nextElementSibling
)
?
nextElementSibling
:
nullptr
;
}
static
nsIContent
*
GetMostDistantAncestorInlineElement
(
const
nsIContent
&
aContent
const
Element
*
aEditingHost
=
nullptr
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
)
{
return
nullptr
;
}
if
(
&
aContent
=
=
aEditingHost
)
{
return
nullptr
;
}
if
(
aEditingHost
&
&
!
aContent
.
IsInclusiveDescendantOf
(
aEditingHost
)
)
{
return
nullptr
;
}
if
(
!
aContent
.
GetParent
(
)
)
{
return
const_cast
<
nsIContent
*
>
(
&
aContent
)
;
}
nsIContent
*
topMostInlineContent
=
const_cast
<
nsIContent
*
>
(
&
aContent
)
;
for
(
nsIContent
*
content
:
aContent
.
AncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
content
=
=
aEditingHost
|
|
!
HTMLEditUtils
:
:
IsInlineElement
(
*
content
)
)
{
break
;
}
topMostInlineContent
=
content
;
}
return
topMostInlineContent
;
}
static
Element
*
GetMostDistantAnscestorEditableEmptyInlineElement
(
const
nsIContent
&
aEmptyContent
const
Element
*
aEditingHost
=
nullptr
)
{
nsIContent
*
lastEmptyContent
=
const_cast
<
nsIContent
*
>
(
&
aEmptyContent
)
;
for
(
Element
*
element
=
aEmptyContent
.
GetParentElement
(
)
;
element
&
&
element
!
=
aEditingHost
&
&
HTMLEditUtils
:
:
IsInlineElement
(
*
element
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
element
)
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
element
-
>
GetChildCount
(
)
>
1
)
{
for
(
const
nsIContent
*
child
=
element
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
lastEmptyContent
|
|
child
-
>
IsComment
(
)
)
{
continue
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
lastEmptyContent
-
>
AsElement
(
)
:
nullptr
;
}
}
lastEmptyContent
=
element
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
lastEmptyContent
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetElementIfOnlyOneSelected
(
const
AbstractRange
&
aRange
)
{
return
GetElementIfOnlyOneSelected
(
EditorRawDOMRange
(
aRange
)
)
;
}
template
<
typename
EditorDOMPointType
>
static
Element
*
GetElementIfOnlyOneSelected
(
const
EditorDOMRangeBase
<
EditorDOMPointType
>
&
aRange
)
{
if
(
!
aRange
.
IsPositioned
(
)
|
|
aRange
.
Collapsed
(
)
)
{
return
nullptr
;
}
const
auto
&
start
=
aRange
.
StartRef
(
)
;
const
auto
&
end
=
aRange
.
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
start
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
end
.
IsSetAndValid
(
)
)
|
|
start
.
GetContainer
(
)
!
=
end
.
GetContainer
(
)
)
{
return
nullptr
;
}
nsIContent
*
childAtStart
=
start
.
GetChild
(
)
;
if
(
!
childAtStart
|
|
!
childAtStart
-
>
IsElement
(
)
)
{
return
nullptr
;
}
if
(
childAtStart
-
>
GetNextSibling
(
)
)
{
return
childAtStart
-
>
GetNextSibling
(
)
=
=
end
.
GetChild
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
return
!
end
.
GetChild
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetTableCellElementIfOnlyOneSelected
(
const
AbstractRange
&
aRange
)
{
Element
*
element
=
HTMLEditUtils
:
:
GetElementIfOnlyOneSelected
(
aRange
)
;
return
element
&
&
HTMLEditUtils
:
:
IsTableCell
(
element
)
?
element
:
nullptr
;
}
static
Element
*
GetFirstSelectedTableCellElement
(
const
Selection
&
aSelection
)
{
if
(
!
aSelection
.
RangeCount
(
)
)
{
return
nullptr
;
}
const
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
|
|
NS_WARN_IF
(
!
firstRange
-
>
IsPositioned
(
)
)
)
{
return
nullptr
;
}
return
GetTableCellElementIfOnlyOneSelected
(
*
firstRange
)
;
}
template
<
typename
FirstElementName
typename
.
.
.
OtherElementNames
>
static
Element
*
GetInclusiveDeepestFirstChildWhichHasOneChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
FirstElementName
aFirstElementName
OtherElementNames
.
.
.
aOtherElementNames
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
nullptr
;
}
Element
*
parentElement
=
nullptr
;
for
(
nsIContent
*
content
=
const_cast
<
nsIContent
*
>
(
aNode
.
AsContent
(
)
)
;
content
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
IsAnyOfHTMLElements
(
aFirstElementName
aOtherElementNames
.
.
.
)
;
content
=
content
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
CountChildren
(
*
content
aOptions
)
!
=
1
)
{
return
content
-
>
AsElement
(
)
;
}
parentElement
=
content
-
>
AsElement
(
)
;
}
return
parentElement
;
}
static
dom
:
:
HTMLBRElement
*
GetFirstBRElement
(
const
dom
:
:
Element
&
aElement
)
{
for
(
nsIContent
*
content
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
aElement
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
content
;
content
=
HTMLEditUtils
:
:
GetNextContent
(
*
content
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
}
&
aElement
)
)
{
if
(
auto
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
*
content
)
)
{
return
brElement
;
}
}
return
nullptr
;
}
static
bool
IsInTableCellSelectionMode
(
const
Selection
&
aSelection
)
{
return
GetFirstSelectedTableCellElement
(
aSelection
)
!
=
nullptr
;
}
static
EditAction
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForInsert
(
const
Element
&
aElement
)
;
static
EditAction
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
;
static
EditAction
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
;
enum
class
WalkTextOption
{
TreatNBSPsCollapsible
}
;
using
WalkTextOptions
=
EnumSet
<
WalkTextOption
>
;
static
Maybe
<
uint32_t
>
GetPreviousNonCollapsibleCharOffset
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetPreviousNonCollapsibleCharOffset
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetPreviousNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
aTextNode
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
aTextNode
)
;
const
bool
isNBSPCollapsible
=
isWhiteSpaceCollapsible
&
&
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
;
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
;
i
;
i
-
-
)
{
switch
(
textFragment
.
CharAt
(
i
-
1
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
!
isWhiteSpaceCollapsible
)
{
return
Some
(
i
-
1
)
;
}
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
!
isNewLineCollapsible
)
{
return
Some
(
i
-
1
)
;
}
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
!
isNBSPCollapsible
)
{
return
Some
(
i
-
1
)
;
}
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
-
1
)
)
)
;
return
Some
(
i
-
1
)
;
}
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
GetNextNonCollapsibleCharOffset
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetNextNonCollapsibleCharOffset
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetNextNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
return
GetInclusiveNextNonCollapsibleCharOffset
(
aTextNode
aOffset
+
1
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetInclusiveNextNonCollapsibleCharOffset
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetInclusiveNextNonCollapsibleCharOffset
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetInclusiveNextNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
aTextNode
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
aTextNode
)
;
const
bool
isNBSPCollapsible
=
isWhiteSpaceCollapsible
&
&
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
;
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
switch
(
textFragment
.
CharAt
(
i
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
!
isWhiteSpaceCollapsible
)
{
return
Some
(
i
)
;
}
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
!
isNewLineCollapsible
)
{
return
Some
(
i
)
;
}
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
!
isNBSPCollapsible
)
{
return
Some
(
i
)
;
}
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
)
)
)
;
return
Some
(
i
)
;
}
}
return
Nothing
(
)
;
}
static
uint32_t
GetFirstWhiteSpaceOffsetCollapsedWith
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
aPoint
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
aPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
;
MOZ_ASSERT_IF
(
!
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
aPoint
.
IsCharCollapsibleASCIISpace
(
)
)
;
return
GetFirstWhiteSpaceOffsetCollapsedWith
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
uint32_t
GetFirstWhiteSpaceOffsetCollapsedWith
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aOffset
<
aTextNode
.
TextLength
(
)
)
;
MOZ_ASSERT_IF
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
;
MOZ_ASSERT_IF
(
!
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
.
IsCharCollapsibleASCIISpace
(
)
)
;
if
(
!
aOffset
)
{
return
0
;
}
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
GetPreviousNonCollapsibleCharOffset
(
aTextNode
aOffset
aWalkTextOptions
)
;
return
previousVisibleCharOffset
.
isSome
(
)
?
previousVisibleCharOffset
.
value
(
)
+
1
:
0
;
}
template
<
typename
EditorDOMPointType
typename
ArgEditorDOMPointType
>
static
EditorDOMPointType
GetPreviousPreformattedNewLineInTextNode
(
const
ArgEditorDOMPointType
&
aPoint
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsStartOfContainer
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
ContainerAsText
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
Text
*
textNode
=
aPoint
.
ContainerAsText
(
)
;
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
MOZ_ASSERT
(
aPoint
.
Offset
(
)
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
offset
=
aPoint
.
Offset
(
)
;
offset
;
-
-
offset
)
{
if
(
textFragment
.
CharAt
(
offset
-
1
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
return
EditorDOMPointType
(
textNode
offset
-
1
)
;
}
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
typename
ArgEditorDOMPointType
>
static
EditorDOMPointType
GetInclusiveNextPreformattedNewLineInTextNode
(
const
ArgEditorDOMPointType
&
aPoint
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
ContainerAsText
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
Text
*
textNode
=
aPoint
.
ContainerAsText
(
)
;
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
for
(
uint32_t
offset
=
aPoint
.
Offset
(
)
;
offset
<
textFragment
.
GetLength
(
)
;
+
+
offset
)
{
if
(
textFragment
.
CharAt
(
offset
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
return
EditorDOMPointType
(
textNode
offset
)
;
}
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetGoodCaretPointFor
(
nsIContent
&
aContent
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePreviousWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
const
bool
goingForward
=
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
if
(
aContent
.
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
|
|
NS_WARN_IF
(
!
aContent
.
GetParentNode
(
)
)
)
{
return
EditorDOMPointType
(
&
aContent
goingForward
?
0
:
aContent
.
Length
(
)
)
;
}
if
(
goingForward
)
{
return
EditorDOMPointType
(
&
aContent
)
;
}
if
(
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
aContent
)
)
{
EditorDOMPointType
ret
(
EditorDOMPointType
:
:
After
(
aContent
)
)
;
NS_WARNING_ASSERTION
(
ret
.
IsSet
(
)
"
Failed
to
set
after
aContent
"
)
;
return
ret
;
}
return
EditorDOMPointType
(
&
aContent
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
static
EditorDOMPointType
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPointTypeInput
&
aPointToInsert
const
Element
&
aEditingHost
)
;
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
static
Result
<
EditorDOMPointType
nsresult
>
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPointTypeInput
&
aCurrentPoint
)
;
static
bool
IsInlineStyleSetByElement
(
const
nsIContent
&
aContent
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
const
nsAString
*
aValue
nsAString
*
aOutValue
=
nullptr
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
&
aProperty
!
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
if
(
!
aAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
value
)
;
if
(
aOutValue
)
{
*
aOutValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
return
false
;
}
}
return
false
;
}
static
size_t
CollectChildren
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
const
CollectChildrenOptions
&
aOptions
)
;
static
size_t
CollectEmptyInlineContainerDescendants
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
const
EmptyCheckOptions
&
aOptions
)
;
private
:
static
bool
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
;
static
bool
IsContainerNode
(
nsHTMLTag
aTagId
)
;
static
bool
CanCrossContentBoundary
(
nsIContent
&
aContent
TableBoundary
aHowToTreatTableBoundary
)
{
const
bool
cannotCrossBoundary
=
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossAnyTableElement
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
)
|
|
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossTableElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
return
!
cannotCrossBoundary
;
}
static
bool
IsContentIgnored
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreNonEditableNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
return
true
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreDataNodeExceptText
)
&
&
!
EditorUtils
:
:
IsElementOrText
(
aContent
)
)
{
return
true
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
)
&
&
aContent
.
IsText
(
)
&
&
const_cast
<
Text
*
>
(
aContent
.
AsText
(
)
)
-
>
TextIsOnlyWhitespace
(
)
)
{
return
true
;
}
return
false
;
}
static
uint32_t
CountChildren
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
)
{
uint32_t
count
=
0
;
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
)
)
{
break
;
}
+
+
count
;
}
return
count
;
}
static
nsIContent
*
GetAdjacentLeafContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
nsIContent
*
GetAdjacentContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetElementOfImmediateBlockBoundary
(
const
nsIContent
&
aContent
const
WalkTreeDirection
aDirection
)
;
}
;
class
MOZ_STACK_CLASS
DefinitionListItemScanner
final
{
using
Element
=
dom
:
:
Element
;
public
:
DefinitionListItemScanner
(
)
=
delete
;
explicit
DefinitionListItemScanner
(
Element
&
aDLElement
)
{
MOZ_ASSERT
(
aDLElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
for
(
nsIContent
*
child
=
aDLElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mDTFound
=
true
;
if
(
mDDFound
)
{
break
;
}
continue
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mDDFound
=
true
;
if
(
mDTFound
)
{
break
;
}
continue
;
}
}
}
bool
DTElementFound
(
)
const
{
return
mDTFound
;
}
bool
DDElementFound
(
)
const
{
return
mDDFound
;
}
private
:
bool
mDTFound
=
false
;
bool
mDDFound
=
false
;
}
;
class
MOZ_STACK_CLASS
SelectedTableCellScanner
final
{
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
public
:
SelectedTableCellScanner
(
)
=
delete
;
explicit
SelectedTableCellScanner
(
const
Selection
&
aSelection
)
{
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetFirstSelectedTableCellElement
(
aSelection
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aSelection
.
RangeCount
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
const
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
1u
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
.
RangeCount
(
)
=
=
rangeCount
)
;
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
|
|
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
)
{
continue
;
}
if
(
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
explicit
SelectedTableCellScanner
(
const
AutoRangeArray
&
aRanges
)
{
if
(
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
;
}
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
aRanges
.
FirstRangeRef
(
)
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
for
(
uint32_t
i
=
1
;
i
<
aRanges
.
Ranges
(
)
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
aRanges
.
Ranges
(
)
[
i
]
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
continue
;
}
if
(
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
bool
IsInTableCellSelectionMode
(
)
const
{
return
!
mSelectedCellElements
.
IsEmpty
(
)
;
}
const
nsTArray
<
OwningNonNull
<
Element
>
>
&
ElementsRef
(
)
const
{
return
mSelectedCellElements
;
}
Element
*
GetFirstElement
(
)
const
{
MOZ_ASSERT
(
!
mSelectedCellElements
.
IsEmpty
(
)
)
;
mIndex
=
0
;
return
!
mSelectedCellElements
.
IsEmpty
(
)
?
mSelectedCellElements
[
0
]
.
get
(
)
:
nullptr
;
}
Element
*
GetNextElement
(
)
const
{
MOZ_ASSERT
(
mIndex
<
mSelectedCellElements
.
Length
(
)
)
;
return
+
+
mIndex
<
mSelectedCellElements
.
Length
(
)
?
mSelectedCellElements
[
mIndex
]
.
get
(
)
:
nullptr
;
}
private
:
AutoTArray
<
OwningNonNull
<
Element
>
16
>
mSelectedCellElements
;
mutable
size_t
mIndex
=
0
;
}
;
}
#
endif
