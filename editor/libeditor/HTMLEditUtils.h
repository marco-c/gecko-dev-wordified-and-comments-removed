#
ifndef
HTMLEditUtils_h
#
define
HTMLEditUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsTArray
.
h
"
class
nsAtom
;
namespace
mozilla
{
enum
class
EditAction
;
class
HTMLEditUtils
final
{
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
public
:
static
const
char16_t
kSpace
=
0x0020
;
static
const
char16_t
kNBSP
=
0x00A0
;
static
bool
IsSimplyEditableNode
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsEditable
(
)
;
}
static
bool
IsRemovableNode
(
const
nsIContent
&
aContent
)
{
return
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
;
}
static
bool
IsRemovableFromParentNode
(
const
nsIContent
&
aContent
)
{
return
aContent
.
IsEditable
(
)
&
&
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
;
}
enum
class
StyleDifference
{
Ignore
CompareIfElements
CompareIfSpanElements
}
;
static
bool
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
StyleDifference
aStyleDifference
)
;
static
bool
IsBlockElement
(
const
nsIContent
&
aContent
)
;
static
bool
IsInlineElement
(
const
nsIContent
&
aContent
)
{
return
!
IsBlockElement
(
aContent
)
;
}
static
bool
IsInlineStyle
(
nsINode
*
aNode
)
;
static
bool
IsRemovableInlineStyleElement
(
dom
:
:
Element
&
aElement
)
;
static
bool
IsFormatNode
(
nsINode
*
aNode
)
;
static
bool
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
;
static
bool
IsHeader
(
nsINode
&
aNode
)
;
static
bool
IsListItem
(
nsINode
*
aNode
)
;
static
bool
IsTable
(
nsINode
*
aNode
)
;
static
bool
IsTableRow
(
nsINode
*
aNode
)
;
static
bool
IsAnyTableElement
(
nsINode
*
aNode
)
;
static
bool
IsAnyTableElementButNotTable
(
nsINode
*
aNode
)
;
static
bool
IsTableCell
(
nsINode
*
node
)
;
static
bool
IsTableCellOrCaption
(
nsINode
&
aNode
)
;
static
bool
IsAnyListElement
(
nsINode
*
aNode
)
;
static
bool
IsPre
(
nsINode
*
aNode
)
;
static
bool
IsImage
(
nsINode
*
aNode
)
;
static
bool
IsLink
(
nsINode
*
aNode
)
;
static
bool
IsNamedAnchor
(
nsINode
*
aNode
)
;
static
bool
IsMozDiv
(
nsINode
*
aNode
)
;
static
bool
IsMailCite
(
nsINode
*
aNode
)
;
static
bool
IsFormWidget
(
nsINode
*
aNode
)
;
static
bool
SupportsAlignAttr
(
nsINode
&
aNode
)
;
static
bool
CanNodeContain
(
const
nsINode
&
aParent
const
nsIContent
&
aChild
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChild
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsINode
&
aParent
nsAtom
&
aChildNodeName
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChildNodeName
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
const
nsIContent
&
aChild
)
{
switch
(
aChild
.
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
aParentNodeName
*
aChild
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
nsAtom
&
aChildNodeName
)
{
nsHTMLTag
childTagEnum
;
if
(
&
aChildNodeName
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildNodeName
)
;
}
nsHTMLTag
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentNodeName
)
;
return
HTMLEditUtils
:
:
CanNodeContain
(
parentTagEnum
childTagEnum
)
;
}
static
bool
CanElementContainParagraph
(
const
Element
&
aElement
)
{
if
(
HTMLEditUtils
:
:
CanNodeContain
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsContainerNode
(
const
nsIContent
&
aContent
)
{
nsHTMLTag
tagEnum
;
if
(
aContent
.
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aContent
.
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
tagEnum
)
;
}
static
bool
IsSplittableNode
(
const
nsIContent
&
aContent
)
{
if
(
aContent
.
IsElement
(
)
)
{
return
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
;
}
return
aContent
.
IsText
(
)
&
&
aContent
.
Length
(
)
>
0
;
}
static
bool
IsNonListSingleLineContainer
(
nsINode
&
aNode
)
;
static
bool
IsSingleLineContainer
(
nsINode
&
aNode
)
;
template
<
typename
PT
typename
CT
>
static
bool
IsPointAtEdgeOfLink
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
return
false
;
}
if
(
!
aPoint
.
IsStartOfContainer
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
false
;
}
bool
maybeStartOfAnchor
=
aPoint
.
IsStartOfContainer
(
)
;
for
(
EditorRawDOMPoint
point
(
aPoint
.
GetContainer
(
)
)
;
point
.
IsSet
(
)
&
&
(
maybeStartOfAnchor
?
point
.
IsStartOfContainer
(
)
:
point
.
IsAtLastContent
(
)
)
;
point
.
Set
(
point
.
GetContainer
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
point
.
GetContainer
(
)
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
point
.
ContainerAsElement
(
)
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
static
bool
IsContentInclusiveDescendantOfLink
(
nsIContent
&
aContent
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
element
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
element
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
template
<
typename
EditorDOMRangeType
>
static
bool
IsRangeEntirelyInLink
(
const
EditorDOMRangeType
&
aRange
Element
*
*
aFoundLinkElement
=
nullptr
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
nsINode
*
commonAncestorNode
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
aRange
.
StartRef
(
)
.
GetContainer
(
)
aRange
.
EndRef
(
)
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
commonAncestorNode
)
|
|
!
commonAncestorNode
-
>
IsContent
(
)
)
{
return
false
;
}
return
IsContentInclusiveDescendantOfLink
(
*
commonAncestorNode
-
>
AsContent
(
)
aFoundLinkElement
)
;
}
enum
class
LeafNodeType
{
OnlyLeafNode
LeafNodeOrChildBlock
LeafNodeOrNonEditableNode
}
;
using
LeafNodeTypes
=
EnumSet
<
LeafNodeType
>
;
static
nsIContent
*
GetLastLeafChild
(
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
)
{
for
(
nsIContent
*
content
=
aNode
.
GetLastChild
(
)
;
content
;
content
=
content
-
>
GetLastChild
(
)
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aNode
.
IsEditable
(
)
&
&
!
content
-
>
IsEditable
(
)
)
{
return
content
;
}
}
return
nullptr
;
}
static
nsIContent
*
GetFirstLeafChild
(
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
)
{
for
(
nsIContent
*
content
=
aNode
.
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetFirstChild
(
)
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aNode
.
IsEditable
(
)
&
&
!
content
-
>
IsEditable
(
)
)
{
return
content
;
}
}
return
nullptr
;
}
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
nsIContent
&
aStartContent
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
nextContent
=
aStartContent
.
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
if
(
parentElement
=
=
aAncestorLimiter
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
nextContent
=
parentElement
-
>
GetNextSibling
(
)
;
if
(
nextContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
nextContent
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartContent
.
IsEditable
(
)
&
&
!
nextContent
-
>
IsEditable
(
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
nextContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
nextContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsText
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
ContainerAsContent
(
)
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
aStartPoint
.
GetChild
(
)
;
if
(
!
nextContent
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartPoint
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
nextContent
-
>
IsEditable
(
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
nextContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
nextContent
;
}
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
nsIContent
&
aStartContent
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
previousContent
=
aStartContent
.
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
if
(
parentElement
=
=
aAncestorLimiter
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
previousContent
=
parentElement
-
>
GetPreviousSibling
(
)
;
if
(
previousContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
previousContent
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartContent
.
IsEditable
(
)
&
&
!
previousContent
-
>
IsEditable
(
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafChild
(
*
previousContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
previousContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
nsIContent
&
aCurrentBlock
const
LeafNodeTypes
&
aLeafNodeTypes
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsText
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
ContainerAsContent
(
)
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
if
(
aStartPoint
.
IsStartOfContainer
(
)
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
&
aCurrentBlock
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
ContainerAsContent
(
)
aCurrentBlock
aLeafNodeTypes
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
previousContent
=
aStartPoint
.
GetPreviousSiblingOfChild
(
)
;
if
(
NS_WARN_IF
(
!
previousContent
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
aStartPoint
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
previousContent
-
>
IsEditable
(
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafChild
(
*
previousContent
aLeafNodeTypes
)
)
{
return
child
;
}
}
return
previousContent
;
}
enum
class
InvisibleWhiteSpaces
{
Ignore
Preserve
}
;
enum
class
TableBoundary
{
Ignore
NoCrossTableElement
NoCrossAnyTableElement
}
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
static
Element
*
GetAncestorBlockElement
(
const
nsIContent
&
aContent
const
nsINode
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
aContent
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
"
aContent
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
)
)
{
return
element
;
}
if
(
element
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
}
return
nullptr
;
}
static
Element
*
GetInclusiveAncestorBlockElement
(
const
nsIContent
&
aContent
const
nsINode
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
aContent
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
"
aContent
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
!
aContent
.
IsContent
(
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
return
GetAncestorBlockElement
(
aContent
aAncestorLimiter
)
;
}
static
Element
*
GetInclusiveAncestorBlockElementExceptHRElement
(
const
nsIContent
&
aContent
const
nsINode
*
aAncestorLimiter
=
nullptr
)
{
Element
*
blockElement
=
GetInclusiveAncestorBlockElement
(
aContent
aAncestorLimiter
)
;
if
(
!
blockElement
|
|
!
blockElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
blockElement
;
}
if
(
!
blockElement
-
>
GetParentElement
(
)
)
{
return
nullptr
;
}
return
GetInclusiveAncestorBlockElementExceptHRElement
(
*
blockElement
-
>
GetParentElement
(
)
aAncestorLimiter
)
;
}
static
Element
*
GetInclusiveAncestorEditableBlockElementOrInlineEditingHost
(
nsIContent
&
aContent
)
;
static
Element
*
GetClosestAncestorTableElement
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
GetParent
(
)
)
{
return
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
static
Element
*
GetClosestAncestorAnyListElement
(
const
nsIContent
&
aContent
)
;
static
Element
*
GetMostDistantAnscestorEditableEmptyInlineElement
(
const
nsIContent
&
aEmptyContent
const
Element
*
aEditingHost
=
nullptr
)
{
nsIContent
*
lastEmptyContent
=
const_cast
<
nsIContent
*
>
(
&
aEmptyContent
)
;
for
(
Element
*
element
=
aEmptyContent
.
GetParentElement
(
)
;
element
&
&
element
!
=
aEditingHost
&
&
HTMLEditUtils
:
:
IsInlineElement
(
*
element
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
element
)
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
element
-
>
GetChildCount
(
)
>
1
)
{
for
(
const
nsIContent
*
child
=
element
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
lastEmptyContent
|
|
child
-
>
IsComment
(
)
)
{
continue
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
lastEmptyContent
-
>
AsElement
(
)
:
nullptr
;
}
}
lastEmptyContent
=
element
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
lastEmptyContent
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetElementIfOnlyOneSelected
(
const
dom
:
:
AbstractRange
&
aRange
)
{
if
(
!
aRange
.
IsPositioned
(
)
|
|
aRange
.
Collapsed
(
)
)
{
return
nullptr
;
}
const
RangeBoundary
&
start
=
aRange
.
StartRef
(
)
;
const
RangeBoundary
&
end
=
aRange
.
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
start
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
end
.
IsSetAndValid
(
)
)
|
|
start
.
Container
(
)
!
=
end
.
Container
(
)
)
{
return
nullptr
;
}
nsIContent
*
childAtStart
=
start
.
GetChildAtOffset
(
)
;
if
(
!
childAtStart
|
|
!
childAtStart
-
>
IsElement
(
)
)
{
return
nullptr
;
}
if
(
childAtStart
-
>
GetNextSibling
(
)
)
{
return
childAtStart
-
>
GetNextSibling
(
)
=
=
end
.
GetChildAtOffset
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
return
!
end
.
GetChildAtOffset
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetTableCellElementIfOnlyOneSelected
(
const
dom
:
:
AbstractRange
&
aRange
)
{
Element
*
element
=
HTMLEditUtils
:
:
GetElementIfOnlyOneSelected
(
aRange
)
;
return
element
&
&
HTMLEditUtils
:
:
IsTableCell
(
element
)
?
element
:
nullptr
;
}
static
Element
*
GetFirstSelectedTableCellElement
(
const
Selection
&
aSelection
)
{
if
(
!
aSelection
.
RangeCount
(
)
)
{
return
nullptr
;
}
const
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
|
|
NS_WARN_IF
(
!
firstRange
-
>
IsPositioned
(
)
)
)
{
return
nullptr
;
}
return
GetTableCellElementIfOnlyOneSelected
(
*
firstRange
)
;
}
static
bool
IsInTableCellSelectionMode
(
const
Selection
&
aSelection
)
{
return
GetFirstSelectedTableCellElement
(
aSelection
)
!
=
nullptr
;
}
static
EditAction
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForInsert
(
const
Element
&
aElement
)
;
static
EditAction
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
;
static
EditAction
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
;
static
Maybe
<
uint32_t
>
GetPreviousCharOffsetExceptASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetPreviousCharOffsetExceptASCIIWhiteSpaces
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
static
Maybe
<
uint32_t
>
GetPreviousCharOffsetExceptASCIIWhiteSpaces
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
)
{
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
;
i
;
i
-
-
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
-
1
)
)
)
{
return
Some
(
i
-
1
)
;
}
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
GetNextCharOffsetExceptASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetNextCharOffsetExceptASCIIWhiteSpaces
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
static
Maybe
<
uint32_t
>
GetNextCharOffsetExceptASCIIWhiteSpaces
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
)
{
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
+
1
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
)
)
)
{
return
Some
(
i
)
;
}
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
GetPreviousCharOffsetExceptWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetPreviousCharOffsetExceptWhiteSpaces
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
static
Maybe
<
uint32_t
>
GetPreviousCharOffsetExceptWhiteSpaces
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
)
{
if
(
!
aOffset
)
{
return
Nothing
(
)
;
}
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
;
i
;
i
-
-
)
{
char16_t
ch
=
textFragment
.
CharAt
(
i
-
1
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
ch
)
&
&
ch
!
=
kNBSP
)
{
return
Some
(
i
-
1
)
;
}
}
return
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
GetInclusiveNextCharOffsetExceptWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetInclusiveNextCharOffsetExceptWhiteSpaces
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
static
Maybe
<
uint32_t
>
GetInclusiveNextCharOffsetExceptWhiteSpaces
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
)
{
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aOffset
<
=
textFragment
.
GetLength
(
)
)
;
for
(
uint32_t
i
=
aOffset
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
char16_t
ch
=
textFragment
.
CharAt
(
i
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
ch
)
&
&
ch
!
=
kNBSP
)
{
return
Some
(
i
)
;
}
}
return
Nothing
(
)
;
}
static
uint32_t
GetFirstASCIIWhiteSpaceOffsetCollapsedWith
(
const
EditorDOMPointInText
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
aPoint
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsCharASCIISpace
(
)
)
;
return
GetFirstASCIIWhiteSpaceOffsetCollapsedWith
(
*
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
static
uint32_t
GetFirstASCIIWhiteSpaceOffsetCollapsedWith
(
const
dom
:
:
Text
&
aTextNode
uint32_t
aOffset
)
{
MOZ_ASSERT
(
aOffset
<
aTextNode
.
TextLength
(
)
)
;
MOZ_ASSERT
(
nsCRT
:
:
IsAsciiSpace
(
aTextNode
.
TextFragment
(
)
.
CharAt
(
aOffset
)
)
)
;
if
(
!
aOffset
)
{
return
0
;
}
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
GetPreviousCharOffsetExceptASCIIWhiteSpaces
(
aTextNode
aOffset
)
;
return
previousVisibleCharOffset
.
isSome
(
)
?
previousVisibleCharOffset
.
value
(
)
+
1
:
0
;
}
private
:
static
bool
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
;
static
bool
IsContainerNode
(
nsHTMLTag
aTagId
)
;
static
bool
CanCrossContentBoundary
(
nsIContent
&
aContent
TableBoundary
aHowToTreatTableBoundary
)
{
const
bool
cannotCrossBoundary
=
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossAnyTableElement
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
)
|
|
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossTableElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
return
!
cannotCrossBoundary
;
}
}
;
class
MOZ_STACK_CLASS
DefinitionListItemScanner
final
{
public
:
DefinitionListItemScanner
(
)
=
delete
;
explicit
DefinitionListItemScanner
(
dom
:
:
Element
&
aDLElement
)
{
MOZ_ASSERT
(
aDLElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
for
(
nsIContent
*
child
=
aDLElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mDTFound
=
true
;
if
(
mDDFound
)
{
break
;
}
continue
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mDDFound
=
true
;
if
(
mDTFound
)
{
break
;
}
continue
;
}
}
}
bool
DTElementFound
(
)
const
{
return
mDTFound
;
}
bool
DDElementFound
(
)
const
{
return
mDDFound
;
}
private
:
bool
mDTFound
=
false
;
bool
mDDFound
=
false
;
}
;
class
MOZ_STACK_CLASS
SelectedTableCellScanner
final
{
public
:
SelectedTableCellScanner
(
)
=
delete
;
explicit
SelectedTableCellScanner
(
const
dom
:
:
Selection
&
aSelection
)
{
dom
:
:
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetFirstSelectedTableCellElement
(
aSelection
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aSelection
.
RangeCount
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
for
(
uint32_t
i
=
1
;
i
<
aSelection
.
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
continue
;
}
if
(
dom
:
:
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
explicit
SelectedTableCellScanner
(
const
AutoRangeArray
&
aRanges
)
{
if
(
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
;
}
dom
:
:
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
aRanges
.
FirstRangeRef
(
)
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
for
(
uint32_t
i
=
1
;
i
<
aRanges
.
Ranges
(
)
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
aRanges
.
Ranges
(
)
[
i
]
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
continue
;
}
if
(
dom
:
:
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
bool
IsInTableCellSelectionMode
(
)
const
{
return
!
mSelectedCellElements
.
IsEmpty
(
)
;
}
const
nsTArray
<
OwningNonNull
<
dom
:
:
Element
>
>
&
ElementsRef
(
)
const
{
return
mSelectedCellElements
;
}
dom
:
:
Element
*
GetFirstElement
(
)
const
{
MOZ_ASSERT
(
!
mSelectedCellElements
.
IsEmpty
(
)
)
;
mIndex
=
0
;
return
!
mSelectedCellElements
.
IsEmpty
(
)
?
mSelectedCellElements
[
0
]
.
get
(
)
:
nullptr
;
}
dom
:
:
Element
*
GetNextElement
(
)
const
{
MOZ_ASSERT
(
mIndex
<
mSelectedCellElements
.
Length
(
)
)
;
return
+
+
mIndex
<
mSelectedCellElements
.
Length
(
)
?
mSelectedCellElements
[
mIndex
]
.
get
(
)
:
nullptr
;
}
private
:
AutoTArray
<
OwningNonNull
<
dom
:
:
Element
>
16
>
mSelectedCellElements
;
mutable
size_t
mIndex
=
0
;
}
;
}
#
endif
