#
ifndef
HTMLEditUtils_h
#
define
HTMLEditUtils_h
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
EditorLineBreak
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
CharacterDataBuffer
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsTArray
.
h
"
class
nsAtom
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
CollectChildrenOption
{
IgnoreNonEditableChildren
IgnoreInvisibleTextNodes
CollectListChildren
CollectTableChildren
}
;
class
HTMLEditUtils
final
{
using
AbstractRange
=
dom
:
:
AbstractRange
;
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
using
Text
=
dom
:
:
Text
;
using
WhitespaceOption
=
dom
:
:
CharacterDataBuffer
:
:
WhitespaceOption
;
using
WhitespaceOptions
=
dom
:
:
CharacterDataBuffer
:
:
WhitespaceOptions
;
public
:
static
constexpr
char16_t
kNewLine
=
'
\
n
'
;
static
constexpr
char16_t
kCarriageReturn
=
'
\
r
'
;
static
constexpr
char16_t
kTab
=
'
\
t
'
;
static
constexpr
char16_t
kSpace
=
'
'
;
static
constexpr
char16_t
kNBSP
=
0x00A0
;
static
constexpr
char16_t
kGreaterThan
=
'
>
'
;
static
bool
IsSimplyEditableNode
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsEditable
(
)
;
}
static
bool
NodeIsEditableOrNotInComposedDoc
(
const
nsINode
&
aNode
)
{
return
MOZ_UNLIKELY
(
!
aNode
.
IsInComposedDoc
(
)
)
|
|
aNode
.
IsEditable
(
)
;
}
[
[
nodiscard
]
]
static
bool
ElementIsEditableRoot
(
const
Element
&
aElement
)
;
static
bool
ContentIsInert
(
const
nsIContent
&
aContent
)
;
static
bool
IsNeverElementContentsEditableByUser
(
const
nsIContent
&
aContent
)
{
return
aContent
.
IsElement
(
)
&
&
(
!
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
|
|
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
applet
nsGkAtoms
:
:
colgroup
nsGkAtoms
:
:
frameset
nsGkAtoms
:
:
head
nsGkAtoms
:
:
html
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
;
}
static
bool
IsNonEditableReplacedContent
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
select
nsGkAtoms
:
:
option
nsGkAtoms
:
:
optgroup
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
IsRemovableNode
(
const
nsIContent
&
aContent
)
{
return
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
aContent
)
|
|
aContent
.
IsRootOfNativeAnonymousSubtree
(
)
|
|
(
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
)
;
}
static
bool
IsRemovableFromParentNode
(
const
nsIContent
&
aContent
)
{
return
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
aContent
)
|
|
aContent
.
IsRootOfNativeAnonymousSubtree
(
)
|
|
(
aContent
.
IsEditable
(
)
&
&
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
&
&
&
aContent
!
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
)
;
}
static
bool
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
)
;
[
[
nodiscard
]
]
static
bool
IsBlockElement
(
const
nsIContent
&
aContent
BlockInlineCheck
aBlockInlineCheck
)
;
[
[
nodiscard
]
]
static
bool
IsInlineContent
(
const
nsIContent
&
aContent
BlockInlineCheck
aBlockInlineCheck
)
;
static
bool
IsVisibleElementEvenIfLeafNode
(
const
nsIContent
&
aContent
)
;
static
bool
IsInlineStyle
(
nsINode
*
aNode
)
;
[
[
nodiscard
]
]
static
bool
IsDisplayOutsideInline
(
const
Element
&
aElement
)
;
[
[
nodiscard
]
]
static
bool
IsDisplayInsideFlowRoot
(
const
Element
&
aElement
)
;
[
[
nodiscard
]
]
static
bool
IsFlexOrGridItem
(
const
Element
&
aElement
)
;
static
bool
IsRemovableInlineStyleElement
(
Element
&
aElement
)
;
[
[
nodiscard
]
]
static
bool
IsFormatTagForFormatBlockCommand
(
const
nsStaticAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
address
|
|
&
aTagName
=
=
nsGkAtoms
:
:
article
|
|
&
aTagName
=
=
nsGkAtoms
:
:
aside
|
|
&
aTagName
=
=
nsGkAtoms
:
:
blockquote
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aTagName
=
=
nsGkAtoms
:
:
div
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dt
|
|
&
aTagName
=
=
nsGkAtoms
:
:
footer
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h1
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h2
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h3
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h4
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h5
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h6
|
|
&
aTagName
=
=
nsGkAtoms
:
:
header
|
|
&
aTagName
=
=
nsGkAtoms
:
:
hgroup
|
|
&
aTagName
=
=
nsGkAtoms
:
:
main
|
|
&
aTagName
=
=
nsGkAtoms
:
:
nav
|
|
&
aTagName
=
=
nsGkAtoms
:
:
p
|
|
&
aTagName
=
=
nsGkAtoms
:
:
pre
|
|
&
aTagName
=
=
nsGkAtoms
:
:
section
;
}
[
[
nodiscard
]
]
static
bool
IsFormatElementForFormatBlockCommand
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsHTMLElement
(
)
|
|
!
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
IsStatic
(
)
)
{
return
false
;
}
const
nsStaticAtom
*
tagName
=
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
AsStatic
(
)
;
return
IsFormatTagForFormatBlockCommand
(
*
tagName
)
;
}
[
[
nodiscard
]
]
static
bool
IsFormatTagForParagraphStateCommand
(
const
nsStaticAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
address
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dt
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h1
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h2
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h3
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h4
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h5
|
|
&
aTagName
=
=
nsGkAtoms
:
:
h6
|
|
&
aTagName
=
=
nsGkAtoms
:
:
p
|
|
&
aTagName
=
=
nsGkAtoms
:
:
pre
;
}
[
[
nodiscard
]
]
static
bool
IsFormatElementForParagraphStateCommand
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsHTMLElement
(
)
|
|
!
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
IsStatic
(
)
)
{
return
false
;
}
const
nsStaticAtom
*
tagName
=
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
AsStatic
(
)
;
return
IsFormatTagForParagraphStateCommand
(
*
tagName
)
;
}
static
bool
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
;
static
bool
IsHeader
(
nsINode
&
aNode
)
;
static
bool
IsListItem
(
const
nsINode
*
aNode
)
;
static
bool
IsTable
(
const
nsINode
*
aNode
)
;
static
bool
IsTableRow
(
nsINode
*
aNode
)
;
static
bool
IsAnyTableElement
(
const
nsINode
*
aNode
)
;
static
bool
IsAnyTableElementButNotTable
(
const
nsINode
*
aNode
)
;
static
bool
IsTableCell
(
const
nsINode
*
aNode
)
;
static
bool
IsTableCellOrCaption
(
nsINode
&
aNode
)
;
static
bool
IsAnyListElement
(
const
nsINode
*
aNode
)
;
static
bool
IsPre
(
const
nsINode
*
aNode
)
;
static
bool
IsImage
(
nsINode
*
aNode
)
;
static
bool
IsLink
(
const
nsINode
*
aNode
)
;
static
bool
IsNamedAnchor
(
const
nsINode
*
aNode
)
;
static
bool
IsMozDiv
(
const
nsINode
*
aNode
)
;
static
bool
IsMailCite
(
const
Element
&
aElement
)
;
static
bool
IsFormWidget
(
const
nsINode
*
aNode
)
;
static
bool
SupportsAlignAttr
(
nsINode
&
aNode
)
;
static
bool
CanNodeContain
(
const
nsINode
&
aParent
const
nsIContent
&
aChild
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChild
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsINode
&
aParent
const
nsAtom
&
aChildNodeName
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChildNodeName
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsAtom
&
aParentNodeName
const
nsIContent
&
aChild
)
{
switch
(
aChild
.
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
COMMENT_NODE
:
case
nsINode
:
:
CDATA_SECTION_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
aParentNodeName
*
aChild
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsAtom
&
aParentNodeName
const
nsAtom
&
aChildNodeName
)
{
nsHTMLTag
childTagEnum
;
if
(
&
aChildNodeName
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
if
(
&
aChildNodeName
=
=
nsGkAtoms
:
:
commentTagName
|
|
&
aChildNodeName
=
=
nsGkAtoms
:
:
cdataTagName
)
{
childTagEnum
=
eHTMLTag_comment
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
const_cast
<
nsAtom
*
>
(
&
aChildNodeName
)
)
;
}
nsHTMLTag
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
const_cast
<
nsAtom
*
>
(
&
aParentNodeName
)
)
;
return
HTMLEditUtils
:
:
CanNodeContain
(
parentTagEnum
childTagEnum
)
;
}
static
bool
CanElementContainParagraph
(
const
Element
&
aElement
)
{
if
(
HTMLEditUtils
:
:
CanNodeContain
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
template
<
typename
EditorDOMPointType
>
static
EditorDOMPoint
GetInsertionPointInInclusiveAncestor
(
const
nsAtom
&
aTagName
const
EditorDOMPointType
&
aPoint
const
Element
*
aAncestorLimit
=
nullptr
)
{
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
Element
*
lastChild
=
nullptr
;
for
(
Element
*
containerElement
:
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
-
>
template
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
containerElement
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
containerElement
aTagName
)
)
{
return
lastChild
?
EditorDOMPoint
(
lastChild
)
:
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
}
if
(
containerElement
=
=
aAncestorLimit
)
{
return
EditorDOMPoint
(
)
;
}
lastChild
=
containerElement
;
}
return
EditorDOMPoint
(
)
;
}
static
bool
IsContainerNode
(
const
nsIContent
&
aContent
)
{
nsHTMLTag
tagEnum
;
if
(
aContent
.
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aContent
.
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
tagEnum
)
;
}
static
bool
IsSplittableNode
(
const
nsIContent
&
aContent
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorUtils
:
:
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
aContent
)
)
{
return
false
;
}
if
(
aContent
.
IsElement
(
)
)
{
return
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
&
&
!
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
button
nsGkAtoms
:
:
caption
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tr
)
&
&
!
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
aContent
)
&
&
!
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
aContent
)
;
}
return
aContent
.
IsText
(
)
&
&
aContent
.
Length
(
)
>
0
;
}
static
bool
IsNonListSingleLineContainer
(
const
nsINode
&
aNode
)
;
static
bool
IsSingleLineContainer
(
const
nsINode
&
aNode
)
;
[
[
nodiscard
]
]
static
bool
TextHasOnlyOnePreformattedLinefeed
(
const
Text
&
aText
)
{
return
aText
.
TextDataLength
(
)
=
=
1u
&
&
aText
.
DataBuffer
(
)
.
CharAt
(
0u
)
=
=
kNewLine
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
aText
)
;
}
[
[
nodiscard
]
]
static
bool
IsVisibleTextNode
(
const
Text
&
aText
)
;
static
bool
IsInVisibleTextFrames
(
nsPresContext
*
aPresContext
const
Text
&
aText
)
;
static
bool
IsVisibleBRElement
(
const
nsIContent
&
aContent
)
{
if
(
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
)
{
return
IsVisibleBRElement
(
*
brElement
)
;
}
return
false
;
}
static
bool
IsVisibleBRElement
(
const
dom
:
:
HTMLBRElement
&
aBRElement
)
{
return
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aBRElement
WalkTreeDirection
:
:
Forward
)
;
}
static
bool
IsInvisibleBRElement
(
const
nsIContent
&
aContent
)
{
if
(
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
)
{
return
IsInvisibleBRElement
(
*
brElement
)
;
}
return
false
;
}
static
bool
IsInvisibleBRElement
(
const
dom
:
:
HTMLBRElement
&
aBRElement
)
{
return
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
aBRElement
)
;
}
enum
class
IgnoreInvisibleLineBreak
{
No
Yes
}
;
template
<
typename
PT
typename
CT
>
[
[
nodiscard
]
]
static
bool
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
;
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
bool
RangeIsAcrossStartBlockBoundary
(
const
EditorDOMRangeBase
<
EditorDOMPointType
>
&
aRange
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aRange
.
StartRef
(
)
.
IsInContentNode
(
)
)
)
{
return
false
;
}
const
Element
*
const
startBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRange
.
StartRef
(
)
.
template
ContainerAs
<
nsIContent
>
(
)
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
MOZ_UNLIKELY
(
!
startBlockElement
)
)
{
return
false
;
}
return
EditorRawDOMPoint
:
:
After
(
*
startBlockElement
)
.
EqualsOrIsBefore
(
aRange
.
EndRef
(
)
)
;
}
static
bool
IsInclusiveAncestorCSSDisplayNone
(
const
nsIContent
&
aContent
)
;
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
bool
IsVisiblePreformattedNewLine
(
const
EditorDOMPointType
&
aPoint
Element
*
*
aFollowingBlockElement
=
nullptr
)
{
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
nullptr
;
}
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
aPoint
.
IsCharPreformattedNewLine
(
)
)
{
return
false
;
}
if
(
!
aPoint
.
IsAtLastContent
(
)
)
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
{
return
true
;
}
const
dom
:
:
CharacterDataBuffer
&
characterDataBuffer
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
DataBuffer
(
)
;
const
uint32_t
nextVisibleCharOffset
=
characterDataBuffer
.
FindNonWhitespaceChar
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
?
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
WhitespaceOption
:
:
NewLineIsSignificant
}
:
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
}
aPoint
.
Offset
(
)
+
1
)
;
if
(
nextVisibleCharOffset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
)
{
return
true
;
}
}
Element
*
followingBlockElement
=
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
WalkTreeDirection
:
:
Forward
)
;
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
followingBlockElement
;
}
return
!
followingBlockElement
;
}
template
<
typename
EditorDOMPointType
>
static
bool
IsInvisiblePreformattedNewLine
(
const
EditorDOMPointType
&
aPoint
Element
*
*
aFollowingBlockElement
=
nullptr
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
aPoint
.
IsCharPreformattedNewLine
(
)
)
{
if
(
aFollowingBlockElement
)
{
*
aFollowingBlockElement
=
nullptr
;
}
return
false
;
}
return
!
IsVisiblePreformattedNewLine
(
aPoint
aFollowingBlockElement
)
;
}
template
<
typename
PT
typename
CT
>
static
EditorDOMPoint
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
Element
&
aEditingHost
)
;
static
bool
ShouldInsertLinefeedCharacter
(
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
enum
class
EmptyCheckOption
{
TreatSingleBRElementAsVisible
TreatBlockAsVisible
TreatListItemAsVisible
TreatTableCellAsVisible
TreatNonEditableContentAsInvisible
SafeToAskLayout
}
;
using
EmptyCheckOptions
=
EnumSet
<
EmptyCheckOption
uint32_t
>
;
static
bool
IsEmptyNode
(
nsPresContext
*
aPresContext
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
=
{
}
bool
*
aSeenBR
=
nullptr
)
;
static
bool
IsEmptyNode
(
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
=
{
}
bool
*
aSeenBR
=
nullptr
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
)
;
return
IsEmptyNode
(
nullptr
aNode
aOptions
aSeenBR
)
;
}
static
bool
IsEmptyInlineContainer
(
const
nsIContent
&
aContent
const
EmptyCheckOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
)
{
return
HTMLEditUtils
:
:
IsInlineContent
(
aContent
aBlockInlineCheck
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
aContent
aOptions
)
;
}
static
bool
IsEmptyBlockElement
(
const
Element
&
aElement
const
EmptyCheckOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
)
{
return
HTMLEditUtils
:
:
IsBlockElement
(
aElement
aBlockInlineCheck
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
aOptions
)
;
}
[
[
nodiscard
]
]
static
bool
IsEmptyAnyListElement
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
bool
foundListItem
=
false
;
for
(
nsIContent
*
child
=
aListElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
if
(
foundListItem
)
{
return
false
;
}
if
(
!
IsEmptyNode
(
*
child
{
}
)
)
{
return
false
;
}
foundListItem
=
true
;
continue
;
}
if
(
child
-
>
IsElement
(
)
)
{
return
false
;
}
if
(
child
-
>
IsText
(
)
&
&
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
child
-
>
AsText
(
)
)
)
{
return
false
;
}
}
return
true
;
}
enum
class
TreatSubListElementAs
{
Invalid
Valid
}
;
[
[
nodiscard
]
]
static
bool
IsValidListElement
(
const
Element
&
aListElement
TreatSubListElementAs
aTreatSubListElementAs
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
for
(
nsIContent
*
child
=
aListElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
child
)
)
{
if
(
aTreatSubListElementAs
=
=
TreatSubListElementAs
:
:
Invalid
)
{
return
false
;
}
continue
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
MOZ_UNLIKELY
(
!
aListElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
)
)
)
{
return
false
;
}
continue
;
}
if
(
child
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
if
(
MOZ_UNLIKELY
(
!
aListElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
)
)
)
{
return
false
;
}
continue
;
}
if
(
MOZ_UNLIKELY
(
child
-
>
IsElement
(
)
)
)
{
return
false
;
}
if
(
MOZ_LIKELY
(
child
-
>
IsText
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
child
-
>
AsText
(
)
)
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
IsEmptyOneHardLine
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
BlockInlineCheck
aBlockInlineCheck
)
{
if
(
NS_WARN_IF
(
aArrayOfContents
.
IsEmpty
(
)
)
)
{
return
true
;
}
bool
brElementHasFound
=
false
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
brElementHasFound
)
{
return
false
;
}
brElementHasFound
=
true
;
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
aBlockInlineCheck
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
PT
typename
CT
>
static
bool
IsPointAtEdgeOfLink
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
return
false
;
}
if
(
!
aPoint
.
IsStartOfContainer
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
false
;
}
bool
maybeStartOfAnchor
=
aPoint
.
IsStartOfContainer
(
)
;
for
(
EditorRawDOMPoint
point
(
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
;
point
.
IsSet
(
)
&
&
(
maybeStartOfAnchor
?
point
.
IsStartOfContainer
(
)
:
point
.
IsAtLastContent
(
)
)
;
point
=
point
.
ParentPoint
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
point
.
GetContainer
(
)
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
point
.
template
ContainerAs
<
Element
>
(
)
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
static
bool
IsContentInclusiveDescendantOfLink
(
nsIContent
&
aContent
Element
*
*
aFoundLinkElement
=
nullptr
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
element
)
)
{
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
do_AddRef
(
element
)
.
take
(
)
;
}
return
true
;
}
}
return
false
;
}
template
<
typename
EditorDOMRangeType
>
static
bool
IsRangeEntirelyInLink
(
const
EditorDOMRangeType
&
aRange
Element
*
*
aFoundLinkElement
=
nullptr
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
if
(
aFoundLinkElement
)
{
*
aFoundLinkElement
=
nullptr
;
}
nsINode
*
commonAncestorNode
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
aRange
.
StartRef
(
)
.
GetContainer
(
)
aRange
.
EndRef
(
)
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
commonAncestorNode
)
|
|
!
commonAncestorNode
-
>
IsContent
(
)
)
{
return
false
;
}
return
IsContentInclusiveDescendantOfLink
(
*
commonAncestorNode
-
>
AsContent
(
)
aFoundLinkElement
)
;
}
enum
class
WalkTreeOption
{
IgnoreNonEditableNode
IgnoreDataNodeExceptText
IgnoreWhiteSpaceOnlyText
StopAtBlockBoundary
}
;
using
WalkTreeOptions
=
EnumSet
<
WalkTreeOption
>
;
static
nsIContent
*
GetPreviousContent
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aNode
=
=
aAncestorLimiter
|
|
(
aAncestorLimiter
&
&
!
aNode
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
aNode
WalkTreeDirection
:
:
Backward
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
static
nsIContent
*
GetNextContent
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aNode
=
=
aAncestorLimiter
|
|
(
aAncestorLimiter
&
&
!
aNode
.
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
aNode
WalkTreeDirection
:
:
Forward
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetPreviousContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetNextContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
nsIContent
*
GetPreviousSibling
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
for
(
nsIContent
*
sibling
=
aContent
.
GetPreviousSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetPreviousSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
sibling
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
sibling
;
}
return
nullptr
;
}
static
nsIContent
*
GetNextSibling
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
for
(
nsIContent
*
sibling
=
aContent
.
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
sibling
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
sibling
;
}
return
nullptr
;
}
static
nsIContent
*
GetLastChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
for
(
nsIContent
*
child
=
aNode
.
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
child
;
}
return
nullptr
;
}
static
nsIContent
*
GetFirstChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
child
;
}
return
nullptr
;
}
static
bool
IsLastChild
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
nsINode
*
parentNode
=
aContent
.
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
false
;
}
return
HTMLEditUtils
:
:
GetLastChild
(
*
parentNode
aOptions
aBlockInlineCheck
)
=
=
&
aContent
;
}
static
bool
IsFirstChild
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
)
{
nsINode
*
parentNode
=
aContent
.
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
false
;
}
return
HTMLEditUtils
:
:
GetFirstChild
(
*
parentNode
aOptions
aBlockInlineCheck
)
=
=
&
aContent
;
}
enum
class
WalkTreeDirection
{
Forward
Backward
}
;
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetAdjacentContentToPutCaret
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
WalkTreeDirection
aWalkTreeDirection
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
editableContent
=
nullptr
;
if
(
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Backward
)
{
editableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
aPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
aEditingHost
)
;
if
(
!
editableContent
)
{
return
nullptr
;
}
}
else
{
editableContent
=
HTMLEditUtils
:
:
GetNextContent
(
aPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
while
(
editableContent
&
&
!
editableContent
-
>
IsText
(
)
&
&
!
editableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsImage
(
editableContent
)
)
{
if
(
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Backward
)
{
editableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
else
{
editableContent
=
HTMLEditUtils
:
:
GetNextContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
}
if
(
(
!
aPoint
.
IsInContentNode
(
)
&
&
!
!
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
editableContent
)
)
|
|
(
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
editableContent
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
)
{
return
nullptr
;
}
return
editableContent
;
}
enum
class
LeafNodeType
{
OnlyLeafNode
LeafNodeOrChildBlock
LeafNodeOrNonEditableNode
OnlyEditableLeafNode
}
;
using
LeafNodeTypes
=
EnumSet
<
LeafNodeType
>
;
static
nsIContent
*
GetLastLeafContent
(
const
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
aNode
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
aNode
.
AsElement
(
)
)
)
{
return
nullptr
;
}
for
(
nsIContent
*
content
=
aNode
.
GetLastChild
(
)
;
content
;
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
content
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aBlockInlineCheck
aAncestorLimiter
)
;
continue
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
aBlockInlineCheck
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
|
|
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
content
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
content
)
)
{
return
content
;
}
content
=
content
-
>
GetLastChild
(
)
;
}
return
nullptr
;
}
static
nsIContent
*
GetFirstLeafContent
(
const
nsINode
&
aNode
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
=
BlockInlineCheck
:
:
Unused
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
aNode
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
aNode
.
AsElement
(
)
)
)
{
return
nullptr
;
}
for
(
nsIContent
*
content
=
aNode
.
GetFirstChild
(
)
;
content
;
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
content
=
HTMLEditUtils
:
:
GetNextContent
(
*
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aBlockInlineCheck
aAncestorLimiter
)
;
continue
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
aBlockInlineCheck
)
)
{
return
content
;
}
if
(
!
content
-
>
HasChildren
(
)
|
|
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
content
)
)
{
return
content
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
content
)
)
{
return
content
;
}
content
=
content
-
>
GetFirstChild
(
)
;
}
return
nullptr
;
}
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
nsIContent
&
aStartContent
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
nextContent
=
aStartContent
.
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
aAncestorLimiter
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
parentElement
aBlockInlineCheck
)
)
{
return
nullptr
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
parentElement
-
>
IsEditable
(
)
)
{
return
nullptr
;
}
nextContent
=
parentElement
-
>
GetNextSibling
(
)
;
if
(
nextContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
nextContent
)
;
aBlockInlineCheck
=
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
aBlockInlineCheck
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
nextContent
-
>
IsEditable
(
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
nextContent
aLeafNodeTypes
aBlockInlineCheck
)
)
{
return
child
;
}
}
return
nextContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetNextLeafContentOrNextBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
Text
>
(
)
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
aStartPoint
.
GetChild
(
)
;
if
(
!
nextContent
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
aAncestorLimiter
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aLeafNodeTypes
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
aAncestorLimiter
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
aBlockInlineCheck
)
)
{
return
nextContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
return
nextContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
nextContent
aLeafNodeTypes
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
)
)
{
return
child
;
}
}
return
nextContent
;
}
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
nsIContent
&
aStartContent
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
&
aStartContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
previousContent
=
aStartContent
.
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
if
(
!
aStartContent
.
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
for
(
Element
*
parentElement
:
aStartContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
aAncestorLimiter
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
parentElement
aBlockInlineCheck
)
)
{
return
nullptr
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
parentElement
-
>
IsEditable
(
)
)
{
return
nullptr
;
}
previousContent
=
parentElement
-
>
GetPreviousSibling
(
)
;
if
(
previousContent
)
{
break
;
}
if
(
!
parentElement
-
>
GetParentElement
(
)
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
}
MOZ_ASSERT
(
previousContent
)
;
aBlockInlineCheck
=
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
aBlockInlineCheck
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousContent
aLeafNodeTypes
aBlockInlineCheck
)
)
{
return
child
;
}
}
return
previousContent
;
}
template
<
typename
PT
typename
CT
>
static
nsIContent
*
GetPreviousLeafContentOrPreviousBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartPoint
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
MOZ_ASSERT
(
aStartPoint
.
IsSet
(
)
)
;
MOZ_ASSERT_IF
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
)
;
NS_ASSERTION
(
!
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
OnlyEditableLeafNode
)
"
Not
implemented
yet
"
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
nullptr
;
}
if
(
aStartPoint
.
IsInTextNode
(
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
Text
>
(
)
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
}
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
}
if
(
aStartPoint
.
IsStartOfContainer
(
)
)
{
if
(
aStartPoint
.
GetContainer
(
)
=
=
aAncestorLimiter
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
aStartPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aLeafNodeTypes
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
aAncestorLimiter
)
;
}
nsCOMPtr
<
nsIContent
>
previousContent
=
aStartPoint
.
GetPreviousSiblingOfChild
(
)
;
if
(
NS_WARN_IF
(
!
previousContent
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
aBlockInlineCheck
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
previousContent
;
}
if
(
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousContent
aLeafNodeTypes
IgnoreInsideBlockBoundary
(
aBlockInlineCheck
)
)
)
{
return
child
;
}
}
return
previousContent
;
}
[
[
nodiscard
]
]
static
nsIContent
*
GetPreviousNonEmptyLeafContentOrPreviousBlockElement
(
const
nsIContent
&
aContent
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aContent
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
previousContent
;
}
Text
*
const
previousText
=
Text
:
:
FromNode
(
previousContent
)
;
if
(
!
previousText
)
{
if
(
!
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
previousContent
)
)
{
continue
;
}
return
previousContent
;
}
if
(
!
previousText
-
>
TextDataLength
(
)
)
{
continue
;
}
return
previousText
;
}
return
nullptr
;
}
template
<
typename
PT
typename
CT
>
[
[
nodiscard
]
]
static
nsIContent
*
GetPreviousNonEmptyLeafContentOrPreviousBlockElement
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
LeafNodeTypes
&
aLeafNodeTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
{
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
aLeafNodeTypes
aBlockInlineCheck
aAncestorLimiter
)
)
{
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrChildBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
return
previousContent
;
}
if
(
aLeafNodeTypes
.
contains
(
LeafNodeType
:
:
LeafNodeOrNonEditableNode
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
previousContent
;
}
Text
*
const
previousText
=
Text
:
:
FromNode
(
previousContent
)
;
if
(
!
previousText
)
{
if
(
!
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
previousContent
)
)
{
continue
;
}
return
previousContent
;
}
if
(
!
previousText
-
>
TextDataLength
(
)
)
{
continue
;
}
return
previousText
;
}
return
nullptr
;
}
template
<
typename
EditorDOMPointType
>
static
nsIContent
*
GetContentToPreserveInlineStyles
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditingHost
)
;
enum
class
InvisibleWhiteSpaces
{
Ignore
Preserve
}
;
enum
class
TableBoundary
{
Ignore
NoCrossTableElement
NoCrossAnyTableElement
}
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
enum
class
AncestorType
{
ClosestBlockElement
ClosestContainerElement
MostDistantInlineElementInBlock
IgnoreHRElement
ButtonElement
AllowRootOrAncestorLimiterElement
EditableElement
}
;
using
AncestorTypes
=
EnumSet
<
AncestorType
>
;
constexpr
static
AncestorTypes
ClosestEditableBlockElementOrInlineEditingHost
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
MostDistantInlineElementInBlock
AncestorType
:
:
EditableElement
}
;
constexpr
static
AncestorTypes
ClosestBlockElement
=
{
AncestorType
:
:
ClosestBlockElement
}
;
constexpr
static
AncestorTypes
ClosestEditableBlockElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
}
;
constexpr
static
AncestorTypes
ClosestBlockElementExceptHRElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
IgnoreHRElement
}
;
constexpr
static
AncestorTypes
ClosestEditableBlockElementExceptHRElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
IgnoreHRElement
AncestorType
:
:
EditableElement
}
;
constexpr
static
AncestorTypes
ClosestEditableBlockElementOrButtonElement
=
{
AncestorType
:
:
ClosestBlockElement
AncestorType
:
:
EditableElement
AncestorType
:
:
ButtonElement
}
;
static
Element
*
GetAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetInclusiveAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetClosestAncestorTableElement
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
GetParent
(
)
)
{
return
nullptr
;
}
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
static
Element
*
GetInclusiveAncestorAnyTableElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
parent
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
parent
)
)
{
return
parent
;
}
}
return
nullptr
;
}
[
[
nodiscard
]
]
static
Element
*
GetClosestAncestorAnyListElement
(
const
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
static
Element
*
GetClosestInclusiveAncestorAnyListElement
(
const
nsIContent
&
aContent
)
;
static
Element
*
GetClosestInclusiveAncestorListItemElement
(
const
nsIContent
&
aContent
const
Element
*
aAncestorLimit
=
nullptr
)
{
MOZ_ASSERT_IF
(
aAncestorLimit
aContent
.
IsInclusiveDescendantOf
(
aAncestorLimit
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
&
aContent
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
parentElement
)
)
{
return
parentElement
;
}
if
(
parentElement
=
=
aAncestorLimit
)
{
return
nullptr
;
}
}
return
nullptr
;
}
template
<
typename
EditorDOMRangeType
>
static
EditorDOMRangeType
GetRangeSelectingAllContentInAllListItems
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
Element
*
firstListItem
=
HTMLEditUtils
:
:
GetFirstListItemElement
(
aListElement
)
;
Element
*
lastListItem
=
HTMLEditUtils
:
:
GetLastListItemElement
(
aListElement
)
;
MOZ_ASSERT_IF
(
firstListItem
lastListItem
)
;
MOZ_ASSERT_IF
(
!
firstListItem
!
lastListItem
)
;
if
(
!
firstListItem
|
|
!
lastListItem
)
{
return
EditorDOMRangeType
(
)
;
}
return
EditorDOMRangeType
(
typename
EditorDOMRangeType
:
:
PointType
(
firstListItem
0u
)
EditorDOMRangeType
:
:
PointType
:
:
AtEndOf
(
*
lastListItem
)
)
;
}
static
Element
*
GetFirstListItemElement
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
for
(
nsIContent
*
maybeFirstListItem
=
aListElement
.
GetFirstChild
(
)
;
maybeFirstListItem
;
maybeFirstListItem
=
maybeFirstListItem
-
>
GetNextNode
(
&
aListElement
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
maybeFirstListItem
)
)
{
return
maybeFirstListItem
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
static
Element
*
GetLastListItemElement
(
const
Element
&
aListElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
for
(
nsIContent
*
maybeLastListItem
=
aListElement
.
GetLastChild
(
)
;
maybeLastListItem
;
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
maybeLastListItem
)
)
{
return
maybeLastListItem
-
>
AsElement
(
)
;
}
if
(
maybeLastListItem
-
>
HasChildren
(
)
)
{
maybeLastListItem
=
maybeLastListItem
-
>
GetLastChild
(
)
;
continue
;
}
if
(
maybeLastListItem
-
>
GetPreviousSibling
(
)
)
{
maybeLastListItem
=
maybeLastListItem
-
>
GetPreviousSibling
(
)
;
continue
;
}
for
(
Element
*
parent
=
maybeLastListItem
-
>
GetParentElement
(
)
;
parent
;
parent
=
parent
-
>
GetParentElement
(
)
)
{
maybeLastListItem
=
nullptr
;
if
(
parent
=
=
&
aListElement
)
{
return
nullptr
;
}
if
(
parent
-
>
GetPreviousSibling
(
)
)
{
maybeLastListItem
=
parent
-
>
GetPreviousSibling
(
)
;
break
;
}
}
}
return
nullptr
;
}
static
Element
*
GetFirstTableCellElementChild
(
const
Element
&
aTableRowElement
)
{
MOZ_ASSERT
(
aTableRowElement
.
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
firstElementChild
=
aTableRowElement
.
GetFirstElementChild
(
)
;
return
firstElementChild
&
&
HTMLEditUtils
:
:
IsTableCell
(
firstElementChild
)
?
firstElementChild
:
nullptr
;
}
static
Element
*
GetLastTableCellElementChild
(
const
Element
&
aTableRowElement
)
{
MOZ_ASSERT
(
aTableRowElement
.
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
lastElementChild
=
aTableRowElement
.
GetLastElementChild
(
)
;
return
lastElementChild
&
&
HTMLEditUtils
:
:
IsTableCell
(
lastElementChild
)
?
lastElementChild
:
nullptr
;
}
static
Element
*
GetPreviousTableCellElementSibling
(
const
nsIContent
&
aChildOfTableRow
)
{
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
previousElementSibling
=
aChildOfTableRow
.
GetPreviousElementSibling
(
)
;
return
previousElementSibling
&
&
HTMLEditUtils
:
:
IsTableCell
(
previousElementSibling
)
?
previousElementSibling
:
nullptr
;
}
static
Element
*
GetNextTableCellElementSibling
(
const
nsIContent
&
aChildOfTableRow
)
{
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aChildOfTableRow
.
GetParentNode
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
;
Element
*
nextElementSibling
=
aChildOfTableRow
.
GetNextElementSibling
(
)
;
return
nextElementSibling
&
&
HTMLEditUtils
:
:
IsTableCell
(
nextElementSibling
)
?
nextElementSibling
:
nullptr
;
}
static
nsIContent
*
GetMostDistantAncestorInlineElement
(
const
nsIContent
&
aContent
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aEditingHost
=
nullptr
const
nsIContent
*
aAncestorLimiter
=
nullptr
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContent
aBlockInlineCheck
)
)
{
return
nullptr
;
}
if
(
&
aContent
=
=
aEditingHost
|
|
&
aContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
if
(
aEditingHost
&
&
!
aContent
.
IsInclusiveDescendantOf
(
aEditingHost
)
)
{
return
nullptr
;
}
if
(
!
aContent
.
GetParent
(
)
)
{
return
const_cast
<
nsIContent
*
>
(
&
aContent
)
;
}
nsIContent
*
topMostInlineContent
=
const_cast
<
nsIContent
*
>
(
&
aContent
)
;
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
element
=
=
aEditingHost
|
|
element
=
=
aAncestorLimiter
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
element
aBlockInlineCheck
)
)
{
break
;
}
topMostInlineContent
=
element
;
}
return
topMostInlineContent
;
}
static
Element
*
GetMostDistantAncestorEditableEmptyInlineElement
(
const
nsIContent
&
aEmptyContent
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aEditingHost
=
nullptr
const
nsIContent
*
aAncestorLimiter
=
nullptr
)
{
if
(
&
aEmptyContent
=
=
aEditingHost
|
|
&
aEmptyContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
lastEmptyContent
=
const_cast
<
nsIContent
*
>
(
&
aEmptyContent
)
;
for
(
Element
*
element
:
aEmptyContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
element
=
=
aEditingHost
|
|
element
=
=
aAncestorLimiter
)
{
break
;
}
if
(
!
HTMLEditUtils
:
:
IsInlineContent
(
*
element
aBlockInlineCheck
)
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
element
)
)
{
break
;
}
if
(
element
-
>
GetChildCount
(
)
>
1
)
{
for
(
const
nsIContent
*
child
=
element
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
lastEmptyContent
|
|
child
-
>
IsComment
(
)
)
{
continue
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
Element
:
:
FromNode
(
lastEmptyContent
)
:
nullptr
;
}
}
lastEmptyContent
=
element
;
}
return
lastEmptyContent
!
=
&
aEmptyContent
?
Element
:
:
FromNode
(
lastEmptyContent
)
:
nullptr
;
}
static
Element
*
GetElementIfOnlyOneSelected
(
const
AbstractRange
&
aRange
)
{
return
GetElementIfOnlyOneSelected
(
EditorRawDOMRange
(
aRange
)
)
;
}
template
<
typename
EditorDOMPointType
>
static
Element
*
GetElementIfOnlyOneSelected
(
const
EditorDOMRangeBase
<
EditorDOMPointType
>
&
aRange
)
{
if
(
!
aRange
.
IsPositioned
(
)
|
|
aRange
.
Collapsed
(
)
)
{
return
nullptr
;
}
const
auto
&
start
=
aRange
.
StartRef
(
)
;
const
auto
&
end
=
aRange
.
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
start
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
end
.
IsSetAndValid
(
)
)
|
|
start
.
GetContainer
(
)
!
=
end
.
GetContainer
(
)
)
{
return
nullptr
;
}
nsIContent
*
childAtStart
=
start
.
GetChild
(
)
;
if
(
!
childAtStart
|
|
!
childAtStart
-
>
IsElement
(
)
)
{
return
nullptr
;
}
if
(
childAtStart
-
>
GetNextSibling
(
)
)
{
return
childAtStart
-
>
GetNextSibling
(
)
=
=
end
.
GetChild
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
return
!
end
.
GetChild
(
)
?
childAtStart
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetTableCellElementIfOnlyOneSelected
(
const
AbstractRange
&
aRange
)
{
Element
*
element
=
HTMLEditUtils
:
:
GetElementIfOnlyOneSelected
(
aRange
)
;
return
element
&
&
HTMLEditUtils
:
:
IsTableCell
(
element
)
?
element
:
nullptr
;
}
static
Element
*
GetFirstSelectedTableCellElement
(
const
Selection
&
aSelection
)
{
if
(
!
aSelection
.
RangeCount
(
)
)
{
return
nullptr
;
}
const
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
|
|
NS_WARN_IF
(
!
firstRange
-
>
IsPositioned
(
)
)
)
{
return
nullptr
;
}
return
GetTableCellElementIfOnlyOneSelected
(
*
firstRange
)
;
}
template
<
typename
FirstElementName
typename
.
.
.
OtherElementNames
>
static
Element
*
GetInclusiveDeepestFirstChildWhichHasOneChild
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
FirstElementName
aFirstElementName
OtherElementNames
.
.
.
aOtherElementNames
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
nullptr
;
}
Element
*
parentElement
=
nullptr
;
for
(
nsIContent
*
content
=
const_cast
<
nsIContent
*
>
(
aNode
.
AsContent
(
)
)
;
content
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
IsAnyOfHTMLElements
(
aFirstElementName
aOtherElementNames
.
.
.
)
;
content
=
content
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
CountChildren
(
*
content
aOptions
aBlockInlineCheck
)
!
=
1
)
{
return
content
-
>
AsElement
(
)
;
}
parentElement
=
content
-
>
AsElement
(
)
;
}
return
parentElement
;
}
template
<
typename
EditorLineBreakType
>
static
Maybe
<
EditorLineBreakType
>
GetFirstLineBreak
(
const
dom
:
:
Element
&
aElement
)
{
for
(
nsIContent
*
content
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
aElement
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
content
;
content
=
HTMLEditUtils
:
:
GetNextContent
(
*
content
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
}
BlockInlineCheck
:
:
Unused
&
aElement
)
)
{
if
(
auto
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
*
content
)
)
{
return
Some
(
EditorLineBreakType
(
*
brElement
)
)
;
}
if
(
auto
*
textNode
=
Text
:
:
FromNode
(
*
content
)
)
{
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
)
{
uint32_t
offset
=
textNode
-
>
DataBuffer
(
)
.
FindChar
(
kNewLine
)
;
if
(
offset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
)
{
return
Some
(
EditorLineBreakType
(
*
textNode
offset
)
)
;
}
}
}
}
return
Nothing
(
)
;
}
enum
class
ScanLineBreak
{
AtEndOfBlock
BeforeBlock
}
;
template
<
typename
EditorLineBreakType
>
static
Maybe
<
EditorLineBreakType
>
GetUnnecessaryLineBreak
(
const
Element
&
aBlockElement
ScanLineBreak
aScanLineBreak
)
;
template
<
typename
EditorLineBreakType
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
Maybe
<
EditorLineBreakType
>
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPointType
&
aPoint
)
;
static
bool
IsInTableCellSelectionMode
(
const
Selection
&
aSelection
)
{
return
GetFirstSelectedTableCellElement
(
aSelection
)
!
=
nullptr
;
}
static
EditAction
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForInsert
(
const
Element
&
aElement
)
;
static
EditAction
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
;
static
EditAction
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
;
enum
class
WalkTextOption
{
TreatNBSPsCollapsible
}
;
using
WalkTextOptions
=
EnumSet
<
WalkTextOption
>
;
static
Maybe
<
uint32_t
>
GetPreviousNonCollapsibleCharOffset
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetPreviousNonCollapsibleCharOffset
(
*
aPoint
.
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetPreviousNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
if
(
MOZ_UNLIKELY
(
!
aOffset
)
)
{
return
Nothing
{
}
;
}
MOZ_ASSERT
(
aOffset
<
=
aTextNode
.
TextDataLength
(
)
)
;
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
aTextNode
)
)
{
return
Some
(
aOffset
-
1
)
;
}
WhitespaceOptions
whitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
}
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
aTextNode
)
)
{
whitespaceOptions
+
=
WhitespaceOption
:
:
NewLineIsSignificant
;
}
if
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
)
{
whitespaceOptions
+
=
WhitespaceOption
:
:
TreatNBSPAsCollapsible
;
}
const
uint32_t
prevVisibleCharOffset
=
aTextNode
.
DataBuffer
(
)
.
RFindNonWhitespaceChar
(
whitespaceOptions
aOffset
-
1
)
;
return
prevVisibleCharOffset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
?
Some
(
prevVisibleCharOffset
)
:
Nothing
(
)
;
}
static
Maybe
<
uint32_t
>
GetNextNonCollapsibleCharOffset
(
const
EditorDOMPointInText
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetNextNonCollapsibleCharOffset
(
*
aPoint
.
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetNextNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
return
GetInclusiveNextNonCollapsibleCharOffset
(
aTextNode
aOffset
+
1
aWalkTextOptions
)
;
}
template
<
typename
PT
typename
CT
>
static
Maybe
<
uint32_t
>
GetInclusiveNextNonCollapsibleCharOffset
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
static_assert
(
std
:
:
is_same
<
PT
RefPtr
<
Text
>
>
:
:
value
|
|
std
:
:
is_same
<
PT
Text
*
>
:
:
value
)
;
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
GetInclusiveNextNonCollapsibleCharOffset
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
Maybe
<
uint32_t
>
GetInclusiveNextNonCollapsibleCharOffset
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
if
(
MOZ_UNLIKELY
(
aOffset
>
=
aTextNode
.
TextDataLength
(
)
)
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
aOffset
<
=
aTextNode
.
TextDataLength
(
)
)
;
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
aTextNode
)
)
{
return
Some
(
aOffset
)
;
}
WhitespaceOptions
whitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
}
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
aTextNode
)
)
{
whitespaceOptions
+
=
WhitespaceOption
:
:
NewLineIsSignificant
;
}
if
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
)
{
whitespaceOptions
+
=
WhitespaceOption
:
:
TreatNBSPAsCollapsible
;
}
const
uint32_t
inclusiveNextVisibleCharOffset
=
aTextNode
.
DataBuffer
(
)
.
FindNonWhitespaceChar
(
whitespaceOptions
aOffset
)
;
if
(
inclusiveNextVisibleCharOffset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
)
{
return
Some
(
inclusiveNextVisibleCharOffset
)
;
}
return
Nothing
(
)
;
}
template
<
typename
PT
typename
CT
>
static
uint32_t
GetFirstWhiteSpaceOffsetCollapsedWith
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
static_assert
(
std
:
:
is_same
<
PT
RefPtr
<
Text
>
>
:
:
value
|
|
std
:
:
is_same
<
PT
Text
*
>
:
:
value
)
;
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
aPoint
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
aPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
;
MOZ_ASSERT_IF
(
!
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
aPoint
.
IsCharCollapsibleASCIISpace
(
)
)
;
return
GetFirstWhiteSpaceOffsetCollapsedWith
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
aPoint
.
Offset
(
)
aWalkTextOptions
)
;
}
static
uint32_t
GetFirstWhiteSpaceOffsetCollapsedWith
(
const
Text
&
aTextNode
uint32_t
aOffset
const
WalkTextOptions
&
aWalkTextOptions
=
{
}
)
{
MOZ_ASSERT
(
aOffset
<
aTextNode
.
TextLength
(
)
)
;
MOZ_ASSERT_IF
(
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
;
MOZ_ASSERT_IF
(
!
aWalkTextOptions
.
contains
(
WalkTextOption
:
:
TreatNBSPsCollapsible
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
.
IsCharCollapsibleASCIISpace
(
)
)
;
if
(
!
aOffset
)
{
return
0
;
}
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
GetPreviousNonCollapsibleCharOffset
(
aTextNode
aOffset
aWalkTextOptions
)
;
return
previousVisibleCharOffset
.
isSome
(
)
?
previousVisibleCharOffset
.
value
(
)
+
1
:
0
;
}
template
<
typename
EditorDOMPointType
typename
ArgEditorDOMPointType
>
static
EditorDOMPointType
GetPreviousPreformattedNewLineInTextNode
(
const
ArgEditorDOMPointType
&
aPoint
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsStartOfContainer
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
Text
&
textNode
=
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
;
MOZ_ASSERT
(
aPoint
.
Offset
(
)
<
=
textNode
.
DataBuffer
(
)
.
GetLength
(
)
)
;
const
uint32_t
previousLineBreakOffset
=
textNode
.
DataBuffer
(
)
.
RFindChar
(
'
\
n
'
aPoint
.
Offset
(
)
-
1u
)
;
return
previousLineBreakOffset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
?
EditorDOMPointType
(
&
textNode
previousLineBreakOffset
)
:
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
typename
ArgEditorDOMPointType
>
static
EditorDOMPointType
GetInclusiveNextPreformattedNewLineInTextNode
(
const
ArgEditorDOMPointType
&
aPoint
)
{
if
(
!
aPoint
.
IsInTextNode
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
Text
&
textNode
=
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
;
MOZ_ASSERT
(
aPoint
.
Offset
(
)
<
=
textNode
.
DataBuffer
(
)
.
GetLength
(
)
)
;
const
uint32_t
inclusiveNextVisibleCharOffset
=
textNode
.
DataBuffer
(
)
.
FindChar
(
'
\
n
'
aPoint
.
Offset
(
)
)
;
return
inclusiveNextVisibleCharOffset
!
=
dom
:
:
CharacterDataBuffer
:
:
kNotFound
?
EditorDOMPointType
(
&
textNode
inclusiveNextVisibleCharOffset
)
:
EditorDOMPointType
(
)
;
}
[
[
nodiscard
]
]
static
uint32_t
GetFirstVisibleCharOffset
(
const
Text
&
aText
)
;
[
[
nodiscard
]
]
static
uint32_t
GetOffsetAfterLastVisibleChar
(
const
Text
&
aText
)
;
[
[
nodiscard
]
]
static
uint32_t
GetInvisibleWhiteSpaceCount
(
const
Text
&
aText
uint32_t
aOffset
=
0u
uint32_t
aLength
=
UINT32_MAX
)
;
template
<
typename
EditorDOMPointType
>
static
EditorDOMPointType
GetGoodCaretPointFor
(
nsIContent
&
aContent
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
nsIEditor
:
:
EDirectionIsValidExceptNone
(
aDirectionAndAmount
)
)
;
if
(
aContent
.
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
|
|
NS_WARN_IF
(
!
aContent
.
GetParentNode
(
)
)
)
{
return
EditorDOMPointType
(
&
aContent
nsIEditor
:
:
DirectionIsDelete
(
aDirectionAndAmount
)
?
0
:
aContent
.
Length
(
)
)
;
}
if
(
nsIEditor
:
:
DirectionIsDelete
(
aDirectionAndAmount
)
)
{
return
EditorDOMPointType
(
&
aContent
)
;
}
if
(
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
aContent
)
)
{
EditorDOMPointType
ret
(
EditorDOMPointType
:
:
After
(
aContent
)
)
;
NS_WARNING_ASSERTION
(
ret
.
IsSet
(
)
"
Failed
to
set
after
aContent
"
)
;
return
ret
;
}
return
EditorDOMPointType
(
&
aContent
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
static
EditorDOMPointType
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPointTypeInput
&
aPointToInsert
)
;
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
static
EditorDOMPointType
GetBetterCaretPositionToInsertText
(
const
EditorDOMPointTypeInput
&
aPoint
)
;
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
static
Result
<
EditorDOMPointType
nsresult
>
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPointTypeInput
&
aCurrentPoint
)
;
[
[
nodiscard
]
]
static
bool
IsInlineStyleSetByElement
(
const
nsIContent
&
aContent
const
EditorInlineStyle
&
aStyle
const
nsAString
*
aValue
nsAString
*
aOutValue
=
nullptr
)
;
static
void
CollectAllChildren
(
const
nsINode
&
aParentNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
{
MOZ_ASSERT
(
aOutArrayOfContents
.
IsEmpty
(
)
)
;
aOutArrayOfContents
.
SetCapacity
(
aParentNode
.
GetChildCount
(
)
)
;
for
(
nsIContent
*
childContent
=
aParentNode
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
childContent
)
;
}
}
static
size_t
CollectChildren
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
const
CollectChildrenOptions
&
aOptions
)
{
return
HTMLEditUtils
:
:
CollectChildren
(
aNode
aOutArrayOfContents
0u
aOptions
)
;
}
static
size_t
CollectChildren
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
const
CollectChildrenOptions
&
aOptions
)
;
static
size_t
CollectEmptyInlineContainerDescendants
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
const
EmptyCheckOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
)
;
[
[
nodiscard
]
]
static
bool
ElementHasAttribute
(
const
Element
&
aElement
)
{
return
ElementHasAttributeExcept
(
aElement
*
nsGkAtoms
:
:
_empty
*
nsGkAtoms
:
:
empty
*
nsGkAtoms
:
:
_empty
)
;
}
[
[
nodiscard
]
]
static
bool
ElementHasAttributeExcept
(
const
Element
&
aElement
const
nsAtom
&
aAttribute
)
{
return
ElementHasAttributeExcept
(
aElement
aAttribute
*
nsGkAtoms
:
:
_empty
*
nsGkAtoms
:
:
empty
)
;
}
[
[
nodiscard
]
]
static
bool
ElementHasAttributeExcept
(
const
Element
&
aElement
const
nsAtom
&
aAttribute1
const
nsAtom
&
aAttribute2
)
{
return
ElementHasAttributeExcept
(
aElement
aAttribute1
aAttribute2
*
nsGkAtoms
:
:
empty
)
;
}
[
[
nodiscard
]
]
static
bool
ElementHasAttributeExcept
(
const
Element
&
aElement
const
nsAtom
&
aAttribute1
const
nsAtom
&
aAttribute2
const
nsAtom
&
aAttribute3
)
;
enum
class
EditablePointOption
{
RecognizeInvisibleWhiteSpaces
StopAtComment
StopAtListElement
StopAtListItemElement
StopAtTableElement
StopAtAnyTableElement
}
;
using
EditablePointOptions
=
EnumSet
<
EditablePointOption
>
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
EditablePointOption
&
aOption
)
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
EditablePointOptions
&
aOptions
)
;
private
:
class
MOZ_STACK_CLASS
AutoEditablePointChecker
final
{
public
:
explicit
AutoEditablePointChecker
(
const
EditablePointOptions
&
aOptions
)
:
mIgnoreInvisibleText
(
!
aOptions
.
contains
(
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
)
)
mIgnoreComment
(
!
aOptions
.
contains
(
EditablePointOption
:
:
StopAtComment
)
)
mStopAtListElement
(
aOptions
.
contains
(
EditablePointOption
:
:
StopAtListElement
)
)
mStopAtListItemElement
(
aOptions
.
contains
(
EditablePointOption
:
:
StopAtListItemElement
)
)
mStopAtTableElement
(
aOptions
.
contains
(
EditablePointOption
:
:
StopAtTableElement
)
)
mStopAtAnyTableElement
(
aOptions
.
contains
(
EditablePointOption
:
:
StopAtAnyTableElement
)
)
{
}
[
[
nodiscard
]
]
bool
IgnoreInvisibleWhiteSpaces
(
)
const
{
return
mIgnoreInvisibleText
;
}
[
[
nodiscard
]
]
bool
NodeShouldBeIgnored
(
const
nsIContent
&
aContent
)
const
{
if
(
mIgnoreInvisibleText
&
&
aContent
.
IsText
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
&
&
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
aContent
.
AsText
(
)
)
)
{
return
true
;
}
if
(
mIgnoreComment
&
&
aContent
.
IsComment
(
)
)
{
return
true
;
}
return
false
;
}
[
[
nodiscard
]
]
bool
ShouldStopScanningAt
(
const
nsIContent
&
aContent
)
const
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aContent
)
)
{
return
mStopAtListElement
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
&
aContent
)
)
{
return
mStopAtListItemElement
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
)
{
return
mStopAtAnyTableElement
|
|
(
mStopAtTableElement
&
&
HTMLEditUtils
:
:
IsTable
(
&
aContent
)
)
;
}
return
false
;
}
private
:
const
bool
mIgnoreInvisibleText
;
const
bool
mIgnoreComment
;
const
bool
mStopAtListElement
;
const
bool
mStopAtListItemElement
;
const
bool
mStopAtTableElement
;
const
bool
mStopAtAnyTableElement
;
}
;
public
:
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetDeepestEditableStartPointOf
(
const
nsIContent
&
aContent
const
EditablePointOptions
&
aOptions
)
{
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorBase
:
:
EditorType
:
:
HTML
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
AutoEditablePointChecker
checker
(
aOptions
)
;
EditorRawDOMPoint
result
(
&
aContent
0u
)
;
while
(
true
)
{
nsIContent
*
firstChild
=
result
.
GetContainer
(
)
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
)
{
break
;
}
nsIContent
*
meaningfulFirstChild
=
nullptr
;
if
(
checker
.
NodeShouldBeIgnored
(
*
firstChild
)
)
{
for
(
nsIContent
*
nextSibling
=
firstChild
-
>
GetNextSibling
(
)
;
nextSibling
;
nextSibling
=
nextSibling
-
>
GetNextSibling
(
)
)
{
if
(
!
checker
.
NodeShouldBeIgnored
(
*
nextSibling
)
|
|
checker
.
ShouldStopScanningAt
(
*
nextSibling
)
)
{
meaningfulFirstChild
=
nextSibling
;
break
;
}
}
if
(
!
meaningfulFirstChild
)
{
break
;
}
}
else
{
meaningfulFirstChild
=
firstChild
;
}
if
(
meaningfulFirstChild
-
>
IsText
(
)
)
{
if
(
checker
.
IgnoreInvisibleWhiteSpaces
(
)
)
{
result
.
Set
(
meaningfulFirstChild
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
*
meaningfulFirstChild
-
>
AsText
(
)
0u
)
.
valueOr
(
0u
)
)
;
}
else
{
result
.
Set
(
meaningfulFirstChild
0u
)
;
}
break
;
}
if
(
checker
.
ShouldStopScanningAt
(
*
meaningfulFirstChild
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
meaningfulFirstChild
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
meaningfulFirstChild
EditorBase
:
:
EditorType
:
:
HTML
)
)
{
result
.
Set
(
meaningfulFirstChild
)
;
break
;
}
result
.
Set
(
meaningfulFirstChild
0u
)
;
}
return
result
.
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
static
EditorDOMPointType
GetDeepestEditableEndPointOf
(
const
nsIContent
&
aContent
const
EditablePointOptions
&
aOptions
)
{
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorBase
:
:
EditorType
:
:
HTML
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
AutoEditablePointChecker
checker
(
aOptions
)
;
auto
result
=
EditorRawDOMPoint
:
:
AtEndOf
(
aContent
)
;
while
(
true
)
{
nsIContent
*
lastChild
=
result
.
GetContainer
(
)
-
>
GetLastChild
(
)
;
if
(
!
lastChild
)
{
break
;
}
nsIContent
*
meaningfulLastChild
=
nullptr
;
if
(
checker
.
NodeShouldBeIgnored
(
*
lastChild
)
)
{
for
(
nsIContent
*
nextSibling
=
lastChild
-
>
GetPreviousSibling
(
)
;
nextSibling
;
nextSibling
=
nextSibling
-
>
GetPreviousSibling
(
)
)
{
if
(
!
checker
.
NodeShouldBeIgnored
(
*
nextSibling
)
|
|
checker
.
ShouldStopScanningAt
(
*
nextSibling
)
)
{
meaningfulLastChild
=
nextSibling
;
break
;
}
}
if
(
!
meaningfulLastChild
)
{
break
;
}
}
else
{
meaningfulLastChild
=
lastChild
;
}
if
(
meaningfulLastChild
-
>
IsText
(
)
)
{
if
(
checker
.
IgnoreInvisibleWhiteSpaces
(
)
)
{
const
Maybe
<
uint32_t
>
visibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
*
meaningfulLastChild
-
>
AsText
(
)
meaningfulLastChild
-
>
AsText
(
)
-
>
TextDataLength
(
)
)
;
if
(
visibleCharOffset
.
isNothing
(
)
)
{
result
=
EditorRawDOMPoint
:
:
AtEndOf
(
*
meaningfulLastChild
)
;
}
else
{
result
.
Set
(
meaningfulLastChild
visibleCharOffset
.
value
(
)
+
1u
)
;
}
}
else
{
result
=
EditorRawDOMPoint
:
:
AtEndOf
(
*
meaningfulLastChild
)
;
}
break
;
}
if
(
checker
.
ShouldStopScanningAt
(
*
meaningfulLastChild
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
meaningfulLastChild
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
meaningfulLastChild
EditorBase
:
:
EditorType
:
:
HTML
)
)
{
result
.
SetAfter
(
meaningfulLastChild
)
;
break
;
}
result
=
EditorRawDOMPoint
:
:
AtEndOf
(
*
lastChild
)
;
}
return
result
.
To
<
EditorDOMPointType
>
(
)
;
}
static
bool
GetNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
;
[
[
nodiscard
]
]
static
bool
MaybeCSSSpecificColorValue
(
const
nsAString
&
aColorValue
)
;
[
[
nodiscard
]
]
static
bool
CanConvertToHTMLColorValue
(
const
nsAString
&
aColorValue
)
;
static
bool
ConvertToNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
;
enum
class
ZeroAlphaColor
{
RGBAValue
TransparentKeyword
}
;
static
bool
GetNormalizedCSSColorValue
(
const
nsAString
&
aColorValue
ZeroAlphaColor
aZeroAlphaColor
nsAString
&
aNormalizedValue
)
;
enum
class
TransparentKeyword
{
Invalid
Allowed
}
;
static
bool
IsSameHTMLColorValue
(
const
nsAString
&
aColorA
const
nsAString
&
aColorB
TransparentKeyword
aTransparentKeyword
)
;
template
<
typename
CharType
>
static
bool
IsSameCSSColorValue
(
const
nsTSubstring
<
CharType
>
&
aColorA
const
nsTSubstring
<
CharType
>
&
aColorB
)
;
[
[
nodiscard
]
]
static
bool
IsTransparentCSSColor
(
const
nsAString
&
aColor
)
;
private
:
static
bool
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
;
static
bool
IsContainerNode
(
nsHTMLTag
aTagId
)
;
static
bool
CanCrossContentBoundary
(
nsIContent
&
aContent
TableBoundary
aHowToTreatTableBoundary
)
{
const
bool
cannotCrossBoundary
=
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossAnyTableElement
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
)
|
|
(
aHowToTreatTableBoundary
=
=
TableBoundary
:
:
NoCrossTableElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
return
!
cannotCrossBoundary
;
}
static
bool
IsContentIgnored
(
const
nsIContent
&
aContent
const
WalkTreeOptions
&
aOptions
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreNonEditableNode
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorUtils
:
:
EditorType
:
:
HTML
)
)
{
return
true
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreDataNodeExceptText
)
&
&
!
EditorUtils
:
:
IsElementOrText
(
aContent
)
)
{
return
true
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
)
&
&
aContent
.
IsText
(
)
&
&
const_cast
<
Text
*
>
(
aContent
.
AsText
(
)
)
-
>
TextIsOnlyWhitespace
(
)
)
{
return
true
;
}
return
false
;
}
static
uint32_t
CountChildren
(
const
nsINode
&
aNode
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
)
{
uint32_t
count
=
0
;
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
HTMLEditUtils
:
:
IsContentIgnored
(
*
child
aOptions
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
child
aBlockInlineCheck
)
)
{
break
;
}
+
+
count
;
}
return
count
;
}
static
nsIContent
*
GetAdjacentLeafContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
nsIContent
*
GetAdjacentContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
=
nullptr
)
;
static
Element
*
GetElementOfImmediateBlockBoundary
(
const
nsIContent
&
aContent
const
WalkTreeDirection
aDirection
)
;
}
;
class
MOZ_STACK_CLASS
DefinitionListItemScanner
final
{
using
Element
=
dom
:
:
Element
;
public
:
DefinitionListItemScanner
(
)
=
delete
;
explicit
DefinitionListItemScanner
(
Element
&
aDLElement
)
{
MOZ_ASSERT
(
aDLElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
for
(
nsIContent
*
child
=
aDLElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mDTFound
=
true
;
if
(
mDDFound
)
{
break
;
}
continue
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mDDFound
=
true
;
if
(
mDTFound
)
{
break
;
}
continue
;
}
}
}
bool
DTElementFound
(
)
const
{
return
mDTFound
;
}
bool
DDElementFound
(
)
const
{
return
mDDFound
;
}
private
:
bool
mDTFound
=
false
;
bool
mDDFound
=
false
;
}
;
class
MOZ_STACK_CLASS
SelectedTableCellScanner
final
{
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
public
:
SelectedTableCellScanner
(
)
=
delete
;
explicit
SelectedTableCellScanner
(
const
Selection
&
aSelection
)
{
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetFirstSelectedTableCellElement
(
aSelection
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aSelection
.
RangeCount
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
const
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
1u
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
.
RangeCount
(
)
=
=
rangeCount
)
;
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
|
|
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
)
{
continue
;
}
if
(
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
explicit
SelectedTableCellScanner
(
const
AutoClonedRangeArray
&
aRanges
)
;
bool
IsInTableCellSelectionMode
(
)
const
{
return
!
mSelectedCellElements
.
IsEmpty
(
)
;
}
const
nsTArray
<
OwningNonNull
<
Element
>
>
&
ElementsRef
(
)
const
{
return
mSelectedCellElements
;
}
Element
*
GetFirstElement
(
)
const
{
MOZ_ASSERT
(
!
mSelectedCellElements
.
IsEmpty
(
)
)
;
mIndex
=
0
;
return
!
mSelectedCellElements
.
IsEmpty
(
)
?
mSelectedCellElements
[
0
]
.
get
(
)
:
nullptr
;
}
Element
*
GetNextElement
(
)
const
{
MOZ_ASSERT
(
mIndex
<
mSelectedCellElements
.
Length
(
)
)
;
return
+
+
mIndex
<
mSelectedCellElements
.
Length
(
)
?
mSelectedCellElements
[
mIndex
]
.
get
(
)
:
nullptr
;
}
private
:
AutoTArray
<
OwningNonNull
<
Element
>
16
>
mSelectedCellElements
;
mutable
size_t
mIndex
=
0
;
}
;
}
#
endif
