#
ifndef
HTMLEditUtils_h
#
define
HTMLEditUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
class
nsAtom
;
namespace
mozilla
{
enum
class
EditAction
;
class
HTMLEditUtils
final
{
using
Element
=
dom
:
:
Element
;
using
Selection
=
dom
:
:
Selection
;
public
:
static
bool
IsSimplyEditableNode
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsEditable
(
)
;
}
static
bool
IsRemovableFromParentNode
(
const
nsIContent
&
aContent
)
{
return
aContent
.
IsEditable
(
)
&
&
aContent
.
GetParentNode
(
)
&
&
aContent
.
GetParentNode
(
)
-
>
IsEditable
(
)
;
}
enum
class
StyleDifference
{
Ignore
CompareIfElements
CompareIfSpanElements
}
;
static
bool
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
StyleDifference
aStyleDifference
)
;
static
bool
IsBlockElement
(
const
nsIContent
&
aContent
)
;
static
bool
IsInlineElement
(
const
nsIContent
&
aContent
)
{
return
!
IsBlockElement
(
aContent
)
;
}
static
bool
IsInlineStyle
(
nsINode
*
aNode
)
;
static
bool
IsRemovableInlineStyleElement
(
dom
:
:
Element
&
aElement
)
;
static
bool
IsFormatNode
(
nsINode
*
aNode
)
;
static
bool
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
;
static
bool
IsHeader
(
nsINode
&
aNode
)
;
static
bool
IsListItem
(
nsINode
*
aNode
)
;
static
bool
IsTable
(
nsINode
*
aNode
)
;
static
bool
IsTableRow
(
nsINode
*
aNode
)
;
static
bool
IsTableElement
(
nsINode
*
aNode
)
;
static
bool
IsTableElementButNotTable
(
nsINode
*
aNode
)
;
static
bool
IsTableCell
(
nsINode
*
node
)
;
static
bool
IsTableCellOrCaption
(
nsINode
&
aNode
)
;
static
bool
IsList
(
nsINode
*
aNode
)
;
static
bool
IsPre
(
nsINode
*
aNode
)
;
static
bool
IsImage
(
nsINode
*
aNode
)
;
static
bool
IsLink
(
nsINode
*
aNode
)
;
static
bool
IsNamedAnchor
(
nsINode
*
aNode
)
;
static
bool
IsMozDiv
(
nsINode
*
aNode
)
;
static
bool
IsMailCite
(
nsINode
*
aNode
)
;
static
bool
IsFormWidget
(
nsINode
*
aNode
)
;
static
bool
SupportsAlignAttr
(
nsINode
&
aNode
)
;
static
bool
CanNodeContain
(
const
nsINode
&
aParent
const
nsIContent
&
aChild
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChild
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
const
nsINode
&
aParent
nsAtom
&
aChildNodeName
)
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChildNodeName
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
const
nsIContent
&
aChild
)
{
switch
(
aChild
.
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
HTMLEditUtils
:
:
CanNodeContain
(
aParentNodeName
*
aChild
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
return
false
;
}
static
bool
CanNodeContain
(
nsAtom
&
aParentNodeName
nsAtom
&
aChildNodeName
)
{
nsHTMLTag
childTagEnum
;
if
(
&
aChildNodeName
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildNodeName
)
;
}
nsHTMLTag
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentNodeName
)
;
return
HTMLEditUtils
:
:
CanNodeContain
(
parentTagEnum
childTagEnum
)
;
}
static
bool
CanElementContainParagraph
(
const
Element
&
aElement
)
{
if
(
HTMLEditUtils
:
:
CanNodeContain
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsContainerNode
(
const
nsIContent
&
aContent
)
{
nsHTMLTag
tagEnum
;
if
(
aContent
.
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aContent
.
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
tagEnum
)
;
}
static
bool
IsNonListSingleLineContainer
(
nsINode
&
aNode
)
;
static
bool
IsSingleLineContainer
(
nsINode
&
aNode
)
;
static
EditAction
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
;
static
EditAction
GetEditActionForInsert
(
const
Element
&
aElement
)
;
static
EditAction
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
;
static
EditAction
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
;
private
:
static
bool
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
;
static
bool
IsContainerNode
(
nsHTMLTag
aTagId
)
;
}
;
class
MOZ_STACK_CLASS
DefinitionListItemScanner
final
{
public
:
DefinitionListItemScanner
(
)
=
delete
;
explicit
DefinitionListItemScanner
(
dom
:
:
Element
&
aDLElement
)
{
MOZ_ASSERT
(
aDLElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
for
(
nsIContent
*
child
=
aDLElement
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mDTFound
=
true
;
if
(
mDDFound
)
{
break
;
}
continue
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mDDFound
=
true
;
if
(
mDTFound
)
{
break
;
}
continue
;
}
}
}
bool
DTElementFound
(
)
const
{
return
mDTFound
;
}
bool
DDElementFound
(
)
const
{
return
mDDFound
;
}
private
:
bool
mDTFound
=
false
;
bool
mDDFound
=
false
;
}
;
}
#
endif
