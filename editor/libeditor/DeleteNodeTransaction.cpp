#
include
"
DeleteNodeTransaction
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMAPIWrapper
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
TextEditor
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsAString
.
h
"
namespace
mozilla
{
already_AddRefed
<
DeleteNodeTransaction
>
DeleteNodeTransaction
:
:
MaybeCreate
(
EditorBase
&
aEditorBase
nsIContent
&
aContentToDelete
)
{
RefPtr
<
DeleteNodeTransaction
>
transaction
=
new
DeleteNodeTransaction
(
aEditorBase
aContentToDelete
)
;
if
(
NS_WARN_IF
(
!
transaction
-
>
CanDoIt
(
)
)
)
{
return
nullptr
;
}
return
transaction
.
forget
(
)
;
}
DeleteNodeTransaction
:
:
DeleteNodeTransaction
(
EditorBase
&
aEditorBase
nsIContent
&
aContentToDelete
)
:
DeleteContentTransactionBase
(
aEditorBase
)
mContentToDelete
(
&
aContentToDelete
)
mParentNode
(
aContentToDelete
.
GetParentNode
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT_IF
(
aEditorBase
.
IsHTMLEditor
(
)
HTMLEditUtils
:
:
IsRemovableNode
(
aContentToDelete
)
|
|
(
aContentToDelete
.
IsText
(
)
&
&
aContentToDelete
.
HasFlag
(
NS_MAYBE_MODIFIED_FREQUENTLY
)
)
)
;
NS_ASSERTION
(
!
aEditorBase
.
IsHTMLEditor
(
)
|
|
HTMLEditUtils
:
:
IsRemovableNode
(
aContentToDelete
)
"
Deleting
non
-
editable
text
node
please
write
a
test
for
this
!
!
"
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
DeleteNodeTransaction
&
aTransaction
)
{
aStream
<
<
"
{
mContentToDelete
=
"
<
<
aTransaction
.
mContentToDelete
.
get
(
)
;
if
(
aTransaction
.
mContentToDelete
)
{
aStream
<
<
"
(
"
<
<
*
aTransaction
.
mContentToDelete
<
<
"
)
"
;
}
aStream
<
<
"
mParentNode
=
"
<
<
aTransaction
.
mParentNode
.
get
(
)
;
if
(
aTransaction
.
mParentNode
)
{
aStream
<
<
"
(
"
<
<
*
aTransaction
.
mParentNode
<
<
"
)
"
;
}
aStream
<
<
"
mRefContent
=
"
<
<
aTransaction
.
mRefContent
.
get
(
)
;
if
(
aTransaction
.
mRefContent
)
{
aStream
<
<
"
(
"
<
<
*
aTransaction
.
mRefContent
<
<
"
)
"
;
}
aStream
<
<
"
mEditorBase
=
"
<
<
aTransaction
.
mEditorBase
.
get
(
)
<
<
"
}
"
;
return
aStream
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
DeleteNodeTransaction
DeleteContentTransactionBase
mContentToDelete
mParentNode
mRefContent
)
NS_IMPL_ADDREF_INHERITED
(
DeleteNodeTransaction
DeleteContentTransactionBase
)
NS_IMPL_RELEASE_INHERITED
(
DeleteNodeTransaction
DeleteContentTransactionBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DeleteNodeTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
DeleteContentTransactionBase
)
bool
DeleteNodeTransaction
:
:
CanDoIt
(
)
const
{
if
(
NS_WARN_IF
(
!
mContentToDelete
)
|
|
NS_WARN_IF
(
!
mEditorBase
)
|
|
!
mParentNode
)
{
return
false
;
}
return
mEditorBase
-
>
IsTextEditor
(
)
|
|
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
mParentNode
)
;
}
NS_IMETHODIMP
DeleteNodeTransaction
:
:
DoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
DeleteNodeTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
CanDoIt
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT_IF
(
mEditorBase
-
>
IsTextEditor
(
)
!
mContentToDelete
-
>
IsText
(
)
)
;
mRefContent
=
mContentToDelete
-
>
GetNextSibling
(
)
;
const
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjDeleteNode
(
*
mContentToDelete
)
;
const
OwningNonNull
<
nsINode
>
parentNode
=
*
mParentNode
;
const
OwningNonNull
<
nsIContent
>
contentToDelete
=
*
mContentToDelete
;
AutoNodeAPIWrapper
nodeWrapper
(
editorBase
parentNode
)
;
nsresult
rv
=
nodeWrapper
.
RemoveChild
(
contentToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoNodeAPIWrapper
:
:
RemoveChild
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
nodeWrapper
.
IsExpectedResult
(
)
"
Removing
a
content
node
caused
other
mutations
but
ignored
"
)
;
return
NS_OK
;
}
EditorDOMPoint
DeleteNodeTransaction
:
:
SuggestPointToPutCaret
(
)
const
{
return
EditorDOMPoint
(
)
;
}
NS_IMETHODIMP
DeleteNodeTransaction
:
:
UndoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
DeleteNodeTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
CanDoIt
(
)
)
)
{
return
NS_OK
;
}
const
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
const
OwningNonNull
<
nsINode
>
parentNode
=
*
mParentNode
;
const
OwningNonNull
<
nsIContent
>
contentToDelete
=
*
mContentToDelete
;
const
nsCOMPtr
<
nsIContent
>
refContent
=
mRefContent
;
AutoNodeAPIWrapper
nodeWrapper
(
editorBase
parentNode
)
;
nsresult
rv
=
nodeWrapper
.
InsertBefore
(
contentToDelete
refContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoNodeAPIWrapper
:
:
InsertBefore
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
nodeWrapper
.
IsExpectedResult
(
)
"
Inserting
a
node
caused
other
mutations
but
ignored
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DeleteNodeTransaction
:
:
RedoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
DeleteNodeTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
CanDoIt
(
)
)
)
{
return
NS_OK
;
}
const
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjDeleteNode
(
*
mContentToDelete
)
;
const
OwningNonNull
<
nsINode
>
parentNode
=
*
mParentNode
;
const
OwningNonNull
<
nsIContent
>
contentToDelete
=
*
mContentToDelete
;
AutoNodeAPIWrapper
nodeWrapper
(
editorBase
parentNode
)
;
nsresult
rv
=
nodeWrapper
.
RemoveChild
(
contentToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoNodeAPIWrapper
:
:
RemoveChild
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
nodeWrapper
.
IsExpectedResult
(
)
"
Removing
a
content
node
caused
other
mutations
but
ignored
"
)
;
return
NS_OK
;
}
}
