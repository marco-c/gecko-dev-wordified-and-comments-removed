#
include
"
mozilla
/
EditorCommands
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCommandParams
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsPresContext
.
h
"
#
define
STATE_ENABLED
"
state_enabled
"
#
define
STATE_ALL
"
state_all
"
#
define
STATE_ATTRIBUTE
"
state_attribute
"
#
define
STATE_DATA
"
state_data
"
namespace
mozilla
{
StaticRefPtr
<
SetDocumentStateCommand
>
SetDocumentStateCommand
:
:
sInstance
;
bool
SetDocumentStateCommand
:
:
IsCommandEnabled
(
const
char
*
aCommandName
TextEditor
*
aTextEditor
)
const
{
return
true
;
}
nsresult
SetDocumentStateCommand
:
:
DoCommand
(
const
char
*
aCommandName
TextEditor
&
aTextEditor
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
SetDocumentStateCommand
:
:
DoCommandParams
(
const
char
*
aCommandName
nsCommandParams
*
aParams
TextEditor
&
aTextEditor
)
const
{
if
(
NS_WARN_IF
(
!
aParams
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentModified
"
)
)
{
ErrorResult
error
;
bool
modified
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
modified
)
{
nsresult
rv
=
aTextEditor
.
IncrementModificationCount
(
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
rv
=
aTextEditor
.
ResetModificationCount
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentReadOnly
"
)
)
{
ErrorResult
error
;
bool
isReadOnly
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
isReadOnly
)
{
nsresult
rv
=
aTextEditor
.
AddFlags
(
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
rv
=
aTextEditor
.
RemoveFlags
(
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentUseCSS
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
error
;
bool
desireCSS
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
nsresult
rv
=
htmlEditor
-
>
SetIsCSSEnabled
(
desireCSS
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_insertBrOnReturn
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
error
;
bool
insertBrOnReturn
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
nsresult
rv
=
htmlEditor
-
>
SetReturnInParagraphCreatesNewParagraph
(
!
insertBrOnReturn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_defaultParagraphSeparator
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
newValue
;
nsresult
rv
=
aParams
-
>
GetCString
(
STATE_ATTRIBUTE
newValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
newValue
.
LowerCaseEqualsLiteral
(
"
div
"
)
)
{
htmlEditor
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
div
)
;
return
NS_OK
;
}
if
(
newValue
.
LowerCaseEqualsLiteral
(
"
p
"
)
)
{
htmlEditor
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
p
)
;
return
NS_OK
;
}
if
(
newValue
.
LowerCaseEqualsLiteral
(
"
br
"
)
)
{
htmlEditor
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
br
)
;
return
NS_OK
;
}
NS_WARNING
(
"
Invalid
default
paragraph
separator
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableObjectResizing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
error
;
bool
enabled
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
htmlEditor
-
>
EnableObjectResizer
(
enabled
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableInlineTableEditing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
error
;
bool
enabled
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
htmlEditor
-
>
EnableInlineTableEditor
(
enabled
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableAbsolutePositionEditing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
error
;
bool
enabled
=
aParams
-
>
GetBool
(
STATE_ATTRIBUTE
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
htmlEditor
-
>
EnableAbsolutePositionEditor
(
enabled
)
;
return
NS_OK
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
SetDocumentStateCommand
:
:
GetCommandStateParams
(
const
char
*
aCommandName
nsCommandParams
&
aParams
TextEditor
*
aTextEditor
nsIEditingSession
*
aEditingSession
)
const
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
aParams
.
SetBool
(
STATE_ENABLED
IsCommandEnabled
(
aCommandName
aTextEditor
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentModified
"
)
)
{
bool
modified
;
rv
=
aTextEditor
-
>
GetDocumentModified
(
&
modified
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
modified
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentReadOnly
"
)
)
{
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
aTextEditor
-
>
IsReadonly
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_setDocumentUseCSS
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsCSSEnabled
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_insertBrOnReturn
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
createPOnReturn
;
htmlEditor
-
>
GetReturnInParagraphCreatesNewParagraph
(
&
createPOnReturn
)
;
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
!
createPOnReturn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_defaultParagraphSeparator
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
switch
(
htmlEditor
-
>
GetDefaultParagraphSeparator
(
)
)
{
case
ParagraphSeparator
:
:
div
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
NS_LITERAL_CSTRING
(
"
div
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
div
\
"
"
)
;
return
NS_OK
;
}
case
ParagraphSeparator
:
:
p
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
NS_LITERAL_CSTRING
(
"
p
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
p
\
"
"
)
;
return
NS_OK
;
}
case
ParagraphSeparator
:
:
br
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
NS_LITERAL_CSTRING
(
"
br
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
br
\
"
"
)
;
return
NS_OK
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
paragraph
separator
value
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableObjectResizing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsObjectResizerEnabled
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableInlineTableEditing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsInlineTableEditorEnabled
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
cmd_enableAbsolutePositionEditing
"
)
)
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsAbsolutePositionEditorEnabled
(
)
)
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
StaticRefPtr
<
DocumentStateCommand
>
DocumentStateCommand
:
:
sInstance
;
bool
DocumentStateCommand
:
:
IsCommandEnabled
(
const
char
*
aCommandName
TextEditor
*
aTextEditor
)
const
{
return
false
;
}
nsresult
DocumentStateCommand
:
:
DoCommand
(
const
char
*
aCommandName
TextEditor
&
aTextEditor
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
DocumentStateCommand
:
:
DoCommandParams
(
const
char
*
aCommandName
nsCommandParams
*
aParams
TextEditor
&
aTextEditor
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
DocumentStateCommand
:
:
GetCommandStateParams
(
const
char
*
aCommandName
nsCommandParams
&
aParams
TextEditor
*
aTextEditor
nsIEditingSession
*
aEditingSession
)
const
{
if
(
!
strcmp
(
aCommandName
"
obs_documentCreated
"
)
)
{
uint32_t
editorStatus
=
nsIEditingSession
:
:
eEditorErrorUnknown
;
if
(
aEditingSession
)
{
nsresult
rv
=
aEditingSession
-
>
GetEditorStatus
(
&
editorStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
aTextEditor
)
{
editorStatus
=
nsIEditingSession
:
:
eEditorOK
;
}
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetInt
(
STATE_DATA
editorStatus
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
editor
status
"
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aCommandName
"
obs_documentLocationChanged
"
)
)
{
if
(
!
aTextEditor
)
{
return
NS_OK
;
}
Document
*
document
=
aTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIURI
*
uri
=
document
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
uri
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aParams
.
SetISupports
(
STATE_DATA
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
