#
include
"
mozilla
/
EditorCommands
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
nsCommandParams
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsPresContext
.
h
"
#
define
STATE_ENABLED
"
state_enabled
"
#
define
STATE_ALL
"
state_all
"
#
define
STATE_ATTRIBUTE
"
state_attribute
"
#
define
STATE_DATA
"
state_data
"
namespace
mozilla
{
using
namespace
dom
;
StaticRefPtr
<
SetDocumentStateCommand
>
SetDocumentStateCommand
:
:
sInstance
;
bool
SetDocumentStateCommand
:
:
IsCommandEnabled
(
Command
aCommand
TextEditor
*
aTextEditor
)
const
{
if
(
aCommand
=
=
Command
:
:
SetDocumentReadOnly
)
{
return
!
!
aTextEditor
;
}
return
aTextEditor
&
&
aTextEditor
-
>
AsHTMLEditor
(
)
;
}
nsresult
SetDocumentStateCommand
:
:
DoCommand
(
Command
aCommand
TextEditor
&
aTextEditor
nsIPrincipal
*
aPrincipal
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
SetDocumentStateCommand
:
:
DoCommandParam
(
Command
aCommand
const
Maybe
<
bool
>
&
aBoolParam
TextEditor
&
aTextEditor
nsIPrincipal
*
aPrincipal
)
const
{
if
(
NS_WARN_IF
(
aBoolParam
.
isNothing
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aCommand
!
=
Command
:
:
SetDocumentReadOnly
&
&
NS_WARN_IF
(
!
aTextEditor
.
IsHTMLEditor
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
switch
(
aCommand
)
{
case
Command
:
:
SetDocumentModified
:
{
if
(
aBoolParam
.
value
(
)
)
{
nsresult
rv
=
aTextEditor
.
IncrementModificationCount
(
1
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
IncrementModificationCount
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aTextEditor
.
ResetModificationCount
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ResetModificationCount
(
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentReadOnly
:
{
if
(
aTextEditor
.
IsTextEditor
(
)
)
{
Element
*
inputOrTextArea
=
aTextEditor
.
GetExposedRoot
(
)
;
if
(
NS_WARN_IF
(
!
inputOrTextArea
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
inputOrTextArea
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
RefPtr
<
HTMLInputElement
>
inputElement
=
HTMLInputElement
:
:
FromNode
(
inputOrTextArea
)
)
{
if
(
inputElement
-
>
ReadOnly
(
)
=
=
aBoolParam
.
value
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
ErrorResult
error
;
inputElement
-
>
SetReadOnly
(
aBoolParam
.
value
(
)
error
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
RefPtr
<
HTMLTextAreaElement
>
textAreaElement
=
HTMLTextAreaElement
:
:
FromNode
(
inputOrTextArea
)
)
{
if
(
textAreaElement
-
>
ReadOnly
(
)
=
=
aBoolParam
.
value
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
ErrorResult
error
;
textAreaElement
-
>
SetReadOnly
(
aBoolParam
.
value
(
)
error
)
;
return
error
.
StealNSResult
(
)
;
}
NS_ASSERTION
(
false
"
Unexpected
exposed
root
element
fallthrough
to
directly
make
the
"
"
editor
readonly
"
)
;
}
ErrorResult
error
;
if
(
aBoolParam
.
value
(
)
)
{
nsresult
rv
=
aTextEditor
.
AddFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
AddFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aTextEditor
.
RemoveFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentUseCSS
:
{
nsresult
rv
=
MOZ_KnownLive
(
aTextEditor
.
AsHTMLEditor
(
)
)
-
>
SetIsCSSEnabled
(
aBoolParam
.
value
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetIsCSSEnabled
(
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
{
nsresult
rv
=
aTextEditor
.
AsHTMLEditor
(
)
-
>
SetReturnInParagraphCreatesNewParagraph
(
!
aBoolParam
.
value
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
ToggleObjectResizers
:
{
MOZ_KnownLive
(
aTextEditor
.
AsHTMLEditor
(
)
)
-
>
EnableObjectResizer
(
aBoolParam
.
value
(
)
)
;
return
NS_OK
;
}
case
Command
:
:
ToggleInlineTableEditor
:
{
MOZ_KnownLive
(
aTextEditor
.
AsHTMLEditor
(
)
)
-
>
EnableInlineTableEditor
(
aBoolParam
.
value
(
)
)
;
return
NS_OK
;
}
case
Command
:
:
ToggleAbsolutePositionEditor
:
{
MOZ_KnownLive
(
aTextEditor
.
AsHTMLEditor
(
)
)
-
>
EnableAbsolutePositionEditor
(
aBoolParam
.
value
(
)
)
;
return
NS_OK
;
}
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
nsresult
SetDocumentStateCommand
:
:
DoCommandParam
(
Command
aCommand
const
nsACString
&
aCStringParam
TextEditor
&
aTextEditor
nsIPrincipal
*
aPrincipal
)
const
{
if
(
NS_WARN_IF
(
aCStringParam
.
IsVoid
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aTextEditor
.
AsHTMLEditor
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
switch
(
aCommand
)
{
case
Command
:
:
SetDocumentDefaultParagraphSeparator
:
{
if
(
aCStringParam
.
LowerCaseEqualsLiteral
(
"
div
"
)
)
{
aTextEditor
.
AsHTMLEditor
(
)
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
div
)
;
return
NS_OK
;
}
if
(
aCStringParam
.
LowerCaseEqualsLiteral
(
"
p
"
)
)
{
aTextEditor
.
AsHTMLEditor
(
)
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
p
)
;
return
NS_OK
;
}
if
(
aCStringParam
.
LowerCaseEqualsLiteral
(
"
br
"
)
)
{
aTextEditor
.
AsHTMLEditor
(
)
-
>
SetDefaultParagraphSeparator
(
ParagraphSeparator
:
:
br
)
;
return
NS_OK
;
}
NS_WARNING
(
"
Invalid
default
paragraph
separator
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
nsresult
SetDocumentStateCommand
:
:
GetCommandStateParams
(
Command
aCommand
nsCommandParams
&
aParams
TextEditor
*
aTextEditor
nsIEditingSession
*
aEditingSession
)
const
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aTextEditor
-
>
AsHTMLEditor
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aParams
.
SetBool
(
STATE_ENABLED
IsCommandEnabled
(
aCommand
aTextEditor
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
switch
(
aCommand
)
{
case
Command
:
:
SetDocumentModified
:
{
bool
modified
;
rv
=
aTextEditor
-
>
GetDocumentModified
(
&
modified
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
GetDocumentModified
(
)
failed
"
)
;
return
rv
;
}
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
modified
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ATTRIBUTE
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentReadOnly
:
{
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
aTextEditor
-
>
IsReadonly
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ATTRIBUTE
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentUseCSS
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsCSSEnabled
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ALL
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
createPOnReturn
;
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
GetReturnInParagraphCreatesNewParagraph
(
&
createPOnReturn
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
failed
"
)
;
rv
=
aParams
.
SetBool
(
STATE_ATTRIBUTE
!
createPOnReturn
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ATTRIBUTE
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
SetDocumentDefaultParagraphSeparator
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
switch
(
htmlEditor
-
>
GetDefaultParagraphSeparator
(
)
)
{
case
ParagraphSeparator
:
:
div
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
"
div
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
div
\
"
"
)
;
return
NS_OK
;
}
case
ParagraphSeparator
:
:
p
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
"
p
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
p
\
"
"
)
;
return
NS_OK
;
}
case
ParagraphSeparator
:
:
br
:
{
DebugOnly
<
nsresult
>
rv
=
aParams
.
SetCString
(
STATE_ATTRIBUTE
"
br
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
command
params
to
return
\
"
br
\
"
"
)
;
return
NS_OK
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
paragraph
separator
value
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
case
Command
:
:
ToggleObjectResizers
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsObjectResizerEnabled
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ALL
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
ToggleInlineTableEditor
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsInlineTableEditorEnabled
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCommandParams
:
:
SetBool
(
STATE_ALL
)
failed
"
)
;
return
rv
;
}
case
Command
:
:
ToggleAbsolutePositionEditor
:
{
HTMLEditor
*
htmlEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
aParams
.
SetBool
(
STATE_ALL
htmlEditor
-
>
IsAbsolutePositionEditorEnabled
(
)
)
;
}
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
StaticRefPtr
<
DocumentStateCommand
>
DocumentStateCommand
:
:
sInstance
;
bool
DocumentStateCommand
:
:
IsCommandEnabled
(
Command
aCommand
TextEditor
*
aTextEditor
)
const
{
return
false
;
}
nsresult
DocumentStateCommand
:
:
DoCommand
(
Command
aCommand
TextEditor
&
aTextEditor
nsIPrincipal
*
aPrincipal
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
DocumentStateCommand
:
:
GetCommandStateParams
(
Command
aCommand
nsCommandParams
&
aParams
TextEditor
*
aTextEditor
nsIEditingSession
*
aEditingSession
)
const
{
switch
(
aCommand
)
{
case
Command
:
:
EditorObserverDocumentCreated
:
{
uint32_t
editorStatus
=
nsIEditingSession
:
:
eEditorErrorUnknown
;
if
(
aEditingSession
)
{
nsresult
rv
=
aEditingSession
-
>
GetEditorStatus
(
&
editorStatus
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsIEditingSession
:
:
GetEditorStatus
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
aTextEditor
)
{
editorStatus
=
nsIEditingSession
:
:
eEditorOK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
aParams
.
SetInt
(
STATE_DATA
editorStatus
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
set
editor
status
"
)
;
return
NS_OK
;
}
case
Command
:
:
EditorObserverDocumentLocationChanged
:
{
if
(
!
aTextEditor
)
{
return
NS_OK
;
}
Document
*
document
=
aTextEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIURI
*
uri
=
document
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
uri
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aParams
.
SetISupports
(
STATE_DATA
uri
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCOmmandParms
:
:
SetISupports
(
STATE_DATA
)
failed
"
)
;
return
rv
;
}
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
}
