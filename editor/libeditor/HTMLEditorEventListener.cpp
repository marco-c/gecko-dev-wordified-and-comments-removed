#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
nsresult
HTMLEditorEventListener
:
:
Connect
(
EditorBase
*
aEditorBase
)
{
if
(
NS_WARN_IF
(
!
aEditorBase
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
HTMLEditor
*
htmlEditor
=
aEditorBase
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
htmlEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
EditorEventListener
:
:
Connect
(
htmlEditor
)
;
}
void
HTMLEditorEventListener
:
:
Disconnect
(
)
{
if
(
DetachedFromEditor
(
)
)
{
EditorEventListener
:
:
Disconnect
(
)
;
}
if
(
mListeningToMouseMoveEventForResizers
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
ListenToMouseMoveEventForResizers
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
remove
resize
event
listener
of
resizers
"
)
;
}
if
(
mListeningToMouseMoveEventForGrabber
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
ListenToMouseMoveEventForGrabber
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
remove
resize
event
listener
of
grabber
"
)
;
}
if
(
mListeningToResizeEvent
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
ListenToWindowResizeEvent
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
remove
resize
event
listener
"
)
;
}
EditorEventListener
:
:
Disconnect
(
)
;
}
NS_IMETHODIMP
HTMLEditorEventListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
switch
(
internalEvent
-
>
mMessage
)
{
case
eMouseMove
:
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
MouseEvent
>
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
NS_WARN_IF
(
!
mouseEvent
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mEditorBase
-
>
AsHTMLEditor
(
)
;
MOZ_ASSERT
(
htmlEditor
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
OnMouseMove
(
mouseEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Resizers
failed
to
handle
mousemove
events
"
)
;
return
NS_OK
;
}
case
eResize
:
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mEditorBase
-
>
AsHTMLEditor
(
)
;
MOZ_ASSERT
(
htmlEditor
)
;
nsresult
rv
=
htmlEditor
-
>
RefreshResizers
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
default
:
nsresult
rv
=
EditorEventListener
:
:
HandleEvent
(
aEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
nsresult
HTMLEditorEventListener
:
:
ListenToMouseMoveEventForResizersOrGrabber
(
bool
aListen
bool
aForGrabber
)
{
MOZ_ASSERT
(
aForGrabber
?
mListeningToMouseMoveEventForGrabber
!
=
aListen
:
mListeningToMouseMoveEventForResizers
!
=
aListen
)
;
if
(
NS_WARN_IF
(
DetachedFromEditor
(
)
)
)
{
return
aListen
?
NS_ERROR_FAILURE
:
NS_OK
;
}
if
(
aListen
)
{
if
(
aForGrabber
&
&
mListeningToMouseMoveEventForResizers
)
{
mListeningToMouseMoveEventForGrabber
=
true
;
return
NS_OK
;
}
if
(
!
aForGrabber
&
&
mListeningToMouseMoveEventForGrabber
)
{
mListeningToMouseMoveEventForResizers
=
true
;
return
NS_OK
;
}
}
else
{
if
(
aForGrabber
&
&
mListeningToMouseMoveEventForResizers
)
{
mListeningToMouseMoveEventForGrabber
=
false
;
return
NS_OK
;
}
if
(
!
aForGrabber
&
&
mListeningToMouseMoveEventForGrabber
)
{
mListeningToMouseMoveEventForResizers
=
false
;
return
NS_OK
;
}
}
EventTarget
*
target
=
mEditorBase
-
>
AsHTMLEditor
(
)
-
>
GetDOMEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
EventListenerManager
*
eventListenerManager
=
target
-
>
GetOrCreateListenerManager
(
)
;
if
(
NS_WARN_IF
(
!
eventListenerManager
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aListen
)
{
eventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousemove
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
if
(
aForGrabber
)
{
mListeningToMouseMoveEventForGrabber
=
true
;
}
else
{
mListeningToMouseMoveEventForResizers
=
true
;
}
return
NS_OK
;
}
eventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mousemove
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
if
(
aForGrabber
)
{
mListeningToMouseMoveEventForGrabber
=
false
;
}
else
{
mListeningToMouseMoveEventForResizers
=
false
;
}
return
NS_OK
;
}
nsresult
HTMLEditorEventListener
:
:
ListenToWindowResizeEvent
(
bool
aListen
)
{
if
(
mListeningToResizeEvent
=
=
aListen
)
{
return
NS_OK
;
}
if
(
DetachedFromEditor
(
)
)
{
return
aListen
?
NS_ERROR_FAILURE
:
NS_OK
;
}
Document
*
document
=
mEditorBase
-
>
AsHTMLEditor
(
)
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
nsPIDOMWindowOuter
*
window
=
document
-
>
GetWindow
(
)
;
if
(
!
window
)
{
NS_WARNING_ASSERTION
(
!
aListen
"
There
should
be
window
when
adding
event
listener
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
window
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
EventListenerManager
*
eventListenerManager
=
target
-
>
GetOrCreateListenerManager
(
)
;
if
(
NS_WARN_IF
(
!
eventListenerManager
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aListen
)
{
eventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
resize
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
mListeningToResizeEvent
=
true
;
return
NS_OK
;
}
eventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
resize
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
mListeningToResizeEvent
=
false
;
return
NS_OK
;
}
nsresult
HTMLEditorEventListener
:
:
MouseUp
(
MouseEvent
*
aMouseEvent
)
{
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mEditorBase
-
>
AsHTMLEditor
(
)
;
MOZ_ASSERT
(
htmlEditor
)
;
RefPtr
<
EventTarget
>
target
=
aMouseEvent
-
>
GetTarget
(
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
target
)
;
int32_t
clientX
=
aMouseEvent
-
>
ClientX
(
)
;
int32_t
clientY
=
aMouseEvent
-
>
ClientY
(
)
;
htmlEditor
-
>
OnMouseUp
(
clientX
clientY
element
)
;
return
EditorEventListener
:
:
MouseUp
(
aMouseEvent
)
;
}
nsresult
HTMLEditorEventListener
:
:
MouseDown
(
MouseEvent
*
aMouseEvent
)
{
if
(
NS_WARN_IF
(
!
aMouseEvent
)
|
|
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
EnsureCommitComposition
(
)
)
{
return
NS_OK
;
}
WidgetMouseEvent
*
mousedownEvent
=
aMouseEvent
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
mEditorBase
-
>
AsHTMLEditor
(
)
;
MOZ_ASSERT
(
htmlEditor
)
;
if
(
!
htmlEditor
-
>
IsAcceptableInputEvent
(
mousedownEvent
)
)
{
return
EditorEventListener
:
:
MouseDown
(
aMouseEvent
)
;
}
int16_t
buttonNumber
=
aMouseEvent
-
>
Button
(
)
;
bool
isContextClick
=
buttonNumber
=
=
2
;
int32_t
clickCount
=
aMouseEvent
-
>
Detail
(
)
;
RefPtr
<
EventTarget
>
target
=
aMouseEvent
-
>
GetExplicitOriginalTarget
(
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
target
)
;
if
(
isContextClick
|
|
(
buttonNumber
=
=
0
&
&
clickCount
=
=
2
)
)
{
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_OK
)
;
int32_t
offset
=
-
1
;
nsCOMPtr
<
nsIContent
>
parentContent
=
aMouseEvent
-
>
GetRangeParentContentAndOffset
(
&
offset
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
nodeIsInSelection
=
false
;
if
(
isContextClick
&
&
!
selection
-
>
IsCollapsed
(
)
)
{
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
!
range
)
{
continue
;
}
IgnoredErrorResult
err
;
nodeIsInSelection
=
range
-
>
IsPointInRange
(
*
parentContent
offset
err
)
&
&
!
err
.
Failed
(
)
;
if
(
nodeIsInSelection
)
{
break
;
}
}
}
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
target
)
;
if
(
node
&
&
!
nodeIsInSelection
)
{
if
(
!
element
)
{
if
(
isContextClick
)
{
selection
-
>
Collapse
(
parentContent
offset
)
;
}
else
{
Element
*
linkElement
=
htmlEditor
-
>
GetElementOrParentByTagName
(
*
nsGkAtoms
:
:
href
node
)
;
if
(
linkElement
)
{
element
=
linkElement
;
}
}
}
if
(
element
)
{
if
(
isContextClick
&
&
!
HTMLEditUtils
:
:
IsImage
(
node
)
)
{
selection
-
>
Collapse
(
parentContent
offset
)
;
}
else
{
htmlEditor
-
>
SelectElement
(
element
)
;
}
if
(
DetachedFromEditor
(
)
)
{
return
NS_OK
;
}
}
}
htmlEditor
-
>
CheckSelectionStateForAnonymousButtons
(
)
;
if
(
element
|
|
isContextClick
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
}
else
if
(
!
isContextClick
&
&
buttonNumber
=
=
0
&
&
clickCount
=
=
1
)
{
int32_t
clientX
=
aMouseEvent
-
>
ClientX
(
)
;
int32_t
clientY
=
aMouseEvent
-
>
ClientY
(
)
;
htmlEditor
-
>
OnMouseDown
(
clientX
clientY
element
aMouseEvent
)
;
}
return
EditorEventListener
:
:
MouseDown
(
aMouseEvent
)
;
}
nsresult
HTMLEditorEventListener
:
:
MouseClick
(
WidgetMouseEvent
*
aMouseClickEvent
)
{
if
(
NS_WARN_IF
(
DetachedFromEditor
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
EventTarget
>
target
=
aMouseClickEvent
-
>
GetDOMEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
target
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mEditorBase
-
>
AsHTMLEditor
(
)
;
MOZ_ASSERT
(
htmlEditor
)
;
htmlEditor
-
>
DoInlineTableEditingAction
(
*
element
)
;
if
(
htmlEditor
-
>
Destroyed
(
)
)
{
return
NS_OK
;
}
return
EditorEventListener
:
:
MouseClick
(
aMouseClickEvent
)
;
}
}
