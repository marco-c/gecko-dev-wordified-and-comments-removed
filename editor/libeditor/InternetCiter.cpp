#
include
"
InternetCiter
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
intl
/
LineBreaker
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringIterator
.
h
"
namespace
mozilla
{
nsresult
InternetCiter
:
:
GetCiteString
(
const
nsAString
&
aInString
nsAString
&
aOutString
)
{
aOutString
.
Truncate
(
)
;
char16_t
uch
=
HTMLEditUtils
:
:
kNewLine
;
nsReadingIterator
<
char16_t
>
beginIter
endIter
;
aInString
.
BeginReading
(
beginIter
)
;
aInString
.
EndReading
(
endIter
)
;
while
(
beginIter
!
=
endIter
&
&
(
*
endIter
=
=
HTMLEditUtils
:
:
kCarridgeReturn
|
|
*
endIter
=
=
HTMLEditUtils
:
:
kNewLine
)
)
{
-
-
endIter
;
}
while
(
beginIter
!
=
endIter
)
{
if
(
uch
=
=
HTMLEditUtils
:
:
kNewLine
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kGreaterThan
)
;
if
(
*
beginIter
!
=
HTMLEditUtils
:
:
kGreaterThan
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kSpace
)
;
}
}
uch
=
*
beginIter
;
+
+
beginIter
;
aOutString
+
=
uch
;
}
if
(
uch
!
=
HTMLEditUtils
:
:
kNewLine
)
{
aOutString
+
=
HTMLEditUtils
:
:
kNewLine
;
}
return
NS_OK
;
}
static
void
AddCite
(
nsAString
&
aOutString
int32_t
citeLevel
)
{
for
(
int32_t
i
=
0
;
i
<
citeLevel
;
+
+
i
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kGreaterThan
)
;
}
if
(
citeLevel
>
0
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kSpace
)
;
}
}
static
inline
void
BreakLine
(
nsAString
&
aOutString
uint32_t
&
outStringCol
uint32_t
citeLevel
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kNewLine
)
;
if
(
citeLevel
>
0
)
{
AddCite
(
aOutString
citeLevel
)
;
outStringCol
=
citeLevel
+
1
;
}
else
{
outStringCol
=
0
;
}
}
static
inline
bool
IsSpace
(
char16_t
c
)
{
return
(
nsCRT
:
:
IsAsciiSpace
(
c
)
|
|
(
c
=
=
HTMLEditUtils
:
:
kNewLine
)
|
|
(
c
=
=
HTMLEditUtils
:
:
kCarridgeReturn
)
|
|
(
c
=
=
HTMLEditUtils
:
:
kNBSP
)
)
;
}
nsresult
InternetCiter
:
:
Rewrap
(
const
nsAString
&
aInString
uint32_t
aWrapCol
uint32_t
aFirstLineOffset
bool
aRespectNewlines
nsAString
&
aOutString
)
{
#
ifdef
DEBUG
int32_t
crPosition
=
aInString
.
FindChar
(
HTMLEditUtils
:
:
kCarridgeReturn
)
;
NS_ASSERTION
(
crPosition
<
0
"
Rewrap
:
CR
in
string
gotten
from
DOM
!
\
n
"
)
;
#
endif
aOutString
.
Truncate
(
)
;
nsresult
rv
;
RefPtr
<
mozilla
:
:
intl
:
:
LineBreaker
>
lineBreaker
=
mozilla
:
:
intl
:
:
LineBreaker
:
:
Create
(
)
;
MOZ_ASSERT
(
lineBreaker
)
;
uint32_t
length
;
uint32_t
posInString
=
0
;
uint32_t
outStringCol
=
0
;
uint32_t
citeLevel
=
0
;
const
nsPromiseFlatString
&
tString
=
PromiseFlatString
(
aInString
)
;
length
=
tString
.
Length
(
)
;
while
(
posInString
<
length
)
{
uint32_t
newCiteLevel
=
0
;
while
(
posInString
<
length
&
&
tString
[
posInString
]
=
=
HTMLEditUtils
:
:
kGreaterThan
)
{
+
+
newCiteLevel
;
+
+
posInString
;
while
(
posInString
<
length
&
&
tString
[
posInString
]
=
=
HTMLEditUtils
:
:
kSpace
)
{
+
+
posInString
;
}
}
if
(
posInString
>
=
length
)
{
break
;
}
if
(
tString
[
posInString
]
=
=
HTMLEditUtils
:
:
kNewLine
&
&
!
aOutString
.
IsEmpty
(
)
)
{
if
(
aOutString
.
Last
(
)
!
=
HTMLEditUtils
:
:
kNewLine
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kNewLine
)
;
}
AddCite
(
aOutString
newCiteLevel
)
;
aOutString
.
Append
(
HTMLEditUtils
:
:
kNewLine
)
;
+
+
posInString
;
outStringCol
=
0
;
continue
;
}
if
(
newCiteLevel
!
=
citeLevel
&
&
posInString
>
newCiteLevel
+
1
&
&
outStringCol
)
{
BreakLine
(
aOutString
outStringCol
0
)
;
}
citeLevel
=
newCiteLevel
;
if
(
!
outStringCol
)
{
AddCite
(
aOutString
citeLevel
)
;
outStringCol
=
citeLevel
+
(
citeLevel
?
1
:
0
)
;
}
else
if
(
outStringCol
>
citeLevel
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kSpace
)
;
+
+
outStringCol
;
}
int32_t
nextNewline
=
tString
.
FindChar
(
HTMLEditUtils
:
:
kNewLine
posInString
)
;
if
(
nextNewline
<
0
)
{
nextNewline
=
length
;
}
if
(
!
citeLevel
)
{
aOutString
.
Append
(
Substring
(
tString
posInString
nextNewline
-
posInString
)
)
;
outStringCol
+
=
nextNewline
-
posInString
;
if
(
nextNewline
!
=
(
int32_t
)
length
)
{
aOutString
.
Append
(
HTMLEditUtils
:
:
kNewLine
)
;
outStringCol
=
0
;
}
posInString
=
nextNewline
+
1
;
continue
;
}
while
(
(
int32_t
)
posInString
<
nextNewline
)
{
while
(
(
int32_t
)
posInString
<
nextNewline
&
&
nsCRT
:
:
IsAsciiSpace
(
tString
[
posInString
]
)
)
{
+
+
posInString
;
}
if
(
outStringCol
+
nextNewline
-
posInString
<
=
aWrapCol
-
citeLevel
-
1
)
{
if
(
nextNewline
+
1
=
=
(
int32_t
)
length
&
&
tString
[
nextNewline
-
1
]
=
=
HTMLEditUtils
:
:
kNewLine
)
{
+
+
nextNewline
;
}
int32_t
lastRealChar
=
nextNewline
;
while
(
(
uint32_t
)
lastRealChar
>
posInString
&
&
nsCRT
:
:
IsAsciiSpace
(
tString
[
lastRealChar
-
1
]
)
)
{
-
-
lastRealChar
;
}
aOutString
+
=
Substring
(
tString
posInString
lastRealChar
-
posInString
)
;
outStringCol
+
=
lastRealChar
-
posInString
;
posInString
=
nextNewline
+
1
;
continue
;
}
int32_t
eol
=
posInString
+
aWrapCol
-
citeLevel
-
outStringCol
;
if
(
eol
<
=
(
int32_t
)
posInString
)
{
BreakLine
(
aOutString
outStringCol
citeLevel
)
;
continue
;
}
int32_t
breakPt
=
0
;
rv
=
NS_ERROR_BASE
;
if
(
lineBreaker
)
{
breakPt
=
lineBreaker
-
>
Prev
(
tString
.
get
(
)
+
posInString
length
-
posInString
eol
+
1
-
posInString
)
;
if
(
breakPt
=
=
NS_LINEBREAKER_NEED_MORE_TEXT
)
{
if
(
outStringCol
>
citeLevel
+
1
)
{
BreakLine
(
aOutString
outStringCol
citeLevel
)
;
continue
;
}
breakPt
=
lineBreaker
-
>
DeprecatedNext
(
tString
.
get
(
)
+
posInString
length
-
posInString
eol
-
posInString
)
;
rv
=
breakPt
=
=
NS_LINEBREAKER_NEED_MORE_TEXT
?
NS_ERROR_BASE
:
NS_OK
;
}
else
{
rv
=
NS_OK
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
breakPt
=
eol
;
}
const
int
SLOP
=
6
;
if
(
outStringCol
+
breakPt
>
aWrapCol
+
SLOP
&
&
outStringCol
>
citeLevel
+
1
)
{
BreakLine
(
aOutString
outStringCol
citeLevel
)
;
continue
;
}
nsAutoString
sub
(
Substring
(
tString
posInString
breakPt
)
)
;
int32_t
subend
=
sub
.
Length
(
)
;
while
(
subend
>
0
&
&
IsSpace
(
sub
[
subend
-
1
]
)
)
{
-
-
subend
;
}
sub
.
Left
(
sub
subend
)
;
aOutString
+
=
sub
;
outStringCol
+
=
sub
.
Length
(
)
;
posInString
+
=
breakPt
;
while
(
posInString
<
length
&
&
IsSpace
(
tString
[
posInString
]
)
)
{
+
+
posInString
;
}
if
(
posInString
<
length
)
{
BreakLine
(
aOutString
outStringCol
citeLevel
)
;
}
}
}
return
NS_OK
;
}
}
