#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nscore
.
h
"
class
nsILoadContext
;
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
nsresult
TextEditor
:
:
PrepareTransferable
(
nsITransferable
*
*
transferable
)
{
nsresult
rv
=
CallCreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
transferable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
transferable
)
{
RefPtr
<
Document
>
destdoc
=
GetDocument
(
)
;
nsILoadContext
*
loadContext
=
destdoc
?
destdoc
-
>
GetLoadContext
(
)
:
nullptr
;
(
*
transferable
)
-
>
Init
(
loadContext
)
;
(
*
transferable
)
-
>
AddDataFlavor
(
kUnicodeMime
)
;
(
*
transferable
)
-
>
AddDataFlavor
(
kMozTextInternal
)
;
}
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
PrepareToInsertContent
(
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
if
(
aDoDeleteSelection
)
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointToInsert
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
TextEditor
:
:
InsertTextAt
(
const
nsAString
&
aStringToInsert
const
EditorDOMPoint
&
aPointToInsert
bool
aDoDeleteSelection
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
nsresult
rv
=
PrepareToInsertContent
(
aPointToInsert
aDoDeleteSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertTextAsSubAction
(
aStringToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextEditor
:
:
InsertTextFromTransferable
(
nsITransferable
*
aTransferable
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
nsAutoCString
bestFlavor
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
if
(
NS_SUCCEEDED
(
aTransferable
-
>
GetAnyTransferData
(
bestFlavor
getter_AddRefs
(
genericDataObj
)
)
)
&
&
(
bestFlavor
.
EqualsLiteral
(
kUnicodeMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kMozTextInternal
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsAutoString
stuffToPaste
;
if
(
nsCOMPtr
<
nsISupportsString
>
text
=
do_QueryInterface
(
genericDataObj
)
)
{
text
-
>
GetData
(
stuffToPaste
)
;
}
MOZ_ASSERT
(
GetEditAction
(
)
=
=
EditAction
:
:
ePaste
)
;
UpdateEditActionData
(
stuffToPaste
)
;
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
stuffToPaste
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
nsresult
rv
=
InsertTextAsSubAction
(
stuffToPaste
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
ScrollSelectionIntoView
(
false
)
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
OnDrop
(
DragEvent
*
aDropEvent
)
{
if
(
NS_WARN_IF
(
!
aDropEvent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
CommitComposition
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDrop
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
DataTransfer
>
dataTransfer
=
aDropEvent
-
>
GetDataTransfer
(
)
;
if
(
NS_WARN_IF
(
!
dataTransfer
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
NS_WARN_IF
(
!
dragSession
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
sourceNode
=
dataTransfer
-
>
GetMozSourceNode
(
)
;
RefPtr
<
Document
>
srcdoc
;
if
(
sourceNode
)
{
srcdoc
=
sourceNode
-
>
OwnerDoc
(
)
;
}
if
(
nsContentUtils
:
:
CheckForSubFrameDrop
(
dragSession
aDropEvent
-
>
WidgetEventPtr
(
)
-
>
AsDragEvent
(
)
)
)
{
if
(
srcdoc
&
&
!
IsSafeToInsertData
(
srcdoc
)
)
{
return
NS_OK
;
}
}
Document
*
destdoc
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
destdoc
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
uint32_t
numItems
=
dataTransfer
-
>
MozItemCount
(
)
;
if
(
NS_WARN_IF
(
!
numItems
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
droppedAt
(
aDropEvent
-
>
GetRangeParent
(
)
aDropEvent
-
>
RangeOffset
(
)
)
;
if
(
NS_WARN_IF
(
!
droppedAt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
deleteSelection
=
false
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
&
&
srcdoc
=
=
destdoc
)
{
uint32_t
rangeCount
=
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
for
(
uint32_t
j
=
0
;
j
<
rangeCount
;
j
+
+
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
j
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
continue
;
}
IgnoredErrorResult
errorIgnored
;
if
(
range
-
>
IsPointInRange
(
*
droppedAt
.
GetContainer
(
)
droppedAt
.
Offset
(
)
errorIgnored
)
&
&
!
errorIgnored
.
Failed
(
)
)
{
return
NS_OK
;
}
}
uint32_t
dropEffect
=
dataTransfer
-
>
DropEffectInt
(
)
;
deleteSelection
=
!
(
dropEffect
&
nsIDragService
:
:
DRAGDROP_ACTION_COPY
)
;
}
if
(
IsPlaintextEditor
(
)
)
{
for
(
nsIContent
*
content
=
droppedAt
.
GetContainerAsContent
(
)
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
(
do_QueryInterface
(
content
)
)
;
if
(
formControl
&
&
!
formControl
-
>
AllowDrop
(
)
)
{
return
NS_OK
;
}
}
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
SelectionBatcher
selectionBatcher
(
SelectionRefPtr
(
)
)
;
if
(
deleteSelection
&
&
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
PrepareToInsertContent
(
droppedAt
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
|
|
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
droppedAt
=
SelectionRefPtr
(
)
-
>
FocusRef
(
)
;
if
(
NS_WARN_IF
(
!
droppedAt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mDispatchInputEvent
)
{
RefPtr
<
DataTransfer
>
dataTransfer
;
FireInputEvent
(
EditAction
:
:
eDeleteByDrag
VoidString
(
)
dataTransfer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
if
(
!
AsHTMLEditor
(
)
)
{
AutoTArray
<
nsString
5
>
textArray
;
textArray
.
SetCapacity
(
numItems
)
;
uint32_t
textLength
=
0
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
+
+
i
)
{
nsCOMPtr
<
nsIVariant
>
data
;
dataTransfer
-
>
GetDataAtNoSecurityCheck
(
NS_LITERAL_STRING
(
"
text
/
plain
"
)
i
getter_AddRefs
(
data
)
)
;
if
(
!
data
)
{
continue
;
}
nsString
insertText
;
data
-
>
GetAsAString
(
insertText
)
;
if
(
insertText
.
IsEmpty
(
)
)
{
continue
;
}
textArray
.
AppendElement
(
insertText
)
;
textLength
+
=
insertText
.
Length
(
)
;
}
nsString
data
;
data
.
SetCapacity
(
textLength
)
;
for
(
nsString
&
text
:
Reversed
(
textArray
)
)
{
data
.
Append
(
text
)
;
}
editActionData
.
SetData
(
data
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
data
)
;
InsertTextAt
(
data
droppedAt
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
else
{
editActionData
.
InitializeDataTransfer
(
dataTransfer
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
AsHTMLEditor
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
+
+
i
)
{
htmlEditor
-
>
InsertFromDataTransfer
(
dataTransfer
i
srcdoc
droppedAt
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
ScrollSelectionIntoView
(
false
)
;
return
NS_OK
;
}
nsresult
TextEditor
:
:
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
AsHTMLEditor
(
)
)
{
editActionData
.
InitializeDataTransferWithClipboard
(
SettingDataTransfer
:
:
eWithFormat
aClipboardType
)
;
nsresult
rv
=
AsHTMLEditor
(
)
-
>
PasteInternal
(
aClipboardType
aDispatchPasteEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aDispatchPasteEvent
&
&
!
FireClipboardEvent
(
ePaste
aClipboardType
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsITransferable
>
transferable
;
rv
=
PrepareTransferable
(
getter_AddRefs
(
transferable
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
transferable
)
)
{
return
NS_OK
;
}
rv
=
clipboard
-
>
GetData
(
transferable
aClipboardType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
rv
=
InsertTextFromTransferable
(
transferable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditor
:
:
PasteTransferable
(
nsITransferable
*
aTransferable
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
FireClipboardEvent
(
ePaste
-
1
)
)
{
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
return
InsertTextFromTransferable
(
aTransferable
)
;
}
NS_IMETHODIMP
TextEditor
:
:
CanPaste
(
int32_t
aSelectionType
bool
*
aCanPaste
)
{
NS_ENSURE_ARG_POINTER
(
aCanPaste
)
;
*
aCanPaste
=
false
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
&
&
doc
-
>
IsHTMLOrXHTML
(
)
)
{
*
aCanPaste
=
true
;
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
char
*
textEditorFlavors
[
]
=
{
kUnicodeMime
}
;
bool
haveFlavors
;
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textEditorFlavors
ArrayLength
(
textEditorFlavors
)
aSelectionType
&
haveFlavors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCanPaste
=
haveFlavors
;
return
NS_OK
;
}
bool
TextEditor
:
:
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
if
(
!
aTransferable
)
{
return
true
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
kUnicodeMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
data
)
{
return
true
;
}
return
false
;
}
bool
TextEditor
:
:
IsSafeToInsertData
(
Document
*
aSourceDoc
)
{
bool
isSafe
=
false
;
RefPtr
<
Document
>
destdoc
=
GetDocument
(
)
;
NS_ASSERTION
(
destdoc
"
Where
is
our
destination
doc
?
"
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
destdoc
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
if
(
dsti
)
{
dsti
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
root
)
;
isSafe
=
docShell
&
&
docShell
-
>
GetAppType
(
)
=
=
nsIDocShell
:
:
APP_TYPE_EDITOR
;
if
(
!
isSafe
&
&
aSourceDoc
)
{
nsIPrincipal
*
srcPrincipal
=
aSourceDoc
-
>
NodePrincipal
(
)
;
nsIPrincipal
*
destPrincipal
=
destdoc
-
>
NodePrincipal
(
)
;
NS_ASSERTION
(
srcPrincipal
&
&
destPrincipal
"
How
come
we
don
'
t
have
a
principal
?
"
)
;
srcPrincipal
-
>
Subsumes
(
destPrincipal
&
isSafe
)
;
}
return
isSafe
;
}
}
