#
include
"
TextEditor
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
using
namespace
dom
;
nsresult
TextEditor
:
:
InsertTextFromTransferable
(
nsITransferable
*
aTransferable
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsTextEditor
(
)
)
;
nsAutoCString
bestFlavor
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
nsresult
rv
=
aTransferable
-
>
GetAnyTransferData
(
bestFlavor
getter_AddRefs
(
genericDataObj
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsITransferable
:
:
GetAnyDataTransferData
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
bestFlavor
.
EqualsLiteral
(
kTextMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kMozTextInternal
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsAutoString
stuffToPaste
;
if
(
nsCOMPtr
<
nsISupportsString
>
text
=
do_QueryInterface
(
genericDataObj
)
)
{
text
-
>
GetData
(
stuffToPaste
)
;
}
MOZ_ASSERT
(
GetEditAction
(
)
=
=
EditAction
:
:
ePaste
)
;
UpdateEditActionData
(
stuffToPaste
)
;
nsresult
rv
=
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
EditorBase
:
:
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
rv
;
}
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
stuffToPaste
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
nsresult
rv
=
InsertTextAsSubAction
(
stuffToPaste
SelectionHandling
:
:
Delete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
return
rv
;
}
}
}
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
InsertDroppedDataTransferAsAction
(
AutoEditActionDataSetter
&
aEditActionData
DataTransfer
&
aDataTransfer
const
EditorDOMPoint
&
aDroppedAt
nsIPrincipal
*
aSourcePrincipal
)
{
MOZ_ASSERT
(
aEditActionData
.
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
)
;
MOZ_ASSERT
(
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
)
;
MOZ_ASSERT
(
aDroppedAt
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aDataTransfer
.
MozItemCount
(
)
>
0
)
;
uint32_t
numItems
=
aDataTransfer
.
MozItemCount
(
)
;
AutoTArray
<
nsString
5
>
textArray
;
textArray
.
SetCapacity
(
numItems
)
;
uint32_t
textLength
=
0
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
+
+
i
)
{
nsCOMPtr
<
nsIVariant
>
data
;
aDataTransfer
.
GetDataAtNoSecurityCheck
(
u
"
text
/
plain
"
_ns
i
getter_AddRefs
(
data
)
)
;
if
(
!
data
)
{
continue
;
}
nsString
insertText
;
data
-
>
GetAsAString
(
insertText
)
;
if
(
insertText
.
IsEmpty
(
)
)
{
continue
;
}
textArray
.
AppendElement
(
insertText
)
;
textLength
+
=
insertText
.
Length
(
)
;
}
nsString
data
;
data
.
SetCapacity
(
textLength
)
;
for
(
nsString
&
text
:
Reversed
(
textArray
)
)
{
data
.
Append
(
text
)
;
}
aEditActionData
.
SetData
(
data
)
;
nsresult
rv
=
aEditActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
rv
;
}
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
data
)
;
rv
=
InsertTextAt
(
data
aDroppedAt
DeleteSelectedContent
:
:
No
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextAt
(
DeleteSelectedContent
:
:
No
)
"
"
failed
but
ignored
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
PasteAsAction
(
int32_t
aClipboardType
DispatchPasteEvent
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aDispatchPasteEvent
=
=
DispatchPasteEvent
:
:
Yes
)
{
Result
<
ClipboardEventResult
nsresult
>
ret
=
DispatchClipboardEventAndUpdateClipboard
(
ePaste
aClipboardType
)
;
if
(
MOZ_UNLIKELY
(
ret
.
isErr
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DispatchClipboardEventAndUpdateClipboard
(
ePaste
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
ret
.
unwrapErr
(
)
)
;
}
switch
(
ret
.
inspect
(
)
)
{
case
ClipboardEventResult
:
:
DoDefault
:
break
;
case
ClipboardEventResult
:
:
DefaultPreventedOfPaste
:
case
ClipboardEventResult
:
:
IgnoredOrError
:
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
case
ClipboardEventResult
:
:
CopyOrCutHandled
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
result
for
ePaste
"
)
;
}
}
else
{
editActionData
.
NotifyOfDispatchingClipboardEvent
(
)
;
}
if
(
!
GetDocument
(
)
)
{
NS_WARNING
(
"
The
editor
didn
'
t
have
document
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
nsIClipboard
service
"
)
;
return
rv
;
}
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
maybeTransferable
=
EditorUtils
:
:
CreateTransferableForPlainText
(
*
GetDocument
(
)
)
;
if
(
maybeTransferable
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorUtils
:
:
CreateTransferableForPlainText
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
maybeTransferable
.
unwrapErr
(
)
)
;
}
nsCOMPtr
<
nsITransferable
>
transferable
(
maybeTransferable
.
unwrap
(
)
)
;
if
(
NS_WARN_IF
(
!
transferable
)
)
{
NS_WARNING
(
"
EditorUtils
:
:
CreateTransferableForPlainText
(
)
returned
nullptr
but
"
"
ignored
"
)
;
return
NS_OK
;
}
rv
=
clipboard
-
>
GetData
(
transferable
aClipboardType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsIClipboard
:
:
GetData
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
rv
=
InsertTextFromTransferable
(
transferable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertTextFromTransferable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
{
Result
<
ClipboardEventResult
nsresult
>
ret
=
DispatchClipboardEventAndUpdateClipboard
(
ePaste
-
1
)
;
if
(
MOZ_UNLIKELY
(
ret
.
isErr
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DispatchClipboardEventAndUpdateClipboard
(
ePaste
-
1
)
"
"
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
ret
.
unwrapErr
(
)
)
;
}
switch
(
ret
.
inspect
(
)
)
{
case
ClipboardEventResult
:
:
DoDefault
:
break
;
case
ClipboardEventResult
:
:
DefaultPreventedOfPaste
:
case
ClipboardEventResult
:
:
IgnoredOrError
:
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
case
ClipboardEventResult
:
:
CopyOrCutHandled
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
result
for
ePaste
"
)
;
}
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
InsertTextFromTransferable
(
aTransferable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertTextFromTransferable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
bool
TextEditor
:
:
CanPaste
(
int32_t
aClipboardType
)
const
{
if
(
AreClipboardCommandsUnconditionallyEnabled
(
)
)
{
return
true
;
}
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
nsIClipboard
service
"
)
;
return
false
;
}
AutoTArray
<
nsCString
1
>
textEditorFlavors
=
{
nsDependentCString
(
kTextMime
)
}
;
bool
haveFlavors
;
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textEditorFlavors
aClipboardType
&
haveFlavors
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsIClipboard
:
:
HasDataMatchingFlavors
(
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
haveFlavors
;
}
bool
TextEditor
:
:
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
if
(
!
aTransferable
)
{
return
true
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
kTextMime
getter_AddRefs
(
data
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsITransferable
:
:
GetTransferData
(
kTextMime
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
data
;
}
}
