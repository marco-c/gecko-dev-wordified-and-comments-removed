#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
using
namespace
dom
;
nsresult
TextEditor
:
:
InsertTextFromTransferable
(
nsITransferable
*
aTransferable
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
nsAutoCString
bestFlavor
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
nsresult
rv
=
aTransferable
-
>
GetAnyTransferData
(
bestFlavor
getter_AddRefs
(
genericDataObj
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsITransferable
:
:
GetAnyDataTransferData
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
bestFlavor
.
EqualsLiteral
(
kUnicodeMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kMozTextInternal
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsAutoString
stuffToPaste
;
if
(
nsCOMPtr
<
nsISupportsString
>
text
=
do_QueryInterface
(
genericDataObj
)
)
{
text
-
>
GetData
(
stuffToPaste
)
;
}
MOZ_ASSERT
(
GetEditAction
(
)
=
=
EditAction
:
:
ePaste
)
;
UpdateEditActionData
(
stuffToPaste
)
;
nsresult
rv
=
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
EditorBase
:
:
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
rv
;
}
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
stuffToPaste
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
nsresult
rv
=
InsertTextAsSubAction
(
stuffToPaste
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextAsSubAction
(
)
failed
"
)
;
return
rv
;
}
}
}
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
OnDrop
(
DragEvent
*
aDropEvent
)
{
if
(
NS_WARN_IF
(
!
aDropEvent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDrop
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
DataTransfer
>
dataTransfer
=
aDropEvent
-
>
GetDataTransfer
(
)
;
if
(
NS_WARN_IF
(
!
dataTransfer
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
NS_WARN_IF
(
!
dragSession
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
sourceNode
=
dataTransfer
-
>
GetMozSourceNode
(
)
;
RefPtr
<
Document
>
srcdoc
;
if
(
sourceNode
)
{
srcdoc
=
sourceNode
-
>
OwnerDoc
(
)
;
}
if
(
nsContentUtils
:
:
CheckForSubFrameDrop
(
dragSession
aDropEvent
-
>
WidgetEventPtr
(
)
-
>
AsDragEvent
(
)
)
)
{
if
(
srcdoc
&
&
!
IsSafeToInsertData
(
srcdoc
)
)
{
return
NS_OK
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
const
uint32_t
numItems
=
dataTransfer
-
>
MozItemCount
(
)
;
if
(
NS_WARN_IF
(
!
numItems
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
dropOffset
=
-
1
;
nsCOMPtr
<
nsIContent
>
dropParentContent
=
aDropEvent
-
>
GetRangeParentContentAndOffset
(
&
dropOffset
)
;
EditorDOMPoint
droppedAt
(
dropParentContent
dropOffset
)
;
if
(
NS_WARN_IF
(
!
droppedAt
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
droppedAt
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
sourceNode
&
&
sourceNode
-
>
IsEditable
(
)
&
&
srcdoc
=
=
document
)
{
bool
isPointInSelection
=
EditorUtils
:
:
IsPointInSelection
(
SelectionRef
(
)
*
droppedAt
.
GetContainer
(
)
droppedAt
.
Offset
(
)
)
;
if
(
isPointInSelection
)
{
return
NS_OK
;
}
}
RefPtr
<
TextEditor
>
editorToDeleteSelection
;
if
(
sourceNode
&
&
sourceNode
-
>
IsEditable
(
)
&
&
srcdoc
=
=
document
)
{
if
(
(
dataTransfer
-
>
DropEffectInt
(
)
&
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
&
&
!
(
dataTransfer
-
>
DropEffectInt
(
)
&
nsIDragService
:
:
DRAGDROP_ACTION_COPY
)
)
{
if
(
sourceNode
-
>
IsInNativeAnonymousSubtree
(
)
)
{
if
(
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
sourceNode
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
)
{
editorToDeleteSelection
=
textControlElement
-
>
GetTextEditor
(
)
;
}
}
else
if
(
AsHTMLEditor
(
)
)
{
editorToDeleteSelection
=
this
;
}
else
{
editorToDeleteSelection
=
nsContentUtils
:
:
GetHTMLEditor
(
srcdoc
-
>
GetPresContext
(
)
)
;
}
}
if
(
editorToDeleteSelection
&
&
!
editorToDeleteSelection
-
>
IsModifiable
(
)
)
{
editorToDeleteSelection
=
nullptr
;
}
if
(
editorToDeleteSelection
)
{
if
(
Selection
*
selection
=
editorToDeleteSelection
-
>
GetSelection
(
)
)
{
if
(
selection
-
>
IsCollapsed
(
)
)
{
editorToDeleteSelection
=
nullptr
;
}
}
}
}
if
(
IsPlaintextEditor
(
)
)
{
for
(
nsIContent
*
content
=
droppedAt
.
GetContainerAsContent
(
)
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
(
do_QueryInterface
(
content
)
)
;
if
(
formControl
&
&
!
formControl
-
>
AllowDrop
(
)
)
{
return
NS_OK
;
}
}
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
SelectionBatcher
selectionBatcher
(
SelectionRef
(
)
)
;
IgnoredErrorResult
ignoredError
;
RefPtr
<
nsRange
>
rangeAtDropPoint
=
nsRange
:
:
Create
(
droppedAt
.
ToRawRangeBoundary
(
)
droppedAt
.
ToRawRangeBoundary
(
)
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
|
|
NS_WARN_IF
(
!
rangeAtDropPoint
-
>
IsPositioned
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_ERROR_FAILURE
;
}
if
(
editorToDeleteSelection
)
{
nsresult
rv
=
editorToDeleteSelection
-
>
DeleteSelectionByDragAsAction
(
mDispatchInputEvent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_OK
;
}
if
(
this
!
=
editorToDeleteSelection
&
&
(
rv
=
=
NS_ERROR_NOT_INITIALIZED
|
|
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
rv
=
NS_OK
;
}
if
(
rv
!
=
NS_ERROR_EDITOR_ACTION_CANCELED
&
&
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionByDragAsAction
(
)
failed
"
)
;
editActionData
.
Abort
(
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
rangeAtDropPoint
-
>
IsPositioned
(
)
)
|
|
NS_WARN_IF
(
!
rangeAtDropPoint
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_ERROR_FAILURE
;
}
droppedAt
=
rangeAtDropPoint
-
>
StartRef
(
)
;
MOZ_ASSERT
(
droppedAt
.
IsSetAndValid
(
)
)
;
}
RefPtr
<
Element
>
focusedElement
newFocusedElement
;
if
(
!
AsHTMLEditor
(
)
)
{
newFocusedElement
=
GetExposedRoot
(
)
;
focusedElement
=
IsActiveInDOMWindow
(
)
?
newFocusedElement
:
nullptr
;
}
else
if
(
!
AsHTMLEditor
(
)
-
>
IsInDesignMode
(
)
)
{
focusedElement
=
AsHTMLEditor
(
)
-
>
GetActiveEditingHost
(
)
;
if
(
focusedElement
&
&
droppedAt
.
GetContainerAsContent
(
)
-
>
IsInclusiveDescendantOf
(
focusedElement
)
)
{
newFocusedElement
=
focusedElement
;
}
else
{
newFocusedElement
=
droppedAt
.
GetContainerAsContent
(
)
-
>
GetEditingHost
(
)
;
}
}
ErrorResult
error
;
SelectionRef
(
)
.
SetStartAndEnd
(
droppedAt
.
ToRawRangeBoundary
(
)
droppedAt
.
ToRawRangeBoundary
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetStartAndEnd
(
)
failed
"
)
;
editActionData
.
Abort
(
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_OK
;
}
if
(
newFocusedElement
&
&
focusedElement
!
=
newFocusedElement
)
{
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
fm
-
>
SetFocus
(
newFocusedElement
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsFocusManager
:
:
SetFocus
(
)
failed
to
set
focus
"
"
to
the
element
but
ignored
"
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
rangeAtDropPoint
-
>
IsPositioned
(
)
)
|
|
NS_WARN_IF
(
!
rangeAtDropPoint
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
droppedAt
=
rangeAtDropPoint
-
>
StartRef
(
)
;
MOZ_ASSERT
(
droppedAt
.
IsSetAndValid
(
)
)
;
if
(
AsHTMLEditor
(
)
&
&
!
AsHTMLEditor
(
)
-
>
IsInDesignMode
(
)
&
&
NS_WARN_IF
(
newFocusedElement
!
=
AsHTMLEditor
(
)
-
>
GetActiveEditingHost
(
)
)
)
{
editActionData
.
Abort
(
)
;
return
NS_OK
;
}
}
if
(
!
AsHTMLEditor
(
)
)
{
AutoTArray
<
nsString
5
>
textArray
;
textArray
.
SetCapacity
(
numItems
)
;
uint32_t
textLength
=
0
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
+
+
i
)
{
nsCOMPtr
<
nsIVariant
>
data
;
dataTransfer
-
>
GetDataAtNoSecurityCheck
(
u
"
text
/
plain
"
_ns
i
getter_AddRefs
(
data
)
)
;
if
(
!
data
)
{
continue
;
}
nsString
insertText
;
data
-
>
GetAsAString
(
insertText
)
;
if
(
insertText
.
IsEmpty
(
)
)
{
continue
;
}
textArray
.
AppendElement
(
insertText
)
;
textLength
+
=
insertText
.
Length
(
)
;
}
nsString
data
;
data
.
SetCapacity
(
textLength
)
;
for
(
nsString
&
text
:
Reversed
(
textArray
)
)
{
data
.
Append
(
text
)
;
}
editActionData
.
SetData
(
data
)
;
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
data
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
InsertTextAt
(
data
droppedAt
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_OK
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
InsertTextAt
(
)
failed
but
ignored
"
)
;
}
else
{
editActionData
.
InitializeDataTransfer
(
dataTransfer
)
;
RefPtr
<
StaticRange
>
targetRange
=
StaticRange
:
:
Create
(
droppedAt
.
GetContainer
(
)
droppedAt
.
Offset
(
)
droppedAt
.
GetContainer
(
)
droppedAt
.
Offset
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
"
Why
did
we
fail
to
create
collapsed
static
range
at
"
"
dropped
position
?
"
)
;
if
(
targetRange
&
&
targetRange
-
>
IsPositioned
(
)
)
{
editActionData
.
AppendTargetRange
(
*
targetRange
)
;
}
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
(
AsHTMLEditor
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
+
+
i
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
InsertFromDataTransfer
(
dataTransfer
i
srcdoc
droppedAt
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_OK
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
InsertFromDataTransfer
(
)
failed
but
ignored
"
)
;
}
}
nsresult
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
rv
;
}
nsresult
TextEditor
:
:
PasteAsAction
(
int32_t
aClipboardType
bool
aDispatchPasteEvent
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aDispatchPasteEvent
)
{
if
(
!
FireClipboardEvent
(
ePaste
aClipboardType
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
}
}
else
{
editActionData
.
NotifyOfDispatchingClipboardEvent
(
)
;
}
if
(
!
GetDocument
(
)
)
{
NS_WARNING
(
"
The
editor
didn
'
t
have
document
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
nsIClipboard
service
"
)
;
return
rv
;
}
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
maybeTransferable
=
EditorUtils
:
:
CreateTransferableForPlainText
(
*
GetDocument
(
)
)
;
if
(
maybeTransferable
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorUtils
:
:
CreateTransferableForPlainText
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
maybeTransferable
.
unwrapErr
(
)
)
;
}
nsCOMPtr
<
nsITransferable
>
transferable
(
maybeTransferable
.
unwrap
(
)
)
;
if
(
NS_WARN_IF
(
!
transferable
)
)
{
NS_WARNING
(
"
EditorUtils
:
:
CreateTransferableForPlainText
(
)
returned
nullptr
but
"
"
ignored
"
)
;
return
NS_OK
;
}
rv
=
clipboard
-
>
GetData
(
transferable
aClipboardType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsIClipboard
:
:
GetData
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
rv
=
InsertTextFromTransferable
(
transferable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertTextFromTransferable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
TextEditor
:
:
PasteTransferableAsAction
(
nsITransferable
*
aTransferable
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
ePaste
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
FireClipboardEvent
(
ePaste
-
1
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_ACTION_CANCELED
)
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
InsertTextFromTransferable
(
aTransferable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
InsertTextFromTransferable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
bool
TextEditor
:
:
CanPaste
(
int32_t
aClipboardType
)
const
{
if
(
AreClipboardCommandsUnconditionallyEnabled
(
)
)
{
return
true
;
}
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
nsIClipboard
service
"
)
;
return
false
;
}
AutoTArray
<
nsCString
1
>
textEditorFlavors
=
{
nsDependentCString
(
kUnicodeMime
)
}
;
bool
haveFlavors
;
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textEditorFlavors
aClipboardType
&
haveFlavors
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsIClipboard
:
:
HasDataMatchingFlavors
(
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
haveFlavors
;
}
bool
TextEditor
:
:
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
if
(
!
aTransferable
)
{
return
true
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
kUnicodeMime
getter_AddRefs
(
data
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsITransferable
:
:
GetTransferData
(
kUnicodeMime
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
data
;
}
}
