#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
"
ChangeAttributeTransaction
.
h
"
#
include
"
CompositionTransaction
.
h
"
#
include
"
CreateElementTransaction
.
h
"
#
include
"
DeleteNodeTransaction
.
h
"
#
include
"
DeleteRangeTransaction
.
h
"
#
include
"
DeleteTextTransaction
.
h
"
#
include
"
EditAggregateTransaction
.
h
"
#
include
"
EditorEventListener
.
h
"
#
include
"
HTMLEditRules
.
h
"
#
include
"
InsertNodeTransaction
.
h
"
#
include
"
InsertTextTransaction
.
h
"
#
include
"
JoinNodeTransaction
.
h
"
#
include
"
PlaceholderTransaction
.
h
"
#
include
"
SplitNodeTransaction
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorSpellCheck
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EditTransactionBase
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
IMEContentObserver
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
mozSpellChecker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextInputListener
.
h
"
#
include
"
mozilla
/
TextServicesDocument
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAbsorbingTransaction
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIDocumentStateListener
.
h
"
#
include
"
nsIEditActionListener
.
h
"
#
include
"
nsIEditorObserver
.
h
"
#
include
"
nsIEditorSpellCheck
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionDisplay
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITransaction
.
h
"
#
include
"
nsITransactionManager
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructFwd
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prtime
.
h
"
class
nsIOutputStream
;
class
nsITransferable
;
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
template
already_AddRefed
<
Element
>
EditorBase
:
:
CreateNodeWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aPointToInsert
)
;
template
already_AddRefed
<
Element
>
EditorBase
:
:
CreateNodeWithTransaction
(
nsAtom
&
aTag
const
EditorRawDOMPoint
&
aPointToInsert
)
;
template
nsresult
EditorBase
:
:
InsertNodeWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
)
;
template
nsresult
EditorBase
:
:
InsertNodeWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
;
template
already_AddRefed
<
nsIContent
>
EditorBase
:
:
SplitNodeWithTransaction
(
const
EditorDOMPoint
&
aStartOfRightNode
ErrorResult
&
aError
)
;
template
already_AddRefed
<
nsIContent
>
EditorBase
:
:
SplitNodeWithTransaction
(
const
EditorRawDOMPoint
&
aStartOfRightNode
ErrorResult
&
aError
)
;
template
SplitNodeResult
EditorBase
:
:
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorDOMPoint
&
aStartOfDeepestRightNode
SplitAtEdges
aSplitAtEdges
)
;
template
SplitNodeResult
EditorBase
:
:
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorRawDOMPoint
&
aStartOfDeepestRightNode
SplitAtEdges
aSplitAtEdges
)
;
template
nsresult
EditorBase
:
:
MoveNodeWithTransaction
(
nsIContent
&
aContent
const
EditorDOMPoint
&
aPointToInsert
)
;
template
nsresult
EditorBase
:
:
MoveNodeWithTransaction
(
nsIContent
&
aContent
const
EditorRawDOMPoint
&
aPointToInsert
)
;
EditorBase
:
:
EditorBase
(
)
:
mEditActionData
(
nullptr
)
mPlaceholderName
(
nullptr
)
mModCount
(
0
)
mFlags
(
0
)
mUpdateCount
(
0
)
mPlaceholderBatch
(
0
)
mDocDirtyState
(
-
1
)
mSpellcheckCheckboxState
(
eTriUnset
)
mAllowsTransactionsToChangeSelection
(
true
)
mDidPreDestroy
(
false
)
mDidPostCreate
(
false
)
mDispatchInputEvent
(
true
)
mIsInEditSubAction
(
false
)
mHidingCaret
(
false
)
mSpellCheckerDictionaryUpdated
(
true
)
mIsHTMLEditorClass
(
false
)
{
}
EditorBase
:
:
~
EditorBase
(
)
{
MOZ_ASSERT
(
!
IsInitialized
(
)
|
|
mDidPreDestroy
"
Why
PreDestroy
hasn
'
t
been
called
?
"
)
;
if
(
mComposition
)
{
mComposition
-
>
OnEditorDestroyed
(
)
;
mComposition
=
nullptr
;
}
HideCaret
(
false
)
;
mTransactionManager
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
EditorBase
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
EditorBase
)
if
(
tmp
-
>
mEventListener
)
{
tmp
-
>
mEventListener
-
>
Disconnect
(
)
;
tmp
-
>
mEventListener
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRootElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectionController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIMEContentObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextServicesDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextInputListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTransactionManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mActionListeners
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEditorObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocStateListeners
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEventTarget
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPlaceholderTransaction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
EditorBase
)
Document
*
currentDoc
=
tmp
-
>
mRootElement
?
tmp
-
>
mRootElement
-
>
GetUncomposedDoc
(
)
:
nullptr
;
if
(
currentDoc
&
&
nsCCUncollectableMarker
:
:
InGeneration
(
cb
currentDoc
-
>
GetMarkedCCGeneration
(
)
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRootElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectionController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIMEContentObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineSpellChecker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextServicesDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextInputListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTransactionManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActionListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEditorObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocStateListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEventTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEventListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPlaceholderTransaction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
EditorBase
)
NS_INTERFACE_MAP_ENTRY
(
nsISelectionListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditor
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditor
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
EditorBase
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
EditorBase
)
nsresult
EditorBase
:
:
Init
(
Document
&
aDocument
Element
*
aRoot
nsISelectionController
*
aSelectionController
uint32_t
aFlags
const
nsAString
&
aValue
)
{
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
EditSubAction
:
:
eNone
"
Initializing
during
an
edit
action
is
an
error
"
)
;
#
ifdef
DEBUG
nsresult
rv
=
#
endif
SetFlags
(
aFlags
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetFlags
(
)
failed
"
)
;
mDocument
=
&
aDocument
;
nsCOMPtr
<
nsISelectionController
>
selectionController
;
if
(
aSelectionController
)
{
mSelectionController
=
aSelectionController
;
selectionController
=
aSelectionController
;
}
else
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
selectionController
=
do_QueryInterface
(
presShell
)
;
}
MOZ_ASSERT
(
selectionController
"
Selection
controller
should
be
available
at
this
point
"
)
;
if
(
aRoot
)
{
mRootElement
=
aRoot
;
}
mUpdateCount
=
0
;
if
(
mComposition
&
&
mComposition
-
>
GetContainerTextNode
(
)
&
&
!
mComposition
-
>
GetContainerTextNode
(
)
-
>
IsInComposedDoc
(
)
)
{
mComposition
-
>
OnTextNodeRemoved
(
)
;
}
selectionController
-
>
SetCaretReadOnly
(
false
)
;
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
selectionController
-
>
SetSelectionFlags
(
nsISelectionDisplay
:
:
DISPLAY_ALL
)
;
MOZ_ASSERT
(
IsInitialized
(
)
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SelectionRefPtr
(
)
-
>
AddSelectionListener
(
this
)
;
mDidPreDestroy
=
false
;
mDidPostCreate
=
false
;
return
NS_OK
;
}
nsresult
EditorBase
:
:
PostCreate
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mFlags
=
~
mFlags
;
nsresult
rv
=
SetFlags
(
~
mFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mDidPostCreate
)
{
mDidPostCreate
=
true
;
CreateEventListeners
(
)
;
rv
=
InstallEventListeners
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ResetModificationCount
(
)
;
NotifyDocumentListeners
(
eDocumentCreated
)
;
NotifyDocumentListeners
(
eDocumentStateChanged
)
;
}
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
focusedContent
)
{
InitializeSelection
(
focusedContent
)
;
mEventListener
-
>
SpellCheckIfNeeded
(
)
;
IMEState
newState
;
rv
=
GetPreferredIMEState
(
&
newState
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
nsCOMPtr
<
nsIContent
>
content
=
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
UpdateIMEState
(
newState
content
this
)
;
}
IMEStateManager
:
:
OnEditorInitialized
(
*
this
)
;
return
NS_OK
;
}
void
EditorBase
:
:
SetTextInputListener
(
TextInputListener
*
aTextInputListener
)
{
MOZ_ASSERT
(
!
mTextInputListener
|
|
!
aTextInputListener
|
|
mTextInputListener
=
=
aTextInputListener
)
;
mTextInputListener
=
aTextInputListener
;
}
void
EditorBase
:
:
SetIMEContentObserver
(
IMEContentObserver
*
aIMEContentObserver
)
{
MOZ_ASSERT
(
!
mIMEContentObserver
|
|
!
aIMEContentObserver
|
|
mIMEContentObserver
=
=
aIMEContentObserver
)
;
mIMEContentObserver
=
aIMEContentObserver
;
}
void
EditorBase
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
EditorEventListener
(
)
;
}
}
nsresult
EditorBase
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIContent
>
rootContent
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootContent
NS_ERROR_NOT_AVAILABLE
)
;
mEventTarget
=
rootContent
-
>
GetParent
(
)
;
NS_ENSURE_TRUE
(
mEventTarget
NS_ERROR_NOT_AVAILABLE
)
;
nsresult
rv
=
mEventListener
-
>
Connect
(
this
)
;
if
(
mComposition
)
{
mComposition
-
>
StartHandlingComposition
(
this
)
;
}
return
rv
;
}
void
EditorBase
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
|
|
!
mEventListener
)
{
return
;
}
mEventListener
-
>
Disconnect
(
)
;
if
(
mComposition
)
{
mComposition
-
>
EndHandlingComposition
(
this
)
;
}
mEventTarget
=
nullptr
;
}
bool
EditorBase
:
:
GetDesiredSpellCheckState
(
)
{
if
(
mSpellcheckCheckboxState
!
=
eTriUnset
)
{
return
(
mSpellcheckCheckboxState
=
=
eTriTrue
)
;
}
int32_t
spellcheckLevel
=
Preferences
:
:
GetInt
(
"
layout
.
spellcheckDefault
"
1
)
;
if
(
!
spellcheckLevel
)
{
return
false
;
}
if
(
!
CanEnableSpellCheck
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
nsPresContext
*
context
=
presShell
-
>
GetPresContext
(
)
;
if
(
context
&
&
!
context
-
>
IsDynamic
(
)
)
{
return
false
;
}
}
nsCOMPtr
<
nsIContent
>
content
=
GetExposedRoot
(
)
;
if
(
!
content
)
{
return
false
;
}
auto
element
=
nsGenericHTMLElement
:
:
FromNode
(
content
)
;
if
(
!
element
)
{
return
false
;
}
if
(
!
IsPlaintextEditor
(
)
)
{
nsCOMPtr
<
nsIHTMLDocument
>
doc
=
do_QueryInterface
(
content
-
>
GetComposedDoc
(
)
)
;
return
doc
&
&
doc
-
>
IsEditingOn
(
)
;
}
return
element
-
>
Spellcheck
(
)
;
}
void
EditorBase
:
:
PreDestroy
(
bool
aDestroyingFrames
)
{
if
(
mDidPreDestroy
)
{
return
;
}
Selection
*
selection
=
GetSelection
(
)
;
if
(
selection
)
{
selection
-
>
RemoveSelectionListener
(
this
)
;
}
IMEStateManager
:
:
OnEditorDestroying
(
*
this
)
;
if
(
mInlineSpellChecker
)
mInlineSpellChecker
-
>
Cleanup
(
aDestroyingFrames
)
;
NotifyDocumentListeners
(
eDocumentToBeDestroyed
)
;
RemoveEventListeners
(
)
;
HideCaret
(
false
)
;
mActionListeners
.
Clear
(
)
;
mEditorObservers
.
Clear
(
)
;
mDocStateListeners
.
Clear
(
)
;
mInlineSpellChecker
=
nullptr
;
mTextServicesDocument
=
nullptr
;
mTextInputListener
=
nullptr
;
mSpellcheckCheckboxState
=
eTriUnset
;
mRootElement
=
nullptr
;
if
(
mTransactionManager
)
{
DebugOnly
<
bool
>
disabledUndoRedo
=
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
mTransactionManager
=
nullptr
;
}
mDidPreDestroy
=
true
;
}
NS_IMETHODIMP
EditorBase
:
:
GetFlags
(
uint32_t
*
aFlags
)
{
*
aFlags
=
Flags
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
SetFlags
(
uint32_t
aFlags
)
{
if
(
mFlags
=
=
aFlags
)
{
return
NS_OK
;
}
bool
spellcheckerWasEnabled
=
CanEnableSpellCheck
(
)
;
mFlags
=
aFlags
;
if
(
!
IsInitialized
(
)
)
{
return
NS_OK
;
}
if
(
CanEnableSpellCheck
(
)
!
=
spellcheckerWasEnabled
)
{
SyncRealTimeSpell
(
)
;
}
if
(
!
mDidPostCreate
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
focusedContent
)
{
IMEState
newState
;
nsresult
rv
=
GetPreferredIMEState
(
&
newState
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
UpdateIMEState
(
newState
content
this
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetIsSelectionEditable
(
bool
*
aIsSelectionEditable
)
{
NS_ENSURE_ARG_POINTER
(
aIsSelectionEditable
)
;
*
aIsSelectionEditable
=
IsSelectionEditable
(
)
;
return
NS_OK
;
}
bool
EditorBase
:
:
IsSelectionEditable
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
false
;
}
if
(
!
mIsHTMLEditorClass
)
{
nsCOMPtr
<
nsINode
>
anchorNode
=
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
;
return
anchorNode
&
&
IsEditable
(
anchorNode
)
;
}
nsINode
*
anchorNode
=
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
;
nsINode
*
focusNode
=
SelectionRefPtr
(
)
-
>
GetFocusNode
(
)
;
if
(
!
anchorNode
|
|
!
focusNode
)
{
return
false
;
}
bool
isSelectionEditable
=
SelectionRefPtr
(
)
-
>
RangeCount
(
)
&
&
anchorNode
-
>
IsEditable
(
)
&
&
focusNode
-
>
IsEditable
(
)
;
if
(
!
isSelectionEditable
)
{
return
false
;
}
nsINode
*
commonAncestor
=
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
GetCommonAncestor
(
)
;
while
(
commonAncestor
&
&
!
commonAncestor
-
>
IsEditable
(
)
)
{
commonAncestor
=
commonAncestor
-
>
GetParentNode
(
)
;
}
return
!
!
commonAncestor
;
}
NS_IMETHODIMP
EditorBase
:
:
GetIsDocumentEditable
(
bool
*
aIsDocumentEditable
)
{
NS_ENSURE_ARG_POINTER
(
aIsDocumentEditable
)
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
*
aIsDocumentEditable
=
doc
&
&
IsModifiable
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetDocument
(
Document
*
*
aDoc
)
{
NS_IF_ADDREF
(
*
aDoc
=
mDocument
)
;
return
*
aDoc
?
NS_OK
:
NS_ERROR_NOT_INITIALIZED
;
}
already_AddRefed
<
nsIWidget
>
EditorBase
:
:
GetWidget
(
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
nullptr
)
;
nsPresContext
*
pc
=
ps
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
pc
nullptr
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
pc
-
>
GetRootWidget
(
)
;
NS_ENSURE_TRUE
(
widget
.
get
(
)
nullptr
)
;
return
widget
.
forget
(
)
;
}
NS_IMETHODIMP
EditorBase
:
:
GetContentsMIMEType
(
char
*
*
aContentsMIMEType
)
{
NS_ENSURE_ARG_POINTER
(
aContentsMIMEType
)
;
*
aContentsMIMEType
=
ToNewCString
(
mContentMIMEType
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
SetContentsMIMEType
(
const
char
*
aContentsMIMEType
)
{
mContentMIMEType
.
Assign
(
aContentsMIMEType
?
aContentsMIMEType
:
"
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetSelectionController
(
nsISelectionController
*
*
aSel
)
{
NS_ENSURE_TRUE
(
aSel
NS_ERROR_NULL_POINTER
)
;
*
aSel
=
nullptr
;
nsCOMPtr
<
nsISelectionController
>
selCon
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selCon
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
selCon
.
forget
(
aSel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
DeleteSelection
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
GetSelection
(
Selection
*
*
aSelection
)
{
return
GetSelection
(
SelectionType
:
:
eNormal
aSelection
)
;
}
nsresult
EditorBase
:
:
GetSelection
(
SelectionType
aSelectionType
Selection
*
*
aSelection
)
const
{
if
(
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
IsEditActionDataAvailable
(
)
)
{
*
aSelection
=
do_AddRef
(
SelectionRefPtr
(
)
)
.
take
(
)
;
return
NS_OK
;
}
*
aSelection
=
nullptr
;
nsISelectionController
*
selcon
=
GetSelectionController
(
)
;
if
(
!
selcon
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Selection
>
selection
=
selcon
-
>
GetSelection
(
ToRawSelectionType
(
aSelectionType
)
)
;
if
(
!
selection
)
{
return
NS_ERROR_INVALID_ARG
;
}
selection
.
forget
(
aSelection
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
DoTransaction
(
nsITransaction
*
aTxn
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eUnknown
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
DoTransactionInternal
(
aTxn
)
;
}
nsresult
EditorBase
:
:
DoTransactionInternal
(
nsITransaction
*
aTxn
)
{
if
(
mPlaceholderBatch
&
&
!
mPlaceholderTransaction
)
{
mPlaceholderTransaction
=
PlaceholderTransaction
:
:
Create
(
*
this
mPlaceholderName
std
:
:
move
(
mSelState
)
)
;
MOZ_ASSERT
(
mSelState
.
isNothing
(
)
)
;
DoTransactionInternal
(
mPlaceholderTransaction
)
;
if
(
mTransactionManager
)
{
nsCOMPtr
<
nsITransaction
>
topTransaction
=
mTransactionManager
-
>
PeekUndoStack
(
)
;
nsCOMPtr
<
nsIAbsorbingTransaction
>
topAbsorbingTransaction
=
do_QueryInterface
(
topTransaction
)
;
if
(
topAbsorbingTransaction
)
{
RefPtr
<
PlaceholderTransaction
>
topPlaceholderTransaction
=
topAbsorbingTransaction
-
>
AsPlaceholderTransaction
(
)
;
if
(
topPlaceholderTransaction
)
{
mPlaceholderTransaction
=
topPlaceholderTransaction
;
}
}
}
}
if
(
aTxn
)
{
SelectionBatcher
selectionBatcher
(
SelectionRefPtr
(
)
)
;
nsresult
rv
;
if
(
mTransactionManager
)
{
RefPtr
<
TransactionManager
>
transactionManager
(
mTransactionManager
)
;
rv
=
transactionManager
-
>
DoTransaction
(
aTxn
)
;
}
else
{
rv
=
aTxn
-
>
DoTransaction
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
DoAfterDoTransaction
(
aTxn
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
EnableUndo
(
bool
aEnable
)
{
if
(
aEnable
)
{
DebugOnly
<
bool
>
enabledUndoRedo
=
EnableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
enabledUndoRedo
"
Failed
to
enable
undo
/
redo
transactions
"
)
;
return
NS_OK
;
}
DebugOnly
<
bool
>
disabledUndoRedo
=
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetTransactionManager
(
nsITransactionManager
*
*
aTransactionManager
)
{
if
(
NS_WARN_IF
(
!
aTransactionManager
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
mTransactionManager
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_IF_ADDREF
(
*
aTransactionManager
=
mTransactionManager
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
Undo
(
uint32_t
aCount
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanUndo
(
bool
*
aIsEnabled
bool
*
aCanUndo
)
{
if
(
NS_WARN_IF
(
!
aIsEnabled
)
|
|
NS_WARN_IF
(
!
aCanUndo
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCanUndo
=
CanUndo
(
)
;
*
aIsEnabled
=
IsUndoRedoEnabled
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
Redo
(
uint32_t
aCount
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanRedo
(
bool
*
aIsEnabled
bool
*
aCanRedo
)
{
if
(
NS_WARN_IF
(
!
aIsEnabled
)
|
|
NS_WARN_IF
(
!
aCanRedo
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCanRedo
=
CanRedo
(
)
;
*
aIsEnabled
=
IsUndoRedoEnabled
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
BeginTransaction
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eUnknown
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
BeginTransactionInternal
(
)
;
return
NS_OK
;
}
void
EditorBase
:
:
BeginTransactionInternal
(
)
{
BeginUpdateViewBatch
(
)
;
if
(
mTransactionManager
)
{
RefPtr
<
TransactionManager
>
transactionManager
(
mTransactionManager
)
;
transactionManager
-
>
BeginBatch
(
nullptr
)
;
}
}
NS_IMETHODIMP
EditorBase
:
:
EndTransaction
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eUnknown
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EndTransactionInternal
(
)
;
return
NS_OK
;
}
void
EditorBase
:
:
EndTransactionInternal
(
)
{
if
(
mTransactionManager
)
{
RefPtr
<
TransactionManager
>
transactionManager
(
mTransactionManager
)
;
transactionManager
-
>
EndBatch
(
false
)
;
}
EndUpdateViewBatch
(
)
;
}
void
EditorBase
:
:
BeginPlaceholderTransaction
(
nsAtom
*
aTransactionName
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
>
=
0
"
negative
placeholder
batch
count
!
"
)
;
if
(
!
mPlaceholderBatch
)
{
NotifyEditorObservers
(
eNotifyEditorObserversOfBefore
)
;
BeginUpdateViewBatch
(
)
;
mPlaceholderTransaction
=
nullptr
;
mPlaceholderName
=
aTransactionName
;
mSelState
.
emplace
(
)
;
mSelState
-
>
SaveSelection
(
SelectionRefPtr
(
)
)
;
if
(
mPlaceholderName
=
=
nsGkAtoms
:
:
IMETxnName
)
{
RangeUpdaterRef
(
)
.
RegisterSelectionState
(
*
mSelState
)
;
}
}
mPlaceholderBatch
+
+
;
}
void
EditorBase
:
:
EndPlaceholderTransaction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
>
0
"
zero
or
negative
placeholder
batch
count
when
ending
batch
!
"
)
;
if
(
mPlaceholderBatch
=
=
1
)
{
SelectionRefPtr
(
)
-
>
SetCanCacheFrameOffset
(
true
)
;
EndUpdateViewBatch
(
)
;
ScrollSelectionIntoView
(
false
)
;
SelectionRefPtr
(
)
-
>
SetCanCacheFrameOffset
(
false
)
;
if
(
mSelState
)
{
if
(
mPlaceholderName
=
=
nsGkAtoms
:
:
IMETxnName
)
{
RangeUpdaterRef
(
)
.
DropSelectionState
(
*
mSelState
)
;
}
mSelState
.
reset
(
)
;
}
if
(
mPlaceholderTransaction
)
{
mPlaceholderTransaction
-
>
EndPlaceHolderBatch
(
)
;
if
(
!
mComposition
)
{
NotifyEditorObservers
(
eNotifyEditorObserversOfEnd
)
;
}
mPlaceholderTransaction
=
nullptr
;
}
else
{
NotifyEditorObservers
(
eNotifyEditorObserversOfCancel
)
;
}
}
mPlaceholderBatch
-
-
;
}
NS_IMETHODIMP
EditorBase
:
:
SetShouldTxnSetSelection
(
bool
aShould
)
{
MakeThisAllowTransactionsToChangeSelection
(
aShould
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetDocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
SelectAll
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
SelectAllInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
EditorBase
:
:
SelectAllInternal
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
CommitComposition
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsresult
rv
=
SelectEntireDocument
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
BeginningOfDocument
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
dom
:
:
Element
*
rootElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootElement
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
firstNode
=
GetFirstEditableNode
(
rootElement
)
;
if
(
!
firstNode
)
{
return
SelectionRefPtr
(
)
-
>
Collapse
(
rootElement
0
)
;
}
if
(
firstNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
return
SelectionRefPtr
(
)
-
>
Collapse
(
firstNode
0
)
;
}
nsCOMPtr
<
nsIContent
>
parent
=
firstNode
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_NULL_POINTER
;
}
MOZ_ASSERT
(
parent
-
>
ComputeIndexOf
(
firstNode
)
=
=
0
"
How
come
the
first
node
isn
'
t
the
left
most
child
in
its
parent
?
"
)
;
return
SelectionRefPtr
(
)
-
>
Collapse
(
parent
0
)
;
}
NS_IMETHODIMP
EditorBase
:
:
EndOfDocument
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
CollapseSelectionToEnd
(
)
;
}
nsresult
EditorBase
:
:
CollapseSelectionToEnd
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsINode
*
node
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
child
=
node
-
>
GetLastChild
(
)
;
while
(
child
&
&
IsContainer
(
child
)
)
{
node
=
child
;
child
=
node
-
>
GetLastChild
(
)
;
}
uint32_t
length
=
node
-
>
Length
(
)
;
return
SelectionRefPtr
(
)
-
>
Collapse
(
node
static_cast
<
int32_t
>
(
length
)
)
;
}
NS_IMETHODIMP
EditorBase
:
:
GetDocumentModified
(
bool
*
outDocModified
)
{
NS_ENSURE_TRUE
(
outDocModified
NS_ERROR_NULL_POINTER
)
;
int32_t
modCount
=
0
;
GetModificationCount
(
&
modCount
)
;
*
outDocModified
=
(
modCount
!
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetDocumentCharacterSet
(
nsACString
&
aCharset
)
{
return
GetDocumentCharsetInternal
(
aCharset
)
;
}
nsresult
EditorBase
:
:
GetDocumentCharsetInternal
(
nsACString
&
aCharset
)
const
{
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
document
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
aCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
SetDocumentCharacterSet
(
const
nsACString
&
characterSet
)
{
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
auto
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
characterSet
)
;
if
(
!
encoding
)
{
return
NS_ERROR_INVALID_ARG
;
}
document
-
>
SetDocumentCharacterSet
(
WrapNotNull
(
encoding
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
Cut
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanCut
(
bool
*
aCanCut
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
Copy
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanCopy
(
bool
*
aCanCut
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanDelete
(
bool
*
aCanDelete
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
Paste
(
int32_t
aClipboardType
)
{
nsresult
rv
=
AsTextEditor
(
)
-
>
PasteAsAction
(
aClipboardType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
PasteTransferable
(
nsITransferable
*
aTransferable
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
CanPaste
(
int32_t
aSelectionType
bool
*
aCanPaste
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
EditorBase
:
:
SetAttribute
(
Element
*
aElement
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
if
(
NS_WARN_IF
(
aAttribute
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
SetAttributeWithTransaction
(
*
aElement
*
attribute
aValue
)
;
}
nsresult
EditorBase
:
:
SetAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
const
nsAString
&
aValue
)
{
RefPtr
<
ChangeAttributeTransaction
>
transaction
=
ChangeAttributeTransaction
:
:
Create
(
aElement
aAttribute
aValue
)
;
return
DoTransactionInternal
(
transaction
)
;
}
NS_IMETHODIMP
EditorBase
:
:
GetAttributeValue
(
Element
*
aElement
const
nsAString
&
aAttribute
nsAString
&
aResultValue
bool
*
aResultIsSet
)
{
NS_ENSURE_TRUE
(
aResultIsSet
NS_ERROR_NULL_POINTER
)
;
*
aResultIsSet
=
false
;
if
(
!
aElement
)
{
return
NS_OK
;
}
nsAutoString
value
;
aElement
-
>
GetAttribute
(
aAttribute
value
)
;
if
(
!
DOMStringIsNull
(
value
)
)
{
*
aResultIsSet
=
true
;
aResultValue
=
value
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
RemoveAttribute
(
Element
*
aElement
const
nsAString
&
aAttribute
)
{
if
(
NS_WARN_IF
(
aAttribute
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
RemoveAttributeWithTransaction
(
*
aElement
*
attribute
)
;
}
nsresult
EditorBase
:
:
RemoveAttributeWithTransaction
(
Element
&
aElement
nsAtom
&
aAttribute
)
{
RefPtr
<
ChangeAttributeTransaction
>
transaction
=
ChangeAttributeTransaction
:
:
CreateToRemove
(
aElement
aAttribute
)
;
return
DoTransactionInternal
(
transaction
)
;
}
NS_IMETHODIMP
EditorBase
:
:
MarkNodeDirty
(
nsINode
*
aNode
)
{
if
(
!
OutputsMozDirty
(
)
)
{
return
NS_OK
;
}
if
(
RefPtr
<
Element
>
element
=
Element
:
:
FromNodeOrNull
(
aNode
)
)
{
element
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozdirty
EmptyString
(
)
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetInlineSpellChecker
(
bool
autoCreate
nsIInlineSpellChecker
*
*
aInlineSpellChecker
)
{
NS_ENSURE_ARG_POINTER
(
aInlineSpellChecker
)
;
if
(
mDidPreDestroy
)
{
*
aInlineSpellChecker
=
nullptr
;
return
autoCreate
?
NS_ERROR_NOT_AVAILABLE
:
NS_OK
;
}
bool
canSpell
=
mozInlineSpellChecker
:
:
CanEnableInlineSpellChecking
(
)
;
if
(
!
canSpell
)
{
*
aInlineSpellChecker
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
!
mInlineSpellChecker
&
&
autoCreate
)
{
mInlineSpellChecker
=
new
mozInlineSpellChecker
(
)
;
}
if
(
mInlineSpellChecker
)
{
rv
=
mInlineSpellChecker
-
>
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
mInlineSpellChecker
=
nullptr
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_IF_ADDREF
(
*
aInlineSpellChecker
=
mInlineSpellChecker
)
;
return
NS_OK
;
}
void
EditorBase
:
:
SyncRealTimeSpell
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
bool
enable
=
GetDesiredSpellCheckState
(
)
;
nsCOMPtr
<
nsIInlineSpellChecker
>
spellChecker
;
GetInlineSpellChecker
(
enable
getter_AddRefs
(
spellChecker
)
)
;
if
(
mInlineSpellChecker
)
{
if
(
!
mSpellCheckerDictionaryUpdated
&
&
enable
)
{
mInlineSpellChecker
-
>
UpdateCurrentDictionary
(
)
;
mSpellCheckerDictionaryUpdated
=
true
;
}
mInlineSpellChecker
-
>
SetEnableRealTimeSpell
(
enable
&
&
spellChecker
)
;
}
}
NS_IMETHODIMP
EditorBase
:
:
SetSpellcheckUserOverride
(
bool
enable
)
{
mSpellcheckCheckboxState
=
enable
?
eTriTrue
:
eTriFalse
;
SyncRealTimeSpell
(
)
;
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
already_AddRefed
<
Element
>
EditorBase
:
:
CreateNodeWithTransaction
(
nsAtom
&
aTagName
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
Unused
<
<
aPointToInsert
.
Offset
(
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eCreateNode
nsIEditor
:
:
eNext
)
;
RefPtr
<
Element
>
newElement
;
RefPtr
<
CreateElementTransaction
>
transaction
=
CreateElementTransaction
:
:
Create
(
*
this
aTagName
aPointToInsert
)
;
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
RangeUpdaterRef
(
)
.
SelAdjCreateNode
(
aPointToInsert
)
;
}
else
{
newElement
=
transaction
-
>
GetNewNode
(
)
;
MOZ_ASSERT
(
newElement
)
;
RangeUpdaterRef
(
)
.
SelAdjCreateNode
(
EditorRawDOMPoint
(
aPointToInsert
.
GetContainer
(
)
aPointToInsert
.
Offset
(
)
)
)
;
}
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
&
&
newElement
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidCreateNode
(
*
newElement
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidCreateNode
(
nsDependentAtomString
(
&
aTagName
)
newElement
rv
)
;
}
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
EditorBase
:
:
InsertNode
(
nsINode
*
aNodeToInsert
nsINode
*
aContainer
int32_t
aOffset
)
{
nsCOMPtr
<
nsIContent
>
contentToInsert
=
do_QueryInterface
(
aNodeToInsert
)
;
if
(
NS_WARN_IF
(
!
contentToInsert
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
NS_WARN_IF
(
!
aContainer
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertNode
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
int32_t
offset
=
aOffset
<
0
?
static_cast
<
int32_t
>
(
aContainer
-
>
Length
(
)
)
:
std
:
:
min
(
aOffset
static_cast
<
int32_t
>
(
aContainer
-
>
Length
(
)
)
)
;
return
InsertNodeWithTransaction
(
*
contentToInsert
EditorRawDOMPoint
(
aContainer
offset
)
)
;
}
template
<
typename
PT
typename
CT
>
nsresult
EditorBase
:
:
InsertNodeWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
)
;
RefPtr
<
InsertNodeTransaction
>
transaction
=
InsertNodeTransaction
:
:
Create
(
*
this
aContentToInsert
aPointToInsert
)
;
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
RangeUpdaterRef
(
)
.
SelAdjInsertNode
(
aPointToInsert
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidInsertNode
(
aContentToInsert
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidInsertNode
(
&
aContentToInsert
rv
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
EditorBase
:
:
SplitNode
(
nsINode
*
aNode
int32_t
aOffset
nsINode
*
*
aNewLeftNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSplitNode
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
int32_t
offset
=
std
:
:
min
(
std
:
:
max
(
aOffset
0
)
static_cast
<
int32_t
>
(
aNode
-
>
Length
(
)
)
)
;
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newNode
=
SplitNodeWithTransaction
(
EditorRawDOMPoint
(
aNode
offset
)
error
)
;
newNode
.
forget
(
aNewLeftNode
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
already_AddRefed
<
nsIContent
>
EditorBase
:
:
SplitNodeWithTransaction
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aStartOfRightNode
.
GetContainerAsContent
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
nullptr
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eSplitNode
nsIEditor
:
:
eNext
)
;
Unused
<
<
aStartOfRightNode
.
Offset
(
)
;
RefPtr
<
SplitNodeTransaction
>
transaction
=
SplitNodeTransaction
:
:
Create
(
*
this
aStartOfRightNode
)
;
aError
=
DoTransactionInternal
(
transaction
)
;
nsCOMPtr
<
nsIContent
>
newNode
=
transaction
-
>
GetNewNode
(
)
;
NS_WARNING_ASSERTION
(
newNode
"
Failed
to
create
a
new
left
node
"
)
;
RangeUpdaterRef
(
)
.
SelAdjSplitNode
(
*
aStartOfRightNode
.
GetContainerAsContent
(
)
newNode
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
&
&
newNode
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidSplitNode
(
*
aStartOfRightNode
.
GetContainer
(
)
*
newNode
)
;
}
if
(
mInlineSpellChecker
)
{
RefPtr
<
mozInlineSpellChecker
>
spellChecker
=
mInlineSpellChecker
;
spellChecker
-
>
DidSplitNode
(
aStartOfRightNode
.
GetContainer
(
)
newNode
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidSplitNode
(
aStartOfRightNode
.
GetContainer
(
)
newNode
)
;
}
}
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
newNode
.
forget
(
)
;
}
NS_IMETHODIMP
EditorBase
:
:
JoinNodes
(
nsINode
*
aLeftNode
nsINode
*
aRightNode
nsINode
*
)
{
if
(
NS_WARN_IF
(
!
aLeftNode
)
|
|
NS_WARN_IF
(
!
aRightNode
)
|
|
NS_WARN_IF
(
!
aLeftNode
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eJoinNodes
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
JoinNodesWithTransaction
(
*
aLeftNode
*
aRightNode
)
;
}
nsresult
EditorBase
:
:
JoinNodesWithTransaction
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
aLeftNode
.
GetParentNode
(
)
;
MOZ_ASSERT
(
parent
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eJoinNodes
nsIEditor
:
:
ePrevious
)
;
int32_t
offset
=
parent
-
>
ComputeIndexOf
(
&
aRightNode
)
;
uint32_t
oldLeftNodeLen
=
aLeftNode
.
Length
(
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
WillJoinNodes
(
aLeftNode
aRightNode
)
;
}
nsresult
rv
=
NS_OK
;
RefPtr
<
JoinNodeTransaction
>
transaction
=
JoinNodeTransaction
:
:
MaybeCreate
(
*
this
aLeftNode
aRightNode
)
;
if
(
transaction
)
{
rv
=
DoTransactionInternal
(
transaction
)
;
}
RangeUpdaterRef
(
)
.
SelAdjJoinNodes
(
aLeftNode
aRightNode
*
parent
offset
static_cast
<
int32_t
>
(
oldLeftNodeLen
)
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidJoinNodes
(
aLeftNode
aRightNode
)
;
}
if
(
mInlineSpellChecker
)
{
RefPtr
<
mozInlineSpellChecker
>
spellChecker
=
mInlineSpellChecker
;
spellChecker
-
>
DidJoinNodes
(
aLeftNode
aRightNode
)
;
}
if
(
mTextServicesDocument
&
&
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
mTextServicesDocument
;
textServicesDocument
-
>
DidJoinNodes
(
aLeftNode
aRightNode
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidJoinNodes
(
&
aLeftNode
&
aRightNode
parent
rv
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
EditorBase
:
:
DeleteNode
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveNode
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
DeleteNodeWithTransaction
(
*
aNode
)
;
}
nsresult
EditorBase
:
:
DeleteNodeWithTransaction
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
ePrevious
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
WillDeleteNode
(
aNode
)
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
this
aNode
)
;
nsresult
rv
=
deleteNodeTransaction
?
DoTransactionInternal
(
deleteNodeTransaction
)
:
NS_ERROR_FAILURE
;
if
(
mTextServicesDocument
&
&
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
mTextServicesDocument
;
textServicesDocument
-
>
DidDeleteNode
(
&
aNode
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidDeleteNode
(
&
aNode
rv
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
already_AddRefed
<
Element
>
EditorBase
:
:
ReplaceContainerWithTransactionInternal
(
Element
&
aOldContainer
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
bool
aCloneAllAttributes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
atOldContainer
(
&
aOldContainer
)
;
if
(
NS_WARN_IF
(
!
atOldContainer
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
nullptr
;
}
if
(
aCloneAllAttributes
)
{
MOZ_ASSERT
(
&
aAttribute
=
=
nsGkAtoms
:
:
_empty
)
;
CloneAttributesWithTransaction
(
*
newContainer
aOldContainer
)
;
}
else
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
AutoReplaceContainerSelNotify
selStateNotify
(
RangeUpdaterRef
(
)
&
aOldContainer
newContainer
)
;
{
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
while
(
aOldContainer
.
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aOldContainer
.
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
InsertNodeWithTransaction
(
*
child
EditorRawDOMPoint
(
newContainer
newContainer
-
>
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
}
NS_WARNING_ASSERTION
(
atOldContainer
.
IsSetAndValid
(
)
"
The
old
container
might
be
moved
by
mutation
observer
"
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
*
newContainer
atOldContainer
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
DeleteNodeWithTransaction
(
aOldContainer
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
newContainer
.
forget
(
)
;
}
nsresult
EditorBase
:
:
RemoveContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToInsertChildren
(
&
aElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertChildren
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoRemoveContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
&
aElement
pointToInsertChildren
.
GetContainer
(
)
pointToInsertChildren
.
Offset
(
)
aElement
.
GetChildCount
(
)
)
;
while
(
aElement
.
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aElement
.
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertNodeWithTransaction
(
*
child
EditorRawDOMPoint
(
pointToInsertChildren
.
GetContainer
(
)
pointToInsertChildren
.
Offset
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
EditorBase
:
:
InsertContainerWithTransactionInternal
(
nsIContent
&
aContent
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
{
EditorDOMPoint
pointToInsertNewContainer
(
&
aContent
)
;
if
(
NS_WARN_IF
(
!
pointToInsertNewContainer
.
IsSet
(
)
)
)
{
return
nullptr
;
}
DebugOnly
<
bool
>
advanced
=
pointToInsertNewContainer
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
aContent
"
)
;
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
nullptr
;
}
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
AutoInsertContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
{
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
rv
=
InsertNodeWithTransaction
(
aContent
EditorRawDOMPoint
(
newContainer
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
rv
=
InsertNodeWithTransaction
(
*
newContainer
pointToInsertNewContainer
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
newContainer
.
forget
(
)
;
}
template
<
typename
PT
typename
CT
>
nsresult
EditorBase
:
:
MoveNodeWithTransaction
(
nsIContent
&
aContent
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
oldPoint
(
&
aContent
)
;
if
(
NS_WARN_IF
(
!
oldPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aPointToInsert
=
=
oldPoint
)
{
return
NS_OK
;
}
EditorDOMPoint
newPoint
(
aPointToInsert
)
;
AutoMoveNodeSelNotify
selNotify
(
RangeUpdaterRef
(
)
oldPoint
newPoint
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EditorRawDOMPoint
pointToInsert
(
selNotify
.
ComputeInsertionPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSetAndValid
(
)
)
)
{
pointToInsert
.
SetToEndOf
(
pointToInsert
.
GetContainer
(
)
)
;
}
rv
=
InsertNodeWithTransaction
(
aContent
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
EditorBase
:
:
MoveAllChildren
(
nsINode
&
aContainer
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
if
(
!
aContainer
.
HasChildren
(
)
)
{
return
;
}
nsIContent
*
firstChild
=
aContainer
.
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
aContainer
.
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
return
MoveChildren
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
}
void
EditorBase
:
:
MovePreviousSiblings
(
nsIContent
&
aChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
if
(
NS_WARN_IF
(
!
aChild
.
GetParentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsIContent
*
firstChild
=
aChild
.
GetParentNode
(
)
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
&
aChild
=
=
firstChild
?
firstChild
:
aChild
.
GetPreviousSibling
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
return
MoveChildren
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
}
void
EditorBase
:
:
MoveChildren
(
nsIContent
&
aFirstChild
nsIContent
&
aLastChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsINode
>
oldContainer
=
aFirstChild
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
oldContainer
!
=
aLastChild
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
CanContainerHaveChildren
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
children
;
for
(
nsIContent
*
child
=
&
aFirstChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
child
)
;
if
(
child
=
=
&
aLastChild
)
{
break
;
}
}
if
(
NS_WARN_IF
(
children
.
LastElement
(
)
!
=
&
aLastChild
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsCOMPtr
<
nsINode
>
newContainer
=
aPointToInsert
.
GetContainer
(
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
aPointToInsert
.
GetChild
(
)
;
for
(
size_t
i
=
children
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
&
child
=
children
[
i
-
1
]
;
if
(
child
-
>
GetParentNode
(
)
!
=
oldContainer
)
{
continue
;
}
oldContainer
-
>
RemoveChild
(
*
child
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
if
(
nextNode
)
{
EditorRawDOMPoint
pointToInsert
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
pointToInsert
.
GetContainer
(
)
!
=
newContainer
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
newContainer
-
>
InsertBefore
(
*
child
nextNode
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
if
(
child
-
>
GetParentNode
(
)
=
=
newContainer
)
{
nextNode
=
child
;
}
}
}
NS_IMETHODIMP
EditorBase
:
:
AddEditorObserver
(
nsIEditorObserver
*
aObserver
)
{
NS_ENSURE_TRUE
(
aObserver
NS_ERROR_NULL_POINTER
)
;
if
(
!
mEditorObservers
.
Contains
(
aObserver
)
)
{
mEditorObservers
.
AppendElement
(
*
aObserver
)
;
NS_WARNING_ASSERTION
(
mEditorObservers
.
Length
(
)
!
=
1
"
nsIEditorObserver
installed
this
editor
becomes
slower
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
RemoveEditorObserver
(
nsIEditorObserver
*
aObserver
)
{
NS_ENSURE_TRUE
(
aObserver
NS_ERROR_FAILURE
)
;
NS_WARNING_ASSERTION
(
mEditorObservers
.
Length
(
)
!
=
1
"
All
nsIEditorObservers
have
been
removed
this
editor
becomes
faster
"
)
;
mEditorObservers
.
RemoveElement
(
aObserver
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
NotifySelectionChanged
(
Document
*
aDocument
Selection
*
aSelection
int16_t
aReason
)
{
if
(
NS_WARN_IF
(
!
aDocument
)
|
|
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mTextInputListener
)
{
RefPtr
<
TextInputListener
>
textInputListener
=
mTextInputListener
;
textInputListener
-
>
OnSelectionChange
(
*
aSelection
aReason
)
;
}
if
(
mIMEContentObserver
)
{
RefPtr
<
IMEContentObserver
>
observer
=
mIMEContentObserver
;
observer
-
>
OnSelectionChange
(
*
aSelection
)
;
}
return
NS_OK
;
}
void
EditorBase
:
:
NotifyEditorObservers
(
NotificationForEditorObservers
aNotification
)
{
switch
(
aNotification
)
{
case
eNotifyEditorObserversOfEnd
:
mIsInEditSubAction
=
false
;
if
(
mTextInputListener
)
{
RefPtr
<
TextInputListener
>
listener
=
mTextInputListener
;
listener
-
>
OnEditActionHandled
(
)
;
}
if
(
mIMEContentObserver
)
{
RefPtr
<
IMEContentObserver
>
observer
=
mIMEContentObserver
;
observer
-
>
OnEditActionHandled
(
)
;
}
if
(
!
mEditorObservers
.
IsEmpty
(
)
)
{
AutoEditorObserverArray
observers
(
mEditorObservers
)
;
for
(
auto
&
observer
:
observers
)
{
observer
-
>
EditAction
(
)
;
}
}
if
(
!
mDispatchInputEvent
)
{
return
;
}
FireInputEvent
(
)
;
break
;
case
eNotifyEditorObserversOfBefore
:
if
(
NS_WARN_IF
(
mIsInEditSubAction
)
)
{
break
;
}
mIsInEditSubAction
=
true
;
if
(
mIMEContentObserver
)
{
RefPtr
<
IMEContentObserver
>
observer
=
mIMEContentObserver
;
observer
-
>
BeforeEditAction
(
)
;
}
break
;
case
eNotifyEditorObserversOfCancel
:
mIsInEditSubAction
=
false
;
if
(
mIMEContentObserver
)
{
RefPtr
<
IMEContentObserver
>
observer
=
mIMEContentObserver
;
observer
-
>
CancelEditAction
(
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Handle
all
notifications
here
"
)
;
break
;
}
}
void
EditorBase
:
:
FireInputEvent
(
)
{
RefPtr
<
Element
>
targetElement
=
GetInputEventTargetElement
(
)
;
if
(
NS_WARN_IF
(
!
targetElement
)
)
{
return
;
}
RefPtr
<
TextEditor
>
textEditor
=
AsTextEditor
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchInputEvent
(
targetElement
textEditor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
dispatch
input
event
"
)
;
}
NS_IMETHODIMP
EditorBase
:
:
AddEditActionListener
(
nsIEditActionListener
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_NULL_POINTER
)
;
if
(
mInlineSpellChecker
)
{
EditorSpellCheck
*
editorSpellCheck
=
mInlineSpellChecker
-
>
GetEditorSpellCheck
(
)
;
if
(
editorSpellCheck
)
{
mozSpellChecker
*
spellChecker
=
editorSpellCheck
-
>
GetSpellChecker
(
)
;
if
(
spellChecker
)
{
TextServicesDocument
*
textServicesDocument
=
spellChecker
-
>
GetTextServicesDocument
(
)
;
if
(
static_cast
<
nsIEditActionListener
*
>
(
textServicesDocument
)
=
=
aListener
)
{
mTextServicesDocument
=
textServicesDocument
;
return
NS_OK
;
}
}
}
}
if
(
!
mActionListeners
.
Contains
(
aListener
)
)
{
mActionListeners
.
AppendElement
(
*
aListener
)
;
NS_WARNING_ASSERTION
(
mActionListeners
.
Length
(
)
!
=
1
"
nsIEditActionListener
installed
this
editor
becomes
slower
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
RemoveEditActionListener
(
nsIEditActionListener
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_FAILURE
)
;
if
(
static_cast
<
nsIEditActionListener
*
>
(
mTextServicesDocument
)
=
=
aListener
)
{
mTextServicesDocument
=
nullptr
;
return
NS_OK
;
}
NS_WARNING_ASSERTION
(
mActionListeners
.
Length
(
)
!
=
1
"
All
nsIEditActionListeners
have
been
removed
this
"
"
editor
becomes
faster
"
)
;
mActionListeners
.
RemoveElement
(
aListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
AddDocumentStateListener
(
nsIDocumentStateListener
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_NULL_POINTER
)
;
if
(
!
mDocStateListeners
.
Contains
(
aListener
)
)
{
mDocStateListeners
.
AppendElement
(
*
aListener
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
RemoveDocumentStateListener
(
nsIDocumentStateListener
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_NULL_POINTER
)
;
mDocStateListeners
.
RemoveElement
(
aListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
OutputToString
(
const
nsAString
&
aFormatType
uint32_t
aFlags
nsAString
&
aOutputString
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
EditorBase
:
:
ArePreservingSelection
(
)
{
return
IsEditActionDataAvailable
(
)
&
&
!
SavedSelectionRef
(
)
.
IsEmpty
(
)
;
}
void
EditorBase
:
:
PreserveSelectionAcrossActions
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SavedSelectionRef
(
)
.
SaveSelection
(
SelectionRefPtr
(
)
)
;
RangeUpdaterRef
(
)
.
RegisterSelectionState
(
SavedSelectionRef
(
)
)
;
}
nsresult
EditorBase
:
:
RestorePreservedSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SavedSelectionRef
(
)
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
SavedSelectionRef
(
)
.
RestoreSelection
(
SelectionRefPtr
(
)
)
;
StopPreservingSelection
(
)
;
return
NS_OK
;
}
void
EditorBase
:
:
StopPreservingSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RangeUpdaterRef
(
)
.
DropSelectionState
(
SavedSelectionRef
(
)
)
;
SavedSelectionRef
(
)
.
MakeEmpty
(
)
;
}
NS_IMETHODIMP
EditorBase
:
:
ForceCompositionEnd
(
)
{
return
CommitComposition
(
)
;
}
nsresult
EditorBase
:
:
CommitComposition
(
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mComposition
?
IMEStateManager
:
:
NotifyIME
(
REQUEST_TO_COMMIT_COMPOSITION
pc
)
:
NS_OK
;
}
nsresult
EditorBase
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
aState
-
>
mEnabled
=
IMEState
:
:
ENABLED
;
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
aState
-
>
mEnabled
=
IMEState
:
:
DISABLED
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
content
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
switch
(
frame
-
>
StyleUIReset
(
)
-
>
mIMEMode
)
{
case
NS_STYLE_IME_MODE_AUTO
:
if
(
IsPasswordEditor
(
)
)
aState
-
>
mEnabled
=
IMEState
:
:
PASSWORD
;
break
;
case
NS_STYLE_IME_MODE_DISABLED
:
aState
-
>
mEnabled
=
IMEState
:
:
PASSWORD
;
break
;
case
NS_STYLE_IME_MODE_ACTIVE
:
aState
-
>
mOpen
=
IMEState
:
:
OPEN
;
break
;
case
NS_STYLE_IME_MODE_INACTIVE
:
aState
-
>
mOpen
=
IMEState
:
:
CLOSED
;
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetComposing
(
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
IsIMEComposing
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetRootElement
(
Element
*
*
aRootElement
)
{
NS_ENSURE_ARG_POINTER
(
aRootElement
)
;
NS_ENSURE_TRUE
(
mRootElement
NS_ERROR_NOT_AVAILABLE
)
;
RefPtr
<
Element
>
rootElement
=
mRootElement
;
rootElement
.
forget
(
aRootElement
)
;
return
NS_OK
;
}
void
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
mEditActionData
-
>
SetTopLevelEditSubAction
(
aEditSubAction
aDirection
)
;
}
void
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
mEditActionData
-
>
SetTopLevelEditSubAction
(
EditSubAction
:
:
eNone
eNone
)
;
}
NS_IMETHODIMP
EditorBase
:
:
CloneAttribute
(
const
nsAString
&
aAttribute
Element
*
aDestElement
Element
*
aSourceElement
)
{
NS_ENSURE_TRUE
(
aDestElement
&
&
aSourceElement
NS_ERROR_NULL_POINTER
)
;
if
(
NS_WARN_IF
(
aAttribute
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
CloneAttributeWithTransaction
(
*
attribute
*
aDestElement
*
aSourceElement
)
;
}
nsresult
EditorBase
:
:
CloneAttributeWithTransaction
(
nsAtom
&
aAttribute
Element
&
aDestElement
Element
&
aSourceElement
)
{
nsAutoString
attrValue
;
if
(
aSourceElement
.
GetAttr
(
kNameSpaceID_None
&
aAttribute
attrValue
)
)
{
return
SetAttributeWithTransaction
(
aDestElement
aAttribute
attrValue
)
;
}
return
RemoveAttributeWithTransaction
(
aDestElement
aAttribute
)
;
}
NS_IMETHODIMP
EditorBase
:
:
CloneAttributes
(
Element
*
aDestElement
Element
*
aSourceElement
)
{
if
(
NS_WARN_IF
(
!
aDestElement
)
|
|
NS_WARN_IF
(
!
aSourceElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CloneAttributesWithTransaction
(
*
aDestElement
*
aSourceElement
)
;
return
NS_OK
;
}
void
EditorBase
:
:
CloneAttributesWithTransaction
(
Element
&
aDestElement
Element
&
aSourceElement
)
{
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
;
}
OwningNonNull
<
Element
>
destElement
(
aDestElement
)
;
OwningNonNull
<
Element
>
sourceElement
(
aSourceElement
)
;
bool
isDestElementInBody
=
rootElement
-
>
Contains
(
destElement
)
;
RefPtr
<
nsDOMAttributeMap
>
destAttributes
=
destElement
-
>
Attributes
(
)
;
while
(
RefPtr
<
Attr
>
attr
=
destAttributes
-
>
Item
(
0
)
)
{
if
(
isDestElementInBody
)
{
RemoveAttributeWithTransaction
(
destElement
*
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
else
{
destElement
-
>
UnsetAttr
(
kNameSpaceID_None
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
true
)
;
}
}
RefPtr
<
nsDOMAttributeMap
>
sourceAttributes
=
sourceElement
-
>
Attributes
(
)
;
uint32_t
sourceCount
=
sourceAttributes
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
sourceCount
;
i
+
+
)
{
RefPtr
<
Attr
>
attr
=
sourceAttributes
-
>
Item
(
i
)
;
nsAutoString
value
;
attr
-
>
GetValue
(
value
)
;
if
(
isDestElementInBody
)
{
SetAttributeOrEquivalent
(
destElement
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
value
false
)
;
}
else
{
SetAttributeOrEquivalent
(
destElement
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
value
true
)
;
}
}
}
nsresult
EditorBase
:
:
ScrollSelectionIntoView
(
bool
aScrollToAnchor
)
{
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
!
selectionController
)
{
return
NS_OK
;
}
int16_t
region
=
nsISelectionController
:
:
SELECTION_FOCUS_REGION
;
if
(
aScrollToAnchor
)
{
region
=
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
;
}
selectionController
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
region
nsISelectionController
:
:
SCROLL_OVERFLOW_HIDDEN
)
;
return
NS_OK
;
}
EditorRawDOMPoint
EditorBase
:
:
FindBetterInsertionPoint
(
const
EditorRawDOMPoint
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
aPoint
;
}
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
aPoint
;
}
if
(
!
IsPlaintextEditor
(
)
)
{
return
aPoint
;
}
nsCOMPtr
<
nsINode
>
root
=
GetRoot
(
)
;
if
(
aPoint
.
GetContainer
(
)
=
=
root
)
{
if
(
aPoint
.
IsStartOfContainer
(
)
&
&
aPoint
.
GetContainer
(
)
-
>
HasChildren
(
)
&
&
aPoint
.
GetContainer
(
)
-
>
GetFirstChild
(
)
-
>
IsText
(
)
)
{
return
EditorRawDOMPoint
(
aPoint
.
GetContainer
(
)
-
>
GetFirstChild
(
)
0
)
;
}
if
(
!
aPoint
.
IsStartOfContainer
(
)
)
{
if
(
AsHTMLEditor
(
)
)
{
nsIContent
*
child
=
aPoint
.
GetPreviousSiblingOfChild
(
)
;
if
(
child
&
&
child
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
child
-
>
Length
(
)
>
INT32_MAX
)
)
{
return
aPoint
;
}
return
EditorRawDOMPoint
(
child
child
-
>
Length
(
)
)
;
}
}
else
{
nsIContent
*
child
=
aPoint
.
GetContainer
(
)
-
>
GetLastChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
child
-
>
Length
(
)
>
INT32_MAX
)
)
{
return
aPoint
;
}
return
EditorRawDOMPoint
(
child
child
-
>
Length
(
)
)
;
}
child
=
child
-
>
GetPreviousSibling
(
)
;
}
}
}
}
if
(
TextEditUtils
:
:
IsMozBR
(
aPoint
.
GetContainer
(
)
)
&
&
aPoint
.
IsStartOfContainer
(
)
)
{
nsIContent
*
previousSibling
=
aPoint
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
;
if
(
previousSibling
&
&
previousSibling
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
previousSibling
-
>
Length
(
)
>
INT32_MAX
)
)
{
return
aPoint
;
}
return
EditorRawDOMPoint
(
previousSibling
previousSibling
-
>
Length
(
)
)
;
}
nsINode
*
parentOfContainer
=
aPoint
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
if
(
parentOfContainer
&
&
parentOfContainer
=
=
root
)
{
return
EditorRawDOMPoint
(
parentOfContainer
aPoint
.
GetContainerAsContent
(
)
0
)
;
}
}
return
aPoint
;
}
nsresult
EditorBase
:
:
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
MOZ_ASSERT
(
ShouldHandleIMEComposition
(
)
|
|
!
AllowsTransactionsToChangeSelection
(
)
"
caller
must
have
already
used
AutoTransactionsConserveSelection
"
"
if
this
is
not
for
updating
composition
string
"
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
ShouldHandleIMEComposition
(
)
&
&
aStringToInsert
.
IsEmpty
(
)
)
{
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
aPointToInsert
;
}
return
NS_OK
;
}
CheckedInt
<
int32_t
>
lengthToInsert
(
aStringToInsert
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
!
lengthToInsert
.
isValid
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
pointToInsert
=
FindBetterInsertionPoint
(
aPointToInsert
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
)
{
nsIContent
*
child
=
nullptr
;
if
(
!
pointToInsert
.
IsStartOfContainer
(
)
&
&
(
child
=
pointToInsert
.
GetPreviousSiblingOfChild
(
)
)
&
&
child
-
>
IsText
(
)
)
{
pointToInsert
.
Set
(
child
child
-
>
Length
(
)
)
;
}
else
if
(
!
pointToInsert
.
IsEndOfContainer
(
)
&
&
(
child
=
pointToInsert
.
GetChild
(
)
)
&
&
child
-
>
IsText
(
)
)
{
pointToInsert
.
Set
(
child
0
)
;
}
}
if
(
ShouldHandleIMEComposition
(
)
)
{
CheckedInt
<
int32_t
>
newOffset
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
)
{
RefPtr
<
nsTextNode
>
newNode
=
EditorBase
:
:
CreateTextNode
(
aDocument
EmptyString
(
)
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
*
newNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
pointToInsert
.
Set
(
newNode
0
)
;
newOffset
=
lengthToInsert
;
}
else
{
newOffset
=
lengthToInsert
+
pointToInsert
.
Offset
(
)
;
NS_ENSURE_TRUE
(
newOffset
.
isValid
(
)
NS_ERROR_FAILURE
)
;
}
nsresult
rv
=
InsertTextIntoTextNodeWithTransaction
(
aStringToInsert
*
pointToInsert
.
GetContainerAsText
(
)
pointToInsert
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPointAfterInsertedString
)
{
aPointAfterInsertedString
-
>
Set
(
pointToInsert
.
GetContainer
(
)
newOffset
.
value
(
)
)
;
}
return
NS_OK
;
}
if
(
pointToInsert
.
IsInTextNode
(
)
)
{
CheckedInt
<
int32_t
>
newOffset
=
lengthToInsert
+
pointToInsert
.
Offset
(
)
;
NS_ENSURE_TRUE
(
newOffset
.
isValid
(
)
NS_ERROR_FAILURE
)
;
nsresult
rv
=
InsertTextIntoTextNodeWithTransaction
(
aStringToInsert
*
pointToInsert
.
GetContainerAsText
(
)
pointToInsert
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aPointAfterInsertedString
)
{
aPointAfterInsertedString
-
>
Set
(
pointToInsert
.
GetContainer
(
)
newOffset
.
value
(
)
)
;
}
return
NS_OK
;
}
RefPtr
<
nsTextNode
>
newNode
=
EditorBase
:
:
CreateTextNode
(
aDocument
aStringToInsert
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
*
newNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aPointAfterInsertedString
)
{
aPointAfterInsertedString
-
>
Set
(
newNode
lengthToInsert
.
value
(
)
)
;
}
return
NS_OK
;
}
nsresult
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
const
nsAString
&
aStringToInsert
Text
&
aTextNode
int32_t
aOffset
bool
aSuppressIME
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
EditTransactionBase
>
transaction
;
bool
isIMETransaction
=
false
;
RefPtr
<
Text
>
insertedTextNode
=
&
aTextNode
;
int32_t
insertedOffset
=
aOffset
;
if
(
ShouldHandleIMEComposition
(
)
&
&
!
aSuppressIME
)
{
transaction
=
CompositionTransaction
:
:
Create
(
*
this
aStringToInsert
aTextNode
aOffset
)
;
isIMETransaction
=
true
;
insertedTextNode
=
mComposition
-
>
GetContainerTextNode
(
)
;
insertedOffset
=
mComposition
-
>
XPOffsetInTextNode
(
)
;
}
else
{
transaction
=
InsertTextTransaction
:
:
Create
(
*
this
aStringToInsert
aTextNode
aOffset
)
;
}
BeginUpdateViewBatch
(
)
;
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
EndUpdateViewBatch
(
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
&
&
insertedTextNode
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidInsertText
(
*
insertedTextNode
insertedOffset
aStringToInsert
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidInsertText
(
insertedTextNode
insertedOffset
aStringToInsert
rv
)
;
}
}
if
(
isIMETransaction
&
&
mComposition
)
{
Text
*
textNode
=
mComposition
-
>
GetContainerTextNode
(
)
;
if
(
textNode
&
&
!
textNode
-
>
Length
(
)
)
{
DeleteNodeWithTransaction
(
*
textNode
)
;
mComposition
-
>
OnTextNodeRemoved
(
)
;
static_cast
<
CompositionTransaction
*
>
(
transaction
.
get
(
)
)
-
>
MarkFixed
(
)
;
}
}
return
rv
;
}
nsresult
EditorBase
:
:
SelectEntireDocument
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Element
*
rootElement
=
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
errorResult
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
rootElement
errorResult
)
;
return
errorResult
.
StealNSResult
(
)
;
}
nsINode
*
EditorBase
:
:
GetFirstEditableNode
(
nsINode
*
aRoot
)
{
MOZ_ASSERT
(
aRoot
)
;
nsIContent
*
node
=
GetLeftmostChild
(
aRoot
)
;
if
(
node
&
&
!
IsEditable
(
node
)
)
{
node
=
GetNextEditableNode
(
*
node
)
;
}
return
(
node
!
=
aRoot
)
?
node
:
nullptr
;
}
nsresult
EditorBase
:
:
NotifyDocumentListeners
(
TDocumentListenerNotification
aNotificationType
)
{
if
(
!
mDocStateListeners
.
Length
(
)
)
{
return
NS_OK
;
}
AutoDocumentStateListenerArray
listeners
(
mDocStateListeners
)
;
nsresult
rv
=
NS_OK
;
switch
(
aNotificationType
)
{
case
eDocumentCreated
:
for
(
auto
&
listener
:
listeners
)
{
rv
=
listener
-
>
NotifyDocumentCreated
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
break
;
case
eDocumentToBeDestroyed
:
for
(
auto
&
listener
:
listeners
)
{
rv
=
listener
-
>
NotifyDocumentWillBeDestroyed
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
break
;
case
eDocumentStateChanged
:
{
bool
docIsDirty
;
rv
=
GetDocumentModified
(
&
docIsDirty
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
static_cast
<
int8_t
>
(
docIsDirty
)
=
=
mDocDirtyState
)
{
return
NS_OK
;
}
mDocDirtyState
=
docIsDirty
;
for
(
auto
&
listener
:
listeners
)
{
rv
=
listener
-
>
NotifyDocumentStateChanged
(
mDocDirtyState
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
notification
"
)
;
}
return
rv
;
}
nsresult
EditorBase
:
:
SetTextImpl
(
const
nsAString
&
aString
Text
&
aCharData
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
const
uint32_t
length
=
aCharData
.
Length
(
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eSetText
nsIEditor
:
:
eNext
)
;
if
(
!
mActionListeners
.
IsEmpty
(
)
&
&
length
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
WillDeleteText
(
&
aCharData
0
length
)
;
}
}
ErrorResult
res
;
aCharData
.
SetData
(
aString
res
)
;
nsresult
rv
=
res
.
StealNSResult
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
{
DebugOnly
<
nsresult
>
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
&
aCharData
aString
.
Length
(
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
could
not
be
collapsed
after
insert
"
)
;
}
RangeUpdaterRef
(
)
.
SelAdjDeleteText
(
&
aCharData
0
length
)
;
RangeUpdaterRef
(
)
.
SelAdjInsertText
(
aCharData
0
aString
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
if
(
length
)
{
htmlEditRules
-
>
DidDeleteText
(
aCharData
0
length
)
;
}
if
(
!
aString
.
IsEmpty
(
)
)
{
htmlEditRules
-
>
DidInsertText
(
aCharData
0
aString
)
;
}
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
if
(
length
)
{
listener
-
>
DidDeleteText
(
&
aCharData
0
length
rv
)
;
}
if
(
!
aString
.
IsEmpty
(
)
)
{
listener
-
>
DidInsertText
(
&
aCharData
0
aString
rv
)
;
}
}
}
return
rv
;
}
nsresult
EditorBase
:
:
DeleteTextWithTransaction
(
CharacterData
&
aCharData
uint32_t
aOffset
uint32_t
aLength
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
DeleteTextTransaction
>
transaction
=
DeleteTextTransaction
:
:
MaybeCreate
(
*
this
aCharData
aOffset
aLength
)
;
if
(
NS_WARN_IF
(
!
transaction
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eDeleteText
nsIEditor
:
:
ePrevious
)
;
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
WillDeleteText
(
&
aCharData
aOffset
aLength
)
;
}
}
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
RefPtr
<
HTMLEditRules
>
htmlEditRules
=
mRules
-
>
AsHTMLEditRules
(
)
;
htmlEditRules
-
>
DidDeleteText
(
aCharData
aOffset
aLength
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
AutoActionListenerArray
listeners
(
mActionListeners
)
;
for
(
auto
&
listener
:
listeners
)
{
listener
-
>
DidDeleteText
(
&
aCharData
aOffset
aLength
rv
)
;
}
}
return
rv
;
}
struct
SavedRange
final
{
RefPtr
<
Selection
>
mSelection
;
nsCOMPtr
<
nsINode
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
int32_t
mStartOffset
;
int32_t
mEndOffset
;
}
;
void
EditorBase
:
:
DoSplitNode
(
const
EditorDOMPoint
&
aStartOfRightNode
nsIContent
&
aNewLeftNode
ErrorResult
&
aError
)
{
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsSet
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
range
;
range
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
NS_WARN_IF
(
!
range
.
mSelection
&
&
selectionType
=
=
SelectionType
:
:
eNormal
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
else
if
(
!
range
.
mSelection
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
range
.
mSelection
-
>
RangeCount
(
)
;
+
+
j
)
{
RefPtr
<
nsRange
>
r
=
range
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
range
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
range
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
range
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
range
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
savedRanges
.
AppendElement
(
range
)
;
}
}
nsCOMPtr
<
nsINode
>
parent
=
aStartOfRightNode
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
firstChildOfRightNode
=
aStartOfRightNode
.
GetChild
(
)
;
parent
-
>
InsertBefore
(
aNewLeftNode
aStartOfRightNode
.
GetContainer
(
)
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
if
(
!
aStartOfRightNode
.
IsStartOfContainer
(
)
)
{
Text
*
rightAsText
=
aStartOfRightNode
.
GetContainerAsText
(
)
;
Text
*
leftAsText
=
aNewLeftNode
.
GetAsText
(
)
;
if
(
rightAsText
&
&
leftAsText
)
{
nsAutoString
leftText
;
rightAsText
-
>
SubstringData
(
0
aStartOfRightNode
.
Offset
(
)
leftText
IgnoreErrors
(
)
)
;
rightAsText
-
>
DeleteData
(
0
aStartOfRightNode
.
Offset
(
)
IgnoreErrors
(
)
)
;
leftAsText
-
>
GetAsText
(
)
-
>
SetData
(
leftText
IgnoreErrors
(
)
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
!
rightAsText
&
&
!
leftAsText
)
;
if
(
!
firstChildOfRightNode
)
{
MoveAllChildren
(
*
aStartOfRightNode
.
GetContainer
(
)
EditorRawDOMPoint
(
&
aNewLeftNode
0
)
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
Failed
to
move
all
children
from
the
right
node
to
the
left
node
"
)
;
}
else
if
(
NS_WARN_IF
(
aStartOfRightNode
.
GetContainer
(
)
!
=
firstChildOfRightNode
-
>
GetParentNode
(
)
)
)
{
}
else
{
MovePreviousSiblings
(
*
firstChildOfRightNode
EditorRawDOMPoint
(
&
aNewLeftNode
0
)
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
Failed
to
move
some
children
from
the
right
node
"
"
to
the
left
node
"
)
;
}
}
}
aError
.
SuppressException
(
)
;
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
if
(
ps
)
{
ps
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
NS_WARNING_ASSERTION
(
!
Destroyed
(
)
"
The
editor
is
destroyed
during
splitting
a
node
"
)
;
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
size_t
i
=
0
;
i
<
savedRanges
.
Length
(
)
;
+
+
i
)
{
SavedRange
&
range
=
savedRanges
[
i
]
;
if
(
range
.
mSelection
!
=
previousSelection
)
{
range
.
mSelection
-
>
RemoveAllRanges
(
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
previousSelection
=
range
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
range
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
range
.
mStartContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
static_cast
<
uint32_t
>
(
range
.
mStartOffset
)
<
aStartOfRightNode
.
Offset
(
)
)
{
range
.
mStartContainer
=
&
aNewLeftNode
;
}
else
{
range
.
mStartOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
}
if
(
range
.
mEndContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
static_cast
<
uint32_t
>
(
range
.
mEndOffset
)
<
aStartOfRightNode
.
Offset
(
)
)
{
range
.
mEndContainer
=
&
aNewLeftNode
;
}
else
{
range
.
mEndOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
}
RefPtr
<
nsRange
>
newRange
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
range
.
mStartContainer
range
.
mStartOffset
range
.
mEndContainer
range
.
mEndOffset
getter_AddRefs
(
newRange
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
range
.
mSelection
-
>
AddRange
(
*
newRange
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
}
}
nsresult
EditorBase
:
:
DoJoinNodes
(
nsINode
*
aNodeToKeep
nsINode
*
aNodeToJoin
nsINode
*
aParent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNodeToKeep
)
;
MOZ_ASSERT
(
aNodeToJoin
)
;
MOZ_ASSERT
(
aParent
)
;
uint32_t
firstNodeLength
=
aNodeToJoin
-
>
Length
(
)
;
int32_t
joinOffset
;
GetNodeLocation
(
aNodeToJoin
&
joinOffset
)
;
int32_t
keepOffset
;
nsINode
*
parent
=
GetNodeLocation
(
aNodeToKeep
&
keepOffset
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
range
;
range
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
selectionType
=
=
SelectionType
:
:
eNormal
)
{
NS_ENSURE_TRUE
(
range
.
mSelection
NS_ERROR_NULL_POINTER
)
;
}
else
if
(
!
range
.
mSelection
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
range
.
mSelection
-
>
RangeCount
(
)
;
+
+
j
)
{
RefPtr
<
nsRange
>
r
=
range
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
range
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
range
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
range
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
range
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
if
(
range
.
mStartContainer
)
{
if
(
range
.
mStartContainer
=
=
parent
&
&
joinOffset
<
range
.
mStartOffset
&
&
range
.
mStartOffset
<
=
keepOffset
)
{
range
.
mStartContainer
=
aNodeToJoin
;
range
.
mStartOffset
=
firstNodeLength
;
}
if
(
range
.
mEndContainer
=
=
parent
&
&
joinOffset
<
range
.
mEndOffset
&
&
range
.
mEndOffset
<
=
keepOffset
)
{
range
.
mEndContainer
=
aNodeToJoin
;
range
.
mEndOffset
=
firstNodeLength
;
}
}
savedRanges
.
AppendElement
(
range
)
;
}
}
if
(
IsTextNode
(
aNodeToKeep
)
&
&
IsTextNode
(
aNodeToJoin
)
)
{
nsAutoString
rightText
;
nsAutoString
leftText
;
aNodeToKeep
-
>
GetAsText
(
)
-
>
GetData
(
rightText
)
;
aNodeToJoin
-
>
GetAsText
(
)
-
>
GetData
(
leftText
)
;
leftText
+
=
rightText
;
aNodeToKeep
-
>
GetAsText
(
)
-
>
SetData
(
leftText
IgnoreErrors
(
)
)
;
}
else
{
nsCOMPtr
<
nsINodeList
>
childNodes
=
aNodeToJoin
-
>
ChildNodes
(
)
;
MOZ_ASSERT
(
childNodes
)
;
nsCOMPtr
<
nsIContent
>
firstNode
=
aNodeToKeep
-
>
GetFirstChild
(
)
;
for
(
uint32_t
i
=
childNodes
-
>
Length
(
)
;
i
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
childNode
=
childNodes
-
>
Item
(
i
-
1
)
;
if
(
childNode
)
{
ErrorResult
err
;
aNodeToKeep
-
>
InsertBefore
(
*
childNode
firstNode
err
)
;
NS_ENSURE_TRUE
(
!
err
.
Failed
(
)
err
.
StealNSResult
(
)
)
;
firstNode
=
childNode
.
forget
(
)
;
}
}
}
ErrorResult
err
;
aParent
-
>
RemoveChild
(
*
aNodeToJoin
err
)
;
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
size_t
i
=
0
;
i
<
savedRanges
.
Length
(
)
;
+
+
i
)
{
SavedRange
&
range
=
savedRanges
[
i
]
;
if
(
range
.
mSelection
!
=
previousSelection
)
{
ErrorResult
rv
;
range
.
mSelection
-
>
RemoveAllRanges
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
previousSelection
=
range
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
range
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
range
.
mStartContainer
=
=
aNodeToJoin
)
{
range
.
mStartContainer
=
aNodeToKeep
;
}
else
if
(
range
.
mStartContainer
=
=
aNodeToKeep
)
{
range
.
mStartOffset
+
=
firstNodeLength
;
}
if
(
range
.
mEndContainer
=
=
aNodeToJoin
)
{
range
.
mEndContainer
=
aNodeToKeep
;
}
else
if
(
range
.
mEndContainer
=
=
aNodeToKeep
)
{
range
.
mEndOffset
+
=
firstNodeLength
;
}
RefPtr
<
nsRange
>
newRange
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
range
.
mStartContainer
range
.
mStartOffset
range
.
mEndContainer
range
.
mEndOffset
getter_AddRefs
(
newRange
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ErrorResult
err
;
range
.
mSelection
-
>
AddRange
(
*
newRange
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
}
if
(
allowedTransactionsToChangeSelection
)
{
DebugOnly
<
nsresult
>
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
aNodeToKeep
AssertedCast
<
int32_t
>
(
firstNodeLength
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
Selection
at
end
of
the
node
"
)
;
}
return
err
.
StealNSResult
(
)
;
}
int32_t
EditorBase
:
:
GetChildOffset
(
nsINode
*
aChild
nsINode
*
aParent
)
{
MOZ_ASSERT
(
aChild
)
;
MOZ_ASSERT
(
aParent
)
;
if
(
aParent
-
>
GetFirstChild
(
)
=
=
aChild
)
{
MOZ_ASSERT
(
aParent
-
>
ComputeIndexOf
(
aChild
)
=
=
0
)
;
return
0
;
}
if
(
aParent
-
>
GetLastChild
(
)
=
=
aChild
)
{
int32_t
lastChildIndex
=
static_cast
<
int32_t
>
(
aParent
-
>
Length
(
)
-
1
)
;
MOZ_ASSERT
(
aParent
-
>
ComputeIndexOf
(
aChild
)
=
=
lastChildIndex
)
;
return
lastChildIndex
;
}
int32_t
index
=
aParent
-
>
ComputeIndexOf
(
aChild
)
;
MOZ_ASSERT
(
index
!
=
-
1
)
;
return
index
;
}
nsINode
*
EditorBase
:
:
GetNodeLocation
(
nsINode
*
aChild
int32_t
*
aOffset
)
{
MOZ_ASSERT
(
aChild
)
;
MOZ_ASSERT
(
aOffset
)
;
nsINode
*
parent
=
aChild
-
>
GetParentNode
(
)
;
if
(
parent
)
{
*
aOffset
=
GetChildOffset
(
aChild
parent
)
;
MOZ_ASSERT
(
*
aOffset
!
=
-
1
)
;
}
else
{
*
aOffset
=
-
1
;
}
return
parent
;
}
nsIContent
*
EditorBase
:
:
GetPreviousNodeInternal
(
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
{
if
(
!
IsDescendantOfEditorRoot
(
&
aNode
)
)
{
return
nullptr
;
}
return
FindNode
(
&
aNode
false
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
nsIContent
*
EditorBase
:
:
GetPreviousNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetPreviousNodeInternal
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
|
|
aPoint
.
IsInTextNode
(
)
)
{
if
(
aNoBlockCrossing
&
&
IsBlockNode
(
aPoint
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
GetPreviousNodeInternal
(
*
aPoint
.
GetContainer
(
)
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
if
(
aPoint
.
GetChild
(
)
)
{
return
GetPreviousNodeInternal
(
*
aPoint
.
GetChild
(
)
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
nsIContent
*
rightMostNode
=
GetRightmostChild
(
aPoint
.
GetContainer
(
)
aNoBlockCrossing
)
;
if
(
!
rightMostNode
)
{
return
nullptr
;
}
if
(
(
!
aFindEditableNode
|
|
IsEditable
(
rightMostNode
)
)
&
&
(
aFindAnyDataNode
|
|
IsElementOrText
(
*
rightMostNode
)
)
)
{
return
rightMostNode
;
}
return
GetPreviousNodeInternal
(
*
rightMostNode
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
nsIContent
*
EditorBase
:
:
GetNextNodeInternal
(
nsINode
&
aNode
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
{
if
(
!
IsDescendantOfEditorRoot
(
&
aNode
)
)
{
return
nullptr
;
}
return
FindNode
(
&
aNode
true
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
nsIContent
*
EditorBase
:
:
GetNextNodeInternal
(
const
EditorRawDOMPoint
&
aPoint
bool
aFindEditableNode
bool
aFindAnyDataNode
bool
aNoBlockCrossing
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetNextNodeInternal
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
EditorRawDOMPoint
point
(
aPoint
)
;
if
(
point
.
IsInTextNode
(
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
bool
advanced
=
point
.
AdvanceOffset
(
)
;
if
(
NS_WARN_IF
(
!
advanced
)
)
{
return
nullptr
;
}
}
if
(
point
.
GetChild
(
)
)
{
if
(
aNoBlockCrossing
&
&
IsBlockNode
(
point
.
GetChild
(
)
)
)
{
return
point
.
GetChild
(
)
;
}
nsIContent
*
leftMostNode
=
GetLeftmostChild
(
point
.
GetChild
(
)
aNoBlockCrossing
)
;
if
(
!
leftMostNode
)
{
return
point
.
GetChild
(
)
;
}
if
(
!
IsDescendantOfEditorRoot
(
leftMostNode
)
)
{
return
nullptr
;
}
if
(
(
!
aFindEditableNode
|
|
IsEditable
(
leftMostNode
)
)
&
&
(
aFindAnyDataNode
|
|
IsElementOrText
(
*
leftMostNode
)
)
)
{
return
leftMostNode
;
}
return
GetNextNodeInternal
(
*
leftMostNode
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
if
(
aNoBlockCrossing
&
&
IsBlockNode
(
point
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
GetNextNodeInternal
(
*
point
.
GetContainer
(
)
aFindEditableNode
aFindAnyDataNode
aNoBlockCrossing
)
;
}
nsIContent
*
EditorBase
:
:
FindNextLeafNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
bNoBlockCrossing
)
{
MOZ_ASSERT
(
IsDescendantOfEditorRoot
(
aCurrentNode
)
&
&
!
IsEditorRoot
(
aCurrentNode
)
"
Bogus
arguments
"
)
;
nsINode
*
cur
=
aCurrentNode
;
for
(
;
;
)
{
nsIContent
*
sibling
=
aGoForward
?
cur
-
>
GetNextSibling
(
)
:
cur
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
if
(
bNoBlockCrossing
&
&
IsBlockNode
(
sibling
)
)
{
return
sibling
;
}
nsIContent
*
leaf
=
aGoForward
?
GetLeftmostChild
(
sibling
bNoBlockCrossing
)
:
GetRightmostChild
(
sibling
bNoBlockCrossing
)
;
if
(
!
leaf
)
{
return
sibling
;
}
return
leaf
;
}
nsINode
*
parent
=
cur
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
NS_ASSERTION
(
IsDescendantOfEditorRoot
(
parent
)
"
We
started
with
a
proper
descendant
of
root
and
should
stop
"
"
if
we
ever
hit
the
root
so
we
better
have
a
descendant
of
"
"
root
now
!
"
)
;
if
(
IsEditorRoot
(
parent
)
|
|
(
bNoBlockCrossing
&
&
IsBlockNode
(
parent
)
)
)
{
return
nullptr
;
}
cur
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
What
part
of
for
(
;
;
)
do
you
not
understand
?
"
)
;
return
nullptr
;
}
nsIContent
*
EditorBase
:
:
FindNode
(
nsINode
*
aCurrentNode
bool
aGoForward
bool
aEditableNode
bool
aFindAnyDataNode
bool
bNoBlockCrossing
)
{
if
(
IsEditorRoot
(
aCurrentNode
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
candidate
=
FindNextLeafNode
(
aCurrentNode
aGoForward
bNoBlockCrossing
)
;
if
(
!
candidate
)
{
return
nullptr
;
}
if
(
(
!
aEditableNode
|
|
IsEditable
(
candidate
)
)
&
&
(
aFindAnyDataNode
|
|
IsElementOrText
(
*
candidate
)
)
)
{
return
candidate
;
}
return
FindNode
(
candidate
aGoForward
aEditableNode
aFindAnyDataNode
bNoBlockCrossing
)
;
}
nsIContent
*
EditorBase
:
:
GetRightmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
)
{
NS_ENSURE_TRUE
(
aCurrentNode
nullptr
)
;
nsIContent
*
cur
=
aCurrentNode
-
>
GetLastChild
(
)
;
if
(
!
cur
)
{
return
nullptr
;
}
for
(
;
;
)
{
if
(
bNoBlockCrossing
&
&
IsBlockNode
(
cur
)
)
{
return
cur
;
}
nsIContent
*
next
=
cur
-
>
GetLastChild
(
)
;
if
(
!
next
)
{
return
cur
;
}
cur
=
next
;
}
MOZ_ASSERT_UNREACHABLE
(
"
What
part
of
for
(
;
;
)
do
you
not
understand
?
"
)
;
return
nullptr
;
}
nsIContent
*
EditorBase
:
:
GetLeftmostChild
(
nsINode
*
aCurrentNode
bool
bNoBlockCrossing
)
{
NS_ENSURE_TRUE
(
aCurrentNode
nullptr
)
;
nsIContent
*
cur
=
aCurrentNode
-
>
GetFirstChild
(
)
;
if
(
!
cur
)
{
return
nullptr
;
}
for
(
;
;
)
{
if
(
bNoBlockCrossing
&
&
IsBlockNode
(
cur
)
)
{
return
cur
;
}
nsIContent
*
next
=
cur
-
>
GetFirstChild
(
)
;
if
(
!
next
)
{
return
cur
;
}
cur
=
next
;
}
MOZ_ASSERT_UNREACHABLE
(
"
What
part
of
for
(
;
;
)
do
you
not
understand
?
"
)
;
return
nullptr
;
}
bool
EditorBase
:
:
IsBlockNode
(
nsINode
*
aNode
)
{
return
false
;
}
bool
EditorBase
:
:
CanContain
(
nsINode
&
aParent
nsIContent
&
aChild
)
const
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
TagCanContain
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChild
)
;
}
return
false
;
}
bool
EditorBase
:
:
CanContainTag
(
nsINode
&
aParent
nsAtom
&
aChildTag
)
const
{
switch
(
aParent
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
TagCanContainTag
(
*
aParent
.
NodeInfo
(
)
-
>
NameAtom
(
)
aChildTag
)
;
}
return
false
;
}
bool
EditorBase
:
:
TagCanContain
(
nsAtom
&
aParentTag
nsIContent
&
aChild
)
const
{
switch
(
aChild
.
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
return
TagCanContainTag
(
aParentTag
*
aChild
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
return
false
;
}
bool
EditorBase
:
:
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
const
{
return
true
;
}
bool
EditorBase
:
:
IsRoot
(
nsINode
*
inNode
)
const
{
if
(
NS_WARN_IF
(
!
inNode
)
)
{
return
false
;
}
nsINode
*
rootNode
=
GetRoot
(
)
;
return
inNode
=
=
rootNode
;
}
bool
EditorBase
:
:
IsEditorRoot
(
nsINode
*
aNode
)
const
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
nsINode
*
rootNode
=
GetEditorRoot
(
)
;
return
aNode
=
=
rootNode
;
}
bool
EditorBase
:
:
IsDescendantOfRoot
(
nsINode
*
inNode
)
const
{
if
(
NS_WARN_IF
(
!
inNode
)
)
{
return
false
;
}
nsIContent
*
root
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
inNode
root
)
;
}
bool
EditorBase
:
:
IsDescendantOfEditorRoot
(
nsINode
*
aNode
)
const
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
nsIContent
*
root
=
GetEditorRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
aNode
root
)
;
}
bool
EditorBase
:
:
IsContainer
(
nsINode
*
aNode
)
{
return
aNode
?
true
:
false
;
}
uint32_t
EditorBase
:
:
CountEditableChildren
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
uint32_t
count
=
0
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
IsEditable
(
child
)
)
{
+
+
count
;
}
}
return
count
;
}
NS_IMETHODIMP
EditorBase
:
:
IncrementModificationCount
(
int32_t
inNumMods
)
{
uint32_t
oldModCount
=
mModCount
;
mModCount
+
=
inNumMods
;
if
(
(
!
oldModCount
&
&
mModCount
)
|
|
(
oldModCount
&
&
!
mModCount
)
)
{
NotifyDocumentListeners
(
eDocumentStateChanged
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
GetModificationCount
(
int32_t
*
outModCount
)
{
NS_ENSURE_ARG_POINTER
(
outModCount
)
;
*
outModCount
=
mModCount
;
return
NS_OK
;
}
NS_IMETHODIMP
EditorBase
:
:
ResetModificationCount
(
)
{
bool
doNotify
=
(
mModCount
!
=
0
)
;
mModCount
=
0
;
if
(
doNotify
)
{
NotifyDocumentListeners
(
eDocumentStateChanged
)
;
}
return
NS_OK
;
}
bool
EditorBase
:
:
AreNodesSameType
(
nsIContent
&
aNode1
nsIContent
&
aNode2
)
const
{
if
(
aNode1
.
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
aNode2
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
false
;
}
if
(
!
AsHTMLEditor
(
)
|
|
!
AsHTMLEditor
(
)
-
>
IsCSSEnabled
(
)
)
{
return
true
;
}
if
(
!
aNode1
.
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
return
true
;
}
if
(
!
aNode1
.
IsElement
(
)
|
|
!
aNode2
.
IsElement
(
)
)
{
return
false
;
}
return
CSSEditUtils
:
:
ElementsSameStyle
(
aNode1
.
AsElement
(
)
aNode2
.
AsElement
(
)
)
;
}
nsIContent
*
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
const
RawRangeBoundary
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
if
(
aPoint
.
Container
(
)
-
>
GetAsText
(
)
)
{
return
aPoint
.
Container
(
)
-
>
AsContent
(
)
;
}
return
aPoint
.
GetChildAtOffset
(
)
;
}
EditorRawDOMPoint
EditorBase
:
:
GetStartPoint
(
const
Selection
&
aSelection
)
{
if
(
NS_WARN_IF
(
!
aSelection
.
RangeCount
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
const
nsRange
*
range
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
return
EditorRawDOMPoint
(
range
-
>
StartRef
(
)
)
;
}
EditorRawDOMPoint
EditorBase
:
:
GetEndPoint
(
const
Selection
&
aSelection
)
{
if
(
NS_WARN_IF
(
!
aSelection
.
RangeCount
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
const
nsRange
*
range
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
return
EditorRawDOMPoint
(
range
-
>
EndRef
(
)
)
;
}
nsresult
EditorBase
:
:
GetEndChildNode
(
const
Selection
&
aSelection
nsIContent
*
*
aEndNode
)
{
MOZ_ASSERT
(
aEndNode
)
;
*
aEndNode
=
nullptr
;
if
(
NS_WARN_IF
(
!
aSelection
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
nsRange
*
range
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_IF_ADDREF
(
*
aEndNode
=
range
-
>
GetChildAtEndOffset
(
)
)
;
return
NS_OK
;
}
bool
EditorBase
:
:
IsPreformatted
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
Element
*
element
=
Element
:
:
FromNode
(
aNode
)
;
if
(
!
element
)
{
element
=
aNode
-
>
GetParentElement
(
)
;
if
(
!
element
)
{
return
false
;
}
}
RefPtr
<
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
nullptr
)
;
if
(
!
elementStyle
)
{
return
false
;
}
const
nsStyleText
*
styleText
=
elementStyle
-
>
StyleText
(
)
;
return
styleText
-
>
WhiteSpaceIsSignificant
(
)
;
}
template
<
typename
PT
typename
CT
>
SplitNodeResult
EditorBase
:
:
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfDeepestRightNode
SplitAtEdges
aSplitAtEdges
)
{
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
GetContainer
(
)
=
=
&
aMostAncestorToSplit
|
|
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
aMostAncestorToSplit
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
nsCOMPtr
<
nsIContent
>
newLeftNodeOfMostAncestor
;
EditorDOMPoint
atStartOfRightNode
(
aStartOfDeepestRightNode
)
;
while
(
true
)
{
if
(
NS_WARN_IF
(
!
atStartOfRightNode
.
GetContainerAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
atStartOfRightNode
.
GetContainer
(
)
!
=
&
aMostAncestorToSplit
&
&
!
atStartOfRightNode
.
GetContainer
(
)
-
>
GetParent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
nsIContent
*
currentRightNode
=
atStartOfRightNode
.
GetContainerAsContent
(
)
;
if
(
(
aSplitAtEdges
=
=
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
&
&
!
atStartOfRightNode
.
GetContainerAsText
(
)
)
|
|
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
&
&
!
atStartOfRightNode
.
IsEndOfContainer
(
)
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStartOfRightNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
newLeftNode
&
aMostAncestorToSplit
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
}
else
if
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
)
{
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
&
aMostAncestorToSplit
nullptr
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
DebugOnly
<
bool
>
advanced
=
atStartOfRightNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
current
node
"
)
;
}
else
{
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
nullptr
&
aMostAncestorToSplit
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
}
}
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
EditorBase
:
:
JoinNodesDeepWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
{
nsCOMPtr
<
nsIContent
>
leftNodeToJoin
=
&
aLeftNode
;
nsCOMPtr
<
nsIContent
>
rightNodeToJoin
=
&
aRightNode
;
nsCOMPtr
<
nsINode
>
parentNode
=
aRightNode
.
GetParentNode
(
)
;
EditorDOMPoint
ret
;
while
(
leftNodeToJoin
&
&
rightNodeToJoin
&
&
parentNode
&
&
AreNodesSameType
(
*
leftNodeToJoin
*
rightNodeToJoin
)
)
{
uint32_t
length
=
leftNodeToJoin
-
>
Length
(
)
;
nsresult
rv
=
JoinNodesWithTransaction
(
*
leftNodeToJoin
*
rightNodeToJoin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
ret
.
Set
(
rightNodeToJoin
length
)
;
if
(
parentNode
-
>
GetAsText
(
)
)
{
return
ret
;
}
parentNode
=
rightNodeToJoin
;
rightNodeToJoin
=
parentNode
-
>
GetChildAt_Deprecated
(
length
)
;
if
(
rightNodeToJoin
)
{
leftNodeToJoin
=
rightNodeToJoin
-
>
GetPreviousSibling
(
)
;
}
else
{
leftNodeToJoin
=
nullptr
;
}
while
(
leftNodeToJoin
&
&
!
IsEditable
(
leftNodeToJoin
)
)
{
leftNodeToJoin
=
leftNodeToJoin
-
>
GetPreviousSibling
(
)
;
}
if
(
!
leftNodeToJoin
)
{
return
ret
;
}
while
(
rightNodeToJoin
&
&
!
IsEditable
(
rightNodeToJoin
)
)
{
rightNodeToJoin
=
rightNodeToJoin
-
>
GetNextSibling
(
)
;
}
if
(
!
rightNodeToJoin
)
{
return
ret
;
}
}
if
(
NS_WARN_IF
(
!
ret
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
return
ret
;
}
void
EditorBase
:
:
BeginUpdateViewBatch
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mUpdateCount
>
=
0
"
bad
state
"
)
;
if
(
!
mUpdateCount
)
{
SelectionRefPtr
(
)
-
>
StartBatchChanges
(
)
;
}
mUpdateCount
+
+
;
}
void
EditorBase
:
:
EndUpdateViewBatch
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mUpdateCount
>
0
"
bad
state
"
)
;
if
(
mUpdateCount
<
=
0
)
{
mUpdateCount
=
0
;
return
;
}
if
(
-
-
mUpdateCount
)
{
return
;
}
SelectionRefPtr
(
)
-
>
EndBatchChanges
(
)
;
HTMLEditor
*
htmlEditor
=
AsHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
htmlEditor
-
>
RefereshEditingUI
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RefereshEditingUI
(
)
failed
"
)
;
}
TextComposition
*
EditorBase
:
:
GetComposition
(
)
const
{
return
mComposition
;
}
bool
EditorBase
:
:
IsIMEComposing
(
)
const
{
return
mComposition
&
&
mComposition
-
>
IsComposing
(
)
;
}
bool
EditorBase
:
:
ShouldHandleIMEComposition
(
)
const
{
return
mComposition
&
&
mDidPostCreate
;
}
void
EditorBase
:
:
DoAfterDoTransaction
(
nsITransaction
*
aTxn
)
{
bool
isTransientTransaction
;
MOZ_ALWAYS_SUCCEEDS
(
aTxn
-
>
GetIsTransient
(
&
isTransientTransaction
)
)
;
if
(
!
isTransientTransaction
)
{
int32_t
modCount
;
GetModificationCount
(
&
modCount
)
;
if
(
modCount
<
0
)
{
modCount
=
-
modCount
;
}
MOZ_ALWAYS_SUCCEEDS
(
IncrementModificationCount
(
1
)
)
;
}
}
void
EditorBase
:
:
DoAfterUndoTransaction
(
)
{
MOZ_ALWAYS_SUCCEEDS
(
IncrementModificationCount
(
-
1
)
)
;
}
void
EditorBase
:
:
DoAfterRedoTransaction
(
)
{
MOZ_ALWAYS_SUCCEEDS
(
IncrementModificationCount
(
1
)
)
;
}
already_AddRefed
<
EditAggregateTransaction
>
EditorBase
:
:
CreateTxnForDeleteSelection
(
EDirection
aAction
nsINode
*
*
aRemovingNode
int32_t
*
aOffset
int32_t
*
aLength
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
&
&
aAction
=
=
eNone
)
)
{
return
nullptr
;
}
RefPtr
<
EditAggregateTransaction
>
aggregateTransaction
=
EditAggregateTransaction
:
:
Create
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
rangeIdx
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
nullptr
;
}
if
(
!
range
-
>
Collapsed
(
)
)
{
RefPtr
<
DeleteRangeTransaction
>
deleteRangeTransaction
=
DeleteRangeTransaction
:
:
Create
(
*
this
*
range
)
;
aggregateTransaction
-
>
AppendChild
(
deleteRangeTransaction
)
;
}
else
if
(
aAction
!
=
eNone
)
{
RefPtr
<
EditTransactionBase
>
deleteRangeTransaction
=
CreateTxnForDeleteRange
(
range
aAction
aRemovingNode
aOffset
aLength
)
;
if
(
NS_WARN_IF
(
!
deleteRangeTransaction
)
)
{
return
nullptr
;
}
aggregateTransaction
-
>
AppendChild
(
deleteRangeTransaction
)
;
}
}
return
aggregateTransaction
.
forget
(
)
;
}
already_AddRefed
<
EditTransactionBase
>
EditorBase
:
:
CreateTxnForDeleteRange
(
nsRange
*
aRangeToDelete
EDirection
aAction
nsINode
*
*
aRemovingNode
int32_t
*
aOffset
int32_t
*
aLength
)
{
MOZ_ASSERT
(
aAction
!
=
eNone
)
;
nsCOMPtr
<
nsINode
>
node
=
aRangeToDelete
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
nullptr
;
}
nsIContent
*
child
=
aRangeToDelete
-
>
GetChildAtStartOffset
(
)
;
int32_t
offset
=
aRangeToDelete
-
>
StartOffset
(
)
;
uint32_t
count
=
node
-
>
Length
(
)
;
bool
isFirst
=
!
offset
;
bool
isLast
=
(
count
=
=
(
uint32_t
)
offset
)
;
if
(
aAction
=
=
ePrevious
&
&
isFirst
)
{
nsCOMPtr
<
nsIContent
>
priorNode
=
GetPreviousEditableNode
(
*
node
)
;
if
(
NS_WARN_IF
(
!
priorNode
)
)
{
return
nullptr
;
}
if
(
RefPtr
<
CharacterData
>
priorNodeAsCharData
=
CharacterData
:
:
FromNode
(
priorNode
)
)
{
uint32_t
length
=
priorNode
-
>
Length
(
)
;
if
(
NS_WARN_IF
(
!
length
)
)
{
return
nullptr
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
DeleteTextTransaction
:
:
MaybeCreateForPreviousCharacter
(
*
this
*
priorNodeAsCharData
length
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
nullptr
;
}
*
aOffset
=
deleteTextTransaction
-
>
Offset
(
)
;
*
aLength
=
deleteTextTransaction
-
>
LengthToDelete
(
)
;
priorNode
.
forget
(
aRemovingNode
)
;
return
deleteTextTransaction
.
forget
(
)
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
this
*
priorNode
)
;
if
(
NS_WARN_IF
(
!
deleteNodeTransaction
)
)
{
return
nullptr
;
}
priorNode
.
forget
(
aRemovingNode
)
;
return
deleteNodeTransaction
.
forget
(
)
;
}
if
(
aAction
=
=
eNext
&
&
isLast
)
{
nsCOMPtr
<
nsIContent
>
nextNode
=
GetNextEditableNode
(
*
node
)
;
if
(
NS_WARN_IF
(
!
nextNode
)
)
{
return
nullptr
;
}
if
(
RefPtr
<
CharacterData
>
nextNodeAsCharData
=
CharacterData
:
:
FromNode
(
nextNode
)
)
{
uint32_t
length
=
nextNode
-
>
Length
(
)
;
if
(
NS_WARN_IF
(
!
length
)
)
{
return
nullptr
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
DeleteTextTransaction
:
:
MaybeCreateForNextCharacter
(
*
this
*
nextNodeAsCharData
0
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
nullptr
;
}
*
aOffset
=
deleteTextTransaction
-
>
Offset
(
)
;
*
aLength
=
deleteTextTransaction
-
>
LengthToDelete
(
)
;
nextNode
.
forget
(
aRemovingNode
)
;
return
deleteTextTransaction
.
forget
(
)
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
this
*
nextNode
)
;
if
(
NS_WARN_IF
(
!
deleteNodeTransaction
)
)
{
return
nullptr
;
}
nextNode
.
forget
(
aRemovingNode
)
;
return
deleteNodeTransaction
.
forget
(
)
;
}
if
(
RefPtr
<
CharacterData
>
nodeAsCharData
=
CharacterData
:
:
FromNode
(
node
)
)
{
if
(
NS_WARN_IF
(
aAction
!
=
ePrevious
&
&
aAction
!
=
eNext
)
)
{
return
nullptr
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
aAction
=
=
ePrevious
?
DeleteTextTransaction
:
:
MaybeCreateForPreviousCharacter
(
*
this
*
nodeAsCharData
offset
)
:
DeleteTextTransaction
:
:
MaybeCreateForNextCharacter
(
*
this
*
nodeAsCharData
offset
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
nullptr
;
}
*
aOffset
=
deleteTextTransaction
-
>
Offset
(
)
;
*
aLength
=
deleteTextTransaction
-
>
LengthToDelete
(
)
;
node
.
forget
(
aRemovingNode
)
;
return
deleteTextTransaction
.
forget
(
)
;
}
nsCOMPtr
<
nsINode
>
selectedNode
;
if
(
aAction
=
=
ePrevious
)
{
selectedNode
=
GetPreviousEditableNode
(
EditorRawDOMPoint
(
node
child
offset
)
)
;
}
else
if
(
aAction
=
=
eNext
)
{
selectedNode
=
GetNextEditableNode
(
EditorRawDOMPoint
(
node
child
offset
)
)
;
}
while
(
selectedNode
&
&
selectedNode
-
>
IsCharacterData
(
)
&
&
!
selectedNode
-
>
Length
(
)
)
{
if
(
aAction
=
=
ePrevious
)
{
selectedNode
=
GetPreviousEditableNode
(
*
selectedNode
)
;
}
else
if
(
aAction
=
=
eNext
)
{
selectedNode
=
GetNextEditableNode
(
*
selectedNode
)
;
}
}
if
(
NS_WARN_IF
(
!
selectedNode
)
)
{
return
nullptr
;
}
if
(
RefPtr
<
CharacterData
>
selectedNodeAsCharData
=
CharacterData
:
:
FromNode
(
selectedNode
)
)
{
if
(
NS_WARN_IF
(
aAction
!
=
ePrevious
&
&
aAction
!
=
eNext
)
)
{
return
nullptr
;
}
uint32_t
position
=
0
;
if
(
aAction
=
=
ePrevious
)
{
position
=
selectedNode
-
>
Length
(
)
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
aAction
=
=
ePrevious
?
DeleteTextTransaction
:
:
MaybeCreateForPreviousCharacter
(
*
this
*
selectedNodeAsCharData
position
)
:
DeleteTextTransaction
:
:
MaybeCreateForNextCharacter
(
*
this
*
selectedNodeAsCharData
position
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
nullptr
;
}
*
aOffset
=
deleteTextTransaction
-
>
Offset
(
)
;
*
aLength
=
deleteTextTransaction
-
>
LengthToDelete
(
)
;
selectedNode
.
forget
(
aRemovingNode
)
;
return
deleteTextTransaction
.
forget
(
)
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
this
*
selectedNode
)
;
if
(
NS_WARN_IF
(
!
deleteNodeTransaction
)
)
{
return
nullptr
;
}
selectedNode
.
forget
(
aRemovingNode
)
;
return
deleteNodeTransaction
.
forget
(
)
;
}
nsresult
EditorBase
:
:
CreateRange
(
nsINode
*
aStartContainer
int32_t
aStartOffset
nsINode
*
aEndContainer
int32_t
aEndOffset
nsRange
*
*
aRange
)
{
return
nsRange
:
:
CreateRange
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
aRange
)
;
}
nsresult
EditorBase
:
:
AppendNodeToSelectionAsRange
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsINode
>
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
offset
=
GetChildOffset
(
aNode
parentNode
)
;
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
CreateRange
(
parentNode
offset
parentNode
offset
+
1
getter_AddRefs
(
range
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
err
;
SelectionRefPtr
(
)
-
>
AddRange
(
*
range
err
)
;
NS_WARNING_ASSERTION
(
!
err
.
Failed
(
)
"
Failed
to
add
range
to
Selection
"
)
;
return
err
.
StealNSResult
(
)
;
}
nsresult
EditorBase
:
:
ClearSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
ErrorResult
rv
;
SelectionRefPtr
(
)
-
>
RemoveAllRanges
(
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
remove
all
ranges
from
Selection
"
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
Element
>
EditorBase
:
:
CreateHTMLContent
(
const
nsAtom
*
aTag
)
{
MOZ_ASSERT
(
aTag
)
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
_empty
)
{
NS_ERROR
(
"
Don
'
t
pass
an
empty
tag
to
EditorBase
:
:
CreateHTMLContent
"
"
check
caller
.
"
)
;
return
nullptr
;
}
return
doc
-
>
CreateElem
(
nsDependentAtomString
(
aTag
)
nullptr
kNameSpaceID_XHTML
)
;
}
already_AddRefed
<
nsTextNode
>
EditorBase
:
:
CreateTextNode
(
Document
&
aDocument
const
nsAString
&
aData
)
{
RefPtr
<
nsTextNode
>
text
=
aDocument
.
CreateEmptyTextNode
(
)
;
text
-
>
MarkAsMaybeModifiedFrequently
(
)
;
text
-
>
SetText
(
aData
false
)
;
return
text
.
forget
(
)
;
}
NS_IMETHODIMP
EditorBase
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
const
nsAString
&
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
SetAttributeOrEquivalent
(
aElement
attribute
aValue
aSuppressTransaction
)
;
}
NS_IMETHODIMP
EditorBase
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
const
nsAString
&
aAttribute
bool
aSuppressTransaction
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveAttribute
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttribute
)
;
return
RemoveAttributeOrEquivalent
(
aElement
attribute
aSuppressTransaction
)
;
}
nsresult
EditorBase
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
if
(
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_BACK
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
return
NS_OK
;
}
nsresult
EditorBase
:
:
HandleInlineSpellCheck
(
EditSubAction
aEditSubAction
nsINode
*
previousSelectedNode
uint32_t
previousSelectedOffset
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mInlineSpellChecker
)
{
return
NS_OK
;
}
return
mInlineSpellChecker
-
>
SpellCheckAfterEditorChange
(
aEditSubAction
*
SelectionRefPtr
(
)
previousSelectedNode
previousSelectedOffset
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
}
Element
*
EditorBase
:
:
FindSelectionRoot
(
nsINode
*
aNode
)
const
{
return
GetRoot
(
)
;
}
void
EditorBase
:
:
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SelectionRefPtr
(
)
-
>
SetAncestorLimiter
(
&
aAncestorLimit
)
;
}
nsresult
EditorBase
:
:
InitializeSelection
(
EventTarget
*
aFocusEventTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
targetNode
=
do_QueryInterface
(
aFocusEventTarget
)
;
if
(
NS_WARN_IF
(
!
targetNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIContent
>
selectionRootContent
=
FindSelectionRoot
(
targetNode
)
;
if
(
!
selectionRootContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsISelectionController
>
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
NS_WARN_IF
(
!
caret
)
)
{
return
NS_ERROR_FAILURE
;
}
caret
-
>
SetSelection
(
SelectionRefPtr
(
)
)
;
selectionController
-
>
SetCaretReadOnly
(
IsReadonly
(
)
)
;
selectionController
-
>
SetCaretEnabled
(
true
)
;
caret
-
>
SetIgnoreUserModify
(
targetNode
-
>
OwnerDoc
(
)
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
;
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
selectionController
-
>
SetSelectionFlags
(
nsISelectionDisplay
:
:
DISPLAY_ALL
)
;
selectionController
-
>
RepaintSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
selectionRootContent
-
>
GetParent
(
)
)
{
InitializeSelectionAncestorLimit
(
*
selectionRootContent
)
;
}
else
{
SelectionRefPtr
(
)
-
>
SetAncestorLimiter
(
nullptr
)
;
}
if
(
mComposition
&
&
mComposition
-
>
IsMovingToNewTextNode
(
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfFirstRange
(
firstRange
-
>
StartRef
(
)
)
;
EditorRawDOMPoint
betterInsertionPoint
=
FindBetterInsertionPoint
(
atStartOfFirstRange
)
;
Text
*
textNode
=
betterInsertionPoint
.
GetContainerAsText
(
)
;
MOZ_ASSERT
(
textNode
"
There
must
be
text
node
if
composition
string
is
not
empty
"
)
;
if
(
textNode
)
{
MOZ_ASSERT
(
textNode
-
>
Length
(
)
>
=
mComposition
-
>
XPEndOffsetInTextNode
(
)
"
The
text
node
must
be
different
from
the
old
text
node
"
)
;
CompositionTransaction
:
:
SetIMESelection
(
*
this
textNode
mComposition
-
>
XPOffsetInTextNode
(
)
mComposition
-
>
XPLengthInTextNode
(
)
mComposition
-
>
GetRanges
(
)
)
;
}
}
return
NS_OK
;
}
class
RepaintSelectionRunner
final
:
public
Runnable
{
public
:
explicit
RepaintSelectionRunner
(
nsISelectionController
*
aSelectionController
)
:
Runnable
(
"
RepaintSelectionRunner
"
)
mSelectionController
(
aSelectionController
)
{
}
NS_IMETHOD
Run
(
)
override
{
mSelectionController
-
>
RepaintSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsISelectionController
>
mSelectionController
;
}
;
nsresult
EditorBase
:
:
FinalizeSelection
(
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
SelectionRefPtr
(
)
-
>
SetAncestorLimiter
(
nullptr
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_NOT_INITIALIZED
)
;
if
(
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
)
{
caret
-
>
SetIgnoreUserModify
(
true
)
;
}
selectionController
-
>
SetCaretEnabled
(
false
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
NS_ERROR_NOT_INITIALIZED
)
;
fm
-
>
UpdateCaretForCaretBrowsingMode
(
)
;
if
(
!
HasIndependentSelection
(
)
)
{
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
ErrorResult
ret
;
if
(
!
doc
|
|
!
doc
-
>
HasFocus
(
ret
)
)
{
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
}
else
{
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
}
}
else
if
(
IsFormWidget
(
)
|
|
IsPasswordEditor
(
)
|
|
IsReadonly
(
)
|
|
IsDisabled
(
)
|
|
IsInputFiltered
(
)
)
{
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
}
else
{
selectionController
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
}
nsContentUtils
:
:
AddScriptRunner
(
new
RepaintSelectionRunner
(
selectionController
)
)
;
return
NS_OK
;
}
void
EditorBase
:
:
ReinitializeSelection
(
Element
&
aElement
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
OnFocus
(
&
aElement
)
;
SyncRealTimeSpell
(
)
;
nsPresContext
*
context
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
context
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContentForIME
(
)
;
IMEStateManager
:
:
OnFocusInEditor
(
context
focusedContent
*
this
)
;
}
Element
*
EditorBase
:
:
GetEditorRoot
(
)
const
{
return
GetRoot
(
)
;
}
Element
*
EditorBase
:
:
GetExposedRoot
(
)
const
{
Element
*
rootElement
=
GetRoot
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
rootElement
=
rootElement
-
>
GetParent
(
)
-
>
AsElement
(
)
;
}
return
rootElement
;
}
nsresult
EditorBase
:
:
DetermineCurrentDirection
(
)
{
nsIContent
*
rootElement
=
GetExposedRoot
(
)
;
NS_ENSURE_TRUE
(
rootElement
NS_ERROR_FAILURE
)
;
if
(
!
IsRightToLeft
(
)
&
&
!
IsLeftToRight
(
)
)
{
nsIFrame
*
frame
=
rootElement
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
if
(
frame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
)
{
mFlags
|
=
nsIPlaintextEditor
:
:
eEditorRightToLeft
;
}
else
{
mFlags
|
=
nsIPlaintextEditor
:
:
eEditorLeftToRight
;
}
}
return
NS_OK
;
}
nsresult
EditorBase
:
:
ToggleTextDirection
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetTextDirection
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
DetermineCurrentDirection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsRightToLeft
(
)
)
{
nsresult
rv
=
SetTextDirectionTo
(
TextDirection
:
:
eLTR
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
IsLeftToRight
(
)
)
{
nsresult
rv
=
SetTextDirectionTo
(
TextDirection
:
:
eRTL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
FireInputEvent
(
)
;
return
NS_OK
;
}
void
EditorBase
:
:
SwitchTextDirectionTo
(
TextDirection
aTextDirection
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetTextDirection
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
nsresult
rv
=
DetermineCurrentDirection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
aTextDirection
=
=
TextDirection
:
:
eLTR
&
&
IsRightToLeft
(
)
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
SetTextDirectionTo
(
aTextDirection
)
)
)
)
{
return
;
}
}
else
if
(
aTextDirection
=
=
TextDirection
:
:
eRTL
&
&
IsLeftToRight
(
)
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
SetTextDirectionTo
(
aTextDirection
)
)
)
)
{
return
;
}
}
FireInputEvent
(
)
;
}
nsresult
EditorBase
:
:
SetTextDirectionTo
(
TextDirection
aTextDirection
)
{
Element
*
rootElement
=
GetExposedRoot
(
)
;
if
(
aTextDirection
=
=
TextDirection
:
:
eLTR
)
{
NS_ASSERTION
(
!
IsLeftToRight
(
)
"
Unexpected
mutually
exclusive
flag
"
)
;
mFlags
&
=
~
nsIPlaintextEditor
:
:
eEditorRightToLeft
;
mFlags
|
=
nsIPlaintextEditor
:
:
eEditorLeftToRight
;
nsresult
rv
=
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
NS_LITERAL_STRING
(
"
ltr
"
)
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aTextDirection
=
=
TextDirection
:
:
eRTL
)
{
NS_ASSERTION
(
!
IsRightToLeft
(
)
"
Unexpected
mutually
exclusive
flag
"
)
;
mFlags
|
=
nsIPlaintextEditor
:
:
eEditorRightToLeft
;
mFlags
&
=
~
nsIPlaintextEditor
:
:
eEditorLeftToRight
;
nsresult
rv
=
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
NS_LITERAL_STRING
(
"
rtl
"
)
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
return
NS_OK
;
}
bool
EditorBase
:
:
IsModifiableNode
(
const
nsINode
&
aNode
)
const
{
return
!
AsHTMLEditor
(
)
|
|
aNode
.
IsEditable
(
)
;
}
nsIContent
*
EditorBase
:
:
GetFocusedContent
(
)
{
EventTarget
*
piTarget
=
GetDOMEventTarget
(
)
;
if
(
!
piTarget
)
{
return
nullptr
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
nullptr
)
;
nsIContent
*
content
=
fm
-
>
GetFocusedElement
(
)
;
MOZ_ASSERT
(
(
content
=
=
piTarget
)
=
=
SameCOMIdentity
(
content
piTarget
)
)
;
return
(
content
=
=
piTarget
)
?
content
:
nullptr
;
}
already_AddRefed
<
nsIContent
>
EditorBase
:
:
GetFocusedContentForIME
(
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetFocusedContent
(
)
;
return
content
.
forget
(
)
;
}
bool
EditorBase
:
:
IsActiveInDOMWindow
(
)
{
EventTarget
*
piTarget
=
GetDOMEventTarget
(
)
;
if
(
!
piTarget
)
{
return
false
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
return
SameCOMIdentity
(
content
piTarget
)
;
}
bool
EditorBase
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
NS_WARN_IF
(
!
aGUIEvent
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
{
nsIContent
*
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
false
;
}
}
bool
needsWidget
=
false
;
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eUnidentifiedEvent
:
return
false
;
case
eCompositionStart
:
case
eCompositionEnd
:
case
eCompositionUpdate
:
case
eCompositionChange
:
case
eCompositionCommitAsIs
:
if
(
!
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
false
;
}
needsWidget
=
true
;
break
;
default
:
break
;
}
if
(
needsWidget
&
&
!
aGUIEvent
-
>
mWidget
)
{
return
false
;
}
if
(
aGUIEvent
-
>
IsTrusted
(
)
)
{
return
true
;
}
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
void
EditorBase
:
:
OnFocus
(
EventTarget
*
aFocusEventTarget
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
InitializeSelection
(
aFocusEventTarget
)
;
mSpellCheckerDictionaryUpdated
=
false
;
if
(
mInlineSpellChecker
&
&
CanEnableSpellCheck
(
)
)
{
mInlineSpellChecker
-
>
UpdateCurrentDictionary
(
)
;
mSpellCheckerDictionaryUpdated
=
true
;
}
}
int32_t
EditorBase
:
:
GetIMESelectionStartOffsetIn
(
nsINode
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
"
aTextNode
must
not
be
nullptr
"
)
;
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
-
1
;
}
uint32_t
minOffset
=
UINT32_MAX
;
static
const
SelectionType
kIMESelectionTypes
[
]
=
{
SelectionType
:
:
eIMERawClause
SelectionType
:
:
eIMESelectedRawClause
SelectionType
:
:
eIMEConvertedClause
SelectionType
:
:
eIMESelectedClause
}
;
for
(
auto
selectionType
:
kIMESelectionTypes
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
selectionType
)
;
if
(
!
selection
)
{
continue
;
}
for
(
uint32_t
i
=
0
;
i
<
selection
-
>
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
continue
;
}
if
(
NS_WARN_IF
(
range
-
>
GetStartContainer
(
)
!
=
aTextNode
)
)
{
}
else
{
minOffset
=
std
:
:
min
(
minOffset
range
-
>
StartOffset
(
)
)
;
}
if
(
NS_WARN_IF
(
range
-
>
GetEndContainer
(
)
!
=
aTextNode
)
)
{
}
else
{
minOffset
=
std
:
:
min
(
minOffset
range
-
>
EndOffset
(
)
)
;
}
}
}
return
minOffset
<
INT32_MAX
?
minOffset
:
-
1
;
}
void
EditorBase
:
:
HideCaret
(
bool
aHide
)
{
if
(
mHidingCaret
=
=
aHide
)
{
return
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE_VOID
(
presShell
)
;
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
NS_ENSURE_TRUE_VOID
(
caret
)
;
mHidingCaret
=
aHide
;
if
(
aHide
)
{
caret
-
>
AddForceHide
(
)
;
}
else
{
caret
-
>
RemoveForceHide
(
)
;
}
}
EditorBase
:
:
AutoSelectionRestorer
:
:
AutoSelectionRestorer
(
EditorBase
&
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
mEditorBase
(
nullptr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
aEditorBase
.
ArePreservingSelection
(
)
)
{
return
;
}
MOZ_ASSERT
(
aEditorBase
.
IsEditActionDataAvailable
(
)
)
;
mEditorBase
=
&
aEditorBase
;
mEditorBase
-
>
PreserveSelectionAcrossActions
(
)
;
}
EditorBase
:
:
AutoSelectionRestorer
:
:
~
AutoSelectionRestorer
(
)
{
if
(
mEditorBase
&
&
mEditorBase
-
>
ArePreservingSelection
(
)
)
{
mEditorBase
-
>
RestorePreservedSelection
(
)
;
}
}
void
EditorBase
:
:
AutoSelectionRestorer
:
:
Abort
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
StopPreservingSelection
(
)
;
}
}
EditorBase
:
:
AutoEditActionDataSetter
:
:
AutoEditActionDataSetter
(
const
EditorBase
&
aEditorBase
EditAction
aEditAction
)
:
mEditorBase
(
const_cast
<
EditorBase
&
>
(
aEditorBase
)
)
mParentData
(
aEditorBase
.
mEditActionData
)
mTopLevelEditSubAction
(
EditSubAction
:
:
eNone
)
{
if
(
mParentData
)
{
mSelection
=
mParentData
-
>
mSelection
;
if
(
aEditAction
!
=
EditAction
:
:
eNotEditing
)
{
mEditAction
=
aEditAction
;
}
mTopLevelEditSubAction
=
mParentData
-
>
mTopLevelEditSubAction
;
mDirectionOfTopLevelEditSubAction
=
mParentData
-
>
mDirectionOfTopLevelEditSubAction
;
}
else
{
mSelection
=
mEditorBase
.
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
;
}
mEditAction
=
aEditAction
;
mDirectionOfTopLevelEditSubAction
=
eNone
;
}
mEditorBase
.
mEditActionData
=
this
;
}
EditorBase
:
:
AutoEditActionDataSetter
:
:
~
AutoEditActionDataSetter
(
)
{
if
(
!
mSelection
|
|
NS_WARN_IF
(
mEditorBase
.
mEditActionData
!
=
this
)
)
{
return
;
}
mEditorBase
.
mEditActionData
=
mParentData
;
}
}
