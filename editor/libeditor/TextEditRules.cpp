#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
HTMLEditRules
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
\
*
aCancel
=
true
;
\
return
NS_OK
;
\
}
#
define
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY_OF_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
\
return
EditActionCanceled
(
NS_OK
)
;
\
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TextEditRules
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TextEditRules
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mBogusNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCachedSelectionNode
)
if
(
HTMLEditRules
*
htmlEditRules
=
tmp
-
>
AsHTMLEditRules
(
)
)
{
HTMLEditRules
*
tmp
=
htmlEditRules
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocChangeRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUtilRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNewBlock
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRangeItem
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TextEditRules
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBogusNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCachedSelectionNode
)
if
(
HTMLEditRules
*
htmlEditRules
=
tmp
-
>
AsHTMLEditRules
(
)
)
{
HTMLEditRules
*
tmp
=
htmlEditRules
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocChangeRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUtilRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNewBlock
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRangeItem
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
TextEditRules
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
TextEditRules
Release
)
TextEditRules
:
:
TextEditRules
(
)
:
mTextEditor
(
nullptr
)
mData
(
nullptr
)
mCachedSelectionOffset
(
0
)
mActionNesting
(
0
)
mLockRulesSniffing
(
false
)
mDidExplicitlySetInterline
(
false
)
mDeleteBidiImmediately
(
false
)
mIsHTMLEditRules
(
false
)
mTopLevelEditSubAction
(
EditSubAction
:
:
eNone
)
{
InitFields
(
)
;
}
void
TextEditRules
:
:
InitFields
(
)
{
mTextEditor
=
nullptr
;
mBogusNode
=
nullptr
;
mCachedSelectionNode
=
nullptr
;
mCachedSelectionOffset
=
0
;
mActionNesting
=
0
;
mLockRulesSniffing
=
false
;
mDidExplicitlySetInterline
=
false
;
mDeleteBidiImmediately
=
false
;
mTopLevelEditSubAction
=
EditSubAction
:
:
eNone
;
}
HTMLEditRules
*
TextEditRules
:
:
AsHTMLEditRules
(
)
{
return
mIsHTMLEditRules
?
static_cast
<
HTMLEditRules
*
>
(
this
)
:
nullptr
;
}
const
HTMLEditRules
*
TextEditRules
:
:
AsHTMLEditRules
(
)
const
{
return
mIsHTMLEditRules
?
static_cast
<
const
HTMLEditRules
*
>
(
this
)
:
nullptr
;
}
nsresult
TextEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
Selection
*
selection
=
aTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
InitFields
(
)
;
mTextEditor
=
aTextEditor
;
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
nsresult
rv
=
CreateBogusNodeIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
rv
=
TextEditorRef
(
)
.
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsPlaintextEditor
(
)
)
{
rv
=
CreateTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mDeleteBidiImmediately
=
Preferences
:
:
GetBool
(
"
bidi
.
edit
.
delete_immediately
"
false
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DetachEditor
(
)
{
mTextEditor
=
nullptr
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
BeforeEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mTopLevelEditSubAction
=
aEditSubAction
;
}
mActionNesting
+
+
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eSetText
)
{
mCachedSelectionNode
=
mTextEditor
-
>
GetRoot
(
)
;
mCachedSelectionOffset
=
0
;
}
else
{
Selection
*
selection
=
mTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
mCachedSelectionNode
=
selection
-
>
GetAnchorNode
(
)
;
mCachedSelectionOffset
=
selection
-
>
AnchorOffset
(
)
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
AfterEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
MOZ_ASSERT
(
mActionNesting
>
0
"
bad
action
nesting
!
"
)
;
if
(
!
-
-
mActionNesting
)
{
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
nsresult
rv
=
TextEditorRef
(
)
.
HandleInlineSpellCheck
(
aEditSubAction
mCachedSelectionNode
mCachedSelectionOffset
nullptr
0
nullptr
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mCachedSelectionNode
=
nullptr
;
rv
=
RemoveRedundantTrailingBR
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CreateBogusNodeIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CreateTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CollapseSelectionToTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
selection
to
after
the
text
node
in
TextEditor
"
)
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDoAction
(
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertLineBreak
:
{
UndefineCaretBidiLevel
(
)
;
EditActionResult
result
=
WillInsertLineBreak
(
aInfo
.
maxLength
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
*
aCancel
=
result
.
Canceled
(
)
;
*
aHandled
=
result
.
Handled
(
)
;
MOZ_ASSERT
(
!
result
.
Ignored
(
)
)
;
return
NS_OK
;
}
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
UndefineCaretBidiLevel
(
)
;
return
WillInsertText
(
aInfo
.
mEditSubAction
aCancel
aHandled
aInfo
.
inString
aInfo
.
outString
aInfo
.
maxLength
)
;
case
EditSubAction
:
:
eSetText
:
UndefineCaretBidiLevel
(
)
;
return
WillSetText
(
aCancel
aHandled
aInfo
.
inString
aInfo
.
maxLength
)
;
case
EditSubAction
:
:
eDeleteSelectedContent
:
return
WillDeleteSelection
(
aInfo
.
collapsedAction
aCancel
aHandled
)
;
case
EditSubAction
:
:
eUndo
:
return
WillUndo
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eRedo
:
return
WillRedo
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eSetTextProperty
:
return
WillSetTextProperty
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eRemoveTextProperty
:
return
WillRemoveTextProperty
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eComputeTextToOutput
:
return
WillOutputText
(
aInfo
.
outputFormat
aInfo
.
outString
aInfo
.
flags
aCancel
aHandled
)
;
case
EditSubAction
:
:
eInsertElement
:
return
WillInsert
(
aCancel
)
;
default
:
return
NS_ERROR_FAILURE
;
}
}
nsresult
TextEditRules
:
:
DidDoAction
(
EditSubActionInfo
&
aInfo
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
return
DidDeleteSelection
(
)
;
case
EditSubAction
:
:
eUndo
:
return
DidUndo
(
aResult
)
;
case
EditSubAction
:
:
eRedo
:
return
DidRedo
(
aResult
)
;
default
:
return
NS_OK
;
}
}
bool
TextEditRules
:
:
DocumentIsEmpty
(
)
{
bool
retVal
=
false
;
if
(
!
mTextEditor
|
|
NS_FAILED
(
mTextEditor
-
>
IsEmpty
(
&
retVal
)
)
)
{
retVal
=
true
;
}
return
retVal
;
}
nsresult
TextEditRules
:
:
WillInsert
(
bool
*
aCancel
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
if
(
aCancel
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
if
(
aCancel
)
{
*
aCancel
=
false
;
}
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
TextEditorRef
(
)
.
MaskAllCharacters
(
)
;
}
if
(
!
mBogusNode
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
bogusNode
(
std
:
:
move
(
mBogusNode
)
)
;
DebugOnly
<
nsresult
>
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteNodeWithTransaction
(
*
bogusNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
bogus
node
"
)
;
return
NS_OK
;
}
EditActionResult
TextEditRules
:
:
WillInsertLineBreak
(
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY_OF_DISABLED
NS_NAMED_LITERAL_STRING
(
inString
"
\
n
"
)
;
nsAutoString
outString
;
bool
didTruncate
;
nsresult
rv
=
TruncateInsertionIfNeeded
(
&
inString
.
AsString
(
)
&
outString
aMaxLength
&
didTruncate
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
didTruncate
)
{
return
EditActionCanceled
(
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
&
&
!
TextEditorRef
(
)
.
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Document
>
doc
=
TextEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
EditorRawDOMPoint
pointAfterInsertedLineBreak
;
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertTextWithTransaction
(
*
doc
NS_LITERAL_STRING
(
"
\
n
"
)
pointToInsert
&
pointAfterInsertedLineBreak
)
;
if
(
NS_WARN_IF
(
!
pointAfterInsertedLineBreak
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
!
pointAfterInsertedLineBreak
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterInsertedLineBreak
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterInsertedLineBreak
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
EditorRawDOMPoint
endPoint
(
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
endPoint
=
=
pointAfterInsertedLineBreak
)
{
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
TextEditRules
:
:
CollapseSelectionToTrailingBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
TextEditorRef
(
)
.
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
selectionStartPoint
.
IsInTextNode
(
)
|
|
!
selectionStartPoint
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
parentNode
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
if
(
parentNode
!
=
rootElement
)
{
return
NS_OK
;
}
nsINode
*
nextNode
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetNextSibling
(
)
;
if
(
!
nextNode
|
|
!
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
afterStartContainer
(
selectionStartPoint
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
afterStartContainer
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterStartContainer
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
TextEditRules
:
:
GetTextNodeAroundSelectionStartContainer
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
if
(
selectionStartPoint
.
IsInTextNode
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
selectionStartPoint
.
GetContainer
(
)
;
return
node
.
forget
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
selectionStartPoint
.
GetContainer
(
)
;
RefPtr
<
NodeIterator
>
iter
=
new
NodeIterator
(
node
NodeFilter_Binding
:
:
SHOW_TEXT
nullptr
)
;
while
(
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
node
=
iter
-
>
NextNode
(
IgnoreErrors
(
)
)
;
if
(
!
node
)
{
return
nullptr
;
}
}
return
node
.
forget
(
)
;
}
void
TextEditRules
:
:
HandleNewLines
(
nsString
&
aString
)
{
static
const
char16_t
kLF
=
static_cast
<
char16_t
>
(
'
\
n
'
)
;
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aString
.
FindChar
(
static_cast
<
uint16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
int32_t
firstLF
=
aString
.
FindChar
(
kLF
0
)
;
if
(
firstLF
=
=
kNotFound
)
{
return
;
}
switch
(
TextEditorRef
(
)
.
mNewlineHandling
)
{
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
LFSTR
false
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStrip
:
aString
.
StripChar
(
kLF
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
offset
=
0
;
while
(
firstLF
=
=
offset
)
{
offset
+
+
;
firstLF
=
aString
.
FindChar
(
kLF
offset
)
;
}
if
(
firstLF
>
0
)
{
aString
.
Truncate
(
firstLF
)
;
}
if
(
offset
>
0
)
{
aString
.
Cut
(
0
offset
)
;
}
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
LFSTR
true
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsAutoString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextLF
=
!
offset
?
firstLF
:
aString
.
FindChar
(
kLF
offset
)
;
if
(
nextLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
{
-
-
wsBegin
;
}
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
{
+
+
offset
;
}
}
aString
=
result
;
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
LFSTR
true
true
)
;
break
;
}
}
nsresult
TextEditRules
:
:
WillInsertText
(
EditSubAction
aEditSubAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
inString
-
>
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
*
aCancel
=
true
;
*
aHandled
=
false
;
return
NS_OK
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
bool
truncated
=
false
;
nsresult
rv
=
TruncateInsertionIfNeeded
(
inString
outString
aMaxLength
&
truncated
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
truncated
&
&
outString
-
>
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
uint32_t
start
=
0
;
if
(
IsPasswordEditor
(
)
)
{
if
(
TextEditorRef
(
)
.
GetComposition
(
)
&
&
!
TextEditorRef
(
)
.
GetComposition
(
)
-
>
String
(
)
.
IsEmpty
(
)
)
{
start
=
TextEditorRef
(
)
.
GetComposition
(
)
-
>
XPOffsetInTextNode
(
)
;
}
else
{
uint32_t
end
=
0
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
TextEditorRef
(
)
.
GetRoot
(
)
start
end
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
WillInsert
(
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsSingleLineEditor
(
)
)
{
nsAutoString
tString
(
*
outString
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
tString
)
;
HandleNewLines
(
tString
)
;
outString
-
>
Assign
(
tString
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
IsInTextNode
(
)
&
&
!
TextEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Document
>
doc
=
TextEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
TextEditorRef
(
)
.
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
TextEditorRef
(
)
.
FindBetterInsertionPoint
(
atStartOfSelection
)
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertTextWithTransaction
(
*
doc
*
outString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
EditorRawDOMPoint
pointAfterStringInserted
;
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertTextWithTransaction
(
*
doc
*
outString
atStartOfSelection
&
pointAfterStringInserted
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
pointAfterStringInserted
.
IsSet
(
)
)
{
bool
endsWithLF
=
!
outString
-
>
IsEmpty
(
)
&
&
outString
-
>
Last
(
)
=
=
nsCRT
:
:
LF
;
IgnoredErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
endsWithLF
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
or
unset
interline
position
"
)
;
MOZ_ASSERT
(
!
pointAfterStringInserted
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterStringInserted
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
error
=
IgnoredErrorResult
(
)
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterStringInserted
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
inserting
string
"
)
;
}
}
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
&
&
!
DontEchoPassword
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
SetUnmaskRangeAndNotify
(
start
outString
-
>
Length
(
)
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillSetText
(
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
MOZ_ASSERT
(
aString
)
;
MOZ_ASSERT
(
aString
-
>
FindChar
(
static_cast
<
char16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aHandled
=
false
;
*
aCancel
=
false
;
if
(
!
IsPlaintextEditor
(
)
|
|
TextEditorRef
(
)
.
IsIMEComposing
(
)
|
|
TextEditorRef
(
)
.
IsUndoRedoEnabled
(
)
|
|
TextEditorRef
(
)
.
GetEditAction
(
)
=
=
EditAction
:
:
eReplaceText
|
|
aMaxLength
!
=
-
1
)
{
return
NS_OK
;
}
nsresult
rv
=
WillInsert
(
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
Element
>
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
nsIContent
*
firstChild
=
rootElement
-
>
GetFirstChild
(
)
;
if
(
IsSingleLineEditor
(
)
)
{
if
(
firstChild
&
&
(
!
EditorBase
:
:
IsTextNode
(
firstChild
)
|
|
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
NS_OK
;
}
}
else
{
if
(
!
firstChild
)
{
return
NS_OK
;
}
if
(
EditorBase
:
:
IsTextNode
(
firstChild
)
)
{
if
(
!
firstChild
-
>
GetNextSibling
(
)
|
|
!
TextEditUtils
:
:
IsMozBR
(
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
NS_OK
;
}
}
else
if
(
!
TextEditUtils
:
:
IsMozBR
(
firstChild
)
)
{
return
NS_OK
;
}
}
nsAutoString
tString
(
*
aString
)
;
if
(
IsSingleLineEditor
(
)
&
&
!
IsPasswordEditor
(
)
)
{
HandleNewLines
(
tString
)
;
}
if
(
!
firstChild
|
|
!
EditorBase
:
:
IsTextNode
(
firstChild
)
)
{
if
(
tString
.
IsEmpty
(
)
)
{
*
aHandled
=
true
;
return
NS_OK
;
}
RefPtr
<
Document
>
doc
=
TextEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_OK
;
}
RefPtr
<
nsTextNode
>
newNode
=
EditorBase
:
:
CreateTextNode
(
*
doc
tString
)
;
if
(
NS_WARN_IF
(
!
newNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertNodeWithTransaction
(
*
newNode
EditorDOMPoint
(
rootElement
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
RefPtr
<
Text
>
textNode
=
firstChild
-
>
GetAsText
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textNode
)
)
)
{
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
SetTextImpl
(
tString
*
textNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
tString
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
DidDeleteSelection
(
)
;
MOZ_ASSERT
(
rvIgnored
!
=
NS_ERROR_EDITOR_DESTROYED
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
DidDeleteSelection
(
)
failed
"
)
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillSetTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillRemoveTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDeleteSelection
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsresult
rv
=
DeleteSelectionWithTransaction
(
aCollapsedAction
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DeleteSelectionWithTransaction
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
SelectionBatcher
selectionBatcher
(
SelectionRefPtr
(
)
)
;
AutoHideSelectionChanges
hideSelection
(
SelectionRefPtr
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
TextEditorRef
(
)
.
MaskAllCharacters
(
)
;
}
else
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
CheckBidiLevelForDeletion
(
selectionStartPoint
aCollapsedAction
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aCancel
)
{
return
NS_OK
;
}
}
nsresult
rv
=
TextEditorRef
(
)
.
ExtendSelectionForDelete
(
&
aCollapsedAction
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteSelectionWithTransaction
(
aCollapsedAction
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidDeleteSelection
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selectionStartPoint
.
IsInTextNode
(
)
&
&
!
selectionStartPoint
.
GetContainer
(
)
-
>
Length
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
selectionStartPoint
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
mDidExplicitlySetInterline
)
{
return
NS_OK
;
}
ErrorResult
err
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
err
)
;
NS_WARNING_ASSERTION
(
!
err
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
return
err
.
StealNSResult
(
)
;
}
nsresult
TextEditRules
:
:
WillUndo
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidUndo
(
nsresult
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
)
)
)
{
return
aResult
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
node
=
TextEditorRef
(
)
.
GetLeftmostChild
(
rootElement
)
;
if
(
node
&
&
TextEditorRef
(
)
.
IsMozEditorBogusNode
(
node
)
)
{
mBogusNode
=
node
;
}
else
{
mBogusNode
=
nullptr
;
}
return
aResult
;
}
nsresult
TextEditRules
:
:
WillRedo
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidRedo
(
nsresult
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_FAILED
(
aResult
)
)
{
return
aResult
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIHTMLCollection
>
nodeList
=
rootElement
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
br
"
)
)
;
MOZ_ASSERT
(
nodeList
)
;
uint32_t
len
=
nodeList
-
>
Length
(
)
;
if
(
len
!
=
1
)
{
mBogusNode
=
nullptr
;
return
NS_OK
;
}
Element
*
brElement
=
nodeList
-
>
Item
(
0
)
;
if
(
TextEditorRef
(
)
.
IsMozEditorBogusNode
(
brElement
)
)
{
mBogusNode
=
brElement
;
}
else
{
mBogusNode
=
nullptr
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillOutputText
(
const
nsAString
*
aOutputFormat
nsAString
*
aOutString
uint32_t
aFlags
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aOutString
)
|
|
NS_WARN_IF
(
!
aOutputFormat
)
|
|
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
!
aOutputFormat
-
>
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
)
{
return
NS_OK
;
}
if
(
mBogusNode
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputSelectionOnly
|
|
aFlags
&
nsIDocumentEncoder
:
:
OutputWrap
)
{
return
NS_OK
;
}
if
(
TextEditorRef
(
)
.
AsHTMLEditor
(
)
)
{
return
NS_OK
;
}
Element
*
root
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
!
root
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsIContent
*
firstChild
=
root
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
Text
*
text
=
firstChild
-
>
GetAsText
(
)
;
nsIContent
*
firstChildExceptText
=
text
?
firstChild
-
>
GetNextSibling
(
)
:
firstChild
;
bool
isInput
=
IsSingleLineEditor
(
)
;
bool
isTextarea
=
!
isInput
;
if
(
NS_WARN_IF
(
isInput
&
&
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
TextEditUtils
:
:
IsMozBR
(
firstChildExceptText
)
&
&
!
firstChildExceptText
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollbar
)
)
)
{
return
NS_OK
;
}
if
(
!
text
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
text
-
>
GetData
(
*
aOutString
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
RemoveRedundantTrailingBR
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
mBogusNode
)
{
return
NS_OK
;
}
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
uint32_t
childCount
=
rootElement
-
>
GetChildCount
(
)
;
if
(
childCount
>
1
)
{
return
NS_OK
;
}
RefPtr
<
nsIContent
>
child
=
rootElement
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
!
child
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
childElement
=
child
-
>
AsElement
(
)
;
if
(
!
TextEditUtils
:
:
IsMozBR
(
childElement
)
)
{
return
NS_OK
;
}
childElement
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
true
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
mBogusNode
=
childElement
;
childElement
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateTrailingBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
lastChild
=
rootElement
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
EditorDOMPoint
endOfRoot
;
endOfRoot
.
SetToEndOf
(
rootElement
)
;
CreateElementResult
createMozBrResult
=
CreateMozBR
(
endOfRoot
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
return
NS_OK
;
}
if
(
!
TextEditorRef
(
)
.
IsMozEditorBogusNode
(
lastChild
)
)
{
return
NS_OK
;
}
lastChild
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
false
)
;
lastChild
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
true
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateBogusNodeIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
mBogusNode
)
{
return
NS_OK
;
}
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
TextEditorRef
(
)
EditSubAction
:
:
eCreateBogusNode
nsIEditor
:
:
eNone
)
;
RefPtr
<
Element
>
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
NS_OK
;
}
bool
isRootEditable
=
TextEditorRef
(
)
.
IsEditable
(
rootElement
)
;
for
(
nsIContent
*
rootChild
=
rootElement
-
>
GetFirstChild
(
)
;
rootChild
;
rootChild
=
rootChild
-
>
GetNextSibling
(
)
)
{
if
(
TextEditorRef
(
)
.
IsMozEditorBogusNode
(
rootChild
)
|
|
!
isRootEditable
|
|
TextEditorRef
(
)
.
IsEditable
(
rootChild
)
|
|
TextEditorRef
(
)
.
IsBlockNode
(
rootChild
)
)
{
return
NS_OK
;
}
}
if
(
!
TextEditorRef
(
)
.
IsModifiableNode
(
*
rootElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
newBrElement
=
TextEditorRef
(
)
.
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBrElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mBogusNode
=
newBrElement
;
newBrElement
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
if
(
NS_WARN_IF
(
mBogusNode
!
=
newBrElement
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertNodeWithTransaction
(
*
newBrElement
EditorDOMPoint
(
rootElement
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
IgnoredErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
rootElement
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
start
of
the
root
element
"
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
TruncateInsertionIfNeeded
(
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aInString
)
|
|
NS_WARN_IF
(
!
aOutString
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aOutString
-
>
Assign
(
*
aInString
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
aTruncated
)
{
*
aTruncated
=
false
;
}
if
(
-
1
!
=
aMaxLength
&
&
IsPlaintextEditor
(
)
&
&
!
TextEditorRef
(
)
.
IsIMEComposing
(
)
)
{
int32_t
docLength
;
nsresult
rv
=
TextEditorRef
(
)
.
GetTextLength
(
&
docLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
TextEditorRef
(
)
.
GetRoot
(
)
start
end
)
;
TextComposition
*
composition
=
TextEditorRef
(
)
.
GetComposition
(
)
;
uint32_t
oldCompStrLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
uint32_t
selectionLength
=
end
-
start
;
const
int32_t
resultingDocLength
=
docLength
-
selectionLength
-
oldCompStrLength
;
if
(
resultingDocLength
>
=
aMaxLength
)
{
aOutString
-
>
Truncate
(
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
else
{
int32_t
oldLength
=
aOutString
-
>
Length
(
)
;
if
(
oldLength
+
resultingDocLength
>
aMaxLength
)
{
int32_t
newLength
=
aMaxLength
-
resultingDocLength
;
MOZ_ASSERT
(
newLength
>
0
)
;
char16_t
newLastChar
=
aOutString
-
>
CharAt
(
newLength
-
1
)
;
char16_t
removingFirstChar
=
aOutString
-
>
CharAt
(
newLength
)
;
if
(
NS_IS_HIGH_SURROGATE
(
newLastChar
)
&
&
NS_IS_LOW_SURROGATE
(
removingFirstChar
)
)
{
newLength
-
-
;
}
aOutString
-
>
Truncate
(
newLength
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
}
}
return
NS_OK
;
}
CreateElementResult
TextEditRules
:
:
CreateBRInternal
(
const
EditorDOMPoint
&
aPointToInsert
bool
aCreateMozBR
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
brElement
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertBrElementWithTransaction
(
aPointToInsert
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aCreateMozBR
)
{
return
CreateElementResult
(
brElement
.
forget
(
)
)
;
}
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
SetAttributeWithTransaction
(
*
brElement
*
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
return
CreateElementResult
(
brElement
.
forget
(
)
)
;
}
bool
TextEditRules
:
:
IsPasswordEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPasswordEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMaskingPassword
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mTextEditor
?
mTextEditor
-
>
IsMaskingPassword
(
)
:
true
;
}
bool
TextEditRules
:
:
IsSingleLineEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsSingleLineEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsPlaintextEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPlaintextEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsReadonly
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsReadonly
(
)
:
false
;
}
bool
TextEditRules
:
:
IsDisabled
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsDisabled
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMailEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsMailEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
DontEchoPassword
(
)
const
{
if
(
!
mTextEditor
)
{
return
false
;
}
if
(
!
LookAndFeel
:
:
GetEchoPassword
(
)
|
|
mTextEditor
-
>
DontEchoPassword
(
)
)
{
return
true
;
}
if
(
mTextEditor
-
>
GetEditAction
(
)
!
=
EditAction
:
:
eDrop
&
&
mTextEditor
-
>
GetEditAction
(
)
!
=
EditAction
:
:
ePaste
)
{
return
false
;
}
return
true
;
}
}
