#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMNodeFilter
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
\
{
\
*
aCancel
=
true
;
\
return
NS_OK
;
\
}
;
TextEditRules
:
:
TextEditRules
(
)
:
mTextEditor
(
nullptr
)
mPasswordIMEIndex
(
0
)
mCachedSelectionOffset
(
0
)
mActionNesting
(
0
)
mLockRulesSniffing
(
false
)
mDidExplicitlySetInterline
(
false
)
mDeleteBidiImmediately
(
false
)
mTheAction
(
EditAction
:
:
none
)
mLastStart
(
0
)
mLastLength
(
0
)
{
InitFields
(
)
;
}
void
TextEditRules
:
:
InitFields
(
)
{
mTextEditor
=
nullptr
;
mPasswordText
.
Truncate
(
)
;
mPasswordIMEText
.
Truncate
(
)
;
mPasswordIMEIndex
=
0
;
mBogusNode
=
nullptr
;
mCachedSelectionNode
=
nullptr
;
mCachedSelectionOffset
=
0
;
mActionNesting
=
0
;
mLockRulesSniffing
=
false
;
mDidExplicitlySetInterline
=
false
;
mDeleteBidiImmediately
=
false
;
mTheAction
=
EditAction
:
:
none
;
mTimer
=
nullptr
;
mLastStart
=
0
;
mLastLength
=
0
;
}
TextEditRules
:
:
~
TextEditRules
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION
(
TextEditRules
mBogusNode
mCachedSelectionNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TextEditRules
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditRules
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditRules
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextEditRules
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextEditRules
)
NS_IMETHODIMP
TextEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
!
aTextEditor
)
{
return
NS_ERROR_NULL_POINTER
;
}
InitFields
(
)
;
mTextEditor
=
aTextEditor
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_WARNING_ASSERTION
(
selection
"
editor
cannot
get
selection
"
)
;
nsresult
rv
=
CreateBogusNodeIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
selection
-
>
RangeCount
(
)
)
{
rv
=
mTextEditor
-
>
CollapseSelectionToEnd
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
IsPlaintextEditor
(
)
)
{
rv
=
CreateTrailingBRIfNeeded
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mDeleteBidiImmediately
=
Preferences
:
:
GetBool
(
"
bidi
.
edit
.
delete_immediately
"
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
SetInitialValue
(
const
nsAString
&
aValue
)
{
if
(
IsPasswordEditor
(
)
)
{
mPasswordText
=
aValue
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
DetachEditor
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
mTextEditor
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
BeforeEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mTheAction
=
action
;
}
mActionNesting
+
+
;
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
RefPtr
<
Selection
>
selection
=
textEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
if
(
action
=
=
EditAction
:
:
setText
)
{
mCachedSelectionNode
=
textEditor
-
>
GetRoot
(
)
;
mCachedSelectionOffset
=
0
;
}
else
{
mCachedSelectionNode
=
selection
-
>
GetAnchorNode
(
)
;
mCachedSelectionOffset
=
selection
-
>
AnchorOffset
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
AfterEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
NS_PRECONDITION
(
mActionNesting
>
0
"
bad
action
nesting
!
"
)
;
if
(
!
-
-
mActionNesting
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
rv
=
mTextEditor
-
>
HandleInlineSpellCheck
(
action
selection
GetAsDOMNode
(
mCachedSelectionNode
)
mCachedSelectionOffset
nullptr
0
nullptr
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCachedSelectionNode
=
nullptr
;
rv
=
RemoveRedundantTrailingBR
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CreateBogusNodeIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateTrailingBRIfNeeded
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CollapseSelectionToTrailingBRIfNeeded
(
selection
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aInfo
&
&
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertBreak
(
aSelection
aCancel
aHandled
info
-
>
maxLength
)
;
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertText
(
info
-
>
action
aSelection
aCancel
aHandled
info
-
>
inString
info
-
>
outString
info
-
>
maxLength
)
;
case
EditAction
:
:
setText
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillSetText
(
*
aSelection
aCancel
aHandled
info
-
>
inString
info
-
>
maxLength
)
;
case
EditAction
:
:
deleteSelection
:
return
WillDeleteSelection
(
aSelection
info
-
>
collapsedAction
aCancel
aHandled
)
;
case
EditAction
:
:
undo
:
return
WillUndo
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
redo
:
return
WillRedo
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
setTextProperty
:
return
WillSetTextProperty
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
removeTextProperty
:
return
WillRemoveTextProperty
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
outputText
:
return
WillOutputText
(
aSelection
info
-
>
outputFormat
info
-
>
outString
info
-
>
flags
aCancel
aHandled
)
;
case
EditAction
:
:
insertElement
:
WillInsert
(
*
aSelection
aCancel
)
;
return
NS_OK
;
default
:
return
NS_ERROR_FAILURE
;
}
}
NS_IMETHODIMP
TextEditRules
:
:
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mTextEditor
)
;
NS_ENSURE_TRUE
(
aSelection
&
&
aInfo
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
return
DidInsertBreak
(
aSelection
aResult
)
;
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
return
DidInsertText
(
aSelection
aResult
)
;
case
EditAction
:
:
setText
:
return
DidSetText
(
*
aSelection
aResult
)
;
case
EditAction
:
:
deleteSelection
:
return
DidDeleteSelection
(
aSelection
info
-
>
collapsedAction
aResult
)
;
case
EditAction
:
:
undo
:
return
DidUndo
(
aSelection
aResult
)
;
case
EditAction
:
:
redo
:
return
DidRedo
(
aSelection
aResult
)
;
case
EditAction
:
:
setTextProperty
:
return
DidSetTextProperty
(
aSelection
aResult
)
;
case
EditAction
:
:
removeTextProperty
:
return
DidRemoveTextProperty
(
aSelection
aResult
)
;
case
EditAction
:
:
outputText
:
return
DidOutputText
(
aSelection
aResult
)
;
default
:
return
NS_OK
;
}
}
NS_IMETHODIMP_
(
bool
)
TextEditRules
:
:
DocumentIsEmpty
(
)
{
bool
retVal
=
false
;
if
(
!
mTextEditor
|
|
NS_FAILED
(
mTextEditor
-
>
DocumentIsEmpty
(
&
retVal
)
)
)
{
retVal
=
true
;
}
return
retVal
;
}
void
TextEditRules
:
:
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
{
MOZ_ASSERT
(
aCancel
)
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
*
aCancel
=
true
;
return
;
}
*
aCancel
=
false
;
if
(
mBogusNode
)
{
NS_ENSURE_TRUE_VOID
(
mTextEditor
)
;
mTextEditor
-
>
DeleteNode
(
mBogusNode
)
;
mBogusNode
=
nullptr
;
}
}
nsresult
TextEditRules
:
:
DidInsert
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillInsertBreak
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
int32_t
aMaxLength
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aHandled
=
false
;
if
(
IsSingleLineEditor
(
)
)
{
*
aCancel
=
true
;
}
else
{
NS_NAMED_LITERAL_STRING
(
inString
"
\
n
"
)
;
nsAutoString
outString
;
bool
didTruncate
;
nsresult
rv
=
TruncateInsertionIfNeeded
(
aSelection
&
inString
.
AsString
(
)
&
outString
aMaxLength
&
didTruncate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
didTruncate
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
*
aCancel
=
false
;
if
(
!
aSelection
-
>
IsCollapsed
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
rv
=
mTextEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CollapseSelectionToTrailingBRIfNeeded
(
Selection
*
aSelection
)
{
if
(
!
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
!
aSelection
-
>
RangeCount
(
)
)
{
mTextEditor
-
>
CollapseSelectionToEnd
(
aSelection
)
;
}
int32_t
selOffset
;
nsCOMPtr
<
nsINode
>
selNode
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
EditorBase
:
:
IsTextNode
(
selNode
)
)
{
return
NS_OK
;
}
if
(
selOffset
!
=
static_cast
<
int32_t
>
(
selNode
-
>
Length
(
)
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
nsINode
*
root
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
parentNode
=
selNode
-
>
GetParentNode
(
)
;
if
(
parentNode
!
=
root
)
{
return
NS_OK
;
}
nsINode
*
nextNode
=
selNode
-
>
GetNextSibling
(
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
EditorRawDOMPoint
afterSelNode
(
selNode
)
;
if
(
NS_WARN_IF
(
!
afterSelNode
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
-
>
Collapse
(
afterSelNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
static
inline
already_AddRefed
<
nsINode
>
GetTextNode
(
Selection
*
selection
)
{
int32_t
selOffset
;
nsCOMPtr
<
nsINode
>
selNode
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
!
EditorBase
:
:
IsTextNode
(
selNode
)
)
{
RefPtr
<
NodeIterator
>
iter
=
new
NodeIterator
(
selNode
nsIDOMNodeFilter
:
:
SHOW_TEXT
NodeFilterHolder
(
)
)
;
while
(
!
EditorBase
:
:
IsTextNode
(
selNode
)
)
{
IgnoredErrorResult
rv
;
selNode
=
iter
-
>
NextNode
(
rv
)
;
if
(
!
selNode
)
{
return
nullptr
;
}
}
}
return
selNode
.
forget
(
)
;
}
#
ifdef
DEBUG
#
define
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
\
if
(
IsPasswordEditor
(
)
&
&
mTextEditor
-
>
GetRoot
(
)
)
{
\
int32_t
txtLen
;
\
mTextEditor
-
>
GetTextLength
(
&
txtLen
)
;
\
NS_ASSERTION
(
mPasswordText
.
Length
(
)
=
=
uint32_t
(
txtLen
)
\
"
password
length
not
equal
to
number
of
asterisks
"
)
;
\
}
#
else
#
define
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
#
endif
void
TextEditRules
:
:
HandleNewLines
(
nsString
&
aString
int32_t
aNewlineHandling
)
{
if
(
aNewlineHandling
<
0
)
{
int32_t
caretStyle
;
TextEditor
:
:
GetDefaultEditorPrefs
(
aNewlineHandling
caretStyle
)
;
}
switch
(
aNewlineHandling
)
{
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
CRLF
false
true
)
;
aString
.
ReplaceChar
(
CRLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStrip
:
aString
.
StripCRLF
(
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
firstCRLF
=
aString
.
FindCharInSet
(
CRLF
)
;
int32_t
offset
=
0
;
while
(
firstCRLF
=
=
offset
)
{
offset
+
+
;
firstCRLF
=
aString
.
FindCharInSet
(
CRLF
offset
)
;
}
if
(
firstCRLF
>
0
)
{
aString
.
Truncate
(
firstCRLF
)
;
}
if
(
offset
>
0
)
{
aString
.
Cut
(
0
offset
)
;
}
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
CRLF
true
true
)
;
aString
.
ReplaceChar
(
CRLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsAutoString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextCRLF
=
aString
.
FindCharInSet
(
CRLF
offset
)
;
if
(
nextCRLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextCRLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
{
-
-
wsBegin
;
}
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextCRLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
{
+
+
offset
;
}
}
aString
=
result
;
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
CRLF
true
true
)
;
break
;
}
}
nsresult
TextEditRules
:
:
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
inString
-
>
IsEmpty
(
)
&
&
aAction
!
=
EditAction
:
:
insertIMEText
)
{
*
aCancel
=
true
;
*
aHandled
=
false
;
return
NS_OK
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
bool
truncated
=
false
;
nsresult
rv
=
TruncateInsertionIfNeeded
(
aSelection
inString
outString
aMaxLength
&
truncated
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
truncated
&
&
outString
-
>
IsEmpty
(
)
&
&
aAction
!
=
EditAction
:
:
insertIMEText
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
uint32_t
start
=
0
;
uint32_t
end
=
0
;
if
(
IsPasswordEditor
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
}
if
(
!
aSelection
-
>
IsCollapsed
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
rv
=
mTextEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
if
(
IsPasswordEditor
(
)
&
&
aAction
=
=
EditAction
:
:
insertIMEText
)
{
RemoveIMETextFromPWBuf
(
start
outString
)
;
}
if
(
IsSingleLineEditor
(
)
)
{
nsAutoString
tString
(
*
outString
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
HandleNewLines
(
tString
mTextEditor
-
>
mNewlineHandling
)
;
outString
-
>
Assign
(
tString
)
;
}
if
(
IsPasswordEditor
(
)
)
{
mPasswordText
.
Insert
(
*
outString
start
)
;
if
(
LookAndFeel
:
:
GetEchoPassword
(
)
&
&
!
DontEchoPassword
(
)
)
{
HideLastPWInput
(
)
;
mLastStart
=
start
;
mLastLength
=
outString
-
>
Length
(
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
else
{
mTimer
=
NS_NewTimer
(
)
;
NS_ENSURE_TRUE
(
mTimer
NS_ERROR_OUT_OF_MEMORY
)
;
}
mTimer
-
>
InitWithCallback
(
this
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
FillBufWithPWChars
(
outString
outString
-
>
Length
(
)
)
;
}
}
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
)
;
EditorRawDOMPoint
atStartOfSelection
(
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
!
EditorBase
:
:
IsTextNode
(
atStartOfSelection
.
Container
(
)
)
&
&
!
mTextEditor
-
>
CanContainTag
(
*
atStartOfSelection
.
Container
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NOT_INITIALIZED
)
;
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
EditorRawDOMPoint
betterInsertionPoint
=
mTextEditor
-
>
FindBetterInsertionPoint
(
atStartOfSelection
)
;
int32_t
IMESelectionOffset
=
mTextEditor
-
>
GetIMESelectionStartOffsetIn
(
betterInsertionPoint
.
Container
(
)
)
;
if
(
IMESelectionOffset
>
=
0
)
{
betterInsertionPoint
.
Set
(
betterInsertionPoint
.
Container
(
)
IMESelectionOffset
)
;
}
rv
=
mTextEditor
-
>
InsertTextImpl
(
*
doc
*
outString
betterInsertionPoint
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
NS_ENSURE_STATE
(
mTextEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mTextEditor
)
;
EditorRawDOMPoint
pointAfterStringInserted
;
rv
=
mTextEditor
-
>
InsertTextImpl
(
*
doc
*
outString
atStartOfSelection
&
pointAfterStringInserted
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
pointAfterStringInserted
.
IsSet
(
)
)
{
bool
endsWithLF
=
!
outString
-
>
IsEmpty
(
)
&
&
outString
-
>
Last
(
)
=
=
nsCRT
:
:
LF
;
aSelection
-
>
SetInterlinePosition
(
endsWithLF
)
;
MOZ_ASSERT
(
!
pointAfterStringInserted
.
GetChildAtOffset
(
)
"
After
inserting
text
into
a
text
node
pointAfterStringInserted
.
"
"
GetChildAtOffset
(
)
should
be
nullptr
"
)
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
pointAfterStringInserted
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
collapse
selection
after
inserting
string
"
)
;
}
}
}
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidInsertText
(
Selection
*
aSelection
nsresult
aResult
)
{
return
DidInsert
(
aSelection
aResult
)
;
}
nsresult
TextEditRules
:
:
WillSetText
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
MOZ_ASSERT
(
aString
)
;
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aHandled
=
false
;
*
aCancel
=
false
;
if
(
NS_WARN_IF
(
!
mTextEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
if
(
!
IsPlaintextEditor
(
)
|
|
textEditor
-
>
IsIMEComposing
(
)
|
|
aMaxLength
!
=
-
1
)
{
return
NS_OK
;
}
if
(
IsPasswordEditor
(
)
&
&
LookAndFeel
:
:
GetEchoPassword
(
)
&
&
!
DontEchoPassword
(
)
)
{
return
NS_OK
;
}
WillInsert
(
aSelection
aCancel
)
;
*
aCancel
=
false
;
RefPtr
<
Element
>
rootElement
=
textEditor
-
>
GetRoot
(
)
;
uint32_t
count
=
rootElement
-
>
GetChildCount
(
)
;
if
(
count
>
1
)
{
return
NS_OK
;
}
nsAutoString
tString
(
*
aString
)
;
if
(
IsPasswordEditor
(
)
)
{
mPasswordText
.
Assign
(
tString
)
;
FillBufWithPWChars
(
&
tString
tString
.
Length
(
)
)
;
}
else
if
(
IsSingleLineEditor
(
)
)
{
HandleNewLines
(
tString
textEditor
-
>
mNewlineHandling
)
;
}
if
(
!
count
)
{
if
(
tString
.
IsEmpty
(
)
)
{
*
aHandled
=
true
;
return
NS_OK
;
}
RefPtr
<
nsIDocument
>
doc
=
textEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_OK
;
}
RefPtr
<
nsTextNode
>
newNode
=
EditorBase
:
:
CreateTextNode
(
*
doc
tString
)
;
if
(
NS_WARN_IF
(
!
newNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
textEditor
-
>
InsertNode
(
*
newNode
*
rootElement
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
;
return
NS_OK
;
}
nsINode
*
curNode
=
rootElement
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
EditorBase
:
:
IsTextNode
(
curNode
)
)
)
{
return
NS_OK
;
}
nsresult
rv
=
textEditor
-
>
SetTextImpl
(
aSelection
tString
*
curNode
-
>
GetAsText
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidSetText
(
Selection
&
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillSetTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidSetTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillRemoveTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidRemoveTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
SelectionBatcher
selectionBatcher
(
aSelection
)
;
AutoHideSelectionChanges
hideSelection
(
aSelection
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
rv
=
mTextEditor
-
>
ExtendSelectionForDelete
(
aSelection
&
aCollapsedAction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
if
(
LookAndFeel
:
:
GetEchoPassword
(
)
)
{
HideLastPWInput
(
)
;
mLastStart
=
start
;
mLastLength
=
0
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
if
(
end
=
=
start
)
{
if
(
nsIEditor
:
:
ePrevious
=
=
aCollapsedAction
&
&
start
>
0
)
{
mPasswordText
.
Cut
(
start
-
1
1
)
;
}
else
if
(
nsIEditor
:
:
eNext
=
=
aCollapsedAction
)
{
mPasswordText
.
Cut
(
start
1
)
;
}
}
else
{
mPasswordText
.
Cut
(
start
end
-
start
)
;
}
}
else
{
nsCOMPtr
<
nsIDOMNode
>
startNode
;
int32_t
startOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
if
(
!
aSelection
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
rv
=
CheckBidiLevelForDeletion
(
aSelection
startNode
startOffset
aCollapsedAction
aCancel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aCancel
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
rv
=
mTextEditor
-
>
ExtendSelectionForDelete
(
aSelection
&
aCollapsedAction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
rv
=
mTextEditor
-
>
DeleteSelectionImpl
(
aCollapsedAction
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
nsresult
aResult
)
{
nsCOMPtr
<
nsINode
>
startNode
;
int32_t
startOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
EditorBase
:
:
IsTextNode
(
startNode
)
)
{
if
(
!
startNode
-
>
Length
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
rv
=
mTextEditor
-
>
DeleteNode
(
startNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
mDidExplicitlySetInterline
)
{
return
NS_OK
;
}
return
aSelection
-
>
SetInterlinePosition
(
true
)
;
}
nsresult
TextEditRules
:
:
WillUndo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidUndo
(
Selection
*
aSelection
nsresult
aResult
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_SUCCESS
(
aResult
aResult
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
dom
:
:
Element
*
theRoot
=
mTextEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
theRoot
NS_ERROR_FAILURE
)
;
nsIContent
*
node
=
mTextEditor
-
>
GetLeftmostChild
(
theRoot
)
;
if
(
node
&
&
mTextEditor
-
>
IsMozEditorBogusNode
(
node
)
)
{
mBogusNode
=
node
;
}
else
{
mBogusNode
=
nullptr
;
}
return
aResult
;
}
nsresult
TextEditRules
:
:
WillRedo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidRedo
(
Selection
*
aSelection
nsresult
aResult
)
{
if
(
!
aSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
NS_FAILED
(
aResult
)
)
{
return
aResult
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Element
>
theRoot
=
mTextEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
theRoot
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIHTMLCollection
>
nodeList
=
theRoot
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
br
"
)
)
;
MOZ_ASSERT
(
nodeList
)
;
uint32_t
len
=
nodeList
-
>
Length
(
)
;
if
(
len
!
=
1
)
{
mBogusNode
=
nullptr
;
return
NS_OK
;
}
RefPtr
<
Element
>
node
=
nodeList
-
>
Item
(
0
)
;
if
(
mTextEditor
-
>
IsMozEditorBogusNode
(
node
)
)
{
mBogusNode
=
node
;
}
else
{
mBogusNode
=
nullptr
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillOutputText
(
Selection
*
aSelection
const
nsAString
*
aOutputFormat
nsAString
*
aOutString
uint32_t
aFlags
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aOutString
)
|
|
NS_WARN_IF
(
!
aOutputFormat
)
|
|
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
!
aOutputFormat
-
>
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
)
{
return
NS_OK
;
}
if
(
IsPasswordEditor
(
)
)
{
*
aOutString
=
mPasswordText
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
mBogusNode
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputSelectionOnly
|
|
aFlags
&
nsIDocumentEncoder
:
:
OutputWrap
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mTextEditor
)
|
|
mTextEditor
-
>
AsHTMLEditor
(
)
)
{
return
NS_OK
;
}
Element
*
root
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
!
root
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsIContent
*
firstChild
=
root
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
Text
*
text
=
firstChild
-
>
GetAsText
(
)
;
nsIContent
*
firstChildExceptText
=
text
?
firstChild
-
>
GetNextSibling
(
)
:
firstChild
;
bool
isInput
=
IsSingleLineEditor
(
)
;
bool
isTextarea
=
!
isInput
;
if
(
NS_WARN_IF
(
isInput
&
&
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
TextEditUtils
:
:
IsMozBR
(
firstChildExceptText
)
&
&
!
firstChildExceptText
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollbar
)
)
)
{
return
NS_OK
;
}
if
(
!
text
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
rv
=
text
-
>
GetData
(
*
aOutString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidOutputText
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
RemoveRedundantTrailingBR
(
)
{
if
(
mBogusNode
)
{
return
NS_OK
;
}
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
dom
:
:
Element
>
body
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
!
body
)
{
return
NS_ERROR_NULL_POINTER
;
}
uint32_t
childCount
=
body
-
>
GetChildCount
(
)
;
if
(
childCount
>
1
)
{
return
NS_OK
;
}
RefPtr
<
nsIContent
>
child
=
body
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
!
child
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
dom
:
:
Element
*
elem
=
child
-
>
AsElement
(
)
;
if
(
!
TextEditUtils
:
:
IsMozBR
(
elem
)
)
{
return
NS_OK
;
}
elem
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
true
)
;
mBogusNode
=
elem
;
elem
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateTrailingBRIfNeeded
(
)
{
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
dom
:
:
Element
*
body
=
mTextEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
body
NS_ERROR_NULL_POINTER
)
;
nsIContent
*
lastChild
=
body
-
>
GetLastChild
(
)
;
NS_ENSURE_TRUE
(
lastChild
NS_ERROR_NULL_POINTER
)
;
if
(
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mTextEditor
)
;
nsCOMPtr
<
nsIDOMNode
>
domBody
=
do_QueryInterface
(
body
)
;
return
CreateMozBR
(
domBody
body
-
>
Length
(
)
)
;
}
if
(
!
mTextEditor
-
>
IsMozEditorBogusNode
(
lastChild
)
)
{
return
NS_OK
;
}
lastChild
-
>
UnsetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
false
)
;
lastChild
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
true
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateBogusNodeIfNeeded
(
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mTextEditor
NS_ERROR_NULL_POINTER
)
;
if
(
mBogusNode
)
{
return
NS_OK
;
}
AutoRules
beginRulesSniffing
(
mTextEditor
EditAction
:
:
ignore
nsIEditor
:
:
eNone
)
;
nsCOMPtr
<
dom
:
:
Element
>
body
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
!
body
)
{
return
NS_OK
;
}
bool
bodyEditable
=
mTextEditor
-
>
IsEditable
(
body
)
;
for
(
nsIContent
*
bodyChild
=
body
-
>
GetFirstChild
(
)
;
bodyChild
;
bodyChild
=
bodyChild
-
>
GetNextSibling
(
)
)
{
if
(
mTextEditor
-
>
IsMozEditorBogusNode
(
bodyChild
)
|
|
!
bodyEditable
|
|
mTextEditor
-
>
IsEditable
(
bodyChild
)
|
|
mTextEditor
-
>
IsBlockNode
(
bodyChild
)
)
{
return
NS_OK
;
}
}
if
(
!
mTextEditor
-
>
IsModifiableNode
(
body
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newContent
=
mTextEditor
-
>
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
NS_ENSURE_STATE
(
newContent
)
;
mBogusNode
=
newContent
;
newContent
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
nsresult
rv
=
mTextEditor
-
>
InsertNode
(
*
mBogusNode
*
body
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aSelection
-
>
Collapse
(
body
0
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
TruncateInsertionIfNeeded
(
Selection
*
aSelection
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
{
if
(
!
aSelection
|
|
!
aInString
|
|
!
aOutString
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
aOutString
-
>
Assign
(
*
aInString
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
aTruncated
)
{
*
aTruncated
=
false
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
-
1
!
=
aMaxLength
&
&
IsPlaintextEditor
(
)
&
&
!
mTextEditor
-
>
IsIMEComposing
(
)
)
{
int32_t
docLength
;
nsresult
rv
=
mTextEditor
-
>
GetTextLength
(
&
docLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
TextComposition
*
composition
=
mTextEditor
-
>
GetComposition
(
)
;
uint32_t
oldCompStrLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
uint32_t
selectionLength
=
end
-
start
;
const
int32_t
resultingDocLength
=
docLength
-
selectionLength
-
oldCompStrLength
;
if
(
resultingDocLength
>
=
aMaxLength
)
{
aOutString
-
>
Truncate
(
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
else
{
int32_t
oldLength
=
aOutString
-
>
Length
(
)
;
if
(
oldLength
+
resultingDocLength
>
aMaxLength
)
{
int32_t
newLength
=
aMaxLength
-
resultingDocLength
;
MOZ_ASSERT
(
newLength
>
0
)
;
char16_t
newLastChar
=
aOutString
-
>
CharAt
(
newLength
-
1
)
;
char16_t
removingFirstChar
=
aOutString
-
>
CharAt
(
newLength
)
;
if
(
NS_IS_HIGH_SURROGATE
(
newLastChar
)
&
&
NS_IS_LOW_SURROGATE
(
removingFirstChar
)
)
{
newLength
-
-
;
}
aOutString
-
>
Truncate
(
newLength
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
}
}
return
NS_OK
;
}
void
TextEditRules
:
:
ResetIMETextPWBuf
(
)
{
mPasswordIMEText
.
Truncate
(
)
;
}
void
TextEditRules
:
:
RemoveIMETextFromPWBuf
(
uint32_t
&
aStart
nsAString
*
aIMEString
)
{
MOZ_ASSERT
(
aIMEString
)
;
if
(
mPasswordIMEText
.
IsEmpty
(
)
)
{
mPasswordIMEIndex
=
aStart
;
}
else
{
mPasswordText
.
Cut
(
mPasswordIMEIndex
mPasswordIMEText
.
Length
(
)
)
;
aStart
=
mPasswordIMEIndex
;
}
mPasswordIMEText
.
Assign
(
*
aIMEString
)
;
}
NS_IMETHODIMP
TextEditRules
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
mTimer
)
;
nsresult
rv
=
IsPasswordEditor
(
)
?
HideLastPWInput
(
)
:
NS_OK
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
;
mLastLength
=
0
;
return
rv
;
}
NS_IMETHODIMP
TextEditRules
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
TextEditRules
"
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
HideLastPWInput
(
)
{
if
(
!
mLastLength
)
{
return
NS_OK
;
}
nsAutoString
hiddenText
;
FillBufWithPWChars
(
&
hiddenText
mLastLength
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
uint32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
selection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
nsCOMPtr
<
nsINode
>
selNode
=
GetTextNode
(
selection
)
;
NS_ENSURE_TRUE
(
selNode
NS_OK
)
;
selNode
-
>
GetAsText
(
)
-
>
ReplaceData
(
mLastStart
mLastLength
hiddenText
)
;
selection
-
>
Collapse
(
selNode
start
)
;
if
(
start
!
=
end
)
{
selection
-
>
Extend
(
selNode
end
)
;
}
return
NS_OK
;
}
void
TextEditRules
:
:
FillBufWithPWChars
(
nsAString
*
aOutString
int32_t
aLength
)
{
MOZ_ASSERT
(
aOutString
)
;
char16_t
passwordChar
=
LookAndFeel
:
:
GetPasswordCharacter
(
)
;
aOutString
-
>
Truncate
(
)
;
for
(
int32_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
aOutString
-
>
Append
(
passwordChar
)
;
}
}
nsresult
TextEditRules
:
:
CreateBRInternal
(
nsIDOMNode
*
inParent
int32_t
inOffset
bool
aMozBR
nsIDOMNode
*
*
outBRNode
)
{
NS_ENSURE_TRUE
(
inParent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
brNode
;
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
rv
=
mTextEditor
-
>
CreateBR
(
inParent
inOffset
address_of
(
brNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
Element
>
brElem
=
do_QueryInterface
(
brNode
)
;
if
(
aMozBR
&
&
brElem
)
{
rv
=
mTextEditor
-
>
SetAttribute
(
brElem
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
outBRNode
)
{
brNode
.
forget
(
outBRNode
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
DocumentModified
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
TextEditRules
:
:
IsPasswordEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPasswordEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsSingleLineEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsSingleLineEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsPlaintextEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPlaintextEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsReadonly
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsReadonly
(
)
:
false
;
}
bool
TextEditRules
:
:
IsDisabled
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsDisabled
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMailEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsMailEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
DontEchoPassword
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
DontEchoPassword
(
)
:
false
;
}
}
