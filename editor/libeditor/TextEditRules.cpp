#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
HTMLEditRules
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
\
*
aCancel
=
true
;
\
return
NS_OK
;
\
}
#
define
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY_OF_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
\
return
EditActionCanceled
(
NS_OK
)
;
\
}
TextEditRules
:
:
TextEditRules
(
)
:
mTextEditor
(
nullptr
)
mData
(
nullptr
)
#
ifdef
DEBUG
mIsHandling
(
false
)
#
endif
mIsHTMLEditRules
(
false
)
{
InitFields
(
)
;
}
void
TextEditRules
:
:
InitFields
(
)
{
mTextEditor
=
nullptr
;
}
HTMLEditRules
*
TextEditRules
:
:
AsHTMLEditRules
(
)
{
return
mIsHTMLEditRules
?
static_cast
<
HTMLEditRules
*
>
(
this
)
:
nullptr
;
}
const
HTMLEditRules
*
TextEditRules
:
:
AsHTMLEditRules
(
)
const
{
return
mIsHTMLEditRules
?
static_cast
<
const
HTMLEditRules
*
>
(
this
)
:
nullptr
;
}
nsresult
TextEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
Selection
*
selection
=
aTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
InitFields
(
)
;
mTextEditor
=
aTextEditor
;
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
rv
=
TextEditorRef
(
)
.
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsPlaintextEditor
(
)
)
{
rv
=
CreateTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DetachEditor
(
)
{
mTextEditor
=
nullptr
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
BeforeEdit
(
)
{
MOZ_ASSERT
(
!
mIsHandling
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
#
ifdef
DEBUG
mIsHandling
=
true
;
#
endif
return
NS_OK
;
}
nsresult
TextEditRules
:
:
AfterEdit
(
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mIsHandling
)
;
mIsHandling
=
false
;
#
endif
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
nsresult
rv
=
TextEditorRef
(
)
.
HandleInlineSpellCheckAfterEdit
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
EnsurePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CreateTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CollapseSelectionToTrailingBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
selection
to
after
the
text
node
in
TextEditor
"
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDoAction
(
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
AutoSafeEditorData
setData
(
*
this
*
mTextEditor
)
;
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
TextEditorRef
(
)
.
UndefineCaretBidiLevel
(
)
;
return
WillInsertText
(
aInfo
.
mEditSubAction
aCancel
aHandled
aInfo
.
inString
aInfo
.
outString
aInfo
.
maxLength
)
;
case
EditSubAction
:
:
eSetText
:
TextEditorRef
(
)
.
UndefineCaretBidiLevel
(
)
;
return
WillSetText
(
aCancel
aHandled
aInfo
.
inString
aInfo
.
maxLength
)
;
case
EditSubAction
:
:
eDeleteSelectedContent
:
return
WillDeleteSelection
(
aInfo
.
collapsedAction
aCancel
aHandled
)
;
case
EditSubAction
:
:
eSetTextProperty
:
return
WillSetTextProperty
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eRemoveTextProperty
:
return
WillRemoveTextProperty
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eComputeTextToOutput
:
return
WillOutputText
(
aInfo
.
outputFormat
aInfo
.
outString
aInfo
.
flags
aCancel
aHandled
)
;
case
EditSubAction
:
:
eInsertQuotedText
:
{
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
TextEditorRef
(
)
.
MaybeDoAutoPasswordMasking
(
)
;
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
"
Failed
to
remove
padding
<
br
>
element
"
)
;
return
rv
;
}
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eUndo
:
case
EditSubAction
:
:
eRedo
:
MOZ_ASSERT_UNREACHABLE
(
"
This
path
should
'
ve
been
dead
code
"
)
;
return
NS_ERROR_UNEXPECTED
;
default
:
return
NS_ERROR_FAILURE
;
}
}
nsresult
TextEditRules
:
:
DidDoAction
(
EditSubActionInfo
&
aInfo
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eUndo
:
case
EditSubAction
:
:
eRedo
:
MOZ_ASSERT_UNREACHABLE
(
"
This
path
should
'
ve
been
dead
code
"
)
;
return
NS_ERROR_UNEXPECTED
;
default
:
return
NS_OK
;
}
}
bool
TextEditRules
:
:
DocumentIsEmpty
(
)
const
{
bool
retVal
=
false
;
if
(
!
mTextEditor
|
|
NS_FAILED
(
mTextEditor
-
>
IsEmpty
(
&
retVal
)
)
)
{
retVal
=
true
;
}
return
retVal
;
}
EditActionResult
TextEditor
:
:
InsertLineFeedCharacterAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
AsHTMLEditor
(
)
)
;
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
UndefineCaretBidiLevel
(
)
;
CANCEL_OPERATION_AND_RETURN_EDIT_ACTION_RESULT_IF_READONLY_OF_DISABLED
if
(
mMaxTextLength
>
=
0
)
{
nsAutoString
insertionString
(
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
EditActionResult
result
=
TruncateInsertionStringForMaxLength
(
insertionString
mMaxTextLength
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
if
(
result
.
Handled
(
)
)
{
return
EditActionCanceled
(
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
&
&
!
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
pointAfterInsertedLineFeed
;
rv
=
InsertTextWithTransaction
(
*
document
NS_LITERAL_STRING
(
"
\
n
"
)
pointToInsert
&
pointAfterInsertedLineFeed
)
;
if
(
NS_WARN_IF
(
!
pointAfterInsertedLineFeed
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
!
pointAfterInsertedLineFeed
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterInsertedLineFeed
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterInsertedLineFeed
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
EditorRawDOMPoint
endPoint
(
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
endPoint
=
=
pointAfterInsertedLineFeed
)
{
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
TextEditRules
:
:
CollapseSelectionToTrailingBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
TextEditorRef
(
)
.
CollapseSelectionToEnd
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
selectionStartPoint
.
IsInTextNode
(
)
|
|
!
selectionStartPoint
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
parentNode
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
if
(
parentNode
!
=
rootElement
)
{
return
NS_OK
;
}
nsINode
*
nextNode
=
selectionStartPoint
.
GetContainer
(
)
-
>
GetNextSibling
(
)
;
if
(
!
nextNode
|
|
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextNode
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
afterStartContainer
(
selectionStartPoint
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
afterStartContainer
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterStartContainer
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
TextEditRules
:
:
GetTextNodeAroundSelectionStartContainer
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
if
(
selectionStartPoint
.
IsInTextNode
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
selectionStartPoint
.
GetContainer
(
)
;
return
node
.
forget
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
selectionStartPoint
.
GetContainer
(
)
;
RefPtr
<
NodeIterator
>
iter
=
new
NodeIterator
(
node
NodeFilter_Binding
:
:
SHOW_TEXT
nullptr
)
;
while
(
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
node
=
iter
-
>
NextNode
(
IgnoreErrors
(
)
)
;
if
(
!
node
)
{
return
nullptr
;
}
}
return
node
.
forget
(
)
;
}
void
TextEditRules
:
:
HandleNewLines
(
nsString
&
aString
)
{
static
const
char16_t
kLF
=
static_cast
<
char16_t
>
(
'
\
n
'
)
;
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aString
.
FindChar
(
static_cast
<
uint16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
int32_t
firstLF
=
aString
.
FindChar
(
kLF
0
)
;
if
(
firstLF
=
=
kNotFound
)
{
return
;
}
switch
(
TextEditorRef
(
)
.
mNewlineHandling
)
{
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
LFSTR
false
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStrip
:
aString
.
StripChar
(
kLF
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
offset
=
0
;
while
(
firstLF
=
=
offset
)
{
offset
+
+
;
firstLF
=
aString
.
FindChar
(
kLF
offset
)
;
}
if
(
firstLF
>
0
)
{
aString
.
Truncate
(
firstLF
)
;
}
if
(
offset
>
0
)
{
aString
.
Cut
(
0
offset
)
;
}
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
LFSTR
true
true
)
;
aString
.
ReplaceChar
(
kLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsAutoString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextLF
=
!
offset
?
firstLF
:
aString
.
FindChar
(
kLF
offset
)
;
if
(
nextLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
{
-
-
wsBegin
;
}
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
{
+
+
offset
;
}
}
aString
=
result
;
break
;
}
case
nsIPlaintextEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
LFSTR
true
true
)
;
break
;
}
}
nsresult
TextEditRules
:
:
WillInsertText
(
EditSubAction
aEditSubAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
inString
-
>
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
*
aCancel
=
true
;
*
aHandled
=
false
;
return
NS_OK
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
outString
-
>
Assign
(
*
inString
)
;
if
(
aMaxLength
>
=
0
)
{
EditActionResult
result
=
TextEditorRef
(
)
.
TruncateInsertionStringForMaxLength
(
*
outString
aMaxLength
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
if
(
result
.
Handled
(
)
&
&
outString
-
>
IsEmpty
(
)
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
}
uint32_t
start
=
0
;
if
(
IsPasswordEditor
(
)
)
{
if
(
TextEditorRef
(
)
.
GetComposition
(
)
&
&
!
TextEditorRef
(
)
.
GetComposition
(
)
-
>
String
(
)
.
IsEmpty
(
)
)
{
start
=
TextEditorRef
(
)
.
GetComposition
(
)
-
>
XPOffsetInTextNode
(
)
;
}
else
{
uint32_t
end
=
0
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
TextEditorRef
(
)
.
GetRoot
(
)
start
end
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
TextEditorRef
(
)
.
MaybeDoAutoPasswordMasking
(
)
;
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsSingleLineEditor
(
)
)
{
nsAutoString
tString
(
*
outString
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
tString
)
;
HandleNewLines
(
tString
)
;
outString
-
>
Assign
(
tString
)
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
IsInTextNode
(
)
&
&
!
TextEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Document
>
doc
=
TextEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
TextEditorRef
(
)
.
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
TextEditorRef
(
)
.
FindBetterInsertionPoint
(
atStartOfSelection
)
;
}
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertTextWithTransaction
(
*
doc
*
outString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
EditorRawDOMPoint
pointAfterStringInserted
;
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertTextWithTransaction
(
*
doc
*
outString
atStartOfSelection
&
pointAfterStringInserted
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
pointAfterStringInserted
.
IsSet
(
)
)
{
bool
endsWithLF
=
!
outString
-
>
IsEmpty
(
)
&
&
outString
-
>
Last
(
)
=
=
nsCRT
:
:
LF
;
IgnoredErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
endsWithLF
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
or
unset
interline
position
"
)
;
MOZ_ASSERT
(
!
pointAfterStringInserted
.
GetChild
(
)
"
After
inserting
text
into
a
text
node
pointAfterStringInserted
.
"
"
GetChild
(
)
should
be
nullptr
"
)
;
error
=
IgnoredErrorResult
(
)
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointAfterStringInserted
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
inserting
string
"
)
;
}
}
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
&
&
!
DontEchoPassword
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
SetUnmaskRangeAndNotify
(
start
outString
-
>
Length
(
)
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillSetText
(
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
mIsHTMLEditRules
)
;
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
MOZ_ASSERT
(
aString
)
;
MOZ_ASSERT
(
aString
-
>
FindChar
(
static_cast
<
char16_t
>
(
'
\
r
'
)
)
=
=
kNotFound
)
;
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aHandled
=
false
;
*
aCancel
=
false
;
if
(
!
IsPlaintextEditor
(
)
|
|
TextEditorRef
(
)
.
IsIMEComposing
(
)
|
|
TextEditorRef
(
)
.
IsUndoRedoEnabled
(
)
|
|
TextEditorRef
(
)
.
GetEditAction
(
)
=
=
EditAction
:
:
eReplaceText
|
|
aMaxLength
!
=
-
1
)
{
return
NS_OK
;
}
TextEditorRef
(
)
.
MaybeDoAutoPasswordMasking
(
)
;
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
Element
>
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
nsIContent
*
firstChild
=
rootElement
-
>
GetFirstChild
(
)
;
if
(
IsSingleLineEditor
(
)
)
{
if
(
firstChild
&
&
(
!
EditorBase
:
:
IsTextNode
(
firstChild
)
|
|
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
NS_OK
;
}
}
else
{
if
(
!
firstChild
)
{
return
NS_OK
;
}
if
(
EditorBase
:
:
IsTextNode
(
firstChild
)
)
{
if
(
!
firstChild
-
>
GetNextSibling
(
)
|
|
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChild
-
>
GetNextSibling
(
)
)
)
{
return
NS_OK
;
}
}
else
if
(
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChild
)
)
{
return
NS_OK
;
}
}
nsAutoString
tString
(
*
aString
)
;
if
(
IsSingleLineEditor
(
)
&
&
!
IsPasswordEditor
(
)
)
{
HandleNewLines
(
tString
)
;
}
if
(
!
firstChild
|
|
!
EditorBase
:
:
IsTextNode
(
firstChild
)
)
{
if
(
tString
.
IsEmpty
(
)
)
{
*
aHandled
=
true
;
return
NS_OK
;
}
RefPtr
<
Document
>
doc
=
TextEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_OK
;
}
RefPtr
<
nsTextNode
>
newNode
=
TextEditorRef
(
)
.
CreateTextNode
(
tString
)
;
if
(
NS_WARN_IF
(
!
newNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertNodeWithTransaction
(
*
newNode
EditorDOMPoint
(
rootElement
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
RefPtr
<
Text
>
textNode
=
firstChild
-
>
GetAsText
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textNode
)
)
)
{
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
SetTextImpl
(
tString
*
textNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
tString
.
IsEmpty
(
)
&
&
!
textNode
-
>
Length
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteNodeWithTransaction
(
*
textNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePoisition
(
)
failed
"
)
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillSetTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillRemoveTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDeleteSelection
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
TextEditorRef
(
)
.
HasPaddingBRElementForEmptyEditor
(
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsresult
rv
=
DeleteSelectionWithTransaction
(
aCollapsedAction
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DeleteSelectionWithTransaction
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
*
aCancel
=
=
false
)
;
MOZ_ASSERT
(
aHandled
)
;
SelectionBatcher
selectionBatcher
(
SelectionRefPtr
(
)
)
;
AutoHideSelectionChanges
hideSelection
(
SelectionRefPtr
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
&
&
IsMaskingPassword
(
)
)
{
TextEditorRef
(
)
.
MaskAllCharacters
(
)
;
}
else
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
TextEditorRef
(
)
.
SetCaretBidiLevelForDeletion
(
selectionStartPoint
aCollapsedAction
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
if
(
result
.
Canceled
(
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
}
nsresult
rv
=
TextEditorRef
(
)
.
ExtendSelectionForDelete
(
&
aCollapsedAction
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
DeleteSelectionWithTransaction
(
aCollapsedAction
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillOutputText
(
const
nsAString
*
aOutputFormat
nsAString
*
aOutString
uint32_t
aFlags
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aOutString
)
|
|
NS_WARN_IF
(
!
aOutputFormat
)
|
|
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
!
aOutputFormat
-
>
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
)
{
return
NS_OK
;
}
if
(
TextEditorRef
(
)
.
HasPaddingBRElementForEmptyEditor
(
)
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputSelectionOnly
|
|
aFlags
&
nsIDocumentEncoder
:
:
OutputWrap
)
{
return
NS_OK
;
}
if
(
TextEditorRef
(
)
.
AsHTMLEditor
(
)
)
{
return
NS_OK
;
}
Element
*
root
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
!
root
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsIContent
*
firstChild
=
root
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
Text
*
text
=
firstChild
-
>
GetAsText
(
)
;
nsIContent
*
firstChildExceptText
=
text
?
firstChild
-
>
GetNextSibling
(
)
:
firstChild
;
bool
isInput
=
IsSingleLineEditor
(
)
;
bool
isTextarea
=
!
isInput
;
if
(
NS_WARN_IF
(
isInput
&
&
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
firstChildExceptText
)
|
|
NS_WARN_IF
(
isTextarea
&
&
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
firstChildExceptText
)
&
&
!
firstChildExceptText
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollbar
)
)
)
{
return
NS_OK
;
}
if
(
!
text
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
text
-
>
GetData
(
*
aOutString
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateTrailingBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
Element
*
rootElement
=
TextEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
rootElement
-
>
GetLastChild
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
HTMLBRElement
>
brElement
=
HTMLBRElement
:
:
FromNode
(
rootElement
-
>
GetLastChild
(
)
)
;
if
(
!
brElement
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
TextEditorRef
(
)
)
;
EditorDOMPoint
endOfRoot
;
endOfRoot
.
SetToEndOf
(
rootElement
)
;
CreateElementResult
createPaddingBRResult
=
MOZ_KnownLive
(
TextEditorRef
(
)
)
.
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfRoot
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
return
NS_OK
;
}
if
(
!
brElement
-
>
IsPaddingForEmptyEditor
(
)
)
{
return
NS_OK
;
}
brElement
-
>
UnsetFlags
(
NS_PADDING_FOR_EMPTY_EDITOR
)
;
brElement
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_LAST_LINE
)
;
return
NS_OK
;
}
EditActionResult
TextEditor
:
:
TruncateInsertionStringForMaxLength
(
nsAString
&
aInsertionString
uint32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
IsPlaintextEditor
(
)
|
|
IsIMEComposing
(
)
)
{
return
EditActionIgnored
(
)
;
}
int32_t
currentLength
=
INT32_MAX
;
nsresult
rv
=
GetTextLength
(
&
currentLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
EditActionResult
(
rv
)
;
}
uint32_t
selectionStart
selectionEnd
;
nsContentUtils
:
:
GetSelectionInTextControl
(
SelectionRefPtr
(
)
GetRoot
(
)
selectionStart
selectionEnd
)
;
TextComposition
*
composition
=
GetComposition
(
)
;
const
uint32_t
kOldCompositionStringLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
uint32_t
kSelectionLength
=
selectionEnd
-
selectionStart
;
const
uint32_t
kNewLength
=
currentLength
-
kSelectionLength
-
kOldCompositionStringLength
;
if
(
kNewLength
>
=
aMaxLength
)
{
aInsertionString
.
Truncate
(
)
;
return
EditActionHandled
(
)
;
}
if
(
aInsertionString
.
Length
(
)
+
kNewLength
<
=
aMaxLength
)
{
return
EditActionIgnored
(
)
;
}
int32_t
newInsertionStringLength
=
aMaxLength
-
kNewLength
;
MOZ_ASSERT
(
newInsertionStringLength
>
0
)
;
char16_t
maybeHighSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
-
1
)
;
char16_t
maybeLowSurrogate
=
aInsertionString
.
CharAt
(
newInsertionStringLength
)
;
if
(
NS_IS_HIGH_SURROGATE
(
maybeHighSurrogate
)
&
&
NS_IS_LOW_SURROGATE
(
maybeLowSurrogate
)
)
{
newInsertionStringLength
-
-
;
}
aInsertionString
.
Truncate
(
newInsertionStringLength
)
;
return
EditActionHandled
(
)
;
}
bool
TextEditRules
:
:
IsPasswordEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPasswordEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMaskingPassword
(
)
const
{
MOZ_ASSERT
(
IsPasswordEditor
(
)
)
;
return
mTextEditor
?
mTextEditor
-
>
IsMaskingPassword
(
)
:
true
;
}
bool
TextEditRules
:
:
IsSingleLineEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsSingleLineEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsPlaintextEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPlaintextEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsReadonly
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsReadonly
(
)
:
false
;
}
bool
TextEditRules
:
:
IsDisabled
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsDisabled
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMailEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsMailEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
DontEchoPassword
(
)
const
{
if
(
!
mTextEditor
)
{
return
false
;
}
if
(
!
LookAndFeel
:
:
GetEchoPassword
(
)
|
|
mTextEditor
-
>
DontEchoPassword
(
)
)
{
return
true
;
}
if
(
mTextEditor
-
>
GetEditAction
(
)
!
=
EditAction
:
:
eDrop
&
&
mTextEditor
-
>
GetEditAction
(
)
!
=
EditAction
:
:
ePaste
)
{
return
false
;
}
return
true
;
}
}
