#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsEditor
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMCharacterData
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMNodeFilter
.
h
"
#
include
"
nsIDOMNodeIterator
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsIDOMText
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
\
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
\
{
\
*
aCancel
=
true
;
\
return
NS_OK
;
\
}
;
TextEditRules
:
:
TextEditRules
(
)
:
mTextEditor
(
nullptr
)
mPasswordIMEIndex
(
0
)
mCachedSelectionOffset
(
0
)
mActionNesting
(
0
)
mLockRulesSniffing
(
false
)
mDidExplicitlySetInterline
(
false
)
mDeleteBidiImmediately
(
false
)
mTheAction
(
EditAction
:
:
none
)
mLastStart
(
0
)
mLastLength
(
0
)
{
InitFields
(
)
;
}
void
TextEditRules
:
:
InitFields
(
)
{
mTextEditor
=
nullptr
;
mPasswordText
.
Truncate
(
)
;
mPasswordIMEText
.
Truncate
(
)
;
mPasswordIMEIndex
=
0
;
mBogusNode
=
nullptr
;
mCachedSelectionNode
=
nullptr
;
mCachedSelectionOffset
=
0
;
mActionNesting
=
0
;
mLockRulesSniffing
=
false
;
mDidExplicitlySetInterline
=
false
;
mDeleteBidiImmediately
=
false
;
mTheAction
=
EditAction
:
:
none
;
mTimer
=
nullptr
;
mLastStart
=
0
;
mLastLength
=
0
;
}
TextEditRules
:
:
~
TextEditRules
(
)
{
if
(
mTimer
)
mTimer
-
>
Cancel
(
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
TextEditRules
mBogusNode
mCachedSelectionNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TextEditRules
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditRules
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditRules
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextEditRules
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextEditRules
)
NS_IMETHODIMP
TextEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
!
aTextEditor
)
{
return
NS_ERROR_NULL_POINTER
;
}
InitFields
(
)
;
mTextEditor
=
aTextEditor
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_WARN_IF_FALSE
(
selection
"
editor
cannot
get
selection
"
)
;
nsresult
res
=
CreateBogusNodeIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
int32_t
rangeCount
;
res
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
rangeCount
)
{
res
=
mTextEditor
-
>
EndOfDocument
(
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
if
(
IsPlaintextEditor
(
)
)
{
res
=
CreateTrailingBRIfNeeded
(
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
mDeleteBidiImmediately
=
Preferences
:
:
GetBool
(
"
bidi
.
edit
.
delete_immediately
"
false
)
;
return
res
;
}
NS_IMETHODIMP
TextEditRules
:
:
SetInitialValue
(
const
nsAString
&
aValue
)
{
if
(
IsPasswordEditor
(
)
)
{
mPasswordText
=
aValue
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
DetachEditor
(
)
{
if
(
mTimer
)
mTimer
-
>
Cancel
(
)
;
mTextEditor
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
BeforeEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
return
NS_OK
;
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mTheAction
=
action
;
}
mActionNesting
+
+
;
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
selection
-
>
GetAnchorNode
(
getter_AddRefs
(
mCachedSelectionNode
)
)
;
selection
-
>
GetAnchorOffset
(
&
mCachedSelectionOffset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
AfterEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
return
NS_OK
;
AutoLockRulesSniffing
lockIt
(
this
)
;
NS_PRECONDITION
(
mActionNesting
>
0
"
bad
action
nesting
!
"
)
;
nsresult
res
=
NS_OK
;
if
(
!
-
-
mActionNesting
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
HandleInlineSpellCheck
(
action
selection
mCachedSelectionNode
mCachedSelectionOffset
nullptr
0
nullptr
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
RemoveRedundantTrailingBR
(
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
res
=
CreateBogusNodeIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
CreateTrailingBRIfNeeded
(
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
CollapseSelectionToTrailingBRIfNeeded
(
selection
)
;
}
return
res
;
}
NS_IMETHODIMP
TextEditRules
:
:
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aInfo
&
&
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertBreak
(
aSelection
aCancel
aHandled
info
-
>
maxLength
)
;
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertText
(
info
-
>
action
aSelection
aCancel
aHandled
info
-
>
inString
info
-
>
outString
info
-
>
maxLength
)
;
case
EditAction
:
:
deleteSelection
:
return
WillDeleteSelection
(
aSelection
info
-
>
collapsedAction
aCancel
aHandled
)
;
case
EditAction
:
:
undo
:
return
WillUndo
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
redo
:
return
WillRedo
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
setTextProperty
:
return
WillSetTextProperty
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
removeTextProperty
:
return
WillRemoveTextProperty
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
outputText
:
return
WillOutputText
(
aSelection
info
-
>
outputFormat
info
-
>
outString
aCancel
aHandled
)
;
case
EditAction
:
:
insertElement
:
WillInsert
(
*
aSelection
aCancel
)
;
return
NS_OK
;
default
:
return
NS_ERROR_FAILURE
;
}
}
NS_IMETHODIMP
TextEditRules
:
:
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
AutoTransactionsConserveSelection
dontSpazMySelection
(
mTextEditor
)
;
NS_ENSURE_TRUE
(
aSelection
&
&
aInfo
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
return
DidInsertBreak
(
aSelection
aResult
)
;
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
return
DidInsertText
(
aSelection
aResult
)
;
case
EditAction
:
:
deleteSelection
:
return
DidDeleteSelection
(
aSelection
info
-
>
collapsedAction
aResult
)
;
case
EditAction
:
:
undo
:
return
DidUndo
(
aSelection
aResult
)
;
case
EditAction
:
:
redo
:
return
DidRedo
(
aSelection
aResult
)
;
case
EditAction
:
:
setTextProperty
:
return
DidSetTextProperty
(
aSelection
aResult
)
;
case
EditAction
:
:
removeTextProperty
:
return
DidRemoveTextProperty
(
aSelection
aResult
)
;
case
EditAction
:
:
outputText
:
return
DidOutputText
(
aSelection
aResult
)
;
default
:
return
NS_OK
;
}
}
NS_IMETHODIMP
TextEditRules
:
:
DocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
{
NS_ENSURE_TRUE
(
aDocumentIsEmpty
NS_ERROR_NULL_POINTER
)
;
*
aDocumentIsEmpty
=
(
mBogusNode
!
=
nullptr
)
;
return
NS_OK
;
}
void
TextEditRules
:
:
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
{
MOZ_ASSERT
(
aCancel
)
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
*
aCancel
=
true
;
return
;
}
*
aCancel
=
false
;
if
(
mBogusNode
)
{
NS_ENSURE_TRUE_VOID
(
mTextEditor
)
;
mTextEditor
-
>
DeleteNode
(
mBogusNode
)
;
mBogusNode
=
nullptr
;
}
}
nsresult
TextEditRules
:
:
DidInsert
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillInsertBreak
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
int32_t
aMaxLength
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aHandled
=
false
;
if
(
IsSingleLineEditor
(
)
)
{
*
aCancel
=
true
;
}
else
{
NS_NAMED_LITERAL_STRING
(
inString
"
\
n
"
)
;
nsAutoString
outString
;
bool
didTruncate
;
nsresult
res
=
TruncateInsertionIfNeeded
(
aSelection
&
inString
&
outString
aMaxLength
&
didTruncate
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
didTruncate
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
*
aCancel
=
false
;
bool
bCollapsed
;
res
=
aSelection
-
>
GetIsCollapsed
(
&
bCollapsed
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
bCollapsed
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CollapseSelectionToTrailingBRIfNeeded
(
Selection
*
aSelection
)
{
if
(
!
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
!
aSelection
-
>
RangeCount
(
)
)
{
mTextEditor
-
>
EndOfDocument
(
)
;
}
int32_t
selOffset
;
nsCOMPtr
<
nsIDOMNode
>
selNode
;
nsresult
res
;
res
=
mTextEditor
-
>
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
nsCOMPtr
<
nsIDOMText
>
nodeAsText
=
do_QueryInterface
(
selNode
)
;
if
(
!
nodeAsText
)
return
NS_OK
;
uint32_t
length
;
res
=
nodeAsText
-
>
GetLength
(
&
length
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
selOffset
!
=
int32_t
(
length
)
)
return
NS_OK
;
int32_t
parentOffset
;
nsCOMPtr
<
nsIDOMNode
>
parentNode
=
nsEditor
:
:
GetNodeLocation
(
selNode
&
parentOffset
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
nsCOMPtr
<
nsIDOMNode
>
root
=
do_QueryInterface
(
mTextEditor
-
>
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_NULL_POINTER
)
;
if
(
parentNode
!
=
root
)
return
NS_OK
;
nsCOMPtr
<
nsIDOMNode
>
nextNode
=
mTextEditor
-
>
GetChildAt
(
parentNode
parentOffset
+
1
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
res
=
aSelection
-
>
Collapse
(
parentNode
parentOffset
+
1
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
return
res
;
}
static
inline
already_AddRefed
<
nsIDOMNode
>
GetTextNode
(
Selection
*
selection
nsEditor
*
editor
)
{
int32_t
selOffset
;
nsCOMPtr
<
nsIDOMNode
>
selNode
;
nsresult
res
=
editor
-
>
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
res
nullptr
)
;
if
(
!
editor
-
>
IsTextNode
(
selNode
)
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
selNode
)
;
NS_ENSURE_TRUE
(
node
nullptr
)
;
NodeFilterHolder
filter
;
RefPtr
<
NodeIterator
>
iter
=
new
NodeIterator
(
node
nsIDOMNodeFilter
:
:
SHOW_TEXT
filter
)
;
while
(
!
editor
-
>
IsTextNode
(
selNode
)
)
{
if
(
NS_FAILED
(
res
=
iter
-
>
NextNode
(
getter_AddRefs
(
selNode
)
)
)
|
|
!
selNode
)
{
return
nullptr
;
}
}
}
return
selNode
.
forget
(
)
;
}
#
ifdef
DEBUG
#
define
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
\
if
(
IsPasswordEditor
(
)
&
&
mTextEditor
-
>
GetRoot
(
)
)
{
\
int32_t
txtLen
;
\
mTextEditor
-
>
GetTextLength
(
&
txtLen
)
;
\
NS_ASSERTION
(
mPasswordText
.
Length
(
)
=
=
uint32_t
(
txtLen
)
\
"
password
length
not
equal
to
number
of
asterisks
"
)
;
\
}
#
else
#
define
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
#
endif
void
TextEditRules
:
:
HandleNewLines
(
nsString
&
aString
int32_t
aNewlineHandling
)
{
if
(
aNewlineHandling
<
0
)
{
int32_t
caretStyle
;
TextEditor
:
:
GetDefaultEditorPrefs
(
aNewlineHandling
caretStyle
)
;
}
switch
(
aNewlineHandling
)
{
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithSpaces
:
aString
.
Trim
(
CRLF
false
true
)
;
aString
.
ReplaceChar
(
CRLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStrip
:
aString
.
StripChars
(
CRLF
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesPasteToFirst
:
default
:
{
int32_t
firstCRLF
=
aString
.
FindCharInSet
(
CRLF
)
;
int32_t
offset
=
0
;
while
(
firstCRLF
=
=
offset
)
{
offset
+
+
;
firstCRLF
=
aString
.
FindCharInSet
(
CRLF
offset
)
;
}
if
(
firstCRLF
>
0
)
aString
.
Truncate
(
firstCRLF
)
;
if
(
offset
>
0
)
aString
.
Cut
(
0
offset
)
;
}
break
;
case
nsIPlaintextEditor
:
:
eNewlinesReplaceWithCommas
:
aString
.
Trim
(
CRLF
true
true
)
;
aString
.
ReplaceChar
(
CRLF
'
'
)
;
break
;
case
nsIPlaintextEditor
:
:
eNewlinesStripSurroundingWhitespace
:
{
nsString
result
;
uint32_t
offset
=
0
;
while
(
offset
<
aString
.
Length
(
)
)
{
int32_t
nextCRLF
=
aString
.
FindCharInSet
(
CRLF
offset
)
;
if
(
nextCRLF
<
0
)
{
result
.
Append
(
nsDependentSubstring
(
aString
offset
)
)
;
break
;
}
uint32_t
wsBegin
=
nextCRLF
;
while
(
wsBegin
>
offset
&
&
NS_IS_SPACE
(
aString
[
wsBegin
-
1
]
)
)
-
-
wsBegin
;
result
.
Append
(
nsDependentSubstring
(
aString
offset
wsBegin
-
offset
)
)
;
offset
=
nextCRLF
+
1
;
while
(
offset
<
aString
.
Length
(
)
&
&
NS_IS_SPACE
(
aString
[
offset
]
)
)
+
+
offset
;
}
aString
=
result
;
}
break
;
case
nsIPlaintextEditor
:
:
eNewlinesPasteIntact
:
aString
.
Trim
(
CRLF
true
true
)
;
break
;
}
}
nsresult
TextEditRules
:
:
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
inString
-
>
IsEmpty
(
)
&
&
aAction
!
=
EditAction
:
:
insertIMEText
)
{
*
aCancel
=
true
;
*
aHandled
=
false
;
return
NS_OK
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
bool
truncated
=
false
;
nsresult
res
=
TruncateInsertionIfNeeded
(
aSelection
inString
outString
aMaxLength
&
truncated
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
truncated
&
&
outString
-
>
IsEmpty
(
)
&
&
aAction
!
=
EditAction
:
:
insertIMEText
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
int32_t
start
=
0
;
int32_t
end
=
0
;
if
(
IsPasswordEditor
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
}
bool
bCollapsed
;
res
=
aSelection
-
>
GetIsCollapsed
(
&
bCollapsed
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
bCollapsed
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
if
(
IsPasswordEditor
(
)
)
{
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
RemoveIMETextFromPWBuf
(
start
outString
)
;
}
}
if
(
IsSingleLineEditor
(
)
)
{
nsAutoString
tString
(
*
outString
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
HandleNewLines
(
tString
mTextEditor
-
>
mNewlineHandling
)
;
outString
-
>
Assign
(
tString
)
;
}
if
(
IsPasswordEditor
(
)
)
{
mPasswordText
.
Insert
(
*
outString
start
)
;
if
(
LookAndFeel
:
:
GetEchoPassword
(
)
&
&
!
DontEchoPassword
(
)
)
{
HideLastPWInput
(
)
;
mLastStart
=
start
;
mLastLength
=
outString
-
>
Length
(
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
else
{
mTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
&
res
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
mTimer
-
>
InitWithCallback
(
this
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
{
FillBufWithPWChars
(
outString
outString
-
>
Length
(
)
)
;
}
}
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
selNode
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartParent
(
)
;
int32_t
selOffset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_STATE
(
selNode
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
!
mTextEditor
-
>
IsTextNode
(
selNode
)
&
&
!
mTextEditor
-
>
CanContainTag
(
*
selNode
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mTextEditor
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NOT_INITIALIZED
)
;
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
mTextEditor
-
>
FindBetterInsertionPoint
(
selNode
selOffset
)
;
int32_t
IMESelectionOffset
=
mTextEditor
-
>
GetIMESelectionStartOffsetIn
(
selNode
)
;
if
(
IMESelectionOffset
>
=
0
)
{
selOffset
=
IMESelectionOffset
;
}
res
=
mTextEditor
-
>
InsertTextImpl
(
*
outString
address_of
(
selNode
)
&
selOffset
doc
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
nsCOMPtr
<
nsINode
>
curNode
=
selNode
;
int32_t
curOffset
=
selOffset
;
NS_ENSURE_STATE
(
mTextEditor
)
;
AutoTransactionsConserveSelection
dontSpazMySelection
(
mTextEditor
)
;
res
=
mTextEditor
-
>
InsertTextImpl
(
*
outString
address_of
(
curNode
)
&
curOffset
doc
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
curNode
)
{
bool
endsWithLF
=
!
outString
-
>
IsEmpty
(
)
&
&
outString
-
>
Last
(
)
=
=
nsCRT
:
:
LF
;
aSelection
-
>
SetInterlinePosition
(
endsWithLF
)
;
aSelection
-
>
Collapse
(
curNode
curOffset
)
;
}
}
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
return
res
;
}
nsresult
TextEditRules
:
:
DidInsertText
(
Selection
*
aSelection
nsresult
aResult
)
{
return
DidInsert
(
aSelection
aResult
)
;
}
nsresult
TextEditRules
:
:
WillSetTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidSetTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillRemoveTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
IsPlaintextEditor
(
)
)
{
*
aCancel
=
true
;
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidRemoveTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsresult
res
=
NS_OK
;
SelectionBatcher
selectionBatcher
(
aSelection
)
;
AutoHideSelectionChanges
hideSelection
(
aSelection
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
IsPasswordEditor
(
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
ExtendSelectionForDelete
(
aSelection
&
aCollapsedAction
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
int32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
if
(
LookAndFeel
:
:
GetEchoPassword
(
)
)
{
HideLastPWInput
(
)
;
mLastStart
=
start
;
mLastLength
=
0
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
if
(
end
=
=
start
)
{
if
(
nsIEditor
:
:
ePrevious
=
=
aCollapsedAction
&
&
0
<
start
)
{
mPasswordText
.
Cut
(
start
-
1
1
)
;
}
else
if
(
nsIEditor
:
:
eNext
=
=
aCollapsedAction
)
{
mPasswordText
.
Cut
(
start
1
)
;
}
}
else
{
mPasswordText
.
Cut
(
start
end
-
start
)
;
}
}
else
{
nsCOMPtr
<
nsIDOMNode
>
startNode
;
int32_t
startOffset
;
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
bool
bCollapsed
;
res
=
aSelection
-
>
GetIsCollapsed
(
&
bCollapsed
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
bCollapsed
)
return
NS_OK
;
res
=
CheckBidiLevelForDeletion
(
aSelection
startNode
startOffset
aCollapsedAction
aCancel
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
*
aCancel
)
return
NS_OK
;
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
ExtendSelectionForDelete
(
aSelection
&
aCollapsedAction
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
res
=
mTextEditor
-
>
DeleteSelectionImpl
(
aCollapsedAction
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
*
aHandled
=
true
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
nsresult
aResult
)
{
nsCOMPtr
<
nsIDOMNode
>
startNode
;
int32_t
startOffset
;
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
res
=
mTextEditor
-
>
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
if
(
mTextEditor
-
>
IsTextNode
(
startNode
)
)
{
nsCOMPtr
<
nsIDOMText
>
textNode
=
do_QueryInterface
(
startNode
)
;
uint32_t
strLength
;
res
=
textNode
-
>
GetLength
(
&
strLength
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
!
strLength
)
{
res
=
mTextEditor
-
>
DeleteNode
(
startNode
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
}
if
(
!
mDidExplicitlySetInterline
)
{
res
=
aSelection
-
>
SetInterlinePosition
(
true
)
;
}
return
res
;
}
nsresult
TextEditRules
:
:
WillUndo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidUndo
(
Selection
*
aSelection
nsresult
aResult
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_SUCCESS
(
aResult
aResult
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
dom
:
:
Element
*
theRoot
=
mTextEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
theRoot
NS_ERROR_FAILURE
)
;
nsIContent
*
node
=
mTextEditor
-
>
GetLeftmostChild
(
theRoot
)
;
if
(
node
&
&
mTextEditor
-
>
IsMozEditorBogusNode
(
node
)
)
{
mBogusNode
=
do_QueryInterface
(
node
)
;
}
else
{
mBogusNode
=
nullptr
;
}
return
aResult
;
}
nsresult
TextEditRules
:
:
WillRedo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
CANCEL_OPERATION_IF_READONLY_OR_DISABLED
*
aCancel
=
false
;
*
aHandled
=
false
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidRedo
(
Selection
*
aSelection
nsresult
aResult
)
{
nsresult
res
=
aResult
;
if
(
!
aSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
NS_SUCCEEDED
(
res
)
)
{
NS_ENSURE_STATE
(
mTextEditor
)
;
nsCOMPtr
<
nsIDOMElement
>
theRoot
=
do_QueryInterface
(
mTextEditor
-
>
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
theRoot
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMHTMLCollection
>
nodeList
;
res
=
theRoot
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
br
"
)
getter_AddRefs
(
nodeList
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
nodeList
)
{
uint32_t
len
;
nodeList
-
>
GetLength
(
&
len
)
;
if
(
len
!
=
1
)
{
mBogusNode
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
node
;
nodeList
-
>
Item
(
0
getter_AddRefs
(
node
)
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
MOZ_ASSERT
(
content
)
;
if
(
mTextEditor
-
>
IsMozEditorBogusNode
(
content
)
)
{
mBogusNode
=
node
;
}
else
{
mBogusNode
=
nullptr
;
}
}
}
return
res
;
}
nsresult
TextEditRules
:
:
WillOutputText
(
Selection
*
aSelection
const
nsAString
*
aOutputFormat
nsAString
*
aOutString
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aOutString
|
|
!
aOutputFormat
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
nsAutoString
outputFormat
(
*
aOutputFormat
)
;
ToLowerCase
(
outputFormat
)
;
if
(
outputFormat
.
EqualsLiteral
(
"
text
/
plain
"
)
)
{
if
(
IsPasswordEditor
(
)
)
{
*
aOutString
=
mPasswordText
;
*
aHandled
=
true
;
}
else
if
(
mBogusNode
)
{
aOutString
-
>
Truncate
(
)
;
*
aHandled
=
true
;
}
}
return
NS_OK
;
}
nsresult
TextEditRules
:
:
DidOutputText
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
TextEditRules
:
:
RemoveRedundantTrailingBR
(
)
{
if
(
mBogusNode
)
return
NS_OK
;
if
(
IsSingleLineEditor
(
)
)
return
NS_OK
;
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
dom
:
:
Element
>
body
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
!
body
)
return
NS_ERROR_NULL_POINTER
;
uint32_t
childCount
=
body
-
>
GetChildCount
(
)
;
if
(
childCount
>
1
)
{
return
NS_OK
;
}
RefPtr
<
nsIContent
>
child
=
body
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
!
child
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
dom
:
:
Element
*
elem
=
child
-
>
AsElement
(
)
;
if
(
!
TextEditUtils
:
:
IsMozBR
(
elem
)
)
{
return
NS_OK
;
}
elem
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
true
)
;
mBogusNode
=
do_QueryInterface
(
elem
)
;
elem
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateTrailingBRIfNeeded
(
)
{
if
(
IsSingleLineEditor
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
dom
:
:
Element
*
body
=
mTextEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
body
NS_ERROR_NULL_POINTER
)
;
nsIContent
*
lastChild
=
body
-
>
GetLastChild
(
)
;
NS_ENSURE_TRUE
(
lastChild
NS_ERROR_NULL_POINTER
)
;
if
(
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoTransactionsConserveSelection
dontSpazMySelection
(
mTextEditor
)
;
nsCOMPtr
<
nsIDOMNode
>
domBody
=
do_QueryInterface
(
body
)
;
return
CreateMozBR
(
domBody
body
-
>
Length
(
)
)
;
}
if
(
!
mTextEditor
-
>
IsMozEditorBogusNode
(
lastChild
)
)
{
return
NS_OK
;
}
lastChild
-
>
UnsetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
false
)
;
lastChild
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
true
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
CreateBogusNodeIfNeeded
(
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mTextEditor
NS_ERROR_NULL_POINTER
)
;
if
(
mBogusNode
)
{
return
NS_OK
;
}
AutoRules
beginRulesSniffing
(
mTextEditor
EditAction
:
:
ignore
nsIEditor
:
:
eNone
)
;
nsCOMPtr
<
dom
:
:
Element
>
body
=
mTextEditor
-
>
GetRoot
(
)
;
if
(
!
body
)
{
return
NS_OK
;
}
for
(
nsCOMPtr
<
nsIContent
>
bodyChild
=
body
-
>
GetFirstChild
(
)
;
bodyChild
;
bodyChild
=
bodyChild
-
>
GetNextSibling
(
)
)
{
if
(
mTextEditor
-
>
IsMozEditorBogusNode
(
bodyChild
)
|
|
!
mTextEditor
-
>
IsEditable
(
body
)
|
|
mTextEditor
-
>
IsEditable
(
bodyChild
)
|
|
mTextEditor
-
>
IsBlockNode
(
bodyChild
)
)
{
return
NS_OK
;
}
}
if
(
!
mTextEditor
-
>
IsModifiableNode
(
body
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newContent
=
mTextEditor
-
>
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
NS_ENSURE_STATE
(
newContent
)
;
mBogusNode
=
do_QueryInterface
(
newContent
)
;
NS_ENSURE_TRUE
(
mBogusNode
NS_ERROR_NULL_POINTER
)
;
newContent
-
>
SetAttr
(
kNameSpaceID_None
kMOZEditorBogusNodeAttrAtom
kMOZEditorBogusNodeValue
false
)
;
nsCOMPtr
<
nsIDOMNode
>
bodyNode
=
do_QueryInterface
(
body
)
;
nsresult
rv
=
mTextEditor
-
>
InsertNode
(
mBogusNode
bodyNode
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aSelection
-
>
CollapseNative
(
body
0
)
;
return
NS_OK
;
}
nsresult
TextEditRules
:
:
TruncateInsertionIfNeeded
(
Selection
*
aSelection
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
{
if
(
!
aSelection
|
|
!
aInString
|
|
!
aOutString
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsresult
res
=
NS_OK
;
if
(
!
aOutString
-
>
Assign
(
*
aInString
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
aTruncated
)
{
*
aTruncated
=
false
;
}
NS_ENSURE_STATE
(
mTextEditor
)
;
if
(
-
1
!
=
aMaxLength
&
&
IsPlaintextEditor
(
)
&
&
!
mTextEditor
-
>
IsIMEComposing
(
)
)
{
int32_t
docLength
;
res
=
mTextEditor
-
>
GetTextLength
(
&
docLength
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
int32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
aSelection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
TextComposition
*
composition
=
mTextEditor
-
>
GetComposition
(
)
;
int32_t
oldCompStrLength
=
composition
?
composition
-
>
String
(
)
.
Length
(
)
:
0
;
const
int32_t
selectionLength
=
end
-
start
;
const
int32_t
resultingDocLength
=
docLength
-
selectionLength
-
oldCompStrLength
;
if
(
resultingDocLength
>
=
aMaxLength
)
{
aOutString
-
>
Truncate
(
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
else
{
int32_t
oldLength
=
aOutString
-
>
Length
(
)
;
if
(
oldLength
+
resultingDocLength
>
aMaxLength
)
{
int32_t
newLength
=
aMaxLength
-
resultingDocLength
;
MOZ_ASSERT
(
newLength
>
0
)
;
char16_t
newLastChar
=
aOutString
-
>
CharAt
(
newLength
-
1
)
;
char16_t
removingFirstChar
=
aOutString
-
>
CharAt
(
newLength
)
;
if
(
NS_IS_HIGH_SURROGATE
(
newLastChar
)
&
&
NS_IS_LOW_SURROGATE
(
removingFirstChar
)
)
{
newLength
-
-
;
}
aOutString
-
>
Truncate
(
newLength
)
;
if
(
aTruncated
)
{
*
aTruncated
=
true
;
}
}
}
}
return
res
;
}
void
TextEditRules
:
:
ResetIMETextPWBuf
(
)
{
mPasswordIMEText
.
Truncate
(
)
;
}
void
TextEditRules
:
:
RemoveIMETextFromPWBuf
(
int32_t
&
aStart
nsAString
*
aIMEString
)
{
MOZ_ASSERT
(
aIMEString
)
;
if
(
mPasswordIMEText
.
IsEmpty
(
)
)
{
mPasswordIMEIndex
=
aStart
;
}
else
{
mPasswordText
.
Cut
(
mPasswordIMEIndex
mPasswordIMEText
.
Length
(
)
)
;
aStart
=
mPasswordIMEIndex
;
}
mPasswordIMEText
.
Assign
(
*
aIMEString
)
;
}
NS_IMETHODIMP
TextEditRules
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
mTimer
)
;
nsresult
res
=
IsPasswordEditor
(
)
?
HideLastPWInput
(
)
:
NS_OK
;
ASSERT_PASSWORD_LENGTHS_EQUAL
(
)
;
mLastLength
=
0
;
return
res
;
}
nsresult
TextEditRules
:
:
HideLastPWInput
(
)
{
if
(
!
mLastLength
)
{
return
NS_OK
;
}
nsAutoString
hiddenText
;
FillBufWithPWChars
(
&
hiddenText
mLastLength
)
;
NS_ENSURE_STATE
(
mTextEditor
)
;
RefPtr
<
Selection
>
selection
=
mTextEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
int32_t
start
end
;
nsContentUtils
:
:
GetSelectionInTextControl
(
selection
mTextEditor
-
>
GetRoot
(
)
start
end
)
;
nsCOMPtr
<
nsIDOMNode
>
selNode
=
GetTextNode
(
selection
mTextEditor
)
;
NS_ENSURE_TRUE
(
selNode
NS_OK
)
;
nsCOMPtr
<
nsIDOMCharacterData
>
nodeAsText
(
do_QueryInterface
(
selNode
)
)
;
NS_ENSURE_TRUE
(
nodeAsText
NS_OK
)
;
nodeAsText
-
>
ReplaceData
(
mLastStart
mLastLength
hiddenText
)
;
selection
-
>
Collapse
(
selNode
start
)
;
if
(
start
!
=
end
)
selection
-
>
Extend
(
selNode
end
)
;
return
NS_OK
;
}
void
TextEditRules
:
:
FillBufWithPWChars
(
nsAString
*
aOutString
int32_t
aLength
)
{
MOZ_ASSERT
(
aOutString
)
;
char16_t
passwordChar
=
LookAndFeel
:
:
GetPasswordCharacter
(
)
;
int32_t
i
;
aOutString
-
>
Truncate
(
)
;
for
(
i
=
0
;
i
<
aLength
;
i
+
+
)
aOutString
-
>
Append
(
passwordChar
)
;
}
nsresult
TextEditRules
:
:
CreateMozBR
(
nsIDOMNode
*
inParent
int32_t
inOffset
nsIDOMNode
*
*
outBRNode
)
{
NS_ENSURE_TRUE
(
inParent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
brNode
;
NS_ENSURE_STATE
(
mTextEditor
)
;
nsresult
res
=
mTextEditor
-
>
CreateBR
(
inParent
inOffset
address_of
(
brNode
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
nsCOMPtr
<
nsIDOMElement
>
brElem
=
do_QueryInterface
(
brNode
)
;
if
(
brElem
)
{
res
=
mTextEditor
-
>
SetAttribute
(
brElem
NS_LITERAL_STRING
(
"
type
"
)
NS_LITERAL_STRING
(
"
_moz
"
)
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
if
(
outBRNode
)
{
brNode
.
forget
(
outBRNode
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextEditRules
:
:
DocumentModified
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
TextEditRules
:
:
IsPasswordEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPasswordEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsSingleLineEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsSingleLineEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsPlaintextEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsPlaintextEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
IsReadonly
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsReadonly
(
)
:
false
;
}
bool
TextEditRules
:
:
IsDisabled
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsDisabled
(
)
:
false
;
}
bool
TextEditRules
:
:
IsMailEditor
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
IsMailEditor
(
)
:
false
;
}
bool
TextEditRules
:
:
DontEchoPassword
(
)
const
{
return
mTextEditor
?
mTextEditor
-
>
DontEchoPassword
(
)
:
false
;
}
}
