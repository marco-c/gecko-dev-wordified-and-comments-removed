#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
<
string
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
InternetCiter
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
dom
/
Comment
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIParserUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStringIterator
.
h
"
#
include
"
nsTreeSanitizer
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsAtom
;
class
nsILoadContext
;
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
#
define
kInsertCookie
"
_moz_Insert
Here_moz_
"
static
bool
FindIntegerAfterString
(
const
char
*
aLeadingString
nsCString
&
aCStr
int32_t
&
foundNumber
)
;
static
nsresult
RemoveFragComments
(
nsCString
&
theStr
)
;
static
void
RemoveBodyAndHead
(
nsINode
&
aNode
)
;
static
nsresult
FindTargetNode
(
nsINode
*
aStart
nsCOMPtr
<
nsINode
>
&
aResult
)
;
nsresult
HTMLEditor
:
:
LoadHTML
(
const
nsAString
&
aInputString
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
CommitComposition
(
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertHTMLSource
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertHTMLSource
)
;
bool
cancel
handled
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
cancel
)
{
return
NS_OK
;
}
if
(
!
handled
)
{
if
(
!
selection
-
>
IsCollapsed
(
)
)
{
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_NULL_POINTER
)
;
ErrorResult
error
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
aInputString
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
EditorDOMPoint
pointToInsert
(
range
-
>
StartRef
(
)
)
;
Unused
<
<
pointToInsert
.
Offset
(
)
;
for
(
nsCOMPtr
<
nsIContent
>
contentToInsert
=
documentFragment
-
>
GetFirstChild
(
)
;
contentToInsert
;
contentToInsert
=
documentFragment
-
>
GetFirstChild
(
)
)
{
rv
=
InsertNodeWithTransaction
(
*
contentToInsert
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
pointToInsert
.
Offset
(
)
+
1
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
Offset
(
)
)
)
{
pointToInsert
.
SetToEndOf
(
pointToInsert
.
GetContainer
(
)
)
;
}
}
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertHTML
(
const
nsAString
&
aInString
)
{
const
nsString
&
empty
=
EmptyString
(
)
;
return
DoInsertHTMLWithContext
(
aInString
empty
empty
empty
nullptr
nullptr
0
true
true
false
)
;
}
nsresult
HTMLEditor
:
:
DoInsertHTMLWithContext
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
const
nsAString
&
aFlavor
nsIDocument
*
aSourceDoc
nsINode
*
aDestNode
int32_t
aDestOffset
bool
aDeleteSelection
bool
aTrustedInput
bool
aClearStyle
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
CommitComposition
(
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
ePasteHTMLContent
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
nsCOMPtr
<
nsINode
>
fragmentAsNode
streamStartParent
streamEndParent
;
int32_t
streamStartOffset
=
0
streamEndOffset
=
0
;
nsresult
rv
=
CreateDOMFragmentFromPaste
(
aInputString
aContextStr
aInfoStr
address_of
(
fragmentAsNode
)
address_of
(
streamStartParent
)
address_of
(
streamEndParent
)
&
streamStartOffset
&
streamEndOffset
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorDOMPoint
targetPoint
;
if
(
!
aDestNode
)
{
targetPoint
=
EditorBase
:
:
GetStartPoint
(
selection
)
;
if
(
NS_WARN_IF
(
!
targetPoint
.
IsSet
(
)
)
|
|
!
IsEditable
(
targetPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
targetPoint
.
Set
(
aDestNode
aDestOffset
)
;
}
if
(
aDestNode
)
{
if
(
aDeleteSelection
)
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
&
targetPoint
)
;
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
ErrorResult
error
;
selection
-
>
Collapse
(
targetPoint
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeList
;
CreateListOfNodesToPaste
(
*
fragmentAsNode
-
>
AsDocumentFragment
(
)
nodeList
streamStartParent
streamStartOffset
streamEndParent
streamEndOffset
)
;
if
(
nodeList
.
IsEmpty
(
)
)
{
if
(
aDeleteSelection
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
bool
cellSelectionMode
=
false
;
RefPtr
<
Element
>
cell
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
cellSelectionMode
=
true
;
}
if
(
cellSelectionMode
)
{
if
(
!
HTMLEditUtils
:
:
IsTableElement
(
nodeList
[
0
]
)
)
{
cellSelectionMode
=
false
;
}
}
if
(
!
cellSelectionMode
)
{
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aClearStyle
)
{
nsCOMPtr
<
nsINode
>
tmpNode
=
selection
-
>
GetAnchorNode
(
)
;
int32_t
tmpOffset
=
static_cast
<
int32_t
>
(
selection
-
>
AnchorOffset
(
)
)
;
rv
=
ClearStyle
(
address_of
(
tmpNode
)
&
tmpOffset
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
{
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
rv
=
DeleteTableCell
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
selection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertElement
)
;
bool
cancel
handled
;
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
)
{
return
NS_OK
;
}
if
(
!
handled
)
{
EditorDOMPoint
pointToInsert
=
GetBetterInsertionPointFor
(
nodeList
[
0
]
GetStartPoint
(
selection
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
WSRunObject
wsObj
(
this
pointToInsert
)
;
if
(
wsObj
.
mEndReasonNode
&
&
TextEditUtils
:
:
IsBreak
(
wsObj
.
mEndReasonNode
)
&
&
!
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
rv
=
DeleteNodeWithTransaction
(
*
wsObj
.
mEndReasonNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
bool
bStartedInLink
=
IsInLink
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
pointToInsert
.
IsInTextNode
(
)
)
{
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
pointToInsert
.
GetContainerAsContent
(
)
pointToInsert
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
pointToInsert
=
splitNodeResult
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsTArray
<
OwningNonNull
<
Element
>
>
startListAndTableArray
;
GetListAndTableParents
(
StartOrEnd
:
:
start
nodeList
startListAndTableArray
)
;
int32_t
highWaterMark
=
-
1
;
if
(
!
startListAndTableArray
.
IsEmpty
(
)
)
{
highWaterMark
=
DiscoverPartialListsAndTables
(
nodeList
startListAndTableArray
)
;
}
if
(
highWaterMark
>
=
0
)
{
ReplaceOrphanedStructure
(
StartOrEnd
:
:
start
nodeList
startListAndTableArray
highWaterMark
)
;
}
nsTArray
<
OwningNonNull
<
Element
>
>
endListAndTableArray
;
GetListAndTableParents
(
StartOrEnd
:
:
end
nodeList
endListAndTableArray
)
;
highWaterMark
=
-
1
;
if
(
!
endListAndTableArray
.
IsEmpty
(
)
)
{
highWaterMark
=
DiscoverPartialListsAndTables
(
nodeList
endListAndTableArray
)
;
}
if
(
highWaterMark
>
=
0
)
{
ReplaceOrphanedStructure
(
StartOrEnd
:
:
end
nodeList
endListAndTableArray
highWaterMark
)
;
}
MOZ_ASSERT
(
pointToInsert
.
GetContainer
(
)
-
>
GetChildAt_Deprecated
(
pointToInsert
.
Offset
(
)
)
=
=
pointToInsert
.
GetChild
(
)
)
;
nsCOMPtr
<
nsINode
>
parentBlock
=
IsBlockNode
(
pointToInsert
.
GetContainer
(
)
)
?
pointToInsert
.
GetContainer
(
)
:
GetBlockNodeParent
(
pointToInsert
.
GetContainer
(
)
)
;
nsCOMPtr
<
nsIContent
>
lastInsertNode
;
nsCOMPtr
<
nsINode
>
insertedContextParent
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
nodeList
)
{
if
(
NS_WARN_IF
(
curNode
=
=
fragmentAsNode
)
|
|
NS_WARN_IF
(
TextEditUtils
:
:
IsBody
(
curNode
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
insertedContextParent
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
insertedContextParent
)
)
{
continue
;
}
}
bool
bDidInsert
=
false
;
if
(
HTMLEditUtils
:
:
IsTableRow
(
curNode
)
&
&
HTMLEditUtils
:
:
IsTableRow
(
pointToInsert
.
GetContainer
(
)
)
&
&
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsTable
(
pointToInsert
.
GetContainer
(
)
)
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
firstChild
=
curNode
-
>
GetFirstChild
(
)
;
firstChild
;
firstChild
=
curNode
-
>
GetFirstChild
(
)
)
{
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
firstChild
pointToInsert
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
insertedPoint
.
IsSet
(
)
)
)
{
break
;
}
bDidInsert
=
true
;
lastInsertNode
=
firstChild
;
pointToInsert
=
insertedPoint
;
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
&
&
(
HTMLEditUtils
:
:
IsList
(
pointToInsert
.
GetContainer
(
)
)
|
|
HTMLEditUtils
:
:
IsListItem
(
pointToInsert
.
GetContainer
(
)
)
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
firstChild
=
curNode
-
>
GetFirstChild
(
)
;
firstChild
;
firstChild
=
curNode
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
firstChild
)
|
|
HTMLEditUtils
:
:
IsList
(
firstChild
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
pointToInsert
.
GetContainer
(
)
)
)
{
bool
isEmpty
;
rv
=
IsEmptyNode
(
pointToInsert
.
GetContainer
(
)
&
isEmpty
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isEmpty
)
{
if
(
NS_WARN_IF
(
!
pointToInsert
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
}
else
{
DeleteNodeWithTransaction
(
*
pointToInsert
.
GetContainer
(
)
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
;
}
}
}
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
firstChild
pointToInsert
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
insertedPoint
.
IsSet
(
)
)
)
{
break
;
}
bDidInsert
=
true
;
lastInsertNode
=
firstChild
;
pointToInsert
=
insertedPoint
;
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
}
else
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
ErrorResult
error
;
curNode
-
>
RemoveChild
(
*
firstChild
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
}
}
}
}
else
if
(
parentBlock
&
&
HTMLEditUtils
:
:
IsPre
(
parentBlock
)
&
&
HTMLEditUtils
:
:
IsPre
(
curNode
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
firstChild
=
curNode
-
>
GetFirstChild
(
)
;
firstChild
;
firstChild
=
curNode
-
>
GetFirstChild
(
)
)
{
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
firstChild
pointToInsert
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
insertedPoint
.
IsSet
(
)
)
)
{
break
;
}
bDidInsert
=
true
;
lastInsertNode
=
firstChild
;
pointToInsert
=
insertedPoint
;
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
}
}
if
(
!
bDidInsert
|
|
NS_FAILED
(
rv
)
)
{
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
curNode
-
>
AsContent
(
)
pointToInsert
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
insertedPoint
.
IsSet
(
)
)
{
lastInsertNode
=
curNode
-
>
AsContent
(
)
;
pointToInsert
=
insertedPoint
;
}
for
(
nsCOMPtr
<
nsIContent
>
content
=
curNode
-
>
IsContent
(
)
?
curNode
-
>
AsContent
(
)
:
nullptr
;
content
&
&
!
insertedPoint
.
IsSet
(
)
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
NS_WARN_IF
(
!
content
-
>
GetParent
(
)
)
|
|
NS_WARN_IF
(
TextEditUtils
:
:
IsBody
(
content
-
>
GetParent
(
)
)
)
)
{
continue
;
}
nsCOMPtr
<
nsINode
>
oldParent
=
content
-
>
GetParentNode
(
)
;
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
content
-
>
GetParent
(
)
pointToInsert
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
insertedPoint
.
IsSet
(
)
)
{
insertedContextParent
=
oldParent
;
pointToInsert
=
insertedPoint
;
}
}
}
if
(
lastInsertNode
)
{
pointToInsert
.
Set
(
lastInsertNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
}
}
if
(
lastInsertNode
)
{
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
if
(
!
HTMLEditUtils
:
:
IsTable
(
lastInsertNode
)
)
{
selNode
=
GetLastEditableLeaf
(
*
lastInsertNode
)
;
nsINode
*
highTable
=
nullptr
;
for
(
nsINode
*
parent
=
selNode
;
parent
&
&
parent
!
=
lastInsertNode
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
parent
)
)
{
highTable
=
parent
;
}
}
if
(
highTable
)
{
selNode
=
highTable
;
}
}
if
(
!
selNode
)
{
selNode
=
lastInsertNode
;
}
if
(
EditorBase
:
:
IsTextNode
(
selNode
)
|
|
(
IsContainer
(
selNode
)
&
&
!
HTMLEditUtils
:
:
IsTable
(
selNode
)
)
)
{
selOffset
=
selNode
-
>
Length
(
)
;
}
else
{
EditorRawDOMPoint
pointAtContainer
(
selNode
)
;
if
(
NS_WARN_IF
(
!
pointAtContainer
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
selNode
=
pointAtContainer
.
GetContainer
(
)
;
selOffset
=
pointAtContainer
.
Offset
(
)
+
1
;
}
WSRunObject
wsRunObj
(
this
selNode
selOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
outVisOffset
=
0
;
WSType
visType
;
wsRunObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
selNode
selOffset
)
address_of
(
visNode
)
&
outVisOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
br
)
{
if
(
!
IsVisibleBRElement
(
wsRunObj
.
mStartReasonNode
)
)
{
EditorRawDOMPoint
atStartReasonNode
(
wsRunObj
.
mStartReasonNode
)
;
selNode
=
atStartReasonNode
.
GetContainer
(
)
;
selOffset
=
atStartReasonNode
.
Offset
(
)
;
WSRunObject
wsRunObj
(
this
selNode
selOffset
)
;
wsRunObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
selNode
selOffset
)
address_of
(
visNode
)
&
outVisOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
text
|
|
visType
=
=
WSType
:
:
normalWS
)
{
selNode
=
visNode
;
selOffset
=
outVisOffset
;
}
else
if
(
visType
=
=
WSType
:
:
special
)
{
atStartReasonNode
.
Set
(
wsRunObj
.
mStartReasonNode
)
;
selNode
=
atStartReasonNode
.
GetContainer
(
)
;
selOffset
=
atStartReasonNode
.
Offset
(
)
+
1
;
}
}
}
selection
-
>
Collapse
(
selNode
selOffset
)
;
nsCOMPtr
<
nsINode
>
link
;
if
(
!
bStartedInLink
&
&
IsInLink
(
selNode
address_of
(
link
)
)
)
{
nsCOMPtr
<
nsIContent
>
linkContent
=
do_QueryInterface
(
link
)
;
NS_ENSURE_STATE
(
linkContent
|
|
!
link
)
;
SplitNodeResult
splitLinkResult
=
SplitNodeDeepWithTransaction
(
*
linkContent
EditorRawDOMPoint
(
selNode
selOffset
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitLinkResult
.
Succeeded
(
)
"
Failed
to
split
the
link
"
)
;
if
(
splitLinkResult
.
GetPreviousNode
(
)
)
{
EditorRawDOMPoint
afterLeftLink
(
splitLinkResult
.
GetPreviousNode
(
)
)
;
if
(
afterLeftLink
.
AdvanceOffset
(
)
)
{
selection
-
>
Collapse
(
afterLeftLink
)
;
}
}
}
}
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
bool
HTMLEditor
:
:
IsInLink
(
nsINode
*
aNode
nsCOMPtr
<
nsINode
>
*
outLink
)
{
NS_ENSURE_TRUE
(
aNode
false
)
;
if
(
outLink
)
{
*
outLink
=
nullptr
;
}
nsINode
*
node
=
aNode
;
while
(
node
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
node
)
)
{
if
(
outLink
)
{
*
outLink
=
node
;
}
return
true
;
}
node
=
node
-
>
GetParentNode
(
)
;
}
return
false
;
}
nsresult
HTMLEditor
:
:
StripFormattingNodes
(
nsIContent
&
aNode
bool
aListOnly
)
{
if
(
aNode
.
TextIsOnlyWhitespace
(
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
aNode
.
GetParentNode
(
)
;
if
(
parent
)
{
if
(
!
aListOnly
|
|
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
ErrorResult
rv
;
parent
-
>
RemoveChild
(
aNode
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
if
(
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
previous
=
child
-
>
GetPreviousSibling
(
)
;
nsresult
rv
=
StripFormattingNodes
(
*
child
aListOnly
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
previous
.
forget
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PrepareTransferable
(
nsITransferable
*
*
aTransferable
)
{
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PrepareHTMLTransferable
(
nsITransferable
*
*
aTransferable
)
{
nsresult
rv
=
CallCreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
aTransferable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aTransferable
)
{
nsCOMPtr
<
nsIDocument
>
destdoc
=
GetDocument
(
)
;
nsILoadContext
*
loadContext
=
destdoc
?
destdoc
-
>
GetLoadContext
(
)
:
nullptr
;
(
*
aTransferable
)
-
>
Init
(
loadContext
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
(
*
aTransferable
)
-
>
AddDataFlavor
(
kNativeHTMLMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kHTMLMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kFileMime
)
;
switch
(
Preferences
:
:
GetInt
(
"
clipboard
.
paste_image_type
"
1
)
)
{
case
0
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
break
;
case
1
:
default
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
break
;
case
2
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
break
;
}
}
(
*
aTransferable
)
-
>
AddDataFlavor
(
kUnicodeMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kMozTextInternal
)
;
}
return
NS_OK
;
}
bool
FindIntegerAfterString
(
const
char
*
aLeadingString
nsCString
&
aCStr
int32_t
&
foundNumber
)
{
int32_t
numFront
=
aCStr
.
Find
(
aLeadingString
)
;
if
(
numFront
=
=
-
1
)
{
return
false
;
}
numFront
+
=
strlen
(
aLeadingString
)
;
int32_t
numBack
=
aCStr
.
FindCharInSet
(
CRLF
numFront
)
;
if
(
numBack
=
=
-
1
)
{
return
false
;
}
nsAutoCString
numStr
(
Substring
(
aCStr
numFront
numBack
-
numFront
)
)
;
nsresult
errorCode
;
foundNumber
=
numStr
.
ToInteger
(
&
errorCode
)
;
return
true
;
}
nsresult
RemoveFragComments
(
nsCString
&
aStr
)
{
int32_t
startCommentIndx
=
aStr
.
Find
(
"
<
!
-
-
StartFragment
"
)
;
if
(
startCommentIndx
>
=
0
)
{
int32_t
startCommentEnd
=
aStr
.
Find
(
"
-
-
>
"
false
startCommentIndx
)
;
if
(
startCommentEnd
>
startCommentIndx
)
{
aStr
.
Cut
(
startCommentIndx
(
startCommentEnd
+
3
)
-
startCommentIndx
)
;
}
}
int32_t
endCommentIndx
=
aStr
.
Find
(
"
<
!
-
-
EndFragment
"
)
;
if
(
endCommentIndx
>
=
0
)
{
int32_t
endCommentEnd
=
aStr
.
Find
(
"
-
-
>
"
false
endCommentIndx
)
;
if
(
endCommentEnd
>
endCommentIndx
)
{
aStr
.
Cut
(
endCommentIndx
(
endCommentEnd
+
3
)
-
endCommentIndx
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ParseCFHTML
(
nsCString
&
aCfhtml
char16_t
*
*
aStuffToPaste
char16_t
*
*
aCfcontext
)
{
int32_t
startHTML
endHTML
startFragment
endFragment
;
if
(
!
FindIntegerAfterString
(
"
StartHTML
:
"
aCfhtml
startHTML
)
|
|
startHTML
<
-
1
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
FindIntegerAfterString
(
"
EndHTML
:
"
aCfhtml
endHTML
)
|
|
endHTML
<
-
1
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
FindIntegerAfterString
(
"
StartFragment
:
"
aCfhtml
startFragment
)
|
|
startFragment
<
0
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
FindIntegerAfterString
(
"
EndFragment
:
"
aCfhtml
endFragment
)
|
|
startFragment
<
0
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startHTML
=
=
-
1
)
{
startHTML
=
aCfhtml
.
Find
(
"
<
!
-
-
StartFragment
-
-
>
"
)
;
if
(
startHTML
=
=
-
1
)
{
return
NS_OK
;
}
}
if
(
endHTML
=
=
-
1
)
{
const
char
endFragmentMarker
[
]
=
"
<
!
-
-
EndFragment
-
-
>
"
;
endHTML
=
aCfhtml
.
Find
(
endFragmentMarker
)
;
if
(
endHTML
=
=
-
1
)
{
return
NS_OK
;
}
endHTML
+
=
ArrayLength
(
endFragmentMarker
)
-
1
;
}
nsAutoCString
contextUTF8
(
Substring
(
aCfhtml
startHTML
startFragment
-
startHTML
)
+
NS_LITERAL_CSTRING
(
"
<
!
-
-
"
kInsertCookie
"
-
-
>
"
)
+
Substring
(
aCfhtml
endFragment
endHTML
-
endFragment
)
)
;
int32_t
curPos
=
startFragment
;
while
(
curPos
>
startHTML
)
{
if
(
aCfhtml
[
curPos
]
=
=
'
>
'
)
{
break
;
}
if
(
aCfhtml
[
curPos
]
=
=
'
<
'
)
{
if
(
curPos
!
=
startFragment
)
{
NS_ERROR
(
"
StartFragment
byte
count
in
the
clipboard
looks
bad
see
bug
#
228879
"
)
;
startFragment
=
curPos
-
1
;
}
break
;
}
curPos
-
-
;
}
nsAutoCString
fragmentUTF8
(
Substring
(
aCfhtml
startFragment
endFragment
-
startFragment
)
)
;
RemoveFragComments
(
fragmentUTF8
)
;
RemoveFragComments
(
contextUTF8
)
;
const
nsString
&
fragUcs2Str
=
NS_ConvertUTF8toUTF16
(
fragmentUTF8
)
;
const
nsString
&
cntxtUcs2Str
=
NS_ConvertUTF8toUTF16
(
contextUTF8
)
;
int32_t
oldLengthInChars
=
fragUcs2Str
.
Length
(
)
+
1
;
int32_t
newLengthInChars
=
0
;
*
aStuffToPaste
=
nsLinebreakConverter
:
:
ConvertUnicharLineBreaks
(
fragUcs2Str
.
get
(
)
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
oldLengthInChars
&
newLengthInChars
)
;
NS_ENSURE_TRUE
(
*
aStuffToPaste
NS_ERROR_FAILURE
)
;
oldLengthInChars
=
cntxtUcs2Str
.
Length
(
)
+
1
;
newLengthInChars
=
0
;
*
aCfcontext
=
nsLinebreakConverter
:
:
ConvertUnicharLineBreaks
(
cntxtUcs2Str
.
get
(
)
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
oldLengthInChars
&
newLengthInChars
)
;
return
NS_OK
;
}
static
nsresult
ImgFromData
(
const
nsACString
&
aType
const
nsACString
&
aData
nsString
&
aOutput
)
{
nsAutoCString
data64
;
nsresult
rv
=
Base64Encode
(
aData
data64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOutput
.
AssignLiteral
(
"
<
IMG
src
=
\
"
data
:
"
)
;
AppendUTF8toUTF16
(
aType
aOutput
)
;
aOutput
.
AppendLiteral
(
"
;
base64
"
)
;
if
(
!
AppendASCIItoUTF16
(
data64
aOutput
fallible_t
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aOutput
.
AppendLiteral
(
"
\
"
alt
=
\
"
\
"
>
"
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
HTMLEditor
:
:
BlobReader
nsIEditorBlobListener
)
HTMLEditor
:
:
BlobReader
:
:
BlobReader
(
BlobImpl
*
aBlob
HTMLEditor
*
aHTMLEditor
bool
aIsSafe
nsIDocument
*
aSourceDoc
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
:
mBlob
(
aBlob
)
mHTMLEditor
(
aHTMLEditor
)
mIsSafe
(
aIsSafe
)
mSourceDoc
(
aSourceDoc
)
mDestinationNode
(
aDestinationNode
)
mDestOffset
(
aDestOffset
)
mDoDeleteSelection
(
aDoDeleteSelection
)
{
MOZ_ASSERT
(
mBlob
)
;
MOZ_ASSERT
(
mHTMLEditor
)
;
MOZ_ASSERT
(
mDestinationNode
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BlobReader
:
:
OnResult
(
const
nsACString
&
aResult
)
{
nsString
blobType
;
mBlob
-
>
GetType
(
blobType
)
;
NS_ConvertUTF16toUTF8
type
(
blobType
)
;
nsAutoString
stuffToPaste
;
nsresult
rv
=
ImgFromData
(
type
aResult
stuffToPaste
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoPlaceholderBatch
beginBatching
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DoInsertHTMLWithContext
(
stuffToPaste
EmptyString
(
)
EmptyString
(
)
NS_LITERAL_STRING
(
kFileMime
)
mSourceDoc
mDestinationNode
mDestOffset
mDoDeleteSelection
mIsSafe
false
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BlobReader
:
:
OnError
(
const
nsAString
&
aError
)
{
const
nsPromiseFlatString
&
flat
=
PromiseFlatString
(
aError
)
;
const
char16_t
*
error
=
flat
.
get
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Editor
"
)
mDestinationNode
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
EditorFileDropFailed
"
&
error
1
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertObject
(
const
nsACString
&
aType
nsISupports
*
aObject
bool
aIsSafe
nsIDocument
*
aSourceDoc
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
{
nsresult
rv
;
if
(
nsCOMPtr
<
BlobImpl
>
blob
=
do_QueryInterface
(
aObject
)
)
{
RefPtr
<
BlobReader
>
br
=
new
BlobReader
(
blob
this
aIsSafe
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
nsCOMPtr
<
nsIEditorUtils
>
utils
=
do_GetService
(
"
mozilla
.
org
/
editor
-
utils
;
1
"
)
;
NS_ENSURE_TRUE
(
utils
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aDestinationNode
)
;
MOZ_ASSERT
(
node
)
;
RefPtr
<
Blob
>
domBlob
=
Blob
:
:
Create
(
node
-
>
GetOwnerGlobal
(
)
blob
)
;
NS_ENSURE_TRUE
(
domBlob
NS_ERROR_FAILURE
)
;
return
utils
-
>
SlurpBlob
(
domBlob
node
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
br
)
;
}
nsAutoCString
type
(
aType
)
;
bool
insertAsImage
=
false
;
nsCOMPtr
<
nsIFile
>
fileObj
;
if
(
type
.
EqualsLiteral
(
kFileMime
)
)
{
fileObj
=
do_QueryInterface
(
aObject
)
;
if
(
fileObj
)
{
if
(
nsContentUtils
:
:
IsFileImage
(
fileObj
type
)
)
{
insertAsImage
=
true
;
}
else
{
type
.
AssignLiteral
(
kFileMime
)
;
}
}
}
if
(
type
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
type
.
EqualsLiteral
(
kJPGImageMime
)
|
|
type
.
EqualsLiteral
(
kPNGImageMime
)
|
|
type
.
EqualsLiteral
(
kGIFImageMime
)
|
|
insertAsImage
)
{
nsCString
imageData
;
if
(
insertAsImage
)
{
rv
=
nsContentUtils
:
:
SlurpFileToString
(
fileObj
imageData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIInputStream
>
imageStream
=
do_QueryInterface
(
aObject
)
;
NS_ENSURE_TRUE
(
imageStream
NS_ERROR_FAILURE
)
;
rv
=
NS_ConsumeStream
(
imageStream
UINT32_MAX
imageData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
imageStream
-
>
Close
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsAutoString
stuffToPaste
;
rv
=
ImgFromData
(
type
imageData
stuffToPaste
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
rv
=
DoInsertHTMLWithContext
(
stuffToPaste
EmptyString
(
)
EmptyString
(
)
NS_LITERAL_STRING
(
kFileMime
)
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
aIsSafe
false
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertFromTransferable
(
nsITransferable
*
transferable
nsIDocument
*
aSourceDoc
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
bool
havePrivateHTMLFlavor
bool
aDoDeleteSelection
)
{
nsresult
rv
=
NS_OK
;
nsAutoCString
bestFlavor
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
uint32_t
len
=
0
;
if
(
NS_SUCCEEDED
(
transferable
-
>
GetAnyTransferData
(
bestFlavor
getter_AddRefs
(
genericDataObj
)
&
len
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
this
)
;
nsAutoString
flavor
;
CopyASCIItoUTF16
(
bestFlavor
flavor
)
;
nsAutoString
stuffToPaste
;
bool
isSafe
=
IsSafeToInsertData
(
aSourceDoc
)
;
if
(
bestFlavor
.
EqualsLiteral
(
kFileMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kJPGImageMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kPNGImageMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kGIFImageMime
)
)
{
rv
=
InsertObject
(
bestFlavor
genericDataObj
isSafe
aSourceDoc
nullptr
0
aDoDeleteSelection
)
;
}
else
if
(
bestFlavor
.
EqualsLiteral
(
kNativeHTMLMime
)
)
{
nsCOMPtr
<
nsISupportsCString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoCString
cfhtml
;
textDataObj
-
>
GetData
(
cfhtml
)
;
NS_ASSERTION
(
cfhtml
.
Length
(
)
<
=
(
len
)
"
Invalid
length
!
"
)
;
nsString
cfcontext
cffragment
cfselection
;
rv
=
ParseCFHTML
(
cfhtml
getter_Copies
(
cffragment
)
getter_Copies
(
cfcontext
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
cffragment
.
IsEmpty
(
)
)
{
AutoPlaceholderBatch
beginBatching
(
this
)
;
if
(
havePrivateHTMLFlavor
)
{
rv
=
DoInsertHTMLWithContext
(
cffragment
aContextStr
aInfoStr
flavor
aSourceDoc
nullptr
0
aDoDeleteSelection
isSafe
)
;
}
else
{
rv
=
DoInsertHTMLWithContext
(
cffragment
cfcontext
cfselection
flavor
aSourceDoc
nullptr
0
aDoDeleteSelection
isSafe
)
;
}
}
else
{
bestFlavor
.
AssignLiteral
(
kHTMLMime
)
;
}
}
}
if
(
bestFlavor
.
EqualsLiteral
(
kHTMLMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kUnicodeMime
)
|
|
bestFlavor
.
EqualsLiteral
(
kMozTextInternal
)
)
{
nsCOMPtr
<
nsISupportsString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoString
text
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
len
/
2
)
"
Invalid
length
!
"
)
;
stuffToPaste
.
Assign
(
text
.
get
(
)
len
/
2
)
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
textDataObj
(
do_QueryInterface
(
genericDataObj
)
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoCString
text
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
len
"
Invalid
length
!
"
)
;
stuffToPaste
.
Assign
(
NS_ConvertUTF8toUTF16
(
Substring
(
text
0
len
)
)
)
;
}
}
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
AutoPlaceholderBatch
beginBatching
(
this
)
;
if
(
bestFlavor
.
EqualsLiteral
(
kHTMLMime
)
)
{
rv
=
DoInsertHTMLWithContext
(
stuffToPaste
aContextStr
aInfoStr
flavor
aSourceDoc
nullptr
0
aDoDeleteSelection
isSafe
)
;
}
else
{
rv
=
InsertTextAt
(
stuffToPaste
nullptr
0
aDoDeleteSelection
)
;
}
}
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
ScrollSelectionIntoView
(
false
)
;
}
return
rv
;
}
static
void
GetStringFromDataTransfer
(
DataTransfer
*
aDataTransfer
const
nsAString
&
aType
int32_t
aIndex
nsAString
&
aOutputString
)
{
nsCOMPtr
<
nsIVariant
>
variant
;
aDataTransfer
-
>
GetDataAtNoSecurityCheck
(
aType
aIndex
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
{
variant
-
>
GetAsAString
(
aOutputString
)
;
}
}
nsresult
HTMLEditor
:
:
InsertFromDataTransfer
(
DataTransfer
*
aDataTransfer
int32_t
aIndex
nsIDocument
*
aSourceDoc
nsINode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
{
ErrorResult
rv
;
RefPtr
<
DOMStringList
>
types
=
aDataTransfer
-
>
MozTypesAt
(
aIndex
CallerType
:
:
System
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
bool
hasPrivateHTMLFlavor
=
types
-
>
Contains
(
NS_LITERAL_STRING
(
kHTMLContext
)
)
;
bool
isText
=
IsPlaintextEditor
(
)
;
bool
isSafe
=
IsSafeToInsertData
(
aSourceDoc
)
;
uint32_t
length
=
types
-
>
Length
(
)
;
for
(
uint32_t
t
=
0
;
t
<
length
;
t
+
+
)
{
nsAutoString
type
;
types
-
>
Item
(
t
type
)
;
if
(
!
isText
)
{
if
(
type
.
EqualsLiteral
(
kFileMime
)
|
|
type
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
type
.
EqualsLiteral
(
kJPGImageMime
)
|
|
type
.
EqualsLiteral
(
kPNGImageMime
)
|
|
type
.
EqualsLiteral
(
kGIFImageMime
)
)
{
nsCOMPtr
<
nsIVariant
>
variant
;
aDataTransfer
-
>
GetDataAtNoSecurityCheck
(
type
aIndex
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
{
nsCOMPtr
<
nsISupports
>
object
;
variant
-
>
GetAsISupports
(
getter_AddRefs
(
object
)
)
;
return
InsertObject
(
NS_ConvertUTF16toUTF8
(
type
)
object
isSafe
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
}
else
if
(
type
.
EqualsLiteral
(
kNativeHTMLMime
)
)
{
nsAutoString
text
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
NS_ConvertUTF16toUTF8
cfhtml
(
text
)
;
nsString
cfcontext
cffragment
cfselection
;
nsresult
rv
=
ParseCFHTML
(
cfhtml
getter_Copies
(
cffragment
)
getter_Copies
(
cfcontext
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
cffragment
.
IsEmpty
(
)
)
{
AutoPlaceholderBatch
beginBatching
(
this
)
;
if
(
hasPrivateHTMLFlavor
)
{
nsAutoString
contextString
infoString
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLContext
)
aIndex
contextString
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLInfo
)
aIndex
infoString
)
;
return
DoInsertHTMLWithContext
(
cffragment
contextString
infoString
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
else
{
return
DoInsertHTMLWithContext
(
cffragment
cfcontext
cfselection
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
}
}
else
if
(
type
.
EqualsLiteral
(
kHTMLMime
)
)
{
nsAutoString
text
contextString
infoString
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLContext
)
aIndex
contextString
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLInfo
)
aIndex
infoString
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
if
(
type
.
EqualsLiteral
(
kHTMLMime
)
)
{
return
DoInsertHTMLWithContext
(
text
contextString
infoString
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
}
}
if
(
type
.
EqualsLiteral
(
kTextMime
)
|
|
type
.
EqualsLiteral
(
kMozTextInternal
)
)
{
nsAutoString
text
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
return
InsertTextAt
(
text
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
HavePrivateHTMLFlavor
(
nsIClipboard
*
aClipboard
)
{
NS_ENSURE_TRUE
(
aClipboard
false
)
;
bool
bHavePrivateHTMLFlavor
=
false
;
const
char
*
flavArray
[
]
=
{
kHTMLContext
}
;
if
(
NS_SUCCEEDED
(
aClipboard
-
>
HasDataMatchingFlavors
(
flavArray
ArrayLength
(
flavArray
)
nsIClipboard
:
:
kGlobalClipboard
&
bHavePrivateHTMLFlavor
)
)
)
{
return
bHavePrivateHTMLFlavor
;
}
return
false
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Paste
(
int32_t
aSelectionType
)
{
if
(
!
FireClipboardEvent
(
ePaste
aSelectionType
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
;
rv
=
PrepareHTMLTransferable
(
getter_AddRefs
(
trans
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
trans
NS_ERROR_FAILURE
)
;
rv
=
clipboard
-
>
GetData
(
trans
aSelectionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsAutoString
contextStr
infoStr
;
bool
bHavePrivateHTMLFlavor
=
HavePrivateHTMLFlavor
(
clipboard
)
;
if
(
bHavePrivateHTMLFlavor
)
{
nsCOMPtr
<
nsISupports
>
contextDataObj
infoDataObj
;
uint32_t
contextLen
infoLen
;
nsCOMPtr
<
nsISupportsString
>
textDataObj
;
nsCOMPtr
<
nsITransferable
>
contextTrans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
NS_ENSURE_TRUE
(
contextTrans
NS_ERROR_NULL_POINTER
)
;
contextTrans
-
>
Init
(
nullptr
)
;
contextTrans
-
>
AddDataFlavor
(
kHTMLContext
)
;
clipboard
-
>
GetData
(
contextTrans
aSelectionType
)
;
contextTrans
-
>
GetTransferData
(
kHTMLContext
getter_AddRefs
(
contextDataObj
)
&
contextLen
)
;
nsCOMPtr
<
nsITransferable
>
infoTrans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
NS_ENSURE_TRUE
(
infoTrans
NS_ERROR_NULL_POINTER
)
;
infoTrans
-
>
Init
(
nullptr
)
;
infoTrans
-
>
AddDataFlavor
(
kHTMLInfo
)
;
clipboard
-
>
GetData
(
infoTrans
aSelectionType
)
;
infoTrans
-
>
GetTransferData
(
kHTMLInfo
getter_AddRefs
(
infoDataObj
)
&
infoLen
)
;
if
(
contextDataObj
)
{
nsAutoString
text
;
textDataObj
=
do_QueryInterface
(
contextDataObj
)
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
contextLen
/
2
)
"
Invalid
length
!
"
)
;
contextStr
.
Assign
(
text
.
get
(
)
contextLen
/
2
)
;
}
if
(
infoDataObj
)
{
nsAutoString
text
;
textDataObj
=
do_QueryInterface
(
infoDataObj
)
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
infoLen
/
2
)
"
Invalid
length
!
"
)
;
infoStr
.
Assign
(
text
.
get
(
)
infoLen
/
2
)
;
}
}
return
InsertFromTransferable
(
trans
nullptr
contextStr
infoStr
bHavePrivateHTMLFlavor
true
)
;
}
nsresult
HTMLEditor
:
:
PasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
FireClipboardEvent
(
ePaste
nsIClipboard
:
:
kGlobalClipboard
)
)
{
return
NS_OK
;
}
nsAutoString
contextStr
infoStr
;
return
InsertFromTransferable
(
aTransferable
nullptr
contextStr
infoStr
false
true
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteNoFormatting
(
int32_t
aSelectionType
)
{
if
(
!
FireClipboardEvent
(
ePasteNoFormatting
aSelectionType
)
)
{
return
NS_OK
;
}
CommitComposition
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
;
rv
=
TextEditor
:
:
PrepareTransferable
(
getter_AddRefs
(
trans
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
trans
)
{
if
(
NS_SUCCEEDED
(
clipboard
-
>
GetData
(
trans
aSelectionType
)
)
&
&
IsModifiable
(
)
)
{
const
nsString
&
empty
=
EmptyString
(
)
;
rv
=
InsertFromTransferable
(
trans
nullptr
empty
empty
false
true
)
;
}
}
return
rv
;
}
static
const
char
*
textEditorFlavors
[
]
=
{
kUnicodeMime
}
;
static
const
char
*
textHtmlEditorFlavors
[
]
=
{
kUnicodeMime
kHTMLMime
kJPEGImageMime
kJPGImageMime
kPNGImageMime
kGIFImageMime
}
;
NS_IMETHODIMP
HTMLEditor
:
:
CanPaste
(
int32_t
aSelectionType
bool
*
aCanPaste
)
{
NS_ENSURE_ARG_POINTER
(
aCanPaste
)
;
*
aCanPaste
=
false
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
if
(
doc
&
&
doc
-
>
IsHTMLOrXHTML
(
)
)
{
*
aCanPaste
=
true
;
return
NS_OK
;
}
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
haveFlavors
;
if
(
IsPlaintextEditor
(
)
)
{
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textEditorFlavors
ArrayLength
(
textEditorFlavors
)
aSelectionType
&
haveFlavors
)
;
}
else
{
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textHtmlEditorFlavors
ArrayLength
(
textHtmlEditorFlavors
)
aSelectionType
&
haveFlavors
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCanPaste
=
haveFlavors
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
CanPasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
IsModifiable
(
)
)
{
return
false
;
}
if
(
!
aTransferable
)
{
return
true
;
}
const
char
*
*
flavors
;
size_t
length
;
if
(
IsPlaintextEditor
(
)
)
{
flavors
=
textEditorFlavors
;
length
=
ArrayLength
(
textEditorFlavors
)
;
}
else
{
flavors
=
textHtmlEditorFlavors
;
length
=
ArrayLength
(
textHtmlEditorFlavors
)
;
}
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
flavors
+
+
)
{
nsCOMPtr
<
nsISupports
>
data
;
uint32_t
dataLen
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
*
flavors
getter_AddRefs
(
data
)
&
dataLen
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
data
)
{
return
true
;
}
}
return
false
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteAsQuotation
(
int32_t
aSelectionType
)
{
if
(
IsPlaintextEditor
(
)
)
{
return
PasteAsPlaintextQuotation
(
aSelectionType
)
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertQuotation
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertElement
)
;
bool
cancel
handled
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
blockquote
)
;
if
(
NS_WARN_IF
(
!
newNode
)
)
{
return
NS_ERROR_FAILURE
;
}
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
cite
"
)
true
)
;
rv
=
selection
-
>
Collapse
(
newNode
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
Paste
(
aSelectionType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PasteAsPlaintextQuotation
(
int32_t
aSelectionType
)
{
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
trans
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
destdoc
=
GetDocument
(
)
;
nsILoadContext
*
loadContext
=
destdoc
?
destdoc
-
>
GetLoadContext
(
)
:
nullptr
;
trans
-
>
Init
(
loadContext
)
;
trans
-
>
AddDataFlavor
(
kUnicodeMime
)
;
clipboard
-
>
GetData
(
trans
aSelectionType
)
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
uint32_t
len
=
0
;
nsAutoCString
flav
;
rv
=
trans
-
>
GetAnyTransferData
(
flav
getter_AddRefs
(
genericDataObj
)
&
len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
flav
.
EqualsLiteral
(
kUnicodeMime
)
)
{
nsCOMPtr
<
nsISupportsString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoString
stuffToPaste
;
textDataObj
-
>
GetData
(
stuffToPaste
)
;
NS_ASSERTION
(
stuffToPaste
.
Length
(
)
<
=
(
len
/
2
)
"
Invalid
length
!
"
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
rv
=
InsertAsPlaintextQuotation
(
stuffToPaste
true
0
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTextWithQuotations
(
const
nsAString
&
aStringToInsert
)
{
BeginTransaction
(
)
;
static
const
char16_t
cite
(
'
>
'
)
;
bool
curHunkIsQuoted
=
(
aStringToInsert
.
First
(
)
=
=
cite
)
;
nsAString
:
:
const_iterator
hunkStart
strEnd
;
aStringToInsert
.
BeginReading
(
hunkStart
)
;
aStringToInsert
.
EndReading
(
strEnd
)
;
#
ifdef
DEBUG
nsAString
:
:
const_iterator
dbgStart
(
hunkStart
)
;
if
(
FindCharInReadable
(
'
\
r
'
dbgStart
strEnd
)
)
{
NS_ASSERTION
(
false
"
Return
characters
in
DOM
!
InsertTextWithQuotations
may
be
wrong
"
)
;
}
#
endif
nsresult
rv
=
NS_OK
;
nsAString
:
:
const_iterator
lineStart
(
hunkStart
)
;
for
(
;
;
)
{
bool
found
=
FindCharInReadable
(
'
\
n
'
lineStart
strEnd
)
;
bool
quoted
=
false
;
if
(
found
)
{
nsAString
:
:
const_iterator
firstNewline
(
lineStart
)
;
while
(
*
lineStart
=
=
'
\
n
'
)
{
+
+
lineStart
;
}
quoted
=
(
*
lineStart
=
=
cite
)
;
if
(
quoted
=
=
curHunkIsQuoted
)
{
continue
;
}
if
(
curHunkIsQuoted
)
{
lineStart
=
firstNewline
;
lineStart
+
+
;
}
}
const
nsAString
&
curHunk
=
Substring
(
hunkStart
lineStart
)
;
nsCOMPtr
<
nsINode
>
dummyNode
;
if
(
curHunkIsQuoted
)
{
rv
=
InsertAsPlaintextQuotation
(
curHunk
false
getter_AddRefs
(
dummyNode
)
)
;
}
else
{
rv
=
InsertTextAsAction
(
curHunk
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
a
line
of
the
quoted
text
"
)
;
}
if
(
!
found
)
{
break
;
}
curHunkIsQuoted
=
quoted
;
hunkStart
=
lineStart
;
}
EndTransaction
(
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertAsQuotation
(
const
nsAString
&
aQuotedText
nsINode
*
*
aNodeInserted
)
{
if
(
IsPlaintextEditor
(
)
)
{
return
InsertAsPlaintextQuotation
(
aQuotedText
true
aNodeInserted
)
;
}
nsAutoString
citation
;
return
InsertAsCitedQuotation
(
aQuotedText
citation
false
aNodeInserted
)
;
}
nsresult
HTMLEditor
:
:
InsertAsPlaintextQuotation
(
const
nsAString
&
aQuotedText
bool
aAddCites
nsINode
*
*
aNodeInserted
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertQuotation
nsIEditor
:
:
eNext
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertElement
)
;
bool
cancel
handled
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
span
)
;
if
(
newNode
)
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozquote
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
nsCOMPtr
<
nsINode
>
parent
=
newNode
-
>
GetParentNode
(
)
;
if
(
parent
&
&
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
NS_LITERAL_STRING
(
"
white
-
space
:
pre
-
wrap
;
display
:
block
;
width
:
98vw
;
"
)
true
)
;
}
else
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
NS_LITERAL_STRING
(
"
white
-
space
:
pre
-
wrap
;
"
)
true
)
;
}
selection
-
>
Collapse
(
newNode
0
)
;
}
if
(
aAddCites
)
{
rv
=
TextEditor
:
:
InsertAsQuotation
(
aQuotedText
aNodeInserted
)
;
}
else
{
rv
=
InsertTextAsAction
(
aQuotedText
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
quoted
text
as
plain
text
"
)
;
}
if
(
aNodeInserted
&
&
NS_SUCCEEDED
(
rv
)
)
{
*
aNodeInserted
=
newNode
;
NS_IF_ADDREF
(
*
aNodeInserted
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
newNode
)
{
EditorRawDOMPoint
afterNewNode
(
newNode
)
;
if
(
afterNewNode
.
AdvanceOffset
(
)
)
{
selection
-
>
Collapse
(
afterNewNode
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Rewrap
(
bool
aRespectNewlines
)
{
int32_t
wrapWidth
=
WrapWidth
(
)
;
if
(
wrapWidth
<
=
0
)
{
wrapWidth
=
72
;
}
nsAutoString
current
;
bool
isCollapsed
;
nsresult
rv
=
SharedOutputString
(
nsIDocumentEncoder
:
:
OutputFormatted
|
nsIDocumentEncoder
:
:
OutputLFLineBreak
&
isCollapsed
current
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
wrapped
;
uint32_t
firstLineOffset
=
0
;
rv
=
InternetCiter
:
:
Rewrap
(
current
wrapWidth
firstLineOffset
aRespectNewlines
wrapped
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isCollapsed
)
{
DebugOnly
<
nsresult
>
rv
=
SelectAllInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
select
all
text
"
)
;
}
return
InsertTextWithQuotations
(
wrapped
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertAsCitedQuotation
(
const
nsAString
&
aQuotedText
const
nsAString
&
aCitation
bool
aInsertHTML
nsINode
*
*
aNodeInserted
)
{
if
(
IsPlaintextEditor
(
)
)
{
NS_ASSERTION
(
!
aInsertHTML
"
InsertAsCitedQuotation
:
trying
to
insert
html
into
plaintext
editor
"
)
;
return
InsertAsPlaintextQuotation
(
aQuotedText
true
aNodeInserted
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertQuotation
nsIEditor
:
:
eNext
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertElement
)
;
bool
cancel
handled
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
blockquote
)
;
NS_ENSURE_TRUE
(
newNode
NS_ERROR_NULL_POINTER
)
;
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
cite
"
)
true
)
;
if
(
!
aCitation
.
IsEmpty
(
)
)
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
cite
aCitation
true
)
;
}
selection
-
>
Collapse
(
newNode
0
)
;
if
(
aInsertHTML
)
{
rv
=
LoadHTML
(
aQuotedText
)
;
}
else
{
rv
=
InsertTextAsAction
(
aQuotedText
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
quoted
text
"
)
;
}
if
(
aNodeInserted
&
&
NS_SUCCEEDED
(
rv
)
)
{
*
aNodeInserted
=
newNode
;
NS_IF_ADDREF
(
*
aNodeInserted
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
newNode
)
{
EditorRawDOMPoint
afterNewNode
(
newNode
)
;
if
(
afterNewNode
.
AdvanceOffset
(
)
)
{
selection
-
>
Collapse
(
afterNewNode
)
;
}
}
return
rv
;
}
void
RemoveBodyAndHead
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
body
head
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
body
=
child
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
head
)
)
{
head
=
child
;
}
}
if
(
head
)
{
ErrorResult
ignored
;
aNode
.
RemoveChild
(
*
head
ignored
)
;
}
if
(
body
)
{
nsCOMPtr
<
nsIContent
>
child
=
body
-
>
GetFirstChild
(
)
;
while
(
child
)
{
ErrorResult
ignored
;
aNode
.
InsertBefore
(
*
child
body
ignored
)
;
child
=
body
-
>
GetFirstChild
(
)
;
}
ErrorResult
ignored
;
aNode
.
RemoveChild
(
*
body
ignored
)
;
}
}
nsresult
FindTargetNode
(
nsINode
*
aStart
nsCOMPtr
<
nsINode
>
&
aResult
)
{
NS_ENSURE_TRUE
(
aStart
NS_OK
)
;
nsCOMPtr
<
nsINode
>
child
=
aStart
-
>
GetFirstChild
(
)
;
if
(
!
child
)
{
if
(
!
aResult
)
{
aResult
=
aStart
;
}
return
NS_OK
;
}
do
{
if
(
auto
*
comment
=
Comment
:
:
FromNode
(
child
)
)
{
nsAutoString
data
;
comment
-
>
GetData
(
data
)
;
if
(
data
.
EqualsLiteral
(
kInsertCookie
)
)
{
aResult
=
aStart
;
child
-
>
Remove
(
)
;
return
NS_SUCCESS_EDITOR_FOUND_TARGET
;
}
}
nsresult
rv
=
FindTargetNode
(
child
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
=
=
NS_SUCCESS_EDITOR_FOUND_TARGET
)
{
return
NS_SUCCESS_EDITOR_FOUND_TARGET
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
while
(
child
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CreateDOMFragmentFromPaste
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
nsCOMPtr
<
nsINode
>
*
outFragNode
nsCOMPtr
<
nsINode
>
*
outStartNode
nsCOMPtr
<
nsINode
>
*
outEndNode
int32_t
*
outStartOffset
int32_t
*
outEndOffset
bool
aTrustedInput
)
{
NS_ENSURE_TRUE
(
outFragNode
&
&
outStartNode
&
&
outEndNode
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINode
>
contextLeaf
;
RefPtr
<
DocumentFragment
>
contextAsNode
;
if
(
!
aContextStr
.
IsEmpty
(
)
)
{
rv
=
ParseFragment
(
aContextStr
nullptr
doc
getter_AddRefs
(
contextAsNode
)
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
contextAsNode
NS_ERROR_FAILURE
)
;
rv
=
StripFormattingNodes
(
*
contextAsNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RemoveBodyAndHead
(
*
contextAsNode
)
;
rv
=
FindTargetNode
(
contextAsNode
contextLeaf
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContent
>
contextLeafAsContent
=
do_QueryInterface
(
contextLeaf
)
;
MOZ_ASSERT_IF
(
contextLeaf
contextLeafAsContent
)
;
nsAtom
*
contextAtom
;
if
(
contextLeafAsContent
)
{
contextAtom
=
contextLeafAsContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
contextLeafAsContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
{
contextAtom
=
nsGkAtoms
:
:
body
;
}
}
else
{
contextAtom
=
nsGkAtoms
:
:
body
;
}
RefPtr
<
DocumentFragment
>
fragment
;
rv
=
ParseFragment
(
aInputString
contextAtom
doc
getter_AddRefs
(
fragment
)
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
fragment
NS_ERROR_FAILURE
)
;
RemoveBodyAndHead
(
*
fragment
)
;
if
(
contextAsNode
)
{
contextLeafAsContent
-
>
AppendChild
(
*
fragment
IgnoreErrors
(
)
)
;
fragment
=
contextAsNode
;
}
rv
=
StripFormattingNodes
(
*
fragment
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
contextLeaf
)
{
*
outEndNode
=
*
outStartNode
=
contextLeaf
;
}
else
{
*
outEndNode
=
*
outStartNode
=
fragment
;
}
*
outFragNode
=
fragment
.
forget
(
)
;
*
outStartOffset
=
0
;
if
(
!
aInfoStr
.
IsEmpty
(
)
)
{
int32_t
sep
=
aInfoStr
.
FindChar
(
(
char16_t
)
'
'
)
;
nsAutoString
numstr1
(
Substring
(
aInfoStr
0
sep
)
)
;
nsAutoString
numstr2
(
Substring
(
aInfoStr
sep
+
1
aInfoStr
.
Length
(
)
-
(
sep
+
1
)
)
)
;
nsresult
err
;
int32_t
num
=
numstr1
.
ToInteger
(
&
err
)
;
while
(
num
-
-
)
{
nsINode
*
tmp
=
(
*
outStartNode
)
-
>
GetFirstChild
(
)
;
NS_ENSURE_TRUE
(
tmp
NS_ERROR_FAILURE
)
;
*
outStartNode
=
tmp
;
}
num
=
numstr2
.
ToInteger
(
&
err
)
;
while
(
num
-
-
)
{
nsINode
*
tmp
=
(
*
outEndNode
)
-
>
GetLastChild
(
)
;
NS_ENSURE_TRUE
(
tmp
NS_ERROR_FAILURE
)
;
*
outEndNode
=
tmp
;
}
}
*
outEndOffset
=
(
*
outEndNode
)
-
>
Length
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ParseFragment
(
const
nsAString
&
aFragStr
nsAtom
*
aContextLocalName
nsIDocument
*
aTargetDocument
DocumentFragment
*
*
aFragment
bool
aTrustedInput
)
{
nsAutoScriptBlockerSuppressNodeRemoved
autoBlocker
;
RefPtr
<
DocumentFragment
>
fragment
=
new
DocumentFragment
(
aTargetDocument
-
>
NodeInfoManager
(
)
)
;
nsresult
rv
=
nsContentUtils
:
:
ParseFragmentHTML
(
aFragStr
fragment
aContextLocalName
?
aContextLocalName
:
nsGkAtoms
:
:
body
kNameSpaceID_XHTML
false
true
)
;
if
(
!
aTrustedInput
)
{
nsTreeSanitizer
sanitizer
(
aContextLocalName
?
nsIParserUtils
:
:
SanitizerAllowStyle
:
nsIParserUtils
:
:
SanitizerAllowComments
)
;
sanitizer
.
Sanitize
(
fragment
)
;
}
fragment
.
forget
(
aFragment
)
;
return
rv
;
}
void
HTMLEditor
:
:
CreateListOfNodesToPaste
(
DocumentFragment
&
aFragment
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outNodeList
nsINode
*
aStartContainer
int32_t
aStartOffset
nsINode
*
aEndContainer
int32_t
aEndOffset
)
{
if
(
!
aStartContainer
)
{
aStartContainer
=
&
aFragment
;
aStartOffset
=
0
;
aEndContainer
=
&
aFragment
;
aEndOffset
=
aFragment
.
Length
(
)
;
}
RefPtr
<
nsRange
>
docFragRange
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
getter_AddRefs
(
docFragRange
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
rv
=
iter
.
Init
(
*
docFragRange
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
iter
.
AppendList
(
functor
outNodeList
)
;
}
void
HTMLEditor
:
:
GetListAndTableParents
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeList
nsTArray
<
OwningNonNull
<
Element
>
>
&
outArray
)
{
MOZ_ASSERT
(
aNodeList
.
Length
(
)
)
;
int32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
end
?
aNodeList
.
Length
(
)
-
1
:
0
;
for
(
nsCOMPtr
<
nsINode
>
node
=
aNodeList
[
idx
]
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
node
)
|
|
HTMLEditUtils
:
:
IsTable
(
node
)
)
{
outArray
.
AppendElement
(
*
node
-
>
AsElement
(
)
)
;
}
}
}
int32_t
HTMLEditor
:
:
DiscoverPartialListsAndTables
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aPasteNodes
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListsAndTables
)
{
int32_t
ret
=
-
1
;
int32_t
listAndTableParents
=
aListsAndTables
.
Length
(
)
;
for
(
auto
&
curNode
:
aPasteNodes
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
curNode
)
&
&
!
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsCOMPtr
<
Element
>
table
=
curNode
-
>
GetParentElement
(
)
;
while
(
table
&
&
!
table
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
table
=
table
-
>
GetParentElement
(
)
;
}
if
(
table
)
{
int32_t
idx
=
aListsAndTables
.
IndexOf
(
table
)
;
if
(
idx
=
=
-
1
)
{
return
ret
;
}
ret
=
idx
;
if
(
ret
=
=
listAndTableParents
-
1
)
{
return
ret
;
}
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
nsCOMPtr
<
Element
>
list
=
curNode
-
>
GetParentElement
(
)
;
while
(
list
&
&
!
HTMLEditUtils
:
:
IsList
(
list
)
)
{
list
=
list
-
>
GetParentElement
(
)
;
}
if
(
list
)
{
int32_t
idx
=
aListsAndTables
.
IndexOf
(
list
)
;
if
(
idx
=
=
-
1
)
{
return
ret
;
}
ret
=
idx
;
if
(
ret
=
=
listAndTableParents
-
1
)
{
return
ret
;
}
}
}
}
return
ret
;
}
nsINode
*
HTMLEditor
:
:
ScanForListAndTableStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodes
Element
&
aListOrTable
)
{
int32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
end
?
aNodes
.
Length
(
)
-
1
:
0
;
bool
isList
=
HTMLEditUtils
:
:
IsList
(
&
aListOrTable
)
;
for
(
nsCOMPtr
<
nsINode
>
node
=
aNodes
[
idx
]
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
isList
&
&
HTMLEditUtils
:
:
IsListItem
(
node
)
)
|
|
(
!
isList
&
&
HTMLEditUtils
:
:
IsTableElement
(
node
)
&
&
!
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
)
{
nsCOMPtr
<
Element
>
structureNode
=
node
-
>
GetParentElement
(
)
;
if
(
isList
)
{
while
(
structureNode
&
&
!
HTMLEditUtils
:
:
IsList
(
structureNode
)
)
{
structureNode
=
structureNode
-
>
GetParentElement
(
)
;
}
}
else
{
while
(
structureNode
&
&
!
structureNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
structureNode
=
structureNode
-
>
GetParentElement
(
)
;
}
}
if
(
structureNode
=
=
&
aListOrTable
)
{
if
(
isList
)
{
return
structureNode
;
}
return
node
;
}
}
}
return
nullptr
;
}
void
HTMLEditor
:
:
ReplaceOrphanedStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListAndTableArray
int32_t
aHighWaterMark
)
{
OwningNonNull
<
Element
>
curNode
=
aListAndTableArray
[
aHighWaterMark
]
;
nsCOMPtr
<
nsINode
>
replaceNode
=
ScanForListAndTableStructure
(
aStartOrEnd
aNodeArray
curNode
)
;
if
(
!
replaceNode
)
{
return
;
}
uint32_t
removedCount
=
0
;
uint32_t
originalLength
=
aNodeArray
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
originalLength
;
i
+
+
)
{
uint32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
start
?
(
i
-
removedCount
)
:
(
originalLength
-
i
-
1
)
;
OwningNonNull
<
nsINode
>
endpoint
=
aNodeArray
[
idx
]
;
if
(
endpoint
=
=
replaceNode
|
|
EditorUtils
:
:
IsDescendantOf
(
*
endpoint
*
replaceNode
)
)
{
aNodeArray
.
RemoveElementAt
(
idx
)
;
removedCount
+
+
;
}
}
if
(
aStartOrEnd
=
=
StartOrEnd
:
:
end
)
{
aNodeArray
.
AppendElement
(
*
replaceNode
)
;
}
else
{
aNodeArray
.
InsertElementAt
(
0
*
replaceNode
)
;
}
}
}
