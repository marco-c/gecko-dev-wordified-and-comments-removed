#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
<
string
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentFilter
.
h
"
#
include
"
nsIDOMComment
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMDocumentFragment
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMHTMLAnchorElement
.
h
"
#
include
"
nsIDOMHTMLEmbedElement
.
h
"
#
include
"
nsIDOMHTMLFrameElement
.
h
"
#
include
"
nsIDOMHTMLIFrameElement
.
h
"
#
include
"
nsIDOMHTMLImageElement
.
h
"
#
include
"
nsIDOMHTMLInputElement
.
h
"
#
include
"
nsIDOMHTMLLinkElement
.
h
"
#
include
"
nsIDOMHTMLObjectElement
.
h
"
#
include
"
nsIDOMHTMLScriptElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorIMESupport
.
h
"
#
include
"
nsIEditorMailSupport
.
h
"
#
include
"
nsIEditRules
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIParserUtils
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStringIterator
.
h
"
#
include
"
nsSubstringTuple
.
h
"
#
include
"
nsTreeSanitizer
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsIAtom
;
class
nsILoadContext
;
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
#
define
kInsertCookie
"
_moz_Insert
Here_moz_
"
static
bool
FindIntegerAfterString
(
const
char
*
aLeadingString
nsCString
&
aCStr
int32_t
&
foundNumber
)
;
static
nsresult
RemoveFragComments
(
nsCString
&
theStr
)
;
static
void
RemoveBodyAndHead
(
nsINode
&
aNode
)
;
static
nsresult
FindTargetNode
(
nsIDOMNode
*
aStart
nsCOMPtr
<
nsIDOMNode
>
&
aResult
)
;
nsresult
HTMLEditor
:
:
LoadHTML
(
const
nsAString
&
aInputString
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
ForceCompositionEnd
(
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
loadHTML
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
loadHTML
)
;
bool
cancel
handled
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
)
{
return
NS_OK
;
}
if
(
!
handled
)
{
if
(
!
selection
-
>
Collapsed
(
)
)
{
rv
=
DeleteSelection
(
eNone
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMDocumentFragment
>
docfrag
;
{
rv
=
range
-
>
CreateContextualFragment
(
aInputString
getter_AddRefs
(
docfrag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
rv
=
range
-
>
GetStartContainer
(
getter_AddRefs
(
parent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
int32_t
childOffset
;
rv
=
range
-
>
GetStartOffset
(
&
childOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
nodeToInsert
;
docfrag
-
>
GetFirstChild
(
getter_AddRefs
(
nodeToInsert
)
)
;
while
(
nodeToInsert
)
{
rv
=
InsertNode
(
nodeToInsert
parent
childOffset
+
+
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
docfrag
-
>
GetFirstChild
(
getter_AddRefs
(
nodeToInsert
)
)
;
}
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertHTML
(
const
nsAString
&
aInString
)
{
const
nsAFlatString
&
empty
=
EmptyString
(
)
;
return
InsertHTMLWithContext
(
aInString
empty
empty
empty
nullptr
nullptr
0
true
)
;
}
nsresult
HTMLEditor
:
:
InsertHTMLWithContext
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
const
nsAString
&
aFlavor
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestNode
int32_t
aDestOffset
bool
aDeleteSelection
)
{
return
DoInsertHTMLWithContext
(
aInputString
aContextStr
aInfoStr
aFlavor
aSourceDoc
aDestNode
aDestOffset
aDeleteSelection
true
false
)
;
}
nsresult
HTMLEditor
:
:
DoInsertHTMLWithContext
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
const
nsAString
&
aFlavor
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestNode
int32_t
aDestOffset
bool
aDeleteSelection
bool
aTrustedInput
bool
aClearStyle
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
ForceCompositionEnd
(
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
htmlPaste
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
nsCOMPtr
<
nsIDOMNode
>
fragmentAsNode
streamStartParent
streamEndParent
;
int32_t
streamStartOffset
=
0
streamEndOffset
=
0
;
nsresult
rv
=
CreateDOMFragmentFromPaste
(
aInputString
aContextStr
aInfoStr
address_of
(
fragmentAsNode
)
address_of
(
streamStartParent
)
address_of
(
streamEndParent
)
&
streamStartOffset
&
streamEndOffset
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
targetNode
;
int32_t
targetOffset
=
0
;
if
(
!
aDestNode
)
{
rv
=
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
targetNode
)
&
targetOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
targetNode
|
|
!
IsEditable
(
targetNode
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
targetNode
=
aDestNode
;
targetOffset
=
aDestOffset
;
}
bool
doContinue
=
true
;
rv
=
DoContentFilterCallback
(
aFlavor
aSourceDoc
aDeleteSelection
(
nsIDOMNode
*
*
)
address_of
(
fragmentAsNode
)
(
nsIDOMNode
*
*
)
address_of
(
streamStartParent
)
&
streamStartOffset
(
nsIDOMNode
*
*
)
address_of
(
streamEndParent
)
&
streamEndOffset
(
nsIDOMNode
*
*
)
address_of
(
targetNode
)
&
targetOffset
&
doContinue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
doContinue
NS_OK
)
;
if
(
aDestNode
)
{
if
(
aDeleteSelection
)
{
AutoTrackDOMPoint
tracker
(
mRangeUpdater
&
targetNode
&
targetOffset
)
;
rv
=
DeleteSelection
(
eNone
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
selection
-
>
Collapse
(
targetNode
targetOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeList
;
nsCOMPtr
<
nsINode
>
fragmentAsNodeNode
=
do_QueryInterface
(
fragmentAsNode
)
;
NS_ENSURE_STATE
(
fragmentAsNodeNode
|
|
!
fragmentAsNode
)
;
nsCOMPtr
<
nsINode
>
streamStartParentNode
=
do_QueryInterface
(
streamStartParent
)
;
NS_ENSURE_STATE
(
streamStartParentNode
|
|
!
streamStartParent
)
;
nsCOMPtr
<
nsINode
>
streamEndParentNode
=
do_QueryInterface
(
streamEndParent
)
;
NS_ENSURE_STATE
(
streamEndParentNode
|
|
!
streamEndParent
)
;
CreateListOfNodesToPaste
(
*
static_cast
<
DocumentFragment
*
>
(
fragmentAsNodeNode
.
get
(
)
)
nodeList
streamStartParentNode
streamStartOffset
streamEndParentNode
streamEndOffset
)
;
if
(
nodeList
.
Length
(
)
=
=
0
)
{
if
(
aDeleteSelection
)
{
return
DeleteSelection
(
eNone
eStrip
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
parentNode
;
int32_t
offsetOfNewNode
;
bool
cellSelectionMode
=
false
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
cellSelectionMode
=
true
;
}
if
(
cellSelectionMode
)
{
if
(
!
HTMLEditUtils
:
:
IsTableElement
(
nodeList
[
0
]
)
)
{
cellSelectionMode
=
false
;
}
}
if
(
!
cellSelectionMode
)
{
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aClearStyle
)
{
nsCOMPtr
<
nsINode
>
tmpNode
=
selection
-
>
GetAnchorNode
(
)
;
int32_t
tmpOffset
=
static_cast
<
int32_t
>
(
selection
-
>
AnchorOffset
(
)
)
;
rv
=
ClearStyle
(
address_of
(
tmpNode
)
&
tmpOffset
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
{
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
rv
=
DeleteTableCell
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
selection
-
>
CollapseToStart
(
)
;
}
TextRulesInfo
ruleInfo
(
EditAction
:
:
insertElement
)
;
bool
cancel
handled
;
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
)
{
return
NS_OK
;
}
if
(
!
handled
)
{
rv
=
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
parentNode
)
&
offsetOfNewNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parentNode
NS_ERROR_FAILURE
)
;
NormalizeEOLInsertPosition
(
nodeList
[
0
]
address_of
(
parentNode
)
&
offsetOfNewNode
)
;
WSRunObject
wsObj
(
this
parentNode
offsetOfNewNode
)
;
if
(
wsObj
.
mEndReasonNode
&
&
TextEditUtils
:
:
IsBreak
(
wsObj
.
mEndReasonNode
)
&
&
!
IsVisBreak
(
wsObj
.
mEndReasonNode
)
)
{
rv
=
DeleteNode
(
wsObj
.
mEndReasonNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
bStartedInLink
=
IsInLink
(
parentNode
)
;
if
(
IsTextNode
(
parentNode
)
)
{
nsCOMPtr
<
nsIContent
>
parentContent
=
do_QueryInterface
(
parentNode
)
;
NS_ENSURE_STATE
(
parentContent
|
|
!
parentNode
)
;
offsetOfNewNode
=
SplitNodeDeep
(
*
parentContent
*
parentContent
offsetOfNewNode
)
;
NS_ENSURE_STATE
(
offsetOfNewNode
!
=
-
1
)
;
nsCOMPtr
<
nsIDOMNode
>
temp
;
rv
=
parentNode
-
>
GetParentNode
(
getter_AddRefs
(
temp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
parentNode
=
temp
;
}
nsTArray
<
OwningNonNull
<
Element
>
>
startListAndTableArray
;
GetListAndTableParents
(
StartOrEnd
:
:
start
nodeList
startListAndTableArray
)
;
int32_t
highWaterMark
=
-
1
;
if
(
startListAndTableArray
.
Length
(
)
>
0
)
{
highWaterMark
=
DiscoverPartialListsAndTables
(
nodeList
startListAndTableArray
)
;
}
if
(
highWaterMark
>
=
0
)
{
ReplaceOrphanedStructure
(
StartOrEnd
:
:
start
nodeList
startListAndTableArray
highWaterMark
)
;
}
nsTArray
<
OwningNonNull
<
Element
>
>
endListAndTableArray
;
GetListAndTableParents
(
StartOrEnd
:
:
end
nodeList
endListAndTableArray
)
;
highWaterMark
=
-
1
;
if
(
endListAndTableArray
.
Length
(
)
>
0
)
{
highWaterMark
=
DiscoverPartialListsAndTables
(
nodeList
endListAndTableArray
)
;
}
if
(
highWaterMark
>
=
0
)
{
ReplaceOrphanedStructure
(
StartOrEnd
:
:
end
nodeList
endListAndTableArray
highWaterMark
)
;
}
nsCOMPtr
<
nsIDOMNode
>
parentBlock
lastInsertNode
insertedContextParent
;
int32_t
listCount
=
nodeList
.
Length
(
)
;
int32_t
j
;
nsCOMPtr
<
nsINode
>
parentNodeNode
=
do_QueryInterface
(
parentNode
)
;
NS_ENSURE_STATE
(
parentNodeNode
|
|
!
parentNode
)
;
if
(
IsBlockNode
(
parentNodeNode
)
)
parentBlock
=
parentNode
;
else
parentBlock
=
GetBlockNodeParent
(
parentNode
)
;
for
(
j
=
0
;
j
<
listCount
;
j
+
+
)
{
bool
bDidInsert
=
false
;
nsCOMPtr
<
nsIDOMNode
>
curNode
=
nodeList
[
j
]
-
>
AsDOMNode
(
)
;
NS_ENSURE_TRUE
(
curNode
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
curNode
!
=
fragmentAsNode
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
!
TextEditUtils
:
:
IsBody
(
curNode
)
NS_ERROR_FAILURE
)
;
if
(
insertedContextParent
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
curNode
insertedContextParent
)
)
{
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsTableRow
(
curNode
)
&
&
HTMLEditUtils
:
:
IsTableRow
(
parentNode
)
&
&
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsTable
(
parentNode
)
)
)
{
nsCOMPtr
<
nsIDOMNode
>
child
;
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
while
(
child
)
{
rv
=
InsertNodeAtPoint
(
child
address_of
(
parentNode
)
&
offsetOfNewNode
true
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
bDidInsert
=
true
;
lastInsertNode
=
child
;
offsetOfNewNode
+
+
;
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
&
&
(
HTMLEditUtils
:
:
IsList
(
parentNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
parentNode
)
)
)
{
nsCOMPtr
<
nsIDOMNode
>
child
tmp
;
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
while
(
child
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
|
|
HTMLEditUtils
:
:
IsList
(
child
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parentNode
)
)
{
bool
isEmpty
;
rv
=
IsEmptyNode
(
parentNode
&
isEmpty
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isEmpty
)
{
int32_t
newOffset
;
nsCOMPtr
<
nsIDOMNode
>
listNode
=
GetNodeLocation
(
parentNode
&
newOffset
)
;
if
(
listNode
)
{
DeleteNode
(
parentNode
)
;
parentNode
=
listNode
;
offsetOfNewNode
=
newOffset
;
}
}
}
rv
=
InsertNodeAtPoint
(
child
address_of
(
parentNode
)
&
offsetOfNewNode
true
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
bDidInsert
=
true
;
lastInsertNode
=
child
;
offsetOfNewNode
+
+
;
}
else
{
curNode
-
>
RemoveChild
(
child
getter_AddRefs
(
tmp
)
)
;
}
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
}
}
else
if
(
parentBlock
&
&
HTMLEditUtils
:
:
IsPre
(
parentBlock
)
&
&
HTMLEditUtils
:
:
IsPre
(
curNode
)
)
{
nsCOMPtr
<
nsIDOMNode
>
child
;
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
while
(
child
)
{
rv
=
InsertNodeAtPoint
(
child
address_of
(
parentNode
)
&
offsetOfNewNode
true
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
bDidInsert
=
true
;
lastInsertNode
=
child
;
offsetOfNewNode
+
+
;
curNode
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
}
}
if
(
!
bDidInsert
|
|
NS_FAILED
(
rv
)
)
{
rv
=
InsertNodeAtPoint
(
curNode
address_of
(
parentNode
)
&
offsetOfNewNode
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bDidInsert
=
true
;
lastInsertNode
=
curNode
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
;
while
(
NS_FAILED
(
rv
)
&
&
curNode
)
{
curNode
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
if
(
parent
&
&
!
TextEditUtils
:
:
IsBody
(
parent
)
)
{
rv
=
InsertNodeAtPoint
(
parent
address_of
(
parentNode
)
&
offsetOfNewNode
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bDidInsert
=
true
;
insertedContextParent
=
parent
;
lastInsertNode
=
GetChildAt
(
parentNode
offsetOfNewNode
)
;
}
}
curNode
=
parent
;
}
}
if
(
lastInsertNode
)
{
parentNode
=
GetNodeLocation
(
lastInsertNode
&
offsetOfNewNode
)
;
offsetOfNewNode
+
+
;
}
}
if
(
lastInsertNode
)
{
nsCOMPtr
<
nsIDOMNode
>
selNode
tmp
highTable
;
int32_t
selOffset
;
if
(
!
HTMLEditUtils
:
:
IsTable
(
lastInsertNode
)
)
{
nsCOMPtr
<
nsINode
>
lastInsertNode_
=
do_QueryInterface
(
lastInsertNode
)
;
NS_ENSURE_STATE
(
lastInsertNode_
|
|
!
lastInsertNode
)
;
selNode
=
GetAsDOMNode
(
GetLastEditableLeaf
(
*
lastInsertNode_
)
)
;
tmp
=
selNode
;
while
(
tmp
&
&
(
tmp
!
=
lastInsertNode
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
tmp
)
)
{
highTable
=
tmp
;
}
nsCOMPtr
<
nsIDOMNode
>
parent
=
tmp
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
tmp
=
parent
;
}
if
(
highTable
)
selNode
=
highTable
;
}
if
(
!
selNode
)
selNode
=
lastInsertNode
;
if
(
IsTextNode
(
selNode
)
|
|
(
IsContainer
(
selNode
)
&
&
!
HTMLEditUtils
:
:
IsTable
(
selNode
)
)
)
{
rv
=
GetLengthOfDOMNode
(
selNode
(
uint32_t
&
)
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
tmp
=
selNode
;
selNode
=
GetNodeLocation
(
tmp
&
selOffset
)
;
NS_ENSURE_STATE
(
selNode
)
;
+
+
selOffset
;
}
WSRunObject
wsRunObj
(
this
selNode
selOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
outVisOffset
=
0
;
WSType
visType
;
nsCOMPtr
<
nsINode
>
selNode_
(
do_QueryInterface
(
selNode
)
)
;
wsRunObj
.
PriorVisibleNode
(
selNode_
selOffset
address_of
(
visNode
)
&
outVisOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
br
)
{
if
(
!
IsVisBreak
(
wsRunObj
.
mStartReasonNode
)
)
{
selNode
=
GetNodeLocation
(
GetAsDOMNode
(
wsRunObj
.
mStartReasonNode
)
&
selOffset
)
;
WSRunObject
wsRunObj
(
this
selNode
selOffset
)
;
selNode_
=
do_QueryInterface
(
selNode
)
;
wsRunObj
.
PriorVisibleNode
(
selNode_
selOffset
address_of
(
visNode
)
&
outVisOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
text
|
|
visType
=
=
WSType
:
:
normalWS
)
{
selNode
=
GetAsDOMNode
(
visNode
)
;
selOffset
=
outVisOffset
;
}
else
if
(
visType
=
=
WSType
:
:
special
)
{
selNode
=
GetNodeLocation
(
GetAsDOMNode
(
wsRunObj
.
mStartReasonNode
)
&
selOffset
)
;
+
+
selOffset
;
}
}
}
selection
-
>
Collapse
(
selNode
selOffset
)
;
nsCOMPtr
<
nsIDOMNode
>
link
;
if
(
!
bStartedInLink
&
&
IsInLink
(
selNode
address_of
(
link
)
)
)
{
nsCOMPtr
<
nsIContent
>
linkContent
=
do_QueryInterface
(
link
)
;
NS_ENSURE_STATE
(
linkContent
|
|
!
link
)
;
nsCOMPtr
<
nsIContent
>
selContent
=
do_QueryInterface
(
selNode
)
;
NS_ENSURE_STATE
(
selContent
|
|
!
selNode
)
;
nsCOMPtr
<
nsIContent
>
leftLink
;
SplitNodeDeep
(
*
linkContent
*
selContent
selOffset
EmptyContainers
:
:
no
getter_AddRefs
(
leftLink
)
)
;
if
(
leftLink
)
{
selNode
=
GetNodeLocation
(
GetAsDOMNode
(
leftLink
)
&
selOffset
)
;
selection
-
>
Collapse
(
selNode
selOffset
+
1
)
;
}
}
}
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddInsertionListener
(
nsIContentFilter
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_NULL_POINTER
)
;
if
(
!
mContentFilters
.
Contains
(
aListener
)
)
{
mContentFilters
.
AppendElement
(
*
aListener
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveInsertionListener
(
nsIContentFilter
*
aListener
)
{
NS_ENSURE_TRUE
(
aListener
NS_ERROR_FAILURE
)
;
mContentFilters
.
RemoveElement
(
aListener
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DoContentFilterCallback
(
const
nsAString
&
aFlavor
nsIDOMDocument
*
sourceDoc
bool
aWillDeleteSelection
nsIDOMNode
*
*
aFragmentAsNode
nsIDOMNode
*
*
aFragStartNode
int32_t
*
aFragStartOffset
nsIDOMNode
*
*
aFragEndNode
int32_t
*
aFragEndOffset
nsIDOMNode
*
*
aTargetNode
int32_t
*
aTargetOffset
bool
*
aDoContinue
)
{
*
aDoContinue
=
true
;
for
(
auto
&
listener
:
mContentFilters
)
{
if
(
!
*
aDoContinue
)
{
break
;
}
listener
-
>
NotifyOfInsertion
(
aFlavor
nullptr
sourceDoc
aWillDeleteSelection
aFragmentAsNode
aFragStartNode
aFragStartOffset
aFragEndNode
aFragEndOffset
aTargetNode
aTargetOffset
aDoContinue
)
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsInLink
(
nsIDOMNode
*
aNode
nsCOMPtr
<
nsIDOMNode
>
*
outLink
)
{
NS_ENSURE_TRUE
(
aNode
false
)
;
if
(
outLink
)
*
outLink
=
nullptr
;
nsCOMPtr
<
nsIDOMNode
>
tmp
node
=
aNode
;
while
(
node
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
node
)
)
{
if
(
outLink
)
*
outLink
=
node
;
return
true
;
}
tmp
=
node
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
node
)
)
;
}
return
false
;
}
nsresult
HTMLEditor
:
:
StripFormattingNodes
(
nsIContent
&
aNode
bool
aListOnly
)
{
if
(
aNode
.
TextIsOnlyWhitespace
(
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
aNode
.
GetParentNode
(
)
;
if
(
parent
)
{
if
(
!
aListOnly
|
|
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
ErrorResult
rv
;
parent
-
>
RemoveChild
(
aNode
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
if
(
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
)
{
nsCOMPtr
<
nsIContent
>
previous
=
child
-
>
GetPreviousSibling
(
)
;
nsresult
rv
=
StripFormattingNodes
(
*
child
aListOnly
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
previous
.
forget
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PrepareTransferable
(
nsITransferable
*
*
aTransferable
)
{
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PrepareHTMLTransferable
(
nsITransferable
*
*
aTransferable
)
{
nsresult
rv
=
CallCreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
aTransferable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aTransferable
)
{
nsCOMPtr
<
nsIDocument
>
destdoc
=
GetDocument
(
)
;
nsILoadContext
*
loadContext
=
destdoc
?
destdoc
-
>
GetLoadContext
(
)
:
nullptr
;
(
*
aTransferable
)
-
>
Init
(
loadContext
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
(
*
aTransferable
)
-
>
AddDataFlavor
(
kNativeHTMLMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kHTMLMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kFileMime
)
;
switch
(
Preferences
:
:
GetInt
(
"
clipboard
.
paste_image_type
"
1
)
)
{
case
0
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
break
;
case
1
:
default
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
break
;
case
2
:
(
*
aTransferable
)
-
>
AddDataFlavor
(
kGIFImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPEGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kJPGImageMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kPNGImageMime
)
;
break
;
}
}
(
*
aTransferable
)
-
>
AddDataFlavor
(
kUnicodeMime
)
;
(
*
aTransferable
)
-
>
AddDataFlavor
(
kMozTextInternal
)
;
}
return
NS_OK
;
}
bool
FindIntegerAfterString
(
const
char
*
aLeadingString
nsCString
&
aCStr
int32_t
&
foundNumber
)
{
int32_t
numFront
=
aCStr
.
Find
(
aLeadingString
)
;
if
(
numFront
=
=
-
1
)
return
false
;
numFront
+
=
strlen
(
aLeadingString
)
;
int32_t
numBack
=
aCStr
.
FindCharInSet
(
CRLF
numFront
)
;
if
(
numBack
=
=
-
1
)
return
false
;
nsAutoCString
numStr
(
Substring
(
aCStr
numFront
numBack
-
numFront
)
)
;
nsresult
errorCode
;
foundNumber
=
numStr
.
ToInteger
(
&
errorCode
)
;
return
true
;
}
nsresult
RemoveFragComments
(
nsCString
&
aStr
)
{
int32_t
startCommentIndx
=
aStr
.
Find
(
"
<
!
-
-
StartFragment
"
)
;
if
(
startCommentIndx
>
=
0
)
{
int32_t
startCommentEnd
=
aStr
.
Find
(
"
-
-
>
"
false
startCommentIndx
)
;
if
(
startCommentEnd
>
startCommentIndx
)
aStr
.
Cut
(
startCommentIndx
(
startCommentEnd
+
3
)
-
startCommentIndx
)
;
}
int32_t
endCommentIndx
=
aStr
.
Find
(
"
<
!
-
-
EndFragment
"
)
;
if
(
endCommentIndx
>
=
0
)
{
int32_t
endCommentEnd
=
aStr
.
Find
(
"
-
-
>
"
false
endCommentIndx
)
;
if
(
endCommentEnd
>
endCommentIndx
)
aStr
.
Cut
(
endCommentIndx
(
endCommentEnd
+
3
)
-
endCommentIndx
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ParseCFHTML
(
nsCString
&
aCfhtml
char16_t
*
*
aStuffToPaste
char16_t
*
*
aCfcontext
)
{
int32_t
startHTML
endHTML
startFragment
endFragment
;
if
(
!
FindIntegerAfterString
(
"
StartHTML
:
"
aCfhtml
startHTML
)
|
|
startHTML
<
-
1
)
return
NS_ERROR_FAILURE
;
if
(
!
FindIntegerAfterString
(
"
EndHTML
:
"
aCfhtml
endHTML
)
|
|
endHTML
<
-
1
)
return
NS_ERROR_FAILURE
;
if
(
!
FindIntegerAfterString
(
"
StartFragment
:
"
aCfhtml
startFragment
)
|
|
startFragment
<
0
)
return
NS_ERROR_FAILURE
;
if
(
!
FindIntegerAfterString
(
"
EndFragment
:
"
aCfhtml
endFragment
)
|
|
startFragment
<
0
)
return
NS_ERROR_FAILURE
;
if
(
startHTML
=
=
-
1
)
{
startHTML
=
aCfhtml
.
Find
(
"
<
!
-
-
StartFragment
-
-
>
"
)
;
if
(
startHTML
=
=
-
1
)
return
NS_OK
;
}
if
(
endHTML
=
=
-
1
)
{
const
char
endFragmentMarker
[
]
=
"
<
!
-
-
EndFragment
-
-
>
"
;
endHTML
=
aCfhtml
.
Find
(
endFragmentMarker
)
;
if
(
endHTML
=
=
-
1
)
return
NS_OK
;
endHTML
+
=
ArrayLength
(
endFragmentMarker
)
-
1
;
}
nsAutoCString
contextUTF8
(
Substring
(
aCfhtml
startHTML
startFragment
-
startHTML
)
+
NS_LITERAL_CSTRING
(
"
<
!
-
-
"
kInsertCookie
"
-
-
>
"
)
+
Substring
(
aCfhtml
endFragment
endHTML
-
endFragment
)
)
;
int32_t
curPos
=
startFragment
;
while
(
curPos
>
startHTML
)
{
if
(
aCfhtml
[
curPos
]
=
=
'
>
'
)
{
break
;
}
else
if
(
aCfhtml
[
curPos
]
=
=
'
<
'
)
{
if
(
curPos
!
=
startFragment
)
{
NS_ERROR
(
"
StartFragment
byte
count
in
the
clipboard
looks
bad
see
bug
#
228879
"
)
;
startFragment
=
curPos
-
1
;
}
break
;
}
else
{
curPos
-
-
;
}
}
nsAutoCString
fragmentUTF8
(
Substring
(
aCfhtml
startFragment
endFragment
-
startFragment
)
)
;
RemoveFragComments
(
fragmentUTF8
)
;
RemoveFragComments
(
contextUTF8
)
;
const
nsAFlatString
&
fragUcs2Str
=
NS_ConvertUTF8toUTF16
(
fragmentUTF8
)
;
const
nsAFlatString
&
cntxtUcs2Str
=
NS_ConvertUTF8toUTF16
(
contextUTF8
)
;
int32_t
oldLengthInChars
=
fragUcs2Str
.
Length
(
)
+
1
;
int32_t
newLengthInChars
=
0
;
*
aStuffToPaste
=
nsLinebreakConverter
:
:
ConvertUnicharLineBreaks
(
fragUcs2Str
.
get
(
)
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
oldLengthInChars
&
newLengthInChars
)
;
NS_ENSURE_TRUE
(
*
aStuffToPaste
NS_ERROR_FAILURE
)
;
oldLengthInChars
=
cntxtUcs2Str
.
Length
(
)
+
1
;
newLengthInChars
=
0
;
*
aCfcontext
=
nsLinebreakConverter
:
:
ConvertUnicharLineBreaks
(
cntxtUcs2Str
.
get
(
)
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
oldLengthInChars
&
newLengthInChars
)
;
return
NS_OK
;
}
static
nsresult
ImgFromData
(
const
nsACString
&
aType
const
nsACString
&
aData
nsString
&
aOutput
)
{
nsAutoCString
data64
;
nsresult
rv
=
Base64Encode
(
aData
data64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOutput
.
AssignLiteral
(
"
<
IMG
src
=
\
"
data
:
"
)
;
AppendUTF8toUTF16
(
aType
aOutput
)
;
aOutput
.
AppendLiteral
(
"
;
base64
"
)
;
if
(
!
AppendASCIItoUTF16
(
data64
aOutput
fallible_t
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aOutput
.
AppendLiteral
(
"
\
"
alt
=
\
"
\
"
>
"
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
HTMLEditor
:
:
BlobReader
nsIEditorBlobListener
)
HTMLEditor
:
:
BlobReader
:
:
BlobReader
(
BlobImpl
*
aBlob
HTMLEditor
*
aHTMLEditor
bool
aIsSafe
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
:
mBlob
(
aBlob
)
mHTMLEditor
(
aHTMLEditor
)
mIsSafe
(
aIsSafe
)
mSourceDoc
(
aSourceDoc
)
mDestinationNode
(
aDestinationNode
)
mDestOffset
(
aDestOffset
)
mDoDeleteSelection
(
aDoDeleteSelection
)
{
MOZ_ASSERT
(
mBlob
)
;
MOZ_ASSERT
(
mHTMLEditor
)
;
MOZ_ASSERT
(
mDestinationNode
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BlobReader
:
:
OnResult
(
const
nsACString
&
aResult
)
{
nsString
blobType
;
mBlob
-
>
GetType
(
blobType
)
;
NS_ConvertUTF16toUTF8
type
(
blobType
)
;
nsAutoString
stuffToPaste
;
nsresult
rv
=
ImgFromData
(
type
aResult
stuffToPaste
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoEditBatch
beginBatching
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DoInsertHTMLWithContext
(
stuffToPaste
EmptyString
(
)
EmptyString
(
)
NS_LITERAL_STRING
(
kFileMime
)
mSourceDoc
mDestinationNode
mDestOffset
mDoDeleteSelection
mIsSafe
false
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BlobReader
:
:
OnError
(
const
nsAString
&
aError
)
{
nsCOMPtr
<
nsINode
>
destNode
=
do_QueryInterface
(
mDestinationNode
)
;
const
nsPromiseFlatString
&
flat
=
PromiseFlatString
(
aError
)
;
const
char16_t
*
error
=
flat
.
get
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Editor
"
)
destNode
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
EditorFileDropFailed
"
&
error
1
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertObject
(
const
char
*
aType
nsISupports
*
aObject
bool
aIsSafe
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
{
nsresult
rv
;
if
(
nsCOMPtr
<
BlobImpl
>
blob
=
do_QueryInterface
(
aObject
)
)
{
RefPtr
<
BlobReader
>
br
=
new
BlobReader
(
blob
this
aIsSafe
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
nsCOMPtr
<
nsIEditorUtils
>
utils
=
do_GetService
(
"
mozilla
.
org
/
editor
-
utils
;
1
"
)
;
NS_ENSURE_TRUE
(
utils
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aDestinationNode
)
;
MOZ_ASSERT
(
node
)
;
nsCOMPtr
<
nsIDOMBlob
>
domBlob
=
Blob
:
:
Create
(
node
-
>
GetOwnerGlobal
(
)
blob
)
;
NS_ENSURE_TRUE
(
domBlob
NS_ERROR_FAILURE
)
;
return
utils
-
>
SlurpBlob
(
domBlob
node
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
br
)
;
}
nsAutoCString
type
(
aType
)
;
bool
insertAsImage
=
false
;
nsCOMPtr
<
nsIFile
>
fileObj
;
if
(
type
.
EqualsLiteral
(
kFileMime
)
)
{
fileObj
=
do_QueryInterface
(
aObject
)
;
if
(
fileObj
)
{
if
(
nsContentUtils
:
:
IsFileImage
(
fileObj
type
)
)
{
insertAsImage
=
true
;
}
else
{
type
.
AssignLiteral
(
kFileMime
)
;
}
}
}
if
(
type
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
type
.
EqualsLiteral
(
kJPGImageMime
)
|
|
type
.
EqualsLiteral
(
kPNGImageMime
)
|
|
type
.
EqualsLiteral
(
kGIFImageMime
)
|
|
insertAsImage
)
{
nsCString
imageData
;
if
(
insertAsImage
)
{
rv
=
nsContentUtils
:
:
SlurpFileToString
(
fileObj
imageData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIInputStream
>
imageStream
=
do_QueryInterface
(
aObject
)
;
NS_ENSURE_TRUE
(
imageStream
NS_ERROR_FAILURE
)
;
rv
=
NS_ConsumeStream
(
imageStream
UINT32_MAX
imageData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
imageStream
-
>
Close
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsAutoString
stuffToPaste
;
rv
=
ImgFromData
(
type
imageData
stuffToPaste
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoEditBatch
beginBatching
(
this
)
;
rv
=
DoInsertHTMLWithContext
(
stuffToPaste
EmptyString
(
)
EmptyString
(
)
NS_LITERAL_STRING
(
kFileMime
)
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
aIsSafe
false
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertFromTransferable
(
nsITransferable
*
transferable
nsIDOMDocument
*
aSourceDoc
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
bool
havePrivateHTMLFlavor
nsIDOMNode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
{
nsresult
rv
=
NS_OK
;
nsXPIDLCString
bestFlavor
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
uint32_t
len
=
0
;
if
(
NS_SUCCEEDED
(
transferable
-
>
GetAnyTransferData
(
getter_Copies
(
bestFlavor
)
getter_AddRefs
(
genericDataObj
)
&
len
)
)
)
{
AutoTransactionsConserveSelection
dontSpazMySelection
(
this
)
;
nsAutoString
flavor
;
flavor
.
AssignWithConversion
(
bestFlavor
)
;
nsAutoString
stuffToPaste
;
bool
isSafe
=
IsSafeToInsertData
(
aSourceDoc
)
;
if
(
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kFileMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kJPEGImageMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kJPGImageMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kPNGImageMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kGIFImageMime
)
)
{
rv
=
InsertObject
(
bestFlavor
genericDataObj
isSafe
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
else
if
(
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kNativeHTMLMime
)
)
{
nsCOMPtr
<
nsISupportsCString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoCString
cfhtml
;
textDataObj
-
>
GetData
(
cfhtml
)
;
NS_ASSERTION
(
cfhtml
.
Length
(
)
<
=
(
len
)
"
Invalid
length
!
"
)
;
nsXPIDLString
cfcontext
cffragment
cfselection
;
rv
=
ParseCFHTML
(
cfhtml
getter_Copies
(
cffragment
)
getter_Copies
(
cfcontext
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
cffragment
.
IsEmpty
(
)
)
{
AutoEditBatch
beginBatching
(
this
)
;
if
(
havePrivateHTMLFlavor
)
{
rv
=
DoInsertHTMLWithContext
(
cffragment
aContextStr
aInfoStr
flavor
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
else
{
rv
=
DoInsertHTMLWithContext
(
cffragment
cfcontext
cfselection
flavor
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
}
else
{
bestFlavor
.
AssignLiteral
(
kHTMLMime
)
;
}
}
}
if
(
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kHTMLMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kUnicodeMime
)
|
|
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kMozTextInternal
)
)
{
nsCOMPtr
<
nsISupportsString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoString
text
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
len
/
2
)
"
Invalid
length
!
"
)
;
stuffToPaste
.
Assign
(
text
.
get
(
)
len
/
2
)
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
textDataObj
(
do_QueryInterface
(
genericDataObj
)
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoCString
text
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
len
"
Invalid
length
!
"
)
;
stuffToPaste
.
Assign
(
NS_ConvertUTF8toUTF16
(
Substring
(
text
0
len
)
)
)
;
}
}
if
(
!
stuffToPaste
.
IsEmpty
(
)
)
{
AutoEditBatch
beginBatching
(
this
)
;
if
(
0
=
=
nsCRT
:
:
strcmp
(
bestFlavor
kHTMLMime
)
)
{
rv
=
DoInsertHTMLWithContext
(
stuffToPaste
aContextStr
aInfoStr
flavor
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
else
{
rv
=
InsertTextAt
(
stuffToPaste
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
}
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
ScrollSelectionIntoView
(
false
)
;
return
rv
;
}
static
void
GetStringFromDataTransfer
(
nsIDOMDataTransfer
*
aDataTransfer
const
nsAString
&
aType
int32_t
aIndex
nsAString
&
aOutputString
)
{
nsCOMPtr
<
nsIVariant
>
variant
;
DataTransfer
:
:
Cast
(
aDataTransfer
)
-
>
GetDataAtNoSecurityCheck
(
aType
aIndex
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
variant
-
>
GetAsAString
(
aOutputString
)
;
}
nsresult
HTMLEditor
:
:
InsertFromDataTransfer
(
DataTransfer
*
aDataTransfer
int32_t
aIndex
nsIDOMDocument
*
aSourceDoc
nsIDOMNode
*
aDestinationNode
int32_t
aDestOffset
bool
aDoDeleteSelection
)
{
ErrorResult
rv
;
RefPtr
<
DOMStringList
>
types
=
aDataTransfer
-
>
MozTypesAt
(
aIndex
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
bool
hasPrivateHTMLFlavor
=
types
-
>
Contains
(
NS_LITERAL_STRING
(
kHTMLContext
)
)
;
bool
isText
=
IsPlaintextEditor
(
)
;
bool
isSafe
=
IsSafeToInsertData
(
aSourceDoc
)
;
uint32_t
length
=
types
-
>
Length
(
)
;
for
(
uint32_t
t
=
0
;
t
<
length
;
t
+
+
)
{
nsAutoString
type
;
types
-
>
Item
(
t
type
)
;
if
(
!
isText
)
{
if
(
type
.
EqualsLiteral
(
kFileMime
)
|
|
type
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
type
.
EqualsLiteral
(
kJPGImageMime
)
|
|
type
.
EqualsLiteral
(
kPNGImageMime
)
|
|
type
.
EqualsLiteral
(
kGIFImageMime
)
)
{
nsCOMPtr
<
nsIVariant
>
variant
;
DataTransfer
:
:
Cast
(
aDataTransfer
)
-
>
GetDataAtNoSecurityCheck
(
type
aIndex
getter_AddRefs
(
variant
)
)
;
if
(
variant
)
{
nsCOMPtr
<
nsISupports
>
object
;
variant
-
>
GetAsISupports
(
getter_AddRefs
(
object
)
)
;
return
InsertObject
(
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
object
isSafe
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
}
else
if
(
type
.
EqualsLiteral
(
kNativeHTMLMime
)
)
{
nsAutoString
text
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
NS_ConvertUTF16toUTF8
cfhtml
(
text
)
;
nsXPIDLString
cfcontext
cffragment
cfselection
;
nsresult
rv
=
ParseCFHTML
(
cfhtml
getter_Copies
(
cffragment
)
getter_Copies
(
cfcontext
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
cffragment
.
IsEmpty
(
)
)
{
AutoEditBatch
beginBatching
(
this
)
;
if
(
hasPrivateHTMLFlavor
)
{
nsAutoString
contextString
infoString
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLContext
)
aIndex
contextString
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLInfo
)
aIndex
infoString
)
;
return
DoInsertHTMLWithContext
(
cffragment
contextString
infoString
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
else
{
return
DoInsertHTMLWithContext
(
cffragment
cfcontext
cfselection
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
}
}
else
if
(
type
.
EqualsLiteral
(
kHTMLMime
)
)
{
nsAutoString
text
contextString
infoString
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLContext
)
aIndex
contextString
)
;
GetStringFromDataTransfer
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLInfo
)
aIndex
infoString
)
;
AutoEditBatch
beginBatching
(
this
)
;
if
(
type
.
EqualsLiteral
(
kHTMLMime
)
)
{
return
DoInsertHTMLWithContext
(
text
contextString
infoString
type
aSourceDoc
aDestinationNode
aDestOffset
aDoDeleteSelection
isSafe
)
;
}
}
}
if
(
type
.
EqualsLiteral
(
kTextMime
)
|
|
type
.
EqualsLiteral
(
kMozTextInternal
)
)
{
nsAutoString
text
;
GetStringFromDataTransfer
(
aDataTransfer
type
aIndex
text
)
;
AutoEditBatch
beginBatching
(
this
)
;
return
InsertTextAt
(
text
aDestinationNode
aDestOffset
aDoDeleteSelection
)
;
}
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
HavePrivateHTMLFlavor
(
nsIClipboard
*
aClipboard
)
{
NS_ENSURE_TRUE
(
aClipboard
false
)
;
bool
bHavePrivateHTMLFlavor
=
false
;
const
char
*
flavArray
[
]
=
{
kHTMLContext
}
;
if
(
NS_SUCCEEDED
(
aClipboard
-
>
HasDataMatchingFlavors
(
flavArray
ArrayLength
(
flavArray
)
nsIClipboard
:
:
kGlobalClipboard
&
bHavePrivateHTMLFlavor
)
)
)
return
bHavePrivateHTMLFlavor
;
return
false
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Paste
(
int32_t
aSelectionType
)
{
if
(
!
FireClipboardEvent
(
ePaste
aSelectionType
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
;
rv
=
PrepareHTMLTransferable
(
getter_AddRefs
(
trans
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
trans
NS_ERROR_FAILURE
)
;
rv
=
clipboard
-
>
GetData
(
trans
aSelectionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsAutoString
contextStr
infoStr
;
bool
bHavePrivateHTMLFlavor
=
HavePrivateHTMLFlavor
(
clipboard
)
;
if
(
bHavePrivateHTMLFlavor
)
{
nsCOMPtr
<
nsISupports
>
contextDataObj
infoDataObj
;
uint32_t
contextLen
infoLen
;
nsCOMPtr
<
nsISupportsString
>
textDataObj
;
nsCOMPtr
<
nsITransferable
>
contextTrans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
NS_ENSURE_TRUE
(
contextTrans
NS_ERROR_NULL_POINTER
)
;
contextTrans
-
>
Init
(
nullptr
)
;
contextTrans
-
>
AddDataFlavor
(
kHTMLContext
)
;
clipboard
-
>
GetData
(
contextTrans
aSelectionType
)
;
contextTrans
-
>
GetTransferData
(
kHTMLContext
getter_AddRefs
(
contextDataObj
)
&
contextLen
)
;
nsCOMPtr
<
nsITransferable
>
infoTrans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
NS_ENSURE_TRUE
(
infoTrans
NS_ERROR_NULL_POINTER
)
;
infoTrans
-
>
Init
(
nullptr
)
;
infoTrans
-
>
AddDataFlavor
(
kHTMLInfo
)
;
clipboard
-
>
GetData
(
infoTrans
aSelectionType
)
;
infoTrans
-
>
GetTransferData
(
kHTMLInfo
getter_AddRefs
(
infoDataObj
)
&
infoLen
)
;
if
(
contextDataObj
)
{
nsAutoString
text
;
textDataObj
=
do_QueryInterface
(
contextDataObj
)
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
contextLen
/
2
)
"
Invalid
length
!
"
)
;
contextStr
.
Assign
(
text
.
get
(
)
contextLen
/
2
)
;
}
if
(
infoDataObj
)
{
nsAutoString
text
;
textDataObj
=
do_QueryInterface
(
infoDataObj
)
;
textDataObj
-
>
GetData
(
text
)
;
NS_ASSERTION
(
text
.
Length
(
)
<
=
(
infoLen
/
2
)
"
Invalid
length
!
"
)
;
infoStr
.
Assign
(
text
.
get
(
)
infoLen
/
2
)
;
}
}
nsCOMPtr
<
nsIDOMDocument
>
domdoc
;
GetDocument
(
getter_AddRefs
(
domdoc
)
)
;
if
(
!
EditorHookUtils
:
:
DoInsertionHook
(
domdoc
nullptr
trans
)
)
{
return
NS_OK
;
}
return
InsertFromTransferable
(
trans
nullptr
contextStr
infoStr
bHavePrivateHTMLFlavor
nullptr
0
true
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteTransferable
(
nsITransferable
*
aTransferable
)
{
if
(
!
FireClipboardEvent
(
ePaste
nsIClipboard
:
:
kGlobalClipboard
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMDocument
>
domdoc
=
GetDOMDocument
(
)
;
if
(
!
EditorHookUtils
:
:
DoInsertionHook
(
domdoc
nullptr
aTransferable
)
)
{
return
NS_OK
;
}
nsAutoString
contextStr
infoStr
;
return
InsertFromTransferable
(
aTransferable
nullptr
contextStr
infoStr
false
nullptr
0
true
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteNoFormatting
(
int32_t
aSelectionType
)
{
if
(
!
FireClipboardEvent
(
ePaste
aSelectionType
)
)
{
return
NS_OK
;
}
ForceCompositionEnd
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
;
rv
=
TextEditor
:
:
PrepareTransferable
(
getter_AddRefs
(
trans
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
trans
)
{
if
(
NS_SUCCEEDED
(
clipboard
-
>
GetData
(
trans
aSelectionType
)
)
&
&
IsModifiable
(
)
)
{
const
nsAFlatString
&
empty
=
EmptyString
(
)
;
rv
=
InsertFromTransferable
(
trans
nullptr
empty
empty
false
nullptr
0
true
)
;
}
}
return
rv
;
}
static
const
char
*
textEditorFlavors
[
]
=
{
kUnicodeMime
}
;
static
const
char
*
textHtmlEditorFlavors
[
]
=
{
kUnicodeMime
kHTMLMime
kJPEGImageMime
kJPGImageMime
kPNGImageMime
kGIFImageMime
}
;
NS_IMETHODIMP
HTMLEditor
:
:
CanPaste
(
int32_t
aSelectionType
bool
*
aCanPaste
)
{
NS_ENSURE_ARG_POINTER
(
aCanPaste
)
;
*
aCanPaste
=
false
;
if
(
!
IsModifiable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
haveFlavors
;
if
(
IsPlaintextEditor
(
)
)
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textEditorFlavors
ArrayLength
(
textEditorFlavors
)
aSelectionType
&
haveFlavors
)
;
else
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
textHtmlEditorFlavors
ArrayLength
(
textHtmlEditorFlavors
)
aSelectionType
&
haveFlavors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCanPaste
=
haveFlavors
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CanPasteTransferable
(
nsITransferable
*
aTransferable
bool
*
aCanPaste
)
{
NS_ENSURE_ARG_POINTER
(
aCanPaste
)
;
if
(
!
IsModifiable
(
)
)
{
*
aCanPaste
=
false
;
return
NS_OK
;
}
if
(
!
aTransferable
)
{
*
aCanPaste
=
true
;
return
NS_OK
;
}
const
char
*
*
flavors
;
unsigned
length
;
if
(
IsPlaintextEditor
(
)
)
{
flavors
=
textEditorFlavors
;
length
=
ArrayLength
(
textEditorFlavors
)
;
}
else
{
flavors
=
textHtmlEditorFlavors
;
length
=
ArrayLength
(
textHtmlEditorFlavors
)
;
}
for
(
unsigned
int
i
=
0
;
i
<
length
;
i
+
+
flavors
+
+
)
{
nsCOMPtr
<
nsISupports
>
data
;
uint32_t
dataLen
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
*
flavors
getter_AddRefs
(
data
)
&
dataLen
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
data
)
{
*
aCanPaste
=
true
;
return
NS_OK
;
}
}
*
aCanPaste
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteAsQuotation
(
int32_t
aSelectionType
)
{
if
(
IsPlaintextEditor
(
)
)
return
PasteAsPlaintextQuotation
(
aSelectionType
)
;
nsAutoString
citation
;
return
PasteAsCitedQuotation
(
citation
aSelectionType
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteAsCitedQuotation
(
const
nsAString
&
aCitation
int32_t
aSelectionType
)
{
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertQuotation
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
insertElement
)
;
bool
cancel
handled
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
blockquote
)
;
NS_ENSURE_TRUE
(
newNode
NS_ERROR_NULL_POINTER
)
;
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
cite
"
)
true
)
;
rv
=
selection
-
>
Collapse
(
newNode
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
Paste
(
aSelectionType
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PasteAsPlaintextQuotation
(
int32_t
aSelectionType
)
{
nsresult
rv
;
nsCOMPtr
<
nsIClipboard
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
trans
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
destdoc
=
GetDocument
(
)
;
nsILoadContext
*
loadContext
=
destdoc
?
destdoc
-
>
GetLoadContext
(
)
:
nullptr
;
trans
-
>
Init
(
loadContext
)
;
trans
-
>
AddDataFlavor
(
kUnicodeMime
)
;
clipboard
-
>
GetData
(
trans
aSelectionType
)
;
nsCOMPtr
<
nsISupports
>
genericDataObj
;
uint32_t
len
=
0
;
char
*
flav
=
0
;
rv
=
trans
-
>
GetAnyTransferData
(
&
flav
getter_AddRefs
(
genericDataObj
)
&
len
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
flav
&
&
0
=
=
nsCRT
:
:
strcmp
(
flav
kUnicodeMime
)
)
{
nsCOMPtr
<
nsISupportsString
>
textDataObj
=
do_QueryInterface
(
genericDataObj
)
;
if
(
textDataObj
&
&
len
>
0
)
{
nsAutoString
stuffToPaste
;
textDataObj
-
>
GetData
(
stuffToPaste
)
;
NS_ASSERTION
(
stuffToPaste
.
Length
(
)
<
=
(
len
/
2
)
"
Invalid
length
!
"
)
;
AutoEditBatch
beginBatching
(
this
)
;
rv
=
InsertAsPlaintextQuotation
(
stuffToPaste
true
0
)
;
}
}
free
(
flav
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTextWithQuotations
(
const
nsAString
&
aStringToInsert
)
{
BeginTransaction
(
)
;
static
const
char16_t
cite
(
'
>
'
)
;
bool
curHunkIsQuoted
=
(
aStringToInsert
.
First
(
)
=
=
cite
)
;
nsAString
:
:
const_iterator
hunkStart
strEnd
;
aStringToInsert
.
BeginReading
(
hunkStart
)
;
aStringToInsert
.
EndReading
(
strEnd
)
;
#
ifdef
DEBUG
nsAString
:
:
const_iterator
dbgStart
(
hunkStart
)
;
if
(
FindCharInReadable
(
'
\
r
'
dbgStart
strEnd
)
)
NS_ASSERTION
(
false
"
Return
characters
in
DOM
!
InsertTextWithQuotations
may
be
wrong
"
)
;
#
endif
nsresult
rv
=
NS_OK
;
nsAString
:
:
const_iterator
lineStart
(
hunkStart
)
;
while
(
1
)
{
bool
found
=
FindCharInReadable
(
'
\
n
'
lineStart
strEnd
)
;
bool
quoted
=
false
;
if
(
found
)
{
nsAString
:
:
const_iterator
firstNewline
(
lineStart
)
;
while
(
*
lineStart
=
=
'
\
n
'
)
+
+
lineStart
;
quoted
=
(
*
lineStart
=
=
cite
)
;
if
(
quoted
=
=
curHunkIsQuoted
)
continue
;
if
(
curHunkIsQuoted
)
lineStart
=
firstNewline
;
}
const
nsAString
&
curHunk
=
Substring
(
hunkStart
lineStart
)
;
nsCOMPtr
<
nsIDOMNode
>
dummyNode
;
if
(
curHunkIsQuoted
)
rv
=
InsertAsPlaintextQuotation
(
curHunk
false
getter_AddRefs
(
dummyNode
)
)
;
else
rv
=
InsertText
(
curHunk
)
;
if
(
!
found
)
break
;
curHunkIsQuoted
=
quoted
;
hunkStart
=
lineStart
;
}
EndTransaction
(
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertAsQuotation
(
const
nsAString
&
aQuotedText
nsIDOMNode
*
*
aNodeInserted
)
{
if
(
IsPlaintextEditor
(
)
)
return
InsertAsPlaintextQuotation
(
aQuotedText
true
aNodeInserted
)
;
nsAutoString
citation
;
return
InsertAsCitedQuotation
(
aQuotedText
citation
false
aNodeInserted
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertAsPlaintextQuotation
(
const
nsAString
&
aQuotedText
bool
aAddCites
nsIDOMNode
*
*
aNodeInserted
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertQuotation
nsIEditor
:
:
eNext
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
insertElement
)
;
bool
cancel
handled
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
span
)
;
if
(
newNode
)
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozquote
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
NS_LITERAL_STRING
(
"
white
-
space
:
pre
-
wrap
;
"
)
true
)
;
selection
-
>
Collapse
(
newNode
0
)
;
}
if
(
aAddCites
)
rv
=
TextEditor
:
:
InsertAsQuotation
(
aQuotedText
aNodeInserted
)
;
else
rv
=
TextEditor
:
:
InsertText
(
aQuotedText
)
;
if
(
aNodeInserted
&
&
NS_SUCCEEDED
(
rv
)
)
{
*
aNodeInserted
=
GetAsDOMNode
(
newNode
)
;
NS_IF_ADDREF
(
*
aNodeInserted
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
newNode
)
{
nsCOMPtr
<
nsINode
>
parent
=
newNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
IndexOf
(
newNode
)
:
-
1
;
if
(
parent
)
{
selection
-
>
Collapse
(
parent
offset
+
1
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
StripCites
(
)
{
return
TextEditor
:
:
StripCites
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Rewrap
(
bool
aRespectNewlines
)
{
return
TextEditor
:
:
Rewrap
(
aRespectNewlines
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertAsCitedQuotation
(
const
nsAString
&
aQuotedText
const
nsAString
&
aCitation
bool
aInsertHTML
nsIDOMNode
*
*
aNodeInserted
)
{
if
(
IsPlaintextEditor
(
)
)
{
NS_ASSERTION
(
!
aInsertHTML
"
InsertAsCitedQuotation
:
trying
to
insert
html
into
plaintext
editor
"
)
;
return
InsertAsPlaintextQuotation
(
aQuotedText
true
aNodeInserted
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertQuotation
nsIEditor
:
:
eNext
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
insertElement
)
;
bool
cancel
handled
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancel
|
|
handled
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
newNode
=
DeleteSelectionAndCreateElement
(
*
nsGkAtoms
:
:
blockquote
)
;
NS_ENSURE_TRUE
(
newNode
NS_ERROR_NULL_POINTER
)
;
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
cite
"
)
true
)
;
if
(
!
aCitation
.
IsEmpty
(
)
)
{
newNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
cite
aCitation
true
)
;
}
selection
-
>
Collapse
(
newNode
0
)
;
if
(
aInsertHTML
)
rv
=
LoadHTML
(
aQuotedText
)
;
else
rv
=
InsertText
(
aQuotedText
)
;
if
(
aNodeInserted
&
&
NS_SUCCEEDED
(
rv
)
)
{
*
aNodeInserted
=
GetAsDOMNode
(
newNode
)
;
NS_IF_ADDREF
(
*
aNodeInserted
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
newNode
)
{
nsCOMPtr
<
nsINode
>
parent
=
newNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
IndexOf
(
newNode
)
:
-
1
;
if
(
parent
)
{
selection
-
>
Collapse
(
parent
offset
+
1
)
;
}
}
return
rv
;
}
void
RemoveBodyAndHead
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
body
head
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
body
=
child
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
head
)
)
{
head
=
child
;
}
}
if
(
head
)
{
ErrorResult
ignored
;
aNode
.
RemoveChild
(
*
head
ignored
)
;
}
if
(
body
)
{
nsCOMPtr
<
nsIContent
>
child
=
body
-
>
GetFirstChild
(
)
;
while
(
child
)
{
ErrorResult
ignored
;
aNode
.
InsertBefore
(
*
child
body
ignored
)
;
child
=
body
-
>
GetFirstChild
(
)
;
}
ErrorResult
ignored
;
aNode
.
RemoveChild
(
*
body
ignored
)
;
}
}
nsresult
FindTargetNode
(
nsIDOMNode
*
aStart
nsCOMPtr
<
nsIDOMNode
>
&
aResult
)
{
NS_ENSURE_TRUE
(
aStart
NS_OK
)
;
nsCOMPtr
<
nsIDOMNode
>
child
tmp
;
nsresult
rv
=
aStart
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
child
)
{
if
(
!
aResult
)
aResult
=
aStart
;
return
NS_OK
;
}
do
{
nsCOMPtr
<
nsIDOMComment
>
comment
=
do_QueryInterface
(
child
)
;
if
(
comment
)
{
nsAutoString
data
;
rv
=
comment
-
>
GetData
(
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
data
.
EqualsLiteral
(
kInsertCookie
)
)
{
aResult
=
aStart
;
aStart
-
>
RemoveChild
(
child
getter_AddRefs
(
tmp
)
)
;
return
NS_FOUND_TARGET
;
}
}
rv
=
FindTargetNode
(
child
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
child
-
>
GetNextSibling
(
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
tmp
;
}
while
(
child
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CreateDOMFragmentFromPaste
(
const
nsAString
&
aInputString
const
nsAString
&
aContextStr
const
nsAString
&
aInfoStr
nsCOMPtr
<
nsIDOMNode
>
*
outFragNode
nsCOMPtr
<
nsIDOMNode
>
*
outStartNode
nsCOMPtr
<
nsIDOMNode
>
*
outEndNode
int32_t
*
outStartOffset
int32_t
*
outEndOffset
bool
aTrustedInput
)
{
NS_ENSURE_TRUE
(
outFragNode
&
&
outStartNode
&
&
outEndNode
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIDOMNode
>
contextLeaf
;
RefPtr
<
DocumentFragment
>
contextAsNode
;
if
(
!
aContextStr
.
IsEmpty
(
)
)
{
rv
=
ParseFragment
(
aContextStr
nullptr
doc
getter_AddRefs
(
contextAsNode
)
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
contextAsNode
NS_ERROR_FAILURE
)
;
rv
=
StripFormattingNodes
(
*
contextAsNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RemoveBodyAndHead
(
*
contextAsNode
)
;
rv
=
FindTargetNode
(
contextAsNode
contextLeaf
)
;
if
(
rv
=
=
NS_FOUND_TARGET
)
{
rv
=
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContent
>
contextLeafAsContent
=
do_QueryInterface
(
contextLeaf
)
;
nsIAtom
*
contextAtom
;
if
(
contextLeafAsContent
)
{
contextAtom
=
contextLeafAsContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
contextLeafAsContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
{
contextAtom
=
nsGkAtoms
:
:
body
;
}
}
else
{
contextAtom
=
nsGkAtoms
:
:
body
;
}
RefPtr
<
DocumentFragment
>
fragment
;
rv
=
ParseFragment
(
aInputString
contextAtom
doc
getter_AddRefs
(
fragment
)
aTrustedInput
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
fragment
NS_ERROR_FAILURE
)
;
RemoveBodyAndHead
(
*
fragment
)
;
if
(
contextAsNode
)
{
nsCOMPtr
<
nsIDOMNode
>
junk
;
contextLeaf
-
>
AppendChild
(
fragment
getter_AddRefs
(
junk
)
)
;
fragment
=
contextAsNode
;
}
rv
=
StripFormattingNodes
(
*
fragment
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
contextLeaf
)
{
*
outEndNode
=
*
outStartNode
=
contextLeaf
;
}
else
{
*
outEndNode
=
*
outStartNode
=
fragment
;
}
*
outFragNode
=
fragment
.
forget
(
)
;
*
outStartOffset
=
0
;
if
(
!
aInfoStr
.
IsEmpty
(
)
)
{
int32_t
sep
=
aInfoStr
.
FindChar
(
(
char16_t
)
'
'
)
;
nsAutoString
numstr1
(
Substring
(
aInfoStr
0
sep
)
)
;
nsAutoString
numstr2
(
Substring
(
aInfoStr
sep
+
1
aInfoStr
.
Length
(
)
-
(
sep
+
1
)
)
)
;
nsresult
err
;
int32_t
num
=
numstr1
.
ToInteger
(
&
err
)
;
nsCOMPtr
<
nsIDOMNode
>
tmp
;
while
(
num
-
-
)
{
(
*
outStartNode
)
-
>
GetFirstChild
(
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_TRUE
(
tmp
NS_ERROR_FAILURE
)
;
tmp
.
swap
(
*
outStartNode
)
;
}
num
=
numstr2
.
ToInteger
(
&
err
)
;
while
(
num
-
-
)
{
(
*
outEndNode
)
-
>
GetLastChild
(
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_TRUE
(
tmp
NS_ERROR_FAILURE
)
;
tmp
.
swap
(
*
outEndNode
)
;
}
}
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
*
outEndNode
)
;
*
outEndOffset
=
node
-
>
Length
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ParseFragment
(
const
nsAString
&
aFragStr
nsIAtom
*
aContextLocalName
nsIDocument
*
aTargetDocument
DocumentFragment
*
*
aFragment
bool
aTrustedInput
)
{
nsAutoScriptBlockerSuppressNodeRemoved
autoBlocker
;
RefPtr
<
DocumentFragment
>
fragment
=
new
DocumentFragment
(
aTargetDocument
-
>
NodeInfoManager
(
)
)
;
nsresult
rv
=
nsContentUtils
:
:
ParseFragmentHTML
(
aFragStr
fragment
aContextLocalName
?
aContextLocalName
:
nsGkAtoms
:
:
body
kNameSpaceID_XHTML
false
true
)
;
if
(
!
aTrustedInput
)
{
nsTreeSanitizer
sanitizer
(
aContextLocalName
?
nsIParserUtils
:
:
SanitizerAllowStyle
:
nsIParserUtils
:
:
SanitizerAllowComments
)
;
sanitizer
.
Sanitize
(
fragment
)
;
}
fragment
.
forget
(
aFragment
)
;
return
rv
;
}
void
HTMLEditor
:
:
CreateListOfNodesToPaste
(
DocumentFragment
&
aFragment
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outNodeList
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
if
(
!
aStartNode
)
{
aStartNode
=
&
aFragment
;
aStartOffset
=
0
;
aEndNode
=
&
aFragment
;
aEndOffset
=
aFragment
.
Length
(
)
;
}
RefPtr
<
nsRange
>
docFragRange
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
aStartNode
aStartOffset
aEndNode
aEndOffset
getter_AddRefs
(
docFragRange
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
rv
=
iter
.
Init
(
*
docFragRange
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
iter
.
AppendList
(
functor
outNodeList
)
;
}
void
HTMLEditor
:
:
GetListAndTableParents
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeList
nsTArray
<
OwningNonNull
<
Element
>
>
&
outArray
)
{
MOZ_ASSERT
(
aNodeList
.
Length
(
)
)
;
int32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
end
?
aNodeList
.
Length
(
)
-
1
:
0
;
for
(
nsCOMPtr
<
nsINode
>
node
=
aNodeList
[
idx
]
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
node
)
|
|
HTMLEditUtils
:
:
IsTable
(
node
)
)
{
outArray
.
AppendElement
(
*
node
-
>
AsElement
(
)
)
;
}
}
}
int32_t
HTMLEditor
:
:
DiscoverPartialListsAndTables
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aPasteNodes
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListsAndTables
)
{
int32_t
ret
=
-
1
;
int32_t
listAndTableParents
=
aListsAndTables
.
Length
(
)
;
for
(
auto
&
curNode
:
aPasteNodes
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
curNode
)
&
&
!
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsCOMPtr
<
Element
>
table
=
curNode
-
>
GetParentElement
(
)
;
while
(
table
&
&
!
table
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
table
=
table
-
>
GetParentElement
(
)
;
}
if
(
table
)
{
int32_t
idx
=
aListsAndTables
.
IndexOf
(
table
)
;
if
(
idx
=
=
-
1
)
{
return
ret
;
}
ret
=
idx
;
if
(
ret
=
=
listAndTableParents
-
1
)
{
return
ret
;
}
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
nsCOMPtr
<
Element
>
list
=
curNode
-
>
GetParentElement
(
)
;
while
(
list
&
&
!
HTMLEditUtils
:
:
IsList
(
list
)
)
{
list
=
list
-
>
GetParentElement
(
)
;
}
if
(
list
)
{
int32_t
idx
=
aListsAndTables
.
IndexOf
(
list
)
;
if
(
idx
=
=
-
1
)
{
return
ret
;
}
ret
=
idx
;
if
(
ret
=
=
listAndTableParents
-
1
)
{
return
ret
;
}
}
}
}
return
ret
;
}
nsINode
*
HTMLEditor
:
:
ScanForListAndTableStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodes
Element
&
aListOrTable
)
{
int32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
end
?
aNodes
.
Length
(
)
-
1
:
0
;
bool
isList
=
HTMLEditUtils
:
:
IsList
(
&
aListOrTable
)
;
for
(
nsCOMPtr
<
nsINode
>
node
=
aNodes
[
idx
]
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
isList
&
&
HTMLEditUtils
:
:
IsListItem
(
node
)
)
|
|
(
!
isList
&
&
HTMLEditUtils
:
:
IsTableElement
(
node
)
&
&
!
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
)
{
nsCOMPtr
<
Element
>
structureNode
=
node
-
>
GetParentElement
(
)
;
if
(
isList
)
{
while
(
structureNode
&
&
!
HTMLEditUtils
:
:
IsList
(
structureNode
)
)
{
structureNode
=
structureNode
-
>
GetParentElement
(
)
;
}
}
else
{
while
(
structureNode
&
&
!
structureNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
structureNode
=
structureNode
-
>
GetParentElement
(
)
;
}
}
if
(
structureNode
=
=
&
aListOrTable
)
{
if
(
isList
)
{
return
structureNode
;
}
return
node
;
}
}
}
return
nullptr
;
}
void
HTMLEditor
:
:
ReplaceOrphanedStructure
(
StartOrEnd
aStartOrEnd
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
OwningNonNull
<
Element
>
>
&
aListAndTableArray
int32_t
aHighWaterMark
)
{
OwningNonNull
<
Element
>
curNode
=
aListAndTableArray
[
aHighWaterMark
]
;
nsCOMPtr
<
nsINode
>
replaceNode
=
ScanForListAndTableStructure
(
aStartOrEnd
aNodeArray
curNode
)
;
if
(
!
replaceNode
)
{
return
;
}
bool
shouldReplaceNodes
=
true
;
for
(
uint32_t
i
=
0
;
i
<
aNodeArray
.
Length
(
)
;
i
+
+
)
{
uint32_t
idx
=
aStartOrEnd
=
=
StartOrEnd
:
:
start
?
i
:
(
aNodeArray
.
Length
(
)
-
i
-
1
)
;
OwningNonNull
<
nsINode
>
endpoint
=
aNodeArray
[
idx
]
;
if
(
!
EditorUtils
:
:
IsDescendantOf
(
endpoint
replaceNode
)
)
{
shouldReplaceNodes
=
false
;
break
;
}
}
if
(
shouldReplaceNodes
)
{
aNodeArray
.
Clear
(
)
;
if
(
aStartOrEnd
=
=
StartOrEnd
:
:
end
)
{
aNodeArray
.
AppendElement
(
*
replaceNode
)
;
}
else
{
aNodeArray
.
InsertElementAt
(
0
*
replaceNode
)
;
}
}
}
}
