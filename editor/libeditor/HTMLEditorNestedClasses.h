#
ifndef
HTMLEditorNestedClasses_h
#
define
HTMLEditorNestedClasses_h
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoInlineStyleSetter
final
:
private
EditorInlineStyleAndValue
{
using
Element
=
dom
:
:
Element
;
using
Text
=
dom
:
:
Text
;
public
:
explicit
AutoInlineStyleSetter
(
const
EditorInlineStyleAndValue
&
aStyleAndValue
)
:
EditorInlineStyleAndValue
(
aStyleAndValue
)
{
}
void
Reset
(
)
{
mFirstHandledPoint
.
Clear
(
)
;
mLastHandledPoint
.
Clear
(
)
;
}
const
EditorDOMPoint
&
FirstHandledPointRef
(
)
const
{
return
mFirstHandledPoint
;
}
const
EditorDOMPoint
&
LastHandledPointRef
(
)
const
{
return
mLastHandledPoint
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
SplitTextNodeAndApplyStyleToMiddleNode
(
HTMLEditor
&
aHTMLEditor
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Text
&
aTextNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
Result
<
EditorRawDOMRange
nsresult
>
ExtendOrShrinkRangeToApplyTheStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
)
const
;
[
[
nodiscard
]
]
static
nsIContent
*
GetNextEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
static
nsIContent
*
GetPreviousEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
Result
<
RefPtr
<
Text
>
nsresult
>
GetEmptyTextNodeToApplyNewStyle
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCandidatePointToInsert
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyCSSTextDecoration
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
bool
ElementIsGoodContainerToSetStyle
(
nsStyledElement
&
aStyledElement
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
bool
nsresult
>
ElementIsGoodContainerForTheStyle
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
const
;
[
[
nodiscard
]
]
bool
ContentIsElementSettingTheStyle
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeStart
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aFirstEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeEnd
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aLastEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeStartToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aStartPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeEndToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aEndPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMRange
GetExtendedRangeToMinimizeTheNumberOfNewElements
(
const
HTMLEditor
&
aHTMLEditor
const
nsINode
&
aCommonAncestor
EditorRawDOMPoint
&
&
aStartPoint
EditorRawDOMPoint
&
&
aEndPoint
)
const
;
void
OnHandled
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
=
aStartPoint
;
}
mLastHandledPoint
=
aEndPoint
;
}
void
OnHandled
(
nsIContent
&
aContent
)
{
if
(
aContent
.
IsElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
.
Set
(
&
aContent
)
;
}
mLastHandledPoint
.
SetAfter
(
&
aContent
)
;
return
;
}
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
.
Set
(
&
aContent
0u
)
;
}
mLastHandledPoint
=
EditorDOMPoint
:
:
AtEndOf
(
aContent
)
;
}
EditorDOMPoint
mFirstHandledPoint
;
EditorDOMPoint
mLastHandledPoint
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoMoveOneLineHandler
final
{
public
:
explicit
AutoMoveOneLineHandler
(
const
EditorDOMPoint
&
aPointToInsert
)
:
mPointToInsert
(
aPointToInsert
)
mMoveToEndOfContainer
(
MoveToEndOfContainer
:
:
No
)
{
MOZ_ASSERT
(
mPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mPointToInsert
.
IsInContentNode
(
)
)
;
}
explicit
AutoMoveOneLineHandler
(
Element
&
aNewContainerElement
)
:
mPointToInsert
(
&
aNewContainerElement
0
)
mMoveToEndOfContainer
(
MoveToEndOfContainer
:
:
Yes
)
{
MOZ_ASSERT
(
mPointToInsert
.
IsSetAndValid
(
)
)
;
}
[
[
nodiscard
]
]
nsresult
Prepare
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
MoveNodeResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
static
Result
<
bool
nsresult
>
CanMoveOrDeleteSomethingInLine
(
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
;
AutoMoveOneLineHandler
(
const
AutoMoveOneLineHandler
&
aOther
)
=
delete
;
AutoMoveOneLineHandler
(
AutoMoveOneLineHandler
&
&
aOther
)
=
delete
;
private
:
[
[
nodiscard
]
]
bool
ForceMoveToEndOfContainer
(
)
const
{
return
mMoveToEndOfContainer
=
=
MoveToEndOfContainer
:
:
Yes
;
}
[
[
nodiscard
]
]
EditorDOMPoint
&
NextInsertionPointRef
(
)
{
if
(
ForceMoveToEndOfContainer
(
)
)
{
mPointToInsert
.
SetToEndOf
(
mPointToInsert
.
GetContainer
(
)
)
;
}
return
mPointToInsert
;
}
[
[
nodiscard
]
]
static
PreserveWhiteSpaceStyle
ConsiderWhetherPreserveWhiteSpaceStyle
(
const
nsIContent
*
aContentInLine
const
Element
*
aInclusiveAncestorBlockOfInsertionPoint
)
;
[
[
nodiscard
]
]
static
Element
*
GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement
(
Element
&
aBlockElement
const
Element
&
aAncestorElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
SplitToMakeTheLineIsolated
(
HTMLEditor
&
aHTMLEditor
const
nsIContent
&
aNewContainer
const
Element
&
aEditingHost
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteUnnecessaryTrailingLineBreakInMovedLineEnd
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aMovedContentRange
const
Element
&
aEditingHost
)
const
;
EditorDOMRange
mLineRange
;
EditorDOMPoint
mPointToInsert
;
RefPtr
<
Element
>
mSrcInclusiveAncestorBlock
;
RefPtr
<
Element
>
mDestInclusiveAncestorBlock
;
RefPtr
<
Element
>
mTopmostSrcAncestorBlockInDestBlock
;
enum
class
MoveToEndOfContainer
{
No
Yes
}
;
MoveToEndOfContainer
mMoveToEndOfContainer
;
PreserveWhiteSpaceStyle
mPreserveWhiteSpaceStyle
=
PreserveWhiteSpaceStyle
:
:
No
;
bool
mMovingToParentBlock
=
false
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoListElementCreator
final
{
public
:
AutoListElementCreator
(
const
nsStaticAtom
&
aListElementTagName
const
nsStaticAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
)
:
mListTagName
(
const_cast
<
nsStaticAtom
&
>
(
aListElementTagName
)
)
mListItemTagName
(
const_cast
<
nsStaticAtom
&
>
(
aListItemElementTagName
)
)
mBulletType
(
aBulletType
)
{
MOZ_ASSERT
(
&
mListTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
mListTagName
=
=
nsGkAtoms
:
:
ol
|
|
&
mListTagName
=
=
nsGkAtoms
:
:
dl
)
;
MOZ_ASSERT_IF
(
&
mListTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
mListTagName
=
=
nsGkAtoms
:
:
ol
&
mListItemTagName
=
=
nsGkAtoms
:
:
li
)
;
MOZ_ASSERT_IF
(
&
mListTagName
=
=
nsGkAtoms
:
:
dl
&
mListItemTagName
=
=
nsGkAtoms
:
:
dt
|
|
&
mListItemTagName
=
=
nsGkAtoms
:
:
dd
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
AutoClonedSelectionRangeArray
&
aRanges
HTMLEditor
:
:
SelectAllOfCurrentList
aSelectAllOfCurrentList
const
Element
&
aEditingHost
)
const
;
private
:
using
ContentNodeArray
=
nsTArray
<
OwningNonNull
<
nsIContent
>
>
;
using
AutoContentNodeArray
=
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SplitAtRangeEdgesAndCollectContentNodesToMoveIntoList
(
HTMLEditor
&
aHTMLEditor
AutoClonedRangeArray
&
aRanges
SelectAllOfCurrentList
aSelectAllOfCurrentList
const
Element
&
aEditingHost
ContentNodeArray
&
aOutArrayOfContents
)
const
;
[
[
nodiscard
]
]
static
bool
IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements
(
const
ContentNodeArray
&
aArrayOfContents
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
RefPtr
<
Element
>
nsresult
>
ReplaceContentNodesWithEmptyNewList
(
HTMLEditor
&
aHTMLEditor
const
AutoClonedRangeArray
&
aRanges
const
AutoContentNodeArray
&
aArrayOfContents
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
RefPtr
<
Element
>
nsresult
>
WrapContentNodesIntoNewListElements
(
HTMLEditor
&
aHTMLEditor
AutoClonedRangeArray
&
aRanges
AutoContentNodeArray
&
aArrayOfContents
const
Element
&
aEditingHost
)
const
;
struct
MOZ_STACK_CLASS
AutoHandlingState
final
{
RefPtr
<
Element
>
mCurrentListElement
;
RefPtr
<
Element
>
mPreviousListItemElement
;
RefPtr
<
Element
>
mListOrListItemElementToPutCaret
;
RefPtr
<
Element
>
mReplacingBlockElement
;
bool
mMaybeCopiedReplacingBlockElementId
=
false
;
}
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aHandlingContent
AutoHandlingState
&
aState
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildListElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aHandlingListElement
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildListItemElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aHandlingListItemElement
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildListItemInDifferentTypeList
(
HTMLEditor
&
aHTMLEditor
Element
&
aHandlingListItemElement
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildListItemInSameTypeList
(
HTMLEditor
&
aHTMLEditor
Element
&
aHandlingListItemElement
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildDivOrParagraphElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aHandlingDivOrParagraphElement
AutoHandlingState
&
aState
const
Element
&
aEditingHost
)
const
;
enum
class
EmptyListItem
{
NotCreate
Create
}
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
CreateAndUpdateCurrentListElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToInsert
EmptyListItem
aEmptyListItem
AutoHandlingState
&
aState
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CreateElementResult
nsresult
>
AppendListItemElement
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aListElement
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsresult
MaybeCloneAttributesToNewListItem
(
HTMLEditor
&
aHTMLEditor
Element
&
aListItemElement
AutoHandlingState
&
aState
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleChildInlineContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aHandlingInlineContent
AutoHandlingState
&
aState
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
WrapContentIntoNewListItemElement
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aHandlingContent
AutoHandlingState
&
aState
)
const
;
nsresult
EnsureCollapsedRangeIsInListItemOrListElement
(
Element
&
aListItemOrListToPutCaret
AutoClonedRangeArray
&
aRanges
)
const
;
MOZ_KNOWN_LIVE
nsStaticAtom
&
mListTagName
;
MOZ_KNOWN_LIVE
nsStaticAtom
&
mListItemTagName
;
const
nsAutoString
mBulletType
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoInsertParagraphHandler
final
{
public
:
explicit
AutoInsertParagraphHandler
(
)
=
default
;
AutoInsertParagraphHandler
(
const
AutoInsertParagraphHandler
&
)
=
delete
;
AutoInsertParagraphHandler
(
AutoInsertParagraphHandler
&
&
)
=
delete
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitNodeResult
nsresult
>
SplitParagraphWithTransaction
(
HTMLEditor
&
aHTMLEditor
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aStartOfRightNode
dom
:
:
HTMLBRElement
*
aMayBecomeVisibleBRElement
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitNodeResult
nsresult
>
HandleInParagraph
(
HTMLEditor
&
aHTMLEditor
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aCandidatePointToSplit
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
InsertParagraphResult
nsresult
>
HandleInHeadingElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aHeadingElement
const
EditorDOMPoint
&
aPointToSplit
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
InsertParagraphResult
nsresult
>
HandleInListItemElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aListItemElement
const
EditorDOMPoint
&
aPointToSplit
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
HandleInMailCiteElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aMailCiteElement
const
EditorDOMPoint
&
aPointToSplit
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CreateElementResult
nsresult
>
InsertBRElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToBreak
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
bool
ShouldInsertLineBreakInstead
(
HTMLEditor
&
aHTMLEditor
const
Element
*
aEditableBlockElement
const
EditorDOMPoint
&
aCandidatePointToSplit
ParagraphSeparator
aDefaultParagraphSeparator
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InsertBRElementIfEmptyBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aMaybeBlockElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitNodeResult
nsresult
>
SplitMailCiteElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
Element
&
aMailCiteElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeInsertPaddingBRElementToInlineMailCiteElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToInsertBRElement
Element
&
aMailCiteElement
)
;
[
[
nodiscard
]
]
static
Element
*
GetDeepestFirstChildInlineContainerElement
(
Element
&
aBlockElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsresult
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCandidatePointToPutCaret
const
Element
*
aBlockElementShouldHaveCaret
const
SuggestCaretOptions
&
aOptions
)
;
[
[
nodiscard
]
]
static
EditorDOMPoint
GetBetterSplitPointToAvoidToContinueLink
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCandidatePointToSplit
const
Element
&
aElementToSplit
)
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoInsertLineBreakHandler
final
{
public
:
explicit
AutoInsertLineBreakHandler
(
)
=
default
;
AutoInsertLineBreakHandler
(
const
AutoInsertLineBreakHandler
&
)
=
delete
;
AutoInsertLineBreakHandler
(
AutoInsertLineBreakHandler
&
&
)
=
delete
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
private
:
[
[
nodiscard
]
]
static
MOZ_CAN_RUN_SCRIPT
Result
<
EditorDOMPoint
nsresult
>
InsertLinefeed
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToBreak
const
Element
&
aEditingHost
)
;
friend
class
AutoInsertParagraphHandler
;
}
;
struct
MOZ_STACK_CLASS
HTMLEditor
:
:
NormalizedStringToInsertText
final
{
NormalizedStringToInsertText
(
const
nsAString
&
aStringToInsertWithoutSurroundingWhiteSpaces
const
EditorDOMPoint
&
aPointToInsert
)
:
mNormalizedString
(
aStringToInsertWithoutSurroundingWhiteSpaces
)
mReplaceStartOffset
(
aPointToInsert
.
IsInTextNode
(
)
?
aPointToInsert
.
Offset
(
)
:
0u
)
mReplaceEndOffset
(
mReplaceStartOffset
)
{
MOZ_ASSERT
(
aStringToInsertWithoutSurroundingWhiteSpaces
.
Length
(
)
=
=
InsertingTextLength
(
)
)
;
}
NormalizedStringToInsertText
(
const
nsAString
&
aStringToInsertWithSurroundingWhiteSpaces
uint32_t
aInsertOffset
uint32_t
aReplaceStartOffset
uint32_t
aReplaceLength
uint32_t
aNewPrecedingWhiteSpaceLengthBeforeInsertionString
uint32_t
aNewFollowingWhiteSpaceLengthAfterInsertionString
)
:
mNormalizedString
(
aStringToInsertWithSurroundingWhiteSpaces
)
mReplaceStartOffset
(
aReplaceStartOffset
)
mReplaceEndOffset
(
mReplaceStartOffset
+
aReplaceLength
)
mReplaceLengthBefore
(
aInsertOffset
-
mReplaceStartOffset
)
mReplaceLengthAfter
(
aReplaceLength
-
mReplaceLengthBefore
)
mNewLengthBefore
(
aNewPrecedingWhiteSpaceLengthBeforeInsertionString
)
mNewLengthAfter
(
aNewFollowingWhiteSpaceLengthAfterInsertionString
)
{
MOZ_ASSERT
(
aReplaceStartOffset
<
=
aInsertOffset
)
;
MOZ_ASSERT
(
aReplaceStartOffset
+
aReplaceLength
>
=
aInsertOffset
)
;
MOZ_ASSERT
(
aNewPrecedingWhiteSpaceLengthBeforeInsertionString
+
aNewFollowingWhiteSpaceLengthAfterInsertionString
<
mNormalizedString
.
Length
(
)
)
;
MOZ_ASSERT
(
mReplaceLengthBefore
+
mReplaceLengthAfter
=
=
ReplaceLength
(
)
)
;
MOZ_ASSERT
(
mReplaceLengthBefore
>
=
mNewLengthBefore
)
;
MOZ_ASSERT
(
mReplaceLengthAfter
>
=
mNewLengthAfter
)
;
}
NormalizedStringToInsertText
GetMinimizedData
(
const
Text
&
aText
)
const
{
if
(
mNormalizedString
.
IsEmpty
(
)
|
|
!
ReplaceLength
(
)
)
{
return
*
this
;
}
const
nsTextFragment
&
textFragment
=
aText
.
TextFragment
(
)
;
const
uint32_t
minimizedReplaceStart
=
[
&
]
(
)
{
const
auto
firstDiffCharOffset
=
mNewLengthBefore
?
textFragment
.
FindFirstDifferentCharOffset
(
PrecedingWhiteSpaces
(
)
mReplaceStartOffset
)
:
nsTextFragment
:
:
kNotFound
;
if
(
firstDiffCharOffset
=
=
nsTextFragment
:
:
kNotFound
)
{
return
(
mReplaceStartOffset
+
mReplaceLengthBefore
)
-
DeletingPrecedingInvisibleWhiteSpaces
(
)
;
}
return
firstDiffCharOffset
;
}
(
)
;
const
uint32_t
minimizedReplaceEnd
=
[
&
]
(
)
{
const
auto
lastDiffCharOffset
=
mNewLengthAfter
?
textFragment
.
RFindFirstDifferentCharOffset
(
FollowingWhiteSpaces
(
)
mReplaceEndOffset
)
:
nsTextFragment
:
:
kNotFound
;
if
(
lastDiffCharOffset
=
=
nsTextFragment
:
:
kNotFound
)
{
return
(
mReplaceEndOffset
-
mReplaceLengthAfter
)
+
DeletingFollowingInvisibleWhiteSpaces
(
)
;
}
return
lastDiffCharOffset
+
1u
;
}
(
)
;
if
(
minimizedReplaceStart
=
=
mReplaceStartOffset
&
&
minimizedReplaceEnd
=
=
mReplaceEndOffset
)
{
return
*
this
;
}
const
uint32_t
newPrecedingWhiteSpaceLength
=
mNewLengthBefore
-
(
minimizedReplaceStart
-
mReplaceStartOffset
)
;
const
uint32_t
newFollowingWhiteSpaceLength
=
mNewLengthAfter
-
(
mReplaceEndOffset
-
minimizedReplaceEnd
)
;
return
NormalizedStringToInsertText
(
Substring
(
mNormalizedString
mNewLengthBefore
-
newPrecedingWhiteSpaceLength
mNormalizedString
.
Length
(
)
-
(
mNewLengthBefore
-
newPrecedingWhiteSpaceLength
)
-
(
mNewLengthAfter
-
newFollowingWhiteSpaceLength
)
)
OffsetToInsertText
(
)
minimizedReplaceStart
minimizedReplaceEnd
-
minimizedReplaceStart
newPrecedingWhiteSpaceLength
newFollowingWhiteSpaceLength
)
;
}
[
[
nodiscard
]
]
uint32_t
OffsetToInsertText
(
)
const
{
return
mReplaceStartOffset
+
mReplaceLengthBefore
;
}
[
[
nodiscard
]
]
uint32_t
InsertingTextLength
(
)
const
{
return
mNormalizedString
.
Length
(
)
-
mNewLengthBefore
-
mNewLengthAfter
;
}
[
[
nodiscard
]
]
uint32_t
EndOffsetOfInsertedText
(
)
const
{
return
OffsetToInsertText
(
)
+
InsertingTextLength
(
)
;
}
[
[
nodiscard
]
]
uint32_t
ReplaceLength
(
)
const
{
return
mReplaceEndOffset
-
mReplaceStartOffset
;
}
[
[
nodiscard
]
]
uint32_t
DeletingPrecedingInvisibleWhiteSpaces
(
)
const
{
return
mReplaceLengthBefore
-
mNewLengthBefore
;
}
[
[
nodiscard
]
]
uint32_t
DeletingFollowingInvisibleWhiteSpaces
(
)
const
{
return
mReplaceLengthAfter
-
mNewLengthAfter
;
}
[
[
nodiscard
]
]
nsDependentSubstring
PrecedingWhiteSpaces
(
)
const
{
return
Substring
(
mNormalizedString
0u
mNewLengthBefore
)
;
}
[
[
nodiscard
]
]
nsDependentSubstring
FollowingWhiteSpaces
(
)
const
{
return
Substring
(
mNormalizedString
mNormalizedString
.
Length
(
)
-
mNewLengthAfter
)
;
}
nsAutoString
mNormalizedString
;
const
uint32_t
mReplaceStartOffset
;
const
uint32_t
mReplaceEndOffset
;
const
uint32_t
mReplaceLengthBefore
=
0u
;
const
uint32_t
mReplaceLengthAfter
=
0u
;
const
uint32_t
mNewLengthBefore
=
0u
;
const
uint32_t
mNewLengthAfter
=
0u
;
}
;
struct
MOZ_STACK_CLASS
HTMLEditor
:
:
ReplaceWhiteSpacesData
final
{
ReplaceWhiteSpacesData
(
)
=
default
;
ReplaceWhiteSpacesData
(
const
nsAString
&
aWhiteSpaces
uint32_t
aStartOffset
uint32_t
aReplaceLength
uint32_t
aOffsetAfterReplacing
=
UINT32_MAX
)
:
mNormalizedString
(
aWhiteSpaces
)
mReplaceStartOffset
(
aStartOffset
)
mReplaceEndOffset
(
aStartOffset
+
aReplaceLength
)
mNewOffsetAfterReplace
(
aOffsetAfterReplacing
)
{
MOZ_ASSERT
(
ReplaceLength
(
)
>
=
mNormalizedString
.
Length
(
)
)
;
MOZ_ASSERT_IF
(
mNewOffsetAfterReplace
!
=
UINT32_MAX
mNewOffsetAfterReplace
<
=
mReplaceStartOffset
+
mNormalizedString
.
Length
(
)
)
;
}
ReplaceWhiteSpacesData
(
nsAutoString
&
&
aWhiteSpaces
uint32_t
aStartOffset
uint32_t
aReplaceLength
uint32_t
aOffsetAfterReplacing
=
UINT32_MAX
)
:
mNormalizedString
(
std
:
:
forward
<
nsAutoString
>
(
aWhiteSpaces
)
)
mReplaceStartOffset
(
aStartOffset
)
mReplaceEndOffset
(
aStartOffset
+
aReplaceLength
)
mNewOffsetAfterReplace
(
aOffsetAfterReplacing
)
{
MOZ_ASSERT
(
ReplaceLength
(
)
>
=
mNormalizedString
.
Length
(
)
)
;
MOZ_ASSERT_IF
(
mNewOffsetAfterReplace
!
=
UINT32_MAX
mNewOffsetAfterReplace
<
=
mReplaceStartOffset
+
mNormalizedString
.
Length
(
)
)
;
}
ReplaceWhiteSpacesData
GetMinimizedData
(
const
Text
&
aText
)
const
{
if
(
!
ReplaceLength
(
)
)
{
return
*
this
;
}
const
nsTextFragment
&
textFragment
=
aText
.
TextFragment
(
)
;
const
auto
minimizedReplaceStart
=
[
&
]
(
)
-
>
uint32_t
{
if
(
mNormalizedString
.
IsEmpty
(
)
)
{
return
mReplaceStartOffset
;
}
const
uint32_t
firstDiffCharOffset
=
textFragment
.
FindFirstDifferentCharOffset
(
mNormalizedString
mReplaceStartOffset
)
;
if
(
firstDiffCharOffset
=
=
nsTextFragment
:
:
kNotFound
)
{
return
mReplaceStartOffset
+
mNormalizedString
.
Length
(
)
;
}
return
firstDiffCharOffset
;
}
(
)
;
const
auto
minimizedReplaceEnd
=
[
&
]
(
)
-
>
uint32_t
{
if
(
mNormalizedString
.
IsEmpty
(
)
)
{
return
mReplaceEndOffset
;
}
if
(
minimizedReplaceStart
=
=
mReplaceStartOffset
+
mNormalizedString
.
Length
(
)
)
{
MOZ_ASSERT
(
mReplaceEndOffset
>
=
minimizedReplaceStart
)
;
return
mReplaceEndOffset
;
}
if
(
ReplaceLength
(
)
!
=
mNormalizedString
.
Length
(
)
)
{
return
mReplaceEndOffset
;
}
const
auto
lastDiffCharOffset
=
textFragment
.
RFindFirstDifferentCharOffset
(
mNormalizedString
mReplaceEndOffset
)
;
MOZ_ASSERT
(
lastDiffCharOffset
!
=
nsTextFragment
:
:
kNotFound
)
;
return
lastDiffCharOffset
=
=
nsTextFragment
:
:
kNotFound
?
mReplaceEndOffset
:
lastDiffCharOffset
+
1u
;
}
(
)
;
if
(
minimizedReplaceStart
=
=
mReplaceStartOffset
&
&
minimizedReplaceEnd
=
=
mReplaceEndOffset
)
{
return
*
this
;
}
const
uint32_t
precedingUnnecessaryLength
=
minimizedReplaceStart
-
mReplaceStartOffset
;
const
uint32_t
followingUnnecessaryLength
=
mReplaceEndOffset
-
minimizedReplaceEnd
;
return
ReplaceWhiteSpacesData
(
Substring
(
mNormalizedString
precedingUnnecessaryLength
mNormalizedString
.
Length
(
)
-
(
precedingUnnecessaryLength
+
followingUnnecessaryLength
)
)
minimizedReplaceStart
minimizedReplaceEnd
-
minimizedReplaceStart
mNewOffsetAfterReplace
)
;
}
[
[
nodiscard
]
]
ReplaceWhiteSpacesData
PreviousDataOfNewOffset
(
uint32_t
aReplaceEndOffset
)
const
{
MOZ_ASSERT
(
mNewOffsetAfterReplace
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
mReplaceStartOffset
<
=
mNewOffsetAfterReplace
)
;
MOZ_ASSERT
(
mReplaceEndOffset
>
=
mNewOffsetAfterReplace
)
;
MOZ_ASSERT
(
mReplaceStartOffset
<
=
aReplaceEndOffset
)
;
MOZ_ASSERT
(
mReplaceEndOffset
>
=
aReplaceEndOffset
)
;
if
(
!
ReplaceLength
(
)
|
|
aReplaceEndOffset
=
=
mReplaceStartOffset
)
{
return
ReplaceWhiteSpacesData
(
)
;
}
return
ReplaceWhiteSpacesData
(
Substring
(
mNormalizedString
0u
mNewOffsetAfterReplace
-
mReplaceStartOffset
)
mReplaceStartOffset
aReplaceEndOffset
-
mReplaceStartOffset
)
;
}
[
[
nodiscard
]
]
ReplaceWhiteSpacesData
NextDataOfNewOffset
(
uint32_t
aReplaceStartOffset
)
const
{
MOZ_ASSERT
(
mNewOffsetAfterReplace
!
=
UINT32_MAX
)
;
MOZ_ASSERT
(
mReplaceStartOffset
<
=
mNewOffsetAfterReplace
)
;
MOZ_ASSERT
(
mReplaceEndOffset
>
=
mNewOffsetAfterReplace
)
;
MOZ_ASSERT
(
mReplaceStartOffset
<
=
aReplaceStartOffset
)
;
MOZ_ASSERT
(
mReplaceEndOffset
>
=
aReplaceStartOffset
)
;
if
(
!
ReplaceLength
(
)
|
|
aReplaceStartOffset
=
=
mReplaceEndOffset
)
{
return
ReplaceWhiteSpacesData
(
)
;
}
return
ReplaceWhiteSpacesData
(
Substring
(
mNormalizedString
mNewOffsetAfterReplace
-
mReplaceStartOffset
)
aReplaceStartOffset
mReplaceEndOffset
-
aReplaceStartOffset
)
;
}
[
[
nodiscard
]
]
uint32_t
ReplaceLength
(
)
const
{
return
mReplaceEndOffset
-
mReplaceStartOffset
;
}
[
[
nodiscard
]
]
uint32_t
DeletingInvisibleWhiteSpaces
(
)
const
{
return
ReplaceLength
(
)
-
mNormalizedString
.
Length
(
)
;
}
[
[
nodiscard
]
]
ReplaceWhiteSpacesData
operator
+
(
const
ReplaceWhiteSpacesData
&
aOther
)
const
{
if
(
!
ReplaceLength
(
)
)
{
return
aOther
;
}
if
(
!
aOther
.
ReplaceLength
(
)
)
{
return
*
this
;
}
MOZ_ASSERT
(
mReplaceEndOffset
=
=
aOther
.
mReplaceStartOffset
)
;
MOZ_ASSERT_IF
(
aOther
.
mNewOffsetAfterReplace
!
=
UINT32_MAX
aOther
.
mNewOffsetAfterReplace
>
=
DeletingInvisibleWhiteSpaces
(
)
)
;
return
ReplaceWhiteSpacesData
(
nsAutoString
(
mNormalizedString
+
aOther
.
mNormalizedString
)
mReplaceStartOffset
aOther
.
mReplaceEndOffset
aOther
.
mNewOffsetAfterReplace
!
=
UINT32_MAX
?
aOther
.
mNewOffsetAfterReplace
-
DeletingInvisibleWhiteSpaces
(
)
:
mNewOffsetAfterReplace
)
;
}
nsAutoString
mNormalizedString
;
const
uint32_t
mReplaceStartOffset
=
0u
;
const
uint32_t
mReplaceEndOffset
=
0u
;
const
uint32_t
mNewOffsetAfterReplace
=
UINT32_MAX
;
}
;
}
#
endif
