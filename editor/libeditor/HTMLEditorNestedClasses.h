#
ifndef
HTMLEditorNestedClasses_h
#
define
HTMLEditorNestedClasses_h
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Result
.
h
"
namespace
mozilla
{
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoInlineStyleSetter
final
:
private
EditorInlineStyleAndValue
{
using
Element
=
dom
:
:
Element
;
using
Text
=
dom
:
:
Text
;
public
:
explicit
AutoInlineStyleSetter
(
const
EditorInlineStyleAndValue
&
aStyleAndValue
)
:
EditorInlineStyleAndValue
(
aStyleAndValue
)
{
}
void
Reset
(
)
{
mFirstHandledPoint
.
Clear
(
)
;
mLastHandledPoint
.
Clear
(
)
;
}
const
EditorDOMPoint
&
FirstHandledPointRef
(
)
const
{
return
mFirstHandledPoint
;
}
const
EditorDOMPoint
&
LastHandledPointRef
(
)
const
{
return
mLastHandledPoint
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
SplitTextNodeAndApplyStyleToMiddleNode
(
HTMLEditor
&
aHTMLEditor
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Text
&
aTextNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
Result
<
EditorRawDOMRange
nsresult
>
ExtendOrShrinkRangeToApplyTheStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
static
nsIContent
*
GetNextEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
static
nsIContent
*
GetPreviousEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
Result
<
RefPtr
<
Text
>
nsresult
>
GetEmptyTextNodeToApplyNewStyle
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCandidatePointToInsert
const
Element
&
aEditingHost
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyCSSTextDecoration
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
bool
ElementIsGoodContainerToSetStyle
(
nsStyledElement
&
aStyledElement
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
bool
nsresult
>
ElementIsGoodContainerForTheStyle
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
const
;
[
[
nodiscard
]
]
bool
ContentIsElementSettingTheStyle
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeStart
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aFirstEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeEnd
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aLastEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeStartToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aStartPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeEndToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aEndPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMRange
GetExtendedRangeToMinimizeTheNumberOfNewElements
(
const
HTMLEditor
&
aHTMLEditor
const
nsINode
&
aCommonAncestor
EditorRawDOMPoint
&
&
aStartPoint
EditorRawDOMPoint
&
&
aEndPoint
)
const
;
void
OnHandled
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
=
aStartPoint
;
}
mLastHandledPoint
=
aEndPoint
;
}
void
OnHandled
(
nsIContent
&
aContent
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
.
Set
(
&
aContent
0u
)
;
}
mLastHandledPoint
=
EditorDOMPoint
:
:
AtEndOf
(
aContent
)
;
}
EditorDOMPoint
mFirstHandledPoint
;
EditorDOMPoint
mLastHandledPoint
;
}
;
}
#
endif
