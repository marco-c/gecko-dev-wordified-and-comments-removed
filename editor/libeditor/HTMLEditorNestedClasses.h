#
ifndef
HTMLEditorNestedClasses_h
#
define
HTMLEditorNestedClasses_h
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Result
.
h
"
namespace
mozilla
{
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoInlineStyleSetter
final
:
private
EditorInlineStyleAndValue
{
using
Element
=
dom
:
:
Element
;
using
Text
=
dom
:
:
Text
;
public
:
explicit
AutoInlineStyleSetter
(
const
EditorInlineStyleAndValue
&
aStyleAndValue
)
:
EditorInlineStyleAndValue
(
aStyleAndValue
)
{
}
void
Reset
(
)
{
mFirstHandledPoint
.
Clear
(
)
;
mLastHandledPoint
.
Clear
(
)
;
}
const
EditorDOMPoint
&
FirstHandledPointRef
(
)
const
{
return
mFirstHandledPoint
;
}
const
EditorDOMPoint
&
LastHandledPointRef
(
)
const
{
return
mLastHandledPoint
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
SplitTextNodeAndApplyStyleToMiddleNode
(
HTMLEditor
&
aHTMLEditor
Text
&
aText
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyleToNodeOrChildrenAndRemoveNestedSameStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
SplitRangeOffFromNodeResult
nsresult
>
InvertStyleIfApplied
(
HTMLEditor
&
aHTMLEditor
Text
&
aTextNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
Result
<
EditorRawDOMRange
nsresult
>
ExtendOrShrinkRangeToApplyTheStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
static
nsIContent
*
GetNextEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
static
nsIContent
*
GetPreviousEditableInlineContent
(
const
nsIContent
&
aContent
const
nsINode
*
aLimiter
=
nullptr
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
Result
<
RefPtr
<
Text
>
nsresult
>
GetEmptyTextNodeToApplyNewStyle
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCandidatePointToInsert
const
Element
&
aEditingHost
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyStyle
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
ApplyCSSTextDecoration
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
bool
ElementIsGoodContainerToSetStyle
(
nsStyledElement
&
aStyledElement
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
bool
nsresult
>
ElementIsGoodContainerForTheStyle
(
HTMLEditor
&
aHTMLEditor
Element
&
aElement
)
const
;
[
[
nodiscard
]
]
bool
ContentIsElementSettingTheStyle
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeStart
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aFirstEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetShrunkenRangeEnd
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRange
const
nsINode
&
aCommonAncestorOfRange
const
nsIContent
*
aLastEntirelySelectedContentNodeInRange
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeStartToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aStartPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMPoint
GetExtendedRangeEndToWrapAncestorApplyingSameStyle
(
const
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aEndPoint
)
const
;
[
[
nodiscard
]
]
EditorRawDOMRange
GetExtendedRangeToMinimizeTheNumberOfNewElements
(
const
HTMLEditor
&
aHTMLEditor
const
nsINode
&
aCommonAncestor
EditorRawDOMPoint
&
&
aStartPoint
EditorRawDOMPoint
&
&
aEndPoint
)
const
;
void
OnHandled
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
=
aStartPoint
;
}
mLastHandledPoint
=
aEndPoint
;
}
void
OnHandled
(
nsIContent
&
aContent
)
{
if
(
!
mFirstHandledPoint
.
IsSet
(
)
)
{
mFirstHandledPoint
.
Set
(
&
aContent
0u
)
;
}
mLastHandledPoint
=
EditorDOMPoint
:
:
AtEndOf
(
aContent
)
;
}
EditorDOMPoint
mFirstHandledPoint
;
EditorDOMPoint
mLastHandledPoint
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoMoveOneLineHandler
final
{
public
:
explicit
AutoMoveOneLineHandler
(
const
EditorDOMPoint
&
aPointToInsert
)
:
mPointToInsert
(
aPointToInsert
)
mMoveToEndOfContainer
(
MoveToEndOfContainer
:
:
No
)
{
MOZ_ASSERT
(
mPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mPointToInsert
.
IsInContentNode
(
)
)
;
}
explicit
AutoMoveOneLineHandler
(
Element
&
aNewContainerElement
)
:
mPointToInsert
(
&
aNewContainerElement
0
)
mMoveToEndOfContainer
(
MoveToEndOfContainer
:
:
Yes
)
{
MOZ_ASSERT
(
mPointToInsert
.
IsSetAndValid
(
)
)
;
}
[
[
nodiscard
]
]
nsresult
Prepare
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
MoveNodeResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
static
Result
<
bool
nsresult
>
CanMoveOrDeleteSomethingInLine
(
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
;
AutoMoveOneLineHandler
(
const
AutoMoveOneLineHandler
&
aOther
)
=
delete
;
AutoMoveOneLineHandler
(
AutoMoveOneLineHandler
&
&
aOther
)
=
delete
;
private
:
[
[
nodiscard
]
]
bool
ForceMoveToEndOfContainer
(
)
const
{
return
mMoveToEndOfContainer
=
=
MoveToEndOfContainer
:
:
Yes
;
}
[
[
nodiscard
]
]
EditorDOMPoint
&
NextInsertionPointRef
(
)
{
if
(
ForceMoveToEndOfContainer
(
)
)
{
mPointToInsert
.
SetToEndOf
(
mPointToInsert
.
GetContainer
(
)
)
;
}
return
mPointToInsert
;
}
[
[
nodiscard
]
]
static
PreserveWhiteSpaceStyle
ConsiderWhetherPreserveWhiteSpaceStyle
(
const
nsIContent
*
aContentInLine
const
Element
*
aInclusiveAncestorBlockOfInsertionPoint
)
;
[
[
nodiscard
]
]
static
Element
*
GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement
(
Element
&
aBlockElement
const
Element
&
aAncestorElement
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
SplitToMakeTheLineIsolated
(
HTMLEditor
&
aHTMLEditor
const
nsIContent
&
aNewContainer
const
Element
&
aEditingHost
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteUnnecessaryTrailingLineBreakInMovedLineEnd
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aMovedContentRange
const
Element
&
aEditingHost
)
const
;
EditorDOMRange
mLineRange
;
EditorDOMPoint
mPointToInsert
;
RefPtr
<
Element
>
mSrcInclusiveAncestorBlock
;
RefPtr
<
Element
>
mDestInclusiveAncestorBlock
;
RefPtr
<
Element
>
mTopmostSrcAncestorBlockInDestBlock
;
enum
class
MoveToEndOfContainer
{
No
Yes
}
;
MoveToEndOfContainer
mMoveToEndOfContainer
;
PreserveWhiteSpaceStyle
mPreserveWhiteSpaceStyle
=
PreserveWhiteSpaceStyle
:
:
No
;
bool
mMovingToParentBlock
=
false
;
}
;
}
#
endif
