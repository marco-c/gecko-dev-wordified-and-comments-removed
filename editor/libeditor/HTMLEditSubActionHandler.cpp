#
include
"
HTMLEditor
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
StyleDifference
=
HTMLEditUtils
:
:
StyleDifference
;
using
WalkTextOption
=
HTMLEditUtils
:
:
WalkTextOption
;
using
WalkTreeDirection
=
HTMLEditUtils
:
:
WalkTreeDirection
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
static
bool
IsStyleCachePreservingSubAction
(
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertQuotation
:
case
EditSubAction
:
:
eInsertQuotedText
:
return
true
;
default
:
return
false
;
}
}
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
EditorDOMPoint
&
aStartPoint
EditorDOMPoint
&
aEndPoint
const
Element
&
aEditingHost
)
const
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
EditorRawDOMPoint
&
aStartPoint
EditorDOMPoint
&
aEndPoint
const
Element
&
aEditingHost
)
const
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
EditorDOMPoint
&
aStartPoint
EditorRawDOMPoint
&
aEndPoint
const
Element
&
aEditingHost
)
const
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
EditorRawDOMPoint
&
aStartPoint
EditorRawDOMPoint
&
aEndPoint
const
Element
&
aEditingHost
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMRange
&
aRange
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMRange
&
aRange
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorDOMRange
&
aRange
EditSubAction
aEditSubAction
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorRawDOMRange
&
aRange
EditSubAction
aEditSubAction
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
EditSubAction
aEditSubAction
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
EditSubAction
aEditSubAction
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
EditSubAction
aEditSubAction
)
const
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
EditSubAction
aEditSubAction
)
const
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
EditorDOMPoint
&
aPoint
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
const
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
EditorRawDOMPoint
&
aPoint
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
const
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
const
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
const
;
nsresult
HTMLEditor
:
:
InitEditorContentAndSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
EditorBase
:
:
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
return
rv
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
&
&
!
GetDocument
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
bodyOrDocumentElement
)
{
return
NS_OK
;
}
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
RawRangeBoundary
(
bodyOrDocumentElement
0u
)
RawRangeBoundary
(
bodyOrDocumentElement
bodyOrDocumentElement
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aTopLevelEditSubAction
aDirectionOfTopLevelEditSubAction
aRv
)
;
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
aTopLevelEditSubAction
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
aDirectionOfTopLevelEditSubAction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
!
mInitSucceeded
)
{
return
;
}
NS_WARNING_ASSERTION
(
!
aRv
.
Failed
(
)
"
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
"
)
;
const
auto
atCompositionStart
=
GetFirstIMESelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
atCompositionStart
.
IsSet
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
atCompositionStart
GetLastIMESelectionEndPoint
<
EditorRawDOMPoint
>
(
)
)
;
}
else
{
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
*
range
)
;
}
}
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
bool
cacheInlineStyles
;
switch
(
aTopLevelEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
cacheInlineStyles
=
true
;
break
;
default
:
cacheInlineStyles
=
IsStyleCachePreservingSubAction
(
aTopLevelEditSubAction
)
;
break
;
}
if
(
cacheInlineStyles
)
{
nsCOMPtr
<
nsIContent
>
containerContent
=
nsIContent
:
:
FromNodeOrNull
(
aDirectionOfTopLevelEditSubAction
=
=
nsIEditor
:
:
eNext
?
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mEndContainer
:
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mStartContainer
)
;
if
(
NS_WARN_IF
(
!
containerContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
rv
=
CacheInlineStyles
(
*
containerContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CacheInlineStyles
(
)
failed
"
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
=
true
;
}
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
;
while
(
true
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
rv
=
NS_ERROR_EDITOR_DESTROYED
;
break
;
}
if
(
!
mInitSucceeded
)
{
rv
=
NS_OK
;
break
;
}
rv
=
OnEndHandlingTopLevelEditSubActionInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
failied
"
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
)
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
}
break
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
GetTopLevelEditSubAction
(
)
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
eNone
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eReplaceHeadWithHTMLSource
:
case
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
return
NS_OK
;
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
IsPositioned
(
)
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eUndo
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eRedo
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
{
EditorRawDOMRange
changedRange
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
changedRange
.
IsPositioned
(
)
&
&
changedRange
.
EnsureNotInNativeAnonymousSubtree
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eDeleteText
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
changedRange
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
default
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
changedRange
GetTopLevelEditSubAction
(
)
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
}
}
}
if
(
GetTopLevelEditSubAction
(
)
=
=
EditSubAction
:
:
eDeleteSelectedContent
&
&
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
&
&
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
auto
newCaretPosition
=
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
.
To
<
EditorDOMPoint
>
(
)
;
if
(
!
newCaretPosition
.
IsSet
(
)
)
{
NS_WARNING
(
"
There
was
no
selection
range
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
StartRef
(
)
.
AsRaw
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
break
;
default
:
{
nsresult
rv
=
CollapseAdjacentTextNodes
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
)
failed
"
)
;
return
rv
;
}
break
;
}
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mNeedsToCleanUpEmptyElements
)
{
nsresult
rv
=
RemoveEmptyNodesIn
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveEmptyNodesIn
(
)
failed
"
)
;
return
rv
;
}
}
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidNormalizeWhitespaces
)
{
break
;
}
[
[
fallthrough
]
]
;
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
{
auto
pointToAdjust
=
GetLastIMESelectionEndPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
pointToAdjust
.
IsInContentNode
(
)
)
{
pointToAdjust
=
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
.
To
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToAdjust
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
EditorUtils
:
:
IsEditableContent
(
*
pointToAdjust
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
AutoTrackDOMPoint
trackPointToAdjust
(
RangeUpdaterRef
(
)
&
pointToAdjust
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
pointToAdjust
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStart
=
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
;
if
(
atStart
!
=
pointToAdjust
&
&
atStart
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atStart
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
AutoTrackDOMPoint
trackPointToAdjust
(
RangeUpdaterRef
(
)
&
pointToAdjust
)
;
AutoTrackDOMPoint
trackStartPoint
(
RangeUpdaterRef
(
)
&
atStart
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
atStart
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
}
EditorDOMPoint
atEnd
=
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
EndPoint
(
)
;
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsCollapsed
(
)
&
&
atEnd
!
=
pointToAdjust
&
&
atEnd
!
=
atStart
&
&
atEnd
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atEnd
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
atEnd
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
}
break
;
}
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretInBlockElement
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBlockElement
(
)
failed
but
ignored
"
)
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
rv
=
AdjustCaretPositionAndEnsurePaddingBRElement
(
GetDirectionOfTopLevelEditSubAction
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
)
"
"
failed
"
)
;
return
rv
;
}
break
;
default
:
break
;
}
}
bool
reapplyCachedStyle
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
reapplyCachedStyle
=
true
;
break
;
default
:
reapplyCachedStyle
=
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
;
break
;
}
if
(
mPlaceholderBatch
&
&
TopLevelEditSubActionDataRef
(
)
.
mNeedsToCleanUpEmptyElements
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
GetFocusNode
(
)
)
{
RefPtr
<
Element
>
mostDistantEmptyInlineAncestor
=
nullptr
;
for
(
Element
*
ancestor
:
SelectionRef
(
)
.
GetFocusNode
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
!
ancestor
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
*
ancestor
)
|
|
!
HTMLEditUtils
:
:
IsEmptyInlineContent
(
*
ancestor
)
)
{
break
;
}
mostDistantEmptyInlineAncestor
=
ancestor
;
}
if
(
mostDistantEmptyInlineAncestor
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
mostDistantEmptyInlineAncestor
)
;
if
(
Destroyed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
caused
destroying
the
"
"
editor
at
deleting
empty
inline
ancestors
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
at
deleting
"
"
empty
inline
ancestors
"
)
;
return
rv
;
}
}
}
if
(
reapplyCachedStyle
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mTypeInState
-
>
UpdateSelState
(
SelectionRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TypeInState
:
:
UpdateSelState
(
)
failed
but
ignored
"
)
;
rvIgnored
=
ReapplyCachedStyles
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
}
rv
=
HandleInlineSpellCheck
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
HandleInlineSpellCheck
(
)
failed
"
)
;
return
rv
;
}
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
SetSelectionInterlinePosition
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
EditActionCanceled
(
)
;
}
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
nsINode
*
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
selStartNode
)
|
|
NS_WARN_IF
(
!
selStartNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selStartNode
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
selStartNode
-
>
AsContent
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
selEndNode
)
|
|
NS_WARN_IF
(
!
selEndNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
selStartNode
=
=
selEndNode
)
{
return
EditActionIgnored
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selEndNode
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
selEndNode
-
>
AsContent
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
commonAncestor
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
commonAncestor
)
{
NS_WARNING
(
"
AbstractRange
:
:
GetClosestCommonInclusiveAncestor
(
)
returned
nullptr
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
return
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
commonAncestor
)
?
EditActionIgnored
(
)
:
EditActionCanceled
(
)
;
}
MOZ_CAN_RUN_SCRIPT
static
nsStaticAtom
&
MarginPropertyAtomForIndent
(
nsIContent
&
aContent
)
{
nsAutoString
direction
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
aContent
*
nsGkAtoms
:
:
direction
direction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
direction
)
"
"
failed
but
ignored
"
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atSelectionStart
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atSelectionStart
.
IsSetAndValid
(
)
)
;
if
(
!
atSelectionStart
.
IsInContentNode
(
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
did
nothing
"
"
because
of
no
editing
host
"
)
;
return
NS_OK
;
}
nsIContent
*
previousBRElement
=
HTMLEditUtils
:
:
GetPreviousContent
(
atSelectionStart
{
}
editingHost
)
;
if
(
!
previousBRElement
|
|
!
previousBRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
!
previousBRElement
-
>
GetParent
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
previousBRElement
-
>
GetParent
(
)
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
previousBRElement
)
)
{
return
NS_OK
;
}
const
RefPtr
<
const
Element
>
blockElementAtSelectionStart
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atSelectionStart
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
const
RefPtr
<
const
Element
>
parentBlockElementOfBRElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
previousBRElement
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
!
blockElementAtSelectionStart
|
|
blockElementAtSelectionStart
!
=
parentBlockElementOfBRElement
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atInvisibleBRElement
(
previousBRElement
)
;
nsresult
rv
=
CollapseSelectionTo
(
atInvisibleBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
mPaddingBRElementForEmptyEditor
)
{
return
NS_OK
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
NS_OK
;
}
EditorType
editorType
=
GetEditorType
(
)
;
bool
isRootEditable
=
EditorUtils
:
:
IsEditableContent
(
*
rootElement
editorType
)
;
for
(
nsIContent
*
rootChild
=
rootElement
-
>
GetFirstChild
(
)
;
rootChild
;
rootChild
=
rootChild
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
rootChild
)
|
|
!
isRootEditable
|
|
EditorUtils
:
:
IsEditableContent
(
*
rootChild
editorType
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
rootChild
)
)
{
return
NS_OK
;
}
}
if
(
IsHTMLEditor
(
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
rootElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
newBRElement
=
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
newBRElement
.
get
(
)
)
;
newBRElement
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_EDITOR
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
*
newBRElement
EditorDOMPoint
(
rootElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rv
=
CollapseSelectionToStartOf
(
*
rootElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mPaddingBRElementForEmptyEditor
)
{
return
NS_OK
;
}
RefPtr
<
HTMLBRElement
>
paddingBRElement
(
std
:
:
move
(
mPaddingBRElementForEmptyEditor
)
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
paddingBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ReflectPaddingBRElementForEmptyEditor
(
)
{
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
NS_WARNING
(
"
Failed
to
handle
padding
BR
element
due
to
no
root
element
"
)
;
return
NS_ERROR_FAILURE
;
}
nsIContent
*
firstLeafChild
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
mRootElement
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
if
(
firstLeafChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
firstLeafChild
)
)
{
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
firstLeafChild
)
;
}
else
{
mPaddingBRElementForEmptyEditor
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
"
)
;
return
rv
;
}
break
;
}
default
:
break
;
}
}
if
(
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
SelectionHandling
aSelectionHandling
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
MOZ_ASSERT_IF
(
aSelectionHandling
=
=
SelectionHandling
:
:
Ignore
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
aSelectionHandling
=
=
SelectionHandling
:
:
Delete
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
"
"
nsIEditor
:
:
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
const
nsRange
>
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
rv
=
CreateStyleForInsertText
(
*
firstRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateStyleForInsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
GetDocument
(
)
-
>
IsXMLDocument
(
)
?
LimitInBodyElement
:
:
No
:
LimitInBodyElement
:
:
Yes
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
while
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
if
(
NS_WARN_IF
(
pointToInsert
.
GetContainer
(
)
=
=
editingHost
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
GetContainerParentAsContent
(
)
)
)
{
NS_WARNING
(
"
Selection
start
point
couldn
'
t
have
text
nodes
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
pointToInsert
.
Set
(
pointToInsert
.
ContainerAsContent
(
)
)
;
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
auto
compositionStartPoint
=
GetFirstIMESelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
pointToInsert
.
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
aInsertionString
.
IsEmpty
(
)
)
{
nsresult
rv
=
InsertTextWithTransaction
(
*
document
aInsertionString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
auto
compositionEndPoint
=
GetLastIMESelectionEndPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
!
compositionEndPoint
.
IsSet
(
)
)
{
compositionEndPoint
=
compositionStartPoint
;
}
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
*
this
aInsertionString
EditorDOMRange
(
compositionStartPoint
compositionEndPoint
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
compositionStartPoint
=
GetFirstIMESelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
compositionEndPoint
=
GetLastIMESelectionEndPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
compositionStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
compositionEndPoint
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
)
;
}
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
compositionStartPoint
.
ToRawRangeBoundary
(
)
compositionEndPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
pointToInsert
.
ContainerAsContent
(
)
)
;
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
int32_t
pos
=
0
;
constexpr
auto
newlineStr
=
NS_LITERAL_STRING_FROM_CSTRING
(
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
!
isWhiteSpaceCollapsible
|
|
IsInPlaintextMode
(
)
)
{
while
(
pos
!
=
-
1
&
&
pos
<
AssertedCast
<
int32_t
>
(
aInsertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
aInsertionString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
aInsertionString
.
Length
(
)
-
oldPos
;
pos
=
aInsertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
aInsertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
eNone
)
"
"
failed
"
)
;
return
EditActionHandled
(
resultOfInsertingBRElement
.
unwrapErr
(
)
)
;
}
pos
+
+
;
RefPtr
<
Element
>
brElement
(
resultOfInsertingBRElement
.
unwrap
(
)
.
forget
(
)
)
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
brElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
"
"
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
subStr
currentPoint
.
To
<
EditorRawDOMPoint
>
(
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
currentPoint
=
pointAfterInsertedString
.
To
<
EditorDOMPoint
>
(
)
;
pointToInsert
=
pointAfterInsertedString
.
To
<
EditorDOMPoint
>
(
)
;
}
}
}
else
{
constexpr
auto
tabStr
=
u
"
\
t
"
_ns
;
constexpr
auto
spacesStr
=
u
"
"
_ns
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
nsAutoString
insertionString
(
aInsertionString
)
;
while
(
pos
!
=
-
1
&
&
pos
<
AssertedCast
<
int32_t
>
(
insertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
insertionString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
insertionString
.
Length
(
)
-
oldPos
;
pos
=
insertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
insertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
spacesStr
currentPoint
&
pointAfterInsertedSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
pos
+
+
;
MOZ_ASSERT
(
pointAfterInsertedSpaces
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedSpaces
.
To
<
EditorDOMPoint
>
(
)
;
pointToInsert
=
pointAfterInsertedSpaces
.
To
<
EditorDOMPoint
>
(
)
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
currentPoint
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
inspectErr
(
)
)
;
}
pos
+
+
;
RefPtr
<
Element
>
newBRElement
=
result
.
unwrap
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
newBRElement
)
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
newBRElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
subStr
currentPoint
&
pointAfterInsertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
pointAfterInsertedString
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedString
.
To
<
EditorDOMPoint
>
(
)
;
pointToInsert
=
pointAfterInsertedString
.
To
<
EditorDOMPoint
>
(
)
;
}
}
}
}
if
(
currentPoint
.
IsSet
(
)
)
{
currentPoint
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
nsresult
rv
=
CollapseSelectionTo
(
currentPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
currentPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
CollapseTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertLineBreakAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
rv
;
}
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
GetDefaultParagraphSeparator
(
)
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
atStartOfSelection
*
editingHost
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
atStartOfSelection
nsIEditor
:
:
eNext
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
return
NS_OK
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
atStartOfSelection
=
EditorDOMPoint
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
rv
=
HandleInsertLinefeed
(
atStartOfSelection
*
editingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertParagraphSeparator
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
IsMailEditor
(
)
)
{
auto
pointToSplit
=
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
.
To
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
RefPtr
<
Element
>
mailCiteElement
=
GetMostDistantAncestorMailCiteElement
(
*
pointToSplit
.
ContainerAsContent
(
)
)
)
{
Result
<
EditorDOMPoint
nsresult
>
atNewBRElementOrError
=
HandleInsertParagraphInMailCiteElement
(
*
mailCiteElement
pointToSplit
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
atNewBRElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInMailCiteElement
(
)
failed
"
)
;
return
EditActionHandled
(
atNewBRElementOrError
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
atNewBRElementOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToPutCaret
.
IsSet
(
)
)
;
pointToPutCaret
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
MOZ_ASSERT
(
pointToPutCaret
.
GetChild
(
)
)
;
MOZ_ASSERT
(
pointToPutCaret
.
GetChild
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
editingHost
-
>
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
editingHost
-
>
GetParentElement
(
)
)
&
&
(
!
atStartOfSelection
.
IsInContentNode
(
)
|
|
!
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
atStartOfSelection
.
ContainerAsContent
(
)
editingHost
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
RefPtr
<
Element
>
editableBlockElement
=
atStartOfSelection
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atStartOfSelection
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
:
nullptr
;
ParagraphSeparator
separator
=
GetDefaultParagraphSeparator
(
)
;
bool
insertLineBreak
;
if
(
!
editableBlockElement
)
{
insertLineBreak
=
true
;
}
else
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
)
{
insertLineBreak
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
editingHost
)
|
|
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
atStartOfSelection
*
editingHost
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
editableBlockElement
)
)
{
insertLineBreak
=
false
;
}
else
{
insertLineBreak
=
true
;
for
(
const
Element
*
editableBlockAncestor
=
editableBlockElement
;
editableBlockAncestor
&
&
insertLineBreak
;
editableBlockAncestor
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
editableBlockAncestor
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
{
insertLineBreak
=
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
editableBlockAncestor
)
;
}
}
if
(
insertLineBreak
)
{
if
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
atStartOfSelection
*
editingHost
)
)
{
nsresult
rv
=
HandleInsertLinefeed
(
atStartOfSelection
*
editingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
rv
=
HandleInsertBRElement
(
atStartOfSelection
*
editingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
FormatBlockContainerWithTransaction
(
MOZ_KnownLive
(
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
separator
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsInContentNode
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atStartOfSelection
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
NS_WARN_IF
(
!
editableBlockElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
)
)
{
nsresult
rv
=
HandleInsertBRElement
(
atStartOfSelection
*
editingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
editableBlockElement
;
}
if
(
HTMLEditUtils
:
:
IsEmptyBlockElement
(
*
editableBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditorDOMPoint
endOfBlockParent
;
endOfBlockParent
.
SetToEndOf
(
editableBlockElement
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
endOfBlockParent
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
EditActionIgnored
(
resultOfInsertingBRElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
}
RefPtr
<
Element
>
maybeNonEditableListItem
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
*
editableBlockElement
editingHost
)
;
if
(
maybeNonEditableListItem
&
&
HTMLEditUtils
:
:
IsSplittableNode
(
*
maybeNonEditableListItem
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
HandleInsertParagraphInListItemElement
(
*
maybeNonEditableListItem
atStartOfSelection
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
unwrapErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
)
failed
but
"
"
ignored
"
)
;
return
EditActionHandled
(
)
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
editableBlockElement
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
HandleInsertParagraphInHeadingElement
(
*
editableBlockElement
atStartOfSelection
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
unwrapErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
)
failed
but
"
"
ignored
"
)
;
return
EditActionHandled
(
)
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditActionResult
result
=
HandleInsertParagraphInParagraph
(
*
editableBlockElement
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
Handled
(
)
)
{
lockOffset
.
Cancel
(
)
;
return
result
;
}
MOZ_ASSERT
(
!
result
.
Canceled
(
)
"
HandleInsertParagraphInParagraph
(
)
canceled
this
edit
action
"
"
InsertParagraphSeparatorAsSubAction
(
)
needs
to
handle
this
"
"
action
instead
"
)
;
}
rv
=
HandleInsertBRElement
(
atStartOfSelection
*
editingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
HandleInsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
brElementIsAfterBlock
=
false
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsInPlaintextMode
(
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
aPointToBreak
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
brElement
=
resultOfInsertingBRElement
.
unwrap
(
)
.
forget
(
)
;
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunScanner
wsRunScanner
(
&
aEditingHost
pointToBreak
)
;
WSScanResult
backwardScanResult
=
wsRunScanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
;
if
(
backwardScanResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
brElementIsAfterBlock
=
backwardScanResult
.
ReachedBlockBoundary
(
)
;
WSScanResult
forwardScanResult
=
wsRunScanner
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
;
if
(
forwardScanResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
brElementIsBeforeBlock
=
forwardScanResult
.
ReachedBlockBoundary
(
)
;
RefPtr
<
Element
>
linkNode
=
HTMLEditor
:
:
GetLinkElement
(
pointToBreak
.
GetContainer
(
)
)
;
if
(
linkNode
)
{
SplitNodeResult
splitLinkNodeResult
=
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitLinkNodeResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitLinkNodeResult
.
Rv
(
)
;
}
pointToBreak
=
splitLinkNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
pointToBreak
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
result
.
inspectErr
(
)
;
}
brElement
=
result
.
unwrap
(
)
;
MOZ_ASSERT
(
brElement
)
;
}
if
(
NS_WARN_IF
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
brElement
InterlinePosition
:
:
StartOfNextLine
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
afterBRElement
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
WSScanResult
forwardScanFromAfterBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
afterBRElement
)
;
if
(
forwardScanFromAfterBRElementResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
forwardScanFromAfterBRElementResult
.
ReachedBRElement
(
)
)
{
if
(
brElement
-
>
GetNextSibling
(
)
!
=
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
{
MOZ_ASSERT
(
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
afterBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
afterBRElement
.
SetInterlinePosition
(
nextSiblingOfBRElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSiblingOfBRElement
)
?
InterlinePosition
:
:
EndOfLine
:
InterlinePosition
:
:
StartOfNextLine
)
;
nsresult
rv
=
CollapseSelectionTo
(
afterBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleInsertLinefeed
(
const
EditorDOMPoint
&
aPointToBreak
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
const
nsRange
>
caretRange
=
nsRange
:
:
Create
(
aPointToBreak
.
ToRawRangeBoundary
(
)
aPointToBreak
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
caretRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CreateStyleForInsertText
(
*
caretRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateStyleForInsertText
(
)
failed
"
)
;
return
rv
;
}
caretRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
caretRange
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
pointToInsert
(
caretRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
&
&
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
ContainerAsContent
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
couldn
'
t
insert
a
linefeed
because
"
"
the
insertion
position
couldn
'
t
have
text
nodes
"
)
;
return
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
MOZ_ASSERT
(
document
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorRawDOMPoint
caretAfterInsert
;
{
AutoTrackDOMPoint
trackingInsertingPosition
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
u
"
\
n
"
_ns
pointToInsert
.
To
<
EditorRawDOMPoint
>
(
)
&
caretAfterInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
caretAfterInsert
.
IsInContentNode
(
)
&
&
caretAfterInsert
.
IsEndOfContainer
(
)
)
{
WSRunScanner
wsScannerAtCaret
(
&
aEditingHost
caretAfterInsert
)
;
if
(
wsScannerAtCaret
.
StartsFromPreformattedLineBreak
(
)
&
&
wsScannerAtCaret
.
EndsByBlockBoundary
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
wsScannerAtCaret
.
GetEndReasonContent
(
)
*
nsGkAtoms
:
:
br
)
)
{
auto
newCaretPosition
=
caretAfterInsert
.
To
<
EditorDOMPoint
>
(
)
;
{
AutoTrackDOMPoint
trackingInsertedPosition
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
newCaretPosition
nsIEditor
:
:
ePrevious
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
}
caretAfterInsert
=
newCaretPosition
.
To
<
EditorRawDOMPoint
>
(
)
;
}
}
if
(
NS_WARN_IF
(
!
caretAfterInsert
.
IsSet
(
)
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
if
(
NS_FAILED
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
CollapseTo
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_ERROR_FAILURE
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
caretAfterInsert
.
ToRawRangeBoundary
(
)
)
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
caretAfterInsert
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
rv
=
CollapseSelectionTo
(
caretAfterInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertParagraphInMailCiteElement
(
Element
&
aMailCiteElement
const
EditorDOMPoint
&
aPointToSplit
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aMailCiteElement
)
"
The
mail
-
cite
element
will
be
deleted
does
it
expected
result
"
"
for
you
?
"
)
;
SplitNodeResult
splitCiteElementResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
WSScanResult
forwardScanFromPointToSplitResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
pointToSplit
)
;
if
(
forwardScanFromPointToSplitResult
.
Failed
(
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromPointToSplitResult
.
ReachedBRElement
(
)
&
&
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
!
=
&
aMailCiteElement
&
&
aMailCiteElement
.
Contains
(
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
)
)
{
pointToSplit
=
forwardScanFromPointToSplitResult
.
PointAfterContent
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
result
=
SplitNodeDeepWithTransaction
(
aMailCiteElement
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aMailCiteElement
"
"
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
result
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
splitCiteElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
Failed
to
split
a
mail
-
cite
element
"
)
;
return
Err
(
splitCiteElementResult
.
Rv
(
)
)
;
}
Element
*
const
leftCiteElement
=
Element
:
:
FromNodeOrNull
(
splitCiteElementResult
.
GetPreviousContent
(
)
)
;
Element
*
const
rightCiteElement
=
Element
:
:
FromNodeOrNull
(
splitCiteElementResult
.
GetNextContent
(
)
)
;
if
(
leftCiteElement
&
&
leftCiteElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsIContent
*
lastChild
=
leftCiteElement
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingInvisibleBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
*
leftCiteElement
)
)
;
if
(
MOZ_UNLIKELY
(
resultOfInsertingInvisibleBRElement
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
resultOfInsertingInvisibleBRElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
resultOfInsertingInvisibleBRElement
.
inspect
(
)
)
;
}
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
splitCiteElementResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
resultOfInsertingBRElement
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
resultOfInsertingBRElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
aMailCiteElement
)
)
{
nsresult
rvOfInsertingBRElement
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
pointToCreateNewBRElement
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
WSScanResult
backwardScanFromPointToCreateNewBRElementResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
&
aEditingHost
pointToCreateNewBRElement
)
;
if
(
MOZ_UNLIKELY
(
backwardScanFromPointToCreateNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
backwardScanFromPointToCreateNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
backwardScanFromPointToCreateNewBRElementResult
.
ReachedSpecialContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
WSScanResult
forwardScanFromPointAfterNewBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
EditorRawDOMPoint
:
:
After
(
pointToCreateNewBRElement
)
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromPointAfterNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
forwardScanFromPointAfterNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedSpecialContent
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToCreateNewBRElement
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
result
.
inspect
(
)
)
;
return
NS_OK
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rvOfInsertingBRElement
)
)
)
{
NS_WARNING
(
"
Failed
to
insert
additional
<
br
>
element
before
the
inline
right
"
"
mail
-
cite
element
"
)
;
return
Err
(
rvOfInsertingBRElement
)
;
}
}
if
(
leftCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftCiteElement
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
leftCiteElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
rightCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
rightCiteElement
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightCiteElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
resultOfInsertingBRElement
.
inspect
(
)
-
>
GetParent
(
)
)
)
{
NS_WARNING
(
"
Inserted
<
br
>
shouldn
'
t
become
an
orphan
node
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
EditorDOMPoint
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsStartOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetPreviousCharPointType
(
aPoint
)
)
;
}
EditorDOMPointInText
previousCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
GetActiveEditingHost
(
)
aPoint
)
;
if
(
!
previousCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
previousCharPoint
)
)
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetCharPointType
(
aPoint
)
)
;
}
EditorDOMPointInText
nextCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
GetActiveEditingHost
(
)
aPoint
)
;
if
(
!
nextCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
nextCharPoint
)
)
;
}
void
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
nsAString
&
aResult
uint32_t
aLength
const
CharPointData
&
aPreviousCharPointData
const
CharPointData
&
aNextCharPointData
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aLength
)
;
MOZ_ASSERT
(
aPreviousCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aPreviousCharPointData
.
IsCollapsibleWhiteSpace
(
)
)
;
MOZ_ASSERT
(
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aNextCharPointData
.
IsCollapsibleWhiteSpace
(
)
)
;
if
(
aLength
=
=
1
)
{
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
&
&
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kNBSP
)
;
return
;
}
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kNBSP
)
;
return
;
}
aResult
.
Assign
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
aResult
.
SetLength
(
aLength
)
;
bool
appendNBSP
=
true
;
char16_t
*
lastChar
=
aResult
.
EndWriting
(
)
-
1
;
for
(
char16_t
*
iter
=
aResult
.
BeginWriting
(
)
;
iter
!
=
lastChar
;
iter
+
+
)
{
*
iter
=
appendNBSP
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
appendNBSP
=
!
appendNBSP
;
}
if
(
appendNBSP
)
{
*
lastChar
=
HTMLEditUtils
:
:
kNBSP
;
return
;
}
*
lastChar
=
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
}
void
HTMLEditor
:
:
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
EditorDOMPointInText
&
aStartToDelete
EditorDOMPointInText
&
aEndToDelete
nsAString
&
aNormalizedWhiteSpacesInStartNode
nsAString
&
aNormalizedWhiteSpacesInEndNode
)
const
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInStartNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
IsEmpty
(
)
)
;
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
EditorDOMPointInText
precedingCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
editingHost
aStartToDelete
)
;
EditorDOMPointInText
followingCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
editingHost
aEndToDelete
)
;
const
bool
removingLastCharOfStartNode
=
aStartToDelete
.
ContainerAsText
(
)
!
=
aEndToDelete
.
ContainerAsText
(
)
|
|
(
aEndToDelete
.
IsEndOfContainer
(
)
&
&
followingCharPoint
.
IsSet
(
)
)
;
const
bool
maybeNormalizePrecedingWhiteSpaces
=
!
removingLastCharOfStartNode
&
&
precedingCharPoint
.
IsSet
(
)
&
&
!
precedingCharPoint
.
IsEndOfContainer
(
)
&
&
precedingCharPoint
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
&
&
precedingCharPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
;
const
bool
maybeNormalizeFollowingWhiteSpaces
=
followingCharPoint
.
IsSet
(
)
&
&
!
followingCharPoint
.
IsEndOfContainer
(
)
&
&
(
followingCharPoint
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
|
|
removingLastCharOfStartNode
)
&
&
followingCharPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
;
if
(
!
maybeNormalizePrecedingWhiteSpaces
&
&
!
maybeNormalizeFollowingWhiteSpaces
)
{
return
;
}
EditorDOMPointInText
startToNormalize
endToNormalize
;
if
(
maybeNormalizePrecedingWhiteSpaces
)
{
Maybe
<
uint32_t
>
previousCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
precedingCharPoint
{
WalkTextOption
:
:
TreatNBSPsCollapsible
}
)
;
startToNormalize
.
Set
(
precedingCharPoint
.
ContainerAsText
(
)
previousCharOffsetOfWhiteSpaces
.
isSome
(
)
?
previousCharOffsetOfWhiteSpaces
.
value
(
)
+
1
:
0
)
;
MOZ_ASSERT
(
!
startToNormalize
.
IsEndOfContainer
(
)
)
;
}
if
(
maybeNormalizeFollowingWhiteSpaces
)
{
Maybe
<
uint32_t
>
nextCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
followingCharPoint
{
WalkTextOption
:
:
TreatNBSPsCollapsible
}
)
;
if
(
nextCharOffsetOfWhiteSpaces
.
isSome
(
)
)
{
endToNormalize
.
Set
(
followingCharPoint
.
ContainerAsText
(
)
nextCharOffsetOfWhiteSpaces
.
value
(
)
)
;
}
else
{
endToNormalize
.
SetToEndOf
(
followingCharPoint
.
ContainerAsText
(
)
)
;
}
MOZ_ASSERT
(
!
endToNormalize
.
IsStartOfContainer
(
)
)
;
}
CharPointData
previousCharPointData
=
removingLastCharOfStartNode
?
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
startToNormalize
.
IsSet
(
)
?
startToNormalize
:
aStartToDelete
)
;
CharPointData
nextCharPointData
=
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
endToNormalize
.
IsSet
(
)
?
endToNormalize
:
aEndToDelete
)
;
uint32_t
lengthInStartNode
=
0
lengthInEndNode
=
0
;
if
(
startToNormalize
.
IsSet
(
)
)
{
MOZ_ASSERT
(
startToNormalize
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
)
;
lengthInStartNode
=
aStartToDelete
.
Offset
(
)
-
startToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInStartNode
)
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
lengthInEndNode
=
endToNormalize
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
?
endToNormalize
.
Offset
(
)
-
aEndToDelete
.
Offset
(
)
:
endToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInEndNode
)
;
if
(
endToNormalize
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
)
{
lengthInStartNode
+
=
lengthInEndNode
;
lengthInEndNode
=
0
;
}
}
MOZ_ASSERT
(
lengthInStartNode
+
lengthInEndNode
)
;
if
(
!
lengthInEndNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInStartNode
lengthInStartNode
previousCharPointData
nextCharPointData
)
;
}
else
if
(
!
lengthInStartNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInEndNode
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
}
else
{
nsAutoString
whiteSpaces
;
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
whiteSpaces
lengthInStartNode
+
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
aNormalizedWhiteSpacesInStartNode
=
Substring
(
whiteSpaces
0
lengthInStartNode
)
;
aNormalizedWhiteSpacesInEndNode
=
Substring
(
whiteSpaces
lengthInStartNode
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
Length
(
)
=
=
lengthInEndNode
)
;
}
if
(
startToNormalize
.
IsSet
(
)
)
{
aStartToDelete
=
startToNormalize
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
aEndToDelete
=
endToNormalize
;
}
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
const
EditorDOMPointInText
&
aStartToDelete
const
EditorDOMPointInText
&
aEndToDelete
TreatEmptyTextNodes
aTreatEmptyTextNodes
DeleteDirection
aDeleteDirection
)
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
nsString
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
;
EditorDOMPointInText
startToDelete
(
aStartToDelete
)
;
EditorDOMPointInText
endToDelete
(
aEndToDelete
)
;
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
startToDelete
endToDelete
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
)
;
if
(
startToDelete
=
=
endToDelete
)
{
return
aStartToDelete
.
To
<
EditorDOMPoint
>
(
)
;
}
EditorDOMPoint
newCaretPosition
;
if
(
aStartToDelete
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
)
{
newCaretPosition
=
aEndToDelete
.
To
<
EditorDOMPoint
>
(
)
;
}
else
if
(
aDeleteDirection
=
=
DeleteDirection
:
:
Forward
)
{
newCaretPosition
.
SetToEndOf
(
aStartToDelete
.
ContainerAsText
(
)
)
;
}
else
{
newCaretPosition
.
Set
(
aEndToDelete
.
ContainerAsText
(
)
0u
)
;
}
while
(
true
)
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
if
(
!
normalizedWhiteSpacesInFirstNode
.
IsEmpty
(
)
)
{
EditorDOMPoint
trackingEndToDelete
(
endToDelete
.
ContainerAsText
(
)
endToDelete
.
Offset
(
)
)
;
{
AutoTrackDOMPoint
trackEndToDelete
(
RangeUpdaterRef
(
)
&
trackingEndToDelete
)
;
uint32_t
lengthToReplaceInFirstTextNode
=
startToDelete
.
ContainerAsText
(
)
=
=
trackingEndToDelete
.
ContainerAsText
(
)
?
trackingEndToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
:
startToDelete
.
ContainerAsText
(
)
-
>
TextLength
(
)
-
startToDelete
.
Offset
(
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAsText
(
)
)
startToDelete
.
Offset
(
)
lengthToReplaceInFirstTextNode
normalizedWhiteSpacesInFirstNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
startToDelete
.
ContainerAsText
(
)
=
=
trackingEndToDelete
.
ContainerAsText
(
)
)
{
MOZ_ASSERT
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
break
;
}
}
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
(
NS_WARN_IF
(
!
trackingEndToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
trackingEndToDelete
.
IsInTextNode
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
trackingEndToDelete
.
IsInTextNode
(
)
)
;
endToDelete
.
Set
(
trackingEndToDelete
.
ContainerAsText
(
)
trackingEndToDelete
.
Offset
(
)
)
;
startToDelete
=
EditorDOMPointInText
:
:
AtEndOf
(
*
startToDelete
.
ContainerAsText
(
)
)
;
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
NS_WARN_IF
(
!
startToDelete
.
IsBefore
(
endToDelete
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
|
|
startToDelete
.
ContainerAsText
(
)
!
=
endToDelete
.
ContainerAsText
(
)
)
{
EditorDOMPointInText
endToDeleteExceptReplaceRange
=
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
?
endToDelete
:
EditorDOMPointInText
(
endToDelete
.
ContainerAsText
(
)
0
)
;
if
(
startToDelete
!
=
endToDeleteExceptReplaceRange
)
{
nsresult
rv
=
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDeleteExceptReplaceRange
aTreatEmptyTextNodes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
{
break
;
}
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
&
&
(
NS_WARN_IF
(
!
endToDeleteExceptReplaceRange
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
endToDelete
.
IsStartOfContainer
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
startToDelete
=
endToDeleteExceptReplaceRange
;
}
}
MOZ_ASSERT
(
!
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
ContainerAsText
(
)
=
=
endToDelete
.
ContainerAsText
(
)
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAsText
(
)
)
startToDelete
.
Offset
(
)
endToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
normalizedWhiteSpacesInLastNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
break
;
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
|
|
!
newCaretPosition
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
got
lost
"
"
the
modifying
line
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
newCaretPosition
.
IsInTextNode
(
)
)
{
if
(
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
newCaretPosition
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
newCaretPosition
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
editingHost
)
;
if
(
previousContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
newCaretPosition
=
previousContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
?
EditorDOMPoint
:
:
AtEndOf
(
*
previousContent
)
:
EditorDOMPoint
:
:
After
(
*
previousContent
)
;
}
else
if
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
newCaretPosition
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
editingHost
)
)
{
newCaretPosition
=
nextContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
?
EditorDOMPoint
(
nextContent
0
)
:
EditorDOMPoint
(
nextContent
)
;
}
}
}
if
(
newCaretPosition
.
IsStartOfContainer
(
)
&
&
newCaretPosition
.
IsInTextNode
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
IsText
(
)
)
{
newCaretPosition
.
SetToEndOf
(
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
AsText
(
)
)
;
}
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
Inserting
<
br
>
element
caused
unexpected
DOM
tree
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
newCaretPosition
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
!
aPointToInsert
.
GetContainerAsContent
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
aPointToInsert
.
ContainerAsContent
(
)
)
)
{
return
NS_OK
;
}
WSRunScanner
wsRunScanner
(
GetActiveEditingHost
(
)
aPointToInsert
)
;
if
(
!
wsRunScanner
.
StartsFromHardLineBreak
(
)
)
{
return
NS_OK
;
}
if
(
!
wsRunScanner
.
EndsByBlockBoundary
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
aPointToInsert
nsIEditor
:
:
ePrevious
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
ePrevious
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
nsAtom
&
aListElementOrListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
?
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
EditSubAction
:
:
eCreateOrChangeList
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
nsAtom
*
listTagName
=
nullptr
;
nsAtom
*
listItemTagName
=
nullptr
;
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
li
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
dd
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
{
listTagName
=
nsGkAtoms
:
:
dl
;
listItemTagName
=
&
aListElementOrListItemElementTagName
;
}
else
{
NS_WARNING
(
"
aListElementOrListItemElementTagName
was
neither
list
element
name
"
"
nor
"
"
definition
listitem
element
name
"
)
;
return
EditActionResult
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
result
=
ChangeSelectedHardLinesToList
(
MOZ_KnownLive
(
*
listTagName
)
MOZ_KnownLive
(
*
listItemTagName
)
aBulletType
aSelectAllOfCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
ChangeSelectedHardLinesToList
(
)
failed
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
ChangeSelectedHardLinesToList
(
nsAtom
&
aListElementTagName
nsAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
Element
*
parentListElement
=
aSelectAllOfCurrentList
=
=
SelectAllOfCurrentList
:
:
Yes
?
GetParentListElementAtSelection
(
)
:
nullptr
;
if
(
parentListElement
)
{
arrayOfContents
.
AppendElement
(
OwningNonNull
<
nsIContent
>
(
*
parentListElement
)
)
;
}
else
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
bool
bOnlyBreaks
=
true
;
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsEmptyInlineContent
(
content
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
content
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atStartOfSelection
.
GetContainer
(
)
aListElementTagName
)
)
{
return
EditActionCanceled
(
)
;
}
RefPtr
<
Element
>
newListItemElement
;
Result
<
RefPtr
<
Element
>
nsresult
>
newListElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
aListElementTagName
atStartOfSelection
BRElementNextToSplitPoint
:
:
Keep
[
&
newListItemElement
&
aListItemElementTagName
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aListElement
const
EditorDOMPoint
&
aPointToInsert
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aListElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
Result
<
RefPtr
<
Element
>
nsresult
>
listItemElementOrError
=
aHTMLEditor
.
CreateAndInsertElement
(
withTransaction
aListItemElementTagName
EditorDOMPoint
(
&
aListElement
0u
)
)
;
if
(
listItemElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
listItemElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
listItemElementOrError
.
inspect
(
)
)
;
newListItemElement
=
listItemElementOrError
.
unwrap
(
)
;
return
NS_OK
;
}
)
;
if
(
MOZ_UNLIKELY
(
newListElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
&
aListElementTagName
)
.
get
(
)
)
.
get
(
)
)
;
return
EditActionResult
(
newListElementOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
newListElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newListItemElement
;
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
newListItemElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
if
(
Element
*
deepestDivBlockquoteOrListElement
=
HTMLEditUtils
:
:
GetInclusiveDeepestFirstChildWhichHasOneChild
(
arrayOfContents
[
0
]
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
)
)
{
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
arrayOfContents
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
arrayOfContents
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
}
else
{
arrayOfContents
.
ReplaceElementAt
(
0
OwningNonNull
<
nsIContent
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
}
}
}
uint32_t
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
RefPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
countOfCollectedContents
;
i
+
+
)
{
OwningNonNull
<
nsIContent
>
content
=
arrayOfContents
[
i
]
;
if
(
curList
&
&
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
curList
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
content
)
)
{
curList
=
nullptr
;
}
if
(
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
HTMLEditUtils
:
:
IsEmptyInlineContent
(
content
)
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
content
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
convertListTypeResult
.
GetNewNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
prevListItem
=
nullptr
;
continue
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
curList
=
convertListTypeResult
.
forget
(
)
;
prevListItem
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atContent
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
!
atContent
.
IsContainerHTMLElement
(
&
aListElementTagName
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atContent
.
GetContainerAsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
atContent
)
;
if
(
MOZ_UNLIKELY
(
splitListItemParentResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
splitListItemParentResult
.
Rv
(
)
)
;
}
MOZ_ASSERT
(
splitListItemParentResult
.
DidSplit
(
)
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewListElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
aListElementTagName
splitListItemParentResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
)
;
if
(
maybeNewListElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
EditActionResult
(
maybeNewListElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
maybeNewListElement
.
inspect
(
)
)
;
curList
=
maybeNewListElement
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
else
{
if
(
!
curList
)
{
curList
=
atContent
.
GetContainerAsElement
(
)
;
NS_WARNING_ASSERTION
(
HTMLEditUtils
:
:
IsAnyListElement
(
curList
)
"
Current
list
item
parent
is
not
a
list
element
"
)
;
}
else
if
(
atContent
.
GetContainer
(
)
!
=
curList
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
Element
*
element
=
Element
:
:
FromNode
(
content
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aBulletType
.
IsEmpty
(
)
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
aBulletType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
!
element
-
>
HasAttr
(
nsGkAtoms
:
:
type
)
)
{
continue
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
&
&
!
HTMLEditUtils
:
:
IsListItem
(
content
)
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
CollectChildren
(
*
content
arrayOfContents
i
+
1
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
prevListItem
=
nullptr
;
Result
<
RefPtr
<
Element
>
nsresult
>
newListElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
aListElementTagName
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newListElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aListElementTagName
)
.
get
(
)
)
.
get
(
)
)
;
return
EditActionResult
(
newListElementOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
newListElementOrError
.
inspect
(
)
)
;
curList
=
newListElementOrError
.
unwrap
(
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curList
;
atContent
.
Clear
(
)
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
prevListItem
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
prevListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
prevListItem
=
nullptr
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
RefPtr
<
Element
>
newListItemElement
=
InsertContainerWithTransaction
(
*
content
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
prevListItem
=
newListItemElement
;
}
else
{
prevListItem
=
nullptr
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveList
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
rv
;
}
}
for
(
int32_t
i
=
arrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
i
]
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
nsAtom
&
blockType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
firstRange
-
>
StartRef
(
)
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
if
(
!
pointToInsertBlock
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
because
container
of
the
point
is
not
content
"
)
;
return
NS_ERROR_FAILURE
;
}
const
RefPtr
<
Element
>
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsertBlock
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
editableBlockElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
editableBlockElement
)
)
{
return
NS_OK
;
}
if
(
Element
*
editingHost
=
GetActiveEditingHost
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditUtils
:
:
GetNextContent
(
pointToInsertBlock
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
)
{
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
editableBlockElement
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitNodeResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
splitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
resultOfInsertingBRElement
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
if
(
Element
*
editingHost
=
GetActiveEditingHost
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
HTMLEditUtils
:
:
GetNextContent
(
pointToInsertBlock
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
maybeBRContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElement
(
maybeBRContent
)
;
}
}
}
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
blockType
pointToInsertBlock
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
&
blockType
)
.
get
(
)
)
.
get
(
)
)
;
return
newBlockElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newBlockElementOrError
.
inspect
(
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
rv
=
CollapseSelectionToStartOf
(
MOZ_KnownLive
(
*
newBlockElementOrError
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
nsresult
rv
=
MoveNodesIntoNewBlockquoteElement
(
arrayOfContents
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
)
failed
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
RemoveBlockContainerElements
(
arrayOfContents
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerElements
(
)
failed
"
)
;
return
rv
;
}
rv
=
CreateOrChangeBlockContainerElement
(
arrayOfContents
blockType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
Container
(
)
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Element
>
startContainerElement
=
*
atStartOfSelection
.
Container
(
)
-
>
AsElement
(
)
;
nsresult
rv
=
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
startContainerElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
IndentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eIndent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleIndentAtSelection
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleIndentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
IndentListChild
(
RefPtr
<
Element
>
*
aCurList
const
EditorDOMPoint
&
aCurPoint
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
aCurPoint
.
GetContainer
(
)
)
"
unexpected
container
"
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
nextEditableSibling
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aContent
EditorDOMPoint
(
nextEditableSibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EdigtorBase
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
previousEditableSibling
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aContent
*
previousEditableSibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsIContent
*
previousEditableSibling
=
*
aCurList
?
HTMLEditUtils
:
:
GetPreviousSibling
(
aContent
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
*
aCurList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
*
aCurList
)
)
{
nsAtom
*
containerName
=
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
newListElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
aCurPoint
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newListElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
containerName
)
.
get
(
)
)
.
get
(
)
)
;
return
newListElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newListElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newListElementOrError
.
inspect
(
)
;
*
aCurList
=
newListElementOrError
.
unwrap
(
)
;
}
RefPtr
<
nsINode
>
container
=
*
aCurList
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aContent
*
container
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
HandleIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
HandleCSSIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleCSSIndentAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
HandleHTMLIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleHTMLIndent
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
HandleCSSIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleCSSIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCaret
.
IsInContentNode
(
)
)
;
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atCaret
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
editableBlockElement
&
&
HTMLEditUtils
:
:
IsListItem
(
editableBlockElement
)
)
{
arrayOfContents
.
AppendElement
(
*
editableBlockElement
)
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eIndent
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newDivElementOrError
.
inspect
(
)
;
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
rv
=
CollapseSelectionToStartOf
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
curList
curQuote
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
IndentListChild
(
&
curList
atContent
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChild
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
curQuote
=
nullptr
;
continue
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newDivElementOrError
.
inspect
(
)
;
curQuote
=
newDivElementOrError
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
HandleHTMLIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleHTMLIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eIndent
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfContents
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
eIndent
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockQuoteElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atStartOfSelection
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockQuoteElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
newBlockQuoteElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockQuoteElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newBlockQuoteElementOrError
.
inspect
(
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
MOZ_KnownLive
(
*
newBlockQuoteElementOrError
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
curList
curQuote
indentedLI
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
IndentListChild
(
&
curList
atContent
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChild
(
)
failed
"
)
;
return
rv
;
}
curQuote
=
nullptr
;
continue
;
}
if
(
RefPtr
<
Element
>
listItem
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
content
editingHost
)
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
nsIContent
*
previousEditableSibling
=
curList
?
HTMLEditUtils
:
:
GetPreviousSibling
(
*
listItem
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
curList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
newListElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newListElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTr
"
"
ansaction
(
%
s
)
failed
"
nsAtomCString
(
containerName
)
.
get
(
)
)
.
get
(
)
)
;
return
newListElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newListElementOrError
.
inspect
(
)
)
;
curList
=
newListElementOrError
.
unwrap
(
)
;
}
rv
=
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
curQuote
&
&
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
curQuote
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
content
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockQuoteElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockQuoteElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
newBlockQuoteElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockQuoteElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newBlockQuoteElementOrError
.
inspect
(
)
;
curQuote
=
newBlockQuoteElementOrError
.
unwrap
(
)
;
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
OutdentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eOutdent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleOutdentAtSelection
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
SplitRangeOffFromNodeResult
outdentResult
=
HandleOutdentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
failed
"
)
;
return
EditActionHandled
(
outdentResult
.
Rv
(
)
)
;
}
if
(
!
outdentResult
.
GetLeftContent
(
)
&
&
!
outdentResult
.
GetRightContent
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
outdentResult
.
GetLeftContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetLeftContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetLeftContent
(
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
EditorRawDOMPoint
:
:
After
(
*
outdentResult
.
GetLeftContent
(
)
)
)
;
NS_WARNING_ASSERTION
(
afterRememberedLeftBQ
.
IsSet
(
)
"
Failed
to
set
after
remembered
left
blockquote
element
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
afterRememberedLeftBQ
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
if
(
outdentResult
.
GetRightContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetRightContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetRightContent
(
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
outdentResult
.
GetRightContent
(
)
)
;
nsresult
rv
=
CollapseSelectionTo
(
atRememberedRightBQ
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
return
EditActionHandled
(
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eOutdent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
)
"
"
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
leftContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
middleContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
rightContentOfLastOutdented
;
RefPtr
<
Element
>
indentedParentElement
;
nsCOMPtr
<
nsIContent
>
firstContentToBeOutdented
lastContentToBeOutdented
;
BlockIndentedWith
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
indentedParentElement
)
{
MOZ_ASSERT
(
indentedParentElement
=
=
content
)
;
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
content
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
=
0
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
"
"
Decrease
)
failed
but
ignored
"
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
indentedParentElement
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
indentedParentElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
indentedParentElement
)
)
{
lastContentToBeOutdented
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
}
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
for
(
nsCOMPtr
<
nsIContent
>
parentContent
=
content
-
>
GetParent
(
)
;
parentContent
&
&
!
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
parentContent
!
=
editingHost
&
&
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentContent
)
)
;
parentContent
=
parentContent
-
>
GetParent
(
)
)
{
if
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
break
;
}
if
(
!
useCSS
)
{
continue
;
}
nsCOMPtr
<
nsINode
>
grandParentNode
=
parentContent
-
>
GetParentNode
(
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
grandParentNode
!
=
parentContent
-
>
GetParentNode
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
parentContent
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
&
&
!
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
CSS
;
break
;
}
}
if
(
indentedParentElement
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
lastChildContent
=
content
-
>
GetLastChild
(
)
;
lastChildContent
;
lastChildContent
=
content
-
>
GetLastChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
lastChildContent
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
lastChildContent
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
lastChildContent
)
)
{
EditorDOMPoint
afterCurrentList
(
EditorDOMPoint
:
:
After
(
atContent
)
)
;
NS_WARNING_ASSERTION
(
afterCurrentList
.
IsSet
(
)
"
Failed
to
set
it
to
after
current
list
element
"
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
*
lastChildContent
afterCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
lastChildContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
)
{
if
(
RefPtr
<
Element
>
element
=
content
-
>
GetAsElementOrParentElement
(
)
)
{
nsresult
rv
=
ChangeMarginStart
(
*
element
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
"
"
Decrease
)
failed
but
ignored
"
)
;
}
continue
;
}
}
if
(
!
indentedParentElement
)
{
return
SplitRangeOffFromNodeResult
(
leftContentOfLastOutdented
middleContentOfLastOutdented
rightContentOfLastOutdented
)
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
NS_WARNING_ASSERTION
(
outdentResult
.
Succeeded
(
)
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
Element
&
aBlockElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfRange
aEndOfRange
)
;
if
(
NS_WARN_IF
(
splitResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
splitResult
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aBlockElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartOfMiddleElement
aBlockElement
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aEndOfMiddleElement
aBlockElement
)
)
;
SplitNodeResult
splitAtStartResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
EditorDOMPoint
(
&
aStartOfMiddleElement
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
splitAtStartResult
.
EditorDestroyed
(
)
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtStartResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
EditorDOMPoint
atAfterEnd
(
&
aEndOfMiddleElement
)
;
DebugOnly
<
bool
>
advanced
=
atAfterEnd
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
end
node
"
)
;
SplitNodeResult
splitAtEndResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
splitAtEndResult
.
EditorDestroyed
(
)
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtEndResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
splitAtEndResult
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOfOutdent
BlockIndentedWith
aBlockIndentedWith
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfOutdent
aEndOfOutdent
)
;
if
(
NS_WARN_IF
(
splitResult
.
EditorDestroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
splitResult
.
GetMiddleContentAsElement
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
didn
'
t
return
middle
content
"
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_FAILURE
)
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
if
(
aBlockIndentedWith
=
=
BlockIndentedWith
:
:
HTML
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
if
(
splitResult
.
GetMiddleContentAsElement
(
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Decrease
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
splitResult
;
}
return
splitResult
;
}
CreateElementResult
HTMLEditor
:
:
ChangeListElementType
(
Element
&
aListElement
nsAtom
&
aNewListTag
nsAtom
&
aNewListItemTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
nsIContent
*
childContent
=
aListElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsElement
(
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListItemTag
)
)
{
OwningNonNull
<
Element
>
listItemElement
=
*
childContent
-
>
AsElement
(
)
;
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
listItemElement
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
childContent
=
newListItemElement
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListTag
)
)
{
OwningNonNull
<
Element
>
listElement
=
*
childContent
-
>
AsElement
(
)
;
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
listElement
aNewListTag
aNewListItemTag
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
convertListTypeResult
;
}
childContent
=
convertListTypeResult
.
GetNewNode
(
)
;
continue
;
}
}
if
(
aListElement
.
IsHTMLElement
(
&
aNewListTag
)
)
{
return
CreateElementResult
(
&
aListElement
)
;
}
RefPtr
<
Element
>
listElement
=
ReplaceContainerWithTransaction
(
aListElement
aNewListTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
listElement
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
std
:
:
move
(
listElement
)
)
;
}
nsresult
HTMLEditor
:
:
CreateStyleForInsertText
(
const
AbstractRange
&
aAbstractRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAbstractRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
mTypeInState
)
;
RefPtr
<
Element
>
documentRootElement
=
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
documentRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
PropItem
>
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
EditorDOMPoint
pointToPutCaret
(
aAbstractRange
.
StartRef
(
)
)
;
bool
putCaret
=
false
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
while
(
item
&
&
pointToPutCaret
.
GetContainer
(
)
!
=
documentRootElement
)
{
EditResult
result
=
ClearStyleAt
(
pointToPutCaret
MOZ_KnownLive
(
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
item
-
>
specifiedStyle
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearStyleAt
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
pointToPutCaret
=
result
.
PointRefToCollapseSelection
(
)
;
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
putCaret
=
true
;
}
}
int32_t
relFontSize
=
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
if
(
item
|
|
relFontSize
)
{
if
(
pointToPutCaret
.
IsInTextNode
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToPutCaret
.
GetContainerAsText
(
)
)
pointToPutCaret
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitTextNodeResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitTextNodeResult
.
Rv
(
)
;
}
pointToPutCaret
=
splitTextNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
}
if
(
!
pointToPutCaret
.
IsInContentNode
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
pointToPutCaret
.
ContainerAsContent
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
Text
>
newEmptyTextNode
=
CreateTextNode
(
u
"
"
_ns
)
;
if
(
!
newEmptyTextNode
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateTextNode
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InsertNodeWithTransaction
(
*
newEmptyTextNode
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
pointToPutCaret
.
Set
(
newEmptyTextNode
0
)
;
putCaret
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
nsresult
rv
=
RelativeFontChangeOnTextNode
(
dir
*
newEmptyTextNode
0
UINT32_MAX
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
}
while
(
item
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
pointToPutCaret
.
GetContainerAsContent
(
)
)
MOZ_KnownLive
(
*
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
item
-
>
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
!
putCaret
)
{
return
NS_OK
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AlignAsSubAction
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetOrClearAlignment
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
rv
=
AlignContentsAtSelection
(
aAlignType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
bool
createEmptyDivElement
=
arrayOfContents
.
IsEmpty
(
)
;
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBlockElementAlign
(
)
failed
"
)
;
return
rv
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
atStartOfSelection
.
Container
(
)
;
createEmptyDivElement
=
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
createEmptyDivElement
)
{
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutaiton
event
listener
might
have
changed
the
selection
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditActionResult
result
=
AlignContentsAtSelectionWithEmptyDivElement
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
AlignContentsAtSelectionWithEmptyDivElement
(
)
failed
"
)
;
if
(
result
.
Handled
(
)
)
{
restoreSelectionLater
.
Abort
(
)
;
}
return
rv
;
}
rv
=
AlignNodesAndDescendants
(
arrayOfContents
aAlignType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AlignNodesAndDescendants
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AlignContentsAtSelectionWithEmptyDivElement
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
BRElementNextToSplitPoint
:
:
Delete
)
;
if
(
newDivElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
BRElementNextToSplitPoint
:
:
Delete
)
failed
"
)
;
return
EditActionResult
(
newDivElementOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newDivElementOrError
.
inspect
(
)
;
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
newDivElementOrError
.
inspect
(
)
0
)
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
createPaddingBRResult
.
Rv
(
)
)
;
}
rv
=
CollapseSelectionToStartOf
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignNodesAndDescendants
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
const
nsAString
&
aAlignType
)
{
AutoTArray
<
bool
64
>
transitionList
;
HTMLEditor
:
:
MakeTransitionList
(
aArrayOfContents
transitionList
)
;
RefPtr
<
Element
>
createdDivElement
;
bool
useCSS
=
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
+
+
indexOfTransitionList
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
NodeAndDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
NodeAndDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsAnyTableElement
(
atContent
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atContent
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
|
|
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
Element
*
listOrListItemElement
=
content
-
>
AsElement
(
)
;
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atContent
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
if
(
useCSS
)
{
if
(
nsStyledElement
*
styledListOrListItemElement
=
nsStyledElement
:
:
FromNode
(
listOrListItemElement
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledListOrListItemElement
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
failed
but
ignored
"
)
;
}
}
createdDivElement
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
AlignContentsInAllTableCellsAndListItems
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
)
failed
"
)
;
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
}
if
(
!
createdDivElement
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newDivElementOrError
.
inspect
(
)
;
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
but
ignored
"
)
;
createdDivElement
=
newDivElementOrError
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
Element
&
aElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfTableCellsAndListItems
;
DOMIterator
iter
(
aElement
)
;
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
-
>
bool
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
return
HTMLEditUtils
:
:
IsTableCell
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
&
aNode
)
;
}
arrayOfTableCellsAndListItems
)
;
for
(
auto
&
tableCellOrListItemElement
:
arrayOfTableCellsAndListItems
)
{
nsresult
rv
=
AlignBlockContentsWithDivElement
(
MOZ_KnownLive
(
tableCellOrListItemElement
)
aAlignType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
Element
&
aBlockElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstEditableContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
firstEditableContent
=
=
lastEditableContent
&
&
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
MOZ_KnownLive
(
firstEditableContent
-
>
AsElement
(
)
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewDivElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
&
aBlockElement
0u
)
[
&
aAlignType
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
nsresult
rv
=
aHTMLEditor
.
SetAttributeOrEquivalent
(
&
aDivElement
nsGkAtoms
:
:
align
aAlignType
!
aDivElement
.
IsInComposedDoc
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
nsPrintfCString
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
"
"
align
\
"
.
.
.
\
"
%
s
)
failed
"
!
aDivElement
.
IsInComposedDoc
(
)
?
"
true
"
:
"
false
"
)
.
get
(
)
)
;
return
rv
;
}
)
;
if
(
maybeNewDivElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
maybeNewDivElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
maybeNewDivElement
.
inspect
(
)
)
;
while
(
lastEditableContent
&
&
(
lastEditableContent
!
=
maybeNewDivElement
.
inspect
(
)
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
lastEditableContent
EditorDOMPoint
(
maybeNewDivElement
.
inspect
(
)
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
}
return
NS_OK
;
}
size_t
HTMLEditor
:
:
CollectChildren
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
CollectListChildren
aCollectListChildren
CollectTableChildren
aCollectTableChildren
CollectNonEditableNodes
aCollectNonEditableNodes
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
size_t
numberOfFoundChildren
=
0
;
for
(
nsIContent
*
content
=
HTMLEditUtils
:
:
GetFirstChild
(
aNode
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
(
aCollectListChildren
=
=
CollectListChildren
:
:
Yes
&
&
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
)
|
|
(
aCollectTableChildren
=
=
CollectTableChildren
:
:
Yes
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
)
)
{
numberOfFoundChildren
+
=
CollectChildren
(
*
content
aOutArrayOfContents
aIndexToInsertChildren
+
numberOfFoundChildren
aCollectListChildren
aCollectTableChildren
aCollectNonEditableNodes
)
;
}
else
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
Yes
|
|
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
aOutArrayOfContents
.
InsertElementAt
(
aIndexToInsertChildren
+
numberOfFoundChildren
+
+
*
content
)
;
}
}
return
numberOfFoundChildren
;
}
nsresult
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
const
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMPoint
startPoint
(
range
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMPoint
endPoint
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
newStartPoint
(
startPoint
)
;
EditorDOMPoint
newEndPoint
(
endPoint
)
;
WSRunScanner
wsScannerAtEnd
(
GetActiveEditingHost
(
)
endPoint
)
;
WSScanResult
scanResultAtEnd
=
wsScannerAtEnd
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
endPoint
)
;
if
(
scanResultAtEnd
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
scanResultAtEnd
.
ReachedSomethingNonTextContent
(
)
)
{
if
(
wsScannerAtEnd
.
StartsFromOtherBlockElement
(
)
)
{
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
wsScannerAtEnd
.
StartReasonOtherBlockElementPtr
(
)
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
;
if
(
child
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
else
if
(
wsScannerAtEnd
.
StartsFromCurrentBlockBoundary
(
)
)
{
if
(
wsScannerAtEnd
.
GetEditingHost
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetPreviousContent
(
endPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
wsScannerAtEnd
.
GetEditingHost
(
)
)
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
}
else
if
(
wsScannerAtEnd
.
StartsFromBRElement
(
)
)
{
newEndPoint
.
Set
(
wsScannerAtEnd
.
StartReasonBRElementPtr
(
)
)
;
}
}
WSRunScanner
wsScannerAtStart
(
wsScannerAtEnd
.
GetEditingHost
(
)
startPoint
)
;
WSScanResult
scanResultAtStart
=
wsScannerAtStart
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
startPoint
)
;
if
(
scanResultAtStart
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
scanResultAtStart
.
ReachedSomethingNonTextContent
(
)
)
{
if
(
wsScannerAtStart
.
EndsByOtherBlockElement
(
)
)
{
nsINode
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
wsScannerAtStart
.
EndReasonOtherBlockElementPtr
(
)
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
;
if
(
child
)
{
newStartPoint
.
Set
(
child
)
;
}
}
else
if
(
wsScannerAtStart
.
EndsByCurrentBlockBoundary
(
)
)
{
if
(
wsScannerAtStart
.
GetEditingHost
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetNextContent
(
startPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
wsScannerAtStart
.
GetEditingHost
(
)
)
)
{
newStartPoint
.
Set
(
child
)
;
}
}
}
else
if
(
wsScannerAtStart
.
EndsByBRElement
(
)
)
{
newStartPoint
.
SetAfter
(
wsScannerAtStart
.
EndReasonBRElementPtr
(
)
)
;
}
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
startPoint
.
ToRawRangeBoundary
(
)
newEndPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
comp
=
=
1
)
{
return
NS_OK
;
}
ErrorResult
error
;
SelectionRef
(
)
.
SetBaseAndExtentInLimiter
(
newStartPoint
newEndPoint
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
else
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
}
return
error
.
StealNSResult
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
EditorDOMPointType
&
aPoint
EditSubAction
aEditSubAction
const
Element
&
aEditingHost
)
const
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
auto
point
=
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
EditorDOMPoint
atLastPreformattedNewLine
=
HTMLEditUtils
:
:
GetPreviousPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
point
)
;
if
(
atLastPreformattedNewLine
.
IsSet
(
)
)
{
return
atLastPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
constexpr
HTMLEditUtils
:
:
WalkTreeOptions
ignoreNonEditableNodeAndStopAtBlockBoundary
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
previousEditableContent
&
&
previousEditableContent
-
>
GetParentNode
(
)
&
&
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
previousEditableContent
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
;
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
EditorDOMPoint
atLastPreformattedNewLine
=
HTMLEditUtils
:
:
GetPreviousPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
EditorRawDOMPoint
:
:
AtEndOf
(
*
previousEditableContent
)
)
;
if
(
atLastPreformattedNewLine
.
IsSet
(
)
)
{
return
atLastPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
Set
(
previousEditableContent
)
;
}
for
(
nsIContent
*
nearContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
;
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
return
point
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditingHost
)
const
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
auto
point
=
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
NS_WARN_IF
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
return
point
;
}
EditorDOMPoint
atNextPreformattedNewLine
=
HTMLEditUtils
:
:
GetInclusiveNextPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
point
)
;
if
(
atNextPreformattedNewLine
.
IsSet
(
)
)
{
Element
*
maybeNonEditableBlockElement
=
nullptr
;
if
(
HTMLEditUtils
:
:
IsInvisiblePreformattedNewLine
(
atNextPreformattedNewLine
&
maybeNonEditableBlockElement
)
&
&
maybeNonEditableBlockElement
)
{
if
(
maybeNonEditableBlockElement
=
=
&
aEditingHost
|
|
!
maybeNonEditableBlockElement
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
if
(
atNextPreformattedNewLine
.
ContainerAsText
(
)
-
>
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
return
EditorDOMPoint
(
maybeNonEditableBlockElement
)
;
}
return
atNextPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
point
.
IsSet
(
)
"
Failed
to
set
to
after
the
text
node
"
)
;
}
constexpr
HTMLEditUtils
:
:
WalkTreeOptions
ignoreNonEditableNodeAndStopAtBlockBoundary
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
nextEditableContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
nextEditableContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
&
&
nextEditableContent
-
>
GetParent
(
)
;
nextEditableContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
EditorDOMPoint
atFirstPreformattedNewLine
=
HTMLEditUtils
:
:
GetInclusiveNextPreformattedNewLineInTextNode
<
EditorDOMPoint
>
(
EditorRawDOMPoint
(
nextEditableContent
0
)
)
;
if
(
atFirstPreformattedNewLine
.
IsSet
(
)
)
{
Element
*
maybeNonEditableBlockElement
=
nullptr
;
if
(
HTMLEditUtils
:
:
IsInvisiblePreformattedNewLine
(
atFirstPreformattedNewLine
&
maybeNonEditableBlockElement
)
&
&
maybeNonEditableBlockElement
)
{
if
(
maybeNonEditableBlockElement
=
=
&
aEditingHost
|
|
!
maybeNonEditableBlockElement
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
if
(
atFirstPreformattedNewLine
.
ContainerAsText
(
)
-
>
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
maybeNonEditableBlockElement
)
;
}
return
EditorDOMPoint
(
maybeNonEditableBlockElement
)
;
}
return
atFirstPreformattedNewLine
.
NextPoint
(
)
;
}
point
.
SetAfter
(
nextEditableContent
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
nextEditableContent
)
)
{
break
;
}
}
for
(
nsIContent
*
nearContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
HTMLEditUtils
:
:
GetNextContent
(
point
ignoreNonEditableNodeAndStopAtBlockBoundary
&
aEditingHost
)
)
{
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
&
&
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
}
return
point
;
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToIncludeAdjuscentWhiteSpaces
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
const
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
aOutArrayOfRanges
.
SetCapacity
(
rangeCount
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
selectionRange
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
EditorRawDOMRange
rawRange
(
*
selectionRange
)
;
if
(
!
rawRange
.
IsPositioned
(
)
|
|
!
rawRange
.
EnsureNotInNativeAnonymousSubtree
(
)
)
{
continue
;
}
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
rawRange
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToHardLineStartAndEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
const
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
aOutArrayOfRanges
.
SetCapacity
(
rangeCount
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
rangeCount
)
;
nsRange
*
selectionRange
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
EditorRawDOMRange
rawRange
(
*
selectionRange
)
;
if
(
!
rawRange
.
IsPositioned
(
)
|
|
!
rawRange
.
EnsureNotInNativeAnonymousSubtree
(
)
)
{
continue
;
}
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
rawRange
aEditSubAction
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
template
<
typename
EditorDOMPointType1
typename
EditorDOMPointType2
>
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
EditorDOMPointType1
&
aStartPoint
EditorDOMPointType2
&
aEndPoint
const
Element
&
aEditingHost
)
const
{
if
(
aStartPoint
!
=
aEndPoint
)
{
return
;
}
if
(
!
aStartPoint
.
IsInContentNode
(
)
)
{
return
;
}
Element
*
const
maybeNonEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aStartPoint
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
!
maybeNonEditableBlockElement
)
{
return
;
}
if
(
aEditingHost
.
IsInclusiveDescendantOf
(
maybeNonEditableBlockElement
)
)
{
return
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
maybeNonEditableBlockElement
)
)
{
aStartPoint
.
Set
(
maybeNonEditableBlockElement
0u
)
;
aEndPoint
.
SetToEndOf
(
maybeNonEditableBlockElement
)
;
}
}
template
<
typename
EditorDOMRangeType
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMRangeType
&
aRange
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
return
CreateRangeIncludingAdjuscentWhiteSpaces
(
aRange
.
StartRef
(
)
aRange
.
EndRef
(
)
)
;
}
template
<
typename
EditorDOMPointType1
typename
EditorDOMPointType2
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPointType1
&
aStartPoint
const
EditorDOMPointType2
&
aEndPoint
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aStartPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aEndPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
|
|
!
aEndPoint
.
IsInContentNode
(
)
)
{
NS_WARNING_ASSERTION
(
aStartPoint
.
IsSet
(
)
"
aStartPoint
was
not
set
"
)
;
NS_WARNING_ASSERTION
(
aEndPoint
.
IsSet
(
)
"
aEndPoint
was
not
set
"
)
;
return
nullptr
;
}
const
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
nullptr
;
}
auto
startPoint
=
aStartPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
auto
endPoint
=
aEndPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startPoint
endPoint
*
editingHost
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
endPoint
.
IsInContentNode
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
)
failed
"
)
;
return
nullptr
;
}
if
(
startPoint
.
IsInTextNode
(
)
)
{
while
(
!
startPoint
.
IsStartOfContainer
(
)
)
{
if
(
!
startPoint
.
IsPreviousCharASCIISpaceOrNBSP
(
)
)
{
break
;
}
MOZ_ALWAYS_TRUE
(
startPoint
.
RewindOffset
(
)
)
;
}
}
if
(
!
IsDescendantOfEditorRoot
(
startPoint
.
GetChildOrContainerIfDataNode
(
)
)
)
{
return
nullptr
;
}
if
(
endPoint
.
IsInTextNode
(
)
)
{
while
(
!
endPoint
.
IsEndOfContainer
(
)
)
{
if
(
!
endPoint
.
IsCharASCIISpaceOrNBSP
(
)
)
{
break
;
}
MOZ_ALWAYS_TRUE
(
endPoint
.
AdvanceOffset
(
)
)
;
}
}
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
if
(
!
lastRawPoint
.
IsStartOfContainer
(
)
)
{
lastRawPoint
.
RewindOffset
(
)
;
}
if
(
!
IsDescendantOfEditorRoot
(
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
template
<
typename
EditorDOMRangeType
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorDOMRangeType
&
aRange
EditSubAction
aEditSubAction
)
const
{
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeExtendedToHardLineStartAndEnd
(
aRange
.
StartRef
(
)
aRange
.
EndRef
(
)
aEditSubAction
)
;
}
template
<
typename
EditorDOMPointType1
typename
EditorDOMPointType2
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
EditorDOMPointType1
&
aStartPoint
const
EditorDOMPointType2
&
aEndPoint
EditSubAction
aEditSubAction
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aStartPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aEndPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
const
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
nullptr
;
}
auto
startPoint
=
aStartPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
auto
endPoint
=
aEndPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startPoint
endPoint
*
editingHost
)
;
startPoint
=
GetCurrentHardLineStartPoint
(
startPoint
aEditSubAction
*
editingHost
)
;
if
(
!
IsDescendantOfEditorRoot
(
startPoint
.
GetChildOrContainerIfDataNode
(
)
)
)
{
return
nullptr
;
}
endPoint
=
GetCurrentHardLineEndPoint
(
endPoint
*
editingHost
)
;
const
EditorDOMPoint
lastRawPoint
=
endPoint
.
IsStartOfContainer
(
)
?
endPoint
:
endPoint
.
PreviousPoint
(
)
;
if
(
!
IsDescendantOfEditorRoot
(
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
nsresult
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
nsresult
rv
=
SplitTextNodesAtRangeEnd
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SplitTextNodesAtRangeEnd
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SplitParentInlineElementsAtRangeEdges
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CollectEditTargetNodes
(
aArrayOfRanges
aOutArrayOfContents
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollectEditTargetNodes
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
MaybeSplitElementsAtEveryBRElement
(
aOutArrayOfContents
aEditSubAction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SplitTextNodesAtRangeEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
IgnoredErrorResult
ignoredError
;
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
IsInTextNode
(
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
SplitNodeResult
splitAtEndResult
=
SplitNodeWithTransaction
(
atEnd
)
;
if
(
MOZ_UNLIKELY
(
splitAtEndResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitAtEndResult
.
Rv
(
)
;
}
MOZ_ASSERT
(
!
range
-
>
IsInSelection
(
)
)
;
range
-
>
SetEnd
(
splitAtEndResult
.
AtNextContent
<
EditorRawDOMPoint
>
(
)
.
ToRawRangeBoundary
(
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
SetEnd
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
*
aArrayOfRanges
[
0
]
)
;
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
*
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
nsresult
rv
=
NS_OK
;
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
rv
=
SplitParentInlineElementsAtRangeEdges
(
MOZ_KnownLive
(
*
item
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
)
failed
"
)
;
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
if
(
aOutArrayOfContents
.
IsEmpty
(
)
)
{
iter
.
AppendAllNodesToArray
(
aOutArrayOfContents
)
;
}
else
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfTopChildren
;
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
aArray
)
-
>
bool
{
MOZ_ASSERT
(
aArray
)
;
return
!
static_cast
<
nsTArray
<
OwningNonNull
<
nsIContent
>
>
*
>
(
aArray
)
-
>
Contains
(
&
aNode
)
;
}
arrayOfTopChildren
&
aOutArrayOfContents
)
;
aOutArrayOfContents
.
AppendElements
(
std
:
:
move
(
arrayOfTopChildren
)
)
;
}
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
No
)
{
for
(
size_t
i
=
aOutArrayOfContents
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
aOutArrayOfContents
[
i
-
1
]
EditorType
:
:
HTML
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
-
1
)
;
}
}
}
}
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
Text
*
text
=
aOutArrayOfContents
[
i
]
-
>
GetAsText
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
text
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
}
}
}
break
;
case
EditSubAction
:
:
eCreateOrChangeList
:
{
for
(
size_t
i
=
aOutArrayOfContents
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
-
1
]
;
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
-
1
)
;
CollectChildren
(
content
aOutArrayOfContents
i
-
1
CollectListChildren
:
:
No
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
}
}
if
(
aOutArrayOfContents
.
Length
(
)
!
=
1
)
{
break
;
}
Element
*
deepestDivBlockquoteOrListElement
=
HTMLEditUtils
:
:
GetInclusiveDeepestFirstChildWhichHasOneChild
(
aOutArrayOfContents
[
0
]
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
)
;
if
(
!
deepestDivBlockquoteOrListElement
)
{
break
;
}
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
aOutArrayOfContents
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
aOutArrayOfContents
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
break
;
}
aOutArrayOfContents
.
ReplaceElementAt
(
0
OwningNonNull
<
nsIContent
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
break
;
}
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
break
;
default
:
break
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
!
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
aCollectNonEditableNodes
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
for
(
int32_t
i
=
aArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
aArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
content
)
&
&
!
content
-
>
IsText
(
)
)
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfInlineContents
;
nsresult
rv
=
SplitElementsAtEveryBRElement
(
MOZ_KnownLive
(
content
)
arrayOfInlineContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
rv
;
}
aArrayOfContents
.
RemoveElementAt
(
i
)
;
aArrayOfContents
.
InsertElementsAt
(
i
arrayOfInlineContents
)
;
}
}
return
NS_OK
;
default
:
return
NS_OK
;
}
}
Element
*
HTMLEditor
:
:
GetParentListElementAtSelection
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
const
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
rangeCount
)
;
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
range
)
;
for
(
nsINode
*
parent
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
parent
)
)
{
return
parent
-
>
AsElement
(
)
;
}
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
RangeItem
&
aRangeItem
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_OK
;
}
if
(
!
aRangeItem
.
IsCollapsed
(
)
&
&
aRangeItem
.
mEndContainer
&
&
aRangeItem
.
mEndContainer
-
>
IsContent
(
)
)
{
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtEnd
=
HTMLEditUtils
:
:
GetMostDistantAncestorInlineElement
(
*
aRangeItem
.
mEndContainer
-
>
AsContent
(
)
editingHost
)
;
if
(
mostAncestorInlineContentAtEnd
)
{
SplitNodeResult
splitEndInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtEnd
aRangeItem
.
EndPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitEndInlineResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitEndInlineResult
.
Rv
(
)
;
}
if
(
MOZ_UNLIKELY
(
editingHost
!
=
GetActiveEditingHost
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
caused
changing
editing
host
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
const
EditorRawDOMPoint
&
splitPointAtEnd
=
splitEndInlineResult
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
!
splitPointAtEnd
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
aRangeItem
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
}
if
(
!
aRangeItem
.
mStartContainer
|
|
!
aRangeItem
.
mStartContainer
-
>
IsContent
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtStart
=
HTMLEditUtils
:
:
GetMostDistantAncestorInlineElement
(
*
aRangeItem
.
mStartContainer
-
>
AsContent
(
)
editingHost
)
;
if
(
mostAncestorInlineContentAtStart
)
{
SplitNodeResult
splitStartInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtStart
aRangeItem
.
StartPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitStartInlineResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitStartInlineResult
.
Rv
(
)
;
}
const
EditorRawDOMPoint
&
splitPointAtStart
=
splitStartInlineResult
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
splitPointAtStart
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
aRangeItem
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
nsIContent
&
aMostAncestorToBeSplit
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
HTMLBRElement
>
24
>
arrayOfBRElements
;
DOMIterator
iter
(
aMostAncestorToBeSplit
)
;
iter
.
AppendAllNodesToArray
(
arrayOfBRElements
)
;
if
(
arrayOfBRElements
.
IsEmpty
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
aMostAncestorToBeSplit
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
&
aMostAncestorToBeSplit
;
for
(
OwningNonNull
<
HTMLBRElement
>
&
brElement
:
arrayOfBRElements
)
{
EditorDOMPoint
atBRNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBRNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
nextContent
atBRNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitNodeResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
if
(
nsIContent
*
previousContent
=
splitNodeResult
.
GetPreviousContent
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
previousContent
)
;
}
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
brElement
)
splitNodeResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
aOutArrayOfContents
.
AppendElement
(
brElement
)
;
nextContent
=
splitNodeResult
.
GetNextContent
(
)
;
}
aOutArrayOfContents
.
AppendElement
(
*
nextContent
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
MakeTransitionList
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsINode
*
prevParent
=
nullptr
;
aTransitionArray
.
EnsureLengthAtLeast
(
aArrayOfContents
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aArrayOfContents
.
Length
(
)
;
i
+
+
)
{
aTransitionArray
[
i
]
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
;
prevParent
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
;
}
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
Element
&
aHeadingElement
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
SplitNodeResult
splitHeadingResult
=
[
this
&
aPointToSplit
&
aHeadingElement
]
(
)
MOZ_CAN_RUN_SCRIPT
{
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aPointToSplit
aHeadingElement
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
SplitNodeResult
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
SplitNodeResult
result
=
SplitNodeDeepWithTransaction
(
aHeadingElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aHeadingElement
"
"
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
result
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
splitHeadingResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
Failed
to
splitting
aHeadingElement
"
)
;
return
Err
(
splitHeadingResult
.
Rv
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitHeadingResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
didn
'
t
split
aHeadingElement
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Element
*
leftHeadingElement
=
Element
:
:
FromNode
(
splitHeadingResult
.
GetPreviousContent
(
)
)
;
MOZ_ASSERT
(
leftHeadingElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
leftHeadingElement
)
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftHeadingElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
leftHeadingElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
createPaddingBRResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
Err
(
createPaddingBRResult
.
Rv
(
)
)
;
}
}
Element
*
rightHeadingElement
=
Element
:
:
FromNode
(
splitHeadingResult
.
GetNextContent
(
)
)
;
MOZ_ASSERT
(
rightHeadingElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
!
HTMLEditUtils
:
:
IsEmptyBlockElement
(
*
rightHeadingElement
{
}
)
)
{
return
EditorDOMPoint
(
rightHeadingElement
0u
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightHeadingElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
rightHeadingElement
-
>
GetNextSibling
(
)
)
{
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
rightHeadingElement
-
>
GetNextSibling
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
nextEditableSibling
&
&
nextEditableSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
auto
afterEditableBRElement
=
EditorDOMPoint
:
:
After
(
*
nextEditableSibling
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
afterEditableBRElement
.
IsSet
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
afterEditableBRElement
;
}
}
if
(
MOZ_UNLIKELY
(
!
leftHeadingElement
-
>
IsInComposedDoc
(
)
)
)
{
NS_WARNING
(
"
The
left
heading
element
was
unexpectedly
removed
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
mTypeInState
-
>
ClearAllProps
(
)
;
nsStaticAtom
&
newParagraphTagName
=
&
DefaultParagraphSeparatorTagName
(
)
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
DefaultParagraphSeparatorTagName
(
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewParagraphElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
EditorDOMPoint
:
:
After
(
*
leftHeadingElement
)
[
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivOrParagraphElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aDivOrParagraphElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
Result
<
RefPtr
<
Element
>
nsresult
>
brElementOrError
=
aHTMLEditor
.
InsertBRElement
(
withTransaction
EditorDOMPoint
(
&
aDivOrParagraphElement
0u
)
)
;
if
(
brElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertBRElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
brElementOrError
.
unwrapErr
(
)
;
}
return
NS_OK
;
}
)
;
if
(
MOZ_UNLIKELY
(
maybeNewParagraphElement
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
maybeNewParagraphElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
maybeNewParagraphElement
.
inspect
(
)
)
;
return
EditorDOMPoint
(
maybeNewParagraphElement
.
unwrap
(
)
.
get
(
)
0u
)
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
Element
&
aParentDivOrP
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
|
|
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
;
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
}
bool
doesCRCreateNewP
=
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brContent
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brContent
=
nullptr
;
}
else
if
(
atStartOfSelection
.
IsInTextNode
(
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brContent
=
atStartOfSelection
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetPreviousSibling
(
*
atStartOfSelection
.
ContainerAsContent
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
brContent
|
|
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
brContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
brContent
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brContent
=
atStartOfSelection
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetNextSibling
(
*
atStartOfSelection
.
ContainerAsContent
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
brContent
|
|
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
brContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
SetAfter
(
atStartOfSelection
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
pointToInsertBR
.
IsSet
(
)
"
Failed
to
set
to
after
the
container
of
selection
start
"
)
;
brContent
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
pointToSplitParentDivOrP
aParentDivOrP
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
"
"
failed
"
)
;
return
EditActionResult
(
pointToSplitOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
pointToSplitOrError
.
inspect
(
)
.
IsSetAndValid
(
)
)
;
if
(
pointToSplitOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToSplitParentDivOrP
=
pointToSplitOrError
.
unwrap
(
)
;
}
SplitNodeResult
splitParentDivOrPResult
=
SplitNodeWithTransaction
(
pointToSplitParentDivOrP
)
;
if
(
MOZ_UNLIKELY
(
splitParentDivOrPResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
splitParentDivOrPResult
.
Rv
(
)
)
;
}
pointToSplitParentDivOrP
.
SetToEndOf
(
splitParentDivOrPResult
.
GetPreviousContent
(
)
)
;
}
pointToInsertBR
.
SetAfter
(
pointToSplitParentDivOrP
.
GetContainer
(
)
)
;
}
}
else
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
nsIContent
*
nearContent
=
editingHost
?
HTMLEditUtils
:
:
GetPreviousContent
(
atStartOfSelection
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
:
nullptr
;
if
(
!
nearContent
|
|
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
nearContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearContent
)
)
{
nearContent
=
editingHost
?
HTMLEditUtils
:
:
GetNextContent
(
atStartOfSelection
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
:
nullptr
;
if
(
!
nearContent
|
|
!
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
nearContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearContent
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
nearContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
brContent
=
nearContent
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToInsertBR
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
EditActionResult
(
resultOfInsertingBRElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
SetAfter
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
NS_WARNING_ASSERTION
(
pointToSplitParentDivOrP
.
IsSet
(
)
"
Failed
to
set
after
the
new
<
br
>
"
)
;
}
brContent
=
resultOfInsertingBRElement
.
unwrap
(
)
.
forget
(
)
;
}
EditActionResult
result
(
SplitParagraph
(
aParentDivOrP
pointToSplitParentDivOrP
brContent
)
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitParagraph
(
)
failed
"
)
;
result
.
MarkAsHandled
(
)
;
return
result
;
}
nsresult
HTMLEditor
:
:
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aStartOfRightNode
aParentDivOrP
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
preparationResult
.
unwrapErr
(
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
SplitNodeResult
splitDivOrPResult
=
SplitNodeDeepWithTransaction
(
aParentDivOrP
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitDivOrPResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitDivOrPResult
.
Rv
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitDivOrPResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
any
nodes
"
)
;
return
NS_ERROR_FAILURE
;
}
Element
*
leftDivOrParagraphElement
=
Element
:
:
FromNode
(
splitDivOrPResult
.
GetPreviousContent
(
)
)
;
MOZ_ASSERT
(
leftDivOrParagraphElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
Element
*
rightDivOrParagraphElement
=
Element
:
:
FromNode
(
splitDivOrPResult
.
GetNextContent
(
)
)
;
MOZ_ASSERT
(
rightDivOrParagraphElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
aNextBRNode
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
aNextBRNode
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
aNextBRNode
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
*
nsGkAtoms
:
:
id
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
id
)
failed
"
)
;
return
rv
;
}
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
leftDivOrParagraphElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
)
failed
"
)
;
return
rv
;
}
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
rightDivOrParagraphElement
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
;
if
(
child
&
&
(
child
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
)
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
child
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
else
{
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
child
)
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
Element
&
aListItemElement
const
EditorDOMPoint
&
aPointToSplit
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
;
if
(
&
aEditingHost
!
=
aListItemElement
.
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsEmptyBlockElement
(
aListItemElement
{
}
)
)
{
RefPtr
<
Element
>
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
!
HTMLEditUtils
:
:
IsLastChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
EditorDOMPoint
(
&
aListItemElement
)
)
;
if
(
MOZ_UNLIKELY
(
splitListItemParentResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
splitListItemParentResult
.
Rv
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitListItemParentResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
split
the
parent
of
"
"
aListItemElement
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
leftListElement
=
Element
:
:
FromNode
(
splitListItemParentResult
.
GetPreviousContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
leftListElement
)
;
}
auto
afterLeftListElement
=
EditorDOMPoint
:
:
After
(
leftListElement
)
;
if
(
MOZ_UNLIKELY
(
!
afterLeftListElement
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
afterLeftListElement
.
GetContainer
(
)
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aListItemElement
afterLeftListElement
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditorDOMPoint
(
&
aListItemElement
0u
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aListItemElement
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
nsStaticAtom
&
newParagraphTagName
=
&
DefaultParagraphSeparatorTagName
(
)
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
DefaultParagraphSeparatorTagName
(
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewParagraphElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
afterLeftListElement
[
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivOrParagraphElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aDivOrParagraphElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
Result
<
RefPtr
<
Element
>
nsresult
>
brElementOrError
=
aHTMLEditor
.
InsertBRElement
(
withTransaction
EditorDOMPoint
(
&
aDivOrParagraphElement
0u
)
)
;
if
(
brElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertBRElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
brElementOrError
.
unwrapErr
(
)
;
}
return
NS_OK
;
}
)
;
if
(
MOZ_UNLIKELY
(
maybeNewParagraphElement
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
maybeNewParagraphElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
maybeNewParagraphElement
.
inspect
(
)
)
;
return
EditorDOMPoint
(
maybeNewParagraphElement
.
inspect
(
)
0u
)
;
}
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aPointToSplit
aListItemElement
)
;
if
(
preparationResult
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
Err
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
SplitNodeResult
splitListItemResult
=
SplitNodeDeepWithTransaction
(
aListItemElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
splitListItemResult
.
EditorDestroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitListItemResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
MOZ_UNLIKELY
(
!
aListItemElement
.
GetParent
(
)
)
)
{
NS_WARNING
(
"
Somebody
disconnected
the
target
listitem
from
the
parent
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitListItemResult
.
DidSplit
(
)
)
|
|
NS_WARN_IF
(
!
splitListItemResult
.
GetNewContent
(
)
-
>
IsElement
(
)
)
|
|
NS_WARN_IF
(
!
splitListItemResult
.
GetOriginalContent
(
)
-
>
IsElement
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Element
&
leftListItemElement
=
*
splitListItemResult
.
GetPreviousContent
(
)
-
>
AsElement
(
)
;
Element
&
rightListItemElement
=
*
splitListItemResult
.
GetNextContent
(
)
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
leftListItemElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
leftListItemElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
createPaddingBRResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
Err
(
createPaddingBRResult
.
Rv
(
)
)
;
}
return
EditorDOMPoint
(
&
rightListItemElement
0u
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
rightListItemElement
)
)
{
if
(
aListItemElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
)
{
nsStaticAtom
&
nextDefinitionListItemTagName
=
aListItemElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
?
*
nsGkAtoms
:
:
dd
:
*
nsGkAtoms
:
:
dt
;
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewListItemElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
nextDefinitionListItemTagName
)
EditorDOMPoint
:
:
After
(
rightListItemElement
)
)
;
if
(
MOZ_UNLIKELY
(
maybeNewListItemElement
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
maybeNewListItemElement
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
maybeNewListItemElement
.
inspect
(
)
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
rightListItemElement
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditorDOMPoint
(
maybeNewListItemElement
.
unwrap
(
)
0u
)
;
}
Result
<
RefPtr
<
HTMLBRElement
>
nsresult
>
newBRElementOrError
=
CopyLastEditableChildStylesWithTransaction
(
MOZ_KnownLive
(
leftListItemElement
)
MOZ_KnownLive
(
rightListItemElement
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
newBRElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
)
failed
"
)
;
return
Err
(
newBRElementOrError
.
unwrapErr
(
)
)
;
}
return
newBRElementOrError
.
inspect
(
)
?
EditorDOMPoint
(
newBRElementOrError
.
unwrap
(
)
.
get
(
)
)
:
EditorDOMPoint
(
&
rightListItemElement
0u
)
;
}
WSScanResult
forwardScanFromStartOfListItemResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
EditorRawDOMPoint
(
&
rightListItemElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromStartOfListItemResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromStartOfListItemResult
.
ReachedSpecialContent
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedBRElement
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedHRElement
(
)
)
{
EditorDOMPoint
atFoundElement
=
forwardScanFromStartOfListItemResult
.
PointAtContent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
atFoundElement
.
IsSetAndValid
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
atFoundElement
;
}
return
forwardScanFromStartOfListItemResult
.
Point
(
)
;
}
nsresult
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
nsresult
rv
=
MoveNodesIntoNewBlockquoteElement
(
childContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
)
failed
"
)
;
return
rv
;
}
}
if
(
prevParent
)
{
if
(
prevParent
!
=
content
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
content
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
content
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockQuoteElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
EditorDOMPoint
(
content
)
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockQuoteElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
newBlockQuoteElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockQuoteElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newBlockQuoteElementOrError
.
inspect
(
)
;
curBlock
=
newBlockQuoteElementOrError
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerElements
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
blockElement
;
nsCOMPtr
<
nsIContent
>
firstContent
lastContent
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
nsresult
rv
=
RemoveBlockContainerElements
(
childContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElements
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
blockElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
blockElement
)
)
{
lastContent
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
blockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
content
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
blockElement
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
blockElement
)
|
|
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
blockElement
)
)
{
blockElement
=
nullptr
;
}
else
{
firstContent
=
lastContent
=
content
;
}
continue
;
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
continue
;
}
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsAtom
&
aBlockTag
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
content
:
aArrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNode
(
)
)
)
{
curBlock
=
nullptr
;
newBlock
=
nullptr
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
content
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
curBlock
=
nullptr
;
newBlock
=
ReplaceContainerAndCloneAttributesWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aBlockTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
newBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
ReplaceContainerAndCloneAttributesWithTransaction
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
newBlock
-
>
GetParentNode
(
)
!
=
atContent
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
if
(
!
childContents
.
IsEmpty
(
)
)
{
nsresult
rv
=
CreateOrChangeBlockContainerElement
(
childContents
aBlockTag
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
newBlockElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockElementOrError
.
inspect
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
newBlockElementOrError
.
unwrap
(
)
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
newBlockElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockElementOrError
.
inspect
(
)
)
;
curBlock
=
newBlockElementOrError
.
unwrap
(
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
!
curBlock
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
newBlockElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTr
"
"
ansaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
newBlockElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newBlockElementOrError
.
inspect
(
)
)
;
curBlock
=
newBlockElementOrError
.
unwrap
(
)
;
atContent
.
Set
(
content
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
SplitNodeResult
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aStartOfDeepestRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
host
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
host
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
*
host
)
)
{
NS_WARNING
(
"
aStartOfDeepestRightNode
was
not
in
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
pointToInsert
.
GetChild
(
)
=
=
host
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
reached
"
"
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
:
:
NotHandled
(
aStartOfDeepestRightNode
SplitNodeDirection
:
:
LeftNodeIsNewOne
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitNodeResult
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
nsAtom
&
aTagName
const
EditorDOMPoint
&
aPointToInsert
BRElementNextToSplitPoint
aBRElementNextToSplitPoint
const
InitializeInsertingElement
&
aInitializer
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aTagName
aPointToInsert
)
;
if
(
MOZ_UNLIKELY
(
splitNodeResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
Err
(
splitNodeResult
.
Rv
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
aPointToInsert
.
HasChildMovedFromContainer
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
aBRElementNextToSplitPoint
=
=
BRElementNextToSplitPoint
:
:
Delete
)
{
if
(
Element
*
editingHost
=
GetActiveEditingHost
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
HTMLEditUtils
:
:
GetNextContent
(
splitPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
maybeBRContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
splitPoint
.
GetChild
(
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
splitPoint
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableSibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
splitPoint
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
}
}
}
}
Result
<
RefPtr
<
Element
>
nsresult
>
newElementOrError
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
aTagName
splitPoint
aInitializer
)
;
if
(
MOZ_UNLIKELY
(
newElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
newElementOrError
;
}
MOZ_ASSERT
(
newElementOrError
.
inspect
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
newElementOrError
.
inspect
(
)
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
newElementOrError
;
}
nsresult
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNewFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
!
aNodeLeft
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNodeLeft
.
GetParentNode
(
)
!
=
aNodeRight
.
GetParentNode
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aNodeRight
EditorDOMPoint
(
&
aNodeLeft
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aNodeLeft
)
|
|
aNodeLeft
.
IsText
(
)
)
{
JoinNodesResult
joinNodesResult
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
MOZ_UNLIKELY
(
joinNodesResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
failed
"
)
;
return
joinNodesResult
.
Rv
(
)
;
}
*
aNewFirstChildOfRightNode
=
joinNodesResult
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
return
joinNodesResult
.
Rv
(
)
;
}
nsCOMPtr
<
nsIContent
>
lastEditableChildOfLeftContent
=
HTMLEditUtils
:
:
GetLastChild
(
aNodeLeft
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
lastEditableChildOfLeftContent
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstEditableChildOfRightContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aNodeRight
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
NS_WARN_IF
(
!
firstEditableChildOfRightContent
)
)
{
return
NS_ERROR_FAILURE
;
}
JoinNodesResult
joinNodesResult
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
MOZ_UNLIKELY
(
joinNodesResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
joinNodesResult
.
Rv
(
)
;
}
if
(
(
lastEditableChildOfLeftContent
-
>
IsText
(
)
|
|
lastEditableChildOfLeftContent
-
>
IsElement
(
)
)
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
lastEditableChildOfLeftContent
*
firstEditableChildOfRightContent
StyleDifference
:
:
CompareIfElements
)
)
{
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
lastEditableChildOfLeftContent
*
firstEditableChildOfRightContent
aNewFirstChildOfRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
*
aNewFirstChildOfRightNode
=
joinNodesResult
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetMostDistantAncestorMailCiteElement
(
const
nsINode
&
aNode
)
const
{
Element
*
mailCiteElement
=
nullptr
;
const
bool
isPlaintextEditor
=
IsInPlaintextMode
(
)
;
for
(
Element
*
element
:
aNode
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
(
isPlaintextEditor
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
*
element
)
)
{
mailCiteElement
=
element
;
continue
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
mailCiteElement
;
}
nsresult
HTMLEditor
:
:
CacheInlineStyles
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
GetInlineStyles
(
aContent
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlineStyles
(
nsIContent
&
aContent
AutoStyleCacheArray
&
aStyleCacheArray
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStyleCacheArray
.
IsEmpty
(
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
for
(
nsStaticAtom
*
property
:
{
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
s
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
face
nsGkAtoms
:
:
size
nsGkAtoms
:
:
color
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
em
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
code
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
var
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
backgroundColor
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
}
)
{
nsStaticAtom
*
tag
*
attribute
;
if
(
property
=
=
nsGkAtoms
:
:
face
|
|
property
=
=
nsGkAtoms
:
:
size
|
|
property
=
=
nsGkAtoms
:
:
color
)
{
tag
=
nsGkAtoms
:
:
font
;
attribute
=
property
;
}
else
{
tag
=
property
;
attribute
=
nullptr
;
}
bool
typeInSet
unused
;
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
tag
attribute
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsString
value
;
if
(
!
useCSS
|
|
(
property
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
aContent
*
tag
attribute
nullptr
&
value
)
;
}
else
{
isSet
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aContent
MOZ_KnownLive
(
tag
)
MOZ_KnownLive
(
attribute
)
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
isSet
)
{
aStyleCacheArray
.
AppendElement
(
StyleCache
(
tag
attribute
value
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
IsEmpty
(
)
|
|
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
bool
useCSS
=
IsCSSEnabled
(
)
;
const
RangeBoundary
&
atStartOfSelection
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
-
>
StartRef
(
)
;
nsCOMPtr
<
nsIContent
>
startContainerContent
=
atStartOfSelection
.
Container
(
)
&
&
atStartOfSelection
.
Container
(
)
-
>
IsContent
(
)
?
atStartOfSelection
.
Container
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
startContainerContent
)
)
{
return
NS_OK
;
}
AutoStyleCacheArray
styleCacheArrayAtInsertionPoint
;
nsresult
rv
=
GetInlineStyles
(
*
startContainerContent
styleCacheArrayAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
for
(
StyleCache
&
styleCacheBeforeEdit
:
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
{
bool
isFirst
=
false
isAny
=
false
isAll
=
false
;
nsAutoString
currentValue
;
if
(
useCSS
)
{
isAny
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
startContainerContent
MOZ_KnownLive
(
styleCacheBeforeEdit
.
Tag
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
currentValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
!
isAny
)
{
nsresult
rv
=
GetInlinePropertyBase
(
MOZ_KnownLive
(
*
styleCacheBeforeEdit
.
Tag
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
&
styleCacheBeforeEdit
.
Value
(
)
&
isFirst
&
isAny
&
isAll
&
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
rv
;
}
}
if
(
isAny
&
&
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
continue
;
}
AutoStyleCacheArray
:
:
index_type
index
=
styleCacheArrayAtInsertionPoint
.
IndexOf
(
styleCacheBeforeEdit
.
Tag
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
)
;
if
(
index
=
=
AutoStyleCacheArray
:
:
NoIndex
|
|
styleCacheBeforeEdit
.
Value
(
)
!
=
styleCacheArrayAtInsertionPoint
.
ElementAt
(
index
)
.
Value
(
)
)
{
mTypeInState
-
>
SetProp
(
styleCacheBeforeEdit
.
Tag
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
styleCacheBeforeEdit
.
Value
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfEmptyElements
;
DOMIterator
iter
;
if
(
NS_FAILED
(
iter
.
Init
(
aStartRef
aEndRef
)
)
)
{
NS_WARNING
(
"
DOMIterator
:
:
Init
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
aSelf
)
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
MOZ_ASSERT
(
aSelf
)
;
Element
*
element
=
aNode
.
AsElement
(
)
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
element
EditorType
:
:
HTML
)
|
|
(
!
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
element
)
)
)
{
return
false
;
}
return
HTMLEditUtils
:
:
IsEmptyNode
(
*
element
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
;
}
arrayOfEmptyElements
this
)
;
for
(
auto
&
emptyElement
:
arrayOfEmptyElements
)
{
EditorDOMPoint
endOfNode
(
EditorDOMPoint
:
:
AtEndOf
(
emptyElement
)
)
;
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfNode
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureCaretInBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
StaticRange
>
staticRange
=
StaticRange
:
:
Create
(
atCaret
.
ToRawRangeBoundary
(
)
atCaret
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
!
staticRange
)
{
NS_WARNING
(
"
StaticRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
&
aElement
staticRange
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUtils
:
:
CompareNodeToRange
(
)
failed
"
)
;
return
rv
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
nsIContent
*
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
lastEditableContent
)
{
lastEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
endPoint
;
if
(
lastEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
lastEditableContent
)
)
{
endPoint
.
SetToEndOf
(
lastEditableContent
)
;
}
else
{
endPoint
.
SetAfter
(
lastEditableContent
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsresult
rv
=
CollapseSelectionTo
(
endPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsIContent
*
firstEditableContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
firstEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
firstEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
firstEditableContent
)
)
{
atStartOfBlock
.
Set
(
firstEditableContent
)
;
}
else
{
atStartOfBlock
.
Set
(
firstEditableContent
0
)
;
}
rv
=
CollapseSelectionTo
(
atStartOfBlock
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
SetSelectionInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atCaret
.
IsSetAndValid
(
)
)
;
if
(
Element
*
editingHost
=
GetActiveEditingHost
(
)
)
{
if
(
nsIContent
*
previousEditableContentInBlock
=
HTMLEditUtils
:
:
GetPreviousContent
(
atCaret
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
return
;
}
}
}
if
(
!
atCaret
.
GetChild
(
)
)
{
return
;
}
if
(
nsIContent
*
previousEditableContentInBlockAtCaret
=
HTMLEditUtils
:
:
GetPreviousSibling
(
*
atCaret
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContentInBlockAtCaret
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
nsIContent
*
nextEditableContentInBlockAtCaret
=
HTMLEditUtils
:
:
GetNextSibling
(
*
atCaret
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContentInBlockAtCaret
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
}
}
}
nsresult
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
auto
point
=
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
.
To
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
EditorUtils
:
:
IsEditableContent
(
*
point
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
point
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
{
if
(
editableBlockElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
editableBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
bodyOrDocumentElement
)
{
return
NS_OK
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
NS_WARNING_ASSERTION
(
createPaddingBRResult
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
)
{
const
Element
*
const
blockElementContainingCaret
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
point
.
ContainerAsContent
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
const
Element
*
const
blockElementContainingPreviousEditableContent
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
previousEditableContent
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
blockElementContainingCaret
&
&
blockElementContainingCaret
=
=
blockElementContainingPreviousEditableContent
&
&
point
.
ContainerAsContent
(
)
-
>
GetEditingHost
(
)
=
=
previousEditableContent
-
>
GetEditingHost
(
)
&
&
previousEditableContent
&
&
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
previousEditableContent
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
point
=
EditorDOMPoint
(
createPaddingBRResult
.
GetNewNode
(
)
InterlinePosition
:
:
StartOfNextLine
)
;
nsresult
rv
=
CollapseSelectionTo
(
point
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
nsIContent
*
nextEditableContentInBlock
=
HTMLEditUtils
:
:
GetNextContent
(
*
previousEditableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextEditableContentInBlock
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
}
}
}
}
if
(
nsIContent
*
previousEditableContentInBlock
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
previousEditableContentInBlock
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsImage
(
previousEditableContentInBlock
)
|
|
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
if
(
nsIContent
*
nextEditableContentInBlock
=
HTMLEditUtils
:
:
GetNextContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
nextEditableContentInBlock
-
>
IsText
(
)
|
|
nextEditableContentInBlock
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
br
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
nsIContent
*
nearEditableContent
=
HTMLEditUtils
:
:
GetAdjacentContentToPutCaret
(
point
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
WalkTreeDirection
:
:
Backward
:
WalkTreeDirection
:
:
Forward
*
editingHost
)
;
if
(
!
nearEditableContent
)
{
return
NS_OK
;
}
EditorRawDOMPoint
pointToPutCaret
=
HTMLEditUtils
:
:
GetGoodCaretPointFor
<
EditorRawDOMPoint
>
(
*
nearEditableContent
aDirectionAndAmount
)
;
if
(
!
pointToPutCaret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyNodesIn
(
nsRange
&
aRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
&
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfEmptyContents
arrayOfEmptyCites
skipList
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
MOZ_ASSERT
(
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
;
nsIContent
*
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
nsIContent
*
parentContent
=
content
-
>
GetParent
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
content
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parentContent
)
{
skipList
[
idx
]
=
parentContent
;
}
continue
;
}
bool
isCandidate
=
false
;
bool
isMailCite
=
false
;
if
(
content
-
>
IsElement
(
)
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
isMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
*
content
-
>
AsElement
(
)
)
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
isCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
isCandidate
=
!
selectionRanges
.
IsAtLeastOneContainerOfRangeBoundariesInclusiveDescendantOf
(
*
content
)
;
}
}
bool
isEmptyNode
=
false
;
if
(
isCandidate
)
{
HTMLEditUtils
:
:
EmptyCheckOptions
options
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
;
if
(
!
isMailCite
)
{
options
+
=
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
;
}
isEmptyNode
=
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
options
)
;
if
(
isEmptyNode
)
{
if
(
isMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
content
)
;
}
else
{
arrayOfEmptyContents
.
AppendElement
(
*
content
)
;
}
}
}
if
(
!
isEmptyNode
&
&
parentContent
)
{
skipList
.
AppendElement
(
*
parentContent
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
emptyContent
:
arrayOfEmptyContents
)
{
if
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
emptyContent
)
)
{
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
for
(
OwningNonNull
<
nsIContent
>
&
emptyCite
:
arrayOfEmptyCites
)
{
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
emptyCite
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
emptyCite
)
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
}
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyCite
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
LiftUpListItemElement
(
Element
&
aListItemElement
LiftUpFromAllParentListElements
aLiftUpFromAllParentListElements
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
)
|
|
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isFirstListItem
=
HTMLEditUtils
:
:
IsFirstChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
bool
isLastListItem
=
HTMLEditUtils
:
:
IsLastChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
Element
*
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
leftListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
&
&
!
isLastListItem
)
{
EditorDOMPoint
atListItemElement
(
&
aListItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItemElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atListItemElement
.
IsSetAndValid
(
)
)
;
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
atListItemElement
)
;
if
(
MOZ_UNLIKELY
(
splitListItemParentResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitListItemParentResult
.
Rv
(
)
;
}
leftListElement
=
Element
:
:
FromNodeOrNull
(
splitListItemParentResult
.
GetPreviousContent
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
leftListElement
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
return
left
list
"
"
element
"
)
;
return
NS_ERROR_FAILURE
;
}
}
EditorDOMPoint
pointToInsertListItem
(
leftListElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
MoveNodeWithTransaction
(
aListItemElement
pointToInsertListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aListItemElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aLiftUpFromAllParentListElements
=
=
LiftUpFromAllParentListElements
:
:
No
)
{
return
NS_OK
;
}
rv
=
LiftUpListItemElement
(
aListItemElement
LiftUpFromAllParentListElements
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
Yes
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DestroyListStructureRecursively
(
Element
&
aListElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
while
(
aListElement
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aListElement
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
HTMLEditor
:
:
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
child
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
atCaret
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
NS_OK
;
}
CreateElementResult
createBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
NS_WARNING_ASSERTION
(
createBRResult
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createBRResult
.
Rv
(
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aElement
0u
)
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveAlignFromDescendants
(
Element
&
aElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
;
for
(
nsIContent
*
content
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
&
aElement
:
aElement
.
GetFirstChild
(
)
;
content
;
content
=
nextSibling
)
{
nextSibling
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
nullptr
:
content
-
>
GetNextSibling
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
OwningNonNull
<
Element
>
centerElement
=
*
content
-
>
AsElement
(
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
centerElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
rv
=
EnsureHardLineBeginsWithFirstChildOf
(
centerElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
)
failed
"
)
;
return
rv
;
}
rv
=
EnsureHardLineEndsWithLastChildOf
(
centerElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
)
failed
"
)
;
return
rv
;
}
rv
=
RemoveContainerWithTransaction
(
centerElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
&
&
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
continue
;
}
OwningNonNull
<
Element
>
blockOrHRElement
=
*
content
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
blockOrHRElement
)
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
blockOrHRElement
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
align
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
useCSS
)
{
if
(
blockOrHRElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
blockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
}
else
{
nsStyledElement
*
styledBlockOrHRElement
=
nsStyledElement
:
:
FromNode
(
blockOrHRElement
)
;
if
(
NS_WARN_IF
(
!
styledBlockOrHRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
dummyCssValue
;
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSInlineStyleWithTransaction
(
MOZ_KnownLive
(
*
styledBlockOrHRElement
)
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSInlineStyleWithTransaction
(
nsGkAtoms
:
:
"
"
textAlign
)
failed
"
)
;
return
rv
;
}
}
}
if
(
!
blockOrHRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
blockOrHRElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableChild
=
HTMLEditUtils
:
:
GetFirstChild
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableChild
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableChild
)
|
|
firstEditableChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
previousEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
|
|
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aRemovingContainerElement
0u
)
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableContent
)
|
|
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
nextEditableContent
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
nextEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
|
|
nextEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
resultOfInsertingBRElement
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
aRemovingContainerElement
)
)
;
if
(
resultOfInsertingBRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
resultOfInsertingBRElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
resultOfInsertingBRElement
.
inspect
(
)
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetBlockElementAlign
(
Element
&
aBlockOrHRElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aBlockOrHRElement
)
|
|
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
IsCSSEnabled
(
)
|
|
HTMLEditUtils
:
:
SupportsAlignAttr
(
aBlockOrHRElement
)
)
;
if
(
!
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
aBlockOrHRElement
aAlignType
aEditTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
SetAttributeOrEquivalent
(
&
aBlockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ChangeMarginStart
(
Element
&
aElement
ChangeMargin
aChangeMargin
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChangeMargin
=
=
ChangeMargin
:
:
Increase
?
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
newValue
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
value
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
&
aElement
=
=
editingHost
|
|
!
aElement
.
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToAbsoluteAsSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToAbsolute
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditgor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
focusElement
=
GetSelectionContainerElement
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
focusElement
)
;
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
nullptr
;
RefPtr
<
Element
>
divElement
;
rv
=
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
address_of
(
divElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
!
divElement
)
{
return
EditActionHandled
(
)
;
}
rv
=
SetPositionToAbsoluteOrStatic
(
*
divElement
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
divElement
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
RefPtr
<
Element
>
*
aTargetElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aTargetElement
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eSetPositionToAbsolute
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfContents
EditSubAction
:
:
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
"
"
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atCaret
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
curNode
=
arrayOfContents
[
0
]
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
curNode
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
MOZ_KnownLive
(
*
newDivElementOrError
.
inspect
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
*
aTargetElement
=
newDivElementOrError
.
unwrap
(
)
;
return
rv
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
targetDivElement
;
RefPtr
<
Element
>
createdListElement
;
RefPtr
<
Element
>
handledListItemElement
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsIContent
*
previousEditableContent
=
createdListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
nsAtom
*
ULOrOLOrDLTagName
=
atContent
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
targetDivElement
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
atContent
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
}
else
{
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
nsGkAtoms
:
:
"
"
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
targetDivElement
=
newDivElementOrError
.
unwrap
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewListElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
maybeNewListElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
maybeNewListElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
maybeNewListElement
.
inspect
(
)
)
;
createdListElement
=
maybeNewListElement
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
RefPtr
<
Element
>
listItemElement
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
content
editingHost
)
)
{
if
(
handledListItemElement
=
=
listItemElement
)
{
continue
;
}
nsIContent
*
previousEditableContent
=
createdListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
*
listItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
EditorDOMPoint
atListItem
(
listItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
targetDivElement
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
}
else
{
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
MOZ_UNLIKELY
(
newDivElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
targetDivElement
=
newDivElementOrError
.
unwrap
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
maybeNewListElement
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
*
containerName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
maybeNewListElement
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
maybeNewListElement
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
maybeNewListElement
.
inspect
(
)
)
;
createdListElement
=
maybeNewListElement
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
listItemElement
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
handledListItemElement
=
std
:
:
move
(
listItemElement
)
;
continue
;
}
if
(
!
targetDivElement
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
targetDivElement
=
content
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
createdListElement
)
;
MOZ_ASSERT
(
!
handledListItemElement
)
;
continue
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
newDivElementOrError
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
)
;
if
(
newDivElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
newDivElementOrError
.
inspect
(
)
)
;
targetDivElement
=
newDivElementOrError
.
unwrap
(
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
targetDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
createdListElement
=
nullptr
;
}
*
aTargetElement
=
std
:
:
move
(
targetDivElement
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToStaticAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToStatic
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
element
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
element
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
nsresult
rv
=
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
EditActionResult
HTMLEditor
:
:
AddZIndexAsSubAction
(
int32_t
aChange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
aChange
<
0
?
EditSubAction
:
:
eDecreaseZIndex
:
EditSubAction
:
:
eIncreaseZIndex
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
absolutelyPositionedElement
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
absolutelyPositionedElement
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
nsStyledElement
*
absolutelyPositionedStyledElement
=
nsStyledElement
:
:
FromNode
(
absolutelyPositionedElement
)
;
if
(
NS_WARN_IF
(
!
absolutelyPositionedStyledElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
Result
<
int32_t
nsresult
>
result
=
AddZIndexWithTransaction
(
MOZ_KnownLive
(
*
absolutelyPositionedStyledElement
)
aChange
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AddZIndexWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
unwrapErr
(
)
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
nsresult
HTMLEditor
:
:
OnDocumentModified
(
)
{
if
(
mPendingDocumentModifiedRunner
)
{
return
NS_OK
;
}
mPendingDocumentModifiedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
OnModifyDocument
"
this
&
HTMLEditor
:
:
OnModifyDocument
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingDocumentModifiedRunner
)
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
}
