#
include
"
HTMLEditor
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
AutoRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
EmptyCheckOptions
=
HTMLEditUtils
:
:
EmptyCheckOptions
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
StyleDifference
=
HTMLEditUtils
:
:
StyleDifference
;
using
WalkTextOption
=
HTMLEditUtils
:
:
WalkTextOption
;
using
WalkTreeDirection
=
HTMLEditUtils
:
:
WalkTreeDirection
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
static
bool
IsStyleCachePreservingSubAction
(
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertQuotation
:
case
EditSubAction
:
:
eInsertQuotedText
:
return
true
;
default
:
return
false
;
}
}
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMRange
&
aRange
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMRange
&
aRange
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorRawDOMPoint
&
aStartPoint
const
EditorRawDOMPoint
&
aEndPoint
)
;
nsresult
HTMLEditor
:
:
InitEditorContentAndSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
EditorBase
:
:
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
return
rv
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
&
&
!
GetDocument
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
bodyOrDocumentElement
)
{
return
NS_OK
;
}
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
RawRangeBoundary
(
bodyOrDocumentElement
0u
)
RawRangeBoundary
(
bodyOrDocumentElement
bodyOrDocumentElement
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aTopLevelEditSubAction
aDirectionOfTopLevelEditSubAction
aRv
)
;
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
aTopLevelEditSubAction
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
aDirectionOfTopLevelEditSubAction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
!
mInitSucceeded
)
{
return
;
}
NS_WARNING_ASSERTION
(
!
aRv
.
Failed
(
)
"
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
"
)
;
const
auto
atCompositionStart
=
GetFirstIMESelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
atCompositionStart
.
IsSet
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
atCompositionStart
GetLastIMESelectionEndPoint
<
EditorRawDOMPoint
>
(
)
)
;
}
else
{
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
*
range
)
;
}
}
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
bool
cacheInlineStyles
;
switch
(
aTopLevelEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
cacheInlineStyles
=
true
;
break
;
default
:
cacheInlineStyles
=
IsStyleCachePreservingSubAction
(
aTopLevelEditSubAction
)
;
break
;
}
if
(
cacheInlineStyles
)
{
nsCOMPtr
<
nsIContent
>
containerContent
=
nsIContent
:
:
FromNodeOrNull
(
aDirectionOfTopLevelEditSubAction
=
=
nsIEditor
:
:
eNext
?
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mEndContainer
:
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mStartContainer
)
;
if
(
NS_WARN_IF
(
!
containerContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
rv
=
CacheInlineStyles
(
*
containerContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CacheInlineStyles
(
)
failed
"
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
=
true
;
}
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
;
while
(
true
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
rv
=
NS_ERROR_EDITOR_DESTROYED
;
break
;
}
if
(
!
mInitSucceeded
)
{
rv
=
NS_OK
;
break
;
}
rv
=
OnEndHandlingTopLevelEditSubActionInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
failied
"
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
)
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
}
break
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
GetTopLevelEditSubAction
(
)
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
eNone
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eReplaceHeadWithHTMLSource
:
case
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
return
NS_OK
;
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
IsPositioned
(
)
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eUndo
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eRedo
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
{
EditorDOMRange
changedRange
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
changedRange
.
IsPositioned
(
)
&
&
changedRange
.
EnsureNotInNativeAnonymousSubtree
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eDeleteText
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
changedRange
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
default
:
{
if
(
Element
*
editingHost
=
ComputeEditingHost
(
)
)
{
if
(
RefPtr
<
nsRange
>
extendedChangedRange
=
AutoRangeArray
:
:
CreateRangeWrappingStartAndEndLinesContainingBoundaries
(
changedRange
GetTopLevelEditSubAction
(
)
*
editingHost
)
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
}
}
}
}
if
(
GetTopLevelEditSubAction
(
)
=
=
EditSubAction
:
:
eDeleteSelectedContent
&
&
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
&
&
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
const
auto
newCaretPosition
=
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
newCaretPosition
.
IsSet
(
)
)
{
NS_WARNING
(
"
There
was
no
selection
range
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
StartRef
(
)
.
AsRaw
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
break
;
default
:
{
nsresult
rv
=
CollapseAdjacentTextNodes
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
)
failed
"
)
;
return
rv
;
}
break
;
}
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mNeedsToCleanUpEmptyElements
)
{
nsresult
rv
=
RemoveEmptyNodesIn
(
EditorDOMRange
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveEmptyNodesIn
(
)
failed
"
)
;
return
rv
;
}
}
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidNormalizeWhitespaces
)
{
break
;
}
[
[
fallthrough
]
]
;
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
{
auto
pointToAdjust
=
GetLastIMESelectionEndPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
pointToAdjust
.
IsInContentNode
(
)
)
{
pointToAdjust
=
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToAdjust
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
EditorUtils
:
:
IsEditableContent
(
*
pointToAdjust
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
AutoTrackDOMPoint
trackPointToAdjust
(
RangeUpdaterRef
(
)
&
pointToAdjust
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
pointToAdjust
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStart
=
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
;
if
(
atStart
!
=
pointToAdjust
&
&
atStart
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atStart
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
AutoTrackDOMPoint
trackPointToAdjust
(
RangeUpdaterRef
(
)
&
pointToAdjust
)
;
AutoTrackDOMPoint
trackStartPoint
(
RangeUpdaterRef
(
)
&
atStart
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
atStart
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
}
EditorDOMPoint
atEnd
=
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
EndPoint
(
)
;
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
Collapsed
(
)
&
&
atEnd
!
=
pointToAdjust
&
&
atEnd
!
=
atStart
&
&
atEnd
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
atEnd
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
atEnd
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
}
break
;
}
default
:
break
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
rv
=
AdjustCaretPositionAndEnsurePaddingBRElement
(
GetDirectionOfTopLevelEditSubAction
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
)
"
"
failed
"
)
;
return
rv
;
}
break
;
default
:
break
;
}
}
bool
reapplyCachedStyle
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
reapplyCachedStyle
=
true
;
break
;
default
:
reapplyCachedStyle
=
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
;
break
;
}
if
(
mPlaceholderBatch
&
&
TopLevelEditSubActionDataRef
(
)
.
mNeedsToCleanUpEmptyElements
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
GetFocusNode
(
)
)
{
RefPtr
<
Element
>
mostDistantEmptyInlineAncestor
=
nullptr
;
for
(
Element
*
ancestor
:
SelectionRef
(
)
.
GetFocusNode
(
)
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
!
ancestor
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
*
ancestor
)
|
|
!
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
*
ancestor
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
break
;
}
mostDistantEmptyInlineAncestor
=
ancestor
;
}
if
(
mostDistantEmptyInlineAncestor
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
mostDistantEmptyInlineAncestor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
at
deleting
"
"
empty
inline
ancestors
"
)
;
return
rv
;
}
}
}
if
(
reapplyCachedStyle
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mTypeInState
-
>
UpdateSelState
(
*
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TypeInState
:
:
UpdateSelState
(
)
failed
but
ignored
"
)
;
rvIgnored
=
ReapplyCachedStyles
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
}
rv
=
HandleInlineSpellCheck
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
HandleInlineSpellCheck
(
)
failed
"
)
;
return
rv
;
}
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
SetSelectionInterlinePosition
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
EditActionCanceled
(
)
;
}
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
nsINode
*
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
selStartNode
)
|
|
NS_WARN_IF
(
!
selStartNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selStartNode
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
selStartNode
-
>
AsContent
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
selEndNode
)
|
|
NS_WARN_IF
(
!
selEndNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
selStartNode
=
=
selEndNode
)
{
return
EditActionIgnored
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selEndNode
)
|
|
HTMLEditUtils
:
:
IsNonEditableReplacedContent
(
*
selEndNode
-
>
AsContent
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
commonAncestor
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
commonAncestor
)
{
NS_WARNING
(
"
AbstractRange
:
:
GetClosestCommonInclusiveAncestor
(
)
returned
nullptr
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
return
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
commonAncestor
)
?
EditActionIgnored
(
)
:
EditActionCanceled
(
)
;
}
MOZ_CAN_RUN_SCRIPT
static
nsStaticAtom
&
MarginPropertyAtomForIndent
(
nsIContent
&
aContent
)
{
nsAutoString
direction
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
aContent
*
nsGkAtoms
:
:
direction
direction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
direction
)
"
"
failed
but
ignored
"
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atSelectionStart
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atSelectionStart
.
IsSetAndValid
(
)
)
;
if
(
!
atSelectionStart
.
IsInContentNode
(
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
did
nothing
"
"
because
of
no
editing
host
"
)
;
return
NS_OK
;
}
nsIContent
*
previousBRElement
=
HTMLEditUtils
:
:
GetPreviousContent
(
atSelectionStart
{
}
editingHost
)
;
if
(
!
previousBRElement
|
|
!
previousBRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
!
previousBRElement
-
>
GetParent
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
previousBRElement
-
>
GetParent
(
)
EditorType
:
:
HTML
)
|
|
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
previousBRElement
)
)
{
return
NS_OK
;
}
const
RefPtr
<
const
Element
>
blockElementAtSelectionStart
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atSelectionStart
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
const
RefPtr
<
const
Element
>
parentBlockElementOfBRElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
previousBRElement
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
!
blockElementAtSelectionStart
|
|
blockElementAtSelectionStart
!
=
parentBlockElementOfBRElement
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atInvisibleBRElement
(
previousBRElement
)
;
nsresult
rv
=
CollapseSelectionTo
(
atInvisibleBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
mPaddingBRElementForEmptyEditor
)
{
return
NS_OK
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
!
rootElement
)
{
return
NS_OK
;
}
EditorType
editorType
=
GetEditorType
(
)
;
bool
isRootEditable
=
EditorUtils
:
:
IsEditableContent
(
*
rootElement
editorType
)
;
for
(
nsIContent
*
rootChild
=
rootElement
-
>
GetFirstChild
(
)
;
rootChild
;
rootChild
=
rootChild
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
rootChild
)
|
|
!
isRootEditable
|
|
EditorUtils
:
:
IsEditableContent
(
*
rootChild
editorType
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
rootChild
)
)
{
return
NS_OK
;
}
}
if
(
IsHTMLEditor
(
)
&
&
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
rootElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
newBRElement
=
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
newBRElement
.
get
(
)
)
;
newBRElement
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_EDITOR
)
;
CreateElementResult
insertBRElementResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newBRElement
EditorDOMPoint
(
rootElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
rootElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mPaddingBRElementForEmptyEditor
)
{
return
NS_OK
;
}
RefPtr
<
HTMLBRElement
>
paddingBRElement
(
std
:
:
move
(
mPaddingBRElementForEmptyEditor
)
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
paddingBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ReflectPaddingBRElementForEmptyEditor
(
)
{
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
NS_WARNING
(
"
Failed
to
handle
padding
BR
element
due
to
no
root
element
"
)
;
return
NS_ERROR_FAILURE
;
}
nsIContent
*
firstLeafChild
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
mRootElement
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
if
(
firstLeafChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
firstLeafChild
)
)
{
mPaddingBRElementForEmptyEditor
=
static_cast
<
HTMLBRElement
*
>
(
firstLeafChild
)
;
}
else
{
mPaddingBRElementForEmptyEditor
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
"
)
;
return
rv
;
}
break
;
}
default
:
break
;
}
}
if
(
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
SelectionHandling
aSelectionHandling
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
MOZ_ASSERT_IF
(
aSelectionHandling
=
=
SelectionHandling
:
:
Ignore
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
aSelectionHandling
=
=
SelectionHandling
:
:
Delete
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
"
"
nsIEditor
:
:
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
GetDocument
(
)
-
>
IsXMLDocument
(
)
?
LimitInBodyElement
:
:
No
:
LimitInBodyElement
:
:
Yes
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
auto
pointToInsert
=
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
CreateStyleForInsertText
(
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateStyleForInsertText
(
)
failed
"
)
;
return
EditActionHandled
(
setStyleResult
.
unwrapErr
(
)
)
;
}
if
(
setStyleResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToInsert
=
setStyleResult
.
unwrap
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
)
{
while
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
if
(
NS_WARN_IF
(
pointToInsert
.
GetContainer
(
)
=
=
editingHost
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
GetContainerParentAs
<
nsIContent
>
(
)
)
)
{
NS_WARNING
(
"
Selection
start
point
couldn
'
t
have
text
nodes
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
pointToInsert
.
Set
(
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
auto
compositionStartPoint
=
GetFirstIMESelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
pointToInsert
;
}
if
(
aInsertionString
.
IsEmpty
(
)
)
{
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
InsertTextWithTransaction
(
*
document
aInsertionString
compositionStartPoint
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
insertTextResult
.
unwrapErr
(
)
)
;
}
return
EditActionHandled
(
)
;
}
auto
compositionEndPoint
=
GetLastIMESelectionEndPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
compositionEndPoint
.
IsSet
(
)
)
{
compositionEndPoint
=
compositionStartPoint
;
}
Result
<
EditorDOMPoint
nsresult
>
replaceTextResult
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
*
this
aInsertionString
EditorDOMRange
(
compositionStartPoint
compositionEndPoint
)
)
;
if
(
MOZ_UNLIKELY
(
replaceTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
)
failed
"
)
;
return
EditActionHandled
(
replaceTextResult
.
unwrapErr
(
)
)
;
}
compositionStartPoint
=
GetFirstIMESelectionStartPoint
<
EditorDOMPoint
>
(
)
;
compositionEndPoint
=
GetLastIMESelectionEndPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
compositionStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
compositionEndPoint
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
)
;
}
nsresult
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
compositionStartPoint
.
ToRawRangeBoundary
(
)
compositionEndPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
int32_t
pos
=
0
;
constexpr
auto
newlineStr
=
NS_LITERAL_STRING_FROM_CSTRING
(
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
!
isWhiteSpaceCollapsible
|
|
IsInPlaintextMode
(
)
)
{
while
(
pos
!
=
-
1
&
&
pos
<
AssertedCast
<
int32_t
>
(
aInsertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
aInsertionString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
aInsertionString
.
Length
(
)
-
oldPos
;
pos
=
aInsertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
aInsertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
currentPoint
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
EditActionHandled
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
!
AllowsTransactionsToChangeSelection
(
)
)
;
pos
+
+
;
RefPtr
<
Element
>
brElement
=
insertBRElementResult
.
UnwrapNewNode
(
)
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
brElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
"
"
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
InsertTextWithTransaction
(
*
document
subStr
currentPoint
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
insertTextResult
.
unwrapErr
(
)
)
;
}
currentPoint
=
insertTextResult
.
inspect
(
)
;
pointToInsert
=
insertTextResult
.
unwrap
(
)
;
}
}
}
else
{
constexpr
auto
tabStr
=
u
"
\
t
"
_ns
;
constexpr
auto
spacesStr
=
u
"
"
_ns
;
nsAutoString
insertionString
(
aInsertionString
)
;
while
(
pos
!
=
-
1
&
&
pos
<
AssertedCast
<
int32_t
>
(
insertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
insertionString
.
FindCharInSet
(
u
"
\
t
\
n
"
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
insertionString
.
Length
(
)
-
oldPos
;
pos
=
insertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
insertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
spacesStr
currentPoint
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
insertTextResult
.
unwrapErr
(
)
)
;
}
pos
+
+
;
MOZ_ASSERT
(
insertTextResult
.
inspect
(
)
.
IsSet
(
)
)
;
currentPoint
=
insertTextResult
.
inspect
(
)
;
pointToInsert
=
insertTextResult
.
unwrap
(
)
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
CreateElementResult
insertBRElementResult
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
currentPoint
*
editingHost
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionHandled
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CareateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
pos
+
+
;
RefPtr
<
Element
>
newBRElement
=
insertBRElementResult
.
UnwrapNewNode
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
newBRElement
)
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
newBRElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
subStr
currentPoint
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
insertTextResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
insertTextResult
.
inspect
(
)
.
IsSet
(
)
)
;
currentPoint
=
insertTextResult
.
inspect
(
)
;
pointToInsert
=
insertTextResult
.
unwrap
(
)
;
}
}
}
}
if
(
currentPoint
.
IsSet
(
)
)
{
currentPoint
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
nsresult
rv
=
CollapseSelectionTo
(
currentPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
currentPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
CollapseTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertLineBreakAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
rv
;
}
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
GetDefaultParagraphSeparator
(
)
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
atStartOfSelection
*
editingHost
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
atStartOfSelection
nsIEditor
:
:
eNext
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
*
this
{
}
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
return
rv
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
atStartOfSelection
=
EditorDOMPoint
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
Result
<
EditorDOMPoint
nsresult
>
insertLineFeedResult
=
HandleInsertLinefeed
(
atStartOfSelection
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
insertLineFeedResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
failed
"
)
;
return
insertLineFeedResult
.
unwrapErr
(
)
;
}
rv
=
CollapseSelectionTo
(
insertLineFeedResult
.
inspect
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertParagraphSeparator
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
{
const
Element
*
editingHostMaybeOutsideBody
=
&
aEditingHost
;
if
(
aEditingHost
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
editingHostMaybeOutsideBody
=
ComputeEditingHost
(
LimitInBodyElement
:
:
No
)
;
if
(
NS_WARN_IF
(
!
editingHostMaybeOutsideBody
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
}
selectionRanges
.
EnsureOnlyEditableRanges
(
*
editingHostMaybeOutsideBody
)
;
if
(
NS_WARN_IF
(
selectionRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
}
auto
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
if
(
IsMailEditor
(
)
)
{
if
(
RefPtr
<
Element
>
mailCiteElement
=
GetMostDistantAncestorMailCiteElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
Result
<
EditorDOMPoint
nsresult
>
atNewBRElementOrError
=
HandleInsertParagraphInMailCiteElement
(
*
mailCiteElement
pointToInsert
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
atNewBRElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInMailCiteElement
(
)
failed
"
)
;
return
EditActionHandled
(
atNewBRElementOrError
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
atNewBRElementOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToPutCaret
.
IsSet
(
)
)
;
pointToPutCaret
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
MOZ_ASSERT
(
pointToPutCaret
.
GetChild
(
)
)
;
MOZ_ASSERT
(
pointToPutCaret
.
GetChild
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
if
(
aEditingHost
.
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aEditingHost
.
GetParentElement
(
)
)
&
&
!
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
&
aEditingHost
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
auto
InsertLineBreakInstead
=
[
]
(
const
Element
*
aEditableBlockElement
const
EditorDOMPoint
&
aCandidatePointToSplit
ParagraphSeparator
aDefaultParagraphSeparator
const
Element
&
aEditingHost
)
{
if
(
!
aEditableBlockElement
)
{
return
true
;
}
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
aEditableBlockElement
)
)
{
return
aDefaultParagraphSeparator
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
aEditingHost
)
|
|
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
aCandidatePointToSplit
aEditingHost
)
;
}
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
aEditableBlockElement
)
)
{
return
false
;
}
for
(
const
Element
*
editableBlockAncestor
=
aEditableBlockElement
;
editableBlockAncestor
;
editableBlockAncestor
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
editableBlockAncestor
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
{
if
(
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
editableBlockAncestor
)
)
{
return
false
;
}
}
return
true
;
}
;
RefPtr
<
Element
>
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
const
ParagraphSeparator
separator
=
GetDefaultParagraphSeparator
(
)
;
if
(
InsertLineBreakInstead
(
editableBlockElement
pointToInsert
separator
aEditingHost
)
)
{
if
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
pointToInsert
aEditingHost
)
)
{
Result
<
EditorDOMPoint
nsresult
>
insertLineFeedResult
=
HandleInsertLinefeed
(
pointToInsert
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
insertLineFeedResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
failed
"
)
;
return
EditActionResult
(
insertLineFeedResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
CollapseSelectionTo
(
insertLineFeedResult
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
CreateElementResult
insertBRElementResult
=
HandleInsertBRElement
(
pointToInsert
aEditingHost
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionHandled
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
*
this
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
auto
CollapseSelection
=
[
this
]
(
const
EditorDOMPoint
&
aCandidatePointToPutCaret
const
Element
*
aBlockElementShouldHaveCaret
const
SuggestCaretOptions
&
aOptions
)
MOZ_CAN_RUN_SCRIPT
-
>
nsresult
{
if
(
!
aCandidatePointToPutCaret
.
IsSet
(
)
)
{
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
)
{
return
NS_OK
;
}
return
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
?
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
:
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToPutCaret
(
aCandidatePointToPutCaret
)
;
if
(
aBlockElementShouldHaveCaret
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorDOMPoint
>
(
*
aBlockElementShouldHaveCaret
aCandidatePointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
"
"
failed
but
ignored
"
)
;
}
else
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
&
&
MOZ_LIKELY
(
rv
!
=
NS_ERROR_EDITOR_DESTROYED
)
&
&
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
{
rv
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
;
}
return
rv
;
}
;
RefPtr
<
Element
>
blockElementToPutCaret
;
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
suggestBlockElementToPutCaretOrError
=
FormatBlockContainerWithTransaction
(
selectionRanges
MOZ_KnownLive
(
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
separator
)
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
suggestBlockElementToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
suggestBlockElementToPutCaretOrError
.
unwrapErr
(
)
)
;
}
if
(
selectionRanges
.
HasSavedRanges
(
)
)
{
selectionRanges
.
RestoreFromSavedRanges
(
)
;
}
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
blockElementToPutCaret
=
suggestBlockElementToPutCaretOrError
.
unwrap
(
)
;
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
NS_WARN_IF
(
!
editableBlockElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
)
)
{
CreateElementResult
insertBRElementResult
=
HandleInsertBRElement
(
pointToInsert
aEditingHost
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
insertBRElementResult
.
UnwrapCaretPoint
(
)
;
if
(
MOZ_UNLIKELY
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
didn
'
t
suggest
a
point
to
put
"
"
caret
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
nsresult
rv
=
CollapseSelection
(
pointToPutCaret
blockElementToPutCaret
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
blockElementToPutCaret
=
editableBlockElement
;
}
RefPtr
<
Element
>
insertedPaddingBRElement
;
if
(
HTMLEditUtils
:
:
IsEmptyBlockElement
(
*
editableBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
*
editableBlockElement
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
EditActionIgnored
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
insertedPaddingBRElement
=
insertBRElementResult
.
UnwrapNewNode
(
)
;
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
RefPtr
<
Element
>
maybeNonEditableListItem
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
*
editableBlockElement
&
aEditingHost
)
;
if
(
maybeNonEditableListItem
&
&
HTMLEditUtils
:
:
IsSplittableNode
(
*
maybeNonEditableListItem
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
HandleInsertParagraphInListItemElement
(
*
maybeNonEditableListItem
pointToInsert
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
unwrapErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
)
failed
but
"
"
ignored
"
)
;
return
EditActionHandled
(
)
;
}
nsresult
rv
=
CollapseSelection
(
pointToPutCaretOrError
.
inspect
(
)
blockElementToPutCaret
{
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CollapseSelection
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
editableBlockElement
)
)
{
SplitNodeResult
splitHeadingElementResult
=
HandleInsertParagraphInHeadingElement
(
*
editableBlockElement
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
splitHeadingElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
)
failed
"
)
;
return
EditActionHandled
(
)
;
}
EditorDOMPoint
pointToPutCaret
=
splitHeadingElementResult
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
CollapseSelection
(
pointToPutCaret
blockElementToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CollapseSelection
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
SplitNodeResult
splitResult
=
HandleInsertParagraphInParagraph
(
*
editableBlockElement
insertedPaddingBRElement
?
EditorDOMPoint
(
insertedPaddingBRElement
)
:
pointToInsert
aEditingHost
)
;
if
(
splitResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
failed
"
)
;
return
EditActionResult
(
splitResult
.
unwrapErr
(
)
)
;
}
if
(
splitResult
.
Handled
(
)
)
{
EditorDOMPoint
pointToPutCaret
=
splitResult
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
CollapseSelection
(
pointToPutCaret
blockElementToPutCaret
{
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CollapseSelection
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CollapseSelection
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
MOZ_ASSERT
(
!
splitResult
.
HasCaretPointSuggestion
(
)
)
;
MOZ_ASSERT
(
!
result
.
Canceled
(
)
)
;
MOZ_ASSERT
(
result
.
Rv
(
)
=
=
NS_SUCCESS_DOM_NO_OPERATION
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
shouldn
'
t
touch
"
"
the
DOM
tree
if
it
returns
not
-
handled
state
"
)
;
}
CreateElementResult
insertBRElementResult
=
HandleInsertBRElement
(
pointToInsert
aEditingHost
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
insertBRElementResult
.
UnwrapCaretPoint
(
)
;
rv
=
CollapseSelection
(
pointToPutCaret
blockElementToPutCaret
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
CreateElementResult
HTMLEditor
:
:
HandleInsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPointToBreak
.
IsSet
(
)
)
;
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
brElementIsAfterBlock
=
false
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsInPlaintextMode
(
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
aPointToBreak
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
CreateElementResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
brElement
=
insertBRElementResult
.
UnwrapNewNode
(
)
;
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunScanner
wsRunScanner
(
&
aEditingHost
pointToBreak
)
;
WSScanResult
backwardScanResult
=
wsRunScanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
;
if
(
MOZ_UNLIKELY
(
backwardScanResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
brElementIsAfterBlock
=
backwardScanResult
.
ReachedBlockBoundary
(
)
;
WSScanResult
forwardScanResult
=
wsRunScanner
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
;
if
(
MOZ_UNLIKELY
(
forwardScanResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
brElementIsBeforeBlock
=
forwardScanResult
.
ReachedBlockBoundary
(
)
;
RefPtr
<
Element
>
linkNode
=
HTMLEditor
:
:
GetLinkElement
(
pointToBreak
.
GetContainer
(
)
)
;
if
(
linkNode
)
{
const
SplitNodeResult
splitLinkNodeResult
=
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitLinkNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
CreateElementResult
(
splitLinkNodeResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
splitLinkNodeResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
pointToBreak
=
splitLinkNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
splitLinkNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
CreateElementResult
insertBRElementResult
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
pointToBreak
aEditingHost
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
CreateElementResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
insertBRElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
brElement
)
;
}
if
(
MOZ_UNLIKELY
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
NS_WARNING
(
"
Inserted
<
br
>
element
was
removed
by
the
web
app
"
)
;
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
EditorDOMPoint
pointToPutCaret
(
brElement
InterlinePosition
:
:
StartOfNextLine
)
;
return
CreateElementResult
(
std
:
:
move
(
brElement
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
auto
afterBRElement
=
EditorDOMPoint
:
:
After
(
brElement
)
;
WSScanResult
forwardScanFromAfterBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
afterBRElement
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromAfterBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromAfterBRElementResult
.
ReachedBRElement
(
)
)
{
if
(
brElement
-
>
GetNextSibling
(
)
!
=
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
{
MOZ_ASSERT
(
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
;
const
MoveNodeResult
moveBRElementResult
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
afterBRElement
)
;
if
(
moveBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveBRElementResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
moveBRElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
afterBRElement
.
SetInterlinePosition
(
nextSiblingOfBRElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSiblingOfBRElement
)
?
InterlinePosition
:
:
EndOfLine
:
InterlinePosition
:
:
StartOfNextLine
)
;
return
CreateElementResult
(
std
:
:
move
(
brElement
)
afterBRElement
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertLinefeed
(
const
EditorDOMPoint
&
aPointToBreak
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
const
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
document
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
CreateStyleForInsertText
(
aPointToBreak
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateStyleForInsertText
(
)
failed
"
)
;
return
setStyleResult
.
propagateErr
(
)
;
}
EditorDOMPoint
pointToInsert
=
setStyleResult
.
inspect
(
)
.
IsSet
(
)
?
setStyleResult
.
inspect
(
)
:
aPointToBreak
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
&
&
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertLinefeed
(
)
couldn
'
t
insert
a
linefeed
because
"
"
the
insertion
position
couldn
'
t
have
text
nodes
"
)
;
return
Err
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorDOMPoint
pointToPutCaret
;
{
AutoTrackDOMPoint
trackingInsertingPosition
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
InsertTextWithTransaction
(
*
document
u
"
\
n
"
_ns
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
insertTextResult
;
}
pointToPutCaret
=
insertTextResult
.
unwrap
(
)
;
}
if
(
pointToPutCaret
.
IsInContentNode
(
)
&
&
pointToPutCaret
.
IsEndOfContainer
(
)
)
{
WSRunScanner
wsScannerAtCaret
(
&
aEditingHost
pointToPutCaret
)
;
if
(
wsScannerAtCaret
.
StartsFromPreformattedLineBreak
(
)
&
&
wsScannerAtCaret
.
EndsByBlockBoundary
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
wsScannerAtCaret
.
GetEndReasonContent
(
)
*
nsGkAtoms
:
:
br
)
)
{
AutoTrackDOMPoint
trackingInsertedPosition
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToPutCaret
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
MOZ_ASSERT
(
pointToPutCaret
.
IsSet
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
if
(
NS_FAILED
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
CollapseTo
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
NS_WARNING
(
"
We
always
return
NS_ERROR_FAILURE
here
because
of
a
failure
of
"
"
updating
mChangedRange
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_FAILED
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
pointToPutCaret
.
ToRawRangeBoundary
(
)
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
pointToPutCaret
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertParagraphInMailCiteElement
(
Element
&
aMailCiteElement
const
EditorDOMPoint
&
aPointToSplit
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aMailCiteElement
)
"
The
mail
-
cite
element
will
be
deleted
does
it
expected
result
"
"
for
you
?
"
)
;
const
SplitNodeResult
splitCiteElementResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
WSScanResult
forwardScanFromPointToSplitResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
pointToSplit
)
;
if
(
forwardScanFromPointToSplitResult
.
Failed
(
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromPointToSplitResult
.
ReachedBRElement
(
)
&
&
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
!
=
&
aMailCiteElement
&
&
aMailCiteElement
.
Contains
(
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
)
)
{
pointToSplit
=
forwardScanFromPointToSplitResult
.
PointAfterContent
<
EditorDOMPoint
>
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitResult
=
SplitNodeDeepWithTransaction
(
aMailCiteElement
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aMailCiteElement
"
"
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitResult
;
}
nsresult
rv
=
splitResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
return
splitResult
;
}
(
)
;
if
(
splitCiteElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
Failed
to
split
a
mail
-
cite
element
"
)
;
return
Err
(
splitCiteElementResult
.
unwrapErr
(
)
)
;
}
splitCiteElementResult
.
IgnoreCaretPointSuggestion
(
)
;
Element
*
const
leftCiteElement
=
Element
:
:
FromNodeOrNull
(
splitCiteElementResult
.
GetPreviousContent
(
)
)
;
Element
*
const
rightCiteElement
=
Element
:
:
FromNodeOrNull
(
splitCiteElementResult
.
GetNextContent
(
)
)
;
if
(
leftCiteElement
&
&
leftCiteElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsIContent
*
lastChild
=
leftCiteElement
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
const
CreateElementResult
insertInvisibleBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
*
leftCiteElement
)
)
;
if
(
insertInvisibleBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertInvisibleBRElementResult
.
unwrapErr
(
)
)
;
}
insertInvisibleBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertInvisibleBRElementResult
.
GetNewNode
(
)
)
;
}
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
splitCiteElementResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
aMailCiteElement
)
)
{
nsresult
rvOfInsertingBRElement
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
EditorDOMPoint
pointToCreateNewBRElement
(
insertBRElementResult
.
GetNewNode
(
)
)
;
WSScanResult
backwardScanFromPointToCreateNewBRElementResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
&
aEditingHost
pointToCreateNewBRElement
)
;
if
(
MOZ_UNLIKELY
(
backwardScanFromPointToCreateNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
backwardScanFromPointToCreateNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
backwardScanFromPointToCreateNewBRElementResult
.
ReachedSpecialContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
WSScanResult
forwardScanFromPointAfterNewBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
EditorRawDOMPoint
:
:
After
(
pointToCreateNewBRElement
)
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromPointAfterNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
forwardScanFromPointAfterNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedSpecialContent
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToCreateNewBRElement
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
return
NS_OK
;
}
(
)
;
if
(
NS_FAILED
(
rvOfInsertingBRElement
)
)
{
NS_WARNING
(
"
Failed
to
insert
additional
<
br
>
element
before
the
inline
right
"
"
mail
-
cite
element
"
)
;
return
Err
(
rvOfInsertingBRElement
)
;
}
}
if
(
leftCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftCiteElement
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
leftCiteElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
rightCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
rightCiteElement
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightCiteElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
insertBRElementResult
.
GetNewNode
(
)
-
>
GetParent
(
)
)
)
{
NS_WARNING
(
"
Inserted
<
br
>
shouldn
'
t
become
an
orphan
node
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
EditorDOMPoint
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsStartOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetPreviousCharPointType
(
aPoint
)
)
;
}
const
auto
previousCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
<
EditorRawDOMPointInText
>
(
ComputeEditingHost
(
)
aPoint
)
;
if
(
!
previousCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
previousCharPoint
)
)
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetCharPointType
(
aPoint
)
)
;
}
const
auto
nextCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
<
EditorRawDOMPointInText
>
(
ComputeEditingHost
(
)
aPoint
)
;
if
(
!
nextCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
nextCharPoint
)
)
;
}
void
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
nsAString
&
aResult
uint32_t
aLength
const
CharPointData
&
aPreviousCharPointData
const
CharPointData
&
aNextCharPointData
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aLength
)
;
MOZ_ASSERT
(
aPreviousCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aPreviousCharPointData
.
IsCollapsibleWhiteSpace
(
)
)
;
MOZ_ASSERT
(
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aNextCharPointData
.
IsCollapsibleWhiteSpace
(
)
)
;
if
(
aLength
=
=
1
)
{
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
&
&
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kNBSP
)
;
return
;
}
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kNBSP
)
;
return
;
}
aResult
.
Assign
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
aResult
.
SetLength
(
aLength
)
;
bool
appendNBSP
=
true
;
char16_t
*
lastChar
=
aResult
.
EndWriting
(
)
-
1
;
for
(
char16_t
*
iter
=
aResult
.
BeginWriting
(
)
;
iter
!
=
lastChar
;
iter
+
+
)
{
*
iter
=
appendNBSP
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
appendNBSP
=
!
appendNBSP
;
}
if
(
appendNBSP
)
{
*
lastChar
=
HTMLEditUtils
:
:
kNBSP
;
return
;
}
*
lastChar
=
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
PreformattedLineBreak
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
}
void
HTMLEditor
:
:
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
EditorDOMPointInText
&
aStartToDelete
EditorDOMPointInText
&
aEndToDelete
nsAString
&
aNormalizedWhiteSpacesInStartNode
nsAString
&
aNormalizedWhiteSpacesInEndNode
)
const
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInStartNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
IsEmpty
(
)
)
;
Element
*
editingHost
=
ComputeEditingHost
(
)
;
const
EditorDOMPointInText
precedingCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
editingHost
aStartToDelete
)
;
const
EditorDOMPointInText
followingCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
editingHost
aEndToDelete
)
;
const
bool
removingLastCharOfStartNode
=
aStartToDelete
.
ContainerAs
<
Text
>
(
)
!
=
aEndToDelete
.
ContainerAs
<
Text
>
(
)
|
|
(
aEndToDelete
.
IsEndOfContainer
(
)
&
&
followingCharPoint
.
IsSet
(
)
)
;
const
bool
maybeNormalizePrecedingWhiteSpaces
=
!
removingLastCharOfStartNode
&
&
precedingCharPoint
.
IsSet
(
)
&
&
!
precedingCharPoint
.
IsEndOfContainer
(
)
&
&
precedingCharPoint
.
ContainerAs
<
Text
>
(
)
=
=
aStartToDelete
.
ContainerAs
<
Text
>
(
)
&
&
precedingCharPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
;
const
bool
maybeNormalizeFollowingWhiteSpaces
=
followingCharPoint
.
IsSet
(
)
&
&
!
followingCharPoint
.
IsEndOfContainer
(
)
&
&
(
followingCharPoint
.
ContainerAs
<
Text
>
(
)
=
=
aEndToDelete
.
ContainerAs
<
Text
>
(
)
|
|
removingLastCharOfStartNode
)
&
&
followingCharPoint
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
;
if
(
!
maybeNormalizePrecedingWhiteSpaces
&
&
!
maybeNormalizeFollowingWhiteSpaces
)
{
return
;
}
EditorDOMPointInText
startToNormalize
endToNormalize
;
if
(
maybeNormalizePrecedingWhiteSpaces
)
{
Maybe
<
uint32_t
>
previousCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
precedingCharPoint
{
WalkTextOption
:
:
TreatNBSPsCollapsible
}
)
;
startToNormalize
.
Set
(
precedingCharPoint
.
ContainerAs
<
Text
>
(
)
previousCharOffsetOfWhiteSpaces
.
isSome
(
)
?
previousCharOffsetOfWhiteSpaces
.
value
(
)
+
1
:
0
)
;
MOZ_ASSERT
(
!
startToNormalize
.
IsEndOfContainer
(
)
)
;
}
if
(
maybeNormalizeFollowingWhiteSpaces
)
{
Maybe
<
uint32_t
>
nextCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
followingCharPoint
{
WalkTextOption
:
:
TreatNBSPsCollapsible
}
)
;
if
(
nextCharOffsetOfWhiteSpaces
.
isSome
(
)
)
{
endToNormalize
.
Set
(
followingCharPoint
.
ContainerAs
<
Text
>
(
)
nextCharOffsetOfWhiteSpaces
.
value
(
)
)
;
}
else
{
endToNormalize
.
SetToEndOf
(
followingCharPoint
.
ContainerAs
<
Text
>
(
)
)
;
}
MOZ_ASSERT
(
!
endToNormalize
.
IsStartOfContainer
(
)
)
;
}
CharPointData
previousCharPointData
=
removingLastCharOfStartNode
?
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
startToNormalize
.
IsSet
(
)
?
startToNormalize
:
aStartToDelete
)
;
CharPointData
nextCharPointData
=
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
endToNormalize
.
IsSet
(
)
?
endToNormalize
:
aEndToDelete
)
;
uint32_t
lengthInStartNode
=
0
lengthInEndNode
=
0
;
if
(
startToNormalize
.
IsSet
(
)
)
{
MOZ_ASSERT
(
startToNormalize
.
ContainerAs
<
Text
>
(
)
=
=
aStartToDelete
.
ContainerAs
<
Text
>
(
)
)
;
lengthInStartNode
=
aStartToDelete
.
Offset
(
)
-
startToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInStartNode
)
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
lengthInEndNode
=
endToNormalize
.
ContainerAs
<
Text
>
(
)
=
=
aEndToDelete
.
ContainerAs
<
Text
>
(
)
?
endToNormalize
.
Offset
(
)
-
aEndToDelete
.
Offset
(
)
:
endToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInEndNode
)
;
if
(
endToNormalize
.
ContainerAs
<
Text
>
(
)
=
=
aStartToDelete
.
ContainerAs
<
Text
>
(
)
)
{
lengthInStartNode
+
=
lengthInEndNode
;
lengthInEndNode
=
0
;
}
}
MOZ_ASSERT
(
lengthInStartNode
+
lengthInEndNode
)
;
if
(
!
lengthInEndNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInStartNode
lengthInStartNode
previousCharPointData
nextCharPointData
)
;
}
else
if
(
!
lengthInStartNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInEndNode
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
}
else
{
nsAutoString
whiteSpaces
;
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
whiteSpaces
lengthInStartNode
+
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
aNormalizedWhiteSpacesInStartNode
=
Substring
(
whiteSpaces
0
lengthInStartNode
)
;
aNormalizedWhiteSpacesInEndNode
=
Substring
(
whiteSpaces
lengthInStartNode
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
Length
(
)
=
=
lengthInEndNode
)
;
}
if
(
startToNormalize
.
IsSet
(
)
)
{
aStartToDelete
=
startToNormalize
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
aEndToDelete
=
endToNormalize
;
}
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
const
EditorDOMPointInText
&
aStartToDelete
const
EditorDOMPointInText
&
aEndToDelete
TreatEmptyTextNodes
aTreatEmptyTextNodes
DeleteDirection
aDeleteDirection
)
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
nsString
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
;
EditorDOMPointInText
startToDelete
(
aStartToDelete
)
;
EditorDOMPointInText
endToDelete
(
aEndToDelete
)
;
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
startToDelete
endToDelete
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
)
;
if
(
startToDelete
=
=
endToDelete
)
{
return
aStartToDelete
.
To
<
EditorDOMPoint
>
(
)
;
}
EditorDOMPoint
newCaretPosition
;
if
(
aStartToDelete
.
ContainerAs
<
Text
>
(
)
=
=
aEndToDelete
.
ContainerAs
<
Text
>
(
)
)
{
newCaretPosition
=
aEndToDelete
.
To
<
EditorDOMPoint
>
(
)
;
}
else
if
(
aDeleteDirection
=
=
DeleteDirection
:
:
Forward
)
{
newCaretPosition
.
SetToEndOf
(
aStartToDelete
.
ContainerAs
<
Text
>
(
)
)
;
}
else
{
newCaretPosition
.
Set
(
aEndToDelete
.
ContainerAs
<
Text
>
(
)
0u
)
;
}
while
(
true
)
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
if
(
!
normalizedWhiteSpacesInFirstNode
.
IsEmpty
(
)
)
{
EditorDOMPoint
trackingEndToDelete
(
endToDelete
.
ContainerAs
<
Text
>
(
)
endToDelete
.
Offset
(
)
)
;
{
AutoTrackDOMPoint
trackEndToDelete
(
RangeUpdaterRef
(
)
&
trackingEndToDelete
)
;
uint32_t
lengthToReplaceInFirstTextNode
=
startToDelete
.
ContainerAs
<
Text
>
(
)
=
=
trackingEndToDelete
.
ContainerAs
<
Text
>
(
)
?
trackingEndToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
:
startToDelete
.
ContainerAs
<
Text
>
(
)
-
>
TextLength
(
)
-
startToDelete
.
Offset
(
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAs
<
Text
>
(
)
)
startToDelete
.
Offset
(
)
lengthToReplaceInFirstTextNode
normalizedWhiteSpacesInFirstNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
startToDelete
.
ContainerAs
<
Text
>
(
)
=
=
trackingEndToDelete
.
ContainerAs
<
Text
>
(
)
)
{
MOZ_ASSERT
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
break
;
}
}
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
(
NS_WARN_IF
(
!
trackingEndToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
trackingEndToDelete
.
IsInTextNode
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
trackingEndToDelete
.
IsInTextNode
(
)
)
;
endToDelete
.
Set
(
trackingEndToDelete
.
ContainerAs
<
Text
>
(
)
trackingEndToDelete
.
Offset
(
)
)
;
startToDelete
=
EditorDOMPointInText
:
:
AtEndOf
(
*
startToDelete
.
ContainerAs
<
Text
>
(
)
)
;
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
NS_WARN_IF
(
!
startToDelete
.
IsBefore
(
endToDelete
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
|
|
startToDelete
.
ContainerAs
<
Text
>
(
)
!
=
endToDelete
.
ContainerAs
<
Text
>
(
)
)
{
EditorDOMPointInText
endToDeleteExceptReplaceRange
=
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
?
endToDelete
:
EditorDOMPointInText
(
endToDelete
.
ContainerAs
<
Text
>
(
)
0
)
;
if
(
startToDelete
!
=
endToDeleteExceptReplaceRange
)
{
nsresult
rv
=
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDeleteExceptReplaceRange
aTreatEmptyTextNodes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
{
break
;
}
if
(
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
&
&
(
NS_WARN_IF
(
!
endToDeleteExceptReplaceRange
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
endToDelete
.
IsStartOfContainer
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
startToDelete
=
endToDeleteExceptReplaceRange
;
}
}
MOZ_ASSERT
(
!
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
ContainerAs
<
Text
>
(
)
=
=
endToDelete
.
ContainerAs
<
Text
>
(
)
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAs
<
Text
>
(
)
)
startToDelete
.
Offset
(
)
endToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
normalizedWhiteSpacesInLastNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
break
;
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
|
|
!
newCaretPosition
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
got
lost
"
"
the
modifying
line
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
newCaretPosition
.
IsInTextNode
(
)
)
{
if
(
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
newCaretPosition
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
)
{
Element
*
editingHost
=
ComputeEditingHost
(
)
;
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
newCaretPosition
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
editingHost
)
;
if
(
previousContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
newCaretPosition
=
previousContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
?
EditorDOMPoint
:
:
AtEndOf
(
*
previousContent
)
:
EditorDOMPoint
:
:
After
(
*
previousContent
)
;
}
else
if
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
newCaretPosition
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
editingHost
)
)
{
newCaretPosition
=
nextContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
?
EditorDOMPoint
(
nextContent
0
)
:
EditorDOMPoint
(
nextContent
)
;
}
}
}
if
(
newCaretPosition
.
IsStartOfContainer
(
)
&
&
newCaretPosition
.
IsInTextNode
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
IsText
(
)
)
{
newCaretPosition
.
SetToEndOf
(
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
AsText
(
)
)
;
}
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
Inserting
<
br
>
element
caused
unexpected
DOM
tree
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
newCaretPosition
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
!
aPointToInsert
.
IsInContentNode
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
NS_OK
;
}
WSRunScanner
wsRunScanner
(
ComputeEditingHost
(
)
aPointToInsert
)
;
if
(
!
wsRunScanner
.
StartsFromHardLineBreak
(
)
)
{
return
NS_OK
;
}
if
(
!
wsRunScanner
.
EndsByBlockBoundary
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
aPointToInsert
nsIEditor
:
:
ePrevious
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
ePrevious
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
*
this
{
}
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
nsAtom
&
aListElementOrListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
?
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
EditSubAction
:
:
eCreateOrChangeList
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
nsAtom
*
listTagName
=
nullptr
;
nsAtom
*
listItemTagName
=
nullptr
;
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
li
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
dd
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
{
listTagName
=
nsGkAtoms
:
:
dl
;
listItemTagName
=
&
aListElementOrListItemElementTagName
;
}
else
{
NS_WARNING
(
"
aListElementOrListItemElementTagName
was
neither
list
element
name
"
"
nor
"
"
definition
listitem
element
name
"
)
;
return
EditActionResult
(
NS_ERROR_INVALID_ARG
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
MOZ_UNLIKELY
(
!
editingHost
)
)
{
return
EditActionIgnored
(
NS_SUCCESS_DOM_NO_OPERATION
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
SelectionRef
(
)
.
GetRangeAt
(
0u
)
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
extendedRange
.
unwrapErr
(
)
)
;
}
error
.
SuppressException
(
)
;
SelectionRef
(
)
.
SetBaseAndExtentInLimiter
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
}
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
result
=
ConvertContentAroundRangesToList
(
selectionRanges
MOZ_KnownLive
(
*
listTagName
)
MOZ_KnownLive
(
*
listItemTagName
)
aBulletType
aSelectAllOfCurrentList
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
result
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ConvertContentAroundRangesToList
(
)
failed
"
)
;
return
result
;
}
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
result
.
Ignored
(
)
?
EditActionCanceled
(
rv
)
:
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
ConvertContentAroundRangesToList
(
AutoRangeArray
&
aRanges
nsAtom
&
aListElementTagName
nsAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
NS_WARN_IF
(
!
aRanges
.
SaveAndTrackRanges
(
*
this
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
Element
*
parentListElement
=
aSelectAllOfCurrentList
=
=
SelectAllOfCurrentList
:
:
Yes
?
aRanges
.
GetClosestAncestorAnyListElementOfRange
(
)
:
nullptr
)
{
arrayOfContents
.
AppendElement
(
OwningNonNull
<
nsIContent
>
(
*
parentListElement
)
)
;
}
else
{
AutoRangeArray
extendedRanges
(
aRanges
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
extendedRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrChangeList
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
EditActionResult
(
splitResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
extendedRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
const
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eCreateOrChangeList
)
failed
"
)
;
return
EditActionResult
(
splitAtBRElementsResult
.
inspectErr
(
)
)
;
}
}
auto
IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements
=
[
]
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
false
;
}
}
return
true
;
}
;
if
(
IsEmptyOrContainsOnlyBRElementsOrEmptyInlineElements
(
arrayOfContents
)
)
{
for
(
auto
&
content
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
const
auto
firstRangeStartPoint
=
aRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
firstRangeStartPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
firstRangeStartPoint
.
GetContainer
(
)
aListElementTagName
)
)
{
aRanges
.
RestoreFromSavedRanges
(
)
;
return
EditActionCanceled
(
)
;
}
RefPtr
<
Element
>
newListItemElement
;
CreateElementResult
createNewListElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
aListElementTagName
firstRangeStartPoint
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
[
&
newListItemElement
&
aListItemElementTagName
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aListElement
const
EditorDOMPoint
&
aPointToInsert
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aListElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
CreateElementResult
createNewListItemElementResult
=
aHTMLEditor
.
CreateAndInsertElement
(
withTransaction
aListItemElementTagName
EditorDOMPoint
(
&
aListElement
0u
)
)
;
if
(
createNewListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
createNewListItemElementResult
.
unwrapErr
(
)
;
}
createNewListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
newListItemElement
=
createNewListItemElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newListItemElement
)
;
return
NS_OK
;
}
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
&
aListElementTagName
)
.
get
(
)
)
.
get
(
)
)
;
return
EditActionResult
(
createNewListElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
createNewListElementResult
.
GetNewNode
(
)
)
;
createNewListElementResult
.
IgnoreCaretPointSuggestion
(
)
;
aRanges
.
ClearSavedRanges
(
)
;
nsresult
rv
=
aRanges
.
Collapse
(
EditorRawDOMPoint
(
newListItemElement
0u
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
if
(
Element
*
deepestDivBlockquoteOrListElement
=
HTMLEditUtils
:
:
GetInclusiveDeepestFirstChildWhichHasOneChild
(
arrayOfContents
[
0
]
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
)
)
{
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
arrayOfContents
.
Clear
(
)
;
HTMLEditUtils
:
:
CollectChildren
(
*
deepestDivBlockquoteOrListElement
arrayOfContents
0
{
}
)
;
}
else
{
arrayOfContents
.
ReplaceElementAt
(
0
OwningNonNull
<
nsIContent
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
}
}
}
uint32_t
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
RefPtr
<
Element
>
curList
prevListItem
listItemOrListToPutCaret
;
for
(
uint32_t
i
=
0
;
i
<
countOfCollectedContents
;
i
+
+
)
{
const
OwningNonNull
<
nsIContent
>
content
=
arrayOfContents
[
i
]
;
if
(
curList
&
&
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
curList
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
content
)
)
{
curList
=
nullptr
;
}
if
(
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
content
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
const
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
const
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
convertListTypeResult
.
IgnoreCaretPointSuggestion
(
)
;
const
Result
<
EditorDOMPoint
nsresult
>
unwrapNewListElementResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
convertListTypeResult
.
GetNewNode
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapNewListElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
unwrapNewListElementResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
prevListItem
=
nullptr
;
continue
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
convertListTypeResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
convertListTypeResult
.
GetNewNode
(
)
)
;
curList
=
convertListTypeResult
.
UnwrapNewNode
(
)
;
prevListItem
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atContent
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
!
atContent
.
IsContainerHTMLElement
(
&
aListElementTagName
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNode
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
const
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
atContent
)
;
if
(
splitListItemParentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
splitListItemParentResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
splitListItemParentResult
.
DidSplit
(
)
)
;
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
splitListItemParentResult
.
IgnoreCaretPointSuggestion
(
)
;
CreateElementResult
createNewListElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
aListElementTagName
splitListItemParentResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
EditActionResult
(
createNewListElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
createNewListElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewListElementResult
.
GetNewNode
(
)
)
;
curList
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
}
const
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
const
CreateElementResult
newListItemElementOrError
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
newListItemElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
newListItemElementOrError
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
newListItemElementOrError
.
IgnoreCaretPointSuggestion
(
)
;
}
}
else
{
if
(
!
curList
)
{
curList
=
atContent
.
GetContainerAs
<
Element
>
(
)
;
NS_WARNING_ASSERTION
(
HTMLEditUtils
:
:
IsAnyListElement
(
curList
)
"
Current
list
item
parent
is
not
a
list
element
"
)
;
}
else
if
(
atContent
.
GetContainer
(
)
!
=
curList
)
{
const
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
const
CreateElementResult
newListItemElementOrError
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
newListItemElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
newListItemElementOrError
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
newListItemElementOrError
.
IgnoreCaretPointSuggestion
(
)
;
}
}
Element
*
element
=
Element
:
:
FromNode
(
content
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aBulletType
.
IsEmpty
(
)
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
aBulletType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
!
element
-
>
HasAttr
(
nsGkAtoms
:
:
type
)
)
{
continue
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
&
&
!
HTMLEditUtils
:
:
IsListItem
(
content
)
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
HTMLEditUtils
:
:
CollectChildren
(
*
content
arrayOfContents
i
+
1
{
CollectChildrenOption
:
:
CollectListChildren
CollectChildrenOption
:
:
CollectTableChildren
}
)
;
const
Result
<
EditorDOMPoint
nsresult
>
unwrapDivElementResult
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapDivElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
unwrapDivElementResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
prevListItem
=
nullptr
;
CreateElementResult
createNewListElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
aListElementTagName
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aListElementTagName
)
.
get
(
)
)
.
get
(
)
)
;
return
EditActionResult
(
createNewListElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
createNewListElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewListElementResult
.
GetNewNode
(
)
)
;
listItemOrListToPutCaret
=
createNewListElementResult
.
GetNewNode
(
)
;
curList
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
atContent
.
Clear
(
)
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
prevListItem
)
{
const
MoveNodeResult
moveInlineElementResult
=
MoveNodeToEndWithTransaction
(
*
content
*
prevListItem
)
;
if
(
moveInlineElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveInlineElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveInlineElementResult
.
IgnoreCaretPointSuggestion
(
)
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
CreateElementResult
newListItemElementOrError
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
newListItemElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
newListItemElementOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
newListItemElementOrError
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
newListItemElementOrError
.
GetNewNode
(
)
)
;
const
MoveNodeResult
moveListItemElementResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
newListItemElementOrError
.
GetNewNode
(
)
)
*
curList
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveListItemElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
prevListItem
=
nullptr
;
continue
;
}
CreateElementResult
wrapContentInListItemElementResult
=
InsertContainerWithTransaction
(
*
content
aListItemElementTagName
)
;
if
(
wrapContentInListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
wrapContentInListItemElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
wrapContentInListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
wrapContentInListItemElementResult
.
GetNewNode
(
)
)
;
const
MoveNodeResult
moveListItemElementResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
wrapContentInListItemElementResult
.
GetNewNode
(
)
)
*
curList
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveListItemElementResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
moveListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
prevListItem
=
wrapContentInListItemElementResult
.
UnwrapNewNode
(
)
;
}
else
{
prevListItem
=
nullptr
;
}
}
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
aRanges
.
RestoreFromSavedRanges
(
)
;
if
(
listItemOrListToPutCaret
&
&
aRanges
.
IsCollapsed
(
)
&
&
aRanges
.
Ranges
(
)
.
Length
(
)
)
{
const
auto
firstRangeStartPoint
=
aRanges
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_LIKELY
(
firstRangeStartPoint
.
IsSet
(
)
)
)
{
const
Result
<
EditorRawDOMPoint
nsresult
>
pointToPutCaretOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
*
listItemOrListToPutCaret
firstRangeStartPoint
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
"
"
failed
but
ignored
"
)
;
}
else
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
aRanges
.
Collapse
(
pointToPutCaretOrError
.
inspect
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveList
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
SelectionRef
(
)
.
GetRangeAt
(
0u
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
extendedRange
.
unwrapErr
(
)
;
}
error
.
SuppressException
(
)
;
SelectionRef
(
)
.
SetBaseAndExtentInLimiter
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
{
AutoRangeArray
extendedSelectionRanges
(
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrChangeList
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedSelectionRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
rv
;
}
}
const
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eCreateOrChangeList
)
failed
"
)
;
return
splitAtBRElementsResult
.
inspectErr
(
)
;
}
}
for
(
int32_t
i
=
arrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
i
]
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
}
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
AutoRangeArray
&
aSelectionRanges
nsAtom
&
blockType
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
!
aSelectionRanges
.
IsCollapsed
(
)
&
&
aSelectionRanges
.
Ranges
(
)
.
Length
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
aSelectionRanges
.
FirstRangeRef
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
extendedRange
.
propagateErr
(
)
;
}
if
(
NS_FAILED
(
aSelectionRanges
.
SetBaseAndExtent
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
SetBaseAndExtent
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
MOZ_ALWAYS_TRUE
(
aSelectionRanges
.
SaveAndTrackRanges
(
*
this
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
aSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrRemoveBlock
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
aSelectionRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
propagateErr
(
)
;
}
nsresult
rv
=
aSelectionRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
Err
(
rv
)
;
}
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eCreateOrRemoveBlock
)
failed
"
)
;
return
splitAtBRElementsResult
.
propagateErr
(
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
if
(
NS_WARN_IF
(
aSelectionRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
auto
pointToInsertBlock
=
aSelectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
if
(
!
pointToInsertBlock
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
because
container
of
the
point
is
not
content
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
RefPtr
<
Element
>
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsertBlock
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
editableBlockElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
editableBlockElement
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
if
(
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditUtils
:
:
GetNextContent
(
pointToInsertBlock
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
)
{
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
const
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
editableBlockElement
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
Err
(
splitNodeResult
.
unwrapErr
(
)
)
;
}
splitNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
const
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
splitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
aSelectionRanges
.
ClearSavedRanges
(
)
;
nsresult
rv
=
aSelectionRanges
.
Collapse
(
EditorRawDOMPoint
(
insertBRElementResult
.
GetNewNode
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
RefPtr
<
Element
>
(
)
;
}
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
HTMLEditUtils
:
:
GetNextContent
(
pointToInsertBlock
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
&
aEditingHost
)
)
{
if
(
maybeBRContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
arrayOfContents
.
RemoveElement
(
maybeBRContent
)
;
}
}
CreateElementResult
createNewBlockElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
blockType
pointToInsertBlock
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
&
blockType
)
.
get
(
)
)
.
get
(
)
)
;
return
Err
(
createNewBlockElementResult
.
unwrapErr
(
)
)
;
}
createNewBlockElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewBlockElementResult
.
GetNewNode
(
)
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
aSelectionRanges
.
ClearSavedRanges
(
)
;
nsresult
rv
=
aSelectionRanges
.
Collapse
(
EditorRawDOMPoint
(
createNewBlockElementResult
.
GetNewNode
(
)
0u
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
createNewBlockElementResult
.
UnwrapNewNode
(
)
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
CreateElementResult
wrapContentsInBlockquoteElementsResult
=
WrapContentsInBlockquoteElementsWithTransaction
(
arrayOfContents
aEditingHost
)
;
if
(
wrapContentsInBlockquoteElementsResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
WrapContentsInBlockquoteElementsWithTransaction
(
)
"
"
failed
"
)
;
return
Err
(
wrapContentsInBlockquoteElementsResult
.
unwrapErr
(
)
)
;
}
wrapContentsInBlockquoteElementsResult
.
IgnoreCaretPointSuggestion
(
)
;
return
wrapContentsInBlockquoteElementsResult
.
UnwrapNewNode
(
)
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
Result
<
EditorDOMPoint
nsresult
>
removeBlockContainerElementsResult
=
RemoveBlockContainerElementsWithTransaction
(
arrayOfContents
)
;
if
(
MOZ_UNLIKELY
(
removeBlockContainerElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementsWithTransaction
(
)
failed
"
)
;
removeBlockContainerElementsResult
.
unwrapErr
(
)
;
}
return
RefPtr
<
Element
>
(
)
;
}
CreateElementResult
wrapContentsInBlockElementResult
=
CreateOrChangeBlockContainerElement
(
arrayOfContents
blockType
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
wrapContentsInBlockElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
Err
(
wrapContentsInBlockElementResult
.
unwrapErr
(
)
)
;
}
wrapContentsInBlockElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
wrapContentsInBlockElementResult
.
UnwrapNewNode
(
)
;
}
nsresult
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
Container
(
)
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Element
>
startContainerElement
=
*
atStartOfSelection
.
Container
(
)
-
>
AsElement
(
)
;
nsresult
rv
=
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
startContainerElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
IndentAsSubAction
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eIndent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleIndentAtSelection
(
aEditingHost
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleIndentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
IndentListChildWithTransaction
(
RefPtr
<
Element
>
*
aSubListElement
const
EditorDOMPoint
&
aPointInListElement
nsIContent
&
aContentMovingToSubList
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
aPointInListElement
.
GetContainer
(
)
)
"
unexpected
container
"
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aContentMovingToSubList
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
nextEditableSibling
)
&
&
aPointInListElement
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aPointInListElement
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
MoveNodeResult
moveListElementResult
=
MoveNodeWithTransaction
(
aContentMovingToSubList
EditorDOMPoint
(
nextEditableSibling
0u
)
)
;
if
(
moveListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
moveListElementResult
.
unwrapErr
(
)
)
;
}
return
moveListElementResult
.
UnwrapCaretPoint
(
)
;
}
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContentMovingToSubList
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
previousEditableSibling
)
&
&
aPointInListElement
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aPointInListElement
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
MoveNodeResult
moveListElementResult
=
MoveNodeToEndWithTransaction
(
aContentMovingToSubList
*
previousEditableSibling
)
;
if
(
moveListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
Err
(
moveListElementResult
.
unwrapErr
(
)
)
;
}
return
moveListElementResult
.
UnwrapCaretPoint
(
)
;
}
}
EditorDOMPoint
pointToPutCaret
;
nsIContent
*
previousEditableSibling
=
*
aSubListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
aContentMovingToSubList
{
WalkTreeOption
:
:
IgnoreWhiteSpaceOnlyText
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
*
aSubListElement
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
*
aSubListElement
)
)
{
nsAtom
*
containerName
=
aPointInListElement
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
CreateElementResult
createNewListElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
aPointInListElement
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
%
s
)
failed
"
nsAtomCString
(
containerName
)
.
get
(
)
)
.
get
(
)
)
;
return
Err
(
createNewListElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
createNewListElementResult
.
GetNewNode
(
)
)
;
pointToPutCaret
=
createNewListElementResult
.
UnwrapCaretPoint
(
)
;
*
aSubListElement
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
}
const
RefPtr
<
Element
>
subListElement
=
*
aSubListElement
;
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
aContentMovingToSubList
*
subListElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
Err
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
if
(
moveNodeResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveNodeResult
.
UnwrapCaretPoint
(
)
;
}
return
pointToPutCaret
;
}
EditActionResult
HTMLEditor
:
:
HandleIndentAtSelection
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
if
(
!
selectionRanges
.
IsInContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
HandleCSSIndentAroundRanges
(
selectionRanges
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleCSSIndentAroundRanges
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
else
{
nsresult
rv
=
HandleHTMLIndentAroundRanges
(
selectionRanges
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleHTMLIndentAroundRanges
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ApplyTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAroundRanges
(
AutoRangeArray
&
aRanges
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aRanges
.
IsInContent
(
)
)
;
if
(
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
There
is
no
selection
range
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
aRanges
.
IsCollapsed
(
)
&
&
aRanges
.
Ranges
(
)
.
Length
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
aRanges
.
FirstRangeRef
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
extendedRange
.
unwrapErr
(
)
;
}
nsresult
rv
=
aRanges
.
SetBaseAndExtent
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
SetBaseAndExtent
(
)
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
aRanges
.
SaveAndTrackRanges
(
*
this
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
aRanges
.
IsCollapsed
(
)
)
{
const
auto
atCaret
=
aRanges
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCaret
.
IsInContentNode
(
)
)
;
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atCaret
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
editableBlockElement
&
&
HTMLEditUtils
:
:
IsListItem
(
editableBlockElement
)
)
{
arrayOfContents
.
AppendElement
(
*
editableBlockElement
)
;
}
}
EditorDOMPoint
pointToPutCaret
;
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
{
AutoRangeArray
extendedRanges
(
aRanges
)
;
extendedRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eIndent
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
unwrapErr
(
)
;
}
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
nsresult
rv
=
extendedRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eIndent
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
eIndent
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eIndent
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eIndent
)
failed
"
)
;
return
splitAtBRElementsResult
.
inspectErr
(
)
;
}
if
(
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitAtBRElementsResult
.
unwrap
(
)
;
}
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
EditorDOMPoint
pointToInsertDivElement
=
pointToPutCaret
.
IsSet
(
)
?
std
:
:
move
(
pointToPutCaret
)
:
aRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
pointToInsertDivElement
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
createNewDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
const
RefPtr
<
Element
>
newDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newDivElement
)
;
const
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
*
newDivElement
ChangeMargin
:
:
Increase
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Increase
)
failed
but
"
"
ignored
"
)
;
}
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
aRanges
.
ClearSavedRanges
(
)
;
nsresult
rv
=
aRanges
.
Collapse
(
EditorDOMPoint
(
newDivElement
0u
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
latestNewBlockElement
;
auto
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
=
[
&
]
(
)
-
>
nsresult
{
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
aRanges
.
RestoreFromSavedRanges
(
)
;
if
(
!
latestNewBlockElement
|
|
!
aRanges
.
IsCollapsed
(
)
|
|
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
const
auto
firstRangeStartRawPoint
=
aRanges
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
firstRangeStartRawPoint
.
IsSet
(
)
)
)
{
return
NS_OK
;
}
Result
<
EditorRawDOMPoint
nsresult
>
pointInNewBlockElementOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
*
latestNewBlockElement
firstRangeStartRawPoint
)
;
if
(
MOZ_UNLIKELY
(
pointInNewBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
failed
"
"
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
pointInNewBlockElementOrError
.
inspect
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
return
aRanges
.
Collapse
(
pointInNewBlockElementOrError
.
unwrap
(
)
)
;
}
;
RefPtr
<
Element
>
subListElement
divElement
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
const
RefPtr
<
Element
>
oldSubListElement
=
subListElement
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
IndentListChildWithTransaction
(
&
subListElement
atContent
MOZ_KnownLive
(
content
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChildWithTransaction
(
)
failed
"
)
;
return
pointToPutCaretOrError
.
unwrapErr
(
)
;
}
if
(
subListElement
!
=
oldSubListElement
)
{
latestNewBlockElement
=
subListElement
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Increase
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Increase
)
failed
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Increase
)
failed
but
"
"
ignored
"
)
;
}
else
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
divElement
=
nullptr
;
continue
;
}
if
(
!
divElement
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RestoreSavedRangesAndCollapseInLatestBlockElement
"
"
IfOutside
(
)
failed
"
)
;
return
rv
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
pointToPutCaret
=
createNewDivElementResult
.
UnwrapCaretPoint
(
)
;
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
divElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
*
divElement
ChangeMargin
:
:
Increase
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Increase
)
failed
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Increase
)
failed
but
"
"
ignored
"
)
;
}
else
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
latestNewBlockElement
=
divElement
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
divElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
unwrapErr
(
)
;
}
if
(
moveNodeResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveNodeResult
.
UnwrapCaretPoint
(
)
;
}
}
nsresult
rv
=
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAroundRanges
(
AutoRangeArray
&
aRanges
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aRanges
.
IsInContent
(
)
)
;
if
(
!
aRanges
.
IsCollapsed
(
)
&
&
aRanges
.
Ranges
(
)
.
Length
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
aRanges
.
FirstRangeRef
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
extendedRange
.
unwrapErr
(
)
;
}
nsresult
rv
=
aRanges
.
SetBaseAndExtent
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
SetBaseAndExtent
(
)
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
aRanges
.
SaveAndTrackRanges
(
*
this
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedRanges
(
aRanges
)
;
extendedRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eIndent
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
unwrapErr
(
)
;
}
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
nsresult
rv
=
extendedRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eIndent
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
eIndent
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eIndent
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
eIndent
)
"
"
failed
"
)
;
return
splitAtBRElementsResult
.
inspectErr
(
)
;
}
if
(
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitAtBRElementsResult
.
unwrap
(
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
EditorDOMPoint
pointToInsertBlockquoteElement
=
pointToPutCaret
.
IsSet
(
)
?
std
:
:
move
(
pointToPutCaret
)
:
EditorBase
:
:
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsertBlockquoteElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
CreateElementResult
createNewBlockquoteElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
pointToInsertBlockquoteElement
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockquoteElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
createNewBlockquoteElementResult
.
unwrapErr
(
)
;
}
createNewBlockquoteElementResult
.
IgnoreCaretPointSuggestion
(
)
;
RefPtr
<
Element
>
newBlockquoteElement
=
createNewBlockquoteElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newBlockquoteElement
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
aRanges
.
ClearSavedRanges
(
)
;
nsresult
rv
=
aRanges
.
Collapse
(
EditorRawDOMPoint
(
newBlockquoteElement
0u
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
latestNewBlockElement
;
auto
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
=
[
&
]
(
)
-
>
nsresult
{
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
aRanges
.
RestoreFromSavedRanges
(
)
;
if
(
!
latestNewBlockElement
|
|
!
aRanges
.
IsCollapsed
(
)
|
|
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
const
auto
firstRangeStartRawPoint
=
aRanges
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
firstRangeStartRawPoint
.
IsSet
(
)
)
)
{
return
NS_OK
;
}
Result
<
EditorRawDOMPoint
nsresult
>
pointInNewBlockElementOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
*
latestNewBlockElement
firstRangeStartRawPoint
)
;
if
(
MOZ_UNLIKELY
(
pointInNewBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
failed
"
"
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
pointInNewBlockElementOrError
.
inspect
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
return
aRanges
.
Collapse
(
pointInNewBlockElementOrError
.
unwrap
(
)
)
;
}
;
RefPtr
<
Element
>
subListElement
blockquoteElement
indentedListItemElement
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
const
RefPtr
<
Element
>
oldSubListElement
=
subListElement
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
IndentListChildWithTransaction
(
&
subListElement
atContent
MOZ_KnownLive
(
content
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChildWithTransaction
(
)
failed
"
)
;
return
pointToPutCaretOrError
.
unwrapErr
(
)
;
}
if
(
oldSubListElement
!
=
subListElement
)
{
latestNewBlockElement
=
subListElement
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
blockquoteElement
=
nullptr
;
continue
;
}
if
(
RefPtr
<
Element
>
listItem
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
content
&
aEditingHost
)
)
{
if
(
indentedListItemElement
=
=
listItem
)
{
continue
;
}
nsIContent
*
previousEditableSibling
=
subListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
*
listItem
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
subListElement
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
subListElement
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
CreateElementResult
createNewListElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTr
"
"
ansaction
(
%
s
)
failed
"
nsAtomCString
(
containerName
)
.
get
(
)
)
.
get
(
)
)
;
return
createNewListElementResult
.
unwrapErr
(
)
;
}
if
(
createNewListElementResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
createNewListElementResult
.
UnwrapCaretPoint
(
)
;
}
MOZ_ASSERT
(
createNewListElementResult
.
GetNewNode
(
)
)
;
subListElement
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
}
MoveNodeResult
moveListItemElementResult
=
MoveNodeToEndWithTransaction
(
*
listItem
*
subListElement
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveListItemElementResult
.
unwrapErr
(
)
;
}
if
(
moveListItemElementResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveListItemElementResult
.
UnwrapCaretPoint
(
)
;
}
indentedListItemElement
=
std
:
:
move
(
listItem
)
;
continue
;
}
if
(
blockquoteElement
&
&
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
blockquoteElement
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
content
)
)
{
blockquoteElement
=
nullptr
;
}
if
(
!
blockquoteElement
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
nsresult
rv
=
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RestoreSavedRangesAndCollapseInLatestBlockElement
"
"
IfOutside
(
)
failed
"
)
;
return
rv
;
}
CreateElementResult
createNewBlockquoteElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockquoteElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
createNewBlockquoteElementResult
.
unwrapErr
(
)
;
}
if
(
createNewBlockquoteElementResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
createNewBlockquoteElementResult
.
UnwrapCaretPoint
(
)
;
}
MOZ_ASSERT
(
createNewBlockquoteElementResult
.
GetNewNode
(
)
)
;
blockquoteElement
=
createNewBlockquoteElementResult
.
UnwrapNewNode
(
)
;
latestNewBlockElement
=
blockquoteElement
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
blockquoteElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
unwrapErr
(
)
;
}
if
(
moveNodeResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveNodeResult
.
UnwrapCaretPoint
(
)
;
}
subListElement
=
nullptr
;
}
nsresult
rv
=
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RestoreSavedRangesAndCollapseInLatestBlockElementIfOutside
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
OutdentAsSubAction
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eOutdent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleOutdentAtSelection
(
aEditingHost
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleOutdentAtSelection
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
SelectionRef
(
)
.
GetRangeAt
(
0u
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
extendedRange
.
unwrapErr
(
)
)
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
SetBaseAndExtentInLimiter
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
}
SplitRangeOffFromNodeResult
outdentResult
=
HandleOutdentAtSelectionInternal
(
aEditingHost
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
outdentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
failed
"
)
;
return
EditActionHandled
(
outdentResult
.
unwrapErr
(
)
)
;
}
if
(
!
outdentResult
.
GetLeftContent
(
)
&
&
!
outdentResult
.
GetRightContent
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
outdentResult
.
GetLeftContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetLeftContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetLeftContent
(
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
EditorRawDOMPoint
:
:
After
(
*
outdentResult
.
GetLeftContent
(
)
)
)
;
NS_WARNING_ASSERTION
(
afterRememberedLeftBQ
.
IsSet
(
)
"
Failed
to
set
after
remembered
left
blockquote
element
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
afterRememberedLeftBQ
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
if
(
outdentResult
.
GetRightContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetRightContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetRightContent
(
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
outdentResult
.
GetRightContent
(
)
)
;
nsresult
rv
=
CollapseSelectionTo
(
atRememberedRightBQ
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
return
EditActionHandled
(
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedSelectionRanges
(
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eOutdent
aEditingHost
)
;
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eOutdent
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
eOutdent
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
const
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eOutdent
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eOutdent
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
splitAtBRElementsResult
.
inspectErr
(
)
)
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
splitAtBRElementsResult
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
leftContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
middleContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
rightContentOfLastOutdented
;
RefPtr
<
Element
>
indentedParentElement
;
nsCOMPtr
<
nsIContent
>
firstContentToBeOutdented
lastContentToBeOutdented
;
BlockIndentedWith
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
indentedParentElement
)
{
NS_WARNING_ASSERTION
(
indentedParentElement
=
=
content
"
Indented
parent
element
is
not
the
<
blockquote
>
"
)
;
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
aEditingHost
)
;
if
(
outdentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
const
Result
<
EditorDOMPoint
nsresult
>
unwrapBlockquoteElementResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapBlockquoteElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
unwrapBlockquoteElementResult
.
inspectErr
(
)
)
;
}
const
EditorDOMPoint
&
pointToPutCaret
=
unwrapBlockquoteElementResult
.
inspect
(
)
;
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
if
(
useCSS
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
content
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
=
0
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
)
{
const
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Decrease
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Decrease
)
failed
"
"
but
ignored
"
)
;
}
else
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
indentedParentElement
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
aEditingHost
)
;
if
(
outdentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
indentedParentElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
indentedParentElement
)
)
{
lastContentToBeOutdented
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
aEditingHost
)
;
if
(
outdentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
}
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
for
(
nsCOMPtr
<
nsIContent
>
parentContent
=
content
-
>
GetParent
(
)
;
parentContent
&
&
!
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
parentContent
!
=
&
aEditingHost
&
&
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentContent
)
)
;
parentContent
=
parentContent
-
>
GetParent
(
)
)
{
if
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
break
;
}
if
(
!
useCSS
)
{
continue
;
}
nsCOMPtr
<
nsINode
>
grandParentNode
=
parentContent
-
>
GetParentNode
(
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
grandParentNode
!
=
parentContent
-
>
GetParentNode
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
parentContent
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
&
&
!
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
CSS
;
break
;
}
}
if
(
indentedParentElement
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
if
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
continue
;
}
const
Result
<
EditorDOMPoint
nsresult
>
unwrapSubListElementResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapSubListElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
unwrapSubListElementResult
.
inspectErr
(
)
)
;
}
const
EditorDOMPoint
&
pointToPutCaret
=
unwrapSubListElementResult
.
inspect
(
)
;
if
(
!
AllowsTransactionsToChangeSelection
(
)
|
|
!
pointToPutCaret
.
IsSet
(
)
)
{
continue
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
lastChildContent
=
content
-
>
GetLastChild
(
)
;
lastChildContent
;
lastChildContent
=
content
-
>
GetLastChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
lastChildContent
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
lastChildContent
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
lastChildContent
)
)
{
EditorDOMPoint
afterCurrentList
(
EditorDOMPoint
:
:
After
(
atContent
)
)
;
NS_WARNING_ASSERTION
(
afterCurrentList
.
IsSet
(
)
"
Failed
to
set
it
to
after
current
list
element
"
)
;
const
MoveNodeResult
moveListElementResult
=
MoveNodeWithTransaction
(
*
lastChildContent
afterCurrentList
)
;
if
(
moveListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
moveListElementResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
moveListElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
lastChildContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
const
Result
<
EditorDOMPoint
nsresult
>
unwrapListElementResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapListElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
unwrapListElementResult
.
inspectErr
(
)
)
;
}
const
EditorDOMPoint
&
pointToPutCaret
=
unwrapListElementResult
.
inspect
(
)
;
if
(
!
AllowsTransactionsToChangeSelection
(
)
|
|
!
pointToPutCaret
.
IsSet
(
)
)
{
continue
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
)
{
if
(
RefPtr
<
Element
>
element
=
content
-
>
GetAsElementOrParentElement
(
)
)
{
const
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
*
element
ChangeMargin
:
:
Decrease
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Decrease
)
failed
"
"
but
ignored
"
)
;
}
else
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
}
continue
;
}
}
if
(
!
indentedParentElement
)
{
return
SplitRangeOffFromNodeResult
(
leftContentOfLastOutdented
middleContentOfLastOutdented
rightContentOfLastOutdented
)
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
aEditingHost
)
;
NS_WARNING_ASSERTION
(
outdentResult
.
isOk
(
)
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
Element
&
aBlockContainerElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockContainerElement
aStartOfRange
aEndOfRange
)
;
if
(
splitResult
.
EditorDestroyed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
"
)
;
return
splitResult
;
}
if
(
splitResult
.
isOk
(
)
)
{
splitResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
else
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
}
Result
<
EditorDOMPoint
nsresult
>
unwrapBlockElementResult
=
RemoveBlockContainerWithTransaction
(
aBlockContainerElement
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
unwrapBlockElementResult
.
inspectErr
(
)
)
;
}
if
(
unwrapBlockElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapBlockElementResult
.
unwrap
(
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartOfMiddleElement
aBlockElement
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aEndOfMiddleElement
aBlockElement
)
)
;
EditorDOMPoint
pointToPutCaret
;
SplitNodeResult
splitAtStartResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
EditorDOMPoint
(
&
aStartOfMiddleElement
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitAtStartResult
.
EditorDestroyed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
(
at
left
)
"
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtStartResult
.
isOk
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
at
start
of
middle
element
failed
"
)
;
splitAtStartResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
auto
atAfterEnd
=
EditorDOMPoint
:
:
After
(
aEndOfMiddleElement
)
;
SplitNodeResult
splitAtEndResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitAtEndResult
.
EditorDestroyed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
(
at
right
)
"
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtEndResult
.
isOk
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
after
end
of
middle
element
failed
"
)
;
splitAtEndResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
splitAtStartResult
.
DidSplit
(
)
&
&
splitAtEndResult
.
DidSplit
(
)
)
{
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
.
GetPreviousContent
(
)
splitAtEndResult
.
GetPreviousContent
(
)
splitAtEndResult
.
GetNextContent
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
splitAtStartResult
.
DidSplit
(
)
)
{
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
.
GetPreviousContent
(
)
splitAtStartResult
.
GetNextContent
(
)
nullptr
std
:
:
move
(
pointToPutCaret
)
)
;
}
if
(
splitAtEndResult
.
DidSplit
(
)
)
{
return
SplitRangeOffFromNodeResult
(
nullptr
splitAtEndResult
.
GetPreviousContent
(
)
splitAtEndResult
.
GetNextContent
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
return
SplitRangeOffFromNodeResult
(
nullptr
&
aBlockElement
nullptr
std
:
:
move
(
pointToPutCaret
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOfOutdent
BlockIndentedWith
aBlockIndentedWith
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfOutdent
aEndOfOutdent
)
;
if
(
splitResult
.
EditorDestroyed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
splitResult
.
GetMiddleContentAs
<
Element
>
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
didn
'
t
return
middle
content
"
)
;
splitResult
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
splitResult
.
isOk
(
)
)
{
nsresult
rv
=
splitResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitRangeOffFromNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SplitRangeOffFromNodeResult
:
:
SuggestCaretPointTo
(
)
"
"
failed
but
ignored
"
)
;
}
else
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
}
if
(
aBlockIndentedWith
=
=
BlockIndentedWith
:
:
HTML
)
{
Result
<
EditorDOMPoint
nsresult
>
unwrapBlockElementResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAs
<
Element
>
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapBlockElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
unwrapBlockElementResult
.
inspectErr
(
)
)
;
}
const
EditorDOMPoint
&
pointToPutCaret
=
unwrapBlockElementResult
.
inspect
(
)
;
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
if
(
!
splitResult
.
GetMiddleContentAs
<
Element
>
(
)
)
{
return
splitResult
;
}
const
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAs
<
Element
>
(
)
)
ChangeMargin
:
:
Decrease
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Decrease
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
pointToPutCaretOrError
.
inspectErr
(
)
)
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
return
splitResult
;
}
CreateElementResult
HTMLEditor
:
:
ChangeListElementType
(
Element
&
aListElement
nsAtom
&
aNewListTag
nsAtom
&
aNewListItemTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
listElementChildren
;
HTMLEditor
:
:
GetChildNodesOf
(
aListElement
listElementChildren
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
childContent
:
listElementChildren
)
{
if
(
!
childContent
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
childElement
=
childContent
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
childElement
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListItemTag
)
)
{
CreateElementResult
newListItemElementOrError
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
childElement
)
aNewListItemTag
)
;
if
(
newListItemElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
newListItemElementOrError
;
}
newListItemElementOrError
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
childElement
)
&
&
!
childElement
-
>
IsHTMLElement
(
&
aNewListTag
)
)
{
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
childElement
)
aNewListTag
aNewListItemTag
)
;
if
(
convertListTypeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
convertListTypeResult
;
}
convertListTypeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
continue
;
}
}
if
(
aListElement
.
IsHTMLElement
(
&
aNewListTag
)
)
{
return
CreateElementResult
(
&
aListElement
std
:
:
move
(
pointToPutCaret
)
)
;
}
CreateElementResult
listElementOrError
=
ReplaceContainerWithTransaction
(
aListElement
aNewListTag
)
;
if
(
listElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
listElementOrError
;
}
listElementOrError
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CreateElementResult
(
listElementOrError
.
UnwrapNewNode
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
CreateStyleForInsertText
(
const
EditorDOMPoint
&
aPointToInsertText
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsertText
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mTypeInState
)
;
const
RefPtr
<
Element
>
documentRootElement
=
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
documentRootElement
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
UniquePtr
<
PropItem
>
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
EditorDOMPoint
pointToPutCaret
(
aPointToInsertText
)
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
while
(
item
&
&
pointToPutCaret
.
GetContainer
(
)
!
=
documentRootElement
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
ClearStyleAt
(
pointToPutCaret
MOZ_KnownLive
(
item
-
>
mTag
)
MOZ_KnownLive
(
item
-
>
mAttribute
)
item
-
>
specifiedStyle
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearStyleAt
(
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
}
}
const
int32_t
relFontSize
=
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
if
(
item
|
|
relFontSize
)
{
EditorDOMPoint
pointToInsertTextNode
(
pointToPutCaret
)
;
if
(
pointToInsertTextNode
.
IsInTextNode
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsertTextNode
.
ContainerAs
<
Text
>
(
)
)
pointToInsertTextNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitTextNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
Err
(
splitTextNodeResult
.
unwrapErr
(
)
)
;
}
splitTextNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
pointToInsertTextNode
=
splitTextNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
}
if
(
!
pointToInsertTextNode
.
IsInContentNode
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
pointToInsertTextNode
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
pointToPutCaret
;
}
RefPtr
<
Text
>
newEmptyTextNode
=
CreateTextNode
(
u
"
"
_ns
)
;
if
(
!
newEmptyTextNode
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateTextNode
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
CreateTextResult
insertNewTextNodeResult
=
InsertNodeWithTransaction
<
Text
>
(
*
newEmptyTextNode
pointToInsertTextNode
)
;
if
(
insertNewTextNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
insertNewTextNodeResult
.
unwrapErr
(
)
)
;
}
insertNewTextNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
pointToPutCaret
.
Set
(
newEmptyTextNode
0u
)
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
incrementOrDecrement
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
[
[
maybe_unused
]
]
uint32_t
j
:
IntegerRange
(
Abs
(
relFontSize
)
)
)
{
const
CreateElementResult
wrapTextInBigOrSmallElementResult
=
SetFontSizeOnTextNode
(
*
newEmptyTextNode
0
UINT32_MAX
incrementOrDecrement
)
;
if
(
wrapTextInBigOrSmallElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFontSizeOnTextNode
(
)
failed
"
)
;
return
Err
(
wrapTextInBigOrSmallElementResult
.
inspectErr
(
)
)
;
}
MOZ_ASSERT
(
pointToPutCaret
.
IsSet
(
)
)
;
wrapTextInBigOrSmallElementResult
.
IgnoreCaretPointSuggestion
(
)
;
}
}
while
(
item
)
{
Result
<
EditorDOMPoint
nsresult
>
setStyleResult
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
pointToPutCaret
.
ContainerAs
<
nsIContent
>
(
)
)
MOZ_KnownLive
(
*
item
-
>
mTag
)
MOZ_KnownLive
(
item
-
>
mAttribute
)
item
-
>
value
)
;
if
(
MOZ_UNLIKELY
(
setStyleResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
Err
(
setStyleResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
pointToPutCaret
.
IsSet
(
)
)
;
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
return
pointToPutCaret
;
}
EditActionResult
HTMLEditor
:
:
AlignAsSubAction
(
const
nsAString
&
aAlignType
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetOrClearAlignment
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
if
(
!
selectionRanges
.
IsCollapsed
(
)
&
&
selectionRanges
.
Ranges
(
)
.
Length
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
selectionRanges
.
FirstRangeRef
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
extendedRange
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
selectionRanges
.
SetBaseAndExtent
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
rv
=
AlignContentsAtRanges
(
selectionRanges
aAlignType
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ApplyTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignContentsAtRanges
(
AutoRangeArray
&
aRanges
const
nsAString
&
aAlignType
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRanges
.
IsInContent
(
)
)
;
if
(
NS_WARN_IF
(
!
aRanges
.
SaveAndTrackRanges
(
*
this
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedRanges
(
aRanges
)
;
extendedRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eSetOrClearAlignment
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
unwrapErr
(
)
;
}
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
nsresult
rv
=
extendedRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eSetOrClearAlignment
)
failed
"
)
;
return
splitAtBRElementsResult
.
inspectErr
(
)
;
}
if
(
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitAtBRElementsResult
.
unwrap
(
)
;
}
bool
createEmptyDivElement
=
arrayOfContents
.
IsEmpty
(
)
;
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
)
failed
"
)
;
return
pointToPutCaretOrError
.
unwrapErr
(
)
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
const
EditorDOMPoint
firstRangeStartPoint
=
pointToPutCaret
.
IsSet
(
)
?
pointToPutCaret
:
aRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
firstRangeStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
firstRangeStartPoint
.
GetContainer
(
)
;
createEmptyDivElement
=
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
createEmptyDivElement
)
{
if
(
MOZ_UNLIKELY
(
!
pointToPutCaret
.
IsSet
(
)
&
&
!
aRanges
.
IsInContent
(
)
)
)
{
NS_WARNING
(
"
Mutaiton
event
listener
might
have
changed
the
selection
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
const
EditorDOMPoint
pointToInsertDivElement
=
pointToPutCaret
.
IsSet
(
)
?
pointToPutCaret
:
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
CreateElementResult
newDivElementOrError
=
InsertDivElementToAlignContents
(
pointToInsertDivElement
aAlignType
aEditingHost
)
;
if
(
newDivElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertDivElementToAlignContents
(
)
failed
"
)
;
return
newDivElementOrError
.
unwrapErr
(
)
;
}
aRanges
.
ClearSavedRanges
(
)
;
EditorDOMPoint
pointToPutCaret
=
newDivElementOrError
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
aRanges
.
Collapse
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
CreateElementResult
maybeCreateDivElementResult
=
AlignNodesAndDescendants
(
arrayOfContents
aAlignType
aEditingHost
)
;
if
(
maybeCreateDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignNodesAndDescendants
(
)
failed
"
)
;
return
maybeCreateDivElementResult
.
unwrapErr
(
)
;
}
maybeCreateDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
aRanges
.
HasSavedRanges
(
)
)
;
aRanges
.
RestoreFromSavedRanges
(
)
;
if
(
maybeCreateDivElementResult
.
GetNewNode
(
)
&
&
aRanges
.
IsCollapsed
(
)
&
&
!
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
const
auto
firstRangeStartRawPoint
=
aRanges
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_LIKELY
(
firstRangeStartRawPoint
.
IsSet
(
)
)
)
{
Result
<
EditorRawDOMPoint
nsresult
>
pointInNewDivOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
*
maybeCreateDivElementResult
.
GetNewNode
(
)
firstRangeStartRawPoint
)
;
if
(
MOZ_UNLIKELY
(
pointInNewDivOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
failed
"
"
but
ignored
"
)
;
}
else
if
(
pointInNewDivOrError
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
aRanges
.
Collapse
(
pointInNewDivOrError
.
unwrap
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_OK
;
}
CreateElementResult
HTMLEditor
:
:
InsertDivElementToAlignContents
(
const
EditorDOMPoint
&
aPointToInsert
const
nsAString
&
aAlignType
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
aPointToInsert
BRElementNextToSplitPoint
:
:
Delete
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
BRElementNextToSplitPoint
:
:
Delete
)
failed
"
)
;
return
createNewDivElementResult
;
}
createNewDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
RefPtr
<
Element
>
newDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
SetBlockElementAlign
(
*
newDivElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
CreateElementResult
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
newDivElement
0u
)
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
insertPaddingBRElementResult
;
}
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
CreateElementResult
(
newDivElement
EditorDOMPoint
(
newDivElement
0u
)
)
;
}
CreateElementResult
HTMLEditor
:
:
AlignNodesAndDescendants
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
const
nsAString
&
aAlignType
const
Element
&
aEditingHost
)
{
AutoTArray
<
bool
64
>
transitionList
;
HTMLEditor
:
:
MakeTransitionList
(
aArrayOfContents
transitionList
)
;
RefPtr
<
Element
>
latestCreatedDivElement
;
EditorDOMPoint
pointToPutCaret
;
RefPtr
<
Element
>
createdDivElement
;
const
bool
useCSS
=
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
+
+
indexOfTransitionList
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
NodeAndDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
NodeAndDescendantsExceptTable
)
failed
"
)
;
return
CreateElementResult
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
createdDivElement
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsAnyTableElement
(
atContent
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atContent
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
|
|
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
Element
*
listOrListItemElement
=
content
-
>
AsElement
(
)
;
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atContent
)
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
RemoveAlignFromDescendants
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
CreateElementResult
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
if
(
useCSS
)
{
if
(
nsStyledElement
*
styledListOrListItemElement
=
nsStyledElement
:
:
FromNode
(
listOrListItemElement
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledListOrListItemElement
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
destroyed
the
editor
"
)
;
return
CreateElementResult
(
result
.
unwrapErr
(
)
)
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
failed
but
ignored
"
)
;
}
}
createdDivElement
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
AlignContentsInAllTableCellsAndListItems
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
)
failed
"
)
;
return
CreateElementResult
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
createdDivElement
=
nullptr
;
continue
;
}
}
if
(
!
createdDivElement
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
latestCreatedDivElement
?
CreateElementResult
(
std
:
:
move
(
latestCreatedDivElement
)
std
:
:
move
(
pointToPutCaret
)
)
:
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
;
}
if
(
createNewDivElementResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
createNewDivElementResult
.
UnwrapCaretPoint
(
)
;
}
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
createdDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
SetBlockElementAlign
(
*
createdDivElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
CreateElementResult
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
but
ignored
"
)
;
}
else
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
latestCreatedDivElement
=
createdDivElement
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdDivElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
if
(
moveNodeResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveNodeResult
.
UnwrapCaretPoint
(
)
;
}
}
return
latestCreatedDivElement
?
CreateElementResult
(
std
:
:
move
(
latestCreatedDivElement
)
std
:
:
move
(
pointToPutCaret
)
)
:
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
Element
&
aElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfTableCellsAndListItems
;
DOMIterator
iter
(
aElement
)
;
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
-
>
bool
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
return
HTMLEditUtils
:
:
IsTableCell
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
&
aNode
)
;
}
arrayOfTableCellsAndListItems
)
;
EditorDOMPoint
pointToPutCaret
;
for
(
auto
&
tableCellOrListItemElement
:
arrayOfTableCellsAndListItems
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
AlignBlockContentsWithDivElement
(
MOZ_KnownLive
(
tableCellOrListItemElement
)
aAlignType
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
Element
&
aBlockElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstEditableContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
return
EditorDOMPoint
(
)
;
}
nsCOMPtr
<
nsIContent
>
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
firstEditableContent
=
=
lastEditableContent
&
&
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
MOZ_KnownLive
(
firstEditableContent
-
>
AsElement
(
)
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
caused
"
"
destroying
the
editor
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditorDOMPoint
(
)
;
}
CreateElementResult
createNewDivElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
&
aBlockElement
0u
)
[
&
aAlignType
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
nsresult
rv
=
aHTMLEditor
.
SetAttributeOrEquivalent
(
&
aDivElement
nsGkAtoms
:
:
align
aAlignType
!
aDivElement
.
IsInComposedDoc
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
nsPrintfCString
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
"
"
align
\
"
.
.
.
\
"
%
s
)
failed
"
!
aDivElement
.
IsInComposedDoc
(
)
?
"
true
"
:
"
false
"
)
.
get
(
)
)
;
return
rv
;
}
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
Err
(
createNewDivElementResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
=
createNewDivElementResult
.
UnwrapCaretPoint
(
)
;
RefPtr
<
Element
>
newDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newDivElement
)
;
while
(
lastEditableContent
&
&
(
lastEditableContent
!
=
newDivElement
)
)
{
MoveNodeResult
moveNodeResult
=
MoveNodeWithTransaction
(
*
lastEditableContent
EditorDOMPoint
(
newDivElement
0u
)
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
if
(
moveNodeResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
moveNodeResult
.
UnwrapCaretPoint
(
)
;
}
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
}
return
pointToPutCaret
;
}
Result
<
EditorRawDOMRange
nsresult
>
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
const
nsRange
*
aRange
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aRange
)
|
|
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorRawDOMPoint
startPoint
(
aRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorRawDOMPoint
endPoint
(
aRange
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMRange
newRange
(
startPoint
endPoint
)
;
WSRunScanner
wsScannerAtEnd
(
&
aEditingHost
endPoint
)
;
WSScanResult
scanResultAtEnd
=
wsScannerAtEnd
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
endPoint
)
;
if
(
scanResultAtEnd
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
scanResultAtEnd
.
ReachedSomethingNonTextContent
(
)
)
{
if
(
wsScannerAtEnd
.
StartsFromOtherBlockElement
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
wsScannerAtEnd
.
StartReasonOtherBlockElementPtr
(
)
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
)
{
newRange
.
SetEnd
(
EditorRawDOMPoint
:
:
After
(
*
child
)
)
;
}
}
else
if
(
wsScannerAtEnd
.
StartsFromCurrentBlockBoundary
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetPreviousContent
(
endPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
)
{
newRange
.
SetEnd
(
EditorRawDOMPoint
:
:
After
(
*
child
)
)
;
}
}
else
if
(
wsScannerAtEnd
.
StartsFromBRElement
(
)
)
{
newRange
.
SetEnd
(
EditorRawDOMPoint
(
wsScannerAtEnd
.
StartReasonBRElementPtr
(
)
)
)
;
}
}
WSRunScanner
wsScannerAtStart
(
&
aEditingHost
startPoint
)
;
WSScanResult
scanResultAtStart
=
wsScannerAtStart
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
startPoint
)
;
if
(
scanResultAtStart
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
scanResultAtStart
.
ReachedSomethingNonTextContent
(
)
)
{
if
(
wsScannerAtStart
.
EndsByOtherBlockElement
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
wsScannerAtStart
.
EndReasonOtherBlockElementPtr
(
)
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
)
{
newRange
.
SetStart
(
EditorRawDOMPoint
(
child
)
)
;
}
}
else
if
(
wsScannerAtStart
.
EndsByCurrentBlockBoundary
(
)
)
{
if
(
nsIContent
*
child
=
HTMLEditUtils
:
:
GetNextContent
(
startPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
)
{
newRange
.
SetStart
(
EditorRawDOMPoint
(
child
)
)
;
}
}
else
if
(
wsScannerAtStart
.
EndsByBRElement
(
)
)
{
newRange
.
SetStart
(
EditorRawDOMPoint
:
:
After
(
*
wsScannerAtStart
.
EndReasonBRElementPtr
(
)
)
)
;
}
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
startPoint
.
ToRawRangeBoundary
(
)
newRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
*
comp
=
=
1
)
{
return
EditorRawDOMRange
(
)
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
*
comp
=
=
1
)
{
return
EditorRawDOMRange
(
)
;
}
return
newRange
;
}
template
<
typename
EditorDOMRangeType
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMRangeType
&
aRange
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
return
CreateRangeIncludingAdjuscentWhiteSpaces
(
aRange
.
StartRef
(
)
aRange
.
EndRef
(
)
)
;
}
template
<
typename
EditorDOMPointType1
typename
EditorDOMPointType2
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
EditorDOMPointType1
&
aStartPoint
const
EditorDOMPointType2
&
aEndPoint
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aStartPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aEndPoint
.
IsInNativeAnonymousSubtree
(
)
)
;
if
(
!
aStartPoint
.
IsInContentNode
(
)
|
|
!
aEndPoint
.
IsInContentNode
(
)
)
{
NS_WARNING_ASSERTION
(
aStartPoint
.
IsSet
(
)
"
aStartPoint
was
not
set
"
)
;
NS_WARNING_ASSERTION
(
aEndPoint
.
IsSet
(
)
"
aEndPoint
was
not
set
"
)
;
return
nullptr
;
}
const
Element
*
const
editingHost
=
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
nullptr
;
}
EditorDOMPoint
startPoint
=
aStartPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
EditorDOMPoint
endPoint
=
aEndPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
AutoRangeArray
:
:
UpdatePointsToSelectAllChildrenIfCollapsedInEmptyBlockElement
(
startPoint
endPoint
*
editingHost
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
endPoint
.
IsInContentNode
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
UpdatePointsToSelectAllChildrenIfCollapsedInEmptyBlockElement
(
)
"
"
failed
"
)
;
return
nullptr
;
}
if
(
startPoint
.
IsInTextNode
(
)
)
{
while
(
!
startPoint
.
IsStartOfContainer
(
)
)
{
if
(
!
startPoint
.
IsPreviousCharASCIISpaceOrNBSP
(
)
)
{
break
;
}
MOZ_ALWAYS_TRUE
(
startPoint
.
RewindOffset
(
)
)
;
}
}
if
(
!
startPoint
.
GetChildOrContainerIfDataNode
(
)
|
|
!
startPoint
.
GetChildOrContainerIfDataNode
(
)
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
nullptr
;
}
if
(
endPoint
.
IsInTextNode
(
)
)
{
while
(
!
endPoint
.
IsEndOfContainer
(
)
)
{
if
(
!
endPoint
.
IsCharASCIISpaceOrNBSP
(
)
)
{
break
;
}
MOZ_ALWAYS_TRUE
(
endPoint
.
AdvanceOffset
(
)
)
;
}
}
EditorDOMPoint
lastRawPoint
(
endPoint
)
;
if
(
!
lastRawPoint
.
IsStartOfContainer
(
)
)
{
lastRawPoint
.
RewindOffset
(
)
;
}
if
(
!
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
|
|
!
lastRawPoint
.
GetChildOrContainerIfDataNode
(
)
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
{
EditorDOMPoint
pointToPutCaret
;
for
(
int32_t
i
=
aArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
aArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
content
)
&
&
!
content
-
>
IsText
(
)
)
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfInlineContents
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
SplitElementsAtEveryBRElement
(
MOZ_KnownLive
(
content
)
arrayOfInlineContents
)
;
if
(
splitResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
splitResult
;
}
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
aArrayOfContents
.
RemoveElementAt
(
i
)
;
aArrayOfContents
.
InsertElementsAt
(
i
arrayOfInlineContents
)
;
}
}
return
pointToPutCaret
;
}
default
:
return
EditorDOMPoint
(
)
;
}
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
RangeItem
&
aRangeItem
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
pointToPutCaret
;
if
(
!
aRangeItem
.
Collapsed
(
)
&
&
aRangeItem
.
mEndContainer
&
&
aRangeItem
.
mEndContainer
-
>
IsContent
(
)
)
{
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtEnd
=
HTMLEditUtils
:
:
GetMostDistantAncestorInlineElement
(
*
aRangeItem
.
mEndContainer
-
>
AsContent
(
)
editingHost
)
;
if
(
mostAncestorInlineContentAtEnd
)
{
SplitNodeResult
splitEndInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtEnd
aRangeItem
.
EndPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitEndInlineResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
Err
(
splitEndInlineResult
.
unwrapErr
(
)
)
;
}
splitEndInlineResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
pointToPutCaret
.
IsInContentNode
(
)
&
&
MOZ_UNLIKELY
(
editingHost
!
=
ComputeEditingHost
(
*
pointToPutCaret
.
ContainerAs
<
nsIContent
>
(
)
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
caused
changing
editing
host
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
const
EditorRawDOMPoint
&
splitPointAtEnd
=
splitEndInlineResult
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
splitPointAtEnd
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
aRangeItem
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
aRangeItem
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
}
if
(
!
aRangeItem
.
mStartContainer
|
|
!
aRangeItem
.
mStartContainer
-
>
IsContent
(
)
)
{
return
pointToPutCaret
;
}
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtStart
=
HTMLEditUtils
:
:
GetMostDistantAncestorInlineElement
(
*
aRangeItem
.
mStartContainer
-
>
AsContent
(
)
editingHost
)
;
if
(
mostAncestorInlineContentAtStart
)
{
SplitNodeResult
splitStartInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtStart
aRangeItem
.
StartPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
splitStartInlineResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
Err
(
splitStartInlineResult
.
unwrapErr
(
)
)
;
}
splitStartInlineResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
const
EditorRawDOMPoint
&
splitPointAtStart
=
splitStartInlineResult
.
AtSplitPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
splitPointAtStart
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
aRangeItem
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
aRangeItem
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
nsIContent
&
aMostAncestorToBeSplit
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
HTMLBRElement
>
24
>
arrayOfBRElements
;
DOMIterator
iter
(
aMostAncestorToBeSplit
)
;
iter
.
AppendAllNodesToArray
(
arrayOfBRElements
)
;
if
(
arrayOfBRElements
.
IsEmpty
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
aMostAncestorToBeSplit
)
;
return
EditorDOMPoint
(
)
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
&
aMostAncestorToBeSplit
;
EditorDOMPoint
pointToPutCaret
;
for
(
OwningNonNull
<
HTMLBRElement
>
&
brElement
:
arrayOfBRElements
)
{
EditorDOMPoint
atBRNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBRNode
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
nextContent
atBRNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
Err
(
splitNodeResult
.
unwrapErr
(
)
)
;
}
splitNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
nsIContent
*
previousContent
=
splitNodeResult
.
GetPreviousContent
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
previousContent
)
;
}
MoveNodeResult
moveBRElementResult
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
brElement
)
splitNodeResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
)
;
if
(
moveBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
moveBRElementResult
.
unwrapErr
(
)
)
;
}
moveBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
aOutArrayOfContents
.
AppendElement
(
brElement
)
;
nextContent
=
splitNodeResult
.
GetNextContent
(
)
;
}
aOutArrayOfContents
.
AppendElement
(
*
nextContent
)
;
return
pointToPutCaret
;
}
void
HTMLEditor
:
:
MakeTransitionList
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsINode
*
prevParent
=
nullptr
;
aTransitionArray
.
EnsureLengthAtLeast
(
aArrayOfContents
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aArrayOfContents
.
Length
(
)
;
i
+
+
)
{
aTransitionArray
[
i
]
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
;
prevParent
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
;
}
}
SplitNodeResult
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
Element
&
aHeadingElement
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
SplitNodeResult
splitHeadingResult
=
[
this
&
aPointToSplit
&
aHeadingElement
]
(
)
MOZ_CAN_RUN_SCRIPT
{
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aPointToSplit
aHeadingElement
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
"
"
failed
"
)
;
return
SplitNodeResult
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
SplitNodeResult
splitResult
=
SplitNodeDeepWithTransaction
(
aHeadingElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitResult
.
isOk
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aHeadingElement
"
"
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitResult
;
}
(
)
;
if
(
splitHeadingResult
.
isErr
(
)
)
{
NS_WARNING
(
"
Failed
to
splitting
aHeadingElement
"
)
;
return
splitHeadingResult
;
}
splitHeadingResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
MOZ_UNLIKELY
(
!
splitHeadingResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
didn
'
t
split
aHeadingElement
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
Element
*
leftHeadingElement
=
Element
:
:
FromNode
(
splitHeadingResult
.
GetPreviousContent
(
)
)
;
MOZ_ASSERT
(
leftHeadingElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
leftHeadingElement
)
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftHeadingElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
leftHeadingElement
0u
)
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
SplitNodeResult
(
insertPaddingBRElementResult
.
unwrapErr
(
)
)
;
}
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
}
Element
*
rightHeadingElement
=
Element
:
:
FromNode
(
splitHeadingResult
.
GetNextContent
(
)
)
;
MOZ_ASSERT
(
rightHeadingElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
!
HTMLEditUtils
:
:
IsEmptyBlockElement
(
*
rightHeadingElement
{
}
)
)
{
return
SplitNodeResult
(
std
:
:
move
(
splitHeadingResult
)
EditorDOMPoint
(
rightHeadingElement
0u
)
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightHeadingElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
if
(
rightHeadingElement
-
>
GetNextSibling
(
)
)
{
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
rightHeadingElement
-
>
GetNextSibling
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
nextEditableSibling
&
&
nextEditableSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
auto
afterEditableBRElement
=
EditorDOMPoint
:
:
After
(
*
nextEditableSibling
)
;
if
(
NS_WARN_IF
(
!
afterEditableBRElement
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
SplitNodeResult
(
SplitNodeResult
:
:
HandledButDidNotSplitDueToEndOfContainer
(
*
leftHeadingElement
GetSplitNodeDirection
(
)
)
afterEditableBRElement
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
leftHeadingElement
-
>
IsInComposedDoc
(
)
)
)
{
NS_WARNING
(
"
The
left
heading
element
was
unexpectedly
removed
"
)
;
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
mTypeInState
-
>
ClearAllProps
(
)
;
nsStaticAtom
&
newParagraphTagName
=
&
DefaultParagraphSeparatorTagName
(
)
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
DefaultParagraphSeparatorTagName
(
)
;
const
CreateElementResult
createNewParagraphElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
EditorDOMPoint
:
:
After
(
*
leftHeadingElement
)
[
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivOrParagraphElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aDivOrParagraphElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
CreateElementResult
insertBRElementResult
=
aHTMLEditor
.
InsertBRElement
(
withTransaction
EditorDOMPoint
(
&
aDivOrParagraphElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertBRElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
)
;
if
(
createNewParagraphElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
SplitNodeResult
(
createNewParagraphElementResult
.
unwrapErr
(
)
)
;
}
createNewParagraphElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewParagraphElementResult
.
GetNewNode
(
)
)
;
return
SplitNodeResult
(
*
leftHeadingElement
*
createNewParagraphElementResult
.
GetNewNode
(
)
GetSplitNodeDirection
(
)
Some
(
EditorDOMPoint
(
createNewParagraphElementResult
.
GetNewNode
(
)
0u
)
)
)
;
}
SplitNodeResult
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aCandidatePointToSplit
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCandidatePointToSplit
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
pointToSplit
=
[
&
]
(
)
{
if
(
aCandidatePointToSplit
.
IsStartOfContainer
(
)
)
{
EditorDOMPoint
candidatePoint
(
aCandidatePointToSplit
)
;
for
(
nsIContent
*
container
=
aCandidatePointToSplit
.
GetContainerAs
<
nsIContent
>
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
candidatePoint
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
return
candidatePoint
;
}
if
(
aCandidatePointToSplit
.
IsEndOfContainer
(
)
|
|
aCandidatePointToSplit
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
aCandidatePointToSplit
.
IsBRElementAtEndOfContainer
(
)
;
EditorDOMPoint
candidatePoint
(
aCandidatePointToSplit
)
;
for
(
nsIContent
*
container
=
aCandidatePointToSplit
.
GetContainerAs
<
nsIContent
>
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
candidatePoint
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
return
candidatePoint
;
}
return
aCandidatePointToSplit
;
}
(
)
;
const
bool
createNewParagraph
=
GetReturnInParagraphCreatesNewParagraph
(
)
;
RefPtr
<
HTMLBRElement
>
brElement
;
if
(
createNewParagraph
&
&
pointToSplit
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brElement
=
nullptr
;
}
else
if
(
pointToSplit
.
IsInTextNode
(
)
)
{
if
(
pointToSplit
.
IsStartOfContainer
(
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousSibling
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
if
(
!
brElement
|
|
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
brElement
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brElement
)
)
{
if
(
!
createNewParagraph
)
{
return
SplitNodeResult
:
:
NotHandled
(
pointToSplit
GetSplitNodeDirection
(
)
)
;
}
const
EditorDOMPoint
pointToInsertBR
=
pointToSplit
.
ParentPoint
(
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToInsertBR
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
SplitNodeResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
else
if
(
pointToSplit
.
IsEndOfContainer
(
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextSibling
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
if
(
!
brElement
|
|
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
brElement
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brElement
)
)
{
if
(
!
createNewParagraph
)
{
return
SplitNodeResult
:
:
NotHandled
(
pointToSplit
GetSplitNodeDirection
(
)
)
;
}
const
EditorDOMPoint
pointToInsertBR
=
EditorDOMPoint
:
:
After
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToInsertBR
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
SplitNodeResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
else
{
if
(
!
createNewParagraph
)
{
return
SplitNodeResult
:
:
NotHandled
(
pointToSplit
GetSplitNodeDirection
(
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
pointToSplit
aParentDivOrP
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
"
"
failed
"
)
;
return
SplitNodeResult
(
pointToSplitOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
pointToSplitOrError
.
inspect
(
)
.
IsSetAndValid
(
)
)
;
if
(
pointToSplitOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
;
}
SplitNodeResult
splitParentDivOrPResult
=
SplitNodeWithTransaction
(
pointToSplit
)
;
if
(
splitParentDivOrPResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitParentDivOrPResult
;
}
splitParentDivOrPResult
.
IgnoreCaretPointSuggestion
(
)
;
pointToSplit
.
SetToEndOf
(
splitParentDivOrPResult
.
GetPreviousContent
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
const
EditorDOMPoint
pointToInsertBR
=
EditorDOMPoint
:
:
After
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToInsertBR
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
SplitNodeResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
else
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousContent
(
pointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
)
;
if
(
!
brElement
|
|
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
brElement
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brElement
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextContent
(
pointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
)
;
if
(
!
brElement
|
|
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
brElement
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brElement
)
)
{
if
(
!
createNewParagraph
)
{
return
SplitNodeResult
:
:
NotHandled
(
pointToSplit
GetSplitNodeDirection
(
)
)
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
pointToSplit
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
SplitNodeResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
insertBRElementResult
.
GetNewNode
(
)
)
;
pointToSplit
.
SetAfter
(
brElement
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
}
SplitNodeResult
splitParagraphResult
=
SplitParagraphWithTransaction
(
aParentDivOrP
pointToSplit
brElement
)
;
if
(
splitParagraphResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitParagraphWithTransaction
(
)
failed
"
)
;
return
splitParagraphResult
;
}
if
(
MOZ_UNLIKELY
(
!
splitParagraphResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitParagraphWithTransaction
(
)
didn
'
t
split
the
"
"
paragraph
"
)
;
splitParagraphResult
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
splitParagraphResult
.
Handled
(
)
)
;
return
splitParagraphResult
;
}
SplitNodeResult
HTMLEditor
:
:
SplitParagraphWithTransaction
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aStartOfRightNode
HTMLBRElement
*
aMayBecomeVisibleBRElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aStartOfRightNode
aParentDivOrP
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
SplitNodeResult
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
SplitNodeResult
splitDivOrPResult
=
SplitNodeDeepWithTransaction
(
aParentDivOrP
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitDivOrPResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitDivOrPResult
;
}
if
(
MOZ_UNLIKELY
(
!
splitDivOrPResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
any
nodes
"
)
;
return
splitDivOrPResult
;
}
splitDivOrPResult
.
IgnoreCaretPointSuggestion
(
)
;
Element
*
leftDivOrParagraphElement
=
Element
:
:
FromNode
(
splitDivOrPResult
.
GetPreviousContent
(
)
)
;
MOZ_ASSERT
(
leftDivOrParagraphElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
Element
*
rightDivOrParagraphElement
=
Element
:
:
FromNode
(
splitDivOrPResult
.
GetNextContent
(
)
)
;
MOZ_ASSERT
(
rightDivOrParagraphElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
aMayBecomeVisibleBRElement
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
aMayBecomeVisibleBRElement
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
aMayBecomeVisibleBRElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
*
nsGkAtoms
:
:
id
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
id
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
auto
InsertBRElementIfEmptyBlockElement
=
[
&
]
(
Element
&
aElement
)
MOZ_CAN_RUN_SCRIPT
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
NS_OK
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
;
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
leftDivOrParagraphElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InsertBRElementIfEmptyBlockElement
(
leftDivOrParagraphElement
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
rightDivOrParagraphElement
)
)
{
const
RefPtr
<
Element
>
deepestInlineContainerElement
=
[
]
(
const
Element
&
aBlockElement
)
{
Element
*
result
=
nullptr
;
for
(
Element
*
maybeDeepestInlineContainer
=
Element
:
:
FromNodeOrNull
(
aBlockElement
.
GetFirstChild
(
)
)
;
maybeDeepestInlineContainer
&
&
HTMLEditUtils
:
:
IsInlineElement
(
*
maybeDeepestInlineContainer
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
maybeDeepestInlineContainer
)
;
maybeDeepestInlineContainer
=
maybeDeepestInlineContainer
-
>
GetFirstElementChild
(
)
)
{
result
=
maybeDeepestInlineContainer
;
}
return
result
;
}
(
*
rightDivOrParagraphElement
)
;
if
(
deepestInlineContainerElement
)
{
RefPtr
<
HTMLBRElement
>
brElement
=
HTMLEditUtils
:
:
GetFirstBRElement
(
*
rightDivOrParagraphElement
)
;
if
(
brElement
&
&
brElement
-
>
GetParentNode
(
)
=
=
deepestInlineContainerElement
)
{
brElement
-
>
SetFlags
(
NS_PADDING_FOR_EMPTY_LAST_LINE
)
;
return
SplitNodeResult
(
std
:
:
move
(
splitDivOrPResult
)
EditorDOMPoint
(
brElement
)
)
;
}
if
(
brElement
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
brElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
}
const
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
:
:
AtEndOf
(
deepestInlineContainerElement
)
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
failed
"
)
;
return
SplitNodeResult
(
insertPaddingBRElementResult
.
inspectErr
(
)
)
;
}
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitNodeResult
(
std
:
:
move
(
splitDivOrPResult
)
EditorDOMPoint
(
insertPaddingBRElementResult
.
GetNewNode
(
)
)
)
;
}
nsresult
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InsertBRElementIfEmptyBlockElement
(
rightDivOrParagraphElement
)
"
"
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
}
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
rightDivOrParagraphElement
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
)
;
if
(
MOZ_UNLIKELY
(
!
child
)
)
{
return
SplitNodeResult
(
std
:
:
move
(
splitDivOrPResult
)
EditorDOMPoint
(
rightDivOrParagraphElement
0u
)
)
;
}
return
child
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
?
SplitNodeResult
(
std
:
:
move
(
splitDivOrPResult
)
EditorDOMPoint
(
child
0u
)
)
:
SplitNodeResult
(
std
:
:
move
(
splitDivOrPResult
)
EditorDOMPoint
(
child
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
Element
&
aListItemElement
const
EditorDOMPoint
&
aPointToSplit
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
;
if
(
&
aEditingHost
!
=
aListItemElement
.
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsEmptyBlockElement
(
aListItemElement
{
}
)
)
{
RefPtr
<
Element
>
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
!
HTMLEditUtils
:
:
IsLastChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
const
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
EditorDOMPoint
(
&
aListItemElement
)
)
;
if
(
splitListItemParentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
splitListItemParentResult
.
unwrapErr
(
)
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitListItemParentResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
split
the
parent
of
"
"
aListItemElement
"
)
;
MOZ_ASSERT
(
!
splitListItemParentResult
.
HasCaretPointSuggestion
(
)
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
splitListItemParentResult
.
IgnoreCaretPointSuggestion
(
)
;
leftListElement
=
Element
:
:
FromNode
(
splitListItemParentResult
.
GetPreviousContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
leftListElement
)
;
}
auto
afterLeftListElement
=
EditorDOMPoint
:
:
After
(
leftListElement
)
;
if
(
MOZ_UNLIKELY
(
!
afterLeftListElement
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
afterLeftListElement
.
GetContainer
(
)
)
)
{
const
MoveNodeResult
moveListItemElementResult
=
MoveNodeWithTransaction
(
aListItemElement
afterLeftListElement
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
moveListItemElementResult
.
unwrapErr
(
)
)
;
}
moveListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
EditorDOMPoint
(
&
aListItemElement
0u
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aListItemElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
nsStaticAtom
&
newParagraphTagName
=
&
DefaultParagraphSeparatorTagName
(
)
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
DefaultParagraphSeparatorTagName
(
)
;
const
CreateElementResult
createNewParagraphElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
afterLeftListElement
[
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aDivOrParagraphElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
const
auto
withTransaction
=
aDivOrParagraphElement
.
IsInComposedDoc
(
)
?
WithTransaction
:
:
Yes
:
WithTransaction
:
:
No
;
CreateElementResult
insertBRElementResult
=
aHTMLEditor
.
InsertBRElement
(
withTransaction
EditorDOMPoint
(
&
aDivOrParagraphElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
InsertBRElement
(
%
s
)
failed
"
ToString
(
withTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
)
;
if
(
createNewParagraphElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
createNewParagraphElementResult
.
unwrapErr
(
)
)
;
}
createNewParagraphElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewParagraphElementResult
.
GetNewNode
(
)
)
;
return
EditorDOMPoint
(
createNewParagraphElementResult
.
GetNewNode
(
)
0u
)
;
}
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
*
this
aPointToSplit
aListItemElement
)
;
if
(
preparationResult
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
Err
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
const
SplitNodeResult
splitListItemResult
=
SplitNodeDeepWithTransaction
(
aListItemElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
splitListItemResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
Err
(
splitListItemResult
.
unwrapErr
(
)
)
;
}
splitListItemResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
MOZ_UNLIKELY
(
!
aListItemElement
.
GetParent
(
)
)
)
{
NS_WARNING
(
"
Somebody
disconnected
the
target
listitem
from
the
parent
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
splitListItemResult
.
DidSplit
(
)
)
|
|
NS_WARN_IF
(
!
splitListItemResult
.
GetNewContent
(
)
-
>
IsElement
(
)
)
|
|
NS_WARN_IF
(
!
splitListItemResult
.
GetOriginalContent
(
)
-
>
IsElement
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Element
&
leftListItemElement
=
*
splitListItemResult
.
GetPreviousContent
(
)
-
>
AsElement
(
)
;
Element
&
rightListItemElement
=
*
splitListItemResult
.
GetNextContent
(
)
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
leftListItemElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
leftListItemElement
0u
)
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
Err
(
insertPaddingBRElementResult
.
unwrapErr
(
)
)
;
}
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
EditorDOMPoint
(
&
rightListItemElement
0u
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
rightListItemElement
)
)
{
if
(
aListItemElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
)
{
nsStaticAtom
&
nextDefinitionListItemTagName
=
aListItemElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
?
*
nsGkAtoms
:
:
dd
:
*
nsGkAtoms
:
:
dt
;
CreateElementResult
createNewListItemElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
nextDefinitionListItemTagName
)
EditorDOMPoint
:
:
After
(
rightListItemElement
)
)
;
if
(
createNewListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
createNewListItemElementResult
.
unwrapErr
(
)
)
;
}
createNewListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
RefPtr
<
Element
>
newListItemElement
=
createNewListItemElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newListItemElement
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
rightListItemElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditorDOMPoint
(
newListItemElement
0u
)
;
}
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
CopyLastEditableChildStylesWithTransaction
(
MOZ_KnownLive
(
leftListItemElement
)
MOZ_KnownLive
(
rightListItemElement
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
)
failed
"
)
;
return
Err
(
pointToPutCaretOrError
.
unwrapErr
(
)
)
;
}
return
pointToPutCaretOrError
.
unwrap
(
)
;
}
WSScanResult
forwardScanFromStartOfListItemResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
EditorRawDOMPoint
(
&
rightListItemElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromStartOfListItemResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromStartOfListItemResult
.
ReachedSpecialContent
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedBRElement
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedHRElement
(
)
)
{
auto
atFoundElement
=
forwardScanFromStartOfListItemResult
.
PointAtContent
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atFoundElement
.
IsSetAndValid
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
atFoundElement
;
}
return
forwardScanFromStartOfListItemResult
.
Point
<
EditorDOMPoint
>
(
)
;
}
CreateElementResult
HTMLEditor
:
:
WrapContentsInBlockquoteElementsWithTransaction
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
curBlock
blockElementToPutCaret
;
nsCOMPtr
<
nsINode
>
prevParent
;
EditorDOMPoint
pointToPutCaret
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
CreateElementResult
wrapChildrenInAnotherBlockquoteResult
=
WrapContentsInBlockquoteElementsWithTransaction
(
childContents
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
wrapChildrenInAnotherBlockquoteResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
WrapContentsInBlockquoteElementsWithTransaction
(
)
"
"
failed
"
)
;
return
wrapChildrenInAnotherBlockquoteResult
;
}
wrapChildrenInAnotherBlockquoteResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
wrapChildrenInAnotherBlockquoteResult
.
GetNewNode
(
)
)
{
blockElementToPutCaret
=
wrapChildrenInAnotherBlockquoteResult
.
UnwrapNewNode
(
)
;
}
}
if
(
prevParent
)
{
if
(
prevParent
!
=
content
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
content
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
content
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
CreateElementResult
createNewBlockQuoteElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
blockquote
EditorDOMPoint
(
content
)
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockQuoteElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
blockquote
)
failed
"
)
;
return
createNewBlockQuoteElementResult
;
}
createNewBlockQuoteElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
createNewBlockQuoteElementResult
.
GetNewNode
(
)
)
;
blockElementToPutCaret
=
createNewBlockQuoteElementResult
.
GetNewNode
(
)
;
curBlock
=
createNewBlockQuoteElementResult
.
UnwrapNewNode
(
)
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
moveNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
return
blockElementToPutCaret
?
CreateElementResult
(
std
:
:
move
(
blockElementToPutCaret
)
std
:
:
move
(
pointToPutCaret
)
)
:
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
RemoveBlockContainerElementsWithTransaction
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
blockElement
;
nsCOMPtr
<
nsIContent
>
firstContent
lastContent
;
EditorDOMPoint
pointToPutCaret
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
unwrapBlockElementResult
=
RemoveBlockContainerElementWithTransactionBetween
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
)
"
"
failed
"
)
;
return
Err
(
unwrapBlockElementResult
.
unwrapErr
(
)
)
;
}
unwrapBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
Result
<
EditorDOMPoint
nsresult
>
unwrapFormatBlockResult
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
unwrapFormatBlockResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
unwrapFormatBlockResult
;
}
if
(
unwrapFormatBlockResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapFormatBlockResult
.
unwrap
(
)
;
}
continue
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
unwrapBlockElementResult
=
RemoveBlockContainerElementWithTransactionBetween
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
)
"
"
failed
"
)
;
return
Err
(
unwrapBlockElementResult
.
unwrapErr
(
)
)
;
}
unwrapBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
Result
<
EditorDOMPoint
nsresult
>
removeBlockContainerElementsResult
=
RemoveBlockContainerElementsWithTransaction
(
childContents
)
;
if
(
MOZ_UNLIKELY
(
removeBlockContainerElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementsWithTransaction
(
)
failed
"
)
;
return
removeBlockContainerElementsResult
;
}
if
(
removeBlockContainerElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
removeBlockContainerElementsResult
.
unwrap
(
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
blockElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
blockElement
)
)
{
lastContent
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
unwrapBlockElementResult
=
RemoveBlockContainerElementWithTransactionBetween
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
)
"
"
failed
"
)
;
return
Err
(
unwrapBlockElementResult
.
unwrapErr
(
)
)
;
}
unwrapBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
blockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
content
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
blockElement
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
blockElement
)
|
|
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
blockElement
)
)
{
blockElement
=
nullptr
;
}
else
{
firstContent
=
lastContent
=
content
;
}
continue
;
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
unwrapBlockElementResult
=
RemoveBlockContainerElementWithTransactionBetween
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
)
"
"
failed
"
)
;
return
Err
(
unwrapBlockElementResult
.
unwrapErr
(
)
)
;
}
unwrapBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
firstContent
=
lastContent
=
blockElement
=
nullptr
;
continue
;
}
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
unwrapBlockElementResult
=
RemoveBlockContainerElementWithTransactionBetween
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
unwrapBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElementWithTransactionBetween
(
)
"
"
failed
"
)
;
return
Err
(
unwrapBlockElementResult
.
unwrapErr
(
)
)
;
}
unwrapBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
return
pointToPutCaret
;
}
CreateElementResult
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsAtom
&
aBlockTag
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
newBlock
curBlock
blockElementToPutCaret
;
EditorDOMPoint
pointToPutCaret
;
for
(
auto
&
content
:
aArrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNode
(
)
)
)
{
curBlock
=
nullptr
;
newBlock
=
nullptr
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
content
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
curBlock
=
nullptr
;
CreateElementResult
newBlockElementOrError
=
ReplaceContainerAndCloneAttributesWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aBlockTag
)
;
if
(
newBlockElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
ReplaceContainerAndCloneAttributesWithTransaction
(
)
"
"
failed
"
)
;
return
newBlockElementOrError
;
}
if
(
NS_WARN_IF
(
newBlockElementOrError
.
GetNewNode
(
)
-
>
GetParentNode
(
)
!
=
atContent
.
GetContainer
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
newBlockElementOrError
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
newBlock
=
newBlockElementOrError
.
UnwrapNewNode
(
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
if
(
!
childContents
.
IsEmpty
(
)
)
{
CreateElementResult
wrapChildrenInBlockElementResult
=
CreateOrChangeBlockContainerElement
(
childContents
aBlockTag
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
wrapChildrenInBlockElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
wrapChildrenInBlockElementResult
;
}
wrapChildrenInBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
wrapChildrenInBlockElementResult
.
GetNewNode
(
)
)
{
blockElementToPutCaret
=
wrapChildrenInBlockElementResult
.
UnwrapNewNode
(
)
;
}
continue
;
}
CreateElementResult
createNewBlockElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
createNewBlockElementResult
;
}
createNewBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
createNewBlockElementResult
.
GetNewNode
(
)
)
;
blockElementToPutCaret
=
createNewBlockElementResult
.
UnwrapNewNode
(
)
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
continue
;
}
CreateElementResult
createNewBlockElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
createNewBlockElementResult
;
}
createNewBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
RefPtr
<
Element
>
newBlockElement
=
createNewBlockElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newBlockElement
)
;
blockElementToPutCaret
=
newBlockElement
;
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
newBlockElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
moveNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
curBlock
=
std
:
:
move
(
newBlockElement
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
!
curBlock
)
{
CreateElementResult
createNewBlockElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
aBlockTag
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewBlockElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTr
"
"
ansaction
(
%
s
)
failed
"
nsAtomCString
(
&
aBlockTag
)
.
get
(
)
)
.
get
(
)
)
;
return
createNewBlockElementResult
;
}
createNewBlockElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
createNewBlockElementResult
.
GetNewNode
(
)
)
;
blockElementToPutCaret
=
createNewBlockElementResult
.
GetNewNode
(
)
;
curBlock
=
createNewBlockElementResult
.
UnwrapNewNode
(
)
;
atContent
.
Set
(
content
)
;
}
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_UNEXPECTED
)
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
moveNodeResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
}
return
blockElementToPutCaret
?
CreateElementResult
(
std
:
:
move
(
blockElementToPutCaret
)
std
:
:
move
(
pointToPutCaret
)
)
:
CreateElementResult
:
:
NotHandled
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
SplitNodeResult
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aStartOfDeepestRightNode
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
if
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
&
aEditingHost
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
aEditingHost
)
)
{
NS_WARNING
(
"
aStartOfDeepestRightNode
was
not
in
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
pointToInsert
.
GetChild
(
)
=
=
&
aEditingHost
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
reached
"
"
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
:
:
NotHandled
(
aStartOfDeepestRightNode
GetSplitNodeDirection
(
)
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitNodeResult
.
isOk
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitNodeResult
;
}
CreateElementResult
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
nsAtom
&
aTagName
const
EditorDOMPoint
&
aPointToInsert
BRElementNextToSplitPoint
aBRElementNextToSplitPoint
const
Element
&
aEditingHost
const
InitializeInsertingElement
&
aInitializer
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
const
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aTagName
aPointToInsert
aEditingHost
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
splitNodeResult
.
unwrapErr
(
)
)
;
}
DebugOnly
<
bool
>
wasCaretPositionSuggestedAtSplit
=
splitNodeResult
.
HasCaretPointSuggestion
(
)
;
splitNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
NS_WARN_IF
(
aPointToInsert
.
HasChildMovedFromContainer
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
aBRElementNextToSplitPoint
=
=
BRElementNextToSplitPoint
:
:
Delete
)
{
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
HTMLEditUtils
:
:
GetNextContent
(
splitPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
&
aEditingHost
)
)
{
if
(
maybeBRContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
splitPoint
.
GetChild
(
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
splitPoint
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableSibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
splitPoint
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
}
}
}
}
}
CreateElementResult
createNewElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
aTagName
splitPoint
aInitializer
)
;
if
(
createNewElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
CreateElementResult
(
createNewElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT_IF
(
wasCaretPositionSuggestedAtSplit
createNewElementResult
.
HasCaretPointSuggestion
(
)
)
;
MOZ_ASSERT
(
createNewElementResult
.
GetNewNode
(
)
)
;
if
(
NS_WARN_IF
(
createNewElementResult
.
GetNewNode
(
)
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
createNewElementResult
;
}
nsresult
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNewFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
!
aNodeLeft
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNodeLeft
.
GetParentNode
(
)
!
=
aNodeRight
.
GetParentNode
(
)
)
{
const
MoveNodeResult
moveNodeResult
=
MoveNodeWithTransaction
(
aNodeRight
EditorDOMPoint
(
&
aNodeLeft
)
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
moveNodeResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aNodeLeft
)
|
|
aNodeLeft
.
IsText
(
)
)
{
JoinNodesResult
joinNodesResult
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
MOZ_UNLIKELY
(
joinNodesResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
failed
"
)
;
return
joinNodesResult
.
Rv
(
)
;
}
*
aNewFirstChildOfRightNode
=
joinNodesResult
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
return
joinNodesResult
.
Rv
(
)
;
}
nsCOMPtr
<
nsIContent
>
lastEditableChildOfLeftContent
=
HTMLEditUtils
:
:
GetLastChild
(
aNodeLeft
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
lastEditableChildOfLeftContent
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstEditableChildOfRightContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aNodeRight
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
NS_WARN_IF
(
!
firstEditableChildOfRightContent
)
)
{
return
NS_ERROR_FAILURE
;
}
JoinNodesResult
joinNodesResult
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
MOZ_UNLIKELY
(
joinNodesResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
joinNodesResult
.
Rv
(
)
;
}
if
(
(
lastEditableChildOfLeftContent
-
>
IsText
(
)
|
|
lastEditableChildOfLeftContent
-
>
IsElement
(
)
)
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
lastEditableChildOfLeftContent
*
firstEditableChildOfRightContent
StyleDifference
:
:
CompareIfElements
)
)
{
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
lastEditableChildOfLeftContent
*
firstEditableChildOfRightContent
aNewFirstChildOfRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
*
aNewFirstChildOfRightNode
=
joinNodesResult
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetMostDistantAncestorMailCiteElement
(
const
nsINode
&
aNode
)
const
{
Element
*
mailCiteElement
=
nullptr
;
const
bool
isPlaintextEditor
=
IsInPlaintextMode
(
)
;
for
(
Element
*
element
:
aNode
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
(
isPlaintextEditor
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
*
element
)
)
{
mailCiteElement
=
element
;
continue
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
mailCiteElement
;
}
nsresult
HTMLEditor
:
:
CacheInlineStyles
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
GetInlineStyles
(
aContent
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlineStyles
(
nsIContent
&
aContent
AutoStyleCacheArray
&
aStyleCacheArray
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStyleCacheArray
.
IsEmpty
(
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
for
(
nsStaticAtom
*
property
:
{
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
s
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
face
nsGkAtoms
:
:
size
nsGkAtoms
:
:
color
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
em
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
code
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
var
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
backgroundColor
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
}
)
{
nsStaticAtom
*
tag
*
attribute
;
if
(
property
=
=
nsGkAtoms
:
:
face
|
|
property
=
=
nsGkAtoms
:
:
size
|
|
property
=
=
nsGkAtoms
:
:
color
)
{
tag
=
nsGkAtoms
:
:
font
;
attribute
=
property
;
}
else
{
tag
=
property
;
attribute
=
nullptr
;
}
bool
typeInSet
unused
;
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
*
tag
attribute
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsString
value
;
if
(
!
useCSS
|
|
(
property
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
aContent
*
tag
attribute
nullptr
&
value
)
;
}
else
{
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
mCSSEditUtils
-
>
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aContent
MOZ_KnownLive
(
tag
)
MOZ_KnownLive
(
attribute
)
value
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrapErr
(
)
;
}
isSet
=
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
;
}
if
(
isSet
)
{
aStyleCacheArray
.
AppendElement
(
StyleCache
(
*
tag
attribute
value
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
IsEmpty
(
)
|
|
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
bool
useCSS
=
IsCSSEnabled
(
)
;
const
RangeBoundary
&
atStartOfSelection
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
-
>
StartRef
(
)
;
nsCOMPtr
<
nsIContent
>
startContainerContent
=
atStartOfSelection
.
Container
(
)
&
&
atStartOfSelection
.
Container
(
)
-
>
IsContent
(
)
?
atStartOfSelection
.
Container
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
startContainerContent
)
)
{
return
NS_OK
;
}
AutoStyleCacheArray
styleCacheArrayAtInsertionPoint
;
nsresult
rv
=
GetInlineStyles
(
*
startContainerContent
styleCacheArrayAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
for
(
StyleCache
&
styleCacheBeforeEdit
:
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
{
bool
isFirst
=
false
isAny
=
false
isAll
=
false
;
nsAutoString
currentValue
;
if
(
useCSS
)
{
Result
<
bool
nsresult
>
isComputedCSSEquivalentToHTMLInlineStyleOrError
=
mCSSEditUtils
-
>
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
startContainerContent
MOZ_KnownLive
(
&
styleCacheBeforeEdit
.
TagRef
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
currentValue
)
;
if
(
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
)
"
"
failed
"
)
;
return
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrapErr
(
)
;
}
isAny
=
isComputedCSSEquivalentToHTMLInlineStyleOrError
.
unwrap
(
)
;
}
if
(
!
isAny
)
{
nsresult
rv
=
GetInlinePropertyBase
(
MOZ_KnownLive
(
styleCacheBeforeEdit
.
TagRef
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
&
styleCacheBeforeEdit
.
Value
(
)
&
isFirst
&
isAny
&
isAll
&
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
rv
;
}
}
if
(
isAny
&
&
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
continue
;
}
AutoStyleCacheArray
:
:
index_type
index
=
styleCacheArrayAtInsertionPoint
.
IndexOf
(
styleCacheBeforeEdit
.
TagRef
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
)
;
if
(
index
=
=
AutoStyleCacheArray
:
:
NoIndex
|
|
styleCacheBeforeEdit
.
Value
(
)
!
=
styleCacheArrayAtInsertionPoint
.
ElementAt
(
index
)
.
Value
(
)
)
{
mTypeInState
-
>
SetProp
(
styleCacheBeforeEdit
.
TagRef
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
styleCacheBeforeEdit
.
Value
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfEmptyElements
;
DOMIterator
iter
;
if
(
NS_FAILED
(
iter
.
Init
(
aStartRef
aEndRef
)
)
)
{
NS_WARNING
(
"
DOMIterator
:
:
Init
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
aSelf
)
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
MOZ_ASSERT
(
aSelf
)
;
Element
*
element
=
aNode
.
AsElement
(
)
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
element
EditorType
:
:
HTML
)
|
|
(
!
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
element
)
)
)
{
return
false
;
}
return
HTMLEditUtils
:
:
IsEmptyNode
(
*
element
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
;
}
arrayOfEmptyElements
this
)
;
EditorDOMPoint
pointToPutCaret
;
for
(
auto
&
emptyElement
:
arrayOfEmptyElements
)
{
EditorDOMPoint
endOfNode
(
EditorDOMPoint
:
:
AtEndOf
(
emptyElement
)
)
;
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfNode
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
insertPaddingBRElementResult
.
unwrapErr
(
)
;
}
insertPaddingBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
if
(
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetSelectionInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atCaret
.
IsSetAndValid
(
)
)
;
if
(
Element
*
editingHost
=
ComputeEditingHost
(
)
)
{
if
(
nsIContent
*
previousEditableContentInBlock
=
HTMLEditUtils
:
:
GetPreviousContent
(
atCaret
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
return
;
}
}
}
if
(
!
atCaret
.
GetChild
(
)
)
{
return
;
}
if
(
nsIContent
*
previousEditableContentInBlockAtCaret
=
HTMLEditUtils
:
:
GetPreviousSibling
(
*
atCaret
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContentInBlockAtCaret
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
nsIContent
*
nextEditableContentInBlockAtCaret
=
HTMLEditUtils
:
:
GetNextSibling
(
*
atCaret
.
GetChild
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContentInBlockAtCaret
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
EndOfLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
EndOfLine
)
failed
but
ignored
"
)
;
}
}
}
nsresult
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
;
auto
point
=
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
EditorUtils
:
:
IsEditableContent
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
{
if
(
editableBlockElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
editableBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
bodyOrDocumentElement
)
{
return
NS_OK
;
}
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
insertPaddingBRElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
insertPaddingBRElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
)
{
const
Element
*
const
blockElementContainingCaret
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
;
const
Element
*
const
blockElementContainingPreviousEditableContent
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
previousEditableContent
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
blockElementContainingCaret
&
&
blockElementContainingCaret
=
=
blockElementContainingPreviousEditableContent
&
&
point
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetEditingHost
(
)
=
=
previousEditableContent
-
>
GetEditingHost
(
)
&
&
previousEditableContent
&
&
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
previousEditableContent
)
&
&
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
previousEditableContent
)
)
{
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
failed
"
)
;
return
insertPaddingBRElementResult
.
unwrapErr
(
)
;
}
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
insertPaddingBRElementResult
.
GetNewNode
(
)
InterlinePosition
:
:
StartOfNextLine
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
nsIContent
*
nextEditableContentInBlock
=
HTMLEditUtils
:
:
GetNextContent
(
*
previousEditableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextEditableContentInBlock
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRef
(
)
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
SetInterlinePosition
(
InterlinePosition
:
:
"
"
StartOfNextLine
)
failed
but
ignored
"
)
;
}
}
}
}
if
(
nsIContent
*
previousEditableContentInBlock
=
HTMLEditUtils
:
:
GetPreviousContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
previousEditableContentInBlock
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsImage
(
previousEditableContentInBlock
)
|
|
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
if
(
nsIContent
*
nextEditableContentInBlock
=
HTMLEditUtils
:
:
GetNextContent
(
point
{
WalkTreeOption
:
:
IgnoreNonEditableNode
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
nextEditableContentInBlock
-
>
IsText
(
)
|
|
nextEditableContentInBlock
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
br
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
nsIContent
*
nearEditableContent
=
HTMLEditUtils
:
:
GetAdjacentContentToPutCaret
(
point
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
WalkTreeDirection
:
:
Backward
:
WalkTreeDirection
:
:
Forward
*
editingHost
)
;
if
(
!
nearEditableContent
)
{
return
NS_OK
;
}
EditorRawDOMPoint
pointToPutCaret
=
HTMLEditUtils
:
:
GetGoodCaretPointFor
<
EditorRawDOMPoint
>
(
*
nearEditableContent
aDirectionAndAmount
)
;
if
(
!
pointToPutCaret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyNodesIn
(
const
EditorDOMRange
&
aRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
const
RawRangeBoundary
endOfRange
=
[
&
]
(
)
{
if
(
aRange
.
Collapsed
(
)
|
|
!
aRange
.
IsInContentNodes
(
)
|
|
!
aRange
.
EndRef
(
)
.
IsStartOfContainer
(
)
)
{
return
aRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
;
}
nsINode
*
const
commonAncestor
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
aRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
)
;
if
(
!
commonAncestor
)
{
return
aRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
;
}
nsIContent
*
maybeRightContent
=
nullptr
;
for
(
nsIContent
*
content
:
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
content
)
|
|
content
=
=
commonAncestor
)
{
break
;
}
if
(
aRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
=
=
content
)
{
break
;
}
EmptyCheckOptions
options
=
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
options
+
=
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
options
)
)
{
break
;
}
maybeRightContent
=
content
;
}
if
(
!
maybeRightContent
)
{
return
aRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
;
}
return
EditorRawDOMPoint
:
:
After
(
*
maybeRightContent
)
.
ToRawRangeBoundary
(
)
;
}
(
)
;
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
aRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
endOfRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfEmptyContents
arrayOfEmptyCites
;
{
const
bool
isMailEditor
=
IsMailEditor
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
knownNonEmptyContents
;
Maybe
<
AutoRangeArray
>
maybeSelectionRanges
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
MOZ_ASSERT
(
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
;
nsIContent
*
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
nsIContent
*
parentContent
=
content
-
>
GetParent
(
)
;
size_t
idx
=
knownNonEmptyContents
.
IndexOf
(
content
)
;
if
(
idx
!
=
decltype
(
knownNonEmptyContents
)
:
:
NoIndex
)
{
if
(
parentContent
)
{
knownNonEmptyContents
[
idx
]
=
parentContent
;
}
continue
;
}
const
bool
isEmptyNode
=
[
&
]
(
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
return
false
;
}
const
bool
isMailCite
=
isMailEditor
&
&
HTMLEditUtils
:
:
IsMailCite
(
*
content
-
>
AsElement
(
)
)
;
const
bool
isCandidate
=
[
&
]
(
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
false
;
}
if
(
isMailCite
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
return
true
;
}
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
maybeSelectionRanges
.
isNothing
(
)
)
{
maybeSelectionRanges
.
emplace
(
SelectionRef
(
)
)
;
}
return
!
maybeSelectionRanges
-
>
IsAtLeastOneContainerOfRangeBoundariesInclusiveDescendantOf
(
*
content
)
;
}
return
false
;
}
(
)
;
if
(
!
isCandidate
)
{
return
false
;
}
HTMLEditUtils
:
:
EmptyCheckOptions
options
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
;
if
(
!
isMailCite
)
{
options
+
=
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
options
)
)
{
return
false
;
}
if
(
isMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
content
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
content
)
&
&
HTMLEditUtils
:
:
IsRemovableNode
(
*
content
)
)
{
arrayOfEmptyContents
.
AppendElement
(
*
content
)
;
}
return
true
;
}
(
)
;
if
(
!
isEmptyNode
&
&
parentContent
)
{
knownNonEmptyContents
.
AppendElement
(
*
parentContent
)
;
}
}
}
for
(
OwningNonNull
<
nsIContent
>
&
emptyContent
:
arrayOfEmptyContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyContent
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
EditorDOMPoint
pointToPutCaret
;
for
(
OwningNonNull
<
nsIContent
>
&
emptyCite
:
arrayOfEmptyCites
)
{
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
emptyCite
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
emptyCite
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
insertBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyCite
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
LiftUpListItemElement
(
Element
&
aListItemElement
LiftUpFromAllParentListElements
aLiftUpFromAllParentListElements
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
)
|
|
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isFirstListItem
=
HTMLEditUtils
:
:
IsFirstChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
bool
isLastListItem
=
HTMLEditUtils
:
:
IsLastChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
Element
*
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
leftListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
&
&
!
isLastListItem
)
{
EditorDOMPoint
atListItemElement
(
&
aListItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItemElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atListItemElement
.
IsSetAndValid
(
)
)
;
const
SplitNodeResult
splitListItemParentResult
=
SplitNodeWithTransaction
(
atListItemElement
)
;
if
(
splitListItemParentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitListItemParentResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
splitListItemParentResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
leftListElement
=
Element
:
:
FromNodeOrNull
(
splitListItemParentResult
.
GetPreviousContent
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
leftListElement
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
return
left
list
"
"
element
"
)
;
return
NS_ERROR_FAILURE
;
}
}
EditorDOMPoint
pointToInsertListItem
(
leftListElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
EditorDOMPoint
pointToPutCaret
;
MoveNodeResult
moveListItemElementResult
=
MoveNodeWithTransaction
(
aListItemElement
pointToInsertListItem
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveListItemElementResult
.
unwrapErr
(
)
;
}
moveListItemElementResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
Result
<
EditorDOMPoint
nsresult
>
unwrapOrphanListItemElementResult
=
RemoveBlockContainerWithTransaction
(
aListItemElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapOrphanListItemElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
unwrapOrphanListItemElementResult
.
unwrapErr
(
)
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
unwrapOrphanListItemElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapOrphanListItemElementResult
.
unwrap
(
)
;
}
if
(
!
pointToPutCaret
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
if
(
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
if
(
aLiftUpFromAllParentListElements
=
=
LiftUpFromAllParentListElements
:
:
No
)
{
return
NS_OK
;
}
nsresult
rv
=
LiftUpListItemElement
(
aListItemElement
LiftUpFromAllParentListElements
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
Yes
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DestroyListStructureRecursively
(
Element
&
aListElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
while
(
aListElement
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aListElement
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
HTMLEditor
:
:
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
child
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
const
Result
<
EditorDOMPoint
nsresult
>
unwrapListElementResult
=
RemoveBlockContainerWithTransaction
(
aListElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapListElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
unwrapListElementResult
.
inspectErr
(
)
;
}
const
EditorDOMPoint
&
pointToPutCaret
=
unwrapListElementResult
.
inspect
(
)
;
if
(
!
AllowsTransactionsToChangeSelection
(
)
|
|
!
pointToPutCaret
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
const
auto
atCaret
=
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
atCaret
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
const
auto
selectionEndPoint
=
GetFirstSelectionEndPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
NS_OK
;
}
CreateElementResult
insertPaddingBRElementResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
aElement
0u
)
)
;
if
(
insertPaddingBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
insertPaddingBRElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
insertPaddingBRElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
RemoveAlignFromDescendants
(
Element
&
aElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
const
bool
useCSS
=
IsCSSEnabled
(
)
;
EditorDOMPoint
pointToPutCaret
;
nsCOMPtr
<
nsIContent
>
nextSibling
;
for
(
nsIContent
*
content
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
&
aElement
:
aElement
.
GetFirstChild
(
)
;
content
;
content
=
nextSibling
)
{
nextSibling
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
nullptr
:
content
-
>
GetNextSibling
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
OwningNonNull
<
Element
>
centerElement
=
*
content
-
>
AsElement
(
)
;
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
RemoveAlignFromDescendants
(
centerElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
{
CreateElementResult
maybeInsertBRElementBeforeFirstChildResult
=
EnsureHardLineBeginsWithFirstChildOf
(
centerElement
)
;
if
(
maybeInsertBRElementBeforeFirstChildResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
)
failed
"
)
;
return
Err
(
maybeInsertBRElementBeforeFirstChildResult
.
unwrapErr
(
)
)
;
}
if
(
maybeInsertBRElementBeforeFirstChildResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
maybeInsertBRElementBeforeFirstChildResult
.
UnwrapCaretPoint
(
)
;
}
}
{
CreateElementResult
maybeInsertBRElementAfterLastChildResult
=
EnsureHardLineEndsWithLastChildOf
(
centerElement
)
;
if
(
maybeInsertBRElementAfterLastChildResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
)
failed
"
)
;
return
Err
(
maybeInsertBRElementAfterLastChildResult
.
unwrapErr
(
)
)
;
}
if
(
maybeInsertBRElementAfterLastChildResult
.
HasCaretPointSuggestion
(
)
)
{
pointToPutCaret
=
maybeInsertBRElementAfterLastChildResult
.
UnwrapCaretPoint
(
)
;
}
}
{
Result
<
EditorDOMPoint
nsresult
>
unwrapCenterElementResult
=
RemoveContainerWithTransaction
(
centerElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapCenterElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
Err
(
unwrapCenterElementResult
.
inspectErr
(
)
)
;
}
if
(
unwrapCenterElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapCenterElementResult
.
unwrap
(
)
;
}
}
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
&
&
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
continue
;
}
const
OwningNonNull
<
Element
>
blockOrHRElement
=
*
content
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
blockOrHRElement
)
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
blockOrHRElement
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
align
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
useCSS
)
{
if
(
blockOrHRElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
blockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
else
{
nsStyledElement
*
styledBlockOrHRElement
=
nsStyledElement
:
:
FromNode
(
blockOrHRElement
)
;
if
(
NS_WARN_IF
(
!
styledBlockOrHRElement
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
nsAutoString
dummyCssValue
;
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
mCSSEditUtils
-
>
RemoveCSSInlineStyleWithTransaction
(
MOZ_KnownLive
(
*
styledBlockOrHRElement
)
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSInlineStyleWithTransaction
(
nsGkAtoms
:
:
"
"
textAlign
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
}
if
(
!
blockOrHRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
RemoveAlignFromDescendants
(
blockOrHRElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
pointToPutCaretOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
}
return
pointToPutCaret
;
}
CreateElementResult
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableChild
=
HTMLEditUtils
:
:
GetFirstChild
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableChild
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableChild
)
|
|
firstEditableChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
nsIContent
*
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
previousEditableContent
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
|
|
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aRemovingContainerElement
0u
)
)
;
NS_WARNING_ASSERTION
(
insertBRElementResult
.
isOk
(
)
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
;
}
CreateElementResult
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableContent
)
|
|
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
nsIContent
*
nextEditableContent
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aRemovingContainerElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
nextEditableContent
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
|
|
nextEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
CreateElementResult
:
:
NotHandled
(
)
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
aRemovingContainerElement
)
)
;
NS_WARNING_ASSERTION
(
insertBRElementResult
.
isOk
(
)
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
SetBlockElementAlign
(
Element
&
aBlockOrHRElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aBlockOrHRElement
)
|
|
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
IsCSSEnabled
(
)
|
|
HTMLEditUtils
:
:
SupportsAlignAttr
(
aBlockOrHRElement
)
)
;
EditorDOMPoint
pointToPutCaret
;
if
(
!
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
RemoveAlignFromDescendants
(
aBlockOrHRElement
aAlignType
aEditTarget
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
)
failed
"
)
;
return
pointToPutCaretOrError
;
}
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
nsresult
rv
=
SetAttributeOrEquivalent
(
&
aBlockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
pointToPutCaret
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
ChangeMarginStart
(
Element
&
aElement
ChangeMargin
aChangeMargin
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChangeMargin
=
=
ChangeMargin
:
:
Increase
?
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
newValue
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
return
EditorDOMPoint
(
)
;
}
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
value
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
&
aElement
=
=
&
aEditingHost
|
|
!
aElement
.
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
{
return
EditorDOMPoint
(
)
;
}
Result
<
EditorDOMPoint
nsresult
>
unwrapDivElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
NS_WARNING_ASSERTION
(
unwrapDivElementResult
.
isOk
(
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapDivElementResult
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToAbsoluteAsSubAction
(
const
Element
&
aEditingHost
)
{
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToAbsolute
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditgor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
auto
EnsureCaretInElementIfCollapsedOutside
=
[
&
]
(
Element
&
aElement
)
MOZ_CAN_RUN_SCRIPT
{
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
const
auto
firstRangeStartPoint
=
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
firstRangeStartPoint
.
IsSet
(
)
)
)
{
return
NS_OK
;
}
const
Result
<
EditorRawDOMPoint
nsresult
>
pointToPutCaretOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
aElement
firstRangeStartPoint
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
"
"
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaretOrError
.
inspect
(
)
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
;
RefPtr
<
Element
>
focusElement
=
GetSelectionContainerElement
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
nsresult
rv
=
EnsureCaretInElementIfCollapsedOutside
(
*
focusElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretInElementIfCollapsedOutside
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
=
=
1u
)
{
Result
<
EditorRawDOMRange
nsresult
>
extendedRange
=
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
SelectionRef
(
)
.
GetRangeAt
(
0u
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
extendedRange
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetRangeExtendedToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
extendedRange
.
unwrapErr
(
)
)
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
SetBaseAndExtentInLimiter
(
extendedRange
.
inspect
(
)
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
extendedRange
.
inspect
(
)
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
}
RefPtr
<
Element
>
divElement
;
rv
=
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
address_of
(
divElement
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
!
divElement
)
{
return
EditActionHandled
(
)
;
}
rv
=
SetPositionToAbsoluteOrStatic
(
*
divElement
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
EnsureCaretInElementIfCollapsedOutside
(
*
divElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretInElementIfCollapsedOutside
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
RefPtr
<
Element
>
*
aTargetElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aTargetElement
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedSelectionRanges
(
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eSetPositionToAbsolute
aEditingHost
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
extendedSelectionRanges
.
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
*
this
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
)
"
"
failed
"
)
;
return
splitResult
.
unwrapErr
(
)
;
}
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
*
this
arrayOfContents
EditSubAction
:
:
eSetPositionToAbsolute
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eSetPositionToAbsolute
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eSetPositionToAbsolute
)
failed
"
)
;
return
splitAtBRElementsResult
.
inspectErr
(
)
;
}
if
(
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitAtBRElementsResult
.
unwrap
(
)
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaret
.
IsSetAndValid
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
if
(
HTMLEditUtils
:
:
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
auto
atCaret
=
EditorBase
:
:
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atCaret
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
createNewDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
RefPtr
<
Element
>
newDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newDivElement
)
;
for
(
OwningNonNull
<
nsIContent
>
&
curNode
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
curNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
newDivElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
*
aTargetElement
=
std
:
:
move
(
newDivElement
)
;
return
rv
;
}
RefPtr
<
Element
>
targetDivElement
;
RefPtr
<
Element
>
createdListElement
;
RefPtr
<
Element
>
handledListItemElement
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsIContent
*
previousEditableContent
=
createdListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
content
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
nsAtom
*
ULOrOLOrDLTagName
=
atContent
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
targetDivElement
)
{
const
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
atContent
aEditingHost
)
;
if
(
splitNodeResult
.
isOk
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
"
"
failed
"
)
;
return
splitNodeResult
.
unwrapErr
(
)
;
}
splitNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
else
{
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
nsGkAtoms
:
:
"
"
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
createNewDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
targetDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
}
CreateElementResult
createNewListElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
createNewListElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
createNewListElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
createdListElement
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
createdListElement
)
;
}
const
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdListElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
Err
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
moveNodeResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
continue
;
}
if
(
RefPtr
<
Element
>
listItemElement
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
content
&
aEditingHost
)
)
{
if
(
handledListItemElement
=
=
listItemElement
)
{
continue
;
}
nsIContent
*
previousEditableContent
=
createdListElement
?
HTMLEditUtils
:
:
GetPreviousSibling
(
*
listItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
EditorDOMPoint
atListItem
(
listItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
targetDivElement
)
{
const
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
aEditingHost
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
"
"
failed
"
)
;
return
splitNodeResult
.
unwrapErr
(
)
;
}
splitNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
else
{
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
createNewDivElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
targetDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
}
CreateElementResult
createNewListElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
*
containerName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
createNewListElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
"
"
failed
"
)
;
return
createNewListElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
createNewListElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
createdListElement
=
createNewListElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
createdListElement
)
;
}
const
MoveNodeResult
moveListItemElementResult
=
MoveNodeToEndWithTransaction
(
*
listItemElement
*
createdListElement
)
;
if
(
moveListItemElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
Err
(
moveListItemElementResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
moveListItemElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
handledListItemElement
=
std
:
:
move
(
listItemElement
)
;
continue
;
}
if
(
!
targetDivElement
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
targetDivElement
=
content
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
createdListElement
)
;
MOZ_ASSERT
(
!
handledListItemElement
)
;
continue
;
}
CreateElementResult
createNewDivElementResult
=
InsertElementWithSplittingAncestorsWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
BRElementNextToSplitPoint
:
:
Keep
aEditingHost
)
;
if
(
createNewDivElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertElementWithSplittingAncestorsWithTransaction
(
"
"
nsGkAtoms
:
:
div
)
failed
"
)
;
return
createNewDivElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
createNewDivElementResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
createNewDivElementResult
.
GetNewNode
(
)
)
;
targetDivElement
=
createNewDivElementResult
.
UnwrapNewNode
(
)
;
}
const
MoveNodeResult
moveNodeResult
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
targetDivElement
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
moveNodeResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
moveNodeResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
createdListElement
=
nullptr
;
}
*
aTargetElement
=
std
:
:
move
(
targetDivElement
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToStaticAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToStatic
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
element
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
element
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
nsresult
rv
=
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
EditActionResult
HTMLEditor
:
:
AddZIndexAsSubAction
(
int32_t
aChange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
aChange
<
0
?
EditSubAction
:
:
eDecreaseZIndex
:
EditSubAction
:
:
eIncreaseZIndex
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
absolutelyPositionedElement
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
absolutelyPositionedElement
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
nsStyledElement
*
absolutelyPositionedStyledElement
=
nsStyledElement
:
:
FromNode
(
absolutelyPositionedElement
)
;
if
(
NS_WARN_IF
(
!
absolutelyPositionedStyledElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
Result
<
int32_t
nsresult
>
result
=
AddZIndexWithTransaction
(
MOZ_KnownLive
(
*
absolutelyPositionedStyledElement
)
aChange
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AddZIndexWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
unwrapErr
(
)
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
nsresult
HTMLEditor
:
:
OnDocumentModified
(
)
{
if
(
mPendingDocumentModifiedRunner
)
{
return
NS_OK
;
}
mPendingDocumentModifiedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
OnModifyDocument
"
this
&
HTMLEditor
:
:
OnModifyDocument
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingDocumentModifiedRunner
)
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
}
