#
include
"
HTMLEditor
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
using
ChildBlockBoundary
=
HTMLEditUtils
:
:
ChildBlockBoundary
;
using
InvisibleWhiteSpaces
=
HTMLEditUtils
:
:
InvisibleWhiteSpaces
;
using
StyleDifference
=
HTMLEditUtils
:
:
StyleDifference
;
using
TableBoundary
=
HTMLEditUtils
:
:
TableBoundary
;
enum
{
kLonely
=
0
kPrevSib
=
1
kNextSib
=
2
kBothSibs
=
3
}
;
static
bool
IsStyleCachePreservingSubAction
(
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertQuotation
:
case
EditSubAction
:
:
eInsertQuotedText
:
return
true
;
default
:
return
false
;
}
}
class
MOZ_RAII
AutoSetTemporaryAncestorLimiter
final
{
public
:
AutoSetTemporaryAncestorLimiter
(
const
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
nsINode
&
aStartPointNode
AutoRangeArray
*
aRanges
=
nullptr
)
{
MOZ_ASSERT
(
aSelection
.
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
aSelection
.
GetAncestorLimiter
(
)
)
{
return
;
}
Element
*
root
=
aHTMLEditor
.
FindSelectionRoot
(
&
aStartPointNode
)
;
if
(
root
)
{
aHTMLEditor
.
InitializeSelectionAncestorLimit
(
*
root
)
;
mSelection
=
&
aSelection
;
if
(
aRanges
)
{
aRanges
-
>
Initialize
(
aSelection
)
;
}
}
}
~
AutoSetTemporaryAncestorLimiter
(
)
{
if
(
mSelection
)
{
mSelection
-
>
SetAncestorLimiter
(
nullptr
)
;
}
}
private
:
RefPtr
<
Selection
>
mSelection
;
}
;
struct
MOZ_STACK_CLASS
SavedRange
final
{
RefPtr
<
Selection
>
mSelection
;
nsCOMPtr
<
nsINode
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
int32_t
mStartOffset
=
0
;
int32_t
mEndOffset
=
0
;
}
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundary
&
aStartRef
RangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RawRangeBoundary
&
aStartRef
RangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundary
&
aStartRef
RawRangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RawRangeBoundary
&
aStartRef
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RawRangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RawRangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RangeBoundary
&
aPoint
ScanDirection
aScanDirection
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RawRangeBoundary
&
aPoint
ScanDirection
aScanDirection
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RangeBoundary
&
aPoint
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RawRangeBoundary
&
aPoint
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RangeBoundary
&
aPoint
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RawRangeBoundary
&
aPoint
)
;
template
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorDOMPoint
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
template
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorRawDOMPoint
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
template
nsresult
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
;
template
nsresult
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPointInText
&
aStartPoint
const
EditorDOMPointInText
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
;
nsresult
HTMLEditor
:
:
InitEditorContentAndSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
TextEditor
:
:
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
return
rv
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
&
&
!
GetDocument
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
bodyOrDocumentElement
)
{
return
NS_OK
;
}
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
RawRangeBoundary
(
bodyOrDocumentElement
0u
)
RawRangeBoundary
(
bodyOrDocumentElement
bodyOrDocumentElement
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aTopLevelEditSubAction
nsIEditor
:
:
EDirection
aDirectionOfTopLevelEditSubAction
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aTopLevelEditSubAction
aDirectionOfTopLevelEditSubAction
aRv
)
;
MOZ_ASSERT
(
GetTopLevelEditSubAction
(
)
=
=
aTopLevelEditSubAction
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
aDirectionOfTopLevelEditSubAction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
!
mInitSucceeded
)
{
return
;
}
NS_WARNING_ASSERTION
(
!
aRv
.
Failed
(
)
"
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
"
)
;
if
(
GetCompositionStartPoint
(
)
.
IsSet
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
GetCompositionStartPoint
(
)
GetCompositionEndPoint
(
)
)
;
}
else
{
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
*
range
)
;
}
}
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
bool
cacheInlineStyles
;
switch
(
aTopLevelEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
cacheInlineStyles
=
true
;
break
;
default
:
cacheInlineStyles
=
IsStyleCachePreservingSubAction
(
aTopLevelEditSubAction
)
;
break
;
}
if
(
cacheInlineStyles
)
{
nsCOMPtr
<
nsIContent
>
containerContent
=
nsIContent
:
:
FromNodeOrNull
(
aDirectionOfTopLevelEditSubAction
=
=
nsIEditor
:
:
eNext
?
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mEndContainer
:
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mStartContainer
)
;
if
(
NS_WARN_IF
(
!
containerContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
rv
=
CacheInlineStyles
(
*
containerContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CacheInlineStyles
(
)
failed
"
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
=
true
;
}
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
;
while
(
true
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
rv
=
NS_ERROR_EDITOR_DESTROYED
;
break
;
}
if
(
!
mInitSucceeded
)
{
rv
=
NS_OK
;
break
;
}
rv
=
OnEndHandlingTopLevelEditSubActionInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
failied
"
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
*
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
)
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
if
(
document
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
document
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
}
break
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
!
GetTopLevelEditSubAction
(
)
)
;
MOZ_ASSERT
(
GetDirectionOfTopLevelEditSubAction
(
)
=
=
eNone
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eReplaceHeadWithHTMLSource
:
case
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
return
NS_OK
;
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
IsPositioned
(
)
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eUndo
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eRedo
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eDeleteText
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
default
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
GetTopLevelEditSubAction
(
)
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
}
if
(
GetTopLevelEditSubAction
(
)
=
=
EditSubAction
:
:
eDeleteSelectedContent
&
&
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
&
&
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
StartRef
(
)
.
AsRaw
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
break
;
default
:
{
nsresult
rv
=
CollapseAdjacentTextNodes
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
)
failed
"
)
;
return
rv
;
}
break
;
}
}
rv
=
RemoveEmptyNodesIn
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveEmptyNodesIn
(
)
failed
"
)
;
return
rv
;
}
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidNormalizeWhitespaces
)
{
break
;
}
[
[
fallthrough
]
]
;
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
{
EditorRawDOMPoint
pointToAdjust
(
GetCompositionEndPoint
(
)
)
;
if
(
!
pointToAdjust
.
IsSet
(
)
)
{
pointToAdjust
=
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToAdjust
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
pointToAdjust
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartRawPoint
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
*
this
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
EndRawPoint
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
)
"
"
failed
but
ignored
"
)
;
}
break
;
}
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretInBlockElement
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureSelectionInBlockElement
(
)
failed
but
ignored
"
)
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
rv
=
AdjustCaretPositionAndEnsurePaddingBRElement
(
GetDirectionOfTopLevelEditSubAction
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
)
"
"
failed
"
)
;
return
rv
;
}
break
;
default
:
break
;
}
}
bool
reapplyCachedStyle
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
reapplyCachedStyle
=
true
;
break
;
default
:
reapplyCachedStyle
=
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
;
break
;
}
if
(
reapplyCachedStyle
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mTypeInState
-
>
UpdateSelState
(
SelectionRefPtr
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
TypeInState
:
:
UpdateSelState
(
)
failed
but
ignored
"
)
;
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
"
)
;
return
rv
;
}
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
}
rv
=
HandleInlineSpellCheck
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
HandleInlineSpellCheck
(
)
failed
"
)
;
return
rv
;
}
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
SetSelectionInterlinePosition
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
EditActionCanceled
(
)
;
}
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
nsINode
*
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
selStartNode
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selStartNode
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
selEndNode
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
selStartNode
=
=
selEndNode
)
{
return
EditActionIgnored
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
selEndNode
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
commonAncestor
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
commonAncestor
)
{
NS_WARNING
(
"
AbstractRange
:
:
GetClosestCommonInclusiveAncestor
(
)
returned
nullptr
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
return
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
commonAncestor
)
?
EditActionIgnored
(
)
:
EditActionCanceled
(
)
;
}
ListElementSelectionState
:
:
ListElementSelectionState
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
aHTMLEditor
.
CollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
HTMLEditor
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
aRv
=
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
return
;
}
for
(
const
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
mIsOtherContentSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
mIsULElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
mIsOLElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
Element
*
parent
=
content
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
mIsULElementSelected
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
mIsOLElementSelected
=
true
;
}
}
}
else
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
mIsDLElementSelected
=
true
;
}
else
{
mIsOtherContentSelected
=
true
;
}
if
(
mIsULElementSelected
&
&
mIsOLElementSelected
&
&
mIsDLElementSelected
&
&
mIsOtherContentSelected
)
{
break
;
}
}
}
ListItemElementSelectionState
:
:
ListItemElementSelectionState
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
aHTMLEditor
.
CollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
HTMLEditor
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
aRv
=
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
return
;
}
for
(
const
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
mIsOtherElementSelected
=
true
;
}
else
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
mIsLIElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mIsDTElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mIsDDElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
if
(
mIsDTElementSelected
&
&
mIsDDElementSelected
)
{
continue
;
}
DefinitionListItemScanner
scanner
(
*
content
-
>
AsElement
(
)
)
;
mIsDTElementSelected
|
=
scanner
.
DTElementFound
(
)
;
mIsDDElementSelected
|
=
scanner
.
DDElementFound
(
)
;
}
else
{
mIsOtherElementSelected
=
true
;
}
if
(
mIsLIElementSelected
&
&
mIsDTElementSelected
&
&
mIsDDElementSelected
&
&
mIsOtherElementSelected
)
{
break
;
}
}
}
AlignStateAtSelection
:
:
AlignStateAtSelection
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aHTMLEditor
.
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
;
}
if
(
NS_WARN_IF
(
!
aHTMLEditor
.
GetRoot
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
OwningNonNull
<
Element
>
bodyOrDocumentElement
=
*
aHTMLEditor
.
GetRoot
(
)
;
EditorRawDOMPoint
atBodyOrDocumentElement
(
bodyOrDocumentElement
)
;
const
nsRange
*
firstRange
=
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
mFoundSelectionRanges
=
!
!
firstRange
;
if
(
!
mFoundSelectionRanges
)
{
NS_WARNING
(
"
There
was
no
selection
range
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsIContent
*
editTargetContent
=
nullptr
;
if
(
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
|
|
atStartOfSelection
.
IsInTextNode
(
)
)
{
editTargetContent
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
editTargetContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
else
if
(
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atBodyOrDocumentElement
.
IsSet
(
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
atBodyOrDocumentElement
.
Offset
(
)
)
{
editTargetContent
=
aHTMLEditor
.
GetNextEditableNode
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
!
editTargetContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
else
{
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
aHTMLEditor
.
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eSetOrClearAlignment
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
aHTMLEditor
.
CollectEditTargetNodes
(
arrayOfRanges
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollectEditTargetNodes
(
eSetOrClearAlignment
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollectEditTargetNodes
(
eSetOrClearAlignment
"
"
CollectNonEditableNodes
:
:
Yes
)
returned
no
contents
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
editTargetContent
=
arrayOfContents
[
0
]
;
}
RefPtr
<
Element
>
blockElementAtEditTarget
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
editTargetContent
)
;
if
(
NS_WARN_IF
(
!
blockElementAtEditTarget
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
aHTMLEditor
.
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
blockElementAtEditTarget
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedCSSEquivalentToHTMLInlineStyleSet
(
*
blockElementAtEditTarget
nullptr
nsGkAtoms
:
:
align
value
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedCSSEquivalentToHTMLInlineStyleSet
(
nsGkAtoms
:
:
"
"
align
"
"
eComputed
)
failed
but
ignored
"
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
for
(
nsIContent
*
containerContent
:
editTargetContent
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
containerContent
!
=
editTargetContent
&
&
containerContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
containerContent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
containerContent
*
nsGkAtoms
:
:
textAlign
value
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
nsGkAtoms
:
:
"
"
textAlign
)
failed
but
ignored
"
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
}
}
if
(
!
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
containerContent
)
)
{
continue
;
}
nsAutoString
alignAttributeValue
;
containerContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
alignAttributeValue
)
;
if
(
alignAttributeValue
.
IsEmpty
(
)
)
{
continue
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
center
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
right
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
}
MOZ_CAN_RUN_SCRIPT
static
nsStaticAtom
&
MarginPropertyAtomForIndent
(
nsIContent
&
aContent
)
{
nsAutoString
direction
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
aContent
*
nsGkAtoms
:
:
direction
direction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
direction
)
"
"
failed
but
ignored
"
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
ParagraphStateAtSelection
:
:
ParagraphStateAtSelection
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aHTMLEditor
.
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
CollectEditableFormatNodesInSelection
(
aHTMLEditor
arrayOfContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
ParagraphStateAtSelection
:
:
CollectEditableFormatNodesInSelection
(
)
"
"
failed
"
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
for
(
int32_t
i
=
arrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
content
=
arrayOfContents
[
i
]
;
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
arrayOfContents
*
content
-
>
AsElement
(
)
)
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
content
=
atCaret
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
arrayOfContents
.
AppendElement
(
*
content
)
;
}
Element
*
bodyOrDocumentElement
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
for
(
auto
&
content
:
Reversed
(
arrayOfContents
)
)
{
nsAtom
*
paragraphStateOfNode
=
nsGkAtoms
:
:
_empty
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
MOZ_ASSERT
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
paragraphStateOfNode
=
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
else
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
continue
;
}
else
{
for
(
nsINode
*
parentNode
=
content
-
>
GetParentNode
(
)
;
parentNode
;
parentNode
=
parentNode
-
>
GetParentNode
(
)
)
{
if
(
parentNode
=
=
bodyOrDocumentElement
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsFormatNode
(
parentNode
)
)
{
MOZ_ASSERT
(
parentNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
paragraphStateOfNode
=
parentNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
break
;
}
}
}
if
(
!
mFirstParagraphState
)
{
mFirstParagraphState
=
paragraphStateOfNode
;
continue
;
}
if
(
mFirstParagraphState
!
=
paragraphStateOfNode
)
{
mIsMixed
=
true
;
break
;
}
}
}
void
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
Element
&
aNonFormatBlockElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aNonFormatBlockElement
)
)
;
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsFormatNode
(
&
aNonFormatBlockElement
)
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
childContent
=
aNonFormatBlockElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
HTMLEditUtils
:
:
IsBlockElement
(
*
childContent
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
childContent
)
;
if
(
isBlock
&
&
!
isFormat
)
{
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
aArrayOfContents
*
childContent
-
>
AsElement
(
)
)
;
continue
;
}
if
(
isFormat
)
{
aArrayOfContents
.
AppendElement
(
*
childContent
)
;
continue
;
}
MOZ_ASSERT
(
!
isBlock
)
;
if
(
!
foundInline
)
{
foundInline
=
true
;
aArrayOfContents
.
AppendElement
(
*
childContent
)
;
continue
;
}
}
}
nsresult
ParagraphStateAtSelection
:
:
CollectEditableFormatNodesInSelection
(
HTMLEditor
&
aHTMLEditor
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
nsresult
rv
=
aHTMLEditor
.
CollectEditTargetNodesInExtendedSelectionRanges
(
aArrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
for
(
int32_t
i
=
aArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aArrayOfContents
[
i
]
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
aArrayOfContents
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
aArrayOfContents
.
RemoveElementAt
(
i
)
;
aHTMLEditor
.
CollectChildren
(
content
aArrayOfContents
i
HTMLEditor
:
:
CollectListChildren
:
:
Yes
HTMLEditor
:
:
CollectTableChildren
:
:
Yes
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atSelectionStart
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atSelectionStart
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
GetPreviousEditableHTMLNode
(
atSelectionStart
)
;
if
(
!
previousEditableContent
|
|
!
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
previousEditableContent
)
)
{
return
NS_OK
;
}
if
(
!
atSelectionStart
.
IsInContentNode
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
blockElementAtSelectionStart
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
atSelectionStart
.
ContainerAsContent
(
)
)
;
RefPtr
<
Element
>
parentBlockElementOfPreviousEditableContent
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
previousEditableContent
)
;
if
(
!
blockElementAtSelectionStart
|
|
blockElementAtSelectionStart
!
=
parentBlockElementOfPreviousEditableContent
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atPreviousEditableContent
(
previousEditableContent
)
;
nsresult
rv
=
CollapseSelectionTo
(
atPreviousEditableContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReapplyCachedStyles
(
)
failed
"
)
;
return
rv
;
}
break
;
}
default
:
break
;
}
}
if
(
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
"
"
nsIEditor
:
:
eNoStrip
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
const
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
rv
=
CreateStyleForInsertText
(
*
firstRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateStyleForInsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
pointToInsert
.
IsInTextNode
(
)
&
&
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
NS_WARNING
(
"
Selection
start
container
couldn
'
t
have
text
nodes
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
pointToInsert
;
}
if
(
aInsertionString
.
IsEmpty
(
)
)
{
nsresult
rv
=
InsertTextWithTransaction
(
*
document
aInsertionString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditorRawDOMPoint
compositionEndPoint
=
GetCompositionEndPoint
(
)
;
if
(
!
compositionEndPoint
.
IsSet
(
)
)
{
compositionEndPoint
=
compositionStartPoint
;
}
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
*
this
aInsertionString
EditorDOMRange
(
compositionStartPoint
compositionEndPoint
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
compositionEndPoint
=
GetCompositionEndPoint
(
)
;
if
(
NS_WARN_IF
(
!
compositionStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
compositionEndPoint
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
)
;
}
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
compositionStartPoint
.
ToRawRangeBoundary
(
)
compositionEndPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
bool
isPRE
=
EditorUtils
:
:
IsContentPreformatted
(
*
pointToInsert
.
ContainerAsContent
(
)
)
;
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
int32_t
pos
=
0
;
constexpr
auto
newlineStr
=
NS_LITERAL_STRING_FROM_CSTRING
(
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
isPRE
|
|
IsPlaintextEditor
(
)
)
{
while
(
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
aInsertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
aInsertionString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
aInsertionString
.
Length
(
)
-
oldPos
;
pos
=
aInsertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
aInsertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
eNone
)
failed
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
pos
+
+
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
brElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
"
"
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
subStr
EditorRawDOMPoint
(
currentPoint
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
else
{
constexpr
auto
tabStr
=
u
"
\
t
"
_ns
;
constexpr
auto
spacesStr
=
u
"
"
_ns
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
nsAutoString
insertionString
(
aInsertionString
)
;
while
(
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
insertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
insertionString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
insertionString
.
Length
(
)
-
oldPos
;
pos
=
insertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
insertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
spacesStr
currentPoint
&
pointAfterInsertedSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
pos
+
+
;
MOZ_ASSERT
(
pointAfterInsertedSpaces
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedSpaces
;
pointToInsert
=
pointAfterInsertedSpaces
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
currentPoint
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
inspectErr
(
)
)
;
}
pos
+
+
;
RefPtr
<
Element
>
newBRElement
=
result
.
unwrap
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
newBRElement
)
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
SetAfter
(
newBRElement
)
;
NS_WARNING_ASSERTION
(
currentPoint
.
IsSet
(
)
"
Failed
to
set
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
*
this
subStr
currentPoint
&
pointAfterInsertedString
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertText
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
pointAfterInsertedString
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
if
(
currentPoint
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
currentPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
}
if
(
currentPoint
.
IsSet
(
)
)
{
nsresult
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
currentPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
CollapseTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertParagraphSeparator
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsMailEditor
(
)
)
{
EditorDOMPoint
pointToSplit
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
SplitMailCiteElements
(
pointToSplit
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitMailCiteElements
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
Handled
(
)
)
{
return
result
;
}
}
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
blockElement
=
atStartOfSelection
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
atStartOfSelection
.
ContainerAsContent
(
)
editingHost
)
:
nullptr
;
ParagraphSeparator
separator
=
GetDefaultParagraphSeparator
(
)
;
bool
insertBRElement
;
if
(
!
blockElement
)
{
insertBRElement
=
true
;
}
else
if
(
editingHost
=
=
blockElement
)
{
insertBRElement
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
editingHost
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
blockElement
)
)
{
insertBRElement
=
false
;
}
else
{
insertBRElement
=
true
;
for
(
Element
*
blockAncestor
=
blockElement
;
blockAncestor
&
&
insertBRElement
;
blockAncestor
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
blockAncestor
editingHost
)
)
{
insertBRElement
=
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
blockAncestor
)
;
}
}
if
(
insertBRElement
)
{
nsresult
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
if
(
editingHost
=
=
blockElement
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
FormatBlockContainerWithTransaction
(
MOZ_KnownLive
(
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
separator
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
blockElement
=
atStartOfSelection
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
atStartOfSelection
.
ContainerAsContent
(
)
editingHost
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
blockElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
NS_WARN_IF
(
blockElement
=
=
editingHost
)
)
{
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
blockElement
;
}
if
(
IsEmptyBlockElement
(
*
blockElement
IgnoreSingleBR
:
:
No
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditorDOMPoint
endOfBlockParent
;
endOfBlockParent
.
SetToEndOf
(
blockElement
)
;
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
endOfBlockParent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
}
RefPtr
<
Element
>
listItem
=
GetNearestAncestorListItemElement
(
*
blockElement
)
;
if
(
listItem
&
&
listItem
!
=
editingHost
)
{
nsresult
rv
=
HandleInsertParagraphInListItemElement
(
*
listItem
MOZ_KnownLive
(
*
atStartOfSelection
.
GetContainer
(
)
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
)
"
"
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
blockElement
)
)
{
nsresult
rv
=
HandleInsertParagraphInHeadingElement
(
*
blockElement
MOZ_KnownLive
(
*
atStartOfSelection
.
GetContainer
(
)
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
)
"
"
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
blockElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
blockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditActionResult
result
=
HandleInsertParagraphInParagraph
(
*
blockElement
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
Handled
(
)
)
{
lockOffset
.
Cancel
(
)
;
return
result
;
}
MOZ_ASSERT
(
!
result
.
Canceled
(
)
"
HandleInsertParagraphInParagraph
(
)
canceled
this
edit
action
"
"
InsertParagraphSeparatorAsSubAction
(
)
needs
to
handle
this
"
"
action
instead
"
)
;
}
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
brElementIsAfterBlock
=
false
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsPlaintextEditor
(
)
)
{
brElement
=
InsertBRElementWithTransaction
(
aPointToBreak
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunScanner
wsRunScanner
(
*
this
pointToBreak
)
;
brElementIsAfterBlock
=
wsRunScanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
.
ReachedBlockBoundary
(
)
;
brElementIsBeforeBlock
=
wsRunScanner
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
pointToBreak
)
.
ReachedBlockBoundary
(
)
;
RefPtr
<
Element
>
linkNode
=
HTMLEditor
:
:
GetLinkElement
(
pointToBreak
.
GetContainer
(
)
)
;
if
(
linkNode
)
{
SplitNodeResult
splitLinkNodeResult
=
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitLinkNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitLinkNodeResult
.
Rv
(
)
;
}
pointToBreak
=
splitLinkNodeResult
.
SplitPoint
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
*
this
pointToBreak
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
)
failed
"
)
;
return
result
.
inspectErr
(
)
;
}
brElement
=
result
.
unwrap
(
)
;
MOZ_ASSERT
(
brElement
)
;
}
if
(
NS_WARN_IF
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
brElement
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
afterBRElement
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
WSScanResult
forwardScanFromAfterBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
afterBRElement
)
;
if
(
forwardScanFromAfterBRElementResult
.
ReachedBRElement
(
)
)
{
if
(
brElement
-
>
GetNextSibling
(
)
!
=
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
{
MOZ_ASSERT
(
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
afterBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
!
(
nextSiblingOfBRElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSiblingOfBRElement
)
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
afterBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
SplitMailCiteElements
(
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
RefPtr
<
Element
>
citeNode
=
GetMostAncestorMailCiteElement
(
*
aPointToSplit
.
GetContainer
(
)
)
;
if
(
!
citeNode
)
{
return
EditActionIgnored
(
)
;
}
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
WSScanResult
forwardScanFromPointToSplitResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
pointToSplit
)
;
if
(
forwardScanFromPointToSplitResult
.
ReachedBRElement
(
)
&
&
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
!
=
citeNode
&
&
citeNode
-
>
Contains
(
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
)
)
{
pointToSplit
=
forwardScanFromPointToSplitResult
.
PointAfterContent
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitCiteNodeResult
=
SplitNodeDeepWithTransaction
(
*
citeNode
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
splitCiteNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
EditActionIgnored
(
splitCiteNodeResult
.
Rv
(
)
)
;
}
pointToSplit
.
Clear
(
)
;
nsIContent
*
previousNodeOfSplitPoint
=
splitCiteNodeResult
.
GetPreviousNode
(
)
;
if
(
previousNodeOfSplitPoint
&
&
previousNodeOfSplitPoint
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsCOMPtr
<
nsINode
>
lastChild
=
previousNodeOfSplitPoint
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorDOMPoint
endOfPreviousNodeOfSplitPoint
;
endOfPreviousNodeOfSplitPoint
.
SetToEndOf
(
previousNodeOfSplitPoint
)
;
RefPtr
<
Element
>
invisibleBRElement
=
InsertBRElementWithTransaction
(
endOfPreviousNodeOfSplitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
invisibleBRElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
but
ignored
"
)
;
}
}
EditorDOMPoint
pointToInsertBRNode
(
splitCiteNodeResult
.
SplitPoint
(
)
)
;
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
pointToInsertBRNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
pointToInsertBRNode
.
Clear
(
)
;
EditorDOMPoint
atBRElement
(
brElement
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atBRElement
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
atBRElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
*
citeNode
)
)
{
EditorDOMPoint
pointToCreateNewBRElement
(
atBRElement
)
;
WSScanResult
backwardScanFromPointToCreateNewBRElementResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
*
this
pointToCreateNewBRElement
)
;
if
(
backwardScanFromPointToCreateNewBRElementResult
.
InNormalWhiteSpacesOrText
(
)
|
|
backwardScanFromPointToCreateNewBRElementResult
.
ReachedSpecialContent
(
)
)
{
EditorRawDOMPoint
pointAfterNewBRElement
(
EditorRawDOMPoint
:
:
After
(
pointToCreateNewBRElement
)
)
;
NS_WARNING_ASSERTION
(
pointAfterNewBRElement
.
IsSet
(
)
"
Failed
to
set
to
after
the
<
br
>
node
"
)
;
WSScanResult
forwardScanFromPointAfterNewBRElementResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
pointAfterNewBRElement
)
;
if
(
forwardScanFromPointAfterNewBRElementResult
.
InNormalWhiteSpacesOrText
(
)
|
|
forwardScanFromPointAfterNewBRElementResult
.
ReachedSpecialContent
(
)
|
|
forwardScanFromPointAfterNewBRElementResult
.
ReachedCurrentBlockBoundary
(
)
)
{
brElement
=
InsertBRElementWithTransaction
(
pointToCreateNewBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
pointToCreateNewBRElement
.
Clear
(
)
;
pointAfterNewBRElement
.
Clear
(
)
;
}
}
}
if
(
previousNodeOfSplitPoint
&
&
IsEmptyNode
(
*
previousNodeOfSplitPoint
true
false
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
previousNodeOfSplitPoint
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
if
(
citeNode
&
&
IsEmptyNode
(
*
citeNode
true
false
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionIgnored
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoDeleteRangesHandler
final
{
public
:
explicit
AutoDeleteRangesHandler
(
const
AutoDeleteRangesHandler
*
aParent
=
nullptr
)
:
mParent
(
aParent
)
mOriginalDirectionAndAmount
(
nsIEditor
:
:
eNone
)
mOriginalStripWrappers
(
nsIEditor
:
:
eNoStrip
)
{
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
;
private
:
bool
IsHandlingRecursively
(
)
const
{
return
mParent
!
=
nullptr
;
}
bool
CanFallbackToDeleteRangesWithTransaction
(
const
AutoRangeArray
&
aRangesToDelete
)
const
{
return
!
IsHandlingRecursively
(
)
&
&
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
&
&
(
!
aRangesToDelete
.
IsCollapsed
(
)
|
|
EditorBase
:
:
HowToHandleCollapsedRangeFor
(
mOriginalDirectionAndAmount
)
!
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
Ignore
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
;
nsresult
ComputeRangesToDeleteAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
const
;
enum
class
SelectionWasCollapsed
{
Yes
No
}
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteTextAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
;
nsresult
ComputeRangesToDeleteTextAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteCollapsedSelectionAtVisibleChar
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteAtomicContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
;
nsresult
ComputeRangesToDeleteAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
const
nsIContent
&
aAtomicContent
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteHRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
;
nsresult
ComputeRangesToDeleteHRElement
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
WSRunScanner
&
aWSRunScannerAtCaret
AutoRangeArray
&
aRangesToDelete
)
;
bool
ExtendRangeToIncludeInvisibleNodes
(
const
HTMLEditor
&
aHTMLEditor
const
nsFrameSelection
*
aFrameSelection
nsRange
&
aRange
)
;
Result
<
bool
nsresult
>
ShouldDeleteHRElement
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteUnnecessaryNodesAndCollapseSelection
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteNodeIfInvisibleAndEditableTextNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteParentBlocksWithTransactionIfEmpty
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
FallbackToDeleteRangesWithTransaction
(
HTMLEditor
&
aHTMLEditor
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
mOriginalDirectionAndAmount
mOriginalStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
class
MOZ_STACK_CLASS
AutoBlockElementsJoiner
final
{
public
:
AutoBlockElementsJoiner
(
)
=
delete
;
explicit
AutoBlockElementsJoiner
(
AutoDeleteRangesHandler
&
aDeleteRangesHandler
)
:
mDeleteRangesHandler
(
aDeleteRangesHandler
)
{
}
bool
PrepareToDeleteCollapsedSelectionAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
;
bool
PrepareToDeleteCollapsedSelectionAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
;
bool
PrepareToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
const
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
)
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
{
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
aHTMLEditor
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
JoinOtherBlock
:
{
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aCaretPoint
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteBRElement
:
{
EditActionResult
result
=
DeleteBRElement
(
aHTMLEditor
aDirectionAndAmount
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
DeleteBRElement
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
JoinBlocksInSameParent
:
case
Mode
:
:
DeleteContentInRanges
:
case
Mode
:
:
DeleteNonCollapsedRanges
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
Run
(
)
"
)
;
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
case
Mode
:
:
NotInitialized
:
return
EditActionIgnored
(
)
;
}
return
EditActionResult
(
NS_ERROR_NOT_INITIALIZED
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
case
Mode
:
:
JoinOtherBlock
:
case
Mode
:
:
DeleteBRElement
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
Run
(
)
"
)
;
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
case
Mode
:
:
JoinBlocksInSameParent
:
{
EditActionResult
result
=
JoinBlockElementsInSameParent
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
"
"
JoinBlockElementsInSameParent
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteContentInRanges
:
{
EditActionResult
result
=
DeleteContentInRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
DeleteContentInRanges
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteNonCollapsedRanges
:
{
EditActionResult
result
=
HandleDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
aSelectionWasCollapsed
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteNonCollapsedRange
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
NotInitialized
:
MOZ_ASSERT_UNREACHABLE
(
"
Call
Run
(
)
after
calling
a
preparation
method
"
)
;
return
EditActionIgnored
(
)
;
}
return
EditActionResult
(
NS_ERROR_NOT_INITIALIZED
)
;
}
nsIContent
*
GetLeafContentInOtherBlockElement
(
)
const
{
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
JoinOtherBlock
)
;
return
mLeafContentInOtherBlock
;
}
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
JoinBlockElementsInSameParent
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
DeleteBRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
DeleteContentInRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
;
MOZ_CAN_RUN_SCRIPT
Result
<
EditorDOMPoint
nsresult
>
JoinNodesDeepWithTransaction
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
;
MOZ_CAN_RUN_SCRIPT
Result
<
bool
nsresult
>
DeleteNodesEntirelyInRangeButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteContentButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTextAtStartAndEndOfRange
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
)
;
class
MOZ_STACK_CLASS
AutoInclusiveAncestorBlockElementsJoiner
final
{
public
:
AutoInclusiveAncestorBlockElementsJoiner
(
)
=
delete
;
AutoInclusiveAncestorBlockElementsJoiner
(
nsIContent
&
aInclusiveDescendantOfLeftBlockElement
nsIContent
&
aInclusiveDescendantOfRightBlockElement
)
:
mInclusiveDescendantOfLeftBlockElement
(
aInclusiveDescendantOfLeftBlockElement
)
mInclusiveDescendantOfRightBlockElement
(
aInclusiveDescendantOfRightBlockElement
)
mCanJoinBlocks
(
false
)
{
}
bool
IsSet
(
)
const
{
return
mLeftBlockElement
&
&
mRightBlockElement
;
}
bool
IsSameBlockElement
(
)
const
{
return
mLeftBlockElement
&
&
mLeftBlockElement
=
=
mRightBlockElement
;
}
Result
<
bool
nsresult
>
Prepare
(
)
;
bool
CanJoinBlocks
(
)
const
{
return
mCanJoinBlocks
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
Run
(
HTMLEditor
&
aHTMLEditor
)
;
private
:
OwningNonNull
<
nsIContent
>
mInclusiveDescendantOfLeftBlockElement
;
OwningNonNull
<
nsIContent
>
mInclusiveDescendantOfRightBlockElement
;
RefPtr
<
Element
>
mLeftBlockElement
;
RefPtr
<
Element
>
mRightBlockElement
;
Maybe
<
nsAtom
*
>
mNewListElementTagNameOfRightListElement
;
bool
mCanJoinBlocks
;
}
;
enum
class
Mode
{
NotInitialized
JoinCurrentBlock
JoinOtherBlock
JoinBlocksInSameParent
DeleteBRElement
DeleteContentInRanges
DeleteNonCollapsedRanges
}
;
AutoDeleteRangesHandler
&
mDeleteRangesHandler
;
nsCOMPtr
<
nsIContent
>
mLeftContent
;
nsCOMPtr
<
nsIContent
>
mRightContent
;
nsCOMPtr
<
nsIContent
>
mLeafContentInOtherBlock
;
RefPtr
<
dom
:
:
HTMLBRElement
>
mBRElement
;
Mode
mMode
=
Mode
:
:
NotInitialized
;
}
;
class
MOZ_STACK_CLASS
AutoEmptyBlockAncestorDeleter
final
{
public
:
[
[
nodiscard
]
]
Element
*
ScanEmptyBlockInclusiveAncestor
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aStartContent
Element
&
aEditingHostElement
)
;
nsresult
ComputeTargetRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
EditActionResult
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
RefPtr
<
Element
>
nsresult
>
MaybeInsertBRElementBeforeEmptyListItemElement
(
HTMLEditor
&
aHTMLEditor
)
;
[
[
nodiscard
]
]
Result
<
EditorDOMPoint
nsresult
>
GetNewCaretPoisition
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
const
;
RefPtr
<
Element
>
mEmptyInclusiveAncestorBlockElement
;
}
;
const
AutoDeleteRangesHandler
*
const
mParent
;
nsIEditor
:
:
EDirection
mOriginalDirectionAndAmount
;
nsIEditor
:
:
EStripWrappers
mOriginalStripWrappers
;
}
;
nsresult
HTMLEditor
:
:
ComputeTargetRanges
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
AutoDeleteRangesHandler
deleteHandler
;
nsresult
rv
=
deleteHandler
.
ComputeRangesToDelete
(
*
this
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
=
true
;
if
(
mPaddingBRElementForEmptyEditor
)
{
return
EditActionCanceled
(
)
;
}
ErrorResult
error
;
if
(
RefPtr
<
Element
>
cellElement
=
GetFirstSelectedTableCellElement
(
error
)
)
{
error
.
SuppressException
(
)
;
nsresult
rv
=
DeleteTableCellContentsWithTransaction
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableCellContentsWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstSelectedTableCellElement
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
AutoRangeArray
rangesToDelete
(
*
SelectionRefPtr
(
)
)
;
AutoDeleteRangesHandler
deleteHandler
;
EditActionResult
result
=
deleteHandler
.
Run
(
*
this
aDirectionAndAmount
aStripWrappers
rangesToDelete
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
result
;
}
EditorDOMPoint
atNewStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atNewStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atNewStartOfSelection
.
GetContainerAsContent
(
)
)
{
nsresult
rv
=
DeleteMostAncestorMailCiteElementIfEmpty
(
MOZ_KnownLive
(
*
atNewStartOfSelection
.
GetContainerAsContent
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteMostAncestorMailCiteElementIfEmpty
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
mOriginalDirectionAndAmount
=
aDirectionAndAmount
;
mOriginalStripWrappers
=
aStripWrappers
;
if
(
aHTMLEditor
.
mPaddingBRElementForEmptyEditor
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
EditorRawDOMPoint
(
aHTMLEditor
.
mPaddingBRElementForEmptyEditor
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
SelectionWasCollapsed
selectionWasCollapsed
=
aRangesToDelete
.
IsCollapsed
(
)
?
SelectionWasCollapsed
:
:
Yes
:
SelectionWasCollapsed
:
:
No
;
if
(
selectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
EditorDOMPoint
startPoint
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startPoint
.
GetContainerAsContent
(
)
)
{
AutoEmptyBlockAncestorDeleter
deleter
;
if
(
deleter
.
ScanEmptyBlockInclusiveAncestor
(
aHTMLEditor
*
startPoint
.
GetContainerAsContent
(
)
*
editingHost
)
)
{
nsresult
rv
=
deleter
.
ComputeTargetRanges
(
aHTMLEditor
aDirectionAndAmount
*
editingHost
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoEmptyBlockAncestorDeleter
:
:
ComputeTargetRanges
(
)
failed
"
)
;
return
rv
;
}
}
AutoCaretBidiLevelManager
bidiLevelManager
(
aHTMLEditor
aDirectionAndAmount
startPoint
)
;
if
(
bidiLevelManager
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
AutoCaretBidiLevelManager
failed
to
initialize
itself
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
bidiLevelManager
.
Canceled
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
AutoSetTemporaryAncestorLimiter
autoSetter
(
aHTMLEditor
*
aHTMLEditor
.
SelectionRefPtr
(
)
*
startPoint
.
GetContainer
(
)
&
aRangesToDelete
)
;
Result
<
nsIEditor
:
:
EDirection
nsresult
>
extendResult
=
aRangesToDelete
.
ExtendAnchorFocusRangeFor
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
extendResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
)
failed
"
)
;
return
extendResult
.
unwrapErr
(
)
;
}
Result
<
bool
nsresult
>
shrunkenResult
=
aRangesToDelete
.
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
aHTMLEditor
aDirectionAndAmount
AutoRangeArray
:
:
IfSelectingOnlyOneAtomicContent
:
:
Collapse
editingHost
)
;
if
(
shrunkenResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
)
"
"
failed
"
)
;
return
shrunkenResult
.
unwrapErr
(
)
;
}
if
(
!
shrunkenResult
.
inspect
(
)
|
|
!
aRangesToDelete
.
IsCollapsed
(
)
)
{
aDirectionAndAmount
=
extendResult
.
unwrap
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNone
)
{
MOZ_ASSERT
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
;
if
(
!
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
return
NS_OK
;
}
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
EditorDOMPoint
caretPoint
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
if
(
NS_WARN_IF
(
!
caretPoint
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
caretPoint
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
WSRunScanner
wsRunScannerAtCaret
(
aHTMLEditor
caretPoint
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
)
;
if
(
!
scanFromCaretPointResult
.
GetContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
scanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
scanFromCaretPointResult
.
BRElementPtr
(
)
=
=
wsRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
EditorType
:
:
HTML
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
!
aHTMLEditor
.
IsVisibleBRElement
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
{
return
NS_OK
;
}
}
nsresult
rv
=
ComputeRangesToDeleteAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
wsRunScannerAtCaret
scanFromCaretPointResult
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAroundCollapsedRanges
(
"
"
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
mOriginalDirectionAndAmount
=
aDirectionAndAmount
;
mOriginalStripWrappers
=
aStripWrappers
;
if
(
aHTMLEditor
.
mPaddingBRElementForEmptyEditor
)
{
return
EditActionCanceled
(
)
;
}
SelectionWasCollapsed
selectionWasCollapsed
=
aRangesToDelete
.
IsCollapsed
(
)
?
SelectionWasCollapsed
:
:
Yes
:
SelectionWasCollapsed
:
:
No
;
if
(
selectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
EditorDOMPoint
startPoint
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
GetActiveEditingHost
(
)
;
if
(
startPoint
.
GetContainerAsContent
(
)
)
{
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
#
ifdef
DEBUG
nsMutationGuard
debugMutation
;
#
endif
AutoEmptyBlockAncestorDeleter
deleter
;
if
(
deleter
.
ScanEmptyBlockInclusiveAncestor
(
aHTMLEditor
*
startPoint
.
GetContainerAsContent
(
)
*
editingHost
)
)
{
EditActionResult
result
=
deleter
.
Run
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Handled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoEmptyBlockAncestorDeleter
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
MOZ_ASSERT
(
!
debugMutation
.
Mutated
(
0
)
"
AutoEmptyBlockAncestorDeleter
shouldn
'
t
modify
the
DOM
tree
"
"
if
it
returns
not
handled
nor
error
"
)
;
}
AutoCaretBidiLevelManager
bidiLevelManager
(
aHTMLEditor
aDirectionAndAmount
startPoint
)
;
if
(
bidiLevelManager
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
AutoCaretBidiLevelManager
failed
to
initialize
itself
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
bidiLevelManager
.
MaybeUpdateCaretBidiLevel
(
aHTMLEditor
)
;
if
(
bidiLevelManager
.
Canceled
(
)
)
{
return
EditActionCanceled
(
)
;
}
AutoSetTemporaryAncestorLimiter
autoSetter
(
aHTMLEditor
*
aHTMLEditor
.
SelectionRefPtr
(
)
*
startPoint
.
GetContainer
(
)
&
aRangesToDelete
)
;
Maybe
<
EditorDOMPoint
>
caretPoint
;
if
(
aRangesToDelete
.
IsCollapsed
(
)
&
&
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
{
caretPoint
=
Some
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
if
(
NS_WARN_IF
(
!
caretPoint
.
ref
(
)
.
IsInContentNode
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
Result
<
nsIEditor
:
:
EDirection
nsresult
>
extendResult
=
aRangesToDelete
.
ExtendAnchorFocusRangeFor
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
extendResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
)
failed
"
)
;
return
EditActionResult
(
extendResult
.
unwrapErr
(
)
)
;
}
if
(
caretPoint
.
isSome
(
)
&
&
!
caretPoint
.
ref
(
)
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
The
caret
position
became
invalid
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
Result
<
bool
nsresult
>
shrunkenResult
=
aRangesToDelete
.
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
aHTMLEditor
aDirectionAndAmount
AutoRangeArray
:
:
IfSelectingOnlyOneAtomicContent
:
:
Collapse
editingHost
)
;
if
(
shrunkenResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
)
"
"
failed
"
)
;
return
EditActionResult
(
shrunkenResult
.
unwrapErr
(
)
)
;
}
if
(
!
shrunkenResult
.
inspect
(
)
|
|
!
aRangesToDelete
.
IsCollapsed
(
)
)
{
aDirectionAndAmount
=
extendResult
.
unwrap
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNone
)
{
MOZ_ASSERT
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
;
if
(
!
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
EditActionIgnored
(
)
;
}
EditActionResult
result
=
FallbackToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
"
"
FallbackToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
result
;
}
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
caretPoint
.
ref
(
)
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
return
EditActionCanceled
(
)
;
}
WSRunScanner
wsRunScannerAtCaret
(
aHTMLEditor
caretPoint
.
ref
(
)
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
;
if
(
!
scanFromCaretPointResult
.
GetContent
(
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
scanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
scanFromCaretPointResult
.
BRElementPtr
(
)
=
=
wsRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
EditorType
:
:
HTML
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
!
aHTMLEditor
.
IsVisibleBRElement
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
aHTMLEditor
MOZ_KnownLive
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
caretPoint
.
ref
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
DeleteContentNodeAndJoinTextNodesAroundIt
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
RangeCount
(
)
!
=
1
)
{
NS_WARNING
(
"
Selection
was
unexpected
after
removing
an
invisible
<
br
>
"
"
element
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
AutoRangeArray
rangesToDelete
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
;
caretPoint
=
Some
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
if
(
!
caretPoint
.
ref
(
)
.
IsSet
(
)
)
{
NS_WARNING
(
"
New
selection
after
deleting
invisible
<
br
>
element
was
"
"
invalid
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
aHTMLEditor
.
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
)
)
{
WSRunScanner
wsRunScannerAtCaret
(
aHTMLEditor
caretPoint
.
ref
(
)
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
;
if
(
scanFromCaretPointResult
.
ReachedBRElement
(
)
&
&
!
aHTMLEditor
.
IsVisibleBRElement
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
AutoDeleteRangesHandler
anotherHandler
(
this
)
;
EditActionResult
result
=
anotherHandler
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
rangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Recursive
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
EditActionResult
result
=
HandleDeleteAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
wsRunScannerAtCaret
scanFromCaretPointResult
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteAroundCollapsedRanges
(
)
failed
"
)
;
return
result
;
}
}
EditActionResult
result
=
HandleDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
selectionWasCollapsed
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
HandleDeleteNonCollapsedRanges
(
)
failed
"
)
;
return
result
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
const
{
if
(
aScanFromCaretPointResult
.
InNormalWhiteSpaces
(
)
|
|
aScanFromCaretPointResult
.
InNormalText
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aScanFromCaretPointResult
.
Point
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
ComputeRangesToDeleteTextAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteTextAroundCollapsedRanges
(
)
failed
"
)
;
return
rv
;
}
if
(
aScanFromCaretPointResult
.
ReachedSpecialContent
(
)
|
|
aScanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ComputeRangesToDeleteAtomicContent
(
aHTMLEditor
*
aScanFromCaretPointResult
.
GetContent
(
)
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
)
failed
"
)
;
return
rv
;
}
if
(
aScanFromCaretPointResult
.
ReachedHRElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ComputeRangesToDeleteHRElement
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteHRElement
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
!
=
nsIEditor
:
:
eNone
)
;
MOZ_ASSERT
(
aWSRunScannerAtCaret
.
ScanStartRef
(
)
.
IsInContentNode
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aWSRunScannerAtCaret
.
ScanStartRef
(
)
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
;
if
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
if
(
aScanFromCaretPointResult
.
InNormalWhiteSpaces
(
)
|
|
aScanFromCaretPointResult
.
InNormalText
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aScanFromCaretPointResult
.
Point
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteTextAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteTextAroundCollapsedRanges
(
)
failed
"
)
;
return
result
;
}
}
if
(
aScanFromCaretPointResult
.
InNormalWhiteSpaces
(
)
)
{
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
aHTMLEditor
aDirectionAndAmount
aWSRunScannerAtCaret
.
ScanStartRef
(
)
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
"
"
HandleDelectCollapsedSelectionAtWhiteSpaces
(
)
"
"
failed
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
InNormalText
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsText
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtVisibleChar
(
aHTMLEditor
aDirectionAndAmount
aScanFromCaretPointResult
.
Point
(
)
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteCollapsedSelectionAtVisibleChar
(
)
"
"
failed
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
ReachedSpecialContent
(
)
|
|
aScanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
EditActionHandled
(
)
;
}
EditActionResult
result
=
HandleDeleteAtomicContent
(
aHTMLEditor
MOZ_KnownLive
(
*
aScanFromCaretPointResult
.
GetContent
(
)
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
HandleDeleteAtomicContent
(
)
failed
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
ReachedHRElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
EditActionHandled
(
)
;
}
EditActionResult
result
=
HandleDeleteHRElement
(
aHTMLEditor
aDirectionAndAmount
MOZ_KnownLive
(
*
aScanFromCaretPointResult
.
ElementPtr
(
)
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
HandleDeleteHRElement
(
)
failed
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
ReachedOtherBlockElement
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteCollapsedSelectionAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
)
)
{
return
EditActionCanceled
(
)
;
}
EditActionResult
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
(
other
block
boundary
)
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteCollapsedSelectionAtCurrentBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
EditActionResult
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
(
current
block
boundary
)
"
)
;
return
result
;
}
MOZ_ASSERT_UNREACHABLE
(
"
New
type
of
reached
content
hasn
'
t
been
handled
yet
"
)
;
return
EditActionIgnored
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteTextAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
;
EditorDOMPoint
caretPosition
(
aRangesToDelete
.
GetStartPointOfFirstRange
(
)
)
;
MOZ_ASSERT
(
caretPosition
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
caretPosition
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
Result
<
EditorDOMRangeInTexts
nsresult
>
result
=
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
aHTMLEditor
caretPosition
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
rangeToDelete
=
result
.
unwrap
(
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
return
NS_OK
;
}
}
else
{
Result
<
EditorDOMRangeInTexts
nsresult
>
result
=
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
aHTMLEditor
caretPosition
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
rangeToDelete
=
result
.
unwrap
(
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
return
NS_OK
;
}
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
rangeToDelete
.
StartRef
(
)
rangeToDelete
.
EndRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoArrayRanges
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteTextAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
;
nsresult
rv
=
ComputeRangesToDeleteTextAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
return
EditActionHandled
(
)
;
}
EditorRawDOMRange
rangeToDelete
(
aRangesToDelete
.
FirstRangeRef
(
)
)
;
if
(
!
rangeToDelete
.
IsInTextNodes
(
)
)
{
NS_WARNING
(
"
The
extended
range
to
delete
character
was
not
in
text
nodes
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
Result
<
EditorDOMPoint
nsresult
>
result
=
aHTMLEditor
.
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
rangeToDelete
.
StartRef
(
)
.
AsInText
(
)
rangeToDelete
.
EndRef
(
)
.
AsInText
(
)
TreatEmptyTextNodes
:
:
RemoveAllEmptyInlineAncestors
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
DeleteDirection
:
:
Forward
:
DeleteDirection
:
:
Backward
)
;
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidNormalizeWhitespaces
=
true
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
unwrapErr
(
)
)
;
}
const
EditorDOMPoint
&
newCaretPosition
=
result
.
inspect
(
)
;
MOZ_ASSERT
(
newCaretPosition
.
IsSetAndValid
(
)
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
CollapseInLimiter
(
newCaretPosition
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
aHTMLEditor
aPointToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
else
{
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
aHTMLEditor
aPointToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteCollapsedSelectionAtVisibleChar
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPointToDelete
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aPointToDelete
.
IsInTextNode
(
)
)
;
OwningNonNull
<
Text
>
visibleTextNode
=
*
aPointToDelete
.
GetContainerAsText
(
)
;
EditorDOMPoint
startToDelete
endToDelete
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
aPointToDelete
.
IsStartOfContainer
(
)
)
{
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
}
startToDelete
=
aPointToDelete
.
PreviousPoint
(
)
;
endToDelete
=
aPointToDelete
;
if
(
!
startToDelete
.
IsStartOfContainer
(
)
)
{
const
nsTextFragment
*
text
=
&
visibleTextNode
-
>
TextFragment
(
)
;
if
(
text
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
startToDelete
.
Offset
(
)
)
)
{
startToDelete
.
RewindOffset
(
)
;
}
}
}
else
{
RefPtr
<
const
nsRange
>
range
=
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
range
-
>
GetStartContainer
(
)
!
=
aPointToDelete
.
GetContainer
(
)
)
|
|
NS_WARN_IF
(
range
-
>
GetEndContainer
(
)
!
=
aPointToDelete
.
GetContainer
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
startToDelete
=
range
-
>
StartRef
(
)
;
endToDelete
=
range
-
>
EndRef
(
)
;
}
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
aHTMLEditor
.
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
IsInTextNode
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsInTextNode
(
)
)
|
|
NS_WARN_IF
(
startToDelete
.
ContainerAsText
(
)
!
=
visibleTextNode
)
|
|
NS_WARN_IF
(
endToDelete
.
ContainerAsText
(
)
!
=
visibleTextNode
)
|
|
NS_WARN_IF
(
startToDelete
.
Offset
(
)
>
=
endToDelete
.
Offset
(
)
)
)
)
{
NS_WARNING
(
"
Mutation
event
listener
changed
the
DOM
tree
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
aHTMLEditor
.
DeleteTextWithTransaction
(
visibleTextNode
startToDelete
.
Offset
(
)
endToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
visibleTextNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
but
ignored
"
)
;
rv
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
return
EditActionHandled
(
)
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ShouldDeleteHRElement
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
if
(
StaticPrefs
:
:
editor_hr_element_allow_to_delete_from_following_line
(
)
)
{
return
true
;
}
if
(
aDirectionAndAmount
!
=
nsIEditor
:
:
ePrevious
)
{
return
true
;
}
EditorRawDOMPoint
atHRElement
(
&
aHRElement
)
;
ErrorResult
error
;
bool
interLineIsRight
=
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
GetInterlinePosition
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
GetInterlinePosition
(
)
failed
"
)
;
nsresult
rv
=
error
.
StealNSResult
(
)
;
return
Err
(
rv
)
;
}
return
!
interLineIsRight
&
&
aCaretPoint
.
GetContainer
(
)
=
=
atHRElement
.
GetContainer
(
)
&
&
aCaretPoint
.
Offset
(
)
-
1
=
=
atHRElement
.
Offset
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteHRElement
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
&
aHRElement
!
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
;
Result
<
bool
nsresult
>
canDeleteHRElement
=
ShouldDeleteHRElement
(
aHTMLEditor
aDirectionAndAmount
aHRElement
aCaretPoint
)
;
if
(
canDeleteHRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
ShouldDeleteHRElement
(
)
failed
"
)
;
return
canDeleteHRElement
.
unwrapErr
(
)
;
}
if
(
canDeleteHRElement
.
inspect
(
)
)
{
nsresult
rv
=
ComputeRangesToDeleteAtomicContent
(
aHTMLEditor
aHRElement
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
)
failed
"
)
;
return
rv
;
}
WSScanResult
forwardScanFromCaretResult
=
aWSRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
;
if
(
!
forwardScanFromCaretResult
.
ReachedBRElement
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
ComputeRangesToDeleteAtomicContent
(
aHTMLEditor
*
forwardScanFromCaretResult
.
ElementPtr
(
)
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteHRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aHRElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
&
aHRElement
!
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
;
Result
<
bool
nsresult
>
canDeleteHRElement
=
ShouldDeleteHRElement
(
aHTMLEditor
aDirectionAndAmount
aHRElement
aCaretPoint
)
;
if
(
canDeleteHRElement
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
ShouldDeleteHRElement
(
)
failed
"
)
;
return
EditActionHandled
(
canDeleteHRElement
.
unwrapErr
(
)
)
;
}
if
(
canDeleteHRElement
.
inspect
(
)
)
{
EditActionResult
result
=
HandleDeleteAtomicContent
(
aHTMLEditor
aHRElement
aCaretPoint
aWSRunScannerAtCaret
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
HandleDeleteAtomicContent
(
)
failed
"
)
;
return
result
;
}
EditorDOMPoint
atNextOfHRElement
(
EditorDOMPoint
:
:
After
(
aHRElement
)
)
;
NS_WARNING_ASSERTION
(
atNextOfHRElement
.
IsSet
(
)
"
Failed
to
set
after
<
hr
>
element
"
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atNextOfHRElement
)
;
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
atNextOfHRElement
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
IgnoredErrorResult
ignoredError
;
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
false
)
failed
but
ignored
"
)
;
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
=
true
;
WSScanResult
forwardScanFromCaretResult
=
aWSRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
;
if
(
!
forwardScanFromCaretResult
.
ReachedBRElement
(
)
)
{
return
EditActionHandled
(
)
;
}
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
aHTMLEditor
MOZ_KnownLive
(
*
forwardScanFromCaretResult
.
BRElementPtr
(
)
)
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
DeleteContentNodeAndJoinTextNodesAroundIt
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
const
nsIContent
&
aAtomicContent
AutoRangeArray
&
aRangesToDelete
)
const
{
EditorDOMRange
rangeToDelete
=
WSRunScanner
:
:
GetRangesForDeletingAtomicContent
(
aHTMLEditor
aAtomicContent
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeForDeleteAContentNode
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
rangeToDelete
.
StartRef
(
)
rangeToDelete
.
EndRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteAtomicContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT_IF
(
aAtomicContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
aHTMLEditor
.
IsVisibleBRElement
(
&
aAtomicContent
)
)
;
MOZ_ASSERT
(
&
aAtomicContent
!
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
aHTMLEditor
aAtomicContent
aCaretPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
"
"
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteCollapsedSelectionAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
mMode
=
Mode
:
:
JoinOtherBlock
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aOtherBlockElement
)
)
{
return
false
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
mLeafContentInOtherBlock
=
aHTMLEditor
.
GetLastEditableLeaf
(
aOtherBlockElement
)
;
mLeftContent
=
mLeafContentInOtherBlock
;
mRightContent
=
aCaretPoint
.
GetContainerAsContent
(
)
;
}
else
{
mLeafContentInOtherBlock
=
aHTMLEditor
.
GetFirstEditableLeaf
(
aOtherBlockElement
)
;
mLeftContent
=
aCaretPoint
.
GetContainerAsContent
(
)
;
mRightContent
=
mLeafContentInOtherBlock
;
}
WSScanResult
scanFromCaretResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
aWSRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
:
aWSRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
;
if
(
scanFromCaretResult
.
ReachedBRElement
(
)
)
{
mBRElement
=
scanFromCaretResult
.
BRElementPtr
(
)
;
mMode
=
Mode
:
:
DeleteBRElement
;
return
true
;
}
return
mLeftContent
&
&
mRightContent
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteBRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mBRElement
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
mBRElement
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
mLeftContent
&
&
mRightContent
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
mLeftContent
*
mRightContent
)
)
{
return
EditActionHandled
(
)
;
}
if
(
NS_WARN_IF
(
!
mLeafContentInOtherBlock
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
newCaretPosition
=
aHTMLEditor
.
GetGoodCaretPointFor
(
*
mLeafContentInOtherBlock
aDirectionAndAmount
)
;
if
(
!
newCaretPosition
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPosition
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
if
(
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
mLeftContent
*
mRightContent
)
)
{
if
(
!
mDeleteRangesHandler
.
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
EditActionIgnored
(
)
;
}
EditActionResult
result
=
mDeleteRangesHandler
.
FallbackToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoDeleteRangesHandler
:
:
FallbackToDeleteRangesWithTransaction
(
)
"
"
failed
to
delete
leaf
content
in
the
block
"
)
;
return
result
;
}
EditActionResult
result
(
NS_OK
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
EditActionResult
(
canJoinThem
.
unwrapErr
(
)
)
;
}
if
(
canJoinThem
.
inspect
(
)
)
{
if
(
joiner
.
CanJoinBlocks
(
)
)
{
result
|
=
joiner
.
Run
(
aHTMLEditor
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
else
{
result
.
MarkAsHandled
(
)
;
}
}
else
{
result
.
MarkAsCanceled
(
)
;
}
}
if
(
result
.
Ignored
(
)
&
&
mLeafContentInOtherBlock
!
=
aCaretPoint
.
GetContainer
(
)
)
{
EditorRawDOMPoint
newCaretPoint
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
EditorRawDOMPoint
:
:
AtEndOf
(
*
mLeafContentInOtherBlock
)
:
EditorRawDOMPoint
(
mLeafContentInOtherBlock
0
)
;
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
NS_WARNING
(
"
Failed
to
put
caret
to
new
position
"
)
;
return
EditActionHandled
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
AutoRangeArray
rangesToDelete
(
*
aHTMLEditor
.
SelectionRefPtr
(
)
)
;
AutoDeleteRangesHandler
anotherHandler
(
&
mDeleteRangesHandler
)
;
result
=
anotherHandler
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
rangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Recursive
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteCollapsedSelectionAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
mMode
=
Mode
:
:
JoinCurrentBlock
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aCurrentBlockElement
)
)
{
return
false
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
mLeftContent
=
aHTMLEditor
.
GetPreviousEditableHTMLNode
(
aCurrentBlockElement
)
;
mRightContent
=
aCaretPoint
.
GetContainerAsContent
(
)
;
}
else
{
mRightContent
=
aHTMLEditor
.
GetNextEditableHTMLNode
(
aCurrentBlockElement
)
;
mLeftContent
=
aCaretPoint
.
GetContainerAsContent
(
)
;
}
if
(
!
mLeftContent
|
|
!
mRightContent
)
{
return
false
;
}
return
!
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
mLeftContent
*
mRightContent
)
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
)
{
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
EditActionResult
result
(
NS_OK
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
EditActionResult
(
canJoinThem
.
unwrapErr
(
)
)
;
}
if
(
canJoinThem
.
inspect
(
)
)
{
if
(
joiner
.
CanJoinBlocks
(
)
)
{
result
|
=
joiner
.
Run
(
aHTMLEditor
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
else
{
result
.
MarkAsHandled
(
)
;
}
}
else
{
result
.
MarkAsCanceled
(
)
;
}
result
.
MarkAsHandled
(
)
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
{
nsFrameSelection
*
frameSelection
=
aHTMLEditor
.
SelectionRefPtr
(
)
-
>
GetFrameSelection
(
)
;
if
(
NS_WARN_IF
(
!
frameSelection
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
ExtendRangeToIncludeInvisibleNodes
(
aHTMLEditor
frameSelection
aRangesToDelete
.
FirstRangeRef
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
ExtendRangeToIncludeInvisibleNodes
(
)
"
"
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
if
(
!
aHTMLEditor
.
IsPlaintextEditor
(
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
aHTMLEditor
EditorDOMRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
.
IsSetAndValid
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
)
made
the
firstr
"
"
range
invalid
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
{
if
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
Collapsed
(
)
)
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsContent
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
startCiteNode
=
aHTMLEditor
.
GetMostAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
)
;
RefPtr
<
Element
>
endCiteNode
=
aHTMLEditor
.
GetMostAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteNonCollapsedRanges
(
aHTMLEditor
aRangesToDelete
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
aSelectionWasCollapsed
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
result
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
const
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
mLeftContent
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
)
;
mRightContent
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
mLeftContent
)
|
|
NS_WARN_IF
(
!
mRightContent
)
)
{
return
false
;
}
if
(
mLeftContent
=
=
mRightContent
)
{
mMode
=
Mode
:
:
DeleteContentInRanges
;
return
true
;
}
if
(
mLeftContent
-
>
GetParentNode
(
)
=
=
mRightContent
-
>
GetParentNode
(
)
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
mLeftContent
*
mRightContent
aHTMLEditor
.
IsCSSEnabled
(
)
?
StyleDifference
:
:
CompareIfSpanElements
:
StyleDifference
:
:
Ignore
)
&
&
(
mLeftContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
mLeftContent
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
mLeftContent
)
)
)
{
mMode
=
Mode
:
:
JoinBlocksInSameParent
;
return
true
;
}
mMode
=
Mode
:
:
DeleteNonCollapsedRanges
;
return
true
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteContentInRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
DeleteContentInRanges
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT
(
mLeftContent
=
=
mRightContent
)
;
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
caused
destroying
the
"
"
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
mDeleteRangesHandler
.
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
JoinBlockElementsInSameParent
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
JoinBlocksInSameParent
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT
(
mLeftContent
-
>
GetParentNode
(
)
=
=
mRightContent
-
>
GetParentNode
(
)
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
Result
<
EditorDOMPoint
nsresult
>
atFirstChildOfTheLastRightNodeOrError
=
JoinNodesDeepWithTransaction
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftContent
)
MOZ_KnownLive
(
*
mRightContent
)
)
;
if
(
atFirstChildOfTheLastRightNodeOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesDeepWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
atFirstChildOfTheLastRightNodeOrError
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
atFirstChildOfTheLastRightNodeOrError
.
inspect
(
)
.
IsSet
(
)
)
;
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
atFirstChildOfTheLastRightNodeOrError
.
inspect
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteNodesEntirelyInRangeButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
arrayOfTopChildren
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
iter
.
AppendAllNodesToArray
(
arrayOfTopChildren
)
;
bool
join
=
true
;
for
(
auto
&
content
:
arrayOfTopChildren
)
{
nsresult
rv
=
DeleteContentButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
DeleteContentButKeepTableStructure
(
)
failed
"
"
but
ignored
"
)
;
if
(
!
join
|
|
aSelectionWasCollapsed
=
=
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
:
:
No
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
)
{
join
=
!
aHTMLEditor
.
IsInVisibleTextFrames
(
*
content
-
>
AsText
(
)
)
;
continue
;
}
if
(
!
content
-
>
IsElement
(
)
|
|
aHTMLEditor
.
IsEmptyNode
(
*
content
-
>
AsElement
(
)
)
)
{
continue
;
}
join
=
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
aHTMLEditor
.
IsVisibleBRElement
(
content
)
;
}
return
join
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteTextAtStartAndEndOfRange
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
)
{
EditorDOMPoint
rangeStart
(
aRange
.
StartRef
(
)
)
;
EditorDOMPoint
rangeEnd
(
aRange
.
EndRef
(
)
)
;
if
(
rangeStart
.
IsInTextNode
(
)
&
&
!
rangeStart
.
IsEndOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
rangeStart
.
GetContainerAsText
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextWithTransaction
(
textNode
rangeStart
.
Offset
(
)
rangeStart
.
GetContainer
(
)
-
>
Length
(
)
-
rangeStart
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
rangeEnd
.
IsInTextNode
(
)
&
&
!
rangeEnd
.
IsStartOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
rangeEnd
.
GetContainerAsText
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextWithTransaction
(
textNode
0
rangeEnd
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
EditActionResult
result
(
NS_OK
)
;
result
.
MarkAsHandled
(
)
;
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
bool
joinInclusiveAncestorBlockElements
=
true
;
for
(
auto
&
range
:
aRangesToDelete
.
Ranges
(
)
)
{
Result
<
bool
nsresult
>
deleteResult
=
DeleteNodesEntirelyInRangeButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
range
)
aSelectionWasCollapsed
)
;
if
(
deleteResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoBlockElementsJoiner
:
:
"
"
DeleteNodesEntirelyInRangeButKeepTableStructure
(
)
failed
"
)
;
return
result
.
SetResult
(
deleteResult
.
unwrapErr
(
)
)
;
}
joinInclusiveAncestorBlockElements
&
=
deleteResult
.
unwrap
(
)
;
}
nsresult
rv
=
DeleteTextAtStartAndEndOfRange
(
aHTMLEditor
MOZ_KnownLive
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoBlockElementsJoiner
:
:
DeleteTextAtStartAndEndOfRange
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
joinInclusiveAncestorBlockElements
)
{
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
EditActionResult
(
canJoinThem
.
unwrapErr
(
)
)
;
}
if
(
canJoinThem
.
inspect
(
)
)
{
if
(
joiner
.
CanJoinBlocks
(
)
)
{
result
|
=
joiner
.
Run
(
aHTMLEditor
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
else
{
result
.
MarkAsHandled
(
)
;
}
}
else
{
result
.
Canceled
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
else
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
}
}
nsresult
rv
=
mDeleteRangesHandler
.
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
EditorDOMPoint
atCaret
(
aSelectionStartPoint
)
;
EditorDOMPoint
selectionEndPoint
(
aSelectionEndPoint
)
;
if
(
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
|
|
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDeleteByDrag
)
{
MOZ_ASSERT
(
(
atCaret
.
GetContainer
(
)
=
=
selectionEndPoint
.
GetContainer
(
)
&
&
atCaret
.
Offset
(
)
=
=
selectionEndPoint
.
Offset
(
)
)
|
|
(
atCaret
.
GetContainer
(
)
-
>
GetNextSibling
(
)
=
=
selectionEndPoint
.
GetContainer
(
)
&
&
atCaret
.
IsEndOfContainer
(
)
&
&
selectionEndPoint
.
IsStartOfContainer
(
)
)
)
;
{
AutoTrackDOMPoint
startTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atCaret
)
;
AutoTrackDOMPoint
endTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
selectionEndPoint
)
;
nsresult
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
aHTMLEditor
atCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
)
failed
"
)
;
return
rv
;
}
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
=
rv
=
=
NS_OK
;
}
if
(
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
atCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
atCaret
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
selectionEndPoint
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
{
AutoTrackDOMPoint
startTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atCaret
)
;
AutoTrackDOMPoint
endTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
selectionEndPoint
)
;
nsresult
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
MOZ_KnownLive
(
*
atCaret
.
ContainerAsContent
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
to
remove
start
node
but
ignored
"
)
;
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
MOZ_KnownLive
(
*
selectionEndPoint
.
ContainerAsContent
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
to
remove
end
node
but
ignored
"
)
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
selectionEndPoint
:
atCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
Text
*
text
=
aContent
.
GetAsText
(
)
;
if
(
!
text
)
{
return
NS_OK
;
}
if
(
aHTMLEditor
.
IsVisibleTextNode
(
*
text
)
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
text
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
mPlaceholderBatch
)
;
WSRunScanner
wsScannerForPoint
(
aHTMLEditor
aPoint
)
;
if
(
!
wsScannerForPoint
.
StartsFromCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
)
|
|
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
wsScannerForPoint
.
GetEditingHost
(
)
=
=
wsScannerForPoint
.
GetStartReasonContent
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
WSScanResult
forwardScanFromPointResult
=
wsScannerForPoint
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
if
(
forwardScanFromPointResult
.
ReachedBRElement
(
)
)
{
NS_ASSERTION
(
wsScannerForPoint
.
GetEndReasonContent
(
)
=
=
forwardScanFromPointResult
.
BRElementPtr
(
)
"
End
reason
is
not
the
reached
<
br
>
element
"
)
;
if
(
aHTMLEditor
.
IsVisibleBRElement
(
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
wsScannerForPoint
.
GetEndReasonContent
(
)
-
>
GetNextSibling
(
)
)
{
if
(
!
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
aHTMLEditor
EditorRawDOMPoint
:
:
After
(
*
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
}
}
else
if
(
!
forwardScanFromPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
EditorDOMPoint
nextPoint
(
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
0
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
nextPoint
.
GetContainer
(
)
=
=
wsScannerForPoint
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
if
(
aHTMLEditor
.
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
Element
*
editingHost
=
aHTMLEditor
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
|
|
NS_WARN_IF
(
editingHost
!
=
wsScannerForPoint
.
GetEditingHost
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
*
nextPoint
.
GetContainer
(
)
*
editingHost
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
}
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
aHTMLEditor
nextPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
DeleteParentBlocksWithTransactionIfEmpty
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
EditorDOMPointType
>
nsresult
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPointType
&
aStartPoint
const
EditorDOMPointType
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
{
if
(
NS_WARN_IF
(
!
aStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aStartPoint
=
=
aEndPoint
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
auto
deleteEmptyContentNodeWithTransaction
=
[
this
&
aTreatEmptyTextNodes
&
editingHost
]
(
nsIContent
&
aContent
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
nsresult
{
OwningNonNull
<
nsIContent
>
nodeToRemove
=
aContent
;
if
(
aTreatEmptyTextNodes
=
=
TreatEmptyTextNodes
:
:
RemoveAllEmptyInlineAncestors
)
{
Element
*
emptyParentElementToRemove
=
HTMLEditUtils
:
:
GetMostDistantAnscestorEditableEmptyInlineElement
(
nodeToRemove
editingHost
)
;
if
(
emptyParentElementToRemove
)
{
nodeToRemove
=
*
emptyParentElementToRemove
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
nodeToRemove
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
;
if
(
aStartPoint
.
GetContainer
(
)
=
=
aEndPoint
.
GetContainer
(
)
&
&
aStartPoint
.
IsInTextNode
(
)
)
{
if
(
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
&
&
aStartPoint
.
IsStartOfContainer
(
)
&
&
aEndPoint
.
IsEndOfContainer
(
)
)
{
nsresult
rv
=
deleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aStartPoint
.
ContainerAsText
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
deleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Text
>
textNode
=
aStartPoint
.
ContainerAsText
(
)
;
nsresult
rv
=
DeleteTextWithTransaction
(
*
textNode
aStartPoint
.
Offset
(
)
aEndPoint
.
Offset
(
)
-
aStartPoint
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aStartPoint
.
ToRawRangeBoundary
(
)
aEndPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
!
range
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoTArray
<
OwningNonNull
<
Text
>
16
>
arrayOfTextNodes
;
DOMIterator
iter
;
if
(
NS_FAILED
(
iter
.
Init
(
*
range
)
)
)
{
return
NS_OK
;
}
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
{
MOZ_ASSERT
(
aNode
.
IsText
(
)
)
;
return
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aNode
)
;
}
arrayOfTextNodes
)
;
for
(
OwningNonNull
<
Text
>
&
textNode
:
arrayOfTextNodes
)
{
if
(
textNode
=
=
aStartPoint
.
GetContainer
(
)
)
{
if
(
aStartPoint
.
IsEndOfContainer
(
)
)
{
continue
;
}
if
(
aStartPoint
.
IsStartOfContainer
(
)
&
&
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
{
nsresult
rv
=
deleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aStartPoint
.
ContainerAsText
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
deleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
nsresult
rv
=
DeleteTextWithTransaction
(
MOZ_KnownLive
(
textNode
)
aStartPoint
.
Offset
(
)
textNode
-
>
Length
(
)
-
aStartPoint
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
textNode
=
=
aEndPoint
.
GetContainer
(
)
)
{
if
(
aEndPoint
.
IsStartOfContainer
(
)
)
{
break
;
}
if
(
aEndPoint
.
IsEndOfContainer
(
)
&
&
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
{
nsresult
rv
=
deleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aEndPoint
.
ContainerAsText
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
deleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
DeleteTextWithTransaction
(
MOZ_KnownLive
(
textNode
)
0
aEndPoint
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
deleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
textNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
deleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsStartOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetPreviousCharPointType
(
aPoint
)
)
;
}
EditorDOMPointInText
previousCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
*
this
aPoint
)
;
if
(
!
previousCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
previousCharPoint
)
)
;
}
HTMLEditor
:
:
CharPointData
HTMLEditor
:
:
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
CharPointData
:
:
InSameTextNode
(
HTMLEditor
:
:
GetCharPointType
(
aPoint
)
)
;
}
EditorDOMPointInText
nextCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
*
this
aPoint
)
;
if
(
!
nextCharPoint
.
IsSet
(
)
)
{
return
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
;
}
return
CharPointData
:
:
InDifferentTextNode
(
HTMLEditor
:
:
GetCharPointType
(
nextCharPoint
)
)
;
}
void
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
nsAString
&
aResult
uint32_t
aLength
const
CharPointData
&
aPreviousCharPointData
const
CharPointData
&
aNextCharPointData
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aLength
)
;
MOZ_ASSERT
(
aPreviousCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aPreviousCharPointData
.
IsWhiteSpace
(
)
)
;
MOZ_ASSERT
(
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
!
aNextCharPointData
.
IsWhiteSpace
(
)
)
;
if
(
aLength
=
=
1
)
{
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
&
&
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
VisibleChar
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
if
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
TextEnd
)
{
aResult
.
Assign
(
HTMLEditUtils
:
:
kNBSP
)
;
return
;
}
aResult
.
Assign
(
aPreviousCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
)
;
return
;
}
aResult
.
SetLength
(
aLength
)
;
bool
appendNBSP
=
true
;
char16_t
*
lastChar
=
aResult
.
EndWriting
(
)
-
1
;
for
(
char16_t
*
iter
=
aResult
.
BeginWriting
(
)
;
iter
!
=
lastChar
;
iter
+
+
)
{
*
iter
=
appendNBSP
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
appendNBSP
=
!
appendNBSP
;
}
if
(
appendNBSP
)
{
*
lastChar
=
HTMLEditUtils
:
:
kNBSP
;
return
;
}
*
lastChar
=
aNextCharPointData
.
AcrossTextNodeBoundary
(
)
|
|
aNextCharPointData
.
Type
(
)
=
=
CharPointType
:
:
ASCIIWhiteSpace
?
HTMLEditUtils
:
:
kNBSP
:
HTMLEditUtils
:
:
kSpace
;
}
void
HTMLEditor
:
:
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
EditorDOMPointInText
&
aStartToDelete
EditorDOMPointInText
&
aEndToDelete
nsAString
&
aNormalizedWhiteSpacesInStartNode
nsAString
&
aNormalizedWhiteSpacesInEndNode
)
const
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInStartNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
IsEmpty
(
)
)
;
EditorDOMPointInText
precedingCharPoint
=
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
*
this
aStartToDelete
)
;
EditorDOMPointInText
followingCharPoint
=
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
*
this
aEndToDelete
)
;
const
bool
removingLastCharOfStartNode
=
aStartToDelete
.
ContainerAsText
(
)
!
=
aEndToDelete
.
ContainerAsText
(
)
|
|
(
aEndToDelete
.
IsEndOfContainer
(
)
&
&
followingCharPoint
.
IsSet
(
)
)
;
const
bool
maybeNormalizePrecedingWhiteSpaces
=
!
removingLastCharOfStartNode
&
&
precedingCharPoint
.
IsSet
(
)
&
&
!
precedingCharPoint
.
IsEndOfContainer
(
)
&
&
precedingCharPoint
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
&
&
precedingCharPoint
.
IsCharASCIISpaceOrNBSP
(
)
&
&
!
EditorUtils
:
:
IsContentPreformatted
(
*
precedingCharPoint
.
ContainerAsText
(
)
)
;
const
bool
maybeNormalizeFollowingWhiteSpaces
=
followingCharPoint
.
IsSet
(
)
&
&
!
followingCharPoint
.
IsEndOfContainer
(
)
&
&
(
followingCharPoint
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
|
|
removingLastCharOfStartNode
)
&
&
followingCharPoint
.
IsCharASCIISpaceOrNBSP
(
)
&
&
!
EditorUtils
:
:
IsContentPreformatted
(
*
followingCharPoint
.
ContainerAsText
(
)
)
;
if
(
!
maybeNormalizePrecedingWhiteSpaces
&
&
!
maybeNormalizeFollowingWhiteSpaces
)
{
return
;
}
EditorDOMPointInText
startToNormalize
endToNormalize
;
if
(
maybeNormalizePrecedingWhiteSpaces
)
{
Maybe
<
uint32_t
>
previousCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetPreviousCharOffsetExceptWhiteSpaces
(
precedingCharPoint
)
;
startToNormalize
.
Set
(
precedingCharPoint
.
ContainerAsText
(
)
previousCharOffsetOfWhiteSpaces
.
isSome
(
)
?
previousCharOffsetOfWhiteSpaces
.
value
(
)
+
1
:
0
)
;
MOZ_ASSERT
(
!
startToNormalize
.
IsEndOfContainer
(
)
)
;
}
if
(
maybeNormalizeFollowingWhiteSpaces
)
{
Maybe
<
uint32_t
>
nextCharOffsetOfWhiteSpaces
=
HTMLEditUtils
:
:
GetInclusiveNextCharOffsetExceptWhiteSpaces
(
followingCharPoint
)
;
if
(
nextCharOffsetOfWhiteSpaces
.
isSome
(
)
)
{
endToNormalize
.
Set
(
followingCharPoint
.
ContainerAsText
(
)
nextCharOffsetOfWhiteSpaces
.
value
(
)
)
;
}
else
{
endToNormalize
.
SetToEndOf
(
followingCharPoint
.
ContainerAsText
(
)
)
;
}
MOZ_ASSERT
(
!
endToNormalize
.
IsStartOfContainer
(
)
)
;
}
CharPointData
previousCharPointData
=
removingLastCharOfStartNode
?
CharPointData
:
:
InDifferentTextNode
(
CharPointType
:
:
TextEnd
)
:
GetPreviousCharPointDataForNormalizingWhiteSpaces
(
startToNormalize
.
IsSet
(
)
?
startToNormalize
:
aStartToDelete
)
;
CharPointData
nextCharPointData
=
GetInclusiveNextCharPointDataForNormalizingWhiteSpaces
(
endToNormalize
.
IsSet
(
)
?
endToNormalize
:
aEndToDelete
)
;
uint32_t
lengthInStartNode
=
0
lengthInEndNode
=
0
;
if
(
startToNormalize
.
IsSet
(
)
)
{
MOZ_ASSERT
(
startToNormalize
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
)
;
lengthInStartNode
=
aStartToDelete
.
Offset
(
)
-
startToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInStartNode
)
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
lengthInEndNode
=
endToNormalize
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
?
endToNormalize
.
Offset
(
)
-
aEndToDelete
.
Offset
(
)
:
endToNormalize
.
Offset
(
)
;
MOZ_ASSERT
(
lengthInEndNode
)
;
if
(
endToNormalize
.
ContainerAsText
(
)
=
=
aStartToDelete
.
ContainerAsText
(
)
)
{
lengthInStartNode
+
=
lengthInEndNode
;
lengthInEndNode
=
0
;
}
}
MOZ_ASSERT
(
lengthInStartNode
+
lengthInEndNode
)
;
if
(
!
lengthInEndNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInStartNode
lengthInStartNode
previousCharPointData
nextCharPointData
)
;
}
else
if
(
!
lengthInStartNode
)
{
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
aNormalizedWhiteSpacesInEndNode
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
}
else
{
nsAutoString
whiteSpaces
;
HTMLEditor
:
:
GenerateWhiteSpaceSequence
(
whiteSpaces
lengthInStartNode
+
lengthInEndNode
previousCharPointData
nextCharPointData
)
;
aNormalizedWhiteSpacesInStartNode
=
Substring
(
whiteSpaces
0
lengthInStartNode
)
;
aNormalizedWhiteSpacesInEndNode
=
Substring
(
whiteSpaces
lengthInStartNode
)
;
MOZ_ASSERT
(
aNormalizedWhiteSpacesInEndNode
.
Length
(
)
=
=
lengthInEndNode
)
;
}
if
(
startToNormalize
.
IsSet
(
)
)
{
aStartToDelete
=
startToNormalize
;
}
if
(
endToNormalize
.
IsSet
(
)
)
{
aEndToDelete
=
endToNormalize
;
}
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
const
EditorDOMPointInText
&
aStartToDelete
const
EditorDOMPointInText
&
aEndToDelete
TreatEmptyTextNodes
aTreatEmptyTextNodes
DeleteDirection
aDeleteDirection
)
{
MOZ_ASSERT
(
aStartToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartToDelete
.
EqualsOrIsBefore
(
aEndToDelete
)
)
;
nsString
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
;
EditorDOMPointInText
startToDelete
(
aStartToDelete
)
;
EditorDOMPointInText
endToDelete
(
aEndToDelete
)
;
ExtendRangeToDeleteWithNormalizingWhiteSpaces
(
startToDelete
endToDelete
normalizedWhiteSpacesInFirstNode
normalizedWhiteSpacesInLastNode
)
;
if
(
startToDelete
=
=
endToDelete
)
{
return
EditorDOMPoint
(
aStartToDelete
)
;
}
EditorDOMPoint
newCaretPosition
;
if
(
aStartToDelete
.
ContainerAsText
(
)
=
=
aEndToDelete
.
ContainerAsText
(
)
)
{
newCaretPosition
=
aEndToDelete
;
}
else
if
(
aDeleteDirection
=
=
DeleteDirection
:
:
Forward
)
{
newCaretPosition
.
SetToEndOf
(
aStartToDelete
.
ContainerAsText
(
)
)
;
}
else
{
newCaretPosition
.
Set
(
aEndToDelete
.
ContainerAsText
(
)
0
)
;
}
while
(
true
)
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
if
(
!
normalizedWhiteSpacesInFirstNode
.
IsEmpty
(
)
)
{
EditorDOMPoint
trackingEndToDelete
(
endToDelete
.
ContainerAsText
(
)
endToDelete
.
Offset
(
)
)
;
{
AutoTrackDOMPoint
trackEndToDelete
(
RangeUpdaterRef
(
)
&
trackingEndToDelete
)
;
uint32_t
lengthToReplaceInFirstTextNode
=
startToDelete
.
ContainerAsText
(
)
=
=
trackingEndToDelete
.
ContainerAsText
(
)
?
trackingEndToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
:
startToDelete
.
ContainerAsText
(
)
-
>
TextLength
(
)
-
startToDelete
.
Offset
(
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAsText
(
)
)
startToDelete
.
Offset
(
)
lengthToReplaceInFirstTextNode
normalizedWhiteSpacesInFirstNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
startToDelete
.
ContainerAsText
(
)
=
=
trackingEndToDelete
.
ContainerAsText
(
)
)
{
MOZ_ASSERT
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
break
;
}
}
if
(
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
(
NS_WARN_IF
(
!
trackingEndToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
trackingEndToDelete
.
IsInTextNode
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
trackingEndToDelete
.
IsInTextNode
(
)
)
;
endToDelete
.
Set
(
trackingEndToDelete
.
ContainerAsText
(
)
trackingEndToDelete
.
Offset
(
)
)
;
startToDelete
=
EditorDOMPointInText
:
:
AtEndOf
(
*
startToDelete
.
ContainerAsText
(
)
)
;
if
(
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
NS_WARN_IF
(
!
startToDelete
.
IsBefore
(
endToDelete
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
|
|
startToDelete
.
ContainerAsText
(
)
!
=
endToDelete
.
ContainerAsText
(
)
)
{
EditorDOMPointInText
endToDeleteExceptReplaceRange
=
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
?
endToDelete
:
EditorDOMPointInText
(
endToDelete
.
ContainerAsText
(
)
0
)
;
if
(
startToDelete
!
=
endToDeleteExceptReplaceRange
)
{
nsresult
rv
=
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDeleteExceptReplaceRange
aTreatEmptyTextNodes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
{
break
;
}
if
(
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
&
&
(
NS_WARN_IF
(
!
endToDeleteExceptReplaceRange
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
endToDelete
.
IsStartOfContainer
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
startToDelete
=
endToDeleteExceptReplaceRange
;
}
}
MOZ_ASSERT
(
!
normalizedWhiteSpacesInLastNode
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
ContainerAsText
(
)
=
=
endToDelete
.
ContainerAsText
(
)
)
;
nsresult
rv
=
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
startToDelete
.
ContainerAsText
(
)
)
startToDelete
.
Offset
(
)
endToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
normalizedWhiteSpacesInLastNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
break
;
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
|
|
!
newCaretPosition
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
got
lost
"
"
the
modifying
line
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
newCaretPosition
.
IsInTextNode
(
)
)
{
if
(
nsIContent
*
currentBlock
=
HTMLEditUtils
:
:
GetInclusiveAncestorEditableBlockElementOrInlineEditingHost
(
*
newCaretPosition
.
ContainerAsContent
(
)
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
newCaretPosition
*
currentBlock
editingHost
)
;
if
(
previousContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousContent
)
)
{
newCaretPosition
=
previousContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
?
EditorDOMPoint
:
:
AtEndOf
(
*
previousContent
)
:
EditorDOMPoint
:
:
After
(
*
previousContent
)
;
}
else
if
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
newCaretPosition
*
currentBlock
editingHost
)
)
{
newCaretPosition
=
nextContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
?
EditorDOMPoint
(
nextContent
0
)
:
EditorDOMPoint
(
nextContent
)
;
}
}
}
if
(
newCaretPosition
.
IsStartOfContainer
(
)
&
&
newCaretPosition
.
IsInTextNode
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
&
&
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
IsText
(
)
)
{
newCaretPosition
.
SetToEndOf
(
newCaretPosition
.
GetContainer
(
)
-
>
GetPreviousSibling
(
)
-
>
AsText
(
)
)
;
}
{
AutoTrackDOMPoint
trackingNewCaretPosition
(
RangeUpdaterRef
(
)
&
newCaretPosition
)
;
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
!
newCaretPosition
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
Inserting
<
br
>
element
caused
unexpected
DOM
tree
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
newCaretPosition
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
!
aPointToInsert
.
GetContainerAsContent
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
aPointToInsert
.
ContainerAsContent
(
)
)
)
{
return
NS_OK
;
}
WSRunScanner
wsRunScanner
(
*
this
aPointToInsert
)
;
if
(
!
wsRunScanner
.
StartsFromHardLineBreak
(
)
)
{
return
NS_OK
;
}
if
(
!
wsRunScanner
.
EndsByBlockBoundary
(
)
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
aPointToInsert
nsIEditor
:
:
ePrevious
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
EditorDOMPoint
HTMLEditor
:
:
GetGoodCaretPointFor
(
nsIContent
&
aContent
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePreviousWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
bool
goingForward
=
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
if
(
aContent
.
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
|
|
NS_WARN_IF
(
!
aContent
.
GetParentNode
(
)
)
)
{
return
EditorDOMPoint
(
&
aContent
goingForward
?
0
:
aContent
.
Length
(
)
)
;
}
if
(
goingForward
)
{
return
EditorDOMPoint
(
&
aContent
)
;
}
if
(
!
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
IsVisibleBRElement
(
&
aContent
)
)
{
EditorDOMPoint
ret
(
EditorDOMPoint
:
:
After
(
aContent
)
)
;
NS_WARNING_ASSERTION
(
ret
.
IsSet
(
)
"
Failed
to
set
after
aContent
"
)
;
return
ret
;
}
return
EditorDOMPoint
(
&
aContent
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
JoinNodesDeepWithTransaction
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
{
nsCOMPtr
<
nsIContent
>
leftContentToJoin
=
&
aLeftContent
;
nsCOMPtr
<
nsIContent
>
rightContentToJoin
=
&
aRightContent
;
nsCOMPtr
<
nsINode
>
parentNode
=
aRightContent
.
GetParentNode
(
)
;
EditorDOMPoint
ret
;
const
HTMLEditUtils
:
:
StyleDifference
kCompareStyle
=
aHTMLEditor
.
IsCSSEnabled
(
)
?
StyleDifference
:
:
CompareIfSpanElements
:
StyleDifference
:
:
Ignore
;
while
(
leftContentToJoin
&
&
rightContentToJoin
&
&
parentNode
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
leftContentToJoin
*
rightContentToJoin
kCompareStyle
)
)
{
uint32_t
length
=
leftContentToJoin
-
>
Length
(
)
;
nsresult
rv
=
aHTMLEditor
.
JoinNodesWithTransaction
(
*
leftContentToJoin
*
rightContentToJoin
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
ret
.
Set
(
rightContentToJoin
length
)
;
if
(
NS_WARN_IF
(
!
ret
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
parentNode
-
>
IsText
(
)
)
{
return
ret
;
}
parentNode
=
rightContentToJoin
;
rightContentToJoin
=
parentNode
-
>
GetChildAt_Deprecated
(
length
)
;
if
(
rightContentToJoin
)
{
leftContentToJoin
=
rightContentToJoin
-
>
GetPreviousSibling
(
)
;
}
else
{
leftContentToJoin
=
nullptr
;
}
while
(
leftContentToJoin
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
leftContentToJoin
EditorType
:
:
HTML
)
)
{
leftContentToJoin
=
leftContentToJoin
-
>
GetPreviousSibling
(
)
;
}
if
(
!
leftContentToJoin
)
{
return
ret
;
}
while
(
rightContentToJoin
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
rightContentToJoin
EditorType
:
:
HTML
)
)
{
rightContentToJoin
=
rightContentToJoin
-
>
GetNextSibling
(
)
;
}
if
(
!
rightContentToJoin
)
{
return
ret
;
}
}
if
(
!
ret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesDeepWithTransaction
(
)
joined
no
contents
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
ret
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
{
mLeftBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElementExceptHRElement
(
mInclusiveDescendantOfLeftBlockElement
)
;
mRightBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElementExceptHRElement
(
mInclusiveDescendantOfRightBlockElement
)
;
if
(
NS_WARN_IF
(
!
IsSet
(
)
)
)
{
mCanJoinBlocks
=
false
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
mLeftBlockElement
)
|
|
HTMLEditUtils
:
:
IsAnyTableElement
(
mRightBlockElement
)
)
{
mCanJoinBlocks
=
false
;
return
false
;
}
if
(
IsSameBlockElement
(
)
)
{
mCanJoinBlocks
=
true
;
return
true
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
mLeftBlockElement
)
&
&
HTMLEditUtils
:
:
IsListItem
(
mRightBlockElement
)
&
&
mRightBlockElement
-
>
GetParentNode
(
)
=
=
mLeftBlockElement
)
{
mCanJoinBlocks
=
false
;
return
true
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
mLeftBlockElement
)
&
&
HTMLEditUtils
:
:
IsListItem
(
mRightBlockElement
)
)
{
Element
*
leftListElement
=
mLeftBlockElement
-
>
GetParentElement
(
)
;
Element
*
rightListElement
=
mRightBlockElement
-
>
GetParentElement
(
)
;
EditorDOMPoint
atChildInBlock
;
if
(
leftListElement
&
&
rightListElement
&
&
leftListElement
!
=
rightListElement
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftListElement
*
mRightBlockElement
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightListElement
*
mLeftBlockElement
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
mLeftBlockElement
=
leftListElement
;
mRightBlockElement
=
rightListElement
;
mNewListElementTagNameOfRightListElement
=
Some
(
leftListElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
}
mCanJoinBlocks
=
true
;
return
true
;
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
HTMLEditor
&
aHTMLEditor
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mLeftBlockElement
)
;
MOZ_ASSERT
(
mRightBlockElement
)
;
if
(
IsSameBlockElement
(
)
)
{
return
EditActionIgnored
(
)
;
}
if
(
!
mCanJoinBlocks
)
{
return
EditActionHandled
(
)
;
}
EditorDOMPoint
atRightBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
mLeftBlockElement
*
mRightBlockElement
&
atRightBlockChild
)
)
{
EditActionResult
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
atRightBlockChild
mNewListElementTagNameOfRightListElement
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoDescendantLeftBl
"
"
ockElement
(
)
failed
"
)
;
return
result
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
EditorDOMPoint
atLeftBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
mRightBlockElement
*
mLeftBlockElement
&
atLeftBlockChild
)
)
{
EditActionResult
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
atLeftBlockChild
MOZ_KnownLive
(
*
mInclusiveDescendantOfLeftBlockElement
)
mNewListElementTagNameOfRightListElement
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoAncestorLeftBloc
"
"
kElement
(
)
failed
"
)
;
return
result
;
}
EditActionResult
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
mNewListElementTagNameOfRightListElement
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
)
failed
"
)
;
return
result
;
}
MoveNodeResult
HTMLEditor
:
:
MoveOneHardLineContents
(
const
EditorDOMPoint
&
aPointInHardLine
const
EditorDOMPoint
&
aPointToInsert
MoveToEndOfContainer
aMoveToEndOfContainer
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInOneHardLine
(
aPointInHardLine
arrayOfContents
EditSubAction
:
:
eMergeBlockContents
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodesInOneHardLine
(
"
"
eMergeBlockContents
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
MoveNodeResult
(
rv
)
;
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
return
MoveNodeIgnored
(
aPointToInsert
)
;
}
uint32_t
offset
=
aPointToInsert
.
Offset
(
)
;
MoveNodeResult
result
;
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
aMoveToEndOfContainer
=
=
MoveToEndOfContainer
:
:
Yes
)
{
offset
=
aPointToInsert
.
GetContainer
(
)
-
>
Length
(
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
result
|
=
MoveChildrenWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
EditorDOMPoint
(
aPointToInsert
.
GetContainer
(
)
offset
)
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
"
)
;
return
result
;
}
offset
=
result
.
NextInsertionPointRef
(
)
.
Offset
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
result
.
MarkAsHandled
(
)
;
if
(
MaybeHasMutationEventListeners
(
)
)
{
offset
=
std
:
:
min
(
offset
aPointToInsert
.
GetContainer
(
)
-
>
Length
(
)
)
;
}
continue
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeOrChildrenWithTransaction
(
MOZ_KnownLive
(
content
)
EditorDOMPoint
(
aPointToInsert
.
GetContainer
(
)
offset
)
)
;
if
(
NS_WARN_IF
(
moveNodeResult
.
EditorDestroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
moveNodeResult
.
Succeeded
(
)
"
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
moveNodeResult
.
Succeeded
(
)
)
{
offset
=
moveNodeResult
.
NextInsertionPointRef
(
)
.
Offset
(
)
;
result
|
=
moveNodeResult
;
}
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Last
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
)
failed
"
)
;
return
result
;
}
MoveNodeResult
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
nsIContent
&
aContent
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
aContent
)
)
{
uint32_t
offsetAtInserting
=
aPointToInsert
.
Offset
(
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
aContent
aPointToInsert
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
MoveNodeResult
(
rv
)
;
}
return
MoveNodeHandled
(
aPointToInsert
.
GetContainer
(
)
+
+
offsetAtInserting
)
;
}
MoveNodeResult
result
;
if
(
aContent
.
IsElement
(
)
)
{
result
=
MoveChildrenWithTransaction
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
aPointToInsert
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
"
)
;
return
result
;
}
}
else
{
result
=
MoveNodeHandled
(
aPointToInsert
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
MoveNodeResult
(
rv
)
;
}
if
(
MaybeHasMutationEventListeners
(
)
)
{
if
(
!
result
.
NextInsertionPointRef
(
)
.
IsSetAndValid
(
)
)
{
result
=
MoveNodeHandled
(
EditorDOMPoint
:
:
AtEndOf
(
*
aPointToInsert
.
GetContainer
(
)
)
)
;
}
}
return
result
;
}
MoveNodeResult
HTMLEditor
:
:
MoveChildrenWithTransaction
(
Element
&
aElement
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
aPointToInsert
.
GetContainer
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MoveNodeResult
result
=
MoveNodeIgnored
(
aPointToInsert
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
result
|
=
MoveNodeOrChildrenWithTransaction
(
MOZ_KnownLive
(
*
aElement
.
GetFirstChild
(
)
)
result
.
NextInsertionPoint
(
)
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
)
failed
"
)
;
return
result
;
}
}
return
result
;
}
void
HTMLEditor
:
:
MoveAllChildren
(
nsINode
&
aContainer
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
Failed
(
)
)
;
if
(
!
aContainer
.
HasChildren
(
)
)
{
return
;
}
nsIContent
*
firstChild
=
aContainer
.
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
aContainer
.
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MoveChildrenBetween
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveChildrenBetween
(
)
failed
"
)
;
}
void
HTMLEditor
:
:
MoveChildrenBetween
(
nsIContent
&
aFirstChild
nsIContent
&
aLastChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsINode
>
oldContainer
=
aFirstChild
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
oldContainer
!
=
aLastChild
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
CanContainerHaveChildren
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
children
;
for
(
nsIContent
*
child
=
&
aFirstChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
child
)
;
if
(
child
=
=
&
aLastChild
)
{
break
;
}
}
if
(
NS_WARN_IF
(
children
.
LastElement
(
)
!
=
&
aLastChild
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsCOMPtr
<
nsINode
>
newContainer
=
aPointToInsert
.
GetContainer
(
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
aPointToInsert
.
GetChild
(
)
;
for
(
size_t
i
=
children
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
&
child
=
children
[
i
-
1
]
;
if
(
child
-
>
GetParentNode
(
)
!
=
oldContainer
)
{
continue
;
}
oldContainer
-
>
RemoveChild
(
*
child
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
RemoveChild
(
)
failed
"
)
;
return
;
}
if
(
nextNode
)
{
EditorRawDOMPoint
pointToInsert
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
pointToInsert
.
GetContainer
(
)
!
=
newContainer
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
newContainer
-
>
InsertBefore
(
*
child
nextNode
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
;
}
if
(
child
-
>
GetParentNode
(
)
=
=
newContainer
)
{
nextNode
=
child
;
}
}
}
void
HTMLEditor
:
:
MovePreviousSiblings
(
nsIContent
&
aChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
!
aChild
.
GetParentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsIContent
*
firstChild
=
aChild
.
GetParentNode
(
)
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
&
aChild
=
=
firstChild
?
firstChild
:
aChild
.
GetPreviousSibling
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MoveChildrenBetween
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveChildrenBetween
(
)
failed
"
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteContentButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
&
aContent
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aContent
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
*
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteContentButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteContentButKeepTableStructure
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteMostAncestorMailCiteElementIfEmpty
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
mailCiteElement
=
GetMostAncestorMailCiteElement
(
aContent
)
;
if
(
!
mailCiteElement
)
{
return
NS_OK
;
}
bool
seenBR
=
false
;
if
(
!
IsEmptyNodeImpl
(
*
mailCiteElement
true
true
false
&
seenBR
)
)
{
return
NS_OK
;
}
EditorDOMPoint
atEmptyMailCiteElement
(
mailCiteElement
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atEmptyMailCiteElement
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
mailCiteElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
atEmptyMailCiteElement
.
IsSet
(
)
|
|
!
seenBR
)
{
NS_WARNING_ASSERTION
(
atEmptyMailCiteElement
.
IsSet
(
)
"
Mutation
event
listener
might
changed
the
DOM
tree
during
"
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
but
ignored
"
)
;
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
atEmptyMailCiteElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
brElement
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
nsAtom
&
aListElementOrListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
?
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
EditSubAction
:
:
eCreateOrChangeList
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
nsAtom
*
listTagName
=
nullptr
;
nsAtom
*
listItemTagName
=
nullptr
;
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
li
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
dd
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
{
listTagName
=
nsGkAtoms
:
:
dl
;
listItemTagName
=
&
aListElementOrListItemElementTagName
;
}
else
{
NS_WARNING
(
"
aListElementOrListItemElementTagName
was
neither
list
element
name
"
"
nor
"
"
definition
listitem
element
name
"
)
;
return
EditActionResult
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
result
=
ChangeSelectedHardLinesToList
(
MOZ_KnownLive
(
*
listTagName
)
MOZ_KnownLive
(
*
listItemTagName
)
aBulletType
aSelectAllOfCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
ChangeSelectedHardLinesToList
(
)
failed
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
ChangeSelectedHardLinesToList
(
nsAtom
&
aListElementTagName
nsAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
Element
*
parentListElement
=
aSelectAllOfCurrentList
=
=
SelectAllOfCurrentList
:
:
Yes
?
GetParentListElementAtSelection
(
)
:
nullptr
;
if
(
parentListElement
)
{
arrayOfContents
.
AppendElement
(
OwningNonNull
<
nsIContent
>
(
*
parentListElement
)
)
;
}
else
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
bool
bOnlyBreaks
=
true
;
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsEmptyInlineNode
(
content
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
content
:
arrayOfContents
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
}
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atStartOfSelection
.
GetContainer
(
)
aListElementTagName
)
)
{
return
EditActionCanceled
(
)
;
}
SplitNodeResult
splitAtSelectionStartResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListElementTagName
atStartOfSelection
)
;
if
(
splitAtSelectionStartResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
splitAtSelectionStartResult
.
Rv
(
)
)
;
}
RefPtr
<
Element
>
theList
=
CreateNodeWithTransaction
(
aListElementTagName
splitAtSelectionStartResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
theList
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
theListItem
=
CreateNodeWithTransaction
(
aListItemElementTagName
EditorDOMPoint
(
theList
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
theListItem
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theListItem
;
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
theListItem
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
if
(
Element
*
deepestDivBlockquoteOrListElement
=
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
arrayOfContents
[
0
]
)
)
{
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
arrayOfContents
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
arrayOfContents
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
}
else
{
arrayOfContents
.
ReplaceElementAt
(
0
OwningNonNull
<
nsIContent
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
}
}
}
uint32_t
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
RefPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
countOfCollectedContents
;
i
+
+
)
{
OwningNonNull
<
nsIContent
>
content
=
arrayOfContents
[
i
]
;
if
(
curList
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
curList
content
)
)
{
curList
=
nullptr
;
}
if
(
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
IsEmptyInlineNode
(
content
)
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
content
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
convertListTypeResult
.
GetNewNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
prevListItem
=
nullptr
;
continue
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
curList
=
convertListTypeResult
.
forget
(
)
;
prevListItem
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atContent
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
!
atContent
.
IsContainerHTMLElement
(
&
aListElementTagName
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
content
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atContent
.
GetContainerAsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atContent
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
curList
=
CreateNodeWithTransaction
(
aListElementTagName
EditorDOMPoint
(
atContent
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
curList
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
else
{
if
(
!
curList
)
{
curList
=
atContent
.
GetContainerAsElement
(
)
;
NS_WARNING_ASSERTION
(
HTMLEditUtils
:
:
IsAnyListElement
(
curList
)
"
Current
list
item
parent
is
not
a
list
element
"
)
;
}
else
if
(
atContent
.
GetContainer
(
)
!
=
curList
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
if
(
!
content
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
Element
*
element
=
Element
:
:
FromNode
(
content
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aBulletType
.
IsEmpty
(
)
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
aBulletType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
!
element
-
>
HasAttr
(
nsGkAtoms
:
:
type
)
)
{
continue
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
element
)
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
type
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
&
&
!
HTMLEditUtils
:
:
IsListItem
(
content
)
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
CollectChildren
(
*
content
arrayOfContents
i
+
1
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
countOfCollectedContents
=
arrayOfContents
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
SplitNodeResult
splitCurNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListElementTagName
atContent
)
;
if
(
splitCurNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
splitCurNodeResult
.
Rv
(
)
)
;
}
prevListItem
=
nullptr
;
curList
=
CreateNodeWithTransaction
(
aListElementTagName
splitCurNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
curList
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curList
;
atContent
.
Clear
(
)
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
prevListItem
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
content
*
prevListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
prevListItem
=
nullptr
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
continue
;
}
RefPtr
<
Element
>
newListItemElement
=
InsertContainerWithTransaction
(
*
content
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
prevListItem
=
newListItemElement
;
}
else
{
prevListItem
=
nullptr
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveList
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
return
rv
;
}
}
for
(
int32_t
i
=
arrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
i
]
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
nsAtom
&
blockType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
firstRange
-
>
StartRef
(
)
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
if
(
!
pointToInsertBlock
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
because
container
of
the
point
is
not
content
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
pointToInsertBlock
.
ContainerAsContent
(
)
)
;
if
(
!
blockElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
couldn
'
t
find
"
"
block
parent
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
blockElement
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
GetNextEditableHTMLNode
(
pointToInsertBlock
)
;
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
blockElement
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
EditorDOMPoint
pointToInsertBRNode
(
splitNodeResult
.
SplitPoint
(
)
)
;
brContent
=
InsertBRElementWithTransaction
(
pointToInsertBRNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brContent
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
brContent
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
brNode
=
GetNextEditableHTMLNodeInBlock
(
pointToInsertBlock
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElement
(
brNode
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
blockType
pointToInsertBlock
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
block
=
CreateNodeWithTransaction
(
blockType
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
block
)
{
NS_WARNING
(
"
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
block
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
rv
=
CollapseSelectionToStartOf
(
*
block
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
nsresult
rv
=
MoveNodesIntoNewBlockquoteElement
(
arrayOfContents
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
)
failed
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
RemoveBlockContainerElements
(
arrayOfContents
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerElements
(
)
failed
"
)
;
return
rv
;
}
rv
=
CreateOrChangeBlockContainerElement
(
arrayOfContents
blockType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
Container
(
)
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Element
>
startContainerElement
=
*
atStartOfSelection
.
Container
(
)
-
>
AsElement
(
)
;
nsresult
rv
=
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
startContainerElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
IndentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eIndent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleIndentAtSelection
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleIndentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
IndentListChild
(
RefPtr
<
Element
>
*
aCurList
const
EditorDOMPoint
&
aCurPoint
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
aCurPoint
.
GetContainer
(
)
)
"
unexpected
container
"
)
;
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
nsIContent
*
nextEditableSibling
=
GetNextHTMLSibling
(
&
aContent
SkipWhiteSpace
:
:
Yes
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
nextEditableSibling
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aContent
EditorDOMPoint
(
nextEditableSibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EdigtorBase
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
GetPriorHTMLSibling
(
&
aContent
SkipWhiteSpace
:
:
Yes
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
previousEditableSibling
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aContent
*
previousEditableSibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsIContent
*
previousEditableSibling
=
*
aCurList
?
GetPriorHTMLSibling
(
&
aContent
SkipWhiteSpace
:
:
Yes
)
:
nullptr
;
if
(
!
*
aCurList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
*
aCurList
)
)
{
nsAtom
*
containerName
=
aCurPoint
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
aCurPoint
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
*
aCurList
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
*
aCurList
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
*
aCurList
;
}
RefPtr
<
nsINode
>
container
=
*
aCurList
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
aContent
*
container
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
HandleIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
HandleCSSIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleCSSIndentAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
HandleHTMLIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleHTMLIndent
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
HandleCSSIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleCSSIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCaret
.
IsInContentNode
(
)
)
;
Element
*
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
atCaret
.
ContainerAsContent
(
)
)
;
if
(
blockElement
&
&
HTMLEditUtils
:
:
IsListItem
(
blockElement
)
)
{
arrayOfContents
.
AppendElement
(
*
blockElement
)
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eIndent
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
if
(
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
:
"
"
div
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
theBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theBlock
;
nsresult
rv
=
ChangeMarginStart
(
*
theBlock
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
rv
=
CollapseSelectionToStartOf
(
*
theBlock
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
curList
curQuote
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
IndentListChild
(
&
curList
atContent
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChild
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
curQuote
=
nullptr
;
continue
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
"
"
:
div
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curQuote
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
ChangeMarginStart
(
*
curQuote
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curQuote
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
HandleHTMLIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HandleHTMLIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eIndent
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfContents
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
eIndent
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atStartOfSelection
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
:
"
"
blockquote
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
theBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theBlock
;
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
theBlock
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
curList
curQuote
indentedLI
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
IndentListChild
(
&
curList
atContent
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
IndentListChild
(
)
failed
"
)
;
return
rv
;
}
curQuote
=
nullptr
;
continue
;
}
if
(
RefPtr
<
Element
>
listItem
=
GetNearestAncestorListItemElement
(
content
)
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
nsIContent
*
previousEditableSibling
=
curList
?
GetPriorHTMLSibling
(
listItem
)
:
nullptr
;
if
(
!
curList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
"
"
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curList
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
rv
=
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
curQuote
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
curQuote
content
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
"
"
:
blockquote
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curQuote
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
blockquote
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curQuote
;
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
OutdentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eOutdent
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
result
|
=
HandleOutdentAtSelection
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
SplitRangeOffFromNodeResult
outdentResult
=
HandleOutdentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
failed
"
)
;
return
EditActionHandled
(
outdentResult
.
Rv
(
)
)
;
}
if
(
!
outdentResult
.
GetLeftContent
(
)
&
&
!
outdentResult
.
GetRightContent
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
outdentResult
.
GetLeftContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetLeftContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetLeftContent
(
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
EditorRawDOMPoint
:
:
After
(
*
outdentResult
.
GetLeftContent
(
)
)
)
;
NS_WARNING_ASSERTION
(
afterRememberedLeftBQ
.
IsSet
(
)
"
Failed
to
set
after
remembered
left
blockquote
element
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
afterRememberedLeftBQ
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
if
(
outdentResult
.
GetRightContent
(
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetRightContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetRightContent
(
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
outdentResult
.
GetRightContent
(
)
)
;
nsresult
rv
=
CollapseSelectionTo
(
atRememberedRightBQ
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
return
EditActionHandled
(
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eOutdent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
)
"
"
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
leftContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
middleContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
rightContentOfLastOutdented
;
RefPtr
<
Element
>
indentedParentElement
;
nsCOMPtr
<
nsIContent
>
firstContentToBeOutdented
lastContentToBeOutdented
;
BlockIndentedWith
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
indentedParentElement
)
{
MOZ_ASSERT
(
indentedParentElement
=
=
content
)
;
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
content
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
=
0
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
"
"
Decrease
)
failed
but
ignored
"
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
if
(
indentedParentElement
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
indentedParentElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
indentedParentElement
)
)
{
lastContentToBeOutdented
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
outdentResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
}
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
for
(
nsCOMPtr
<
nsIContent
>
parentContent
=
content
-
>
GetParent
(
)
;
parentContent
&
&
!
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
parentContent
!
=
editingHost
&
&
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentContent
)
)
;
parentContent
=
parentContent
-
>
GetParent
(
)
)
{
if
(
parentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
break
;
}
if
(
!
useCSS
)
{
continue
;
}
nsCOMPtr
<
nsINode
>
grandParentNode
=
parentContent
-
>
GetParentNode
(
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
grandParentNode
!
=
parentContent
-
>
GetParentNode
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
parentContent
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
startMargin
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
&
&
!
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
)
{
indentedParentElement
=
parentContent
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
content
;
lastContentToBeOutdented
=
content
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
CSS
;
break
;
}
}
if
(
indentedParentElement
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
lastChildContent
=
content
-
>
GetLastChild
(
)
;
lastChildContent
;
lastChildContent
=
content
-
>
GetLastChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
lastChildContent
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
lastChildContent
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
No
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
lastChildContent
)
)
{
EditorDOMPoint
afterCurrentList
(
EditorDOMPoint
:
:
After
(
atContent
)
)
;
NS_WARNING_ASSERTION
(
afterCurrentList
.
IsSet
(
)
"
Failed
to
set
it
to
after
current
list
element
"
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
*
lastChildContent
afterCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
lastChildContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
)
{
if
(
RefPtr
<
Element
>
element
=
content
-
>
GetAsElementOrParentElement
(
)
)
{
nsresult
rv
=
ChangeMarginStart
(
*
element
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
"
"
Decrease
)
failed
but
ignored
"
)
;
}
continue
;
}
}
if
(
!
indentedParentElement
)
{
return
SplitRangeOffFromNodeResult
(
leftContentOfLastOutdented
middleContentOfLastOutdented
rightContentOfLastOutdented
)
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
NS_WARNING_ASSERTION
(
outdentResult
.
Succeeded
(
)
"
HTMLEditor
:
:
OutdentPartOfBlock
(
)
failed
"
)
;
return
outdentResult
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
Element
&
aBlockElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfRange
aEndOfRange
)
;
if
(
NS_WARN_IF
(
splitResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
splitResult
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aBlockElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartOfMiddleElement
aBlockElement
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aEndOfMiddleElement
aBlockElement
)
)
;
SplitNodeResult
splitAtStartResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
EditorDOMPoint
(
&
aStartOfMiddleElement
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtStartResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
EditorDOMPoint
atAfterEnd
(
&
aEndOfMiddleElement
)
;
DebugOnly
<
bool
>
advanced
=
atAfterEnd
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
end
node
"
)
;
SplitNodeResult
splitAtEndResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtEndResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
splitAtEndResult
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOfOutdent
BlockIndentedWith
aBlockIndentedWith
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfOutdent
aEndOfOutdent
)
;
if
(
NS_WARN_IF
(
splitResult
.
EditorDestroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
splitResult
.
GetMiddleContentAsElement
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
didn
'
t
return
middle
content
"
)
;
return
SplitRangeOffFromNodeResult
(
NS_ERROR_FAILURE
)
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitRangeOffFromBlock
(
)
failed
but
might
be
ignored
"
)
;
if
(
aBlockIndentedWith
=
=
BlockIndentedWith
:
:
HTML
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
if
(
splitResult
.
GetMiddleContentAsElement
(
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeMarginStart
(
ChangeMargin
:
:
Decrease
)
failed
"
)
;
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
splitResult
;
}
return
splitResult
;
}
CreateElementResult
HTMLEditor
:
:
ChangeListElementType
(
Element
&
aListElement
nsAtom
&
aNewListTag
nsAtom
&
aNewListItemTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
nsIContent
*
childContent
=
aListElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsElement
(
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListItemTag
)
)
{
OwningNonNull
<
Element
>
listItemElement
=
*
childContent
-
>
AsElement
(
)
;
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
listItemElement
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newListItemElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
childContent
=
newListItemElement
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListTag
)
)
{
OwningNonNull
<
Element
>
listElement
=
*
childContent
-
>
AsElement
(
)
;
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
listElement
aNewListTag
aNewListItemTag
)
;
if
(
convertListTypeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
"
)
;
return
convertListTypeResult
;
}
childContent
=
convertListTypeResult
.
GetNewNode
(
)
;
continue
;
}
}
if
(
aListElement
.
IsHTMLElement
(
&
aNewListTag
)
)
{
return
CreateElementResult
(
&
aListElement
)
;
}
RefPtr
<
Element
>
listElement
=
ReplaceContainerWithTransaction
(
aListElement
aNewListTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
listElement
"
HTMLEditor
:
:
ReplaceContainerWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
std
:
:
move
(
listElement
)
)
;
}
nsresult
HTMLEditor
:
:
CreateStyleForInsertText
(
const
AbstractRange
&
aAbstractRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAbstractRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
mTypeInState
)
;
RefPtr
<
Element
>
documentRootElement
=
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
documentRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
PropItem
>
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
EditorDOMPoint
pointToPutCaret
(
aAbstractRange
.
StartRef
(
)
)
;
bool
putCaret
=
false
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
while
(
item
&
&
pointToPutCaret
.
GetContainer
(
)
!
=
documentRootElement
)
{
EditResult
result
=
ClearStyleAt
(
pointToPutCaret
MOZ_KnownLive
(
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearStyleAt
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
pointToPutCaret
=
result
.
PointRefToCollapseSelection
(
)
;
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
putCaret
=
true
;
}
}
int32_t
relFontSize
=
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
if
(
item
|
|
relFontSize
)
{
if
(
pointToPutCaret
.
IsInTextNode
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToPutCaret
.
GetContainerAsText
(
)
)
pointToPutCaret
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitTextNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitTextNodeResult
.
Rv
(
)
;
}
pointToPutCaret
=
splitTextNodeResult
.
SplitPoint
(
)
;
}
if
(
!
pointToPutCaret
.
IsInContentNode
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
pointToPutCaret
.
ContainerAsContent
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
Text
>
newEmptyTextNode
=
CreateTextNode
(
EmptyString
(
)
)
;
if
(
!
newEmptyTextNode
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateTextNode
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InsertNodeWithTransaction
(
*
newEmptyTextNode
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
pointToPutCaret
.
Set
(
newEmptyTextNode
0
)
;
putCaret
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
nsresult
rv
=
RelativeFontChangeOnTextNode
(
dir
*
newEmptyTextNode
0
-
1
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RelativeFontChangeOnTextNode
(
)
failed
"
)
;
return
rv
;
}
}
}
while
(
item
)
{
nsresult
rv
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
pointToPutCaret
.
GetContainerAsContent
(
)
)
MOZ_KnownLive
(
*
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
item
-
>
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetInlinePropertyOnNode
(
)
failed
"
)
;
return
rv
;
}
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
!
putCaret
)
{
return
NS_OK
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
const
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
false
;
}
return
IsEmptyNode
(
aElement
aIgnoreSingleBR
=
=
IgnoreSingleBR
:
:
Yes
)
;
}
EditActionResult
HTMLEditor
:
:
AlignAsSubAction
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetOrClearAlignment
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
EditActionIgnored
(
)
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
rv
=
AlignContentsAtSelection
(
aAlignType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
"
"
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
bool
createEmptyDivElement
=
arrayOfContents
.
IsEmpty
(
)
;
if
(
arrayOfContents
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsIContent
>
&
content
=
arrayOfContents
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBlockElementAlign
(
)
failed
"
)
;
return
rv
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
atStartOfSelection
.
Container
(
)
;
createEmptyDivElement
=
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
createEmptyDivElement
)
{
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutaiton
event
listener
might
have
changed
the
selection
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditActionResult
result
=
AlignContentsAtSelectionWithEmptyDivElement
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
AlignContentsAtSelectionWithEmptyDivElement
(
)
failed
"
)
;
if
(
result
.
Handled
(
)
)
{
restoreSelectionLater
.
Abort
(
)
;
}
return
rv
;
}
rv
=
AlignNodesAndDescendants
(
arrayOfContents
aAlignType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AlignNodesAndDescendants
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AlignContentsAtSelectionWithEmptyDivElement
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
:
"
"
div
)
failed
"
)
;
return
EditActionResult
(
splitNodeResult
.
Rv
(
)
)
;
}
EditorDOMPoint
pointToInsertDiv
(
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
GetNextEditableHTMLNodeInBlock
(
splitNodeResult
.
SplitPoint
(
)
)
)
{
if
(
maybeBRContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
pointToInsertDiv
.
GetChild
(
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
GetNextHTMLSibling
(
pointToInsertDiv
.
GetChild
(
)
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableSibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertDiv
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
}
}
}
RefPtr
<
Element
>
divElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
pointToInsertDiv
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
divElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
divElement
;
nsresult
rv
=
SetBlockElementAlign
(
*
divElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
divElement
0
)
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
EditActionResult
(
createPaddingBRResult
.
Rv
(
)
)
;
}
rv
=
CollapseSelectionToStartOf
(
*
divElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignNodesAndDescendants
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
const
nsAString
&
aAlignType
)
{
AutoTArray
<
bool
64
>
transitionList
;
HTMLEditor
:
:
MakeTransitionList
(
aArrayOfContents
transitionList
)
;
RefPtr
<
Element
>
createdDivElement
;
bool
useCSS
=
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
+
+
indexOfTransitionList
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
content
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
NodeAndDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
NodeAndDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsAnyTableElement
(
atContent
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atContent
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
|
|
IsEmptyNode
(
*
content
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
Element
*
listOrListItemElement
=
content
-
>
AsElement
(
)
;
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atContent
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
if
(
useCSS
)
{
if
(
nsStyledElement
*
styledListOrListItemElement
=
nsStyledElement
:
:
FromNode
(
listOrListItemElement
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledListOrListItemElement
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
align
)
failed
but
ignored
"
)
;
}
}
createdDivElement
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsresult
rv
=
AlignContentsInAllTableCellsAndListItems
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
)
failed
"
)
;
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
}
if
(
!
createdDivElement
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
atContent
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
"
"
:
div
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
createdDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
createdDivElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
createdDivElement
;
nsresult
rv
=
SetBlockElementAlign
(
*
createdDivElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBlockElementAlign
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
Element
&
aElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfTableCellsAndListItems
;
DOMIterator
iter
(
aElement
)
;
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
-
>
bool
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
return
HTMLEditUtils
:
:
IsTableCell
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
&
aNode
)
;
}
arrayOfTableCellsAndListItems
)
;
for
(
auto
&
tableCellOrListItemElement
:
arrayOfTableCellsAndListItems
)
{
nsresult
rv
=
AlignBlockContentsWithDivElement
(
MOZ_KnownLive
(
tableCellOrListItemElement
)
aAlignType
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
Element
&
aBlockElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstEditableContent
=
GetFirstEditableChild
(
aBlockElement
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastEditableContent
=
GetLastEditableChild
(
aBlockElement
)
;
if
(
firstEditableContent
=
=
lastEditableContent
&
&
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
MOZ_KnownLive
(
firstEditableContent
-
>
AsElement
(
)
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
divElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
&
aBlockElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
divElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
SetAttributeOrEquivalent
(
divElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
while
(
lastEditableContent
&
&
(
lastEditableContent
!
=
divElement
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
lastEditableContent
EditorDOMPoint
(
divElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
lastEditableContent
=
GetLastEditableChild
(
aBlockElement
)
;
}
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
ScanEmptyBlockInclusiveAncestor
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aStartContent
Element
&
aEditingHostElement
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
aEditingHostElement
)
)
{
return
nullptr
;
}
Element
*
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
aStartContent
)
;
if
(
!
blockElement
)
{
return
nullptr
;
}
while
(
blockElement
&
&
blockElement
!
=
&
aEditingHostElement
&
&
!
HTMLEditUtils
:
:
IsAnyTableElement
(
blockElement
)
&
&
aHTMLEditor
.
IsEmptyNode
(
*
blockElement
true
false
)
)
{
mEmptyInclusiveAncestorBlockElement
=
blockElement
;
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
mEmptyInclusiveAncestorBlockElement
)
;
}
if
(
!
mEmptyInclusiveAncestorBlockElement
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
mEmptyInclusiveAncestorBlockElement
-
>
IsEditable
(
)
)
|
|
NS_WARN_IF
(
!
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
)
{
mEmptyInclusiveAncestorBlockElement
=
nullptr
;
}
return
mEmptyInclusiveAncestorBlockElement
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
ComputeTargetRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNone
:
break
;
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
startPoint
=
HTMLEditUtils
:
:
GetPreviousEditablePoint
<
EditorRawDOMPoint
>
(
*
mEmptyInclusiveAncestorBlockElement
&
aEditingHost
InvisibleWhiteSpaces
:
:
Preserve
TableBoundary
:
:
NoCrossAnyTableElement
)
;
if
(
!
startPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
didn
'
t
return
a
valid
"
"
point
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
startPoint
EditorRawDOMPoint
:
:
AtEndOf
(
mEmptyInclusiveAncestorBlockElement
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
EditorRawDOMPoint
endPoint
=
HTMLEditUtils
:
:
GetNextEditablePoint
<
EditorRawDOMPoint
>
(
*
mEmptyInclusiveAncestorBlockElement
&
aEditingHost
InvisibleWhiteSpaces
:
:
Preserve
TableBoundary
:
:
NoCrossAnyTableElement
)
;
if
(
!
endPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetNextEditablePoint
(
)
didn
'
t
return
a
valid
"
"
point
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
EditorRawDOMPoint
(
mEmptyInclusiveAncestorBlockElement
0
)
endPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Handle
the
nsIEditor
:
:
EDirection
value
"
)
;
break
;
}
nsresult
rv
=
aRangesToDelete
.
SelectNode
(
*
mEmptyInclusiveAncestorBlockElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SelectNode
(
)
failed
"
)
;
return
rv
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
MaybeInsertBRElementBeforeEmptyListItemElement
(
HTMLEditor
&
aHTMLEditor
)
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
!
aHTMLEditor
.
IsFirstEditableChild
(
mEmptyInclusiveAncestorBlockElement
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
EditorDOMPoint
atParentOfEmptyListItem
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
if
(
NS_WARN_IF
(
!
atParentOfEmptyListItem
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atParentOfEmptyListItem
.
GetContainer
(
)
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
RefPtr
<
Element
>
brElement
=
aHTMLEditor
.
InsertBRElementWithTransaction
(
atParentOfEmptyListItem
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
brElement
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
GetNewCaretPoisition
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
const
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
EditorDOMPoint
afterEmptyBlock
(
EditorRawDOMPoint
:
:
After
(
mEmptyInclusiveAncestorBlockElement
)
)
;
MOZ_ASSERT
(
afterEmptyBlock
.
IsSet
(
)
)
;
if
(
nsIContent
*
nextContentOfEmptyBlock
=
aHTMLEditor
.
GetNextNode
(
afterEmptyBlock
)
)
{
EditorDOMPoint
pt
=
aHTMLEditor
.
GetGoodCaretPointFor
(
*
nextContentOfEmptyBlock
aDirectionAndAmount
)
;
if
(
!
pt
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
pt
;
}
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
afterEmptyBlock
;
}
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
atEmptyBlock
(
mEmptyInclusiveAncestorBlockElement
)
;
if
(
nsIContent
*
previousContentOfEmptyBlock
=
aHTMLEditor
.
GetPreviousEditableNode
(
atEmptyBlock
)
)
{
EditorDOMPoint
pt
=
aHTMLEditor
.
GetGoodCaretPointFor
(
*
previousContentOfEmptyBlock
aDirectionAndAmount
)
;
if
(
!
pt
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
pt
;
}
EditorDOMPoint
afterEmptyBlock
(
EditorRawDOMPoint
:
:
After
(
*
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
afterEmptyBlock
;
}
case
nsIEditor
:
:
eNone
:
return
EditorDOMPoint
(
)
;
default
:
MOZ_CRASH
(
"
AutoEmptyBlockAncestorDeleter
doesn
'
t
support
this
action
yet
"
)
;
return
EditorDOMPoint
(
)
;
}
}
EditActionResult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
mEmptyInclusiveAncestorBlockElement
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
MaybeInsertBRElementBeforeEmptyListItemElement
(
aHTMLEditor
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoEmptyBlockAncestorDeleter
:
:
"
"
MaybeInsertBRElementBeforeEmptyListItemElement
(
)
failed
"
)
;
return
EditActionResult
(
result
.
inspectErr
(
)
)
;
}
if
(
RefPtr
<
Element
>
brElement
=
result
.
unwrap
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
EditorRawDOMPoint
(
brElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
}
else
{
Result
<
EditorDOMPoint
nsresult
>
result
=
GetNewCaretPoisition
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoEmptyBlockAncestorDeleter
:
:
GetNewCaretPoisition
(
)
failed
"
)
;
return
EditActionResult
(
result
.
inspectErr
(
)
)
;
}
if
(
result
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
result
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
}
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
size_t
HTMLEditor
:
:
CollectChildren
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
CollectListChildren
aCollectListChildren
CollectTableChildren
aCollectTableChildren
CollectNonEditableNodes
aCollectNonEditableNodes
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
size_t
numberOfFoundChildren
=
0
;
for
(
nsIContent
*
content
=
GetFirstEditableChild
(
aNode
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
(
aCollectListChildren
=
=
CollectListChildren
:
:
Yes
&
&
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
)
|
|
(
aCollectTableChildren
=
=
CollectTableChildren
:
:
Yes
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
)
)
{
numberOfFoundChildren
+
=
CollectChildren
(
*
content
aOutArrayOfContents
aIndexToInsertChildren
+
numberOfFoundChildren
aCollectListChildren
aCollectTableChildren
aCollectNonEditableNodes
)
;
}
else
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
Yes
|
|
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
aOutArrayOfContents
.
InsertElementAt
(
aIndexToInsertChildren
+
numberOfFoundChildren
+
+
*
content
)
;
}
}
return
numberOfFoundChildren
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ExtendRangeToIncludeInvisibleNodes
(
const
HTMLEditor
&
aHTMLEditor
const
nsFrameSelection
*
aFrameSelection
nsRange
&
aRange
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRange
.
Collapsed
(
)
)
;
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
!
aRange
.
IsInSelection
(
)
)
;
EditorRawDOMPoint
atStart
(
aRange
.
StartRef
(
)
)
;
EditorRawDOMPoint
atEnd
(
aRange
.
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
aRange
.
GetClosestCommonInclusiveAncestor
(
)
-
>
IsContent
(
)
)
)
{
return
false
;
}
Element
*
commonAncestorBlock
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
aRange
.
GetClosestCommonInclusiveAncestor
(
)
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
commonAncestorBlock
)
)
{
return
false
;
}
Element
*
editingHost
=
aHTMLEditor
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
false
;
}
if
(
atStart
.
GetContainer
(
)
!
=
commonAncestorBlock
&
&
atStart
.
GetContainer
(
)
!
=
editingHost
)
{
for
(
;
;
)
{
WSScanResult
backwardScanFromStartResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
aHTMLEditor
atStart
)
;
if
(
!
backwardScanFromStartResult
.
ReachedCurrentBlockBoundary
(
)
)
{
break
;
}
MOZ_ASSERT
(
backwardScanFromStartResult
.
GetContent
(
)
=
=
WSRunScanner
(
aHTMLEditor
atStart
)
.
GetStartReasonContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
backwardScanFromStartResult
.
GetContent
(
)
)
|
|
backwardScanFromStartResult
.
GetContent
(
)
=
=
commonAncestorBlock
|
|
backwardScanFromStartResult
.
GetContent
(
)
=
=
editingHost
)
{
break
;
}
atStart
=
backwardScanFromStartResult
.
PointAtContent
(
)
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
atStart
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
start
container
was
out
of
selection
limiter
"
)
;
return
false
;
}
}
if
(
atEnd
.
GetContainer
(
)
!
=
commonAncestorBlock
&
&
atEnd
.
GetContainer
(
)
!
=
editingHost
)
{
EditorDOMPoint
atFirstInvisibleBRElement
;
for
(
;
;
)
{
WSRunScanner
wsScannerAtEnd
(
aHTMLEditor
atEnd
)
;
WSScanResult
forwardScanFromEndResult
=
wsScannerAtEnd
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
atEnd
)
;
if
(
forwardScanFromEndResult
.
ReachedBRElement
(
)
)
{
NS_ASSERTION
(
wsScannerAtEnd
.
GetEndReasonContent
(
)
=
=
forwardScanFromEndResult
.
BRElementPtr
(
)
"
End
reason
is
not
the
reached
<
br
>
element
"
)
;
if
(
aHTMLEditor
.
IsVisibleBRElement
(
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
)
{
break
;
}
if
(
!
atFirstInvisibleBRElement
.
IsSet
(
)
)
{
atFirstInvisibleBRElement
=
atEnd
;
}
atEnd
.
SetAfter
(
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
;
continue
;
}
if
(
forwardScanFromEndResult
.
ReachedCurrentBlockBoundary
(
)
)
{
MOZ_ASSERT
(
forwardScanFromEndResult
.
GetContent
(
)
=
=
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
forwardScanFromEndResult
.
GetContent
(
)
)
|
|
forwardScanFromEndResult
.
GetContent
(
)
=
=
commonAncestorBlock
|
|
forwardScanFromEndResult
.
GetContent
(
)
=
=
editingHost
)
{
break
;
}
atEnd
=
forwardScanFromEndResult
.
PointAfterContent
(
)
;
continue
;
}
break
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
atEnd
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
end
container
was
out
of
selection
limiter
"
)
;
return
false
;
}
if
(
atFirstInvisibleBRElement
.
IsInContentNode
(
)
)
{
if
(
RefPtr
<
Element
>
brElementParent
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
atFirstInvisibleBRElement
.
ContainerAsContent
(
)
)
)
{
EditorRawDOMRange
range
(
atStart
atEnd
)
;
if
(
range
.
Contains
(
EditorRawDOMPoint
(
brElementParent
)
)
)
{
nsresult
rv
=
aRange
.
SetStartAndEnd
(
atStart
.
ToRawRangeBoundary
(
)
atEnd
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
to
extend
the
range
"
)
;
return
false
;
}
return
aRange
.
IsPositioned
(
)
&
&
aRange
.
StartRef
(
)
.
IsSet
(
)
&
&
aRange
.
EndRef
(
)
.
IsSet
(
)
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
atFirstInvisibleBRElement
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
end
container
(
<
br
>
element
)
was
out
of
selection
"
"
limiter
"
)
;
return
false
;
}
atEnd
=
atFirstInvisibleBRElement
;
}
}
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
atStart
.
ToRawRangeBoundary
(
)
atEnd
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
to
extend
the
range
"
)
;
return
false
;
}
return
aRange
.
IsPositioned
(
)
&
&
aRange
.
StartRef
(
)
.
IsSet
(
)
&
&
aRange
.
EndRef
(
)
.
IsSet
(
)
;
}
nsresult
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
const
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMPoint
startPoint
(
range
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMPoint
endPoint
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
newStartPoint
(
startPoint
)
;
EditorDOMPoint
newEndPoint
(
endPoint
)
;
WSRunScanner
wsScannerAtEnd
(
*
this
endPoint
)
;
if
(
wsScannerAtEnd
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
endPoint
)
.
ReachedSomething
(
)
)
{
if
(
wsScannerAtEnd
.
StartsFromOtherBlockElement
(
)
)
{
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafChild
(
*
wsScannerAtEnd
.
StartReasonOtherBlockElementPtr
(
)
ChildBlockBoundary
:
:
TreatAsLeaf
)
;
if
(
child
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
else
if
(
wsScannerAtEnd
.
StartsFromCurrentBlockBoundary
(
)
)
{
nsINode
*
child
=
GetPreviousEditableHTMLNode
(
endPoint
)
;
if
(
child
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
else
if
(
wsScannerAtEnd
.
StartsFromBRElement
(
)
)
{
newEndPoint
.
Set
(
wsScannerAtEnd
.
StartReasonBRElementPtr
(
)
)
;
}
}
WSRunScanner
wsScannerAtStart
(
*
this
startPoint
)
;
if
(
wsScannerAtStart
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
startPoint
)
.
ReachedSomething
(
)
)
{
if
(
wsScannerAtStart
.
EndsByOtherBlockElement
(
)
)
{
nsINode
*
child
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
wsScannerAtStart
.
EndReasonOtherBlockElementPtr
(
)
ChildBlockBoundary
:
:
TreatAsLeaf
)
;
if
(
child
)
{
newStartPoint
.
Set
(
child
)
;
}
}
else
if
(
wsScannerAtStart
.
EndsByCurrentBlockBoundary
(
)
)
{
nsINode
*
child
=
GetNextEditableHTMLNode
(
startPoint
)
;
if
(
child
)
{
newStartPoint
.
Set
(
child
)
;
}
}
else
if
(
wsScannerAtStart
.
EndsByBRElement
(
)
)
{
newStartPoint
.
SetAfter
(
wsScannerAtStart
.
EndReasonBRElementPtr
(
)
)
;
}
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
startPoint
.
ToRawRangeBoundary
(
)
newEndPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
!
comp
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
*
comp
=
=
1
)
{
return
NS_OK
;
}
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetBaseAndExtentInLimiter
(
newStartPoint
newEndPoint
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
else
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
SetBaseAndExtentInLimiter
(
)
failed
"
)
;
}
return
error
.
StealNSResult
(
)
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
ScanDirection
aScanDirection
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
bool
isSpace
=
false
isNBSP
=
false
;
nsIContent
*
newContent
=
aPoint
.
Container
(
)
-
>
AsContent
(
)
;
int32_t
newOffset
=
*
aPoint
.
Offset
(
RangeBoundaryBase
<
PT
RT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
;
while
(
newContent
)
{
int32_t
offset
=
-
1
;
nsCOMPtr
<
nsIContent
>
content
;
if
(
aScanDirection
=
=
ScanDirection
:
:
Backward
)
{
HTMLEditor
:
:
IsPrevCharInNodeWhiteSpace
(
newContent
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
content
)
&
offset
)
;
}
else
{
HTMLEditor
:
:
IsNextCharInNodeWhiteSpace
(
newContent
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
content
)
&
offset
)
;
}
if
(
!
isSpace
&
&
!
isNBSP
)
{
break
;
}
newContent
=
content
;
newOffset
=
offset
;
}
return
EditorDOMPoint
(
newContent
newOffset
)
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
EditSubAction
aEditSubAction
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPoint
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
for
(
nsIContent
*
previousEditableContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
previousEditableContent
&
&
previousEditableContent
-
>
GetParentNode
(
)
&
&
!
IsVisibleBRElement
(
previousEditableContent
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
;
previousEditableContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
point
.
Set
(
previousEditableContent
)
;
}
for
(
nsIContent
*
nearContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
;
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
return
point
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPoint
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
point
.
IsSet
(
)
"
Failed
to
set
to
after
the
text
node
"
)
;
}
for
(
nsIContent
*
nextEditableContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
;
nextEditableContent
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
&
&
nextEditableContent
-
>
GetParent
(
)
;
nextEditableContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
point
.
SetAfter
(
nextEditableContent
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
if
(
IsVisibleBRElement
(
nextEditableContent
)
)
{
break
;
}
if
(
nextEditableContent
-
>
IsText
(
)
&
&
EditorUtils
:
:
IsContentPreformatted
(
*
nextEditableContent
)
)
{
nsAutoString
textContent
;
nextEditableContent
-
>
GetAsText
(
)
-
>
GetData
(
textContent
)
;
int32_t
newlinePos
=
textContent
.
FindChar
(
nsCRT
:
:
LF
)
;
if
(
newlinePos
>
=
0
)
{
if
(
static_cast
<
uint32_t
>
(
newlinePos
)
+
1
=
=
textContent
.
Length
(
)
)
{
break
;
}
return
EditorDOMPoint
(
nextEditableContent
newlinePos
+
1
)
;
}
}
}
for
(
nsIContent
*
nearContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
&
&
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
break
;
}
}
return
point
;
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToIncludeAdjuscentWhiteSpaces
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
aOutArrayOfRanges
.
SetCapacity
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
const
nsRange
*
selectionRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
*
selectionRange
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToHardLineStartAndEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
aOutArrayOfRanges
.
SetCapacity
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
selectionRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
*
selectionRange
aEditSubAction
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
{
if
(
aStartRef
!
=
aEndRef
)
{
return
;
}
if
(
!
aStartRef
.
Container
(
)
-
>
IsContent
(
)
)
{
return
;
}
Element
*
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
aStartRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
!
blockElement
)
{
return
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
;
}
if
(
editingHost
-
>
IsInclusiveDescendantOf
(
blockElement
)
)
{
return
;
}
if
(
IsEmptyNode
(
*
blockElement
true
false
)
)
{
aStartRef
=
{
blockElement
0u
}
;
aEndRef
=
{
blockElement
blockElement
-
>
Length
(
)
}
;
}
}
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
AbstractRange
&
aAbstractRange
)
{
if
(
!
aAbstractRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeIncludingAdjuscentWhiteSpaces
(
aAbstractRange
.
StartRef
(
)
aAbstractRange
.
EndRef
(
)
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
{
if
(
NS_WARN_IF
(
!
aStartRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndRef
.
IsSet
(
)
)
)
{
return
nullptr
;
}
if
(
!
aStartRef
.
Container
(
)
-
>
IsContent
(
)
|
|
!
aEndRef
.
Container
(
)
-
>
IsContent
(
)
)
{
return
nullptr
;
}
RangeBoundaryBase
<
SPT
SRT
>
startRef
(
aStartRef
)
;
RangeBoundaryBase
<
EPT
ERT
>
endRef
(
aEndRef
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startRef
endRef
)
;
EditorDOMPoint
startPoint
=
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
startRef
HTMLEditor
:
:
ScanDirection
:
:
Backward
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
nullptr
;
}
EditorDOMPoint
endPoint
=
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
endRef
HTMLEditor
:
:
ScanDirection
:
:
Forward
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
AbstractRange
&
aAbstractRange
EditSubAction
aEditSubAction
)
{
if
(
!
aAbstractRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeExtendedToHardLineStartAndEnd
(
aAbstractRange
.
StartRef
(
)
aAbstractRange
.
EndRef
(
)
aEditSubAction
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
EditSubAction
aEditSubAction
)
{
if
(
NS_WARN_IF
(
!
aStartRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndRef
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RangeBoundaryBase
<
SPT
SRT
>
startRef
(
aStartRef
)
;
RangeBoundaryBase
<
EPT
ERT
>
endRef
(
aEndRef
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startRef
endRef
)
;
EditorDOMPoint
startPoint
=
GetCurrentHardLineStartPoint
(
startRef
aEditSubAction
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
nullptr
;
}
EditorDOMPoint
endPoint
=
GetCurrentHardLineEndPoint
(
endRef
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
nsresult
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
nsresult
rv
=
SplitTextNodesAtRangeEnd
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SplitTextNodesAtRangeEnd
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SplitParentInlineElementsAtRangeEdges
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CollectEditTargetNodes
(
aArrayOfRanges
aOutArrayOfContents
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollectEditTargetNodes
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
MaybeSplitElementsAtEveryBRElement
(
aOutArrayOfContents
aEditSubAction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SplitTextNodesAtRangeEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
ErrorResult
error
;
IgnoredErrorResult
ignoredError
;
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
IsInTextNode
(
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atContainerOfSplitNode
(
atEnd
.
GetContainer
(
)
)
;
MOZ_ASSERT
(
!
range
-
>
IsInSelection
(
)
)
;
range
-
>
SetEnd
(
atContainerOfSplitNode
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
SetEnd
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
*
aArrayOfRanges
[
0
]
)
;
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
*
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
nsresult
rv
=
NS_OK
;
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
rv
=
SplitParentInlineElementsAtRangeEdges
(
MOZ_KnownLive
(
*
item
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
)
failed
"
)
;
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
if
(
aOutArrayOfContents
.
IsEmpty
(
)
)
{
iter
.
AppendAllNodesToArray
(
aOutArrayOfContents
)
;
}
else
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfTopChildren
;
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
aArray
)
-
>
bool
{
MOZ_ASSERT
(
aArray
)
;
return
!
static_cast
<
nsTArray
<
OwningNonNull
<
nsIContent
>
>
*
>
(
aArray
)
-
>
Contains
(
&
aNode
)
;
}
arrayOfTopChildren
&
aOutArrayOfContents
)
;
aOutArrayOfContents
.
AppendElements
(
std
:
:
move
(
arrayOfTopChildren
)
)
;
}
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
No
)
{
for
(
size_t
i
=
aOutArrayOfContents
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
aOutArrayOfContents
[
i
-
1
]
EditorType
:
:
HTML
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
-
1
)
;
}
}
}
}
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
Text
*
text
=
aOutArrayOfContents
[
i
]
-
>
GetAsText
(
)
)
{
if
(
!
IsVisibleTextNode
(
*
text
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
}
}
}
break
;
case
EditSubAction
:
:
eCreateOrChangeList
:
{
for
(
size_t
i
=
aOutArrayOfContents
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
-
1
]
;
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
-
1
)
;
CollectChildren
(
content
aOutArrayOfContents
i
-
1
CollectListChildren
:
:
No
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
}
}
if
(
aOutArrayOfContents
.
Length
(
)
!
=
1
)
{
break
;
}
Element
*
deepestDivBlockquoteOrListElement
=
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
aOutArrayOfContents
[
0
]
)
;
if
(
!
deepestDivBlockquoteOrListElement
)
{
break
;
}
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
aOutArrayOfContents
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
aOutArrayOfContents
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
break
;
}
aOutArrayOfContents
.
ReplaceElementAt
(
0
OwningNonNull
<
nsIContent
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
break
;
}
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
break
;
default
:
break
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
!
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aOutArrayOfContents
[
i
]
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
aOutArrayOfContents
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
content
aOutArrayOfContents
i
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
aCollectNonEditableNodes
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
for
(
int32_t
i
=
aArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
&
content
=
aArrayOfContents
[
i
]
;
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
content
)
&
&
!
content
-
>
IsText
(
)
)
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
arrayOfInlineContents
;
nsresult
rv
=
SplitElementsAtEveryBRElement
(
MOZ_KnownLive
(
content
)
arrayOfInlineContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
rv
;
}
aArrayOfContents
.
RemoveElementAt
(
i
)
;
aArrayOfContents
.
InsertElementsAt
(
i
arrayOfInlineContents
)
;
}
}
return
NS_OK
;
default
:
return
NS_OK
;
}
}
Element
*
HTMLEditor
:
:
GetParentListElementAtSelection
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
+
+
i
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
for
(
nsINode
*
parent
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
parent
)
)
{
return
parent
-
>
AsElement
(
)
;
}
}
}
return
nullptr
;
}
Element
*
HTMLEditor
:
:
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
nullptr
;
}
Element
*
parentElement
=
nullptr
;
for
(
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
content
&
&
content
-
>
IsElement
(
)
&
&
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
;
content
=
content
-
>
GetFirstChild
(
)
)
{
if
(
CountEditableChildren
(
content
)
!
=
1
)
{
return
content
-
>
AsElement
(
)
;
}
parentElement
=
content
-
>
AsElement
(
)
;
}
return
parentElement
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
RangeItem
&
aRangeItem
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aRangeItem
.
IsCollapsed
(
)
)
{
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtEnd
=
GetMostAncestorInlineElement
(
*
aRangeItem
.
mEndContainer
)
;
if
(
mostAncestorInlineContentAtEnd
)
{
SplitNodeResult
splitEndInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtEnd
aRangeItem
.
EndPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitEndInlineResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitEndInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtEnd
(
splitEndInlineResult
.
SplitPoint
(
)
)
;
if
(
!
splitPointAtEnd
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
aRangeItem
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
}
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtStart
=
GetMostAncestorInlineElement
(
*
aRangeItem
.
mStartContainer
)
;
if
(
mostAncestorInlineContentAtStart
)
{
SplitNodeResult
splitStartInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtStart
aRangeItem
.
StartPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitStartInlineResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitStartInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtStart
(
splitStartInlineResult
.
SplitPoint
(
)
)
;
if
(
!
splitPointAtStart
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
didn
'
t
return
split
point
"
)
;
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
aRangeItem
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
nsIContent
&
aMostAncestorToBeSplit
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
HTMLBRElement
>
24
>
arrayOfBRElements
;
DOMIterator
iter
(
aMostAncestorToBeSplit
)
;
iter
.
AppendAllNodesToArray
(
arrayOfBRElements
)
;
if
(
arrayOfBRElements
.
IsEmpty
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
aMostAncestorToBeSplit
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
&
aMostAncestorToBeSplit
;
for
(
OwningNonNull
<
HTMLBRElement
>
&
brElement
:
arrayOfBRElements
)
{
EditorDOMPoint
atBRNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBRNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
nextContent
atBRNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
if
(
splitNodeResult
.
GetPreviousNode
(
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
splitNodeResult
.
GetPreviousNode
(
)
)
;
}
EditorDOMPoint
atNextNode
(
splitNodeResult
.
GetNextNode
(
)
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
brElement
)
atNextNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
aOutArrayOfContents
.
AppendElement
(
brElement
)
;
nextContent
=
splitNodeResult
.
GetNextNode
(
)
;
}
aOutArrayOfContents
.
AppendElement
(
*
nextContent
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetMostAncestorInlineElement
(
nsINode
&
aNode
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aNode
.
IsContent
(
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
aNode
.
AsContent
(
)
)
)
{
return
nullptr
;
}
Element
*
host
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
nullptr
;
}
if
(
&
aNode
=
=
host
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
aNode
*
host
)
)
)
{
return
nullptr
;
}
if
(
!
aNode
.
GetParent
(
)
)
{
return
aNode
.
AsContent
(
)
;
}
nsIContent
*
topMostInlineContent
=
aNode
.
AsContent
(
)
;
for
(
nsIContent
*
content
:
aNode
.
AncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
content
=
=
host
|
|
!
HTMLEditUtils
:
:
IsInlineElement
(
*
content
)
)
{
break
;
}
topMostInlineContent
=
content
;
}
return
topMostInlineContent
;
}
void
HTMLEditor
:
:
MakeTransitionList
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsINode
*
prevParent
=
nullptr
;
aTransitionArray
.
EnsureLengthAtLeast
(
aArrayOfContents
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aArrayOfContents
.
Length
(
)
;
i
+
+
)
{
aTransitionArray
[
i
]
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
;
prevParent
=
aArrayOfContents
[
i
]
-
>
GetParentNode
(
)
;
}
}
Element
*
HTMLEditor
:
:
GetNearestAncestorListItemElement
(
nsIContent
&
aContent
)
const
{
if
(
HTMLEditUtils
:
:
IsListItem
(
&
aContent
)
)
{
return
aContent
.
AsElement
(
)
;
}
for
(
Element
*
parentElement
=
aContent
.
GetParentElement
(
)
;
parentElement
&
&
IsDescendantOfEditorRoot
(
parentElement
)
&
&
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
;
parentElement
=
parentElement
-
>
GetParentElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parentElement
)
)
{
return
parentElement
;
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
headerParent
=
aHeader
.
GetParentNode
(
)
;
int32_t
offset
=
headerParent
?
headerParent
-
>
ComputeIndexOf
(
&
aHeader
)
:
-
1
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
*
this
address_of
(
node
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
failed
"
)
;
return
rv
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
returned
"
"
Document
or
something
non
-
content
node
"
)
;
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitHeaderResult
=
SplitNodeDeepWithTransaction
(
aHeader
EditorDOMPoint
(
node
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitHeaderResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
but
ignored
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
GetPriorHTMLSibling
(
&
aHeader
)
;
if
(
prevItem
)
{
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
prevItem
)
)
;
if
(
IsEmptyNode
(
*
prevItem
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
prevItem
0
)
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
}
if
(
IsEmptyBlockElement
(
aHeader
IgnoreSingleBR
:
:
Yes
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
aHeader
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
aHeader
.
GetNextSibling
(
)
)
{
sibling
=
GetNextHTMLSibling
(
aHeader
.
GetNextSibling
(
)
)
;
}
if
(
!
sibling
|
|
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
Clear
(
)
;
mTypeInState
-
>
ClearAllProps
(
)
;
nsStaticAtom
&
paraAtom
=
DefaultParagraphSeparatorTagName
(
)
;
EditorDOMPoint
nextToHeader
(
headerParent
offset
+
1
)
;
RefPtr
<
Element
>
pOrDivElement
=
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
MOZ_KnownLive
(
paraAtom
)
nextToHeader
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
pOrDivElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
pOrDivElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionToStartOf
(
*
pOrDivElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
EditorRawDOMPoint
afterSibling
(
EditorRawDOMPoint
:
:
After
(
*
sibling
)
)
;
if
(
NS_WARN_IF
(
!
afterSibling
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
CollapseSelectionTo
(
afterSibling
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
rv
=
CollapseSelectionToStartOf
(
aHeader
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
Element
&
aParentDivOrP
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
|
|
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
;
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
}
bool
doesCRCreateNewP
=
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brContent
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brContent
=
nullptr
;
}
else
if
(
atStartOfSelection
.
IsInTextNode
(
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brContent
=
GetPriorHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
IsVisibleBRElement
(
brContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
brContent
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brContent
=
GetNextHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
IsVisibleBRElement
(
brContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
SetAfter
(
atStartOfSelection
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
pointToInsertBR
.
IsSet
(
)
"
Failed
to
set
to
after
the
container
of
selection
start
"
)
;
brContent
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftDivOrP
=
SplitNodeWithTransaction
(
pointToSplitParentDivOrP
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
pointToSplitParentDivOrP
.
SetToEndOf
(
newLeftDivOrP
)
;
}
pointToInsertBR
.
Set
(
pointToSplitParentDivOrP
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
"
"
of
selection
start
"
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nearContent
=
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearContent
|
|
!
IsVisibleBRElement
(
nearContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearContent
)
)
{
nearContent
=
GetNextEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearContent
|
|
!
IsVisibleBRElement
(
nearContent
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearContent
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
nearContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
brContent
=
nearContent
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
brContent
=
InsertBRElementWithTransaction
(
pointToInsertBR
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
brContent
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
SetAfter
(
brContent
)
;
NS_WARNING_ASSERTION
(
pointToSplitParentDivOrP
.
IsSet
(
)
"
Failed
to
set
after
the
new
<
br
>
"
)
;
}
}
EditActionResult
result
(
SplitParagraph
(
aParentDivOrP
pointToSplitParentDivOrP
brContent
)
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitParagraph
(
)
failed
"
)
;
result
.
MarkAsHandled
(
)
;
return
result
;
}
template
<
typename
PT
typename
CT
>
nsresult
HTMLEditor
:
:
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
selNode
=
aStartOfRightNode
.
GetContainer
(
)
;
int32_t
selOffset
=
aStartOfRightNode
.
Offset
(
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
*
this
address_of
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
failed
"
)
;
return
rv
;
}
if
(
!
selNode
-
>
IsContent
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
returned
"
"
Document
or
something
non
-
content
node
"
)
;
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitDivOrPResult
=
SplitNodeDeepWithTransaction
(
aParentDivOrP
EditorDOMPoint
(
selNode
selOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
splitDivOrPResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitDivOrPResult
.
Rv
(
)
;
}
if
(
!
splitDivOrPResult
.
DidSplit
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
any
nodes
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aNextBRNode
&
&
IsVisibleBRElement
(
aNextBRNode
)
)
{
rv
=
DeleteNodeWithTransaction
(
*
aNextBRNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
rv
=
RemoveAttributeWithTransaction
(
aParentDivOrP
*
nsGkAtoms
:
:
id
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
id
)
failed
"
)
;
return
rv
;
}
if
(
splitDivOrPResult
.
GetPreviousNode
(
)
-
>
IsElement
(
)
)
{
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
splitDivOrPResult
.
GetPreviousNode
(
)
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
)
failed
"
)
;
return
rv
;
}
}
if
(
splitDivOrPResult
.
GetNextNode
(
)
-
>
IsElement
(
)
)
{
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
splitDivOrPResult
.
GetNextNode
(
)
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
)
failed
"
)
;
return
rv
;
}
}
nsCOMPtr
<
nsIContent
>
child
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
aParentDivOrP
ChildBlockBoundary
:
:
TreatAsLeaf
)
;
if
(
child
&
&
(
child
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
)
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
child
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
else
{
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
child
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
;
RefPtr
<
Element
>
host
=
GetActiveEditingHost
(
)
;
if
(
host
!
=
aListItem
.
GetParentElement
(
)
&
&
IsEmptyBlockElement
(
aListItem
IgnoreSingleBR
:
:
Yes
)
)
{
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
IsLastEditableChild
(
&
aListItem
)
)
{
EditorDOMPoint
atListItem
(
&
aListItem
)
;
ErrorResult
error
;
leftListNode
=
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atNextSiblingOfLeftList
(
leftListNode
)
;
DebugOnly
<
bool
>
advanced
=
atNextSiblingOfLeftList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
right
list
node
"
)
;
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atNextSiblingOfLeftList
.
GetContainer
(
)
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aListItem
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rv
=
CollapseSelectionToStartOf
(
aListItem
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsStaticAtom
&
paraAtom
=
DefaultParagraphSeparatorTagName
(
)
;
RefPtr
<
Element
>
pOrDivElement
=
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
MOZ_KnownLive
(
paraAtom
)
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
pOrDivElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
pOrDivElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
CollapseSelectionToStartOf
(
*
pOrDivElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsINode
>
selNode
=
&
aNode
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
*
this
address_of
(
selNode
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
failed
"
)
;
return
rv
;
}
if
(
!
selNode
-
>
IsContent
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitAcrossBlocks
(
)
returned
"
"
document
node
or
something
non
-
content
node
"
)
;
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitListItemResult
=
SplitNodeDeepWithTransaction
(
aListItem
EditorDOMPoint
(
selNode
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitListItemResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
but
ignored
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
GetPriorHTMLSibling
(
&
aListItem
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsListItem
(
prevItem
)
)
{
if
(
IsEmptyNode
(
*
prevItem
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
prevItem
0
)
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
else
{
if
(
IsEmptyNode
(
aListItem
true
)
)
{
if
(
aListItem
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
)
{
nsCOMPtr
<
nsINode
>
list
=
aListItem
.
GetParentNode
(
)
;
int32_t
itemOffset
=
list
?
list
-
>
ComputeIndexOf
(
&
aListItem
)
:
-
1
;
nsStaticAtom
*
nextDefinitionListItemTagName
=
aListItem
.
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
?
nsGkAtoms
:
:
dd
:
nsGkAtoms
:
:
dt
;
MOZ_DIAGNOSTIC_ASSERT
(
itemOffset
!
=
-
1
)
;
EditorDOMPoint
atNextListItem
(
list
aListItem
.
GetNextSibling
(
)
itemOffset
+
1
)
;
RefPtr
<
Element
>
newListItem
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
nextDefinitionListItemTagName
)
atNextListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
newListItem
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rv
=
CollapseSelectionToStartOf
(
*
newListItem
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
brElement
;
nsresult
rv
=
CopyLastEditableChildStylesWithTransaction
(
MOZ_KnownLive
(
*
prevItem
-
>
AsElement
(
)
)
aListItem
address_of
(
brElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
brElement
)
{
EditorRawDOMPoint
atBRNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBRNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
atBRNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
else
{
WSScanResult
forwardScanFromStartOfListItemResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
EditorRawDOMPoint
(
&
aListItem
0
)
)
;
if
(
forwardScanFromStartOfListItemResult
.
ReachedSpecialContent
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedBRElement
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedHRElement
(
)
)
{
EditorRawDOMPoint
atFoundElement
(
forwardScanFromStartOfListItemResult
.
RawPointAtContent
(
)
)
;
if
(
NS_WARN_IF
(
!
atFoundElement
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
atFoundElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
CollapseSelectionTo
(
forwardScanFromStartOfListItemResult
.
RawPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
}
rv
=
CollapseSelectionToStartOf
(
aListItem
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
nsresult
rv
=
MoveNodesIntoNewBlockquoteElement
(
childContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
)
failed
"
)
;
return
rv
;
}
}
if
(
prevParent
)
{
if
(
prevParent
!
=
content
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
content
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
content
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
EditorDOMPoint
(
content
)
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
"
"
:
blockquote
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
blockquote
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerElements
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
blockElement
;
nsCOMPtr
<
nsIContent
>
firstContent
lastContent
;
for
(
auto
&
content
:
aArrayOfContents
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
)
{
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
nsresult
rv
=
RemoveBlockContainerElements
(
childContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveBlockContainerElements
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
blockElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
content
*
blockElement
)
)
{
lastContent
=
content
;
continue
;
}
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
content
)
;
if
(
!
blockElement
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
blockElement
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
blockElement
EditorType
:
:
HTML
)
)
{
blockElement
=
nullptr
;
}
else
{
firstContent
=
lastContent
=
content
;
}
continue
;
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
continue
;
}
}
if
(
blockElement
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
blockElement
*
firstContent
*
lastContent
)
;
if
(
removeMiddleContainerResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
)
"
"
failed
"
)
;
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstContent
=
lastContent
=
blockElement
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
nsAtom
&
aBlockTag
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
content
:
aArrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsInContentNode
(
)
)
)
{
curBlock
=
nullptr
;
newBlock
=
nullptr
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
content
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
curBlock
=
nullptr
;
newBlock
=
ReplaceContainerAndCloneAttributesWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
aBlockTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
newBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
ReplaceContainerAndCloneAttributesWithTransaction
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
newBlock
-
>
GetParentNode
(
)
!
=
atContent
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
24
>
childContents
;
HTMLEditor
:
:
GetChildNodesOf
(
*
content
childContents
)
;
if
(
!
childContents
.
IsEmpty
(
)
)
{
nsresult
rv
=
CreateOrChangeBlockContainerElement
(
childContents
aBlockTag
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atContent
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
theBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
theBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
theBlock
)
;
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
content
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atContent
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
curBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
curBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsInlineElement
(
content
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
!
curBlock
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
"
"
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atContent
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
curBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
curBlock
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
curBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
atContent
.
Set
(
content
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
SplitNodeResult
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aStartOfDeepestRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
host
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
host
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
*
host
)
)
{
NS_WARNING
(
"
aStartOfDeepestRightNode
was
not
in
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
pointToInsert
.
GetChild
(
)
=
=
host
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
)
reached
"
"
editing
host
"
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
(
aStartOfDeepestRightNode
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitNodeResult
;
}
nsresult
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNewFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
!
aNodeLeft
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNodeLeft
.
GetParentNode
(
)
!
=
aNodeRight
.
GetParentNode
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aNodeRight
EditorDOMPoint
(
&
aNodeLeft
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
EditorDOMPoint
ret
(
&
aNodeRight
aNodeLeft
.
Length
(
)
)
;
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aNodeLeft
)
|
|
aNodeLeft
.
IsText
(
)
)
{
nsresult
rv
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNodesWithTransaction
failed
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
}
return
rv
;
}
nsCOMPtr
<
nsIContent
>
lastLeft
=
GetLastEditableChild
(
aNodeLeft
)
;
if
(
NS_WARN_IF
(
!
lastLeft
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstRight
=
GetFirstEditableChild
(
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
firstRight
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
(
lastLeft
-
>
IsText
(
)
|
|
lastLeft
-
>
IsElement
(
)
)
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
lastLeft
*
firstRight
StyleDifference
:
:
CompareIfElements
)
)
{
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
lastLeft
*
firstRight
aNewFirstChildOfRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetMostAncestorMailCiteElement
(
nsINode
&
aNode
)
const
{
Element
*
mailCiteElement
=
nullptr
;
bool
isPlaintextEditor
=
IsPlaintextEditor
(
)
;
for
(
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
isPlaintextEditor
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
{
mailCiteElement
=
node
-
>
AsElement
(
)
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
mailCiteElement
;
}
nsresult
HTMLEditor
:
:
CacheInlineStyles
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
GetInlineStyles
(
aContent
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlineStyles
(
nsIContent
&
aContent
AutoStyleCacheArray
&
aStyleCacheArray
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStyleCacheArray
.
IsEmpty
(
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
for
(
nsStaticAtom
*
property
:
{
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
face
nsGkAtoms
:
:
size
nsGkAtoms
:
:
color
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
em
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
code
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
var
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
backgroundColor
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
}
)
{
nsStaticAtom
*
tag
*
attribute
;
if
(
property
=
=
nsGkAtoms
:
:
face
|
|
property
=
=
nsGkAtoms
:
:
size
|
|
property
=
=
nsGkAtoms
:
:
color
)
{
tag
=
nsGkAtoms
:
:
font
;
attribute
=
property
;
}
else
{
tag
=
property
;
attribute
=
nullptr
;
}
bool
typeInSet
unused
;
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
tag
attribute
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsString
value
;
if
(
!
useCSS
|
|
(
property
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
IsTextPropertySetByContent
(
&
aContent
tag
attribute
nullptr
&
value
)
;
}
else
{
isSet
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
aContent
MOZ_KnownLive
(
tag
)
MOZ_KnownLive
(
attribute
)
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
isSet
)
{
aStyleCacheArray
.
AppendElement
(
StyleCache
(
tag
attribute
value
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
-
>
IsEmpty
(
)
|
|
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
NS_OK
;
}
bool
useCSS
=
IsCSSEnabled
(
)
;
const
RangeBoundary
&
atStartOfSelection
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
-
>
StartRef
(
)
;
nsCOMPtr
<
nsIContent
>
startContainerContent
=
atStartOfSelection
.
Container
(
)
&
&
atStartOfSelection
.
Container
(
)
-
>
IsContent
(
)
?
atStartOfSelection
.
Container
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
startContainerContent
)
)
{
return
NS_OK
;
}
AutoStyleCacheArray
styleCacheArrayAtInsertionPoint
;
nsresult
rv
=
GetInlineStyles
(
*
startContainerContent
styleCacheArrayAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlineStyles
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
for
(
StyleCache
&
styleCacheBeforeEdit
:
*
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
{
bool
isFirst
=
false
isAny
=
false
isAll
=
false
;
nsAutoString
currentValue
;
if
(
useCSS
)
{
isAny
=
CSSEditUtils
:
:
IsComputedCSSEquivalentToHTMLInlineStyleSet
(
*
startContainerContent
MOZ_KnownLive
(
styleCacheBeforeEdit
.
Tag
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
currentValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
!
isAny
)
{
nsresult
rv
=
GetInlinePropertyBase
(
MOZ_KnownLive
(
*
styleCacheBeforeEdit
.
Tag
(
)
)
MOZ_KnownLive
(
styleCacheBeforeEdit
.
GetAttribute
(
)
)
&
styleCacheBeforeEdit
.
Value
(
)
&
isFirst
&
isAny
&
isAll
&
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInlinePropertyBase
(
)
failed
"
)
;
return
rv
;
}
}
if
(
isAny
&
&
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
continue
;
}
AutoStyleCacheArray
:
:
index_type
index
=
styleCacheArrayAtInsertionPoint
.
IndexOf
(
styleCacheBeforeEdit
.
Tag
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
)
;
if
(
index
=
=
AutoStyleCacheArray
:
:
NoIndex
|
|
styleCacheBeforeEdit
.
Value
(
)
!
=
styleCacheArrayAtInsertionPoint
.
ElementAt
(
index
)
.
Value
(
)
)
{
mTypeInState
-
>
SetProp
(
styleCacheBeforeEdit
.
Tag
(
)
styleCacheBeforeEdit
.
GetAttribute
(
)
styleCacheBeforeEdit
.
Value
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
Element
>
64
>
arrayOfEmptyElements
;
DOMIterator
iter
;
if
(
NS_FAILED
(
iter
.
Init
(
aStartRef
aEndRef
)
)
)
{
NS_WARNING
(
"
DOMIterator
:
:
Init
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
aSelf
)
{
MOZ_ASSERT
(
Element
:
:
FromNode
(
&
aNode
)
)
;
MOZ_ASSERT
(
aSelf
)
;
Element
*
element
=
aNode
.
AsElement
(
)
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
element
EditorType
:
:
HTML
)
|
|
(
!
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
element
)
)
)
{
return
false
;
}
return
static_cast
<
HTMLEditor
*
>
(
aSelf
)
-
>
IsEmptyNode
(
*
element
false
false
)
;
}
arrayOfEmptyElements
this
)
;
for
(
auto
&
emptyElement
:
arrayOfEmptyElements
)
{
EditorDOMPoint
endOfNode
(
EditorDOMPoint
:
:
AtEndOf
(
emptyElement
)
)
;
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfNode
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureCaretInBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
StaticRange
>
staticRange
=
StaticRange
:
:
Create
(
atCaret
.
ToRawRangeBoundary
(
)
atCaret
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
!
staticRange
)
{
NS_WARNING
(
"
StaticRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
&
aElement
staticRange
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUtils
:
:
CompareNodeToRange
(
)
failed
"
)
;
return
rv
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
nsIContent
*
lastEditableContent
=
GetLastEditableChild
(
aElement
)
;
if
(
!
lastEditableContent
)
{
lastEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
endPoint
;
if
(
lastEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
lastEditableContent
)
)
{
endPoint
.
SetToEndOf
(
lastEditableContent
)
;
}
else
{
endPoint
.
SetAfter
(
lastEditableContent
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsresult
rv
=
CollapseSelectionTo
(
endPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsIContent
*
firstEditableContent
=
GetFirstEditableChild
(
aElement
)
;
if
(
!
firstEditableContent
)
{
firstEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
firstEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
firstEditableContent
)
)
{
atStartOfBlock
.
Set
(
firstEditableContent
)
;
}
else
{
atStartOfBlock
.
Set
(
firstEditableContent
0
)
;
}
rv
=
CollapseSelectionTo
(
atStartOfBlock
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
SetSelectionInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atCaret
.
IsSetAndValid
(
)
)
;
if
(
nsIContent
*
previousEditableContentInBlock
=
GetPreviousEditableHTMLNodeInBlock
(
atCaret
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
!
atCaret
.
GetChild
(
)
)
{
return
;
}
if
(
nsIContent
*
previousEditableContentInBlockAtCaret
=
GetPriorHTMLSibling
(
atCaret
.
GetChild
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContentInBlockAtCaret
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
nsIContent
*
nextEditableContentInBlockAtCaret
=
GetNextHTMLSibling
(
atCaret
.
GetChild
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContentInBlockAtCaret
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
false
)
failed
but
ignored
"
)
;
}
}
}
nsresult
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
EditorDOMPoint
point
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
EditorUtils
:
:
IsEditableContent
(
*
point
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsInContentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
point
.
ContainerAsContent
(
)
)
)
{
if
(
blockElement
&
&
EditorUtils
:
:
IsEditableContent
(
*
blockElement
EditorType
:
:
HTML
)
&
&
IsEmptyNode
(
*
blockElement
false
false
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
bodyOrDocumentElement
)
{
return
NS_OK
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
NS_WARNING_ASSERTION
(
createPaddingBRResult
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
GetPreviousEditableHTMLNode
(
point
)
)
{
RefPtr
<
Element
>
blockElementAtCaret
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
point
.
ContainerAsContent
(
)
)
;
RefPtr
<
Element
>
blockElementParentAtPreviousEditableContent
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
previousEditableContent
)
;
if
(
blockElementAtCaret
&
&
blockElementAtCaret
=
=
blockElementParentAtPreviousEditableContent
&
&
previousEditableContent
&
&
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
!
IsVisibleBRElement
(
previousEditableContent
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
createPaddingBRResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
failed
"
)
;
return
createPaddingBRResult
.
Rv
(
)
;
}
point
.
Set
(
createPaddingBRResult
.
GetNewNode
(
)
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
point
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
nsIContent
*
nextEditableContentInBlock
=
GetNextEditableHTMLNodeInBlock
(
*
previousEditableContent
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextEditableContentInBlock
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
}
}
}
}
if
(
nsIContent
*
previousEditableContentInBlock
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
previousEditableContentInBlock
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsImage
(
previousEditableContentInBlock
)
|
|
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
if
(
nsIContent
*
nextEditableContentInBlock
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
if
(
nextEditableContentInBlock
-
>
IsText
(
)
|
|
nextEditableContentInBlock
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
br
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
nsIContent
*
nearEditableContent
=
FindNearEditableContent
(
point
aDirectionAndAmount
)
;
if
(
!
nearEditableContent
)
{
return
NS_OK
;
}
EditorDOMPoint
pointToPutCaret
=
GetGoodCaretPointFor
(
*
nearEditableContent
aDirectionAndAmount
)
;
if
(
!
pointToPutCaret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
editableContent
=
nullptr
;
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
editableContent
=
GetPreviousEditableHTMLNode
(
aPoint
)
;
if
(
!
editableContent
)
{
return
nullptr
;
}
}
else
{
editableContent
=
GetNextEditableHTMLNode
(
aPoint
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
while
(
editableContent
&
&
!
editableContent
-
>
IsText
(
)
&
&
!
editableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsImage
(
editableContent
)
)
{
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
editableContent
=
GetPreviousEditableHTMLNode
(
*
editableContent
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
else
{
editableContent
=
GetNextEditableHTMLNode
(
*
editableContent
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
}
if
(
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
editableContent
*
aPoint
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
editableContent
;
}
bool
HTMLEditor
:
:
NodesInDifferentTableElements
(
nsINode
&
aNode1
nsINode
&
aNode2
)
{
nsINode
*
parentNode1
;
for
(
parentNode1
=
&
aNode1
;
parentNode1
&
&
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentNode1
)
;
parentNode1
=
parentNode1
-
>
GetParentNode
(
)
)
{
}
nsINode
*
parentNode2
;
for
(
parentNode2
=
&
aNode2
;
parentNode2
&
&
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentNode2
)
;
parentNode2
=
parentNode2
-
>
GetParentNode
(
)
)
{
}
return
parentNode1
!
=
parentNode2
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyNodesIn
(
nsRange
&
aRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
&
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfEmptyContents
arrayOfEmptyCites
skipList
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
MOZ_ASSERT
(
postOrderIter
.
GetCurrentNode
(
)
-
>
IsContent
(
)
)
;
nsIContent
*
content
=
postOrderIter
.
GetCurrentNode
(
)
-
>
AsContent
(
)
;
nsIContent
*
parentContent
=
content
-
>
GetParent
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
content
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parentContent
)
{
skipList
[
idx
]
=
parentContent
;
}
continue
;
}
bool
isCandidate
=
false
;
bool
isMailCite
=
false
;
if
(
content
-
>
IsElement
(
)
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
isMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
content
)
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
isCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
isCandidate
=
!
StartOrEndOfSelectionRangesIsIn
(
*
content
)
;
}
}
bool
isEmptyNode
=
false
;
if
(
isCandidate
)
{
isEmptyNode
=
IsEmptyNode
(
*
content
isMailCite
true
)
;
if
(
isEmptyNode
)
{
if
(
isMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
content
)
;
}
else
{
arrayOfEmptyContents
.
AppendElement
(
*
content
)
;
}
}
}
if
(
!
isEmptyNode
&
&
parentContent
)
{
skipList
.
AppendElement
(
*
parentContent
)
;
}
}
for
(
OwningNonNull
<
nsIContent
>
&
emptyContent
:
arrayOfEmptyContents
)
{
if
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
emptyContent
)
)
{
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
for
(
OwningNonNull
<
nsIContent
>
&
emptyCite
:
arrayOfEmptyCites
)
{
if
(
!
IsEmptyNode
(
emptyCite
false
true
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
emptyCite
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
emptyCite
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
StartOrEndOfSelectionRangesIsIn
(
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
+
+
i
)
{
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
)
{
if
(
&
aContent
=
=
startContainer
)
{
return
true
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
startContainer
aContent
)
)
{
return
true
;
}
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
)
{
if
(
&
aContent
=
=
endContainer
)
{
return
true
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
endContainer
aContent
)
)
{
return
true
;
}
}
}
return
false
;
}
nsresult
HTMLEditor
:
:
LiftUpListItemElement
(
Element
&
aListItemElement
LiftUpFromAllParentListElements
aLiftUpFromAllParentListElements
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
)
|
|
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isFirstListItem
=
IsFirstEditableChild
(
&
aListItemElement
)
;
bool
isLastListItem
=
IsLastEditableChild
(
&
aListItemElement
)
;
Element
*
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
leftListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
&
&
!
isLastListItem
)
{
EditorDOMPoint
atListItemElement
(
&
aListItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItemElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atListItemElement
.
IsSetAndValid
(
)
)
;
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
maybeLeftListContent
=
SplitNodeWithTransaction
(
atListItemElement
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
=
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING_ASSERTION
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
!
maybeLeftListContent
-
>
IsElement
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
return
left
list
"
"
element
"
)
;
return
NS_ERROR_FAILURE
;
}
leftListElement
=
maybeLeftListContent
-
>
AsElement
(
)
;
}
EditorDOMPoint
pointToInsertListItem
(
leftListElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
MoveNodeWithTransaction
(
aListItemElement
pointToInsertListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aListItemElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aLiftUpFromAllParentListElements
=
=
LiftUpFromAllParentListElements
:
:
No
)
{
return
NS_OK
;
}
rv
=
LiftUpListItemElement
(
aListItemElement
LiftUpFromAllParentListElements
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
LiftUpListItemElement
(
"
"
LiftUpFromAllParentListElements
:
:
Yes
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DestroyListStructureRecursively
(
Element
&
aListElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsAnyListElement
(
&
aListElement
)
)
;
while
(
aListElement
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aListElement
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
HTMLEditor
:
:
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LiftUpListItemElement
(
LiftUpFromAllParentListElements
:
"
"
:
Yes
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
child
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DestroyListStructureRecursively
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
atCaret
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
IsEmptyNode
(
aElement
)
)
{
return
NS_OK
;
}
CreateElementResult
createBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
NS_WARNING_ASSERTION
(
createBRResult
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
"
"
failed
"
)
;
return
createBRResult
.
Rv
(
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aElement
)
)
{
return
NS_OK
;
}
if
(
!
IsEmptyNode
(
aElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
HTMELditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
HTMLEditor
:
:
RemoveAlignFromDescendants
(
Element
&
aElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
;
for
(
nsIContent
*
content
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
&
aElement
:
aElement
.
GetFirstChild
(
)
;
content
;
content
=
nextSibling
)
{
nextSibling
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
nullptr
:
content
-
>
GetNextSibling
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
OwningNonNull
<
Element
>
centerElement
=
*
content
-
>
AsElement
(
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
centerElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
rv
=
EnsureHardLineBeginsWithFirstChildOf
(
centerElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
)
failed
"
)
;
return
rv
;
}
rv
=
EnsureHardLineEndsWithLastChildOf
(
centerElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
)
failed
"
)
;
return
rv
;
}
rv
=
RemoveContainerWithTransaction
(
centerElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
&
&
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
continue
;
}
OwningNonNull
<
Element
>
blockOrHRElement
=
*
content
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
blockOrHRElement
)
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
blockOrHRElement
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
align
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
useCSS
)
{
if
(
blockOrHRElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
blockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
}
else
{
nsStyledElement
*
styledBlockOrHRElement
=
nsStyledElement
:
:
FromNode
(
blockOrHRElement
)
;
if
(
NS_WARN_IF
(
!
styledBlockOrHRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
dummyCssValue
;
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSInlineStyleWithTransaction
(
MOZ_KnownLive
(
*
styledBlockOrHRElement
)
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSInlineStyleWithTransaction
(
nsGkAtoms
:
:
"
"
textAlign
)
failed
"
)
;
return
rv
;
}
}
}
if
(
!
blockOrHRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
blockOrHRElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
EditTarget
:
:
"
"
OnlyDescendantsExceptTable
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableChild
=
GetFirstEditableChild
(
aRemovingContainerElement
)
;
if
(
!
firstEditableChild
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableChild
)
|
|
firstEditableChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
previousEditableContent
=
GetPriorHTMLSibling
(
&
aRemovingContainerElement
)
;
if
(
!
previousEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousEditableContent
)
|
|
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aRemovingContainerElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableContent
=
GetLastEditableChild
(
aRemovingContainerElement
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
firstEditableContent
)
|
|
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
nextEditableContent
=
GetPriorHTMLSibling
(
&
aRemovingContainerElement
)
;
if
(
!
nextEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextEditableContent
)
|
|
nextEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
:
:
AtEndOf
(
aRemovingContainerElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
HTMLEditor
:
:
SetBlockElementAlign
(
Element
&
aBlockOrHRElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aBlockOrHRElement
)
|
|
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
IsCSSEnabled
(
)
|
|
HTMLEditUtils
:
:
SupportsAlignAttr
(
aBlockOrHRElement
)
)
;
if
(
!
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
aBlockOrHRElement
aAlignType
aEditTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveAlignFromDescendants
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
SetAttributeOrEquivalent
(
&
aBlockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
align
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ChangeMarginStart
(
Element
&
aElement
ChangeMargin
aChangeMargin
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
)
failed
but
ignored
"
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChangeMargin
=
=
ChangeMargin
:
:
Increase
?
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
newValue
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aElement
)
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSPropertyWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
MOZ_KnownLive
(
marginProperty
)
value
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
destroyed
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
)
failed
but
ignored
"
)
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
&
aElement
=
=
editingHost
|
|
!
aElement
.
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToAbsoluteAsSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToAbsolute
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditgor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
focusElement
=
GetSelectionContainerElement
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
focusElement
)
;
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
nullptr
;
RefPtr
<
Element
>
divElement
;
rv
=
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
address_of
(
divElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
)
"
"
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Mutation
event
listener
might
have
changed
the
selection
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
!
divElement
)
{
return
EditActionHandled
(
)
;
}
rv
=
SetPositionToAbsoluteOrStatic
(
*
divElement
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
divElement
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
RefPtr
<
Element
>
*
aTargetElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aTargetElement
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eSetPositionToAbsolute
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfContents
EditSubAction
:
:
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
"
"
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfContents
)
)
{
const
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCaret
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
:
"
"
div
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
newDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
newDivElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
while
(
!
arrayOfContents
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsIContent
>
&
curNode
=
arrayOfContents
[
0
]
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
curNode
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
arrayOfContents
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
nsresult
rv
=
CollapseSelectionToStartOf
(
*
newDivElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
*
aTargetElement
=
std
:
:
move
(
newDivElement
)
;
return
rv
;
}
RefPtr
<
Element
>
targetDivElement
;
RefPtr
<
Element
>
createdListElement
;
RefPtr
<
Element
>
handledListItemElement
;
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
EditorDOMPoint
atContent
(
content
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atContent
.
GetContainer
(
)
)
)
{
nsIContent
*
previousEditableContent
=
createdListElement
?
GetPriorHTMLSibling
(
content
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
nsAtom
*
ULOrOLOrDLTagName
=
atContent
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
atContent
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
targetDivElement
)
{
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
targetDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
createdListElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
createdListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
RefPtr
<
Element
>
listItemElement
=
GetNearestAncestorListItemElement
(
content
)
)
{
if
(
handledListItemElement
=
=
listItemElement
)
{
continue
;
}
nsIContent
*
previousEditableContent
=
createdListElement
?
GetPriorHTMLSibling
(
listItemElement
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
EditorDOMPoint
atListItem
(
listItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
targetDivElement
)
{
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
atListItem
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
targetDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
createdListElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
EditorDOMPoint
:
:
AtEndOf
(
targetDivElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
createdListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
listItemElement
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
handledListItemElement
=
std
:
:
move
(
listItemElement
)
;
continue
;
}
if
(
!
targetDivElement
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
targetDivElement
=
content
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
createdListElement
)
;
MOZ_ASSERT
(
!
handledListItemElement
)
;
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atContent
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsGkAtoms
:
"
"
:
div
)
failed
"
)
;
return
splitNodeResult
.
Rv
(
)
;
}
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
targetDivElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
content
)
*
targetDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeToEndWithTransaction
(
)
failed
"
)
;
return
rv
;
}
createdListElement
=
nullptr
;
}
*
aTargetElement
=
std
:
:
move
(
targetDivElement
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToStaticAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToStatic
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
element
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
element
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
nsresult
rv
=
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
EditActionResult
HTMLEditor
:
:
AddZIndexAsSubAction
(
int32_t
aChange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
aChange
<
0
?
EditSubAction
:
:
eDecreaseZIndex
:
EditSubAction
:
:
eIncreaseZIndex
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditActionResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
absolutelyPositionedElement
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
!
absolutelyPositionedElement
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
GetAbsolutelyPositionedSelectionContainer
(
)
returned
"
"
nullptr
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
nsStyledElement
*
absolutelyPositionedStyledElement
=
nsStyledElement
:
:
FromNode
(
absolutelyPositionedElement
)
;
if
(
NS_WARN_IF
(
!
absolutelyPositionedStyledElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
Result
<
int32_t
nsresult
>
result
=
AddZIndexWithTransaction
(
MOZ_KnownLive
(
*
absolutelyPositionedStyledElement
)
aChange
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AddZIndexWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
result
.
unwrapErr
(
)
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
nsresult
HTMLEditor
:
:
OnDocumentModified
(
)
{
if
(
mPendingDocumentModifiedRunner
)
{
return
NS_OK
;
}
mPendingDocumentModifiedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
OnModifyDocument
"
this
&
HTMLEditor
:
:
OnModifyDocument
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingDocumentModifiedRunner
)
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
}
