#
include
"
DeleteRangeTransaction
.
h
"
#
include
"
DeleteNodeTransaction
.
h
"
#
include
"
DeleteTextTransaction
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsAString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
DeleteRangeTransaction
:
:
DeleteRangeTransaction
(
EditorBase
&
aEditorBase
nsRange
&
aRangeToDelete
RangeUpdater
*
aRangeUpdater
)
:
mEditorBase
(
&
aEditorBase
)
mRangeToDelete
(
aRangeToDelete
.
CloneRange
(
)
)
mRangeUpdater
(
aRangeUpdater
)
{
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
DeleteRangeTransaction
EditAggregateTransaction
mEditorBase
mRangeToDelete
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DeleteRangeTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditAggregateTransaction
)
NS_IMETHODIMP
DeleteRangeTransaction
:
:
DoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mRangeToDelete
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsRange
>
rangeToDelete
;
rangeToDelete
.
swap
(
mRangeToDelete
)
;
nsCOMPtr
<
nsINode
>
startParent
=
rangeToDelete
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
rangeToDelete
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endParent
=
rangeToDelete
-
>
GetEndParent
(
)
;
int32_t
endOffset
=
rangeToDelete
-
>
EndOffset
(
)
;
MOZ_ASSERT
(
startParent
&
&
endParent
)
;
if
(
startParent
=
=
endParent
)
{
nsresult
rv
=
CreateTxnsToDeleteBetween
(
startParent
startOffset
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsresult
rv
=
CreateTxnsToDeleteContent
(
startParent
startOffset
nsIEditor
:
:
eNext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateTxnsToDeleteNodesBetween
(
rangeToDelete
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateTxnsToDeleteContent
(
endParent
endOffset
nsIEditor
:
:
ePrevious
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
EditAggregateTransaction
:
:
DoTransaction
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
bAdjustSelection
;
mEditorBase
-
>
ShouldTxnSetSelection
(
&
bAdjustSelection
)
;
if
(
bAdjustSelection
)
{
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
rv
=
selection
-
>
Collapse
(
startParent
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DeleteRangeTransaction
:
:
UndoTransaction
(
)
{
return
EditAggregateTransaction
:
:
UndoTransaction
(
)
;
}
NS_IMETHODIMP
DeleteRangeTransaction
:
:
RedoTransaction
(
)
{
return
EditAggregateTransaction
:
:
RedoTransaction
(
)
;
}
NS_IMETHODIMP
DeleteRangeTransaction
:
:
GetTxnDescription
(
nsAString
&
aString
)
{
aString
.
AssignLiteral
(
"
DeleteRangeTransaction
"
)
;
return
NS_OK
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteBetween
(
nsINode
*
aNode
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
{
int32_t
numToDel
;
if
(
aStartOffset
=
=
aEndOffset
)
{
numToDel
=
1
;
}
else
{
numToDel
=
aEndOffset
-
aStartOffset
;
}
RefPtr
<
nsGenericDOMDataNode
>
charDataNode
=
static_cast
<
nsGenericDOMDataNode
*
>
(
aNode
)
;
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
new
DeleteTextTransaction
(
*
mEditorBase
*
charDataNode
aStartOffset
numToDel
mRangeUpdater
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
-
>
CanDoIt
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteTextTransaction
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
child
=
aNode
-
>
GetChildAt
(
aStartOffset
)
;
for
(
int32_t
i
=
aStartOffset
;
i
<
aEndOffset
;
+
+
i
)
{
if
(
NS_WARN_IF
(
!
child
)
)
{
break
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
new
DeleteNodeTransaction
(
*
mEditorBase
*
child
mRangeUpdater
)
;
if
(
deleteNodeTransaction
-
>
CanDoIt
(
)
)
{
AppendChild
(
deleteNodeTransaction
)
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
return
NS_OK
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteContent
(
nsINode
*
aNode
int32_t
aOffset
nsIEditor
:
:
EDirection
aAction
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
{
uint32_t
start
numToDelete
;
if
(
nsIEditor
:
:
eNext
=
=
aAction
)
{
start
=
aOffset
;
numToDelete
=
aNode
-
>
Length
(
)
-
aOffset
;
}
else
{
start
=
0
;
numToDelete
=
aOffset
;
}
if
(
numToDelete
)
{
RefPtr
<
nsGenericDOMDataNode
>
dataNode
=
static_cast
<
nsGenericDOMDataNode
*
>
(
aNode
)
;
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
new
DeleteTextTransaction
(
*
mEditorBase
*
dataNode
start
numToDelete
mRangeUpdater
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
-
>
CanDoIt
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteTextTransaction
)
;
}
}
return
NS_OK
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteNodesBetween
(
nsRange
*
aRangeToDelete
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRangeToDelete
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
new
DeleteNodeTransaction
(
*
mEditorBase
*
node
mRangeUpdater
)
;
if
(
NS_WARN_IF
(
!
deleteNodeTransaction
-
>
CanDoIt
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteNodeTransaction
)
;
iter
-
>
Next
(
)
;
}
return
NS_OK
;
}
}
