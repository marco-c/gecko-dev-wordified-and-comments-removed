#
include
"
DeleteRangeTransaction
.
h
"
#
include
"
DeleteNodeTransaction
.
h
"
#
include
"
DeleteTextTransaction
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsAString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
DeleteRangeTransaction
:
:
DeleteRangeTransaction
(
EditorBase
&
aEditorBase
nsRange
&
aRangeToDelete
)
:
mEditorBase
(
&
aEditorBase
)
mRangeToDelete
(
aRangeToDelete
.
CloneRange
(
)
)
{
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
DeleteRangeTransaction
EditAggregateTransaction
mEditorBase
mRangeToDelete
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DeleteRangeTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditAggregateTransaction
)
NS_IMETHODIMP
DeleteRangeTransaction
:
:
DoTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mRangeToDelete
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsRange
>
rangeToDelete
;
rangeToDelete
.
swap
(
mRangeToDelete
)
;
const
RangeBoundary
&
startRef
=
rangeToDelete
-
>
StartRef
(
)
;
const
RangeBoundary
&
endRef
=
rangeToDelete
-
>
EndRef
(
)
;
MOZ_ASSERT
(
startRef
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endRef
.
IsSetAndValid
(
)
)
;
if
(
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
)
{
nsresult
rv
=
CreateTxnsToDeleteBetween
(
startRef
.
AsRaw
(
)
endRef
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
CreateTxnsToDeleteContent
(
startRef
.
AsRaw
(
)
nsIEditor
:
:
eNext
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CreateTxnsToDeleteNodesBetween
(
rangeToDelete
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CreateTxnsToDeleteContent
(
endRef
.
AsRaw
(
)
nsIEditor
:
:
ePrevious
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
EditAggregateTransaction
:
:
DoTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
mEditorBase
-
>
AllowsTransactionsToChangeSelection
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
rv
=
selection
-
>
Collapse
(
startRef
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
DeleteRangeTransaction
:
:
UndoTransaction
(
)
{
return
EditAggregateTransaction
:
:
UndoTransaction
(
)
;
}
NS_IMETHODIMP
DeleteRangeTransaction
:
:
RedoTransaction
(
)
{
return
EditAggregateTransaction
:
:
RedoTransaction
(
)
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteBetween
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
if
(
NS_WARN_IF
(
!
aStart
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aEnd
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
aStart
.
Container
(
)
!
=
aEnd
.
Container
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
RefPtr
<
CharacterData
>
charDataNode
=
CharacterData
:
:
FromNode
(
aStart
.
Container
(
)
)
)
{
int32_t
numToDel
;
if
(
aStart
=
=
aEnd
)
{
numToDel
=
1
;
}
else
{
numToDel
=
aEnd
.
Offset
(
)
-
aStart
.
Offset
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
numToDel
>
0
)
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
DeleteTextTransaction
:
:
MaybeCreate
(
*
mEditorBase
*
charDataNode
aStart
.
Offset
(
)
numToDel
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteTextTransaction
)
;
return
NS_OK
;
}
for
(
nsIContent
*
child
=
aStart
.
GetChildAtOffset
(
)
;
child
&
&
child
!
=
aEnd
.
GetChildAtOffset
(
)
;
child
=
child
-
>
GetNextSibling
(
)
)
{
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
mEditorBase
*
child
)
;
if
(
deleteNodeTransaction
)
{
AppendChild
(
deleteNodeTransaction
)
;
}
}
return
NS_OK
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteContent
(
const
RawRangeBoundary
&
aPoint
nsIEditor
:
:
EDirection
aAction
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
CharacterData
>
dataNode
=
CharacterData
:
:
FromNode
(
aPoint
.
Container
(
)
)
;
if
(
!
dataNode
)
{
return
NS_OK
;
}
uint32_t
startOffset
numToDelete
;
if
(
nsIEditor
:
:
eNext
=
=
aAction
)
{
startOffset
=
aPoint
.
Offset
(
)
;
numToDelete
=
aPoint
.
Container
(
)
-
>
Length
(
)
-
aPoint
.
Offset
(
)
;
}
else
{
startOffset
=
0
;
numToDelete
=
aPoint
.
Offset
(
)
;
}
if
(
!
numToDelete
)
{
return
NS_OK
;
}
RefPtr
<
DeleteTextTransaction
>
deleteTextTransaction
=
DeleteTextTransaction
:
:
MaybeCreate
(
*
mEditorBase
*
dataNode
startOffset
numToDelete
)
;
if
(
NS_WARN_IF
(
!
deleteTextTransaction
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteTextTransaction
)
;
return
NS_OK
;
}
nsresult
DeleteRangeTransaction
:
:
CreateTxnsToDeleteNodesBetween
(
nsRange
*
aRangeToDelete
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ContentSubtreeIterator
subtreeIter
;
nsresult
rv
=
subtreeIter
.
Init
(
aRangeToDelete
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
!
subtreeIter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
DeleteNodeTransaction
>
deleteNodeTransaction
=
DeleteNodeTransaction
:
:
MaybeCreate
(
*
mEditorBase
*
node
)
;
if
(
NS_WARN_IF
(
!
deleteNodeTransaction
)
)
{
return
NS_ERROR_FAILURE
;
}
AppendChild
(
deleteNodeTransaction
)
;
subtreeIter
.
Next
(
)
;
}
return
NS_OK
;
}
}
