#
include
"
TypeInState
.
h
"
#
include
<
stddef
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStringFwd
.
h
"
namespace
mozilla
{
using
namespace
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLastSelectionPoint
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLastSelectionPoint
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
TypeInState
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
TypeInState
Release
)
TypeInState
:
:
TypeInState
(
)
:
mRelativeFontSize
(
0
)
mLastSelectionCommand
(
Command
:
:
DoNothing
)
mMouseDownFiredInLinkElement
(
false
)
mMouseUpFiredInLinkElement
(
false
)
{
Reset
(
)
;
}
TypeInState
:
:
~
TypeInState
(
)
{
Reset
(
)
;
}
nsresult
TypeInState
:
:
UpdateSelState
(
const
HTMLEditor
&
aHTMLEditor
)
{
if
(
!
aHTMLEditor
.
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
mLastSelectionPoint
=
aHTMLEditor
.
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
mLastSelectionPoint
.
IsSet
(
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoEditorDOMPointChildInvalidator
saveOnlyOffset
(
mLastSelectionPoint
)
;
return
NS_OK
;
}
void
TypeInState
:
:
PreHandleMouseEvent
(
const
MouseEvent
&
aMouseDownOrUpEvent
)
{
MOZ_ASSERT
(
aMouseDownOrUpEvent
.
WidgetEventPtr
(
)
-
>
mMessage
=
=
eMouseDown
|
|
aMouseDownOrUpEvent
.
WidgetEventPtr
(
)
-
>
mMessage
=
=
eMouseUp
)
;
bool
&
eventFiredInLinkElement
=
aMouseDownOrUpEvent
.
WidgetEventPtr
(
)
-
>
mMessage
=
=
eMouseDown
?
mMouseDownFiredInLinkElement
:
mMouseUpFiredInLinkElement
;
eventFiredInLinkElement
=
false
;
if
(
aMouseDownOrUpEvent
.
DefaultPrevented
(
)
)
{
return
;
}
EventTarget
*
target
=
aMouseDownOrUpEvent
.
GetExplicitOriginalTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
;
}
nsIContent
*
targetContent
=
nsIContent
:
:
FromEventTarget
(
target
)
;
if
(
NS_WARN_IF
(
!
targetContent
)
)
{
return
;
}
eventFiredInLinkElement
=
HTMLEditUtils
:
:
IsContentInclusiveDescendantOfLink
(
*
targetContent
)
;
}
void
TypeInState
:
:
PreHandleSelectionChangeCommand
(
Command
aCommand
)
{
mLastSelectionCommand
=
aCommand
;
}
void
TypeInState
:
:
PostHandleSelectionChangeCommand
(
const
HTMLEditor
&
aHTMLEditor
Command
aCommand
)
{
if
(
mLastSelectionCommand
!
=
aCommand
)
{
return
;
}
if
(
!
aHTMLEditor
.
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
!
aHTMLEditor
.
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
;
}
const
auto
caretPoint
=
aHTMLEditor
.
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
caretPoint
.
IsSet
(
)
)
)
{
return
;
}
if
(
!
HTMLEditUtils
:
:
IsPointAtEdgeOfLink
(
caretPoint
)
)
{
return
;
}
if
(
AreAllStylesCleared
(
)
|
|
IsLinkStyleSet
(
)
)
{
return
;
}
if
(
AreSomeStylesSet
(
)
|
|
(
AreSomeStylesCleared
(
)
&
&
!
IsOnlyLinkStyleCleared
(
)
)
)
{
ClearLinkPropAndDiscardItsSpecifiedStyle
(
)
;
return
;
}
Reset
(
)
;
ClearLinkPropAndDiscardItsSpecifiedStyle
(
)
;
}
void
TypeInState
:
:
OnSelectionChange
(
const
HTMLEditor
&
aHTMLEditor
int16_t
aReason
)
{
const
bool
causedByFrameSelectionMoveCaret
=
(
aReason
&
(
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
|
nsISelectionListener
:
:
COLLAPSETOEND_REASON
)
)
&
&
!
(
aReason
&
nsISelectionListener
:
:
JS_REASON
)
;
Command
lastSelectionCommand
=
mLastSelectionCommand
;
if
(
causedByFrameSelectionMoveCaret
)
{
mLastSelectionCommand
=
Command
:
:
DoNothing
;
}
bool
mouseEventFiredInLinkElement
=
false
;
if
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
)
)
{
MOZ_ASSERT
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
)
)
!
=
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
)
)
;
bool
&
eventFiredInLinkElement
=
aReason
&
nsISelectionListener
:
:
MOUSEDOWN_REASON
?
mMouseDownFiredInLinkElement
:
mMouseUpFiredInLinkElement
;
mouseEventFiredInLinkElement
=
eventFiredInLinkElement
;
eventFiredInLinkElement
=
false
;
}
bool
unlink
=
false
;
bool
resetAllStyles
=
true
;
if
(
aHTMLEditor
.
SelectionRef
(
)
.
IsCollapsed
(
)
&
&
aHTMLEditor
.
SelectionRef
(
)
.
RangeCount
(
)
)
{
const
auto
selectionStartPoint
=
aHTMLEditor
.
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
)
{
return
;
}
if
(
mLastSelectionPoint
=
=
selectionStartPoint
)
{
if
(
AreAllStylesCleared
(
)
|
|
IsLinkStyleSet
(
)
)
{
return
;
}
if
(
AreSomeStylesSet
(
)
|
|
(
AreSomeStylesCleared
(
)
&
&
!
IsOnlyLinkStyleCleared
(
)
)
)
{
resetAllStyles
=
false
;
}
}
RefPtr
<
Element
>
linkElement
;
if
(
HTMLEditUtils
:
:
IsPointAtEdgeOfLink
(
selectionStartPoint
getter_AddRefs
(
linkElement
)
)
)
{
if
(
causedByFrameSelectionMoveCaret
)
{
MOZ_ASSERT
(
!
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
)
)
)
;
switch
(
lastSelectionCommand
)
{
case
Command
:
:
CharNext
:
case
Command
:
:
CharPrevious
:
case
Command
:
:
MoveLeft
:
case
Command
:
:
MoveLeft2
:
case
Command
:
:
MoveRight
:
case
Command
:
:
MoveRight2
:
if
(
!
mLastSelectionPoint
.
IsSet
(
)
)
{
unlink
=
true
;
break
;
}
if
(
mLastSelectionPoint
=
=
selectionStartPoint
)
{
unlink
=
true
;
break
;
}
unlink
=
!
mLastSelectionPoint
.
GetContainer
(
)
-
>
IsInclusiveDescendantOf
(
linkElement
)
;
break
;
default
:
unlink
=
true
;
break
;
}
}
else
if
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
)
)
{
unlink
=
!
mouseEventFiredInLinkElement
;
}
else
if
(
aReason
&
nsISelectionListener
:
:
JS_REASON
)
{
unlink
=
true
;
}
else
{
switch
(
aHTMLEditor
.
GetEditAction
(
)
)
{
case
EditAction
:
:
eDeleteBackward
:
case
EditAction
:
:
eDeleteForward
:
case
EditAction
:
:
eDeleteSelection
:
case
EditAction
:
:
eDeleteToBeginningOfSoftLine
:
case
EditAction
:
:
eDeleteToEndOfSoftLine
:
case
EditAction
:
:
eDeleteWordBackward
:
case
EditAction
:
:
eDeleteWordForward
:
unlink
=
true
;
break
;
default
:
break
;
}
}
}
else
if
(
mLastSelectionPoint
=
=
selectionStartPoint
)
{
return
;
}
mLastSelectionPoint
=
selectionStartPoint
;
AutoEditorDOMPointChildInvalidator
saveOnlyOffset
(
mLastSelectionPoint
)
;
}
else
{
if
(
aHTMLEditor
.
SelectionRef
(
)
.
RangeCount
(
)
)
{
EditorRawDOMRange
firstRange
(
*
aHTMLEditor
.
SelectionRef
(
)
.
GetRangeAt
(
0
)
)
;
if
(
firstRange
.
StartRef
(
)
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
IsContentInclusiveDescendantOfLink
(
*
firstRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
unlink
=
!
HTMLEditUtils
:
:
IsRangeEntirelyInLink
(
firstRange
)
;
}
}
mLastSelectionPoint
.
Clear
(
)
;
}
if
(
resetAllStyles
)
{
Reset
(
)
;
if
(
unlink
)
{
ClearLinkPropAndDiscardItsSpecifiedStyle
(
)
;
}
return
;
}
if
(
unlink
=
=
IsExplicitlyLinkStyleCleared
(
)
)
{
return
;
}
if
(
unlink
)
{
ClearLinkPropAndDiscardItsSpecifiedStyle
(
)
;
}
else
if
(
!
unlink
)
{
RemovePropFromClearedList
(
nsGkAtoms
:
:
a
nullptr
)
;
}
}
void
TypeInState
:
:
Reset
(
)
{
mClearingStyles
.
Clear
(
)
;
mPreservingStyles
.
Clear
(
)
;
}
void
TypeInState
:
:
PreserveStyles
(
const
nsTArray
<
EditorInlineStyleAndValue
>
&
aStylesToPreserve
)
{
for
(
const
EditorInlineStyleAndValue
&
styleToPreserve
:
aStylesToPreserve
)
{
PreserveStyle
(
styleToPreserve
.
HTMLPropertyRef
(
)
styleToPreserve
.
mAttribute
styleToPreserve
.
mAttributeValue
)
;
}
}
void
TypeInState
:
:
PreserveStyle
(
nsStaticAtom
&
aHTMLProperty
nsAtom
*
aAttribute
const
nsAString
&
aAttributeValueOrCSSValue
)
{
if
(
nsGkAtoms
:
:
big
=
=
&
aHTMLProperty
)
{
mRelativeFontSize
+
+
;
return
;
}
if
(
nsGkAtoms
:
:
small
=
=
&
aHTMLProperty
)
{
mRelativeFontSize
-
-
;
return
;
}
int32_t
index
;
if
(
IsPropSet
(
aHTMLProperty
aAttribute
nullptr
index
)
)
{
mPreservingStyles
[
index
]
-
>
mAttributeValueOrCSSValue
=
aAttributeValueOrCSSValue
;
return
;
}
mPreservingStyles
.
AppendElement
(
MakeUnique
<
PropItem
>
(
&
aHTMLProperty
aAttribute
aAttributeValueOrCSSValue
)
)
;
RemovePropFromClearedList
(
&
aHTMLProperty
aAttribute
)
;
}
void
TypeInState
:
:
ClearAllProps
(
)
{
ClearProp
(
nullptr
nullptr
)
;
}
void
TypeInState
:
:
ClearProp
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
SpecifiedStyle
aSpecifiedStyle
)
{
if
(
IsPropCleared
(
aProp
aAttr
)
)
{
return
;
}
RemovePropFromSetList
(
aProp
aAttr
)
;
mClearingStyles
.
AppendElement
(
MakeUnique
<
PropItem
>
(
aProp
aAttr
u
"
"
_ns
aSpecifiedStyle
)
)
;
}
void
TypeInState
:
:
ClearLinkPropAndDiscardItsSpecifiedStyle
(
)
{
ClearProp
(
nsGkAtoms
:
:
a
nullptr
SpecifiedStyle
:
:
Discard
)
;
}
UniquePtr
<
PropItem
>
TypeInState
:
:
TakeClearProperty
(
)
{
if
(
mClearingStyles
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
mClearingStyles
.
PopLastElement
(
)
;
}
int32_t
TypeInState
:
:
TakeRelativeFontSize
(
)
{
int32_t
relSize
=
mRelativeFontSize
;
mRelativeFontSize
=
0
;
return
relSize
;
}
void
TypeInState
:
:
GetTypingState
(
bool
&
isSet
bool
&
theSetting
nsStaticAtom
&
aProp
nsAtom
*
aAttr
nsString
*
aOutValue
)
{
if
(
IsPropSet
(
aProp
aAttr
aOutValue
)
)
{
isSet
=
true
;
theSetting
=
true
;
}
else
if
(
IsPropCleared
(
&
aProp
aAttr
)
)
{
isSet
=
true
;
theSetting
=
false
;
}
else
{
isSet
=
false
;
}
}
void
TypeInState
:
:
RemovePropFromSetList
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
!
aProp
)
{
mPreservingStyles
.
Clear
(
)
;
mRelativeFontSize
=
0
;
}
else
if
(
FindPropInList
(
aProp
aAttr
nullptr
mPreservingStyles
index
)
)
{
mPreservingStyles
.
RemoveElementAt
(
index
)
;
}
}
void
TypeInState
:
:
RemovePropFromClearedList
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearingStyles
index
)
)
{
mClearingStyles
.
RemoveElementAt
(
index
)
;
}
}
bool
TypeInState
:
:
IsPropSet
(
nsStaticAtom
&
aProp
nsAtom
*
aAttr
nsAString
*
outValue
)
{
int32_t
i
;
return
IsPropSet
(
aProp
aAttr
outValue
i
)
;
}
bool
TypeInState
:
:
IsPropSet
(
nsStaticAtom
&
aProp
nsAtom
*
aAttr
nsAString
*
outValue
int32_t
&
outIndex
)
{
return
FindPropInList
(
&
aProp
aAttr
outValue
mPreservingStyles
outIndex
)
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
i
;
return
IsPropCleared
(
aProp
aAttr
i
)
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
int32_t
&
outIndex
)
{
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearingStyles
outIndex
)
)
{
return
true
;
}
if
(
AreAllStylesCleared
(
)
)
{
outIndex
=
-
1
;
return
true
;
}
return
false
;
}
bool
TypeInState
:
:
FindPropInList
(
nsStaticAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
const
nsTArray
<
UniquePtr
<
PropItem
>
>
&
aList
int32_t
&
outIndex
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
_empty
)
{
aAttr
=
nullptr
;
}
for
(
size_t
i
:
IntegerRange
(
aList
.
Length
(
)
)
)
{
const
UniquePtr
<
PropItem
>
&
item
=
aList
[
i
]
;
if
(
item
-
>
mTag
=
=
aProp
&
&
item
-
>
mAttribute
=
=
aAttr
)
{
if
(
outValue
)
{
*
outValue
=
item
-
>
mAttributeValueOrCSSValue
;
}
outIndex
=
static_cast
<
int32_t
>
(
i
)
;
return
true
;
}
}
return
false
;
}
}
