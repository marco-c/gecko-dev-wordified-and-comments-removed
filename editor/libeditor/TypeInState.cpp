#
include
"
TypeInState
.
h
"
#
include
<
stddef
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStringFwd
.
h
"
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsAtom
;
namespace
mozilla
{
using
namespace
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLastSelectionPoint
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLastSelectionPoint
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
TypeInState
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
TypeInState
Release
)
TypeInState
:
:
TypeInState
(
)
:
mRelativeFontSize
(
0
)
{
Reset
(
)
;
}
TypeInState
:
:
~
TypeInState
(
)
{
Reset
(
)
;
}
nsresult
TypeInState
:
:
UpdateSelState
(
Selection
*
aSelection
)
{
if
(
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aSelection
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
mLastSelectionPoint
=
EditorBase
:
:
GetStartPoint
(
*
aSelection
)
;
if
(
!
mLastSelectionPoint
.
IsSet
(
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoEditorDOMPointChildInvalidator
saveOnlyOffset
(
mLastSelectionPoint
)
;
return
NS_OK
;
}
void
TypeInState
:
:
OnSelectionChange
(
Selection
&
aSelection
int16_t
aReason
)
{
bool
unlink
=
false
;
if
(
aSelection
.
IsCollapsed
(
)
&
&
aSelection
.
RangeCount
(
)
)
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
aSelection
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
;
}
if
(
mLastSelectionPoint
=
=
selectionStartPoint
)
{
return
;
}
if
(
aReason
=
=
nsISelectionListener
:
:
KEYPRESS_REASON
&
&
mLastSelectionPoint
.
IsSet
(
)
&
&
selectionStartPoint
.
IsInTextNode
(
)
&
&
(
selectionStartPoint
.
IsStartOfContainer
(
)
|
|
selectionStartPoint
.
IsEndOfContainer
(
)
)
&
&
mLastSelectionPoint
.
GetContainer
(
)
!
=
selectionStartPoint
.
GetContainer
(
)
)
{
bool
maybeStartOfAnchor
=
selectionStartPoint
.
IsStartOfContainer
(
)
;
for
(
EditorRawDOMPoint
point
(
selectionStartPoint
.
GetContainer
(
)
)
;
point
.
IsSet
(
)
&
&
(
maybeStartOfAnchor
?
point
.
IsStartOfContainer
(
)
:
point
.
IsAtLastContent
(
)
)
;
point
.
Set
(
point
.
GetContainer
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
point
.
GetContainer
(
)
)
)
{
unlink
=
!
mLastSelectionPoint
.
GetContainer
(
)
-
>
IsInclusiveDescendantOf
(
point
.
GetContainer
(
)
)
;
break
;
}
}
}
mLastSelectionPoint
=
selectionStartPoint
;
AutoEditorDOMPointChildInvalidator
saveOnlyOffset
(
mLastSelectionPoint
)
;
}
else
{
mLastSelectionPoint
.
Clear
(
)
;
}
Reset
(
)
;
if
(
unlink
)
{
ClearProp
(
nsGkAtoms
:
:
a
nullptr
)
;
}
}
void
TypeInState
:
:
Reset
(
)
{
for
(
size_t
i
=
0
n
=
mClearedArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mClearedArray
[
i
]
;
}
mClearedArray
.
Clear
(
)
;
for
(
size_t
i
=
0
n
=
mSetArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mSetArray
[
i
]
;
}
mSetArray
.
Clear
(
)
;
}
void
TypeInState
:
:
SetProp
(
nsAtom
*
aProp
nsAtom
*
aAttr
const
nsAString
&
aValue
)
{
if
(
nsGkAtoms
:
:
big
=
=
aProp
)
{
mRelativeFontSize
+
+
;
return
;
}
if
(
nsGkAtoms
:
:
small
=
=
aProp
)
{
mRelativeFontSize
-
-
;
return
;
}
int32_t
index
;
if
(
IsPropSet
(
aProp
aAttr
nullptr
index
)
)
{
mSetArray
[
index
]
-
>
value
=
aValue
;
return
;
}
mSetArray
.
AppendElement
(
new
PropItem
(
aProp
aAttr
aValue
)
)
;
RemovePropFromClearedList
(
aProp
aAttr
)
;
}
void
TypeInState
:
:
ClearAllProps
(
)
{
ClearProp
(
nullptr
nullptr
)
;
}
void
TypeInState
:
:
ClearProp
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
if
(
IsPropCleared
(
aProp
aAttr
)
)
{
return
;
}
PropItem
*
item
=
new
PropItem
(
aProp
aAttr
u
"
"
_ns
)
;
RemovePropFromSetList
(
aProp
aAttr
)
;
mClearedArray
.
AppendElement
(
item
)
;
}
UniquePtr
<
PropItem
>
TypeInState
:
:
TakeClearProperty
(
)
{
return
mClearedArray
.
Length
(
)
?
UniquePtr
<
PropItem
>
{
mClearedArray
.
PopLastElement
(
)
}
:
nullptr
;
}
UniquePtr
<
PropItem
>
TypeInState
:
:
TakeSetProperty
(
)
{
return
mSetArray
.
Length
(
)
?
UniquePtr
<
PropItem
>
{
mSetArray
.
PopLastElement
(
)
}
:
nullptr
;
}
int32_t
TypeInState
:
:
TakeRelativeFontSize
(
)
{
int32_t
relSize
=
mRelativeFontSize
;
mRelativeFontSize
=
0
;
return
relSize
;
}
void
TypeInState
:
:
GetTypingState
(
bool
&
isSet
bool
&
theSetting
nsAtom
*
aProp
nsAtom
*
aAttr
nsString
*
aValue
)
{
if
(
IsPropSet
(
aProp
aAttr
aValue
)
)
{
isSet
=
true
;
theSetting
=
true
;
}
else
if
(
IsPropCleared
(
aProp
aAttr
)
)
{
isSet
=
true
;
theSetting
=
false
;
}
else
{
isSet
=
false
;
}
}
void
TypeInState
:
:
RemovePropFromSetList
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
!
aProp
)
{
for
(
size_t
i
=
0
n
=
mSetArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mSetArray
[
i
]
;
}
mSetArray
.
Clear
(
)
;
mRelativeFontSize
=
0
;
}
else
if
(
FindPropInList
(
aProp
aAttr
nullptr
mSetArray
index
)
)
{
delete
mSetArray
[
index
]
;
mSetArray
.
RemoveElementAt
(
index
)
;
}
}
void
TypeInState
:
:
RemovePropFromClearedList
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearedArray
index
)
)
{
delete
mClearedArray
[
index
]
;
mClearedArray
.
RemoveElementAt
(
index
)
;
}
}
bool
TypeInState
:
:
IsPropSet
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
)
{
int32_t
i
;
return
IsPropSet
(
aProp
aAttr
outValue
i
)
;
}
bool
TypeInState
:
:
IsPropSet
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
int32_t
&
outIndex
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
_empty
)
{
aAttr
=
nullptr
;
}
size_t
count
=
mSetArray
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
PropItem
*
item
=
mSetArray
[
i
]
;
if
(
item
-
>
tag
=
=
aProp
&
&
item
-
>
attr
=
=
aAttr
)
{
if
(
outValue
)
{
*
outValue
=
item
-
>
value
;
}
outIndex
=
i
;
return
true
;
}
}
return
false
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
i
;
return
IsPropCleared
(
aProp
aAttr
i
)
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsAtom
*
aProp
nsAtom
*
aAttr
int32_t
&
outIndex
)
{
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearedArray
outIndex
)
)
{
return
true
;
}
if
(
FindPropInList
(
nullptr
nullptr
nullptr
mClearedArray
outIndex
)
)
{
outIndex
=
-
1
;
return
true
;
}
return
false
;
}
bool
TypeInState
:
:
FindPropInList
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
nsTArray
<
PropItem
*
>
&
aList
int32_t
&
outIndex
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
_empty
)
{
aAttr
=
nullptr
;
}
size_t
count
=
aList
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
PropItem
*
item
=
aList
[
i
]
;
if
(
item
-
>
tag
=
=
aProp
&
&
item
-
>
attr
=
=
aAttr
)
{
if
(
outValue
)
{
*
outValue
=
item
-
>
value
;
}
outIndex
=
i
;
return
true
;
}
}
return
false
;
}
}
