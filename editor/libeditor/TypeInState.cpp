#
include
"
TypeInState
.
h
"
#
include
<
stddef
.
h
>
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStringFwd
.
h
"
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsAtom
;
class
nsIDOMDocument
;
namespace
mozilla
{
using
namespace
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLastSelectionContainer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLastSelectionContainer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
TypeInState
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
TypeInState
Release
)
TypeInState
:
:
TypeInState
(
)
:
mRelativeFontSize
(
0
)
mLastSelectionOffset
(
0
)
{
Reset
(
)
;
}
TypeInState
:
:
~
TypeInState
(
)
{
Reset
(
)
;
}
nsresult
TypeInState
:
:
UpdateSelState
(
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
if
(
!
aSelection
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
return
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
mLastSelectionContainer
)
&
mLastSelectionOffset
)
;
}
void
TypeInState
:
:
OnSelectionChange
(
Selection
&
aSelection
)
{
if
(
aSelection
.
IsCollapsed
(
)
&
&
aSelection
.
RangeCount
(
)
)
{
nsCOMPtr
<
nsIDOMNode
>
selNode
;
int32_t
selOffset
=
0
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
&
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
selNode
&
&
selNode
=
=
mLastSelectionContainer
&
&
selOffset
=
=
mLastSelectionOffset
)
{
return
;
}
mLastSelectionContainer
=
selNode
;
mLastSelectionOffset
=
selOffset
;
}
else
{
mLastSelectionContainer
=
nullptr
;
mLastSelectionOffset
=
0
;
}
Reset
(
)
;
}
void
TypeInState
:
:
Reset
(
)
{
for
(
size_t
i
=
0
n
=
mClearedArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mClearedArray
[
i
]
;
}
mClearedArray
.
Clear
(
)
;
for
(
size_t
i
=
0
n
=
mSetArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mSetArray
[
i
]
;
}
mSetArray
.
Clear
(
)
;
}
void
TypeInState
:
:
SetProp
(
nsAtom
*
aProp
nsAtom
*
aAttr
const
nsAString
&
aValue
)
{
if
(
nsGkAtoms
:
:
big
=
=
aProp
)
{
mRelativeFontSize
+
+
;
return
;
}
if
(
nsGkAtoms
:
:
small
=
=
aProp
)
{
mRelativeFontSize
-
-
;
return
;
}
int32_t
index
;
if
(
IsPropSet
(
aProp
aAttr
nullptr
index
)
)
{
mSetArray
[
index
]
-
>
value
=
aValue
;
return
;
}
mSetArray
.
AppendElement
(
new
PropItem
(
aProp
aAttr
aValue
)
)
;
RemovePropFromClearedList
(
aProp
aAttr
)
;
}
void
TypeInState
:
:
ClearAllProps
(
)
{
ClearProp
(
nullptr
nullptr
)
;
}
void
TypeInState
:
:
ClearProp
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
if
(
IsPropCleared
(
aProp
aAttr
)
)
{
return
;
}
PropItem
*
item
=
new
PropItem
(
aProp
aAttr
EmptyString
(
)
)
;
RemovePropFromSetList
(
aProp
aAttr
)
;
mClearedArray
.
AppendElement
(
item
)
;
}
UniquePtr
<
PropItem
>
TypeInState
:
:
TakeClearProperty
(
)
{
size_t
count
=
mClearedArray
.
Length
(
)
;
if
(
!
count
)
{
return
nullptr
;
}
-
-
count
;
PropItem
*
propItem
=
mClearedArray
[
count
]
;
mClearedArray
.
RemoveElementAt
(
count
)
;
return
UniquePtr
<
PropItem
>
(
propItem
)
;
}
UniquePtr
<
PropItem
>
TypeInState
:
:
TakeSetProperty
(
)
{
size_t
count
=
mSetArray
.
Length
(
)
;
if
(
!
count
)
{
return
nullptr
;
}
count
-
-
;
PropItem
*
propItem
=
mSetArray
[
count
]
;
mSetArray
.
RemoveElementAt
(
count
)
;
return
UniquePtr
<
PropItem
>
(
propItem
)
;
}
int32_t
TypeInState
:
:
TakeRelativeFontSize
(
)
{
int32_t
relSize
=
mRelativeFontSize
;
mRelativeFontSize
=
0
;
return
relSize
;
}
void
TypeInState
:
:
GetTypingState
(
bool
&
isSet
bool
&
theSetting
nsAtom
*
aProp
nsAtom
*
aAttr
nsString
*
aValue
)
{
if
(
IsPropSet
(
aProp
aAttr
aValue
)
)
{
isSet
=
true
;
theSetting
=
true
;
}
else
if
(
IsPropCleared
(
aProp
aAttr
)
)
{
isSet
=
true
;
theSetting
=
false
;
}
else
{
isSet
=
false
;
}
}
void
TypeInState
:
:
RemovePropFromSetList
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
!
aProp
)
{
for
(
size_t
i
=
0
n
=
mSetArray
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
delete
mSetArray
[
i
]
;
}
mSetArray
.
Clear
(
)
;
mRelativeFontSize
=
0
;
}
else
if
(
FindPropInList
(
aProp
aAttr
nullptr
mSetArray
index
)
)
{
delete
mSetArray
[
index
]
;
mSetArray
.
RemoveElementAt
(
index
)
;
}
}
void
TypeInState
:
:
RemovePropFromClearedList
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
index
;
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearedArray
index
)
)
{
delete
mClearedArray
[
index
]
;
mClearedArray
.
RemoveElementAt
(
index
)
;
}
}
bool
TypeInState
:
:
IsPropSet
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
)
{
int32_t
i
;
return
IsPropSet
(
aProp
aAttr
outValue
i
)
;
}
bool
TypeInState
:
:
IsPropSet
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
int32_t
&
outIndex
)
{
size_t
count
=
mSetArray
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
PropItem
*
item
=
mSetArray
[
i
]
;
if
(
item
-
>
tag
=
=
aProp
&
&
item
-
>
attr
=
=
aAttr
)
{
if
(
outValue
)
{
*
outValue
=
item
-
>
value
;
}
outIndex
=
i
;
return
true
;
}
}
return
false
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsAtom
*
aProp
nsAtom
*
aAttr
)
{
int32_t
i
;
return
IsPropCleared
(
aProp
aAttr
i
)
;
}
bool
TypeInState
:
:
IsPropCleared
(
nsAtom
*
aProp
nsAtom
*
aAttr
int32_t
&
outIndex
)
{
if
(
FindPropInList
(
aProp
aAttr
nullptr
mClearedArray
outIndex
)
)
{
return
true
;
}
if
(
FindPropInList
(
nullptr
nullptr
nullptr
mClearedArray
outIndex
)
)
{
outIndex
=
-
1
;
return
true
;
}
return
false
;
}
bool
TypeInState
:
:
FindPropInList
(
nsAtom
*
aProp
nsAtom
*
aAttr
nsAString
*
outValue
nsTArray
<
PropItem
*
>
&
aList
int32_t
&
outIndex
)
{
size_t
count
=
aList
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
PropItem
*
item
=
aList
[
i
]
;
if
(
item
-
>
tag
=
=
aProp
&
&
item
-
>
attr
=
=
aAttr
)
{
if
(
outValue
)
{
*
outValue
=
item
-
>
value
;
}
outIndex
=
i
;
return
true
;
}
}
return
false
;
}
PropItem
:
:
PropItem
(
)
:
tag
(
nullptr
)
attr
(
nullptr
)
{
MOZ_COUNT_CTOR
(
PropItem
)
;
}
PropItem
:
:
PropItem
(
nsAtom
*
aTag
nsAtom
*
aAttr
const
nsAString
&
aValue
)
:
tag
(
aTag
)
attr
(
aAttr
)
value
(
aValue
)
{
MOZ_COUNT_CTOR
(
PropItem
)
;
}
PropItem
:
:
~
PropItem
(
)
{
MOZ_COUNT_DTOR
(
PropItem
)
;
}
}
