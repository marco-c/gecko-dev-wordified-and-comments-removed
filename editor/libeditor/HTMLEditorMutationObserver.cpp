#
include
"
HTMLEditor
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditorNestedClasses
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozInlineSpellChecker
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
MOZ_ASSERT
(
mPendingRootElementUpdatedRunner
"
HTMLEditor
:
:
NotifyRootChanged
(
)
should
be
called
via
a
runner
"
)
;
mPendingRootElementUpdatedRunner
=
nullptr
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InstallEventListeners
(
)
failed
but
ignored
"
)
;
return
;
}
UpdateRootElement
(
)
;
if
(
MOZ_LIKELY
(
mRootElement
)
)
{
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
"
"
failed
"
"
but
ignored
"
)
;
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
if
(
node
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
InitializeSelection
(
*
node
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
InitializeSelection
(
)
failed
but
ignored
"
)
;
}
SyncRealTimeSpell
(
)
;
}
RefPtr
<
Element
>
newRootElement
(
mRootElement
)
;
IMEStateManager
:
:
OnUpdateHTMLEditorRootElement
(
*
this
newRootElement
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
const
ContentAppendInfo
&
)
{
DoContentInserted
(
aFirstNewContent
ContentNodeIs
:
:
Appended
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentInserted
(
nsIContent
*
aChild
const
ContentInsertInfo
&
)
{
DoContentInserted
(
aChild
ContentNodeIs
:
:
Inserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
if
(
Element
*
root
=
GetRoot
(
)
)
{
if
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
IsInNativeAnonymousSubtree
(
)
!
=
aChild
-
>
IsInNativeAnonymousSubtree
(
)
|
|
root
-
>
IsInShadowTree
(
)
!
=
aChild
-
>
IsInShadowTree
(
)
)
{
return
false
;
}
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
IsInShadowTree
(
)
&
&
!
aChild
-
>
IsInNativeAnonymousSubtree
(
)
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
const
{
if
(
!
mRootElement
)
{
return
true
;
}
return
mRootElement
!
=
GetBodyElement
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIContent
*
aChild
ContentNodeIs
aContentNodeIs
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
ShouldReplaceRootElement
(
)
)
{
mRootElement
=
nullptr
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
container
-
>
IsEditable
(
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
RunOrScheduleOnModifyDocument
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RunOrScheduleOnModifyDocument
(
)
failed
but
ignored
"
)
;
if
(
mInlineSpellChecker
)
{
nsIContent
*
endContent
=
aChild
;
if
(
aContentNodeIs
=
=
ContentNodeIs
:
:
Appended
)
{
nsIContent
*
child
=
nullptr
;
for
(
child
=
aChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
InclusiveDescendantMayNeedSpellchecking
(
this
)
)
{
break
;
}
}
if
(
!
child
)
{
return
;
}
endContent
=
container
-
>
GetLastChild
(
)
;
}
else
if
(
!
aChild
-
>
InclusiveDescendantMayNeedSpellchecking
(
this
)
)
{
return
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aChild
)
;
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
NS_WARNING_ASSERTION
(
rvIgnored
=
=
NS_ERROR_NOT_INITIALIZED
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
mozInlineSpellChecker
:
:
SpellCheckRange
(
)
failed
but
ignored
"
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentWillBeRemoved
(
nsIContent
*
aChild
const
ContentRemoveInfo
&
)
{
if
(
mLastCollapsibleWhiteSpaceAppendedTextNode
=
=
aChild
)
{
mLastCollapsibleWhiteSpaceAppendedTextNode
=
nullptr
;
}
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
mRootElement
&
&
mRootElement
-
>
IsInclusiveDescendantOf
(
aChild
)
)
{
mRootElement
=
nullptr
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
aChild
-
>
GetParentNode
(
)
-
>
IsEditable
(
)
)
{
if
(
aChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
RunOrScheduleOnModifyDocument
(
aChild
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RunOrScheduleOnModifyDocument
(
)
failed
but
ignored
"
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
if
(
!
mInlineSpellChecker
|
|
!
aContent
-
>
IsEditable
(
)
|
|
!
IsInObservedSubtree
(
aContent
)
|
|
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eNone
)
{
return
;
}
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
InclusiveDescendantMayNeedSpellchecking
(
this
)
)
{
return
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aContent
)
;
range
-
>
SelectNodesInContainer
(
parent
aContent
aContent
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
}
nsresult
HTMLEditor
:
:
RunOrScheduleOnModifyDocument
(
const
nsIContent
*
aContentWillBeRemoved
)
{
if
(
mPendingDocumentModifiedRunner
)
{
return
NS_OK
;
}
mPendingDocumentModifiedRunner
=
new
DocumentModifiedEvent
(
*
this
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingDocumentModifiedRunner
)
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
nsresult
HTMLEditor
:
:
OnModifyDocument
(
const
DocumentModifiedEvent
&
aRunner
)
{
MOZ_ASSERT
(
mPendingDocumentModifiedRunner
"
HTMLEditor
:
:
OnModifyDocument
(
)
should
be
called
via
a
runner
"
)
;
MOZ_ASSERT
(
&
aRunner
=
=
mPendingDocumentModifiedRunner
)
;
mPendingDocumentModifiedRunner
=
nullptr
;
Maybe
<
AutoEditActionDataSetter
>
editActionData
;
if
(
!
IsEditActionDataAvailable
(
)
)
{
editActionData
.
emplace
(
*
this
EditAction
:
:
eCreatePaddingBRElementForEmptyEditor
)
;
if
(
NS_WARN_IF
(
!
editActionData
-
>
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
rv
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
}
