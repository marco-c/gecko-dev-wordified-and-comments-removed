#
include
"
HTMLEditRules
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
<
algorithm
>
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
enum
{
kLonely
=
0
kPrevSib
=
1
kNextSib
=
2
kBothSibs
=
3
}
;
static
bool
IsStyleCachePreservingSubAction
(
EditSubAction
aEditSubAction
)
{
return
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertParagraphSeparator
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrChangeList
|
|
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
|
|
aEditSubAction
=
=
EditSubAction
:
:
eRemoveList
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrChangeDefinitionList
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertElement
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertQuotation
;
}
static
nsAtom
&
ParagraphSeparatorElement
(
ParagraphSeparator
separator
)
{
switch
(
separator
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
paragraph
separator
!
"
)
;
case
ParagraphSeparator
:
:
div
:
return
*
nsGkAtoms
:
:
div
;
case
ParagraphSeparator
:
:
p
:
return
*
nsGkAtoms
:
:
p
;
case
ParagraphSeparator
:
:
br
:
return
*
nsGkAtoms
:
:
br
;
}
}
class
TableCellAndListItemFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
aNode
)
;
}
}
;
class
BRNodeFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
}
;
class
EmptyEditableFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
EmptyEditableFunctor
(
HTMLEditor
*
aHTMLEditor
)
:
mHTMLEditor
(
aHTMLEditor
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
if
(
mHTMLEditor
-
>
IsEditable
(
aNode
)
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
aNode
)
)
)
{
bool
bIsEmptyNode
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
aNode
&
bIsEmptyNode
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
bIsEmptyNode
)
{
return
true
;
}
}
return
false
;
}
protected
:
HTMLEditor
*
mHTMLEditor
;
}
;
HTMLEditRules
:
:
HTMLEditRules
(
)
:
mHTMLEditor
(
nullptr
)
mListenerEnabled
(
false
)
mReturnInEmptyLIKillsList
(
false
)
mDidDeleteSelection
(
false
)
mDidRangedDelete
(
false
)
mRestoreContentEditableCount
(
false
)
mJoinOffset
(
0
)
{
mIsHTMLEditRules
=
true
;
InitFields
(
)
;
}
void
HTMLEditRules
:
:
InitFields
(
)
{
mHTMLEditor
=
nullptr
;
mDocChangeRange
=
nullptr
;
mReturnInEmptyLIKillsList
=
true
;
mDidDeleteSelection
=
false
;
mDidRangedDelete
=
false
;
mRestoreContentEditableCount
=
false
;
mUtilRange
=
nullptr
;
mJoinOffset
=
0
;
mNewBlock
=
nullptr
;
mRangeItem
=
new
RangeItem
(
)
;
InitStyleCacheArray
(
mCachedStyles
)
;
}
void
HTMLEditRules
:
:
InitStyleCacheArray
(
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
aStyleCache
[
0
]
=
StyleCache
(
nsGkAtoms
:
:
b
nullptr
)
;
aStyleCache
[
1
]
=
StyleCache
(
nsGkAtoms
:
:
i
nullptr
)
;
aStyleCache
[
2
]
=
StyleCache
(
nsGkAtoms
:
:
u
nullptr
)
;
aStyleCache
[
3
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
;
aStyleCache
[
4
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
size
)
;
aStyleCache
[
5
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
)
;
aStyleCache
[
6
]
=
StyleCache
(
nsGkAtoms
:
:
tt
nullptr
)
;
aStyleCache
[
7
]
=
StyleCache
(
nsGkAtoms
:
:
em
nullptr
)
;
aStyleCache
[
8
]
=
StyleCache
(
nsGkAtoms
:
:
strong
nullptr
)
;
aStyleCache
[
9
]
=
StyleCache
(
nsGkAtoms
:
:
dfn
nullptr
)
;
aStyleCache
[
10
]
=
StyleCache
(
nsGkAtoms
:
:
code
nullptr
)
;
aStyleCache
[
11
]
=
StyleCache
(
nsGkAtoms
:
:
samp
nullptr
)
;
aStyleCache
[
12
]
=
StyleCache
(
nsGkAtoms
:
:
var
nullptr
)
;
aStyleCache
[
13
]
=
StyleCache
(
nsGkAtoms
:
:
cite
nullptr
)
;
aStyleCache
[
14
]
=
StyleCache
(
nsGkAtoms
:
:
abbr
nullptr
)
;
aStyleCache
[
15
]
=
StyleCache
(
nsGkAtoms
:
:
acronym
nullptr
)
;
aStyleCache
[
16
]
=
StyleCache
(
nsGkAtoms
:
:
backgroundColor
nullptr
)
;
aStyleCache
[
17
]
=
StyleCache
(
nsGkAtoms
:
:
sub
nullptr
)
;
aStyleCache
[
18
]
=
StyleCache
(
nsGkAtoms
:
:
sup
nullptr
)
;
}
HTMLEditRules
:
:
~
HTMLEditRules
(
)
{
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
HTMLEditRules
TextEditRules
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLEditRules
TextEditRules
mDocChangeRange
mUtilRange
mNewBlock
mRangeItem
)
nsresult
HTMLEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
|
|
NS_WARN_IF
(
!
aTextEditor
-
>
AsHTMLEditor
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
InitFields
(
)
;
mHTMLEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
Selection
*
selection
=
aTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsresult
rv
=
TextEditRules
:
:
Init
(
aTextEditor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
static
const
char
kPrefName
[
]
=
"
editor
.
html
.
typing
.
returnInEmptyListItemClosesList
"
;
nsAutoCString
returnInEmptyLIKillsList
;
Preferences
:
:
GetCString
(
kPrefName
returnInEmptyLIKillsList
)
;
mReturnInEmptyLIKillsList
=
!
returnInEmptyLIKillsList
.
EqualsLiteral
(
"
false
"
)
;
nsCOMPtr
<
nsINode
>
node
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
!
node
)
{
node
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mUtilRange
=
new
nsRange
(
node
)
;
AutoLockRulesSniffing
lockIt
(
this
)
;
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
node
)
;
}
if
(
node
-
>
IsElement
(
)
)
{
ErrorResult
error
;
mDocChangeRange
-
>
SelectNode
(
*
node
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInChangedRange
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
<
br
>
elements
to
empty
list
items
and
table
cells
"
)
;
}
StartToListenToEditSubActions
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DetachEditor
(
)
{
EndListeningToEditSubActions
(
)
;
mHTMLEditor
=
nullptr
;
return
TextEditRules
:
:
DetachEditor
(
)
;
}
nsresult
HTMLEditRules
:
:
BeforeEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mActionNesting
+
+
;
mDidRangedDelete
=
false
;
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRangeItem
-
>
StoreRange
(
SelectionRef
(
)
.
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
mRangeItem
-
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
selEndNode
=
mRangeItem
-
>
mEndContainer
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
mDidDeleteSelection
=
false
;
if
(
mDocChangeRange
)
{
mDocChangeRange
-
>
Reset
(
)
;
}
if
(
mUtilRange
)
{
mUtilRange
-
>
Reset
(
)
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
|
|
IsStyleCachePreservingSubAction
(
aEditSubAction
)
)
{
nsCOMPtr
<
nsINode
>
selNode
=
aDirection
=
=
nsIEditor
:
:
eNext
?
selEndNode
:
selStartNode
;
nsresult
rv
=
CacheInlineStyles
(
selNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsHTMLDocument
*
htmlDoc
=
HTMLEditorRef
(
)
.
GetHTMLDocument
(
)
;
if
(
NS_WARN_IF
(
!
htmlDoc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
mRestoreContentEditableCount
=
true
;
}
nsresult
rv
=
ConfirmSelectionInBody
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
mTopLevelEditSubAction
=
aEditSubAction
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
MOZ_ASSERT
(
mActionNesting
>
0
)
;
nsresult
rv
=
NS_OK
;
mActionNesting
-
-
;
if
(
!
mActionNesting
)
{
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
rv
=
AfterEditInner
(
aEditSubAction
aDirection
)
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
if
(
mRestoreContentEditableCount
)
{
nsHTMLDocument
*
htmlDoc
=
HTMLEditorRef
(
)
.
GetHTMLDocument
(
)
;
if
(
NS_WARN_IF
(
!
htmlDoc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
mRestoreContentEditableCount
=
false
;
}
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEditInner
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
ConfirmSelectionInBody
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
normalize
Selection
"
)
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eReplaceHeadWithHTMLSource
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateBogusNode
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
rangeStartContainer
rangeEndContainer
;
uint32_t
rangeStartOffset
=
0
rangeEndOffset
=
0
;
bool
bDamagedRange
=
false
;
if
(
mDocChangeRange
)
{
rangeStartContainer
=
mDocChangeRange
-
>
GetStartContainer
(
)
;
rangeEndContainer
=
mDocChangeRange
-
>
GetEndContainer
(
)
;
rangeStartOffset
=
mDocChangeRange
-
>
StartOffset
(
)
;
rangeEndOffset
=
mDocChangeRange
-
>
EndOffset
(
)
;
if
(
rangeStartContainer
&
&
rangeEndContainer
)
{
bDamagedRange
=
true
;
}
}
if
(
bDamagedRange
&
&
!
(
(
aEditSubAction
=
=
EditSubAction
:
:
eUndo
)
|
|
(
aEditSubAction
=
=
EditSubAction
:
:
eRedo
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
PromoteRange
(
*
mDocChangeRange
aEditSubAction
)
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
&
&
mDidRangedDelete
)
{
nsresult
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInChangedRange
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
<
br
>
elements
to
empty
list
items
and
table
cells
"
)
;
if
(
aEditSubAction
!
=
EditSubAction
:
:
eInsertText
&
&
aEditSubAction
!
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
CollapseAdjacentTextNodes
(
mDocChangeRange
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
RemoveEmptyNodesInChangedRange
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertParagraphSeparator
|
|
aEditSubAction
=
=
EditSubAction
:
:
ePasteHTMLContent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertHTMLSource
)
{
rv
=
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ENSURE_STATE
(
mRangeItem
-
>
mStartContainer
)
;
NS_ENSURE_STATE
(
mRangeItem
-
>
mEndContainer
)
;
WSRunObject
(
&
HTMLEditorRef
(
)
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
)
.
AdjustWhitespace
(
)
;
if
(
mRangeItem
-
>
mStartContainer
!
=
mRangeItem
-
>
mEndContainer
|
|
mRangeItem
-
>
mStartOffset
!
=
mRangeItem
-
>
mEndOffset
)
{
WSRunObject
(
&
HTMLEditorRef
(
)
mRangeItem
-
>
mEndContainer
mRangeItem
-
>
mEndOffset
)
.
AdjustWhitespace
(
)
;
}
}
if
(
mNewBlock
)
{
rv
=
PinSelectionToNewBlock
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
pin
selection
to
the
new
block
"
)
;
mNewBlock
=
nullptr
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertParagraphSeparator
|
|
aEditSubAction
=
=
EditSubAction
:
:
ePasteHTMLContent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertHTMLSource
)
{
rv
=
AdjustSelection
(
aDirection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
|
|
IsStyleCachePreservingSubAction
(
aEditSubAction
)
)
{
HTMLEditorRef
(
)
.
mTypeInState
-
>
UpdateSelState
(
&
SelectionRef
(
)
)
;
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ClearCachedStyles
(
)
;
}
}
rv
=
HTMLEditorRef
(
)
.
HandleInlineSpellCheck
(
aEditSubAction
SelectionRef
(
)
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
rangeStartContainer
rangeStartOffset
rangeEndContainer
rangeEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CreateBogusNodeIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
mDidExplicitlySetInterline
)
{
CheckInterlinePosition
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillDoAction
(
Selection
*
aSelection
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
aInfo
.
mEditSubAction
=
=
EditSubAction
:
:
eComputeTextToOutput
|
|
aInfo
.
mEditSubAction
=
=
EditSubAction
:
:
eUndo
|
|
aInfo
.
mEditSubAction
=
=
EditSubAction
:
:
eRedo
)
{
return
TextEditRules
:
:
WillDoAction
(
aSelection
aInfo
aCancel
aHandled
)
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
aSelection
)
;
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
selStartNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
selStartNode
!
=
selEndNode
)
{
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
selEndNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
range
-
>
GetCommonAncestor
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
}
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
UndefineCaretBidiLevel
(
)
;
return
WillInsertText
(
aInfo
.
mEditSubAction
aCancel
aHandled
aInfo
.
inString
aInfo
.
outString
aInfo
.
maxLength
)
;
case
EditSubAction
:
:
eInsertHTMLSource
:
return
WillLoadHTML
(
)
;
case
EditSubAction
:
:
eInsertParagraphSeparator
:
UndefineCaretBidiLevel
(
)
;
return
WillInsertBreak
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eDeleteSelectedContent
:
return
WillDeleteSelection
(
aInfo
.
collapsedAction
aInfo
.
stripWrappers
aCancel
aHandled
)
;
case
EditSubAction
:
:
eCreateOrChangeList
:
return
WillMakeList
(
aInfo
.
blockType
aInfo
.
entireList
aInfo
.
bulletType
aCancel
aHandled
)
;
case
EditSubAction
:
:
eIndent
:
return
WillIndent
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eOutdent
:
return
WillOutdent
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eSetPositionToAbsolute
:
return
WillAbsolutePosition
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eSetPositionToStatic
:
return
WillRemoveAbsolutePosition
(
aCancel
aHandled
)
;
case
EditSubAction
:
:
eSetOrClearAlignment
:
return
WillAlign
(
*
aInfo
.
alignType
aCancel
aHandled
)
;
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
return
WillMakeBasicBlock
(
*
aInfo
.
blockType
aCancel
aHandled
)
;
case
EditSubAction
:
:
eRemoveList
:
{
nsresult
rv
=
WillRemoveList
(
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
case
EditSubAction
:
:
eCreateOrChangeDefinitionList
:
return
WillMakeDefListItem
(
aInfo
.
blockType
aInfo
.
entireList
aCancel
aHandled
)
;
case
EditSubAction
:
:
eInsertElement
:
{
nsresult
rv
=
WillInsert
(
aCancel
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
return
NS_OK
;
}
case
EditSubAction
:
:
eDecreaseZIndex
:
return
WillRelativeChangeZIndex
(
-
1
aCancel
aHandled
)
;
case
EditSubAction
:
:
eIncreaseZIndex
:
return
WillRelativeChangeZIndex
(
1
aCancel
aHandled
)
;
default
:
return
TextEditRules
:
:
WillDoAction
(
&
SelectionRef
(
)
aInfo
aCancel
aHandled
)
;
}
}
nsresult
HTMLEditRules
:
:
DidDoAction
(
Selection
*
aSelection
EditSubActionInfo
&
aInfo
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
aSelection
)
;
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
return
NS_OK
;
case
EditSubAction
:
:
eDeleteSelectedContent
:
return
DidDeleteSelection
(
)
;
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
return
DidMakeBasicBlock
(
)
;
case
EditSubAction
:
:
eSetPositionToAbsolute
:
{
nsresult
rv
=
DidMakeBasicBlock
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
DidAbsolutePosition
(
)
;
}
default
:
return
TextEditRules
:
:
DidDoAction
(
aSelection
aInfo
aResult
)
;
}
}
bool
HTMLEditRules
:
:
DocumentIsEmpty
(
)
{
return
!
!
mBogusNode
;
}
nsresult
HTMLEditRules
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aOL
=
false
;
*
aUL
=
false
;
*
aDL
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
curNode
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
dom
:
:
Element
*
parent
=
curNode
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
}
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
*
aDL
=
true
;
}
else
{
bNonList
=
true
;
}
}
if
(
(
*
aUL
+
*
aOL
+
*
aDL
+
bNonList
)
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aLI
=
false
;
*
aDT
=
false
;
*
aDD
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
node
:
arrayOfNodes
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
node
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
*
aLI
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
bool
bDT
bDD
;
GetDefinitionListItemTypes
(
node
-
>
AsElement
(
)
&
bDT
&
bDD
)
;
*
aDT
|
=
bDT
;
*
aDD
|
=
bDD
;
}
else
{
bNonList
=
true
;
}
}
if
(
*
aDT
+
*
aDD
+
bNonList
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
MOZ_ASSERT
(
aMixed
&
&
aAlign
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
*
aMixed
=
false
;
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
if
(
NS_WARN_IF
(
!
HTMLEditorRef
(
)
.
GetRoot
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
Element
>
root
=
*
HTMLEditorRef
(
)
.
GetRoot
(
)
;
int32_t
rootOffset
=
root
-
>
GetParentNode
(
)
?
root
-
>
GetParentNode
(
)
-
>
ComputeIndexOf
(
root
)
:
-
1
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
atStartOfSelection
.
GetContainerAsText
(
)
)
{
nodeToExamine
=
atStartOfSelection
.
GetContainer
(
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
static_cast
<
uint32_t
>
(
rootOffset
)
)
{
nodeToExamine
=
HTMLEditorRef
(
)
.
GetNextEditableNode
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditSubAction
:
:
eSetOrClearAlignment
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eSetOrClearAlignment
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nodeToExamine
=
arrayOfNodes
.
SafeElementAt
(
0
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
blockParent
=
HTMLEditorRef
(
)
.
GetBlock
(
*
nodeToExamine
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
blockParent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetCSSEquivalentToHTMLInlineStyleSet
(
blockParent
nullptr
nsGkAtoms
:
:
align
value
CSSEditUtils
:
:
eComputed
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
bool
isFirstNodeToExamine
=
true
;
for
(
;
nodeToExamine
;
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
)
{
if
(
!
isFirstNodeToExamine
&
&
nodeToExamine
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
nodeToExamine
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
textAlign
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
}
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
nodeToExamine
)
)
{
nsAutoString
typeAttrVal
;
nodeToExamine
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
typeAttrVal
)
;
ToLowerCase
(
typeAttrVal
)
;
if
(
!
typeAttrVal
.
IsEmpty
(
)
)
{
if
(
typeAttrVal
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
}
else
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
}
return
NS_OK
;
}
}
isFirstNodeToExamine
=
false
;
}
return
NS_OK
;
}
static
nsAtom
&
MarginPropertyAtomForIndent
(
nsINode
&
aNode
)
{
nsAutoString
direction
;
CSSEditUtils
:
:
GetComputedProperty
(
aNode
*
nsGkAtoms
:
:
direction
direction
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditRules
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
*
aMixed
=
true
;
outFormat
.
Truncate
(
0
)
;
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
bool
bMixed
=
false
;
nsAutoString
formatStr
(
NS_LITERAL_STRING
(
"
x
"
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetParagraphFormatNodes
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
curNode
=
arrayOfNodes
[
i
]
;
nsAutoString
format
;
if
(
IsBlockNode
(
curNode
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
rv
=
AppendInnerFormatNodes
(
arrayOfNodes
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
arrayOfNodes
.
AppendElement
(
*
selectionStartPoint
.
GetContainer
(
)
)
;
}
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
GetFormatString
(
curNode
format
)
;
}
else
if
(
IsBlockNode
(
curNode
)
)
{
continue
;
}
else
{
nsINode
*
node
=
curNode
-
>
GetParentNode
(
)
;
while
(
node
)
{
if
(
node
=
=
rootElement
)
{
format
.
Truncate
(
0
)
;
break
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
)
{
GetFormatString
(
node
format
)
;
break
;
}
node
=
node
-
>
GetParentNode
(
)
;
}
}
if
(
formatStr
.
EqualsLiteral
(
"
x
"
)
)
{
formatStr
=
format
;
}
else
if
(
format
!
=
formatStr
)
{
bMixed
=
true
;
break
;
}
}
*
aMixed
=
bMixed
;
outFormat
=
formatStr
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
IsBlockNode
(
*
child
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
child
)
;
if
(
isBlock
&
&
!
isFormat
)
{
AppendInnerFormatNodes
(
aArray
child
)
;
}
else
if
(
isFormat
)
{
aArray
.
AppendElement
(
*
child
)
;
}
else
if
(
!
foundInline
)
{
foundInline
=
true
;
aArray
.
AppendElement
(
*
child
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetFormatString
(
nsINode
*
aNode
nsAString
&
outFormat
)
{
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
aNode
)
)
{
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
outFormat
)
;
}
else
{
outFormat
.
Truncate
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillInsert
(
bool
*
aCancel
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
TextEditRules
:
:
WillInsert
(
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
priorNode
&
&
TextEditUtils
:
:
IsMozBR
(
priorNode
)
)
{
RefPtr
<
Element
>
block1
=
HTMLEditorRef
(
)
.
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
block2
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
priorNode
)
;
if
(
block1
&
&
block1
=
=
block2
)
{
EditorRawDOMPoint
point
(
priorNode
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
if
(
mDidDeleteSelection
&
&
(
mTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
mTopLevelEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
mTopLevelEditSubAction
=
=
EditSubAction
:
:
eDeleteSelectedContent
)
)
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
!
IsStyleCachePreservingSubAction
(
mTopLevelEditSubAction
)
)
{
ClearCachedStyles
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillInsertText
(
EditSubAction
aEditSubAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
CreateStyleForInsertText
(
*
doc
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
EditorBase
:
:
IsTextNode
(
pointToInsert
.
GetContainer
(
)
)
&
&
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
int32_t
IMESelectionOffset
=
HTMLEditorRef
(
)
.
GetIMESelectionStartOffsetIn
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
IMESelectionOffset
>
=
0
)
{
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
IMESelectionOffset
)
;
}
if
(
inString
-
>
IsEmpty
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
InsertTextWithTransaction
(
*
doc
*
inString
EditorRawDOMPoint
(
pointToInsert
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToInsert
)
;
rv
=
wsObj
.
InsertText
(
*
doc
*
inString
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
bool
isPRE
=
EditorBase
:
:
IsPreformatted
(
pointToInsert
.
GetContainer
(
)
)
;
AutoLockListener
lockit
(
&
mListenerEnabled
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
nsAutoString
tString
(
*
inString
)
;
const
char16_t
*
unicodeBuf
=
tString
.
get
(
)
;
int32_t
pos
=
0
;
NS_NAMED_LITERAL_STRING
(
newlineStr
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
pointToInsert
)
;
if
(
isPRE
|
|
IsPlaintextEditor
(
)
)
{
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pos
+
+
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
HTMLEditorRef
(
)
.
InsertTextWithTransaction
(
*
doc
subStr
EditorRawDOMPoint
(
currentPoint
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
else
{
NS_NAMED_LITERAL_STRING
(
tabStr
"
\
t
"
)
;
NS_NAMED_LITERAL_STRING
(
spacesStr
"
"
)
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
currentPoint
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
rv
=
wsObj
.
InsertText
(
*
doc
spacesStr
currentPoint
&
pointAfterInsertedSpaces
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
pos
+
+
;
currentPoint
=
pointAfterInsertedSpaces
;
pointToInsert
=
pointAfterInsertedSpaces
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
newBRElement
=
wsObj
.
InsertBreak
(
SelectionRef
(
)
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pos
+
+
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
newBRElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
new
<
br
>
node
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
wsObj
.
InsertText
(
*
doc
subStr
currentPoint
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
}
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
if
(
currentPoint
.
IsSet
(
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
currentPoint
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
at
current
point
"
)
;
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
pointToInsert
.
GetContainer
(
)
)
;
}
if
(
currentPoint
.
IsSet
(
)
)
{
rv
=
mDocChangeRange
-
>
SetStartAndEnd
(
pointToInsert
currentPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
mDocChangeRange
-
>
CollapseTo
(
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillLoadHTML
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
mBogusNode
)
{
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
mBogusNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
bogus
node
"
)
;
mBogusNode
=
nullptr
;
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
CanContainParagraph
(
Element
&
aElement
)
const
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditRules
:
:
WillInsertBreak
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
if
(
IsMailEditor
(
)
)
{
nsresult
rv
=
SplitMailCites
(
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aHandled
)
{
return
NS_OK
;
}
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
atStartOfSelection
.
GetContainer
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
host
)
;
ParagraphSeparator
separator
=
HTMLEditorRef
(
)
.
GetDefaultParagraphSeparator
(
)
;
bool
insertBRElement
;
if
(
!
blockParent
)
{
insertBRElement
=
true
;
}
else
if
(
host
=
=
blockParent
)
{
insertBRElement
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
CanContainParagraph
(
*
host
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
blockParent
)
)
{
insertBRElement
=
false
;
}
else
{
insertBRElement
=
true
;
for
(
Element
*
blockAncestor
=
blockParent
;
blockAncestor
&
&
insertBRElement
;
blockAncestor
=
HTMLEditor
:
:
GetBlockNodeParent
(
blockAncestor
host
)
)
{
insertBRElement
=
!
CanContainParagraph
(
*
blockAncestor
)
;
}
}
if
(
insertBRElement
)
{
nsresult
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
host
=
=
blockParent
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
MakeBasicBlock
(
ParagraphSeparatorElement
(
separator
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditRules
:
:
MakeBasicBlock
(
)
failed
"
)
;
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
host
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
blockParent
=
=
host
)
)
{
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
mNewBlock
=
blockParent
;
}
if
(
IsEmptyBlockElement
(
*
blockParent
IgnoreSingleBR
:
:
eNo
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditorRawDOMPoint
endOfBlockParent
;
endOfBlockParent
.
SetToEndOf
(
blockParent
)
;
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
endOfBlockParent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsCOMPtr
<
Element
>
listItem
=
IsInListItem
(
blockParent
)
;
if
(
listItem
&
&
listItem
!
=
host
)
{
nsresult
rv
=
ReturnInListItem
(
*
listItem
*
atStartOfSelection
.
GetContainer
(
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
break
into
list
item
"
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
blockParent
)
)
{
nsresult
rv
=
ReturnInHeader
(
*
blockParent
*
atStartOfSelection
.
GetContainer
(
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
handle
insertParagraph
in
the
heading
element
"
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditActionResult
result
=
ReturnInParagraph
(
*
blockParent
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
*
aHandled
=
result
.
Handled
(
)
;
*
aCancel
=
result
.
Canceled
(
)
;
if
(
result
.
Handled
(
)
)
{
lockOffset
.
Cancel
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
*
aCancel
"
ReturnInParagraph
canceled
this
edit
action
"
"
WillInsertBreak
(
)
needs
to
handle
such
case
"
)
;
}
MOZ_ASSERT
(
!
*
aHandled
"
Reached
last
resort
of
WillInsertBreak
(
)
"
"
after
the
edit
action
is
handled
"
)
;
rv
=
InsertBRElement
(
atStartOfSelection
)
;
*
aHandled
=
true
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
brElementIsAfterBlock
=
false
;
bool
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsPlaintextEditor
(
)
)
{
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
aPointToBreak
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToBreak
)
;
int32_t
visOffset
=
0
;
WSType
wsType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
PriorVisibleNode
(
pointToBreak
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsAfterBlock
=
true
;
}
wsObj
.
NextVisibleNode
(
pointToBreak
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsBeforeBlock
=
true
;
}
nsCOMPtr
<
nsINode
>
linkDOMNode
;
if
(
HTMLEditorRef
(
)
.
IsInLink
(
pointToBreak
.
GetContainer
(
)
address_of
(
linkDOMNode
)
)
)
{
nsCOMPtr
<
Element
>
linkNode
=
do_QueryInterface
(
linkDOMNode
)
;
if
(
NS_WARN_IF
(
!
linkNode
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitLinkNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitLinkNodeResult
.
Failed
(
)
)
)
{
return
splitLinkNodeResult
.
Rv
(
)
;
}
pointToBreak
=
splitLinkNodeResult
.
SplitPoint
(
)
;
}
brElement
=
wsObj
.
InsertBreak
(
SelectionRef
(
)
pointToBreak
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
NS_WARN_IF
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
EditorRawDOMPoint
point
(
brElement
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditorDOMPoint
afterBRElement
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
afterBRElement
)
;
nsCOMPtr
<
nsINode
>
maybeSecondBRNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
afterBRElement
address_of
(
maybeSecondBRNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
EditorDOMPoint
atSecondBRElement
(
maybeSecondBRNode
)
;
if
(
brElement
-
>
GetNextSibling
(
)
!
=
maybeSecondBRNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
maybeSecondBRNode
-
>
AsContent
(
)
afterBRElement
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
!
(
nextSiblingOfBRElement
&
&
IsBlockNode
(
*
nextSiblingOfBRElement
)
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
or
unset
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
afterBRElement
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SplitMailCites
(
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
pointToSplit
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
citeNode
=
GetTopEnclosingMailCite
(
*
pointToSplit
.
GetContainer
(
)
)
;
if
(
!
citeNode
)
{
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToSplit
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
pointToSplit
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
&
&
visNode
!
=
citeNode
&
&
citeNode
-
>
Contains
(
visNode
)
)
{
pointToSplit
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplit
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
visible
node
"
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitCiteNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
citeNode
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitCiteNodeResult
.
Failed
(
)
)
)
{
return
splitCiteNodeResult
.
Rv
(
)
;
}
pointToSplit
.
Clear
(
)
;
nsIContent
*
previousNodeOfSplitPoint
=
splitCiteNodeResult
.
GetPreviousNode
(
)
;
if
(
previousNodeOfSplitPoint
&
&
previousNodeOfSplitPoint
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
nsCOMPtr
<
nsINode
>
lastChild
=
previousNodeOfSplitPoint
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorRawDOMPoint
endOfPreviousNodeOfSplitPoint
;
endOfPreviousNodeOfSplitPoint
.
SetToEndOf
(
previousNodeOfSplitPoint
)
;
RefPtr
<
Element
>
invisibleBrElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
endOfPreviousNodeOfSplitPoint
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
invisibleBrElement
"
Failed
to
create
an
invisible
<
br
>
element
"
)
;
}
}
EditorRawDOMPoint
pointToInsertBrNode
(
splitCiteNodeResult
.
SplitPoint
(
)
)
;
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pointToInsertBrNode
.
Clear
(
)
;
EditorDOMPoint
atBrNode
(
brElement
)
;
Unused
<
<
atBrNode
.
Offset
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
IsInlineNode
(
*
citeNode
)
)
{
EditorRawDOMPoint
pointToCreateNewBrNode
(
atBrNode
.
GetContainer
(
)
atBrNode
.
Offset
(
)
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToCreateNewBrNode
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
pointToCreateNewBrNode
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
)
{
EditorRawDOMPoint
pointAfterNewBrNode
(
pointToCreateNewBrNode
)
;
DebugOnly
<
bool
>
advanced
=
pointAfterNewBrNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
<
br
>
node
"
)
;
WSRunObject
wsObjAfterBR
(
&
HTMLEditorRef
(
)
pointAfterNewBrNode
)
;
wsObjAfterBR
.
NextVisibleNode
(
pointAfterNewBrNode
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
thisBlock
)
{
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToCreateNewBrNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pointToCreateNewBrNode
.
Clear
(
)
;
pointAfterNewBrNode
.
Clear
(
)
;
}
}
}
bool
bEmptyCite
=
false
;
if
(
previousNodeOfSplitPoint
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
previousNodeOfSplitPoint
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
previousNodeOfSplitPoint
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
citeNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
citeNode
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillDeleteSelection
(
nsIEditor
:
:
EDirection
aAction
nsIEditor
:
:
EStripWrappers
aStripWrappers
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
mDidDeleteSelection
=
true
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
RefPtr
<
Element
>
cell
;
nsresult
rv
=
HTMLEditorRef
(
)
.
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteTableCellContents
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
*
aHandled
=
true
;
return
rv
;
}
cell
=
nullptr
;
bool
bCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
bool
join
=
false
;
bool
origCollapsed
=
bCollapsed
;
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
startOffset
=
firstRange
-
>
StartOffset
(
)
;
if
(
bCollapsed
)
{
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
MaybeDeleteTopMostEmptyAncestor
(
*
startNode
*
host
aAction
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aHandled
)
{
return
NS_OK
;
}
rv
=
CheckBidiLevelForDeletion
(
EditorRawDOMPoint
(
startNode
startOffset
)
aAction
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aCancel
)
{
return
NS_OK
;
}
rv
=
HTMLEditorRef
(
)
.
ExtendSelectionForDelete
(
&
SelectionRef
(
)
&
aAction
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aAction
=
=
nsIEditor
:
:
eNone
)
{
return
NS_OK
;
}
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startOffset
=
firstRange
-
>
StartOffset
(
)
;
bCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
}
if
(
bCollapsed
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
startNode
startOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
;
WSType
wsType
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
else
{
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
if
(
!
visNode
)
{
*
aCancel
=
true
;
return
rv
;
}
if
(
wsType
=
=
WSType
:
:
normalWS
)
{
*
aHandled
=
true
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
rv
=
wsObj
.
DeleteWSForward
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
wsObj
.
DeleteWSBackward
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
text
)
{
OwningNonNull
<
Text
>
nodeAsText
=
*
visNode
-
>
GetAsText
(
)
;
int32_t
so
=
visOffset
;
int32_t
eo
=
visOffset
+
1
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
!
so
)
{
return
NS_ERROR_UNEXPECTED
;
}
so
-
-
;
eo
-
-
;
if
(
so
>
0
)
{
const
nsTextFragment
*
text
=
nodeAsText
-
>
GetText
(
)
;
if
(
NS_IS_LOW_SURROGATE
(
text
-
>
CharAt
(
so
)
)
&
&
NS_IS_HIGH_SURROGATE
(
text
-
>
CharAt
(
so
-
1
)
)
)
{
so
-
-
;
}
}
}
else
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
range
-
>
GetStartContainer
(
)
=
=
visNode
"
selection
start
not
in
visNode
"
)
;
NS_ASSERTION
(
range
-
>
GetEndContainer
(
)
=
=
visNode
"
selection
end
not
in
visNode
"
)
;
so
=
range
-
>
StartOffset
(
)
;
eo
=
range
-
>
EndOffset
(
)
;
}
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
&
HTMLEditorRef
(
)
address_of
(
visNode
)
&
so
address_of
(
visNode
)
&
eo
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
nodeAsText
std
:
:
min
(
so
eo
)
DeprecatedAbs
(
eo
-
so
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
DeleteNodeIfCollapsedText
(
nodeAsText
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
collapsed
text
"
)
;
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mDidRangedDelete
=
true
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
visNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
visNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
WillDeleteSelection
(
aAction
aStripWrappers
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
&
&
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
bool
moveOnly
=
true
;
selNode
=
visNode
-
>
GetParentNode
(
)
;
selOffset
=
selNode
?
selNode
-
>
ComputeIndexOf
(
visNode
)
:
-
1
;
ErrorResult
err
;
bool
interLineIsRight
=
SelectionRef
(
)
.
GetInterlinePosition
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
if
(
startNode
=
=
selNode
&
&
startOffset
-
1
=
=
selOffset
&
&
!
interLineIsRight
)
{
moveOnly
=
false
;
}
if
(
moveOnly
)
{
+
+
selOffset
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
selNode
selOffset
)
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
after
the
<
hr
>
"
)
;
(
ErrorResult
&
)
ignoredError
=
NS_OK
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
mDidExplicitlySetInterline
=
true
;
*
aHandled
=
true
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
if
(
otherWSType
=
=
WSType
:
:
br
)
{
if
(
NS_WARN_IF
(
!
otherNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
otherContent
=
otherNode
-
>
AsContent
(
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
&
HTMLEditorRef
(
)
otherContent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
otherContent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
}
if
(
NS_WARN_IF
(
!
visNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
&
HTMLEditorRef
(
)
visNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
visNode
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
visNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
nsCOMPtr
<
nsINode
>
stepbrother
;
if
(
sibling
)
{
stepbrother
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
sibling
)
;
}
if
(
startNode
=
=
stepbrother
&
&
startNode
-
>
GetAsText
(
)
&
&
sibling
-
>
GetAsText
(
)
)
{
EditorDOMPoint
pt
;
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
sibling
*
startNode
-
>
AsContent
(
)
&
pt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
otherBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
bool
bDeletedBR
=
false
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
else
{
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
nsCOMPtr
<
nsIContent
>
leafNode
;
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
leafNode
=
HTMLEditorRef
(
)
.
GetLastEditableLeaf
(
*
visNode
)
;
leftNode
=
leafNode
;
rightNode
=
startNode
;
}
else
{
leafNode
=
HTMLEditorRef
(
)
.
GetFirstEditableLeaf
(
*
visNode
)
;
leftNode
=
startNode
;
rightNode
=
leafNode
;
}
if
(
otherNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
otherNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
bDeletedBR
=
true
;
}
if
(
leftNode
&
&
rightNode
&
&
InDifferentTableElements
(
leftNode
rightNode
)
)
{
return
NS_OK
;
}
if
(
bDeletedBR
)
{
if
(
NS_WARN_IF
(
!
leafNode
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
newSel
=
GetGoodSelPointForNode
(
*
leafNode
aAction
)
;
if
(
NS_WARN_IF
(
!
newSel
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
newSel
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
edge
of
the
block
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
leftNode
)
|
|
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
|
=
ret
.
Handled
(
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
if
(
!
*
aHandled
&
&
!
*
aCancel
&
&
leafNode
!
=
startNode
)
{
int32_t
offset
=
aAction
=
=
nsIEditor
:
:
ePrevious
?
static_cast
<
int32_t
>
(
leafNode
-
>
Length
(
)
)
:
0
;
rv
=
SelectionRef
(
)
.
Collapse
(
leafNode
offset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
at
the
leaf
node
"
)
;
rv
=
WillDeleteSelection
(
aAction
aStripWrappers
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
SelectionRef
(
)
.
Collapse
(
selPointNode
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
selection
at
deleted
point
"
)
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
leftNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
*
visNode
)
;
rightNode
=
startNode
;
}
else
{
rightNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
*
visNode
)
;
leftNode
=
startNode
;
}
if
(
!
leftNode
|
|
!
rightNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
if
(
InDifferentTableElements
(
leftNode
rightNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
=
true
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
rv
=
SelectionRef
(
)
.
Collapse
(
selPointNode
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
return
NS_OK
;
}
}
rv
=
ExpandSelectionForDeletion
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mDidRangedDelete
=
true
;
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startOffset
=
firstRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
firstRange
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
endOffset
=
firstRange
-
>
EndOffset
(
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
&
HTMLEditorRef
(
)
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
{
AutoTrackDOMPoint
startTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
*
aHandled
=
true
;
if
(
endNode
=
=
startNode
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsCOMPtr
<
Element
>
startCiteNode
=
GetTopEnclosingMailCite
(
*
startNode
)
;
nsCOMPtr
<
Element
>
endCiteNode
=
GetTopEnclosingMailCite
(
*
endNode
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aAction
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aAction
=
nsIEditor
:
:
ePrevious
;
}
nsCOMPtr
<
Element
>
leftParent
=
HTMLEditor
:
:
GetBlock
(
*
startNode
)
;
nsCOMPtr
<
Element
>
rightParent
=
HTMLEditor
:
:
GetBlock
(
*
endNode
)
;
if
(
leftParent
&
&
leftParent
=
=
rightParent
)
{
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
else
{
if
(
NS_WARN_IF
(
!
leftParent
)
|
|
NS_WARN_IF
(
!
rightParent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
leftBlockParent
=
leftParent
-
>
GetParentNode
(
)
;
nsCOMPtr
<
nsINode
>
rightBlockParent
=
rightParent
-
>
GetParentNode
(
)
;
if
(
leftBlockParent
=
=
rightBlockParent
&
&
HTMLEditorRef
(
)
.
AreNodesSameType
(
leftParent
rightParent
)
&
&
(
leftParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
leftParent
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
leftParent
)
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EditorDOMPoint
pt
=
HTMLEditorRef
(
)
.
JoinNodesDeepWithTransaction
(
*
leftParent
*
rightParent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
join
=
true
;
AutoRangeArray
arrayOfRanges
(
&
SelectionRef
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
.
AppendList
(
functor
arrayOfNodes
)
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
j
=
0
;
j
<
listCount
;
j
+
+
)
{
OwningNonNull
<
nsINode
>
node
=
arrayOfNodes
[
0
]
;
nsresult
rv
=
DeleteElementsExceptTableRelatedElements
(
node
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
elements
except
table
related
elements
"
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
if
(
join
&
&
origCollapsed
)
{
if
(
!
node
-
>
IsContent
(
)
)
{
join
=
false
;
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
Text
*
text
=
content
-
>
GetAsText
(
)
)
{
join
=
!
HTMLEditorRef
(
)
.
IsInVisibleTextFrames
(
*
text
)
;
}
else
{
join
=
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
node
)
;
}
}
}
}
if
(
startNode
-
>
GetAsText
(
)
&
&
startNode
-
>
Length
(
)
>
static_cast
<
uint32_t
>
(
startOffset
)
)
{
OwningNonNull
<
CharacterData
>
dataNode
=
*
static_cast
<
CharacterData
*
>
(
startNode
.
get
(
)
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
dataNode
startOffset
startNode
-
>
Length
(
)
-
startOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
endNode
-
>
GetAsText
(
)
&
&
endOffset
)
{
OwningNonNull
<
CharacterData
>
dataNode
=
*
static_cast
<
CharacterData
*
>
(
endNode
.
get
(
)
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
dataNode
0
endOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
join
)
{
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftParent
*
rightParent
)
;
MOZ_ASSERT
(
*
aHandled
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
}
}
}
{
AutoTrackDOMPoint
startTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
nsresult
rv
=
DeleteNodeIfCollapsedText
(
*
startNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
delete
start
node
even
though
it
'
s
collapsed
text
"
)
;
rv
=
DeleteNodeIfCollapsedText
(
*
endNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
delete
end
node
even
though
it
'
s
collapsed
text
"
)
;
}
if
(
aAction
=
=
(
join
?
nsIEditor
:
:
eNext
:
nsIEditor
:
:
ePrevious
)
)
{
rv
=
SelectionRef
(
)
.
Collapse
(
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
SelectionRef
(
)
.
Collapse
(
startNode
startOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DeleteNodeIfCollapsedText
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
Text
*
text
=
aNode
.
GetAsText
(
)
;
if
(
!
text
)
{
return
NS_OK
;
}
if
(
HTMLEditorRef
(
)
.
IsVisibleTextNode
(
*
text
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsBlockNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
atStartOfSelection
)
;
if
(
(
(
wsObj
.
mStartReason
&
WSType
:
:
block
)
|
|
(
wsObj
.
mStartReason
&
WSType
:
:
br
)
)
&
&
(
wsObj
.
mEndReason
&
WSType
:
:
block
)
)
{
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atStartOfSelection
nsIEditor
:
:
ePrevious
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetGoodSelPointForNode
(
nsINode
&
aNode
nsIEditor
:
:
EDirection
aAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAction
=
=
nsIEditor
:
:
eNext
|
|
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
;
bool
isPreviousAction
=
(
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
)
;
if
(
aNode
.
GetAsText
(
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
&
aNode
)
|
|
NS_WARN_IF
(
!
aNode
.
GetParentNode
(
)
)
)
{
return
EditorDOMPoint
(
&
aNode
isPreviousAction
?
aNode
.
Length
(
)
:
0
)
;
}
if
(
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
ret
(
&
aNode
)
;
if
(
(
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
&
aNode
)
)
&
&
isPreviousAction
)
{
ret
.
AdvanceOffset
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
TryToJoinBlocksWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
RefPtr
<
Element
>
leftBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
aLeftNode
)
;
RefPtr
<
Element
>
rightBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
aRightNode
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
|
|
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
if
(
NS_WARN_IF
(
leftBlock
=
=
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
leftBlock
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
rightBlock
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
leftBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
leftBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
leftBlock
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
rightBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
rightBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
rightBlock
)
;
if
(
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
leftBlock
=
=
rightBlock
)
{
return
EditActionIgnored
(
)
;
}
if
(
HTMLEditUtils
:
:
IsList
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
&
&
rightBlock
-
>
GetParentNode
(
)
=
=
leftBlock
)
{
return
EditActionHandled
(
)
;
}
bool
mergeLists
=
false
;
nsAtom
*
existingList
=
nsGkAtoms
:
:
_empty
;
EditorDOMPoint
atChildInBlock
;
nsCOMPtr
<
Element
>
leftList
rightList
;
if
(
HTMLEditUtils
:
:
IsListItem
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
)
{
leftList
=
leftBlock
-
>
GetParentElement
(
)
;
rightList
=
rightBlock
-
>
GetParentElement
(
)
;
if
(
leftList
&
&
rightList
&
&
leftList
!
=
rightList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftList
*
rightBlock
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightList
*
leftBlock
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
leftBlock
=
leftList
;
rightBlock
=
rightList
;
mergeLists
=
true
;
existingList
=
leftList
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
EditorDOMPoint
atRightBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
leftBlock
*
rightBlock
&
atRightBlockChild
)
)
{
DebugOnly
<
bool
>
advanced
=
atRightBlockChild
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
child
of
rightBlock
"
"
leftBlock
is
a
descendant
of
the
child
"
)
;
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBlockEnd
leftBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
atRightBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kAfterBlock
atRightBlockChild
.
GetContainer
(
)
atRightBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
rightBlock
=
=
atRightBlockChild
.
GetContainer
(
)
)
;
if
(
atRightBlockChild
.
GetContainerAsElement
(
)
)
{
rightBlock
=
atRightBlockChild
.
GetContainerAsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
atRightBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
rightBlock
=
atRightBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
;
}
}
RefPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
NS_WARN_IF
(
mergeLists
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
EditActionResult
retMoveBlock
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
atRightBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
retMoveBlock
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
ret
;
}
NS_WARNING_ASSERTION
(
retMoveBlock
.
Succeeded
(
)
"
Failed
to
move
contents
of
the
right
block
to
the
left
block
"
)
;
if
(
retMoveBlock
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
atRightBlockChild
.
Clear
(
)
;
}
if
(
brNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
ret
.
MarkAsHandled
(
)
;
}
else
{
NS_WARNING
(
"
Failed
to
remove
the
<
br
>
element
"
)
;
}
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
EditorDOMPoint
leftBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rightBlock
*
leftBlock
&
leftBlockChild
)
)
{
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBlockStart
rightBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
leftBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBeforeBlock
leftBlock
leftBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
leftBlock
=
=
leftBlockChild
.
GetContainer
(
)
)
;
if
(
leftBlockChild
.
GetContainerAsElement
(
)
)
{
leftBlock
=
leftBlockChild
.
GetContainerAsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
leftBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
leftBlock
=
leftBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
;
}
}
RefPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
beforeBlock
leftBlockChild
.
Offset
(
)
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
)
{
int32_t
offset
=
leftBlockChild
.
Offset
(
)
;
EditActionResult
retMoveContents
=
MoveContents
(
*
rightList
*
leftList
&
offset
)
;
if
(
NS_WARN_IF
(
retMoveContents
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
ret
;
}
NS_WARNING_ASSERTION
(
retMoveContents
.
Succeeded
(
)
"
Failed
to
move
contents
from
the
right
list
to
the
left
list
"
)
;
if
(
retMoveContents
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
leftBlockChild
.
Clear
(
)
;
}
else
{
EditorDOMPoint
previousContent
;
if
(
&
aLeftNode
=
=
leftBlock
)
{
previousContent
=
leftBlockChild
;
}
else
{
previousContent
.
Set
(
&
aLeftNode
)
;
previousContent
.
AdvanceOffset
(
)
;
}
RefPtr
<
Element
>
editorRoot
=
HTMLEditorRef
(
)
.
GetEditorRoot
(
)
;
if
(
!
editorRoot
|
|
&
aLeftNode
!
=
editorRoot
)
{
nsCOMPtr
<
nsIContent
>
splittedPreviousContent
;
nsCOMPtr
<
nsINode
>
previousContentParent
=
previousContent
.
GetContainer
(
)
;
int32_t
previousContentOffset
=
previousContent
.
Offset
(
)
;
rv
=
HTMLEditorRef
(
)
.
SplitStyleAbovePoint
(
address_of
(
previousContentParent
)
&
previousContentOffset
nullptr
nullptr
nullptr
getter_AddRefs
(
splittedPreviousContent
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
splittedPreviousContent
)
{
previousContent
.
Set
(
splittedPreviousContent
)
;
}
else
{
previousContent
.
Set
(
previousContentParent
previousContentOffset
)
;
}
}
if
(
NS_WARN_IF
(
!
previousContent
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
ret
|
=
MoveBlock
(
*
previousContent
.
GetContainerAsElement
(
)
*
rightBlock
previousContent
.
Offset
(
)
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
ret
.
MarkAsHandled
(
)
;
}
else
{
NS_WARNING
(
"
Failed
to
remove
the
<
br
>
element
"
)
;
}
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
leftBlockChild
.
IsSet
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToJoinBlocks
(
&
HTMLEditorRef
(
)
leftBlock
rightBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
nsCOMPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
|
|
leftBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
rightBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
EditorDOMPoint
pt
;
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
leftBlock
*
rightBlock
&
pt
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
pt
.
IsSet
(
)
&
&
mergeLists
)
{
CreateElementResult
convertListTypeResult
=
ConvertListType
(
*
rightBlock
*
existingList
*
nsGkAtoms
:
:
li
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
}
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveBlock
(
Element
&
aLeftBlock
Element
&
aRightBlock
int32_t
aLeftOffset
int32_t
aRightOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromPoint
(
EditorDOMPoint
(
&
aRightBlock
aRightOffset
)
EditSubAction
:
:
eCreateOrChangeList
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
EditActionResult
ret
(
NS_OK
)
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
IsBlockNode
(
arrayOfNodes
[
i
]
)
)
{
ret
|
=
MoveContents
(
*
arrayOfNodes
[
i
]
-
>
AsElement
(
)
aLeftBlock
&
aLeftOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
arrayOfNodes
[
i
]
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
a
block
node
"
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveNodeSmart
(
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
aLeftBlock
&
aLeftOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
ret
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
move
current
node
to
the
left
block
"
)
;
}
}
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveNodeSmart
(
nsIContent
&
aNode
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
HTMLEditorRef
(
)
.
CanContain
(
aDestElement
aNode
)
)
{
if
(
*
aInOutDestOffset
=
=
-
1
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
aNode
aDestElement
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
else
{
EditorRawDOMPoint
pointToInsert
(
&
aDestElement
*
aInOutDestOffset
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
if
(
*
aInOutDestOffset
!
=
-
1
)
{
(
*
aInOutDestOffset
)
+
+
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
ret
(
NS_OK
)
;
if
(
aNode
.
IsElement
(
)
)
{
ret
=
MoveContents
(
*
aNode
.
AsElement
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
return
ret
.
MarkAsHandled
(
)
;
}
EditActionResult
HTMLEditRules
:
:
MoveContents
(
Element
&
aElement
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
&
aDestElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_ILLEGAL_VALUE
)
;
}
EditActionResult
ret
(
NS_OK
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
ret
|
=
MoveNodeSmart
(
*
aElement
.
GetFirstChild
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
DeleteElementsExceptTableRelatedElements
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsTableElementButNotTable
(
&
aNode
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
*
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteElementsExceptTableRelatedElements
(
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidDeleteSelection
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
citeNode
=
GetTopEnclosingMailCite
(
*
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
citeNode
)
{
bool
isEmpty
=
true
seenBR
=
false
;
HTMLEditorRef
(
)
.
IsEmptyNodeImpl
(
citeNode
&
isEmpty
true
true
false
&
seenBR
)
;
if
(
isEmpty
)
{
EditorDOMPoint
atCiteNode
(
citeNode
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atCiteNode
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
atCiteNode
.
IsSet
(
)
&
&
seenBR
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atCiteNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
brElement
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
new
<
br
>
element
"
)
;
}
}
}
nsresult
rv
=
TextEditRules
:
:
DidDeleteSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeList
(
const
nsAString
*
aListType
bool
aEntireList
const
nsAString
*
aBulletType
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aItemType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aListType
)
|
|
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
OwningNonNull
<
nsAtom
>
listType
=
NS_Atomize
(
*
aListType
)
;
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
RefPtr
<
nsAtom
>
itemType
;
if
(
aItemType
)
{
itemType
=
NS_Atomize
(
*
aItemType
)
;
}
else
if
(
listType
=
=
nsGkAtoms
:
:
dl
)
{
itemType
=
nsGkAtoms
:
:
dd
;
}
else
{
itemType
=
nsGkAtoms
:
:
li
;
}
*
aHandled
=
true
;
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MakeList
(
listType
aEntireList
aBulletType
aCancel
*
itemType
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeList
(
nsAtom
&
aListType
bool
aEntireList
const
nsAString
*
aBulletType
bool
*
aCancel
nsAtom
&
aItemType
)
{
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
aEntireList
?
EntireList
:
:
yes
:
EntireList
:
:
no
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
bOnlyBreaks
=
true
;
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
TextEditUtils
:
:
IsBreak
(
curNode
)
&
&
!
IsEmptyInline
(
curNode
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
node
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
aListType
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
SplitNodeResult
splitAtSelectionStartResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListType
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitAtSelectionStartResult
.
Failed
(
)
)
)
{
return
splitAtSelectionStartResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aListType
splitAtSelectionStartResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theList
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atFirstListItemToInsertBefore
(
theList
0
)
;
RefPtr
<
Element
>
theListItem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aItemType
atFirstListItemToInsertBefore
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theListItem
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
theListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
LookInsideDivBQandList
(
arrayOfNodes
)
;
uint32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
RefPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
RefPtr
<
Element
>
newBlock
;
if
(
NS_WARN_IF
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
if
(
curList
&
&
InDifferentTableElements
(
curList
curNode
)
)
{
curList
=
nullptr
;
}
if
(
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
&
&
(
TextEditUtils
:
:
IsBreak
(
curNode
)
|
|
IsEmptyInline
(
curNode
)
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
TextEditUtils
:
:
IsBreak
(
curNode
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CreateElementResult
convertListTypeResult
=
ConvertListType
(
*
curNode
-
>
AsElement
(
)
aListType
aItemType
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
convertListTypeResult
.
Rv
(
)
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
convertListTypeResult
.
GetNewNode
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
newBlock
=
convertListTypeResult
.
forget
(
)
;
}
else
{
CreateElementResult
convertListTypeResult
=
ConvertListType
(
*
curNode
-
>
AsElement
(
)
aListType
aItemType
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
convertListTypeResult
.
Rv
(
)
;
}
curList
=
convertListTypeResult
.
forget
(
)
;
}
prevListItem
=
nullptr
;
continue
;
}
EditorRawDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCurNode
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
!
atCurNode
.
IsContainerHTMLElement
(
&
aListType
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atCurNode
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atCurNode
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
newBlock
=
newLeftNode
?
newLeftNode
-
>
AsElement
(
)
:
nullptr
;
EditorRawDOMPoint
atParentOfCurNode
(
atCurNode
.
GetContainer
(
)
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aListType
atParentOfCurNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
curNode
-
>
IsHTMLElement
(
&
aItemType
)
)
{
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
aItemType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
else
{
if
(
!
curList
)
{
curList
=
atCurNode
.
GetContainerAsElement
(
)
;
}
else
if
(
atCurNode
.
GetContainer
(
)
!
=
curList
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
!
curNode
-
>
IsHTMLElement
(
&
aItemType
)
)
{
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
aItemType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
nsCOMPtr
<
Element
>
curElement
=
do_QueryInterface
(
curNode
)
;
if
(
NS_WARN_IF
(
!
curElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aBulletType
&
&
!
aBulletType
-
>
IsEmpty
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
SetAttributeWithTransaction
(
*
curElement
*
nsGkAtoms
:
:
type
*
aBulletType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
*
curElement
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
int32_t
j
=
i
+
1
;
GetInnerContent
(
*
curNode
arrayOfNodes
&
j
)
;
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
listCount
=
arrayOfNodes
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
SplitNodeResult
splitCurNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListType
atCurNode
)
;
if
(
NS_WARN_IF
(
splitCurNodeResult
.
Failed
(
)
)
)
{
return
splitCurNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aListType
splitCurNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
prevListItem
=
nullptr
;
atCurNode
.
Clear
(
)
;
}
nsCOMPtr
<
Element
>
listItem
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
IsInlineNode
(
curNode
)
&
&
prevListItem
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
prevListItem
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
listItem
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
aItemType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
listItem
=
HTMLEditorRef
(
)
.
InsertContainerWithTransaction
(
*
curNode
aItemType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
IsInlineNode
(
curNode
)
)
{
prevListItem
=
listItem
;
}
else
{
prevListItem
=
nullptr
;
}
}
}
else
{
listItem
=
curNode
-
>
AsElement
(
)
;
}
if
(
listItem
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRemoveList
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditSubAction
:
:
eCreateOrChangeList
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
arrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
arrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
bool
bOutOfList
;
do
{
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
&
bOutOfList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
while
(
!
bOutOfList
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
RemoveListStructure
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeDefListItem
(
const
nsAString
*
aItemType
bool
aEntireList
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_NAMED_LITERAL_STRING
(
listType
"
dl
"
)
;
nsresult
rv
=
WillMakeList
(
&
listType
.
AsString
(
)
aEntireList
nullptr
aCancel
aHandled
aItemType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeBasicBlock
(
const
nsAString
&
aBlockType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
OwningNonNull
<
nsAtom
>
blockType
=
NS_Atomize
(
aBlockType
)
;
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
rv
=
MakeBasicBlock
(
blockType
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeBasicBlock
(
nsAtom
&
blockType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eCreateOrRemoveBlock
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
firstRange
-
>
StartRef
(
)
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
RefPtr
<
Element
>
curBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
*
pointToInsertBlock
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
pointToInsertBlock
)
;
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
curBlock
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
EditorRawDOMPoint
pointToInsertBrNode
(
splitNodeResult
.
SplitPoint
(
)
)
;
brContent
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brContent
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atBrNode
(
brContent
)
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
pointToInsertBlock
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElement
(
brNode
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
blockType
pointToInsertBlock
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
blockType
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
block
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
block
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
selectionRestorer
.
Abort
(
)
;
rv
=
SelectionRef
(
)
.
Collapse
(
block
0
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
rv
=
MakeBlockquote
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
rv
=
RemoveBlockStyle
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
ApplyBlockStyle
(
arrayOfNodes
blockType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidMakeBasicBlock
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InsertMozBRIfNeeded
(
*
atStartOfSelection
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
nsresult
rv
=
WillCSSIndent
(
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
WillHTMLIndent
(
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillCSSIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
IndentAroundSelectionWithCSS
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
IndentAroundSelectionWithCSS
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsRange
>
>
arrayOfRanges
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsCOMPtr
<
Element
>
liNode
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
selectionStartPoint
.
GetContainer
(
)
)
;
if
(
block
&
&
HTMLEditUtils
:
:
IsListItem
(
block
)
)
{
liNode
=
block
;
}
}
if
(
liNode
)
{
arrayOfNodes
.
AppendElement
(
*
liNode
)
;
}
else
{
nsresult
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eIndent
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
nsresult
rv
=
IncreaseMarginToIndent
(
*
theBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
increase
indentation
"
)
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfTheBlock
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curQuote
;
nsCOMPtr
<
nsIContent
>
sibling
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
curNode
-
>
AsContent
(
)
EditorRawDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
sibling
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
IsBlockNode
(
*
curNode
)
)
{
nsresult
rv
=
IncreaseMarginToIndent
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
inrease
indentation
"
)
;
curQuote
=
nullptr
;
continue
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
IncreaseMarginToIndent
(
*
curQuote
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
increase
indentation
"
)
;
mNewBlock
=
curQuote
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillHTMLIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
IndentAroundSelectionWithHTML
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
IndentAroundSelectionWithHTML
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditSubAction
:
:
eIndent
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eIndent
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfTheBlock
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
nsCOMPtr
<
Element
>
curList
curQuote
indentedLI
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
curNode
-
>
AsContent
(
)
EditorRawDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
sibling
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curQuote
=
nullptr
;
continue
;
}
RefPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
listItem
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
curQuote
&
&
InDifferentTableElements
(
curQuote
curNode
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curQuote
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillOutdent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentAroundSelection
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
.
Rv
(
)
;
}
if
(
!
outdentResult
.
GetLeftContent
(
)
&
&
!
outdentResult
.
GetRightContent
(
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
outdentResult
.
GetLeftContent
(
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_OK
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetLeftContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetLeftContent
(
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
outdentResult
.
GetLeftContent
(
)
)
;
afterRememberedLeftBQ
.
AdvanceOffset
(
)
;
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterRememberedLeftBQ
error
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
the
left
<
blockquote
>
"
)
;
}
}
if
(
outdentResult
.
GetRightContent
(
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetRightContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetRightContent
(
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
outdentResult
.
GetRightContent
(
)
)
;
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atRememberedRightBQ
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
the
right
<
blockquote
>
"
)
;
}
}
return
NS_OK
;
}
SplitRangeOffFromNodeResult
HTMLEditRules
:
:
OutdentAroundSelection
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eOutdent
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
leftContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
middleContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
rightContentOfLastOutdented
;
nsCOMPtr
<
Element
>
curBlockQuote
;
nsCOMPtr
<
nsIContent
>
firstBQChild
lastBQChild
;
bool
curBlockQuoteIsIndentedWithCSS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
{
continue
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
curBlockQuote
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
&
&
IsBlockNode
(
curNode
)
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curNode
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
curNode
marginProperty
value
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
)
{
nsresult
rv
=
DecreaseMarginToOutdent
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
decrease
indentation
"
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
curBlockQuote
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
curBlockQuote
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlockQuote
)
)
{
lastBQChild
=
curNode
;
continue
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
OwningNonNull
<
nsINode
>
n
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
false
;
while
(
!
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
n
)
&
&
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
n
)
)
)
{
if
(
!
n
-
>
GetParentNode
(
)
)
{
break
;
}
n
=
*
n
-
>
GetParentNode
(
)
;
if
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
break
;
}
if
(
!
useCSS
)
{
continue
;
}
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curNode
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
n
marginProperty
value
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
&
&
!
(
HTMLEditUtils
:
:
IsList
(
curParent
)
&
&
HTMLEditUtils
:
:
IsList
(
curNode
)
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
true
;
break
;
}
}
if
(
curBlockQuote
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetLastChild
(
)
;
while
(
child
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
rv
=
PopListItem
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
EditorRawDOMPoint
afterCurrentList
(
curParent
offset
+
1
)
;
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
child
afterCurrentList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
child
=
curNode
-
>
GetLastChild
(
)
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
)
{
nsCOMPtr
<
Element
>
element
;
if
(
curNode
-
>
GetAsText
(
)
)
{
element
=
curNode
-
>
GetParentElement
(
)
;
}
else
if
(
curNode
-
>
IsElement
(
)
)
{
element
=
curNode
-
>
AsElement
(
)
;
}
if
(
element
)
{
nsresult
rv
=
DecreaseMarginToOutdent
(
*
element
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
decrease
indentation
"
)
;
}
continue
;
}
}
if
(
!
curBlockQuote
)
{
return
SplitRangeOffFromNodeResult
(
leftContentOfLastOutdented
middleContentOfLastOutdented
rightContentOfLastOutdented
)
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
return
outdentResult
;
}
SplitRangeOffFromNodeResult
HTMLEditRules
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
Element
&
aBlockElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfRange
aEndOfRange
)
;
if
(
NS_WARN_IF
(
splitResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
splitResult
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
Failed
to
split
the
range
off
from
the
block
element
"
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
aBlockElement
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditRules
:
:
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartOfMiddleElement
aBlockElement
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aEndOfMiddleElement
aBlockElement
)
)
;
SplitNodeResult
splitAtStartResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aBlockElement
EditorRawDOMPoint
(
&
aStartOfMiddleElement
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtStartResult
.
Succeeded
(
)
"
Failed
to
split
aBlockElement
at
start
"
)
;
EditorRawDOMPoint
atAfterEnd
(
&
aEndOfMiddleElement
)
;
DebugOnly
<
bool
>
advanced
=
atAfterEnd
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
end
node
"
)
;
SplitNodeResult
splitAtEndResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aBlockElement
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtEndResult
.
Succeeded
(
)
"
Failed
to
split
aBlockElement
at
after
end
"
)
;
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
splitAtEndResult
)
;
}
SplitRangeOffFromNodeResult
HTMLEditRules
:
:
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOfOutdent
bool
aIsBlockIndentedWithCSS
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfOutdent
aEndOfOutdent
)
;
if
(
NS_WARN_IF
(
splitResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
splitResult
.
GetMiddleContentAsElement
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aIsBlockIndentedWithCSS
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
if
(
splitResult
.
GetMiddleContentAsElement
(
)
)
{
nsresult
rv
=
DecreaseMarginToOutdent
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
splitResult
;
}
return
splitResult
;
}
CreateElementResult
HTMLEditRules
:
:
ConvertListType
(
Element
&
aListElement
nsAtom
&
aNewListTag
nsAtom
&
aNewListItemTag
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
child
=
aListElement
.
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
)
{
Element
*
element
=
child
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
&
aNewListItemTag
)
)
{
child
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
element
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
child
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
&
aNewListTag
)
)
{
CreateElementResult
convertListTypeResult
=
ConvertListType
(
*
child
-
>
AsElement
(
)
aNewListTag
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
convertListTypeResult
;
}
child
=
convertListTypeResult
.
forget
(
)
;
}
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
aListElement
.
IsHTMLElement
(
&
aNewListTag
)
)
{
return
CreateElementResult
(
&
aListElement
)
;
}
RefPtr
<
Element
>
listElement
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
aListElement
aNewListTag
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
listElement
!
=
nullptr
"
Failed
to
create
list
element
"
)
;
return
CreateElementResult
(
listElement
.
forget
(
)
)
;
}
nsresult
HTMLEditRules
:
:
CreateStyleForInsertText
(
nsIDocument
&
aDocument
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditorRef
(
)
.
mTypeInState
)
;
bool
weDidSomething
=
false
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
node
=
firstRange
-
>
GetStartContainer
(
)
;
int32_t
offset
=
firstRange
-
>
StartOffset
(
)
;
RefPtr
<
Element
>
rootElement
=
aDocument
.
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
PropItem
>
item
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeClearProperty
(
)
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
while
(
item
&
&
node
!
=
rootElement
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
ClearStyle
(
address_of
(
node
)
&
offset
item
-
>
tag
item
-
>
attr
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeClearProperty
(
)
;
weDidSomething
=
true
;
}
}
int32_t
relFontSize
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeSetProperty
(
)
;
if
(
item
|
|
relFontSize
)
{
if
(
RefPtr
<
Text
>
text
=
node
-
>
GetAsText
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
text
EditorRawDOMPoint
(
text
offset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitTextNodeResult
.
Failed
(
)
)
)
{
return
splitTextNodeResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPoint
(
splitTextNodeResult
.
SplitPoint
(
)
)
;
node
=
splitPoint
.
GetContainer
(
)
;
offset
=
splitPoint
.
Offset
(
)
;
}
if
(
!
HTMLEditorRef
(
)
.
IsContainer
(
node
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Text
>
newNode
=
EditorBase
:
:
CreateTextNode
(
aDocument
EmptyString
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
InsertNodeWithTransaction
(
*
newNode
EditorRawDOMPoint
(
node
offset
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
node
=
newNode
;
offset
=
0
;
weDidSomething
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
rv
=
HTMLEditorRef
(
)
.
RelativeFontChangeOnTextNode
(
dir
newNode
0
-
1
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
while
(
item
)
{
rv
=
HTMLEditorRef
(
)
.
SetInlinePropertyOnNode
(
*
node
-
>
AsContent
(
)
*
item
-
>
tag
item
-
>
attr
item
-
>
value
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
!
weDidSomething
)
{
return
NS_OK
;
}
nsresult
rv
=
SelectionRef
(
)
.
Collapse
(
node
offset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsBlockNode
(
aElement
)
)
)
{
return
false
;
}
bool
isEmpty
=
true
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aElement
&
isEmpty
aIgnoreSingleBR
=
=
IgnoreSingleBR
:
:
eYes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
isEmpty
;
}
nsresult
HTMLEditRules
:
:
WillAlign
(
const
nsAString
&
aAlignType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
rv
=
AlignContentsAtSelection
(
aAlignType
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
{
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
nsresult
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eSetOrClearAlignment
nodeArray
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
emptyDiv
=
nodeArray
.
IsEmpty
(
)
;
if
(
nodeArray
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsINode
>
node
=
nodeArray
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
node
)
)
{
rv
=
AlignBlock
(
*
node
-
>
AsElement
(
)
aAlignType
ResetAlignOf
:
:
OnlyDescendants
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
atStartOfSelection
.
Container
(
)
;
emptyDiv
=
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
emptyDiv
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
splitNodeResult
.
SplitPoint
(
)
)
;
EditorDOMPoint
pointToInsertDiv
(
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
brContent
&
&
TextEditUtils
:
:
IsBreak
(
brContent
)
)
{
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
pointToInsertDiv
.
GetChild
(
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
pointToInsertDiv
.
GetChild
(
)
)
;
}
if
(
sibling
&
&
!
IsBlockNode
(
*
sibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertDiv
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
RefPtr
<
Element
>
div
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
pointToInsertDiv
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
div
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
div
;
rv
=
AlignBlock
(
*
div
aAlignType
ResetAlignOf
:
:
OnlyDescendants
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CreateElementResult
createMozBrResult
=
CreateMozBR
(
EditorRawDOMPoint
(
div
0
)
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
EditorRawDOMPoint
atStartOfDiv
(
div
0
)
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfDiv
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsTArray
<
bool
>
transitionList
;
MakeTransitionList
(
nodeArray
transitionList
)
;
nsCOMPtr
<
Element
>
curDiv
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
nodeArray
)
{
+
+
indexOfTransitionList
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
curNode
)
)
{
rv
=
AlignBlock
(
*
curNode
-
>
AsElement
(
)
aAlignType
ResetAlignOf
:
:
ElementAndDescendants
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curDiv
=
nullptr
;
continue
;
}
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
bool
isEmptyTextNode
=
false
;
if
(
curNode
-
>
GetAsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsTableElement
(
atCurNode
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atCurNode
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
|
|
(
NS_SUCCEEDED
(
HTMLEditorRef
(
)
.
IsEmptyNode
(
curNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atCurNode
)
;
rv
=
RemoveAlignment
(
*
curNode
aAlignType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
useCSS
)
{
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
curNode
-
>
AsElement
(
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
curDiv
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
rv
=
AlignInnerBlocks
(
*
curNode
aAlignType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curDiv
=
nullptr
;
continue
;
}
}
if
(
!
curDiv
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curDiv
;
rv
=
AlignBlock
(
*
curDiv
aAlignType
ResetAlignOf
:
:
OnlyDescendants
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
align
the
<
div
>
"
)
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curDiv
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignInnerBlocks
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
TableCellAndListItemFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
nsresult
rv
=
AlignBlockContents
(
*
node
aAlignType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignBlockContents
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstChild
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
;
if
(
!
firstChild
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastChild
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
if
(
firstChild
=
=
lastChild
&
&
firstChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
firstChild
-
>
AsElement
(
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
EditorRawDOMPoint
atStartOfNode
(
&
aNode
0
)
;
RefPtr
<
Element
>
divElem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
divElem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
divElem
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
lastChild
&
&
(
lastChild
!
=
divElem
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
lastChild
EditorRawDOMPoint
(
divElem
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
lastChild
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MaybeDeleteTopMostEmptyAncestor
(
nsINode
&
aStartNode
Element
&
aEditingHostElement
nsIEditor
:
:
EDirection
aAction
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsInlineNode
(
aEditingHostElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
aStartNode
)
;
RefPtr
<
Element
>
emptyBlock
;
if
(
block
&
&
block
!
=
&
aEditingHostElement
)
{
bool
isEmptyNode
=
false
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
isEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
block
&
&
isEmptyNode
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
block
)
&
&
block
!
=
&
aEditingHostElement
)
{
emptyBlock
=
block
;
block
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
emptyBlock
)
;
if
(
block
)
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
isEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
if
(
!
emptyBlock
|
|
!
emptyBlock
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
blockParent
=
emptyBlock
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
emptyBlock
)
)
{
if
(
HTMLEditorRef
(
)
.
IsFirstEditableChild
(
emptyBlock
)
)
{
EditorDOMPoint
atBlockParent
(
blockParent
)
;
if
(
NS_WARN_IF
(
!
atBlockParent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
atBlockParent
.
GetContainer
(
)
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atBlockParent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
brElement
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
}
else
{
switch
(
aAction
)
{
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
bool
advancedFromEmptyBlock
=
afterEmptyBlock
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advancedFromEmptyBlock
"
Failed
to
set
selection
to
the
after
the
empty
block
"
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextNode
(
afterEmptyBlock
)
;
if
(
nextNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nextNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
break
;
}
if
(
NS_WARN_IF
(
!
advancedFromEmptyBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
break
;
}
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
atEmptyBlock
(
emptyBlock
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableNode
(
atEmptyBlock
)
;
if
(
priorNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
priorNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
break
;
}
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
break
;
}
case
nsIEditor
:
:
eNone
:
break
;
default
:
MOZ_CRASH
(
"
CheckForEmptyBlock
doesn
'
t
support
this
action
yet
"
)
;
}
}
*
aHandled
=
true
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
Element
*
HTMLEditRules
:
:
CheckForInvisibleBR
(
Element
&
aBlock
BRLocation
aWhere
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
testNode
;
int32_t
testOffset
=
0
;
if
(
aWhere
=
=
BRLocation
:
:
blockEnd
)
{
nsCOMPtr
<
nsIContent
>
rightmostNode
=
HTMLEditorRef
(
)
.
GetRightmostChild
(
&
aBlock
true
)
;
if
(
!
rightmostNode
)
{
return
nullptr
;
}
testNode
=
rightmostNode
-
>
GetParentNode
(
)
;
testOffset
=
testNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
testNode
-
>
ComputeIndexOf
(
rightmostNode
)
+
1
=
=
testOffset
)
;
}
else
if
(
aOffset
)
{
testNode
=
&
aBlock
;
testOffset
=
aOffset
;
}
else
{
return
nullptr
;
}
WSRunObject
wsTester
(
&
HTMLEditorRef
(
)
testNode
testOffset
)
;
if
(
WSType
:
:
br
=
=
wsTester
.
mStartReason
)
{
return
wsTester
.
mStartReasonNode
-
>
AsElement
(
)
;
}
return
nullptr
;
}
void
HTMLEditRules
:
:
GetInnerContent
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
int32_t
*
aIndex
Lists
aLists
Tables
aTables
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aIndex
)
;
for
(
nsCOMPtr
<
nsIContent
>
node
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
if
(
(
aLists
=
=
Lists
:
:
yes
&
&
(
HTMLEditUtils
:
:
IsList
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
)
)
|
|
(
aTables
=
=
Tables
:
:
yes
&
&
HTMLEditUtils
:
:
IsTableElement
(
node
)
)
)
{
GetInnerContent
(
*
node
aOutArrayOfNodes
aIndex
aLists
aTables
)
;
}
else
{
aOutArrayOfNodes
.
InsertElementAt
(
*
aIndex
*
node
)
;
(
*
aIndex
)
+
+
;
}
}
}
nsresult
HTMLEditRules
:
:
ExpandSelectionForDeletion
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
selStartNode
=
firstRange
-
>
GetStartContainer
(
)
;
int32_t
selStartOffset
=
firstRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
selEndNode
=
firstRange
-
>
GetEndContainer
(
)
;
int32_t
selEndOffset
=
firstRange
-
>
EndOffset
(
)
;
RefPtr
<
Element
>
selCommon
=
HTMLEditor
:
:
GetBlock
(
*
firstRange
-
>
GetCommonAncestor
(
)
)
;
if
(
NS_WARN_IF
(
!
selCommon
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
firstBRParent
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
visOffset
=
0
firstBROffset
=
0
;
WSType
wsType
;
RefPtr
<
Element
>
root
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selStartNode
!
=
selCommon
&
&
selStartNode
!
=
root
)
{
while
(
true
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
selStartNode
selStartOffset
)
;
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
selStartNode
selStartOffset
)
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
thisBlock
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mStartReasonNode
)
|
|
selCommon
=
=
wsObj
.
mStartReasonNode
|
|
root
=
=
wsObj
.
mStartReasonNode
)
{
break
;
}
selStartNode
=
wsObj
.
mStartReasonNode
-
>
GetParentNode
(
)
;
selStartOffset
=
selStartNode
?
selStartNode
-
>
ComputeIndexOf
(
wsObj
.
mStartReasonNode
)
:
-
1
;
}
}
if
(
selEndNode
!
=
selCommon
&
&
selEndNode
!
=
root
)
{
for
(
;
;
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
selEndNode
selEndOffset
)
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
selEndNode
selEndOffset
)
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
break
;
}
if
(
!
firstBRParent
)
{
firstBRParent
=
selEndNode
;
firstBROffset
=
selEndOffset
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
selEndNode
?
selEndNode
-
>
ComputeIndexOf
(
wsObj
.
mEndReasonNode
)
+
1
:
0
;
}
else
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mEndReasonNode
)
|
|
selCommon
=
=
wsObj
.
mEndReasonNode
|
|
root
=
=
wsObj
.
mEndReasonNode
)
{
break
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
1
+
selEndNode
-
>
ComputeIndexOf
(
wsObj
.
mEndReasonNode
)
;
}
else
{
break
;
}
}
}
DebugOnly
<
nsresult
>
rv
=
SelectionRef
(
)
.
Collapse
(
selStartNode
selStartOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
bool
doEndExpansion
=
true
;
if
(
firstBRParent
)
{
nsCOMPtr
<
Element
>
brBlock
=
HTMLEditor
:
:
GetBlock
(
*
firstBRParent
)
;
bool
nodeBefore
=
false
nodeAfter
=
false
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
selStartNode
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
selStartNode
selStartOffset
selEndNode
selEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
brBlock
)
{
nsRange
:
:
CompareNodeToRange
(
brBlock
range
&
nodeBefore
&
nodeAfter
)
;
}
if
(
nodeBefore
|
|
nodeAfter
)
{
doEndExpansion
=
false
;
}
}
if
(
doEndExpansion
)
{
nsresult
rv
=
SelectionRef
(
)
.
Extend
(
selEndNode
selEndOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
SelectionRef
(
)
.
Extend
(
firstBRParent
firstBROffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
NormalizeSelection
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
startChild
=
range
-
>
GetChildAtStartOffset
(
)
;
nsIContent
*
endChild
=
range
-
>
GetChildAtEndOffset
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
newStartNode
=
startNode
;
uint32_t
newStartOffset
=
startOffset
;
nsCOMPtr
<
nsINode
>
newEndNode
=
endNode
;
uint32_t
newEndOffset
=
endOffset
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
offset
=
-
1
;
WSType
wsType
;
WSRunObject
wsEndObj
(
&
HTMLEditorRef
(
)
endNode
static_cast
<
int32_t
>
(
endOffset
)
)
;
wsEndObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
endNode
endOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetRightmostChild
(
wsEndObj
.
mStartReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
thisBlock
)
{
EditorRawDOMPoint
atEnd
(
endNode
endChild
endOffset
)
;
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atEnd
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
wsEndObj
.
mStartReasonNode
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
;
}
}
WSRunObject
wsStartObj
(
&
HTMLEditorRef
(
)
startNode
static_cast
<
int32_t
>
(
startOffset
)
)
;
wsStartObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetLeftmostChild
(
wsStartObj
.
mEndReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
thisBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
EditorRawDOMPoint
(
startNode
startChild
startOffset
)
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
wsStartObj
.
mEndReasonNode
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
int16_t
comp
;
comp
=
nsContentUtils
:
:
ComparePoints
(
startNode
startOffset
newEndNode
newEndOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartNode
newStartOffset
endNode
endOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rv
=
SelectionRef
(
)
.
Collapse
(
newStartNode
newStartOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
rv
=
SelectionRef
(
)
.
Extend
(
newEndNode
newEndOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
extend
selection
"
)
;
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetPromotedPoint
(
RulesEndpoint
aWhere
nsINode
&
aNode
int32_t
aOffset
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertParagraphSeparator
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteText
)
{
bool
isSpace
isNBSP
;
nsCOMPtr
<
nsIContent
>
content
=
aNode
.
IsContent
(
)
?
aNode
.
AsContent
(
)
:
nullptr
;
nsCOMPtr
<
nsIContent
>
temp
;
int32_t
newOffset
=
aOffset
;
while
(
content
)
{
int32_t
offset
;
if
(
aWhere
=
=
kStart
)
{
HTMLEditorRef
(
)
.
IsPrevCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
else
{
HTMLEditorRef
(
)
.
IsNextCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
if
(
isSpace
|
|
isNBSP
)
{
content
=
temp
;
newOffset
=
offset
;
}
else
{
break
;
}
}
return
EditorDOMPoint
(
content
newOffset
)
;
}
EditorDOMPoint
point
(
&
aNode
aOffset
)
;
if
(
aWhere
=
=
kStart
)
{
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
while
(
priorNode
&
&
priorNode
-
>
GetParentNode
(
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
priorNode
)
&
&
!
IsBlockNode
(
*
priorNode
)
)
{
point
.
Set
(
priorNode
)
;
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
while
(
!
nearNode
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
}
return
point
;
}
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
text
node
"
)
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
while
(
nextNode
&
&
!
IsBlockNode
(
*
nextNode
)
&
&
nextNode
-
>
GetParentNode
(
)
)
{
point
.
Set
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
if
(
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nextNode
)
)
{
break
;
}
if
(
EditorBase
:
:
IsPreformatted
(
nextNode
)
&
&
EditorBase
:
:
IsTextNode
(
nextNode
)
)
{
nsAutoString
tempString
;
nextNode
-
>
GetAsText
(
)
-
>
GetData
(
tempString
)
;
int32_t
newlinePos
=
tempString
.
FindChar
(
nsCRT
:
:
LF
)
;
if
(
newlinePos
>
=
0
)
{
if
(
static_cast
<
uint32_t
>
(
newlinePos
)
+
1
=
=
tempString
.
Length
(
)
)
{
break
;
}
return
EditorDOMPoint
(
nextNode
newlinePos
+
1
)
;
}
}
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
while
(
!
nearNode
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
&
&
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
}
return
point
;
}
void
HTMLEditRules
:
:
GetPromotedRanges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
outArrayOfRanges
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
selectionRange
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
opRange
=
selectionRange
-
>
CloneRange
(
)
;
PromoteRange
(
*
opRange
aEditSubAction
)
;
outArrayOfRanges
.
AppendElement
(
opRange
)
;
}
}
void
HTMLEditRules
:
:
PromoteRange
(
nsRange
&
aRange
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRange
.
IsInSelection
(
)
)
;
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
if
(
startNode
=
=
endNode
&
&
startOffset
=
=
endOffset
)
{
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
startNode
)
;
if
(
block
)
{
bool
bIsEmptyNode
=
false
;
nsIContent
*
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
host
block
)
)
{
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
}
if
(
bIsEmptyNode
)
{
startNode
=
block
;
endNode
=
block
;
startOffset
=
0
;
endOffset
=
block
-
>
Length
(
)
;
}
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertParagraphSeparator
|
|
aEditSubAction
=
=
EditSubAction
:
:
eDeleteText
)
{
if
(
!
startNode
-
>
IsContent
(
)
|
|
!
endNode
-
>
IsContent
(
)
)
{
return
;
}
}
EditorDOMPoint
startPoint
=
GetPromotedPoint
(
kStart
*
startNode
startOffset
aEditSubAction
)
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
;
}
EditorDOMPoint
endPoint
=
GetPromotedPoint
(
kEnd
*
endNode
endOffset
aEditSubAction
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
aRange
.
SetStartAndEnd
(
startPoint
endPoint
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
class
UniqueFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
UniqueFunctor
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
)
:
mArray
(
aArray
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
!
mArray
.
Contains
(
aNode
)
;
}
private
:
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
mArray
;
}
;
nsresult
HTMLEditRules
:
:
GetNodesForOperation
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
IsInTextNode
(
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atContainerOfSplitNode
(
atEnd
.
GetContainer
(
)
)
;
MOZ_ASSERT
(
!
range
-
>
IsInSelection
(
)
)
;
range
-
>
SetEnd
(
atContainerOfSplitNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
}
}
}
}
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
aArrayOfRanges
[
0
]
)
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
RegisterRangeItem
(
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
nsresult
rv
=
BustUpInlinesAtRangeEndpoints
(
*
item
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
HTMLEditorRef
(
)
.
mRangeUpdater
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
}
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
iter
.
AppendList
(
TrivialFunctor
(
)
aOutArrayOfNodes
)
;
}
else
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodes
;
iter
.
AppendList
(
UniqueFunctor
(
aOutArrayOfNodes
)
nodes
)
;
aOutArrayOfNodes
.
AppendElements
(
nodes
)
;
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
Text
*
text
=
aOutArrayOfNodes
[
i
]
-
>
GetAsText
(
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsVisibleTextNode
(
*
text
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
}
}
else
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetPositionToAbsolute
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
!
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
Lists
:
:
no
Tables
:
:
no
)
;
}
}
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrChangeList
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetPositionToAbsolute
|
|
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
&
&
IsInlineNode
(
node
)
&
&
HTMLEditorRef
(
)
.
IsContainer
(
node
)
&
&
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfInlines
;
nsresult
rv
=
BustUpInlinesAtBRs
(
*
node
-
>
AsContent
(
)
arrayOfInlines
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
aOutArrayOfNodes
.
InsertElementsAt
(
i
arrayOfInlines
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
GetChildNodesForOperation
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
{
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
outArrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
nsresult
HTMLEditRules
:
:
GetListActionNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EntireList
aEntireList
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aEntireList
=
=
EntireList
:
:
yes
)
{
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
rangeIdx
)
;
for
(
nsCOMPtr
<
nsINode
>
parent
=
range
-
>
GetCommonAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
parent
)
;
break
;
}
}
}
if
(
!
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
}
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
HTMLEditorRef
(
)
)
;
nsresult
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eCreateOrChangeList
aOutArrayOfNodes
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
aOutArrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
testNode
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
testNode
aOutArrayOfNodes
&
j
Lists
:
:
no
)
;
}
}
LookInsideDivBQandList
(
aOutArrayOfNodes
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
LookInsideDivBQandList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aNodeArray
.
Length
(
)
!
=
1
)
{
return
;
}
OwningNonNull
<
nsINode
>
curNode
=
aNodeArray
[
0
]
;
while
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
uint32_t
numChildren
=
HTMLEditorRef
(
)
.
CountEditableChildren
(
curNode
)
;
if
(
numChildren
!
=
1
)
{
break
;
}
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetFirstChild
(
)
;
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
!
HTMLEditUtils
:
:
IsList
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
curNode
=
child
;
}
aNodeArray
.
RemoveElementAt
(
0
)
;
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
int32_t
j
=
0
;
GetInnerContent
(
*
curNode
aNodeArray
&
j
Lists
:
:
no
Tables
:
:
no
)
;
return
;
}
aNodeArray
.
AppendElement
(
*
curNode
)
;
}
void
HTMLEditRules
:
:
GetDefinitionListItemTypes
(
dom
:
:
Element
*
aElement
bool
*
aDT
bool
*
aDD
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
MOZ_ASSERT
(
aDT
)
;
MOZ_ASSERT
(
aDD
)
;
*
aDT
=
*
aDD
=
false
;
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
}
}
nsresult
HTMLEditRules
:
:
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
GetNodesFromSelection
(
EditSubAction
:
:
eCreateOrRemoveBlock
outArrayOfNodes
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
outArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
outArrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
testNode
)
|
|
HTMLEditUtils
:
:
IsList
(
testNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
testNode
)
)
{
int32_t
j
=
i
;
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
testNode
outArrayOfNodes
&
j
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtRangeEndpoints
(
RangeItem
&
aRangeItem
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
bool
isCollapsed
=
aRangeItem
.
mStartContainer
=
=
aRangeItem
.
mEndContainer
&
&
aRangeItem
.
mStartOffset
=
=
aRangeItem
.
mEndOffset
;
nsCOMPtr
<
nsIContent
>
endInline
=
GetHighestInlineParent
(
*
aRangeItem
.
mEndContainer
)
;
if
(
endInline
&
&
!
isCollapsed
)
{
SplitNodeResult
splitEndInlineResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
endInline
EditorRawDOMPoint
(
aRangeItem
.
mEndContainer
aRangeItem
.
mEndOffset
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitEndInlineResult
.
Failed
(
)
)
)
{
return
splitEndInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtEnd
(
splitEndInlineResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
splitPointAtEnd
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
aRangeItem
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
nsCOMPtr
<
nsIContent
>
startInline
=
GetHighestInlineParent
(
*
aRangeItem
.
mStartContainer
)
;
if
(
startInline
)
{
SplitNodeResult
splitStartInlineResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
startInline
EditorRawDOMPoint
(
aRangeItem
.
mStartContainer
aRangeItem
.
mStartOffset
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitStartInlineResult
.
Failed
(
)
)
)
{
return
splitStartInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtStart
(
splitStartInlineResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
splitPointAtStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
aRangeItem
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtBRs
(
nsIContent
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfBreaks
;
BRNodeFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
arrayOfBreaks
)
;
if
(
arrayOfBreaks
.
IsEmpty
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
aNode
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
&
aNode
;
for
(
OwningNonNull
<
nsINode
>
&
brNode
:
arrayOfBreaks
)
{
EditorRawDOMPoint
atBrNode
(
brNode
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
nextNode
atBrNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
splitNodeResult
.
GetPreviousNode
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
splitNodeResult
.
GetPreviousNode
(
)
)
;
}
EditorRawDOMPoint
atNextNode
(
splitNodeResult
.
GetNextNode
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
brNode
-
>
AsContent
(
)
atNextNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutArrayOfNodes
.
AppendElement
(
*
brNode
)
;
nextNode
=
splitNodeResult
.
GetNextNode
(
)
;
}
aOutArrayOfNodes
.
AppendElement
(
*
nextNode
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditRules
:
:
GetHighestInlineParent
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
aNode
.
IsContent
(
)
|
|
IsBlockNode
(
aNode
)
)
{
return
nullptr
;
}
Element
*
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
nullptr
;
}
if
(
&
aNode
=
=
host
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
aNode
*
host
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
for
(
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
parent
&
&
parent
!
=
host
&
&
IsInlineNode
(
*
parent
)
;
parent
=
parent
-
>
GetParent
(
)
)
{
content
=
parent
;
}
return
content
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromPoint
(
const
EditorDOMPoint
&
aPoint
EditSubAction
aEditSubAction
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aPoint
.
GetContainer
(
)
)
;
IgnoredErrorResult
ignoredError
;
range
-
>
SetStart
(
aPoint
ignoredError
)
;
MOZ_ASSERT
(
!
ignoredError
.
Failed
(
)
)
;
PromoteRange
(
*
range
aEditSubAction
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
arrayOfRanges
.
AppendElement
(
range
)
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aEditSubAction
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromSelection
(
EditSubAction
aEditSubAction
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
aEditSubAction
)
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aEditSubAction
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
MakeTransitionList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsCOMPtr
<
nsINode
>
prevParent
;
aTransitionArray
.
EnsureLengthAtLeast
(
aNodeArray
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNodeArray
.
Length
(
)
;
i
+
+
)
{
if
(
aNodeArray
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
)
{
aTransitionArray
[
i
]
=
true
;
}
else
{
aTransitionArray
[
i
]
=
false
;
}
prevParent
=
aNodeArray
[
i
]
-
>
GetParentNode
(
)
;
}
}
Element
*
HTMLEditRules
:
:
IsInListItem
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_ENSURE_TRUE
(
aNode
nullptr
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
)
{
return
aNode
-
>
AsElement
(
)
;
}
Element
*
parent
=
aNode
-
>
GetParentElement
(
)
;
while
(
parent
&
&
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
parent
)
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parent
)
)
{
return
parent
;
}
parent
=
parent
-
>
GetParentElement
(
)
;
}
return
nullptr
;
}
nsAtom
&
HTMLEditRules
:
:
DefaultParagraphSeparator
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
return
ParagraphSeparatorElement
(
HTMLEditorRef
(
)
.
GetDefaultParagraphSeparator
(
)
)
;
}
nsresult
HTMLEditRules
:
:
ReturnInHeader
(
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
headerParent
=
aHeader
.
GetParentNode
(
)
;
int32_t
offset
=
headerParent
?
headerParent
-
>
ComputeIndexOf
(
&
aHeader
)
:
-
1
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
node
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
node
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitHeaderResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aHeader
EditorRawDOMPoint
(
node
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitHeaderResult
.
Succeeded
(
)
"
Failed
to
split
aHeader
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aHeader
)
;
if
(
prevItem
)
{
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
prevItem
)
)
;
bool
isEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
CreateElementResult
createMozBrResult
=
CreateMozBR
(
EditorRawDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
}
}
if
(
IsEmptyBlockElement
(
aHeader
IgnoreSingleBR
:
:
eYes
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aHeader
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
aHeader
.
GetNextSibling
(
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
aHeader
.
GetNextSibling
(
)
)
;
}
if
(
!
sibling
|
|
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
ClearCachedStyles
(
)
;
HTMLEditorRef
(
)
.
mTypeInState
-
>
ClearAllProps
(
)
;
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
EditorRawDOMPoint
nextToHeader
(
headerParent
offset
+
1
)
;
RefPtr
<
Element
>
pNode
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
paraAtom
nextToHeader
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
EditorRawDOMPoint
afterSibling
(
sibling
)
;
if
(
NS_WARN_IF
(
!
afterSibling
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterSibling
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
else
{
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
&
aHeader
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
EditActionResult
HTMLEditRules
:
:
ReturnInParagraph
(
Element
&
aParentDivOrP
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
|
|
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
;
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
}
bool
doesCRCreateNewP
=
HTMLEditorRef
(
)
.
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brContent
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorRawDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brContent
=
nullptr
;
}
else
if
(
atStartOfSelection
.
IsInTextNode
(
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brContent
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
brContent
)
|
|
TextEditUtils
:
:
HasMozAttr
(
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
brContent
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brContent
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
brContent
)
|
|
TextEditUtils
:
:
HasMozAttr
(
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
brContent
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftDivOrP
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
pointToSplitParentDivOrP
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
pointToSplitParentDivOrP
.
SetToEndOf
(
newLeftDivOrP
)
;
}
pointToInsertBR
.
Set
(
pointToSplitParentDivOrP
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nearNode
;
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
nearNode
)
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
nearNode
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
brContent
=
nearNode
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
brContent
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBR
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
brContent
"
Failed
to
create
a
<
br
>
element
"
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
Set
(
brContent
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplitParentDivOrP
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
"
)
;
}
}
EditActionResult
result
(
SplitParagraph
(
aParentDivOrP
pointToSplitParentDivOrP
brContent
)
)
;
result
.
MarkAsHandled
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
return
result
;
}
template
<
typename
PT
typename
CT
>
nsresult
HTMLEditRules
:
:
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
selNode
=
aStartOfRightNode
.
GetContainer
(
)
;
int32_t
selOffset
=
aStartOfRightNode
.
Offset
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitDivOrPResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aParentDivOrP
EditorRawDOMPoint
(
selNode
selOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitDivOrPResult
.
Failed
(
)
)
)
{
return
splitDivOrPResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
!
splitDivOrPResult
.
DidSplit
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNextBRNode
&
&
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
aNextBRNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
aNextBRNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
aParentDivOrP
*
nsGkAtoms
:
:
id
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertBRIfNeeded
(
*
splitDivOrPResult
.
GetPreviousNode
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertBRIfNeeded
(
*
splitDivOrPResult
.
GetNextNode
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsIContent
*
child
=
HTMLEditorRef
(
)
.
GetLeftmostChild
(
&
aParentDivOrP
true
)
;
if
(
EditorBase
:
:
IsTextNode
(
child
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
child
)
)
{
EditorRawDOMPoint
atStartOfChild
(
child
0
)
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
atStartOfChild
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
end
of
the
child
"
)
;
}
else
{
EditorRawDOMPoint
atChild
(
child
)
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
atChild
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
child
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReturnInListItem
(
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
;
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
mReturnInEmptyLIKillsList
&
&
host
!
=
aListItem
.
GetParentElement
(
)
&
&
IsEmptyBlockElement
(
aListItem
IgnoreSingleBR
:
:
eYes
)
)
{
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsLastEditableChild
(
&
aListItem
)
)
{
EditorRawDOMPoint
atListItem
(
&
aListItem
)
;
ErrorResult
error
;
leftListNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorRawDOMPoint
atNextSiblingOfLeftList
(
leftListNode
)
;
DebugOnly
<
bool
>
advanced
=
atNextSiblingOfLeftList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
right
list
node
"
)
;
if
(
HTMLEditUtils
:
:
IsList
(
atNextSiblingOfLeftList
.
GetContainer
(
)
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aListItem
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
RefPtr
<
Element
>
pNode
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
paraAtom
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selNode
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
selNode
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitListItemResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aListItem
EditorRawDOMPoint
(
selNode
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitListItemResult
.
Succeeded
(
)
"
Failed
to
split
the
list
item
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aListItem
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsListItem
(
prevItem
)
)
{
bool
isEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
CreateElementResult
createMozBrResult
=
CreateMozBR
(
EditorRawDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aListItem
&
isEmptyNode
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
RefPtr
<
nsAtom
>
nodeAtom
=
aListItem
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
nodeAtom
=
=
nsGkAtoms
:
:
dd
|
|
nodeAtom
=
=
nsGkAtoms
:
:
dt
)
{
nsCOMPtr
<
nsINode
>
list
=
aListItem
.
GetParentNode
(
)
;
int32_t
itemOffset
=
list
?
list
-
>
ComputeIndexOf
(
&
aListItem
)
:
-
1
;
nsAtom
*
listAtom
=
nodeAtom
=
=
nsGkAtoms
:
:
dt
?
nsGkAtoms
:
:
dd
:
nsGkAtoms
:
:
dt
;
MOZ_DIAGNOSTIC_ASSERT
(
itemOffset
!
=
-
1
)
;
EditorRawDOMPoint
atNextListItem
(
list
aListItem
.
GetNextSibling
(
)
itemOffset
+
1
)
;
RefPtr
<
Element
>
newListItem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
listAtom
atNextListItem
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
newListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CopyLastEditableChildStylesWithTransaction
(
*
prevItem
-
>
AsElement
(
)
aListItem
address_of
(
brElement
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElement
)
{
EditorRawDOMPoint
atBrNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
else
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
&
aListItem
0
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
&
aListItem
0
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
EditorRawDOMPoint
atVisNode
(
visNode
)
;
if
(
NS_WARN_IF
(
!
atVisNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atVisNode
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
rv
=
SelectionRef
(
)
.
Collapse
(
visNode
visOffset
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeBlockquote
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
RefPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
NS_WARN_IF
(
!
curNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
MakeBlockquote
(
childArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
prevParent
)
{
if
(
prevParent
!
=
curNode
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsIContent
>
firstNode
lastNode
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
RemoveBlockStyle
(
childArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
IsInlineNode
(
curNode
)
)
{
if
(
curBlock
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlock
)
)
{
lastNode
=
curNode
-
>
AsContent
(
)
;
continue
;
}
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
curBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
curNode
)
;
if
(
!
curBlock
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
|
|
!
HTMLEditorRef
(
)
.
IsEditable
(
curBlock
)
)
{
curBlock
=
nullptr
;
}
else
{
firstNode
=
lastNode
=
curNode
-
>
AsContent
(
)
;
}
continue
;
}
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
continue
;
}
}
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ApplyBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
curNode
:
aNodeArray
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
curNode
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
&
&
IsBlockNode
(
curNode
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
curNode
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
curBlock
=
nullptr
;
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerAndCloneAttributesWithTransaction
(
*
curNode
-
>
AsElement
(
)
aBlockTag
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
if
(
!
childArray
.
IsEmpty
(
)
)
{
nsresult
rv
=
ApplyBlockStyle
(
childArray
aBlockTag
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
IsInlineNode
(
curNode
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
!
curBlock
)
{
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atCurNode
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
SplitNodeResult
HTMLEditRules
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfDeepestRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
host
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
*
host
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorRawDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToInsert
.
GetChild
(
)
=
=
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
(
aStartOfDeepestRightNode
)
;
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
pointToInsert
.
GetChild
(
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
Failed
to
split
the
node
for
insert
the
element
"
)
;
return
splitNodeResult
;
}
nsresult
HTMLEditRules
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNewFirstChildOfRightNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNodeLeft
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
rightParent
=
aNodeRight
.
GetParentNode
(
)
;
if
(
parent
!
=
rightParent
)
{
int32_t
parOffset
=
parent
-
>
ComputeIndexOf
(
&
aNodeLeft
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aNodeRight
EditorRawDOMPoint
(
parent
parOffset
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
EditorDOMPoint
ret
(
&
aNodeRight
aNodeLeft
.
Length
(
)
)
;
if
(
HTMLEditUtils
:
:
IsList
(
&
aNodeLeft
)
|
|
aNodeLeft
.
GetAsText
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastLeft
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNodeLeft
)
;
if
(
NS_WARN_IF
(
!
lastLeft
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstRight
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
firstRight
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
lastLeft
&
&
firstRight
&
&
HTMLEditorRef
(
)
.
AreNodesSameType
(
lastLeft
firstRight
)
&
&
(
lastLeft
-
>
GetAsText
(
)
|
|
(
lastLeft
-
>
IsElement
(
)
&
&
firstRight
-
>
IsElement
(
)
&
&
CSSEditUtils
:
:
ElementsSameStyle
(
lastLeft
-
>
AsElement
(
)
firstRight
-
>
AsElement
(
)
)
)
)
)
{
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
lastLeft
*
firstRight
aNewFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
return
NS_OK
;
}
Element
*
HTMLEditRules
:
:
GetTopEnclosingMailCite
(
nsINode
&
aNode
)
{
nsCOMPtr
<
Element
>
ret
;
for
(
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
IsPlaintextEditor
(
)
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
{
ret
=
node
-
>
AsElement
(
)
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
CacheInlineStyles
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
GetInlineStyles
(
aNode
mCachedStyles
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetInlineStyles
(
nsINode
*
aNode
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
+
+
j
)
{
bool
typeInSet
unused
;
HTMLEditorRef
(
)
.
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsAutoString
outValue
;
if
(
!
useCSS
|
|
(
aStyleCache
[
j
]
.
tag
=
=
nsGkAtoms
:
:
font
&
&
aStyleCache
[
j
]
.
attr
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
HTMLEditorRef
(
)
.
IsTextPropertySetByContent
(
aNode
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
nullptr
&
outValue
)
;
}
else
{
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
aNode
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
outValue
CSSEditUtils
:
:
eComputed
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
isSet
)
{
aStyleCache
[
j
]
.
mPresent
=
true
;
aStyleCache
[
j
]
.
value
.
Assign
(
outValue
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
const
RangeBoundary
&
atStartOfSelection
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
-
>
StartRef
(
)
;
nsCOMPtr
<
nsIContent
>
selNode
=
atStartOfSelection
.
Container
(
)
&
&
atStartOfSelection
.
Container
(
)
-
>
IsContent
(
)
?
atStartOfSelection
.
Container
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
!
selNode
)
{
return
NS_OK
;
}
StyleCache
styleAtInsertionPoint
[
SIZE_STYLE_TABLE
]
;
InitStyleCacheArray
(
styleAtInsertionPoint
)
;
nsresult
rv
=
GetInlineStyles
(
selNode
styleAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
=
=
NS_ERROR_EDITOR_DESTROYED
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
SIZE_STYLE_TABLE
;
+
+
i
)
{
if
(
mCachedStyles
[
i
]
.
mPresent
)
{
bool
bFirst
bAny
bAll
;
bFirst
=
bAny
=
bAll
=
false
;
nsAutoString
curValue
;
if
(
useCSS
)
{
bAny
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
selNode
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
curValue
CSSEditUtils
:
:
eComputed
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
!
bAny
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
GetInlinePropertyBase
(
*
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
&
(
mCachedStyles
[
i
]
.
value
)
&
bFirst
&
bAny
&
bAll
&
curValue
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
(
!
bAny
|
|
IsStyleCachePreservingSubAction
(
mTopLevelEditSubAction
)
)
&
&
(
!
styleAtInsertionPoint
[
i
]
.
mPresent
|
|
styleAtInsertionPoint
[
i
]
.
value
!
=
mCachedStyles
[
i
]
.
value
)
)
{
HTMLEditorRef
(
)
.
mTypeInState
-
>
SetProp
(
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
mCachedStyles
[
i
]
.
value
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
ClearCachedStyles
(
)
{
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
j
+
+
)
{
mCachedStyles
[
j
]
.
mPresent
=
false
;
mCachedStyles
[
j
]
.
value
.
Truncate
(
)
;
}
}
nsresult
HTMLEditRules
:
:
InsertBRElementToEmptyListItemsAndTableCellsInChangedRange
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
EmptyEditableFunctor
functor
(
&
HTMLEditorRef
(
)
)
;
DOMIterator
iter
;
if
(
NS_WARN_IF
(
NS_FAILED
(
iter
.
Init
(
*
mDocChangeRange
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
EditorRawDOMPoint
endOfNode
;
endOfNode
.
SetToEndOf
(
node
)
;
CreateElementResult
createMozBrResult
=
CreateMozBR
(
endOfNode
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AdjustWhitespace
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
WSRunObject
(
&
HTMLEditorRef
(
)
selectionStartPoint
)
.
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
PinSelectionToNewBlock
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mNewBlock
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
selectionStartPoint
.
GetContainer
(
)
)
;
nsresult
rv
=
range
-
>
CollapseTo
(
selectionStartPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
nodeBefore
nodeAfter
;
rv
=
nsRange
:
:
CompareNodeToRange
(
mNewBlock
range
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
nsCOMPtr
<
nsINode
>
tmp
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
endPoint
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
tmp
)
)
{
endPoint
.
SetToEndOf
(
tmp
)
;
}
else
{
endPoint
.
Set
(
tmp
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
endPoint
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
tmp
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
tmp
)
)
{
atStartOfBlock
.
Set
(
tmp
)
;
}
else
{
atStartOfBlock
.
Set
(
tmp
0
)
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfBlock
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
CheckInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
node
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
atStartOfSelection
)
;
if
(
node
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
return
;
}
if
(
atStartOfSelection
.
GetChild
(
)
)
{
node
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
atStartOfSelection
.
GetChild
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
return
;
}
if
(
atStartOfSelection
.
GetChild
(
)
)
{
node
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
atStartOfSelection
.
GetChild
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
}
}
nsresult
HTMLEditRules
:
:
AdjustSelection
(
nsIEditor
:
:
EDirection
aAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
EditorDOMPoint
point
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
HTMLEditorRef
(
)
.
IsEditable
(
point
.
GetContainer
(
)
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
theblock
=
HTMLEditorRef
(
)
.
GetBlock
(
*
point
.
GetContainer
(
)
)
;
if
(
theblock
&
&
HTMLEditorRef
(
)
.
IsEditable
(
theblock
)
)
{
bool
isEmptyNode
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
theblock
&
isEmptyNode
false
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
&
&
HTMLEditorRef
(
)
.
CanContainTag
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
rootElement
)
{
return
NS_OK
;
}
CreateElementResult
createMozBrResult
=
CreateMozBR
(
point
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
return
NS_OK
;
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
point
)
;
if
(
nearNode
)
{
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
point
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
nearBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
nearNode
)
;
if
(
block
&
&
block
=
=
nearBlock
)
{
if
(
nearNode
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
)
{
CreateElementResult
createMozBrResult
=
CreateMozBR
(
point
)
;
if
(
NS_WARN_IF
(
createMozBrResult
.
Failed
(
)
)
)
{
return
createMozBrResult
.
Rv
(
)
;
}
point
.
Set
(
createMozBrResult
.
GetNewNode
(
)
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
*
nearNode
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
}
}
}
}
}
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
|
|
nearNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
nearNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
nearNode
=
FindNearEditableNode
(
point
aAction
)
;
if
(
!
nearNode
)
{
return
NS_OK
;
}
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nearNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditRules
:
:
FindNearEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
nearNode
=
nullptr
;
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
aPoint
)
;
if
(
!
nearNode
)
{
return
nullptr
;
}
}
else
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
aPoint
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
while
(
nearNode
&
&
!
(
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
)
)
{
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
else
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
}
if
(
InDifferentTableElements
(
nearNode
aPoint
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
nearNode
;
}
bool
HTMLEditRules
:
:
InDifferentTableElements
(
nsINode
*
aNode1
nsINode
*
aNode2
)
{
MOZ_ASSERT
(
aNode1
&
&
aNode2
)
;
while
(
aNode1
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode1
)
)
{
aNode1
=
aNode1
-
>
GetParentNode
(
)
;
}
while
(
aNode2
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode2
)
)
{
aNode2
=
aNode2
-
>
GetParentNode
(
)
;
}
return
aNode1
!
=
aNode2
;
}
nsresult
HTMLEditRules
:
:
RemoveEmptyNodesInChangedRange
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
mDocChangeRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfEmptyNodes
arrayOfEmptyCites
skipList
;
while
(
!
iter
-
>
IsDone
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
iter
-
>
GetCurrentNode
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
node
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parent
)
{
skipList
[
idx
]
=
parent
;
}
}
else
{
bool
isCandidate
=
false
;
bool
isEmptyNode
=
false
;
bool
isMailCite
=
false
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
isMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
node
)
|
|
HTMLEditUtils
:
:
IsList
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
isCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
bool
isSelectionEndInNode
;
rv
=
SelectionEndpointInNode
(
node
&
isSelectionEndInNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isSelectionEndInNode
)
{
isCandidate
=
true
;
}
}
}
if
(
isCandidate
)
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
node
&
isEmptyNode
isMailCite
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
if
(
isMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
node
)
;
}
else
{
arrayOfEmptyNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
!
isEmptyNode
&
&
parent
)
{
skipList
.
AppendElement
(
*
parent
)
;
}
}
iter
-
>
Next
(
)
;
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyNodes
)
{
if
(
HTMLEditorRef
(
)
.
IsModifiableNode
(
delNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyCites
)
{
bool
isEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
delNode
&
isEmptyNode
false
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmptyNode
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
delNode
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SelectionEndpointInNode
(
nsINode
*
aNode
bool
*
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_ENSURE_TRUE
(
aNode
&
&
aResult
NS_ERROR_NULL_POINTER
)
;
*
aResult
=
false
;
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
rangeIdx
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
)
{
if
(
aNode
=
=
startContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
startContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
)
{
if
(
aNode
=
=
endContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
endContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
IsEmptyInline
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsInlineNode
(
aNode
)
&
&
HTMLEditorRef
(
)
.
IsContainer
(
&
aNode
)
)
{
bool
isEmpty
=
true
;
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
return
isEmpty
;
}
return
false
;
}
bool
HTMLEditRules
:
:
ListIsEmptyLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aArrayOfNodes
.
Length
(
)
)
)
{
return
true
;
}
int32_t
brCount
=
0
;
for
(
auto
&
node
:
aArrayOfNodes
)
{
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
node
)
)
{
continue
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
if
(
brCount
)
{
return
false
;
}
brCount
+
+
;
}
else
if
(
IsEmptyInline
(
node
)
)
{
}
else
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditRules
:
:
PopListItem
(
nsIContent
&
aListItem
bool
*
aOutOfList
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aOutOfList
)
{
*
aOutOfList
=
false
;
}
if
(
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
)
|
|
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
-
>
GetParentNode
(
)
)
|
|
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isFirstListItem
=
HTMLEditorRef
(
)
.
IsFirstEditableChild
(
&
aListItem
)
;
bool
isLastListItem
=
HTMLEditorRef
(
)
.
IsLastEditableChild
(
&
aListItem
)
;
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
nsCOMPtr
<
nsIContent
>
listItem
(
&
aListItem
)
;
if
(
!
isFirstListItem
&
&
!
isLastListItem
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
atListItem
.
IsSetAndValid
(
)
)
;
ErrorResult
error
;
leftListNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
pointToInsertListItem
(
leftListNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsertListItem
.
IsSetAndValid
(
)
)
;
if
(
!
isFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
listItem
pointToInsertListItem
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
listItem
)
)
{
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
listItem
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aOutOfList
)
{
*
aOutOfList
=
true
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveListStructure
(
Element
&
aListElement
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsList
(
&
aListElement
)
)
;
while
(
aListElement
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aListElement
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
bool
isOutOfList
;
do
{
nsresult
rv
=
PopListItem
(
child
&
isOutOfList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
while
(
!
isOutOfList
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
nsresult
rv
=
RemoveListStructure
(
*
child
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
aListElement
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ConfirmSelectionInBody
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
selectionStartPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
rootElement
0
)
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
start
of
the
root
element
"
)
;
return
NS_OK
;
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
rootElement
0
)
ignoredError
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
start
of
the
root
element
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
UpdateDocChangeRange
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
const
RangeBoundary
&
atStart
=
aRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfRoot
(
atStart
.
Container
(
)
)
)
{
return
NS_OK
;
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
aRange
-
>
CloneRange
(
)
;
}
else
{
ErrorResult
error
;
int16_t
result
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
START_TO_START
*
aRange
error
)
;
if
(
error
.
ErrorCodeIs
(
NS_ERROR_NOT_INITIALIZED
)
)
{
result
=
1
;
error
.
SuppressException
(
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
result
>
0
)
{
mDocChangeRange
-
>
SetStart
(
atStart
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
result
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
END_TO_END
*
aRange
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
result
<
0
)
{
const
RangeBoundary
&
atEnd
=
aRange
-
>
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mDocChangeRange
-
>
SetEnd
(
atEnd
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeededInternal
(
nsINode
&
aNode
bool
aInsertMozBR
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsBlockNode
(
aNode
)
)
{
return
NS_OK
;
}
bool
isEmpty
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmpty
)
{
return
NS_OK
;
}
CreateElementResult
createBrResult
=
!
aInsertMozBR
?
CreateBR
(
EditorRawDOMPoint
(
&
aNode
0
)
)
:
CreateMozBR
(
EditorRawDOMPoint
(
&
aNode
0
)
)
;
if
(
NS_WARN_IF
(
createBrResult
.
Failed
(
)
)
)
{
return
createBrResult
.
Rv
(
)
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
DidCreateNode
(
Selection
&
aSelection
Element
&
aNewElement
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aNewElement
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidInsertNode
(
Selection
&
aSelection
nsIContent
&
aContent
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aContent
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillDeleteNode
(
Selection
&
aSelection
nsINode
&
aChild
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aChild
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidSplitNode
(
Selection
&
aSelection
nsINode
&
aExistingRightNode
nsINode
&
aNewLeftNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
&
aNewLeftNode
0
&
aExistingRightNode
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
mJoinOffset
=
aLeftNode
.
Length
(
)
;
}
void
HTMLEditRules
:
:
DidJoinNodes
(
Selection
&
aSelection
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
&
aRightNode
mJoinOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidInsertText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
int32_t
length
=
aString
.
Length
(
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
&
aTextNode
aOffset
&
aTextNode
aOffset
+
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidDeleteText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
&
aTextNode
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillDeleteSelection
(
Selection
&
aSelection
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
EditorRawDOMPoint
startPoint
=
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
;
}
EditorRawDOMPoint
endPoint
=
EditorBase
:
:
GetEndPoint
(
&
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
;
}
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
startPoint
endPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
nsresult
HTMLEditRules
:
:
RemoveAlignment
(
nsINode
&
aNode
const
nsAString
&
aAlignType
bool
aDescendantsOnly
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
EditorBase
:
:
IsTextNode
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsTable
(
&
aNode
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
child
tmp
;
if
(
aDescendantsOnly
)
{
child
=
aNode
.
GetFirstChild
(
)
;
}
else
{
child
=
&
aNode
;
}
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
while
(
child
)
{
if
(
aDescendantsOnly
)
{
tmp
=
child
-
>
GetNextSibling
(
)
;
}
else
{
tmp
=
nullptr
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MakeSureElemStartsAndEndsOnCR
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
*
child
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
child
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
*
child
-
>
AsElement
(
)
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
useCSS
)
{
if
(
child
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
child
-
>
AsElement
(
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsAutoString
dummyCssValue
;
nsresult
rv
=
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
RemoveCSSInlineStyle
(
*
child
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
child
=
tmp
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
bool
aStarts
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsINode
*
child
=
aStarts
?
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
:
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
NS_OK
;
}
bool
foundCR
=
false
;
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
else
{
nsINode
*
sibling
=
aStarts
?
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aNode
)
:
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
&
aNode
)
;
if
(
sibling
)
{
if
(
IsBlockNode
(
*
sibling
)
|
|
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
}
else
{
foundCR
=
true
;
}
}
if
(
!
foundCR
)
{
EditorRawDOMPoint
pointToInsert
;
if
(
!
aStarts
)
{
pointToInsert
.
SetToEndOf
(
&
aNode
)
;
}
else
{
pointToInsert
.
Set
(
&
aNode
0
)
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsAndEndsOnCR
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsresult
rv
=
MakeSureElemStartsOrEndsOnCR
(
aNode
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MakeSureElemStartsOrEndsOnCR
(
aNode
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignBlock
(
Element
&
aElement
const
nsAString
&
aAlignType
ResetAlignOf
aResetAlignOf
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsBlockNode
(
aElement
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RemoveAlignment
(
aElement
aAlignType
aResetAlignOf
=
=
ResetAlignOf
:
:
OnlyDescendants
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
SupportsAlignAttr
(
aElement
)
)
)
{
return
NS_OK
;
}
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ChangeMarginStart
(
Element
&
aElement
bool
aIncrease
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aIncrease
?
+
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
SetCSSProperty
(
aElement
marginProperty
newValue
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
RemoveCSSProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
&
aElement
=
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
|
|
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
&
aElement
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
focusElement
=
HTMLEditorRef
(
)
.
GetSelectionContainer
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
mNewBlock
=
focusElement
;
return
NS_OK
;
}
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
PrepareToMakeElementAbsolutePosition
(
aHandled
address_of
(
mNewBlock
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
PrepareToMakeElementAbsolutePosition
(
bool
*
aHandled
RefPtr
<
Element
>
*
aTargetElement
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aHandled
)
;
MOZ_ASSERT
(
aTargetElement
)
;
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditSubAction
:
:
eSetPositionToAbsolute
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eSetPositionToAbsolute
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
positionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
positionedDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aTargetElement
=
positionedDiv
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
selectionRestorer
.
Abort
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
positionedDiv
0
)
error
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curPositionedDiv
indentedLI
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
curPositionedDiv
)
{
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
curPositionedDiv
"
Failed
to
create
current
positioned
div
element
"
)
;
*
aTargetElement
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
;
atEndOfCurPositionedDiv
.
SetToEndOf
(
curPositionedDiv
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
atEndOfCurPositionedDiv
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
RefPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
listItem
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
curPositionedDiv
)
{
EditorRawDOMPoint
atListItemParent
(
atListItem
.
GetContainer
(
)
)
;
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
atListItemParent
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
curPositionedDiv
"
Failed
to
create
current
positioned
div
element
"
)
;
*
aTargetElement
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
;
atEndOfCurPositionedDiv
.
SetToEndOf
(
curPositionedDiv
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
atEndOfCurPositionedDiv
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
!
curPositionedDiv
)
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
curPositionedDiv
=
curNode
-
>
AsElement
(
)
;
*
aTargetElement
=
curPositionedDiv
;
curList
=
nullptr
;
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curPositionedDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aTargetElement
=
curPositionedDiv
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curPositionedDiv
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidAbsolutePosition
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
mNewBlock
)
{
return
NS_OK
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
SetPositionToAbsoluteOrStatic
(
*
mNewBlock
true
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRemoveAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
element
=
HTMLEditorRef
(
)
.
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
{
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRelativeChangeZIndex
(
int32_t
aChange
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
WillInsert
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WillInsert
(
)
failed
"
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
element
=
HTMLEditorRef
(
)
.
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
{
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
int32_t
zIndex
;
nsresult
rv
=
HTMLEditorRef
(
)
.
RelativeChangeElementZIndex
(
*
element
aChange
&
zIndex
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DocumentModified
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditRules
:
:
DocumentModifiedWorker
"
this
&
HTMLEditRules
:
:
DocumentModifiedWorker
)
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
DocumentModifiedWorker
(
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
if
(
mBogusNode
)
{
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
mBogusNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
bogus
node
"
)
;
mBogusNode
=
nullptr
;
}
DebugOnly
<
nsresult
>
rv
=
CreateBogusNodeIfNeeded
(
)
;
NS_WARNING_ASSERTION
(
rv
.
value
!
=
NS_ERROR_EDITOR_DESTROYED
"
The
editor
has
been
destroyed
during
creating
a
bogus
node
"
)
;
}
}
