#
include
"
HTMLEditRules
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
<
algorithm
>
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
class
RulesInfo
;
using
namespace
dom
;
enum
{
kLonely
=
0
kPrevSib
=
1
kNextSib
=
2
kBothSibs
=
3
}
;
static
bool
IsBlockNode
(
const
nsINode
&
node
)
{
return
HTMLEditor
:
:
NodeIsBlockStatic
(
&
node
)
;
}
static
bool
IsInlineNode
(
const
nsINode
&
node
)
{
return
!
IsBlockNode
(
node
)
;
}
static
bool
IsStyleCachePreservingAction
(
EditAction
action
)
{
return
action
=
=
EditAction
:
:
deleteSelection
|
|
action
=
=
EditAction
:
:
insertBreak
|
|
action
=
=
EditAction
:
:
makeList
|
|
action
=
=
EditAction
:
:
indent
|
|
action
=
=
EditAction
:
:
outdent
|
|
action
=
=
EditAction
:
:
align
|
|
action
=
=
EditAction
:
:
makeBasicBlock
|
|
action
=
=
EditAction
:
:
removeList
|
|
action
=
=
EditAction
:
:
makeDefListItem
|
|
action
=
=
EditAction
:
:
insertElement
|
|
action
=
=
EditAction
:
:
insertQuotation
;
}
static
nsAtom
&
ParagraphSeparatorElement
(
ParagraphSeparator
separator
)
{
switch
(
separator
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
paragraph
separator
!
"
)
;
case
ParagraphSeparator
:
:
div
:
return
*
nsGkAtoms
:
:
div
;
case
ParagraphSeparator
:
:
p
:
return
*
nsGkAtoms
:
:
p
;
case
ParagraphSeparator
:
:
br
:
return
*
nsGkAtoms
:
:
br
;
}
}
class
TableCellAndListItemFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
aNode
)
;
}
}
;
class
BRNodeFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
}
;
class
EmptyEditableFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
EmptyEditableFunctor
(
HTMLEditor
*
aHTMLEditor
)
:
mHTMLEditor
(
aHTMLEditor
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
if
(
mHTMLEditor
-
>
IsEditable
(
aNode
)
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
aNode
)
)
)
{
bool
bIsEmptyNode
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
aNode
&
bIsEmptyNode
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
bIsEmptyNode
)
{
return
true
;
}
}
return
false
;
}
protected
:
HTMLEditor
*
mHTMLEditor
;
}
;
HTMLEditRules
:
:
HTMLEditRules
(
)
:
mHTMLEditor
(
nullptr
)
mListenerEnabled
(
false
)
mReturnInEmptyLIKillsList
(
false
)
mDidDeleteSelection
(
false
)
mDidRangedDelete
(
false
)
mRestoreContentEditableCount
(
false
)
mJoinOffset
(
0
)
{
mIsHTMLEditRules
=
true
;
InitFields
(
)
;
}
void
HTMLEditRules
:
:
InitFields
(
)
{
mHTMLEditor
=
nullptr
;
mDocChangeRange
=
nullptr
;
mReturnInEmptyLIKillsList
=
true
;
mDidDeleteSelection
=
false
;
mDidRangedDelete
=
false
;
mRestoreContentEditableCount
=
false
;
mUtilRange
=
nullptr
;
mJoinOffset
=
0
;
mNewBlock
=
nullptr
;
mRangeItem
=
new
RangeItem
(
)
;
InitStyleCacheArray
(
mCachedStyles
)
;
}
void
HTMLEditRules
:
:
InitStyleCacheArray
(
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
aStyleCache
[
0
]
=
StyleCache
(
nsGkAtoms
:
:
b
nullptr
)
;
aStyleCache
[
1
]
=
StyleCache
(
nsGkAtoms
:
:
i
nullptr
)
;
aStyleCache
[
2
]
=
StyleCache
(
nsGkAtoms
:
:
u
nullptr
)
;
aStyleCache
[
3
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
face
)
;
aStyleCache
[
4
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
size
)
;
aStyleCache
[
5
]
=
StyleCache
(
nsGkAtoms
:
:
font
nsGkAtoms
:
:
color
)
;
aStyleCache
[
6
]
=
StyleCache
(
nsGkAtoms
:
:
tt
nullptr
)
;
aStyleCache
[
7
]
=
StyleCache
(
nsGkAtoms
:
:
em
nullptr
)
;
aStyleCache
[
8
]
=
StyleCache
(
nsGkAtoms
:
:
strong
nullptr
)
;
aStyleCache
[
9
]
=
StyleCache
(
nsGkAtoms
:
:
dfn
nullptr
)
;
aStyleCache
[
10
]
=
StyleCache
(
nsGkAtoms
:
:
code
nullptr
)
;
aStyleCache
[
11
]
=
StyleCache
(
nsGkAtoms
:
:
samp
nullptr
)
;
aStyleCache
[
12
]
=
StyleCache
(
nsGkAtoms
:
:
var
nullptr
)
;
aStyleCache
[
13
]
=
StyleCache
(
nsGkAtoms
:
:
cite
nullptr
)
;
aStyleCache
[
14
]
=
StyleCache
(
nsGkAtoms
:
:
abbr
nullptr
)
;
aStyleCache
[
15
]
=
StyleCache
(
nsGkAtoms
:
:
acronym
nullptr
)
;
aStyleCache
[
16
]
=
StyleCache
(
nsGkAtoms
:
:
backgroundColor
nullptr
)
;
aStyleCache
[
17
]
=
StyleCache
(
nsGkAtoms
:
:
sub
nullptr
)
;
aStyleCache
[
18
]
=
StyleCache
(
nsGkAtoms
:
:
sup
nullptr
)
;
}
HTMLEditRules
:
:
~
HTMLEditRules
(
)
{
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
HTMLEditRules
TextEditRules
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLEditRules
TextEditRules
mDocChangeRange
mUtilRange
mNewBlock
mRangeItem
)
nsresult
HTMLEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
|
|
NS_WARN_IF
(
!
aTextEditor
-
>
AsHTMLEditor
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
InitFields
(
)
;
mHTMLEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
Selection
*
selection
=
aTextEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsresult
rv
=
TextEditRules
:
:
Init
(
aTextEditor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
static
const
char
kPrefName
[
]
=
"
editor
.
html
.
typing
.
returnInEmptyListItemClosesList
"
;
nsAutoCString
returnInEmptyLIKillsList
;
Preferences
:
:
GetCString
(
kPrefName
returnInEmptyLIKillsList
)
;
mReturnInEmptyLIKillsList
=
!
returnInEmptyLIKillsList
.
EqualsLiteral
(
"
false
"
)
;
nsCOMPtr
<
nsINode
>
node
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
!
node
)
{
node
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mUtilRange
=
new
nsRange
(
node
)
;
AutoLockRulesSniffing
lockIt
(
this
)
;
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
node
)
;
}
if
(
node
-
>
IsElement
(
)
)
{
ErrorResult
rv
;
mDocChangeRange
-
>
SelectNode
(
*
node
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
AdjustSpecialBreaks
(
)
;
}
StartToListenToEditActions
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DetachEditor
(
)
{
EndListeningToEditActions
(
)
;
mHTMLEditor
=
nullptr
;
return
TextEditRules
:
:
DetachEditor
(
)
;
}
nsresult
HTMLEditRules
:
:
BeforeEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mActionNesting
+
+
;
mDidRangedDelete
=
false
;
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRangeItem
-
>
StoreRange
(
SelectionRef
(
)
.
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
mRangeItem
-
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
selEndNode
=
mRangeItem
-
>
mEndContainer
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
mDidDeleteSelection
=
false
;
if
(
mDocChangeRange
)
{
mDocChangeRange
-
>
Reset
(
)
;
}
if
(
mUtilRange
)
{
mUtilRange
-
>
Reset
(
)
;
}
if
(
aAction
=
=
EditAction
:
:
insertText
|
|
aAction
=
=
EditAction
:
:
insertIMEText
|
|
aAction
=
=
EditAction
:
:
deleteSelection
|
|
IsStyleCachePreservingAction
(
aAction
)
)
{
nsCOMPtr
<
nsINode
>
selNode
=
aDirection
=
=
nsIEditor
:
:
eNext
?
selEndNode
:
selStartNode
;
nsresult
rv
=
CacheInlineStyles
(
selNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsHTMLDocument
*
htmlDoc
=
HTMLEditorRef
(
)
.
GetHTMLDocument
(
)
;
if
(
NS_WARN_IF
(
!
htmlDoc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
mRestoreContentEditableCount
=
true
;
}
ConfirmSelectionInBody
(
)
;
mTheAction
=
aAction
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
AutoLockRulesSniffing
lockIt
(
this
)
;
MOZ_ASSERT
(
mActionNesting
>
0
)
;
nsresult
rv
=
NS_OK
;
mActionNesting
-
-
;
if
(
!
mActionNesting
)
{
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
rv
=
AfterEditInner
(
aAction
aDirection
)
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
if
(
mRestoreContentEditableCount
)
{
nsHTMLDocument
*
htmlDoc
=
HTMLEditorRef
(
)
.
GetHTMLDocument
(
)
;
if
(
NS_WARN_IF
(
!
htmlDoc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
mRestoreContentEditableCount
=
false
;
}
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEditInner
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
ConfirmSelectionInBody
(
)
;
if
(
aAction
=
=
EditAction
:
:
ignore
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
rangeStartContainer
rangeEndContainer
;
uint32_t
rangeStartOffset
=
0
rangeEndOffset
=
0
;
bool
bDamagedRange
=
false
;
if
(
mDocChangeRange
)
{
rangeStartContainer
=
mDocChangeRange
-
>
GetStartContainer
(
)
;
rangeEndContainer
=
mDocChangeRange
-
>
GetEndContainer
(
)
;
rangeStartOffset
=
mDocChangeRange
-
>
StartOffset
(
)
;
rangeEndOffset
=
mDocChangeRange
-
>
EndOffset
(
)
;
if
(
rangeStartContainer
&
&
rangeEndContainer
)
{
bDamagedRange
=
true
;
}
}
if
(
bDamagedRange
&
&
!
(
(
aAction
=
=
EditAction
:
:
undo
)
|
|
(
aAction
=
=
EditAction
:
:
redo
)
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
PromoteRange
(
*
mDocChangeRange
aAction
)
;
if
(
aAction
=
=
EditAction
:
:
deleteSelection
&
&
mDidRangedDelete
)
{
nsresult
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
AdjustSpecialBreaks
(
)
;
if
(
aAction
!
=
EditAction
:
:
insertText
&
&
aAction
!
=
EditAction
:
:
insertIMEText
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
CollapseAdjacentTextNodes
(
mDocChangeRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
RemoveEmptyNodes
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aAction
=
=
EditAction
:
:
insertText
|
|
aAction
=
=
EditAction
:
:
insertIMEText
|
|
aAction
=
=
EditAction
:
:
deleteSelection
|
|
aAction
=
=
EditAction
:
:
insertBreak
|
|
aAction
=
=
EditAction
:
:
htmlPaste
|
|
aAction
=
=
EditAction
:
:
loadHTML
)
{
rv
=
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ENSURE_STATE
(
mRangeItem
-
>
mStartContainer
)
;
NS_ENSURE_STATE
(
mRangeItem
-
>
mEndContainer
)
;
WSRunObject
(
&
HTMLEditorRef
(
)
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
)
.
AdjustWhitespace
(
)
;
if
(
mRangeItem
-
>
mStartContainer
!
=
mRangeItem
-
>
mEndContainer
|
|
mRangeItem
-
>
mStartOffset
!
=
mRangeItem
-
>
mEndOffset
)
{
WSRunObject
(
&
HTMLEditorRef
(
)
mRangeItem
-
>
mEndContainer
mRangeItem
-
>
mEndOffset
)
.
AdjustWhitespace
(
)
;
}
}
if
(
mNewBlock
)
{
rv
=
PinSelectionToNewBlock
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
pin
selection
to
the
new
block
"
)
;
mNewBlock
=
nullptr
;
}
if
(
aAction
=
=
EditAction
:
:
insertText
|
|
aAction
=
=
EditAction
:
:
insertIMEText
|
|
aAction
=
=
EditAction
:
:
deleteSelection
|
|
aAction
=
=
EditAction
:
:
insertBreak
|
|
aAction
=
=
EditAction
:
:
htmlPaste
|
|
aAction
=
=
EditAction
:
:
loadHTML
)
{
rv
=
AdjustSelection
(
aDirection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aAction
=
=
EditAction
:
:
insertText
|
|
aAction
=
=
EditAction
:
:
insertIMEText
|
|
aAction
=
=
EditAction
:
:
deleteSelection
|
|
IsStyleCachePreservingAction
(
aAction
)
)
{
HTMLEditorRef
(
)
.
mTypeInState
-
>
UpdateSelState
(
&
SelectionRef
(
)
)
;
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ClearCachedStyles
(
)
;
}
}
nsresult
rv
=
HTMLEditorRef
(
)
.
HandleInlineSpellCheck
(
aAction
SelectionRef
(
)
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
rangeStartContainer
rangeStartOffset
rangeEndContainer
rangeEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
CreateBogusNodeIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
mDidExplicitlySetInterline
)
{
CheckInterlinePosition
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
aSelection
)
|
|
NS_WARN_IF
(
!
aInfo
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
aInfo
-
>
action
=
=
EditAction
:
:
outputText
|
|
aInfo
-
>
action
=
=
EditAction
:
:
undo
|
|
aInfo
-
>
action
=
=
EditAction
:
:
redo
)
{
return
TextEditRules
:
:
WillDoAction
(
aSelection
aInfo
aCancel
aHandled
)
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
aSelection
)
;
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
selStartNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
selStartNode
!
=
selEndNode
)
{
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
selEndNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
range
-
>
GetCommonAncestor
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
}
switch
(
aInfo
-
>
action
)
{
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
UndefineCaretBidiLevel
(
)
;
return
WillInsertText
(
aInfo
-
>
action
aCancel
aHandled
aInfo
-
>
inString
aInfo
-
>
outString
aInfo
-
>
maxLength
)
;
case
EditAction
:
:
loadHTML
:
return
WillLoadHTML
(
aCancel
)
;
case
EditAction
:
:
insertBreak
:
UndefineCaretBidiLevel
(
)
;
return
WillInsertBreak
(
aCancel
aHandled
)
;
case
EditAction
:
:
deleteSelection
:
return
WillDeleteSelection
(
aInfo
-
>
collapsedAction
aInfo
-
>
stripWrappers
aCancel
aHandled
)
;
case
EditAction
:
:
makeList
:
return
WillMakeList
(
aInfo
-
>
blockType
aInfo
-
>
entireList
aInfo
-
>
bulletType
aCancel
aHandled
)
;
case
EditAction
:
:
indent
:
return
WillIndent
(
aCancel
aHandled
)
;
case
EditAction
:
:
outdent
:
return
WillOutdent
(
aCancel
aHandled
)
;
case
EditAction
:
:
setAbsolutePosition
:
return
WillAbsolutePosition
(
aCancel
aHandled
)
;
case
EditAction
:
:
removeAbsolutePosition
:
return
WillRemoveAbsolutePosition
(
aCancel
aHandled
)
;
case
EditAction
:
:
align
:
return
WillAlign
(
*
aInfo
-
>
alignType
aCancel
aHandled
)
;
case
EditAction
:
:
makeBasicBlock
:
return
WillMakeBasicBlock
(
*
aInfo
-
>
blockType
aCancel
aHandled
)
;
case
EditAction
:
:
removeList
:
return
WillRemoveList
(
aInfo
-
>
bOrdered
aCancel
aHandled
)
;
case
EditAction
:
:
makeDefListItem
:
return
WillMakeDefListItem
(
aInfo
-
>
blockType
aInfo
-
>
entireList
aCancel
aHandled
)
;
case
EditAction
:
:
insertElement
:
WillInsert
(
aCancel
)
;
return
NS_OK
;
case
EditAction
:
:
decreaseZIndex
:
return
WillRelativeChangeZIndex
(
-
1
aCancel
aHandled
)
;
case
EditAction
:
:
increaseZIndex
:
return
WillRelativeChangeZIndex
(
1
aCancel
aHandled
)
;
default
:
return
TextEditRules
:
:
WillDoAction
(
&
SelectionRef
(
)
aInfo
aCancel
aHandled
)
;
}
}
nsresult
HTMLEditRules
:
:
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
!
aSelection
)
|
|
NS_WARN_IF
(
!
aInfo
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
aSelection
)
;
switch
(
aInfo
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
return
DidInsertBreak
(
aResult
)
;
case
EditAction
:
:
deleteSelection
:
return
DidDeleteSelection
(
aInfo
-
>
collapsedAction
aResult
)
;
case
EditAction
:
:
makeBasicBlock
:
case
EditAction
:
:
indent
:
case
EditAction
:
:
outdent
:
case
EditAction
:
:
align
:
return
DidMakeBasicBlock
(
aInfo
aResult
)
;
case
EditAction
:
:
setAbsolutePosition
:
{
nsresult
rv
=
DidMakeBasicBlock
(
aInfo
aResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
DidAbsolutePosition
(
)
;
}
default
:
return
TextEditRules
:
:
DidDoAction
(
aSelection
aInfo
aResult
)
;
}
}
bool
HTMLEditRules
:
:
DocumentIsEmpty
(
)
{
return
!
!
mBogusNode
;
}
nsresult
HTMLEditRules
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aOL
=
false
;
*
aUL
=
false
;
*
aDL
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
curNode
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
dom
:
:
Element
*
parent
=
curNode
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
}
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
*
aDL
=
true
;
}
else
{
bNonList
=
true
;
}
}
if
(
(
*
aUL
+
*
aOL
+
*
aDL
+
bNonList
)
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aLI
=
false
;
*
aDT
=
false
;
*
aDD
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
node
:
arrayOfNodes
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
node
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
*
aLI
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
bool
bDT
bDD
;
GetDefinitionListItemTypes
(
node
-
>
AsElement
(
)
&
bDT
&
bDD
)
;
*
aDT
|
=
bDT
;
*
aDD
|
=
bDD
;
}
else
{
bNonList
=
true
;
}
}
if
(
*
aDT
+
*
aDD
+
bNonList
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
MOZ_ASSERT
(
aMixed
&
&
aAlign
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
*
aMixed
=
false
;
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
if
(
NS_WARN_IF
(
!
HTMLEditorRef
(
)
.
GetRoot
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
Element
>
root
=
*
HTMLEditorRef
(
)
.
GetRoot
(
)
;
int32_t
rootOffset
=
root
-
>
GetParentNode
(
)
?
root
-
>
GetParentNode
(
)
-
>
ComputeIndexOf
(
root
)
:
-
1
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
atStartOfSelection
.
GetContainerAsText
(
)
)
{
nodeToExamine
=
atStartOfSelection
.
GetContainer
(
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
static_cast
<
uint32_t
>
(
rootOffset
)
)
{
nodeToExamine
=
HTMLEditorRef
(
)
.
GetNextEditableNode
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditAction
:
:
align
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
align
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nodeToExamine
=
arrayOfNodes
.
SafeElementAt
(
0
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
blockParent
=
HTMLEditorRef
(
)
.
GetBlock
(
*
nodeToExamine
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
blockParent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetCSSEquivalentToHTMLInlineStyleSet
(
blockParent
nullptr
nsGkAtoms
:
:
align
value
CSSEditUtils
:
:
eComputed
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
bool
isFirstNodeToExamine
=
true
;
for
(
;
nodeToExamine
;
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
)
{
if
(
!
isFirstNodeToExamine
&
&
nodeToExamine
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
nodeToExamine
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
textAlign
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
}
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
nodeToExamine
)
)
{
nsAutoString
typeAttrVal
;
nodeToExamine
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
typeAttrVal
)
;
ToLowerCase
(
typeAttrVal
)
;
if
(
!
typeAttrVal
.
IsEmpty
(
)
)
{
if
(
typeAttrVal
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
}
else
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
}
return
NS_OK
;
}
}
isFirstNodeToExamine
=
false
;
}
return
NS_OK
;
}
static
nsAtom
&
MarginPropertyAtomForIndent
(
nsINode
&
aNode
)
{
nsAutoString
direction
;
CSSEditUtils
:
:
GetComputedProperty
(
aNode
*
nsGkAtoms
:
:
direction
direction
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditRules
:
:
GetIndentState
(
bool
*
aCanIndent
bool
*
aCanOutdent
)
{
if
(
NS_WARN_IF
(
!
aCanIndent
)
|
|
NS_WARN_IF
(
!
aCanOutdent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCanIndent
=
true
;
*
aCanOutdent
=
false
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromSelection
(
EditAction
:
:
indent
arrayOfNodes
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
curNode
)
)
{
*
aCanOutdent
=
true
;
break
;
}
else
if
(
useCSS
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curNode
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
curNode
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
0
<
f
)
{
*
aCanOutdent
=
true
;
break
;
}
}
}
if
(
*
aCanOutdent
)
{
return
NS_OK
;
}
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsINode
*
node
=
selectionStartPoint
.
GetContainer
(
)
;
node
&
&
node
!
=
rootElement
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
node
)
)
{
*
aCanOutdent
=
true
;
return
NS_OK
;
}
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsINode
*
node
=
selectionEndPoint
.
GetContainer
(
)
;
node
&
&
node
!
=
rootElement
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
node
)
)
{
*
aCanOutdent
=
true
;
return
NS_OK
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
true
;
outFormat
.
Truncate
(
0
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
bool
bMixed
=
false
;
nsAutoString
formatStr
(
NS_LITERAL_STRING
(
"
x
"
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetParagraphFormatNodes
(
arrayOfNodes
TouchContent
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
curNode
=
arrayOfNodes
[
i
]
;
nsAutoString
format
;
if
(
IsBlockNode
(
curNode
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
rv
=
AppendInnerFormatNodes
(
arrayOfNodes
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
arrayOfNodes
.
AppendElement
(
*
selectionStartPoint
.
GetContainer
(
)
)
;
}
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
GetFormatString
(
curNode
format
)
;
}
else
if
(
IsBlockNode
(
curNode
)
)
{
continue
;
}
else
{
nsINode
*
node
=
curNode
-
>
GetParentNode
(
)
;
while
(
node
)
{
if
(
node
=
=
rootElement
)
{
format
.
Truncate
(
0
)
;
break
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
)
{
GetFormatString
(
node
format
)
;
break
;
}
node
=
node
-
>
GetParentNode
(
)
;
}
}
if
(
formatStr
.
EqualsLiteral
(
"
x
"
)
)
{
formatStr
=
format
;
}
else
if
(
format
!
=
formatStr
)
{
bMixed
=
true
;
break
;
}
}
*
aMixed
=
bMixed
;
outFormat
=
formatStr
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
IsBlockNode
(
*
child
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
child
)
;
if
(
isBlock
&
&
!
isFormat
)
{
AppendInnerFormatNodes
(
aArray
child
)
;
}
else
if
(
isFormat
)
{
aArray
.
AppendElement
(
*
child
)
;
}
else
if
(
!
foundInline
)
{
foundInline
=
true
;
aArray
.
AppendElement
(
*
child
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetFormatString
(
nsINode
*
aNode
nsAString
&
outFormat
)
{
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
aNode
)
)
{
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
outFormat
)
;
}
else
{
outFormat
.
Truncate
(
)
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
WillInsert
(
bool
*
aCancel
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
)
;
TextEditRules
:
:
WillInsert
(
aCancel
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
priorNode
&
&
TextEditUtils
:
:
IsMozBR
(
priorNode
)
)
{
RefPtr
<
Element
>
block1
=
HTMLEditorRef
(
)
.
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
block2
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
priorNode
)
;
if
(
block1
&
&
block1
=
=
block2
)
{
EditorRawDOMPoint
point
(
priorNode
)
;
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
;
}
}
}
if
(
mDidDeleteSelection
&
&
(
mTheAction
=
=
EditAction
:
:
insertText
|
|
mTheAction
=
=
EditAction
:
:
insertIMEText
|
|
mTheAction
=
=
EditAction
:
:
deleteSelection
)
)
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
if
(
!
IsStyleCachePreservingAction
(
mTheAction
)
)
{
ClearCachedStyles
(
)
;
}
}
nsresult
HTMLEditRules
:
:
WillInsertText
(
EditAction
aAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionAsAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
nsCOMPtr
<
nsIDocument
>
doc
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CreateStyleForInsertText
(
*
doc
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
EditorBase
:
:
IsTextNode
(
pointToInsert
.
GetContainer
(
)
)
&
&
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
int32_t
IMESelectionOffset
=
HTMLEditorRef
(
)
.
GetIMESelectionStartOffsetIn
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
IMESelectionOffset
>
=
0
)
{
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
IMESelectionOffset
)
;
}
if
(
inString
-
>
IsEmpty
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
InsertTextWithTransaction
(
*
doc
*
inString
EditorRawDOMPoint
(
pointToInsert
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToInsert
)
;
rv
=
wsObj
.
InsertText
(
*
doc
*
inString
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
bool
isPRE
=
EditorBase
:
:
IsPreformatted
(
pointToInsert
.
GetContainer
(
)
)
;
AutoLockListener
lockit
(
&
mListenerEnabled
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
nsAutoString
tString
(
*
inString
)
;
const
char16_t
*
unicodeBuf
=
tString
.
get
(
)
;
int32_t
pos
=
0
;
NS_NAMED_LITERAL_STRING
(
newlineStr
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
pointToInsert
)
;
if
(
isPRE
|
|
IsPlaintextEditor
(
)
)
{
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pos
+
+
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
HTMLEditorRef
(
)
.
InsertTextWithTransaction
(
*
doc
subStr
EditorRawDOMPoint
(
currentPoint
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
else
{
NS_NAMED_LITERAL_STRING
(
tabStr
"
\
t
"
)
;
NS_NAMED_LITERAL_STRING
(
spacesStr
"
"
)
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
currentPoint
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
rv
=
wsObj
.
InsertText
(
*
doc
spacesStr
currentPoint
&
pointAfterInsertedSpaces
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
pos
+
+
;
currentPoint
=
pointAfterInsertedSpaces
;
pointToInsert
=
pointAfterInsertedSpaces
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
newBRElement
=
wsObj
.
InsertBreak
(
SelectionRef
(
)
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pos
+
+
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
newBRElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
new
<
br
>
node
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
wsObj
.
InsertText
(
*
doc
subStr
currentPoint
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
}
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
if
(
currentPoint
.
IsSet
(
)
)
{
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
currentPoint
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
collapse
at
current
point
"
)
;
error
.
SuppressException
(
)
;
}
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
pointToInsert
.
GetContainer
(
)
)
;
}
if
(
currentPoint
.
IsSet
(
)
)
{
rv
=
mDocChangeRange
-
>
SetStartAndEnd
(
pointToInsert
currentPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
mDocChangeRange
-
>
CollapseTo
(
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillLoadHTML
(
bool
*
aCancel
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
if
(
mBogusNode
)
{
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
mBogusNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
bogus
node
"
)
;
mBogusNode
=
nullptr
;
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
CanContainParagraph
(
Element
&
aElement
)
const
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditRules
:
:
WillInsertBreak
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionAsAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
if
(
IsMailEditor
(
)
)
{
nsresult
rv
=
SplitMailCites
(
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aHandled
)
{
return
NS_OK
;
}
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
HTMLEditorRef
(
)
.
IsModifiableNode
(
atStartOfSelection
.
GetContainer
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
host
)
;
ParagraphSeparator
separator
=
HTMLEditorRef
(
)
.
GetDefaultParagraphSeparator
(
)
;
bool
insertBRElement
;
if
(
!
blockParent
)
{
insertBRElement
=
true
;
}
else
if
(
host
=
=
blockParent
)
{
insertBRElement
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
CanContainParagraph
(
*
host
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
blockParent
)
)
{
insertBRElement
=
false
;
}
else
{
insertBRElement
=
true
;
for
(
Element
*
blockAncestor
=
blockParent
;
blockAncestor
&
&
insertBRElement
;
blockAncestor
=
HTMLEditor
:
:
GetBlockNodeParent
(
blockAncestor
host
)
)
{
insertBRElement
=
!
CanContainParagraph
(
*
blockAncestor
)
;
}
}
if
(
insertBRElement
)
{
nsresult
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
host
=
=
blockParent
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
MakeBasicBlock
(
ParagraphSeparatorElement
(
separator
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditRules
:
:
MakeBasicBlock
(
)
failed
"
)
;
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
host
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
blockParent
=
=
host
)
)
{
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
mNewBlock
=
blockParent
;
}
if
(
IsEmptyBlockElement
(
*
blockParent
IgnoreSingleBR
:
:
eNo
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditorRawDOMPoint
endOfBlockParent
;
endOfBlockParent
.
SetToEndOf
(
blockParent
)
;
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
endOfBlockParent
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsCOMPtr
<
Element
>
listItem
=
IsInListItem
(
blockParent
)
;
if
(
listItem
&
&
listItem
!
=
host
)
{
ReturnInListItem
(
*
listItem
*
atStartOfSelection
.
GetContainer
(
)
atStartOfSelection
.
Offset
(
)
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
blockParent
)
)
{
ReturnInHeader
(
*
blockParent
*
atStartOfSelection
.
GetContainer
(
)
atStartOfSelection
.
Offset
(
)
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditActionResult
result
=
ReturnInParagraph
(
*
blockParent
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
*
aHandled
=
result
.
Handled
(
)
;
*
aCancel
=
result
.
Canceled
(
)
;
if
(
result
.
Handled
(
)
)
{
lockOffset
.
Cancel
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
*
aCancel
"
ReturnInParagraph
canceled
this
edit
action
"
"
WillInsertBreak
(
)
needs
to
handle
such
case
"
)
;
}
MOZ_ASSERT
(
!
*
aHandled
"
Reached
last
resort
of
WillInsertBreak
(
)
"
"
after
the
edit
action
is
handled
"
)
;
nsresult
rv
=
InsertBRElement
(
atStartOfSelection
)
;
*
aHandled
=
true
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
brElementIsAfterBlock
=
false
;
bool
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsPlaintextEditor
(
)
)
{
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
aPointToBreak
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToBreak
)
;
int32_t
visOffset
=
0
;
WSType
wsType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
PriorVisibleNode
(
pointToBreak
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsAfterBlock
=
true
;
}
wsObj
.
NextVisibleNode
(
pointToBreak
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsBeforeBlock
=
true
;
}
nsCOMPtr
<
nsINode
>
linkDOMNode
;
if
(
HTMLEditorRef
(
)
.
IsInLink
(
pointToBreak
.
GetContainer
(
)
address_of
(
linkDOMNode
)
)
)
{
nsCOMPtr
<
Element
>
linkNode
=
do_QueryInterface
(
linkDOMNode
)
;
if
(
NS_WARN_IF
(
!
linkNode
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitLinkNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitLinkNodeResult
.
Failed
(
)
)
)
{
return
splitLinkNodeResult
.
Rv
(
)
;
}
pointToBreak
=
splitLinkNodeResult
.
SplitPoint
(
)
;
}
brElement
=
wsObj
.
InsertBreak
(
SelectionRef
(
)
pointToBreak
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
NS_WARN_IF
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
EditorRawDOMPoint
point
(
brElement
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditorDOMPoint
afterBRElement
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
afterBRElement
)
;
nsCOMPtr
<
nsINode
>
maybeSecondBRNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
afterBRElement
address_of
(
maybeSecondBRNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
EditorDOMPoint
atSecondBRElement
(
maybeSecondBRNode
)
;
if
(
brElement
-
>
GetNextSibling
(
)
!
=
maybeSecondBRNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
maybeSecondBRNode
-
>
AsContent
(
)
afterBRElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
!
(
nextSiblingOfBRElement
&
&
IsBlockNode
(
*
nextSiblingOfBRElement
)
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
or
unset
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
afterBRElement
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidInsertBreak
(
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SplitMailCites
(
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
pointToSplit
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
citeNode
=
GetTopEnclosingMailCite
(
*
pointToSplit
.
GetContainer
(
)
)
;
if
(
!
citeNode
)
{
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToSplit
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
pointToSplit
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
&
&
visNode
!
=
citeNode
&
&
citeNode
-
>
Contains
(
visNode
)
)
{
pointToSplit
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplit
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
visible
node
"
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitCiteNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
citeNode
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitCiteNodeResult
.
Failed
(
)
)
)
{
return
splitCiteNodeResult
.
Rv
(
)
;
}
pointToSplit
.
Clear
(
)
;
nsIContent
*
previousNodeOfSplitPoint
=
splitCiteNodeResult
.
GetPreviousNode
(
)
;
if
(
previousNodeOfSplitPoint
&
&
previousNodeOfSplitPoint
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
nsCOMPtr
<
nsINode
>
lastChild
=
previousNodeOfSplitPoint
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorRawDOMPoint
endOfPreviousNodeOfSplitPoint
;
endOfPreviousNodeOfSplitPoint
.
SetToEndOf
(
previousNodeOfSplitPoint
)
;
RefPtr
<
Element
>
invisibleBrElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
endOfPreviousNodeOfSplitPoint
)
;
NS_WARNING_ASSERTION
(
invisibleBrElement
"
Failed
to
create
an
invisible
<
br
>
element
"
)
;
}
}
EditorRawDOMPoint
pointToInsertBrNode
(
splitCiteNodeResult
.
SplitPoint
(
)
)
;
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pointToInsertBrNode
.
Clear
(
)
;
EditorDOMPoint
atBrNode
(
brElement
)
;
Unused
<
<
atBrNode
.
Offset
(
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
IsInlineNode
(
*
citeNode
)
)
{
EditorRawDOMPoint
pointToCreateNewBrNode
(
atBrNode
.
GetContainer
(
)
atBrNode
.
Offset
(
)
)
;
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
pointToCreateNewBrNode
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
pointToCreateNewBrNode
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
)
{
EditorRawDOMPoint
pointAfterNewBrNode
(
pointToCreateNewBrNode
)
;
DebugOnly
<
bool
>
advanced
=
pointAfterNewBrNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
<
br
>
node
"
)
;
WSRunObject
wsObjAfterBR
(
&
HTMLEditorRef
(
)
pointAfterNewBrNode
)
;
wsObjAfterBR
.
NextVisibleNode
(
pointAfterNewBrNode
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
thisBlock
)
{
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToCreateNewBrNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
pointToCreateNewBrNode
.
Clear
(
)
;
pointAfterNewBrNode
.
Clear
(
)
;
}
}
}
bool
bEmptyCite
=
false
;
if
(
previousNodeOfSplitPoint
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
previousNodeOfSplitPoint
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
previousNodeOfSplitPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
citeNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
citeNode
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aHandled
=
true
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillDeleteSelection
(
nsIEditor
:
:
EDirection
aAction
nsIEditor
:
:
EStripWrappers
aStripWrappers
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
mDidDeleteSelection
=
true
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
RefPtr
<
Element
>
cell
;
nsresult
rv
=
HTMLEditorRef
(
)
.
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteTableCellContents
(
)
;
*
aHandled
=
true
;
return
rv
;
}
cell
=
nullptr
;
bool
bCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
bool
join
=
false
;
bool
origCollapsed
=
bCollapsed
;
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
startOffset
=
firstRange
-
>
StartOffset
(
)
;
if
(
bCollapsed
)
{
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
CheckForEmptyBlock
(
startNode
host
aAction
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aHandled
)
{
return
NS_OK
;
}
rv
=
CheckBidiLevelForDeletion
(
EditorRawDOMPoint
(
startNode
startOffset
)
aAction
aCancel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
*
aCancel
)
{
return
NS_OK
;
}
rv
=
HTMLEditorRef
(
)
.
ExtendSelectionForDelete
(
&
SelectionRef
(
)
&
aAction
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aAction
=
=
nsIEditor
:
:
eNone
)
{
return
NS_OK
;
}
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startOffset
=
firstRange
-
>
StartOffset
(
)
;
bCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
}
if
(
bCollapsed
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
startNode
startOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
;
WSType
wsType
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
else
{
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
if
(
!
visNode
)
{
*
aCancel
=
true
;
return
rv
;
}
if
(
wsType
=
=
WSType
:
:
normalWS
)
{
*
aHandled
=
true
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
rv
=
wsObj
.
DeleteWSForward
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
wsObj
.
DeleteWSBackward
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
text
)
{
OwningNonNull
<
Text
>
nodeAsText
=
*
visNode
-
>
GetAsText
(
)
;
int32_t
so
=
visOffset
;
int32_t
eo
=
visOffset
+
1
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
!
so
)
{
return
NS_ERROR_UNEXPECTED
;
}
so
-
-
;
eo
-
-
;
if
(
so
>
0
)
{
const
nsTextFragment
*
text
=
nodeAsText
-
>
GetText
(
)
;
if
(
NS_IS_LOW_SURROGATE
(
text
-
>
CharAt
(
so
)
)
&
&
NS_IS_HIGH_SURROGATE
(
text
-
>
CharAt
(
so
-
1
)
)
)
{
so
-
-
;
}
}
}
else
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
range
-
>
GetStartContainer
(
)
=
=
visNode
"
selection
start
not
in
visNode
"
)
;
NS_ASSERTION
(
range
-
>
GetEndContainer
(
)
=
=
visNode
"
selection
end
not
in
visNode
"
)
;
so
=
range
-
>
StartOffset
(
)
;
eo
=
range
-
>
EndOffset
(
)
;
}
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
&
HTMLEditorRef
(
)
address_of
(
visNode
)
&
so
address_of
(
visNode
)
&
eo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
nodeAsText
std
:
:
min
(
so
eo
)
DeprecatedAbs
(
eo
-
so
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
DeleteNodeIfCollapsedText
(
nodeAsText
)
;
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mDidRangedDelete
=
true
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
visNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
visNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
WillDeleteSelection
(
aAction
aStripWrappers
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
&
&
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
bool
moveOnly
=
true
;
selNode
=
visNode
-
>
GetParentNode
(
)
;
selOffset
=
selNode
?
selNode
-
>
ComputeIndexOf
(
visNode
)
:
-
1
;
ErrorResult
err
;
bool
interLineIsRight
=
SelectionRef
(
)
.
GetInterlinePosition
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
if
(
startNode
=
=
selNode
&
&
startOffset
-
1
=
=
selOffset
&
&
!
interLineIsRight
)
{
moveOnly
=
false
;
}
if
(
moveOnly
)
{
+
+
selOffset
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
selNode
selOffset
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
after
the
<
hr
>
"
)
;
(
ErrorResult
&
)
ignoredError
=
NS_OK
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
mDidExplicitlySetInterline
=
true
;
*
aHandled
=
true
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
if
(
otherWSType
=
=
WSType
:
:
br
)
{
if
(
NS_WARN_IF
(
!
otherNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
otherContent
=
otherNode
-
>
AsContent
(
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
&
HTMLEditorRef
(
)
otherContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
otherContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
}
if
(
NS_WARN_IF
(
!
visNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
&
HTMLEditorRef
(
)
visNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
visNode
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
visNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
nsCOMPtr
<
nsINode
>
stepbrother
;
if
(
sibling
)
{
stepbrother
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
sibling
)
;
}
if
(
startNode
=
=
stepbrother
&
&
startNode
-
>
GetAsText
(
)
&
&
sibling
-
>
GetAsText
(
)
)
{
EditorDOMPoint
pt
=
JoinNearestEditableNodesWithTransaction
(
*
sibling
*
startNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
rv
=
InsertBRIfNeeded
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
otherBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
bool
bDeletedBR
=
false
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
else
{
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
nsCOMPtr
<
nsIContent
>
leafNode
;
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
leafNode
=
HTMLEditorRef
(
)
.
GetLastEditableLeaf
(
*
visNode
)
;
leftNode
=
leafNode
;
rightNode
=
startNode
;
}
else
{
leafNode
=
HTMLEditorRef
(
)
.
GetFirstEditableLeaf
(
*
visNode
)
;
leftNode
=
startNode
;
rightNode
=
leafNode
;
}
if
(
otherNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
otherNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
bDeletedBR
=
true
;
}
if
(
leftNode
&
&
rightNode
&
&
InDifferentTableElements
(
leftNode
rightNode
)
)
{
return
NS_OK
;
}
if
(
bDeletedBR
)
{
if
(
NS_WARN_IF
(
!
leafNode
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
newSel
=
GetGoodSelPointForNode
(
*
leafNode
aAction
)
;
if
(
NS_WARN_IF
(
!
newSel
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
newSel
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
edge
of
the
block
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
leftNode
)
|
|
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
|
=
ret
.
Handled
(
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
if
(
!
*
aHandled
&
&
!
*
aCancel
&
&
leafNode
!
=
startNode
)
{
int32_t
offset
=
aAction
=
=
nsIEditor
:
:
ePrevious
?
static_cast
<
int32_t
>
(
leafNode
-
>
Length
(
)
)
:
0
;
rv
=
SelectionRef
(
)
.
Collapse
(
leafNode
offset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
at
the
leaf
node
"
)
;
rv
=
WillDeleteSelection
(
aAction
aStripWrappers
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
SelectionRef
(
)
.
Collapse
(
selPointNode
selPointOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
selection
at
deleted
point
"
)
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
leftNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
*
visNode
)
;
rightNode
=
startNode
;
}
else
{
rightNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
*
visNode
)
;
leftNode
=
startNode
;
}
if
(
!
leftNode
|
|
!
rightNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
if
(
InDifferentTableElements
(
leftNode
rightNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
if
(
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
=
true
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
rv
=
SelectionRef
(
)
.
Collapse
(
selPointNode
selPointOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
return
NS_OK
;
}
}
rv
=
ExpandSelectionForDeletion
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mDidRangedDelete
=
true
;
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
startNode
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startOffset
=
firstRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
firstRange
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
endOffset
=
firstRange
-
>
EndOffset
(
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
&
HTMLEditorRef
(
)
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
{
AutoTrackDOMPoint
startTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
*
aHandled
=
true
;
if
(
endNode
=
=
startNode
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsCOMPtr
<
Element
>
startCiteNode
=
GetTopEnclosingMailCite
(
*
startNode
)
;
nsCOMPtr
<
Element
>
endCiteNode
=
GetTopEnclosingMailCite
(
*
endNode
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aAction
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aAction
=
nsIEditor
:
:
ePrevious
;
}
nsCOMPtr
<
Element
>
leftParent
=
HTMLEditor
:
:
GetBlock
(
*
startNode
)
;
nsCOMPtr
<
Element
>
rightParent
=
HTMLEditor
:
:
GetBlock
(
*
endNode
)
;
if
(
leftParent
&
&
leftParent
=
=
rightParent
)
{
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
}
else
{
if
(
NS_WARN_IF
(
!
leftParent
)
|
|
NS_WARN_IF
(
!
rightParent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
leftBlockParent
=
leftParent
-
>
GetParentNode
(
)
;
nsCOMPtr
<
nsINode
>
rightBlockParent
=
rightParent
-
>
GetParentNode
(
)
;
if
(
leftBlockParent
=
=
rightBlockParent
&
&
HTMLEditorRef
(
)
.
AreNodesSameType
(
leftParent
rightParent
)
&
&
(
leftParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
leftParent
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
leftParent
)
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EditorDOMPoint
pt
=
HTMLEditorRef
(
)
.
JoinNodesDeepWithTransaction
(
*
leftParent
*
rightParent
)
;
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
join
=
true
;
AutoRangeArray
arrayOfRanges
(
&
SelectionRef
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
.
AppendList
(
functor
arrayOfNodes
)
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
j
=
0
;
j
<
listCount
;
j
+
+
)
{
nsCOMPtr
<
nsINode
>
somenode
=
do_QueryInterface
(
arrayOfNodes
[
0
]
)
;
if
(
NS_WARN_IF
(
!
somenode
)
)
{
return
NS_ERROR_FAILURE
;
}
DeleteNonTableElements
(
somenode
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
if
(
join
&
&
origCollapsed
)
{
if
(
!
somenode
-
>
IsContent
(
)
)
{
join
=
false
;
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
somenode
-
>
AsContent
(
)
;
if
(
Text
*
text
=
content
-
>
GetAsText
(
)
)
{
join
=
!
HTMLEditorRef
(
)
.
IsInVisibleTextFrames
(
*
text
)
;
}
else
{
join
=
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
somenode
)
;
}
}
}
}
if
(
startNode
-
>
GetAsText
(
)
&
&
startNode
-
>
Length
(
)
>
static_cast
<
uint32_t
>
(
startOffset
)
)
{
OwningNonNull
<
CharacterData
>
dataNode
=
*
static_cast
<
CharacterData
*
>
(
startNode
.
get
(
)
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
dataNode
startOffset
startNode
-
>
Length
(
)
-
startOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
endNode
-
>
GetAsText
(
)
&
&
endOffset
)
{
OwningNonNull
<
CharacterData
>
dataNode
=
*
static_cast
<
CharacterData
*
>
(
endNode
.
get
(
)
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteTextWithTransaction
(
dataNode
0
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
join
)
{
EditActionResult
ret
=
TryToJoinBlocksWithTransaction
(
*
leftParent
*
rightParent
)
;
MOZ_ASSERT
(
*
aHandled
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
}
}
}
{
AutoTrackDOMPoint
startTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
DeleteNodeIfCollapsedText
(
*
startNode
)
;
DeleteNodeIfCollapsedText
(
*
endNode
)
;
}
if
(
aAction
=
=
(
join
?
nsIEditor
:
:
eNext
:
nsIEditor
:
:
ePrevious
)
)
{
rv
=
SelectionRef
(
)
.
Collapse
(
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
SelectionRef
(
)
.
Collapse
(
startNode
startOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
DeleteNodeIfCollapsedText
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
Text
*
text
=
aNode
.
GetAsText
(
)
;
if
(
!
text
)
{
return
;
}
if
(
!
HTMLEditorRef
(
)
.
IsVisibleTextNode
(
*
text
)
)
{
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
aNode
"
)
;
}
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeeded
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsBlockNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
NS_OK
;
}
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
atStartOfSelection
)
;
if
(
(
(
wsObj
.
mStartReason
&
WSType
:
:
block
)
|
|
(
wsObj
.
mStartReason
&
WSType
:
:
br
)
)
&
&
(
wsObj
.
mEndReason
&
WSType
:
:
block
)
)
{
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atStartOfSelection
nsIEditor
:
:
ePrevious
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetGoodSelPointForNode
(
nsINode
&
aNode
nsIEditor
:
:
EDirection
aAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAction
=
=
nsIEditor
:
:
eNext
|
|
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
;
bool
isPreviousAction
=
(
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
)
;
if
(
aNode
.
GetAsText
(
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
&
aNode
)
|
|
NS_WARN_IF
(
!
aNode
.
GetParentNode
(
)
)
)
{
return
EditorDOMPoint
(
&
aNode
isPreviousAction
?
aNode
.
Length
(
)
:
0
)
;
}
if
(
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
ret
(
&
aNode
)
;
if
(
(
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
&
aNode
)
)
&
&
isPreviousAction
)
{
ret
.
AdvanceOffset
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
TryToJoinBlocksWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
RefPtr
<
Element
>
leftBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
aLeftNode
)
;
RefPtr
<
Element
>
rightBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
aRightNode
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
|
|
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
if
(
NS_WARN_IF
(
leftBlock
=
=
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
leftBlock
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
rightBlock
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
leftBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
leftBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
leftBlock
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
rightBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
rightBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
rightBlock
)
;
if
(
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
leftBlock
=
=
rightBlock
)
{
return
EditActionIgnored
(
)
;
}
if
(
HTMLEditUtils
:
:
IsList
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
&
&
rightBlock
-
>
GetParentNode
(
)
=
=
leftBlock
)
{
return
EditActionHandled
(
)
;
}
bool
mergeLists
=
false
;
nsAtom
*
existingList
=
nsGkAtoms
:
:
_empty
;
EditorDOMPoint
atChildInBlock
;
nsCOMPtr
<
Element
>
leftList
rightList
;
if
(
HTMLEditUtils
:
:
IsListItem
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
)
{
leftList
=
leftBlock
-
>
GetParentElement
(
)
;
rightList
=
rightBlock
-
>
GetParentElement
(
)
;
if
(
leftList
&
&
rightList
&
&
leftList
!
=
rightList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftList
*
rightBlock
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightList
*
leftBlock
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
leftBlock
=
leftList
;
rightBlock
=
rightList
;
mergeLists
=
true
;
existingList
=
leftList
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
EditorDOMPoint
atRightBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
leftBlock
*
rightBlock
&
atRightBlockChild
)
)
{
DebugOnly
<
bool
>
advanced
=
atRightBlockChild
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
child
of
rightBlock
"
"
leftBlock
is
a
descendant
of
the
child
"
)
;
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBlockEnd
leftBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
atRightBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kAfterBlock
atRightBlockChild
.
GetContainer
(
)
atRightBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
rightBlock
=
=
atRightBlockChild
.
GetContainer
(
)
)
;
if
(
atRightBlockChild
.
GetContainerAsElement
(
)
)
{
rightBlock
=
atRightBlockChild
.
GetContainerAsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
atRightBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
rightBlock
=
atRightBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
;
}
}
RefPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
NS_WARN_IF
(
mergeLists
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
EditActionResult
retMoveBlock
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
atRightBlockChild
.
Offset
(
)
)
;
if
(
retMoveBlock
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
atRightBlockChild
.
Clear
(
)
;
}
if
(
brNode
&
&
NS_SUCCEEDED
(
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
EditorDOMPoint
leftBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rightBlock
*
leftBlock
&
leftBlockChild
)
)
{
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBlockStart
rightBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
HTMLEditorRef
(
)
.
mRangeUpdater
&
leftBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
&
HTMLEditorRef
(
)
WSRunObject
:
:
kBeforeBlock
leftBlock
leftBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
leftBlock
=
=
leftBlockChild
.
GetContainer
(
)
)
;
if
(
leftBlockChild
.
GetContainerAsElement
(
)
)
{
leftBlock
=
leftBlockChild
.
GetContainerAsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
leftBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
leftBlock
=
leftBlockChild
.
GetContainer
(
)
-
>
GetParentElement
(
)
;
}
}
RefPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
beforeBlock
leftBlockChild
.
Offset
(
)
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
)
{
int32_t
offset
=
leftBlockChild
.
Offset
(
)
;
EditActionResult
retMoveContents
=
MoveContents
(
*
rightList
*
leftList
&
offset
)
;
if
(
retMoveContents
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
leftBlockChild
.
Clear
(
)
;
}
else
{
EditorDOMPoint
previousContent
;
if
(
&
aLeftNode
=
=
leftBlock
)
{
previousContent
=
leftBlockChild
;
}
else
{
previousContent
.
Set
(
&
aLeftNode
)
;
previousContent
.
AdvanceOffset
(
)
;
}
RefPtr
<
Element
>
editorRoot
=
HTMLEditorRef
(
)
.
GetEditorRoot
(
)
;
if
(
!
editorRoot
|
|
&
aLeftNode
!
=
editorRoot
)
{
nsCOMPtr
<
nsIContent
>
splittedPreviousContent
;
nsCOMPtr
<
nsINode
>
previousContentParent
=
previousContent
.
GetContainer
(
)
;
int32_t
previousContentOffset
=
previousContent
.
Offset
(
)
;
rv
=
HTMLEditorRef
(
)
.
SplitStyleAbovePoint
(
address_of
(
previousContentParent
)
&
previousContentOffset
nullptr
nullptr
nullptr
getter_AddRefs
(
splittedPreviousContent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
splittedPreviousContent
)
{
previousContent
.
Set
(
splittedPreviousContent
)
;
}
else
{
previousContent
.
Set
(
previousContentParent
previousContentOffset
)
;
}
}
if
(
NS_WARN_IF
(
!
previousContent
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
ret
|
=
MoveBlock
(
*
previousContent
.
GetContainerAsElement
(
)
*
rightBlock
previousContent
.
Offset
(
)
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
&
&
NS_SUCCEEDED
(
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
leftBlockChild
.
IsSet
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToJoinBlocks
(
&
HTMLEditorRef
(
)
leftBlock
rightBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
nsCOMPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
|
|
leftBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
rightBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
EditorDOMPoint
pt
=
JoinNearestEditableNodesWithTransaction
(
*
leftBlock
*
rightBlock
)
;
if
(
pt
.
IsSet
(
)
&
&
mergeLists
)
{
RefPtr
<
Element
>
newBlock
=
ConvertListType
(
rightBlock
existingList
nsGkAtoms
:
:
li
)
;
}
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveBlock
(
Element
&
aLeftBlock
Element
&
aRightBlock
int32_t
aLeftOffset
int32_t
aRightOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromPoint
(
EditorDOMPoint
(
&
aRightBlock
aRightOffset
)
EditAction
:
:
makeList
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
EditActionResult
ret
(
NS_OK
)
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
IsBlockNode
(
arrayOfNodes
[
i
]
)
)
{
ret
|
=
MoveContents
(
*
arrayOfNodes
[
i
]
-
>
AsElement
(
)
aLeftBlock
&
aLeftOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
arrayOfNodes
[
i
]
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
a
block
node
"
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveNodeSmart
(
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
aLeftBlock
&
aLeftOffset
)
;
}
}
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveNodeSmart
(
nsIContent
&
aNode
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
HTMLEditorRef
(
)
.
CanContain
(
aDestElement
aNode
)
)
{
if
(
*
aInOutDestOffset
=
=
-
1
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
aNode
aDestElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
else
{
EditorRawDOMPoint
pointToInsert
(
&
aDestElement
*
aInOutDestOffset
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
if
(
*
aInOutDestOffset
!
=
-
1
)
{
(
*
aInOutDestOffset
)
+
+
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
ret
(
NS_OK
)
;
if
(
aNode
.
IsElement
(
)
)
{
ret
=
MoveContents
(
*
aNode
.
AsElement
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
return
ret
.
MarkAsHandled
(
)
;
}
EditActionResult
HTMLEditRules
:
:
MoveContents
(
Element
&
aElement
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
&
aDestElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_ILLEGAL_VALUE
)
;
}
EditActionResult
ret
(
NS_OK
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
ret
|
=
MoveNodeSmart
(
*
aElement
.
GetFirstChild
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
DeleteNonTableElements
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
if
(
!
HTMLEditUtils
:
:
IsTableElementButNotTable
(
aNode
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteNonTableElements
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidDeleteSelection
(
nsIEditor
:
:
EDirection
aDir
nsresult
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
citeNode
=
GetTopEnclosingMailCite
(
*
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
citeNode
)
{
bool
isEmpty
=
true
seenBR
=
false
;
HTMLEditorRef
(
)
.
IsEmptyNodeImpl
(
citeNode
&
isEmpty
true
true
false
&
seenBR
)
;
if
(
isEmpty
)
{
EditorDOMPoint
atCiteNode
(
citeNode
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atCiteNode
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
atCiteNode
.
IsSet
(
)
&
&
seenBR
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atCiteNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
brElement
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
new
<
br
>
element
"
)
;
}
}
}
return
TextEditRules
:
:
DidDeleteSelection
(
aDir
aResult
)
;
}
nsresult
HTMLEditRules
:
:
WillMakeList
(
const
nsAString
*
aListType
bool
aEntireList
const
nsAString
*
aBulletType
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aItemType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aListType
)
|
|
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
OwningNonNull
<
nsAtom
>
listType
=
NS_Atomize
(
*
aListType
)
;
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
RefPtr
<
nsAtom
>
itemType
;
if
(
aItemType
)
{
itemType
=
NS_Atomize
(
*
aItemType
)
;
}
else
if
(
listType
=
=
nsGkAtoms
:
:
dl
)
{
itemType
=
nsGkAtoms
:
:
dd
;
}
else
{
itemType
=
nsGkAtoms
:
:
li
;
}
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetListActionNodes
(
arrayOfNodes
aEntireList
?
EntireList
:
:
yes
:
EntireList
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
bOnlyBreaks
=
true
;
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
TextEditUtils
:
:
IsBreak
(
curNode
)
&
&
!
IsEmptyInline
(
curNode
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
node
:
arrayOfNodes
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
node
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
listType
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
SplitNodeResult
splitAtSelectionStartResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
listType
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitAtSelectionStartResult
.
Failed
(
)
)
)
{
return
splitAtSelectionStartResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
listType
splitAtSelectionStartResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
theList
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atFirstListItemToInsertBefore
(
theList
0
)
;
RefPtr
<
Element
>
theListItem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
itemType
atFirstListItemToInsertBefore
)
;
if
(
NS_WARN_IF
(
!
theListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theListItem
;
*
aHandled
=
true
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
theListItem
0
)
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
LookInsideDivBQandList
(
arrayOfNodes
)
;
uint32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
nsCOMPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
RefPtr
<
Element
>
newBlock
;
if
(
NS_WARN_IF
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
if
(
curList
&
&
InDifferentTableElements
(
curList
curNode
)
)
{
curList
=
nullptr
;
}
if
(
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
&
&
(
TextEditUtils
:
:
IsBreak
(
curNode
)
|
|
IsEmptyInline
(
curNode
)
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
TextEditUtils
:
:
IsBreak
(
curNode
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
newBlock
=
ConvertListType
(
curNode
-
>
AsElement
(
)
listType
itemType
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
newBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
curList
=
ConvertListType
(
curNode
-
>
AsElement
(
)
listType
itemType
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
prevListItem
=
nullptr
;
continue
;
}
EditorRawDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCurNode
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
!
atCurNode
.
IsContainerHTMLElement
(
listType
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atCurNode
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atCurNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
newBlock
=
newLeftNode
?
newLeftNode
-
>
AsElement
(
)
:
nullptr
;
EditorRawDOMPoint
atParentOfCurNode
(
atCurNode
.
GetContainer
(
)
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
listType
atParentOfCurNode
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
curNode
-
>
IsHTMLElement
(
itemType
)
)
{
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
*
itemType
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
else
{
if
(
!
curList
)
{
curList
=
atCurNode
.
GetContainerAsElement
(
)
;
}
else
if
(
atCurNode
.
GetContainer
(
)
!
=
curList
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
!
curNode
-
>
IsHTMLElement
(
itemType
)
)
{
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
*
itemType
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
nsCOMPtr
<
Element
>
curElement
=
do_QueryInterface
(
curNode
)
;
if
(
NS_WARN_IF
(
!
curElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aBulletType
&
&
!
aBulletType
-
>
IsEmpty
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
SetAttributeWithTransaction
(
*
curElement
*
nsGkAtoms
:
:
type
*
aBulletType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
*
curElement
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
int32_t
j
=
i
+
1
;
GetInnerContent
(
*
curNode
arrayOfNodes
&
j
)
;
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
listCount
=
arrayOfNodes
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
SplitNodeResult
splitCurNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
listType
atCurNode
)
;
if
(
NS_WARN_IF
(
splitCurNodeResult
.
Failed
(
)
)
)
{
return
splitCurNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
listType
splitCurNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
prevListItem
=
nullptr
;
atCurNode
.
Clear
(
)
;
}
nsCOMPtr
<
Element
>
listItem
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
IsInlineNode
(
curNode
)
&
&
prevListItem
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
*
prevListItem
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
listItem
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
*
itemType
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
listItem
=
HTMLEditorRef
(
)
.
InsertContainerWithTransaction
(
*
curNode
*
itemType
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
IsInlineNode
(
curNode
)
)
{
prevListItem
=
listItem
;
}
else
{
prevListItem
=
nullptr
;
}
}
}
else
{
listItem
=
curNode
-
>
AsElement
(
)
;
}
if
(
listItem
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRemoveList
(
bool
aOrdered
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditAction
:
:
makeList
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
arrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
arrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
bool
bOutOfList
;
do
{
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
&
bOutOfList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
while
(
!
bOutOfList
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
RemoveListStructure
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeDefListItem
(
const
nsAString
*
aItemType
bool
aEntireList
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_NAMED_LITERAL_STRING
(
listType
"
dl
"
)
;
nsresult
rv
=
WillMakeList
(
&
listType
.
AsString
(
)
aEntireList
nullptr
aCancel
aHandled
aItemType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeBasicBlock
(
const
nsAString
&
aBlockType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
OwningNonNull
<
nsAtom
>
blockType
=
NS_Atomize
(
aBlockType
)
;
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
MakeBasicBlock
(
blockType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeBasicBlock
(
nsAtom
&
blockType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesFromSelection
(
EditAction
:
:
makeBasicBlock
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
firstRange
-
>
StartRef
(
)
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
RefPtr
<
Element
>
curBlock
=
HTMLEditorRef
(
)
.
GetBlock
(
*
pointToInsertBlock
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
pointToInsertBlock
)
;
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
curBlock
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
EditorRawDOMPoint
pointToInsertBrNode
(
splitNodeResult
.
SplitPoint
(
)
)
;
brContent
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
!
brContent
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atBrNode
(
brContent
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
pointToInsertBlock
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElement
(
brNode
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
blockType
pointToInsertBlock
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
blockType
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
block
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
block
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
rv
=
SelectionRef
(
)
.
Collapse
(
block
0
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
rv
=
MakeBlockquote
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
rv
=
RemoveBlockStyle
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
ApplyBlockStyle
(
arrayOfNodes
blockType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidMakeBasicBlock
(
RulesInfo
*
aInfo
nsresult
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InsertMozBRIfNeeded
(
*
atStartOfSelection
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
nsresult
rv
=
WillCSSIndent
(
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
WillHTMLIndent
(
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillCSSIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsRange
>
>
arrayOfRanges
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsCOMPtr
<
Element
>
liNode
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
selectionStartPoint
.
GetContainer
(
)
)
;
if
(
block
&
&
HTMLEditUtils
:
:
IsListItem
(
block
)
)
{
liNode
=
block
;
}
}
if
(
liNode
)
{
arrayOfNodes
.
AppendElement
(
*
liNode
)
;
}
else
{
rv
=
GetNodesFromSelection
(
EditAction
:
:
indent
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
ChangeIndentation
(
*
theBlock
Change
:
:
plus
)
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfTheBlock
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curQuote
;
nsCOMPtr
<
nsIContent
>
sibling
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
curNode
-
>
AsContent
(
)
EditorRawDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
sibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
IsBlockNode
(
*
curNode
)
)
{
ChangeIndentation
(
*
curNode
-
>
AsElement
(
)
Change
:
:
plus
)
;
curQuote
=
nullptr
;
continue
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
ChangeIndentation
(
*
curQuote
Change
:
:
plus
)
;
mNewBlock
=
curQuote
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillHTMLIndent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditAction
:
:
indent
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
indent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfTheBlock
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
nsCOMPtr
<
Element
>
curList
curQuote
indentedLI
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
curNode
-
>
AsContent
(
)
EditorRawDOMPoint
(
sibling
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
sibling
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curList
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curQuote
=
nullptr
;
continue
;
}
RefPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
listItem
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
curQuote
&
&
InDifferentTableElements
(
curQuote
curNode
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curQuote
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillOutdent
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsCOMPtr
<
nsIContent
>
rememberedLeftBQ
rememberedRightBQ
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
{
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesFromSelection
(
EditAction
:
:
outdent
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
Element
>
curBlockQuote
;
nsCOMPtr
<
nsIContent
>
firstBQChild
lastBQChild
;
bool
curBlockQuoteIsIndentedWithCSS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
{
continue
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
useCSS
&
&
IsBlockNode
(
curNode
)
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curNode
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
curNode
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
)
{
ChangeIndentation
(
*
curNode
-
>
AsElement
(
)
Change
:
:
minus
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
if
(
curBlockQuote
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlockQuote
)
)
{
lastBQChild
=
curNode
;
continue
;
}
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
OwningNonNull
<
nsINode
>
n
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
false
;
while
(
!
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
n
)
&
&
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
n
)
)
)
{
if
(
!
n
-
>
GetParentNode
(
)
)
{
break
;
}
n
=
*
n
-
>
GetParentNode
(
)
;
if
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
break
;
}
else
if
(
useCSS
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curNode
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
n
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
&
&
!
(
HTMLEditUtils
:
:
IsList
(
curParent
)
&
&
HTMLEditUtils
:
:
IsList
(
curNode
)
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
true
;
break
;
}
}
}
if
(
!
curBlockQuote
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetLastChild
(
)
;
while
(
child
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
rv
=
PopListItem
(
*
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
EditorRawDOMPoint
afterCurrentList
(
curParent
offset
+
1
)
;
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
child
afterCurrentList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
child
=
curNode
-
>
GetLastChild
(
)
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
useCSS
)
{
nsCOMPtr
<
Element
>
element
;
if
(
curNode
-
>
GetAsText
(
)
)
{
element
=
curNode
-
>
GetParentElement
(
)
;
}
else
if
(
curNode
-
>
IsElement
(
)
)
{
element
=
curNode
-
>
AsElement
(
)
;
}
if
(
element
)
{
ChangeIndentation
(
*
element
Change
:
:
minus
)
;
}
}
}
}
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
!
rememberedLeftBQ
&
&
!
rememberedRightBQ
)
{
return
NS_OK
;
}
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
rememberedLeftBQ
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_OK
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
rememberedLeftBQ
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
rememberedLeftBQ
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
rememberedLeftBQ
)
;
afterRememberedLeftBQ
.
AdvanceOffset
(
)
;
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterRememberedLeftBQ
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
the
left
<
blockquote
>
"
)
;
}
}
if
(
rememberedRightBQ
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
rememberedRightBQ
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
rememberedRightBQ
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
rememberedRightBQ
)
;
IgnoredErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atRememberedRightBQ
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
the
right
<
blockquote
>
"
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemovePartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
SplitBlock
(
aBlock
aStartChild
aEndChild
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
aBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
SplitBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
nsIContent
*
*
aOutMiddleNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartChild
aBlock
)
&
&
EditorUtils
:
:
IsDescendantOf
(
aEndChild
aBlock
)
)
;
SplitNodeResult
splitAtStartResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aBlock
EditorRawDOMPoint
(
&
aStartChild
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitAtStartResult
.
Succeeded
(
)
"
Failed
to
split
aBlock
at
start
"
)
;
EditorRawDOMPoint
atAfterEnd
(
&
aEndChild
)
;
DebugOnly
<
bool
>
advanced
=
atAfterEnd
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
end
node
"
)
;
SplitNodeResult
splitAtEndResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aBlock
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitAtEndResult
.
Succeeded
(
)
"
Failed
to
split
aBlock
at
after
end
"
)
;
if
(
aOutLeftNode
)
{
NS_IF_ADDREF
(
*
aOutLeftNode
=
splitAtStartResult
.
GetPreviousNode
(
)
)
;
}
if
(
aOutRightNode
)
{
NS_IF_ADDREF
(
*
aOutRightNode
=
splitAtEndResult
.
GetNextNode
(
)
)
;
}
if
(
aOutMiddleNode
)
{
if
(
splitAtEndResult
.
GetPreviousNode
(
)
)
{
NS_IF_ADDREF
(
*
aOutMiddleNode
=
splitAtEndResult
.
GetPreviousNode
(
)
)
;
}
else
{
NS_IF_ADDREF
(
*
aOutMiddleNode
=
splitAtStartResult
.
GetNextNode
(
)
)
;
}
}
}
nsresult
HTMLEditRules
:
:
OutdentPartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
bool
aIsBlockIndentedWithCSS
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutLeftNode
&
&
aOutRightNode
)
;
nsCOMPtr
<
nsIContent
>
middleNode
;
SplitBlock
(
aBlock
aStartChild
aEndChild
aOutLeftNode
aOutRightNode
getter_AddRefs
(
middleNode
)
)
;
if
(
NS_WARN_IF
(
!
middleNode
)
|
|
NS_WARN_IF
(
!
middleNode
-
>
IsElement
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
aIsBlockIndentedWithCSS
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
middleNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
middleNode
-
>
IsElement
(
)
)
{
nsresult
rv
=
ChangeIndentation
(
*
middleNode
-
>
AsElement
(
)
Change
:
:
minus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditRules
:
:
ConvertListType
(
Element
*
aList
nsAtom
*
aListType
nsAtom
*
aItemType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aList
)
;
MOZ_ASSERT
(
aListType
)
;
MOZ_ASSERT
(
aItemType
)
;
nsCOMPtr
<
nsINode
>
child
=
aList
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
)
{
Element
*
element
=
child
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
aItemType
)
)
{
child
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
element
*
aItemType
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
aListType
)
)
{
child
=
ConvertListType
(
child
-
>
AsElement
(
)
aListType
aItemType
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
}
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
aList
-
>
IsHTMLElement
(
aListType
)
)
{
RefPtr
<
dom
:
:
Element
>
list
=
aList
;
return
list
.
forget
(
)
;
}
RefPtr
<
Element
>
listElement
=
HTMLEditorRef
(
)
.
ReplaceContainerWithTransaction
(
*
aList
*
aListType
)
;
NS_WARNING_ASSERTION
(
listElement
!
=
nullptr
"
Failed
to
create
list
element
"
)
;
return
listElement
.
forget
(
)
;
}
nsresult
HTMLEditRules
:
:
CreateStyleForInsertText
(
nsIDocument
&
aDoc
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditorRef
(
)
.
mTypeInState
)
;
bool
weDidSomething
=
false
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
node
=
firstRange
-
>
GetStartContainer
(
)
;
int32_t
offset
=
firstRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
Element
>
rootElement
=
aDoc
.
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
PropItem
>
item
=
Move
(
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeClearProperty
(
)
)
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
while
(
item
&
&
node
!
=
rootElement
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
ClearStyle
(
address_of
(
node
)
&
offset
item
-
>
tag
item
-
>
attr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
Move
(
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeClearProperty
(
)
)
;
weDidSomething
=
true
;
}
}
int32_t
relFontSize
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
Move
(
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeSetProperty
(
)
)
;
if
(
item
|
|
relFontSize
)
{
if
(
RefPtr
<
Text
>
text
=
node
-
>
GetAsText
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
text
EditorRawDOMPoint
(
text
offset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitTextNodeResult
.
Failed
(
)
)
)
{
return
splitTextNodeResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPoint
(
splitTextNodeResult
.
SplitPoint
(
)
)
;
node
=
splitPoint
.
GetContainer
(
)
;
offset
=
splitPoint
.
Offset
(
)
;
}
if
(
!
HTMLEditorRef
(
)
.
IsContainer
(
node
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Text
>
newNode
=
EditorBase
:
:
CreateTextNode
(
aDoc
EmptyString
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
InsertNodeWithTransaction
(
*
newNode
EditorRawDOMPoint
(
node
offset
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
node
=
newNode
;
offset
=
0
;
weDidSomething
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
rv
=
HTMLEditorRef
(
)
.
RelativeFontChangeOnTextNode
(
dir
newNode
0
-
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
while
(
item
)
{
rv
=
HTMLEditorRef
(
)
.
SetInlinePropertyOnNode
(
*
node
-
>
AsContent
(
)
*
item
-
>
tag
item
-
>
attr
item
-
>
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
HTMLEditorRef
(
)
.
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
!
weDidSomething
)
{
return
NS_OK
;
}
nsresult
rv
=
SelectionRef
(
)
.
Collapse
(
node
offset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsBlockNode
(
aElement
)
)
)
{
return
false
;
}
bool
isEmpty
=
true
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aElement
&
isEmpty
aIgnoreSingleBR
=
=
IgnoreSingleBR
:
:
eYes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
isEmpty
;
}
nsresult
HTMLEditRules
:
:
WillAlign
(
const
nsAString
&
aAlignType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
*
aHandled
=
true
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
rv
=
GetNodesFromSelection
(
EditAction
:
:
align
nodeArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
emptyDiv
=
nodeArray
.
IsEmpty
(
)
;
if
(
nodeArray
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsINode
>
node
=
nodeArray
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
node
)
)
{
rv
=
AlignBlock
(
*
node
-
>
AsElement
(
)
aAlignType
ContentsOnly
:
:
yes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
atStartOfSelection
.
Container
(
)
;
emptyDiv
=
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
emptyDiv
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
splitNodeResult
.
SplitPoint
(
)
)
;
EditorDOMPoint
pointToInsertDiv
(
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
brContent
&
&
TextEditUtils
:
:
IsBreak
(
brContent
)
)
{
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
pointToInsertDiv
.
GetChild
(
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
pointToInsertDiv
.
GetChild
(
)
)
;
}
if
(
sibling
&
&
!
IsBlockNode
(
*
sibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertDiv
)
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
RefPtr
<
Element
>
div
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
pointToInsertDiv
)
;
if
(
NS_WARN_IF
(
!
div
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
div
;
rv
=
AlignBlock
(
*
div
aAlignType
ContentsOnly
:
:
yes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
EditorRawDOMPoint
(
div
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfDiv
(
div
0
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfDiv
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsTArray
<
bool
>
transitionList
;
MakeTransitionList
(
nodeArray
transitionList
)
;
nsCOMPtr
<
Element
>
curDiv
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
nodeArray
)
{
+
+
indexOfTransitionList
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
curNode
)
)
{
rv
=
AlignBlock
(
*
curNode
-
>
AsElement
(
)
aAlignType
ContentsOnly
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curDiv
=
nullptr
;
continue
;
}
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
bool
isEmptyTextNode
=
false
;
if
(
curNode
-
>
GetAsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsTableElement
(
atCurNode
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atCurNode
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
|
|
(
NS_SUCCEEDED
(
HTMLEditorRef
(
)
.
IsEmptyNode
(
curNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atCurNode
)
;
rv
=
RemoveAlignment
(
*
curNode
aAlignType
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
useCSS
)
{
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
curNode
-
>
AsElement
(
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
false
)
;
curDiv
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
rv
=
AlignInnerBlocks
(
*
curNode
aAlignType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curDiv
=
nullptr
;
continue
;
}
}
if
(
!
curDiv
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
HTMLEditorRef
(
)
.
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curDiv
;
rv
=
AlignBlock
(
*
curDiv
aAlignType
ContentsOnly
:
:
yes
)
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curDiv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignInnerBlocks
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
TableCellAndListItemFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
nsresult
rv
=
AlignBlockContents
(
*
node
aAlignType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignBlockContents
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstChild
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
;
if
(
!
firstChild
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastChild
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
if
(
firstChild
=
=
lastChild
&
&
firstChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
return
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
firstChild
-
>
AsElement
(
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
}
EditorRawDOMPoint
atStartOfNode
(
&
aNode
0
)
;
RefPtr
<
Element
>
divElem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfNode
)
;
if
(
NS_WARN_IF
(
!
divElem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
divElem
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
lastChild
&
&
(
lastChild
!
=
divElem
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
lastChild
EditorRawDOMPoint
(
divElem
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
lastChild
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
CheckForEmptyBlock
(
nsINode
*
aStartNode
Element
*
aBodyNode
nsIEditor
:
:
EDirection
aAction
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aBodyNode
&
&
IsInlineNode
(
*
aBodyNode
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
aStartNode
)
;
bool
bIsEmptyNode
;
RefPtr
<
Element
>
emptyBlock
;
if
(
block
&
&
block
!
=
aBodyNode
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
block
&
&
bIsEmptyNode
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
block
)
&
&
block
!
=
aBodyNode
)
{
emptyBlock
=
block
;
block
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
emptyBlock
)
;
if
(
block
)
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
if
(
emptyBlock
&
&
emptyBlock
-
>
IsEditable
(
)
)
{
nsCOMPtr
<
nsINode
>
blockParent
=
emptyBlock
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
blockParent
NS_ERROR_FAILURE
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
emptyBlock
)
)
{
if
(
HTMLEditorRef
(
)
.
IsFirstEditableChild
(
emptyBlock
)
)
{
EditorDOMPoint
atBlockParent
(
blockParent
)
;
if
(
NS_WARN_IF
(
!
atBlockParent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
atBlockParent
.
GetContainer
(
)
)
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
atBlockParent
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
brElement
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
}
else
{
if
(
aAction
=
=
nsIEditor
:
:
eNext
|
|
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
DebugOnly
<
bool
>
advanced
=
afterEmptyBlock
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
set
selection
to
the
after
the
empty
block
"
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextNode
(
afterEmptyBlock
)
;
if
(
nextNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nextNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
else
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
)
{
EditorRawDOMPoint
atEmptyBlock
(
emptyBlock
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableNode
(
atEmptyBlock
)
;
if
(
priorNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
priorNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
else
if
(
aAction
!
=
nsIEditor
:
:
eNone
)
{
MOZ_CRASH
(
"
CheckForEmptyBlock
doesn
'
t
support
this
action
yet
"
)
;
}
}
*
aHandled
=
true
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
emptyBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
Element
*
HTMLEditRules
:
:
CheckForInvisibleBR
(
Element
&
aBlock
BRLocation
aWhere
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
testNode
;
int32_t
testOffset
=
0
;
if
(
aWhere
=
=
BRLocation
:
:
blockEnd
)
{
nsCOMPtr
<
nsIContent
>
rightmostNode
=
HTMLEditorRef
(
)
.
GetRightmostChild
(
&
aBlock
true
)
;
if
(
!
rightmostNode
)
{
return
nullptr
;
}
testNode
=
rightmostNode
-
>
GetParentNode
(
)
;
testOffset
=
testNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
testNode
-
>
ComputeIndexOf
(
rightmostNode
)
+
1
=
=
testOffset
)
;
}
else
if
(
aOffset
)
{
testNode
=
&
aBlock
;
testOffset
=
aOffset
;
}
else
{
return
nullptr
;
}
WSRunObject
wsTester
(
&
HTMLEditorRef
(
)
testNode
testOffset
)
;
if
(
WSType
:
:
br
=
=
wsTester
.
mStartReason
)
{
return
wsTester
.
mStartReasonNode
-
>
AsElement
(
)
;
}
return
nullptr
;
}
void
HTMLEditRules
:
:
GetInnerContent
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
int32_t
*
aIndex
Lists
aLists
Tables
aTables
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aIndex
)
;
for
(
nsCOMPtr
<
nsIContent
>
node
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
if
(
(
aLists
=
=
Lists
:
:
yes
&
&
(
HTMLEditUtils
:
:
IsList
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
)
)
|
|
(
aTables
=
=
Tables
:
:
yes
&
&
HTMLEditUtils
:
:
IsTableElement
(
node
)
)
)
{
GetInnerContent
(
*
node
aOutArrayOfNodes
aIndex
aLists
aTables
)
;
}
else
{
aOutArrayOfNodes
.
InsertElementAt
(
*
aIndex
*
node
)
;
(
*
aIndex
)
+
+
;
}
}
}
nsresult
HTMLEditRules
:
:
ExpandSelectionForDeletion
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
selStartNode
=
firstRange
-
>
GetStartContainer
(
)
;
int32_t
selStartOffset
=
firstRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
selEndNode
=
firstRange
-
>
GetEndContainer
(
)
;
int32_t
selEndOffset
=
firstRange
-
>
EndOffset
(
)
;
nsCOMPtr
<
Element
>
selCommon
=
HTMLEditor
:
:
GetBlock
(
*
firstRange
-
>
GetCommonAncestor
(
)
)
;
if
(
NS_WARN_IF
(
!
selCommon
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
firstBRParent
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
visOffset
=
0
firstBROffset
=
0
;
WSType
wsType
;
RefPtr
<
Element
>
root
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selStartNode
!
=
selCommon
&
&
selStartNode
!
=
root
)
{
while
(
true
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
selStartNode
selStartOffset
)
;
wsObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
selStartNode
selStartOffset
)
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
thisBlock
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mStartReasonNode
)
|
|
selCommon
=
=
wsObj
.
mStartReasonNode
|
|
root
=
=
wsObj
.
mStartReasonNode
)
{
break
;
}
selStartNode
=
wsObj
.
mStartReasonNode
-
>
GetParentNode
(
)
;
selStartOffset
=
selStartNode
?
selStartNode
-
>
ComputeIndexOf
(
wsObj
.
mStartReasonNode
)
:
-
1
;
}
}
if
(
selEndNode
!
=
selCommon
&
&
selEndNode
!
=
root
)
{
for
(
;
;
)
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
selEndNode
selEndOffset
)
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
selEndNode
selEndOffset
)
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
break
;
}
if
(
!
firstBRParent
)
{
firstBRParent
=
selEndNode
;
firstBROffset
=
selEndOffset
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
selEndNode
?
selEndNode
-
>
ComputeIndexOf
(
wsObj
.
mEndReasonNode
)
+
1
:
0
;
}
else
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mEndReasonNode
)
|
|
selCommon
=
=
wsObj
.
mEndReasonNode
|
|
root
=
=
wsObj
.
mEndReasonNode
)
{
break
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
1
+
selEndNode
-
>
ComputeIndexOf
(
wsObj
.
mEndReasonNode
)
;
}
else
{
break
;
}
}
}
DebugOnly
<
nsresult
>
rv
=
SelectionRef
(
)
.
Collapse
(
selStartNode
selStartOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
bool
doEndExpansion
=
true
;
if
(
firstBRParent
)
{
nsCOMPtr
<
Element
>
brBlock
=
HTMLEditor
:
:
GetBlock
(
*
firstBRParent
)
;
bool
nodeBefore
=
false
nodeAfter
=
false
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
selStartNode
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
selStartNode
selStartOffset
selEndNode
selEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
brBlock
)
{
nsRange
:
:
CompareNodeToRange
(
brBlock
range
&
nodeBefore
&
nodeAfter
)
;
}
if
(
nodeBefore
|
|
nodeAfter
)
{
doEndExpansion
=
false
;
}
}
if
(
doEndExpansion
)
{
nsresult
rv
=
SelectionRef
(
)
.
Extend
(
selEndNode
selEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
SelectionRef
(
)
.
Extend
(
firstBRParent
firstBROffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
NormalizeSelection
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
startChild
=
range
-
>
GetChildAtStartOffset
(
)
;
nsIContent
*
endChild
=
range
-
>
GetChildAtEndOffset
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
newStartNode
=
startNode
;
uint32_t
newStartOffset
=
startOffset
;
nsCOMPtr
<
nsINode
>
newEndNode
=
endNode
;
uint32_t
newEndOffset
=
endOffset
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
offset
=
-
1
;
WSType
wsType
;
WSRunObject
wsEndObj
(
&
HTMLEditorRef
(
)
endNode
static_cast
<
int32_t
>
(
endOffset
)
)
;
wsEndObj
.
PriorVisibleNode
(
EditorRawDOMPoint
(
endNode
endOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetRightmostChild
(
wsEndObj
.
mStartReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
thisBlock
)
{
EditorRawDOMPoint
atEnd
(
endNode
endChild
endOffset
)
;
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atEnd
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
wsEndObj
.
mStartReasonNode
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
;
}
}
WSRunObject
wsStartObj
(
&
HTMLEditorRef
(
)
startNode
static_cast
<
int32_t
>
(
startOffset
)
)
;
wsStartObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
startNode
startOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetLeftmostChild
(
wsStartObj
.
mEndReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
thisBlock
)
{
nsINode
*
child
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
EditorRawDOMPoint
(
startNode
startChild
startOffset
)
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
wsStartObj
.
mEndReasonNode
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
int16_t
comp
;
comp
=
nsContentUtils
:
:
ComparePoints
(
startNode
startOffset
newEndNode
newEndOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartNode
newStartOffset
endNode
endOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rv
=
SelectionRef
(
)
.
Collapse
(
newStartNode
newStartOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
selection
"
)
;
rv
=
SelectionRef
(
)
.
Extend
(
newEndNode
newEndOffset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
extend
selection
"
)
;
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetPromotedPoint
(
RulesEndpoint
aWhere
nsINode
&
aNode
int32_t
aOffset
EditAction
actionID
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
actionID
=
=
EditAction
:
:
insertText
|
|
actionID
=
=
EditAction
:
:
insertIMEText
|
|
actionID
=
=
EditAction
:
:
insertBreak
|
|
actionID
=
=
EditAction
:
:
deleteText
)
{
bool
isSpace
isNBSP
;
nsCOMPtr
<
nsIContent
>
content
=
aNode
.
IsContent
(
)
?
aNode
.
AsContent
(
)
:
nullptr
;
nsCOMPtr
<
nsIContent
>
temp
;
int32_t
newOffset
=
aOffset
;
while
(
content
)
{
int32_t
offset
;
if
(
aWhere
=
=
kStart
)
{
HTMLEditorRef
(
)
.
IsPrevCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
else
{
HTMLEditorRef
(
)
.
IsNextCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
if
(
isSpace
|
|
isNBSP
)
{
content
=
temp
;
newOffset
=
offset
;
}
else
{
break
;
}
}
return
EditorDOMPoint
(
content
newOffset
)
;
}
EditorDOMPoint
point
(
&
aNode
aOffset
)
;
if
(
aWhere
=
=
kStart
)
{
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
while
(
priorNode
&
&
priorNode
-
>
GetParentNode
(
)
&
&
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
priorNode
)
&
&
!
IsBlockNode
(
*
priorNode
)
)
{
point
.
Set
(
priorNode
)
;
priorNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
while
(
!
nearNode
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
if
(
actionID
=
=
EditAction
:
:
outdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
actionID
=
=
EditAction
:
:
indent
|
|
actionID
=
=
EditAction
:
:
outdent
|
|
actionID
=
=
EditAction
:
:
align
|
|
actionID
=
=
EditAction
:
:
makeBasicBlock
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
}
return
point
;
}
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
text
node
"
)
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
while
(
nextNode
&
&
!
IsBlockNode
(
*
nextNode
)
&
&
nextNode
-
>
GetParentNode
(
)
)
{
point
.
Set
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
if
(
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nextNode
)
)
{
break
;
}
if
(
EditorBase
:
:
IsPreformatted
(
nextNode
)
&
&
EditorBase
:
:
IsTextNode
(
nextNode
)
)
{
nsAutoString
tempString
;
nextNode
-
>
GetAsText
(
)
-
>
GetData
(
tempString
)
;
int32_t
newlinePos
=
tempString
.
FindChar
(
nsCRT
:
:
LF
)
;
if
(
newlinePos
>
=
0
)
{
if
(
static_cast
<
uint32_t
>
(
newlinePos
)
+
1
=
=
tempString
.
Length
(
)
)
{
break
;
}
return
EditorDOMPoint
(
nextNode
newlinePos
+
1
)
;
}
}
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
while
(
!
nearNode
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
&
&
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
}
return
point
;
}
void
HTMLEditRules
:
:
GetPromotedRanges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
outArrayOfRanges
EditAction
inOperationType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
selectionRange
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
opRange
=
selectionRange
-
>
CloneRange
(
)
;
PromoteRange
(
*
opRange
inOperationType
)
;
outArrayOfRanges
.
AppendElement
(
opRange
)
;
}
}
void
HTMLEditRules
:
:
PromoteRange
(
nsRange
&
aRange
EditAction
aOperationType
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
if
(
startNode
=
=
endNode
&
&
startOffset
=
=
endOffset
)
{
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
startNode
)
;
if
(
block
)
{
bool
bIsEmptyNode
=
false
;
nsIContent
*
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
host
block
)
)
{
HTMLEditorRef
(
)
.
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
}
if
(
bIsEmptyNode
)
{
startNode
=
block
;
endNode
=
block
;
startOffset
=
0
;
endOffset
=
block
-
>
Length
(
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
insertText
|
|
aOperationType
=
=
EditAction
:
:
insertIMEText
|
|
aOperationType
=
=
EditAction
:
:
insertBreak
|
|
aOperationType
=
=
EditAction
:
:
deleteText
)
{
if
(
!
startNode
-
>
IsContent
(
)
|
|
!
endNode
-
>
IsContent
(
)
)
{
return
;
}
}
EditorDOMPoint
startPoint
=
GetPromotedPoint
(
kStart
*
startNode
startOffset
aOperationType
)
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
;
}
EditorDOMPoint
endPoint
=
GetPromotedPoint
(
kEnd
*
endNode
endOffset
aOperationType
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
aRange
.
SetStartAndEnd
(
startPoint
endPoint
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
class
UniqueFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
UniqueFunctor
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
)
:
mArray
(
aArray
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
!
mArray
.
Contains
(
aNode
)
;
}
private
:
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
mArray
;
}
;
nsresult
HTMLEditRules
:
:
GetNodesForOperation
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditAction
aOperationType
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
IsInTextNode
(
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atContainerOfSplitNode
(
atEnd
.
GetContainer
(
)
)
;
range
-
>
SetEnd
(
atContainerOfSplitNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
}
}
}
}
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
aArrayOfRanges
[
0
]
)
;
HTMLEditorRef
(
)
.
mRangeUpdater
.
RegisterRangeItem
(
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
nsresult
rv
=
BustUpInlinesAtRangeEndpoints
(
*
item
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
HTMLEditorRef
(
)
.
mRangeUpdater
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
}
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
iter
.
AppendList
(
TrivialFunctor
(
)
aOutArrayOfNodes
)
;
}
else
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodes
;
iter
.
AppendList
(
UniqueFunctor
(
aOutArrayOfNodes
)
nodes
)
;
aOutArrayOfNodes
.
AppendElements
(
nodes
)
;
}
}
if
(
aOperationType
=
=
EditAction
:
:
makeBasicBlock
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
Text
*
text
=
aOutArrayOfNodes
[
i
]
-
>
GetAsText
(
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsVisibleTextNode
(
*
text
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
}
}
else
if
(
aOperationType
=
=
EditAction
:
:
outdent
|
|
aOperationType
=
=
EditAction
:
:
indent
|
|
aOperationType
=
=
EditAction
:
:
setAbsolutePosition
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
outdent
&
&
!
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
Lists
:
:
no
Tables
:
:
no
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
makeBasicBlock
|
|
aOperationType
=
=
EditAction
:
:
makeList
|
|
aOperationType
=
=
EditAction
:
:
align
|
|
aOperationType
=
=
EditAction
:
:
setAbsolutePosition
|
|
aOperationType
=
=
EditAction
:
:
indent
|
|
aOperationType
=
=
EditAction
:
:
outdent
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
&
&
IsInlineNode
(
node
)
&
&
HTMLEditorRef
(
)
.
IsContainer
(
node
)
&
&
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfInlines
;
nsresult
rv
=
BustUpInlinesAtBRs
(
*
node
-
>
AsContent
(
)
arrayOfInlines
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
aOutArrayOfNodes
.
InsertElementsAt
(
i
arrayOfInlines
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
GetChildNodesForOperation
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
{
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
outArrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
nsresult
HTMLEditRules
:
:
GetListActionNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EntireList
aEntireList
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aEntireList
=
=
EntireList
:
:
yes
)
{
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
rangeIdx
)
;
for
(
nsCOMPtr
<
nsINode
>
parent
=
range
-
>
GetCommonAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
parent
)
;
break
;
}
}
}
if
(
!
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
}
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
&
HTMLEditorRef
(
)
)
;
nsresult
rv
=
GetNodesFromSelection
(
EditAction
:
:
makeList
aOutArrayOfNodes
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
aOutArrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
testNode
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
testNode
aOutArrayOfNodes
&
j
Lists
:
:
no
)
;
}
}
LookInsideDivBQandList
(
aOutArrayOfNodes
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
LookInsideDivBQandList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aNodeArray
.
Length
(
)
!
=
1
)
{
return
;
}
OwningNonNull
<
nsINode
>
curNode
=
aNodeArray
[
0
]
;
while
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
uint32_t
numChildren
=
HTMLEditorRef
(
)
.
CountEditableChildren
(
curNode
)
;
if
(
numChildren
!
=
1
)
{
break
;
}
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetFirstChild
(
)
;
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
!
HTMLEditUtils
:
:
IsList
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
curNode
=
child
;
}
aNodeArray
.
RemoveElementAt
(
0
)
;
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
int32_t
j
=
0
;
GetInnerContent
(
*
curNode
aNodeArray
&
j
Lists
:
:
no
Tables
:
:
no
)
;
return
;
}
aNodeArray
.
AppendElement
(
*
curNode
)
;
}
void
HTMLEditRules
:
:
GetDefinitionListItemTypes
(
dom
:
:
Element
*
aElement
bool
*
aDT
bool
*
aDD
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
MOZ_ASSERT
(
aDT
)
;
MOZ_ASSERT
(
aDD
)
;
*
aDT
=
*
aDD
=
false
;
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
}
}
nsresult
HTMLEditRules
:
:
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
GetNodesFromSelection
(
EditAction
:
:
makeBasicBlock
outArrayOfNodes
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
outArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
outArrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
testNode
)
|
|
HTMLEditUtils
:
:
IsList
(
testNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
testNode
)
)
{
int32_t
j
=
i
;
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
testNode
outArrayOfNodes
&
j
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtRangeEndpoints
(
RangeItem
&
item
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
bool
isCollapsed
=
item
.
mStartContainer
=
=
item
.
mEndContainer
&
&
item
.
mStartOffset
=
=
item
.
mEndOffset
;
nsCOMPtr
<
nsIContent
>
endInline
=
GetHighestInlineParent
(
*
item
.
mEndContainer
)
;
if
(
endInline
&
&
!
isCollapsed
)
{
SplitNodeResult
splitEndInlineResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
endInline
EditorRawDOMPoint
(
item
.
mEndContainer
item
.
mEndOffset
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitEndInlineResult
.
Failed
(
)
)
)
{
return
splitEndInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtEnd
(
splitEndInlineResult
.
SplitPoint
(
)
)
;
item
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
item
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
nsCOMPtr
<
nsIContent
>
startInline
=
GetHighestInlineParent
(
*
item
.
mStartContainer
)
;
if
(
startInline
)
{
SplitNodeResult
splitStartInlineResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
startInline
EditorRawDOMPoint
(
item
.
mStartContainer
item
.
mStartOffset
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitStartInlineResult
.
Failed
(
)
)
)
{
return
splitStartInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtStart
(
splitStartInlineResult
.
SplitPoint
(
)
)
;
item
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
item
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtBRs
(
nsIContent
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfBreaks
;
BRNodeFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
arrayOfBreaks
)
;
if
(
arrayOfBreaks
.
IsEmpty
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
aNode
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
&
aNode
;
for
(
OwningNonNull
<
nsINode
>
&
brNode
:
arrayOfBreaks
)
{
EditorRawDOMPoint
atBrNode
(
brNode
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
nextNode
atBrNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
splitNodeResult
.
GetPreviousNode
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
splitNodeResult
.
GetPreviousNode
(
)
)
;
}
EditorRawDOMPoint
atNextNode
(
splitNodeResult
.
GetNextNode
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
*
brNode
-
>
AsContent
(
)
atNextNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutArrayOfNodes
.
AppendElement
(
*
brNode
)
;
nextNode
=
splitNodeResult
.
GetNextNode
(
)
;
}
aOutArrayOfNodes
.
AppendElement
(
*
nextNode
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditRules
:
:
GetHighestInlineParent
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
aNode
.
IsContent
(
)
|
|
IsBlockNode
(
aNode
)
)
{
return
nullptr
;
}
Element
*
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
nullptr
;
}
if
(
&
aNode
=
=
host
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
aNode
*
host
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
for
(
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
parent
&
&
parent
!
=
host
&
&
IsInlineNode
(
*
parent
)
;
parent
=
parent
-
>
GetParent
(
)
)
{
content
=
parent
;
}
return
content
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromPoint
(
const
EditorDOMPoint
&
aPoint
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aPoint
.
GetContainer
(
)
)
;
ErrorResult
error
;
range
-
>
SetStart
(
aPoint
error
)
;
MOZ_ASSERT
(
!
error
.
Failed
(
)
)
;
PromoteRange
(
*
range
aOperation
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
arrayOfRanges
.
AppendElement
(
range
)
;
nsresult
rv2
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aOperation
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
)
{
return
rv2
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromSelection
(
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
aOperation
)
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aOperation
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
MakeTransitionList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsCOMPtr
<
nsINode
>
prevParent
;
aTransitionArray
.
EnsureLengthAtLeast
(
aNodeArray
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNodeArray
.
Length
(
)
;
i
+
+
)
{
if
(
aNodeArray
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
)
{
aTransitionArray
[
i
]
=
true
;
}
else
{
aTransitionArray
[
i
]
=
false
;
}
prevParent
=
aNodeArray
[
i
]
-
>
GetParentNode
(
)
;
}
}
Element
*
HTMLEditRules
:
:
IsInListItem
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_ENSURE_TRUE
(
aNode
nullptr
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
)
{
return
aNode
-
>
AsElement
(
)
;
}
Element
*
parent
=
aNode
-
>
GetParentElement
(
)
;
while
(
parent
&
&
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
parent
)
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parent
)
)
{
return
parent
;
}
parent
=
parent
-
>
GetParentElement
(
)
;
}
return
nullptr
;
}
nsAtom
&
HTMLEditRules
:
:
DefaultParagraphSeparator
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
return
ParagraphSeparatorElement
(
HTMLEditorRef
(
)
.
GetDefaultParagraphSeparator
(
)
)
;
}
nsresult
HTMLEditRules
:
:
ReturnInHeader
(
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
headerParent
=
aHeader
.
GetParentNode
(
)
;
int32_t
offset
=
headerParent
?
headerParent
-
>
ComputeIndexOf
(
&
aHeader
)
:
-
1
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
node
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
node
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SplitNodeResult
splitHeaderResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aHeader
EditorRawDOMPoint
(
node
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitHeaderResult
.
Succeeded
(
)
"
Failed
to
split
aHeader
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aHeader
)
;
if
(
prevItem
)
{
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
prevItem
)
)
;
bool
isEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
EditorRawDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
if
(
IsEmptyBlockElement
(
aHeader
IgnoreSingleBR
:
:
eYes
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aHeader
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
aHeader
.
GetNextSibling
(
)
)
{
sibling
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
aHeader
.
GetNextSibling
(
)
)
;
}
if
(
!
sibling
|
|
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
ClearCachedStyles
(
)
;
HTMLEditorRef
(
)
.
mTypeInState
-
>
ClearAllProps
(
)
;
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
EditorRawDOMPoint
nextToHeader
(
headerParent
offset
+
1
)
;
RefPtr
<
Element
>
pNode
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
paraAtom
nextToHeader
)
;
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
EditorRawDOMPoint
afterSibling
(
sibling
)
;
if
(
NS_WARN_IF
(
!
afterSibling
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
afterSibling
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
else
{
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
&
aHeader
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
EditActionResult
HTMLEditRules
:
:
ReturnInParagraph
(
Element
&
aParentDivOrP
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
|
|
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
;
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
}
bool
doesCRCreateNewP
=
HTMLEditorRef
(
)
.
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brContent
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorRawDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brContent
=
nullptr
;
}
else
if
(
atStartOfSelection
.
IsInTextNode
(
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brContent
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
brContent
)
|
|
TextEditUtils
:
:
HasMozAttr
(
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
brContent
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brContent
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
brContent
)
|
|
TextEditUtils
:
:
HasMozAttr
(
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
brContent
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftDivOrP
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
pointToSplitParentDivOrP
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
pointToSplitParentDivOrP
.
SetToEndOf
(
newLeftDivOrP
)
;
}
pointToInsertBR
.
Set
(
pointToSplitParentDivOrP
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nearNode
;
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
nearNode
)
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
nearNode
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
brContent
=
nearNode
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
HTMLEditorRef
(
)
.
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
brContent
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsertBR
)
;
NS_WARNING_ASSERTION
(
brContent
"
Failed
to
create
a
<
br
>
element
"
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
Set
(
brContent
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplitParentDivOrP
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
"
)
;
}
}
EditActionResult
result
(
SplitParagraph
(
aParentDivOrP
pointToSplitParentDivOrP
brContent
)
)
;
result
.
MarkAsHandled
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
return
result
;
}
template
<
typename
PT
typename
CT
>
nsresult
HTMLEditRules
:
:
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
selNode
=
aStartOfRightNode
.
GetContainer
(
)
;
int32_t
selOffset
=
aStartOfRightNode
.
Offset
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitDivOrPResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aParentDivOrP
EditorRawDOMPoint
(
selNode
selOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitDivOrPResult
.
Failed
(
)
)
)
{
return
splitDivOrPResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
!
splitDivOrPResult
.
DidSplit
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNextBRNode
&
&
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
aNextBRNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
aNextBRNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
aParentDivOrP
*
nsGkAtoms
:
:
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertBRIfNeeded
(
*
splitDivOrPResult
.
GetPreviousNode
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
InsertBRIfNeeded
(
*
splitDivOrPResult
.
GetNextNode
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsIContent
*
child
=
HTMLEditorRef
(
)
.
GetLeftmostChild
(
&
aParentDivOrP
true
)
;
if
(
EditorBase
:
:
IsTextNode
(
child
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
child
)
)
{
EditorRawDOMPoint
atStartOfChild
(
child
0
)
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
atStartOfChild
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
end
of
the
child
"
)
;
}
else
{
EditorRawDOMPoint
atChild
(
child
)
;
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
atChild
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
child
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReturnInListItem
(
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
;
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
mReturnInEmptyLIKillsList
&
&
host
!
=
aListItem
.
GetParentElement
(
)
&
&
IsEmptyBlockElement
(
aListItem
IgnoreSingleBR
:
:
eYes
)
)
{
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
HTMLEditorRef
(
)
.
IsLastEditableChild
(
&
aListItem
)
)
{
EditorRawDOMPoint
atListItem
(
&
aListItem
)
;
ErrorResult
error
;
leftListNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorRawDOMPoint
atNextSiblingOfLeftList
(
leftListNode
)
;
DebugOnly
<
bool
>
advanced
=
atNextSiblingOfLeftList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
right
list
node
"
)
;
if
(
HTMLEditUtils
:
:
IsList
(
atNextSiblingOfLeftList
.
GetContainer
(
)
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aListItem
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
RefPtr
<
Element
>
pNode
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
paraAtom
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selNode
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
&
HTMLEditorRef
(
)
address_of
(
selNode
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitListItemResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
aListItem
EditorRawDOMPoint
(
selNode
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitListItemResult
.
Succeeded
(
)
"
Failed
to
split
the
list
item
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aListItem
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsListItem
(
prevItem
)
)
{
bool
isEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
EditorRawDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aListItem
&
isEmptyNode
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
RefPtr
<
nsAtom
>
nodeAtom
=
aListItem
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
nodeAtom
=
=
nsGkAtoms
:
:
dd
|
|
nodeAtom
=
=
nsGkAtoms
:
:
dt
)
{
nsCOMPtr
<
nsINode
>
list
=
aListItem
.
GetParentNode
(
)
;
int32_t
itemOffset
=
list
?
list
-
>
ComputeIndexOf
(
&
aListItem
)
:
-
1
;
nsAtom
*
listAtom
=
nodeAtom
=
=
nsGkAtoms
:
:
dt
?
nsGkAtoms
:
:
dd
:
nsGkAtoms
:
:
dt
;
MOZ_DIAGNOSTIC_ASSERT
(
itemOffset
!
=
-
1
)
;
EditorRawDOMPoint
atNextListItem
(
list
aListItem
.
GetNextSibling
(
)
itemOffset
+
1
)
;
RefPtr
<
Element
>
newListItem
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
listAtom
atNextListItem
)
;
if
(
NS_WARN_IF
(
!
newListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
newListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CopyLastEditableChildStylesWithTransaction
(
*
prevItem
-
>
AsElement
(
)
aListItem
address_of
(
brElement
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElement
)
{
EditorRawDOMPoint
atBrNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
else
{
WSRunObject
wsObj
(
&
HTMLEditorRef
(
)
&
aListItem
0
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
&
aListItem
0
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
EditorRawDOMPoint
atVisNode
(
visNode
)
;
if
(
NS_WARN_IF
(
!
atVisNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atVisNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
rv
=
SelectionRef
(
)
.
Collapse
(
visNode
visOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
EditorRawDOMPoint
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeBlockquote
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
curNode
:
aNodeArray
)
{
NS_ENSURE_STATE
(
curNode
-
>
IsContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
MakeBlockquote
(
childArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
prevParent
)
{
if
(
prevParent
!
=
curNode
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsIContent
>
firstNode
lastNode
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
curNode
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
RemoveBlockStyle
(
childArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
IsInlineNode
(
curNode
)
)
{
if
(
curBlock
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlock
)
)
{
lastNode
=
curNode
-
>
AsContent
(
)
;
continue
;
}
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
curBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
curNode
)
;
if
(
!
curBlock
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
|
|
!
HTMLEditorRef
(
)
.
IsEditable
(
curBlock
)
)
{
curBlock
=
nullptr
;
}
else
{
firstNode
=
lastNode
=
curNode
-
>
AsContent
(
)
;
}
}
else
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
}
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ApplyBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
curNode
:
aNodeArray
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
curNode
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
&
&
IsBlockNode
(
curNode
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
curNode
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
curBlock
=
nullptr
;
newBlock
=
HTMLEditorRef
(
)
.
ReplaceContainerAndCloneAttributesWithTransaction
(
*
curNode
-
>
AsElement
(
)
aBlockTag
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
if
(
!
childArray
.
IsEmpty
(
)
)
{
nsresult
rv
=
ApplyBlockStyle
(
childArray
aBlockTag
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
theBlock
;
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
IsInlineNode
(
curNode
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
!
curBlock
)
{
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atCurNode
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
aBlockTag
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
SplitNodeResult
HTMLEditRules
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfDeepestRightNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
host
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
host
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
*
host
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorRawDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToInsert
.
GetChild
(
)
=
=
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditorRef
(
)
.
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
(
aStartOfDeepestRightNode
)
;
}
SplitNodeResult
splitNodeResult
=
HTMLEditorRef
(
)
.
SplitNodeDeepWithTransaction
(
*
pointToInsert
.
GetChild
(
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
Failed
to
split
the
node
for
insert
the
element
"
)
;
return
splitNodeResult
;
}
EditorDOMPoint
HTMLEditRules
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNodeLeft
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
EditorDOMPoint
(
)
;
}
int32_t
parOffset
=
parent
-
>
ComputeIndexOf
(
&
aNodeLeft
)
;
nsCOMPtr
<
nsINode
>
rightParent
=
aNodeRight
.
GetParentNode
(
)
;
if
(
parent
!
=
rightParent
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aNodeRight
EditorRawDOMPoint
(
parent
parOffset
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
}
EditorDOMPoint
ret
(
&
aNodeRight
aNodeLeft
.
Length
(
)
)
;
if
(
HTMLEditUtils
:
:
IsList
(
&
aNodeLeft
)
|
|
aNodeLeft
.
GetAsText
(
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
return
ret
;
}
nsCOMPtr
<
nsIContent
>
lastLeft
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNodeLeft
)
;
if
(
NS_WARN_IF
(
!
lastLeft
)
)
{
return
EditorDOMPoint
(
)
;
}
nsCOMPtr
<
nsIContent
>
firstRight
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
firstRight
)
)
{
return
EditorDOMPoint
(
)
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
lastLeft
&
&
firstRight
&
&
HTMLEditorRef
(
)
.
AreNodesSameType
(
lastLeft
firstRight
)
&
&
(
lastLeft
-
>
GetAsText
(
)
|
|
(
lastLeft
-
>
IsElement
(
)
&
&
firstRight
-
>
IsElement
(
)
&
&
CSSEditUtils
:
:
ElementsSameStyle
(
lastLeft
-
>
AsElement
(
)
firstRight
-
>
AsElement
(
)
)
)
)
)
{
return
JoinNearestEditableNodesWithTransaction
(
*
lastLeft
*
firstRight
)
;
}
return
ret
;
}
Element
*
HTMLEditRules
:
:
GetTopEnclosingMailCite
(
nsINode
&
aNode
)
{
nsCOMPtr
<
Element
>
ret
;
for
(
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
IsPlaintextEditor
(
)
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
{
ret
=
node
-
>
AsElement
(
)
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
CacheInlineStyles
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
GetInlineStyles
(
aNode
mCachedStyles
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetInlineStyles
(
nsINode
*
aNode
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
+
+
j
)
{
bool
typeInSet
unused
;
HTMLEditorRef
(
)
.
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsAutoString
outValue
;
if
(
!
useCSS
|
|
(
aStyleCache
[
j
]
.
tag
=
=
nsGkAtoms
:
:
font
&
&
aStyleCache
[
j
]
.
attr
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
HTMLEditorRef
(
)
.
IsTextPropertySetByContent
(
aNode
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
nullptr
&
outValue
)
;
}
else
{
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
aNode
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
outValue
CSSEditUtils
:
:
eComputed
)
;
}
if
(
isSet
)
{
aStyleCache
[
j
]
.
mPresent
=
true
;
aStyleCache
[
j
]
.
value
.
Assign
(
outValue
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
if
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
selNode
=
do_QueryInterface
(
SelectionRef
(
)
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
if
(
!
selNode
)
{
return
NS_OK
;
}
StyleCache
styleAtInsertionPoint
[
SIZE_STYLE_TABLE
]
;
InitStyleCacheArray
(
styleAtInsertionPoint
)
;
nsresult
rv
=
GetInlineStyles
(
selNode
styleAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
SIZE_STYLE_TABLE
;
+
+
i
)
{
if
(
mCachedStyles
[
i
]
.
mPresent
)
{
bool
bFirst
bAny
bAll
;
bFirst
=
bAny
=
bAll
=
false
;
nsAutoString
curValue
;
if
(
useCSS
)
{
bAny
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
selNode
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
curValue
CSSEditUtils
:
:
eComputed
)
;
}
if
(
!
bAny
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
GetInlinePropertyBase
(
*
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
&
(
mCachedStyles
[
i
]
.
value
)
&
bFirst
&
bAny
&
bAll
&
curValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
(
!
bAny
|
|
IsStyleCachePreservingAction
(
mTheAction
)
)
&
&
(
!
styleAtInsertionPoint
[
i
]
.
mPresent
|
|
styleAtInsertionPoint
[
i
]
.
value
!
=
mCachedStyles
[
i
]
.
value
)
)
{
HTMLEditorRef
(
)
.
mTypeInState
-
>
SetProp
(
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
mCachedStyles
[
i
]
.
value
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
ClearCachedStyles
(
)
{
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
j
+
+
)
{
mCachedStyles
[
j
]
.
mPresent
=
false
;
mCachedStyles
[
j
]
.
value
.
Truncate
(
)
;
}
}
void
HTMLEditRules
:
:
AdjustSpecialBreaks
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
EmptyEditableFunctor
functor
(
&
HTMLEditorRef
(
)
)
;
DOMIterator
iter
;
if
(
NS_WARN_IF
(
NS_FAILED
(
iter
.
Init
(
*
mDocChangeRange
)
)
)
)
{
return
;
}
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
EditorRawDOMPoint
endOfNode
;
endOfNode
.
SetToEndOf
(
node
)
;
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
endOfNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
;
}
}
}
nsresult
HTMLEditRules
:
:
AdjustWhitespace
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
WSRunObject
(
&
HTMLEditorRef
(
)
selectionStartPoint
)
.
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
PinSelectionToNewBlock
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mNewBlock
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
selectionStartPoint
.
GetContainer
(
)
)
;
nsresult
rv
=
range
-
>
CollapseTo
(
selectionStartPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
nodeBefore
nodeAfter
;
rv
=
nsRange
:
:
CompareNodeToRange
(
mNewBlock
range
&
nodeBefore
&
nodeAfter
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
nsCOMPtr
<
nsINode
>
tmp
=
HTMLEditorRef
(
)
.
GetLastEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
endPoint
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
tmp
)
)
{
endPoint
.
SetToEndOf
(
tmp
)
;
}
else
{
endPoint
.
Set
(
tmp
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
endPoint
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
tmp
=
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
HTMLEditorRef
(
)
.
IsContainer
(
tmp
)
)
{
atStartOfBlock
.
Set
(
tmp
)
;
}
else
{
atStartOfBlock
.
Set
(
tmp
0
)
;
}
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
atStartOfBlock
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
CheckInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
;
}
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
node
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
atStartOfSelection
)
;
if
(
node
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
return
;
}
if
(
atStartOfSelection
.
GetChild
(
)
)
{
node
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
atStartOfSelection
.
GetChild
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
return
;
}
if
(
atStartOfSelection
.
GetChild
(
)
)
{
node
=
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
atStartOfSelection
.
GetChild
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
}
}
nsresult
HTMLEditRules
:
:
AdjustSelection
(
nsIEditor
:
:
EDirection
aAction
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
NS_OK
;
}
EditorDOMPoint
point
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
HTMLEditorRef
(
)
.
IsEditable
(
point
.
GetContainer
(
)
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
theblock
=
HTMLEditorRef
(
)
.
GetBlock
(
*
point
.
GetContainer
(
)
)
;
if
(
theblock
&
&
HTMLEditorRef
(
)
.
IsEditable
(
theblock
)
)
{
bool
bIsEmptyNode
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
theblock
&
bIsEmptyNode
false
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bIsEmptyNode
&
&
HTMLEditorRef
(
)
.
CanContainTag
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
rootElement
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
point
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
point
)
;
if
(
nearNode
)
{
RefPtr
<
Element
>
block
=
HTMLEditorRef
(
)
.
GetBlock
(
*
point
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
nearBlock
=
HTMLEditorRef
(
)
.
GetBlockNodeParent
(
nearNode
)
;
if
(
block
&
&
block
=
=
nearBlock
)
{
if
(
nearNode
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
if
(
!
HTMLEditorRef
(
)
.
IsVisibleBRElement
(
nearNode
)
)
{
RefPtr
<
Element
>
brElement
=
CreateMozBR
(
point
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
point
.
Set
(
brElement
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
error
=
NS_OK
;
SelectionRef
(
)
.
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nextNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
*
nearNode
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
}
}
}
}
}
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
|
|
nearNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNodeInBlock
(
point
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
nearNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
nearNode
=
FindNearEditableNode
(
point
aAction
)
;
if
(
!
nearNode
)
{
return
NS_OK
;
}
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nearNode
aAction
)
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditRules
:
:
FindNearEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
nearNode
=
nullptr
;
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
aPoint
)
;
if
(
!
nearNode
)
{
return
nullptr
;
}
}
else
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
aPoint
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
while
(
nearNode
&
&
!
(
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
)
)
{
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
HTMLEditorRef
(
)
.
GetPreviousEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
else
{
nearNode
=
HTMLEditorRef
(
)
.
GetNextEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
}
if
(
InDifferentTableElements
(
nearNode
aPoint
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
nearNode
;
}
bool
HTMLEditRules
:
:
InDifferentTableElements
(
nsINode
*
aNode1
nsINode
*
aNode2
)
{
MOZ_ASSERT
(
aNode1
&
&
aNode2
)
;
while
(
aNode1
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode1
)
)
{
aNode1
=
aNode1
-
>
GetParentNode
(
)
;
}
while
(
aNode2
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode2
)
)
{
aNode2
=
aNode2
-
>
GetParentNode
(
)
;
}
return
aNode1
!
=
aNode2
;
}
nsresult
HTMLEditRules
:
:
RemoveEmptyNodes
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
mDocChangeRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfEmptyNodes
arrayOfEmptyCites
skipList
;
while
(
!
iter
-
>
IsDone
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
iter
-
>
GetCurrentNode
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
node
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parent
)
{
skipList
[
idx
]
=
parent
;
}
}
else
{
bool
bIsCandidate
=
false
;
bool
bIsEmptyNode
=
false
;
bool
bIsMailCite
=
false
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
bIsMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
node
)
|
|
HTMLEditUtils
:
:
IsList
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
bIsCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
bool
bIsSelInNode
;
rv
=
SelectionEndpointInNode
(
node
&
bIsSelInNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
bIsSelInNode
)
{
bIsCandidate
=
true
;
}
}
}
if
(
bIsCandidate
)
{
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
node
&
bIsEmptyNode
bIsMailCite
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bIsEmptyNode
)
{
if
(
bIsMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
node
)
;
}
else
{
arrayOfEmptyNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
!
bIsEmptyNode
&
&
parent
)
{
skipList
.
AppendElement
(
*
parent
)
;
}
}
iter
-
>
Next
(
)
;
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyNodes
)
{
if
(
HTMLEditorRef
(
)
.
IsModifiableNode
(
delNode
)
)
{
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyCites
)
{
bool
bIsEmptyNode
;
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
delNode
&
bIsEmptyNode
false
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
bIsEmptyNode
)
{
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
EditorRawDOMPoint
(
delNode
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SelectionEndpointInNode
(
nsINode
*
aNode
bool
*
aResult
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
NS_ENSURE_TRUE
(
aNode
&
&
aResult
NS_ERROR_NULL_POINTER
)
;
*
aResult
=
false
;
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
rangeIdx
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
)
{
if
(
aNode
=
=
startContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
startContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
)
{
if
(
aNode
=
=
endContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
endContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
IsEmptyInline
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
IsInlineNode
(
aNode
)
&
&
HTMLEditorRef
(
)
.
IsContainer
(
&
aNode
)
)
{
bool
isEmpty
=
true
;
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
return
isEmpty
;
}
return
false
;
}
bool
HTMLEditRules
:
:
ListIsEmptyLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aArrayOfNodes
.
Length
(
)
)
)
{
return
true
;
}
int32_t
brCount
=
0
;
for
(
auto
&
node
:
aArrayOfNodes
)
{
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
node
)
)
{
continue
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
if
(
brCount
)
{
return
false
;
}
brCount
+
+
;
}
else
if
(
IsEmptyInline
(
node
)
)
{
}
else
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditRules
:
:
PopListItem
(
nsIContent
&
aListItem
bool
*
aOutOfList
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
aOutOfList
)
{
*
aOutOfList
=
false
;
}
nsCOMPtr
<
nsIContent
>
kungFuDeathGrip
(
&
aListItem
)
;
Unused
<
<
kungFuDeathGrip
;
if
(
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
)
|
|
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
-
>
GetParentNode
(
)
)
|
|
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
bIsFirstListItem
=
HTMLEditorRef
(
)
.
IsFirstEditableChild
(
&
aListItem
)
;
bool
bIsLastListItem
=
HTMLEditorRef
(
)
.
IsLastEditableChild
(
&
aListItem
)
;
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
bIsFirstListItem
&
&
!
bIsLastListItem
)
{
EditorDOMPoint
atListItem
(
&
aListItem
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
atListItem
.
IsSetAndValid
(
)
)
;
ErrorResult
error
;
leftListNode
=
HTMLEditorRef
(
)
.
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
pointToInsertListItem
(
leftListNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsertListItem
.
IsSetAndValid
(
)
)
;
if
(
!
bIsFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
MoveNodeWithTransaction
(
aListItem
pointToInsertListItem
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
{
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
*
aListItem
.
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aOutOfList
)
{
*
aOutOfList
=
true
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveListStructure
(
Element
&
aList
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
while
(
aList
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aList
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
bool
isOutOfList
;
do
{
nsresult
rv
=
PopListItem
(
child
&
isOutOfList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
while
(
!
isOutOfList
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
nsresult
rv
=
RemoveListStructure
(
*
child
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveBlockContainerWithTransaction
(
aList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ConfirmSelectionInBody
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
EditorRawDOMPoint
selectionStartPoint
(
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionStartPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
selectionStartPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
rootElement
0
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
start
of
the
root
element
"
)
;
return
NS_OK
;
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
&
SelectionRef
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
rootElement
0
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
start
of
the
root
element
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
UpdateDocChangeRange
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
const
RangeBoundary
&
atStart
=
aRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
IsDescendantOfRoot
(
atStart
.
Container
(
)
)
)
{
return
NS_OK
;
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
aRange
-
>
CloneRange
(
)
;
}
else
{
ErrorResult
error
;
int16_t
result
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
RangeBinding
:
:
START_TO_START
*
aRange
error
)
;
if
(
error
.
ErrorCodeIs
(
NS_ERROR_NOT_INITIALIZED
)
)
{
result
=
1
;
error
.
SuppressException
(
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
result
>
0
)
{
mDocChangeRange
-
>
SetStart
(
atStart
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
result
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
RangeBinding
:
:
END_TO_END
*
aRange
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
result
<
0
)
{
const
RangeBoundary
&
atEnd
=
aRange
-
>
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mDocChangeRange
-
>
SetEnd
(
atEnd
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeededInternal
(
nsINode
&
aNode
bool
aInsertMozBR
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsBlockNode
(
aNode
)
)
{
return
NS_OK
;
}
bool
isEmpty
;
nsresult
rv
=
HTMLEditorRef
(
)
.
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmpty
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
CreateBRInternal
(
EditorRawDOMPoint
(
&
aNode
0
)
aInsertMozBR
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
DidCreateNode
(
Selection
&
aSelection
Element
&
aNewElement
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aNewElement
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidInsertNode
(
Selection
&
aSelection
nsIContent
&
aContent
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aContent
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillDeleteNode
(
Selection
&
aSelection
nsINode
&
aChild
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
IgnoredErrorResult
ignoredError
;
mUtilRange
-
>
SelectNode
(
aChild
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
Failed
(
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidSplitNode
(
Selection
&
aSelection
nsINode
&
aExistingRightNode
nsINode
&
aNewLeftNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
&
aNewLeftNode
0
&
aExistingRightNode
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
mJoinOffset
=
aLeftNode
.
Length
(
)
;
}
void
HTMLEditRules
:
:
DidJoinNodes
(
Selection
&
aSelection
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
&
aRightNode
mJoinOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidInsertText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
int32_t
length
=
aString
.
Length
(
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
&
aTextNode
aOffset
&
aTextNode
aOffset
+
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
DidDeleteText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
&
aTextNode
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
void
HTMLEditRules
:
:
WillDeleteSelection
(
Selection
&
aSelection
)
{
if
(
!
mListenerEnabled
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
aSelection
)
;
EditorRawDOMPoint
startPoint
=
EditorBase
:
:
GetStartPoint
(
&
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
;
}
EditorRawDOMPoint
endPoint
=
EditorBase
:
:
GetEndPoint
(
&
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
;
}
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
startPoint
endPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
UpdateDocChangeRange
(
mUtilRange
)
;
}
nsresult
HTMLEditRules
:
:
RemoveAlignment
(
nsINode
&
aNode
const
nsAString
&
aAlignType
bool
aChildrenOnly
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
EditorBase
:
:
IsTextNode
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsTable
(
&
aNode
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
child
tmp
;
if
(
aChildrenOnly
)
{
child
=
aNode
.
GetFirstChild
(
)
;
}
else
{
child
=
&
aNode
;
}
bool
useCSS
=
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
;
while
(
child
)
{
if
(
aChildrenOnly
)
{
tmp
=
child
-
>
GetNextSibling
(
)
;
}
else
{
tmp
=
nullptr
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MakeSureElemStartsAndEndsOnCR
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
*
child
-
>
AsElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
child
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveAttributeWithTransaction
(
*
child
-
>
AsElement
(
)
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
useCSS
)
{
if
(
child
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
child
-
>
AsElement
(
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsAutoString
dummyCssValue
;
nsresult
rv
=
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
RemoveCSSInlineStyle
(
*
child
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
child
=
tmp
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
bool
aStarts
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsINode
*
child
=
aStarts
?
HTMLEditorRef
(
)
.
GetFirstEditableChild
(
aNode
)
:
HTMLEditorRef
(
)
.
GetLastEditableChild
(
aNode
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
NS_OK
;
}
bool
foundCR
=
false
;
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
else
{
nsINode
*
sibling
=
aStarts
?
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
&
aNode
)
:
HTMLEditorRef
(
)
.
GetNextHTMLSibling
(
&
aNode
)
;
if
(
sibling
)
{
if
(
IsBlockNode
(
*
sibling
)
|
|
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
}
else
{
foundCR
=
true
;
}
}
if
(
!
foundCR
)
{
EditorRawDOMPoint
pointToInsert
;
if
(
!
aStarts
)
{
pointToInsert
.
SetToEndOf
(
&
aNode
)
;
}
else
{
pointToInsert
.
Set
(
&
aNode
0
)
;
}
RefPtr
<
Element
>
brElement
=
HTMLEditorRef
(
)
.
InsertBrElementWithTransaction
(
SelectionRef
(
)
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsAndEndsOnCR
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsresult
rv
=
MakeSureElemStartsOrEndsOnCR
(
aNode
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MakeSureElemStartsOrEndsOnCR
(
aNode
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignBlock
(
Element
&
aElement
const
nsAString
&
aAlignType
ContentsOnly
aContentsOnly
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
IsBlockNode
(
aElement
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RemoveAlignment
(
aElement
aAlignType
aContentsOnly
=
=
ContentsOnly
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
)
{
return
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
SupportsAlignAttr
(
aElement
)
)
)
{
return
NS_OK
;
}
rv
=
HTMLEditorRef
(
)
.
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ChangeIndentation
(
Element
&
aElement
Change
aChange
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChange
=
=
Change
:
:
plus
?
+
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
SetCSSProperty
(
aElement
marginProperty
newValue
)
;
return
NS_OK
;
}
HTMLEditorRef
(
)
.
mCSSEditUtils
-
>
RemoveCSSProperty
(
aElement
marginProperty
value
)
;
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
&
aElement
=
=
HTMLEditorRef
(
)
.
GetActiveEditingHost
(
)
|
|
!
HTMLEditorRef
(
)
.
IsDescendantOfEditorRoot
(
&
aElement
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
focusElement
=
HTMLEditorRef
(
)
.
GetSelectionContainer
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
mNewBlock
=
focusElement
;
return
NS_OK
;
}
nsresult
rv
=
NormalizeSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
arrayOfRanges
EditAction
:
:
setAbsolutePosition
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
setAbsolutePosition
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
positionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
positionedDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
positionedDiv
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
ErrorResult
error
;
SelectionRef
(
)
.
Collapse
(
RawRangeBoundary
(
positionedDiv
0
)
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curPositionedDiv
indentedLI
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
curNode
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
curPositionedDiv
)
{
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
NS_WARNING_ASSERTION
(
curPositionedDiv
"
Failed
to
create
current
positioned
div
element
"
)
;
mNewBlock
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
;
atEndOfCurPositionedDiv
.
SetToEndOf
(
curPositionedDiv
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
atEndOfCurPositionedDiv
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
RefPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
if
(
curList
)
{
sibling
=
HTMLEditorRef
(
)
.
GetPriorHTMLSibling
(
listItem
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
containerName
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
curPositionedDiv
)
{
EditorRawDOMPoint
atListItemParent
(
atListItem
.
GetContainer
(
)
)
;
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
atListItemParent
)
;
NS_WARNING_ASSERTION
(
curPositionedDiv
"
Failed
to
create
current
positioned
div
element
"
)
;
mNewBlock
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
;
atEndOfCurPositionedDiv
.
SetToEndOf
(
curPositionedDiv
)
;
curList
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
containerName
atEndOfCurPositionedDiv
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
!
curPositionedDiv
)
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
curPositionedDiv
=
curNode
-
>
AsElement
(
)
;
mNewBlock
=
curPositionedDiv
;
curList
=
nullptr
;
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curPositionedDiv
=
HTMLEditorRef
(
)
.
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
curPositionedDiv
)
)
{
return
NS_ERROR_FAILURE
;
}
mNewBlock
=
curPositionedDiv
;
}
rv
=
HTMLEditorRef
(
)
.
MoveNodeToEndWithTransaction
(
*
curNode
-
>
AsContent
(
)
*
curPositionedDiv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidAbsolutePosition
(
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
!
mNewBlock
)
{
return
NS_OK
;
}
nsresult
rv
=
HTMLEditorRef
(
)
.
SetPositionToAbsoluteOrStatic
(
*
mNewBlock
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRemoveAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
element
=
HTMLEditorRef
(
)
.
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRelativeChangeZIndex
(
int32_t
aChange
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aCancel
)
|
|
NS_WARN_IF
(
!
aHandled
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
WillInsert
(
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
RefPtr
<
Element
>
element
=
HTMLEditorRef
(
)
.
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSelectionRestorer
selectionRestorer
(
&
SelectionRef
(
)
&
HTMLEditorRef
(
)
)
;
int32_t
zIndex
;
nsresult
rv
=
HTMLEditorRef
(
)
.
RelativeChangeElementZIndex
(
*
element
aChange
&
zIndex
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DocumentModified
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditRules
:
:
DocumentModifiedWorker
"
this
&
HTMLEditRules
:
:
DocumentModifiedWorker
)
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
DocumentModifiedWorker
(
)
{
if
(
!
mHTMLEditor
)
{
return
;
}
Selection
*
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
*
selection
)
;
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
if
(
mBogusNode
)
{
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
DeleteNodeWithTransaction
(
*
mBogusNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
bogus
node
"
)
;
mBogusNode
=
nullptr
;
}
CreateBogusNodeIfNeeded
(
)
;
}
}
