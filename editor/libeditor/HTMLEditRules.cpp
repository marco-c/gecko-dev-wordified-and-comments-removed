#
include
"
HTMLEditRules
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
<
algorithm
>
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
using
namespace
dom
;
enum
{
kLonely
=
0
kPrevSib
=
1
kNextSib
=
2
kBothSibs
=
3
}
;
static
bool
IsStyleCachePreservingSubAction
(
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertQuotation
:
case
EditSubAction
:
:
eInsertQuotedText
:
return
true
;
default
:
return
false
;
}
}
class
TableCellAndListItemFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
aNode
)
;
}
}
;
class
BRNodeFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
}
;
class
EmptyEditableFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
EmptyEditableFunctor
(
HTMLEditor
*
aHTMLEditor
)
:
mHTMLEditor
(
aHTMLEditor
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
if
(
mHTMLEditor
-
>
IsEditable
(
aNode
)
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
aNode
)
)
)
{
bool
bIsEmptyNode
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
aNode
&
bIsEmptyNode
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
bIsEmptyNode
)
{
return
true
;
}
}
return
false
;
}
protected
:
HTMLEditor
*
mHTMLEditor
;
}
;
class
MOZ_RAII
AutoSetTemporaryAncestorLimiter
final
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
public
:
explicit
AutoSetTemporaryAncestorLimiter
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
nsINode
&
aStartPointNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
aSelection
.
GetAncestorLimiter
(
)
)
{
return
;
}
Element
*
root
=
aHTMLEditor
.
FindSelectionRoot
(
&
aStartPointNode
)
;
if
(
root
)
{
aHTMLEditor
.
InitializeSelectionAncestorLimit
(
*
root
)
;
mSelection
=
&
aSelection
;
}
}
~
AutoSetTemporaryAncestorLimiter
(
)
{
if
(
mSelection
)
{
mSelection
-
>
SetAncestorLimiter
(
nullptr
)
;
}
}
private
:
RefPtr
<
Selection
>
mSelection
;
}
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundary
&
aStartRef
RangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RawRangeBoundary
&
aStartRef
RangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundary
&
aStartRef
RawRangeBoundary
&
aEndRef
)
;
template
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RawRangeBoundary
&
aStartRef
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RawRangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RawRangeBoundary
&
aStartRef
const
RangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RangeBoundary
&
aPoint
ScanDirection
aScanDirection
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RawRangeBoundary
&
aPoint
ScanDirection
aScanDirection
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RangeBoundary
&
aPoint
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RawRangeBoundary
&
aPoint
EditSubAction
aEditSubAction
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RangeBoundary
&
aPoint
)
;
template
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RawRangeBoundary
&
aPoint
)
;
template
Element
*
HTMLEditor
:
:
GetInvisibleBRElementAt
(
const
EditorDOMPoint
&
aPoint
)
;
template
Element
*
HTMLEditor
:
:
GetInvisibleBRElementAt
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorDOMPoint
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
template
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorRawDOMPoint
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
HTMLEditRules
:
:
HTMLEditRules
(
)
:
mHTMLEditor
(
nullptr
)
mInitialized
(
false
)
{
mIsHTMLEditRules
=
true
;
}
nsresult
HTMLEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
|
|
NS_WARN_IF
(
!
aTextEditor
-
>
AsHTMLEditor
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mHTMLEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
nsresult
rv
=
TextEditRules
:
:
Init
(
aTextEditor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
bodyOrDocumentElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
&
&
!
HTMLEditorRef
(
)
.
GetDocument
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
bodyOrDocumentElement
)
{
nsresult
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
RawRangeBoundary
(
bodyOrDocumentElement
0
)
RawRangeBoundary
(
bodyOrDocumentElement
bodyOrDocumentElement
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
<
br
>
elements
to
empty
list
items
and
table
cells
"
)
;
}
mInitialized
=
true
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DetachEditor
(
)
{
mHTMLEditor
=
nullptr
;
return
TextEditRules
:
:
DetachEditor
(
)
;
}
nsresult
HTMLEditRules
:
:
BeforeEdit
(
)
{
MOZ_ASSERT
(
!
mIsHandling
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
mInitialized
)
{
return
NS_OK
;
}
#
ifdef
DEBUG
mIsHandling
=
true
;
#
endif
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
HTMLEditorRef
(
)
.
GetCompositionStartPoint
(
)
.
IsSet
(
)
)
{
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
HTMLEditorRef
(
)
.
GetCompositionStartPoint
(
)
HTMLEditorRef
(
)
.
GetCompositionEndPoint
(
)
)
;
}
else
{
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StoreRange
(
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
)
;
}
nsCOMPtr
<
nsINode
>
selStartNode
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
selEndNode
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
mEndContainer
;
HTMLEditorRef
(
)
.
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
bool
cacheInlineStyles
;
switch
(
HTMLEditorRef
(
)
.
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
cacheInlineStyles
=
true
;
break
;
default
:
cacheInlineStyles
=
IsStyleCachePreservingSubAction
(
HTMLEditorRef
(
)
.
GetTopLevelEditSubAction
(
)
)
;
break
;
}
if
(
cacheInlineStyles
)
{
nsCOMPtr
<
nsINode
>
selNode
=
HTMLEditorRef
(
)
.
GetDirectionOfTopLevelEditSubAction
(
)
=
=
nsIEditor
:
:
eNext
?
selEndNode
:
selStartNode
;
if
(
NS_WARN_IF
(
!
selNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
CacheInlineStyles
(
*
selNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
Document
*
doc
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
doc
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
doc
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
=
true
;
}
nsresult
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureSelectionInBodyOrDocumentElement
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEdit
(
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
mInitialized
)
{
return
NS_OK
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mIsHandling
)
;
mIsHandling
=
false
;
#
endif
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
OnEndHandlingTopLevelEditSubActionInternal
(
)
;
HTMLEditorRef
(
)
.
RangeUpdaterRef
(
)
.
DropRangeItem
(
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
)
;
if
(
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
mRestoreContentEditableCount
)
{
Document
*
doc
=
HTMLEditorRef
(
)
.
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
doc
-
>
GetEditingState
(
)
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
doc
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
OnEndHandlingTopLevelEditSubActionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubActionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
EnsureSelectionInBodyOrDocumentElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureSelectionInBodyOrDocumentElement
(
)
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eReplaceHeadWithHTMLSource
:
case
EditSubAction
:
:
eCreatePaddingBRElementForEmptyEditor
:
return
NS_OK
;
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
IsPositioned
(
)
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eUndo
&
&
GetTopLevelEditSubAction
(
)
!
=
EditSubAction
:
:
eRedo
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eDeleteText
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
default
:
{
RefPtr
<
nsRange
>
extendedChangedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
GetTopLevelEditSubAction
(
)
)
;
if
(
extendedChangedRange
)
{
MOZ_ASSERT
(
extendedChangedRange
-
>
IsPositioned
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
=
std
:
:
move
(
extendedChangedRange
)
;
}
break
;
}
}
if
(
GetTopLevelEditSubAction
(
)
=
=
EditSubAction
:
:
eDeleteSelectedContent
&
&
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
&
&
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
StartRef
(
)
.
AsRaw
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
)
"
"
failed
but
ignored
"
)
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
break
;
default
:
{
nsresult
rv
=
CollapseAdjacentTextNodes
(
MOZ_KnownLive
(
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
break
;
}
}
rv
=
RemoveEmptyNodesIn
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
{
EditorRawDOMPoint
pointToAdjust
(
GetCompositionEndPoint
(
)
)
;
if
(
!
pointToAdjust
.
IsSet
(
)
)
{
pointToAdjust
=
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToAdjust
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
WSRunObject
(
this
pointToAdjust
)
.
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
WSRunObject
(
this
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartRawPoint
(
)
)
.
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
IsCollapsed
(
)
)
{
WSRunObject
(
this
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
EndRawPoint
(
)
)
.
AdjustWhitespace
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
break
;
}
default
:
break
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretInBlockElement
(
MOZ_KnownLive
(
*
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureSelectionInBlockElement
(
)
failed
but
ignored
"
)
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
ePasteHTMLContent
:
case
EditSubAction
:
:
eInsertHTMLSource
:
rv
=
AdjustCaretPositionAndEnsurePaddingBRElement
(
GetDirectionOfTopLevelEditSubAction
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
break
;
default
:
break
;
}
}
bool
reapplyCachedStyle
;
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
reapplyCachedStyle
=
true
;
break
;
default
:
reapplyCachedStyle
=
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
;
break
;
}
if
(
reapplyCachedStyle
)
{
mTypeInState
-
>
UpdateSelState
(
SelectionRefPtr
(
)
)
;
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
.
Clear
(
)
;
}
}
rv
=
HandleInlineSpellCheck
(
TopLevelEditSubActionDataRef
(
)
.
mSelectedRange
-
>
StartPoint
(
)
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
SetSelectionInterlinePosition
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
EditActionCanceled
(
)
;
}
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
nsINode
*
selStartNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
selStartNode
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
IsModifiableNode
(
*
selStartNode
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
selEndNode
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
selStartNode
=
=
selEndNode
)
{
return
EditActionIgnored
(
)
;
}
if
(
!
IsModifiableNode
(
*
selEndNode
)
)
{
return
EditActionCanceled
(
)
;
}
nsINode
*
commonAncestor
=
range
-
>
GetCommonAncestor
(
)
;
if
(
NS_WARN_IF
(
!
commonAncestor
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
IsModifiableNode
(
*
commonAncestor
)
)
{
return
EditActionCanceled
(
)
;
}
return
EditActionIgnored
(
)
;
}
nsresult
HTMLEditRules
:
:
WillDoAction
(
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
MOZ_ASSERT
(
aCancel
)
;
MOZ_ASSERT
(
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
EditActionResult
result
=
HTMLEditorRef
(
)
.
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
if
(
result
.
Canceled
(
)
)
{
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
NS_OK
;
}
*
aCancel
=
true
;
return
NS_OK
;
}
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertQuotedText
:
{
*
aCancel
=
IsReadonly
(
)
|
|
IsDisabled
(
)
;
nsresult
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
HTMLEditorRef
(
)
)
.
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
case
EditSubAction
:
:
eComputeTextToOutput
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eDecreaseZIndex
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eIncreaseZIndex
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertHTMLSource
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eUndo
:
case
EditSubAction
:
:
eRedo
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eRemoveTextProperty
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eSetPositionToStatic
:
case
EditSubAction
:
:
eSetTextProperty
:
MOZ_ASSERT_UNREACHABLE
(
"
This
path
should
'
ve
been
dead
code
"
)
;
return
NS_ERROR_UNEXPECTED
;
default
:
return
TextEditRules
:
:
WillDoAction
(
aInfo
aCancel
aHandled
)
;
}
}
nsresult
HTMLEditRules
:
:
DidDoAction
(
EditSubActionInfo
&
aInfo
nsresult
aResult
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
switch
(
aInfo
.
mEditSubAction
)
{
case
EditSubAction
:
:
eInsertQuotedText
:
return
NS_OK
;
case
EditSubAction
:
:
eComputeTextToOutput
:
case
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eDecreaseZIndex
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
case
EditSubAction
:
:
eIncreaseZIndex
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eInsertElement
:
case
EditSubAction
:
:
eInsertHTMLSource
:
case
EditSubAction
:
:
eInsertLineBreak
:
case
EditSubAction
:
:
eInsertParagraphSeparator
:
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eUndo
:
case
EditSubAction
:
:
eRedo
:
case
EditSubAction
:
:
eRemoveList
:
case
EditSubAction
:
:
eRemoveTextProperty
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eSetPositionToStatic
:
case
EditSubAction
:
:
eSetTextProperty
:
MOZ_ASSERT_UNREACHABLE
(
"
This
path
should
'
ve
been
dead
code
"
)
;
return
NS_ERROR_UNEXPECTED
;
default
:
return
TextEditRules
:
:
DidDoAction
(
aInfo
aResult
)
;
}
}
bool
HTMLEditRules
:
:
DocumentIsEmpty
(
)
const
{
return
HTMLEditorRef
(
)
.
HasPaddingBRElementForEmptyEditor
(
)
;
}
nsresult
HTMLEditRules
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aOL
=
false
;
*
aUL
=
false
;
*
aDL
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eCreateOrChangeList
HTMLEditor
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
curNode
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
dom
:
:
Element
*
parent
=
curNode
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
}
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
*
aDL
=
true
;
}
else
{
bNonList
=
true
;
}
}
if
(
(
*
aUL
+
*
aOL
+
*
aDL
+
bNonList
)
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aLI
=
false
;
*
aDT
=
false
;
*
aDD
=
false
;
bool
bNonList
=
false
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eCreateOrChangeList
HTMLEditor
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
node
:
arrayOfNodes
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
node
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
*
aLI
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
if
(
*
aDT
&
&
*
aDD
)
{
continue
;
}
DefinitionListItemScanner
scanner
(
*
node
-
>
AsElement
(
)
)
;
*
aDT
|
=
scanner
.
DTElementFound
(
)
;
*
aDD
|
=
scanner
.
DDElementFound
(
)
;
}
else
{
bNonList
=
true
;
}
}
if
(
*
aDT
+
*
aDD
+
bNonList
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
MOZ_ASSERT
(
aMixed
&
&
aAlign
)
;
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
*
aMixed
=
false
;
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
if
(
NS_WARN_IF
(
!
HTMLEditorRef
(
)
.
GetRoot
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
Element
>
root
=
*
HTMLEditorRef
(
)
.
GetRoot
(
)
;
int32_t
rootOffset
=
root
-
>
GetParentNode
(
)
?
root
-
>
GetParentNode
(
)
-
>
ComputeIndexOf
(
root
)
:
-
1
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
|
|
atStartOfSelection
.
GetContainerAsText
(
)
)
{
nodeToExamine
=
atStartOfSelection
.
GetContainer
(
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
static_cast
<
uint32_t
>
(
rootOffset
)
)
{
nodeToExamine
=
HTMLEditorRef
(
)
.
GetNextEditableNode
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
HTMLEditorRef
(
)
.
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eSetOrClearAlignment
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CollectEditTargetNodes
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eSetOrClearAlignment
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nodeToExamine
=
arrayOfNodes
.
SafeElementAt
(
0
)
;
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
blockParent
=
HTMLEditorRef
(
)
.
GetBlock
(
*
nodeToExamine
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditorRef
(
)
.
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
blockParent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetCSSEquivalentToHTMLInlineStyleSet
(
blockParent
nullptr
nsGkAtoms
:
:
align
value
CSSEditUtils
:
:
eComputed
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
bool
isFirstNodeToExamine
=
true
;
for
(
;
nodeToExamine
;
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
)
{
if
(
!
isFirstNodeToExamine
&
&
nodeToExamine
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
NS_OK
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
nodeToExamine
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
textAlign
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
}
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
nodeToExamine
)
)
{
nsAutoString
typeAttrVal
;
nodeToExamine
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
typeAttrVal
)
;
ToLowerCase
(
typeAttrVal
)
;
if
(
!
typeAttrVal
.
IsEmpty
(
)
)
{
if
(
typeAttrVal
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
}
else
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
}
return
NS_OK
;
}
}
isFirstNodeToExamine
=
false
;
}
return
NS_OK
;
}
static
nsStaticAtom
&
MarginPropertyAtomForIndent
(
nsINode
&
aNode
)
{
nsAutoString
direction
;
CSSEditUtils
:
:
GetComputedProperty
(
aNode
*
nsGkAtoms
:
:
direction
direction
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditRules
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
*
aMixed
=
true
;
outFormat
.
Truncate
(
0
)
;
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
bool
bMixed
=
false
;
nsAutoString
formatStr
(
NS_LITERAL_STRING
(
"
x
"
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetParagraphFormatNodes
(
arrayOfNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
curNode
=
arrayOfNodes
[
i
]
;
nsAutoString
format
;
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
curNode
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
rv
=
AppendInnerFormatNodes
(
arrayOfNodes
curNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
arrayOfNodes
.
AppendElement
(
*
atCaret
.
GetContainer
(
)
)
;
}
Element
*
rootElement
=
HTMLEditorRef
(
)
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
GetFormatString
(
curNode
format
)
;
}
else
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
curNode
)
)
{
continue
;
}
else
{
nsINode
*
node
=
curNode
-
>
GetParentNode
(
)
;
while
(
node
)
{
if
(
node
=
=
rootElement
)
{
format
.
Truncate
(
0
)
;
break
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
)
{
GetFormatString
(
node
format
)
;
break
;
}
node
=
node
-
>
GetParentNode
(
)
;
}
}
if
(
formatStr
.
EqualsLiteral
(
"
x
"
)
)
{
formatStr
=
format
;
}
else
if
(
format
!
=
formatStr
)
{
bMixed
=
true
;
break
;
}
}
*
aMixed
=
bMixed
;
outFormat
=
formatStr
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
HTMLEditor
:
:
NodeIsBlockStatic
(
*
child
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
child
)
;
if
(
isBlock
&
&
!
isFormat
)
{
AppendInnerFormatNodes
(
aArray
child
)
;
}
else
if
(
isFormat
)
{
aArray
.
AppendElement
(
*
child
)
;
}
else
if
(
!
foundInline
)
{
foundInline
=
true
;
aArray
.
AppendElement
(
*
child
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetFormatString
(
nsINode
*
aNode
nsAString
&
outFormat
)
{
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
aNode
)
)
{
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
outFormat
)
;
}
else
{
outFormat
.
Truncate
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atSelectionStart
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atSelectionStart
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
GetPreviousEditableHTMLNode
(
atSelectionStart
)
;
if
(
!
previousEditableContent
|
|
!
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
previousEditableContent
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
blockElementAtSelectionStart
=
GetBlock
(
*
atSelectionStart
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
parentBlockElementOfPreviousEditableContent
=
GetBlockNodeParent
(
previousEditableContent
)
;
if
(
!
blockElementAtSelectionStart
|
|
blockElementAtSelectionStart
!
=
parentBlockElementOfPreviousEditableContent
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atPreviousEditableContent
(
previousEditableContent
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atPreviousEditableContent
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
)
{
switch
(
GetTopLevelEditSubAction
(
)
)
{
case
EditSubAction
:
:
eInsertText
:
case
EditSubAction
:
:
eInsertTextComingFromIME
:
case
EditSubAction
:
:
eDeleteSelectedContent
:
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
break
;
}
default
:
break
;
}
}
if
(
!
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
.
Clear
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertText
(
EditSubAction
aEditSubAction
const
nsAString
&
aInsertionString
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
|
|
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
rv
=
CreateStyleForInsertText
(
*
firstRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
EditorBase
:
:
IsTextNode
(
pointToInsert
.
GetContainer
(
)
)
&
&
!
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertTextComingFromIME
)
{
EditorRawDOMPoint
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
if
(
!
compositionStartPoint
.
IsSet
(
)
)
{
compositionStartPoint
=
pointToInsert
;
}
if
(
aInsertionString
.
IsEmpty
(
)
)
{
nsresult
rv
=
InsertTextWithTransaction
(
*
document
aInsertionString
compositionStartPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertTextWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditorRawDOMPoint
compositionEndPoint
=
GetCompositionEndPoint
(
)
;
if
(
!
compositionEndPoint
.
IsSet
(
)
)
{
compositionEndPoint
=
compositionStartPoint
;
}
WSRunObject
wsObj
(
this
compositionStartPoint
compositionEndPoint
)
;
nsresult
rv
=
wsObj
.
InsertText
(
*
document
aInsertionString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
compositionStartPoint
=
GetCompositionStartPoint
(
)
;
compositionEndPoint
=
GetCompositionEndPoint
(
)
;
if
(
NS_WARN_IF
(
!
compositionStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
compositionEndPoint
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
)
;
}
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
compositionStartPoint
.
ToRawRangeBoundary
(
)
compositionEndPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Faliled
to
set
mChangedRange
to
composing
range
"
)
;
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
aEditSubAction
=
=
EditSubAction
:
:
eInsertText
)
;
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
bool
isPRE
=
EditorBase
:
:
IsPreformatted
(
pointToInsert
.
GetContainer
(
)
)
;
AutoRestore
<
bool
>
disableListener
(
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
;
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
=
false
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
int32_t
pos
=
0
;
NS_NAMED_LITERAL_STRING
(
newlineStr
LFSTR
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
isPRE
|
|
IsPlaintextEditor
(
)
)
{
while
(
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
aInsertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
aInsertionString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
aInsertionString
.
Length
(
)
-
oldPos
;
pos
=
aInsertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
aInsertionString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
pos
+
+
;
if
(
brElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
brElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
<
br
>
element
position
has
been
moved
"
"
to
different
point
"
"
by
mutation
observer
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
InsertTextWithTransaction
(
*
document
subStr
EditorRawDOMPoint
(
currentPoint
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
else
{
NS_NAMED_LITERAL_STRING
(
tabStr
"
\
t
"
)
;
NS_NAMED_LITERAL_STRING
(
spacesStr
"
"
)
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
nsAutoString
insertionString
(
aInsertionString
)
;
while
(
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
insertionString
.
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
insertionString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
insertionString
.
Length
(
)
-
oldPos
;
pos
=
insertionString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
insertionString
oldPos
subStrLen
)
;
WSRunObject
wsObj
(
this
currentPoint
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
nsresult
rv
=
wsObj
.
InsertText
(
*
document
spacesStr
&
pointAfterInsertedSpaces
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
pos
+
+
;
MOZ_ASSERT
(
pointAfterInsertedSpaces
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedSpaces
;
pointToInsert
=
pointAfterInsertedSpaces
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
RefPtr
<
Element
>
newBRElement
=
wsObj
.
InsertBreak
(
MOZ_KnownLive
(
*
SelectionRefPtr
(
)
)
currentPoint
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
pos
+
+
;
if
(
newBRElement
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
newBRElement
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
SetToEndOf
(
currentPoint
.
GetContainer
(
)
)
;
}
currentPoint
.
Set
(
newBRElement
)
;
DebugOnly
<
bool
>
advanced
=
currentPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
new
<
br
>
node
"
)
;
NS_WARNING_ASSERTION
(
currentPoint
=
=
pointToInsert
"
Perhaps
newBRElement
has
been
moved
or
removed
unexpectedly
"
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
nsresult
rv
=
wsObj
.
InsertText
(
*
document
subStr
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
MOZ_ASSERT
(
pointAfterInsertedString
.
IsSet
(
)
)
;
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
if
(
currentPoint
.
IsSet
(
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
currentPoint
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
at
current
point
"
)
;
}
if
(
currentPoint
.
IsSet
(
)
)
{
nsresult
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
SetStartAndEnd
(
pointToInsert
.
ToRawRangeBoundary
(
)
currentPoint
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
mChangedRange
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
TopLevelEditSubActionDataRef
(
)
.
mChangedRange
-
>
CollapseTo
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
mChangedRange
"
)
;
return
EditActionHandled
(
rv
)
;
}
bool
HTMLEditor
:
:
CanContainParagraph
(
Element
&
aElement
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
CanContainTag
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
EditActionResult
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
{
if
(
!
mRules
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertParagraphSeparator
nsIEditor
:
:
eNext
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsMailEditor
(
)
)
{
EditorDOMPoint
pointToSplit
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
SplitMailCiteElements
(
pointToSplit
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
if
(
result
.
Handled
(
)
)
{
return
result
;
}
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
IsModifiableNode
(
*
atStartOfSelection
.
GetContainer
(
)
)
)
{
return
EditActionCanceled
(
)
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
editingHost
)
;
ParagraphSeparator
separator
=
GetDefaultParagraphSeparator
(
)
;
bool
insertBRElement
;
if
(
!
blockParent
)
{
insertBRElement
=
true
;
}
else
if
(
editingHost
=
=
blockParent
)
{
insertBRElement
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
CanContainParagraph
(
*
editingHost
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
blockParent
)
)
{
insertBRElement
=
false
;
}
else
{
insertBRElement
=
true
;
for
(
Element
*
blockAncestor
=
blockParent
;
blockAncestor
&
&
insertBRElement
;
blockAncestor
=
HTMLEditor
:
:
GetBlockNodeParent
(
blockAncestor
editingHost
)
)
{
insertBRElement
=
!
CanContainParagraph
(
*
blockAncestor
)
;
}
}
if
(
insertBRElement
)
{
nsresult
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
if
(
editingHost
=
=
blockParent
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
FormatBlockContainerWithTransaction
(
MOZ_KnownLive
(
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
separator
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
failed
"
)
;
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
GetContainer
(
)
editingHost
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
NS_WARN_IF
(
blockParent
=
=
editingHost
)
)
{
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
blockParent
;
}
if
(
IsEmptyBlockElement
(
*
blockParent
IgnoreSingleBR
:
:
No
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditorDOMPoint
endOfBlockParent
;
endOfBlockParent
.
SetToEndOf
(
blockParent
)
;
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
endOfBlockParent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
}
RefPtr
<
Element
>
listItem
=
GetNearestAncestorListItemElement
(
*
blockParent
)
;
if
(
listItem
&
&
listItem
!
=
editingHost
)
{
nsresult
rv
=
HandleInsertParagraphInListItemElement
(
*
listItem
MOZ_KnownLive
(
*
atStartOfSelection
.
GetContainer
(
)
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleInsertParagraphInListItemElement
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
blockParent
)
)
{
nsresult
rv
=
HandleInsertParagraphInHeadingElement
(
*
blockParent
MOZ_KnownLive
(
*
atStartOfSelection
.
GetContainer
(
)
)
atStartOfSelection
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleInsertParagraphInHeadingElement
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atStartOfSelection
)
;
EditActionResult
result
=
HandleInsertParagraphInParagraph
(
*
blockParent
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
if
(
result
.
Handled
(
)
)
{
lockOffset
.
Cancel
(
)
;
return
result
;
}
MOZ_ASSERT
(
!
result
.
Canceled
(
)
"
HandleInsertParagraphInParagraph
(
)
canceled
this
edit
action
"
"
InsertParagraphSeparatorAsSubAction
(
)
needs
to
handle
this
"
"
action
instead
"
)
;
}
rv
=
InsertBRElement
(
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
brElementIsAfterBlock
=
false
;
bool
brElementIsBeforeBlock
=
false
;
RefPtr
<
Element
>
brElement
;
if
(
IsPlaintextEditor
(
)
)
{
brElement
=
InsertBRElementWithTransaction
(
aPointToBreak
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
WSRunObject
wsObj
(
this
pointToBreak
)
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
pointToBreak
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsAfterBlock
=
true
;
}
wsObj
.
NextVisibleNode
(
pointToBreak
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
brElementIsBeforeBlock
=
true
;
}
RefPtr
<
Element
>
linkNode
=
HTMLEditor
:
:
GetLinkElement
(
pointToBreak
.
GetContainer
(
)
)
;
if
(
linkNode
)
{
SplitNodeResult
splitLinkNodeResult
=
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitLinkNodeResult
.
Failed
(
)
)
)
{
return
splitLinkNodeResult
.
Rv
(
)
;
}
pointToBreak
=
splitLinkNodeResult
.
SplitPoint
(
)
;
}
brElement
=
wsObj
.
InsertBreak
(
MOZ_KnownLive
(
*
SelectionRefPtr
(
)
)
pointToBreak
nsIEditor
:
:
eNone
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
NS_WARN_IF
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
EditorRawDOMPoint
point
(
brElement
)
;
error
=
NS_OK
;
SelectionRefPtr
(
)
-
>
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditorDOMPoint
afterBRElement
(
brElement
)
;
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
element
"
)
;
WSRunObject
wsObj
(
this
afterBRElement
)
;
nsCOMPtr
<
nsINode
>
maybeSecondBRNode
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
afterBRElement
address_of
(
maybeSecondBRNode
)
nullptr
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
EditorDOMPoint
atSecondBRElement
(
maybeSecondBRNode
)
;
if
(
brElement
-
>
GetNextSibling
(
)
!
=
maybeSecondBRNode
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
maybeSecondBRNode
-
>
AsContent
(
)
)
afterBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
!
(
nextSiblingOfBRElement
&
&
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nextSiblingOfBRElement
)
)
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
or
unset
interline
position
"
)
;
error
=
NS_OK
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterBRElement
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
SplitMailCiteElements
(
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
RefPtr
<
Element
>
citeNode
=
GetMostAncestorMailCiteElement
(
*
aPointToSplit
.
GetContainer
(
)
)
;
if
(
!
citeNode
)
{
return
EditActionIgnored
(
)
;
}
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
WSRunObject
wsObj
(
this
pointToSplit
)
;
nsCOMPtr
<
nsINode
>
visNode
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
pointToSplit
address_of
(
visNode
)
nullptr
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
&
&
visNode
!
=
citeNode
&
&
citeNode
-
>
Contains
(
visNode
)
)
{
pointToSplit
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplit
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
visible
node
"
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
GetContainerAsContent
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitCiteNodeResult
=
SplitNodeDeepWithTransaction
(
*
citeNode
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
splitCiteNodeResult
.
Failed
(
)
)
)
{
return
EditActionIgnored
(
splitCiteNodeResult
.
Rv
(
)
)
;
}
pointToSplit
.
Clear
(
)
;
nsIContent
*
previousNodeOfSplitPoint
=
splitCiteNodeResult
.
GetPreviousNode
(
)
;
if
(
previousNodeOfSplitPoint
&
&
previousNodeOfSplitPoint
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
&
&
previousNodeOfSplitPoint
-
>
GetPrimaryFrame
(
)
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsCOMPtr
<
nsINode
>
lastChild
=
previousNodeOfSplitPoint
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorDOMPoint
endOfPreviousNodeOfSplitPoint
;
endOfPreviousNodeOfSplitPoint
.
SetToEndOf
(
previousNodeOfSplitPoint
)
;
RefPtr
<
Element
>
invisibleBrElement
=
InsertBRElementWithTransaction
(
endOfPreviousNodeOfSplitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
invisibleBrElement
"
Failed
to
create
an
invisible
<
br
>
element
"
)
;
}
}
EditorDOMPoint
pointToInsertBrNode
(
splitCiteNodeResult
.
SplitPoint
(
)
)
;
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
pointToInsertBrNode
.
Clear
(
)
;
EditorDOMPoint
atBrNode
(
brElement
)
;
Unused
<
<
atBrNode
.
Offset
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
error
=
NS_OK
;
SelectionRefPtr
(
)
-
>
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionIgnored
(
error
.
StealNSResult
(
)
)
;
}
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
*
citeNode
)
)
{
EditorDOMPoint
pointToCreateNewBrNode
(
atBrNode
.
GetContainer
(
)
atBrNode
.
Offset
(
)
)
;
WSRunObject
wsObj
(
this
pointToCreateNewBrNode
)
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
pointToCreateNewBrNode
nullptr
nullptr
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
)
{
EditorRawDOMPoint
pointAfterNewBrNode
(
pointToCreateNewBrNode
)
;
DebugOnly
<
bool
>
advanced
=
pointAfterNewBrNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
<
br
>
node
"
)
;
WSRunObject
wsObjAfterBR
(
this
pointAfterNewBrNode
)
;
wsObjAfterBR
.
NextVisibleNode
(
pointAfterNewBrNode
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
thisBlock
)
{
brElement
=
InsertBRElementWithTransaction
(
pointToCreateNewBrNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_FAILURE
)
;
}
pointToCreateNewBrNode
.
Clear
(
)
;
pointAfterNewBrNode
.
Clear
(
)
;
}
}
}
bool
bEmptyCite
=
false
;
if
(
previousNodeOfSplitPoint
)
{
nsresult
rv
=
IsEmptyNode
(
previousNodeOfSplitPoint
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
bEmptyCite
)
{
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
previousNodeOfSplitPoint
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
}
if
(
citeNode
)
{
nsresult
rv
=
IsEmptyNode
(
citeNode
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
bEmptyCite
)
{
rv
=
DeleteNodeWithTransaction
(
*
citeNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
}
}
return
EditActionHandled
(
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
EditActionResult
result
=
HandleDeleteSelectionInternal
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
if
(
!
result
.
Handled
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
DeleteSelectionWithTransaction
(
)
failed
but
ignored
"
)
;
}
EditorDOMPoint
atNewStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atNewStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atNewStartOfSelection
.
GetContainerAsContent
(
)
)
{
nsresult
rv
=
DeleteMostAncestorMailCiteElementIfEmpty
(
MOZ_KnownLive
(
*
atNewStartOfSelection
.
GetContainerAsContent
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteSelectionInternal
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
=
true
;
if
(
HasPaddingBRElementForEmptyEditor
(
)
)
{
return
EditActionCanceled
(
)
;
}
ErrorResult
error
;
if
(
RefPtr
<
Element
>
cellElement
=
GetFirstSelectedTableCellElement
(
error
)
)
{
error
.
SuppressException
(
)
;
nsresult
rv
=
DeleteTableCellContentsWithTransaction
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteTableCellContentsWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
SelectionWasCollapsed
selectionWasCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
?
SelectionWasCollapsed
:
:
Yes
:
SelectionWasCollapsed
:
:
No
;
if
(
selectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
EditorDOMPoint
startPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
startPoint
.
GetContainerAsContent
(
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
startPoint
)
;
EditActionResult
result
=
MaybeDeleteTopMostEmptyAncestor
(
MOZ_KnownLive
(
*
startPoint
.
GetContainerAsContent
(
)
)
*
editingHost
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Handled
(
)
)
{
return
result
;
}
}
EditActionResult
result
=
SetCaretBidiLevelForDeletion
(
startPoint
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
AutoSetTemporaryAncestorLimiter
autoSetter
(
*
this
*
SelectionRefPtr
(
)
*
startPoint
.
GetContainer
(
)
)
;
nsresult
rv
=
ExtendSelectionForDelete
(
&
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNone
)
{
return
EditActionIgnored
(
)
;
}
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
EditActionResult
result
=
HandleDeleteAroundCollapsedSelection
(
aDirectionAndAmount
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteAroundCollapsedSelection
(
)
failed
"
)
;
return
result
;
}
}
EditActionResult
result
=
HandleDeleteNonCollapsedSelection
(
aDirectionAndAmount
aStripWrappers
selectionWasCollapsed
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteNonCollapasedSelection
(
)
failed
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteAroundCollapsedSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
!
=
nsIEditor
:
:
eNone
)
;
EditorDOMPoint
startPoint
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
WSRunObject
wsObj
(
this
startPoint
)
;
nsCOMPtr
<
nsINode
>
visibleNode
;
int32_t
visibleNodeOffset
;
WSType
wsType
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
NextVisibleNode
(
startPoint
address_of
(
visibleNode
)
&
visibleNodeOffset
&
wsType
)
;
}
else
{
wsObj
.
PriorVisibleNode
(
startPoint
address_of
(
visibleNode
)
&
visibleNodeOffset
&
wsType
)
;
}
if
(
!
visibleNode
)
{
return
EditActionCanceled
(
)
;
}
if
(
wsType
=
=
WSType
:
:
normalWS
)
{
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
aDirectionAndAmount
wsObj
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDelectCollapsedSelectionAtWhiteSpaces
(
)
failed
"
)
;
return
result
;
}
if
(
wsType
=
=
WSType
:
:
text
)
{
if
(
NS_WARN_IF
(
!
visibleNode
-
>
IsText
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtTextNode
(
aDirectionAndAmount
EditorDOMPoint
(
visibleNode
visibleNodeOffset
)
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteCollapsedSelectionAtTextNode
(
)
failed
"
)
;
return
result
;
}
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visibleNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
NS_WARN_IF
(
!
visibleNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtAtomicContent
(
aDirectionAndAmount
aStripWrappers
MOZ_KnownLive
(
*
visibleNode
-
>
AsContent
(
)
)
startPoint
wsObj
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteCollapsedSelectionAtAtomicContent
(
)
failed
"
)
;
return
result
;
}
if
(
wsType
=
=
WSType
:
:
otherBlock
)
{
if
(
NS_WARN_IF
(
!
visibleNode
-
>
IsElement
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
aDirectionAndAmount
aStripWrappers
MOZ_KnownLive
(
*
visibleNode
-
>
AsElement
(
)
)
startPoint
wsObj
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
)
failed
"
)
;
return
result
;
}
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
NS_WARN_IF
(
!
visibleNode
-
>
IsElement
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditActionResult
result
=
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
aDirectionAndAmount
MOZ_KnownLive
(
*
visibleNode
-
>
AsElement
(
)
)
startPoint
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
)
failed
"
)
;
return
result
;
}
MOZ_ASSERT_UNREACHABLE
(
"
New
WSType
value
hasn
'
t
been
handled
yet
"
)
;
return
EditActionIgnored
(
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
WSRunObject
&
aWSRunObjectAtCaret
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
nsresult
rv
=
aWSRunObjectAtCaret
.
DeleteWSForward
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
else
{
nsresult
rv
=
aWSRunObjectAtCaret
.
DeleteWSBackward
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteCollapsedSelectionAtTextNode
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToDelete
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aPointToDelete
.
IsInTextNode
(
)
)
;
OwningNonNull
<
Text
>
visibleTextNode
=
*
aPointToDelete
.
GetContainerAsText
(
)
;
int32_t
startOffset
=
aPointToDelete
.
Offset
(
)
;
int32_t
endOffset
=
startOffset
+
1
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
!
startOffset
)
{
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
}
startOffset
-
-
;
endOffset
-
-
;
if
(
startOffset
>
0
)
{
const
nsTextFragment
*
text
=
&
visibleTextNode
-
>
TextFragment
(
)
;
if
(
text
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
startOffset
)
)
{
startOffset
-
-
;
}
}
}
else
{
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
NS_ASSERTION
(
range
-
>
GetStartContainer
(
)
=
=
aPointToDelete
.
GetContainer
(
)
"
selection
start
not
in
the
text
node
"
)
;
NS_ASSERTION
(
range
-
>
GetEndContainer
(
)
=
=
aPointToDelete
.
GetContainer
(
)
"
selection
end
not
in
the
text
node
"
)
;
startOffset
=
range
-
>
StartOffset
(
)
;
endOffset
=
range
-
>
EndOffset
(
)
;
}
nsCOMPtr
<
nsINode
>
textNodeForDeletion
=
aPointToDelete
.
GetContainer
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
this
address_of
(
textNodeForDeletion
)
&
startOffset
address_of
(
textNodeForDeletion
)
&
endOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
rv
=
DeleteTextWithTransaction
(
visibleTextNode
std
:
:
min
(
startOffset
endOffset
)
DeprecatedAbs
(
endOffset
-
startOffset
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
visibleTextNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeIfInvisibleAndEditableTextNode
(
)
failed
but
ignored
"
)
;
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
return
EditActionHandled
(
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteCollapsedSelectionAtAtomicContent
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
WSRunObject
&
aWSRunObjectAtCaret
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSet
(
)
)
;
if
(
&
aAtomicContent
=
=
aWSRunObjectAtCaret
.
GetEditingHost
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
aAtomicContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsVisibleBRElement
(
&
aAtomicContent
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
aAtomicContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
EditActionResult
result
=
HandleDeleteSelectionInternal
(
aDirectionAndAmount
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Nested
HandleDeleteSelectionInternal
(
)
failed
"
)
;
return
result
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
&
&
aAtomicContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
bool
moveOnly
=
true
;
EditorRawDOMPoint
atHRElement
(
&
aAtomicContent
)
;
ErrorResult
err
;
bool
interLineIsRight
=
SelectionRefPtr
(
)
-
>
GetInterlinePosition
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
EditActionResult
(
err
.
StealNSResult
(
)
)
;
}
if
(
aCaretPoint
.
GetContainer
(
)
=
=
atHRElement
.
GetContainer
(
)
&
&
aCaretPoint
.
Offset
(
)
-
1
=
=
atHRElement
.
Offset
(
)
&
&
!
interLineIsRight
)
{
moveOnly
=
false
;
}
if
(
moveOnly
)
{
EditorDOMPoint
atNextOfHRElement
(
&
aAtomicContent
)
;
DebugOnly
<
bool
>
advanced
=
atNextOfHRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
<
hr
>
element
"
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atNextOfHRElement
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
atNextOfHRElement
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
after
the
<
hr
>
"
)
;
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
unset
interline
position
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mDidExplicitlySetInterLine
=
true
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
aWSRunObjectAtCaret
.
NextVisibleNode
(
aCaretPoint
address_of
(
otherNode
)
nullptr
&
otherWSType
)
;
if
(
otherWSType
!
=
WSType
:
:
br
)
{
return
EditActionHandled
(
)
;
}
if
(
NS_WARN_IF
(
!
otherNode
-
>
IsContent
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
nsIContent
*
otherContent
=
otherNode
-
>
AsContent
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
this
MOZ_KnownLive
(
otherContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
otherContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
this
MOZ_KnownLive
(
&
aAtomicContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
GetPriorHTMLSibling
(
&
aAtomicContent
)
;
rv
=
DeleteNodeWithTransaction
(
aAtomicContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
nsCOMPtr
<
nsINode
>
nextEditableSibling
;
if
(
previousEditableSibling
)
{
nextEditableSibling
=
GetNextHTMLSibling
(
previousEditableSibling
)
;
}
if
(
aCaretPoint
.
GetContainer
(
)
=
=
nextEditableSibling
&
&
aCaretPoint
.
GetContainerAsText
(
)
&
&
previousEditableSibling
-
>
GetAsText
(
)
)
{
EditorDOMPoint
atFirstChildOfRightNode
;
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
previousEditableSibling
MOZ_KnownLive
(
*
aCaretPoint
.
GetContainerAsContent
(
)
)
&
atFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
atFirstChildOfRightNode
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atFirstChildOfRightNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionHandled
(
error
.
StealNSResult
(
)
)
;
}
}
rv
=
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteCollapsedSelectionAtOtherBlockBoundary
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
WSRunObject
&
aWSRunObjectAtCaret
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSet
(
)
)
;
if
(
HTMLEditUtils
:
:
IsTableElement
(
&
aOtherBlockElement
)
)
{
return
EditActionCanceled
(
)
;
}
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
aWSRunObjectAtCaret
.
PriorVisibleNode
(
aCaretPoint
address_of
(
otherNode
)
nullptr
&
otherWSType
)
;
}
else
{
aWSRunObjectAtCaret
.
NextVisibleNode
(
aCaretPoint
address_of
(
otherNode
)
nullptr
&
otherWSType
)
;
}
nsCOMPtr
<
nsIContent
>
leafNode
;
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
leafNode
=
GetLastEditableLeaf
(
aOtherBlockElement
)
;
leftNode
=
leafNode
;
rightNode
=
aCaretPoint
.
GetContainer
(
)
;
}
else
{
leafNode
=
GetFirstEditableLeaf
(
aOtherBlockElement
)
;
leftNode
=
aCaretPoint
.
GetContainer
(
)
;
rightNode
=
leafNode
;
}
bool
didBRElementDeleted
=
false
;
if
(
otherNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
otherNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
didBRElementDeleted
=
true
;
}
if
(
leftNode
&
&
rightNode
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
leftNode
*
rightNode
)
)
{
return
didBRElementDeleted
?
EditActionHandled
(
)
:
EditActionIgnored
(
)
;
}
if
(
didBRElementDeleted
)
{
if
(
NS_WARN_IF
(
!
leafNode
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
newSel
=
GetGoodCaretPointFor
(
*
leafNode
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
!
newSel
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
IgnoredErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
newSel
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
return
EditActionHandled
(
)
;
}
EditActionResult
result
(
NS_OK
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
!
leftNode
)
|
|
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
result
|
=
TryToJoinBlocksWithTransaction
(
MOZ_KnownLive
(
*
leftNode
-
>
AsContent
(
)
)
MOZ_KnownLive
(
*
rightNode
-
>
AsContent
(
)
)
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
}
if
(
!
result
.
Handled
(
)
&
&
!
result
.
Canceled
(
)
&
&
leafNode
!
=
aCaretPoint
.
GetContainer
(
)
)
{
int32_t
offset
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
static_cast
<
int32_t
>
(
leafNode
-
>
Length
(
)
)
:
0
;
DebugOnly
<
nsresult
>
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
leafNode
offset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
HandleDeleteSelectionInternal
(
aDirectionAndAmount
aStripWrappers
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Nested
HandleDeleteSelectionInternal
(
)
failed
"
)
;
return
result
;
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointToPutCaret
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
selection
at
deleted
point
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteCollapsedSelectionAtCurrentBlockBoundary
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
HTMLEditUtils
:
:
IsTableElement
(
&
aCurrentBlockElement
)
)
{
return
EditActionCanceled
(
)
;
}
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
leftNode
=
GetPreviousEditableHTMLNode
(
aCurrentBlockElement
)
;
rightNode
=
aCaretPoint
.
GetContainer
(
)
;
}
else
{
rightNode
=
GetNextEditableHTMLNode
(
aCurrentBlockElement
)
;
leftNode
=
aCaretPoint
.
GetContainer
(
)
;
}
if
(
!
leftNode
|
|
!
rightNode
)
{
return
EditActionCanceled
(
)
;
}
if
(
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
leftNode
*
rightNode
)
)
{
return
EditActionCanceled
(
)
;
}
EditActionResult
result
(
NS_OK
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
!
leftNode
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
rightNode
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
result
|
=
TryToJoinBlocksWithTransaction
(
MOZ_KnownLive
(
*
leftNode
-
>
AsContent
(
)
)
MOZ_KnownLive
(
*
rightNode
-
>
AsContent
(
)
)
)
;
result
.
MarkAsHandled
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointToPutCaret
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
HandleDeleteNonCollapsedSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
=
=
1
)
{
if
(
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
)
{
RefPtr
<
StaticRange
>
extendedRange
=
GetExtendedRangeToIncludeInvisibleNodes
(
*
firstRange
)
;
if
(
NS_WARN_IF
(
!
extendedRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetStartAndEndInLimiter
(
extendedRange
-
>
StartRef
(
)
.
AsRaw
(
)
extendedRange
-
>
EndRef
(
)
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
}
}
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
firstRangeStart
(
firstRange
-
>
StartRef
(
)
)
;
EditorDOMPoint
firstRangeEnd
(
firstRange
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
firstRangeStart
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
firstRangeEnd
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
IsPlaintextEditor
(
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsCOMPtr
<
nsINode
>
startNode
=
firstRangeStart
.
GetContainer
(
)
;
int32_t
startOffset
=
firstRangeStart
.
Offset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
firstRangeEnd
.
GetContainer
(
)
;
int32_t
endOffset
=
firstRangeEnd
.
Offset
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
this
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
firstRangeStart
.
Set
(
startNode
startOffset
)
;
firstRangeEnd
.
Set
(
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
!
firstRangeStart
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
firstRangeEnd
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
if
(
firstRangeStart
.
GetContainer
(
)
=
=
firstRangeEnd
.
GetContainer
(
)
)
{
{
AutoTrackDOMPoint
startTracker
(
RangeUpdaterRef
(
)
&
firstRangeStart
)
;
AutoTrackDOMPoint
endTracker
(
RangeUpdaterRef
(
)
&
firstRangeEnd
)
;
nsresult
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
nsresult
rv
=
DeleteUnnecessaryNodesAndCollapseSelection
(
aDirectionAndAmount
firstRangeStart
firstRangeEnd
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
RefPtr
<
Element
>
startCiteNode
=
GetMostAncestorMailCiteElement
(
*
firstRangeStart
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
endCiteNode
=
GetMostAncestorMailCiteElement
(
*
firstRangeEnd
.
GetContainer
(
)
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
RefPtr
<
Element
>
leftBlock
=
HTMLEditor
:
:
GetBlock
(
*
firstRangeStart
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
rightBlock
=
HTMLEditor
:
:
GetBlock
(
*
firstRangeEnd
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
|
|
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
leftBlock
&
&
leftBlock
=
=
rightBlock
)
{
{
AutoTrackDOMPoint
startTracker
(
RangeUpdaterRef
(
)
&
firstRangeStart
)
;
AutoTrackDOMPoint
endTracker
(
RangeUpdaterRef
(
)
&
firstRangeEnd
)
;
DebugOnly
<
nsresult
>
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteSelectionWithTransaction
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
DeleteUnnecessaryNodesAndCollapseSelection
(
aDirectionAndAmount
firstRangeStart
firstRangeEnd
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
leftBlock
-
>
GetParentNode
(
)
=
=
rightBlock
-
>
GetParentNode
(
)
&
&
AreNodesSameType
(
*
leftBlock
*
rightBlock
)
&
&
(
leftBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
leftBlock
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
leftBlock
)
)
)
{
nsresult
rv
=
DeleteSelectionWithTransaction
(
aDirectionAndAmount
aStripWrappers
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
EditorDOMPoint
atFirstChildOfTheLastRightNode
=
JoinNodesDeepWithTransaction
(
*
leftBlock
*
rightBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
atFirstChildOfTheLastRightNode
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atFirstChildOfTheLastRightNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
EditActionHandled
(
error
.
StealNSResult
(
)
)
;
}
EditActionResult
result
(
NS_OK
)
;
result
.
MarkAsHandled
(
)
;
{
AutoTrackDOMPoint
startTracker
(
RangeUpdaterRef
(
)
&
firstRangeStart
)
;
AutoTrackDOMPoint
endTracker
(
RangeUpdaterRef
(
)
&
firstRangeEnd
)
;
bool
join
=
true
;
AutoRangeArray
arrayOfRanges
(
SelectionRefPtr
(
)
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
result
.
SetResult
(
rv
)
;
}
iter
.
AppendList
(
functor
arrayOfNodes
)
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
j
=
0
;
j
<
listCount
;
j
+
+
)
{
OwningNonNull
<
nsINode
>
node
=
arrayOfNodes
[
0
]
;
nsresult
rv
=
DeleteElementsExceptTableRelatedElements
(
node
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
elements
except
table
related
elements
"
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
if
(
join
&
&
aSelectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
if
(
!
node
-
>
IsContent
(
)
)
{
join
=
false
;
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
Text
*
text
=
content
-
>
GetAsText
(
)
)
{
join
=
!
IsInVisibleTextFrames
(
*
text
)
;
}
else
{
join
=
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsVisibleBRElement
(
node
)
;
}
}
}
}
if
(
firstRangeStart
.
IsInTextNode
(
)
&
&
!
firstRangeStart
.
IsEndOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
firstRangeStart
.
GetContainerAsText
(
)
;
nsresult
rv
=
DeleteTextWithTransaction
(
textNode
firstRangeStart
.
Offset
(
)
firstRangeStart
.
GetContainer
(
)
-
>
Length
(
)
-
firstRangeStart
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
result
.
SetResult
(
rv
)
;
}
}
if
(
firstRangeEnd
.
IsInTextNode
(
)
&
&
!
firstRangeEnd
.
IsStartOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
firstRangeEnd
.
GetContainerAsText
(
)
;
nsresult
rv
=
DeleteTextWithTransaction
(
textNode
0
firstRangeEnd
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
result
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
result
.
SetResult
(
rv
)
;
}
}
if
(
join
)
{
result
|
=
TryToJoinBlocksWithTransaction
(
*
leftBlock
*
rightBlock
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
else
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
}
}
nsresult
rv
=
DeleteUnnecessaryNodesAndCollapseSelection
(
aDirectionAndAmount
firstRangeStart
firstRangeEnd
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteUnnecessaryNodesAndCollapseSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
EditorDOMPoint
atCaret
(
aSelectionStartPoint
)
;
EditorDOMPoint
selectionEndPoint
(
aSelectionEndPoint
)
;
if
(
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
)
{
MOZ_ASSERT
(
atCaret
.
GetContainer
(
)
=
=
selectionEndPoint
.
GetContainer
(
)
)
;
MOZ_ASSERT
(
atCaret
.
Offset
(
)
=
=
selectionEndPoint
.
Offset
(
)
)
;
{
AutoTrackDOMPoint
startTracker
(
RangeUpdaterRef
(
)
&
atCaret
)
;
AutoTrackDOMPoint
endTracker
(
RangeUpdaterRef
(
)
&
selectionEndPoint
)
;
nsresult
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
atCaret
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
=
rv
=
=
NS_OK
;
}
if
(
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
atCaret
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
}
{
AutoTrackDOMPoint
startTracker
(
RangeUpdaterRef
(
)
&
atCaret
)
;
AutoTrackDOMPoint
endTracker
(
RangeUpdaterRef
(
)
&
selectionEndPoint
)
;
nsresult
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
MOZ_KnownLive
(
*
atCaret
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeIfInvisibleAndEditableTextNode
(
)
failed
to
"
"
remove
start
node
but
ignored
"
)
;
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
MOZ_KnownLive
(
*
selectionEndPoint
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeIfInvisibleAndEditableTextNode
(
)
failed
to
"
"
remove
end
node
but
ignored
"
)
;
}
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
selectionEndPoint
.
ToRawRangeBoundary
(
)
:
atCaret
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Text
*
text
=
aNode
.
GetAsText
(
)
;
if
(
!
text
)
{
return
NS_OK
;
}
if
(
IsVisibleTextNode
(
*
text
)
|
|
!
IsModifiableNode
(
*
text
)
)
{
return
NS_OK
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
*
aPointToInsert
.
GetContainer
(
)
)
)
{
return
NS_OK
;
}
WSRunObject
wsObj
(
this
aPointToInsert
)
;
if
(
!
(
wsObj
.
mStartReason
&
(
WSType
:
:
block
|
WSType
:
:
br
)
)
)
{
return
NS_OK
;
}
if
(
!
(
wsObj
.
mEndReason
&
WSType
:
:
block
)
)
{
return
NS_OK
;
}
if
(
!
CanContainTag
(
*
aPointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
aPointToInsert
nsIEditor
:
:
ePrevious
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
Failed
to
insert
<
br
>
element
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
EditorDOMPoint
HTMLEditor
:
:
GetGoodCaretPointFor
(
nsIContent
&
aContent
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePreviousWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
bool
goingForward
=
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eNextWord
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
eToEndOfLine
)
;
if
(
aContent
.
IsText
(
)
|
|
IsContainer
(
&
aContent
)
|
|
NS_WARN_IF
(
!
aContent
.
GetParentNode
(
)
)
)
{
return
EditorDOMPoint
(
&
aContent
goingForward
?
0
:
aContent
.
Length
(
)
)
;
}
if
(
goingForward
)
{
return
EditorDOMPoint
(
&
aContent
)
;
}
if
(
!
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
IsVisibleBRElement
(
&
aContent
)
)
{
EditorDOMPoint
ret
(
&
aContent
)
;
DebugOnly
<
bool
>
advanced
=
ret
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
"
)
;
return
ret
;
}
return
EditorDOMPoint
(
&
aContent
)
;
}
EditActionResult
HTMLEditor
:
:
TryToJoinBlocksWithTransaction
(
nsIContent
&
aLeftContentInBlock
nsIContent
&
aRightContentInBlock
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
leftBlock
=
GetBlock
(
aLeftContentInBlock
)
;
RefPtr
<
Element
>
rightBlock
=
GetBlock
(
aRightContentInBlock
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
|
|
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
if
(
NS_WARN_IF
(
leftBlock
=
=
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
leftBlock
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
rightBlock
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
leftBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
leftBlock
=
GetBlockNodeParent
(
leftBlock
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
rightBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
rightBlock
=
GetBlockNodeParent
(
rightBlock
)
;
if
(
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
leftBlock
=
=
rightBlock
)
{
return
EditActionIgnored
(
)
;
}
if
(
HTMLEditUtils
:
:
IsList
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
&
&
rightBlock
-
>
GetParentNode
(
)
=
=
leftBlock
)
{
return
EditActionHandled
(
)
;
}
bool
mergeListElements
=
false
;
nsAtom
*
leftListElementTagName
=
nsGkAtoms
:
:
_empty
;
RefPtr
<
Element
>
leftListElement
rightListElement
;
if
(
HTMLEditUtils
:
:
IsListItem
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
)
{
leftListElement
=
leftBlock
-
>
GetParentElement
(
)
;
rightListElement
=
rightBlock
-
>
GetParentElement
(
)
;
EditorDOMPoint
atChildInBlock
;
if
(
leftListElement
&
&
rightListElement
&
&
leftListElement
!
=
rightListElement
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftListElement
*
rightBlock
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightListElement
*
leftBlock
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
leftBlock
=
leftListElement
;
rightBlock
=
rightListElement
;
mergeListElements
=
true
;
leftListElementTagName
=
leftListElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
EditorDOMPoint
atRightBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
leftBlock
*
rightBlock
&
atRightBlockChild
)
)
{
MOZ_ASSERT
(
atRightBlockChild
.
GetContainer
(
)
=
=
rightBlock
)
;
DebugOnly
<
bool
>
advanced
=
atRightBlockChild
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
child
of
rightBlock
"
"
leftBlock
is
a
descendant
of
the
child
"
)
;
nsresult
rv
=
WSRunObject
:
:
Scrub
(
*
this
EditorDOMPoint
:
:
AtEndOf
(
*
leftBlock
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
atRightBlockChild
)
;
rv
=
WSRunObject
:
:
Scrub
(
*
this
atRightBlockChild
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
atRightBlockChild
.
GetContainerAsElement
(
)
)
{
rightBlock
=
atRightBlockChild
.
GetContainerAsElement
(
)
;
}
else
if
(
NS_WARN_IF
(
!
atRightBlockChild
.
GetContainerParentAsElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
else
{
rightBlock
=
atRightBlockChild
.
GetContainerParentAsElement
(
)
;
}
}
RefPtr
<
Element
>
invisibleBRElement
=
GetInvisibleBRElementAt
(
EditorDOMPoint
:
:
AtEndOf
(
*
leftBlock
)
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
NS_WARN_IF
(
mergeListElements
)
)
{
ret
.
MarkAsHandled
(
)
;
}
else
{
NS_WARNING_ASSERTION
(
rightBlock
=
=
atRightBlockChild
.
GetContainer
(
)
"
The
relation
is
not
guaranteed
but
assumed
"
)
;
MoveNodeResult
moveNodeResult
=
MoveOneHardLineContents
(
EditorDOMPoint
(
rightBlock
atRightBlockChild
.
Offset
(
)
)
EditorDOMPoint
(
leftBlock
0
)
MoveToEndOfContainer
:
:
Yes
)
;
if
(
NS_WARN_IF
(
moveNodeResult
.
EditorDestroyed
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
moveNodeResult
.
Succeeded
(
)
"
MoveOneHardLineContents
(
)
failed
but
ignored
"
)
;
if
(
moveNodeResult
.
Succeeded
(
)
)
{
ret
|
=
moveNodeResult
;
}
atRightBlockChild
.
Clear
(
)
;
}
if
(
!
invisibleBRElement
)
{
return
ret
;
}
rv
=
DeleteNodeWithTransaction
(
*
invisibleBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeWithTransaction
(
)
failed
removing
"
"
invisible
<
br
>
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
EditorDOMPoint
atLeftBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rightBlock
*
leftBlock
&
atLeftBlockChild
)
)
{
MOZ_ASSERT
(
leftBlock
=
=
atLeftBlockChild
.
GetContainer
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
Scrub
(
*
this
EditorDOMPoint
(
rightBlock
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
RangeUpdaterRef
(
)
&
atLeftBlockChild
)
;
rv
=
WSRunObject
:
:
Scrub
(
*
this
EditorDOMPoint
(
leftBlock
atLeftBlockChild
.
Offset
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
atLeftBlockChild
.
GetContainerAsElement
(
)
)
{
leftBlock
=
atLeftBlockChild
.
GetContainerAsElement
(
)
;
}
else
if
(
NS_WARN_IF
(
!
atLeftBlockChild
.
GetContainerParentAsElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
else
{
leftBlock
=
atLeftBlockChild
.
GetContainerParentAsElement
(
)
;
}
}
RefPtr
<
Element
>
invisibleBRElement
=
GetInvisibleBRElementAt
(
atLeftBlockChild
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeListElements
)
{
NS_WARNING_ASSERTION
(
leftListElement
=
=
atLeftBlockChild
.
GetContainer
(
)
"
This
is
not
guaranteed
but
assumed
"
)
;
MoveNodeResult
moveNodeResult
=
MoveChildren
(
*
rightListElement
EditorDOMPoint
(
leftListElement
atLeftBlockChild
.
Offset
(
)
)
)
;
if
(
NS_WARN_IF
(
moveNodeResult
.
EditorDestroyed
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
moveNodeResult
.
Succeeded
(
)
"
MoveChildren
(
)
failed
but
ignored
"
)
;
if
(
moveNodeResult
.
Succeeded
(
)
)
{
ret
|
=
moveNodeResult
;
}
atLeftBlockChild
.
Clear
(
)
;
}
else
{
EditorDOMPoint
atPreviousContent
;
if
(
&
aLeftContentInBlock
=
=
leftBlock
)
{
atPreviousContent
=
atLeftBlockChild
;
}
else
{
atPreviousContent
.
Set
(
&
aLeftContentInBlock
)
;
atPreviousContent
.
AdvanceOffset
(
)
;
}
MOZ_ASSERT
(
atPreviousContent
.
IsSet
(
)
)
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
|
|
&
aLeftContentInBlock
!
=
editingHost
)
{
nsCOMPtr
<
nsIContent
>
splittedPreviousContent
;
nsCOMPtr
<
nsINode
>
previousContentParent
=
atPreviousContent
.
GetContainer
(
)
;
int32_t
previousContentOffset
=
atPreviousContent
.
Offset
(
)
;
rv
=
SplitStyleAbovePoint
(
address_of
(
previousContentParent
)
&
previousContentOffset
nullptr
nullptr
nullptr
getter_AddRefs
(
splittedPreviousContent
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
splittedPreviousContent
)
{
atPreviousContent
.
Set
(
splittedPreviousContent
)
;
if
(
NS_WARN_IF
(
!
atPreviousContent
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
}
else
{
atPreviousContent
.
Set
(
previousContentParent
previousContentOffset
)
;
if
(
NS_WARN_IF
(
!
atPreviousContent
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
}
}
ret
|
=
MoveOneHardLineContents
(
EditorDOMPoint
(
rightBlock
0
)
atPreviousContent
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
!
invisibleBRElement
)
{
return
ret
;
}
rv
=
DeleteNodeWithTransaction
(
*
invisibleBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteNodeWithTransaction
(
)
failed
removing
"
"
invisible
<
br
>
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
atLeftBlockChild
.
IsSet
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToJoinBlocks
(
*
this
*
leftBlock
*
rightBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
RefPtr
<
Element
>
invisibleBRElement
=
GetInvisibleBRElementAt
(
EditorDOMPoint
:
:
AtEndOf
(
*
leftBlock
)
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeListElements
|
|
leftBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
rightBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
EditorDOMPoint
atFirstChildOfRightNode
;
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
leftBlock
*
rightBlock
&
atFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
JoinNearestEditableNodesWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
mergeListElements
&
&
atFirstChildOfRightNode
.
IsSet
(
)
)
{
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
*
rightBlock
MOZ_KnownLive
(
*
leftListElementTagName
)
*
nsGkAtoms
:
:
li
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
EditorDestroyed
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
convertListTypeResult
.
Succeeded
(
)
"
ChangeListElementType
(
)
failed
but
ignored
"
)
;
}
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveOneHardLineContents
(
EditorDOMPoint
(
rightBlock
0
)
EditorDOMPoint
(
leftBlock
0
)
MoveToEndOfContainer
:
:
Yes
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
!
invisibleBRElement
)
{
return
ret
.
MarkAsHandled
(
)
;
}
rv
=
DeleteNodeWithTransaction
(
*
invisibleBRElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
ret
.
SetResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
return
ret
.
MarkAsHandled
(
)
;
}
MoveNodeResult
HTMLEditor
:
:
MoveOneHardLineContents
(
const
EditorDOMPoint
&
aPointInHardLine
const
EditorDOMPoint
&
aPointToInsert
MoveToEndOfContainer
aMoveToEndOfContainer
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInOneHardLine
(
aPointInHardLine
arrayOfNodes
EditSubAction
:
:
eMergeBlockContents
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
MoveNodeResult
(
rv
)
;
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
return
MoveNodeIgnored
(
aPointToInsert
)
;
}
uint32_t
offset
=
aPointToInsert
.
Offset
(
)
;
MoveNodeResult
result
;
for
(
auto
&
node
:
arrayOfNodes
)
{
if
(
aMoveToEndOfContainer
=
=
MoveToEndOfContainer
:
:
Yes
)
{
offset
=
aPointToInsert
.
GetContainer
(
)
-
>
Length
(
)
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
node
)
)
{
result
|
=
MoveChildren
(
MOZ_KnownLive
(
*
node
-
>
AsElement
(
)
)
EditorDOMPoint
(
aPointToInsert
.
GetContainer
(
)
offset
)
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
offset
=
result
.
NextInsertionPointRef
(
)
.
Offset
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteNodeWithTransaction
(
*
node
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
result
.
MarkAsHandled
(
)
;
if
(
HasMutationEventListeners
(
)
)
{
offset
=
std
:
:
min
(
offset
aPointToInsert
.
GetContainer
(
)
-
>
Length
(
)
)
;
}
continue
;
}
MoveNodeResult
moveNodeResult
=
MoveNodeOrChildren
(
MOZ_KnownLive
(
*
node
-
>
AsContent
(
)
)
EditorDOMPoint
(
aPointToInsert
.
GetContainer
(
)
offset
)
)
;
if
(
NS_WARN_IF
(
moveNodeResult
.
EditorDestroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
moveNodeResult
.
Succeeded
(
)
"
MoveNodeOrChildren
(
)
failed
but
ignored
"
)
;
if
(
moveNodeResult
.
Succeeded
(
)
)
{
offset
=
moveNodeResult
.
NextInsertionPointRef
(
)
.
Offset
(
)
;
result
|
=
moveNodeResult
;
}
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
Last
MoveNodeOrChildren
(
)
failed
"
)
;
return
result
;
}
MoveNodeResult
HTMLEditor
:
:
MoveNodeOrChildren
(
nsIContent
&
aContent
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
CanContain
(
*
aPointToInsert
.
GetContainer
(
)
aContent
)
)
{
uint32_t
offsetAtInserting
=
aPointToInsert
.
Offset
(
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
aContent
aPointToInsert
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
MoveNodeResult
(
rv
)
;
}
return
MoveNodeHandled
(
aPointToInsert
.
GetContainer
(
)
+
+
offsetAtInserting
)
;
}
MoveNodeResult
result
;
if
(
aContent
.
IsElement
(
)
)
{
result
=
MoveChildren
(
MOZ_KnownLive
(
*
aContent
.
AsElement
(
)
)
aPointToInsert
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
}
else
{
result
=
MoveNodeHandled
(
aPointToInsert
)
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
MoveNodeResult
(
rv
)
;
}
if
(
HasMutationEventListeners
(
)
)
{
if
(
!
result
.
NextInsertionPointRef
(
)
.
IsSetAndValid
(
)
)
{
result
=
MoveNodeHandled
(
EditorDOMPoint
:
:
AtEndOf
(
*
aPointToInsert
.
GetContainer
(
)
)
)
;
}
}
return
result
;
}
MoveNodeResult
HTMLEditor
:
:
MoveChildren
(
Element
&
aElement
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
aPointToInsert
.
GetContainer
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MoveNodeResult
result
=
MoveNodeIgnored
(
aPointToInsert
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
result
|
=
MoveNodeOrChildren
(
MOZ_KnownLive
(
*
aElement
.
GetFirstChild
(
)
)
result
.
NextInsertionPoint
(
)
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
}
return
result
;
}
nsresult
HTMLEditor
:
:
DeleteElementsExceptTableRelatedElements
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsTableElementButNotTable
(
&
aNode
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
*
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteElementsExceptTableRelatedElements
(
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteMostAncestorMailCiteElementIfEmpty
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
mailCiteElement
=
GetMostAncestorMailCiteElement
(
aContent
)
;
if
(
!
mailCiteElement
)
{
return
NS_OK
;
}
bool
isEmpty
=
true
seenBR
=
false
;
IsEmptyNodeImpl
(
mailCiteElement
&
isEmpty
true
true
false
&
seenBR
)
;
EditorDOMPoint
atEmptyMailCiteElement
(
mailCiteElement
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atEmptyMailCiteElement
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
mailCiteElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
!
atEmptyMailCiteElement
.
IsSet
(
)
)
|
|
!
seenBR
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
atEmptyMailCiteElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
brElement
)
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
nsAtom
&
aListElementOrListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
;
if
(
!
mRules
)
{
return
EditActionIgnored
(
NS_ERROR_NOT_INITIALIZED
)
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Canceled
(
)
|
|
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
?
EditSubAction
:
:
eCreateOrChangeDefinitionListItem
:
EditSubAction
:
:
eCreateOrChangeList
nsIEditor
:
:
eNext
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
nsAtom
*
listTagName
=
nullptr
;
nsAtom
*
listItemTagName
=
nullptr
;
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ul
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
ol
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
li
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dl
)
{
listTagName
=
&
aListElementOrListItemElementTagName
;
listItemTagName
=
nsGkAtoms
:
:
dd
;
}
else
if
(
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dd
|
|
&
aListElementOrListItemElementTagName
=
=
nsGkAtoms
:
:
dt
)
{
listTagName
=
nsGkAtoms
:
:
dl
;
listItemTagName
=
&
aListElementOrListItemElementTagName
;
}
else
{
return
EditActionResult
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
result
=
ChangeSelectedHardLinesToList
(
MOZ_KnownLive
(
*
listTagName
)
MOZ_KnownLive
(
*
listItemTagName
)
aBulletType
aSelectAllOfCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
ChangeSelectedHardLinesToList
(
)
failed
"
)
;
return
result
;
}
EditActionResult
HTMLEditor
:
:
ChangeSelectedHardLinesToList
(
nsAtom
&
aListElementTagName
nsAtom
&
aListItemElementTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
Element
*
parentListElement
=
aSelectAllOfCurrentList
=
=
SelectAllOfCurrentList
:
:
Yes
?
GetParentListElementAtSelection
(
)
:
nullptr
;
if
(
parentListElement
)
{
arrayOfNodes
.
AppendElement
(
OwningNonNull
<
nsINode
>
(
*
parentListElement
)
)
;
}
else
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
bool
bOnlyBreaks
=
true
;
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
TextEditUtils
:
:
IsBreak
(
curNode
)
&
&
!
IsEmptyInineNode
(
curNode
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
node
:
arrayOfNodes
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
node
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
CanContainTag
(
*
atStartOfSelection
.
GetContainer
(
)
aListElementTagName
)
)
{
return
EditActionCanceled
(
)
;
}
SplitNodeResult
splitAtSelectionStartResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListElementTagName
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitAtSelectionStartResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
splitAtSelectionStartResult
.
Rv
(
)
)
;
}
RefPtr
<
Element
>
theList
=
CreateNodeWithTransaction
(
aListElementTagName
splitAtSelectionStartResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
theList
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
theListItem
=
CreateNodeWithTransaction
(
aListItemElementTagName
EditorDOMPoint
(
theList
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
theListItem
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theListItem
;
restoreSelectionLater
.
Abort
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
theListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
if
(
arrayOfNodes
.
Length
(
)
=
=
1
)
{
if
(
Element
*
deepestDivBlockquoteOrListElement
=
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
arrayOfNodes
[
0
]
)
)
{
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
arrayOfNodes
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
arrayOfNodes
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
}
else
{
arrayOfNodes
.
ReplaceElementAt
(
0
OwningNonNull
<
nsINode
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
}
}
}
uint32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
RefPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
if
(
NS_WARN_IF
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
if
(
curList
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
curList
curNode
)
)
{
curList
=
nullptr
;
}
if
(
IsEditable
(
curNode
)
&
&
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
IsEmptyInineNode
(
curNode
)
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
convertListTypeResult
.
GetNewNode
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
prevListItem
=
nullptr
;
continue
;
}
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aListElementTagName
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
convertListTypeResult
.
Rv
(
)
)
;
}
curList
=
convertListTypeResult
.
forget
(
)
;
prevListItem
=
nullptr
;
continue
;
}
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atCurNode
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
!
atCurNode
.
IsContainerHTMLElement
(
&
aListElementTagName
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
if
(
NS_WARN_IF
(
!
atCurNode
.
GetContainerAsContent
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atCurNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
curList
=
CreateNodeWithTransaction
(
aListElementTagName
EditorDOMPoint
(
atCurNode
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
if
(
!
curNode
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newListItemElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
else
{
if
(
!
curList
)
{
curList
=
atCurNode
.
GetContainerAsElement
(
)
;
NS_WARNING_ASSERTION
(
HTMLEditUtils
:
:
IsList
(
curList
)
"
Current
list
item
parent
is
not
a
list
element
"
)
;
}
else
if
(
atCurNode
.
GetContainer
(
)
!
=
curList
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
curNode
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
if
(
!
curNode
-
>
IsHTMLElement
(
&
aListItemElementTagName
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newListItemElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
}
}
Element
*
curElement
=
Element
:
:
FromNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
curElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aBulletType
.
IsEmpty
(
)
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
*
curElement
)
*
nsGkAtoms
:
:
type
aBulletType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
!
curElement
-
>
HasAttr
(
nsGkAtoms
:
:
type
)
)
{
continue
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
curElement
)
*
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
continue
;
}
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsList
(
curNode
)
&
&
!
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
;
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
CollectChildren
(
*
curNode
arrayOfNodes
i
+
1
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
nsresult
rv
=
RemoveContainerWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
listCount
=
arrayOfNodes
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
SplitNodeResult
splitCurNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aListElementTagName
atCurNode
)
;
if
(
NS_WARN_IF
(
splitCurNodeResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
splitCurNodeResult
.
Rv
(
)
)
;
}
prevListItem
=
nullptr
;
curList
=
CreateNodeWithTransaction
(
aListElementTagName
splitCurNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curList
;
atCurNode
.
Clear
(
)
;
}
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
curNode
)
&
&
prevListItem
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
curNode
*
prevListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newListItemElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
prevListItem
=
nullptr
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
continue
;
}
RefPtr
<
Element
>
newListItemElement
=
InsertContainerWithTransaction
(
*
curNode
aListItemElementTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newListItemElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
curNode
)
)
{
prevListItem
=
newListItemElement
;
}
else
{
prevListItem
=
nullptr
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
*
newListItemElement
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
return
EditActionHandled
(
)
;
}
nsresult
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
return
result
.
Rv
(
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eRemoveList
nsIEditor
:
:
eNext
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
arrayOfNodes
[
i
]
;
if
(
!
IsEditable
(
testNode
)
)
{
arrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
nsAtom
&
blockType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
firstRange
-
>
StartRef
(
)
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
RefPtr
<
Element
>
curBlock
=
GetBlock
(
*
pointToInsertBlock
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brContent
=
GetNextEditableHTMLNode
(
pointToInsertBlock
)
;
if
(
brContent
&
&
brContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
brContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
curBlock
pointToInsertBlock
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
EditorDOMPoint
pointToInsertBrNode
(
splitNodeResult
.
SplitPoint
(
)
)
;
brContent
=
InsertBRElementWithTransaction
(
pointToInsertBrNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brContent
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atBrNode
(
brContent
)
;
restoreSelectionLater
.
Abort
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
brNode
=
GetNextEditableHTMLNodeInBlock
(
pointToInsertBlock
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertBlock
)
;
rv
=
DeleteNodeWithTransaction
(
*
brNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElement
(
brNode
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
blockType
pointToInsertBlock
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
block
=
CreateNodeWithTransaction
(
blockType
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
block
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
block
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
block
0
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
Selection
into
the
new
block
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
rv
=
MoveNodesIntoNewBlockquoteElement
(
arrayOfNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MoveNodesIntoNewBlockquoteElement
(
)
failed
"
)
;
return
rv
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
rv
=
RemoveBlockContainerElements
(
arrayOfNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveBlockContainerElements
(
)
failed
"
)
;
return
rv
;
}
rv
=
CreateOrChangeBlockContainerElement
(
arrayOfNodes
blockType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CreateOrChangeBlockContainerElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
atStartOfSelection
.
Container
(
)
-
>
IsElement
(
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Element
>
startContainerElement
=
*
atStartOfSelection
.
Container
(
)
-
>
AsElement
(
)
;
nsresult
rv
=
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
startContainerElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
IndentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eIndent
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
result
|
=
HandleIndentAtSelection
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
HandleCSSIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleCSSIndentAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
HandleHTMLIndentAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleHTMLIndent
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
HandleCSSIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleCSSIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleCSSIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
block
=
GetBlock
(
*
atCaret
.
GetContainer
(
)
)
;
if
(
block
&
&
HTMLEditUtils
:
:
IsListItem
(
block
)
)
{
arrayOfNodes
.
AppendElement
(
*
block
)
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsEmptyOneHardLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theBlock
;
nsresult
rv
=
ChangeMarginStart
(
*
theBlock
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
restoreSelectionLater
.
Abort
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atStartOfTheBlock
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
curList
curQuote
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
GetNextHTMLSibling
(
curNode
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
nextEditableSibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
EditorDOMPoint
(
nextEditableSibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
GetPriorHTMLSibling
(
curNode
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
previousEditableSibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
previousEditableSibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
}
nsIContent
*
previousEditableSibling
=
curList
?
GetPriorHTMLSibling
(
curNode
)
:
nullptr
;
if
(
!
curList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curList
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
curNode
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
curQuote
=
nullptr
;
continue
;
}
if
(
!
curQuote
)
{
if
(
!
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
ChangeMarginStart
(
*
curQuote
ChangeMargin
:
:
Increase
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curQuote
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
HandleHTMLIndentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandleHTMLIndentAtSelectionInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleHTMLIndentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eIndent
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eIndent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
theBlock
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
restoreSelectionLater
.
Abort
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atStartOfTheBlock
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
curList
curQuote
indentedLI
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
GetNextHTMLSibling
(
curNode
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
nextEditableSibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
nextEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
EditorDOMPoint
(
nextEditableSibling
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
GetPriorHTMLSibling
(
curNode
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
previousEditableSibling
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
previousEditableSibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
previousEditableSibling
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
}
nsIContent
*
previousEditableSibling
=
curList
?
GetPriorHTMLSibling
(
curNode
)
:
nullptr
;
if
(
!
curList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
curList
)
)
{
nsAtom
*
containerName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curList
;
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curQuote
=
nullptr
;
continue
;
}
if
(
RefPtr
<
Element
>
listItem
=
curNode
-
>
IsContent
(
)
?
GetNearestAncestorListItemElement
(
*
curNode
-
>
AsContent
(
)
)
:
nullptr
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
nsIContent
*
previousEditableSibling
=
curList
?
GetPriorHTMLSibling
(
listItem
)
:
nullptr
;
if
(
!
curList
|
|
(
previousEditableSibling
&
&
previousEditableSibling
!
=
curList
)
)
{
EditorDOMPoint
atListItem
(
listItem
)
;
if
(
NS_WARN_IF
(
!
listItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curList
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
MoveNodeToEndWithTransaction
(
*
listItem
*
curList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
indentedLI
=
listItem
;
continue
;
}
if
(
curQuote
&
&
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
curQuote
*
curNode
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
!
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curQuote
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curQuote
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curQuote
;
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curQuote
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
curList
=
nullptr
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
OutdentAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eOutdent
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
result
|
=
HandleOutdentAtSelection
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
result
.
SetResult
(
rv
)
;
}
EditActionResult
HTMLEditor
:
:
HandleOutdentAtSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
SplitRangeOffFromNodeResult
outdentResult
=
HandleOutdentAtSelectionInternal
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
EditActionHandled
(
outdentResult
.
Rv
(
)
)
;
}
if
(
!
outdentResult
.
GetLeftContent
(
)
&
&
!
outdentResult
.
GetRightContent
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
EditActionHandled
(
)
;
}
if
(
outdentResult
.
GetLeftContent
(
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetLeftContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetLeftContent
(
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
outdentResult
.
GetLeftContent
(
)
)
;
afterRememberedLeftBQ
.
AdvanceOffset
(
)
;
IgnoredErrorResult
errorIgnored
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterRememberedLeftBQ
errorIgnored
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
errorIgnored
.
Failed
(
)
"
Selection
:
:
Colapsed
(
)
failed
but
ignored
"
)
;
}
}
if
(
outdentResult
.
GetRightContent
(
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionHandled
(
)
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
if
(
atStartOfSelection
.
Container
(
)
=
=
outdentResult
.
GetRightContent
(
)
|
|
EditorUtils
:
:
IsDescendantOf
(
*
atStartOfSelection
.
Container
(
)
*
outdentResult
.
GetRightContent
(
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
outdentResult
.
GetRightContent
(
)
)
;
IgnoredErrorResult
errorIgnored
;
SelectionRefPtr
(
)
-
>
Collapse
(
atRememberedRightBQ
errorIgnored
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
errorIgnored
.
Failed
(
)
"
Selection
:
:
Colapsed
(
)
failed
but
ignored
"
)
;
}
}
return
EditActionHandled
(
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
HandleOutdentAtSelectionInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
arrayOfNodes
EditSubAction
:
:
eOutdent
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
leftContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
middleContentOfLastOutdented
;
nsCOMPtr
<
nsIContent
>
rightContentOfLastOutdented
;
RefPtr
<
Element
>
indentedParentElement
;
nsCOMPtr
<
nsIContent
>
firstContentToBeOutdented
lastContentToBeOutdented
;
BlockIndentedWith
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
curNode
-
>
IsContent
(
)
)
{
continue
;
}
OwningNonNull
<
nsIContent
>
curContent
=
*
curNode
-
>
AsContent
(
)
;
EditorDOMPoint
atCurContent
(
curContent
)
;
if
(
!
atCurContent
.
IsSet
(
)
)
{
continue
;
}
if
(
curContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
indentedParentElement
)
{
MOZ_ASSERT
(
indentedParentElement
=
=
curContent
)
;
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
curContent
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
&
&
HTMLEditor
:
:
NodeIsBlockStatic
(
curContent
)
)
{
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curContent
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
curContent
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
float
startMargin
=
0
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
curContent
-
>
AsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curContent
)
)
{
if
(
indentedParentElement
)
{
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
}
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
curContent
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
indentedParentElement
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curContent
*
indentedParentElement
)
)
{
lastContentToBeOutdented
=
curContent
;
continue
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
leftContentOfLastOutdented
=
outdentResult
.
GetLeftContent
(
)
;
middleContentOfLastOutdented
=
outdentResult
.
GetMiddleContent
(
)
;
rightContentOfLastOutdented
=
outdentResult
.
GetRightContent
(
)
;
indentedParentElement
=
nullptr
;
firstContentToBeOutdented
=
nullptr
;
lastContentToBeOutdented
=
nullptr
;
}
indentedParentIndentedWith
=
BlockIndentedWith
:
:
HTML
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
for
(
nsCOMPtr
<
nsINode
>
parentNode
=
curContent
-
>
GetParentNode
(
)
;
parentNode
&
&
!
parentNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
parentNode
!
=
editingHost
&
&
(
parentNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
parentNode
)
)
;
parentNode
=
parentNode
-
>
GetParentNode
(
)
)
{
if
(
parentNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
indentedParentElement
=
parentNode
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
curContent
;
lastContentToBeOutdented
=
curContent
;
break
;
}
if
(
!
useCSS
)
{
continue
;
}
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
curContent
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
parentNode
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
float
startMargin
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
startMargin
getter_AddRefs
(
unit
)
)
;
if
(
startMargin
>
0
&
&
!
(
HTMLEditUtils
:
:
IsList
(
atCurContent
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsList
(
curContent
)
)
)
{
indentedParentElement
=
parentNode
-
>
AsElement
(
)
;
firstContentToBeOutdented
=
curContent
;
lastContentToBeOutdented
=
curContent
;
indentedParentIndentedWith
=
BlockIndentedWith
:
:
CSS
;
break
;
}
}
if
(
indentedParentElement
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurContent
.
GetContainer
(
)
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curContent
)
)
{
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
curContent
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curContent
)
)
{
for
(
nsCOMPtr
<
nsIContent
>
lastChildContent
=
curContent
-
>
GetLastChild
(
)
;
lastChildContent
;
lastChildContent
=
curContent
-
>
GetLastChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
lastChildContent
)
)
{
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
lastChildContent
-
>
AsElement
(
)
)
LiftUpFromAllParentListElements
:
:
No
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
lastChildContent
)
)
{
EditorDOMPoint
afterCurrentList
(
atCurContent
)
;
DebugOnly
<
bool
>
advanced
=
afterCurrentList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
set
it
to
after
current
list
element
"
)
;
rv
=
MoveNodeWithTransaction
(
*
lastChildContent
afterCurrentList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
rv
=
DeleteNodeWithTransaction
(
*
lastChildContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
}
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
curContent
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
continue
;
}
if
(
useCSS
)
{
RefPtr
<
Element
>
element
;
if
(
curContent
-
>
IsCharacterData
(
)
)
{
element
=
curContent
-
>
GetParentElement
(
)
;
}
else
if
(
curContent
-
>
IsElement
(
)
)
{
element
=
curContent
-
>
AsElement
(
)
;
}
if
(
element
)
{
nsresult
rv
=
ChangeMarginStart
(
*
element
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ChangeMarginStart
(
)
failed
but
ignored
"
)
;
}
continue
;
}
}
if
(
!
indentedParentElement
)
{
return
SplitRangeOffFromNodeResult
(
leftContentOfLastOutdented
middleContentOfLastOutdented
rightContentOfLastOutdented
)
;
}
SplitRangeOffFromNodeResult
outdentResult
=
OutdentPartOfBlock
(
*
indentedParentElement
*
firstContentToBeOutdented
*
lastContentToBeOutdented
indentedParentIndentedWith
)
;
if
(
NS_WARN_IF
(
outdentResult
.
Failed
(
)
)
)
{
return
outdentResult
;
}
return
outdentResult
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
Element
&
aBlockElement
nsIContent
&
aStartOfRange
nsIContent
&
aEndOfRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfRange
aEndOfRange
)
;
if
(
NS_WARN_IF
(
splitResult
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
splitResult
;
}
NS_WARNING_ASSERTION
(
splitResult
.
Succeeded
(
)
"
Failed
to
split
the
range
off
from
the
block
element
"
)
;
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aBlockElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
SplitRangeOffFromBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfMiddleElement
nsIContent
&
aEndOfMiddleElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartOfMiddleElement
aBlockElement
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aEndOfMiddleElement
aBlockElement
)
)
;
SplitNodeResult
splitAtStartResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
EditorDOMPoint
(
&
aStartOfMiddleElement
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtStartResult
.
Succeeded
(
)
"
Failed
to
split
aBlockElement
at
start
"
)
;
EditorDOMPoint
atAfterEnd
(
&
aEndOfMiddleElement
)
;
DebugOnly
<
bool
>
advanced
=
atAfterEnd
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
end
node
"
)
;
SplitNodeResult
splitAtEndResult
=
SplitNodeDeepWithTransaction
(
aBlockElement
atAfterEnd
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitAtEndResult
.
Succeeded
(
)
"
Failed
to
split
aBlockElement
at
after
end
"
)
;
return
SplitRangeOffFromNodeResult
(
splitAtStartResult
splitAtEndResult
)
;
}
SplitRangeOffFromNodeResult
HTMLEditor
:
:
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOfOutdent
BlockIndentedWith
aBlockIndentedWith
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SplitRangeOffFromNodeResult
splitResult
=
SplitRangeOffFromBlock
(
aBlockElement
aStartOfOutdent
aEndOfOutdent
)
;
if
(
NS_WARN_IF
(
splitResult
.
EditorDestroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
splitResult
.
GetMiddleContentAsElement
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aBlockIndentedWith
=
=
BlockIndentedWith
:
:
HTML
)
{
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitRangeOffFromNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
SplitRangeOffFromNodeResult
(
splitResult
.
GetLeftContent
(
)
nullptr
splitResult
.
GetRightContent
(
)
)
;
}
if
(
splitResult
.
GetMiddleContentAsElement
(
)
)
{
nsresult
rv
=
ChangeMarginStart
(
MOZ_KnownLive
(
*
splitResult
.
GetMiddleContentAsElement
(
)
)
ChangeMargin
:
:
Decrease
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
SplitRangeOffFromNodeResult
(
rv
)
;
}
return
splitResult
;
}
return
splitResult
;
}
CreateElementResult
HTMLEditor
:
:
ChangeListElementType
(
Element
&
aListElement
nsAtom
&
aNewListTag
nsAtom
&
aNewListItemTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
nsIContent
*
childContent
=
aListElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsElement
(
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListItemTag
)
)
{
OwningNonNull
<
Element
>
listItemElement
=
*
childContent
-
>
AsElement
(
)
;
RefPtr
<
Element
>
newListItemElement
=
ReplaceContainerWithTransaction
(
listItemElement
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newListItemElement
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
childContent
=
newListItemElement
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
childContent
-
>
AsElement
(
)
)
&
&
!
childContent
-
>
IsHTMLElement
(
&
aNewListTag
)
)
{
OwningNonNull
<
Element
>
listElement
=
*
childContent
-
>
AsElement
(
)
;
CreateElementResult
convertListTypeResult
=
ChangeListElementType
(
listElement
aNewListTag
aNewListItemTag
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
Failed
(
)
)
)
{
return
convertListTypeResult
;
}
childContent
=
convertListTypeResult
.
GetNewNode
(
)
;
continue
;
}
}
if
(
aListElement
.
IsHTMLElement
(
&
aNewListTag
)
)
{
return
CreateElementResult
(
&
aListElement
)
;
}
RefPtr
<
Element
>
listElement
=
ReplaceContainerWithTransaction
(
aListElement
aNewListTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
listElement
!
=
nullptr
"
Failed
to
create
list
element
"
)
;
return
CreateElementResult
(
listElement
.
forget
(
)
)
;
}
nsresult
HTMLEditor
:
:
CreateStyleForInsertText
(
AbstractRange
&
aAbstractRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aAbstractRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
mTypeInState
)
;
nsCOMPtr
<
nsINode
>
node
=
aAbstractRange
.
GetStartContainer
(
)
;
int32_t
offset
=
aAbstractRange
.
StartOffset
(
)
;
RefPtr
<
Element
>
documentRootElement
=
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
documentRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
PropItem
>
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
bool
weDidSomething
=
false
;
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
while
(
item
&
&
node
!
=
documentRootElement
)
{
nsresult
rv
=
ClearStyle
(
address_of
(
node
)
&
offset
MOZ_KnownLive
(
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
mTypeInState
-
>
TakeClearProperty
(
)
;
weDidSomething
=
true
;
}
}
int32_t
relFontSize
=
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
if
(
item
|
|
relFontSize
)
{
if
(
RefPtr
<
Text
>
text
=
node
-
>
GetAsText
(
)
)
{
SplitNodeResult
splitTextNodeResult
=
SplitNodeDeepWithTransaction
(
*
text
EditorDOMPoint
(
text
offset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitTextNodeResult
.
Failed
(
)
)
)
{
return
splitTextNodeResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPoint
(
splitTextNodeResult
.
SplitPoint
(
)
)
;
node
=
splitPoint
.
GetContainer
(
)
;
offset
=
splitPoint
.
Offset
(
)
;
}
if
(
!
IsContainer
(
node
)
)
{
return
NS_OK
;
}
RefPtr
<
Text
>
newNode
=
CreateTextNode
(
EmptyString
(
)
)
;
if
(
NS_WARN_IF
(
!
newNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InsertNodeWithTransaction
(
*
newNode
EditorDOMPoint
(
node
offset
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
node
=
newNode
;
offset
=
0
;
weDidSomething
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
rv
=
RelativeFontChangeOnTextNode
(
dir
*
newNode
0
-
1
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
while
(
item
)
{
rv
=
SetInlinePropertyOnNode
(
MOZ_KnownLive
(
*
node
-
>
AsContent
(
)
)
MOZ_KnownLive
(
*
item
-
>
tag
)
MOZ_KnownLive
(
item
-
>
attr
)
item
-
>
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
item
=
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
!
weDidSomething
)
{
return
NS_OK
;
}
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
node
offset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
const
{
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
aElement
)
)
{
return
false
;
}
bool
isEmpty
=
true
;
nsresult
rv
=
IsEmptyNode
(
&
aElement
&
isEmpty
aIgnoreSingleBR
=
=
IgnoreSingleBR
:
:
Yes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
IsEmptyNode
(
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
isEmpty
;
}
EditActionResult
HTMLEditor
:
:
AlignAsSubAction
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetOrClearAlignment
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
rv
=
AlignContentsAtSelection
(
aAlignType
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
nodeArray
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodesInExtendedSelectionRanges
(
nodeArray
EditSubAction
:
:
eSetOrClearAlignment
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
createEmptyDivElement
=
nodeArray
.
IsEmpty
(
)
;
if
(
nodeArray
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsINode
>
node
=
nodeArray
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
node
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
node
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetBlockElementAlign
(
)
failed
"
)
;
return
rv
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
atStartOfSelection
.
Container
(
)
;
createEmptyDivElement
=
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parent
)
;
}
}
if
(
createEmptyDivElement
)
{
EditActionResult
result
=
AlignContentsAtSelectionWithEmptyDivElement
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AlignContentsAtSelectionWithEmptyDivElement
(
)
failed
"
)
;
if
(
result
.
Handled
(
)
)
{
restoreSelectionLater
.
Abort
(
)
;
}
return
rv
;
}
rv
=
AlignNodesAndDescendants
(
nodeArray
aAlignType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AlignNodesAndDescendants
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
AlignContentsAtSelectionWithEmptyDivElement
(
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atStartOfSelection
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
splitNodeResult
.
Rv
(
)
)
;
}
EditorDOMPoint
pointToInsertDiv
(
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
nsCOMPtr
<
nsIContent
>
maybeBRContent
=
GetNextEditableHTMLNodeInBlock
(
splitNodeResult
.
SplitPoint
(
)
)
)
{
if
(
TextEditUtils
:
:
IsBreak
(
maybeBRContent
)
&
&
pointToInsertDiv
.
GetChild
(
)
)
{
if
(
nsIContent
*
nextEditableSibling
=
GetNextHTMLSibling
(
pointToInsertDiv
.
GetChild
(
)
)
)
{
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nextEditableSibling
)
)
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsertDiv
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
maybeBRContent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
}
}
}
RefPtr
<
Element
>
divElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
pointToInsertDiv
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
divElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
divElement
;
nsresult
rv
=
SetBlockElementAlign
(
*
divElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
divElement
0
)
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
EditActionResult
(
createPaddingBRResult
.
Rv
(
)
)
;
}
EditorRawDOMPoint
atStartOfDiv
(
divElement
0
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atStartOfDiv
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
EditActionHandled
(
error
.
StealNSResult
(
)
)
;
}
nsresult
HTMLEditor
:
:
AlignNodesAndDescendants
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
const
nsAString
&
aAlignType
)
{
AutoTArray
<
bool
64
>
transitionList
;
HTMLEditor
:
:
MakeTransitionList
(
aArrayOfNodes
transitionList
)
;
RefPtr
<
Element
>
createdDivElement
;
bool
useCSS
=
IsCSSEnabled
(
)
;
int32_t
indexOfTransitionList
=
-
1
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
aArrayOfNodes
)
{
+
+
indexOfTransitionList
;
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
curNode
)
)
{
nsresult
rv
=
SetBlockElementAlign
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aAlignType
EditTarget
:
:
NodeAndDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
continue
;
}
bool
isEmptyTextNode
=
false
;
if
(
curNode
-
>
IsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsTableElement
(
atCurNode
.
GetContainer
(
)
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
atCurNode
.
GetContainer
(
)
)
)
|
|
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
|
|
(
NS_SUCCEEDED
(
IsEmptyNode
(
curNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
Element
*
listOrListItemElement
=
curNode
-
>
AsElement
(
)
;
AutoEditorDOMPointOffsetInvalidator
lockChild
(
atCurNode
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
useCSS
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
MOZ_KnownLive
(
listOrListItemElement
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
createdDivElement
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
nsresult
rv
=
AlignContentsInAllTableCellsAndListItems
(
MOZ_KnownLive
(
*
listOrListItemElement
)
aAlignType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
createdDivElement
=
nullptr
;
continue
;
}
}
if
(
!
createdDivElement
|
|
transitionList
[
indexOfTransitionList
]
)
{
if
(
!
CanContainTag
(
*
atCurNode
.
GetContainer
(
)
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
createdDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
createdDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
createdDivElement
;
nsresult
rv
=
SetBlockElementAlign
(
*
createdDivElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetBlockElementAlign
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
createdDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignContentsInAllTableCellsAndListItems
(
Element
&
aElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
nodeArray
;
TableCellAndListItemFunctor
functor
;
DOMIterator
iter
(
aElement
)
;
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
MOZ_ASSERT
(
node
-
>
IsElement
(
)
)
;
nsresult
rv
=
AlignBlockContentsWithDivElement
(
MOZ_KnownLive
(
*
node
-
>
AsElement
(
)
)
aAlignType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AlignBlockContentsWithDivElement
(
Element
&
aBlockElement
const
nsAString
&
aAlignType
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
firstEditableContent
=
GetFirstEditableChild
(
aBlockElement
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
lastEditableContent
=
GetLastEditableChild
(
aBlockElement
)
;
if
(
firstEditableContent
=
=
lastEditableContent
&
&
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
MOZ_KnownLive
(
firstEditableContent
-
>
AsElement
(
)
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetAttributeOrEquivalent
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
divElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
&
aBlockElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
divElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
SetAttributeOrEquivalent
(
divElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
lastEditableContent
&
&
(
lastEditableContent
!
=
divElement
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
*
lastEditableContent
EditorDOMPoint
(
divElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
lastEditableContent
=
GetLastEditableChild
(
aBlockElement
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
MaybeDeleteTopMostEmptyAncestor
(
nsIContent
&
aStartContent
Element
&
aEditingHostElement
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
aEditingHostElement
)
)
{
return
EditActionIgnored
(
)
;
}
RefPtr
<
Element
>
blockElement
=
GetBlock
(
aStartContent
)
;
RefPtr
<
Element
>
topMostEmptyBlockElement
;
if
(
blockElement
&
&
blockElement
!
=
&
aEditingHostElement
)
{
bool
isEmptyNode
=
false
;
nsresult
rv
=
IsEmptyNode
(
blockElement
&
isEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
while
(
blockElement
&
&
isEmptyNode
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
blockElement
)
&
&
blockElement
!
=
&
aEditingHostElement
)
{
topMostEmptyBlockElement
=
blockElement
;
blockElement
=
GetBlockNodeParent
(
topMostEmptyBlockElement
)
;
if
(
!
blockElement
)
{
break
;
}
nsresult
rv
=
IsEmptyNode
(
blockElement
&
isEmptyNode
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
}
}
if
(
!
topMostEmptyBlockElement
|
|
!
topMostEmptyBlockElement
-
>
IsEditable
(
)
)
{
return
EditActionIgnored
(
)
;
}
RefPtr
<
Element
>
parentOfEmptyBlockElement
=
topMostEmptyBlockElement
-
>
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
parentOfEmptyBlockElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
topMostEmptyBlockElement
)
)
{
if
(
IsFirstEditableChild
(
topMostEmptyBlockElement
)
)
{
EditorDOMPoint
atParentOfEmptyBlock
(
parentOfEmptyBlockElement
)
;
if
(
NS_WARN_IF
(
!
atParentOfEmptyBlock
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
atParentOfEmptyBlock
.
GetContainer
(
)
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
atParentOfEmptyBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
brElement
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
}
}
}
else
{
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
EditorRawDOMPoint
afterEmptyBlock
(
topMostEmptyBlockElement
)
;
bool
advancedFromEmptyBlock
=
afterEmptyBlock
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advancedFromEmptyBlock
"
Failed
to
set
selection
to
the
after
the
empty
block
"
)
;
nsCOMPtr
<
nsIContent
>
nextContentOfEmptyBlock
=
GetNextNode
(
afterEmptyBlock
)
;
if
(
nextContentOfEmptyBlock
)
{
EditorDOMPoint
pt
=
GetGoodCaretPointFor
(
*
nextContentOfEmptyBlock
aDirectionAndAmount
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
break
;
}
if
(
NS_WARN_IF
(
!
advancedFromEmptyBlock
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
break
;
}
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
atEmptyBlock
(
topMostEmptyBlockElement
)
;
nsCOMPtr
<
nsIContent
>
previousContentOfEmptyBlock
=
GetPreviousEditableNode
(
atEmptyBlock
)
;
if
(
previousContentOfEmptyBlock
)
{
EditorDOMPoint
pt
=
GetGoodCaretPointFor
(
*
previousContentOfEmptyBlock
aDirectionAndAmount
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
pt
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
break
;
}
EditorRawDOMPoint
afterEmptyBlock
(
topMostEmptyBlockElement
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterEmptyBlock
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
break
;
}
case
nsIEditor
:
:
eNone
:
break
;
default
:
MOZ_CRASH
(
"
CheckForEmptyBlock
doesn
'
t
support
this
action
yet
"
)
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
topMostEmptyBlockElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
template
<
typename
PT
typename
CT
>
Element
*
HTMLEditor
:
:
GetInvisibleBRElementAt
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
)
{
return
nullptr
;
}
WSRunObject
wsTester
(
this
aPoint
)
;
return
WSType
:
:
br
=
=
wsTester
.
mStartReason
?
wsTester
.
mStartReasonNode
-
>
AsElement
(
)
:
nullptr
;
}
size_t
HTMLEditor
:
:
CollectChildren
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
size_t
aIndexToInsertChildren
CollectListChildren
aCollectListChildren
CollectTableChildren
aCollectTableChildren
CollectNonEditableNodes
aCollectNonEditableNodes
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
size_t
numberOfFoundChildren
=
0
;
for
(
nsIContent
*
content
=
GetFirstEditableChild
(
aNode
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
(
aCollectListChildren
=
=
CollectListChildren
:
:
Yes
&
&
(
HTMLEditUtils
:
:
IsList
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
)
|
|
(
aCollectTableChildren
=
=
CollectTableChildren
:
:
Yes
&
&
HTMLEditUtils
:
:
IsTableElement
(
content
)
)
)
{
numberOfFoundChildren
+
=
CollectChildren
(
*
content
aOutArrayOfNodes
aIndexToInsertChildren
+
numberOfFoundChildren
aCollectListChildren
aCollectTableChildren
aCollectNonEditableNodes
)
;
}
else
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
Yes
|
|
IsEditable
(
content
)
)
{
aOutArrayOfNodes
.
InsertElementAt
(
aIndexToInsertChildren
+
numberOfFoundChildren
+
+
*
content
)
;
}
}
return
numberOfFoundChildren
;
}
already_AddRefed
<
StaticRange
>
HTMLEditor
:
:
GetExtendedRangeToIncludeInvisibleNodes
(
const
AbstractRange
&
aAbstractRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aAbstractRange
.
Collapsed
(
)
)
;
MOZ_ASSERT
(
aAbstractRange
.
IsPositioned
(
)
)
;
EditorRawDOMPoint
atStart
(
aAbstractRange
.
StartRef
(
)
)
;
EditorRawDOMPoint
atEnd
(
aAbstractRange
.
EndRef
(
)
)
;
Element
*
commonAncestorBlock
=
HTMLEditor
:
:
GetBlock
(
*
aAbstractRange
.
GetCommonAncestor
(
)
)
;
if
(
NS_WARN_IF
(
!
commonAncestorBlock
)
)
{
return
nullptr
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
nullptr
;
}
if
(
atStart
.
GetContainer
(
)
!
=
commonAncestorBlock
&
&
atStart
.
GetContainer
(
)
!
=
editingHost
)
{
for
(
;
;
)
{
WSRunObject
wsObj
(
this
atStart
)
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
atStart
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
thisBlock
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mStartReasonNode
)
|
|
wsObj
.
mStartReasonNode
=
=
commonAncestorBlock
|
|
wsObj
.
mStartReasonNode
=
=
editingHost
)
{
break
;
}
atStart
.
Set
(
wsObj
.
mStartReasonNode
)
;
}
}
if
(
atEnd
.
GetContainer
(
)
!
=
commonAncestorBlock
&
&
atEnd
.
GetContainer
(
)
!
=
editingHost
)
{
EditorDOMPoint
atFirstInvisibleBRElement
;
for
(
;
;
)
{
WSRunObject
wsObj
(
this
atEnd
)
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
atEnd
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
break
;
}
if
(
!
atFirstInvisibleBRElement
.
IsSet
(
)
)
{
atFirstInvisibleBRElement
=
atEnd
;
}
atEnd
.
Set
(
wsObj
.
mEndReasonNode
)
;
atEnd
.
AdvanceOffset
(
)
;
continue
;
}
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mEndReasonNode
)
|
|
wsObj
.
mEndReasonNode
=
=
commonAncestorBlock
|
|
wsObj
.
mEndReasonNode
=
=
editingHost
)
{
break
;
}
atEnd
.
Set
(
wsObj
.
mEndReasonNode
)
;
atEnd
.
AdvanceOffset
(
)
;
continue
;
}
break
;
}
if
(
atFirstInvisibleBRElement
.
IsSet
(
)
)
{
if
(
RefPtr
<
Element
>
brElementParent
=
HTMLEditor
:
:
GetBlock
(
*
atFirstInvisibleBRElement
.
GetContainer
(
)
)
)
{
RefPtr
<
StaticRange
>
staticRange
=
StaticRange
:
:
Create
(
atStart
.
ToRawRangeBoundary
(
)
atEnd
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
staticRange
)
)
{
return
nullptr
;
}
bool
nodeBefore
=
false
nodeAfter
=
false
;
RangeUtils
:
:
CompareNodeToRange
(
brElementParent
staticRange
&
nodeBefore
&
nodeAfter
)
;
if
(
!
nodeBefore
&
&
!
nodeAfter
)
{
return
staticRange
.
forget
(
)
;
}
atEnd
=
atFirstInvisibleBRElement
;
}
}
}
return
StaticRange
:
:
Create
(
atStart
.
ToRawRangeBoundary
(
)
atEnd
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
}
nsresult
HTMLEditor
:
:
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
startPoint
(
range
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
endPoint
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
newStartPoint
(
startPoint
)
;
EditorDOMPoint
newEndPoint
(
endPoint
)
;
WSType
wsType
;
WSRunObject
wsEndObj
(
this
endPoint
)
;
wsEndObj
.
PriorVisibleNode
(
endPoint
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
GetRightmostChild
(
wsEndObj
.
mStartReasonNode
true
)
;
if
(
child
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
thisBlock
)
{
nsINode
*
child
=
GetPreviousEditableHTMLNode
(
endPoint
)
;
if
(
child
)
{
newEndPoint
.
SetAfter
(
child
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
br
)
{
newEndPoint
.
Set
(
wsEndObj
.
mStartReasonNode
)
;
}
}
WSRunObject
wsStartObj
(
this
startPoint
)
;
wsStartObj
.
NextVisibleNode
(
startPoint
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
GetLeftmostChild
(
wsStartObj
.
mEndReasonNode
true
)
;
if
(
child
)
{
newStartPoint
.
Set
(
child
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
thisBlock
)
{
nsINode
*
child
=
GetNextEditableHTMLNode
(
startPoint
)
;
if
(
child
)
{
newStartPoint
.
Set
(
child
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
br
)
{
newStartPoint
.
SetAfter
(
wsStartObj
.
mEndReasonNode
)
;
}
}
int16_t
comp
;
comp
=
nsContentUtils
:
:
ComparePoints
(
startPoint
.
ToRawRangeBoundary
(
)
newEndPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetBaseAndExtentInLimiter
(
newStartPoint
newEndPoint
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
set
selection
"
)
;
return
error
.
StealNSResult
(
)
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
ScanDirection
aScanDirection
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
bool
isSpace
=
false
isNBSP
=
false
;
nsIContent
*
newContent
=
aPoint
.
Container
(
)
-
>
AsContent
(
)
;
int32_t
newOffset
=
aPoint
.
Offset
(
)
;
while
(
newContent
)
{
int32_t
offset
=
-
1
;
nsCOMPtr
<
nsIContent
>
content
;
if
(
aScanDirection
=
=
ScanDirection
:
:
Backward
)
{
HTMLEditor
:
:
IsPrevCharInNodeWhitespace
(
newContent
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
content
)
&
offset
)
;
}
else
{
HTMLEditor
:
:
IsNextCharInNodeWhitespace
(
newContent
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
content
)
&
offset
)
;
}
if
(
!
isSpace
&
&
!
isNBSP
)
{
break
;
}
newContent
=
content
;
newOffset
=
offset
;
}
return
EditorDOMPoint
(
newContent
newOffset
)
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineStartPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
EditSubAction
aEditSubAction
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPoint
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
for
(
nsIContent
*
previousEditableContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
previousEditableContent
&
&
previousEditableContent
-
>
GetParentNode
(
)
&
&
!
IsVisibleBRElement
(
previousEditableContent
)
&
&
!
HTMLEditor
:
:
NodeIsBlockStatic
(
*
previousEditableContent
)
;
previousEditableContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
point
.
Set
(
previousEditableContent
)
;
}
for
(
nsIContent
*
nearContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
aEditSubAction
=
=
EditSubAction
:
:
eIndent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
|
|
aEditSubAction
=
=
EditSubAction
:
:
eSetOrClearAlignment
|
|
aEditSubAction
=
=
EditSubAction
:
:
eCreateOrRemoveBlock
;
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
}
return
point
;
}
template
<
typename
PT
typename
RT
>
EditorDOMPoint
HTMLEditor
:
:
GetCurrentHardLineEndPoint
(
const
RangeBoundaryBase
<
PT
RT
>
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
point
(
aPoint
)
;
if
(
point
.
IsInTextNode
(
)
)
{
if
(
!
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
text
node
"
)
;
}
for
(
nsIContent
*
nextEditableContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
;
nextEditableContent
&
&
!
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nextEditableContent
)
&
&
nextEditableContent
-
>
GetParent
(
)
;
nextEditableContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
point
.
Set
(
nextEditableContent
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
if
(
IsVisibleBRElement
(
nextEditableContent
)
)
{
break
;
}
if
(
EditorBase
:
:
IsPreformatted
(
nextEditableContent
)
&
&
EditorBase
:
:
IsTextNode
(
nextEditableContent
)
)
{
nsAutoString
textContent
;
nextEditableContent
-
>
GetAsText
(
)
-
>
GetData
(
textContent
)
;
int32_t
newlinePos
=
textContent
.
FindChar
(
nsCRT
:
:
LF
)
;
if
(
newlinePos
>
=
0
)
{
if
(
static_cast
<
uint32_t
>
(
newlinePos
)
+
1
=
=
textContent
.
Length
(
)
)
{
break
;
}
return
EditorDOMPoint
(
nextEditableContent
newlinePos
+
1
)
;
}
}
}
for
(
nsIContent
*
nearContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
;
!
nearContent
&
&
!
point
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
;
nearContent
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
if
(
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
)
&
&
!
IsDescendantOfEditorRoot
(
point
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
}
return
point
;
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToIncludeAdjuscentWhiteSpaces
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
aOutArrayOfRanges
.
SetCapacity
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
selectionRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeIncludingAdjuscentWhiteSpaces
(
*
selectionRange
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
void
HTMLEditor
:
:
GetSelectionRangesExtendedToHardLineStartAndEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aOutArrayOfRanges
EditSubAction
aEditSubAction
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aOutArrayOfRanges
.
IsEmpty
(
)
)
;
aOutArrayOfRanges
.
SetCapacity
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
selectionRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
extendedRange
=
CreateRangeExtendedToHardLineStartAndEnd
(
*
selectionRange
aEditSubAction
)
;
if
(
!
extendedRange
)
{
extendedRange
=
selectionRange
-
>
CloneRange
(
)
;
}
aOutArrayOfRanges
.
AppendElement
(
extendedRange
)
;
}
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
void
HTMLEditor
:
:
SelectBRElementIfCollapsedInEmptyBlock
(
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
{
if
(
aStartRef
!
=
aEndRef
)
{
return
;
}
Element
*
block
=
GetBlock
(
*
aStartRef
.
Container
(
)
)
;
if
(
!
block
)
{
return
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
;
}
if
(
editingHost
-
>
IsInclusiveDescendantOf
(
block
)
)
{
return
;
}
bool
isEmptyNode
=
false
;
IsEmptyNode
(
block
&
isEmptyNode
true
false
)
;
if
(
isEmptyNode
)
{
aStartRef
.
Set
(
block
0
)
;
aEndRef
.
Set
(
block
block
-
>
Length
(
)
)
;
}
}
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
AbstractRange
&
aAbstractRange
)
{
if
(
!
aAbstractRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeIncludingAdjuscentWhiteSpaces
(
aAbstractRange
.
StartRef
(
)
aAbstractRange
.
EndRef
(
)
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeIncludingAdjuscentWhiteSpaces
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
)
{
if
(
NS_WARN_IF
(
!
aStartRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndRef
.
IsSet
(
)
)
)
{
return
nullptr
;
}
if
(
!
aStartRef
.
Container
(
)
-
>
IsContent
(
)
|
|
!
aEndRef
.
Container
(
)
-
>
IsContent
(
)
)
{
return
nullptr
;
}
RangeBoundaryBase
<
SPT
SRT
>
startRef
(
aStartRef
)
;
RangeBoundaryBase
<
EPT
ERT
>
endRef
(
aEndRef
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startRef
endRef
)
;
EditorDOMPoint
startPoint
=
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
startRef
HTMLEditor
:
:
ScanDirection
:
:
Backward
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
nullptr
;
}
EditorDOMPoint
endPoint
=
HTMLEditor
:
:
GetWhiteSpaceEndPoint
(
endRef
HTMLEditor
:
:
ScanDirection
:
:
Forward
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
GetDocument
(
)
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
AbstractRange
&
aAbstractRange
EditSubAction
aEditSubAction
)
{
if
(
!
aAbstractRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeExtendedToHardLineStartAndEnd
(
aAbstractRange
.
StartRef
(
)
aAbstractRange
.
EndRef
(
)
aEditSubAction
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
nsRange
>
HTMLEditor
:
:
CreateRangeExtendedToHardLineStartAndEnd
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartRef
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndRef
EditSubAction
aEditSubAction
)
{
if
(
NS_WARN_IF
(
!
aStartRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndRef
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RangeBoundaryBase
<
SPT
SRT
>
startRef
(
aStartRef
)
;
RangeBoundaryBase
<
EPT
ERT
>
endRef
(
aEndRef
)
;
SelectBRElementIfCollapsedInEmptyBlock
(
startRef
endRef
)
;
EditorDOMPoint
startPoint
=
GetCurrentHardLineStartPoint
(
startRef
aEditSubAction
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
)
)
)
{
return
nullptr
;
}
EditorDOMPoint
endPoint
=
GetCurrentHardLineEndPoint
(
endRef
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
GetDocument
(
)
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
startPoint
.
ToRawRangeBoundary
(
)
endPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
class
UniqueFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
UniqueFunctor
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
)
:
mArray
(
aArray
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
!
mArray
.
Contains
(
aNode
)
;
}
private
:
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
mArray
;
}
;
nsresult
HTMLEditor
:
:
SplitInlinesAndCollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
nsresult
rv
=
SplitTextNodesAtRangeEnd
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SplitTextNodesAtRangeEnd
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
SplitParentInlineElementsAtRangeEdges
(
aArrayOfRanges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SplitParentInlineElementsAtRangeEdges
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
CollectEditTargetNodes
(
aArrayOfRanges
aOutArrayOfNodes
aEditSubAction
aCollectNonEditableNodes
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CollectEditTargetNodes
(
)
failed
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
MaybeSplitElementsAtEveryBRElement
(
aOutArrayOfNodes
aEditSubAction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeSplitElementsAtEveryBRElement
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SplitTextNodesAtRangeEnd
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
IsInTextNode
(
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atEnd
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atContainerOfSplitNode
(
atEnd
.
GetContainer
(
)
)
;
MOZ_ASSERT
(
!
range
-
>
IsInSelection
(
)
)
;
range
-
>
SetEnd
(
atContainerOfSplitNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
aArrayOfRanges
[
0
]
)
;
RangeUpdaterRef
(
)
.
RegisterRangeItem
(
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
nsresult
rv
=
NS_OK
;
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
rv
=
SplitParentInlineElementsAtRangeEdges
(
*
item
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
RangeUpdaterRef
(
)
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CollectEditTargetNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
iter
.
AppendList
(
TrivialFunctor
(
)
aOutArrayOfNodes
)
;
}
else
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodes
;
iter
.
AppendList
(
UniqueFunctor
(
aOutArrayOfNodes
)
nodes
)
;
aOutArrayOfNodes
.
AppendElements
(
nodes
)
;
}
if
(
aCollectNonEditableNodes
=
=
CollectNonEditableNodes
:
:
No
)
{
for
(
size_t
i
=
aOutArrayOfNodes
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
if
(
!
IsEditable
(
aOutArrayOfNodes
[
i
-
1
]
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
-
1
)
;
}
}
}
}
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
node
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
node
aOutArrayOfNodes
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
Text
*
text
=
aOutArrayOfNodes
[
i
]
-
>
GetAsText
(
)
)
{
if
(
!
IsVisibleTextNode
(
*
text
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
}
break
;
case
EditSubAction
:
:
eCreateOrChangeList
:
{
for
(
size_t
i
=
aOutArrayOfNodes
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
-
1
]
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
node
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
-
1
)
;
CollectChildren
(
node
aOutArrayOfNodes
i
-
1
CollectListChildren
:
:
No
CollectTableChildren
:
:
Yes
CollectNonEditableNodes
:
:
Yes
)
;
}
}
if
(
aOutArrayOfNodes
.
Length
(
)
!
=
1
)
{
break
;
}
Element
*
deepestDivBlockquoteOrListElement
=
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
aOutArrayOfNodes
[
0
]
)
;
if
(
!
deepestDivBlockquoteOrListElement
)
{
break
;
}
if
(
deepestDivBlockquoteOrListElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
aOutArrayOfNodes
.
Clear
(
)
;
CollectChildren
(
*
deepestDivBlockquoteOrListElement
aOutArrayOfNodes
0
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
CollectNonEditableNodes
:
:
Yes
)
;
break
;
}
aOutArrayOfNodes
.
ReplaceElementAt
(
0
OwningNonNull
<
nsINode
>
(
*
deepestDivBlockquoteOrListElement
)
)
;
break
;
}
case
EditSubAction
:
:
eOutdent
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
node
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
node
aOutArrayOfNodes
i
CollectListChildren
:
:
Yes
CollectTableChildren
:
:
Yes
aCollectNonEditableNodes
)
;
}
}
break
;
default
:
break
;
}
if
(
aEditSubAction
=
=
EditSubAction
:
:
eOutdent
&
&
!
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
CollectChildren
(
*
node
aOutArrayOfNodes
i
CollectListChildren
:
:
No
CollectTableChildren
:
:
No
aCollectNonEditableNodes
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
EditSubAction
aEditSubAction
)
{
switch
(
aEditSubAction
)
{
case
EditSubAction
:
:
eCreateOrRemoveBlock
:
case
EditSubAction
:
:
eMergeBlockContents
:
case
EditSubAction
:
:
eCreateOrChangeList
:
case
EditSubAction
:
:
eSetOrClearAlignment
:
case
EditSubAction
:
:
eSetPositionToAbsolute
:
case
EditSubAction
:
:
eIndent
:
case
EditSubAction
:
:
eOutdent
:
for
(
int32_t
i
=
aArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aArrayOfNodes
[
i
]
;
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
node
)
&
&
IsContainer
(
node
)
&
&
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfInlines
;
nsresult
rv
=
SplitElementsAtEveryBRElement
(
MOZ_KnownLive
(
*
node
-
>
AsContent
(
)
)
arrayOfInlines
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aArrayOfNodes
.
RemoveElementAt
(
i
)
;
aArrayOfNodes
.
InsertElementsAt
(
i
arrayOfInlines
)
;
}
}
return
NS_OK
;
default
:
return
NS_OK
;
}
}
Element
*
HTMLEditor
:
:
GetParentListElementAtSelection
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
+
+
i
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
for
(
nsINode
*
parent
=
range
-
>
GetCommonAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
return
parent
-
>
AsElement
(
)
;
}
}
}
return
nullptr
;
}
Element
*
HTMLEditor
:
:
GetDeepestEditableOnlyChildDivBlockquoteOrListElement
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
nullptr
;
}
Element
*
parentElement
=
nullptr
;
for
(
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
content
&
&
content
-
>
IsElement
(
)
&
&
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
|
|
HTMLEditUtils
:
:
IsList
(
content
)
)
;
content
=
content
-
>
GetFirstChild
(
)
)
{
if
(
CountEditableChildren
(
content
)
!
=
1
)
{
return
content
-
>
AsElement
(
)
;
}
parentElement
=
content
-
>
AsElement
(
)
;
}
return
parentElement
;
}
nsresult
HTMLEditRules
:
:
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditorDataAvailable
(
)
)
;
nsresult
rv
=
HTMLEditorRef
(
)
.
CollectEditTargetNodesInExtendedSelectionRanges
(
outArrayOfNodes
EditSubAction
:
:
eCreateOrRemoveBlock
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
int32_t
i
=
outArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
outArrayOfNodes
[
i
]
;
if
(
!
HTMLEditorRef
(
)
.
IsEditable
(
testNode
)
)
{
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
testNode
)
|
|
HTMLEditUtils
:
:
IsList
(
testNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
testNode
)
)
{
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
HTMLEditorRef
(
)
.
CollectChildren
(
testNode
outArrayOfNodes
i
HTMLEditor
:
:
CollectListChildren
:
:
Yes
HTMLEditor
:
:
CollectTableChildren
:
:
Yes
HTMLEditor
:
:
CollectNonEditableNodes
:
:
Yes
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitParentInlineElementsAtRangeEdges
(
RangeItem
&
aRangeItem
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aRangeItem
.
IsCollapsed
(
)
)
{
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtEnd
=
GetMostAncestorInlineElement
(
*
aRangeItem
.
mEndContainer
)
;
if
(
mostAncestorInlineContentAtEnd
)
{
SplitNodeResult
splitEndInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtEnd
aRangeItem
.
EndPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitEndInlineResult
.
Failed
(
)
)
)
{
return
splitEndInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtEnd
(
splitEndInlineResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
splitPointAtEnd
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mEndContainer
=
splitPointAtEnd
.
GetContainer
(
)
;
aRangeItem
.
mEndOffset
=
splitPointAtEnd
.
Offset
(
)
;
}
}
nsCOMPtr
<
nsIContent
>
mostAncestorInlineContentAtStart
=
GetMostAncestorInlineElement
(
*
aRangeItem
.
mStartContainer
)
;
if
(
mostAncestorInlineContentAtStart
)
{
SplitNodeResult
splitStartInlineResult
=
SplitNodeDeepWithTransaction
(
*
mostAncestorInlineContentAtStart
aRangeItem
.
StartPoint
(
)
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitStartInlineResult
.
Failed
(
)
)
)
{
return
splitStartInlineResult
.
Rv
(
)
;
}
EditorRawDOMPoint
splitPointAtStart
(
splitStartInlineResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
splitPointAtStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aRangeItem
.
mStartContainer
=
splitPointAtStart
.
GetContainer
(
)
;
aRangeItem
.
mStartOffset
=
splitPointAtStart
.
Offset
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SplitElementsAtEveryBRElement
(
nsIContent
&
aMostAncestorToBeSplit
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfBreaks
;
BRNodeFunctor
functor
;
DOMIterator
iter
(
aMostAncestorToBeSplit
)
;
iter
.
AppendList
(
functor
arrayOfBreaks
)
;
if
(
arrayOfBreaks
.
IsEmpty
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
aMostAncestorToBeSplit
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
nextContent
=
&
aMostAncestorToBeSplit
;
for
(
OwningNonNull
<
nsINode
>
&
brNode
:
arrayOfBreaks
)
{
EditorDOMPoint
atBrNode
(
brNode
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
nextContent
atBrNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
splitNodeResult
.
GetPreviousNode
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
splitNodeResult
.
GetPreviousNode
(
)
)
;
}
EditorDOMPoint
atNextNode
(
splitNodeResult
.
GetNextNode
(
)
)
;
nsresult
rv
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
brNode
-
>
AsContent
(
)
)
atNextNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutArrayOfNodes
.
AppendElement
(
*
brNode
)
;
nextContent
=
splitNodeResult
.
GetNextNode
(
)
;
}
aOutArrayOfNodes
.
AppendElement
(
*
nextContent
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetMostAncestorInlineElement
(
nsINode
&
aNode
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aNode
.
IsContent
(
)
|
|
HTMLEditor
:
:
NodeIsBlockStatic
(
aNode
)
)
{
return
nullptr
;
}
Element
*
host
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
nullptr
;
}
if
(
&
aNode
=
=
host
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
aNode
*
host
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
for
(
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
parent
&
&
parent
!
=
host
&
&
HTMLEditor
:
:
NodeIsInlineStatic
(
*
parent
)
;
parent
=
parent
-
>
GetParent
(
)
)
{
content
=
parent
;
}
return
content
;
}
void
HTMLEditor
:
:
MakeTransitionList
(
const
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsINode
*
prevParent
=
nullptr
;
aTransitionArray
.
EnsureLengthAtLeast
(
aNodeArray
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNodeArray
.
Length
(
)
;
i
+
+
)
{
aTransitionArray
[
i
]
=
aNodeArray
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
;
prevParent
=
aNodeArray
[
i
]
-
>
GetParentNode
(
)
;
}
}
Element
*
HTMLEditor
:
:
GetNearestAncestorListItemElement
(
nsIContent
&
aContent
)
const
{
if
(
HTMLEditUtils
:
:
IsListItem
(
&
aContent
)
)
{
return
aContent
.
AsElement
(
)
;
}
for
(
Element
*
parentElement
=
aContent
.
GetParentElement
(
)
;
parentElement
&
&
IsDescendantOfEditorRoot
(
parentElement
)
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parentElement
)
;
parentElement
=
parentElement
-
>
GetParentElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parentElement
)
)
{
return
parentElement
;
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
HandleInsertParagraphInHeadingElement
(
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
headerParent
=
aHeader
.
GetParentNode
(
)
;
int32_t
offset
=
headerParent
?
headerParent
-
>
ComputeIndexOf
(
&
aHeader
)
:
-
1
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
this
address_of
(
node
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
node
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitHeaderResult
=
SplitNodeDeepWithTransaction
(
aHeader
EditorDOMPoint
(
node
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitHeaderResult
.
Succeeded
(
)
"
Failed
to
split
aHeader
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
GetPriorHTMLSibling
(
&
aHeader
)
;
if
(
prevItem
)
{
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
prevItem
)
)
;
bool
isEmptyNode
;
rv
=
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
}
}
if
(
IsEmptyBlockElement
(
aHeader
IgnoreSingleBR
:
:
Yes
)
)
{
rv
=
DeleteNodeWithTransaction
(
aHeader
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
aHeader
.
GetNextSibling
(
)
)
{
sibling
=
GetNextHTMLSibling
(
aHeader
.
GetNextSibling
(
)
)
;
}
if
(
!
sibling
|
|
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
.
Clear
(
)
;
mTypeInState
-
>
ClearAllProps
(
)
;
nsStaticAtom
&
paraAtom
=
DefaultParagraphSeparatorTagName
(
)
;
EditorDOMPoint
nextToHeader
(
headerParent
offset
+
1
)
;
RefPtr
<
Element
>
pNode
=
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
MOZ_KnownLive
(
paraAtom
)
nextToHeader
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditorRawDOMPoint
afterSibling
(
sibling
)
;
if
(
NS_WARN_IF
(
!
afterSibling
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterSibling
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
RawRangeBoundary
(
&
aHeader
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
Element
&
aParentDivOrP
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
Set
(
container
)
;
}
if
(
container
-
>
GetPreviousSibling
(
)
)
{
break
;
}
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
|
|
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
)
{
bool
foundBRElement
=
atStartOfSelection
.
IsBRElementAtEndOfContainer
(
)
;
for
(
nsIContent
*
container
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
container
&
&
container
!
=
&
aParentDivOrP
;
container
=
container
-
>
GetParent
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
atStartOfSelection
.
SetAfter
(
container
)
;
}
if
(
nsIContent
*
nextSibling
=
container
-
>
GetNextSibling
(
)
)
{
if
(
foundBRElement
)
{
break
;
}
if
(
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
break
;
}
foundBRElement
=
true
;
}
}
}
bool
doesCRCreateNewP
=
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brContent
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
brContent
=
nullptr
;
}
else
if
(
atStartOfSelection
.
IsInTextNode
(
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brContent
=
GetPriorHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
IsVisibleBRElement
(
brContent
)
|
|
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
brContent
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brContent
=
GetNextHTMLSibling
(
atStartOfSelection
.
GetContainer
(
)
)
;
if
(
!
brContent
|
|
!
IsVisibleBRElement
(
brContent
)
|
|
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
brContent
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
"
"
of
selection
start
"
)
;
brContent
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftDivOrP
=
SplitNodeWithTransaction
(
pointToSplitParentDivOrP
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
pointToSplitParentDivOrP
.
SetToEndOf
(
newLeftDivOrP
)
;
}
pointToInsertBR
.
Set
(
pointToSplitParentDivOrP
.
GetContainer
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
"
"
of
selection
start
"
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nearNode
=
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
IsVisibleBRElement
(
nearNode
)
|
|
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearNode
)
)
{
nearNode
=
GetNextEditableHTMLNode
(
atStartOfSelection
)
;
if
(
!
nearNode
|
|
!
IsVisibleBRElement
(
nearNode
)
|
|
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nearNode
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
brContent
=
nearNode
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
brContent
=
InsertBRElementWithTransaction
(
pointToInsertBR
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
brContent
"
Failed
to
create
a
<
br
>
element
"
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
Set
(
brContent
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplitParentDivOrP
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
"
)
;
}
}
EditActionResult
result
(
SplitParagraph
(
aParentDivOrP
pointToSplitParentDivOrP
brContent
)
)
;
result
.
MarkAsHandled
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
return
result
;
}
template
<
typename
PT
typename
CT
>
nsresult
HTMLEditor
:
:
SplitParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsINode
>
selNode
=
aStartOfRightNode
.
GetContainer
(
)
;
int32_t
selOffset
=
aStartOfRightNode
.
Offset
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
this
address_of
(
selNode
)
&
selOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitDivOrPResult
=
SplitNodeDeepWithTransaction
(
aParentDivOrP
EditorDOMPoint
(
selNode
selOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
splitDivOrPResult
.
Failed
(
)
)
)
{
return
splitDivOrPResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
!
splitDivOrPResult
.
DidSplit
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNextBRNode
&
&
IsVisibleBRElement
(
aNextBRNode
)
)
{
rv
=
DeleteNodeWithTransaction
(
*
aNextBRNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
RemoveAttributeWithTransaction
(
aParentDivOrP
*
nsGkAtoms
:
:
id
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
splitDivOrPResult
.
GetPreviousNode
(
)
-
>
IsElement
(
)
)
{
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
splitDivOrPResult
.
GetPreviousNode
(
)
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
splitDivOrPResult
.
GetNextNode
(
)
-
>
IsElement
(
)
)
{
rv
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
splitDivOrPResult
.
GetNextNode
(
)
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsIContent
*
child
=
GetLeftmostChild
(
&
aParentDivOrP
true
)
;
if
(
EditorBase
:
:
IsTextNode
(
child
)
|
|
IsContainer
(
child
)
)
{
EditorRawDOMPoint
atStartOfChild
(
child
0
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
atStartOfChild
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
end
of
the
child
but
ignored
"
)
;
}
else
{
EditorRawDOMPoint
atChild
(
child
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
atChild
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
child
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleInsertParagraphInListItemElement
(
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
;
RefPtr
<
Element
>
host
=
GetActiveEditingHost
(
)
;
if
(
host
!
=
aListItem
.
GetParentElement
(
)
&
&
IsEmptyBlockElement
(
aListItem
IgnoreSingleBR
:
:
Yes
)
)
{
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
IsLastEditableChild
(
&
aListItem
)
)
{
EditorDOMPoint
atListItem
(
&
aListItem
)
;
ErrorResult
error
;
leftListNode
=
SplitNodeWithTransaction
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorDOMPoint
atNextSiblingOfLeftList
(
leftListNode
)
;
DebugOnly
<
bool
>
advanced
=
atNextSiblingOfLeftList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
right
list
node
"
)
;
if
(
HTMLEditUtils
:
:
IsList
(
atNextSiblingOfLeftList
.
GetContainer
(
)
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aListItem
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
RawRangeBoundary
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsStaticAtom
&
paraAtom
=
DefaultParagraphSeparatorTagName
(
)
;
RefPtr
<
Element
>
pNode
=
CreateNodeWithTransaction
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
MOZ_KnownLive
(
paraAtom
)
atNextSiblingOfLeftList
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
pNode
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
pNode
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
pNode
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selNode
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
this
address_of
(
selNode
)
&
aOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
selNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitListItemResult
=
SplitNodeDeepWithTransaction
(
aListItem
EditorDOMPoint
(
selNode
aOffset
)
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
splitListItemResult
.
Succeeded
(
)
"
Failed
to
split
the
list
item
"
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
GetPriorHTMLSibling
(
&
aListItem
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsListItem
(
prevItem
)
)
{
bool
isEmptyNode
;
rv
=
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
prevItem
0
)
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
}
else
{
rv
=
IsEmptyNode
(
&
aListItem
&
isEmptyNode
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
if
(
aListItem
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
)
{
nsCOMPtr
<
nsINode
>
list
=
aListItem
.
GetParentNode
(
)
;
int32_t
itemOffset
=
list
?
list
-
>
ComputeIndexOf
(
&
aListItem
)
:
-
1
;
nsStaticAtom
*
nextDefinitionListItemTagName
=
aListItem
.
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
?
nsGkAtoms
:
:
dd
:
nsGkAtoms
:
:
dt
;
MOZ_DIAGNOSTIC_ASSERT
(
itemOffset
!
=
-
1
)
;
EditorDOMPoint
atNextListItem
(
list
aListItem
.
GetNextSibling
(
)
itemOffset
+
1
)
;
RefPtr
<
Element
>
newListItem
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
nextDefinitionListItemTagName
)
atNextListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
DeleteNodeWithTransaction
(
aListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
newListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
;
nsresult
rv
=
CopyLastEditableChildStylesWithTransaction
(
MOZ_KnownLive
(
*
prevItem
-
>
AsElement
(
)
)
aListItem
address_of
(
brElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
brElement
)
{
EditorRawDOMPoint
atBrNode
(
brElement
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atBrNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
else
{
WSRunObject
wsObj
(
this
&
aListItem
0
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
&
aListItem
0
)
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
EditorRawDOMPoint
atVisNode
(
visNode
)
;
if
(
NS_WARN_IF
(
!
atVisNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atVisNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
visNode
visOffset
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
EditorRawDOMPoint
(
&
aListItem
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MoveNodesIntoNewBlockquoteElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
NS_WARN_IF
(
!
curNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsINode
>
24
>
childNodes
;
HTMLEditor
:
:
GetChildNodesOf
(
*
curNode
childNodes
)
;
nsresult
rv
=
MoveNodesIntoNewBlockquoteElement
(
childNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
prevParent
)
{
if
(
prevParent
!
=
curNode
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
blockquote
EditorDOMPoint
(
curNode
)
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
curBlock
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerElements
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsIContent
>
firstNode
lastNode
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
AutoTArray
<
OwningNonNull
<
nsINode
>
24
>
childNodes
;
HTMLEditor
:
:
GetChildNodesOf
(
*
curNode
childNodes
)
;
nsresult
rv
=
RemoveBlockContainerElements
(
childNodes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
curNode
)
)
{
if
(
curBlock
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlock
)
)
{
lastNode
=
curNode
-
>
AsContent
(
)
;
continue
;
}
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
curBlock
=
GetBlockNodeParent
(
curNode
)
;
if
(
!
curBlock
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
|
|
!
IsEditable
(
curBlock
)
)
{
curBlock
=
nullptr
;
}
else
{
firstNode
=
lastNode
=
curNode
-
>
AsContent
(
)
;
}
continue
;
}
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
continue
;
}
}
if
(
curBlock
)
{
SplitRangeOffFromNodeResult
removeMiddleContainerResult
=
SplitRangeOffFromBlockAndRemoveMiddleContainer
(
*
curBlock
*
firstNode
*
lastNode
)
;
if
(
NS_WARN_IF
(
removeMiddleContainerResult
.
Failed
(
)
)
)
{
return
removeMiddleContainerResult
.
Rv
(
)
;
}
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CreateOrChangeBlockContainerElement
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
NS_WARN_IF
(
!
curNode
-
>
GetParent
(
)
)
)
{
curBlock
=
nullptr
;
newBlock
=
nullptr
;
continue
;
}
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
curNode
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
IsEditable
(
curNode
)
&
&
HTMLEditor
:
:
NodeIsBlockStatic
(
curNode
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
curNode
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
curBlock
=
nullptr
;
newBlock
=
ReplaceContainerAndCloneAttributesWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsElement
(
)
)
aBlockTag
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
newBlock
-
>
GetParentNode
(
)
!
=
atCurNode
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
AutoTArray
<
OwningNonNull
<
nsINode
>
24
>
childNodes
;
HTMLEditor
:
:
GetChildNodesOf
(
*
curNode
childNodes
)
;
if
(
!
childNodes
.
IsEmpty
(
)
)
{
nsresult
rv
=
CreateOrChangeBlockContainerElement
(
childNodes
aBlockTag
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atCurNode
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
RefPtr
<
Element
>
theBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
theBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
theBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
theBlock
)
;
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atCurNode
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
curBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
curBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
HTMLEditor
:
:
NodeIsInlineStatic
(
curNode
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
!
curBlock
)
{
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
aBlockTag
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
NS_WARN_IF
(
atCurNode
.
HasChildMovedFromContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
splitPoint
=
splitNodeResult
.
SplitPoint
(
)
;
curBlock
=
CreateNodeWithTransaction
(
aBlockTag
splitPoint
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
curBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
curBlock
-
>
GetParentNode
(
)
!
=
splitPoint
.
GetContainer
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
atCurNode
.
Set
(
curNode
)
;
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
curBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
SplitNodeResult
HTMLEditor
:
:
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPoint
&
aStartOfDeepestRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
RefPtr
<
Element
>
host
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
aStartOfDeepestRightNode
.
GetContainer
(
)
!
=
host
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
*
host
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
EditorDOMPoint
pointToInsert
(
aStartOfDeepestRightNode
)
;
for
(
;
pointToInsert
.
IsSet
(
)
;
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
)
{
if
(
NS_WARN_IF
(
pointToInsert
.
GetChild
(
)
=
=
host
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
CanContainTag
(
*
pointToInsert
.
GetContainer
(
)
aTag
)
)
{
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
if
(
pointToInsert
.
GetContainer
(
)
=
=
aStartOfDeepestRightNode
.
GetContainer
(
)
)
{
return
SplitNodeResult
(
aStartOfDeepestRightNode
)
;
}
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aStartOfDeepestRightNode
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
splitNodeResult
.
Succeeded
(
)
"
Failed
to
split
the
node
for
insert
the
element
"
)
;
return
splitNodeResult
;
}
nsresult
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
EditorDOMPoint
*
aNewFirstChildOfRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNewFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
!
aNodeLeft
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNodeLeft
.
GetParentNode
(
)
!
=
aNodeRight
.
GetParentNode
(
)
)
{
nsresult
rv
=
MoveNodeWithTransaction
(
aNodeRight
EditorDOMPoint
(
&
aNodeLeft
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
EditorDOMPoint
ret
(
&
aNodeRight
aNodeLeft
.
Length
(
)
)
;
if
(
HTMLEditUtils
:
:
IsList
(
&
aNodeLeft
)
|
|
aNodeLeft
.
IsText
(
)
)
{
nsresult
rv
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
JoinNodesWithTransaction
failed
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
}
return
rv
;
}
nsCOMPtr
<
nsIContent
>
lastLeft
=
GetLastEditableChild
(
aNodeLeft
)
;
if
(
NS_WARN_IF
(
!
lastLeft
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstRight
=
GetFirstEditableChild
(
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
firstRight
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
JoinNodesWithTransaction
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
HTMLEditor
:
:
AreNodesSameType
(
*
lastLeft
*
firstRight
)
&
&
(
lastLeft
-
>
IsText
(
)
|
|
(
lastLeft
-
>
IsElement
(
)
&
&
firstRight
-
>
IsElement
(
)
&
&
CSSEditUtils
:
:
ElementsSameStyle
(
lastLeft
-
>
AsElement
(
)
firstRight
-
>
AsElement
(
)
)
)
)
)
{
nsresult
rv
=
JoinNearestEditableNodesWithTransaction
(
*
lastLeft
*
firstRight
aNewFirstChildOfRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
*
aNewFirstChildOfRightNode
=
std
:
:
move
(
ret
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetMostAncestorMailCiteElement
(
nsINode
&
aNode
)
const
{
Element
*
mailCiteElement
=
nullptr
;
bool
isPlaintextEditor
=
IsPlaintextEditor
(
)
;
for
(
nsINode
*
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
isPlaintextEditor
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
{
mailCiteElement
=
node
-
>
AsElement
(
)
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
mailCiteElement
;
}
nsresult
HTMLEditor
:
:
CacheInlineStyles
(
nsINode
&
aNode
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
GetInlineStyles
(
aNode
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetInlineStyles
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetInlineStyles
(
nsINode
&
aNode
AutoStyleCacheArray
&
aStyleCacheArray
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
for
(
StyleCache
&
styleCache
:
aStyleCacheArray
)
{
bool
typeInSet
unused
;
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
styleCache
.
mTag
styleCache
.
mAttr
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsAutoString
outValue
;
if
(
!
useCSS
|
|
(
styleCache
.
mTag
=
=
nsGkAtoms
:
:
font
&
&
styleCache
.
mAttr
=
=
nsGkAtoms
:
:
size
)
)
{
isSet
=
IsTextPropertySetByContent
(
&
aNode
styleCache
.
mTag
styleCache
.
mAttr
nullptr
&
outValue
)
;
}
else
{
isSet
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
&
aNode
styleCache
.
mTag
styleCache
.
mAttr
outValue
CSSEditUtils
:
:
eComputed
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
isSet
)
{
styleCache
.
mPresent
=
true
;
styleCache
.
mValue
.
Assign
(
outValue
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
ReapplyCachedStyles
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
if
(
!
SelectionRefPtr
(
)
-
>
RangeCount
(
)
)
{
return
NS_OK
;
}
const
RangeBoundary
&
atStartOfSelection
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
-
>
StartRef
(
)
;
nsCOMPtr
<
nsIContent
>
selNode
=
atStartOfSelection
.
Container
(
)
&
&
atStartOfSelection
.
Container
(
)
-
>
IsContent
(
)
?
atStartOfSelection
.
Container
(
)
-
>
AsContent
(
)
:
nullptr
;
if
(
!
selNode
)
{
return
NS_OK
;
}
AutoStyleCacheArray
styleCacheArrayAtInsertionPoint
;
nsresult
rv
=
GetInlineStyles
(
*
selNode
styleCacheArrayAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
=
=
NS_ERROR_EDITOR_DESTROYED
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
styleCacheArrayAtInsertionPoint
.
Length
(
)
;
+
+
i
)
{
StyleCache
&
styleCacheAtInsertionPoint
=
styleCacheArrayAtInsertionPoint
[
i
]
;
StyleCache
&
styleCacheBeforeEdit
=
TopLevelEditSubActionDataRef
(
)
.
mCachedInlineStyles
[
i
]
;
if
(
styleCacheBeforeEdit
.
mPresent
)
{
bool
bFirst
bAny
bAll
;
bFirst
=
bAny
=
bAll
=
false
;
nsAutoString
curValue
;
if
(
useCSS
)
{
bAny
=
CSSEditUtils
:
:
IsCSSEquivalentToHTMLInlineStyleSet
(
selNode
styleCacheBeforeEdit
.
mTag
styleCacheBeforeEdit
.
mAttr
curValue
CSSEditUtils
:
:
eComputed
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
!
bAny
)
{
nsresult
rv
=
GetInlinePropertyBase
(
*
styleCacheBeforeEdit
.
mTag
styleCacheBeforeEdit
.
mAttr
&
styleCacheBeforeEdit
.
mValue
&
bFirst
&
bAny
&
bAll
&
curValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
(
!
bAny
|
|
IsStyleCachePreservingSubAction
(
GetTopLevelEditSubAction
(
)
)
)
&
&
(
!
styleCacheAtInsertionPoint
.
mPresent
|
|
styleCacheAtInsertionPoint
.
mValue
!
=
styleCacheBeforeEdit
.
mValue
)
)
{
mTypeInState
-
>
SetProp
(
styleCacheBeforeEdit
.
mTag
styleCacheBeforeEdit
.
mAttr
styleCacheBeforeEdit
.
mValue
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
nodeArray
;
EmptyEditableFunctor
functor
(
this
)
;
DOMIterator
iter
;
if
(
NS_WARN_IF
(
NS_FAILED
(
iter
.
Init
(
aStartRef
aEndRef
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
EditorDOMPoint
endOfNode
(
EditorDOMPoint
:
:
AtEndOf
(
node
)
)
;
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
endOfNode
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureCaretInBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
StaticRange
>
staticRange
=
StaticRange
:
:
Create
(
atCaret
.
ToRawRangeBoundary
(
)
atCaret
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
staticRange
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
&
aElement
staticRange
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
nsIContent
*
lastEditableContent
=
GetLastEditableChild
(
aElement
)
;
if
(
!
lastEditableContent
)
{
lastEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
endPoint
;
if
(
EditorBase
:
:
IsTextNode
(
lastEditableContent
)
|
|
IsContainer
(
lastEditableContent
)
)
{
endPoint
.
SetToEndOf
(
lastEditableContent
)
;
}
else
{
endPoint
.
Set
(
lastEditableContent
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
endPoint
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsIContent
*
firstEditableContent
=
GetFirstEditableChild
(
aElement
)
;
if
(
!
firstEditableContent
)
{
firstEditableContent
=
&
aElement
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
EditorBase
:
:
IsTextNode
(
firstEditableContent
)
|
|
IsContainer
(
firstEditableContent
)
)
{
atStartOfBlock
.
Set
(
firstEditableContent
)
;
}
else
{
atStartOfBlock
.
Set
(
firstEditableContent
0
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atStartOfBlock
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
void
HTMLEditor
:
:
SetSelectionInterlinePosition
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atCaret
.
IsSetAndValid
(
)
)
;
if
(
nsIContent
*
previousEditableContentInBlock
=
GetPreviousEditableHTMLNodeInBlock
(
atCaret
)
)
{
if
(
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
!
atCaret
.
GetChild
(
)
)
{
return
;
}
if
(
nsIContent
*
previousEditableContentInBlockAtCaret
=
GetPriorHTMLSibling
(
atCaret
.
GetChild
(
)
)
)
{
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
previousEditableContentInBlockAtCaret
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
return
;
}
}
if
(
nsIContent
*
nextEditableContentInBlockAtCaret
=
GetNextHTMLSibling
(
atCaret
.
GetChild
(
)
)
)
{
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nextEditableContentInBlockAtCaret
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
false
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
false
)
failed
but
ignored
"
)
;
}
}
}
nsresult
HTMLEditor
:
:
AdjustCaretPositionAndEnsurePaddingBRElement
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
;
EditorDOMPoint
point
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
IsEditable
(
point
.
GetContainer
(
)
)
)
{
point
.
Set
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
RefPtr
<
Element
>
blockElement
=
GetBlock
(
*
point
.
GetContainer
(
)
)
)
{
if
(
IsEditable
(
blockElement
)
)
{
bool
isEmptyNode
;
nsresult
rv
=
IsEmptyNode
(
blockElement
&
isEmptyNode
false
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
&
&
CanContainTag
(
*
point
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
)
{
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
point
.
GetContainer
(
)
=
=
bodyOrDocumentElement
)
{
return
NS_OK
;
}
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
return
NS_OK
;
}
}
}
if
(
point
.
IsInTextNode
(
)
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIContent
>
previousEditableContent
=
GetPreviousEditableHTMLNode
(
point
)
)
{
RefPtr
<
Element
>
blockElementAtCaret
=
GetBlock
(
*
point
.
GetContainer
(
)
)
;
RefPtr
<
Element
>
blockElementParentAtPreviousEditableContent
=
GetBlockNodeParent
(
previousEditableContent
)
;
if
(
blockElementAtCaret
&
&
blockElementAtCaret
=
=
blockElementParentAtPreviousEditableContent
&
&
previousEditableContent
&
&
TextEditUtils
:
:
IsBreak
(
previousEditableContent
)
)
{
if
(
!
IsVisibleBRElement
(
previousEditableContent
)
)
{
CreateElementResult
createPaddingBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
point
)
;
if
(
NS_WARN_IF
(
createPaddingBRResult
.
Failed
(
)
)
)
{
return
createPaddingBRResult
.
Rv
(
)
;
}
point
.
Set
(
createPaddingBRResult
.
GetNewNode
(
)
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
point
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
if
(
nsIContent
*
nextEditableContentInBlock
=
GetNextEditableHTMLNodeInBlock
(
*
previousEditableContent
)
)
{
if
(
EditorBase
:
:
IsPaddingBRElementForEmptyLastLine
(
*
nextEditableContentInBlock
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Failed
to
set
interline
position
"
)
;
}
}
}
}
if
(
nsIContent
*
previousEditableContentInBlock
=
GetPreviousEditableHTMLNodeInBlock
(
point
)
)
{
if
(
TextEditUtils
:
:
IsBreak
(
previousEditableContentInBlock
)
|
|
EditorBase
:
:
IsTextNode
(
previousEditableContentInBlock
)
|
|
HTMLEditUtils
:
:
IsImage
(
previousEditableContentInBlock
)
|
|
previousEditableContentInBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
if
(
nsIContent
*
nextEditableContentInBlock
=
GetNextEditableHTMLNodeInBlock
(
point
)
)
{
if
(
TextEditUtils
:
:
IsBreak
(
nextEditableContentInBlock
)
|
|
EditorBase
:
:
IsTextNode
(
nextEditableContentInBlock
)
|
|
nextEditableContentInBlock
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
}
nsIContent
*
nearEditableContent
=
FindNearEditableContent
(
point
aDirectionAndAmount
)
;
if
(
!
nearEditableContent
)
{
return
NS_OK
;
}
EditorDOMPoint
pointToPutCaret
=
GetGoodCaretPointFor
(
*
nearEditableContent
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
pointToPutCaret
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
FindNearEditableContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
nsIContent
*
editableContent
=
nullptr
;
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
editableContent
=
GetPreviousEditableHTMLNode
(
aPoint
)
;
if
(
!
editableContent
)
{
return
nullptr
;
}
}
else
{
editableContent
=
GetNextEditableHTMLNode
(
aPoint
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
while
(
editableContent
&
&
!
EditorBase
:
:
IsTextNode
(
editableContent
)
&
&
!
TextEditUtils
:
:
IsBreak
(
editableContent
)
&
&
!
HTMLEditUtils
:
:
IsImage
(
editableContent
)
)
{
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
editableContent
=
GetPreviousEditableHTMLNode
(
*
editableContent
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
else
{
editableContent
=
GetNextEditableHTMLNode
(
*
editableContent
)
;
if
(
NS_WARN_IF
(
!
editableContent
)
)
{
return
nullptr
;
}
}
}
if
(
HTMLEditor
:
:
NodesInDifferentTableElements
(
*
editableContent
*
aPoint
.
GetContainer
(
)
)
)
{
return
nullptr
;
}
return
editableContent
;
}
bool
HTMLEditor
:
:
NodesInDifferentTableElements
(
nsINode
&
aNode1
nsINode
&
aNode2
)
{
nsINode
*
parentNode1
;
for
(
parentNode1
=
&
aNode1
;
parentNode1
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parentNode1
)
;
parentNode1
=
parentNode1
-
>
GetParentNode
(
)
)
{
}
nsINode
*
parentNode2
;
for
(
parentNode2
=
&
aNode2
;
parentNode2
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parentNode2
)
;
parentNode2
=
parentNode2
-
>
GetParentNode
(
)
)
{
}
return
parentNode1
!
=
parentNode2
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyNodesIn
(
nsRange
&
aRange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
&
aRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfEmptyNodes
arrayOfEmptyCites
skipList
;
for
(
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
postOrderIter
.
GetCurrentNode
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
node
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parent
)
{
skipList
[
idx
]
=
parent
;
}
continue
;
}
bool
isCandidate
=
false
;
bool
isMailCite
=
false
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
isMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
node
)
|
|
HTMLEditUtils
:
:
IsList
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
isCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
isCandidate
=
!
StartOrEndOfSelectionRangesIsIn
(
*
node
-
>
AsContent
(
)
)
;
}
}
bool
isEmptyNode
=
false
;
if
(
isCandidate
)
{
nsresult
rv
=
IsEmptyNode
(
node
&
isEmptyNode
isMailCite
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmptyNode
)
{
if
(
isMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
node
)
;
}
else
{
arrayOfEmptyNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
!
isEmptyNode
&
&
parent
)
{
skipList
.
AppendElement
(
*
parent
)
;
}
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyNodes
)
{
if
(
IsModifiableNode
(
delNode
)
)
{
rv
=
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
for
(
OwningNonNull
<
nsINode
>
&
delNode
:
arrayOfEmptyCites
)
{
bool
isEmptyNode
;
nsresult
rv
=
IsEmptyNode
(
delNode
&
isEmptyNode
false
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmptyNode
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
delNode
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
DeleteNodeWithTransaction
(
*
delNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
StartOrEndOfSelectionRangesIsIn
(
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
+
+
i
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
)
{
if
(
&
aContent
=
=
startContainer
)
{
return
true
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
startContainer
aContent
)
)
{
return
true
;
}
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
)
{
if
(
&
aContent
=
=
endContainer
)
{
return
true
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
endContainer
aContent
)
)
{
return
true
;
}
}
}
return
false
;
}
nsresult
HTMLEditor
:
:
LiftUpListItemElement
(
Element
&
aListItemElement
LiftUpFromAllParentListElements
aLiftUpFromAllParentListElements
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
)
|
|
NS_WARN_IF
(
!
aListItemElement
.
GetParentElement
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isFirstListItem
=
IsFirstEditableChild
(
&
aListItemElement
)
;
bool
isLastListItem
=
IsLastEditableChild
(
&
aListItemElement
)
;
Element
*
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
leftListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
&
&
!
isLastListItem
)
{
EditorDOMPoint
atListItemElement
(
&
aListItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItemElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atListItemElement
.
IsSetAndValid
(
)
)
;
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
maybeLeftListContent
=
SplitNodeWithTransaction
(
atListItemElement
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
maybeLeftListContent
-
>
IsElement
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
leftListElement
=
maybeLeftListContent
-
>
AsElement
(
)
;
}
EditorDOMPoint
pointToInsertListItem
(
leftListElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
MoveNodeWithTransaction
(
aListItemElement
pointToInsertListItem
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
HTMLEditUtils
:
:
IsList
(
pointToInsertListItem
.
GetContainer
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
{
rv
=
RemoveBlockContainerWithTransaction
(
aListItemElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aLiftUpFromAllParentListElements
=
=
LiftUpFromAllParentListElements
:
:
No
)
{
return
NS_OK
;
}
return
LiftUpListItemElement
(
aListItemElement
LiftUpFromAllParentListElements
:
:
Yes
)
;
}
nsresult
HTMLEditor
:
:
DestroyListStructureRecursively
(
Element
&
aListElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsList
(
&
aListElement
)
)
;
while
(
aListElement
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aListElement
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
nsresult
rv
=
LiftUpListItemElement
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
HTMLEditor
:
:
LiftUpFromAllParentListElements
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
nsresult
rv
=
DestroyListStructureRecursively
(
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
RemoveBlockContainerWithTransaction
(
aListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureSelectionInBodyOrDocumentElement
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atCaret
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
temp
=
atCaret
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
RawRangeBoundary
(
bodyOrDocumentElement
0
)
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
with
start
of
editing
host
failed
but
ignored
"
)
;
return
NS_OK
;
}
EditorRawDOMPoint
selectionEndPoint
(
EditorBase
:
:
GetEndPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
selectionEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
temp
=
selectionEndPoint
.
GetContainer
(
)
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentOrShadowHostNode
(
)
;
}
if
(
!
temp
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
RawRangeBoundary
(
bodyOrDocumentElement
0
)
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
with
start
of
editing
host
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineIfNeeded
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
aElement
)
)
{
return
NS_OK
;
}
bool
isEmpty
=
false
;
nsresult
rv
=
IsEmptyNode
(
&
aElement
&
isEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmpty
)
{
return
NS_OK
;
}
CreateElementResult
createBRResult
=
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
NS_WARNING_ASSERTION
(
createBRResult
.
Succeeded
(
)
"
Failed
to
create
padding
<
br
>
element
"
)
;
return
createBRResult
.
Rv
(
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElementIfEmptyBlockElement
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
aElement
)
)
{
return
NS_OK
;
}
bool
isEmpty
;
nsresult
rv
=
IsEmptyNode
(
&
aElement
&
isEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmpty
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
brElement
"
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
brElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
HTMLEditRules
:
:
DidCreateNode
(
Element
&
aNewElement
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddNodeToChangedRange
(
HTMLEditorRef
(
)
aNewElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddNodeToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
DidInsertNode
(
nsIContent
&
aContent
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddNodeToChangedRange
(
HTMLEditorRef
(
)
aContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddNodeToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
WillDeleteNode
(
nsINode
&
aChild
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddNodeToChangedRange
(
HTMLEditorRef
(
)
aChild
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddNodeToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
DidSplitNode
(
nsINode
&
aExistingRightNode
nsINode
&
aNewLeftNode
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddRangeToChangedRange
(
HTMLEditorRef
(
)
EditorRawDOMPoint
(
&
aNewLeftNode
0
)
EditorRawDOMPoint
(
&
aExistingRightNode
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddRangeToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
WillJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mJoinedLeftNodeLength
=
aLeftNode
.
Length
(
)
;
}
void
HTMLEditRules
:
:
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddPointToChangedRange
(
HTMLEditorRef
(
)
EditorRawDOMPoint
(
&
aRightNode
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mJoinedLeftNodeLength
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddPointToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
DidInsertText
(
nsINode
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddRangeToChangedRange
(
HTMLEditorRef
(
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
+
aString
.
Length
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddRangeToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
DidDeleteText
(
nsINode
&
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddPointToChangedRange
(
HTMLEditorRef
(
)
EditorRawDOMPoint
(
&
aTextNode
aOffset
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddPointToChangedRange
(
)
failed
"
)
;
}
void
HTMLEditRules
:
:
WillDeleteSelection
(
)
{
if
(
!
mInitialized
|
|
!
mHTMLEditor
)
{
return
;
}
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
AutoSafeEditorData
setData
(
*
this
*
mHTMLEditor
)
;
if
(
!
HTMLEditorRef
(
)
.
EditSubActionDataRef
(
)
.
mAdjustChangedRangeFromListener
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
HTMLEditorRef
(
)
.
TopLevelEditSubActionDataRef
(
)
.
AddRangeToChangedRange
(
HTMLEditorRef
(
)
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AddRangeToChangedRange
(
)
failed
"
)
;
}
nsresult
HTMLEditor
:
:
RemoveAlignFromDescendants
(
Element
&
aElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
;
bool
useCSS
=
IsCSSEnabled
(
)
;
nsCOMPtr
<
nsIContent
>
nextSibling
;
for
(
nsIContent
*
content
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
&
aElement
:
aElement
.
GetFirstChild
(
)
;
content
;
content
=
nextSibling
)
{
nextSibling
=
aEditTarget
=
=
EditTarget
:
:
NodeAndDescendantsExceptTable
?
nullptr
:
content
-
>
GetNextSibling
(
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
OwningNonNull
<
Element
>
centerElement
=
*
content
-
>
AsElement
(
)
;
nsresult
rv
=
RemoveAlignFromDescendants
(
centerElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
EnsureHardLineBeginsWithFirstChildOf
(
centerElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
EnsureHardLineEndsWithLastChildOf
(
centerElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
RemoveContainerWithTransaction
(
centerElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
!
HTMLEditor
:
:
NodeIsBlockStatic
(
*
content
)
&
&
!
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
continue
;
}
OwningNonNull
<
Element
>
blockOrHRElement
=
*
content
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
blockOrHRElement
)
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
blockOrHRElement
*
nsGkAtoms
:
:
align
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
useCSS
)
{
if
(
blockOrHRElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
blockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsAutoString
dummyCssValue
;
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSInlineStyle
(
blockOrHRElement
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
blockOrHRElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
blockOrHRElement
aAlignType
EditTarget
:
:
OnlyDescendantsExceptTable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineBeginsWithFirstChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableChild
=
GetFirstEditableChild
(
aRemovingContainerElement
)
;
if
(
!
firstEditableChild
)
{
return
NS_OK
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
firstEditableChild
)
|
|
firstEditableChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
previousEditableContent
=
GetPriorHTMLSibling
(
&
aRemovingContainerElement
)
;
if
(
!
previousEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
previousEditableContent
)
|
|
previousEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aRemovingContainerElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EnsureHardLineEndsWithLastChildOf
(
Element
&
aRemovingContainerElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsIContent
*
firstEditableContent
=
GetLastEditableChild
(
aRemovingContainerElement
)
;
if
(
!
firstEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
firstEditableContent
)
|
|
firstEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
nsIContent
*
nextEditableContent
=
GetPriorHTMLSibling
(
&
aRemovingContainerElement
)
;
if
(
!
nextEditableContent
)
{
return
NS_OK
;
}
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nextEditableContent
)
|
|
nextEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
:
:
AtEndOf
(
aRemovingContainerElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetBlockElementAlign
(
Element
&
aBlockOrHRElement
const
nsAString
&
aAlignType
EditTarget
aEditTarget
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditor
:
:
NodeIsBlockStatic
(
aBlockOrHRElement
)
|
|
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
;
MOZ_ASSERT
(
IsCSSEnabled
(
)
|
|
HTMLEditUtils
:
:
SupportsAlignAttr
(
aBlockOrHRElement
)
)
;
if
(
!
aBlockOrHRElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignFromDescendants
(
aBlockOrHRElement
aAlignType
aEditTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
SetAttributeOrEquivalent
(
&
aBlockOrHRElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetAttributeOrEquivalent
(
)
failed
to
set
align
attribute
or
property
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ChangeMarginStart
(
Element
&
aElement
ChangeMargin
aChangeMargin
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsStaticAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
aElement
)
;
nsAutoString
value
;
CSSEditUtils
:
:
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
float
f
;
RefPtr
<
nsAtom
>
unit
;
CSSEditUtils
:
:
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
CSSEditUtils
:
:
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChangeMargin
=
=
ChangeMargin
:
:
Increase
?
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
mCSSEditUtils
-
>
SetCSSProperty
(
aElement
MOZ_KnownLive
(
marginProperty
)
newValue
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
return
NS_OK
;
}
mCSSEditUtils
-
>
RemoveCSSProperty
(
aElement
MOZ_KnownLive
(
marginProperty
)
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
&
aElement
=
=
editingHost
|
|
!
aElement
.
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToAbsoluteAsSubAction
(
)
{
MOZ_ASSERT
(
IsTopLevelEditSubActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToAbsolute
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
focusElement
=
GetSelectionContainerElement
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
focusElement
)
;
return
EditActionHandled
(
)
;
}
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
MaybeExtendSelectionToHardLineEdgesForBlockEditAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
nullptr
;
RefPtr
<
Element
>
divElement
;
rv
=
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
address_of
(
divElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
!
divElement
)
{
return
EditActionHandled
(
)
;
}
rv
=
SetPositionToAbsoluteOrStatic
(
*
divElement
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mNewBlockElement
=
std
:
:
move
(
divElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetPositionToAbsoluteOrStatic
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
nsresult
HTMLEditor
:
:
MoveSelectedContentsToDivElementToMakeItAbsolutePosition
(
RefPtr
<
Element
>
*
aTargetElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aTargetElement
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTArray
<
RefPtr
<
nsRange
>
4
>
arrayOfRanges
;
GetSelectionRangesExtendedToHardLineStartAndEnd
(
arrayOfRanges
EditSubAction
:
:
eSetPositionToAbsolute
)
;
AutoTArray
<
OwningNonNull
<
nsINode
>
64
>
arrayOfNodes
;
nsresult
rv
=
SplitInlinesAndCollectEditTargetNodes
(
arrayOfRanges
arrayOfNodes
EditSubAction
:
:
eSetPositionToAbsolute
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
IsEmptyOneHardLine
(
arrayOfNodes
)
)
{
nsRange
*
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atCaret
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCaret
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
RefPtr
<
Element
>
newDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
newDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
DeleteNodeWithTransaction
(
*
curNode
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
restoreSelectionLater
.
Abort
(
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
RawRangeBoundary
(
newDivElement
0
)
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
*
aTargetElement
=
std
:
:
move
(
newDivElement
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
RefPtr
<
Element
>
targetDivElement
;
RefPtr
<
Element
>
createdListElement
;
RefPtr
<
Element
>
handledListItemElement
;
for
(
OwningNonNull
<
nsINode
>
&
curNode
:
arrayOfNodes
)
{
EditorDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
atCurNode
.
GetContainer
(
)
)
)
{
nsIContent
*
previousEditableContent
=
createdListElement
?
GetPriorHTMLSibling
(
curNode
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
nsAtom
*
ULOrOLOrDLTagName
=
atCurNode
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
targetDivElement
)
{
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
targetDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
createdListElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
ULOrOLOrDLTagName
)
EditorDOMPoint
:
:
AtEndOf
(
*
targetDivElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
createdListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
continue
;
}
if
(
RefPtr
<
Element
>
listItemElement
=
curNode
-
>
IsContent
(
)
?
GetNearestAncestorListItemElement
(
*
curNode
-
>
AsContent
(
)
)
:
nullptr
)
{
if
(
handledListItemElement
=
=
listItemElement
)
{
continue
;
}
nsIContent
*
previousEditableContent
=
createdListElement
?
GetPriorHTMLSibling
(
listItemElement
)
:
nullptr
;
if
(
!
createdListElement
|
|
(
previousEditableContent
&
&
previousEditableContent
!
=
createdListElement
)
)
{
EditorDOMPoint
atListItem
(
listItemElement
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAtom
*
containerName
=
atListItem
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
atListItem
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
if
(
!
targetDivElement
)
{
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
EditorDOMPoint
(
atListItem
.
GetContainer
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
targetDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
createdListElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
containerName
)
EditorDOMPoint
:
:
AtEndOf
(
*
targetDivElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
createdListElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
MoveNodeToEndWithTransaction
(
*
listItemElement
*
createdListElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
handledListItemElement
=
std
:
:
move
(
listItemElement
)
;
continue
;
}
if
(
!
targetDivElement
)
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
targetDivElement
=
curNode
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
createdListElement
)
;
MOZ_ASSERT
(
!
handledListItemElement
)
;
continue
;
}
SplitNodeResult
splitNodeResult
=
MaybeSplitAncestorsForInsertWithTransaction
(
*
nsGkAtoms
:
:
div
atCurNode
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
targetDivElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
div
splitNodeResult
.
SplitPoint
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
!
targetDivElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
MoveNodeToEndWithTransaction
(
MOZ_KnownLive
(
*
curNode
-
>
AsContent
(
)
)
*
targetDivElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
createdListElement
=
nullptr
;
}
*
aTargetElement
=
std
:
:
move
(
targetDivElement
)
;
return
NS_OK
;
}
EditActionResult
HTMLEditor
:
:
SetSelectionToStaticAsSubAction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSetPositionToStatic
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
element
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
nsresult
rv
=
SetPositionToAbsoluteOrStatic
(
*
element
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
EditActionResult
HTMLEditor
:
:
AddZIndexAsSubAction
(
int32_t
aChange
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
aChange
<
0
?
EditSubAction
:
:
eDecreaseZIndex
:
EditSubAction
:
:
eIncreaseZIndex
nsIEditor
:
:
eNext
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
RefPtr
<
Element
>
absolutelyPositionedElement
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
if
(
NS_WARN_IF
(
!
absolutelyPositionedElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
int32_t
zIndex
;
nsresult
rv
=
RelativeChangeElementZIndex
(
*
absolutelyPositionedElement
aChange
&
zIndex
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
:
EditActionHandled
(
NS_OK
)
;
}
nsresult
HTMLEditRules
:
:
DocumentModified
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditRules
:
:
DocumentModifiedWorker
"
this
&
HTMLEditRules
:
:
DocumentModifiedWorker
)
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
DocumentModifiedWorker
(
)
{
if
(
NS_WARN_IF
(
!
CanHandleEditAction
(
)
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsresult
rv
=
htmlEditor
-
>
OnModifyDocument
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnModifyDocument
(
)
failed
"
)
;
Unused
<
<
rv
;
}
}
