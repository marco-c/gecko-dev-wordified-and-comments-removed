#
include
"
HTMLEditRules
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CSSEditUtils
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMCharacterData
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
<
algorithm
>
#
ifdef
SetProp
#
undef
SetProp
#
endif
class
nsISupports
;
namespace
mozilla
{
class
RulesInfo
;
using
namespace
dom
;
enum
{
kLonely
=
0
kPrevSib
=
1
kNextSib
=
2
kBothSibs
=
3
}
;
static
bool
IsBlockNode
(
const
nsINode
&
node
)
{
return
HTMLEditor
:
:
NodeIsBlockStatic
(
&
node
)
;
}
static
bool
IsInlineNode
(
const
nsINode
&
node
)
{
return
!
IsBlockNode
(
node
)
;
}
static
bool
IsStyleCachePreservingAction
(
EditAction
action
)
{
return
action
=
=
EditAction
:
:
deleteSelection
|
|
action
=
=
EditAction
:
:
insertBreak
|
|
action
=
=
EditAction
:
:
makeList
|
|
action
=
=
EditAction
:
:
indent
|
|
action
=
=
EditAction
:
:
outdent
|
|
action
=
=
EditAction
:
:
align
|
|
action
=
=
EditAction
:
:
makeBasicBlock
|
|
action
=
=
EditAction
:
:
removeList
|
|
action
=
=
EditAction
:
:
makeDefListItem
|
|
action
=
=
EditAction
:
:
insertElement
|
|
action
=
=
EditAction
:
:
insertQuotation
;
}
static
nsAtom
&
ParagraphSeparatorElement
(
ParagraphSeparator
separator
)
{
switch
(
separator
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
paragraph
separator
!
"
)
;
case
ParagraphSeparator
:
:
div
:
return
*
nsGkAtoms
:
:
div
;
case
ParagraphSeparator
:
:
p
:
return
*
nsGkAtoms
:
:
p
;
case
ParagraphSeparator
:
:
br
:
return
*
nsGkAtoms
:
:
br
;
}
}
class
TableCellAndListItemFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
return
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
aNode
)
;
}
}
;
class
BRNodeFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
}
;
class
EmptyEditableFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
EmptyEditableFunctor
(
HTMLEditor
*
aHTMLEditor
)
:
mHTMLEditor
(
aHTMLEditor
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
if
(
mHTMLEditor
-
>
IsEditable
(
aNode
)
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
aNode
)
)
)
{
bool
bIsEmptyNode
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
aNode
&
bIsEmptyNode
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
bIsEmptyNode
)
{
return
true
;
}
}
return
false
;
}
protected
:
HTMLEditor
*
mHTMLEditor
;
}
;
HTMLEditRules
:
:
HTMLEditRules
(
)
:
mHTMLEditor
(
nullptr
)
mListenerEnabled
(
false
)
mReturnInEmptyLIKillsList
(
false
)
mDidDeleteSelection
(
false
)
mDidRangedDelete
(
false
)
mRestoreContentEditableCount
(
false
)
mJoinOffset
(
0
)
{
InitFields
(
)
;
}
void
HTMLEditRules
:
:
InitFields
(
)
{
mHTMLEditor
=
nullptr
;
mDocChangeRange
=
nullptr
;
mListenerEnabled
=
true
;
mReturnInEmptyLIKillsList
=
true
;
mDidDeleteSelection
=
false
;
mDidRangedDelete
=
false
;
mRestoreContentEditableCount
=
false
;
mUtilRange
=
nullptr
;
mJoinOffset
=
0
;
mNewBlock
=
nullptr
;
mRangeItem
=
new
RangeItem
(
)
;
InitStyleCacheArray
(
mCachedStyles
)
;
}
void
HTMLEditRules
:
:
InitStyleCacheArray
(
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
aStyleCache
[
0
]
=
StyleCache
(
nsGkAtoms
:
:
b
EmptyString
(
)
)
;
aStyleCache
[
1
]
=
StyleCache
(
nsGkAtoms
:
:
i
EmptyString
(
)
)
;
aStyleCache
[
2
]
=
StyleCache
(
nsGkAtoms
:
:
u
EmptyString
(
)
)
;
aStyleCache
[
3
]
=
StyleCache
(
nsGkAtoms
:
:
font
NS_LITERAL_STRING
(
"
face
"
)
)
;
aStyleCache
[
4
]
=
StyleCache
(
nsGkAtoms
:
:
font
NS_LITERAL_STRING
(
"
size
"
)
)
;
aStyleCache
[
5
]
=
StyleCache
(
nsGkAtoms
:
:
font
NS_LITERAL_STRING
(
"
color
"
)
)
;
aStyleCache
[
6
]
=
StyleCache
(
nsGkAtoms
:
:
tt
EmptyString
(
)
)
;
aStyleCache
[
7
]
=
StyleCache
(
nsGkAtoms
:
:
em
EmptyString
(
)
)
;
aStyleCache
[
8
]
=
StyleCache
(
nsGkAtoms
:
:
strong
EmptyString
(
)
)
;
aStyleCache
[
9
]
=
StyleCache
(
nsGkAtoms
:
:
dfn
EmptyString
(
)
)
;
aStyleCache
[
10
]
=
StyleCache
(
nsGkAtoms
:
:
code
EmptyString
(
)
)
;
aStyleCache
[
11
]
=
StyleCache
(
nsGkAtoms
:
:
samp
EmptyString
(
)
)
;
aStyleCache
[
12
]
=
StyleCache
(
nsGkAtoms
:
:
var
EmptyString
(
)
)
;
aStyleCache
[
13
]
=
StyleCache
(
nsGkAtoms
:
:
cite
EmptyString
(
)
)
;
aStyleCache
[
14
]
=
StyleCache
(
nsGkAtoms
:
:
abbr
EmptyString
(
)
)
;
aStyleCache
[
15
]
=
StyleCache
(
nsGkAtoms
:
:
acronym
EmptyString
(
)
)
;
aStyleCache
[
16
]
=
StyleCache
(
nsGkAtoms
:
:
backgroundColor
EmptyString
(
)
)
;
aStyleCache
[
17
]
=
StyleCache
(
nsGkAtoms
:
:
sub
EmptyString
(
)
)
;
aStyleCache
[
18
]
=
StyleCache
(
nsGkAtoms
:
:
sup
EmptyString
(
)
)
;
}
HTMLEditRules
:
:
~
HTMLEditRules
(
)
{
if
(
mHTMLEditor
)
{
mHTMLEditor
-
>
RemoveEditActionListener
(
this
)
;
}
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLEditRules
TextEditRules
nsIEditActionListener
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLEditRules
TextEditRules
mDocChangeRange
mUtilRange
mNewBlock
mRangeItem
)
NS_IMETHODIMP
HTMLEditRules
:
:
Init
(
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aTextEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
InitFields
(
)
;
mHTMLEditor
=
aTextEditor
-
>
AsHTMLEditor
(
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
TextEditRules
:
:
Init
(
aTextEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
char
kPrefName
[
]
=
"
editor
.
html
.
typing
.
returnInEmptyListItemClosesList
"
;
nsAutoCString
returnInEmptyLIKillsList
;
Preferences
:
:
GetCString
(
kPrefName
returnInEmptyLIKillsList
)
;
mReturnInEmptyLIKillsList
=
!
returnInEmptyLIKillsList
.
EqualsLiteral
(
"
false
"
)
;
nsCOMPtr
<
nsINode
>
node
=
mHTMLEditor
-
>
GetRoot
(
)
;
if
(
!
node
)
{
node
=
mHTMLEditor
-
>
GetDocument
(
)
;
}
NS_ENSURE_STATE
(
node
)
;
mUtilRange
=
new
nsRange
(
node
)
;
AutoLockRulesSniffing
lockIt
(
this
)
;
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
node
)
;
}
if
(
node
-
>
IsElement
(
)
)
{
ErrorResult
rv
;
mDocChangeRange
-
>
SelectNode
(
*
node
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
AdjustSpecialBreaks
(
)
;
}
return
mHTMLEditor
-
>
AddEditActionListener
(
this
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DetachEditor
(
)
{
if
(
mHTMLEditor
)
{
mHTMLEditor
-
>
RemoveEditActionListener
(
this
)
;
}
mHTMLEditor
=
nullptr
;
return
TextEditRules
:
:
DetachEditor
(
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
BeforeEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
AutoLockRulesSniffing
lockIt
(
this
)
;
mDidExplicitlySetInterline
=
false
;
if
(
!
mActionNesting
)
{
mActionNesting
+
+
;
mDidRangedDelete
=
false
;
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
|
|
!
selection
-
>
RangeCount
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRangeItem
-
>
mStartContainer
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
mRangeItem
-
>
mStartOffset
=
selection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
mRangeItem
-
>
mEndContainer
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetEndContainer
(
)
;
mRangeItem
-
>
mEndOffset
=
selection
-
>
GetRangeAt
(
0
)
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
mRangeItem
-
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
selEndNode
=
mRangeItem
-
>
mEndContainer
;
htmlEditor
-
>
mRangeUpdater
.
RegisterRangeItem
(
mRangeItem
)
;
mDidDeleteSelection
=
false
;
if
(
mDocChangeRange
)
{
mDocChangeRange
-
>
Reset
(
)
;
}
if
(
mUtilRange
)
{
mUtilRange
-
>
Reset
(
)
;
}
if
(
action
=
=
EditAction
:
:
insertText
|
|
action
=
=
EditAction
:
:
insertIMEText
|
|
action
=
=
EditAction
:
:
deleteSelection
|
|
IsStyleCachePreservingAction
(
action
)
)
{
nsCOMPtr
<
nsINode
>
selNode
=
aDirection
=
=
nsIEditor
:
:
eNext
?
selEndNode
:
selStartNode
;
nsresult
rv
=
CacheInlineStyles
(
selNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDOMDocument
>
doc
=
htmlEditor
-
>
GetDOMDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
doc
)
;
NS_ENSURE_TRUE
(
htmlDoc
NS_ERROR_FAILURE
)
;
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
+
1
)
;
mRestoreContentEditableCount
=
true
;
}
ConfirmSelectionInBody
(
)
;
mTheAction
=
action
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
AfterEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
mLockRulesSniffing
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
AutoLockRulesSniffing
lockIt
(
this
)
;
MOZ_ASSERT
(
mActionNesting
>
0
)
;
nsresult
rv
=
NS_OK
;
mActionNesting
-
-
;
if
(
!
mActionNesting
)
{
rv
=
AfterEditInner
(
action
aDirection
)
;
htmlEditor
-
>
mRangeUpdater
.
DropRangeItem
(
mRangeItem
)
;
if
(
mRestoreContentEditableCount
)
{
nsCOMPtr
<
nsIDOMDocument
>
doc
=
htmlEditor
-
>
GetDOMDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
doc
)
;
NS_ENSURE_TRUE
(
htmlDoc
NS_ERROR_FAILURE
)
;
if
(
htmlDoc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
)
{
htmlDoc
-
>
ChangeContentEditableCount
(
nullptr
-
1
)
;
}
mRestoreContentEditableCount
=
false
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AfterEditInner
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
{
ConfirmSelectionInBody
(
)
;
if
(
action
=
=
EditAction
:
:
ignore
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
nsCOMPtr
<
nsINode
>
rangeStartContainer
rangeEndContainer
;
uint32_t
rangeStartOffset
=
0
rangeEndOffset
=
0
;
bool
bDamagedRange
=
false
;
if
(
mDocChangeRange
)
{
rangeStartContainer
=
mDocChangeRange
-
>
GetStartContainer
(
)
;
rangeEndContainer
=
mDocChangeRange
-
>
GetEndContainer
(
)
;
rangeStartOffset
=
mDocChangeRange
-
>
StartOffset
(
)
;
rangeEndOffset
=
mDocChangeRange
-
>
EndOffset
(
)
;
if
(
rangeStartContainer
&
&
rangeEndContainer
)
{
bDamagedRange
=
true
;
}
}
if
(
bDamagedRange
&
&
!
(
(
action
=
=
EditAction
:
:
undo
)
|
|
(
action
=
=
EditAction
:
:
redo
)
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
PromoteRange
(
*
mDocChangeRange
action
)
;
if
(
action
=
=
EditAction
:
:
deleteSelection
&
&
mDidRangedDelete
)
{
nsresult
rv
=
InsertBRIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AdjustSpecialBreaks
(
)
;
if
(
action
!
=
EditAction
:
:
insertText
&
&
action
!
=
EditAction
:
:
insertIMEText
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
CollapseAdjacentTextNodes
(
mDocChangeRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
RemoveEmptyNodes
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
action
=
=
EditAction
:
:
insertText
|
|
action
=
=
EditAction
:
:
insertIMEText
|
|
action
=
=
EditAction
:
:
deleteSelection
|
|
action
=
=
EditAction
:
:
insertBreak
|
|
action
=
=
EditAction
:
:
htmlPaste
|
|
action
=
=
EditAction
:
:
loadHTML
)
{
rv
=
AdjustWhitespace
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
NS_ENSURE_STATE
(
mRangeItem
-
>
mStartContainer
)
;
NS_ENSURE_STATE
(
mRangeItem
-
>
mEndContainer
)
;
WSRunObject
(
mHTMLEditor
mRangeItem
-
>
mStartContainer
mRangeItem
-
>
mStartOffset
)
.
AdjustWhitespace
(
)
;
if
(
mRangeItem
-
>
mStartContainer
!
=
mRangeItem
-
>
mEndContainer
|
|
mRangeItem
-
>
mStartOffset
!
=
mRangeItem
-
>
mEndOffset
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
(
mHTMLEditor
mRangeItem
-
>
mEndContainer
mRangeItem
-
>
mEndOffset
)
.
AdjustWhitespace
(
)
;
}
}
if
(
mNewBlock
)
{
rv
=
PinSelectionToNewBlock
(
selection
)
;
mNewBlock
=
nullptr
;
}
if
(
action
=
=
EditAction
:
:
insertText
|
|
action
=
=
EditAction
:
:
insertIMEText
|
|
action
=
=
EditAction
:
:
deleteSelection
|
|
action
=
=
EditAction
:
:
insertBreak
|
|
action
=
=
EditAction
:
:
htmlPaste
|
|
action
=
=
EditAction
:
:
loadHTML
)
{
rv
=
AdjustSelection
(
selection
aDirection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
action
=
=
EditAction
:
:
insertText
|
|
action
=
=
EditAction
:
:
insertIMEText
|
|
action
=
=
EditAction
:
:
deleteSelection
|
|
IsStyleCachePreservingAction
(
action
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
mTypeInState
-
>
UpdateSelState
(
selection
)
;
rv
=
ReapplyCachedStyles
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ClearCachedStyles
(
)
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
HandleInlineSpellCheck
(
action
selection
GetAsDOMNode
(
mRangeItem
-
>
mStartContainer
)
mRangeItem
-
>
mStartOffset
GetAsDOMNode
(
rangeStartContainer
)
static_cast
<
int32_t
>
(
rangeStartOffset
)
GetAsDOMNode
(
rangeEndContainer
)
static_cast
<
int32_t
>
(
rangeEndOffset
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateBogusNodeIfNeeded
(
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mDidExplicitlySetInterline
)
{
CheckInterlinePosition
(
*
selection
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aInfo
&
&
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
if
(
info
-
>
action
=
=
EditAction
:
:
outputText
|
|
info
-
>
action
=
=
EditAction
:
:
undo
|
|
info
-
>
action
=
=
EditAction
:
:
redo
)
{
return
TextEditRules
:
:
WillDoAction
(
aSelection
aInfo
aCancel
aHandled
)
;
}
if
(
!
aSelection
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aSelection
-
>
RangeCount
(
)
NS_OK
)
;
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
0
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
range
-
>
GetStartContainer
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsModifiableNode
(
selStartNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selEndNode
=
range
-
>
GetEndContainer
(
)
;
if
(
selStartNode
!
=
selEndNode
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsModifiableNode
(
selEndNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsModifiableNode
(
range
-
>
GetCommonAncestor
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
}
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertText
:
case
EditAction
:
:
insertIMEText
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertText
(
info
-
>
action
aSelection
aCancel
aHandled
info
-
>
inString
info
-
>
outString
info
-
>
maxLength
)
;
case
EditAction
:
:
loadHTML
:
return
WillLoadHTML
(
aSelection
aCancel
)
;
case
EditAction
:
:
insertBreak
:
UndefineCaretBidiLevel
(
aSelection
)
;
return
WillInsertBreak
(
*
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
deleteSelection
:
return
WillDeleteSelection
(
aSelection
info
-
>
collapsedAction
info
-
>
stripWrappers
aCancel
aHandled
)
;
case
EditAction
:
:
makeList
:
return
WillMakeList
(
aSelection
info
-
>
blockType
info
-
>
entireList
info
-
>
bulletType
aCancel
aHandled
)
;
case
EditAction
:
:
indent
:
return
WillIndent
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
outdent
:
return
WillOutdent
(
*
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
setAbsolutePosition
:
return
WillAbsolutePosition
(
*
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
removeAbsolutePosition
:
return
WillRemoveAbsolutePosition
(
aSelection
aCancel
aHandled
)
;
case
EditAction
:
:
align
:
return
WillAlign
(
*
aSelection
*
info
-
>
alignType
aCancel
aHandled
)
;
case
EditAction
:
:
makeBasicBlock
:
return
WillMakeBasicBlock
(
*
aSelection
*
info
-
>
blockType
aCancel
aHandled
)
;
case
EditAction
:
:
removeList
:
return
WillRemoveList
(
aSelection
info
-
>
bOrdered
aCancel
aHandled
)
;
case
EditAction
:
:
makeDefListItem
:
return
WillMakeDefListItem
(
aSelection
info
-
>
blockType
info
-
>
entireList
aCancel
aHandled
)
;
case
EditAction
:
:
insertElement
:
WillInsert
(
*
aSelection
aCancel
)
;
return
NS_OK
;
case
EditAction
:
:
decreaseZIndex
:
return
WillRelativeChangeZIndex
(
aSelection
-
1
aCancel
aHandled
)
;
case
EditAction
:
:
increaseZIndex
:
return
WillRelativeChangeZIndex
(
aSelection
1
aCancel
aHandled
)
;
default
:
return
TextEditRules
:
:
WillDoAction
(
aSelection
aInfo
aCancel
aHandled
)
;
}
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
{
TextRulesInfo
*
info
=
static_cast
<
TextRulesInfo
*
>
(
aInfo
)
;
switch
(
info
-
>
action
)
{
case
EditAction
:
:
insertBreak
:
return
DidInsertBreak
(
aSelection
aResult
)
;
case
EditAction
:
:
deleteSelection
:
return
DidDeleteSelection
(
aSelection
info
-
>
collapsedAction
aResult
)
;
case
EditAction
:
:
makeBasicBlock
:
case
EditAction
:
:
indent
:
case
EditAction
:
:
outdent
:
case
EditAction
:
:
align
:
return
DidMakeBasicBlock
(
aSelection
aInfo
aResult
)
;
case
EditAction
:
:
setAbsolutePosition
:
{
nsresult
rv
=
DidMakeBasicBlock
(
aSelection
aInfo
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DidAbsolutePosition
(
)
;
}
default
:
return
TextEditRules
:
:
DidDoAction
(
aSelection
aInfo
aResult
)
;
}
}
NS_IMETHODIMP_
(
bool
)
HTMLEditRules
:
:
DocumentIsEmpty
(
)
{
return
!
!
mBogusNode
;
}
nsresult
HTMLEditRules
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aOL
=
false
;
*
aUL
=
false
;
*
aDL
=
false
;
bool
bNonList
=
false
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
curNode
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
dom
:
:
Element
*
parent
=
curNode
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
*
aUL
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
*
aOL
=
true
;
}
}
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
*
aDL
=
true
;
}
else
{
bNonList
=
true
;
}
}
if
(
(
*
aUL
+
*
aOL
+
*
aDL
+
bNonList
)
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
*
aLI
=
false
;
*
aDT
=
false
;
*
aDD
=
false
;
bool
bNonList
=
false
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
TouchContent
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
node
:
arrayOfNodes
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
bNonList
=
true
;
}
else
if
(
node
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
*
aLI
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
bool
bDT
bDD
;
GetDefinitionListItemTypes
(
node
-
>
AsElement
(
)
&
bDT
&
bDD
)
;
*
aDT
|
=
bDT
;
*
aDD
|
=
bDD
;
}
else
{
bNonList
=
true
;
}
}
if
(
*
aDT
+
*
aDD
+
bNonList
>
1
)
{
*
aMixed
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
MOZ_ASSERT
(
aMixed
&
&
aAlign
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
*
aMixed
=
false
;
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
NS_ENSURE_STATE
(
htmlEditor
-
>
GetSelection
(
)
)
;
OwningNonNull
<
Selection
>
selection
=
*
htmlEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
htmlEditor
-
>
GetRoot
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
Element
>
root
=
*
htmlEditor
-
>
GetRoot
(
)
;
int32_t
rootOffset
=
root
-
>
GetParentNode
(
)
?
root
-
>
GetParentNode
(
)
-
>
IndexOf
(
root
)
:
-
1
;
nsRange
*
firstRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
selection
-
>
Collapsed
(
)
|
|
atStartOfSelection
.
Container
(
)
-
>
GetAsText
(
)
)
{
nodeToExamine
=
atStartOfSelection
.
Container
(
)
;
}
else
if
(
atStartOfSelection
.
Container
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
static_cast
<
uint32_t
>
(
rootOffset
)
)
{
nodeToExamine
=
htmlEditor
-
>
GetNextEditableNode
(
atStartOfSelection
)
;
}
else
{
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
selection
arrayOfRanges
EditAction
:
:
align
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
align
TouchContent
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nodeToExamine
=
arrayOfNodes
.
SafeElementAt
(
0
)
;
}
NS_ENSURE_TRUE
(
nodeToExamine
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
Element
>
blockParent
=
htmlEditor
-
>
GetBlock
(
*
nodeToExamine
)
;
NS_ENSURE_TRUE
(
blockParent
NS_ERROR_FAILURE
)
;
if
(
htmlEditor
-
>
IsCSSEnabled
(
)
&
&
htmlEditor
-
>
mCSSEditUtils
-
>
IsCSSEditableProperty
(
blockParent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetCSSEquivalentToHTMLInlineStyleSet
(
blockParent
nullptr
nsGkAtoms
:
:
align
value
CSSEditUtils
:
:
eComputed
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
bool
isFirstNodeToExamine
=
true
;
for
(
;
nodeToExamine
;
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
)
{
if
(
!
isFirstNodeToExamine
&
&
nodeToExamine
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
NS_OK
;
}
if
(
htmlEditor
-
>
mCSSEditUtils
-
>
IsCSSEditableProperty
(
nodeToExamine
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetSpecifiedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
textAlign
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
NS_OK
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
NS_OK
;
}
}
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
nodeToExamine
)
)
{
nsAutoString
typeAttrVal
;
nodeToExamine
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
typeAttrVal
)
;
ToLowerCase
(
typeAttrVal
)
;
if
(
!
typeAttrVal
.
IsEmpty
(
)
)
{
if
(
typeAttrVal
.
EqualsLiteral
(
"
center
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eCenter
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
right
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eRight
;
}
else
if
(
typeAttrVal
.
EqualsLiteral
(
"
justify
"
)
)
{
*
aAlign
=
nsIHTMLEditor
:
:
eJustify
;
}
else
{
*
aAlign
=
nsIHTMLEditor
:
:
eLeft
;
}
return
NS_OK
;
}
}
isFirstNodeToExamine
=
false
;
}
return
NS_OK
;
}
static
nsAtom
&
MarginPropertyAtomForIndent
(
CSSEditUtils
&
aHTMLCSSUtils
nsINode
&
aNode
)
{
nsAutoString
direction
;
aHTMLCSSUtils
.
GetComputedProperty
(
aNode
*
nsGkAtoms
:
:
direction
direction
)
;
return
direction
.
EqualsLiteral
(
"
rtl
"
)
?
*
nsGkAtoms
:
:
marginRight
:
*
nsGkAtoms
:
:
marginLeft
;
}
nsresult
HTMLEditRules
:
:
GetIndentState
(
bool
*
aCanIndent
bool
*
aCanOutdent
)
{
NS_ENSURE_TRUE
(
aCanIndent
&
&
aCanOutdent
NS_ERROR_FAILURE
)
;
*
aCanIndent
=
true
;
*
aCanOutdent
=
false
;
NS_ENSURE_STATE
(
mHTMLEditor
&
&
mHTMLEditor
-
>
GetSelection
(
)
)
;
OwningNonNull
<
Selection
>
selection
=
*
mHTMLEditor
-
>
GetSelection
(
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromSelection
(
*
selection
EditAction
:
:
indent
arrayOfNodes
TouchContent
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
bool
useCSS
=
mHTMLEditor
-
>
IsCSSEnabled
(
)
;
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
GetAsDOMNode
(
curNode
)
)
)
{
*
aCanOutdent
=
true
;
break
;
}
else
if
(
useCSS
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
*
mHTMLEditor
-
>
mCSSEditUtils
curNode
)
;
nsAutoString
value
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
mCSSEditUtils
-
>
GetSpecifiedProperty
(
*
curNode
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
mCSSEditUtils
-
>
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
0
<
f
)
{
*
aCanOutdent
=
true
;
break
;
}
}
}
if
(
!
*
aCanOutdent
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIDOMNode
>
parent
tmp
root
=
do_QueryInterface
(
mHTMLEditor
-
>
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_NULL_POINTER
)
;
int32_t
selOffset
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
parent
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
parent
&
&
parent
!
=
root
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
parent
)
)
{
*
aCanOutdent
=
true
;
break
;
}
tmp
=
parent
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
}
rv
=
EditorBase
:
:
GetEndNodeAndOffset
(
selection
getter_AddRefs
(
parent
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
parent
&
&
parent
!
=
root
)
{
if
(
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
parent
)
)
{
*
aCanOutdent
=
true
;
break
;
}
tmp
=
parent
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
true
;
outFormat
.
Truncate
(
0
)
;
bool
bMixed
=
false
;
nsAutoString
formatStr
(
NS_LITERAL_STRING
(
"
x
"
)
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetParagraphFormatNodes
(
arrayOfNodes
TouchContent
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
curNode
=
arrayOfNodes
[
i
]
;
nsAutoString
format
;
if
(
IsBlockNode
(
curNode
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
rv
=
AppendInnerFormatNodes
(
arrayOfNodes
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
selNode
NS_ERROR_NULL_POINTER
)
;
arrayOfNodes
.
AppendElement
(
*
selNode
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIDOMElement
>
rootElem
=
do_QueryInterface
(
mHTMLEditor
-
>
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
rootElem
NS_ERROR_NULL_POINTER
)
;
for
(
auto
&
curNode
:
Reversed
(
arrayOfNodes
)
)
{
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
GetFormatString
(
GetAsDOMNode
(
curNode
)
format
)
;
}
else
if
(
IsBlockNode
(
curNode
)
)
{
continue
;
}
else
{
nsCOMPtr
<
nsIDOMNode
>
node
tmp
=
GetAsDOMNode
(
curNode
)
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
node
)
)
;
while
(
node
)
{
if
(
node
=
=
rootElem
)
{
format
.
Truncate
(
0
)
;
break
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
)
{
GetFormatString
(
node
format
)
;
break
;
}
tmp
=
node
;
tmp
-
>
GetParentNode
(
getter_AddRefs
(
node
)
)
;
}
}
if
(
formatStr
.
EqualsLiteral
(
"
x
"
)
)
{
formatStr
=
format
;
}
else
if
(
format
!
=
formatStr
)
{
bMixed
=
true
;
break
;
}
}
*
aMixed
=
bMixed
;
outFormat
=
formatStr
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
IsBlockNode
(
*
child
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
child
)
;
if
(
isBlock
&
&
!
isFormat
)
{
AppendInnerFormatNodes
(
aArray
child
)
;
}
else
if
(
isFormat
)
{
aArray
.
AppendElement
(
*
child
)
;
}
else
if
(
!
foundInline
)
{
foundInline
=
true
;
aArray
.
AppendElement
(
*
child
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetFormatString
(
nsIDOMNode
*
aNode
nsAString
&
outFormat
)
{
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
aNode
)
)
{
RefPtr
<
nsAtom
>
atom
=
EditorBase
:
:
GetTag
(
aNode
)
;
atom
-
>
ToString
(
outFormat
)
;
}
else
{
outFormat
.
Truncate
(
)
;
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
{
MOZ_ASSERT
(
aCancel
)
;
TextEditRules
:
:
WillInsert
(
aSelection
aCancel
)
;
NS_ENSURE_TRUE_VOID
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
!
aSelection
.
Collapsed
(
)
)
{
return
;
}
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNode
(
atStartOfSelection
)
;
if
(
priorNode
&
&
TextEditUtils
:
:
IsMozBR
(
priorNode
)
)
{
RefPtr
<
Element
>
block1
=
htmlEditor
-
>
GetBlock
(
*
atStartOfSelection
.
Container
(
)
)
;
RefPtr
<
Element
>
block2
=
htmlEditor
-
>
GetBlockNodeParent
(
priorNode
)
;
if
(
block1
&
&
block1
=
=
block2
)
{
EditorRawDOMPoint
point
(
priorNode
)
;
nsresult
rv
=
aSelection
.
Collapse
(
point
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
if
(
mDidDeleteSelection
&
&
(
mTheAction
=
=
EditAction
:
:
insertText
|
|
mTheAction
=
=
EditAction
:
:
insertIMEText
|
|
mTheAction
=
=
EditAction
:
:
deleteSelection
)
)
{
nsresult
rv
=
ReapplyCachedStyles
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
if
(
!
IsStyleCachePreservingAction
(
mTheAction
)
)
{
ClearCachedStyles
(
)
;
}
}
nsresult
HTMLEditRules
:
:
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
if
(
!
aSelection
-
>
Collapsed
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mHTMLEditor
-
>
GetDocument
(
)
;
NS_ENSURE_STATE
(
doc
)
;
nsresult
rv
=
CreateStyleForInsertText
(
*
aSelection
*
doc
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsRange
*
firstRange
=
aSelection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsert
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
(
!
EditorBase
:
:
IsTextNode
(
pointToInsert
.
Container
(
)
)
&
&
!
mHTMLEditor
-
>
CanContainTag
(
*
pointToInsert
.
Container
(
)
*
nsGkAtoms
:
:
textTagName
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aAction
=
=
EditAction
:
:
insertIMEText
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
int32_t
IMESelectionOffset
=
mHTMLEditor
-
>
GetIMESelectionStartOffsetIn
(
pointToInsert
.
Container
(
)
)
;
if
(
IMESelectionOffset
>
=
0
)
{
pointToInsert
.
Set
(
pointToInsert
.
Container
(
)
IMESelectionOffset
)
;
}
if
(
inString
-
>
IsEmpty
(
)
)
{
rv
=
mHTMLEditor
-
>
InsertTextImpl
(
*
doc
*
inString
pointToInsert
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
WSRunObject
wsObj
(
mHTMLEditor
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
rv
=
wsObj
.
InsertText
(
*
doc
*
inString
pointToInsert
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
EditorDOMPoint
currentPoint
(
pointToInsert
)
;
bool
isPRE
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
IsPreformatted
(
GetAsDOMNode
(
pointToInsert
.
Container
(
)
)
&
isPRE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoLockListener
lockit
(
&
mListenerEnabled
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
tString
(
*
inString
)
;
const
char16_t
*
unicodeBuf
=
tString
.
get
(
)
;
int32_t
pos
=
0
;
NS_NAMED_LITERAL_STRING
(
newlineStr
LFSTR
)
;
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTrackDOMPoint
tracker
(
mHTMLEditor
-
>
mRangeUpdater
&
pointToInsert
)
;
if
(
isPRE
|
|
IsPlaintextEditor
(
)
)
{
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindChar
(
nsCRT
:
:
LF
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
if
(
subStr
.
Equals
(
newlineStr
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsINode
>
curNode
=
currentPoint
.
Container
(
)
;
int32_t
curOffset
=
currentPoint
.
Offset
(
)
;
nsCOMPtr
<
Element
>
br
=
mHTMLEditor
-
>
CreateBRImpl
(
address_of
(
curNode
)
&
curOffset
nsIEditor
:
:
eNone
)
;
NS_ENSURE_STATE
(
br
)
;
pos
+
+
;
if
(
br
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
br
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
Set
(
curNode
curNode
-
>
Length
(
)
)
;
}
currentPoint
.
Set
(
curNode
curOffset
)
;
MOZ_ASSERT
(
currentPoint
=
=
pointToInsert
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
mHTMLEditor
-
>
InsertTextImpl
(
*
doc
subStr
currentPoint
.
AsRaw
(
)
&
pointAfterInsertedString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
else
{
NS_NAMED_LITERAL_STRING
(
tabStr
"
\
t
"
)
;
NS_NAMED_LITERAL_STRING
(
spacesStr
"
"
)
;
char
specialChars
[
]
=
{
TAB
nsCRT
:
:
LF
0
}
;
while
(
unicodeBuf
&
&
pos
!
=
-
1
&
&
pos
<
static_cast
<
int32_t
>
(
inString
-
>
Length
(
)
)
)
{
int32_t
oldPos
=
pos
;
int32_t
subStrLen
;
pos
=
tString
.
FindCharInSet
(
specialChars
oldPos
)
;
if
(
pos
!
=
-
1
)
{
subStrLen
=
pos
-
oldPos
;
if
(
!
subStrLen
)
{
subStrLen
=
1
;
}
}
else
{
subStrLen
=
tString
.
Length
(
)
-
oldPos
;
pos
=
tString
.
Length
(
)
;
}
nsDependentSubstring
subStr
(
tString
oldPos
subStrLen
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObj
(
mHTMLEditor
currentPoint
.
Container
(
)
currentPoint
.
Offset
(
)
)
;
if
(
subStr
.
Equals
(
tabStr
)
)
{
EditorRawDOMPoint
pointAfterInsertedSpaces
;
rv
=
wsObj
.
InsertText
(
*
doc
spacesStr
currentPoint
.
AsRaw
(
)
&
pointAfterInsertedSpaces
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
pos
+
+
;
currentPoint
=
pointAfterInsertedSpaces
;
pointToInsert
=
pointAfterInsertedSpaces
;
}
else
if
(
subStr
.
Equals
(
newlineStr
)
)
{
nsCOMPtr
<
nsINode
>
curNode
=
currentPoint
.
Container
(
)
;
int32_t
curOffset
=
currentPoint
.
Offset
(
)
;
nsCOMPtr
<
Element
>
br
=
wsObj
.
InsertBreak
(
address_of
(
curNode
)
&
curOffset
nsIEditor
:
:
eNone
)
;
NS_ENSURE_TRUE
(
br
NS_ERROR_FAILURE
)
;
pos
+
+
;
if
(
br
-
>
GetNextSibling
(
)
)
{
pointToInsert
.
Set
(
br
-
>
GetNextSibling
(
)
)
;
}
else
{
pointToInsert
.
Set
(
curNode
curNode
-
>
Length
(
)
)
;
}
currentPoint
.
Set
(
curNode
curOffset
)
;
MOZ_ASSERT
(
currentPoint
=
=
pointToInsert
)
;
}
else
{
EditorRawDOMPoint
pointAfterInsertedString
;
rv
=
wsObj
.
InsertText
(
*
doc
subStr
currentPoint
.
AsRaw
(
)
&
pointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
currentPoint
=
pointAfterInsertedString
;
pointToInsert
=
pointAfterInsertedString
;
}
}
}
}
aSelection
-
>
SetInterlinePosition
(
false
)
;
if
(
currentPoint
.
IsSet
(
)
)
{
ErrorResult
error
;
aSelection
-
>
Collapse
(
currentPoint
.
AsRaw
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
collapse
at
current
point
"
)
;
error
.
SuppressException
(
)
;
}
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
new
nsRange
(
pointToInsert
.
Container
(
)
)
;
}
if
(
currentPoint
.
IsSet
(
)
)
{
rv
=
mDocChangeRange
-
>
SetStartAndEnd
(
pointToInsert
.
AsRaw
(
)
currentPoint
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
rv
=
mDocChangeRange
-
>
CollapseTo
(
pointToInsert
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillLoadHTML
(
Selection
*
aSelection
bool
*
aCancel
)
{
NS_ENSURE_TRUE
(
aSelection
&
&
aCancel
NS_ERROR_NULL_POINTER
)
;
*
aCancel
=
false
;
if
(
mBogusNode
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mHTMLEditor
-
>
DeleteNode
(
mBogusNode
)
;
mBogusNode
=
nullptr
;
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
CanContainParagraph
(
Element
&
aElement
)
const
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
false
;
}
if
(
mHTMLEditor
-
>
CanContainTag
(
aElement
*
nsGkAtoms
:
:
p
)
)
{
return
true
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
table
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
)
)
{
return
true
;
}
return
false
;
}
nsresult
HTMLEditRules
:
:
WillInsertBreak
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
!
aSelection
.
Collapsed
(
)
)
{
nsresult
rv
=
htmlEditor
-
>
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
WillInsert
(
aSelection
aCancel
)
;
*
aCancel
=
false
;
if
(
IsMailEditor
(
)
)
{
nsresult
rv
=
SplitMailCites
(
&
aSelection
aHandled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aHandled
)
{
return
NS_OK
;
}
}
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
if
(
!
htmlEditor
-
>
IsModifiableNode
(
atStartOfSelection
.
Container
(
)
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
host
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
blockParent
=
HTMLEditor
:
:
GetBlock
(
*
atStartOfSelection
.
Container
(
)
host
)
;
ParagraphSeparator
separator
=
htmlEditor
-
>
GetDefaultParagraphSeparator
(
)
;
bool
insertBRElement
;
if
(
!
blockParent
)
{
insertBRElement
=
true
;
}
else
if
(
host
=
=
blockParent
)
{
insertBRElement
=
separator
=
=
ParagraphSeparator
:
:
br
|
|
!
CanContainParagraph
(
*
host
)
;
}
else
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
blockParent
)
)
{
insertBRElement
=
false
;
}
else
{
insertBRElement
=
true
;
for
(
Element
*
blockAncestor
=
blockParent
;
blockAncestor
&
&
insertBRElement
;
blockAncestor
=
HTMLEditor
:
:
GetBlockNodeParent
(
blockAncestor
host
)
)
{
insertBRElement
=
!
CanContainParagraph
(
*
blockAncestor
)
;
}
}
if
(
insertBRElement
)
{
nsresult
rv
=
StandardBreakImpl
(
*
atStartOfSelection
.
Container
(
)
atStartOfSelection
.
Offset
(
)
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
host
=
=
blockParent
&
&
separator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
separator
=
=
ParagraphSeparator
:
:
div
|
|
separator
=
=
ParagraphSeparator
:
:
p
)
;
nsresult
rv
=
MakeBasicBlock
(
aSelection
ParagraphSeparatorElement
(
separator
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditRules
:
:
MakeBasicBlock
(
)
failed
"
)
;
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
atStartOfSelection
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
blockParent
=
mHTMLEditor
-
>
GetBlock
(
*
atStartOfSelection
.
Container
(
)
host
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
blockParent
=
=
host
)
)
{
rv
=
StandardBreakImpl
(
*
atStartOfSelection
.
Container
(
)
atStartOfSelection
.
Offset
(
)
aSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aHandled
=
true
;
return
NS_OK
;
}
}
bool
isEmpty
;
IsEmptyBlock
(
*
blockParent
&
isEmpty
)
;
if
(
isEmpty
)
{
nsCOMPtr
<
Element
>
br
=
htmlEditor
-
>
CreateBR
(
blockParent
blockParent
-
>
Length
(
)
)
;
NS_ENSURE_STATE
(
br
)
;
}
nsCOMPtr
<
Element
>
listItem
=
IsInListItem
(
blockParent
)
;
if
(
listItem
&
&
listItem
!
=
host
)
{
ReturnInListItem
(
aSelection
*
listItem
*
atStartOfSelection
.
Container
(
)
atStartOfSelection
.
Offset
(
)
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
blockParent
)
)
{
ReturnInHeader
(
aSelection
*
blockParent
*
atStartOfSelection
.
Container
(
)
atStartOfSelection
.
Offset
(
)
)
;
*
aHandled
=
true
;
return
NS_OK
;
}
if
(
(
separator
=
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
separator
!
=
ParagraphSeparator
:
:
br
&
&
blockParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
EditActionResult
result
=
ReturnInParagraph
(
aSelection
*
blockParent
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
*
aHandled
=
result
.
Handled
(
)
;
*
aCancel
=
result
.
Canceled
(
)
;
}
if
(
!
(
*
aHandled
)
)
{
*
aHandled
=
true
;
return
StandardBreakImpl
(
*
atStartOfSelection
.
Container
(
)
atStartOfSelection
.
Offset
(
)
aSelection
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
StandardBreakImpl
(
nsINode
&
aNode
int32_t
aOffset
Selection
&
aSelection
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
brNode
;
bool
bAfterBlock
=
false
;
bool
bBeforeBlock
=
false
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
if
(
IsPlaintextEditor
(
)
)
{
brNode
=
htmlEditor
-
>
CreateBR
(
node
aOffset
)
;
NS_ENSURE_STATE
(
brNode
)
;
}
else
{
WSRunObject
wsObj
(
htmlEditor
node
aOffset
)
;
int32_t
visOffset
=
0
;
WSType
wsType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
PriorVisibleNode
(
node
aOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
bAfterBlock
=
true
;
}
wsObj
.
NextVisibleNode
(
node
aOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
&
WSType
:
:
block
)
{
bBeforeBlock
=
true
;
}
nsCOMPtr
<
nsIDOMNode
>
linkDOMNode
;
if
(
htmlEditor
-
>
IsInLink
(
GetAsDOMNode
(
node
)
address_of
(
linkDOMNode
)
)
)
{
nsCOMPtr
<
Element
>
linkNode
=
do_QueryInterface
(
linkDOMNode
)
;
NS_ENSURE_STATE
(
linkNode
|
|
!
linkDOMNode
)
;
nsCOMPtr
<
nsINode
>
linkParent
=
linkNode
-
>
GetParentNode
(
)
;
aOffset
=
htmlEditor
-
>
SplitNodeDeep
(
*
linkNode
*
node
-
>
AsContent
(
)
aOffset
HTMLEditor
:
:
EmptyContainers
:
:
no
)
;
NS_ENSURE_STATE
(
aOffset
!
=
-
1
)
;
node
=
linkParent
;
}
brNode
=
wsObj
.
InsertBreak
(
address_of
(
node
)
&
aOffset
nsIEditor
:
:
eNone
)
;
NS_ENSURE_TRUE
(
brNode
NS_ERROR_FAILURE
)
;
}
node
=
brNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
if
(
bAfterBlock
&
&
bBeforeBlock
)
{
aSelection
.
SetInterlinePosition
(
true
)
;
EditorRawDOMPoint
point
(
brNode
)
;
nsresult
rv
=
aSelection
.
Collapse
(
point
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
int32_t
offset
=
node
-
>
IndexOf
(
brNode
)
;
WSRunObject
wsObj
(
htmlEditor
node
offset
+
1
)
;
nsCOMPtr
<
nsINode
>
secondBR
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
node
offset
+
1
address_of
(
secondBR
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
nsCOMPtr
<
nsINode
>
brParent
=
secondBR
-
>
GetParentNode
(
)
;
int32_t
brOffset
=
brParent
?
brParent
-
>
IndexOf
(
secondBR
)
:
-
1
;
if
(
brParent
!
=
node
|
|
brOffset
!
=
offset
+
1
)
{
nsresult
rv
=
htmlEditor
-
>
MoveNode
(
secondBR
-
>
AsContent
(
)
node
offset
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
nsCOMPtr
<
nsIContent
>
siblingNode
=
brNode
-
>
GetNextSibling
(
)
;
if
(
siblingNode
&
&
IsBlockNode
(
*
siblingNode
)
)
{
aSelection
.
SetInterlinePosition
(
false
)
;
}
else
{
aSelection
.
SetInterlinePosition
(
true
)
;
}
nsresult
rv
=
aSelection
.
Collapse
(
node
offset
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
{
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SplitMailCites
(
Selection
*
aSelection
bool
*
aHandled
)
{
NS_ENSURE_TRUE
(
aSelection
&
&
aHandled
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
leftCite
rightCite
;
nsCOMPtr
<
nsINode
>
selNode
;
nsCOMPtr
<
Element
>
citeNode
;
int32_t
selOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
citeNode
=
GetTopEnclosingMailCite
(
*
selNode
)
;
if
(
citeNode
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObj
(
mHTMLEditor
selNode
selOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
selNode
selOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
visNode
!
=
citeNode
&
&
citeNode
-
>
Contains
(
visNode
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
selNode
=
mHTMLEditor
-
>
GetNodeLocation
(
visNode
&
selOffset
)
;
+
+
selOffset
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
NS_ENSURE_STATE
(
selNode
-
>
IsContent
(
)
)
;
int32_t
newOffset
=
mHTMLEditor
-
>
SplitNodeDeep
(
*
citeNode
*
selNode
-
>
AsContent
(
)
selOffset
HTMLEditor
:
:
EmptyContainers
:
:
no
getter_AddRefs
(
leftCite
)
getter_AddRefs
(
rightCite
)
)
;
NS_ENSURE_STATE
(
newOffset
!
=
-
1
)
;
if
(
leftCite
&
&
leftCite
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
leftCite
-
>
GetPrimaryFrame
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
nsCOMPtr
<
nsINode
>
lastChild
=
leftCite
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
nsCOMPtr
<
Element
>
invisBR
=
mHTMLEditor
-
>
CreateBR
(
leftCite
leftCite
-
>
Length
(
)
)
;
}
}
selNode
=
citeNode
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
brNode
=
mHTMLEditor
-
>
CreateBR
(
selNode
newOffset
)
;
NS_ENSURE_STATE
(
brNode
)
;
aSelection
-
>
SetInterlinePosition
(
true
)
;
rv
=
aSelection
-
>
Collapse
(
selNode
newOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsInlineNode
(
*
citeNode
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObj
(
mHTMLEditor
selNode
newOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
PriorVisibleNode
(
selNode
newOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObjAfterBR
(
mHTMLEditor
selNode
newOffset
+
1
)
;
wsObjAfterBR
.
NextVisibleNode
(
selNode
newOffset
+
1
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
normalWS
|
|
wsType
=
=
WSType
:
:
text
|
|
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
thisBlock
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
brNode
=
mHTMLEditor
-
>
CreateBR
(
selNode
newOffset
)
;
NS_ENSURE_STATE
(
brNode
)
;
}
}
}
bool
bEmptyCite
=
false
;
if
(
leftCite
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
leftCite
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
leftCite
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
rightCite
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
rightCite
&
bEmptyCite
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bEmptyCite
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
rightCite
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aHandled
=
true
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
nsIEditor
:
:
EStripWrappers
aStripWrappers
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
false
;
mDidDeleteSelection
=
true
;
if
(
mBogusNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMElement
>
cell
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteTableCellContents
(
)
;
*
aHandled
=
true
;
return
rv
;
}
cell
=
nullptr
;
bool
bCollapsed
=
aSelection
-
>
Collapsed
(
)
;
bool
join
=
false
;
bool
origCollapsed
=
bCollapsed
;
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
startNode
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
if
(
bCollapsed
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
host
=
mHTMLEditor
-
>
GetActiveEditingHost
(
)
;
NS_ENSURE_TRUE
(
host
NS_ERROR_FAILURE
)
;
rv
=
CheckForEmptyBlock
(
startNode
host
aSelection
aAction
aHandled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aHandled
)
{
return
NS_OK
;
}
rv
=
CheckBidiLevelForDeletion
(
aSelection
GetAsDOMNode
(
startNode
)
startOffset
aAction
aCancel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aCancel
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
ExtendSelectionForDelete
(
aSelection
&
aAction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aAction
=
=
nsIEditor
:
:
eNone
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
)
;
startNode
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
startOffset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
bCollapsed
=
aSelection
-
>
Collapsed
(
)
;
}
if
(
bCollapsed
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObj
(
mHTMLEditor
startNode
startOffset
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
;
WSType
wsType
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
NextVisibleNode
(
startNode
startOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
else
{
wsObj
.
PriorVisibleNode
(
startNode
startOffset
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
}
if
(
!
visNode
)
{
*
aCancel
=
true
;
return
rv
;
}
if
(
wsType
=
=
WSType
:
:
normalWS
)
{
*
aHandled
=
true
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
rv
=
wsObj
.
DeleteWSForward
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
wsObj
.
DeleteWSBackward
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
InsertBRIfNeeded
(
aSelection
)
;
}
if
(
wsType
=
=
WSType
:
:
text
)
{
OwningNonNull
<
Text
>
nodeAsText
=
*
visNode
-
>
GetAsText
(
)
;
int32_t
so
=
visOffset
;
int32_t
eo
=
visOffset
+
1
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
!
so
)
{
return
NS_ERROR_UNEXPECTED
;
}
so
-
-
;
eo
-
-
;
if
(
so
>
0
)
{
const
nsTextFragment
*
text
=
nodeAsText
-
>
GetText
(
)
;
if
(
NS_IS_LOW_SURROGATE
(
text
-
>
CharAt
(
so
)
)
&
&
NS_IS_HIGH_SURROGATE
(
text
-
>
CharAt
(
so
-
1
)
)
)
{
so
-
-
;
}
}
}
else
{
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
NS_ASSERTION
(
range
-
>
GetStartContainer
(
)
=
=
visNode
"
selection
start
not
in
visNode
"
)
;
NS_ASSERTION
(
range
-
>
GetEndContainer
(
)
=
=
visNode
"
selection
end
not
in
visNode
"
)
;
so
=
range
-
>
StartOffset
(
)
;
eo
=
range
-
>
EndOffset
(
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
visNode
)
&
so
address_of
(
visNode
)
&
eo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
*
aHandled
=
true
;
rv
=
mHTMLEditor
-
>
DeleteText
(
nodeAsText
std
:
:
min
(
so
eo
)
DeprecatedAbs
(
eo
-
so
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
DeleteNodeIfCollapsedText
(
nodeAsText
)
;
rv
=
InsertBRIfNeeded
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDidRangedDelete
=
true
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
(
!
mHTMLEditor
|
|
!
mHTMLEditor
-
>
IsVisibleBRElement
(
visNode
)
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
visNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WillDeleteSelection
(
aSelection
aAction
aStripWrappers
aCancel
aHandled
)
;
}
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
&
&
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
bool
moveOnly
=
true
;
selNode
=
visNode
-
>
GetParentNode
(
)
;
selOffset
=
selNode
?
selNode
-
>
IndexOf
(
visNode
)
:
-
1
;
bool
interLineIsRight
;
rv
=
aSelection
-
>
GetInterlinePosition
(
&
interLineIsRight
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startNode
=
=
selNode
&
&
startOffset
-
1
=
=
selOffset
&
&
!
interLineIsRight
)
{
moveOnly
=
false
;
}
if
(
moveOnly
)
{
+
+
selOffset
;
aSelection
-
>
Collapse
(
selNode
selOffset
)
;
aSelection
-
>
SetInterlinePosition
(
false
)
;
mDidExplicitlySetInterline
=
true
;
*
aHandled
=
true
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
wsObj
.
NextVisibleNode
(
startNode
startOffset
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
if
(
otherWSType
=
=
WSType
:
:
br
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContent
>
otherContent
(
do_QueryInterface
(
otherNode
)
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
mHTMLEditor
otherContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
otherNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
NS_ENSURE_STATE
(
visNode
-
>
IsContent
(
)
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteNode
(
mHTMLEditor
visNode
-
>
AsContent
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContent
>
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
visNode
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
visNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
nsCOMPtr
<
nsINode
>
stepbrother
;
if
(
sibling
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
stepbrother
=
mHTMLEditor
-
>
GetNextHTMLSibling
(
sibling
)
;
}
if
(
startNode
=
=
stepbrother
&
&
startNode
-
>
GetAsText
(
)
&
&
sibling
-
>
GetAsText
(
)
)
{
EditorDOMPoint
pt
=
JoinNodesSmart
(
*
sibling
*
startNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
-
>
Collapse
(
pt
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
InsertBRIfNeeded
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
otherBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
bool
bDeletedBR
=
false
;
WSType
otherWSType
;
nsCOMPtr
<
nsINode
>
otherNode
;
int32_t
otherOffset
;
if
(
aAction
=
=
nsIEditor
:
:
eNext
)
{
wsObj
.
PriorVisibleNode
(
startNode
startOffset
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
else
{
wsObj
.
NextVisibleNode
(
startNode
startOffset
address_of
(
otherNode
)
&
otherOffset
&
otherWSType
)
;
}
nsCOMPtr
<
nsIContent
>
leafNode
;
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
leafNode
=
mHTMLEditor
-
>
GetLastEditableLeaf
(
*
visNode
)
;
leftNode
=
leafNode
;
rightNode
=
startNode
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
leafNode
=
mHTMLEditor
-
>
GetFirstEditableLeaf
(
*
visNode
)
;
leftNode
=
startNode
;
rightNode
=
leafNode
;
}
if
(
otherNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
otherNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
bDeletedBR
=
true
;
}
if
(
leftNode
&
&
rightNode
&
&
InDifferentTableElements
(
leftNode
rightNode
)
)
{
return
NS_OK
;
}
if
(
bDeletedBR
)
{
NS_ENSURE_STATE
(
leafNode
)
;
EditorDOMPoint
newSel
=
GetGoodSelPointForNode
(
*
leafNode
aAction
)
;
if
(
NS_WARN_IF
(
!
newSel
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aSelection
-
>
Collapse
(
newSel
.
AsRaw
(
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTrackDOMPoint
tracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
NS_ENSURE_STATE
(
leftNode
&
&
leftNode
-
>
IsContent
(
)
&
&
rightNode
&
&
rightNode
-
>
IsContent
(
)
)
;
EditActionResult
ret
=
TryToJoinBlocks
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
|
=
ret
.
Handled
(
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
if
(
!
*
aHandled
&
&
!
*
aCancel
&
&
leafNode
!
=
startNode
)
{
int32_t
offset
=
aAction
=
=
nsIEditor
:
:
ePrevious
?
static_cast
<
int32_t
>
(
leafNode
-
>
Length
(
)
)
:
0
;
aSelection
-
>
Collapse
(
leafNode
offset
)
;
return
WillDeleteSelection
(
aSelection
aAction
aStripWrappers
aCancel
aHandled
)
;
}
aSelection
-
>
Collapse
(
selPointNode
selPointOffset
)
;
return
NS_OK
;
}
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
visNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
leftNode
rightNode
;
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
leftNode
=
mHTMLEditor
-
>
GetPreviousEditableHTMLNode
(
*
visNode
)
;
rightNode
=
startNode
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rightNode
=
mHTMLEditor
-
>
GetNextEditableHTMLNode
(
*
visNode
)
;
leftNode
=
startNode
;
}
if
(
!
leftNode
|
|
!
rightNode
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
if
(
InDifferentTableElements
(
leftNode
rightNode
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selPointNode
=
startNode
;
int32_t
selPointOffset
=
startOffset
;
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTrackDOMPoint
tracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
selPointNode
)
&
selPointOffset
)
;
NS_ENSURE_STATE
(
leftNode
-
>
IsContent
(
)
&
&
rightNode
-
>
IsContent
(
)
)
;
EditActionResult
ret
=
TryToJoinBlocks
(
*
leftNode
-
>
AsContent
(
)
*
rightNode
-
>
AsContent
(
)
)
;
*
aHandled
=
true
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
aSelection
-
>
Collapse
(
selPointNode
selPointOffset
)
;
return
NS_OK
;
}
}
rv
=
ExpandSelectionForDeletion
(
*
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDidRangedDelete
=
true
;
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
)
;
startNode
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
startOffset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
EndOffset
(
)
;
NS_ENSURE_TRUE
(
endNode
NS_ERROR_FAILURE
)
;
if
(
!
IsPlaintextEditor
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoTrackDOMPoint
startTracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
*
aHandled
=
true
;
if
(
endNode
=
=
startNode
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteSelectionImpl
(
aAction
aStripWrappers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
Element
>
startCiteNode
=
GetTopEnclosingMailCite
(
*
startNode
)
;
nsCOMPtr
<
Element
>
endCiteNode
=
GetTopEnclosingMailCite
(
*
endNode
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aAction
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aAction
=
nsIEditor
:
:
ePrevious
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
leftParent
=
mHTMLEditor
-
>
GetBlock
(
*
startNode
)
;
nsCOMPtr
<
Element
>
rightParent
=
mHTMLEditor
-
>
GetBlock
(
*
endNode
)
;
if
(
leftParent
&
&
leftParent
=
=
rightParent
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
DeleteSelectionImpl
(
aAction
aStripWrappers
)
;
}
else
{
NS_ENSURE_STATE
(
leftParent
&
&
rightParent
)
;
nsCOMPtr
<
nsINode
>
leftBlockParent
=
leftParent
-
>
GetParentNode
(
)
;
nsCOMPtr
<
nsINode
>
rightBlockParent
=
rightParent
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
leftBlockParent
=
=
rightBlockParent
&
&
mHTMLEditor
-
>
NodesSameType
(
GetAsDOMNode
(
leftParent
)
GetAsDOMNode
(
rightParent
)
)
&
&
(
leftParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
leftParent
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
leftParent
)
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteSelectionImpl
(
aAction
aStripWrappers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorDOMPoint
pt
=
mHTMLEditor
-
>
JoinNodeDeep
(
*
leftParent
*
rightParent
)
;
if
(
NS_WARN_IF
(
!
pt
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
-
>
Collapse
(
pt
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
join
=
true
;
AutoRangeArray
arrayOfRanges
(
aSelection
)
;
for
(
auto
&
range
:
arrayOfRanges
.
mRanges
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
TrivialFunctor
functor
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
iter
.
AppendList
(
functor
arrayOfNodes
)
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
j
=
0
;
j
<
listCount
;
j
+
+
)
{
nsCOMPtr
<
nsINode
>
somenode
=
do_QueryInterface
(
arrayOfNodes
[
0
]
)
;
NS_ENSURE_STATE
(
somenode
)
;
DeleteNonTableElements
(
somenode
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
if
(
join
&
&
origCollapsed
)
{
if
(
!
somenode
-
>
IsContent
(
)
)
{
join
=
false
;
continue
;
}
nsCOMPtr
<
nsIContent
>
content
=
somenode
-
>
AsContent
(
)
;
if
(
content
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
IsVisTextNode
(
content
&
join
true
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
join
=
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
mHTMLEditor
-
>
IsVisibleBRElement
(
somenode
)
;
}
}
}
}
if
(
startNode
-
>
GetAsText
(
)
&
&
startNode
-
>
Length
(
)
>
static_cast
<
uint32_t
>
(
startOffset
)
)
{
OwningNonNull
<
nsGenericDOMDataNode
>
dataNode
=
*
static_cast
<
nsGenericDOMDataNode
*
>
(
startNode
.
get
(
)
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteText
(
dataNode
startOffset
startNode
-
>
Length
(
)
-
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
endNode
-
>
GetAsText
(
)
&
&
endOffset
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
OwningNonNull
<
nsGenericDOMDataNode
>
dataNode
=
*
static_cast
<
nsGenericDOMDataNode
*
>
(
endNode
.
get
(
)
)
;
rv
=
mHTMLEditor
-
>
DeleteText
(
dataNode
0
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
join
)
{
EditActionResult
ret
=
TryToJoinBlocks
(
*
leftParent
*
rightParent
)
;
MOZ_ASSERT
(
*
aHandled
)
;
*
aCancel
|
=
ret
.
Canceled
(
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
.
Rv
(
)
;
}
}
}
}
}
{
AutoTrackDOMPoint
startTracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
startNode
)
&
startOffset
)
;
AutoTrackDOMPoint
endTracker
(
mHTMLEditor
-
>
mRangeUpdater
address_of
(
endNode
)
&
endOffset
)
;
DeleteNodeIfCollapsedText
(
*
startNode
)
;
DeleteNodeIfCollapsedText
(
*
endNode
)
;
}
if
(
aAction
=
=
(
join
?
nsIEditor
:
:
eNext
:
nsIEditor
:
:
ePrevious
)
)
{
rv
=
aSelection
-
>
Collapse
(
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
aSelection
-
>
Collapse
(
startNode
startOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
DeleteNodeIfCollapsedText
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
GetAsText
(
)
)
{
return
;
}
bool
empty
;
nsresult
rv
=
mHTMLEditor
-
>
IsVisTextNode
(
aNode
.
AsContent
(
)
&
empty
false
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
empty
)
{
mHTMLEditor
-
>
DeleteNode
(
&
aNode
)
;
}
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeeded
(
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
node
;
int32_t
offset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
node
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
!
IsBlockNode
(
*
node
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
WSRunObject
wsObj
(
mHTMLEditor
node
offset
)
;
if
(
(
(
wsObj
.
mStartReason
&
WSType
:
:
block
)
|
|
(
wsObj
.
mStartReason
&
WSType
:
:
br
)
)
&
&
(
wsObj
.
mEndReason
&
WSType
:
:
block
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
mHTMLEditor
-
>
CanContainTag
(
*
node
*
nsGkAtoms
:
:
br
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
br
=
mHTMLEditor
-
>
CreateBR
(
node
offset
nsIEditor
:
:
ePrevious
)
;
return
br
?
NS_OK
:
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetGoodSelPointForNode
(
nsINode
&
aNode
nsIEditor
:
:
EDirection
aAction
)
{
MOZ_ASSERT
(
aAction
=
=
nsIEditor
:
:
eNext
|
|
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
;
bool
isPreviousAction
=
(
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
aNode
.
GetAsText
(
)
|
|
mHTMLEditor
-
>
IsContainer
(
&
aNode
)
|
|
NS_WARN_IF
(
!
aNode
.
GetParentNode
(
)
)
)
{
return
EditorDOMPoint
(
&
aNode
isPreviousAction
?
aNode
.
Length
(
)
:
0
)
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
EditorDOMPoint
ret
(
&
aNode
)
;
if
(
(
!
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
mHTMLEditor
-
>
IsVisibleBRElement
(
&
aNode
)
)
&
&
isPreviousAction
)
{
ret
.
AdvanceOffset
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
TryToJoinBlocks
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
leftBlock
=
htmlEditor
-
>
GetBlock
(
aLeftNode
)
;
nsCOMPtr
<
Element
>
rightBlock
=
htmlEditor
-
>
GetBlock
(
aRightNode
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
|
|
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
if
(
NS_WARN_IF
(
leftBlock
=
=
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
leftBlock
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
rightBlock
)
)
{
return
EditActionCanceled
(
)
;
}
if
(
leftBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
leftBlock
=
htmlEditor
-
>
GetBlockNodeParent
(
leftBlock
)
;
if
(
NS_WARN_IF
(
!
leftBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
rightBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
rightBlock
=
htmlEditor
-
>
GetBlockNodeParent
(
rightBlock
)
;
if
(
NS_WARN_IF
(
!
rightBlock
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
leftBlock
=
=
rightBlock
)
{
return
EditActionIgnored
(
)
;
}
if
(
HTMLEditUtils
:
:
IsList
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
&
&
rightBlock
-
>
GetParentNode
(
)
=
=
leftBlock
)
{
return
EditActionHandled
(
)
;
}
bool
mergeLists
=
false
;
nsAtom
*
existingList
=
nsGkAtoms
:
:
_empty
;
EditorDOMPoint
atChildInBlock
;
nsCOMPtr
<
Element
>
leftList
rightList
;
if
(
HTMLEditUtils
:
:
IsListItem
(
leftBlock
)
&
&
HTMLEditUtils
:
:
IsListItem
(
rightBlock
)
)
{
leftList
=
leftBlock
-
>
GetParentElement
(
)
;
rightList
=
rightBlock
-
>
GetParentElement
(
)
;
if
(
leftList
&
&
rightList
&
&
leftList
!
=
rightList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftList
*
rightBlock
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightList
*
leftBlock
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
leftBlock
=
leftList
;
rightBlock
=
rightList
;
mergeLists
=
true
;
existingList
=
leftList
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
htmlEditor
)
;
EditorDOMPoint
atRightBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
leftBlock
*
rightBlock
&
atRightBlockChild
)
)
{
DebugOnly
<
bool
>
advanced
=
atRightBlockChild
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
child
of
rightBlock
"
"
leftBlock
is
a
descendant
of
the
child
"
)
;
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
htmlEditor
WSRunObject
:
:
kBlockEnd
leftBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
htmlEditor
-
>
mRangeUpdater
&
atRightBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
htmlEditor
WSRunObject
:
:
kAfterBlock
atRightBlockChild
.
Container
(
)
atRightBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_ASSERT
(
rightBlock
=
=
atRightBlockChild
.
Container
(
)
)
;
if
(
atRightBlockChild
.
Container
(
)
-
>
IsElement
(
)
)
{
rightBlock
=
atRightBlockChild
.
Container
(
)
-
>
AsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
atRightBlockChild
.
Container
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
rightBlock
=
atRightBlockChild
.
Container
(
)
-
>
GetParentElement
(
)
;
}
}
nsCOMPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
NS_WARN_IF
(
mergeLists
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
EditActionResult
retMoveBlock
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
atRightBlockChild
.
Offset
(
)
)
;
if
(
retMoveBlock
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
atRightBlockChild
.
Clear
(
)
;
}
if
(
brNode
&
&
NS_SUCCEEDED
(
htmlEditor
-
>
DeleteNode
(
brNode
)
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
EditorDOMPoint
leftBlockChild
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rightBlock
*
leftBlock
&
leftBlockChild
)
)
{
nsresult
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
htmlEditor
WSRunObject
:
:
kBlockStart
rightBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
{
AutoTrackDOMPoint
tracker
(
htmlEditor
-
>
mRangeUpdater
&
leftBlockChild
)
;
rv
=
WSRunObject
:
:
ScrubBlockBoundary
(
htmlEditor
WSRunObject
:
:
kBeforeBlock
leftBlock
leftBlockChild
.
Offset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
leftBlock
=
=
leftBlockChild
.
Container
(
)
)
;
if
(
leftBlockChild
.
Container
(
)
-
>
IsElement
(
)
)
{
leftBlock
=
leftBlockChild
.
Container
(
)
-
>
AsElement
(
)
;
}
else
{
if
(
NS_WARN_IF
(
!
leftBlockChild
.
Container
(
)
-
>
GetParentElement
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
leftBlock
=
leftBlockChild
.
Container
(
)
-
>
GetParentElement
(
)
;
}
}
nsCOMPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
beforeBlock
leftBlockChild
.
Offset
(
)
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
)
{
int32_t
offset
=
leftBlockChild
.
Offset
(
)
;
EditActionResult
retMoveContents
=
MoveContents
(
*
rightList
*
leftList
&
offset
)
;
if
(
retMoveContents
.
Handled
(
)
)
{
ret
.
MarkAsHandled
(
)
;
}
leftBlockChild
.
Clear
(
)
;
}
else
{
EditorDOMPoint
previousContent
;
if
(
&
aLeftNode
=
=
leftBlock
)
{
previousContent
=
leftBlockChild
;
}
else
{
previousContent
.
Set
(
&
aLeftNode
)
;
previousContent
.
AdvanceOffset
(
)
;
}
nsCOMPtr
<
Element
>
editorRoot
=
htmlEditor
-
>
GetEditorRoot
(
)
;
if
(
!
editorRoot
|
|
&
aLeftNode
!
=
editorRoot
)
{
nsCOMPtr
<
nsIContent
>
splittedPreviousContent
;
nsCOMPtr
<
nsINode
>
previousContentParent
=
previousContent
.
Container
(
)
;
int32_t
previousContentOffset
=
previousContent
.
Offset
(
)
;
rv
=
htmlEditor
-
>
SplitStyleAbovePoint
(
address_of
(
previousContentParent
)
&
previousContentOffset
nullptr
nullptr
nullptr
getter_AddRefs
(
splittedPreviousContent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
splittedPreviousContent
)
{
previousContent
.
Set
(
splittedPreviousContent
)
;
}
else
{
previousContent
.
Set
(
previousContentParent
previousContentOffset
)
;
}
}
if
(
NS_WARN_IF
(
!
previousContent
.
IsSet
(
)
)
)
{
return
EditActionIgnored
(
NS_ERROR_NULL_POINTER
)
;
}
ret
|
=
MoveBlock
(
*
previousContent
.
Container
(
)
-
>
AsElement
(
)
*
rightBlock
previousContent
.
Offset
(
)
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
&
&
NS_SUCCEEDED
(
htmlEditor
-
>
DeleteNode
(
brNode
)
)
)
{
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
atRightBlockChild
.
IsSet
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
leftBlockChild
.
IsSet
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToJoinBlocks
(
htmlEditor
leftBlock
rightBlock
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
nsCOMPtr
<
Element
>
brNode
=
CheckForInvisibleBR
(
*
leftBlock
BRLocation
:
:
blockEnd
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
mergeLists
|
|
leftBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
rightBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
EditorDOMPoint
pt
=
JoinNodesSmart
(
*
leftBlock
*
rightBlock
)
;
if
(
pt
.
IsSet
(
)
&
&
mergeLists
)
{
RefPtr
<
Element
>
newBlock
=
ConvertListType
(
rightBlock
existingList
nsGkAtoms
:
:
li
)
;
}
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveBlock
(
*
leftBlock
*
rightBlock
-
1
0
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
if
(
brNode
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
brNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
ret
.
MarkAsHandled
(
)
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveBlock
(
Element
&
aLeftBlock
Element
&
aRightBlock
int32_t
aLeftOffset
int32_t
aRightOffset
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsresult
rv
=
GetNodesFromPoint
(
EditorDOMPoint
(
&
aRightBlock
aRightOffset
)
EditAction
:
:
makeList
arrayOfNodes
TouchContent
:
:
yes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
EditActionResult
ret
(
NS_OK
)
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
IsBlockNode
(
arrayOfNodes
[
i
]
)
)
{
ret
|
=
MoveContents
(
*
arrayOfNodes
[
i
]
-
>
AsElement
(
)
aLeftBlock
&
aLeftOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
ret
.
SetResult
(
NS_ERROR_UNEXPECTED
)
;
}
rv
=
mHTMLEditor
-
>
DeleteNode
(
arrayOfNodes
[
i
]
)
;
ret
.
MarkAsHandled
(
)
;
}
else
{
ret
|
=
MoveNodeSmart
(
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
aLeftBlock
&
aLeftOffset
)
;
}
}
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
return
ret
;
}
EditActionResult
HTMLEditRules
:
:
MoveNodeSmart
(
nsIContent
&
aNode
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditActionIgnored
(
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
htmlEditor
-
>
CanContain
(
aDestElement
aNode
)
)
{
nsresult
rv
=
htmlEditor
-
>
MoveNode
(
&
aNode
&
aDestElement
*
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionIgnored
(
rv
)
;
}
if
(
*
aInOutDestOffset
!
=
-
1
)
{
(
*
aInOutDestOffset
)
+
+
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
ret
(
NS_OK
)
;
if
(
aNode
.
IsElement
(
)
)
{
ret
=
MoveContents
(
*
aNode
.
AsElement
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
nsresult
rv
=
htmlEditor
-
>
DeleteNode
(
&
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ret
.
SetResult
(
rv
)
;
}
return
ret
.
MarkAsHandled
(
)
;
}
EditActionResult
HTMLEditRules
:
:
MoveContents
(
Element
&
aElement
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
{
MOZ_ASSERT
(
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
&
aDestElement
)
)
{
return
EditActionIgnored
(
NS_ERROR_ILLEGAL_VALUE
)
;
}
EditActionResult
ret
(
NS_OK
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
ret
|
=
MoveNodeSmart
(
*
aElement
.
GetFirstChild
(
)
aDestElement
aInOutDestOffset
)
;
if
(
NS_WARN_IF
(
ret
.
Failed
(
)
)
)
{
return
ret
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
DeleteNonTableElements
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
HTMLEditUtils
:
:
IsTableElementButNotTable
(
aNode
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
return
mHTMLEditor
-
>
DeleteNode
(
aNode
-
>
AsDOMNode
(
)
)
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteNonTableElements
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aDir
nsresult
aResult
)
{
if
(
!
aSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsINode
>
startNode
;
int32_t
startOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Element
>
citeNode
=
GetTopEnclosingMailCite
(
*
startNode
)
;
if
(
citeNode
)
{
bool
isEmpty
=
true
seenBR
=
false
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
IsEmptyNodeImpl
(
citeNode
&
isEmpty
true
true
false
&
seenBR
)
;
if
(
isEmpty
)
{
int32_t
offset
;
nsCOMPtr
<
nsINode
>
parent
=
EditorBase
:
:
GetNodeLocation
(
citeNode
&
offset
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
citeNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
parent
&
&
seenBR
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
brNode
=
mHTMLEditor
-
>
CreateBR
(
parent
offset
)
;
NS_ENSURE_STATE
(
brNode
)
;
aSelection
-
>
Collapse
(
parent
offset
)
;
}
}
}
return
TextEditRules
:
:
DidDeleteSelection
(
aSelection
aDir
aResult
)
;
}
nsresult
HTMLEditRules
:
:
WillMakeList
(
Selection
*
aSelection
const
nsAString
*
aListType
bool
aEntireList
const
nsAString
*
aBulletType
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aItemType
)
{
if
(
!
aSelection
|
|
!
aListType
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
OwningNonNull
<
nsAtom
>
listType
=
NS_Atomize
(
*
aListType
)
;
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
RefPtr
<
nsAtom
>
itemType
;
if
(
aItemType
)
{
itemType
=
NS_Atomize
(
*
aItemType
)
;
NS_ENSURE_TRUE
(
itemType
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
if
(
listType
=
=
nsGkAtoms
:
:
dl
)
{
itemType
=
nsGkAtoms
:
:
dd
;
}
else
{
itemType
=
nsGkAtoms
:
:
li
;
}
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetListActionNodes
(
arrayOfNodes
aEntireList
?
EntireList
:
:
yes
:
EntireList
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
bOnlyBreaks
=
true
;
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
!
TextEditUtils
:
:
IsBreak
(
curNode
)
&
&
!
IsEmptyInline
(
curNode
)
)
{
bOnlyBreaks
=
false
;
break
;
}
}
if
(
arrayOfNodes
.
IsEmpty
(
)
|
|
bOnlyBreaks
)
{
if
(
bOnlyBreaks
)
{
for
(
auto
&
node
:
arrayOfNodes
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
NS_ENSURE_STATE
(
aSelection
-
>
RangeCount
(
)
)
;
nsCOMPtr
<
nsINode
>
container
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
offset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
NS_ENSURE_STATE
(
container
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
CanContainTag
(
*
container
listType
)
)
{
*
aCancel
=
true
;
return
NS_OK
;
}
rv
=
SplitAsNeeded
(
listType
container
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atListItemToInsertBefore
(
container
child
offset
)
;
RefPtr
<
Element
>
theList
=
mHTMLEditor
-
>
CreateNode
(
listType
atListItemToInsertBefore
)
;
NS_ENSURE_STATE
(
theList
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atFirstListItemToInsertBefore
(
theList
0
)
;
RefPtr
<
Element
>
theListItem
=
mHTMLEditor
-
>
CreateNode
(
itemType
atFirstListItemToInsertBefore
)
;
NS_ENSURE_STATE
(
theListItem
)
;
mNewBlock
=
theListItem
;
*
aHandled
=
true
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
EditorRawDOMPoint
(
theListItem
0
)
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
LookInsideDivBQandList
(
arrayOfNodes
)
;
uint32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
nsCOMPtr
<
Element
>
curList
prevListItem
;
for
(
uint32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
nsCOMPtr
<
Element
>
newBlock
;
NS_ENSURE_STATE
(
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
;
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
if
(
curList
&
&
InDifferentTableElements
(
curList
curNode
)
)
{
curList
=
nullptr
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
mHTMLEditor
-
>
IsEditable
(
curNode
)
&
&
(
TextEditUtils
:
:
IsBreak
(
curNode
)
|
|
IsEmptyInline
(
curNode
)
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
TextEditUtils
:
:
IsBreak
(
curNode
)
)
{
prevListItem
=
nullptr
;
}
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curList
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newBlock
=
ConvertListType
(
curNode
-
>
AsElement
(
)
listType
itemType
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
RemoveBlockContainer
(
*
newBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
curList
=
ConvertListType
(
curNode
-
>
AsElement
(
)
listType
itemType
)
;
if
(
NS_WARN_IF
(
!
curList
)
)
{
return
NS_ERROR_FAILURE
;
}
}
prevListItem
=
nullptr
;
continue
;
}
EditorRawDOMPoint
atCurNode
(
curNode
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atCurNode
.
IsSetAndValid
(
)
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
atCurNode
.
Container
(
)
-
>
IsHTMLElement
(
listType
)
)
{
if
(
!
curList
|
|
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curList
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
NS_WARN_IF
(
!
atCurNode
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
mHTMLEditor
-
>
SplitNode
(
atCurNode
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
newBlock
=
newLeftNode
?
newLeftNode
-
>
AsElement
(
)
:
nullptr
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atParentOfCurNode
(
atCurNode
.
Container
(
)
)
;
curList
=
mHTMLEditor
-
>
CreateNode
(
listType
atParentOfCurNode
)
;
NS_ENSURE_STATE
(
curList
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
curNode
-
>
IsHTMLElement
(
itemType
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
newBlock
=
mHTMLEditor
-
>
ReplaceContainer
(
curNode
-
>
AsElement
(
)
itemType
)
;
NS_ENSURE_STATE
(
newBlock
)
;
}
}
else
{
if
(
!
curList
)
{
curList
=
atCurNode
.
Container
(
)
-
>
AsElement
(
)
;
}
else
if
(
atCurNode
.
Container
(
)
!
=
curList
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
curNode
-
>
IsHTMLElement
(
itemType
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
newBlock
=
mHTMLEditor
-
>
ReplaceContainer
(
curNode
-
>
AsElement
(
)
itemType
)
;
NS_ENSURE_STATE
(
newBlock
)
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
curElement
=
do_QueryInterface
(
curNode
)
;
if
(
aBulletType
&
&
!
aBulletType
-
>
IsEmpty
(
)
)
{
rv
=
mHTMLEditor
-
>
SetAttribute
(
curElement
nsGkAtoms
:
:
type
*
aBulletType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
mHTMLEditor
-
>
RemoveAttribute
(
curElement
nsGkAtoms
:
:
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
prevListItem
=
nullptr
;
int32_t
j
=
i
+
1
;
GetInnerContent
(
*
curNode
arrayOfNodes
&
j
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
RemoveContainer
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
listCount
=
arrayOfNodes
.
Length
(
)
;
continue
;
}
if
(
!
curList
)
{
nsCOMPtr
<
nsINode
>
curParent
(
atCurNode
.
Container
(
)
)
;
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
int32_t
offset
=
atCurNode
.
Offset
(
)
;
rv
=
SplitAsNeeded
(
listType
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curList
=
mHTMLEditor
-
>
CreateNode
(
listType
atCurChild
)
;
mNewBlock
=
curList
;
prevListItem
=
nullptr
;
atCurNode
.
Clear
(
)
;
}
nsCOMPtr
<
Element
>
listItem
;
if
(
!
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
IsInlineNode
(
curNode
)
&
&
prevListItem
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
prevListItem
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
listItem
=
mHTMLEditor
-
>
ReplaceContainer
(
curNode
-
>
AsElement
(
)
itemType
)
;
NS_ENSURE_STATE
(
listItem
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
listItem
=
mHTMLEditor
-
>
InsertContainerAbove
(
curNode
itemType
)
;
NS_ENSURE_STATE
(
listItem
)
;
}
if
(
IsInlineNode
(
curNode
)
)
{
prevListItem
=
listItem
;
}
else
{
prevListItem
=
nullptr
;
}
}
}
else
{
listItem
=
curNode
-
>
AsElement
(
)
;
}
if
(
listItem
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
listItem
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillRemoveList
(
Selection
*
aSelection
bool
aOrdered
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
*
aSelection
arrayOfRanges
EditAction
:
:
makeList
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetListActionNodes
(
arrayOfNodes
EntireList
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
int32_t
i
=
arrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
arrayOfNodes
[
i
]
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsEditable
(
testNode
)
)
{
arrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
for
(
auto
&
curNode
:
arrayOfNodes
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
bool
bOutOfList
;
do
{
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
&
bOutOfList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
while
(
!
bOutOfList
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
RemoveListStructure
(
*
curNode
-
>
AsElement
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillMakeDefListItem
(
Selection
*
aSelection
const
nsAString
*
aItemType
bool
aEntireList
bool
*
aCancel
bool
*
aHandled
)
{
NS_NAMED_LITERAL_STRING
(
listType
"
dl
"
)
;
return
WillMakeList
(
aSelection
&
listType
.
AsString
(
)
aEntireList
nullptr
aCancel
aHandled
aItemType
)
;
}
nsresult
HTMLEditRules
:
:
WillMakeBasicBlock
(
Selection
&
aSelection
const
nsAString
&
aBlockType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
OwningNonNull
<
nsAtom
>
blockType
=
NS_Atomize
(
aBlockType
)
;
WillInsert
(
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
MakeBasicBlock
(
aSelection
blockType
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
nsresult
HTMLEditRules
:
:
MakeBasicBlock
(
Selection
&
aSelection
nsAtom
&
blockType
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsresult
rv
=
NormalizeSelection
(
&
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionRestorer
selectionRestorer
(
&
aSelection
htmlEditor
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
htmlEditor
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesFromSelection
(
aSelection
EditAction
:
:
makeBasicBlock
arrayOfNodes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
NS_ENSURE_STATE
(
aSelection
.
GetRangeAt
(
0
)
&
&
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
OwningNonNull
<
nsINode
>
container
=
*
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
int32_t
offset
=
aSelection
.
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
NS_ENSURE_TRUE
(
htmlEditor
-
>
GetBlock
(
container
)
NS_ERROR_NULL_POINTER
)
;
OwningNonNull
<
Element
>
curBlock
=
*
htmlEditor
-
>
GetBlock
(
container
)
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
)
{
nsCOMPtr
<
nsIContent
>
brNode
=
htmlEditor
-
>
GetNextEditableHTMLNode
(
EditorRawDOMPoint
(
container
child
offset
)
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
brNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
offset
=
htmlEditor
-
>
SplitNodeDeep
(
curBlock
*
container
-
>
AsContent
(
)
offset
HTMLEditor
:
:
EmptyContainers
:
:
no
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
brNode
=
htmlEditor
-
>
CreateBR
(
curBlock
-
>
GetParentNode
(
)
offset
)
;
NS_ENSURE_STATE
(
brNode
)
;
rv
=
aSelection
.
Collapse
(
curBlock
-
>
GetParentNode
(
)
offset
)
;
selectionRestorer
.
Abort
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
brNode
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
EditorRawDOMPoint
(
container
child
offset
)
)
;
if
(
brNode
&
&
brNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
brNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
arrayOfNodes
.
RemoveElement
(
brNode
)
;
child
=
container
-
>
GetChildAt
(
offset
)
;
}
rv
=
SplitAsNeeded
(
blockType
container
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atChild
(
container
child
offset
)
;
RefPtr
<
Element
>
block
=
htmlEditor
-
>
CreateNode
(
&
blockType
atChild
)
;
NS_ENSURE_STATE
(
block
)
;
mNewBlock
=
block
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
htmlEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
rv
=
aSelection
.
Collapse
(
block
0
)
;
selectionRestorer
.
Abort
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
if
(
&
blockType
=
=
nsGkAtoms
:
:
blockquote
)
{
rv
=
MakeBlockquote
(
arrayOfNodes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
&
blockType
=
=
nsGkAtoms
:
:
normal
|
|
&
blockType
=
=
nsGkAtoms
:
:
_empty
)
{
rv
=
RemoveBlockStyle
(
arrayOfNodes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
ApplyBlockStyle
(
arrayOfNodes
blockType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidMakeBasicBlock
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
if
(
!
aSelection
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
aSelection
-
>
GetRangeAt
(
0
)
&
&
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
nsresult
rv
=
InsertMozBRIfNeeded
(
*
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
mHTMLEditor
-
>
IsCSSEnabled
(
)
)
{
nsresult
rv
=
WillCSSIndent
(
aSelection
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
WillHTMLIndent
(
aSelection
aCancel
aHandled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillCSSIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
nsTArray
<
OwningNonNull
<
nsRange
>
>
arrayOfRanges
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsCOMPtr
<
Element
>
liNode
;
if
(
aSelection
-
>
Collapsed
(
)
)
{
nsCOMPtr
<
nsINode
>
node
;
int32_t
offset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
node
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
block
=
mHTMLEditor
-
>
GetBlock
(
*
node
)
;
if
(
block
&
&
HTMLEditUtils
:
:
IsListItem
(
block
)
)
{
liNode
=
block
;
}
}
if
(
liNode
)
{
arrayOfNodes
.
AppendElement
(
*
liNode
)
;
}
else
{
rv
=
GetNodesFromSelection
(
*
aSelection
EditAction
:
:
indent
arrayOfNodes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
NS_ENSURE_STATE
(
aSelection
-
>
RangeCount
(
)
)
;
nsCOMPtr
<
nsINode
>
container
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
offset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_STATE
(
container
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
container
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atChild
(
container
child
offset
)
;
RefPtr
<
Element
>
theBlock
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atChild
)
;
NS_ENSURE_STATE
(
theBlock
)
;
mNewBlock
=
theBlock
;
ChangeIndentation
(
*
theBlock
Change
:
:
plus
)
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
atStartOfTheBlock
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curQuote
;
nsCOMPtr
<
nsIContent
>
sibling
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
NS_ENSURE_STATE
(
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
;
nsCOMPtr
<
nsIContent
>
curNode
=
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
sibling
=
nullptr
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
sibling
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
sibling
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
rv
=
SplitAsNeeded
(
*
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curList
=
mHTMLEditor
-
>
CreateNode
(
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
atCurChild
)
;
NS_ENSURE_STATE
(
curList
)
;
mNewBlock
=
curList
;
}
uint32_t
listLen
=
curList
-
>
Length
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curList
listLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
curNode
&
&
IsBlockNode
(
*
curNode
)
)
{
ChangeIndentation
(
*
curNode
-
>
AsElement
(
)
Change
:
:
plus
)
;
curQuote
=
nullptr
;
}
else
{
if
(
!
curQuote
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mHTMLEditor
-
>
CanContainTag
(
*
curParent
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curQuote
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atCurChild
)
;
NS_ENSURE_STATE
(
curQuote
)
;
ChangeIndentation
(
*
curQuote
Change
:
:
plus
)
;
mNewBlock
=
curQuote
;
}
uint32_t
quoteLen
=
curQuote
-
>
Length
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curQuote
quoteLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillHTMLIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsresult
rv
=
NormalizeSelection
(
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
*
aSelection
arrayOfRanges
EditAction
:
:
indent
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
indent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
NS_ENSURE_STATE
(
aSelection
-
>
RangeCount
(
)
)
;
nsCOMPtr
<
nsINode
>
container
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
offset
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
NS_ENSURE_STATE
(
container
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
blockquote
container
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atChild
(
container
child
offset
)
;
RefPtr
<
Element
>
theBlock
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
blockquote
atChild
)
;
NS_ENSURE_STATE
(
theBlock
)
;
mNewBlock
=
theBlock
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
EditorRawDOMPoint
atStartOfTheBlock
(
theBlock
0
)
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
atStartOfTheBlock
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
!
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
nsCOMPtr
<
Element
>
curList
curQuote
indentedLI
;
int32_t
listCount
=
arrayOfNodes
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
listCount
;
i
+
+
)
{
NS_ENSURE_STATE
(
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
;
nsCOMPtr
<
nsIContent
>
curNode
=
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
sibling
=
nullptr
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetNextHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
sibling
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
if
(
sibling
&
&
HTMLEditUtils
:
:
IsList
(
sibling
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
&
&
curParent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
sibling
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
sibling
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
sibling
=
nullptr
;
if
(
curList
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
rv
=
SplitAsNeeded
(
*
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curList
=
mHTMLEditor
-
>
CreateNode
(
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
atCurChild
)
;
NS_ENSURE_STATE
(
curList
)
;
mNewBlock
=
curList
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curQuote
=
nullptr
;
}
else
{
nsCOMPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
curParent
=
listItem
-
>
GetParentNode
(
)
;
offset
=
curParent
?
curParent
-
>
IndexOf
(
listItem
)
:
-
1
;
if
(
curList
)
{
sibling
=
nullptr
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
nsCOMPtr
<
nsIContent
>
curChild
(
listItem
)
;
rv
=
SplitAsNeeded
(
*
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curList
=
mHTMLEditor
-
>
CreateNode
(
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
atCurChild
)
;
NS_ENSURE_STATE
(
curList
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
listItem
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
indentedLI
=
listItem
;
}
else
{
if
(
curQuote
&
&
InDifferentTableElements
(
curQuote
curNode
)
)
{
curQuote
=
nullptr
;
}
if
(
!
curQuote
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mHTMLEditor
-
>
CanContainTag
(
*
curParent
*
nsGkAtoms
:
:
blockquote
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
blockquote
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curQuote
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
blockquote
atCurChild
)
;
NS_ENSURE_STATE
(
curQuote
)
;
mNewBlock
=
curQuote
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
curQuote
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curList
=
nullptr
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillOutdent
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsCOMPtr
<
nsIContent
>
rememberedLeftBQ
rememberedRightBQ
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
bool
useCSS
=
htmlEditor
-
>
IsCSSEnabled
(
)
;
nsresult
rv
=
NormalizeSelection
(
&
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
{
AutoSelectionRestorer
selectionRestorer
(
&
aSelection
htmlEditor
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesFromSelection
(
aSelection
EditAction
:
:
outdent
arrayOfNodes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
Element
>
curBlockQuote
;
nsCOMPtr
<
nsIContent
>
firstBQChild
lastBQChild
;
bool
curBlockQuoteIsIndentedWithCSS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
if
(
!
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
{
continue
;
}
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
htmlEditor
-
>
RemoveBlockContainer
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
if
(
useCSS
&
&
IsBlockNode
(
curNode
)
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
*
htmlEditor
-
>
mCSSEditUtils
curNode
)
;
nsAutoString
value
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetSpecifiedProperty
(
curNode
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
NS_ENSURE_STATE
(
htmlEditor
)
;
htmlEditor
-
>
mCSSEditUtils
-
>
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
)
{
ChangeIndentation
(
*
curNode
-
>
AsElement
(
)
Change
:
:
minus
)
;
continue
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
rv
=
PopListItem
(
*
curNode
-
>
AsContent
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
if
(
curBlockQuote
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlockQuote
)
)
{
lastBQChild
=
curNode
;
continue
;
}
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curBlockQuote
=
nullptr
;
firstBQChild
=
nullptr
;
lastBQChild
=
nullptr
;
curBlockQuoteIsIndentedWithCSS
=
false
;
}
OwningNonNull
<
nsINode
>
n
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
false
;
while
(
!
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
htmlEditor
-
>
IsDescendantOfEditorRoot
(
n
)
&
&
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
n
)
)
)
{
if
(
!
n
-
>
GetParentNode
(
)
)
{
break
;
}
n
=
*
n
-
>
GetParentNode
(
)
;
if
(
n
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
break
;
}
else
if
(
useCSS
)
{
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
*
htmlEditor
-
>
mCSSEditUtils
curNode
)
;
nsAutoString
value
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetSpecifiedProperty
(
*
n
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
htmlEditor
-
>
mCSSEditUtils
-
>
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
f
>
0
&
&
!
(
HTMLEditUtils
:
:
IsList
(
curParent
)
&
&
HTMLEditUtils
:
:
IsList
(
curNode
)
)
)
{
curBlockQuote
=
n
-
>
AsElement
(
)
;
firstBQChild
=
curNode
;
lastBQChild
=
curNode
;
curBlockQuoteIsIndentedWithCSS
=
true
;
break
;
}
}
}
if
(
!
curBlockQuote
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
htmlEditor
-
>
RemoveBlockContainer
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetLastChild
(
)
;
while
(
child
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
rv
=
PopListItem
(
*
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
rv
=
htmlEditor
-
>
MoveNode
(
child
curParent
offset
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
htmlEditor
-
>
DeleteNode
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
child
=
curNode
-
>
GetLastChild
(
)
;
}
rv
=
htmlEditor
-
>
RemoveBlockContainer
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
useCSS
)
{
nsCOMPtr
<
Element
>
element
;
if
(
curNode
-
>
GetAsText
(
)
)
{
element
=
curNode
-
>
GetParentElement
(
)
;
}
else
if
(
curNode
-
>
IsElement
(
)
)
{
element
=
curNode
-
>
AsElement
(
)
;
}
if
(
element
)
{
ChangeIndentation
(
*
element
Change
:
:
minus
)
;
}
}
}
}
if
(
curBlockQuote
)
{
rv
=
OutdentPartOfBlock
(
*
curBlockQuote
*
firstBQChild
*
lastBQChild
curBlockQuoteIsIndentedWithCSS
getter_AddRefs
(
rememberedLeftBQ
)
getter_AddRefs
(
rememberedRightBQ
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
rememberedLeftBQ
|
|
rememberedRightBQ
)
{
if
(
aSelection
.
Collapsed
(
)
)
{
NS_ENSURE_TRUE
(
aSelection
.
GetRangeAt
(
0
)
NS_OK
)
;
nsCOMPtr
<
nsINode
>
startNode
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
if
(
rememberedLeftBQ
&
&
(
startNode
=
=
rememberedLeftBQ
|
|
EditorUtils
:
:
IsDescendantOf
(
*
startNode
*
rememberedLeftBQ
)
)
)
{
EditorRawDOMPoint
afterRememberedLeftBQ
(
rememberedLeftBQ
)
;
afterRememberedLeftBQ
.
AdvanceOffset
(
)
;
aSelection
.
Collapse
(
afterRememberedLeftBQ
)
;
}
startNode
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
if
(
rememberedRightBQ
&
&
(
startNode
=
=
rememberedRightBQ
|
|
EditorUtils
:
:
IsDescendantOf
(
*
startNode
*
rememberedRightBQ
)
)
)
{
EditorRawDOMPoint
atRememberedRightBQ
(
rememberedRightBQ
)
;
aSelection
.
Collapse
(
atRememberedRightBQ
)
;
}
}
return
NS_OK
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemovePartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
)
{
SplitBlock
(
aBlock
aStartChild
aEndChild
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
RemoveBlockContainer
(
aBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
SplitBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
nsIContent
*
*
aOutMiddleNode
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aStartChild
aBlock
)
&
&
EditorUtils
:
:
IsDescendantOf
(
aEndChild
aBlock
)
)
;
NS_ENSURE_TRUE_VOID
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
OwningNonNull
<
nsIContent
>
startParent
=
*
aStartChild
.
GetParent
(
)
;
int32_t
startOffset
=
startParent
-
>
IndexOf
(
&
aStartChild
)
;
nsCOMPtr
<
nsIContent
>
newMiddleNode1
;
htmlEditor
-
>
SplitNodeDeep
(
aBlock
startParent
startOffset
HTMLEditor
:
:
EmptyContainers
:
:
no
aOutLeftNode
getter_AddRefs
(
newMiddleNode1
)
)
;
OwningNonNull
<
nsIContent
>
endParent
=
*
aEndChild
.
GetParent
(
)
;
int32_t
endOffset
=
1
+
endParent
-
>
IndexOf
(
&
aEndChild
)
;
nsCOMPtr
<
nsIContent
>
newMiddleNode2
;
htmlEditor
-
>
SplitNodeDeep
(
aBlock
endParent
endOffset
HTMLEditor
:
:
EmptyContainers
:
:
no
getter_AddRefs
(
newMiddleNode2
)
aOutRightNode
)
;
if
(
aOutMiddleNode
)
{
if
(
newMiddleNode2
)
{
newMiddleNode2
.
forget
(
aOutMiddleNode
)
;
}
else
{
newMiddleNode1
.
forget
(
aOutMiddleNode
)
;
}
}
}
nsresult
HTMLEditRules
:
:
OutdentPartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
bool
aIsBlockIndentedWithCSS
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
)
{
MOZ_ASSERT
(
aOutLeftNode
&
&
aOutRightNode
)
;
nsCOMPtr
<
nsIContent
>
middleNode
;
SplitBlock
(
aBlock
aStartChild
aEndChild
aOutLeftNode
aOutRightNode
getter_AddRefs
(
middleNode
)
)
;
NS_ENSURE_STATE
(
middleNode
)
;
if
(
!
aIsBlockIndentedWithCSS
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
RemoveBlockContainer
(
*
middleNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
middleNode
-
>
IsElement
(
)
)
{
nsresult
rv
=
ChangeIndentation
(
*
middleNode
-
>
AsElement
(
)
Change
:
:
minus
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditRules
:
:
ConvertListType
(
Element
*
aList
nsAtom
*
aListType
nsAtom
*
aItemType
)
{
MOZ_ASSERT
(
aList
)
;
MOZ_ASSERT
(
aListType
)
;
MOZ_ASSERT
(
aItemType
)
;
nsCOMPtr
<
nsINode
>
child
=
aList
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
element
=
child
-
>
AsElement
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
aItemType
)
)
{
child
=
mHTMLEditor
-
>
ReplaceContainer
(
element
aItemType
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
}
else
if
(
HTMLEditUtils
:
:
IsList
(
element
)
&
&
!
element
-
>
IsHTMLElement
(
aListType
)
)
{
child
=
ConvertListType
(
child
-
>
AsElement
(
)
aListType
aItemType
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
}
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
aList
-
>
IsHTMLElement
(
aListType
)
)
{
RefPtr
<
dom
:
:
Element
>
list
=
aList
-
>
AsElement
(
)
;
return
list
.
forget
(
)
;
}
return
mHTMLEditor
-
>
ReplaceContainer
(
aList
aListType
)
;
}
nsresult
HTMLEditRules
:
:
CreateStyleForInsertText
(
Selection
&
aSelection
nsIDocument
&
aDoc
)
{
MOZ_ASSERT
(
mHTMLEditor
-
>
mTypeInState
)
;
bool
weDidSomething
=
false
;
NS_ENSURE_STATE
(
aSelection
.
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
node
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
offset
=
aSelection
.
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
Element
>
rootElement
=
aDoc
.
GetRootElement
(
)
;
NS_ENSURE_STATE
(
rootElement
)
;
UniquePtr
<
PropItem
>
item
=
Move
(
mHTMLEditor
-
>
mTypeInState
-
>
TakeClearProperty
(
)
)
;
while
(
item
&
&
node
!
=
rootElement
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
ClearStyle
(
address_of
(
node
)
&
offset
item
-
>
tag
&
item
-
>
attr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
item
=
Move
(
mHTMLEditor
-
>
mTypeInState
-
>
TakeClearProperty
(
)
)
;
weDidSomething
=
true
;
}
int32_t
relFontSize
=
mHTMLEditor
-
>
mTypeInState
-
>
TakeRelativeFontSize
(
)
;
item
=
Move
(
mHTMLEditor
-
>
mTypeInState
-
>
TakeSetProperty
(
)
)
;
if
(
item
|
|
relFontSize
)
{
if
(
RefPtr
<
Text
>
text
=
node
-
>
GetAsText
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
offset
=
mHTMLEditor
-
>
SplitNodeDeep
(
*
text
*
text
offset
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
node
=
node
-
>
GetParentNode
(
)
;
}
if
(
!
mHTMLEditor
-
>
IsContainer
(
node
)
)
{
return
NS_OK
;
}
OwningNonNull
<
Text
>
newNode
=
EditorBase
:
:
CreateTextNode
(
aDoc
EmptyString
(
)
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
InsertNode
(
*
newNode
*
node
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
node
=
newNode
;
offset
=
0
;
weDidSomething
=
true
;
if
(
relFontSize
)
{
HTMLEditor
:
:
FontSize
dir
=
relFontSize
>
0
?
HTMLEditor
:
:
FontSize
:
:
incr
:
HTMLEditor
:
:
FontSize
:
:
decr
;
for
(
int32_t
j
=
0
;
j
<
DeprecatedAbs
(
relFontSize
)
;
j
+
+
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
RelativeFontChangeOnTextNode
(
dir
newNode
0
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
while
(
item
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
SetInlinePropertyOnNode
(
*
node
-
>
AsContent
(
)
*
item
-
>
tag
&
item
-
>
attr
item
-
>
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
item
=
mHTMLEditor
-
>
mTypeInState
-
>
TakeSetProperty
(
)
;
}
}
if
(
weDidSomething
)
{
return
aSelection
.
Collapse
(
node
offset
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
IsEmptyBlock
(
Element
&
aNode
bool
*
aOutIsEmptyBlock
MozBRCounts
aMozBRCounts
)
{
MOZ_ASSERT
(
aOutIsEmptyBlock
)
;
*
aOutIsEmptyBlock
=
true
;
NS_ENSURE_TRUE
(
IsBlockNode
(
aNode
)
NS_ERROR_NULL_POINTER
)
;
return
mHTMLEditor
-
>
IsEmptyNode
(
aNode
.
AsDOMNode
(
)
aOutIsEmptyBlock
aMozBRCounts
=
=
MozBRCounts
:
:
yes
?
false
:
true
)
;
}
nsresult
HTMLEditRules
:
:
WillAlign
(
Selection
&
aSelection
const
nsAString
&
aAlignType
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
WillInsert
(
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
false
;
nsresult
rv
=
NormalizeSelection
(
&
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionRestorer
selectionRestorer
(
&
aSelection
htmlEditor
)
;
*
aHandled
=
true
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
rv
=
GetNodesFromSelection
(
aSelection
EditAction
:
:
align
nodeArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
emptyDiv
=
nodeArray
.
IsEmpty
(
)
;
if
(
nodeArray
.
Length
(
)
=
=
1
)
{
OwningNonNull
<
nsINode
>
node
=
nodeArray
[
0
]
;
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
node
)
)
{
rv
=
AlignBlock
(
*
node
-
>
AsElement
(
)
aAlignType
ContentsOnly
:
:
yes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
NS_ENSURE_STATE
(
aSelection
.
GetRangeAt
(
0
)
&
&
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
OwningNonNull
<
nsINode
>
parent
=
*
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
emptyDiv
=
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
parent
)
;
}
}
if
(
emptyDiv
)
{
nsCOMPtr
<
nsINode
>
parent
=
aSelection
.
GetRangeAt
(
0
)
?
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
:
nullptr
;
NS_ENSURE_STATE
(
parent
)
;
int32_t
offset
=
aSelection
.
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
parent
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atChild
(
parent
child
offset
)
;
nsCOMPtr
<
nsIContent
>
brContent
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
atChild
)
;
if
(
brContent
&
&
TextEditUtils
:
:
IsBreak
(
brContent
)
)
{
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
child
)
{
sibling
=
htmlEditor
-
>
GetNextHTMLSibling
(
child
)
;
}
if
(
sibling
&
&
!
IsBlockNode
(
*
sibling
)
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
brContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
RefPtr
<
Element
>
div
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atChild
)
;
NS_ENSURE_STATE
(
div
)
;
mNewBlock
=
div
;
rv
=
AlignBlock
(
*
div
aAlignType
ContentsOnly
:
:
yes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aHandled
=
true
;
rv
=
CreateMozBR
(
div
-
>
AsDOMNode
(
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atStartOfDiv
(
div
0
)
;
ErrorResult
error
;
aSelection
.
Collapse
(
atStartOfDiv
error
)
;
selectionRestorer
.
Abort
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsTArray
<
bool
>
transitionList
;
MakeTransitionList
(
nodeArray
transitionList
)
;
nsCOMPtr
<
Element
>
curDiv
;
bool
useCSS
=
htmlEditor
-
>
IsCSSEnabled
(
)
;
for
(
size_t
i
=
0
;
i
<
nodeArray
.
Length
(
)
;
i
+
+
)
{
auto
&
curNode
=
nodeArray
[
i
]
;
if
(
!
htmlEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
curNode
)
)
{
rv
=
AlignBlock
(
*
curNode
-
>
AsElement
(
)
aAlignType
ContentsOnly
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curDiv
=
nullptr
;
continue
;
}
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
bool
isEmptyTextNode
=
false
;
if
(
curNode
-
>
GetAsText
(
)
&
&
(
(
HTMLEditUtils
:
:
IsTableElement
(
curParent
)
&
&
!
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
curParent
)
)
|
|
HTMLEditUtils
:
:
IsList
(
curParent
)
|
|
(
NS_SUCCEEDED
(
htmlEditor
-
>
IsEmptyNode
(
curNode
&
isEmptyTextNode
)
)
&
&
isEmptyTextNode
)
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
rv
=
RemoveAlignment
(
*
curNode
aAlignType
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
useCSS
)
{
htmlEditor
-
>
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
curNode
-
>
AsElement
(
)
nullptr
nsGkAtoms
:
:
align
&
aAlignType
false
)
;
curDiv
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
rv
=
AlignInnerBlocks
(
*
curNode
&
aAlignType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curDiv
=
nullptr
;
continue
;
}
}
if
(
!
curDiv
|
|
transitionList
[
i
]
)
{
if
(
!
htmlEditor
-
>
CanContainTag
(
*
curParent
*
nsGkAtoms
:
:
div
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
-
>
AsContent
(
)
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curDiv
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atCurChild
)
;
NS_ENSURE_STATE
(
curDiv
)
;
mNewBlock
=
curDiv
;
rv
=
AlignBlock
(
*
curDiv
aAlignType
ContentsOnly
:
:
yes
)
;
}
NS_ENSURE_STATE
(
curNode
-
>
IsContent
(
)
)
;
rv
=
htmlEditor
-
>
MoveNode
(
curNode
-
>
AsContent
(
)
curDiv
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignInnerBlocks
(
nsINode
&
aNode
const
nsAString
*
alignType
)
{
NS_ENSURE_TRUE
(
alignType
NS_ERROR_NULL_POINTER
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
TableCellAndListItemFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
nsresult
rv
=
AlignBlockContents
(
GetAsDOMNode
(
node
)
alignType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
AlignBlockContents
(
nsIDOMNode
*
aNode
const
nsAString
*
alignType
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
node
&
&
alignType
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
firstChild
lastChild
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
firstChild
=
mHTMLEditor
-
>
GetFirstEditableChild
(
*
node
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
lastChild
=
mHTMLEditor
-
>
GetLastEditableChild
(
*
node
)
;
if
(
!
firstChild
)
{
}
else
if
(
firstChild
=
=
lastChild
&
&
firstChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
RefPtr
<
Element
>
divElem
=
firstChild
-
>
AsElement
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
SetAttributeOrEquivalent
(
divElem
nsGkAtoms
:
:
align
*
alignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atStartOfNode
(
node
0
)
;
RefPtr
<
Element
>
divElem
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atStartOfNode
)
;
NS_ENSURE_STATE
(
divElem
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
SetAttributeOrEquivalent
(
divElem
nsGkAtoms
:
:
align
*
alignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
lastChild
&
&
(
lastChild
!
=
divElem
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
MoveNode
(
lastChild
divElem
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
lastChild
=
mHTMLEditor
-
>
GetLastEditableChild
(
*
node
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
CheckForEmptyBlock
(
nsINode
*
aStartNode
Element
*
aBodyNode
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
bool
*
aHandled
)
{
if
(
aBodyNode
&
&
IsInlineNode
(
*
aBodyNode
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
block
=
htmlEditor
-
>
GetBlock
(
*
aStartNode
)
;
bool
bIsEmptyNode
;
nsCOMPtr
<
Element
>
emptyBlock
;
if
(
block
&
&
block
!
=
aBodyNode
)
{
nsresult
rv
=
htmlEditor
-
>
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
block
&
&
bIsEmptyNode
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
block
)
&
&
block
!
=
aBodyNode
)
{
emptyBlock
=
block
;
block
=
htmlEditor
-
>
GetBlockNodeParent
(
emptyBlock
)
;
if
(
block
)
{
rv
=
htmlEditor
-
>
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
if
(
emptyBlock
&
&
emptyBlock
-
>
IsEditable
(
)
)
{
nsCOMPtr
<
nsINode
>
blockParent
=
emptyBlock
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
blockParent
NS_ERROR_FAILURE
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
emptyBlock
)
)
{
NS_ENSURE_STATE
(
htmlEditor
)
;
if
(
htmlEditor
-
>
IsFirstEditableChild
(
emptyBlock
)
)
{
nsCOMPtr
<
nsINode
>
listParent
=
blockParent
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
listParent
NS_ERROR_FAILURE
)
;
if
(
!
HTMLEditUtils
:
:
IsList
(
listParent
)
)
{
int32_t
listOffset
=
listParent
-
>
IndexOf
(
blockParent
)
;
NS_ENSURE_STATE
(
htmlEditor
)
;
nsCOMPtr
<
Element
>
br
=
htmlEditor
-
>
CreateBR
(
listParent
listOffset
)
;
NS_ENSURE_STATE
(
br
)
;
nsresult
rv
=
aSelection
-
>
Collapse
(
listParent
listOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
else
{
if
(
aAction
=
=
nsIEditor
:
:
eNext
|
|
aAction
=
=
nsIEditor
:
:
eNextWord
|
|
aAction
=
=
nsIEditor
:
:
eToEndOfLine
)
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
DebugOnly
<
bool
>
advanced
=
afterEmptyBlock
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
set
selection
to
the
after
the
empty
block
"
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
htmlEditor
-
>
GetNextNode
(
afterEmptyBlock
)
;
if
(
nextNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nextNode
aAction
)
;
nsresult
rv
=
aSelection
-
>
Collapse
(
pt
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aSelection
-
>
Collapse
(
afterEmptyBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
if
(
aAction
=
=
nsIEditor
:
:
ePrevious
|
|
aAction
=
=
nsIEditor
:
:
ePreviousWord
|
|
aAction
=
=
nsIEditor
:
:
eToBeginningOfLine
)
{
EditorRawDOMPoint
atEmptyBlock
(
emptyBlock
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
htmlEditor
-
>
GetPreviousEditableNode
(
atEmptyBlock
)
;
if
(
priorNode
)
{
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
priorNode
aAction
)
;
nsresult
rv
=
aSelection
-
>
Collapse
(
pt
.
AsRaw
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
EditorRawDOMPoint
afterEmptyBlock
(
emptyBlock
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aSelection
-
>
Collapse
(
afterEmptyBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
if
(
aAction
!
=
nsIEditor
:
:
eNone
)
{
MOZ_CRASH
(
"
CheckForEmptyBlock
doesn
'
t
support
this
action
yet
"
)
;
}
}
NS_ENSURE_STATE
(
htmlEditor
)
;
*
aHandled
=
true
;
nsresult
rv
=
htmlEditor
-
>
DeleteNode
(
emptyBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
Element
*
HTMLEditRules
:
:
CheckForInvisibleBR
(
Element
&
aBlock
BRLocation
aWhere
int32_t
aOffset
)
{
nsCOMPtr
<
nsINode
>
testNode
;
int32_t
testOffset
=
0
;
if
(
aWhere
=
=
BRLocation
:
:
blockEnd
)
{
nsCOMPtr
<
nsIContent
>
rightmostNode
=
mHTMLEditor
-
>
GetRightmostChild
(
&
aBlock
true
)
;
if
(
!
rightmostNode
)
{
return
nullptr
;
}
testNode
=
rightmostNode
-
>
GetParentNode
(
)
;
testOffset
=
testNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
testNode
-
>
IndexOf
(
rightmostNode
)
+
1
=
=
testOffset
)
;
}
else
if
(
aOffset
)
{
testNode
=
&
aBlock
;
testOffset
=
aOffset
;
}
else
{
return
nullptr
;
}
WSRunObject
wsTester
(
mHTMLEditor
testNode
testOffset
)
;
if
(
WSType
:
:
br
=
=
wsTester
.
mStartReason
)
{
return
wsTester
.
mStartReasonNode
-
>
AsElement
(
)
;
}
return
nullptr
;
}
void
HTMLEditRules
:
:
GetInnerContent
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
int32_t
*
aIndex
Lists
aLists
Tables
aTables
)
{
MOZ_ASSERT
(
aIndex
)
;
for
(
nsCOMPtr
<
nsIContent
>
node
=
mHTMLEditor
-
>
GetFirstEditableChild
(
aNode
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
if
(
(
aLists
=
=
Lists
:
:
yes
&
&
(
HTMLEditUtils
:
:
IsList
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
)
)
|
|
(
aTables
=
=
Tables
:
:
yes
&
&
HTMLEditUtils
:
:
IsTableElement
(
node
)
)
)
{
GetInnerContent
(
*
node
aOutArrayOfNodes
aIndex
aLists
aTables
)
;
}
else
{
aOutArrayOfNodes
.
InsertElementAt
(
*
aIndex
*
node
)
;
(
*
aIndex
)
+
+
;
}
}
}
nsresult
HTMLEditRules
:
:
ExpandSelectionForDeletion
(
Selection
&
aSelection
)
{
if
(
aSelection
.
Collapsed
(
)
)
{
return
NS_OK
;
}
if
(
aSelection
.
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aSelection
.
GetRangeAt
(
0
)
NS_ERROR_NULL_POINTER
)
;
OwningNonNull
<
nsRange
>
range
=
*
aSelection
.
GetRangeAt
(
0
)
;
nsCOMPtr
<
nsINode
>
selStartNode
=
range
-
>
GetStartContainer
(
)
;
int32_t
selStartOffset
=
range
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
selEndNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
selEndOffset
=
range
-
>
EndOffset
(
)
;
nsCOMPtr
<
Element
>
selCommon
=
HTMLEditor
:
:
GetBlock
(
*
range
-
>
GetCommonAncestor
(
)
)
;
NS_ENSURE_STATE
(
selCommon
)
;
nsCOMPtr
<
nsINode
>
firstBRParent
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
visOffset
=
0
firstBROffset
=
0
;
WSType
wsType
;
nsCOMPtr
<
Element
>
root
=
mHTMLEditor
-
>
GetActiveEditingHost
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
if
(
selStartNode
!
=
selCommon
&
&
selStartNode
!
=
root
)
{
while
(
true
)
{
WSRunObject
wsObj
(
mHTMLEditor
selStartNode
selStartOffset
)
;
wsObj
.
PriorVisibleNode
(
selStartNode
selStartOffset
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
thisBlock
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mStartReasonNode
)
|
|
selCommon
=
=
wsObj
.
mStartReasonNode
|
|
root
=
=
wsObj
.
mStartReasonNode
)
{
break
;
}
selStartNode
=
wsObj
.
mStartReasonNode
-
>
GetParentNode
(
)
;
selStartOffset
=
selStartNode
?
selStartNode
-
>
IndexOf
(
wsObj
.
mStartReasonNode
)
:
-
1
;
}
}
if
(
selEndNode
!
=
selCommon
&
&
selEndNode
!
=
root
)
{
for
(
;
;
)
{
WSRunObject
wsObj
(
mHTMLEditor
selEndNode
selEndOffset
)
;
wsObj
.
NextVisibleNode
(
selEndNode
selEndOffset
address_of
(
unused
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
mHTMLEditor
-
>
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
break
;
}
if
(
!
firstBRParent
)
{
firstBRParent
=
selEndNode
;
firstBROffset
=
selEndOffset
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
selEndNode
?
selEndNode
-
>
IndexOf
(
wsObj
.
mEndReasonNode
)
+
1
:
0
;
}
else
if
(
wsType
=
=
WSType
:
:
thisBlock
)
{
if
(
HTMLEditUtils
:
:
IsTableElement
(
wsObj
.
mEndReasonNode
)
|
|
selCommon
=
=
wsObj
.
mEndReasonNode
|
|
root
=
=
wsObj
.
mEndReasonNode
)
{
break
;
}
selEndNode
=
wsObj
.
mEndReasonNode
-
>
GetParentNode
(
)
;
selEndOffset
=
1
+
selEndNode
-
>
IndexOf
(
wsObj
.
mEndReasonNode
)
;
}
else
{
break
;
}
}
}
aSelection
.
Collapse
(
selStartNode
selStartOffset
)
;
bool
doEndExpansion
=
true
;
if
(
firstBRParent
)
{
nsCOMPtr
<
Element
>
brBlock
=
HTMLEditor
:
:
GetBlock
(
*
firstBRParent
)
;
bool
nodeBefore
=
false
nodeAfter
=
false
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
selStartNode
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
selStartNode
selStartOffset
selEndNode
selEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
brBlock
)
{
nsRange
:
:
CompareNodeToRange
(
brBlock
range
&
nodeBefore
&
nodeAfter
)
;
}
if
(
nodeBefore
|
|
nodeAfter
)
{
doEndExpansion
=
false
;
}
}
if
(
doEndExpansion
)
{
nsresult
rv
=
aSelection
.
Extend
(
selEndNode
selEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsresult
rv
=
aSelection
.
Extend
(
firstBRParent
firstBROffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
NormalizeSelection
(
Selection
*
inSelection
)
{
NS_ENSURE_TRUE
(
inSelection
NS_ERROR_NULL_POINTER
)
;
if
(
inSelection
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
if
(
inSelection
-
>
RangeCount
(
)
!
=
1
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
;
RefPtr
<
nsRange
>
range
=
inSelection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
startChild
=
range
-
>
GetChildAtStartOffset
(
)
;
nsIContent
*
endChild
=
range
-
>
GetChildAtEndOffset
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
newStartNode
=
startNode
;
uint32_t
newStartOffset
=
startOffset
;
nsCOMPtr
<
nsINode
>
newEndNode
=
endNode
;
uint32_t
newEndOffset
=
endOffset
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
offset
=
-
1
;
WSType
wsType
;
WSRunObject
wsEndObj
(
htmlEditor
endNode
static_cast
<
int32_t
>
(
endOffset
)
)
;
wsEndObj
.
PriorVisibleNode
(
endNode
static_cast
<
int32_t
>
(
endOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
htmlEditor
-
>
GetRightmostChild
(
wsEndObj
.
mStartReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
thisBlock
)
{
EditorRawDOMPoint
atEnd
(
endNode
endChild
endOffset
)
;
nsINode
*
child
=
htmlEditor
-
>
GetPreviousEditableHTMLNode
(
atEnd
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
else
if
(
wsEndObj
.
mStartReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newEndNode
=
EditorBase
:
:
GetNodeLocation
(
wsEndObj
.
mStartReasonNode
&
offset
)
;
newEndOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
;
}
}
WSRunObject
wsStartObj
(
htmlEditor
startNode
static_cast
<
int32_t
>
(
startOffset
)
)
;
wsStartObj
.
NextVisibleNode
(
startNode
static_cast
<
int32_t
>
(
startOffset
)
address_of
(
unused
)
&
offset
&
wsType
)
;
if
(
wsType
!
=
WSType
:
:
text
&
&
wsType
!
=
WSType
:
:
normalWS
)
{
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
otherBlock
)
{
nsINode
*
child
=
htmlEditor
-
>
GetLeftmostChild
(
wsStartObj
.
mEndReasonNode
true
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
thisBlock
)
{
nsINode
*
child
=
htmlEditor
-
>
GetNextEditableHTMLNode
(
EditorRawDOMPoint
(
startNode
startChild
startOffset
)
)
;
if
(
child
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
child
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
)
;
}
}
else
if
(
wsStartObj
.
mEndReason
=
=
WSType
:
:
br
)
{
int32_t
offset
=
-
1
;
newStartNode
=
EditorBase
:
:
GetNodeLocation
(
wsStartObj
.
mEndReasonNode
&
offset
)
;
newStartOffset
=
static_cast
<
uint32_t
>
(
offset
+
1
)
;
}
}
int16_t
comp
;
comp
=
nsContentUtils
:
:
ComparePoints
(
startNode
startOffset
newEndNode
newEndOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
comp
=
nsContentUtils
:
:
ComparePoints
(
newStartNode
newStartOffset
endNode
endOffset
)
;
if
(
comp
=
=
1
)
{
return
NS_OK
;
}
inSelection
-
>
Collapse
(
newStartNode
newStartOffset
)
;
inSelection
-
>
Extend
(
newEndNode
newEndOffset
)
;
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
GetPromotedPoint
(
RulesEndpoint
aWhere
nsINode
&
aNode
int32_t
aOffset
EditAction
actionID
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
&
aNode
aOffset
)
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
;
if
(
actionID
=
=
EditAction
:
:
insertText
|
|
actionID
=
=
EditAction
:
:
insertIMEText
|
|
actionID
=
=
EditAction
:
:
insertBreak
|
|
actionID
=
=
EditAction
:
:
deleteText
)
{
bool
isSpace
isNBSP
;
nsCOMPtr
<
nsIContent
>
content
=
aNode
.
IsContent
(
)
?
aNode
.
AsContent
(
)
:
nullptr
;
nsCOMPtr
<
nsIContent
>
temp
;
int32_t
newOffset
=
aOffset
;
while
(
content
)
{
int32_t
offset
;
if
(
aWhere
=
=
kStart
)
{
htmlEditor
-
>
IsPrevCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
else
{
htmlEditor
-
>
IsNextCharInNodeWhitespace
(
content
newOffset
&
isSpace
&
isNBSP
getter_AddRefs
(
temp
)
&
offset
)
;
}
if
(
isSpace
|
|
isNBSP
)
{
content
=
temp
;
newOffset
=
offset
;
}
else
{
break
;
}
}
return
EditorDOMPoint
(
content
newOffset
)
;
}
EditorDOMPoint
point
(
&
aNode
aOffset
)
;
if
(
aWhere
=
=
kStart
)
{
if
(
point
.
Container
(
)
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
!
point
.
Container
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
Container
(
)
)
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
while
(
priorNode
&
&
priorNode
-
>
GetParentNode
(
)
&
&
!
htmlEditor
-
>
IsVisibleBRElement
(
priorNode
)
&
&
!
IsBlockNode
(
*
priorNode
)
)
{
point
.
Set
(
priorNode
)
;
priorNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
while
(
!
nearNode
&
&
!
point
.
Container
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
Container
(
)
-
>
GetParentNode
(
)
)
{
if
(
actionID
=
=
EditAction
:
:
outdent
&
&
point
.
Container
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
bool
blockLevelAction
=
actionID
=
=
EditAction
:
:
indent
|
|
actionID
=
=
EditAction
:
:
outdent
|
|
actionID
=
=
EditAction
:
:
align
|
|
actionID
=
=
EditAction
:
:
makeBasicBlock
;
if
(
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
point
.
Container
(
)
-
>
GetParentNode
(
)
)
&
&
(
blockLevelAction
|
|
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
point
.
Container
(
)
)
)
)
{
break
;
}
point
.
Set
(
point
.
Container
(
)
)
;
nearNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
}
return
point
;
}
if
(
point
.
Container
(
)
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
!
point
.
Container
(
)
-
>
GetParentNode
(
)
)
{
return
point
;
}
point
.
Set
(
point
.
Container
(
)
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
text
node
"
)
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
while
(
nextNode
&
&
!
IsBlockNode
(
*
nextNode
)
&
&
nextNode
-
>
GetParentNode
(
)
)
{
point
.
Set
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
if
(
htmlEditor
-
>
IsVisibleBRElement
(
nextNode
)
)
{
break
;
}
bool
isPRE
;
htmlEditor
-
>
IsPreformatted
(
nextNode
-
>
AsDOMNode
(
)
&
isPRE
)
;
if
(
isPRE
)
{
if
(
EditorBase
:
:
IsTextNode
(
nextNode
)
)
{
nsAutoString
tempString
;
nextNode
-
>
GetAsText
(
)
-
>
GetData
(
tempString
)
;
int32_t
newlinePos
=
tempString
.
FindChar
(
nsCRT
:
:
LF
)
;
if
(
newlinePos
>
=
0
)
{
if
(
static_cast
<
uint32_t
>
(
newlinePos
)
+
1
=
=
tempString
.
Length
(
)
)
{
break
;
}
return
EditorDOMPoint
(
nextNode
newlinePos
+
1
)
;
}
}
}
nextNode
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
}
nsCOMPtr
<
nsIContent
>
nearNode
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
while
(
!
nearNode
&
&
!
point
.
Container
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
point
.
Container
(
)
-
>
GetParentNode
(
)
)
{
if
(
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
point
.
Container
(
)
)
&
&
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
point
.
Container
(
)
-
>
GetParentNode
(
)
)
)
{
break
;
}
point
.
Set
(
point
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
AdvanceOffset
(
)
)
)
{
break
;
}
nearNode
=
htmlEditor
-
>
GetNextEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
}
return
point
;
}
void
HTMLEditRules
:
:
GetPromotedRanges
(
Selection
&
aSelection
nsTArray
<
RefPtr
<
nsRange
>
>
&
outArrayOfRanges
EditAction
inOperationType
)
{
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
selectionRange
=
aSelection
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
selectionRange
)
;
RefPtr
<
nsRange
>
opRange
=
selectionRange
-
>
CloneRange
(
)
;
PromoteRange
(
*
opRange
inOperationType
)
;
outArrayOfRanges
.
AppendElement
(
opRange
)
;
}
}
void
HTMLEditRules
:
:
PromoteRange
(
nsRange
&
aRange
EditAction
aOperationType
)
{
NS_ENSURE_TRUE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
startNode
=
aRange
.
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
aRange
.
GetEndContainer
(
)
;
int32_t
startOffset
=
aRange
.
StartOffset
(
)
;
int32_t
endOffset
=
aRange
.
EndOffset
(
)
;
if
(
startNode
=
=
endNode
&
&
startOffset
=
=
endOffset
)
{
nsCOMPtr
<
Element
>
block
=
htmlEditor
-
>
GetBlock
(
*
startNode
)
;
if
(
block
)
{
bool
bIsEmptyNode
=
false
;
nsCOMPtr
<
nsIContent
>
root
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
NS_ENSURE_TRUE
(
root
)
;
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
root
block
)
)
{
htmlEditor
-
>
IsEmptyNode
(
block
&
bIsEmptyNode
true
false
)
;
}
if
(
bIsEmptyNode
)
{
startNode
=
block
;
endNode
=
block
;
startOffset
=
0
;
endOffset
=
block
-
>
Length
(
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
insertText
|
|
aOperationType
=
=
EditAction
:
:
insertIMEText
|
|
aOperationType
=
=
EditAction
:
:
insertBreak
|
|
aOperationType
=
=
EditAction
:
:
deleteText
)
{
if
(
!
startNode
-
>
IsContent
(
)
|
|
!
endNode
-
>
IsContent
(
)
)
{
return
;
}
}
EditorDOMPoint
startPoint
=
GetPromotedPoint
(
kStart
*
startNode
startOffset
aOperationType
)
;
if
(
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
startPoint
.
AsRaw
(
)
)
)
)
{
return
;
}
EditorDOMPoint
endPoint
=
GetPromotedPoint
(
kEnd
*
endNode
endOffset
aOperationType
)
;
EditorRawDOMPoint
lastRawPoint
(
endPoint
.
AsRaw
(
)
)
;
lastRawPoint
.
RewindOffset
(
)
;
if
(
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
EditorBase
:
:
GetNodeAtRangeOffsetPoint
(
lastRawPoint
)
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
aRange
.
SetStartAndEnd
(
startPoint
.
AsRaw
(
)
endPoint
.
AsRaw
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
class
UniqueFunctor
final
:
public
BoolDomIterFunctor
{
public
:
explicit
UniqueFunctor
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
)
:
mArray
(
aArray
)
{
}
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
return
!
mArray
.
Contains
(
aNode
)
;
}
private
:
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
mArray
;
}
;
nsresult
HTMLEditRules
:
:
GetNodesForOperation
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditAction
aOperationType
TouchContent
aTouchContent
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
for
(
RefPtr
<
nsRange
>
&
range
:
aArrayOfRanges
)
{
EditorDOMPoint
atEnd
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atEnd
.
IsSet
(
)
)
|
|
!
atEnd
.
Container
(
)
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
continue
;
}
if
(
!
atEnd
.
IsStartOfContainer
(
)
&
&
!
atEnd
.
IsEndOfContainer
(
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
htmlEditor
-
>
SplitNode
(
atEnd
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atContainerOfSplitNode
(
atEnd
.
Container
(
)
)
;
range
-
>
SetEnd
(
atContainerOfSplitNode
.
Container
(
)
atContainerOfSplitNode
.
Offset
(
)
)
;
}
}
}
if
(
aTouchContent
=
=
TouchContent
:
:
yes
)
{
nsTArray
<
OwningNonNull
<
RangeItem
>
>
rangeItemArray
;
rangeItemArray
.
AppendElements
(
aArrayOfRanges
.
Length
(
)
)
;
for
(
auto
&
rangeItem
:
rangeItemArray
)
{
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
aArrayOfRanges
[
0
]
)
;
htmlEditor
-
>
mRangeUpdater
.
RegisterRangeItem
(
rangeItem
)
;
aArrayOfRanges
.
RemoveElementAt
(
0
)
;
}
nsresult
rv
=
NS_OK
;
for
(
auto
&
item
:
Reversed
(
rangeItemArray
)
)
{
rv
=
BustUpInlinesAtRangeEndpoints
(
*
item
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
for
(
auto
&
item
:
rangeItemArray
)
{
htmlEditor
-
>
mRangeUpdater
.
DropRangeItem
(
item
)
;
RefPtr
<
nsRange
>
range
=
item
-
>
GetRange
(
)
;
if
(
range
)
{
aArrayOfRanges
.
AppendElement
(
range
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
auto
&
range
:
aArrayOfRanges
)
{
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
*
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
iter
.
AppendList
(
TrivialFunctor
(
)
aOutArrayOfNodes
)
;
}
else
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodes
;
iter
.
AppendList
(
UniqueFunctor
(
aOutArrayOfNodes
)
nodes
)
;
aOutArrayOfNodes
.
AppendElements
(
nodes
)
;
}
}
if
(
aOperationType
=
=
EditAction
:
:
makeBasicBlock
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsListItem
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
EditorBase
:
:
IsTextNode
(
node
)
)
{
bool
isEmpty
=
false
;
htmlEditor
-
>
IsVisTextNode
(
node
-
>
AsContent
(
)
&
isEmpty
false
)
;
if
(
isEmpty
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
}
}
}
}
else
if
(
aOperationType
=
=
EditAction
:
:
outdent
|
|
aOperationType
=
=
EditAction
:
:
indent
|
|
aOperationType
=
=
EditAction
:
:
setAbsolutePosition
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
node
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
outdent
&
&
!
htmlEditor
-
>
IsCSSEnabled
(
)
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
node
aOutArrayOfNodes
&
j
Lists
:
:
no
Tables
:
:
no
)
;
}
}
}
if
(
aOperationType
=
=
EditAction
:
:
makeBasicBlock
|
|
aOperationType
=
=
EditAction
:
:
makeList
|
|
aOperationType
=
=
EditAction
:
:
align
|
|
aOperationType
=
=
EditAction
:
:
setAbsolutePosition
|
|
aOperationType
=
=
EditAction
:
:
indent
|
|
aOperationType
=
=
EditAction
:
:
outdent
)
{
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
node
=
aOutArrayOfNodes
[
i
]
;
if
(
aTouchContent
=
=
TouchContent
:
:
yes
&
&
IsInlineNode
(
node
)
&
&
htmlEditor
-
>
IsContainer
(
node
)
&
&
!
EditorBase
:
:
IsTextNode
(
node
)
)
{
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfInlines
;
nsresult
rv
=
BustUpInlinesAtBRs
(
*
node
-
>
AsContent
(
)
arrayOfInlines
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
aOutArrayOfNodes
.
InsertElementsAt
(
i
arrayOfInlines
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
GetChildNodesForOperation
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
{
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
outArrayOfNodes
.
AppendElement
(
*
child
)
;
}
}
nsresult
HTMLEditRules
:
:
GetListActionNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EntireList
aEntireList
TouchContent
aTouchContent
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
aEntireList
=
=
EntireList
:
:
yes
)
{
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
rangeIdx
)
;
for
(
nsCOMPtr
<
nsINode
>
parent
=
range
-
>
GetCommonAncestor
(
)
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
if
(
HTMLEditUtils
:
:
IsList
(
parent
)
)
{
aOutArrayOfNodes
.
AppendElement
(
*
parent
)
;
break
;
}
}
}
if
(
!
aOutArrayOfNodes
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
}
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
htmlEditor
)
;
nsresult
rv
=
GetNodesFromSelection
(
*
selection
EditAction
:
:
makeList
aOutArrayOfNodes
aTouchContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
int32_t
i
=
aOutArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
aOutArrayOfNodes
[
i
]
;
if
(
!
htmlEditor
-
>
IsEditable
(
testNode
)
)
{
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
testNode
)
)
{
int32_t
j
=
i
;
aOutArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
*
testNode
aOutArrayOfNodes
&
j
Lists
:
:
no
)
;
}
}
LookInsideDivBQandList
(
aOutArrayOfNodes
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
LookInsideDivBQandList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
NS_ENSURE_TRUE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
aNodeArray
.
Length
(
)
!
=
1
)
{
return
;
}
OwningNonNull
<
nsINode
>
curNode
=
aNodeArray
[
0
]
;
while
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
uint32_t
numChildren
=
htmlEditor
-
>
CountEditableChildren
(
curNode
)
;
if
(
numChildren
!
=
1
)
{
break
;
}
nsCOMPtr
<
nsIContent
>
child
=
curNode
-
>
GetFirstChild
(
)
;
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
!
HTMLEditUtils
:
:
IsList
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
break
;
}
curNode
=
child
;
}
aNodeArray
.
RemoveElementAt
(
0
)
;
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
div
nsGkAtoms
:
:
blockquote
)
)
{
int32_t
j
=
0
;
GetInnerContent
(
*
curNode
aNodeArray
&
j
Lists
:
:
no
Tables
:
:
no
)
;
return
;
}
aNodeArray
.
AppendElement
(
*
curNode
)
;
}
void
HTMLEditRules
:
:
GetDefinitionListItemTypes
(
dom
:
:
Element
*
aElement
bool
*
aDT
bool
*
aDD
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
;
MOZ_ASSERT
(
aDT
)
;
MOZ_ASSERT
(
aDD
)
;
*
aDT
=
*
aDD
=
false
;
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
*
aDT
=
true
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
*
aDD
=
true
;
}
}
}
nsresult
HTMLEditRules
:
:
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
nsresult
rv
=
GetNodesFromSelection
(
*
selection
EditAction
:
:
makeBasicBlock
outArrayOfNodes
aTouchContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
int32_t
i
=
outArrayOfNodes
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsINode
>
testNode
=
outArrayOfNodes
[
i
]
;
if
(
!
htmlEditor
-
>
IsEditable
(
testNode
)
)
{
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
testNode
)
|
|
HTMLEditUtils
:
:
IsList
(
testNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
testNode
)
)
{
int32_t
j
=
i
;
outArrayOfNodes
.
RemoveElementAt
(
i
)
;
GetInnerContent
(
testNode
outArrayOfNodes
&
j
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtRangeEndpoints
(
RangeItem
&
item
)
{
bool
isCollapsed
=
item
.
mStartContainer
=
=
item
.
mEndContainer
&
&
item
.
mStartOffset
=
=
item
.
mEndOffset
;
nsCOMPtr
<
nsIContent
>
endInline
=
GetHighestInlineParent
(
*
item
.
mEndContainer
)
;
if
(
endInline
&
&
!
isCollapsed
)
{
nsCOMPtr
<
nsINode
>
resultEndNode
=
endInline
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
int32_t
resultEndOffset
=
mHTMLEditor
-
>
SplitNodeDeep
(
*
endInline
*
item
.
mEndContainer
-
>
AsContent
(
)
item
.
mEndOffset
EditorBase
:
:
EmptyContainers
:
:
no
)
;
NS_ENSURE_TRUE
(
resultEndOffset
!
=
-
1
NS_ERROR_FAILURE
)
;
item
.
mEndContainer
=
resultEndNode
;
item
.
mEndOffset
=
resultEndOffset
;
}
nsCOMPtr
<
nsIContent
>
startInline
=
GetHighestInlineParent
(
*
item
.
mStartContainer
)
;
if
(
startInline
)
{
nsCOMPtr
<
nsINode
>
resultStartNode
=
startInline
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
int32_t
resultStartOffset
=
mHTMLEditor
-
>
SplitNodeDeep
(
*
startInline
*
item
.
mStartContainer
-
>
AsContent
(
)
item
.
mStartOffset
EditorBase
:
:
EmptyContainers
:
:
no
)
;
NS_ENSURE_TRUE
(
resultStartOffset
!
=
-
1
NS_ERROR_FAILURE
)
;
item
.
mStartContainer
=
resultStartNode
;
item
.
mStartOffset
=
resultStartOffset
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
BustUpInlinesAtBRs
(
nsIContent
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfBreaks
;
BRNodeFunctor
functor
;
DOMIterator
iter
(
aNode
)
;
iter
.
AppendList
(
functor
arrayOfBreaks
)
;
if
(
arrayOfBreaks
.
IsEmpty
(
)
)
{
aOutArrayOfNodes
.
AppendElement
(
aNode
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
inlineParentNode
=
aNode
.
GetParentNode
(
)
;
nsCOMPtr
<
nsIContent
>
splitDeepNode
=
&
aNode
;
nsCOMPtr
<
nsIContent
>
leftNode
rightNode
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfBreaks
.
Length
(
)
;
i
+
+
)
{
OwningNonNull
<
Element
>
breakNode
=
*
arrayOfBreaks
[
i
]
-
>
AsElement
(
)
;
NS_ENSURE_TRUE
(
splitDeepNode
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
breakNode
-
>
GetParent
(
)
NS_ERROR_NULL_POINTER
)
;
OwningNonNull
<
nsIContent
>
splitParentNode
=
*
breakNode
-
>
GetParent
(
)
;
int32_t
splitOffset
=
splitParentNode
-
>
IndexOf
(
breakNode
)
;
int32_t
resultOffset
=
htmlEditor
-
>
SplitNodeDeep
(
*
splitDeepNode
splitParentNode
splitOffset
HTMLEditor
:
:
EmptyContainers
:
:
yes
getter_AddRefs
(
leftNode
)
getter_AddRefs
(
rightNode
)
)
;
NS_ENSURE_STATE
(
resultOffset
!
=
-
1
)
;
if
(
leftNode
)
{
aOutArrayOfNodes
.
AppendElement
(
*
leftNode
)
;
}
nsresult
rv
=
htmlEditor
-
>
MoveNode
(
breakNode
inlineParentNode
resultOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOutArrayOfNodes
.
AppendElement
(
*
breakNode
)
;
splitDeepNode
=
rightNode
;
}
if
(
rightNode
)
{
aOutArrayOfNodes
.
AppendElement
(
*
rightNode
)
;
}
return
NS_OK
;
}
nsIContent
*
HTMLEditRules
:
:
GetHighestInlineParent
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsContent
(
)
|
|
IsBlockNode
(
aNode
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
nullptr
;
}
Element
*
host
=
mHTMLEditor
-
>
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
host
)
)
{
return
nullptr
;
}
if
(
&
aNode
=
=
host
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
aNode
*
host
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
.
AsContent
(
)
;
for
(
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
parent
&
&
parent
!
=
host
&
&
IsInlineNode
(
*
parent
)
;
parent
=
parent
-
>
GetParent
(
)
)
{
content
=
parent
;
}
return
content
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromPoint
(
const
EditorDOMPoint
&
aPoint
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aPoint
.
Container
(
)
)
;
DebugOnly
<
nsresult
>
rv
=
range
-
>
SetStart
(
aPoint
.
Container
(
)
aPoint
.
Offset
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
PromoteRange
(
*
range
aOperation
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
arrayOfRanges
.
AppendElement
(
range
)
;
nsresult
rv2
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aOperation
aTouchContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
)
{
return
rv2
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetNodesFromSelection
(
Selection
&
aSelection
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
{
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
aSelection
arrayOfRanges
aOperation
)
;
nsresult
rv
=
GetNodesForOperation
(
arrayOfRanges
outArrayOfNodes
aOperation
aTouchContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
MakeTransitionList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
{
nsCOMPtr
<
nsINode
>
prevParent
;
aTransitionArray
.
EnsureLengthAtLeast
(
aNodeArray
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aNodeArray
.
Length
(
)
;
i
+
+
)
{
if
(
aNodeArray
[
i
]
-
>
GetParentNode
(
)
!
=
prevParent
)
{
aTransitionArray
[
i
]
=
true
;
}
else
{
aTransitionArray
[
i
]
=
false
;
}
prevParent
=
aNodeArray
[
i
]
-
>
GetParentNode
(
)
;
}
}
Element
*
HTMLEditRules
:
:
IsInListItem
(
nsINode
*
aNode
)
{
NS_ENSURE_TRUE
(
aNode
nullptr
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
)
{
return
aNode
-
>
AsElement
(
)
;
}
Element
*
parent
=
aNode
-
>
GetParentElement
(
)
;
while
(
parent
&
&
mHTMLEditor
&
&
mHTMLEditor
-
>
IsDescendantOfEditorRoot
(
parent
)
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
parent
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
parent
)
)
{
return
parent
;
}
parent
=
parent
-
>
GetParentElement
(
)
;
}
return
nullptr
;
}
nsAtom
&
HTMLEditRules
:
:
DefaultParagraphSeparator
(
)
{
MOZ_ASSERT
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
)
{
return
*
nsGkAtoms
:
:
div
;
}
return
ParagraphSeparatorElement
(
mHTMLEditor
-
>
GetDefaultParagraphSeparator
(
)
)
;
}
nsresult
HTMLEditRules
:
:
ReturnInHeader
(
Selection
&
aSelection
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
nsINode
>
headerParent
=
aHeader
.
GetParentNode
(
)
;
int32_t
offset
=
headerParent
?
headerParent
-
>
IndexOf
(
&
aHeader
)
:
-
1
;
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
htmlEditor
address_of
(
node
)
&
aOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
node
-
>
IsContent
(
)
)
;
htmlEditor
-
>
SplitNodeDeep
(
aHeader
*
node
-
>
AsContent
(
)
aOffset
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
htmlEditor
-
>
GetPriorHTMLSibling
(
&
aHeader
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsHeader
(
*
prevItem
)
)
{
bool
isEmptyNode
;
rv
=
htmlEditor
-
>
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isEmptyNode
)
{
rv
=
CreateMozBR
(
prevItem
-
>
AsDOMNode
(
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
bool
isEmpty
;
rv
=
IsEmptyBlock
(
aHeader
&
isEmpty
MozBRCounts
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isEmpty
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
&
aHeader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContent
>
sibling
;
if
(
aHeader
.
GetNextSibling
(
)
)
{
sibling
=
htmlEditor
-
>
GetNextHTMLSibling
(
aHeader
.
GetNextSibling
(
)
)
;
}
if
(
!
sibling
|
|
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
ClearCachedStyles
(
)
;
htmlEditor
-
>
mTypeInState
-
>
ClearAllProps
(
)
;
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
EditorRawDOMPoint
nextToHeader
(
headerParent
offset
+
1
)
;
RefPtr
<
Element
>
pNode
=
htmlEditor
-
>
CreateNode
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
nsGkAtoms
:
:
p
:
&
paraAtom
nextToHeader
)
;
NS_ENSURE_STATE
(
pNode
)
;
nsCOMPtr
<
Element
>
brNode
=
htmlEditor
-
>
CreateBR
(
pNode
0
)
;
NS_ENSURE_STATE
(
brNode
)
;
rv
=
aSelection
.
Collapse
(
pNode
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
EditorRawDOMPoint
afterSibling
(
sibling
)
;
if
(
NS_WARN_IF
(
!
afterSibling
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
.
Collapse
(
afterSibling
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
rv
=
aSelection
.
Collapse
(
&
aHeader
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
EditActionResult
HTMLEditRules
:
:
ReturnInParagraph
(
Selection
&
aSelection
Element
&
aParentDivOrP
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditActionResult
(
NS_ERROR_NOT_AVAILABLE
)
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
;
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
bool
doesCRCreateNewP
=
htmlEditor
-
>
GetReturnInParagraphCreatesNewParagraph
(
)
;
bool
splitAfterNewBR
=
false
;
nsCOMPtr
<
nsIContent
>
brNode
;
EditorDOMPoint
pointToSplitParentDivOrP
(
atStartOfSelection
)
;
EditorRawDOMPoint
pointToInsertBR
;
if
(
doesCRCreateNewP
&
&
atStartOfSelection
.
Container
(
)
=
=
&
aParentDivOrP
)
{
brNode
=
nullptr
;
}
else
if
(
EditorBase
:
:
IsTextNode
(
atStartOfSelection
.
Container
(
)
)
)
{
if
(
atStartOfSelection
.
IsStartOfContainer
(
)
)
{
brNode
=
htmlEditor
-
>
GetPriorHTMLSibling
(
atStartOfSelection
.
Container
(
)
)
;
if
(
!
brNode
|
|
!
htmlEditor
-
>
IsVisibleBRElement
(
brNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
GetAsDOMNode
(
brNode
)
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
Container
(
)
)
;
brNode
=
nullptr
;
}
}
else
if
(
atStartOfSelection
.
IsEndOfContainer
(
)
)
{
brNode
=
htmlEditor
-
>
GetNextHTMLSibling
(
atStartOfSelection
.
Container
(
)
)
;
if
(
!
brNode
|
|
!
htmlEditor
-
>
IsVisibleBRElement
(
brNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
GetAsDOMNode
(
brNode
)
)
)
{
pointToInsertBR
.
Set
(
atStartOfSelection
.
Container
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
brNode
=
nullptr
;
}
}
else
{
if
(
doesCRCreateNewP
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftDivOrP
=
htmlEditor
-
>
SplitNode
(
pointToSplitParentDivOrP
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
EditActionResult
(
error
.
StealNSResult
(
)
)
;
}
pointToSplitParentDivOrP
.
Set
(
newLeftDivOrP
newLeftDivOrP
-
>
Length
(
)
)
;
}
pointToInsertBR
.
Set
(
pointToSplitParentDivOrP
.
Container
(
)
)
;
DebugOnly
<
bool
>
advanced
=
pointToInsertBR
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
container
of
selection
start
"
)
;
}
}
else
{
nsCOMPtr
<
nsIContent
>
nearNode
;
nearNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNode
(
atStartOfSelection
.
AsRaw
(
)
)
;
if
(
!
nearNode
|
|
!
htmlEditor
-
>
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
GetAsDOMNode
(
nearNode
)
)
)
{
nearNode
=
htmlEditor
-
>
GetNextEditableHTMLNode
(
atStartOfSelection
.
AsRaw
(
)
)
;
if
(
!
nearNode
|
|
!
htmlEditor
-
>
IsVisibleBRElement
(
nearNode
)
|
|
TextEditUtils
:
:
HasMozAttr
(
GetAsDOMNode
(
nearNode
)
)
)
{
pointToInsertBR
=
atStartOfSelection
;
splitAfterNewBR
=
true
;
}
}
if
(
!
pointToInsertBR
.
IsSet
(
)
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
brNode
=
nearNode
;
}
}
if
(
pointToInsertBR
.
IsSet
(
)
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditActionResult
(
NS_ERROR_NOT_AVAILABLE
)
;
}
if
(
NS_WARN_IF
(
!
doesCRCreateNewP
)
)
{
return
EditActionResult
(
NS_OK
)
;
}
brNode
=
htmlEditor
-
>
CreateBR
(
pointToInsertBR
.
Container
(
)
pointToInsertBR
.
Offset
(
)
)
;
if
(
splitAfterNewBR
)
{
pointToSplitParentDivOrP
.
Set
(
brNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToSplitParentDivOrP
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
new
<
br
>
"
)
;
}
}
EditActionResult
result
(
SplitParagraph
(
aSelection
aParentDivOrP
pointToSplitParentDivOrP
.
AsRaw
(
)
brNode
)
)
;
result
.
MarkAsHandled
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
;
}
return
result
;
}
nsresult
HTMLEditRules
:
:
SplitParagraph
(
Selection
&
aSelection
Element
&
aParentDivOrP
const
EditorRawDOMPoint
&
aStartOfRightNode
nsIContent
*
aNextBRNode
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
;
nsCOMPtr
<
nsIContent
>
leftPara
rightPara
;
nsCOMPtr
<
nsINode
>
selNode
=
aStartOfRightNode
.
Container
(
)
;
int32_t
selOffset
=
aStartOfRightNode
.
Offset
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
htmlEditor
address_of
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
selNode
-
>
IsContent
(
)
)
;
int32_t
offset
=
htmlEditor
-
>
SplitNodeDeep
(
aParentDivOrP
*
selNode
-
>
AsContent
(
)
selOffset
HTMLEditor
:
:
EmptyContainers
:
:
yes
getter_AddRefs
(
leftPara
)
getter_AddRefs
(
rightPara
)
)
;
if
(
NS_WARN_IF
(
offset
=
=
-
1
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNextBRNode
&
&
htmlEditor
-
>
IsVisibleBRElement
(
aNextBRNode
)
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
aNextBRNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
htmlEditor
-
>
RemoveAttribute
(
rightPara
-
>
AsElement
(
)
nsGkAtoms
:
:
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InsertBRIfNeeded
(
*
leftPara
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InsertBRIfNeeded
(
*
rightPara
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIContent
*
child
=
htmlEditor
-
>
GetLeftmostChild
(
rightPara
true
)
;
if
(
EditorBase
:
:
IsTextNode
(
child
)
|
|
htmlEditor
-
>
IsContainer
(
child
)
)
{
aSelection
.
Collapse
(
child
0
)
;
}
else
{
EditorRawDOMPoint
atChild
(
child
)
;
aSelection
.
Collapse
(
atChild
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReturnInListItem
(
Selection
&
aSelection
Element
&
aListItem
nsINode
&
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
root
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
bool
isEmpty
;
nsresult
rv
=
IsEmptyBlock
(
aListItem
&
isEmpty
MozBRCounts
:
:
no
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isEmpty
&
&
root
!
=
aListItem
.
GetParentElement
(
)
&
&
mReturnInEmptyLIKillsList
)
{
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
htmlEditor
-
>
IsLastEditableChild
(
&
aListItem
)
)
{
EditorRawDOMPoint
atListItem
(
&
aListItem
)
;
ErrorResult
error
;
leftListNode
=
htmlEditor
-
>
SplitNode
(
atListItem
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
EditorRawDOMPoint
atNextSiblingOfLeftList
(
leftListNode
)
;
DebugOnly
<
bool
>
advanced
=
atNextSiblingOfLeftList
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
right
list
node
"
)
;
if
(
HTMLEditUtils
:
:
IsList
(
atNextSiblingOfLeftList
.
Container
(
)
)
)
{
rv
=
htmlEditor
-
>
MoveNode
(
&
aListItem
atNextSiblingOfLeftList
.
Container
(
)
atNextSiblingOfLeftList
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aSelection
.
Collapse
(
&
aListItem
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
htmlEditor
-
>
DeleteNode
(
&
aListItem
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAtom
&
paraAtom
=
DefaultParagraphSeparator
(
)
;
RefPtr
<
Element
>
pNode
=
htmlEditor
-
>
CreateNode
(
&
paraAtom
=
=
nsGkAtoms
:
:
br
?
nsGkAtoms
:
:
p
:
&
paraAtom
atNextSiblingOfLeftList
)
;
NS_ENSURE_STATE
(
pNode
)
;
nsCOMPtr
<
Element
>
brNode
=
htmlEditor
-
>
CreateBR
(
pNode
0
)
;
NS_ENSURE_STATE
(
brNode
)
;
rv
=
aSelection
.
Collapse
(
pNode
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
selNode
=
&
aNode
;
rv
=
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
htmlEditor
address_of
(
selNode
)
&
aOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
selNode
-
>
IsContent
(
)
)
;
htmlEditor
-
>
SplitNodeDeep
(
aListItem
*
selNode
-
>
AsContent
(
)
aOffset
)
;
nsCOMPtr
<
nsIContent
>
prevItem
=
htmlEditor
-
>
GetPriorHTMLSibling
(
&
aListItem
)
;
if
(
prevItem
&
&
HTMLEditUtils
:
:
IsListItem
(
prevItem
)
)
{
bool
isEmptyNode
;
rv
=
htmlEditor
-
>
IsEmptyNode
(
prevItem
&
isEmptyNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isEmptyNode
)
{
rv
=
CreateMozBR
(
prevItem
-
>
AsDOMNode
(
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
htmlEditor
-
>
IsEmptyNode
(
&
aListItem
&
isEmptyNode
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isEmptyNode
)
{
RefPtr
<
nsAtom
>
nodeAtom
=
aListItem
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
nodeAtom
=
=
nsGkAtoms
:
:
dd
|
|
nodeAtom
=
=
nsGkAtoms
:
:
dt
)
{
nsCOMPtr
<
nsINode
>
list
=
aListItem
.
GetParentNode
(
)
;
int32_t
itemOffset
=
list
?
list
-
>
IndexOf
(
&
aListItem
)
:
-
1
;
nsAtom
*
listAtom
=
nodeAtom
=
=
nsGkAtoms
:
:
dt
?
nsGkAtoms
:
:
dd
:
nsGkAtoms
:
:
dt
;
MOZ_DIAGNOSTIC_ASSERT
(
itemOffset
!
=
-
1
)
;
EditorRawDOMPoint
atNextListItem
(
list
aListItem
.
GetNextSibling
(
)
itemOffset
+
1
)
;
RefPtr
<
Element
>
newListItem
=
htmlEditor
-
>
CreateNode
(
listAtom
atNextListItem
)
;
NS_ENSURE_STATE
(
newListItem
)
;
rv
=
htmlEditor
-
>
DeleteNode
(
&
aListItem
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aSelection
.
Collapse
(
newListItem
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
brNode
;
rv
=
htmlEditor
-
>
CopyLastEditableChildStyles
(
prevItem
&
aListItem
getter_AddRefs
(
brNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
brNode
)
{
EditorRawDOMPoint
atBrNode
(
brNode
)
;
if
(
NS_WARN_IF
(
!
atBrNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
.
Collapse
(
atBrNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
}
else
{
WSRunObject
wsObj
(
htmlEditor
&
aListItem
0
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
visOffset
=
0
;
WSType
wsType
;
wsObj
.
NextVisibleNode
(
&
aListItem
0
address_of
(
visNode
)
&
visOffset
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
special
|
|
wsType
=
=
WSType
:
:
br
|
|
visNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
EditorRawDOMPoint
atVisNode
(
visNode
)
;
if
(
NS_WARN_IF
(
!
atVisNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aSelection
.
Collapse
(
atVisNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
else
{
rv
=
aSelection
.
Collapse
(
visNode
visOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
}
}
}
rv
=
aSelection
.
Collapse
(
&
aListItem
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeBlockquote
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsINode
>
prevParent
;
for
(
auto
&
curNode
:
aNodeArray
)
{
NS_ENSURE_STATE
(
curNode
-
>
IsContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsTableElementButNotTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsListItem
(
curNode
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
MakeBlockquote
(
childArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
prevParent
)
{
if
(
prevParent
!
=
curNode
-
>
GetParentNode
(
)
)
{
curBlock
=
nullptr
;
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
}
else
{
prevParent
=
curNode
-
>
GetParentNode
(
)
;
}
if
(
!
curBlock
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
curParent
?
curParent
-
>
IndexOf
(
curNode
)
:
-
1
;
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
-
>
AsContent
(
)
)
;
nsresult
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
blockquote
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curBlock
=
mHTMLEditor
-
>
CreateNode
(
nsGkAtoms
:
:
blockquote
atCurChild
)
;
NS_ENSURE_STATE
(
curBlock
)
;
mNewBlock
=
curBlock
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
MoveNode
(
curNode
-
>
AsContent
(
)
curBlock
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
curBlock
;
nsCOMPtr
<
nsIContent
>
firstNode
lastNode
;
for
(
auto
&
curNode
:
aNodeArray
)
{
if
(
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
mHTMLEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
nsresult
rv
=
htmlEditor
-
>
RemoveBlockContainer
(
*
curNode
-
>
AsContent
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
)
{
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
if
(
!
mHTMLEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
nsresult
rv
=
RemoveBlockStyle
(
childArray
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
IsInlineNode
(
curNode
)
)
{
if
(
curBlock
)
{
if
(
EditorUtils
:
:
IsDescendantOf
(
*
curNode
*
curBlock
)
)
{
lastNode
=
curNode
-
>
AsContent
(
)
;
continue
;
}
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
curBlock
=
htmlEditor
-
>
GetBlockNodeParent
(
curNode
)
;
if
(
!
curBlock
|
|
!
HTMLEditUtils
:
:
IsFormatNode
(
curBlock
)
|
|
!
mHTMLEditor
-
>
IsEditable
(
curBlock
)
)
{
curBlock
=
nullptr
;
}
else
{
firstNode
=
lastNode
=
curNode
-
>
AsContent
(
)
;
}
}
else
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
}
if
(
curBlock
)
{
nsresult
rv
=
RemovePartOfBlock
(
*
curBlock
*
firstNode
*
lastNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
firstNode
=
lastNode
=
curBlock
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ApplyBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
newBlock
;
nsCOMPtr
<
Element
>
curBlock
;
for
(
auto
&
curNode
:
aNodeArray
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
curParent
?
curParent
-
>
IndexOf
(
curNode
)
:
-
1
;
if
(
curNode
-
>
IsHTMLElement
(
&
aBlockTag
)
|
|
(
!
mHTMLEditor
-
>
IsEditable
(
curNode
)
&
&
IsBlockNode
(
curNode
)
)
)
{
curBlock
=
nullptr
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsMozDiv
(
curNode
)
|
|
HTMLEditUtils
:
:
IsFormatNode
(
curNode
)
)
{
curBlock
=
nullptr
;
newBlock
=
htmlEditor
-
>
ReplaceContainer
(
curNode
-
>
AsElement
(
)
&
aBlockTag
nullptr
nullptr
EditorBase
:
:
eCloneAttributes
)
;
NS_ENSURE_STATE
(
newBlock
)
;
}
else
if
(
HTMLEditUtils
:
:
IsTable
(
curNode
)
|
|
HTMLEditUtils
:
:
IsList
(
curNode
)
|
|
curNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
li
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
div
)
)
{
curBlock
=
nullptr
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
childArray
;
GetChildNodesForOperation
(
*
curNode
childArray
)
;
if
(
!
childArray
.
IsEmpty
(
)
)
{
nsresult
rv
=
ApplyBlockStyle
(
childArray
aBlockTag
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
-
>
AsContent
(
)
)
;
nsresult
rv
=
SplitAsNeeded
(
aBlockTag
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
RefPtr
<
Element
>
theBlock
=
htmlEditor
-
>
CreateNode
(
&
aBlockTag
atCurChild
)
;
NS_ENSURE_STATE
(
theBlock
)
;
mNewBlock
=
theBlock
;
}
}
else
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
curBlock
)
{
curBlock
=
nullptr
;
nsresult
rv
=
htmlEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
-
>
AsContent
(
)
)
;
nsresult
rv
=
SplitAsNeeded
(
aBlockTag
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curBlock
=
htmlEditor
-
>
CreateNode
(
&
aBlockTag
atCurChild
)
;
NS_ENSURE_STATE
(
curBlock
)
;
mNewBlock
=
curBlock
;
rv
=
htmlEditor
-
>
MoveNode
(
curNode
-
>
AsContent
(
)
curBlock
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
if
(
IsInlineNode
(
curNode
)
)
{
if
(
&
aBlockTag
=
=
nsGkAtoms
:
:
pre
&
&
!
htmlEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
if
(
!
curBlock
)
{
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
-
>
AsContent
(
)
)
;
nsresult
rv
=
SplitAsNeeded
(
aBlockTag
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curBlock
=
htmlEditor
-
>
CreateNode
(
&
aBlockTag
atCurChild
)
;
NS_ENSURE_STATE
(
curBlock
)
;
mNewBlock
=
curBlock
;
}
if
(
NS_WARN_IF
(
!
curNode
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
htmlEditor
-
>
MoveNode
(
curNode
-
>
AsContent
(
)
curBlock
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SplitAsNeeded
(
nsAtom
&
aTag
OwningNonNull
<
nsINode
>
&
aInOutParent
int32_t
&
inOutOffset
nsCOMPtr
<
nsIContent
>
*
inOutChildAtOffset
)
{
nsCOMPtr
<
nsINode
>
parent
=
aInOutParent
.
forget
(
)
;
nsresult
rv
=
SplitAsNeeded
(
aTag
parent
inOutOffset
inOutChildAtOffset
)
;
aInOutParent
=
parent
.
forget
(
)
;
return
rv
;
}
nsresult
HTMLEditRules
:
:
SplitAsNeeded
(
nsAtom
&
aTag
nsCOMPtr
<
nsINode
>
&
inOutParent
int32_t
&
inOutOffset
nsCOMPtr
<
nsIContent
>
*
inOutChildAtOffset
)
{
NS_ENSURE_TRUE
(
inOutParent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
tagParent
splitNode
;
for
(
nsCOMPtr
<
nsINode
>
parent
=
inOutParent
;
parent
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsDescendantOfEditorRoot
(
parent
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
parent
!
=
mHTMLEditor
-
>
GetActiveEditingHost
(
)
)
{
return
NS_ERROR_FAILURE
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
mHTMLEditor
-
>
CanContainTag
(
*
parent
aTag
)
)
{
tagParent
=
parent
;
break
;
}
splitNode
=
parent
;
}
if
(
!
tagParent
)
{
return
NS_ERROR_FAILURE
;
}
if
(
splitNode
&
&
splitNode
-
>
IsContent
(
)
&
&
inOutParent
-
>
IsContent
(
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
int32_t
offset
=
mHTMLEditor
-
>
SplitNodeDeep
(
*
splitNode
-
>
AsContent
(
)
*
inOutParent
-
>
AsContent
(
)
inOutOffset
EditorBase
:
:
EmptyContainers
:
:
yes
nullptr
nullptr
inOutChildAtOffset
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
inOutParent
=
tagParent
;
inOutOffset
=
offset
;
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditRules
:
:
JoinNodesSmart
(
nsIContent
&
aNodeLeft
nsIContent
&
aNodeRight
)
{
nsCOMPtr
<
nsINode
>
parent
=
aNodeLeft
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
EditorDOMPoint
(
)
;
}
int32_t
parOffset
=
parent
-
>
IndexOf
(
&
aNodeLeft
)
;
nsCOMPtr
<
nsINode
>
rightParent
=
aNodeRight
.
GetParentNode
(
)
;
if
(
parent
!
=
rightParent
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
nsresult
rv
=
mHTMLEditor
-
>
MoveNode
(
&
aNodeRight
parent
parOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
}
EditorDOMPoint
ret
(
&
aNodeRight
aNodeLeft
.
Length
(
)
)
;
if
(
HTMLEditUtils
:
:
IsList
(
&
aNodeLeft
)
|
|
aNodeLeft
.
GetAsText
(
)
)
{
nsresult
rv
=
mHTMLEditor
-
>
JoinNodes
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
return
ret
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
nsCOMPtr
<
nsIContent
>
lastLeft
=
mHTMLEditor
-
>
GetLastEditableChild
(
aNodeLeft
)
;
if
(
NS_WARN_IF
(
!
lastLeft
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
nsCOMPtr
<
nsIContent
>
firstRight
=
mHTMLEditor
-
>
GetFirstEditableChild
(
aNodeRight
)
;
if
(
NS_WARN_IF
(
!
firstRight
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
nsresult
rv
=
mHTMLEditor
-
>
JoinNodes
(
aNodeLeft
aNodeRight
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
lastLeft
&
&
firstRight
&
&
mHTMLEditor
&
&
mHTMLEditor
-
>
AreNodesSameType
(
lastLeft
firstRight
)
&
&
(
lastLeft
-
>
GetAsText
(
)
|
|
!
mHTMLEditor
|
|
(
lastLeft
-
>
IsElement
(
)
&
&
firstRight
-
>
IsElement
(
)
&
&
mHTMLEditor
-
>
mCSSEditUtils
-
>
ElementsSameStyle
(
lastLeft
-
>
AsElement
(
)
firstRight
-
>
AsElement
(
)
)
)
)
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
EditorDOMPoint
(
)
;
}
return
JoinNodesSmart
(
*
lastLeft
*
firstRight
)
;
}
return
ret
;
}
Element
*
HTMLEditRules
:
:
GetTopEnclosingMailCite
(
nsINode
&
aNode
)
{
nsCOMPtr
<
Element
>
ret
;
for
(
nsCOMPtr
<
nsINode
>
node
=
&
aNode
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
(
IsPlaintextEditor
(
)
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
|
|
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
{
ret
=
node
-
>
AsElement
(
)
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
ret
;
}
nsresult
HTMLEditRules
:
:
CacheInlineStyles
(
nsINode
*
aNode
)
{
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
GetInlineStyles
(
aNode
mCachedStyles
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
GetInlineStyles
(
nsINode
*
aNode
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
mHTMLEditor
)
;
bool
useCSS
=
mHTMLEditor
-
>
IsCSSEnabled
(
)
;
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
+
+
j
)
{
bool
typeInSet
unused
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mHTMLEditor
-
>
mTypeInState
-
>
GetTypingState
(
typeInSet
unused
aStyleCache
[
j
]
.
tag
aStyleCache
[
j
]
.
attr
nullptr
)
;
if
(
typeInSet
)
{
continue
;
}
bool
isSet
=
false
;
nsAutoString
outValue
;
if
(
!
useCSS
|
|
(
aStyleCache
[
j
]
.
tag
=
=
nsGkAtoms
:
:
font
&
&
aStyleCache
[
j
]
.
attr
.
EqualsLiteral
(
"
size
"
)
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
isSet
=
mHTMLEditor
-
>
IsTextPropertySetByContent
(
aNode
aStyleCache
[
j
]
.
tag
&
(
aStyleCache
[
j
]
.
attr
)
nullptr
&
outValue
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
isSet
=
mHTMLEditor
-
>
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
aNode
aStyleCache
[
j
]
.
tag
&
(
aStyleCache
[
j
]
.
attr
)
outValue
CSSEditUtils
:
:
eComputed
)
;
}
if
(
isSet
)
{
aStyleCache
[
j
]
.
mPresent
=
true
;
aStyleCache
[
j
]
.
value
.
Assign
(
outValue
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ReapplyCachedStyles
(
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
bool
useCSS
=
mHTMLEditor
-
>
IsCSSEnabled
(
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
NS_OK
;
}
if
(
!
selection
-
>
RangeCount
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
selNode
=
do_QueryInterface
(
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
if
(
!
selNode
)
{
return
NS_OK
;
}
StyleCache
styleAtInsertionPoint
[
SIZE_STYLE_TABLE
]
;
InitStyleCacheArray
(
styleAtInsertionPoint
)
;
nsresult
rv
=
GetInlineStyles
(
selNode
styleAtInsertionPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
SIZE_STYLE_TABLE
;
+
+
i
)
{
if
(
mCachedStyles
[
i
]
.
mPresent
)
{
bool
bFirst
bAny
bAll
;
bFirst
=
bAny
=
bAll
=
false
;
nsAutoString
curValue
;
if
(
useCSS
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
bAny
=
mHTMLEditor
-
>
mCSSEditUtils
-
>
IsCSSEquivalentToHTMLInlineStyleSet
(
selNode
mCachedStyles
[
i
]
.
tag
&
(
mCachedStyles
[
i
]
.
attr
)
curValue
CSSEditUtils
:
:
eComputed
)
;
}
if
(
!
bAny
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
GetInlinePropertyBase
(
*
mCachedStyles
[
i
]
.
tag
&
(
mCachedStyles
[
i
]
.
attr
)
&
(
mCachedStyles
[
i
]
.
value
)
&
bFirst
&
bAny
&
bAll
&
curValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
(
!
bAny
|
|
IsStyleCachePreservingAction
(
mTheAction
)
)
&
&
(
!
styleAtInsertionPoint
[
i
]
.
mPresent
|
|
styleAtInsertionPoint
[
i
]
.
value
!
=
mCachedStyles
[
i
]
.
value
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
mHTMLEditor
-
>
mTypeInState
-
>
SetProp
(
mCachedStyles
[
i
]
.
tag
mCachedStyles
[
i
]
.
attr
mCachedStyles
[
i
]
.
value
)
;
}
}
}
return
NS_OK
;
}
void
HTMLEditRules
:
:
ClearCachedStyles
(
)
{
for
(
size_t
j
=
0
;
j
<
SIZE_STYLE_TABLE
;
j
+
+
)
{
mCachedStyles
[
j
]
.
mPresent
=
false
;
mCachedStyles
[
j
]
.
value
.
Truncate
(
)
;
}
}
void
HTMLEditRules
:
:
AdjustSpecialBreaks
(
)
{
NS_ENSURE_TRUE_VOID
(
mHTMLEditor
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
nodeArray
;
EmptyEditableFunctor
functor
(
mHTMLEditor
)
;
DOMIterator
iter
;
if
(
NS_WARN_IF
(
NS_FAILED
(
iter
.
Init
(
*
mDocChangeRange
)
)
)
)
{
return
;
}
iter
.
AppendList
(
functor
nodeArray
)
;
for
(
auto
&
node
:
nodeArray
)
{
nsresult
rv
=
CreateMozBR
(
node
-
>
AsDOMNode
(
)
(
int32_t
)
node
-
>
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
}
nsresult
HTMLEditRules
:
:
AdjustWhitespace
(
Selection
*
aSelection
)
{
nsCOMPtr
<
nsIDOMNode
>
selNode
;
int32_t
selOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
return
WSRunObject
(
mHTMLEditor
selNode
selOffset
)
.
AdjustWhitespace
(
)
;
}
nsresult
HTMLEditRules
:
:
PinSelectionToNewBlock
(
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
if
(
!
aSelection
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mNewBlock
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsIDOMNode
>
selNode
;
int32_t
selOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
aSelection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
selNode
)
;
NS_ENSURE_STATE
(
node
)
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
node
)
;
rv
=
range
-
>
CollapseTo
(
node
selOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
nodeBefore
nodeAfter
;
rv
=
nsRange
:
:
CompareNodeToRange
(
mNewBlock
range
&
nodeBefore
&
nodeAfter
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nodeBefore
&
&
nodeAfter
)
{
return
NS_OK
;
}
if
(
nodeBefore
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsINode
>
tmp
=
mHTMLEditor
-
>
GetLastEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
endPoint
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
mHTMLEditor
-
>
IsContainer
(
tmp
)
)
{
endPoint
.
Set
(
tmp
tmp
-
>
Length
(
)
)
;
}
else
{
endPoint
.
Set
(
tmp
)
;
if
(
NS_WARN_IF
(
!
endPoint
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
aSelection
-
>
Collapse
(
endPoint
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsINode
>
tmp
=
mHTMLEditor
-
>
GetFirstEditableChild
(
*
mNewBlock
)
;
if
(
!
tmp
)
{
tmp
=
mNewBlock
;
}
EditorRawDOMPoint
atStartOfBlock
;
if
(
EditorBase
:
:
IsTextNode
(
tmp
)
|
|
mHTMLEditor
-
>
IsContainer
(
tmp
)
)
{
atStartOfBlock
.
Set
(
tmp
)
;
}
else
{
atStartOfBlock
.
Set
(
tmp
0
)
;
}
return
aSelection
-
>
Collapse
(
atStartOfBlock
)
;
}
void
HTMLEditRules
:
:
CheckInterlinePosition
(
Selection
&
aSelection
)
{
if
(
!
aSelection
.
Collapsed
(
)
)
{
return
;
}
NS_ENSURE_TRUE_VOID
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsRange
*
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
;
}
EditorDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsCOMPtr
<
nsIContent
>
node
=
htmlEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
atStartOfSelection
.
AsRaw
(
)
)
;
if
(
node
&
&
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
aSelection
.
SetInterlinePosition
(
true
)
;
return
;
}
if
(
atStartOfSelection
.
GetChildAtOffset
(
)
)
{
node
=
htmlEditor
-
>
GetPriorHTMLSibling
(
atStartOfSelection
.
GetChildAtOffset
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
aSelection
.
SetInterlinePosition
(
true
)
;
return
;
}
if
(
atStartOfSelection
.
GetChildAtOffset
(
)
)
{
node
=
htmlEditor
-
>
GetNextHTMLSibling
(
atStartOfSelection
.
GetChildAtOffset
(
)
)
;
}
else
{
node
=
nullptr
;
}
if
(
node
&
&
IsBlockNode
(
*
node
)
)
{
aSelection
.
SetInterlinePosition
(
false
)
;
}
}
nsresult
HTMLEditRules
:
:
AdjustSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
if
(
!
aSelection
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
EditorDOMPoint
point
(
EditorBase
:
:
GetStartPoint
(
aSelection
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
while
(
!
mHTMLEditor
-
>
IsEditable
(
point
.
Container
(
)
)
)
{
point
.
Set
(
point
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
theblock
=
mHTMLEditor
-
>
GetBlock
(
*
point
.
Container
(
)
)
;
if
(
theblock
&
&
mHTMLEditor
-
>
IsEditable
(
theblock
)
)
{
bool
bIsEmptyNode
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
theblock
&
bIsEmptyNode
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
bIsEmptyNode
&
&
mHTMLEditor
-
>
CanContainTag
(
*
point
.
Container
(
)
*
nsGkAtoms
:
:
br
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
rootNode
=
mHTMLEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootNode
NS_ERROR_FAILURE
)
;
if
(
point
.
Container
(
)
=
=
rootNode
)
{
return
NS_OK
;
}
return
CreateMozBR
(
GetAsDOMNode
(
point
.
Container
(
)
)
point
.
Offset
(
)
)
;
}
}
if
(
EditorBase
:
:
IsTextNode
(
point
.
Container
(
)
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContent
>
nearNode
=
mHTMLEditor
-
>
GetPreviousEditableHTMLNode
(
point
.
AsRaw
(
)
)
;
if
(
nearNode
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
Element
>
block
=
mHTMLEditor
-
>
GetBlock
(
*
point
.
Container
(
)
)
;
nsCOMPtr
<
Element
>
nearBlock
=
mHTMLEditor
-
>
GetBlockNodeParent
(
nearNode
)
;
if
(
block
&
&
block
=
=
nearBlock
)
{
if
(
nearNode
&
&
TextEditUtils
:
:
IsBreak
(
nearNode
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsVisibleBRElement
(
nearNode
)
)
{
nsCOMPtr
<
nsIDOMNode
>
brNode
;
nsresult
rv
=
CreateMozBR
(
GetAsDOMNode
(
point
.
Container
(
)
)
point
.
Offset
(
)
getter_AddRefs
(
brNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContent
>
br
=
do_QueryInterface
(
brNode
)
;
point
.
Set
(
br
)
;
aSelection
-
>
SetInterlinePosition
(
true
)
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
point
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
mHTMLEditor
-
>
GetNextEditableHTMLNodeInBlock
(
*
nearNode
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsMozBR
(
nextNode
)
)
{
aSelection
-
>
SetInterlinePosition
(
true
)
;
}
}
}
}
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nearNode
=
mHTMLEditor
-
>
GetPreviousEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
|
|
nearNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nearNode
=
mHTMLEditor
-
>
GetNextEditableHTMLNodeInBlock
(
point
.
AsRaw
(
)
)
;
if
(
nearNode
&
&
(
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
nearNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
hr
)
)
)
{
return
NS_OK
;
}
nearNode
=
FindNearEditableNode
(
point
.
AsRaw
(
)
aAction
)
;
if
(
!
nearNode
)
{
return
NS_OK
;
}
EditorDOMPoint
pt
=
GetGoodSelPointForNode
(
*
nearNode
aAction
)
;
ErrorResult
error
;
aSelection
-
>
Collapse
(
pt
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsIContent
*
HTMLEditRules
:
:
FindNearEditableNode
(
const
EditorRawDOMPoint
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsIContent
*
nearNode
=
nullptr
;
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNode
(
aPoint
)
;
if
(
!
nearNode
)
{
return
nullptr
;
}
}
else
{
nearNode
=
htmlEditor
-
>
GetNextEditableHTMLNode
(
aPoint
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
while
(
nearNode
&
&
!
(
EditorBase
:
:
IsTextNode
(
nearNode
)
|
|
TextEditUtils
:
:
IsBreak
(
nearNode
)
|
|
HTMLEditUtils
:
:
IsImage
(
nearNode
)
)
)
{
if
(
aDirection
=
=
nsIEditor
:
:
ePrevious
)
{
nearNode
=
htmlEditor
-
>
GetPreviousEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
else
{
nearNode
=
htmlEditor
-
>
GetNextEditableHTMLNode
(
*
nearNode
)
;
if
(
NS_WARN_IF
(
!
nearNode
)
)
{
return
nullptr
;
}
}
}
if
(
InDifferentTableElements
(
nearNode
aPoint
.
Container
(
)
)
)
{
return
nullptr
;
}
return
nearNode
;
}
bool
HTMLEditRules
:
:
InDifferentTableElements
(
nsIDOMNode
*
aNode1
nsIDOMNode
*
aNode2
)
{
nsCOMPtr
<
nsINode
>
node1
=
do_QueryInterface
(
aNode1
)
;
nsCOMPtr
<
nsINode
>
node2
=
do_QueryInterface
(
aNode2
)
;
return
InDifferentTableElements
(
node1
node2
)
;
}
bool
HTMLEditRules
:
:
InDifferentTableElements
(
nsINode
*
aNode1
nsINode
*
aNode2
)
{
MOZ_ASSERT
(
aNode1
&
&
aNode2
)
;
while
(
aNode1
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode1
)
)
{
aNode1
=
aNode1
-
>
GetParentNode
(
)
;
}
while
(
aNode2
&
&
!
HTMLEditUtils
:
:
IsTableElement
(
aNode2
)
)
{
aNode2
=
aNode2
-
>
GetParentNode
(
)
;
}
return
aNode1
!
=
aNode2
;
}
nsresult
HTMLEditRules
:
:
RemoveEmptyNodes
(
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
mDocChangeRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfEmptyNodes
arrayOfEmptyCites
skipList
;
while
(
!
iter
-
>
IsDone
(
)
)
{
OwningNonNull
<
nsINode
>
node
=
*
iter
-
>
GetCurrentNode
(
)
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
size_t
idx
=
skipList
.
IndexOf
(
node
)
;
if
(
idx
!
=
skipList
.
NoIndex
)
{
if
(
parent
)
{
skipList
[
idx
]
=
parent
;
}
}
else
{
bool
bIsCandidate
=
false
;
bool
bIsEmptyNode
=
false
;
bool
bIsMailCite
=
false
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
}
else
if
(
(
bIsMailCite
=
HTMLEditUtils
:
:
IsMailCite
(
node
)
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
|
|
HTMLEditUtils
:
:
IsInlineStyle
(
node
)
|
|
HTMLEditUtils
:
:
IsList
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
bIsCandidate
=
true
;
}
else
if
(
HTMLEditUtils
:
:
IsFormatNode
(
node
)
|
|
HTMLEditUtils
:
:
IsListItem
(
node
)
|
|
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
blockquote
)
)
{
bool
bIsSelInNode
;
rv
=
SelectionEndpointInNode
(
node
&
bIsSelInNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
bIsSelInNode
)
{
bIsCandidate
=
true
;
}
}
}
if
(
bIsCandidate
)
{
rv
=
htmlEditor
-
>
IsEmptyNode
(
node
-
>
AsDOMNode
(
)
&
bIsEmptyNode
bIsMailCite
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
bIsEmptyNode
)
{
if
(
bIsMailCite
)
{
arrayOfEmptyCites
.
AppendElement
(
*
node
)
;
}
else
{
arrayOfEmptyNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
!
bIsEmptyNode
&
&
parent
)
{
skipList
.
AppendElement
(
*
parent
)
;
}
}
iter
-
>
Next
(
)
;
}
for
(
auto
&
delNode
:
arrayOfEmptyNodes
)
{
if
(
htmlEditor
-
>
IsModifiableNode
(
delNode
)
)
{
rv
=
htmlEditor
-
>
DeleteNode
(
delNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
for
(
auto
&
delNode
:
arrayOfEmptyCites
)
{
bool
bIsEmptyNode
;
rv
=
htmlEditor
-
>
IsEmptyNode
(
delNode
&
bIsEmptyNode
false
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
bIsEmptyNode
)
{
nsCOMPtr
<
nsINode
>
parent
=
delNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
IndexOf
(
delNode
)
:
-
1
;
nsCOMPtr
<
Element
>
br
=
htmlEditor
-
>
CreateBR
(
parent
offset
)
;
NS_ENSURE_STATE
(
br
)
;
}
rv
=
htmlEditor
-
>
DeleteNode
(
delNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
SelectionEndpointInNode
(
nsINode
*
aNode
bool
*
aResult
)
{
NS_ENSURE_TRUE
(
aNode
&
&
aResult
NS_ERROR_NULL_POINTER
)
;
*
aResult
=
false
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
uint32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
rangeIdx
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
)
{
if
(
aNode
=
=
startContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
startContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
)
{
if
(
aNode
=
=
endContainer
)
{
*
aResult
=
true
;
return
NS_OK
;
}
if
(
EditorUtils
:
:
IsDescendantOf
(
*
endContainer
*
aNode
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
}
return
NS_OK
;
}
bool
HTMLEditRules
:
:
IsEmptyInline
(
nsINode
&
aNode
)
{
NS_ENSURE_TRUE
(
mHTMLEditor
false
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
if
(
IsInlineNode
(
aNode
)
&
&
htmlEditor
-
>
IsContainer
(
&
aNode
)
)
{
bool
isEmpty
=
true
;
htmlEditor
-
>
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
return
isEmpty
;
}
return
false
;
}
bool
HTMLEditRules
:
:
ListIsEmptyLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArrayOfNodes
)
{
NS_ENSURE_TRUE
(
aArrayOfNodes
.
Length
(
)
true
)
;
NS_ENSURE_TRUE
(
mHTMLEditor
false
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
int32_t
brCount
=
0
;
for
(
auto
&
node
:
aArrayOfNodes
)
{
if
(
!
htmlEditor
-
>
IsEditable
(
node
)
)
{
continue
;
}
if
(
TextEditUtils
:
:
IsBreak
(
node
)
)
{
if
(
brCount
)
{
return
false
;
}
brCount
+
+
;
}
else
if
(
IsEmptyInline
(
node
)
)
{
}
else
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditRules
:
:
PopListItem
(
nsIContent
&
aListItem
bool
*
aOutOfList
)
{
if
(
aOutOfList
)
{
*
aOutOfList
=
false
;
}
nsCOMPtr
<
nsIContent
>
kungFuDeathGrip
(
&
aListItem
)
;
Unused
<
<
kungFuDeathGrip
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
)
|
|
NS_WARN_IF
(
!
aListItem
.
GetParent
(
)
-
>
GetParentNode
(
)
)
|
|
!
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
bIsFirstListItem
=
mHTMLEditor
-
>
IsFirstEditableChild
(
&
aListItem
)
;
MOZ_ASSERT
(
mHTMLEditor
)
;
bool
bIsLastListItem
=
mHTMLEditor
-
>
IsLastEditableChild
(
&
aListItem
)
;
MOZ_ASSERT
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIContent
>
leftListNode
=
aListItem
.
GetParent
(
)
;
if
(
!
bIsFirstListItem
&
&
!
bIsLastListItem
)
{
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
atListItem
(
&
aListItem
)
;
if
(
NS_WARN_IF
(
!
atListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
atListItem
.
IsSetAndValid
(
)
)
;
ErrorResult
error
;
leftListNode
=
mHTMLEditor
-
>
SplitNode
(
atListItem
.
AsRaw
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_FAILURE
;
}
}
EditorDOMPoint
pointToInsertListItem
(
leftListNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsertListItem
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
pointToInsertListItem
.
IsSetAndValid
(
)
)
;
if
(
!
bIsFirstListItem
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsertListItem
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
right
list
node
"
)
;
}
nsresult
rv
=
mHTMLEditor
-
>
MoveNode
(
&
aListItem
pointToInsertListItem
.
Container
(
)
pointToInsertListItem
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
HTMLEditUtils
:
:
IsList
(
pointToInsertListItem
.
Container
(
)
)
&
&
HTMLEditUtils
:
:
IsListItem
(
&
aListItem
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
RemoveBlockContainer
(
*
aListItem
.
AsElement
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aOutOfList
)
{
*
aOutOfList
=
true
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveListStructure
(
Element
&
aList
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
while
(
aList
.
GetFirstChild
(
)
)
{
OwningNonNull
<
nsIContent
>
child
=
*
aList
.
GetFirstChild
(
)
;
if
(
HTMLEditUtils
:
:
IsListItem
(
child
)
)
{
bool
isOutOfList
;
do
{
nsresult
rv
=
PopListItem
(
child
&
isOutOfList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
while
(
!
isOutOfList
)
;
}
else
if
(
HTMLEditUtils
:
:
IsList
(
child
)
)
{
nsresult
rv
=
RemoveListStructure
(
*
child
-
>
AsElement
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsresult
rv
=
htmlEditor
-
>
DeleteNode
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
nsresult
rv
=
htmlEditor
-
>
RemoveBlockContainer
(
aList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
ConfirmSelectionInBody
(
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Element
>
rootElement
=
mHTMLEditor
-
>
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsINode
>
selNode
;
int32_t
selOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsINode
*
temp
=
selNode
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentNode
(
)
;
}
if
(
!
temp
)
{
selection
-
>
Collapse
(
rootElement
0
)
;
return
NS_OK
;
}
rv
=
EditorBase
:
:
GetEndNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
temp
=
selNode
;
while
(
temp
&
&
!
temp
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
temp
=
temp
-
>
GetParentNode
(
)
;
}
if
(
!
temp
)
{
selection
-
>
Collapse
(
rootElement
0
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
UpdateDocChangeRange
(
nsRange
*
aRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
aRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
if
(
!
mHTMLEditor
-
>
IsDescendantOfRoot
(
startNode
)
)
{
return
NS_OK
;
}
if
(
!
mDocChangeRange
)
{
mDocChangeRange
=
aRange
-
>
CloneRange
(
)
;
}
else
{
int16_t
result
;
nsresult
rv
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
nsIDOMRange
:
:
START_TO_START
aRange
&
result
)
;
if
(
rv
=
=
NS_ERROR_NOT_INITIALIZED
)
{
result
=
1
;
rv
=
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
result
>
0
)
{
rv
=
mDocChangeRange
-
>
SetStart
(
startNode
aRange
-
>
StartOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
mDocChangeRange
-
>
CompareBoundaryPoints
(
nsIDOMRange
:
:
END_TO_END
aRange
&
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
result
<
0
)
{
nsINode
*
endNode
=
aRange
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
mDocChangeRange
-
>
SetEnd
(
endNode
aRange
-
>
EndOffset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
InsertBRIfNeededInternal
(
nsINode
&
aNode
bool
aInsertMozBR
)
{
if
(
!
IsBlockNode
(
aNode
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isEmpty
;
nsresult
rv
=
mHTMLEditor
-
>
IsEmptyNode
(
&
aNode
&
isEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isEmpty
)
{
return
NS_OK
;
}
return
aInsertMozBR
?
CreateMozBR
(
aNode
.
AsDOMNode
(
)
0
)
:
CreateBR
(
aNode
.
AsDOMNode
(
)
0
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillCreateNode
(
const
nsAString
&
aTag
nsIDOMNode
*
aNextSiblingOfNewNode
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidCreateNode
(
const
nsAString
&
aTag
nsIDOMNode
*
aNewNode
nsresult
aResult
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsresult
rv
=
mUtilRange
-
>
SelectNode
(
aNewNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillInsertNode
(
nsIDOMNode
*
aNode
nsIDOMNode
*
aParent
int32_t
aPosition
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidInsertNode
(
nsIDOMNode
*
aNode
nsIDOMNode
*
aParent
int32_t
aPosition
nsresult
aResult
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsresult
rv
=
mUtilRange
-
>
SelectNode
(
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillDeleteNode
(
nsIDOMNode
*
aChild
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsresult
rv
=
mUtilRange
-
>
SelectNode
(
aChild
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidDeleteNode
(
nsIDOMNode
*
aChild
nsresult
aResult
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillSplitNode
(
nsIDOMNode
*
aExistingRightNode
int32_t
aOffset
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidSplitNode
(
nsIDOMNode
*
aExistingRightNode
nsIDOMNode
*
aNewLeftNode
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
newLeftNode
=
do_QueryInterface
(
aNewLeftNode
)
;
nsCOMPtr
<
nsINode
>
existingRightNode
=
do_QueryInterface
(
aExistingRightNode
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
newLeftNode
0
existingRightNode
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillJoinNodes
(
nsIDOMNode
*
aLeftNode
nsIDOMNode
*
aRightNode
nsIDOMNode
*
aParent
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
return
EditorBase
:
:
GetLengthOfDOMNode
(
aLeftNode
mJoinOffset
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidJoinNodes
(
nsIDOMNode
*
aLeftNode
nsIDOMNode
*
aRightNode
nsIDOMNode
*
aParent
nsresult
aResult
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
rightNode
=
do_QueryInterface
(
aRightNode
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
rightNode
mJoinOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillInsertText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidInsertText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
const
nsAString
&
aString
nsresult
aResult
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
int32_t
length
=
aString
.
Length
(
)
;
nsCOMPtr
<
nsINode
>
theNode
=
do_QueryInterface
(
aTextNode
)
;
nsresult
rv
=
mUtilRange
-
>
SetStartAndEnd
(
theNode
aOffset
theNode
aOffset
+
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillDeleteText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidDeleteText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
nsresult
aResult
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
theNode
=
do_QueryInterface
(
aTextNode
)
;
nsresult
rv
=
mUtilRange
-
>
CollapseTo
(
theNode
aOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
WillDeleteSelection
(
nsISelection
*
aSelection
)
{
if
(
!
mListenerEnabled
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
selection
=
aSelection
-
>
AsSelection
(
)
;
nsCOMPtr
<
nsINode
>
startNode
;
int32_t
startOffset
;
nsresult
rv
=
EditorBase
:
:
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
startNode
)
&
startOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
endNode
;
int32_t
endOffset
;
rv
=
EditorBase
:
:
GetEndNodeAndOffset
(
selection
getter_AddRefs
(
endNode
)
&
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mUtilRange
-
>
SetStartAndEnd
(
startNode
startOffset
endNode
endOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
UpdateDocChangeRange
(
mUtilRange
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DidDeleteSelection
(
nsISelection
*
aSelection
)
{
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
RemoveAlignment
(
nsINode
&
aNode
const
nsAString
&
aAlignType
bool
aChildrenOnly
)
{
if
(
EditorBase
:
:
IsTextNode
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsTable
(
&
aNode
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
child
tmp
;
if
(
aChildrenOnly
)
{
child
=
aNode
.
GetFirstChild
(
)
;
}
else
{
child
=
&
aNode
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
bool
useCSS
=
mHTMLEditor
-
>
IsCSSEnabled
(
)
;
while
(
child
)
{
if
(
aChildrenOnly
)
{
tmp
=
child
-
>
GetNextSibling
(
)
;
}
else
{
tmp
=
nullptr
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
center
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MakeSureElemStartsOrEndsOnCR
(
*
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
rv
=
mHTMLEditor
-
>
RemoveContainer
(
child
-
>
AsElement
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
child
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
RemoveAttribute
(
child
-
>
AsElement
(
)
nsGkAtoms
:
:
align
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
useCSS
)
{
if
(
child
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
hr
)
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
SetAttributeOrEquivalent
(
child
-
>
AsElement
(
)
nsGkAtoms
:
:
align
aAlignType
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsAutoString
dummyCssValue
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
mCSSEditUtils
-
>
RemoveCSSInlineStyle
(
*
child
nsGkAtoms
:
:
textAlign
dummyCssValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
nsresult
rv
=
RemoveAlignment
(
*
child
aAlignType
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
child
=
tmp
;
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
bool
aStarts
)
{
nsCOMPtr
<
nsINode
>
child
;
if
(
aStarts
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
child
=
mHTMLEditor
-
>
GetFirstEditableChild
(
aNode
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
child
=
mHTMLEditor
-
>
GetLastEditableChild
(
aNode
)
;
}
NS_ENSURE_TRUE
(
child
NS_OK
)
;
bool
foundCR
=
false
;
if
(
IsBlockNode
(
*
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
else
{
nsCOMPtr
<
nsINode
>
sibling
;
if
(
aStarts
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetPriorHTMLSibling
(
&
aNode
)
;
}
else
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
sibling
=
mHTMLEditor
-
>
GetNextHTMLSibling
(
&
aNode
)
;
}
if
(
sibling
)
{
if
(
IsBlockNode
(
*
sibling
)
|
|
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
foundCR
=
true
;
}
}
else
{
foundCR
=
true
;
}
}
if
(
!
foundCR
)
{
int32_t
offset
=
0
;
if
(
!
aStarts
)
{
offset
=
aNode
.
GetChildCount
(
)
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
Element
>
brNode
=
mHTMLEditor
-
>
CreateBR
(
&
aNode
offset
)
;
if
(
NS_WARN_IF
(
!
brNode
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
)
{
nsresult
rv
=
MakeSureElemStartsOrEndsOnCR
(
aNode
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
MakeSureElemStartsOrEndsOnCR
(
aNode
true
)
;
}
nsresult
HTMLEditRules
:
:
AlignBlock
(
Element
&
aElement
const
nsAString
&
aAlignType
ContentsOnly
aContentsOnly
)
{
if
(
!
IsBlockNode
(
aElement
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsresult
rv
=
RemoveAlignment
(
aElement
aAlignType
aContentsOnly
=
=
ContentsOnly
:
:
yes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
htmlEditor
-
>
IsCSSEnabled
(
)
)
{
return
htmlEditor
-
>
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
SupportsAlignAttr
(
aElement
)
)
)
{
return
NS_OK
;
}
return
htmlEditor
-
>
SetAttributeOrEquivalent
(
&
aElement
nsGkAtoms
:
:
align
aAlignType
false
)
;
}
nsresult
HTMLEditRules
:
:
ChangeIndentation
(
Element
&
aElement
Change
aChange
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
nsAtom
&
marginProperty
=
MarginPropertyAtomForIndent
(
*
htmlEditor
-
>
mCSSEditUtils
aElement
)
;
nsAutoString
value
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetSpecifiedProperty
(
aElement
marginProperty
value
)
;
float
f
;
RefPtr
<
nsAtom
>
unit
;
htmlEditor
-
>
mCSSEditUtils
-
>
ParseLength
(
value
&
f
getter_AddRefs
(
unit
)
)
;
if
(
!
f
)
{
nsAutoString
defaultLengthUnit
;
htmlEditor
-
>
mCSSEditUtils
-
>
GetDefaultLengthUnit
(
defaultLengthUnit
)
;
unit
=
NS_Atomize
(
defaultLengthUnit
)
;
}
int8_t
multiplier
=
aChange
=
=
Change
:
:
plus
?
+
1
:
-
1
;
if
(
nsGkAtoms
:
:
in
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_IN
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
cm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_CM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
mm
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_MM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pt
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PT
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
pc
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PC
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
em
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EM
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
ex
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_EX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
px
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PX
*
multiplier
;
}
else
if
(
nsGkAtoms
:
:
percentage
=
=
unit
)
{
f
+
=
NS_EDITOR_INDENT_INCREMENT_PERCENT
*
multiplier
;
}
if
(
0
<
f
)
{
nsAutoString
newValue
;
newValue
.
AppendFloat
(
f
)
;
newValue
.
Append
(
nsDependentAtomString
(
unit
)
)
;
htmlEditor
-
>
mCSSEditUtils
-
>
SetCSSProperty
(
aElement
marginProperty
newValue
)
;
return
NS_OK
;
}
htmlEditor
-
>
mCSSEditUtils
-
>
RemoveCSSProperty
(
aElement
marginProperty
value
)
;
if
(
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
div
)
|
|
&
aElement
=
=
htmlEditor
-
>
GetActiveEditingHost
(
)
|
|
!
htmlEditor
-
>
IsDescendantOfEditorRoot
(
&
aElement
)
|
|
HTMLEditor
:
:
HasAttributes
(
&
aElement
)
)
{
return
NS_OK
;
}
nsresult
rv
=
htmlEditor
-
>
RemoveContainer
(
&
aElement
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
WillAbsolutePosition
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
MOZ_ASSERT
(
aCancel
&
&
aHandled
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
WillInsert
(
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsCOMPtr
<
Element
>
focusElement
=
htmlEditor
-
>
GetSelectionContainer
(
)
;
if
(
focusElement
&
&
HTMLEditUtils
:
:
IsImage
(
focusElement
)
)
{
mNewBlock
=
focusElement
;
return
NS_OK
;
}
nsresult
rv
=
NormalizeSelection
(
&
aSelection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionRestorer
selectionRestorer
(
&
aSelection
htmlEditor
)
;
nsTArray
<
RefPtr
<
nsRange
>
>
arrayOfRanges
;
GetPromotedRanges
(
aSelection
arrayOfRanges
EditAction
:
:
setAbsolutePosition
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
rv
=
GetNodesForOperation
(
arrayOfRanges
arrayOfNodes
EditAction
:
:
setAbsolutePosition
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ListIsEmptyLine
(
arrayOfNodes
)
)
{
NS_ENSURE_STATE
(
aSelection
.
GetRangeAt
(
0
)
&
&
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
)
;
OwningNonNull
<
nsINode
>
parent
=
*
aSelection
.
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
int32_t
offset
=
aSelection
.
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
aSelection
.
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
parent
offset
address_of
(
child
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atChild
(
parent
child
offset
)
;
RefPtr
<
Element
>
positionedDiv
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atChild
)
;
NS_ENSURE_STATE
(
positionedDiv
)
;
mNewBlock
=
positionedDiv
;
while
(
!
arrayOfNodes
.
IsEmpty
(
)
)
{
OwningNonNull
<
nsINode
>
curNode
=
arrayOfNodes
[
0
]
;
rv
=
htmlEditor
-
>
DeleteNode
(
curNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
arrayOfNodes
.
RemoveElementAt
(
0
)
;
}
*
aHandled
=
true
;
rv
=
aSelection
.
Collapse
(
positionedDiv
0
)
;
selectionRestorer
.
Abort
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
curList
curPositionedDiv
indentedLI
;
for
(
uint32_t
i
=
0
;
i
<
arrayOfNodes
.
Length
(
)
;
i
+
+
)
{
NS_ENSURE_STATE
(
arrayOfNodes
[
i
]
-
>
IsContent
(
)
)
;
OwningNonNull
<
nsIContent
>
curNode
=
*
arrayOfNodes
[
i
]
-
>
AsContent
(
)
;
if
(
!
htmlEditor
-
>
IsEditable
(
curNode
)
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
sibling
;
int32_t
offset
;
nsCOMPtr
<
nsINode
>
curParent
=
EditorBase
:
:
GetNodeLocation
(
curNode
&
offset
)
;
if
(
!
curParent
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsList
(
curParent
)
)
{
if
(
curList
)
{
sibling
=
htmlEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
rv
=
SplitAsNeeded
(
*
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
curParent
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
curPositionedDiv
)
{
EditorRawDOMPoint
atCurParent
(
curParent
)
;
curPositionedDiv
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atCurParent
)
;
mNewBlock
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
(
curPositionedDiv
curPositionedDiv
-
>
Length
(
)
)
;
curList
=
htmlEditor
-
>
CreateNode
(
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
atEndOfCurPositionedDiv
)
;
NS_ENSURE_STATE
(
curList
)
;
}
rv
=
htmlEditor
-
>
MoveNode
(
curNode
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
Element
>
listItem
=
IsInListItem
(
curNode
)
;
if
(
listItem
)
{
if
(
indentedLI
=
=
listItem
)
{
continue
;
}
curParent
=
listItem
-
>
GetParentNode
(
)
;
offset
=
curParent
?
curParent
-
>
IndexOf
(
listItem
)
:
-
1
;
if
(
curList
)
{
sibling
=
htmlEditor
-
>
GetPriorHTMLSibling
(
curNode
)
;
}
if
(
!
curList
|
|
(
sibling
&
&
sibling
!
=
curList
)
)
{
rv
=
SplitAsNeeded
(
*
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
curParent
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
curPositionedDiv
)
{
EditorRawDOMPoint
atCurParent
(
curParent
)
;
curPositionedDiv
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atCurParent
)
;
mNewBlock
=
curPositionedDiv
;
}
EditorRawDOMPoint
atEndOfCurPositionedDiv
(
curPositionedDiv
curPositionedDiv
-
>
Length
(
)
)
;
curList
=
htmlEditor
-
>
CreateNode
(
curParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
atEndOfCurPositionedDiv
)
;
NS_ENSURE_STATE
(
curList
)
;
}
rv
=
htmlEditor
-
>
MoveNode
(
listItem
curList
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
indentedLI
=
listItem
;
}
else
{
if
(
!
curPositionedDiv
)
{
if
(
curNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
)
{
curPositionedDiv
=
curNode
-
>
AsElement
(
)
;
mNewBlock
=
curPositionedDiv
;
curList
=
nullptr
;
continue
;
}
nsCOMPtr
<
nsIContent
>
curChild
(
curNode
)
;
rv
=
SplitAsNeeded
(
*
nsGkAtoms
:
:
div
curParent
offset
address_of
(
curChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
EditorRawDOMPoint
atCurChild
(
curParent
curChild
offset
)
;
curPositionedDiv
=
htmlEditor
-
>
CreateNode
(
nsGkAtoms
:
:
div
atCurChild
)
;
NS_ENSURE_STATE
(
curPositionedDiv
)
;
mNewBlock
=
curPositionedDiv
;
}
rv
=
htmlEditor
-
>
MoveNode
(
curNode
curPositionedDiv
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
curList
=
nullptr
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditRules
:
:
DidAbsolutePosition
(
)
{
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIHTMLAbsPosEditor
>
absPosHTMLEditor
=
mHTMLEditor
;
nsCOMPtr
<
nsIDOMElement
>
elt
=
static_cast
<
nsIDOMElement
*
>
(
GetAsDOMNode
(
mNewBlock
)
)
;
return
absPosHTMLEditor
-
>
AbsolutelyPositionElement
(
elt
true
)
;
}
nsresult
HTMLEditRules
:
:
WillRemoveAbsolutePosition
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsCOMPtr
<
nsIDOMElement
>
elt
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
GetAbsolutelyPositionedSelectionContainer
(
getter_AddRefs
(
elt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIHTMLAbsPosEditor
>
absPosHTMLEditor
=
mHTMLEditor
;
return
absPosHTMLEditor
-
>
AbsolutelyPositionElement
(
elt
false
)
;
}
nsresult
HTMLEditRules
:
:
WillRelativeChangeZIndex
(
Selection
*
aSelection
int32_t
aChange
bool
*
aCancel
bool
*
aHandled
)
{
if
(
!
aSelection
|
|
!
aCancel
|
|
!
aHandled
)
{
return
NS_ERROR_NULL_POINTER
;
}
WillInsert
(
*
aSelection
aCancel
)
;
*
aCancel
=
false
;
*
aHandled
=
true
;
nsCOMPtr
<
nsIDOMElement
>
elt
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsresult
rv
=
mHTMLEditor
-
>
GetAbsolutelyPositionedSelectionContainer
(
getter_AddRefs
(
elt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
AutoSelectionRestorer
selectionRestorer
(
aSelection
mHTMLEditor
)
;
NS_ENSURE_STATE
(
mHTMLEditor
)
;
nsCOMPtr
<
nsIHTMLAbsPosEditor
>
absPosHTMLEditor
=
mHTMLEditor
;
int32_t
zIndex
;
return
absPosHTMLEditor
-
>
RelativeChangeElementZIndex
(
elt
aChange
&
zIndex
)
;
}
NS_IMETHODIMP
HTMLEditRules
:
:
DocumentModified
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditRules
:
:
DocumentModifiedWorker
"
this
&
HTMLEditRules
:
:
DocumentModifiedWorker
)
)
;
return
NS_OK
;
}
void
HTMLEditRules
:
:
DocumentModifiedWorker
(
)
{
if
(
!
mHTMLEditor
)
{
return
;
}
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
;
}
if
(
mBogusNode
)
{
htmlEditor
-
>
DeleteNode
(
mBogusNode
)
;
mBogusNode
=
nullptr
;
}
CreateBogusNodeIfNeeded
(
selection
)
;
}
}
