#
ifndef
mozilla_HTMLEditHelpers_h
#
define
mozilla_HTMLEditHelpers_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
class
nsISimpleEnumerator
;
namespace
mozilla
{
enum
class
JoinNodesDirection
{
LeftNodeIntoRightNode
RightNodeIntoLeftNode
}
;
static
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
JoinNodesDirection
aJoinNodesDirection
)
{
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
)
{
return
aStream
<
<
"
JoinNodesDirection
:
:
LeftNodeIntoRightNode
"
;
}
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
RightNodeIntoLeftNode
)
{
return
aStream
<
<
"
JoinNodesDirection
:
:
RightNodeIntoLeftNode
"
;
}
return
aStream
<
<
"
Invalid
value
"
;
}
enum
class
SplitNodeDirection
{
LeftNodeIsNewOne
RightNodeIsNewOne
}
;
static
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
SplitNodeDirection
aSplitNodeDirection
)
{
if
(
aSplitNodeDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
)
{
return
aStream
<
<
"
SplitNodeDirection
:
:
LeftNodeIsNewOne
"
;
}
if
(
aSplitNodeDirection
=
=
SplitNodeDirection
:
:
RightNodeIsNewOne
)
{
return
aStream
<
<
"
SplitNodeDirection
:
:
RightNodeIsNewOne
"
;
}
return
aStream
<
<
"
Invalid
value
"
;
}
class
MOZ_STACK_CLASS
MoveNodeResult
final
{
public
:
bool
isOk
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
isErr
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
constexpr
bool
Handled
(
)
const
{
return
mHandled
;
}
constexpr
bool
Ignored
(
)
const
{
return
!
Handled
(
)
;
}
constexpr
nsresult
inspectErr
(
)
const
{
return
mRv
;
}
constexpr
nsresult
unwrapErr
(
)
const
{
return
mRv
;
}
constexpr
bool
EditorDestroyed
(
)
const
{
return
MOZ_UNLIKELY
(
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
constexpr
bool
NotInitialized
(
)
const
{
return
mRv
=
=
NS_ERROR_NOT_INITIALIZED
;
}
constexpr
const
EditorDOMPoint
&
NextInsertionPointRef
(
)
const
{
return
mNextInsertionPoint
;
}
EditorDOMPoint
NextInsertionPoint
(
)
const
{
return
mNextInsertionPoint
;
}
void
MarkAsHandled
(
)
{
mHandled
=
true
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SuggestCaretPointTo
(
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
const
;
void
IgnoreCaretPointSuggestion
(
)
const
{
mHandledCaretPoint
=
true
;
}
bool
HasCaretPointSuggestion
(
)
const
{
return
mCaretPoint
.
IsSet
(
)
;
}
constexpr
EditorDOMPoint
&
&
UnwrapCaretPoint
(
)
{
mHandledCaretPoint
=
true
;
return
std
:
:
move
(
mCaretPoint
)
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
)
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
;
MoveNodeResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mHandled
(
false
)
{
}
explicit
MoveNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mHandled
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
MoveNodeResult
(
const
MoveNodeResult
&
aOther
)
=
delete
;
MoveNodeResult
&
operator
=
(
const
MoveNodeResult
&
aOther
)
=
delete
;
MoveNodeResult
(
MoveNodeResult
&
&
aOther
)
=
default
;
MoveNodeResult
&
operator
=
(
MoveNodeResult
&
&
aOther
)
=
default
;
MoveNodeResult
&
operator
|
=
(
const
MoveNodeResult
&
aOther
)
{
aOther
.
mHandledCaretPoint
=
true
;
mHandledCaretPoint
=
false
;
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
if
(
aOther
.
mCaretPoint
.
IsSet
(
)
)
{
mCaretPoint
=
aOther
.
mCaretPoint
;
}
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aOther
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
mNextInsertionPoint
.
Clear
(
)
;
mCaretPoint
.
Clear
(
)
;
return
*
this
;
}
if
(
aOther
.
NotInitialized
(
)
)
{
return
*
this
;
}
if
(
NotInitialized
(
)
)
{
mRv
=
aOther
.
mRv
;
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
mCaretPoint
=
aOther
.
mCaretPoint
;
return
*
this
;
}
if
(
isErr
(
)
|
|
aOther
.
isErr
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
mNextInsertionPoint
.
Clear
(
)
;
mCaretPoint
.
Clear
(
)
;
return
*
this
;
}
mRv
=
NS_OK
;
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
if
(
aOther
.
mCaretPoint
.
IsSet
(
)
)
{
mCaretPoint
=
aOther
.
mCaretPoint
;
}
return
*
this
;
}
#
ifdef
DEBUG
~
MoveNodeResult
(
)
{
MOZ_ASSERT_IF
(
isOk
(
)
&
&
Handled
(
)
!
mCaretPoint
.
IsSet
(
)
|
|
mHandledCaretPoint
)
;
}
#
endif
private
:
explicit
MoveNodeResult
(
const
EditorDOMPoint
&
aNextInsertionPoint
bool
aHandled
)
:
mNextInsertionPoint
(
aNextInsertionPoint
)
mRv
(
aNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
aHandled
&
&
aNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
explicit
MoveNodeResult
(
EditorDOMPoint
&
&
aNextInsertionPoint
bool
aHandled
)
:
mNextInsertionPoint
(
std
:
:
move
(
aNextInsertionPoint
)
)
mRv
(
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
aHandled
&
&
mNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
explicit
MoveNodeResult
(
const
EditorDOMPoint
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
:
mNextInsertionPoint
(
aNextInsertionPoint
)
mCaretPoint
(
aPointToPutCaret
)
mRv
(
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
mNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
explicit
MoveNodeResult
(
EditorDOMPoint
&
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
:
mNextInsertionPoint
(
std
:
:
move
(
aNextInsertionPoint
)
)
mCaretPoint
(
aPointToPutCaret
)
mRv
(
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
mNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
explicit
MoveNodeResult
(
const
EditorDOMPoint
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
:
mNextInsertionPoint
(
aNextInsertionPoint
)
mCaretPoint
(
std
:
:
move
(
aPointToPutCaret
)
)
mRv
(
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
mNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
explicit
MoveNodeResult
(
EditorDOMPoint
&
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
:
mNextInsertionPoint
(
std
:
:
move
(
aNextInsertionPoint
)
)
mCaretPoint
(
std
:
:
move
(
aPointToPutCaret
)
)
mRv
(
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
mNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
EditorDOMPoint
mNextInsertionPoint
;
EditorDOMPoint
mCaretPoint
;
nsresult
mRv
;
bool
mHandled
;
bool
mutable
mHandledCaretPoint
=
false
;
friend
MoveNodeResult
MoveNodeIgnored
(
const
EditorDOMPoint
&
aNextInsertionPoint
)
;
friend
MoveNodeResult
MoveNodeIgnored
(
EditorDOMPoint
&
&
aNextInsertionPoint
)
;
friend
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
)
;
friend
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
)
;
friend
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
;
friend
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
;
friend
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
;
friend
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
;
}
;
inline
MoveNodeResult
MoveNodeIgnored
(
const
EditorDOMPoint
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
aNextInsertionPoint
false
)
;
}
inline
MoveNodeResult
MoveNodeIgnored
(
EditorDOMPoint
&
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
std
:
:
move
(
aNextInsertionPoint
)
false
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
aNextInsertionPoint
true
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
std
:
:
move
(
aNextInsertionPoint
)
true
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
{
return
MoveNodeResult
(
aNextInsertionPoint
aPointToPutCaret
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
const
EditorDOMPoint
&
aPointToPutCaret
)
{
return
MoveNodeResult
(
std
:
:
move
(
aNextInsertionPoint
)
aPointToPutCaret
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPoint
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
{
return
MoveNodeResult
(
aNextInsertionPoint
std
:
:
move
(
aPointToPutCaret
)
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
EditorDOMPoint
&
&
aNextInsertionPoint
EditorDOMPoint
&
&
aPointToPutCaret
)
{
return
MoveNodeResult
(
std
:
:
move
(
aNextInsertionPoint
)
std
:
:
move
(
aPointToPutCaret
)
)
;
}
class
MOZ_STACK_CLASS
SplitNodeResult
final
{
public
:
bool
isOk
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
isErr
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
constexpr
nsresult
inspectErr
(
)
const
{
return
mRv
;
}
constexpr
nsresult
unwrapErr
(
)
const
{
return
inspectErr
(
)
;
}
bool
Handled
(
)
const
{
return
mPreviousNode
|
|
mNextNode
;
}
constexpr
bool
EditorDestroyed
(
)
const
{
return
MOZ_UNLIKELY
(
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
bool
DidSplit
(
)
const
{
return
mPreviousNode
&
&
mNextNode
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetPreviousContent
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mPreviousNode
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtPreviousContent
(
)
const
{
if
(
nsIContent
*
previousContent
=
GetPreviousContent
(
)
)
{
return
EditorDOMPointType
(
previousContent
)
;
}
return
EditorDOMPointType
(
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetNextContent
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
!
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mNextNode
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtNextContent
(
)
const
{
if
(
nsIContent
*
nextContent
=
GetNextContent
(
)
)
{
return
EditorDOMPointType
(
nextContent
)
;
}
return
EditorDOMPointType
(
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetNewContent
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
if
(
!
DidSplit
(
)
)
{
return
nullptr
;
}
return
mDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
?
mPreviousNode
:
mNextNode
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtNewContent
(
)
const
{
if
(
nsIContent
*
newContent
=
GetNewContent
(
)
)
{
return
EditorDOMPointType
(
newContent
)
;
}
return
EditorDOMPointType
(
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetOriginalContent
(
)
const
{
MOZ_ASSERT
(
isOk
(
)
)
;
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
GetContainerAs
<
nsIContent
>
(
)
;
}
if
(
mDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
)
{
return
mNextNode
?
mNextNode
:
mPreviousNode
;
}
return
mPreviousNode
?
mPreviousNode
:
mNextNode
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtOriginalContent
(
)
const
{
if
(
nsIContent
*
originalContent
=
GetOriginalContent
(
)
)
{
return
EditorDOMPointType
(
originalContent
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtSplitPoint
(
)
const
{
if
(
isErr
(
)
)
{
return
EditorDOMPointType
(
)
;
}
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
!
mPreviousNode
)
{
return
EditorDOMPointType
(
mNextNode
)
;
}
return
EditorDOMPointType
:
:
After
(
mPreviousNode
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SuggestCaretPointTo
(
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
const
;
void
IgnoreCaretPointSuggestion
(
)
const
{
mHandledCaretPoint
=
true
;
}
bool
HasCaretPointSuggestion
(
)
const
{
return
mCaretPoint
.
IsSet
(
)
;
}
constexpr
EditorDOMPoint
&
&
UnwrapCaretPoint
(
)
{
mHandledCaretPoint
=
true
;
return
std
:
:
move
(
mCaretPoint
)
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
)
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
;
SplitNodeResult
(
)
=
delete
;
SplitNodeResult
(
const
SplitNodeResult
&
)
=
delete
;
SplitNodeResult
&
operator
=
(
const
SplitNodeResult
&
)
=
delete
;
SplitNodeResult
(
SplitNodeResult
&
&
)
=
default
;
SplitNodeResult
&
operator
=
(
SplitNodeResult
&
&
)
=
default
;
SplitNodeResult
(
SplitNodeResult
&
&
aSplitResult
const
EditorDOMPoint
&
aNewCaretPoint
)
:
SplitNodeResult
(
std
:
:
move
(
aSplitResult
)
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
mCaretPoint
=
aNewCaretPoint
;
mHandledCaretPoint
=
false
;
}
SplitNodeResult
(
SplitNodeResult
&
&
aSplitResult
EditorDOMPoint
&
&
aNewCaretPoint
)
:
SplitNodeResult
(
std
:
:
move
(
aSplitResult
)
)
{
MOZ_ASSERT
(
isOk
(
)
)
;
mCaretPoint
=
std
:
:
move
(
aNewCaretPoint
)
;
mHandledCaretPoint
=
false
;
}
SplitNodeResult
(
nsIContent
&
aNewNode
nsIContent
&
aSplitNode
SplitNodeDirection
aDirection
const
Maybe
<
EditorDOMPoint
>
&
aNewCaretPoint
=
Nothing
(
)
)
:
mPreviousNode
(
aDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
?
&
aNewNode
:
&
aSplitNode
)
mNextNode
(
aDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
?
&
aSplitNode
:
&
aNewNode
)
mCaretPoint
(
aNewCaretPoint
.
isSome
(
)
?
aNewCaretPoint
.
ref
(
)
:
EditorDOMPoint
:
:
AtEndOf
(
mPreviousNode
)
)
mRv
(
NS_OK
)
mDirection
(
aDirection
)
{
}
SplitNodeResult
(
nsCOMPtr
<
nsIContent
>
&
&
aNewNode
nsCOMPtr
<
nsIContent
>
&
&
aSplitNode
SplitNodeDirection
aDirection
const
Maybe
<
EditorDOMPoint
>
&
aNewCaretPoint
=
Nothing
(
)
)
:
mPreviousNode
(
aDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
?
std
:
:
move
(
aNewNode
)
:
std
:
:
move
(
aSplitNode
)
)
mNextNode
(
aDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
?
std
:
:
move
(
aSplitNode
)
:
std
:
:
move
(
aNewNode
)
)
mCaretPoint
(
aNewCaretPoint
.
isSome
(
)
?
aNewCaretPoint
.
ref
(
)
:
(
MOZ_LIKELY
(
mPreviousNode
)
?
EditorDOMPoint
:
:
AtEndOf
(
mPreviousNode
)
:
EditorDOMPoint
(
)
)
)
mRv
(
NS_OK
)
mDirection
(
aDirection
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPreviousNode
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mNextNode
)
;
}
explicit
SplitNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mDirection
(
SplitNodeDirection
:
:
LeftNodeIsNewOne
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitNodeResult
ToHandledResult
(
)
const
{
mHandledCaretPoint
=
true
;
SplitNodeResult
result
(
NS_OK
mDirection
)
;
result
.
mPreviousNode
=
GetPreviousContent
(
)
;
result
.
mNextNode
=
GetNextContent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
result
.
Handled
(
)
)
;
result
.
mCaretPoint
=
mCaretPoint
;
return
result
;
}
static
inline
SplitNodeResult
HandledButDidNotSplitDueToEndOfContainer
(
nsIContent
&
aNotSplitNode
SplitNodeDirection
aDirection
const
SplitNodeResult
*
aDeeperSplitNodeResult
=
nullptr
)
{
SplitNodeResult
result
(
NS_OK
aDirection
)
;
result
.
mPreviousNode
=
&
aNotSplitNode
;
if
(
aDeeperSplitNodeResult
)
{
result
.
mCaretPoint
=
aDeeperSplitNodeResult
-
>
mCaretPoint
;
aDeeperSplitNodeResult
-
>
mHandledCaretPoint
=
true
;
}
return
result
;
}
static
inline
SplitNodeResult
HandledButDidNotSplitDueToStartOfContainer
(
nsIContent
&
aNotSplitNode
SplitNodeDirection
aDirection
const
SplitNodeResult
*
aDeeperSplitNodeResult
=
nullptr
)
{
SplitNodeResult
result
(
NS_OK
aDirection
)
;
result
.
mNextNode
=
&
aNotSplitNode
;
if
(
aDeeperSplitNodeResult
)
{
result
.
mCaretPoint
=
aDeeperSplitNodeResult
-
>
mCaretPoint
;
aDeeperSplitNodeResult
-
>
mHandledCaretPoint
=
true
;
}
return
result
;
}
template
<
typename
PT
typename
CT
>
static
inline
SplitNodeResult
NotHandled
(
const
EditorDOMPointBase
<
PT
CT
>
&
aGivenSplitPoint
SplitNodeDirection
aDirection
const
SplitNodeResult
*
aDeeperSplitNodeResult
=
nullptr
)
{
SplitNodeResult
result
(
NS_OK
aDirection
)
;
result
.
mGivenSplitPoint
=
aGivenSplitPoint
;
if
(
aDeeperSplitNodeResult
)
{
result
.
mCaretPoint
=
aDeeperSplitNodeResult
-
>
mCaretPoint
;
aDeeperSplitNodeResult
-
>
mHandledCaretPoint
=
true
;
}
return
result
;
}
static
inline
SplitNodeResult
MergeWithDeeperSplitNodeResult
(
SplitNodeResult
&
&
aSplitNodeResult
const
SplitNodeResult
&
aDeeperSplitNodeResult
)
{
aSplitNodeResult
.
mHandledCaretPoint
=
false
;
aDeeperSplitNodeResult
.
mHandledCaretPoint
=
true
;
if
(
aSplitNodeResult
.
DidSplit
(
)
|
|
!
aDeeperSplitNodeResult
.
mCaretPoint
.
IsSet
(
)
)
{
return
std
:
:
move
(
aSplitNodeResult
)
;
}
SplitNodeResult
result
(
std
:
:
move
(
aSplitNodeResult
)
)
;
result
.
mCaretPoint
=
aDeeperSplitNodeResult
.
mCaretPoint
;
return
result
;
}
#
ifdef
DEBUG
~
SplitNodeResult
(
)
{
MOZ_ASSERT_IF
(
isOk
(
)
!
mCaretPoint
.
IsSet
(
)
|
|
mHandledCaretPoint
)
;
}
#
endif
private
:
SplitNodeResult
(
nsresult
aRv
SplitNodeDirection
aDirection
)
:
mRv
(
aRv
)
mDirection
(
aDirection
)
{
}
nsCOMPtr
<
nsIContent
>
mPreviousNode
;
nsCOMPtr
<
nsIContent
>
mNextNode
;
EditorDOMPoint
mGivenSplitPoint
;
EditorDOMPoint
mCaretPoint
;
nsresult
mRv
;
SplitNodeDirection
mDirection
;
bool
mutable
mHandledCaretPoint
=
false
;
}
;
class
MOZ_STACK_CLASS
JoinNodesResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Handled
(
)
const
{
return
Succeeded
(
)
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
MOZ_KNOWN_LIVE
nsIContent
*
ExistingContent
(
)
const
{
MOZ_ASSERT
(
Succeeded
(
)
)
;
return
mJoinedPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtExistingContent
(
)
const
{
MOZ_ASSERT
(
Succeeded
(
)
)
;
return
EditorDOMPointType
(
mJoinedPoint
.
ContainerAs
<
nsIContent
>
(
)
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
RemovedContent
(
)
const
{
MOZ_ASSERT
(
Succeeded
(
)
)
;
return
mRemovedContent
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtRemovedContent
(
)
const
{
MOZ_ASSERT
(
Succeeded
(
)
)
;
if
(
mRemovedContent
)
{
return
EditorDOMPointType
(
mRemovedContent
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
AtJoinedPoint
(
)
const
{
MOZ_ASSERT
(
Succeeded
(
)
)
;
return
mJoinedPoint
;
}
JoinNodesResult
(
)
=
delete
;
JoinNodesResult
(
const
EditorDOMPoint
&
aJoinedPoint
nsIContent
&
aRemovedContent
JoinNodesDirection
aDirection
)
:
mJoinedPoint
(
aJoinedPoint
)
mRemovedContent
(
&
aRemovedContent
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aJoinedPoint
.
IsInContentNode
(
)
)
;
}
explicit
JoinNodesResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
private
:
EditorDOMPoint
mJoinedPoint
;
nsCOMPtr
<
nsIContent
>
mRemovedContent
;
nsresult
mRv
;
}
;
class
MOZ_STACK_CLASS
SplitRangeOffFromNodeResult
final
{
public
:
bool
isOk
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
isErr
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
constexpr
nsresult
inspectErr
(
)
const
{
return
mRv
;
}
constexpr
nsresult
unwrapErr
(
)
const
{
return
inspectErr
(
)
;
}
constexpr
bool
EditorDestroyed
(
)
const
{
return
MOZ_UNLIKELY
(
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetLeftContent
(
)
const
{
return
mLeftContent
;
}
template
<
typename
ContentNodeType
>
MOZ_KNOWN_LIVE
ContentNodeType
*
GetLeftContentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetLeftContent
(
)
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetMiddleContent
(
)
const
{
return
mMiddleContent
;
}
template
<
typename
ContentNodeType
>
MOZ_KNOWN_LIVE
ContentNodeType
*
GetMiddleContentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetMiddleContent
(
)
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetRightContent
(
)
const
{
return
mRightContent
;
}
template
<
typename
ContentNodeType
>
MOZ_KNOWN_LIVE
ContentNodeType
*
GetRightContentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetRightContent
(
)
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetLeftmostContent
(
)
const
{
return
mLeftContent
?
mLeftContent
:
(
mMiddleContent
?
mMiddleContent
:
mRightContent
)
;
}
template
<
typename
ContentNodeType
>
MOZ_KNOWN_LIVE
ContentNodeType
*
GetLeftmostContentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetLeftmostContent
(
)
)
;
}
MOZ_KNOWN_LIVE
nsIContent
*
GetRightmostContent
(
)
const
{
return
mRightContent
?
mRightContent
:
(
mMiddleContent
?
mMiddleContent
:
mLeftContent
)
;
}
template
<
typename
ContentNodeType
>
MOZ_KNOWN_LIVE
ContentNodeType
*
GetRightmostContentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetRightmostContent
(
)
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SuggestCaretPointTo
(
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
const
;
void
IgnoreCaretPointSuggestion
(
)
const
{
mHandledCaretPoint
=
true
;
}
bool
HasCaretPointSuggestion
(
)
const
{
return
mCaretPoint
.
IsSet
(
)
;
}
constexpr
EditorDOMPoint
&
&
UnwrapCaretPoint
(
)
{
mHandledCaretPoint
=
true
;
return
std
:
:
move
(
mCaretPoint
)
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
)
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
;
SplitRangeOffFromNodeResult
(
)
=
delete
;
SplitRangeOffFromNodeResult
(
nsIContent
*
aLeftContent
nsIContent
*
aMiddleContent
nsIContent
*
aRightContent
)
:
mLeftContent
(
aLeftContent
)
mMiddleContent
(
aMiddleContent
)
mRightContent
(
aRightContent
)
mRv
(
NS_OK
)
{
}
SplitRangeOffFromNodeResult
(
nsIContent
*
aLeftContent
nsIContent
*
aMiddleContent
nsIContent
*
aRightContent
EditorDOMPoint
&
&
aPointToPutCaret
)
:
mLeftContent
(
aLeftContent
)
mMiddleContent
(
aMiddleContent
)
mRightContent
(
aRightContent
)
mCaretPoint
(
std
:
:
move
(
aPointToPutCaret
)
)
mRv
(
NS_OK
)
{
}
explicit
SplitRangeOffFromNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitRangeOffFromNodeResult
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
&
operator
=
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
SplitRangeOffFromNodeResult
&
operator
=
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
#
ifdef
DEBUG
~
SplitRangeOffFromNodeResult
(
)
{
MOZ_ASSERT_IF
(
isOk
(
)
!
mCaretPoint
.
IsSet
(
)
|
|
mHandledCaretPoint
)
;
}
#
endif
private
:
MOZ_KNOWN_LIVE
nsCOMPtr
<
nsIContent
>
mLeftContent
;
MOZ_KNOWN_LIVE
nsCOMPtr
<
nsIContent
>
mMiddleContent
;
MOZ_KNOWN_LIVE
nsCOMPtr
<
nsIContent
>
mRightContent
;
EditorDOMPoint
mCaretPoint
;
nsresult
mRv
;
bool
mutable
mHandledCaretPoint
=
false
;
}
;
class
MOZ_STACK_CLASS
SplitRangeOffResult
final
{
public
:
bool
isOk
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
isErr
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
constexpr
nsresult
inspectErr
(
)
const
{
return
mRv
;
}
constexpr
nsresult
unwrapErr
(
)
const
{
return
inspectErr
(
)
;
}
constexpr
bool
Handled
(
)
const
{
return
mHandled
;
}
constexpr
bool
EditorDestroyed
(
)
const
{
return
MOZ_UNLIKELY
(
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
constexpr
const
EditorDOMRange
&
RangeRef
(
)
const
{
return
mRange
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
SuggestCaretPointTo
(
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
const
;
void
IgnoreCaretPointSuggestion
(
)
const
{
mHandledCaretPoint
=
true
;
}
bool
HasCaretPointSuggestion
(
)
const
{
return
mCaretPoint
.
IsSet
(
)
;
}
constexpr
EditorDOMPoint
&
&
UnwrapCaretPoint
(
)
{
mHandledCaretPoint
=
true
;
return
std
:
:
move
(
mCaretPoint
)
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
SuggestCaretOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
;
MOZ_ASSERT
(
!
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
)
)
;
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
&
&
!
mCaretPoint
.
IsSet
(
)
)
{
return
false
;
}
aPointToPutCaret
=
UnwrapCaretPoint
(
)
;
return
true
;
}
bool
MoveCaretPointTo
(
EditorDOMPoint
&
aPointToPutCaret
const
HTMLEditor
&
aHTMLEditor
const
SuggestCaretOptions
&
aOptions
)
;
SplitRangeOffResult
(
)
=
delete
;
SplitRangeOffResult
(
EditorDOMRange
&
&
aTrackedRange
SplitNodeResult
&
&
aSplitNodeResultAtStart
SplitNodeResult
&
&
aSplitNodeResultAtEnd
)
:
mRange
(
std
:
:
move
(
aTrackedRange
)
)
mRv
(
NS_OK
)
mHandled
(
aSplitNodeResultAtStart
.
Handled
(
)
|
|
aSplitNodeResultAtEnd
.
Handled
(
)
)
{
MOZ_ASSERT
(
mRange
.
StartRef
(
)
.
IsSet
(
)
)
;
MOZ_ASSERT
(
mRange
.
EndRef
(
)
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aSplitNodeResultAtStart
.
isOk
(
)
)
;
MOZ_ASSERT
(
aSplitNodeResultAtEnd
.
isOk
(
)
)
;
SplitNodeResult
splitNodeResultAtStart
(
std
:
:
move
(
aSplitNodeResultAtStart
)
)
;
SplitNodeResult
splitNodeResultAtEnd
(
std
:
:
move
(
aSplitNodeResultAtEnd
)
)
;
splitNodeResultAtStart
.
MoveCaretPointTo
(
mCaretPoint
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
splitNodeResultAtEnd
.
MoveCaretPointTo
(
mCaretPoint
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
}
explicit
SplitRangeOffResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mHandled
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitRangeOffResult
(
const
SplitRangeOffResult
&
aOther
)
=
delete
;
SplitRangeOffResult
&
operator
=
(
const
SplitRangeOffResult
&
aOther
)
=
delete
;
SplitRangeOffResult
(
SplitRangeOffResult
&
&
aOther
)
=
default
;
SplitRangeOffResult
&
operator
=
(
SplitRangeOffResult
&
&
aOther
)
=
default
;
private
:
EditorDOMRange
mRange
;
EditorDOMPoint
mCaretPoint
;
nsresult
mRv
;
bool
mHandled
;
bool
mutable
mHandledCaretPoint
=
false
;
}
;
class
MOZ_RAII
DOMIterator
{
public
:
explicit
DOMIterator
(
)
;
explicit
DOMIterator
(
nsINode
&
aNode
)
;
virtual
~
DOMIterator
(
)
=
default
;
nsresult
Init
(
nsRange
&
aRange
)
;
nsresult
Init
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
template
<
class
NodeClass
>
void
AppendAllNodesToArray
(
nsTArray
<
OwningNonNull
<
NodeClass
>
>
&
aArrayOfNodes
)
const
;
typedef
bool
(
*
BoolFunctor
)
(
nsINode
&
aNode
void
*
aClosure
)
;
template
<
class
NodeClass
>
void
AppendNodesToArray
(
BoolFunctor
aFunctor
nsTArray
<
OwningNonNull
<
NodeClass
>
>
&
aArrayOfNodes
void
*
aClosure
=
nullptr
)
const
;
protected
:
ContentIteratorBase
*
mIter
;
PostContentIterator
mPostOrderIter
;
}
;
class
MOZ_RAII
DOMSubtreeIterator
final
:
public
DOMIterator
{
public
:
explicit
DOMSubtreeIterator
(
)
;
virtual
~
DOMSubtreeIterator
(
)
=
default
;
nsresult
Init
(
nsRange
&
aRange
)
;
private
:
ContentSubtreeIterator
mSubtreeIter
;
explicit
DOMSubtreeIterator
(
nsINode
&
aNode
)
=
delete
;
}
;
template
<
typename
EditorDOMPointType
>
class
MOZ_STACK_CLASS
ReplaceRangeDataBase
final
{
public
:
ReplaceRangeDataBase
(
)
=
default
;
template
<
typename
OtherEditorDOMRangeType
>
ReplaceRangeDataBase
(
const
OtherEditorDOMRangeType
&
aRange
const
nsAString
&
aReplaceString
)
:
mRange
(
aRange
)
mReplaceString
(
aReplaceString
)
{
}
template
<
typename
StartPointType
typename
EndPointType
>
ReplaceRangeDataBase
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
const
nsAString
&
aReplaceString
)
:
mRange
(
aStart
aEnd
)
mReplaceString
(
aReplaceString
)
{
}
bool
IsSet
(
)
const
{
return
mRange
.
IsPositioned
(
)
;
}
bool
IsSetAndValid
(
)
const
{
return
mRange
.
IsPositionedAndValid
(
)
;
}
bool
Collapsed
(
)
const
{
return
mRange
.
Collapsed
(
)
;
}
bool
HasReplaceString
(
)
const
{
return
!
mReplaceString
.
IsEmpty
(
)
;
}
const
EditorDOMPointType
&
StartRef
(
)
const
{
return
mRange
.
StartRef
(
)
;
}
const
EditorDOMPointType
&
EndRef
(
)
const
{
return
mRange
.
EndRef
(
)
;
}
const
EditorDOMRangeBase
<
EditorDOMPointType
>
&
RangeRef
(
)
const
{
return
mRange
;
}
const
nsString
&
ReplaceStringRef
(
)
const
{
return
mReplaceString
;
}
template
<
typename
PointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStart
(
const
PointType
&
aStart
)
{
mRange
.
SetStart
(
aStart
)
;
}
template
<
typename
PointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetEnd
(
const
PointType
&
aEnd
)
{
mRange
.
SetEnd
(
aEnd
)
;
}
template
<
typename
StartPointType
typename
EndPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStartAndEnd
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
)
{
mRange
.
SetRange
(
aStart
aEnd
)
;
}
template
<
typename
OtherEditorDOMRangeType
>
MOZ_NEVER_INLINE_DEBUG
void
SetRange
(
const
OtherEditorDOMRangeType
&
aRange
)
{
mRange
=
aRange
;
}
void
SetReplaceString
(
const
nsAString
&
aReplaceString
)
{
mReplaceString
=
aReplaceString
;
}
template
<
typename
StartPointType
typename
EndPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStartAndEnd
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
const
nsAString
&
aReplaceString
)
{
SetStartAndEnd
(
aStart
aEnd
)
;
SetReplaceString
(
aReplaceString
)
;
}
template
<
typename
OtherEditorDOMRangeType
>
MOZ_NEVER_INLINE_DEBUG
void
Set
(
const
OtherEditorDOMRangeType
&
aRange
const
nsAString
&
aReplaceString
)
{
SetRange
(
aRange
)
;
SetReplaceString
(
aReplaceString
)
;
}
private
:
EditorDOMRangeBase
<
EditorDOMPointType
>
mRange
;
nsString
mReplaceString
;
}
;
}
#
endif
