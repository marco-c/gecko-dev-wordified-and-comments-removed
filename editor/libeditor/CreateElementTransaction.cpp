#
include
"
CreateElementTransaction
.
h
"
#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
"
EditorDOMPoint
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
using
namespace
dom
;
template
already_AddRefed
<
CreateElementTransaction
>
CreateElementTransaction
:
:
Create
(
HTMLEditor
&
aHTMLEditor
nsAtom
&
aTagName
const
EditorDOMPoint
&
aPointToInsert
)
;
template
already_AddRefed
<
CreateElementTransaction
>
CreateElementTransaction
:
:
Create
(
HTMLEditor
&
aHTMLEditor
nsAtom
&
aTagName
const
EditorRawDOMPoint
&
aPointToInsert
)
;
template
<
typename
PT
typename
CT
>
already_AddRefed
<
CreateElementTransaction
>
CreateElementTransaction
:
:
Create
(
HTMLEditor
&
aHTMLEditor
nsAtom
&
aTagName
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
RefPtr
<
CreateElementTransaction
>
transaction
=
new
CreateElementTransaction
(
aHTMLEditor
aTagName
aPointToInsert
)
;
return
transaction
.
forget
(
)
;
}
template
<
typename
PT
typename
CT
>
CreateElementTransaction
:
:
CreateElementTransaction
(
HTMLEditor
&
aHTMLEditor
nsAtom
&
aTagName
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
:
EditTransactionBase
(
)
mHTMLEditor
(
&
aHTMLEditor
)
mTag
(
&
aTagName
)
mPointToInsert
(
aPointToInsert
)
{
MOZ_ASSERT
(
!
mPointToInsert
.
IsInDataNode
(
)
)
;
AutoEditorDOMPointOffsetInvalidator
lockChild
(
mPointToInsert
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
CreateElementTransaction
&
aTransaction
)
{
aStream
<
<
"
{
mTag
=
\
"
"
<
<
nsAtomCString
(
aTransaction
.
mTag
?
aTransaction
.
mTag
.
get
(
)
:
nsGkAtoms
:
:
_empty
)
.
get
(
)
<
<
"
\
"
"
<
<
"
mPointToInsert
=
"
<
<
aTransaction
.
mPointToInsert
<
<
"
mNewElement
=
"
<
<
aTransaction
.
mNewElement
.
get
(
)
;
if
(
aTransaction
.
mNewElement
)
{
aStream
<
<
"
(
"
<
<
*
aTransaction
.
mNewElement
<
<
"
)
"
;
}
aStream
<
<
"
mHTMLEditor
=
"
<
<
aTransaction
.
mHTMLEditor
.
get
(
)
<
<
"
}
"
;
return
aStream
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
CreateElementTransaction
EditTransactionBase
mHTMLEditor
mPointToInsert
mNewElement
)
NS_IMPL_ADDREF_INHERITED
(
CreateElementTransaction
EditTransactionBase
)
NS_IMPL_RELEASE_INHERITED
(
CreateElementTransaction
EditTransactionBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CreateElementTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditTransactionBase
)
NS_IMETHODIMP
CreateElementTransaction
:
:
DoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CreateElementTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
NS_WARN_IF
(
!
mTag
)
|
|
NS_WARN_IF
(
!
mPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
OwningNonNull
<
HTMLEditor
>
editorBase
=
*
mHTMLEditor
;
mNewElement
=
editorBase
-
>
CreateHTMLContent
(
mTag
)
;
if
(
!
mNewElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateHTMLContent
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
Element
>
newElement
=
*
mNewElement
;
nsresult
rv
=
editorBase
-
>
MarkElementDirty
(
newElement
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
HTMLEditor
:
:
ToGenericNSResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MarkElementDirty
(
)
failed
but
ignored
"
)
;
ErrorResult
error
;
InsertNewNode
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
CreateElementTransaction
:
:
InsertNewNode
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
!
editorBase
-
>
AllowsTransactionsToChangeSelection
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
editorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
afterNewNode
(
EditorRawDOMPoint
:
:
After
(
newElement
)
)
;
if
(
NS_WARN_IF
(
!
afterNewNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
ignoredError
;
selection
-
>
CollapseInLimiter
(
afterNewNode
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseInLimiter
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
void
CreateElementTransaction
:
:
InsertNewNode
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
mNewElement
)
;
MOZ_ASSERT
(
mPointToInsert
.
IsSet
(
)
)
;
if
(
mPointToInsert
.
IsSetAndValid
(
)
)
{
if
(
mPointToInsert
.
IsEndOfContainer
(
)
)
{
OwningNonNull
<
nsINode
>
container
=
*
mPointToInsert
.
GetContainer
(
)
;
OwningNonNull
<
Element
>
newElement
=
*
mNewElement
;
container
-
>
AppendChild
(
newElement
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
nsINode
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
return
;
}
MOZ_ASSERT
(
mPointToInsert
.
GetChild
(
)
)
;
OwningNonNull
<
nsINode
>
container
=
*
mPointToInsert
.
GetContainer
(
)
;
OwningNonNull
<
nsIContent
>
child
=
*
mPointToInsert
.
GetChild
(
)
;
OwningNonNull
<
Element
>
newElement
=
*
mNewElement
;
container
-
>
InsertBefore
(
newElement
child
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
nsINode
:
:
InsertBefore
(
)
failed
but
ignored
"
)
;
aError
.
WouldReportJSException
(
)
;
return
;
}
if
(
NS_WARN_IF
(
mPointToInsert
.
GetChild
(
)
&
&
mPointToInsert
.
GetContainer
(
)
!
=
mPointToInsert
.
GetChild
(
)
-
>
GetParentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
OwningNonNull
<
nsINode
>
container
=
*
mPointToInsert
.
GetContainer
(
)
;
OwningNonNull
<
Element
>
newElement
=
*
mNewElement
;
container
-
>
AppendChild
(
newElement
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
nsINode
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
}
NS_IMETHODIMP
CreateElementTransaction
:
:
UndoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CreateElementTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
NS_WARN_IF
(
!
mPointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
mNewElement
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
OwningNonNull
<
Element
>
newElement
=
*
mNewElement
;
OwningNonNull
<
nsINode
>
containerNode
=
*
mPointToInsert
.
GetContainer
(
)
;
ErrorResult
error
;
containerNode
-
>
RemoveChild
(
newElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
nsINode
:
:
RemoveChild
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
CreateElementTransaction
:
:
RedoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CreateElementTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
mHTMLEditor
)
|
|
NS_WARN_IF
(
!
mPointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
mNewElement
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ErrorResult
error
;
InsertNewNode
(
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
CreateElementTransaction
:
:
InsertNewNode
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
