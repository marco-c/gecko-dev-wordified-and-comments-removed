#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditorNestedClasses
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
AutoRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
InvisibleWhiteSpaces
=
HTMLEditUtils
:
:
InvisibleWhiteSpaces
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
ScanLineBreak
=
HTMLEditUtils
:
:
ScanLineBreak
;
using
TableBoundary
=
HTMLEditUtils
:
:
TableBoundary
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
template
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
;
template
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPointInText
&
aStartPoint
const
EditorDOMPointInText
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
;
class
MOZ_RAII
AutoSetTemporaryAncestorLimiter
final
{
public
:
AutoSetTemporaryAncestorLimiter
(
const
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
nsINode
&
aStartPointNode
AutoRangeArray
*
aRanges
=
nullptr
)
{
MOZ_ASSERT
(
aSelection
.
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
aSelection
.
GetAncestorLimiter
(
)
)
{
return
;
}
Element
*
selectionRootElement
=
aHTMLEditor
.
FindSelectionRoot
(
aStartPointNode
)
;
if
(
!
selectionRootElement
)
{
return
;
}
aHTMLEditor
.
InitializeSelectionAncestorLimit
(
*
selectionRootElement
)
;
mSelection
=
&
aSelection
;
if
(
aRanges
)
{
aRanges
-
>
Initialize
(
aSelection
)
;
}
}
~
AutoSetTemporaryAncestorLimiter
(
)
{
if
(
mSelection
)
{
mSelection
-
>
SetAncestorLimiter
(
nullptr
)
;
}
}
private
:
RefPtr
<
Selection
>
mSelection
;
}
;
class
MOZ_STACK_CLASS
HTMLEditor
:
:
AutoDeleteRangesHandler
final
{
public
:
explicit
AutoDeleteRangesHandler
(
const
AutoDeleteRangesHandler
*
aParent
=
nullptr
)
:
mParent
(
aParent
)
mOriginalDirectionAndAmount
(
nsIEditor
:
:
eNone
)
mOriginalStripWrappers
(
nsIEditor
:
:
eNoStrip
)
{
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
;
private
:
bool
IsHandlingRecursively
(
)
const
{
return
mParent
!
=
nullptr
;
}
bool
CanFallbackToDeleteRangesWithTransaction
(
const
AutoRangeArray
&
aRangesToDelete
)
const
{
return
!
IsHandlingRecursively
(
)
&
&
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
&
&
(
!
aRangesToDelete
.
IsCollapsed
(
)
|
|
EditorBase
:
:
HowToHandleCollapsedRangeFor
(
mOriginalDirectionAndAmount
)
!
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
Ignore
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
const
Element
&
aEditingHost
)
const
;
enum
class
SelectionWasCollapsed
{
Yes
No
}
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
HandleDeleteTextAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteTextAroundCollapsedRanges
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
HandleDeleteCollapsedSelectionAtVisibleChar
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
EditorDOMPoint
&
aPointAtDeletingChar
const
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
HandleDeleteAtomicContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteAtomicContent
(
Element
*
aEditingHost
const
nsIContent
&
aAtomicContent
AutoRangeArray
&
aRangesToDelete
)
const
;
static
nsIContent
*
GetAtomicContentToDelete
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
MOZ_NONNULL_RETURN
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
WSRunScanner
&
aWSRunScannerAtCaret
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
;
template
<
typename
EditorDOMRangeType
>
Result
<
EditorRawDOMRange
nsresult
>
ExtendOrShrinkRangeToDelete
(
const
HTMLEditor
&
aHTMLEditor
const
nsFrameSelection
*
aFrameSelection
const
EditorDOMRangeType
&
aRangeToDelete
)
const
;
MOZ_NEVER_INLINE_DEBUG
static
EditorRawDOMRange
GetRangeToAvoidDeletingAllListItemsIfSelectingAllOverListElements
(
const
EditorRawDOMRange
&
aRangeToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteUnnecessaryNodes
(
HTMLEditor
&
aHTMLEditor
EditorDOMRange
&
aRange
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteUnnecessaryNodesAndCollapseSelection
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteNodeIfInvisibleAndEditableTextNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteParentBlocksWithTransactionIfEmpty
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
CaretPoint
nsresult
>
FallbackToDeleteRangesWithTransaction
(
HTMLEditor
&
aHTMLEditor
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
mOriginalDirectionAndAmount
mOriginalStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
caretPointOrError
.
isOk
(
)
"
HTMLEditor
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
nsresult
ComputeRangesToDeleteRangesWithTransaction
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
;
nsresult
FallbackToComputeRangesToDeleteRangesWithTransaction
(
const
HTMLEditor
&
aHTMLEditor
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
;
nsresult
rv
=
ComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
mOriginalDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
class
MOZ_STACK_CLASS
AutoBlockElementsJoiner
final
{
public
:
AutoBlockElementsJoiner
(
)
=
delete
;
explicit
AutoBlockElementsJoiner
(
AutoDeleteRangesHandler
&
aDeleteRangesHandler
)
:
mDeleteRangesHandler
(
&
aDeleteRangesHandler
)
mDeleteRangesHandlerConst
(
aDeleteRangesHandler
)
{
}
explicit
AutoBlockElementsJoiner
(
const
AutoDeleteRangesHandler
&
aDeleteRangesHandler
)
:
mDeleteRangesHandler
(
nullptr
)
mDeleteRangesHandlerConst
(
aDeleteRangesHandler
)
{
}
bool
PrepareToDeleteAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
;
bool
PrepareToDeleteAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
;
bool
PrepareToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
const
AutoRangeArray
&
aRangesToDelete
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
{
Result
<
EditActionResult
nsresult
>
result
=
HandleDeleteAtCurrentBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
aCaretPoint
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteAtCurrentBlockBoundary
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
JoinOtherBlock
:
{
Result
<
EditActionResult
nsresult
>
result
=
HandleDeleteAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aCaretPoint
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteAtOtherBlockBoundary
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteBRElement
:
{
Result
<
EditActionResult
nsresult
>
result
=
DeleteBRElement
(
aHTMLEditor
aDirectionAndAmount
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
DeleteBRElement
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
JoinBlocksInSameParent
:
case
Mode
:
:
DeleteContentInRanges
:
case
Mode
:
:
DeleteNonCollapsedRanges
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
Run
(
)
"
)
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
case
Mode
:
:
NotInitialized
:
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
nsresult
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
{
nsresult
rv
=
ComputeRangesToDeleteAtCurrentBlockBoundary
(
aHTMLEditor
aCaretPoint
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteAtCurrentBlockBoundary
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
JoinOtherBlock
:
{
nsresult
rv
=
ComputeRangesToDeleteAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
aCaretPoint
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteAtOtherBlockBoundary
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
DeleteBRElement
:
{
nsresult
rv
=
ComputeRangesToDeleteBRElement
(
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteBRElement
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
JoinBlocksInSameParent
:
case
Mode
:
:
DeleteContentInRanges
:
case
Mode
:
:
DeleteNonCollapsedRanges
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
"
"
ComputeRangesToDelete
(
)
"
)
;
return
NS_ERROR_UNEXPECTED
;
case
Mode
:
:
NotInitialized
:
return
NS_OK
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
case
Mode
:
:
JoinOtherBlock
:
case
Mode
:
:
DeleteBRElement
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
Run
(
)
"
)
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
case
Mode
:
:
JoinBlocksInSameParent
:
{
Result
<
EditActionResult
nsresult
>
result
=
JoinBlockElementsInSameParent
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
aSelectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
"
"
JoinBlockElementsInSameParent
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteContentInRanges
:
{
Result
<
EditActionResult
nsresult
>
result
=
DeleteContentInRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
DeleteContentInRanges
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
DeleteNonCollapsedRanges
:
{
Result
<
EditActionResult
nsresult
>
result
=
HandleDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
aSelectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
"
"
HandleDeleteNonCollapsedRange
(
)
failed
"
)
;
return
result
;
}
case
Mode
:
:
NotInitialized
:
MOZ_ASSERT_UNREACHABLE
(
"
Call
Run
(
)
after
calling
a
preparation
method
"
)
;
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
nsresult
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
const
{
switch
(
mMode
)
{
case
Mode
:
:
JoinCurrentBlock
:
case
Mode
:
:
JoinOtherBlock
:
case
Mode
:
:
DeleteBRElement
:
MOZ_ASSERT_UNREACHABLE
(
"
This
mode
should
be
handled
in
the
other
"
"
ComputeRangesToDelete
(
)
"
)
;
return
NS_ERROR_UNEXPECTED
;
case
Mode
:
:
JoinBlocksInSameParent
:
{
nsresult
rv
=
ComputeRangesToJoinBlockElementsInSameParent
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToJoinBlockElementsInSameParent
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
DeleteContentInRanges
:
{
nsresult
rv
=
ComputeRangesToDeleteContentInRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteContentInRanges
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
DeleteNonCollapsedRanges
:
{
nsresult
rv
=
ComputeRangesToDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aSelectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteNonCollapsedRanges
(
)
failed
"
)
;
return
rv
;
}
case
Mode
:
:
NotInitialized
:
MOZ_ASSERT_UNREACHABLE
(
"
Call
ComputeRangesToDelete
(
)
after
calling
a
preparation
"
"
method
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
NS_ERROR_NOT_INITIALIZED
;
}
nsIContent
*
GetLeafContentInOtherBlockElement
(
)
const
{
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
JoinOtherBlock
)
;
return
mLeafContentInOtherBlock
;
}
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteAtCurrentBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
ComputeRangesToDeleteAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
JoinBlockElementsInSameParent
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToJoinBlockElementsInSameParent
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
DeleteBRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteBRElement
(
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
DeleteContentInRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
;
nsresult
ComputeRangesToDeleteContentInRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
;
nsresult
ComputeRangesToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
const
;
MOZ_CAN_RUN_SCRIPT
Result
<
EditorDOMPoint
nsresult
>
JoinNodesDeepWithTransaction
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
;
MOZ_CAN_RUN_SCRIPT
Result
<
bool
nsresult
>
DeleteNodesEntirelyInRangeButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
;
bool
NeedsToJoinNodesAfterDeleteNodesEntirelyInRangeButKeepTableStructure
(
const
HTMLEditor
&
aHTMLEditor
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
const
;
Result
<
bool
nsresult
>
ComputeRangesToDeleteNodesEntirelyInRangeButKeepTableStructure
(
const
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteContentButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteTextAtStartAndEndOfRange
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
)
;
class
MOZ_STACK_CLASS
AutoInclusiveAncestorBlockElementsJoiner
final
{
public
:
AutoInclusiveAncestorBlockElementsJoiner
(
)
=
delete
;
AutoInclusiveAncestorBlockElementsJoiner
(
nsIContent
&
aInclusiveDescendantOfLeftBlockElement
nsIContent
&
aInclusiveDescendantOfRightBlockElement
)
:
mInclusiveDescendantOfLeftBlockElement
(
aInclusiveDescendantOfLeftBlockElement
)
mInclusiveDescendantOfRightBlockElement
(
aInclusiveDescendantOfRightBlockElement
)
mCanJoinBlocks
(
false
)
mFallbackToDeleteLeafContent
(
false
)
{
}
bool
IsSet
(
)
const
{
return
mLeftBlockElement
&
&
mRightBlockElement
;
}
bool
IsSameBlockElement
(
)
const
{
return
mLeftBlockElement
&
&
mLeftBlockElement
=
=
mRightBlockElement
;
}
const
EditorDOMPoint
&
PointRefToPutCaret
(
)
const
{
return
mPointToPutCaret
;
}
Result
<
bool
nsresult
>
Prepare
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
bool
CanJoinBlocks
(
)
const
{
return
mCanJoinBlocks
;
}
bool
ShouldDeleteLeafContentInstead
(
)
const
{
MOZ_ASSERT
(
CanJoinBlocks
(
)
)
;
return
mFallbackToDeleteLeafContent
;
}
nsresult
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
;
private
:
bool
CanMergeLeftAndRightBlockElements
(
)
const
{
if
(
!
IsSet
(
)
)
{
return
false
;
}
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mRightBlockElement
)
{
return
mNewListElementTagNameOfRightListElement
.
isSome
(
)
;
}
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mLeftBlockElement
)
{
return
mNewListElementTagNameOfRightListElement
.
isSome
(
)
&
&
!
mRightBlockElement
-
>
GetChildCount
(
)
;
}
MOZ_ASSERT
(
!
mPointContainingTheOtherBlockElement
.
IsSet
(
)
)
;
return
mNewListElementTagNameOfRightListElement
.
isSome
(
)
|
|
mLeftBlockElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
mRightBlockElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
OwningNonNull
<
nsIContent
>
mInclusiveDescendantOfLeftBlockElement
;
OwningNonNull
<
nsIContent
>
mInclusiveDescendantOfRightBlockElement
;
RefPtr
<
Element
>
mLeftBlockElement
;
RefPtr
<
Element
>
mRightBlockElement
;
Maybe
<
nsAtom
*
>
mNewListElementTagNameOfRightListElement
;
EditorDOMPoint
mPointContainingTheOtherBlockElement
;
EditorDOMPoint
mPointToPutCaret
;
RefPtr
<
dom
:
:
HTMLBRElement
>
mPrecedingInvisibleBRElement
;
bool
mCanJoinBlocks
;
bool
mFallbackToDeleteLeafContent
;
}
;
enum
class
Mode
{
NotInitialized
JoinCurrentBlock
JoinOtherBlock
JoinBlocksInSameParent
DeleteBRElement
DeleteContentInRanges
DeleteNonCollapsedRanges
}
;
AutoDeleteRangesHandler
*
mDeleteRangesHandler
;
const
AutoDeleteRangesHandler
&
mDeleteRangesHandlerConst
;
nsCOMPtr
<
nsIContent
>
mLeftContent
;
nsCOMPtr
<
nsIContent
>
mRightContent
;
nsCOMPtr
<
nsIContent
>
mLeafContentInOtherBlock
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
8
>
mSkippedInvisibleContents
;
RefPtr
<
dom
:
:
HTMLBRElement
>
mBRElement
;
Mode
mMode
=
Mode
:
:
NotInitialized
;
}
;
class
MOZ_STACK_CLASS
AutoEmptyBlockAncestorDeleter
final
{
public
:
[
[
nodiscard
]
]
Element
*
ScanEmptyBlockInclusiveAncestor
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aStartContent
)
;
nsresult
ComputeTargetRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
AutoRangeArray
&
aRangesToDelete
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
private
:
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditActionResult
nsresult
>
MaybeReplaceSubListWithNewListItem
(
HTMLEditor
&
aHTMLEditor
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
RefPtr
<
Element
>
nsresult
>
MaybeInsertBRElementBeforeEmptyListItemElement
(
HTMLEditor
&
aHTMLEditor
)
;
[
[
nodiscard
]
]
Result
<
CaretPoint
nsresult
>
GetNewCaretPosition
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
const
;
RefPtr
<
Element
>
mEmptyInclusiveAncestorBlockElement
;
}
;
const
AutoDeleteRangesHandler
*
const
mParent
;
nsIEditor
:
:
EDirection
mOriginalDirectionAndAmount
;
nsIEditor
:
:
EStripWrappers
mOriginalStripWrappers
;
}
;
nsresult
HTMLEditor
:
:
ComputeTargetRanges
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Element
*
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
aRangesToDelete
.
RemoveAllRanges
(
)
;
return
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
;
}
SelectedTableCellScanner
scanner
(
aRangesToDelete
)
;
if
(
scanner
.
IsInTableCellSelectionMode
(
)
)
{
if
(
scanner
.
ElementsRef
(
)
.
Length
(
)
=
=
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
)
{
return
NS_OK
;
}
size_t
removedRanges
=
0
;
for
(
size_t
i
=
1
;
i
<
scanner
.
ElementsRef
(
)
.
Length
(
)
;
i
+
+
)
{
if
(
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
aRangesToDelete
.
Ranges
(
)
[
i
-
removedRanges
]
)
!
=
scanner
.
ElementsRef
(
)
[
i
]
)
{
aRangesToDelete
.
Ranges
(
)
.
RemoveElementAt
(
i
-
removedRanges
)
;
removedRanges
+
+
;
}
}
return
NS_OK
;
}
aRangesToDelete
.
EnsureOnlyEditableRanges
(
*
editingHost
)
;
if
(
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
There
is
no
range
which
we
can
delete
entire
of
or
around
the
caret
"
)
;
return
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
;
}
AutoDeleteRangesHandler
deleteHandler
;
nsresult
rv
=
deleteHandler
.
ComputeRangesToDelete
(
*
this
aDirectionAndAmount
aRangesToDelete
*
editingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
HandleDeleteSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
if
(
MOZ_UNLIKELY
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
MOZ_UNLIKELY
(
!
editingHost
)
)
{
return
Err
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteSelection
=
true
;
if
(
MOZ_UNLIKELY
(
IsEmpty
(
)
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
if
(
HTMLEditUtils
:
:
IsInTableCellSelectionMode
(
SelectionRef
(
)
)
)
{
nsresult
rv
=
DeleteTableCellContentsWithTransaction
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableCellContentsWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
AutoRangeArray
rangesToDelete
(
SelectionRef
(
)
)
;
rangesToDelete
.
EnsureOnlyEditableRanges
(
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
rangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
)
{
NS_WARNING
(
"
There
is
no
range
which
we
can
delete
entire
the
ranges
or
around
the
"
"
caret
"
)
;
return
Err
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
AutoDeleteRangesHandler
deleteHandler
;
Result
<
EditActionResult
nsresult
>
result
=
deleteHandler
.
Run
(
*
this
aDirectionAndAmount
aStripWrappers
rangesToDelete
*
editingHost
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
|
|
result
.
inspect
(
)
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
result
;
}
const
auto
atNewStartOfSelection
=
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atNewStartOfSelection
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
atNewStartOfSelection
.
IsInContentNode
(
)
)
{
nsresult
rv
=
DeleteMostAncestorMailCiteElementIfEmpty
(
MOZ_KnownLive
(
*
atNewStartOfSelection
.
ContainerAs
<
nsIContent
>
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteMostAncestorMailCiteElementIfEmpty
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
mOriginalDirectionAndAmount
=
aDirectionAndAmount
;
mOriginalStripWrappers
=
nsIEditor
:
:
eNoStrip
;
if
(
aHTMLEditor
.
mPaddingBRElementForEmptyEditor
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
EditorRawDOMPoint
(
aHTMLEditor
.
mPaddingBRElementForEmptyEditor
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
SelectionWasCollapsed
selectionWasCollapsed
=
aRangesToDelete
.
IsCollapsed
(
)
?
SelectionWasCollapsed
:
:
Yes
:
SelectionWasCollapsed
:
:
No
;
if
(
selectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
const
auto
startPoint
=
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startPoint
.
IsInContentNode
(
)
)
{
AutoEmptyBlockAncestorDeleter
deleter
;
if
(
deleter
.
ScanEmptyBlockInclusiveAncestor
(
aHTMLEditor
*
startPoint
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
nsresult
rv
=
deleter
.
ComputeTargetRanges
(
aHTMLEditor
aDirectionAndAmount
*
editingHost
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoEmptyBlockAncestorDeleter
:
:
ComputeTargetRanges
(
)
failed
"
)
;
return
rv
;
}
}
AutoCaretBidiLevelManager
bidiLevelManager
(
aHTMLEditor
aDirectionAndAmount
startPoint
)
;
if
(
bidiLevelManager
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
AutoCaretBidiLevelManager
failed
to
initialize
itself
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
bidiLevelManager
.
Canceled
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
AutoSetTemporaryAncestorLimiter
autoSetter
(
aHTMLEditor
aHTMLEditor
.
SelectionRef
(
)
*
startPoint
.
GetContainer
(
)
&
aRangesToDelete
)
;
Result
<
nsIEditor
:
:
EDirection
nsresult
>
extendResult
=
aRangesToDelete
.
ExtendAnchorFocusRangeFor
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
extendResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
)
failed
"
)
;
return
extendResult
.
unwrapErr
(
)
;
}
Result
<
bool
nsresult
>
shrunkenResult
=
aRangesToDelete
.
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
aHTMLEditor
aDirectionAndAmount
AutoRangeArray
:
:
IfSelectingOnlyOneAtomicContent
:
:
Collapse
editingHost
)
;
if
(
shrunkenResult
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
)
"
"
failed
"
)
;
return
shrunkenResult
.
unwrapErr
(
)
;
}
if
(
!
shrunkenResult
.
inspect
(
)
|
|
!
aRangesToDelete
.
IsCollapsed
(
)
)
{
aDirectionAndAmount
=
extendResult
.
unwrap
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNone
)
{
MOZ_ASSERT
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
;
if
(
!
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
nsresult
rv
=
FallbackToComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
FallbackToComputeRangesToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
const
auto
caretPoint
=
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
caretPoint
.
IsInContentNode
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
caretPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
WSRunScanner
wsRunScannerAtCaret
(
editingHost
caretPoint
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
)
;
if
(
scanFromCaretPointResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
Scan
(
Next
|
Previous
)
VisibleNodeOrBlockBoundaryFrom
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
scanFromCaretPointResult
.
GetContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
scanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
scanFromCaretPointResult
.
BRElementPtr
(
)
=
=
wsRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
EditorType
:
:
HTML
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
{
EditorDOMPoint
newCaretPosition
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
EditorDOMPoint
:
:
After
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
:
EditorDOMPoint
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
;
if
(
NS_WARN_IF
(
!
newCaretPosition
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoHideSelectionChanges
blockSelectionListeners
(
aHTMLEditor
.
SelectionRef
(
)
)
;
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPosition
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
aHTMLEditor
.
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
aRangesToDelete
.
Initialize
(
aHTMLEditor
.
SelectionRef
(
)
)
;
AutoDeleteRangesHandler
anotherHandler
(
this
)
;
rv
=
anotherHandler
.
ComputeRangesToDelete
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Recursive
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
)
"
"
failed
"
)
;
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
caretPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
"
"
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
to
"
"
restore
original
selection
but
ignored
"
)
;
MOZ_ASSERT
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
;
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
SelectNode
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SelectNode
(
)
failed
"
)
;
return
rv
;
}
if
(
EditorRawDOMPoint
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
.
IsBefore
(
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
)
)
{
nsresult
rv
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
EditorRawDOMPoint
(
scanFromCaretPointResult
.
BRElementPtr
(
)
)
.
ToRawRangeBoundary
(
)
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
if
(
aRangesToDelete
.
GetFirstRangeEndPoint
<
EditorRawDOMPoint
>
(
)
.
IsBefore
(
EditorRawDOMPoint
:
:
After
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
)
{
nsresult
rv
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
EditorRawDOMPoint
:
:
After
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING
(
"
Was
the
invisible
<
br
>
element
selected
?
"
)
;
return
NS_OK
;
}
}
nsresult
rv
=
ComputeRangesToDeleteAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
wsRunScannerAtCaret
scanFromCaretPointResult
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAroundCollapsedRanges
(
"
"
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
ComputeRangesToDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
selectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteNonCollapsedRanges
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
nsIEditor
:
:
eStrip
|
|
aStripWrappers
=
=
nsIEditor
:
:
eNoStrip
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
mOriginalDirectionAndAmount
=
aDirectionAndAmount
;
mOriginalStripWrappers
=
aStripWrappers
;
if
(
MOZ_UNLIKELY
(
aHTMLEditor
.
IsEmpty
(
)
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
SelectionWasCollapsed
selectionWasCollapsed
=
aRangesToDelete
.
IsCollapsed
(
)
?
SelectionWasCollapsed
:
:
Yes
:
SelectionWasCollapsed
:
:
No
;
if
(
selectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
)
{
const
auto
startPoint
=
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
startPoint
.
IsInContentNode
(
)
)
{
#
ifdef
DEBUG
nsMutationGuard
debugMutation
;
#
endif
AutoEmptyBlockAncestorDeleter
deleter
;
if
(
deleter
.
ScanEmptyBlockInclusiveAncestor
(
aHTMLEditor
*
startPoint
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
Result
<
EditActionResult
nsresult
>
result
=
deleter
.
Run
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
|
|
result
.
inspect
(
)
.
Handled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoEmptyBlockAncestorDeleter
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
MOZ_ASSERT
(
!
debugMutation
.
Mutated
(
0
)
"
AutoEmptyBlockAncestorDeleter
shouldn
'
t
modify
the
DOM
tree
"
"
if
it
returns
not
handled
nor
error
"
)
;
}
AutoCaretBidiLevelManager
bidiLevelManager
(
aHTMLEditor
aDirectionAndAmount
startPoint
)
;
if
(
MOZ_UNLIKELY
(
bidiLevelManager
.
Failed
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
AutoCaretBidiLevelManager
failed
to
initialize
itself
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
bidiLevelManager
.
MaybeUpdateCaretBidiLevel
(
aHTMLEditor
)
;
if
(
bidiLevelManager
.
Canceled
(
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
AutoSetTemporaryAncestorLimiter
autoSetter
(
aHTMLEditor
aHTMLEditor
.
SelectionRef
(
)
*
startPoint
.
GetContainer
(
)
&
aRangesToDelete
)
;
Maybe
<
EditorDOMPoint
>
caretPoint
;
if
(
aRangesToDelete
.
IsCollapsed
(
)
&
&
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
{
caretPoint
=
Some
(
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
NS_WARN_IF
(
!
caretPoint
.
ref
(
)
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
Result
<
nsIEditor
:
:
EDirection
nsresult
>
extendResult
=
aRangesToDelete
.
ExtendAnchorFocusRangeFor
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
MOZ_UNLIKELY
(
extendResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ExtendAnchorFocusRangeFor
(
)
failed
"
)
;
return
extendResult
.
propagateErr
(
)
;
}
if
(
caretPoint
.
isSome
(
)
&
&
MOZ_UNLIKELY
(
!
caretPoint
.
ref
(
)
.
IsSetAndValid
(
)
)
)
{
NS_WARNING
(
"
The
caret
position
became
invalid
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
Result
<
bool
nsresult
>
shrunkenResult
=
aRangesToDelete
.
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
aHTMLEditor
aDirectionAndAmount
AutoRangeArray
:
:
IfSelectingOnlyOneAtomicContent
:
:
Collapse
&
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
shrunkenResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
)
"
"
failed
"
)
;
return
shrunkenResult
.
propagateErr
(
)
;
}
if
(
!
shrunkenResult
.
inspect
(
)
|
|
!
aRangesToDelete
.
IsCollapsed
(
)
)
{
aDirectionAndAmount
=
extendResult
.
unwrap
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNone
)
{
MOZ_ASSERT
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
;
if
(
!
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
FallbackToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
FallbackToDeleteRangesWithTransaction
(
)
"
"
failed
"
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
aRangesToDelete
.
IsCollapsed
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
caretPoint
.
ref
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
WSRunScanner
wsRunScannerAtCaret
(
&
aEditingHost
caretPoint
.
ref
(
)
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
;
if
(
MOZ_UNLIKELY
(
scanFromCaretPointResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
Scan
(
Next
|
Previous
)
VisibleNodeOrBlockBoundaryFrom
(
)
"
"
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
scanFromCaretPointResult
.
GetContent
(
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
if
(
scanFromCaretPointResult
.
ReachedBRElement
(
)
)
{
if
(
scanFromCaretPointResult
.
BRElementPtr
(
)
=
=
&
aEditingHost
)
{
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
EditorType
:
:
HTML
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
if
(
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
aHTMLEditor
MOZ_KnownLive
(
*
scanFromCaretPointResult
.
BRElementPtr
(
)
)
caretPoint
.
ref
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
DeleteContentNodeAndJoinTextNodesAroundIt
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
if
(
caretPointOrError
.
inspect
(
)
.
HasCaretPointSuggestion
(
)
)
{
caretPoint
=
Some
(
caretPointOrError
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
)
;
}
if
(
NS_WARN_IF
(
!
caretPoint
-
>
IsSetAndValid
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
AutoRangeArray
rangesToDelete
(
caretPoint
.
ref
(
)
)
;
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
)
)
{
WSRunScanner
wsRunScannerAtCaret
(
&
aEditingHost
caretPoint
.
ref
(
)
)
;
WSScanResult
scanFromCaretPointResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
wsRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
:
wsRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
caretPoint
.
ref
(
)
)
;
if
(
MOZ_UNLIKELY
(
scanFromCaretPointResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
Scan
(
Next
|
Previous
)
"
"
VisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
MOZ_UNLIKELY
(
scanFromCaretPointResult
.
ReachedInvisibleBRElement
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
AutoDeleteRangesHandler
anotherHandler
(
this
)
;
Result
<
EditActionResult
nsresult
>
result
=
anotherHandler
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
rangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
Recursive
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
result
;
}
}
Result
<
EditActionResult
nsresult
>
result
=
HandleDeleteAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
wsRunScannerAtCaret
scanFromCaretPointResult
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteAroundCollapsedRanges
(
)
failed
"
)
;
return
result
;
}
}
Result
<
EditActionResult
nsresult
>
result
=
HandleDeleteNonCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
selectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoDeleteRangesHandler
:
:
HandleDeleteNonCollapsedRanges
(
)
failed
"
)
;
return
result
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAroundCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
const
Element
&
aEditingHost
)
const
{
if
(
aScanFromCaretPointResult
.
InCollapsibleWhiteSpaces
(
)
|
|
aScanFromCaretPointResult
.
InNonCollapsibleCharacters
(
)
|
|
aScanFromCaretPointResult
.
ReachedPreformattedLineBreak
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aScanFromCaretPointResult
.
Point
<
EditorRawDOMPoint
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
ComputeRangesToDeleteTextAroundCollapsedRanges
(
aDirectionAndAmount
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteTextAroundCollapsedRanges
(
)
failed
"
)
;
return
rv
;
}
if
(
aScanFromCaretPointResult
.
ReachedSpecialContent
(
)
|
|
aScanFromCaretPointResult
.
ReachedBRElement
(
)
|
|
aScanFromCaretPointResult
.
ReachedHRElement
(
)
|
|
aScanFromCaretPointResult
.
ReachedNonEditableOtherBlockElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
nsIContent
*
atomicContent
=
GetAtomicContentToDelete
(
aDirectionAndAmount
aWSRunScannerAtCaret
aScanFromCaretPointResult
)
;
if
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
atomicContent
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
GetAtomicContentToDelete
(
)
cannot
find
"
"
removable
atomic
content
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
ComputeRangesToDeleteAtomicContent
(
aWSRunScannerAtCaret
.
GetEditingHost
(
)
*
atomicContent
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
)
failed
"
)
;
return
rv
;
}
if
(
aScanFromCaretPointResult
.
ReachedOtherBlockElement
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
aDirectionAndAmount
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
ComputeRangesToDelete
(
)
"
"
failed
(
other
block
boundary
)
"
)
;
return
rv
;
}
if
(
aScanFromCaretPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteAtCurrentBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
aDirectionAndAmount
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
ComputeRangesToDelete
(
)
"
"
failed
(
current
block
boundary
)
"
)
;
return
rv
;
}
return
NS_OK
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
!
=
nsIEditor
:
:
eNone
)
;
MOZ_ASSERT
(
aWSRunScannerAtCaret
.
ScanStartRef
(
)
.
IsInContentNode
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aWSRunScannerAtCaret
.
ScanStartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
;
if
(
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
if
(
aScanFromCaretPointResult
.
InCollapsibleWhiteSpaces
(
)
|
|
aScanFromCaretPointResult
.
InNonCollapsibleCharacters
(
)
|
|
aScanFromCaretPointResult
.
ReachedPreformattedLineBreak
(
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aScanFromCaretPointResult
.
Point
<
EditorRawDOMPoint
>
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
HandleDeleteTextAroundCollapsedRanges
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
HandleDeleteTextAroundCollapsedRanges
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPoint
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
}
if
(
aScanFromCaretPointResult
.
InCollapsibleWhiteSpaces
(
)
|
|
aScanFromCaretPointResult
.
ReachedPreformattedLineBreak
(
)
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
aHTMLEditor
aDirectionAndAmount
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
aScanFromCaretPointResult
.
InNonCollapsibleCharacters
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsText
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
HandleDeleteCollapsedSelectionAtVisibleChar
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aScanFromCaretPointResult
.
Point
<
EditorDOMPoint
>
(
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
"
"
HandleDeleteCollapsedSelectionAtVisibleChar
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
aScanFromCaretPointResult
.
ReachedSpecialContent
(
)
|
|
aScanFromCaretPointResult
.
ReachedBRElement
(
)
|
|
aScanFromCaretPointResult
.
ReachedHRElement
(
)
|
|
aScanFromCaretPointResult
.
ReachedNonEditableOtherBlockElement
(
)
)
{
if
(
aScanFromCaretPointResult
.
GetContent
(
)
=
=
&
aEditingHost
)
{
return
EditActionResult
:
:
HandledResult
(
)
;
}
nsCOMPtr
<
nsIContent
>
atomicContent
=
GetAtomicContentToDelete
(
aDirectionAndAmount
aWSRunScannerAtCaret
aScanFromCaretPointResult
)
;
if
(
MOZ_UNLIKELY
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
atomicContent
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
GetAtomicContentToDelete
(
)
cannot
find
"
"
removable
atomic
content
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
HandleDeleteAtomicContent
(
aHTMLEditor
*
atomicContent
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
HandleDeleteAtomicContent
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
unwrap
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
aScanFromCaretPointResult
.
ReachedOtherBlockElement
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteAtOtherBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aWSRunScannerAtCaret
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
Result
<
EditActionResult
nsresult
>
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
(
other
block
boundary
)
"
)
;
return
result
;
}
if
(
aScanFromCaretPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
if
(
NS_WARN_IF
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsElement
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteAtCurrentBlockBoundary
(
aHTMLEditor
aDirectionAndAmount
*
aScanFromCaretPointResult
.
ElementPtr
(
)
aWSRunScannerAtCaret
.
ScanStartRef
(
)
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
Result
<
EditActionResult
nsresult
>
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aWSRunScannerAtCaret
.
ScanStartRef
(
)
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
(
current
block
boundary
)
"
)
;
return
result
;
}
MOZ_ASSERT_UNREACHABLE
(
"
New
type
of
reached
content
hasn
'
t
been
handled
yet
"
)
;
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteTextAroundCollapsedRanges
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
;
const
auto
caretPosition
=
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
MOZ_ASSERT
(
caretPosition
.
IsSetAndValid
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
caretPosition
.
IsInContentNode
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
Result
<
EditorDOMRangeInTexts
nsresult
>
result
=
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
caretPosition
aEditingHost
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
rangeToDelete
=
result
.
unwrap
(
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
return
NS_OK
;
}
}
else
{
Result
<
EditorDOMRangeInTexts
nsresult
>
result
=
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
caretPosition
aEditingHost
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
)
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
rangeToDelete
=
result
.
unwrap
(
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
return
NS_OK
;
}
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
rangeToDelete
.
StartRef
(
)
rangeToDelete
.
EndRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoArrayRanges
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteTextAroundCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
|
|
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
;
nsresult
rv
=
ComputeRangesToDeleteTextAroundCollapsedRanges
(
aDirectionAndAmount
aRangesToDelete
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
MOZ_UNLIKELY
(
aRangesToDelete
.
IsCollapsed
(
)
)
)
{
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
EditorRawDOMRange
rangeToDelete
(
aRangesToDelete
.
FirstRangeRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
rangeToDelete
.
IsInTextNodes
(
)
)
)
{
NS_WARNING
(
"
The
extended
range
to
delete
character
was
not
in
text
nodes
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
rangeToDelete
.
StartRef
(
)
.
AsInText
(
)
rangeToDelete
.
EndRef
(
)
.
AsInText
(
)
TreatEmptyTextNodes
:
:
RemoveAllEmptyInlineAncestors
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
DeleteDirection
:
:
Forward
:
DeleteDirection
:
:
Backward
)
;
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidNormalizeWhitespaces
=
true
;
NS_WARNING_ASSERTION
(
caretPointOrError
.
isOk
(
)
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
failed
"
)
;
return
caretPointOrError
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteCollapsedSelectionAtWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aPointToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
aHTMLEditor
aPointToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
)
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
else
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
aHTMLEditor
aPointToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
)
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
const
auto
newCaretPosition
=
aHTMLEditor
.
GetFirstSelectionStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
newCaretPosition
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
There
was
no
selection
range
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
newCaretPosition
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteCollapsedSelectionAtVisibleChar
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
const
EditorDOMPoint
&
aPointAtDeletingChar
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
;
MOZ_ASSERT
(
aPointAtDeletingChar
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aPointAtDeletingChar
.
IsInTextNode
(
)
)
;
OwningNonNull
<
Text
>
visibleTextNode
=
*
aPointAtDeletingChar
.
ContainerAs
<
Text
>
(
)
;
EditorDOMPoint
startToDelete
endToDelete
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
if
(
MOZ_UNLIKELY
(
aPointAtDeletingChar
.
IsStartOfContainer
(
)
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
startToDelete
=
aPointAtDeletingChar
.
PreviousPoint
(
)
;
endToDelete
=
aPointAtDeletingChar
;
if
(
!
startToDelete
.
IsStartOfContainer
(
)
)
{
const
nsTextFragment
*
text
=
&
visibleTextNode
-
>
TextFragment
(
)
;
if
(
text
-
>
IsLowSurrogateFollowingHighSurrogateAt
(
startToDelete
.
Offset
(
)
)
)
{
startToDelete
.
RewindOffset
(
)
;
}
}
}
else
{
if
(
NS_WARN_IF
(
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
!
=
aPointAtDeletingChar
.
GetContainer
(
)
)
|
|
NS_WARN_IF
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
!
=
aPointAtDeletingChar
.
GetContainer
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
startToDelete
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
;
endToDelete
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
;
}
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
IsInTextNode
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsInTextNode
(
)
)
|
|
NS_WARN_IF
(
startToDelete
.
ContainerAs
<
Text
>
(
)
!
=
visibleTextNode
)
|
|
NS_WARN_IF
(
endToDelete
.
ContainerAs
<
Text
>
(
)
!
=
visibleTextNode
)
|
|
NS_WARN_IF
(
startToDelete
.
Offset
(
)
>
=
endToDelete
.
Offset
(
)
)
)
)
{
NS_WARNING
(
"
Mutation
event
listener
changed
the
DOM
tree
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
EditorDOMPoint
pointToPutCaret
=
startToDelete
;
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextWithTransaction
(
visibleTextNode
startToDelete
.
Offset
(
)
endToDelete
.
Offset
(
)
-
startToDelete
.
Offset
(
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
visibleTextNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
but
ignored
"
)
;
}
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
nsIContent
*
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
GetAtomicContentToDelete
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
WSRunScanner
&
aWSRunScannerAtCaret
const
WSScanResult
&
aScanFromCaretPointResult
)
{
MOZ_ASSERT
(
aScanFromCaretPointResult
.
GetContent
(
)
)
;
if
(
!
aScanFromCaretPointResult
.
ReachedSpecialContent
(
)
)
{
return
aScanFromCaretPointResult
.
GetContent
(
)
;
}
if
(
!
aScanFromCaretPointResult
.
GetContent
(
)
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsRemovableNode
(
*
aScanFromCaretPointResult
.
GetContent
(
)
)
)
{
return
aScanFromCaretPointResult
.
GetContent
(
)
;
}
nsIContent
*
removableRoot
=
aScanFromCaretPointResult
.
GetContent
(
)
;
while
(
removableRoot
&
&
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
removableRoot
)
)
{
removableRoot
=
removableRoot
-
>
GetParent
(
)
;
}
if
(
removableRoot
)
{
return
removableRoot
;
}
return
aScanFromCaretPointResult
.
GetContent
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteAtomicContent
(
Element
*
aEditingHost
const
nsIContent
&
aAtomicContent
AutoRangeArray
&
aRangesToDelete
)
const
{
EditorDOMRange
rangeToDelete
=
WSRunScanner
:
:
GetRangesForDeletingAtomicContent
(
aEditingHost
aAtomicContent
)
;
if
(
!
rangeToDelete
.
IsPositioned
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeForDeleteAContentNode
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
rangeToDelete
.
StartRef
(
)
rangeToDelete
.
EndRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteAtomicContent
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aAtomicContent
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
aAtomicContent
)
)
;
MOZ_ASSERT
(
&
aAtomicContent
!
=
aWSRunScannerAtCaret
.
GetEditingHost
(
)
)
;
EditorDOMPoint
pointToPutCaret
=
aCaretPoint
;
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
aHTMLEditor
aAtomicContent
aCaretPoint
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
DeleteContentNodeAndJoinTextNodesAroundIt
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
{
AutoTrackDOMPoint
trackPointToPutCaret
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertBRElementIfHardLineIsEmptyAndEndsWithBlockBoundary
(
)
"
"
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
if
(
NS_WARN_IF
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aOtherBlockElement
const
EditorDOMPoint
&
aCaretPoint
const
WSRunScanner
&
aWSRunScannerAtCaret
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
mMode
=
Mode
:
:
JoinOtherBlock
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aOtherBlockElement
)
)
{
return
false
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
mLeafContentInOtherBlock
=
HTMLEditUtils
:
:
GetLastLeafContent
(
aOtherBlockElement
{
LeafNodeType
:
:
OnlyEditableLeafNode
}
&
aOtherBlockElement
)
;
mLeftContent
=
mLeafContentInOtherBlock
;
mRightContent
=
aCaretPoint
.
GetContainerAs
<
nsIContent
>
(
)
;
}
else
{
mLeafContentInOtherBlock
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
aOtherBlockElement
{
LeafNodeType
:
:
OnlyEditableLeafNode
}
&
aOtherBlockElement
)
;
mLeftContent
=
aCaretPoint
.
GetContainerAs
<
nsIContent
>
(
)
;
mRightContent
=
mLeafContentInOtherBlock
;
}
WSScanResult
scanFromCaretResult
=
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
?
aWSRunScannerAtCaret
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
:
aWSRunScannerAtCaret
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aCaretPoint
)
;
if
(
scanFromCaretResult
.
ReachedBRElement
(
)
)
{
mBRElement
=
scanFromCaretResult
.
BRElementPtr
(
)
;
mMode
=
Mode
:
:
DeleteBRElement
;
return
true
;
}
return
mLeftContent
&
&
mRightContent
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteBRElement
(
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
mBRElement
)
;
nsresult
rv
=
aRangesToDelete
.
SelectNode
(
*
mBRElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SelectNode
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteBRElement
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mBRElement
)
;
EditorDOMPoint
pointToPutCaret
=
[
&
]
(
)
{
if
(
!
MayEditActionDeleteAroundCollapsedSelection
(
aHTMLEditor
.
GetEditAction
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
WSRunScanner
scanner
(
&
aEditingHost
EditorRawDOMPoint
(
mBRElement
)
)
;
WSScanResult
maybePreviousText
=
scanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
EditorRawDOMPoint
(
mBRElement
)
)
;
if
(
maybePreviousText
.
IsContentEditable
(
)
&
&
maybePreviousText
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
HTMLEditor
:
:
GetLinkElement
(
maybePreviousText
.
TextPtr
(
)
)
)
{
return
maybePreviousText
.
Point
<
EditorDOMPoint
>
(
)
;
}
WSScanResult
maybeNextText
=
scanner
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
EditorRawDOMPoint
:
:
After
(
*
mBRElement
)
)
;
if
(
maybeNextText
.
IsContentEditable
(
)
&
&
maybeNextText
.
InVisibleOrCollapsibleCharacters
(
)
)
{
return
maybeNextText
.
Point
<
EditorDOMPoint
>
(
)
;
}
return
EditorDOMPoint
(
)
;
}
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
mBRElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
mLeftContent
&
&
mRightContent
&
&
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mLeftContent
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mRightContent
)
)
{
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
NS_WARN_IF
(
!
mLeafContentInOtherBlock
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
nsIEditor
:
:
DirectionIsBackspace
(
aDirectionAndAmount
)
)
{
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
}
if
(
HTMLEditor
:
:
GetLinkElement
(
pointToPutCaret
.
GetContainer
(
)
)
)
{
aHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearLinkAndItsSpecifiedStyle
(
)
;
}
}
else
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
EditorRawDOMPoint
newCaretPosition
=
HTMLEditUtils
:
:
GetGoodCaretPointFor
<
EditorRawDOMPoint
>
(
*
mLeafContentInOtherBlock
aDirectionAndAmount
)
;
if
(
MOZ_UNLIKELY
(
!
newCaretPosition
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPosition
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteAtOtherBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
if
(
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mLeftContent
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mRightContent
)
)
{
if
(
!
mDeleteRangesHandlerConst
.
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
mDeleteRangesHandlerConst
.
FallbackToComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
FallbackToComputeRangesToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
canJoinThem
.
unwrapErr
(
)
;
}
if
(
canJoinThem
.
inspect
(
)
&
&
joiner
.
CanJoinBlocks
(
)
&
&
!
joiner
.
ShouldDeleteLeafContentInstead
(
)
)
{
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
aCaretPoint
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
ComputeRangesToDelete
(
)
"
"
failed
"
)
;
return
rv
;
}
if
(
mLeafContentInOtherBlock
=
=
aCaretPoint
.
GetContainer
(
)
)
{
return
NS_OK
;
}
AutoHideSelectionChanges
hideSelectionChanges
(
aHTMLEditor
.
SelectionRef
(
)
)
;
EditorRawDOMPoint
newCaretPoint
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
EditorRawDOMPoint
:
:
AtEndOf
(
*
mLeafContentInOtherBlock
)
:
EditorRawDOMPoint
(
mLeafContentInOtherBlock
0
)
;
if
(
aRangesToDelete
.
IsCollapsed
(
)
&
&
aRangesToDelete
.
FocusRef
(
)
=
=
newCaretPoint
.
ToRawRangeBoundary
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPoint
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aRangesToDelete
.
Initialize
(
aHTMLEditor
.
SelectionRef
(
)
)
;
AutoDeleteRangesHandler
anotherHandler
(
mDeleteRangesHandlerConst
)
;
rv
=
anotherHandler
.
ComputeRangesToDelete
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Recursive
AutoDeleteRangesHandler
:
:
ComputeRangesToDelete
(
)
failed
"
)
;
}
nsresult
rvCollapsingSelectionTo
=
aHTMLEditor
.
CollapseSelectionTo
(
aCaretPoint
)
;
if
(
MOZ_UNLIKELY
(
rvCollapsingSelectionTo
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvCollapsingSelectionTo
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
to
restore
caret
position
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
rvCollapsingSelectionTo
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteAtOtherBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aCaretPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mDeleteRangesHandler
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
if
(
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mLeftContent
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mRightContent
)
)
{
if
(
!
mDeleteRangesHandler
-
>
CanFallbackToDeleteRangesWithTransaction
(
aRangesToDelete
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
mDeleteRangesHandler
-
>
FallbackToDeleteRangesWithTransaction
(
aHTMLEditor
aRangesToDelete
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
FallbackToDeleteRangesWithTransaction
(
)
"
"
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
canJoinThem
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
canJoinThem
.
propagateErr
(
)
;
}
if
(
!
canJoinThem
.
inspect
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
aCaretPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
CanceledResult
(
)
;
}
auto
result
=
EditActionResult
:
:
IgnoredResult
(
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
if
(
joiner
.
CanJoinBlocks
(
)
)
{
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
EditActionResult
nsresult
>
joinResult
=
joiner
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
joinResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
joinResult
;
}
result
|
=
joinResult
.
unwrap
(
)
;
#
ifdef
DEBUG
if
(
joiner
.
ShouldDeleteLeafContentInstead
(
)
)
{
NS_ASSERTION
(
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
ignored
but
returned
not
ignored
"
)
;
}
else
{
NS_ASSERTION
(
!
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
handled
but
returned
ignored
"
)
;
}
#
endif
if
(
result
.
Handled
(
)
&
&
joiner
.
PointRefToPutCaret
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
joiner
.
PointRefToPutCaret
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
if
(
nsIEditor
:
:
DirectionIsBackspace
(
aDirectionAndAmount
)
)
{
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
}
if
(
HTMLEditor
:
:
GetLinkElement
(
joiner
.
PointRefToPutCaret
(
)
.
GetContainer
(
)
)
)
{
aHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearLinkAndItsSpecifiedStyle
(
)
;
}
return
result
;
}
}
if
(
result
.
Ignored
(
)
&
&
mLeafContentInOtherBlock
!
=
aCaretPoint
.
GetContainer
(
)
)
{
EditorRawDOMPoint
newCaretPoint
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
EditorRawDOMPoint
:
:
AtEndOf
(
*
mLeafContentInOtherBlock
)
:
EditorRawDOMPoint
(
mLeafContentInOtherBlock
0
)
;
if
(
aRangesToDelete
.
IsCollapsed
(
)
&
&
aRangesToDelete
.
FocusRef
(
)
=
=
newCaretPoint
.
ToRawRangeBoundary
(
)
)
{
return
EditActionResult
:
:
CanceledResult
(
)
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
newCaretPoint
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
AutoRangeArray
rangesToDelete
(
aHTMLEditor
.
SelectionRef
(
)
)
;
AutoDeleteRangesHandler
anotherHandler
(
mDeleteRangesHandler
)
;
Result
<
EditActionResult
nsresult
>
fallbackResult
=
anotherHandler
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
rangesToDelete
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
fallbackResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
Recursive
AutoDeleteRangesHandler
:
:
Run
(
)
failed
"
)
;
return
fallbackResult
;
}
result
|
=
fallbackResult
.
unwrap
(
)
;
return
result
;
}
}
else
{
result
.
MarkAsHandled
(
)
;
}
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
Element
&
aCurrentBlockElement
const
EditorDOMPoint
&
aCaretPoint
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
mMode
=
Mode
:
:
JoinCurrentBlock
;
if
(
aCurrentBlockElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
html
nsGkAtoms
:
:
head
nsGkAtoms
:
:
body
)
)
{
return
false
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aCurrentBlockElement
)
)
{
return
false
;
}
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
false
;
}
auto
ScanJoinTarget
=
[
&
]
(
)
-
>
nsIContent
*
{
nsIContent
*
targetContent
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
HTMLEditUtils
:
:
GetPreviousContent
(
aCurrentBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
:
HTMLEditUtils
:
:
GetNextContent
(
aCurrentBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
;
auto
IsIgnorableDataNode
=
[
]
(
nsIContent
*
aContent
)
{
return
aContent
&
&
HTMLEditUtils
:
:
IsRemovableNode
(
*
aContent
)
&
&
(
(
aContent
-
>
IsText
(
)
&
&
aContent
-
>
AsText
(
)
-
>
TextIsOnlyWhitespace
(
)
&
&
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
aContent
-
>
AsText
(
)
)
)
|
|
(
aContent
-
>
IsCharacterData
(
)
&
&
!
aContent
-
>
IsText
(
)
)
)
;
}
;
if
(
!
IsIgnorableDataNode
(
targetContent
)
)
{
return
targetContent
;
}
MOZ_ASSERT
(
mSkippedInvisibleContents
.
IsEmpty
(
)
)
;
for
(
nsIContent
*
adjacentContent
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
HTMLEditUtils
:
:
GetPreviousContent
(
*
targetContent
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
:
HTMLEditUtils
:
:
GetNextContent
(
*
targetContent
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
;
adjacentContent
;
adjacentContent
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
HTMLEditUtils
:
:
GetPreviousContent
(
*
adjacentContent
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
:
HTMLEditUtils
:
:
GetNextContent
(
*
adjacentContent
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
adjacentContent
)
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
adjacentContent
)
)
{
nsIContent
*
leafContent
=
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
HTMLEditUtils
:
:
GetLastLeafContent
(
*
adjacentContent
{
LeafNodeType
:
:
OnlyEditableLeafNode
}
)
:
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
adjacentContent
{
LeafNodeType
:
:
OnlyEditableLeafNode
}
)
;
mSkippedInvisibleContents
.
AppendElement
(
*
targetContent
)
;
return
leafContent
?
leafContent
:
adjacentContent
;
}
if
(
IsIgnorableDataNode
(
adjacentContent
)
)
{
mSkippedInvisibleContents
.
AppendElement
(
*
targetContent
)
;
targetContent
=
adjacentContent
;
continue
;
}
break
;
}
return
targetContent
;
}
;
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
)
{
mLeftContent
=
ScanJoinTarget
(
)
;
mRightContent
=
aCaretPoint
.
GetContainerAs
<
nsIContent
>
(
)
;
}
else
{
mRightContent
=
ScanJoinTarget
(
)
;
mLeftContent
=
aCaretPoint
.
GetContainerAs
<
nsIContent
>
(
)
;
}
if
(
!
mLeftContent
|
|
!
mRightContent
)
{
return
false
;
}
return
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mLeftContent
)
=
=
HTMLEditUtils
:
:
GetInclusiveAncestorAnyTableElement
(
*
mRightContent
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteAtCurrentBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
canJoinThem
.
unwrapErr
(
)
;
}
if
(
canJoinThem
.
inspect
(
)
)
{
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
aCaretPoint
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
"
"
ComputeRangesToDelete
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteAtCurrentBlockBoundary
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aCaretPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mRightContent
)
;
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
canJoinThem
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
Err
(
canJoinThem
.
unwrapErr
(
)
)
;
}
if
(
!
canJoinThem
.
inspect
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
aCaretPoint
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
CanceledResult
(
)
;
}
EditActionResult
result
=
EditActionResult
:
:
IgnoredResult
(
)
;
EditorDOMPoint
pointToPutCaret
(
aCaretPoint
)
;
if
(
joiner
.
CanJoinBlocks
(
)
)
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
EditActionResult
nsresult
>
joinResult
=
joiner
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
joinResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
joinResult
;
}
result
|
=
joinResult
.
unwrap
(
)
;
#
ifdef
DEBUG
if
(
joiner
.
ShouldDeleteLeafContentInstead
(
)
)
{
NS_ASSERTION
(
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
ignored
but
returned
not
ignored
"
)
;
}
else
{
NS_ASSERTION
(
!
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
handled
but
returned
ignored
"
)
;
}
#
endif
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
mSkippedInvisibleContents
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
mSkippedInvisibleContents
.
Clear
(
)
;
if
(
result
.
Handled
(
)
&
&
joiner
.
PointRefToPutCaret
(
)
.
IsSet
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
joiner
.
PointRefToPutCaret
(
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
if
(
nsIEditor
:
:
DirectionIsBackspace
(
aDirectionAndAmount
)
)
{
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
}
if
(
HTMLEditor
:
:
GetLinkElement
(
joiner
.
PointRefToPutCaret
(
)
.
GetContainer
(
)
)
)
{
aHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearLinkAndItsSpecifiedStyle
(
)
;
}
return
result
;
}
}
result
.
MarkAsHandled
(
)
;
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
result
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
{
nsFrameSelection
*
frameSelection
=
aHTMLEditor
.
SelectionRef
(
)
.
GetFrameSelection
(
)
;
if
(
NS_WARN_IF
(
!
frameSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
Result
<
EditorRawDOMRange
nsresult
>
result
=
ExtendOrShrinkRangeToDelete
(
aHTMLEditor
frameSelection
EditorRawDOMRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
ExtendOrShrinkRangeToDelete
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorRawDOMRange
newRange
(
result
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
newRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
newRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
IsPositioned
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
Collapsed
(
)
)
)
{
return
NS_OK
;
}
}
if
(
!
aHTMLEditor
.
IsInPlaintextMode
(
)
)
{
EditorDOMRange
firstRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
;
EditorDOMRange
extendedRange
=
WSRunScanner
:
:
GetRangeContainingInvisibleWhiteSpacesAtRangeBoundaries
(
aHTMLEditor
.
ComputeEditingHost
(
)
EditorDOMRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
firstRange
!
=
extendedRange
)
{
nsresult
rv
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
extendedRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
extendedRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
if
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
{
if
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
Collapsed
(
)
)
{
nsresult
rv
=
ComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteRangesWithTransaction
(
"
"
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
Element
*
startCiteNode
=
aHTMLEditor
.
GetMostDistantAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
)
;
Element
*
endCiteNode
=
aHTMLEditor
.
GetMostDistantAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteNonCollapsedRanges
(
aHTMLEditor
aRangesToDelete
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
aSelectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
ComputeRangesToDelete
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT_IF
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
aRangesToDelete
.
IsFirstRangeEditable
(
aEditingHost
)
)
;
if
(
aRangesToDelete
.
Ranges
(
)
.
Length
(
)
=
=
1
)
{
nsFrameSelection
*
frameSelection
=
aHTMLEditor
.
SelectionRef
(
)
.
GetFrameSelection
(
)
;
if
(
NS_WARN_IF
(
!
frameSelection
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
EditorRawDOMRange
nsresult
>
result
=
ExtendOrShrinkRangeToDelete
(
aHTMLEditor
frameSelection
EditorRawDOMRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
ExtendOrShrinkRangeToDelete
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMRange
newRange
(
result
.
unwrap
(
)
)
;
if
(
NS_FAILED
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
newRange
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
newRange
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
IsPositioned
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
Collapsed
(
)
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorRawDOMPoint
>
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
MOZ_ASSERT
(
aRangesToDelete
.
IsFirstRangeEditable
(
aEditingHost
)
)
;
}
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteNonCollapsedRange
=
true
;
if
(
!
aHTMLEditor
.
IsInPlaintextMode
(
)
)
{
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
aHTMLEditor
EditorDOMRange
(
aRangesToDelete
.
FirstRangeRef
(
)
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
IsPositioned
(
)
)
|
|
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
NS_WARN_IF
(
!
aRangesToDelete
.
IsFirstRangeEditable
(
aEditingHost
)
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRange
(
)
made
the
first
"
"
range
invalid
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
{
if
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
Collapsed
(
)
)
{
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
IsPositioned
(
)
)
|
|
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
&
&
NS_WARN_IF
(
!
aRangesToDelete
.
IsFirstRangeEditable
(
aEditingHost
)
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
made
the
first
range
"
"
invalid
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
nsresult
rv
=
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
"
"
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
)
|
|
NS_WARN_IF
(
!
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsContent
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
startCiteNode
=
aHTMLEditor
.
GetMostDistantAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
)
;
RefPtr
<
Element
>
endCiteNode
=
aHTMLEditor
.
GetMostDistantAncestorMailCiteElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
)
;
if
(
startCiteNode
&
&
!
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
else
if
(
!
startCiteNode
&
&
endCiteNode
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
AutoBlockElementsJoiner
joiner
(
*
this
)
;
if
(
!
joiner
.
PrepareToDeleteNonCollapsedRanges
(
aHTMLEditor
aRangesToDelete
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
EditActionResult
nsresult
>
result
=
joiner
.
Run
(
aHTMLEditor
aDirectionAndAmount
aStripWrappers
aRangesToDelete
aSelectionWasCollapsed
aEditingHost
)
;
NS_WARNING_ASSERTION
(
result
.
isOk
(
)
"
AutoBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
result
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
PrepareToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
const
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
mLeftContent
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
mRightContent
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
mLeftContent
=
=
mRightContent
|
|
!
mLeftContent
|
|
!
mRightContent
)
{
MOZ_ASSERT_IF
(
!
mLeftContent
|
|
!
mRightContent
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
;
mMode
=
Mode
:
:
DeleteContentInRanges
;
return
true
;
}
if
(
mLeftContent
-
>
GetParentNode
(
)
=
=
mRightContent
-
>
GetParentNode
(
)
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
mLeftContent
*
mRightContent
)
&
&
(
mLeftContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
|
|
HTMLEditUtils
:
:
IsListItem
(
mLeftContent
)
|
|
HTMLEditUtils
:
:
IsHeader
(
*
mLeftContent
)
)
)
{
mMode
=
Mode
:
:
JoinBlocksInSameParent
;
return
true
;
}
mMode
=
Mode
:
:
DeleteNonCollapsedRanges
;
return
true
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteContentInRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
DeleteContentInRanges
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
;
MOZ_ASSERT
(
!
mLeftContent
=
=
!
mRightContent
)
;
MOZ_ASSERT_IF
(
mLeftContent
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mLeftContent
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT_IF
(
mRightContent
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mRightContent
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT_IF
(
!
mLeftContent
HTMLEditUtils
:
:
IsInlineElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
)
;
nsresult
rv
=
mDeleteRangesHandlerConst
.
ComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteContentInRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
DeleteContentInRanges
)
;
MOZ_ASSERT
(
mDeleteRangesHandler
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
=
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
;
MOZ_ASSERT_IF
(
mLeftContent
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mLeftContent
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT_IF
(
mRightContent
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT_IF
(
mRightContent
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT_IF
(
!
mLeftContent
HTMLEditUtils
:
:
IsInlineElement
(
*
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
)
;
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
caretPointOrError
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
but
ignored
"
)
;
}
else
{
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
}
nsresult
rv
=
mDeleteRangesHandler
-
>
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToJoinBlockElementsInSameParent
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
JoinBlocksInSameParent
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT
(
mLeftContent
-
>
GetParentNode
(
)
=
=
mRightContent
-
>
GetParentNode
(
)
)
;
nsresult
rv
=
mDeleteRangesHandlerConst
.
ComputeRangesToDeleteRangesWithTransaction
(
aHTMLEditor
aDirectionAndAmount
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
ComputeRangesToDeleteRangesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
JoinBlockElementsInSameParent
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mMode
=
=
Mode
:
:
JoinBlocksInSameParent
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
MOZ_ASSERT
(
mLeftContent
-
>
GetParentNode
(
)
=
=
mRightContent
-
>
GetParentNode
(
)
)
;
const
bool
backspaceInRightBlock
=
aSelectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
&
&
nsIEditor
:
:
DirectionIsBackspace
(
aDirectionAndAmount
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteRangesWithTransaction
(
aDirectionAndAmount
aStripWrappers
aRangesToDelete
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteRangesWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
if
(
NS_WARN_IF
(
!
mLeftContent
-
>
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
!
mRightContent
-
>
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
mLeftContent
-
>
GetParentNode
(
)
!
=
mRightContent
-
>
GetParentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
auto
startOfRightContent
=
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorDOMPoint
>
(
*
mRightContent
)
;
AutoTrackDOMPoint
trackStartOfRightContent
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startOfRightContent
)
;
Result
<
EditorDOMPoint
nsresult
>
atFirstChildOfTheLastRightNodeOrError
=
JoinNodesDeepWithTransaction
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftContent
)
MOZ_KnownLive
(
*
mRightContent
)
)
;
if
(
MOZ_UNLIKELY
(
atFirstChildOfTheLastRightNodeOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesDeepWithTransaction
(
)
failed
"
)
;
return
atFirstChildOfTheLastRightNodeOrError
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
atFirstChildOfTheLastRightNodeOrError
.
inspect
(
)
.
IsSet
(
)
)
;
trackStartOfRightContent
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
startOfRightContent
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
startOfRightContent
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MayEditActionDeleteAroundCollapsedSelection
(
aHTMLEditor
.
GetEditAction
(
)
)
)
{
WSRunScanner
scanner
(
&
aEditingHost
startOfRightContent
)
;
WSScanResult
maybePreviousText
=
scanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
startOfRightContent
)
;
if
(
maybePreviousText
.
IsContentEditable
(
)
&
&
maybePreviousText
.
InVisibleOrCollapsibleCharacters
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
maybePreviousText
.
Point
<
EditorRawDOMPoint
>
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
backspaceInRightBlock
)
{
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
}
if
(
HTMLEditor
:
:
GetLinkElement
(
maybePreviousText
.
TextPtr
(
)
)
)
{
aHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearLinkAndItsSpecifiedStyle
(
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
atFirstChildOfTheLastRightNodeOrError
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteNodesEntirelyInRangeButKeepTableStructure
(
const
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
arrayOfTopChildren
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
iter
.
AppendAllNodesToArray
(
arrayOfTopChildren
)
;
return
NeedsToJoinNodesAfterDeleteNodesEntirelyInRangeButKeepTableStructure
(
aHTMLEditor
arrayOfTopChildren
aSelectionWasCollapsed
)
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteNodesEntirelyInRangeButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
arrayOfTopChildren
;
DOMSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
iter
.
AppendAllNodesToArray
(
arrayOfTopChildren
)
;
bool
needsToJoinLater
=
NeedsToJoinNodesAfterDeleteNodesEntirelyInRangeButKeepTableStructure
(
aHTMLEditor
arrayOfTopChildren
aSelectionWasCollapsed
)
;
for
(
auto
&
content
:
arrayOfTopChildren
)
{
nsresult
rv
=
DeleteContentButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoBlockElementsJoiner
:
:
DeleteContentButKeepTableStructure
(
)
failed
"
"
but
ignored
"
)
;
}
return
needsToJoinLater
;
}
bool
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
NeedsToJoinNodesAfterDeleteNodesEntirelyInRangeButKeepTableStructure
(
const
HTMLEditor
&
aHTMLEditor
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
)
const
{
if
(
aSelectionWasCollapsed
=
=
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
:
:
No
)
{
return
true
;
}
if
(
aArrayOfContents
.
IsEmpty
(
)
)
{
return
true
;
}
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
aArrayOfContents
)
{
if
(
content
-
>
IsText
(
)
)
{
if
(
HTMLEditUtils
:
:
IsInVisibleTextFrames
(
aHTMLEditor
.
GetPresContext
(
)
*
content
-
>
AsText
(
)
)
)
{
return
false
;
}
continue
;
}
if
(
!
content
-
>
IsElement
(
)
|
|
HTMLEditUtils
:
:
IsEmptyNode
(
*
content
-
>
AsElement
(
)
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
content
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteTextAtStartAndEndOfRange
(
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
)
{
EditorDOMPoint
rangeStart
(
aRange
.
StartRef
(
)
)
;
EditorDOMPoint
rangeEnd
(
aRange
.
EndRef
(
)
)
;
if
(
rangeStart
.
IsInTextNode
(
)
&
&
!
rangeStart
.
IsEndOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
rangeStart
.
ContainerAs
<
Text
>
(
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextWithTransaction
(
textNode
rangeStart
.
Offset
(
)
rangeStart
.
GetContainer
(
)
-
>
Length
(
)
-
rangeStart
.
Offset
(
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
if
(
rangeEnd
.
IsInTextNode
(
)
&
&
!
rangeEnd
.
IsStartOfContainer
(
)
)
{
OwningNonNull
<
Text
>
textNode
=
*
rangeEnd
.
ContainerAs
<
Text
>
(
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextWithTransaction
(
textNode
0
rangeEnd
.
Offset
(
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
ComputeRangesToDeleteNonCollapsedRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
for
(
OwningNonNull
<
nsRange
>
&
range
:
aRangesToDelete
.
Ranges
(
)
)
{
Result
<
bool
nsresult
>
result
=
ComputeRangesToDeleteNodesEntirelyInRangeButKeepTableStructure
(
aHTMLEditor
range
aSelectionWasCollapsed
)
;
if
(
result
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoBlockElementsJoiner
:
:
"
"
ComputeRangesToDeleteNodesEntirelyInRangeButKeepTableStructure
(
)
"
"
failed
"
)
;
return
result
.
unwrapErr
(
)
;
}
if
(
!
result
.
unwrap
(
)
)
{
return
NS_OK
;
}
}
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
canJoinThem
.
unwrapErr
(
)
;
}
if
(
!
canJoinThem
.
unwrap
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
!
joiner
.
CanJoinBlocks
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
joiner
.
ComputeRangesToDelete
(
aHTMLEditor
EditorDOMPoint
(
)
aRangesToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
ComputeRangesToDelete
(
)
"
"
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
HandleDeleteNonCollapsedRanges
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
nsIEditor
:
:
EStripWrappers
aStripWrappers
AutoRangeArray
&
aRangesToDelete
AutoDeleteRangesHandler
:
:
SelectionWasCollapsed
aSelectionWasCollapsed
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
IsCollapsed
(
)
)
;
MOZ_ASSERT
(
mDeleteRangesHandler
)
;
MOZ_ASSERT
(
mLeftContent
)
;
MOZ_ASSERT
(
mLeftContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetStartContainer
(
)
-
>
IsInclusiveDescendantOf
(
mLeftContent
)
)
;
MOZ_ASSERT
(
mRightContent
)
;
MOZ_ASSERT
(
mRightContent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
GetEndContainer
(
)
-
>
IsInclusiveDescendantOf
(
mRightContent
)
)
;
const
bool
backspaceInRightBlock
=
aSelectionWasCollapsed
=
=
SelectionWasCollapsed
:
:
Yes
&
&
nsIEditor
:
:
DirectionIsBackspace
(
aDirectionAndAmount
)
;
EditActionResult
result
=
EditActionResult
:
:
IgnoredResult
(
)
;
EditorDOMPoint
pointToPutCaret
;
while
(
true
)
{
AutoTrackDOMRange
firstRangeTracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRangesToDelete
.
FirstRangeRef
(
)
)
;
bool
joinInclusiveAncestorBlockElements
=
true
;
for
(
auto
&
range
:
aRangesToDelete
.
Ranges
(
)
)
{
Result
<
bool
nsresult
>
deleteResult
=
DeleteNodesEntirelyInRangeButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
range
)
aSelectionWasCollapsed
)
;
if
(
MOZ_UNLIKELY
(
deleteResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoBlockElementsJoiner
:
:
"
"
DeleteNodesEntirelyInRangeButKeepTableStructure
(
)
failed
"
)
;
return
deleteResult
.
propagateErr
(
)
;
}
joinInclusiveAncestorBlockElements
&
=
deleteResult
.
unwrap
(
)
;
}
nsresult
rv
=
DeleteTextAtStartAndEndOfRange
(
aHTMLEditor
MOZ_KnownLive
(
aRangesToDelete
.
FirstRangeRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoBlockElementsJoiner
:
:
DeleteTextAtStartAndEndOfRange
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
!
joinInclusiveAncestorBlockElements
)
{
break
;
}
AutoInclusiveAncestorBlockElementsJoiner
joiner
(
*
mLeftContent
*
mRightContent
)
;
Result
<
bool
nsresult
>
canJoinThem
=
joiner
.
Prepare
(
aHTMLEditor
aEditingHost
)
;
if
(
canJoinThem
.
isErr
(
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
)
failed
"
)
;
return
canJoinThem
.
propagateErr
(
)
;
}
if
(
aDirectionAndAmount
=
=
nsIEditor
:
:
eNext
)
{
aDirectionAndAmount
=
nsIEditor
:
:
ePrevious
;
}
else
{
aDirectionAndAmount
=
nsIEditor
:
:
eNext
;
}
if
(
!
canJoinThem
.
inspect
(
)
)
{
result
.
MarkAsCanceled
(
)
;
break
;
}
if
(
!
joiner
.
CanJoinBlocks
(
)
)
{
break
;
}
Result
<
EditActionResult
nsresult
>
joinResult
=
joiner
.
Run
(
aHTMLEditor
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
joinResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
failed
"
)
;
return
joinResult
;
}
result
|
=
joinResult
.
unwrap
(
)
;
#
ifdef
DEBUG
if
(
joiner
.
ShouldDeleteLeafContentInstead
(
)
)
{
NS_ASSERTION
(
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
ignored
but
returned
not
ignored
"
)
;
}
else
{
NS_ASSERTION
(
!
result
.
Ignored
(
)
"
Assumed
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
)
"
"
returning
handled
but
returned
ignored
"
)
;
}
#
endif
pointToPutCaret
=
joiner
.
PointRefToPutCaret
(
)
;
break
;
}
if
(
result
.
Handled
(
)
&
&
pointToPutCaret
.
IsSet
(
)
)
{
EditorDOMRange
range
(
aRangesToDelete
.
FirstRangeRef
(
)
)
;
nsresult
rv
=
mDeleteRangesHandler
-
>
DeleteUnnecessaryNodes
(
aHTMLEditor
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodes
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
backspaceInRightBlock
)
{
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
}
if
(
HTMLEditor
:
:
GetLinkElement
(
pointToPutCaret
.
GetContainer
(
)
)
)
{
aHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearLinkAndItsSpecifiedStyle
(
)
;
}
return
result
;
}
nsresult
rv
=
mDeleteRangesHandler
-
>
DeleteUnnecessaryNodesAndCollapseSelection
(
aHTMLEditor
aDirectionAndAmount
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
StartRef
(
)
)
EditorDOMPoint
(
aRangesToDelete
.
FirstRangeRef
(
)
-
>
EndRef
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
result
.
MarkAsHandled
(
)
;
return
result
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodes
(
HTMLEditor
&
aHTMLEditor
EditorDOMRange
&
aRange
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
;
if
(
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
|
|
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDeleteByDrag
)
{
MOZ_ASSERT
(
aRange
.
Collapsed
(
)
|
|
(
aRange
.
StartRef
(
)
.
GetContainer
(
)
-
>
GetNextSibling
(
)
=
=
aRange
.
EndRef
(
)
.
GetContainer
(
)
&
&
aRange
.
StartRef
(
)
.
IsEndOfContainer
(
)
&
&
aRange
.
EndRef
(
)
.
IsStartOfContainer
(
)
)
)
;
AutoTrackDOMRange
trackRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRange
)
;
nsresult
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
aHTMLEditor
aRange
.
StartRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
)
failed
"
)
;
return
rv
;
}
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
=
rv
=
=
NS_OK
;
if
(
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
return
NS_OK
;
}
}
if
(
NS_WARN_IF
(
!
aRange
.
IsInContentNodes
(
)
)
|
|
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
aRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
|
|
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
AutoTrackDOMRange
trackRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
aRange
)
;
OwningNonNull
<
nsIContent
>
startContainer
=
*
aRange
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
;
OwningNonNull
<
nsIContent
>
endContainer
=
*
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
;
nsresult
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
startContainer
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
to
remove
start
node
but
ignored
"
)
;
if
(
aRange
.
InSameContainer
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
aRange
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
return
NS_OK
;
}
rv
=
DeleteNodeIfInvisibleAndEditableTextNode
(
aHTMLEditor
endContainer
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
)
"
"
failed
to
remove
end
node
but
ignored
"
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodesAndCollapseSelection
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
EditorDOMPoint
&
aSelectionStartPoint
const
EditorDOMPoint
&
aSelectionEndPoint
)
{
EditorDOMRange
range
(
aSelectionStartPoint
aSelectionEndPoint
)
;
nsresult
rv
=
DeleteUnnecessaryNodes
(
aHTMLEditor
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoDeleteRangesHandler
:
:
DeleteUnnecessaryNodes
(
)
failed
"
)
;
return
rv
;
}
if
(
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDrop
|
|
aHTMLEditor
.
GetEditAction
(
)
=
=
EditAction
:
:
eDeleteByDrag
)
{
if
(
aHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mDidDeleteEmptyParentBlocks
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
range
.
StartRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
aDirectionAndAmount
=
=
nsIEditor
:
:
ePrevious
?
range
.
EndRef
(
)
:
range
.
StartRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteNodeIfInvisibleAndEditableTextNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
Text
*
text
=
aContent
.
GetAsText
(
)
;
if
(
!
text
)
{
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
*
text
)
|
|
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
text
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
mPlaceholderBatch
)
;
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
WSRunScanner
wsScannerForPoint
(
editingHost
aPoint
)
;
if
(
!
wsScannerForPoint
.
StartsFromCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
)
|
|
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
editingHost
=
=
wsScannerForPoint
.
GetStartReasonContent
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
WSScanResult
forwardScanFromPointResult
=
wsScannerForPoint
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
if
(
forwardScanFromPointResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
forwardScanFromPointResult
.
ReachedBRElement
(
)
)
{
NS_ASSERTION
(
wsScannerForPoint
.
GetEndReasonContent
(
)
=
=
forwardScanFromPointResult
.
BRElementPtr
(
)
"
End
reason
is
not
the
reached
<
br
>
element
"
)
;
if
(
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
wsScannerForPoint
.
GetEndReasonContent
(
)
-
>
GetNextSibling
(
)
)
{
WSScanResult
scanResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
editingHost
EditorRawDOMPoint
:
:
After
(
*
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
;
if
(
scanResult
.
Failed
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
scanResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
}
}
else
if
(
!
forwardScanFromPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
EditorDOMPoint
nextPoint
(
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
0
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
nextPoint
.
GetContainer
(
)
=
=
editingHost
)
{
return
NS_OK
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
Element
*
newEditingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
newEditingHost
)
|
|
NS_WARN_IF
(
newEditingHost
!
=
editingHost
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
*
nextPoint
.
GetContainer
(
)
*
newEditingHost
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
}
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
aHTMLEditor
nextPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoDeleteRangesHandler
:
:
"
"
DeleteParentBlocksWithTransactionIfEmpty
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ComputeRangesToDeleteRangesWithTransaction
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
EditorBase
:
:
HowToHandleCollapsedRange
howToHandleCollapsedRange
=
EditorBase
:
:
HowToHandleCollapsedRangeFor
(
aDirectionAndAmount
)
;
if
(
NS_WARN_IF
(
aRangesToDelete
.
IsCollapsed
(
)
&
&
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
Ignore
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
extendRangeToSelectCharacterForward
=
[
]
(
nsRange
&
aRange
const
EditorRawDOMPointInText
&
aCaretPoint
)
-
>
void
{
const
nsTextFragment
&
textFragment
=
aCaretPoint
.
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
if
(
!
textFragment
.
GetLength
(
)
)
{
return
;
}
if
(
textFragment
.
IsHighSurrogateFollowedByLowSurrogateAt
(
aCaretPoint
.
Offset
(
)
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
aRange
.
SetStartAndEnd
(
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
+
2
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
aRange
.
SetStartAndEnd
(
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
+
1
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
}
;
auto
extendRangeToSelectCharacterBackward
=
[
]
(
nsRange
&
aRange
const
EditorRawDOMPointInText
&
aCaretPoint
)
-
>
void
{
if
(
aCaretPoint
.
IsStartOfContainer
(
)
)
{
return
;
}
const
nsTextFragment
&
textFragment
=
aCaretPoint
.
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
if
(
!
textFragment
.
GetLength
(
)
)
{
return
;
}
if
(
textFragment
.
IsLowSurrogateFollowingHighSurrogateAt
(
aCaretPoint
.
Offset
(
)
-
1
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
aRange
.
SetStartAndEnd
(
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
-
2
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
aRange
.
SetStartAndEnd
(
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
-
1
aCaretPoint
.
ContainerAs
<
Text
>
(
)
aCaretPoint
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
}
;
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
for
(
OwningNonNull
<
nsRange
>
&
range
:
aRangesToDelete
.
Ranges
(
)
)
{
if
(
!
range
-
>
Collapsed
(
)
)
{
continue
;
}
if
(
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
Ignore
)
{
continue
;
}
EditorRawDOMPoint
caretPoint
(
range
-
>
StartRef
(
)
)
;
if
(
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendBackward
&
&
caretPoint
.
IsStartOfContainer
(
)
)
{
nsIContent
*
previousEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
caretPoint
.
GetContainer
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
;
if
(
!
previousEditableContent
)
{
continue
;
}
if
(
!
previousEditableContent
-
>
IsText
(
)
)
{
IgnoredErrorResult
ignoredError
;
range
-
>
SelectNode
(
*
previousEditableContent
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
SelectNode
(
)
failed
"
)
;
continue
;
}
extendRangeToSelectCharacterBackward
(
range
EditorRawDOMPointInText
:
:
AtEndOf
(
*
previousEditableContent
-
>
AsText
(
)
)
)
;
continue
;
}
if
(
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendForward
&
&
caretPoint
.
IsEndOfContainer
(
)
)
{
nsIContent
*
nextEditableContent
=
HTMLEditUtils
:
:
GetNextContent
(
*
caretPoint
.
GetContainer
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
;
if
(
!
nextEditableContent
)
{
continue
;
}
if
(
!
nextEditableContent
-
>
IsText
(
)
)
{
IgnoredErrorResult
ignoredError
;
range
-
>
SelectNode
(
*
nextEditableContent
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
SelectNode
(
)
failed
"
)
;
continue
;
}
extendRangeToSelectCharacterForward
(
range
EditorRawDOMPointInText
(
nextEditableContent
-
>
AsText
(
)
0
)
)
;
continue
;
}
if
(
caretPoint
.
IsInTextNode
(
)
)
{
if
(
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendBackward
)
{
extendRangeToSelectCharacterBackward
(
range
EditorRawDOMPointInText
(
caretPoint
.
ContainerAs
<
Text
>
(
)
caretPoint
.
Offset
(
)
)
)
;
continue
;
}
extendRangeToSelectCharacterForward
(
range
EditorRawDOMPointInText
(
caretPoint
.
ContainerAs
<
Text
>
(
)
caretPoint
.
Offset
(
)
)
)
;
continue
;
}
nsIContent
*
editableContent
=
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendBackward
?
HTMLEditUtils
:
:
GetPreviousContent
(
caretPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
:
HTMLEditUtils
:
:
GetNextContent
(
caretPoint
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
;
if
(
!
editableContent
)
{
continue
;
}
while
(
editableContent
&
&
editableContent
-
>
IsCharacterData
(
)
&
&
!
editableContent
-
>
Length
(
)
)
{
editableContent
=
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendBackward
?
HTMLEditUtils
:
:
GetPreviousContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
:
HTMLEditUtils
:
:
GetNextContent
(
*
editableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
editingHost
)
;
}
if
(
!
editableContent
)
{
continue
;
}
if
(
!
editableContent
-
>
IsText
(
)
)
{
IgnoredErrorResult
ignoredError
;
range
-
>
SelectNode
(
*
editableContent
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
nsRange
:
:
SelectNode
(
)
failed
"
)
;
continue
;
}
if
(
howToHandleCollapsedRange
=
=
EditorBase
:
:
HowToHandleCollapsedRange
:
:
ExtendBackward
)
{
extendRangeToSelectCharacterBackward
(
range
EditorRawDOMPointInText
:
:
AtEndOf
(
*
editableContent
-
>
AsText
(
)
)
)
;
continue
;
}
extendRangeToSelectCharacterForward
(
range
EditorRawDOMPointInText
(
editableContent
-
>
AsText
(
)
0
)
)
;
}
return
NS_OK
;
}
template
<
typename
EditorDOMPointType
>
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
const
EditorDOMPointType
&
aStartPoint
const
EditorDOMPointType
&
aEndPoint
TreatEmptyTextNodes
aTreatEmptyTextNodes
)
{
if
(
NS_WARN_IF
(
!
aStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
aStartPoint
=
=
aEndPoint
)
{
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
auto
DeleteEmptyContentNodeWithTransaction
=
[
this
&
aTreatEmptyTextNodes
&
editingHost
]
(
nsIContent
&
aContent
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
nsresult
{
OwningNonNull
<
nsIContent
>
nodeToRemove
=
aContent
;
if
(
aTreatEmptyTextNodes
=
=
TreatEmptyTextNodes
:
:
RemoveAllEmptyInlineAncestors
)
{
Element
*
emptyParentElementToRemove
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
nodeToRemove
editingHost
)
;
if
(
emptyParentElementToRemove
)
{
nodeToRemove
=
*
emptyParentElementToRemove
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
nodeToRemove
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
;
if
(
aStartPoint
.
GetContainer
(
)
=
=
aEndPoint
.
GetContainer
(
)
&
&
aStartPoint
.
IsInTextNode
(
)
)
{
if
(
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
&
&
aStartPoint
.
IsStartOfContainer
(
)
&
&
aEndPoint
.
IsEndOfContainer
(
)
)
{
nsresult
rv
=
DeleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aStartPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
deleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
RefPtr
<
Text
>
textNode
=
aStartPoint
.
template
ContainerAs
<
Text
>
(
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
DeleteTextWithTransaction
(
*
textNode
aStartPoint
.
Offset
(
)
aEndPoint
.
Offset
(
)
-
aStartPoint
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
caretPointOrError
.
isOk
(
)
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aStartPoint
.
ToRawRangeBoundary
(
)
aEndPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
!
range
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
AutoTArray
<
OwningNonNull
<
Text
>
16
>
arrayOfTextNodes
;
DOMIterator
iter
;
if
(
NS_FAILED
(
iter
.
Init
(
*
range
)
)
)
{
return
CaretPoint
(
EditorDOMPoint
(
)
)
;
}
iter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
{
MOZ_ASSERT
(
aNode
.
IsText
(
)
)
;
return
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aNode
)
;
}
arrayOfTextNodes
)
;
EditorDOMPoint
pointToPutCaret
;
for
(
OwningNonNull
<
Text
>
&
textNode
:
arrayOfTextNodes
)
{
if
(
textNode
=
=
aStartPoint
.
GetContainer
(
)
)
{
if
(
aStartPoint
.
IsEndOfContainer
(
)
)
{
continue
;
}
if
(
aStartPoint
.
IsStartOfContainer
(
)
&
&
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
DeleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aStartPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DeleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
continue
;
}
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
DeleteTextWithTransaction
(
MOZ_KnownLive
(
textNode
)
aStartPoint
.
Offset
(
)
textNode
-
>
Length
(
)
-
aStartPoint
.
Offset
(
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
continue
;
}
if
(
textNode
=
=
aEndPoint
.
GetContainer
(
)
)
{
if
(
aEndPoint
.
IsStartOfContainer
(
)
)
{
break
;
}
if
(
aEndPoint
.
IsEndOfContainer
(
)
&
&
aTreatEmptyTextNodes
!
=
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
{
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
nsresult
rv
=
DeleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
*
aEndPoint
.
template
ContainerAs
<
Text
>
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DeleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
AutoTrackDOMPoint
trackPointToPutCaret
(
RangeUpdaterRef
(
)
&
pointToPutCaret
)
;
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
DeleteTextWithTransaction
(
MOZ_KnownLive
(
textNode
)
0
aEndPoint
.
Offset
(
)
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
;
}
trackPointToPutCaret
.
FlushAndStopTracking
(
)
;
caretPointOrError
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
return
CaretPoint
(
pointToPutCaret
)
;
}
nsresult
rv
=
DeleteEmptyContentNodeWithTransaction
(
MOZ_KnownLive
(
textNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
DeleteEmptyContentNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
return
CaretPoint
(
pointToPutCaret
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
JoinNodesDeepWithTransaction
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
{
nsCOMPtr
<
nsIContent
>
leftContentToJoin
=
&
aLeftContent
;
nsCOMPtr
<
nsIContent
>
rightContentToJoin
=
&
aRightContent
;
nsCOMPtr
<
nsINode
>
parentNode
=
aRightContent
.
GetParentNode
(
)
;
EditorDOMPoint
ret
;
while
(
leftContentToJoin
&
&
rightContentToJoin
&
&
parentNode
&
&
HTMLEditUtils
:
:
CanContentsBeJoined
(
*
leftContentToJoin
*
rightContentToJoin
)
)
{
Result
<
JoinNodesResult
nsresult
>
joinNodesResult
=
aHTMLEditor
.
JoinNodesWithTransaction
(
*
leftContentToJoin
*
rightContentToJoin
)
;
if
(
MOZ_UNLIKELY
(
joinNodesResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
joinNodesResult
.
propagateErr
(
)
;
}
ret
=
joinNodesResult
.
inspect
(
)
.
AtJoinedPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
ret
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
parentNode
-
>
IsText
(
)
)
{
return
ret
;
}
rightContentToJoin
=
ret
.
GetCurrentChildAtOffset
(
)
;
if
(
rightContentToJoin
)
{
leftContentToJoin
=
rightContentToJoin
-
>
GetPreviousSibling
(
)
;
}
else
{
leftContentToJoin
=
nullptr
;
}
while
(
leftContentToJoin
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
leftContentToJoin
EditorType
:
:
HTML
)
)
{
leftContentToJoin
=
leftContentToJoin
-
>
GetPreviousSibling
(
)
;
}
if
(
!
leftContentToJoin
)
{
return
ret
;
}
while
(
rightContentToJoin
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
rightContentToJoin
EditorType
:
:
HTML
)
)
{
rightContentToJoin
=
rightContentToJoin
-
>
GetNextSibling
(
)
;
}
if
(
!
rightContentToJoin
)
{
return
ret
;
}
}
if
(
!
ret
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesDeepWithTransaction
(
)
joined
no
contents
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
ret
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
AutoInclusiveAncestorBlockElementsJoiner
:
:
Prepare
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
{
mLeftBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
mInclusiveDescendantOfLeftBlockElement
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
)
;
mRightBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
mInclusiveDescendantOfRightBlockElement
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
)
;
if
(
NS_WARN_IF
(
!
IsSet
(
)
)
)
{
mCanJoinBlocks
=
false
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
mLeftBlockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
html
nsGkAtoms
:
:
head
nsGkAtoms
:
:
body
)
&
&
mRightBlockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
html
nsGkAtoms
:
:
head
nsGkAtoms
:
:
body
)
)
{
mCanJoinBlocks
=
false
;
return
false
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
mLeftBlockElement
)
|
|
HTMLEditUtils
:
:
IsAnyTableElement
(
mRightBlockElement
)
)
{
mCanJoinBlocks
=
false
;
return
false
;
}
if
(
IsSameBlockElement
(
)
)
{
mCanJoinBlocks
=
true
;
mFallbackToDeleteLeafContent
=
true
;
return
true
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
mLeftBlockElement
)
&
&
HTMLEditUtils
:
:
IsListItem
(
mRightBlockElement
)
&
&
mRightBlockElement
-
>
GetParentNode
(
)
=
=
mLeftBlockElement
)
{
mCanJoinBlocks
=
false
;
return
true
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
mLeftBlockElement
)
&
&
HTMLEditUtils
:
:
IsListItem
(
mRightBlockElement
)
)
{
Element
*
leftListElement
=
mLeftBlockElement
-
>
GetParentElement
(
)
;
Element
*
rightListElement
=
mRightBlockElement
-
>
GetParentElement
(
)
;
EditorDOMPoint
atChildInBlock
;
if
(
leftListElement
&
&
rightListElement
&
&
leftListElement
!
=
rightListElement
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
leftListElement
*
mRightBlockElement
&
atChildInBlock
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
*
rightListElement
*
mLeftBlockElement
&
atChildInBlock
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
atChildInBlock
.
IsSet
(
)
)
;
mLeftBlockElement
=
leftListElement
;
mRightBlockElement
=
rightListElement
;
mNewListElementTagNameOfRightListElement
=
Some
(
leftListElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
}
if
(
!
EditorUtils
:
:
IsDescendantOf
(
*
mLeftBlockElement
*
mRightBlockElement
&
mPointContainingTheOtherBlockElement
)
)
{
Unused
<
<
EditorUtils
:
:
IsDescendantOf
(
*
mRightBlockElement
*
mLeftBlockElement
&
mPointContainingTheOtherBlockElement
)
;
}
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mRightBlockElement
)
{
mPrecedingInvisibleBRElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
EditorDOMPoint
:
:
AtEndOf
(
mLeftBlockElement
)
)
;
if
(
!
mPrecedingInvisibleBRElement
)
{
if
(
CanMergeLeftAndRightBlockElements
(
)
)
{
mFallbackToDeleteLeafContent
=
false
;
}
else
{
Result
<
bool
nsresult
>
firstLineHasContent
=
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
mPointContainingTheOtherBlockElement
.
NextPoint
<
EditorDOMPoint
>
(
)
aEditingHost
)
;
mFallbackToDeleteLeafContent
=
firstLineHasContent
.
isOk
(
)
&
&
!
firstLineHasContent
.
inspect
(
)
;
}
}
else
{
mFallbackToDeleteLeafContent
=
false
;
}
}
else
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mLeftBlockElement
)
{
mPrecedingInvisibleBRElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
mPointContainingTheOtherBlockElement
)
;
if
(
!
mPrecedingInvisibleBRElement
)
{
if
(
CanMergeLeftAndRightBlockElements
(
)
)
{
Result
<
bool
nsresult
>
rightBlockHasContent
=
aHTMLEditor
.
CanMoveChildren
(
*
mRightBlockElement
*
mLeftBlockElement
)
;
mFallbackToDeleteLeafContent
=
rightBlockHasContent
.
isOk
(
)
&
&
!
rightBlockHasContent
.
inspect
(
)
;
}
else
{
Result
<
bool
nsresult
>
firstLineHasContent
=
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
EditorDOMPoint
(
mRightBlockElement
0u
)
aEditingHost
)
;
mFallbackToDeleteLeafContent
=
firstLineHasContent
.
isOk
(
)
&
&
!
firstLineHasContent
.
inspect
(
)
;
}
}
else
{
mFallbackToDeleteLeafContent
=
false
;
}
}
else
{
mPrecedingInvisibleBRElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
EditorDOMPoint
:
:
AtEndOf
(
mLeftBlockElement
)
)
;
mFallbackToDeleteLeafContent
=
false
;
}
mCanJoinBlocks
=
true
;
return
true
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
AutoInclusiveAncestorBlockElementsJoiner
:
:
ComputeRangesToDelete
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aCaretPoint
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
!
aRangesToDelete
.
Ranges
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mLeftBlockElement
)
;
MOZ_ASSERT
(
mRightBlockElement
)
;
if
(
IsSameBlockElement
(
)
)
{
if
(
!
aCaretPoint
.
IsSet
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRangesToDelete
.
Collapse
(
aCaretPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
Collapse
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
pointContainingTheOtherBlock
;
if
(
!
EditorUtils
:
:
IsDescendantOf
(
*
mLeftBlockElement
*
mRightBlockElement
&
pointContainingTheOtherBlock
)
)
{
Unused
<
<
EditorUtils
:
:
IsDescendantOf
(
*
mRightBlockElement
*
mLeftBlockElement
&
pointContainingTheOtherBlock
)
;
}
EditorDOMRange
range
=
WSRunScanner
:
:
GetRangeForDeletingBlockElementBoundaries
(
aHTMLEditor
*
mLeftBlockElement
*
mRightBlockElement
pointContainingTheOtherBlock
)
;
if
(
!
range
.
IsPositioned
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetRangeForDeletingBlockElementBoundaries
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
aCaretPoint
.
IsSet
(
)
)
{
bool
noNeedToChangeStart
=
false
;
const
auto
atStart
=
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
atStart
.
IsBefore
(
range
.
StartRef
(
)
)
)
{
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
NS_WARNING_ASSERTION
(
editingHost
"
There
was
no
editing
host
"
)
;
nsIContent
*
nextContent
=
atStart
.
IsEndOfContainer
(
)
&
&
range
.
StartRef
(
)
.
GetChild
(
)
&
&
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
range
.
StartRef
(
)
.
GetChild
(
)
)
?
HTMLEditUtils
:
:
GetNextContent
(
*
atStart
.
ContainerAs
<
nsIContent
>
(
)
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
StopAtBlockBoundary
}
editingHost
)
:
nullptr
;
if
(
!
nextContent
|
|
nextContent
!
=
range
.
StartRef
(
)
.
GetChild
(
)
)
{
noNeedToChangeStart
=
true
;
range
.
SetStart
(
aRangesToDelete
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
)
;
}
}
if
(
range
.
EndRef
(
)
.
IsBefore
(
aRangesToDelete
.
GetFirstRangeEndPoint
<
EditorRawDOMPoint
>
(
)
)
)
{
if
(
noNeedToChangeStart
)
{
return
NS_OK
;
}
range
.
SetEnd
(
aRangesToDelete
.
GetFirstRangeEndPoint
<
EditorDOMPoint
>
(
)
)
;
}
}
nsresult
rv
=
aRangesToDelete
.
FirstRangeRef
(
)
-
>
SetStartAndEnd
(
range
.
StartRef
(
)
.
ToRawRangeBoundary
(
)
range
.
EndRef
(
)
.
ToRawRangeBoundary
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
AutoInclusiveAncestorBlockElementsJoiner
:
:
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mLeftBlockElement
)
;
MOZ_ASSERT
(
mRightBlockElement
)
;
if
(
IsSameBlockElement
(
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
if
(
!
mCanJoinBlocks
)
{
return
EditActionResult
:
:
HandledResult
(
)
;
}
EditorDOMPoint
startOfRightContent
;
Result
<
EditActionResult
nsresult
>
result
(
NS_ERROR_NOT_INITIALIZED
)
;
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mRightBlockElement
)
{
startOfRightContent
=
mPointContainingTheOtherBlockElement
.
NextPoint
(
)
;
if
(
Element
*
element
=
startOfRightContent
.
GetChildAs
<
Element
>
(
)
)
{
startOfRightContent
=
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorDOMPoint
>
(
*
element
)
;
}
AutoTrackDOMPoint
trackStartOfRightBlock
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startOfRightContent
)
;
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
mPointContainingTheOtherBlockElement
mNewListElementTagNameOfRightListElement
MOZ_KnownLive
(
mPrecedingInvisibleBRElement
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement
(
)
"
"
failed
"
)
;
return
result
;
}
if
(
NS_WARN_IF
(
!
startOfRightContent
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
startOfRightContent
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
else
if
(
mPointContainingTheOtherBlockElement
.
GetContainer
(
)
=
=
mLeftBlockElement
)
{
startOfRightContent
=
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorDOMPoint
>
(
*
mRightBlockElement
)
;
AutoTrackDOMPoint
trackStartOfRightBlock
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startOfRightContent
)
;
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
mPointContainingTheOtherBlockElement
MOZ_KnownLive
(
*
mInclusiveDescendantOfLeftBlockElement
)
mNewListElementTagNameOfRightListElement
MOZ_KnownLive
(
mPrecedingInvisibleBRElement
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement
(
)
"
"
failed
"
)
;
return
result
;
}
trackStartOfRightBlock
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
startOfRightContent
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
startOfRightContent
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
else
{
MOZ_ASSERT
(
!
mPointContainingTheOtherBlockElement
.
IsSet
(
)
)
;
startOfRightContent
=
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorDOMPoint
>
(
*
mRightBlockElement
)
;
AutoTrackDOMPoint
trackStartOfRightBlock
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startOfRightContent
)
;
result
=
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
aHTMLEditor
MOZ_KnownLive
(
*
mLeftBlockElement
)
MOZ_KnownLive
(
*
mRightBlockElement
)
mNewListElementTagNameOfRightListElement
MOZ_KnownLive
(
mPrecedingInvisibleBRElement
)
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
)
failed
"
)
;
return
result
;
}
trackStartOfRightBlock
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
startOfRightContent
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
startOfRightContent
.
GetContainer
(
)
-
>
IsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
if
(
MayEditActionDeleteAroundCollapsedSelection
(
aHTMLEditor
.
GetEditAction
(
)
)
)
{
WSRunScanner
scanner
(
&
aEditingHost
startOfRightContent
)
;
WSScanResult
maybePreviousText
=
scanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
startOfRightContent
)
;
if
(
maybePreviousText
.
IsContentEditable
(
)
&
&
maybePreviousText
.
InVisibleOrCollapsibleCharacters
(
)
)
{
mPointToPutCaret
=
maybePreviousText
.
Point
<
EditorDOMPoint
>
(
)
;
}
}
return
result
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
CanMoveOrDeleteSomethingInLine
(
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
aPointInHardLine
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
aPointInHardLine
.
IsInNativeAnonymousSubtree
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
RefPtr
<
nsRange
>
oneLineRange
=
AutoRangeArray
:
:
CreateRangeWrappingStartAndEndLinesContainingBoundaries
(
aPointInHardLine
aPointInHardLine
EditSubAction
:
:
eMergeBlockContents
aEditingHost
)
;
if
(
!
oneLineRange
|
|
oneLineRange
-
>
Collapsed
(
)
|
|
!
oneLineRange
-
>
IsPositioned
(
)
|
|
!
oneLineRange
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
|
|
!
oneLineRange
-
>
GetEndContainer
(
)
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
nsIContent
*
childContent
=
oneLineRange
-
>
GetChildAtStartOffset
(
)
)
{
if
(
childContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
childContent
-
>
GetParent
(
)
)
{
if
(
const
Element
*
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
childContent
-
>
GetParent
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
)
{
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
blockElement
)
)
{
return
false
;
}
}
}
}
nsINode
*
commonAncestor
=
oneLineRange
-
>
GetClosestCommonInclusiveAncestor
(
)
;
EditorRawDOMPoint
startPoint
(
oneLineRange
-
>
StartRef
(
)
)
;
if
(
!
startPoint
.
IsEndOfContainer
(
)
)
{
return
true
;
}
EditorRawDOMPoint
endPoint
(
oneLineRange
-
>
EndRef
(
)
)
;
if
(
!
endPoint
.
IsStartOfContainer
(
)
)
{
return
true
;
}
if
(
startPoint
.
GetContainer
(
)
!
=
commonAncestor
)
{
while
(
true
)
{
EditorRawDOMPoint
pointInParent
(
startPoint
.
GetContainerAs
<
nsIContent
>
(
)
)
;
if
(
NS_WARN_IF
(
!
pointInParent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
pointInParent
.
GetContainer
(
)
=
=
commonAncestor
)
{
startPoint
=
pointInParent
;
break
;
}
if
(
!
pointInParent
.
IsEndOfContainer
(
)
)
{
return
true
;
}
}
}
if
(
endPoint
.
GetContainer
(
)
!
=
commonAncestor
)
{
while
(
true
)
{
EditorRawDOMPoint
pointInParent
(
endPoint
.
GetContainerAs
<
nsIContent
>
(
)
)
;
if
(
NS_WARN_IF
(
!
pointInParent
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
pointInParent
.
GetContainer
(
)
=
=
commonAncestor
)
{
endPoint
=
pointInParent
;
break
;
}
if
(
!
pointInParent
.
IsStartOfContainer
(
)
)
{
return
true
;
}
}
}
return
startPoint
.
GetNextSiblingOfChild
(
)
!
=
endPoint
.
GetChild
(
)
;
}
nsresult
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
Prepare
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointInHardLine
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointInHardLine
.
IsInContentNode
(
)
)
;
MOZ_ASSERT
(
mPointToInsert
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
mPointToInsert
.
IsInNativeAnonymousSubtree
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
mSrcInclusiveAncestorBlock
=
aPointInHardLine
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPointInHardLine
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
:
nullptr
;
mDestInclusiveAncestorBlock
=
mPointToInsert
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestBlockElement
)
:
nullptr
;
mMovingToParentBlock
=
mDestInclusiveAncestorBlock
&
&
mSrcInclusiveAncestorBlock
&
&
mDestInclusiveAncestorBlock
!
=
mSrcInclusiveAncestorBlock
&
&
mSrcInclusiveAncestorBlock
-
>
IsInclusiveDescendantOf
(
mDestInclusiveAncestorBlock
)
;
mTopmostSrcAncestorBlockInDestBlock
=
mMovingToParentBlock
?
AutoMoveOneLineHandler
:
:
GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement
(
*
mSrcInclusiveAncestorBlock
*
mDestInclusiveAncestorBlock
)
:
nullptr
;
MOZ_ASSERT_IF
(
mMovingToParentBlock
mTopmostSrcAncestorBlockInDestBlock
)
;
mPreserveWhiteSpaceStyle
=
AutoMoveOneLineHandler
:
:
ConsiderWhetherPreserveWhiteSpaceStyle
(
aPointInHardLine
.
GetContainerAs
<
nsIContent
>
(
)
mDestInclusiveAncestorBlock
)
;
AutoRangeArray
rangesToWrapTheLine
(
aPointInHardLine
)
;
rangesToWrapTheLine
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eMergeBlockContents
aEditingHost
)
;
MOZ_ASSERT
(
rangesToWrapTheLine
.
Ranges
(
)
.
Length
(
)
<
=
1u
)
;
mLineRange
=
EditorDOMRange
(
rangesToWrapTheLine
.
FirstRangeRef
(
)
)
;
return
NS_OK
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
SplitToMakeTheLineIsolated
(
HTMLEditor
&
aHTMLEditor
const
nsIContent
&
aNewContainer
const
Element
&
aEditingHost
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
)
const
{
AutoRangeArray
rangesToWrapTheLine
(
mLineRange
)
;
Result
<
EditorDOMPoint
nsresult
>
splitResult
=
rangesToWrapTheLine
.
SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries
(
aHTMLEditor
aEditingHost
&
aNewContainer
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
"
"
SplitTextAtEndBoundariesAndInlineAncestorsAtBothBoundaries
(
)
failed
"
)
;
return
Err
(
splitResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToPutCaret
;
if
(
splitResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitResult
.
unwrap
(
)
;
}
nsresult
rv
=
rangesToWrapTheLine
.
CollectEditTargetNodes
(
aHTMLEditor
aOutArrayOfContents
EditSubAction
:
:
eMergeBlockContents
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eMergeBlockContents
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
CaretPoint
(
pointToPutCaret
)
;
}
Element
*
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
GetMostDistantInclusiveAncestorBlockInSpecificAncestorElement
(
Element
&
aBlockElement
const
Element
&
aAncestorElement
)
{
MOZ_ASSERT
(
aBlockElement
.
IsInclusiveDescendantOf
(
&
aAncestorElement
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aBlockElement
)
)
;
if
(
&
aBlockElement
=
=
&
aAncestorElement
)
{
return
nullptr
;
}
Element
*
lastBlockAncestor
=
&
aBlockElement
;
for
(
Element
*
element
:
aBlockElement
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
=
=
&
aAncestorElement
)
{
return
lastBlockAncestor
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
lastBlockAncestor
)
)
{
lastBlockAncestor
=
element
;
}
}
return
nullptr
;
}
HTMLEditor
:
:
PreserveWhiteSpaceStyle
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
ConsiderWhetherPreserveWhiteSpaceStyle
(
const
nsIContent
*
aContentInLine
const
Element
*
aInclusiveAncestorBlockOfInsertionPoint
)
{
if
(
MOZ_UNLIKELY
(
!
aInclusiveAncestorBlockOfInsertionPoint
)
)
{
return
PreserveWhiteSpaceStyle
:
:
No
;
}
const
auto
IsInclusiveDescendantOfPre
=
[
]
(
const
nsIContent
&
aContent
)
{
if
(
EditorUtils
:
:
GetComputedWhiteSpaceStyle
(
aContent
)
.
valueOr
(
StyleWhiteSpace
:
:
Normal
)
!
=
StyleWhiteSpace
:
:
Pre
)
{
return
false
;
}
for
(
const
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
)
{
return
true
;
}
}
return
false
;
}
;
if
(
IsInclusiveDescendantOfPre
(
*
aInclusiveAncestorBlockOfInsertionPoint
)
|
|
MOZ_UNLIKELY
(
!
aContentInLine
)
|
|
IsInclusiveDescendantOfPre
(
*
aContentInLine
)
)
{
return
PreserveWhiteSpaceStyle
:
:
No
;
}
return
PreserveWhiteSpaceStyle
:
:
Yes
;
}
Result
<
MoveNodeResult
nsresult
>
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
Run
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
)
{
EditorDOMPoint
pointToInsert
(
NextInsertionPointRef
(
)
)
;
MOZ_ASSERT
(
pointToInsert
.
IsInContentNode
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoTrackDOMPoint
tackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
Result
<
CaretPoint
nsresult
>
splitAtLineEdgesResult
=
SplitToMakeTheLineIsolated
(
aHTMLEditor
MOZ_KnownLive
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
aEditingHost
arrayOfContents
)
;
if
(
MOZ_UNLIKELY
(
splitAtLineEdgesResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
SplitToMakeTheLineIsolated
(
)
failed
"
)
;
return
splitAtLineEdgesResult
.
propagateErr
(
)
;
}
splitAtLineEdgesResult
.
unwrap
(
)
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
Result
<
EditorDOMPoint
nsresult
>
splitAtBRElementsResult
=
aHTMLEditor
.
MaybeSplitElementsAtEveryBRElement
(
arrayOfContents
EditSubAction
:
:
eMergeBlockContents
)
;
if
(
MOZ_UNLIKELY
(
splitAtBRElementsResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeSplitElementsAtEveryBRElement
(
EditSubAction
:
:
"
"
eMergeBlockContents
)
failed
"
)
;
return
splitAtBRElementsResult
.
propagateErr
(
)
;
}
if
(
splitAtBRElementsResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
splitAtBRElementsResult
.
unwrap
(
)
;
}
}
if
(
!
pointToInsert
.
IsSetAndValid
(
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
aHTMLEditor
.
AllowsTransactionsToChangeSelection
(
)
&
&
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
return
MoveNodeResult
:
:
IgnoredResult
(
std
:
:
move
(
pointToInsert
)
)
;
}
if
(
ForceMoveToEndOfContainer
(
)
)
{
pointToInsert
=
NextInsertionPointRef
(
)
;
}
EditorDOMRange
movedContentRange
(
pointToInsert
)
;
MoveNodeResult
moveContentsInLineResult
=
MoveNodeResult
:
:
IgnoredResult
(
pointToInsert
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
{
AutoEditorDOMRangeChildrenInvalidator
lockOffsets
(
movedContentRange
)
;
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveChildrenResult
=
aHTMLEditor
.
MoveChildrenWithTransaction
(
MOZ_KnownLive
(
*
content
-
>
AsElement
(
)
)
pointToInsert
mPreserveWhiteSpaceStyle
RemoveIfCommentNode
:
:
Yes
)
;
if
(
MOZ_UNLIKELY
(
moveChildrenResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
"
)
;
moveContentsInLineResult
.
IgnoreCaretPointSuggestion
(
)
;
return
moveChildrenResult
;
}
moveContentsInLineResult
|
=
moveChildrenResult
.
inspect
(
)
;
moveContentsInLineResult
.
MarkAsHandled
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
content
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
moveContentsInLineResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
}
else
if
(
content
-
>
IsComment
(
)
|
|
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
content
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
)
)
{
nsCOMPtr
<
nsIContent
>
emptyContent
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
content
&
aEditingHost
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
if
(
!
emptyContent
)
{
emptyContent
=
content
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
emptyContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
moveContentsInLineResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
}
else
{
Result
<
MoveNodeResult
nsresult
>
moveNodeOrChildrenResult
=
aHTMLEditor
.
MoveNodeOrChildrenWithTransaction
(
MOZ_KnownLive
(
content
)
pointToInsert
mPreserveWhiteSpaceStyle
RemoveIfCommentNode
:
:
Yes
)
;
if
(
MOZ_UNLIKELY
(
moveNodeOrChildrenResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
)
failed
"
)
;
moveContentsInLineResult
.
IgnoreCaretPointSuggestion
(
)
;
return
moveNodeOrChildrenResult
;
}
moveContentsInLineResult
|
=
moveNodeOrChildrenResult
.
inspect
(
)
;
}
}
if
(
ForceMoveToEndOfContainer
(
)
)
{
pointToInsert
=
NextInsertionPointRef
(
)
;
movedContentRange
.
SetEnd
(
pointToInsert
)
;
}
else
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
MOZ_UNLIKELY
(
!
moveContentsInLineResult
.
NextInsertionPointRef
(
)
.
IsSetAndValid
(
)
)
)
{
mPointToInsert
.
SetToEndOf
(
mPointToInsert
.
GetContainer
(
)
)
;
pointToInsert
=
NextInsertionPointRef
(
)
;
movedContentRange
.
SetEnd
(
pointToInsert
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
moveContentsInLineResult
.
NextInsertionPointRef
(
)
.
IsSet
(
)
)
;
mPointToInsert
=
moveContentsInLineResult
.
NextInsertionPointRef
(
)
;
pointToInsert
=
NextInsertionPointRef
(
)
;
if
(
!
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
|
|
movedContentRange
.
EndRef
(
)
.
IsBefore
(
pointToInsert
)
)
{
movedContentRange
.
SetEnd
(
pointToInsert
)
;
}
}
}
if
(
moveContentsInLineResult
.
Ignored
(
)
|
|
MOZ_UNLIKELY
(
!
mDestInclusiveAncestorBlock
)
)
{
return
moveContentsInLineResult
;
}
if
(
MOZ_UNLIKELY
(
!
movedContentRange
.
IsPositioned
(
)
|
|
movedContentRange
.
Collapsed
(
)
)
)
{
return
moveContentsInLineResult
;
}
nsresult
rv
=
DeleteUnnecessaryTrailingLineBreakInMovedLineEnd
(
aHTMLEditor
movedContentRange
aEditingHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoMoveOneLineHandler
:
:
"
"
DeleteUnnecessaryTrailingLineBreakInMovedLineEnd
(
)
failed
"
)
;
moveContentsInLineResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
return
moveContentsInLineResult
;
}
nsresult
HTMLEditor
:
:
AutoMoveOneLineHandler
:
:
DeleteUnnecessaryTrailingLineBreakInMovedLineEnd
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aMovedContentRange
const
Element
&
aEditingHost
)
const
{
MOZ_ASSERT
(
mDestInclusiveAncestorBlock
)
;
MOZ_ASSERT
(
aMovedContentRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
!
aMovedContentRange
.
Collapsed
(
)
)
;
if
(
mPreserveWhiteSpaceStyle
=
=
PreserveWhiteSpaceStyle
:
:
No
)
{
const
RefPtr
<
Text
>
textNodeEndingWithUnnecessaryLineBreak
=
[
&
]
(
)
-
>
Text
*
{
Text
*
lastTextNode
=
Text
:
:
FromNodeOrNull
(
mMovingToParentBlock
?
HTMLEditUtils
:
:
GetPreviousContent
(
*
mTopmostSrcAncestorBlockInDestBlock
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
mDestInclusiveAncestorBlock
)
:
HTMLEditUtils
:
:
GetLastLeafContent
(
*
mDestInclusiveAncestorBlock
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
)
)
;
if
(
!
lastTextNode
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
lastTextNode
)
)
{
return
nullptr
;
}
const
nsTextFragment
&
textFragment
=
lastTextNode
-
>
TextFragment
(
)
;
const
char16_t
lastCh
=
textFragment
.
GetLength
(
)
?
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
:
0
;
return
lastCh
=
=
HTMLEditUtils
:
:
kNewLine
&
&
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
lastTextNode
)
?
lastTextNode
:
nullptr
;
}
(
)
;
if
(
textNodeEndingWithUnnecessaryLineBreak
)
{
if
(
textNodeEndingWithUnnecessaryLineBreak
-
>
TextDataLength
(
)
=
=
1u
)
{
const
RefPtr
<
Element
>
inlineElement
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
textNodeEndingWithUnnecessaryLineBreak
&
aEditingHost
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
inlineElement
?
static_cast
<
nsIContent
&
>
(
*
inlineElement
)
:
static_cast
<
nsIContent
&
>
(
*
textNodeEndingWithUnnecessaryLineBreak
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
else
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextWithTransaction
(
*
textNodeEndingWithUnnecessaryLineBreak
textNodeEndingWithUnnecessaryLineBreak
-
>
TextDataLength
(
)
-
1u
1u
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
nsresult
rv
=
caretPointOrError
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
lastLineBreakContent
=
mMovingToParentBlock
?
HTMLEditUtils
:
:
GetUnnecessaryLineBreakContent
(
*
mTopmostSrcAncestorBlockInDestBlock
ScanLineBreak
:
:
BeforeBlock
)
:
HTMLEditUtils
:
:
GetUnnecessaryLineBreakContent
(
*
mDestInclusiveAncestorBlock
ScanLineBreak
:
:
AtEndOfBlock
)
;
if
(
!
lastLineBreakContent
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atUnnecessaryLineBreak
(
lastLineBreakContent
)
;
if
(
NS_WARN_IF
(
!
atUnnecessaryLineBreak
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
aMovedContentRange
.
StartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aMovedContentRange
.
EndRef
(
)
.
IsSetAndValid
(
)
)
;
if
(
!
aMovedContentRange
.
Contains
(
atUnnecessaryLineBreak
)
)
{
return
NS_OK
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
if
(
Text
*
textNode
=
Text
:
:
FromNode
(
lastLineBreakContent
)
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
)
;
if
(
textNode
-
>
TextDataLength
(
)
>
1
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
aHTMLEditor
.
DeleteTextWithTransaction
(
MOZ_KnownLive
(
*
textNode
)
textNode
-
>
TextDataLength
(
)
-
1u
1u
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
caretPointOrError
.
unwrapErr
(
)
;
}
caretPointOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
}
else
{
MOZ_ASSERT
(
lastLineBreakContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
}
if
(
const
RefPtr
<
Element
>
inlineElement
=
HTMLEditUtils
:
:
GetMostDistantAncestorEditableEmptyInlineElement
(
*
lastLineBreakContent
&
aEditingHost
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
inlineElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
lastLineBreakContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
CanMoveNodeOrChildren
(
const
nsIContent
&
aContent
const
nsINode
&
aNewContainer
)
const
{
if
(
HTMLEditUtils
:
:
CanNodeContain
(
aNewContainer
aContent
)
)
{
return
true
;
}
if
(
aContent
.
IsElement
(
)
)
{
return
CanMoveChildren
(
*
aContent
.
AsElement
(
)
aNewContainer
)
;
}
return
true
;
}
Result
<
MoveNodeResult
nsresult
>
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
nsIContent
&
aContentToMove
const
EditorDOMPoint
&
aPointToInsert
PreserveWhiteSpaceStyle
aPreserveWhiteSpaceStyle
RemoveIfCommentNode
aRemoveIfCommentNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsInContentNode
(
)
)
;
const
auto
destWhiteSpaceStyle
=
[
&
]
(
)
-
>
Maybe
<
StyleWhiteSpace
>
{
if
(
aPreserveWhiteSpaceStyle
=
=
PreserveWhiteSpaceStyle
:
:
No
|
|
!
aPointToInsert
.
IsInContentNode
(
)
)
{
return
Nothing
(
)
;
}
auto
style
=
EditorUtils
:
:
GetComputedWhiteSpaceStyle
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
if
(
NS_WARN_IF
(
style
.
isSome
(
)
&
&
style
.
value
(
)
=
=
StyleWhiteSpace
:
:
PreSpace
)
)
{
return
Nothing
(
)
;
}
return
style
;
}
(
)
;
const
auto
srcWhiteSpaceStyle
=
[
&
]
(
)
-
>
Maybe
<
StyleWhiteSpace
>
{
if
(
aPreserveWhiteSpaceStyle
=
=
PreserveWhiteSpaceStyle
:
:
No
)
{
return
Nothing
(
)
;
}
auto
style
=
EditorUtils
:
:
GetComputedWhiteSpaceStyle
(
aContentToMove
)
;
if
(
NS_WARN_IF
(
style
.
isSome
(
)
&
&
style
.
value
(
)
=
=
StyleWhiteSpace
:
:
PreSpace
)
)
{
return
Nothing
(
)
;
}
return
style
;
}
(
)
;
const
auto
GetWhiteSpaceStyleValue
=
[
]
(
StyleWhiteSpace
aStyleWhiteSpace
)
{
switch
(
aStyleWhiteSpace
)
{
case
StyleWhiteSpace
:
:
Normal
:
return
u
"
normal
"
_ns
;
case
StyleWhiteSpace
:
:
Pre
:
return
u
"
pre
"
_ns
;
case
StyleWhiteSpace
:
:
Nowrap
:
return
u
"
nowrap
"
_ns
;
case
StyleWhiteSpace
:
:
PreWrap
:
return
u
"
pre
-
wrap
"
_ns
;
case
StyleWhiteSpace
:
:
PreLine
:
return
u
"
pre
-
line
"
_ns
;
case
StyleWhiteSpace
:
:
BreakSpaces
:
return
u
"
break
-
spaces
"
_ns
;
case
StyleWhiteSpace
:
:
PreSpace
:
MOZ_ASSERT_UNREACHABLE
(
"
Don
'
t
handle
-
moz
-
pre
-
space
"
)
;
return
u
"
"
_ns
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Handle
the
new
white
-
space
value
"
)
;
return
u
"
"
_ns
;
}
}
;
if
(
aRemoveIfCommentNode
=
=
RemoveIfCommentNode
:
:
Yes
&
&
aContentToMove
.
IsComment
(
)
)
{
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
{
AutoTrackDOMPoint
trackPointToInsert
(
RangeUpdaterRef
(
)
&
pointToInsert
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
aContentToMove
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSetAndValid
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
MoveNodeResult
:
:
HandledResult
(
std
:
:
move
(
pointToInsert
)
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
aContentToMove
)
)
{
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
if
(
destWhiteSpaceStyle
.
isSome
(
)
&
&
srcWhiteSpaceStyle
.
isSome
(
)
&
&
destWhiteSpaceStyle
.
value
(
)
!
=
srcWhiteSpaceStyle
.
value
(
)
)
{
if
(
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNode
(
&
aContentToMove
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
*
this
MOZ_KnownLive
(
*
styledElement
)
*
nsGkAtoms
:
:
white_space
GetWhiteSpaceStyleValue
(
srcWhiteSpaceStyle
.
value
(
)
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
SetCSSPropertyWithTransaction
(
"
"
nsGkAtoms
:
:
white_space
)
failed
but
ignored
"
)
;
}
else
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsert
.
GetContainer
(
)
*
nsGkAtoms
:
:
span
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
nsGkAtoms
:
:
span
aContentToMove
)
)
{
RefPtr
<
Element
>
newSpanElement
=
CreateHTMLContent
(
nsGkAtoms
:
:
span
)
;
if
(
NS_WARN_IF
(
!
newSpanElement
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
nsAutoString
styleAttrValue
(
u
"
white
-
space
:
"
_ns
)
;
styleAttrValue
.
Append
(
GetWhiteSpaceStyleValue
(
srcWhiteSpaceStyle
.
value
(
)
)
)
;
IgnoredErrorResult
error
;
newSpanElement
-
>
SetAttr
(
nsGkAtoms
:
:
style
styleAttrValue
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
span
)
failed
"
)
;
if
(
MOZ_LIKELY
(
!
error
.
Failed
(
)
)
)
{
Result
<
CreateElementResult
nsresult
>
insertSpanElementResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newSpanElement
aPointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertSpanElementResult
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
insertSpanElementResult
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
InsertNodeWithTransaction
(
)
failed
but
ignored
"
)
;
}
else
{
pointToInsert
.
Set
(
newSpanElement
0u
)
;
insertSpanElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
}
}
}
Result
<
MoveNodeResult
nsresult
>
moveNodeResult
=
MoveNodeWithTransaction
(
aContentToMove
pointToInsert
)
;
NS_WARNING_ASSERTION
(
moveNodeResult
.
isOk
(
)
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
if
(
moveNodeResult
.
isOk
(
)
)
{
MoveNodeResult
unwrappedMoveNodeResult
=
moveNodeResult
.
unwrap
(
)
;
unwrappedMoveNodeResult
.
MarkAsHandled
(
)
;
return
unwrappedMoveNodeResult
;
}
return
moveNodeResult
;
}
auto
moveNodeResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
MoveNodeResult
nsresult
>
{
if
(
!
aContentToMove
.
IsElement
(
)
)
{
return
MoveNodeResult
:
:
HandledResult
(
aPointToInsert
)
;
}
Result
<
MoveNodeResult
nsresult
>
moveChildrenResult
=
MoveChildrenWithTransaction
(
MOZ_KnownLive
(
*
aContentToMove
.
AsElement
(
)
)
aPointToInsert
aPreserveWhiteSpaceStyle
aRemoveIfCommentNode
)
;
NS_WARNING_ASSERTION
(
moveChildrenResult
.
isOk
(
)
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
"
)
;
return
moveChildrenResult
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
moveNodeResult
.
isErr
(
)
)
)
{
return
moveNodeResult
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aContentToMove
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
moveNodeResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
rv
)
;
}
if
(
!
MayHaveMutationEventListeners
(
)
)
{
return
moveNodeResult
;
}
if
(
moveNodeResult
.
inspect
(
)
.
NextInsertionPointRef
(
)
.
IsSetAndValid
(
)
)
{
return
moveNodeResult
;
}
moveNodeResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
MoveNodeResult
:
:
HandledResult
(
EditorDOMPoint
:
:
AtEndOf
(
*
aPointToInsert
.
GetContainer
(
)
)
)
;
}
Result
<
bool
nsresult
>
HTMLEditor
:
:
CanMoveChildren
(
const
Element
&
aElement
const
nsINode
&
aNewContainer
)
const
{
if
(
NS_WARN_IF
(
&
aElement
=
=
&
aNewContainer
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
for
(
nsIContent
*
childContent
=
aElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
Result
<
bool
nsresult
>
result
=
CanMoveNodeOrChildren
(
*
childContent
aNewContainer
)
;
if
(
result
.
isErr
(
)
|
|
result
.
inspect
(
)
)
{
return
result
;
}
}
return
false
;
}
Result
<
MoveNodeResult
nsresult
>
HTMLEditor
:
:
MoveChildrenWithTransaction
(
Element
&
aElement
const
EditorDOMPoint
&
aPointToInsert
PreserveWhiteSpaceStyle
aPreserveWhiteSpaceStyle
RemoveIfCommentNode
aRemoveIfCommentNode
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
NS_WARN_IF
(
&
aElement
=
=
aPointToInsert
.
GetContainer
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
MoveNodeResult
moveChildrenResult
=
MoveNodeResult
:
:
IgnoredResult
(
aPointToInsert
)
;
while
(
aElement
.
GetFirstChild
(
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveNodeOrChildrenResult
=
MoveNodeOrChildrenWithTransaction
(
MOZ_KnownLive
(
*
aElement
.
GetFirstChild
(
)
)
moveChildrenResult
.
NextInsertionPointRef
(
)
aPreserveWhiteSpaceStyle
aRemoveIfCommentNode
)
;
if
(
MOZ_UNLIKELY
(
moveNodeOrChildrenResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeOrChildrenWithTransaction
(
)
failed
"
)
;
moveChildrenResult
.
IgnoreCaretPointSuggestion
(
)
;
return
moveNodeOrChildrenResult
;
}
moveChildrenResult
|
=
moveNodeOrChildrenResult
.
inspect
(
)
;
}
return
moveChildrenResult
;
}
void
HTMLEditor
:
:
MoveAllChildren
(
nsINode
&
aContainer
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
Failed
(
)
)
;
if
(
!
aContainer
.
HasChildren
(
)
)
{
return
;
}
nsIContent
*
firstChild
=
aContainer
.
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
aContainer
.
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MoveChildrenBetween
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveChildrenBetween
(
)
failed
"
)
;
}
void
HTMLEditor
:
:
MoveChildrenBetween
(
nsIContent
&
aFirstChild
nsIContent
&
aLastChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsINode
>
oldContainer
=
aFirstChild
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
oldContainer
!
=
aLastChild
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
aPointToInsert
.
CanContainerHaveChildren
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
children
;
for
(
nsIContent
*
child
=
&
aFirstChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
child
)
;
if
(
child
=
=
&
aLastChild
)
{
break
;
}
}
if
(
NS_WARN_IF
(
children
.
LastElement
(
)
!
=
&
aLastChild
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsCOMPtr
<
nsIContent
>
newContainer
=
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
aPointToInsert
.
GetChild
(
)
;
for
(
size_t
i
=
children
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
&
child
=
children
[
i
-
1
]
;
if
(
child
-
>
GetParentNode
(
)
!
=
oldContainer
)
{
continue
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
*
child
)
)
)
{
aError
.
Throw
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
return
;
}
oldContainer
-
>
RemoveChild
(
*
child
aError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
RemoveChild
(
)
failed
"
)
;
return
;
}
if
(
nextNode
)
{
EditorRawDOMPoint
pointToInsert
(
nextNode
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
pointToInsert
.
GetContainer
(
)
!
=
newContainer
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
newContainer
EditorType
:
:
HTML
)
)
)
{
aError
.
Throw
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
return
;
}
newContainer
-
>
InsertBefore
(
*
child
nextNode
aError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
;
}
if
(
child
-
>
GetParentNode
(
)
=
=
newContainer
)
{
nextNode
=
child
;
}
}
}
void
HTMLEditor
:
:
MovePreviousSiblings
(
nsIContent
&
aChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
!
aChild
.
GetParentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsIContent
*
firstChild
=
aChild
.
GetParentNode
(
)
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
lastChild
=
&
aChild
=
=
firstChild
?
firstChild
:
aChild
.
GetPreviousSibling
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MoveChildrenBetween
(
*
firstChild
*
lastChild
aPointToInsert
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveChildrenBetween
(
)
failed
"
)
;
}
void
HTMLEditor
:
:
MoveInclusiveNextSiblings
(
nsIContent
&
aChild
const
EditorRawDOMPoint
&
aPointToInsert
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
!
aChild
.
GetParentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsIContent
*
lastChild
=
aChild
.
GetParentNode
(
)
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
lastChild
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MoveChildrenBetween
(
aChild
*
lastChild
aPointToInsert
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveChildrenBetween
(
)
failed
"
)
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoBlockElementsJoiner
:
:
DeleteContentButKeepTableStructure
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
&
aContent
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
10
>
childList
;
for
(
nsIContent
*
child
=
aContent
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childList
.
AppendElement
(
*
child
)
;
}
for
(
const
auto
&
child
:
childList
)
{
nsresult
rv
=
DeleteContentButKeepTableStructure
(
aHTMLEditor
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteContentButKeepTableStructure
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteMostAncestorMailCiteElementIfEmpty
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
mailCiteElement
=
GetMostDistantAncestorMailCiteElement
(
aContent
)
;
if
(
!
mailCiteElement
)
{
return
NS_OK
;
}
bool
seenBR
=
false
;
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
*
mailCiteElement
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
&
seenBR
)
)
{
return
NS_OK
;
}
EditorDOMPoint
atEmptyMailCiteElement
(
mailCiteElement
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
atEmptyMailCiteElement
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
*
mailCiteElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
atEmptyMailCiteElement
.
IsSet
(
)
|
|
!
seenBR
)
{
NS_WARNING_ASSERTION
(
atEmptyMailCiteElement
.
IsSet
(
)
"
Mutation
event
listener
might
changed
the
DOM
tree
during
"
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
but
ignored
"
)
;
return
NS_OK
;
}
Result
<
CreateElementResult
nsresult
>
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
atEmptyMailCiteElement
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
MOZ_ASSERT
(
insertBRElementResult
.
inspect
(
)
.
GetNewNode
(
)
)
;
insertBRElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
insertBRElementResult
.
inspect
(
)
.
GetNewNode
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
ScanEmptyBlockInclusiveAncestor
(
const
HTMLEditor
&
aHTMLEditor
nsIContent
&
aStartContent
)
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
mEmptyInclusiveAncestorBlockElement
)
;
Element
*
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
aStartContent
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
editableBlockElement
)
{
return
nullptr
;
}
while
(
editableBlockElement
&
&
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
*
editableBlockElement
)
&
&
!
HTMLEditUtils
:
:
IsAnyTableElement
(
editableBlockElement
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
editableBlockElement
)
)
{
if
(
HTMLEditUtils
:
:
IsListItem
(
editableBlockElement
)
)
{
Element
*
const
parentElement
=
editableBlockElement
-
>
GetParentElement
(
)
;
if
(
parentElement
&
&
HTMLEditUtils
:
:
IsAnyListElement
(
parentElement
)
&
&
!
HTMLEditUtils
:
:
IsRemovableFromParentNode
(
*
parentElement
)
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
parentElement
)
)
{
break
;
}
}
mEmptyInclusiveAncestorBlockElement
=
editableBlockElement
;
editableBlockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
mEmptyInclusiveAncestorBlockElement
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
}
if
(
!
mEmptyInclusiveAncestorBlockElement
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
mEmptyInclusiveAncestorBlockElement
-
>
IsEditable
(
)
)
|
|
NS_WARN_IF
(
!
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
)
{
mEmptyInclusiveAncestorBlockElement
=
nullptr
;
}
return
mEmptyInclusiveAncestorBlockElement
;
}
nsresult
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
ComputeTargetRanges
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
const
Element
&
aEditingHost
AutoRangeArray
&
aRangesToDelete
)
const
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNone
:
break
;
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
startPoint
=
HTMLEditUtils
:
:
GetPreviousEditablePoint
<
EditorRawDOMPoint
>
(
*
mEmptyInclusiveAncestorBlockElement
&
aEditingHost
InvisibleWhiteSpaces
:
:
Preserve
TableBoundary
:
:
NoCrossAnyTableElement
)
;
if
(
!
startPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
didn
'
t
return
a
valid
"
"
point
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
startPoint
EditorRawDOMPoint
:
:
AtEndOf
(
mEmptyInclusiveAncestorBlockElement
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
EditorRawDOMPoint
endPoint
=
HTMLEditUtils
:
:
GetNextEditablePoint
<
EditorRawDOMPoint
>
(
*
mEmptyInclusiveAncestorBlockElement
&
aEditingHost
InvisibleWhiteSpaces
:
:
Preserve
TableBoundary
:
:
NoCrossAnyTableElement
)
;
if
(
!
endPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetNextEditablePoint
(
)
didn
'
t
return
a
valid
"
"
point
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aRangesToDelete
.
SetStartAndEnd
(
EditorRawDOMPoint
(
mEmptyInclusiveAncestorBlockElement
0
)
endPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
rv
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Handle
the
nsIEditor
:
:
EDirection
value
"
)
;
break
;
}
nsresult
rv
=
aRangesToDelete
.
SelectNode
(
*
mEmptyInclusiveAncestorBlockElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
SelectNode
(
)
failed
"
)
;
return
rv
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
MaybeInsertBRElementBeforeEmptyListItemElement
(
HTMLEditor
&
aHTMLEditor
)
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
!
HTMLEditUtils
:
:
IsFirstChild
(
*
mEmptyInclusiveAncestorBlockElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
EditorDOMPoint
atParentOfEmptyListItem
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
if
(
NS_WARN_IF
(
!
atParentOfEmptyListItem
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
atParentOfEmptyListItem
.
GetContainer
(
)
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
Result
<
CreateElementResult
nsresult
>
insertBRElementResult
=
aHTMLEditor
.
InsertBRElement
(
WithTransaction
:
:
Yes
atParentOfEmptyListItem
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedInsertBRElementResult
=
insertBRElementResult
.
unwrap
(
)
;
nsresult
rv
=
unwrappedInsertBRElementResult
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
MOZ_ASSERT
(
unwrappedInsertBRElementResult
.
GetNewNode
(
)
)
;
return
unwrappedInsertBRElementResult
.
UnwrapNewNode
(
)
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
GetNewCaretPosition
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
const
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNext
:
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
eToEndOfLine
:
{
auto
afterEmptyBlock
(
EditorDOMPoint
:
:
After
(
mEmptyInclusiveAncestorBlockElement
)
)
;
MOZ_ASSERT
(
afterEmptyBlock
.
IsSet
(
)
)
;
if
(
nsIContent
*
nextContentOfEmptyBlock
=
HTMLEditUtils
:
:
GetNextContent
(
afterEmptyBlock
{
}
aHTMLEditor
.
ComputeEditingHost
(
)
)
)
{
EditorDOMPoint
pt
=
HTMLEditUtils
:
:
GetGoodCaretPointFor
<
EditorDOMPoint
>
(
*
nextContentOfEmptyBlock
aDirectionAndAmount
)
;
if
(
!
pt
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
pt
)
)
;
}
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
afterEmptyBlock
)
)
;
}
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
{
EditorRawDOMPoint
atEmptyBlock
(
mEmptyInclusiveAncestorBlockElement
)
;
if
(
nsIContent
*
previousContentOfEmptyBlock
=
HTMLEditUtils
:
:
GetPreviousContent
(
atEmptyBlock
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aHTMLEditor
.
ComputeEditingHost
(
)
)
)
{
EditorDOMPoint
pt
=
HTMLEditUtils
:
:
GetGoodCaretPointFor
<
EditorDOMPoint
>
(
*
previousContentOfEmptyBlock
aDirectionAndAmount
)
;
if
(
!
pt
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetGoodCaretPointFor
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
pt
)
)
;
}
auto
afterEmptyBlock
=
EditorDOMPoint
:
:
After
(
*
mEmptyInclusiveAncestorBlockElement
)
;
if
(
NS_WARN_IF
(
!
afterEmptyBlock
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
afterEmptyBlock
)
)
;
}
case
nsIEditor
:
:
eNone
:
{
EditorDOMPoint
atEmptyBlock
(
mEmptyInclusiveAncestorBlockElement
)
;
if
(
NS_WARN_IF
(
!
atEmptyBlock
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
CaretPoint
(
std
:
:
move
(
atEmptyBlock
)
)
;
}
default
:
MOZ_CRASH
(
"
AutoEmptyBlockAncestorDeleter
doesn
'
t
support
this
action
yet
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
Run
(
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
{
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
)
;
MOZ_ASSERT
(
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
)
;
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
{
Result
<
EditActionResult
nsresult
>
result
=
MaybeReplaceSubListWithNewListItem
(
aHTMLEditor
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoEmptyBlockAncestorDeleter
:
:
MaybeReplaceSubListWithNewListItem
(
)
"
"
failed
"
)
;
return
result
;
}
if
(
result
.
inspect
(
)
.
Handled
(
)
)
{
return
result
;
}
}
if
(
HTMLEditUtils
:
:
IsListItem
(
mEmptyInclusiveAncestorBlockElement
)
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
result
=
MaybeInsertBRElementBeforeEmptyListItemElement
(
aHTMLEditor
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoEmptyBlockAncestorDeleter
:
:
"
"
MaybeInsertBRElementBeforeEmptyListItemElement
(
)
failed
"
)
;
return
result
.
propagateErr
(
)
;
}
if
(
RefPtr
<
Element
>
brElement
=
result
.
unwrap
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
EditorRawDOMPoint
(
brElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
else
{
Result
<
CaretPoint
nsresult
>
result
=
GetNewCaretPosition
(
aHTMLEditor
aDirectionAndAmount
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoEmptyBlockAncestorDeleter
:
:
GetNewCaretPosition
(
)
failed
"
)
;
return
result
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
result
.
inspect
(
)
.
HasCaretPointSuggestion
(
)
)
;
nsresult
rv
=
result
.
inspect
(
)
.
SuggestCaretPointTo
(
aHTMLEditor
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
AutoEmptyBlockAncestorDeleter
:
:
MaybeReplaceSubListWithNewListItem
(
HTMLEditor
&
aHTMLEditor
)
{
if
(
!
HTMLEditUtils
:
:
IsAnyListElement
(
mEmptyInclusiveAncestorBlockElement
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
RefPtr
<
Element
>
parentElement
=
mEmptyInclusiveAncestorBlockElement
-
>
GetParentElement
(
)
;
if
(
!
parentElement
|
|
!
HTMLEditUtils
:
:
IsAnyListElement
(
parentElement
)
|
|
!
HTMLEditUtils
:
:
IsEmptyNode
(
*
parentElement
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
nsCOMPtr
<
nsINode
>
nextSibling
=
mEmptyInclusiveAncestorBlockElement
-
>
GetNextSibling
(
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
mEmptyInclusiveAncestorBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
Result
<
CreateElementResult
nsresult
>
insertListItemResult
=
aHTMLEditor
.
CreateAndInsertElement
(
WithTransaction
:
:
Yes
parentElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
?
*
nsGkAtoms
:
:
dd
:
*
nsGkAtoms
:
:
li
!
nextSibling
|
|
nextSibling
-
>
GetParentNode
(
)
!
=
parentElement
?
EditorDOMPoint
:
:
AtEndOf
(
*
parentElement
)
:
EditorDOMPoint
(
nextSibling
)
[
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aNewElement
const
EditorDOMPoint
&
aPointToInsert
)
-
>
nsresult
{
RefPtr
<
Element
>
brElement
=
aHTMLEditor
.
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
;
if
(
MOZ_UNLIKELY
(
!
brElement
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateHTMLContent
(
nsGkAtoms
:
:
br
)
failed
but
"
"
ignored
"
)
;
return
NS_OK
;
}
IgnoredErrorResult
error
;
aNewElement
.
AppendChild
(
*
brElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
nsINode
:
:
AppendChild
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
)
;
if
(
MOZ_UNLIKELY
(
insertListItemResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
)
failed
"
)
;
return
insertListItemResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedInsertListItemResult
=
insertListItemResult
.
unwrap
(
)
;
unwrappedInsertListItemResult
.
IgnoreCaretPointSuggestion
(
)
;
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
EditorRawDOMPoint
(
unwrappedInsertListItemResult
.
GetNewNode
(
)
0u
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
template
<
typename
EditorDOMRangeType
>
Result
<
EditorRawDOMRange
nsresult
>
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
ExtendOrShrinkRangeToDelete
(
const
HTMLEditor
&
aHTMLEditor
const
nsFrameSelection
*
aFrameSelection
const
EditorDOMRangeType
&
aRangeToDelete
)
const
{
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRangeToDelete
.
Collapsed
(
)
)
;
MOZ_ASSERT
(
aRangeToDelete
.
IsPositioned
(
)
)
;
const
nsIContent
*
commonAncestor
=
nsIContent
:
:
FromNodeOrNull
(
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
aRangeToDelete
.
StartRef
(
)
.
GetContainer
(
)
aRangeToDelete
.
EndRef
(
)
.
GetContainer
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
commonAncestor
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
Element
*
const
maybeNonEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
commonAncestor
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
NS_WARN_IF
(
!
maybeNonEditableBlockElement
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
const
Element
*
maybeListElement
=
HTMLEditUtils
:
:
GetElementIfOnlyOneSelected
(
aRangeToDelete
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
maybeListElement
)
&
&
!
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
maybeListElement
)
)
{
EditorRawDOMRange
range
=
HTMLEditUtils
:
:
GetRangeSelectingAllContentInAllListItems
<
EditorRawDOMRange
>
(
*
maybeListElement
)
;
if
(
range
.
IsPositioned
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
range
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
range
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
{
return
range
;
}
}
}
}
EditorRawDOMRange
rangeToDelete
(
aRangeToDelete
)
;
if
(
rangeToDelete
.
StartRef
(
)
.
GetContainer
(
)
!
=
maybeNonEditableBlockElement
&
&
rangeToDelete
.
StartRef
(
)
.
GetContainer
(
)
!
=
editingHost
)
{
for
(
;
;
)
{
WSScanResult
backwardScanFromStartResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
editingHost
rangeToDelete
.
StartRef
(
)
)
;
if
(
!
backwardScanFromStartResult
.
ReachedCurrentBlockBoundary
(
)
)
{
break
;
}
MOZ_ASSERT
(
backwardScanFromStartResult
.
GetContent
(
)
=
=
WSRunScanner
(
editingHost
rangeToDelete
.
StartRef
(
)
)
.
GetStartReasonContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
backwardScanFromStartResult
.
GetContent
(
)
)
|
|
backwardScanFromStartResult
.
GetContent
(
)
=
=
maybeNonEditableBlockElement
|
|
backwardScanFromStartResult
.
GetContent
(
)
=
=
editingHost
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
backwardScanFromStartResult
.
GetContent
(
)
)
&
&
!
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
backwardScanFromStartResult
.
ElementPtr
(
)
)
)
{
break
;
}
rangeToDelete
.
SetStart
(
backwardScanFromStartResult
.
PointAtContent
<
EditorRawDOMPoint
>
(
)
)
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
rangeToDelete
.
StartRef
(
)
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
start
container
was
out
of
selection
limiter
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
EditorDOMPoint
atFirstInvisibleBRElement
;
if
(
rangeToDelete
.
EndRef
(
)
.
GetContainer
(
)
!
=
maybeNonEditableBlockElement
&
&
rangeToDelete
.
EndRef
(
)
.
GetContainer
(
)
!
=
editingHost
)
{
for
(
;
;
)
{
WSRunScanner
wsScannerAtEnd
(
editingHost
rangeToDelete
.
EndRef
(
)
)
;
WSScanResult
forwardScanFromEndResult
=
wsScannerAtEnd
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
rangeToDelete
.
EndRef
(
)
)
;
if
(
forwardScanFromEndResult
.
ReachedBRElement
(
)
)
{
NS_ASSERTION
(
wsScannerAtEnd
.
GetEndReasonContent
(
)
=
=
forwardScanFromEndResult
.
BRElementPtr
(
)
"
End
reason
is
not
the
reached
<
br
>
element
"
)
;
if
(
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
)
{
break
;
}
if
(
!
atFirstInvisibleBRElement
.
IsSet
(
)
)
{
atFirstInvisibleBRElement
=
rangeToDelete
.
EndRef
(
)
.
To
<
EditorDOMPoint
>
(
)
;
}
rangeToDelete
.
SetEnd
(
EditorRawDOMPoint
:
:
After
(
*
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
)
;
continue
;
}
if
(
forwardScanFromEndResult
.
ReachedCurrentBlockBoundary
(
)
)
{
MOZ_ASSERT
(
forwardScanFromEndResult
.
GetContent
(
)
=
=
wsScannerAtEnd
.
GetEndReasonContent
(
)
)
;
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
forwardScanFromEndResult
.
GetContent
(
)
)
|
|
forwardScanFromEndResult
.
GetContent
(
)
=
=
maybeNonEditableBlockElement
|
|
forwardScanFromEndResult
.
GetContent
(
)
=
=
editingHost
)
{
break
;
}
rangeToDelete
.
SetEnd
(
forwardScanFromEndResult
.
PointAfterContent
<
EditorRawDOMPoint
>
(
)
)
;
continue
;
}
break
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
rangeToDelete
.
EndRef
(
)
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
end
container
was
out
of
selection
limiter
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
{
EditorRawDOMRange
rangeToDeleteListOrLeaveOneEmptyListItem
=
AutoDeleteRangesHandler
:
:
GetRangeToAvoidDeletingAllListItemsIfSelectingAllOverListElements
(
rangeToDelete
)
;
if
(
rangeToDeleteListOrLeaveOneEmptyListItem
.
IsPositioned
(
)
)
{
rangeToDelete
=
std
:
:
move
(
rangeToDeleteListOrLeaveOneEmptyListItem
)
;
}
}
if
(
atFirstInvisibleBRElement
.
IsInContentNode
(
)
)
{
if
(
const
RefPtr
<
const
Element
>
editableBlockContainingBRElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
atFirstInvisibleBRElement
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
{
if
(
rangeToDelete
.
Contains
(
EditorRawDOMPoint
(
editableBlockContainingBRElement
)
)
)
{
return
rangeToDelete
;
}
if
(
aFrameSelection
&
&
!
aFrameSelection
-
>
IsValidSelectionPoint
(
atFirstInvisibleBRElement
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Computed
end
container
(
<
br
>
element
)
was
out
of
selection
"
"
limiter
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rangeToDelete
.
SetEnd
(
atFirstInvisibleBRElement
)
;
}
}
return
rangeToDelete
;
}
EditorRawDOMRange
HTMLEditor
:
:
AutoDeleteRangesHandler
:
:
GetRangeToAvoidDeletingAllListItemsIfSelectingAllOverListElements
(
const
EditorRawDOMRange
&
aRangeToDelete
)
{
MOZ_ASSERT
(
aRangeToDelete
.
IsPositionedAndValid
(
)
)
;
auto
GetDeepestEditableStartPointOfList
=
[
]
(
Element
&
aListElement
)
{
Element
*
const
firstListItemElement
=
HTMLEditUtils
:
:
GetFirstListItemElement
(
aListElement
)
;
if
(
MOZ_UNLIKELY
(
!
firstListItemElement
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
*
firstListItemElement
EditorType
:
:
HTML
)
)
)
{
return
EditorRawDOMPoint
(
firstListItemElement
)
;
}
return
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorRawDOMPoint
>
(
*
firstListItemElement
)
;
}
;
auto
GetDeepestEditableEndPointOfList
=
[
]
(
Element
&
aListElement
)
{
Element
*
const
lastListItemElement
=
HTMLEditUtils
:
:
GetLastListItemElement
(
aListElement
)
;
if
(
MOZ_UNLIKELY
(
!
lastListItemElement
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
EditorUtils
:
:
IsEditableContent
(
*
lastListItemElement
EditorType
:
:
HTML
)
)
)
{
return
EditorRawDOMPoint
:
:
After
(
*
lastListItemElement
)
;
}
return
HTMLEditUtils
:
:
GetDeepestEditableEndPointOf
<
EditorRawDOMPoint
>
(
*
lastListItemElement
)
;
}
;
Element
*
const
startListElement
=
aRangeToDelete
.
StartRef
(
)
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetClosestInclusiveAncestorAnyListElement
(
*
aRangeToDelete
.
StartRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
)
:
nullptr
;
Element
*
const
endListElement
=
aRangeToDelete
.
EndRef
(
)
.
IsInContentNode
(
)
?
HTMLEditUtils
:
:
GetClosestInclusiveAncestorAnyListElement
(
*
aRangeToDelete
.
EndRef
(
)
.
ContainerAs
<
nsIContent
>
(
)
)
:
nullptr
;
if
(
!
startListElement
&
&
!
endListElement
)
{
return
EditorRawDOMRange
(
)
;
}
if
(
startListElement
&
&
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsValidListElement
(
*
startListElement
HTMLEditUtils
:
:
TreatSubListElementAs
:
:
Valid
)
)
)
{
return
EditorRawDOMRange
(
)
;
}
if
(
endListElement
&
&
startListElement
!
=
endListElement
&
&
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsValidListElement
(
*
endListElement
HTMLEditUtils
:
:
TreatSubListElementAs
:
:
Valid
)
)
)
{
return
EditorRawDOMRange
(
)
;
}
const
bool
startListElementIsEmpty
=
startListElement
&
&
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
startListElement
)
;
const
bool
endListElementIsEmpty
=
startListElement
=
=
endListElement
?
startListElementIsEmpty
:
endListElement
&
&
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
endListElement
)
;
if
(
startListElementIsEmpty
&
&
endListElementIsEmpty
)
{
return
EditorRawDOMRange
(
)
;
}
EditorRawDOMPoint
deepestStartPointOfStartList
=
startListElement
?
GetDeepestEditableStartPointOfList
(
*
startListElement
)
:
EditorRawDOMPoint
(
)
;
EditorRawDOMPoint
deepestEndPointOfEndList
=
endListElement
?
GetDeepestEditableEndPointOfList
(
*
endListElement
)
:
EditorRawDOMPoint
(
)
;
if
(
MOZ_UNLIKELY
(
!
deepestStartPointOfStartList
.
IsSet
(
)
&
&
!
deepestEndPointOfEndList
.
IsSet
(
)
)
)
{
return
EditorRawDOMRange
(
)
;
}
if
(
deepestStartPointOfStartList
.
IsSet
(
)
)
{
for
(
nsIContent
*
const
maybeList
:
deepestStartPointOfStartList
.
GetContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
aRangeToDelete
.
StartRef
(
)
.
GetContainer
(
)
=
=
maybeList
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
maybeList
)
&
&
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
maybeList
-
>
AsElement
(
)
)
)
{
deepestStartPointOfStartList
.
Set
(
maybeList
)
;
}
}
}
if
(
deepestEndPointOfEndList
.
IsSet
(
)
)
{
for
(
nsIContent
*
const
maybeList
:
deepestEndPointOfEndList
.
GetContainer
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
aRangeToDelete
.
EndRef
(
)
.
GetContainer
(
)
=
=
maybeList
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
maybeList
)
&
&
HTMLEditUtils
:
:
IsEmptyAnyListElement
(
*
maybeList
-
>
AsElement
(
)
)
)
{
deepestEndPointOfEndList
.
SetAfter
(
maybeList
)
;
}
}
}
const
EditorRawDOMPoint
deepestEndPointOfStartList
=
startListElement
?
GetDeepestEditableEndPointOfList
(
*
startListElement
)
:
EditorRawDOMPoint
(
)
;
MOZ_ASSERT_IF
(
deepestStartPointOfStartList
.
IsSet
(
)
deepestEndPointOfStartList
.
IsSet
(
)
)
;
MOZ_ASSERT_IF
(
!
deepestStartPointOfStartList
.
IsSet
(
)
!
deepestEndPointOfStartList
.
IsSet
(
)
)
;
const
bool
rangeStartsFromBeginningOfStartList
=
deepestStartPointOfStartList
.
IsSet
(
)
&
&
aRangeToDelete
.
StartRef
(
)
.
EqualsOrIsBefore
(
deepestStartPointOfStartList
)
;
const
bool
rangeEndsByEndingOfStartListOrLater
=
!
deepestEndPointOfStartList
.
IsSet
(
)
|
|
deepestEndPointOfStartList
.
EqualsOrIsBefore
(
aRangeToDelete
.
EndRef
(
)
)
;
const
bool
rangeEndsByEndingOfEndList
=
deepestEndPointOfEndList
.
IsSet
(
)
&
&
deepestEndPointOfEndList
.
EqualsOrIsBefore
(
aRangeToDelete
.
EndRef
(
)
)
;
EditorRawDOMRange
newRangeToDelete
;
if
(
!
startListElementIsEmpty
&
&
rangeStartsFromBeginningOfStartList
&
&
rangeEndsByEndingOfStartListOrLater
)
{
newRangeToDelete
.
SetStart
(
EditorRawDOMPoint
(
deepestStartPointOfStartList
.
ContainerAs
<
nsIContent
>
(
)
0u
)
)
;
}
if
(
!
endListElementIsEmpty
&
&
rangeEndsByEndingOfEndList
)
{
if
(
aRangeToDelete
.
StartRef
(
)
.
IsBefore
(
EditorRawDOMPoint
(
endListElement
0u
)
)
)
{
newRangeToDelete
.
SetEnd
(
EditorRawDOMPoint
:
:
After
(
*
endListElement
)
)
;
MOZ_ASSERT_IF
(
newRangeToDelete
.
StartRef
(
)
.
IsSet
(
)
newRangeToDelete
.
IsPositionedAndValid
(
)
)
;
}
else
{
newRangeToDelete
.
SetEnd
(
EditorRawDOMPoint
:
:
AtEndOf
(
*
deepestEndPointOfEndList
.
ContainerAs
<
nsIContent
>
(
)
)
)
;
MOZ_ASSERT_IF
(
newRangeToDelete
.
StartRef
(
)
.
IsSet
(
)
newRangeToDelete
.
IsPositionedAndValid
(
)
)
;
}
}
if
(
!
newRangeToDelete
.
StartRef
(
)
.
IsSet
(
)
&
&
!
newRangeToDelete
.
EndRef
(
)
.
IsSet
(
)
)
{
return
EditorRawDOMRange
(
)
;
}
if
(
!
newRangeToDelete
.
StartRef
(
)
.
IsSet
(
)
)
{
newRangeToDelete
.
SetStart
(
aRangeToDelete
.
StartRef
(
)
)
;
MOZ_ASSERT
(
newRangeToDelete
.
IsPositionedAndValid
(
)
)
;
}
if
(
!
newRangeToDelete
.
EndRef
(
)
.
IsSet
(
)
)
{
newRangeToDelete
.
SetEnd
(
aRangeToDelete
.
EndRef
(
)
)
;
MOZ_ASSERT
(
newRangeToDelete
.
IsPositionedAndValid
(
)
)
;
}
return
newRangeToDelete
;
}
}
