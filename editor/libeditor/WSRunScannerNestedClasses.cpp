#
include
"
WSRunScanner
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPoint
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorRawDOMPoint
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointInText
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorRawDOMPointInText
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
;
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointType
&
aPoint
const
Element
*
aEditingHost
BlockInlineCheck
aBlockInlineCheck
)
:
mEditingHost
(
aEditingHost
)
mBlockInlineCheck
(
aBlockInlineCheck
)
{
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
aPoint
was
invalid
"
)
;
return
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
aPoint
was
in
Document
or
DocumentFragment
"
)
;
return
;
}
mScanStartPoint
=
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
;
}
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
aBlockInlineCheck
)
;
if
(
!
editableBlockElementOrInlineEditingHost
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
HTMLEditUtils
:
:
"
"
ClosestEditableBlockElementOrInlineEditingHost
)
couldn
'
t
find
"
"
editing
host
"
)
;
return
;
}
mStart
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
aBlockInlineCheck
)
;
MOZ_ASSERT_IF
(
mStart
.
IsNonCollapsibleCharacters
(
)
!
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsPreformattedLineBreak
(
)
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
mEnd
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
aBlockInlineCheck
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsNonCollapsibleCharacters
(
)
!
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsPreformattedLineBreak
(
)
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
std
:
:
min
(
aPoint
.
Offset
(
)
textFragment
.
GetLength
(
)
)
;
i
;
i
-
-
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
-
1
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
-
1
)
NoBreakingSpaceData
:
:
Scanning
:
:
Backward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
-
1
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineElement
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEditableBlockParentOrTopmostEditableInlineElement
.
IsEditable
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
aPoint
aNBSPData
aBlockInlineCheck
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
nsIContent
*
previousLeafContentOrBlock
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineElement
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aBlockInlineCheck
aEditingHost
)
;
if
(
!
previousLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineElement
)
HTMLEditUtils
:
:
IsBlockElement
(
aEditableBlockParentOrTopmostEditableInlineElement
aBlockInlineCheck
)
?
WSType
:
:
CurrentBlockBoundary
:
WSType
:
:
InlineEditingHostBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousLeafContentOrBlock
aBlockInlineCheck
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
IsText
(
)
|
|
!
previousLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
previousLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
AsText
(
)
-
>
TextLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
EditorDOMPointInText
:
:
AtEndOf
(
*
previousLeafContentOrBlock
-
>
AsText
(
)
)
aNBSPData
aBlockInlineCheck
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
aPoint
.
Offset
(
)
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
NoBreakingSpaceData
:
:
Scanning
:
:
Forward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineElement
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEditableBlockParentOrTopmostEditableInlineElement
.
IsEditable
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
aPoint
aNBSPData
aBlockInlineCheck
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
nsIContent
*
nextLeafContentOrBlock
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineElement
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aBlockInlineCheck
aEditingHost
)
;
if
(
!
nextLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineElement
)
HTMLEditUtils
:
:
IsBlockElement
(
aEditableBlockParentOrTopmostEditableInlineElement
aBlockInlineCheck
)
?
WSType
:
:
CurrentBlockBoundary
:
WSType
:
:
InlineEditingHostBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextLeafContentOrBlock
aBlockInlineCheck
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
IsText
(
)
|
|
!
nextLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
nextLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
AsText
(
)
-
>
TextFragment
(
)
.
GetLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aNBSPData
aBlockInlineCheck
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
nextLeafContentOrBlock
-
>
AsText
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
aBlockInlineCheck
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleLeadingWhiteSpaceRangeRef
(
)
const
{
if
(
mLeadingWhiteSpaceRange
.
isSome
(
)
)
{
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
&
&
!
StartsFromInlineEditingHostBoundary
(
)
)
{
mLeadingWhiteSpaceRange
.
emplace
(
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mNBSPData
.
FirstPointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleTrailingWhiteSpaceRangeRef
(
)
const
{
if
(
mTrailingWhiteSpaceRange
.
isSome
(
)
)
{
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
EndsByBlockBoundary
(
)
&
&
!
EndsByInlineEditingHostBoundary
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
GetContainer
(
)
=
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
Offset
(
)
=
=
mEnd
.
PointRef
(
)
.
Offset
(
)
-
1
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
!
mNBSPData
.
LastPointRef
(
)
.
IsEndOfContainer
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mNBSPData
.
LastPointRef
(
)
.
NextPoint
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
EditorDOMRangeInTexts
WSRunScanner
:
:
TextFragmentData
:
:
GetNonCollapsedRangeInTexts
(
const
EditorDOMRange
&
aRange
)
const
{
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
IsInTextNodes
(
)
)
{
return
aRange
.
GetAsInTexts
(
)
;
}
const
auto
firstPoint
=
aRange
.
StartRef
(
)
.
IsInTextNode
(
)
?
aRange
.
StartRef
(
)
.
AsInText
(
)
:
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aRange
.
StartRef
(
)
)
;
if
(
!
firstPoint
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
endPoint
;
if
(
aRange
.
EndRef
(
)
.
IsInTextNode
(
)
)
{
endPoint
=
aRange
.
EndRef
(
)
.
AsInText
(
)
;
}
else
{
endPoint
=
GetPreviousEditableCharPoint
(
aRange
.
EndRef
(
)
)
;
if
(
endPoint
.
IsSet
(
)
&
&
endPoint
.
IsAtLastContent
(
)
)
{
MOZ_ALWAYS_TRUE
(
endPoint
.
AdvanceOffset
(
)
)
;
}
}
if
(
!
endPoint
.
IsSet
(
)
|
|
firstPoint
=
=
endPoint
)
{
return
EditorDOMRangeInTexts
(
)
;
}
return
EditorDOMRangeInTexts
(
firstPoint
endPoint
)
;
}
const
WSRunScanner
:
:
VisibleWhiteSpacesData
&
WSRunScanner
:
:
TextFragmentData
:
:
VisibleWhiteSpacesDataRef
(
)
const
{
if
(
mVisibleWhiteSpacesData
.
isSome
(
)
)
{
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
{
const
bool
mayHaveInvisibleLeadingSpace
=
!
StartsFromNonCollapsibleCharacters
(
)
&
&
!
StartsFromSpecialContent
(
)
;
const
bool
mayHaveInvisibleTrailingWhiteSpace
=
!
EndsByNonCollapsibleCharacters
(
)
&
&
!
EndsBySpecialContent
(
)
&
&
!
EndsByBRElement
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
;
if
(
!
mayHaveInvisibleLeadingSpace
&
&
!
mayHaveInvisibleTrailingWhiteSpace
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveLeadingWhiteSpaces
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveLeadingWhiteSpaces
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveTrailingWhiteSpaces
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveTrailingWhiteSpaces
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
&
&
!
StartsFromInlineEditingHostBoundary
(
)
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
=
Some
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
|
|
StartsFromInlineEditingHostBoundary
(
)
)
;
MOZ_ASSERT
(
maybeHaveLeadingWhiteSpaces
)
;
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFromLeadingWhiteSpaces
(
)
;
if
(
!
EndsByBlockBoundary
(
)
&
&
!
EndsByInlineEditingHostBoundary
(
)
)
{
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
EndsByBlockBoundary
(
)
|
|
EndsByInlineEditingHostBoundary
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtEndOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtStartToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
aTextFragmentDataAtStartToDelete
.
ScanStartRef
(
)
;
const
EditorDOMPoint
&
endToDelete
=
mScanStartPoint
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
EndRef
(
)
.
EqualsOrIsBefore
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
endToDelete
)
;
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
endToDelete
)
;
return
ReplaceRangeData
(
invisibleTrailingWhiteSpaceRangeAtEnd
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtEnd
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtEnd
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
=
nonPreformattedVisibleWhiteSpacesAtEnd
.
ComparePoint
(
endToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
StartOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
MiddleOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtStartToDelete
.
FollowingContentMayBecomeFirstVisibleContent
(
startToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
auto
nextCharOfStartOfEnd
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
endToDelete
)
;
if
(
!
nextCharOfStartOfEnd
.
IsSet
(
)
|
|
nextCharOfStartOfEnd
.
IsEndOfContainer
(
)
|
|
!
nextCharOfStartOfEnd
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
nextCharOfStartOfEnd
.
IsStartOfContainer
(
)
|
|
nextCharOfStartOfEnd
.
IsPreviousCharCollapsibleASCIISpace
(
)
)
{
nextCharOfStartOfEnd
=
aTextFragmentDataAtStartToDelete
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
aTextFragmentDataAtStartToDelete
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
nextCharOfStartOfEnd
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtStartOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtEndToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
mScanStartPoint
;
const
EditorDOMPoint
&
endToDelete
=
aTextFragmentDataAtEndToDelete
.
ScanStartRef
(
)
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
startToDelete
.
EqualsOrIsBefore
(
StartRef
(
)
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
startToDelete
)
;
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
return
ReplaceRangeData
(
invisibleLeadingWhiteSpaceRangeAtStart
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtStart
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtStart
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
=
nonPreformattedVisibleWhiteSpacesAtStart
.
ComparePoint
(
startToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
MiddleOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
EndOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtEndToDelete
.
PrecedingContentMayBecomeInvisible
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
startToDelete
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
child
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
child
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
child
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
child
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
Set
(
leafContent
0
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsEndOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetEndReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
mBlockInlineCheck
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
nextContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
)
{
if
(
!
nextContent
-
>
IsText
(
)
|
|
!
nextContent
-
>
IsEditable
(
)
)
{
if
(
nextContent
=
=
GetEndReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
nextContent
-
>
AsText
(
)
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
previousChild
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetPreviousSiblingOfChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
previousChild
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousChild
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
previousChild
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
SetToEndOf
(
leafContent
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsStartOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
-
1
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetStartReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
mBlockInlineCheck
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mBlockInlineCheck
mEditingHost
)
)
{
if
(
!
previousContent
-
>
IsText
(
)
|
|
!
previousContent
-
>
IsEditable
(
)
)
{
if
(
previousContent
=
=
GetStartReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
previousContent
-
>
AsText
(
)
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
?
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
-
1
:
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanFollowingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtNextVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtNextVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
&
&
aAtNextVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanNextNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanFollowingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
aPoint
)
;
if
(
!
nextVisibleCharOffset
.
isSome
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atNextVisibleChar
(
aPoint
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanFollowingWhiteSpaces
(
atNextVisibleChar
)
)
{
return
atNextVisibleChar
;
}
hasSeenPreformattedNewLine
|
=
atNextVisibleChar
.
IsCharPreformattedNewLine
(
)
;
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
atNextVisibleChar
)
;
if
(
nextVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsAtLastContent
(
)
)
{
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
afterLastWhiteSpace
=
EditorDOMPointInText
:
:
AtEndOf
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
;
for
(
EditorDOMPointInText
atEndOfPreviousTextNode
=
afterLastWhiteSpace
;
;
)
{
const
auto
atStartOfNextTextNode
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atEndOfPreviousTextNode
)
;
if
(
!
atStartOfNextTextNode
.
IsSet
(
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atStartOfNextTextNode
.
IsContainerEmpty
(
)
)
{
atEndOfPreviousTextNode
=
atStartOfNextTextNode
;
continue
;
}
if
(
!
atStartOfNextTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanFollowingWhiteSpaces
(
atStartOfNextTextNode
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
atStartOfNextTextNode
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
afterLastWhiteSpace
=
atEndOfPreviousTextNode
=
EditorDOMPointInText
:
:
AtEndOf
(
*
atStartOfNextTextNode
.
ContainerAs
<
Text
>
(
)
)
;
}
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanPrecedingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtPreviousVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtPreviousVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
&
&
aAtPreviousVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanPreviousNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanPrecedingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
aPoint
)
;
if
(
previousVisibleCharOffset
.
isNothing
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atPreviousVisibleCharacter
(
aPoint
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanPrecedingWhiteSpaces
(
atPreviousVisibleCharacter
)
)
{
return
atPreviousVisibleCharacter
.
NextPoint
(
)
;
}
hasSeenPreformattedNewLine
|
=
atPreviousVisibleCharacter
.
IsCharPreformattedNewLine
(
)
;
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
atPreviousVisibleCharacter
)
;
if
(
previousVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
+
1
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsStartOfContainer
(
)
)
{
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
atLastWhiteSpace
=
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
0u
)
;
for
(
EditorDOMPointInText
atStartOfPreviousTextNode
=
atLastWhiteSpace
;
;
)
{
const
EditorDOMPointInText
atLastCharOfPreviousTextNode
=
GetPreviousEditableCharPoint
(
atStartOfPreviousTextNode
)
;
if
(
!
atLastCharOfPreviousTextNode
.
IsSet
(
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atLastCharOfPreviousTextNode
.
IsContainerEmpty
(
)
)
{
atStartOfPreviousTextNode
=
atLastCharOfPreviousTextNode
;
continue
;
}
if
(
!
atLastCharOfPreviousTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanPrecedingWhiteSpaces
(
atLastCharOfPreviousTextNode
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
atLastCharOfPreviousTextNode
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
atLastWhiteSpace
=
atStartOfPreviousTextNode
=
EditorDOMPointInText
(
atLastCharOfPreviousTextNode
.
ContainerAs
<
Text
>
(
)
0u
)
;
}
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
EndOfFragment
"
Previous
char
of
aPoint
should
be
in
the
visible
white
-
spaces
"
)
;
const
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
aPointToInsert
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
|
|
atPreviousChar
.
IsEndOfContainer
(
)
|
|
!
atPreviousChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
EditorDOMPointInText
atPreviousCharOfPreviousChar
=
GetPreviousEditableCharPoint
(
atPreviousChar
)
;
if
(
atPreviousCharOfPreviousChar
.
IsSet
(
)
)
{
if
(
atPreviousChar
.
ContainerAs
<
Text
>
(
)
!
=
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atPreviousCharOfPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousChar
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
StartsFromNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
StartsFromSpecialContent
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
StartOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
"
Inclusive
next
char
of
aPointToInsert
should
be
in
the
visible
"
"
white
-
spaces
"
)
;
auto
atNextChar
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPointToInsert
)
;
if
(
!
atNextChar
.
IsSet
(
)
|
|
NS_WARN_IF
(
atNextChar
.
IsEndOfContainer
(
)
)
|
|
!
atNextChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
auto
atNextCharOfNextCharOfNBSP
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atNextChar
.
NextPoint
<
EditorRawDOMPointInText
>
(
)
)
;
if
(
atNextCharOfNextCharOfNBSP
.
IsSet
(
)
)
{
if
(
atNextChar
.
ContainerAs
<
Text
>
(
)
!
=
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atNextCharOfNextCharOfNBSP
.
IsEndOfContainer
(
)
&
&
atNextCharOfNextCharOfNBSP
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
EndsByNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
EndsBySpecialContent
(
)
&
&
!
visibleWhiteSpaces
.
EndsByBRElement
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
}
