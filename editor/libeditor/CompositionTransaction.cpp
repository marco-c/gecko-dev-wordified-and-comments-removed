#
include
"
CompositionTransaction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
using
namespace
dom
;
CompositionTransaction
:
:
CompositionTransaction
(
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aReplaceLength
TextRangeArray
*
aTextRangeArray
const
nsAString
&
aStringToInsert
EditorBase
&
aEditorBase
)
:
mTextNode
(
&
aTextNode
)
mOffset
(
aOffset
)
mReplaceLength
(
aReplaceLength
)
mRanges
(
aTextRangeArray
)
mStringToInsert
(
aStringToInsert
)
mEditorBase
(
aEditorBase
)
mFixed
(
false
)
{
}
CompositionTransaction
:
:
~
CompositionTransaction
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
CompositionTransaction
EditTransactionBase
mTextNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CompositionTransaction
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
CompositionTransaction
)
)
)
{
foundInterface
=
static_cast
<
nsITransaction
*
>
(
this
)
;
}
else
NS_INTERFACE_MAP_END_INHERITING
(
EditTransactionBase
)
NS_IMPL_ADDREF_INHERITED
(
CompositionTransaction
EditTransactionBase
)
NS_IMPL_RELEASE_INHERITED
(
CompositionTransaction
EditTransactionBase
)
NS_IMETHODIMP
CompositionTransaction
:
:
DoTransaction
(
)
{
nsCOMPtr
<
nsISelectionController
>
selCon
;
mEditorBase
.
GetSelectionController
(
getter_AddRefs
(
selCon
)
)
;
NS_ENSURE_TRUE
(
selCon
NS_ERROR_NOT_INITIALIZED
)
;
if
(
mReplaceLength
=
=
0
)
{
nsresult
rv
=
mTextNode
-
>
InsertData
(
mOffset
mStringToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
mTextNode
-
>
ReplaceData
(
mOffset
mReplaceLength
mStringToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
SetSelectionForRanges
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
UndoTransaction
(
)
{
RefPtr
<
Selection
>
selection
=
mEditorBase
.
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
mTextNode
-
>
DeleteData
(
mOffset
mStringToInsert
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
selection
-
>
Collapse
(
mTextNode
mOffset
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
could
not
be
collapsed
after
undo
of
IME
insert
.
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
Merge
(
nsITransaction
*
aTransaction
bool
*
aDidMerge
)
{
NS_ENSURE_ARG_POINTER
(
aTransaction
&
&
aDidMerge
)
;
if
(
mFixed
)
{
*
aDidMerge
=
false
;
return
NS_OK
;
}
RefPtr
<
CompositionTransaction
>
otherTransaction
=
do_QueryObject
(
aTransaction
)
;
if
(
otherTransaction
)
{
mStringToInsert
=
otherTransaction
-
>
mStringToInsert
;
mRanges
=
otherTransaction
-
>
mRanges
;
*
aDidMerge
=
true
;
return
NS_OK
;
}
*
aDidMerge
=
false
;
return
NS_OK
;
}
void
CompositionTransaction
:
:
MarkFixed
(
)
{
mFixed
=
true
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
GetTxnDescription
(
nsAString
&
aString
)
{
aString
.
AssignLiteral
(
"
CompositionTransaction
:
"
)
;
aString
+
=
mStringToInsert
;
return
NS_OK
;
}
nsresult
CompositionTransaction
:
:
SetSelectionForRanges
(
)
{
return
SetIMESelection
(
mEditorBase
mTextNode
mOffset
mStringToInsert
.
Length
(
)
mRanges
)
;
}
nsresult
CompositionTransaction
:
:
SetIMESelection
(
EditorBase
&
aEditorBase
Text
*
aTextNode
uint32_t
aOffsetInNode
uint32_t
aLengthOfCompositionString
const
TextRangeArray
*
aRanges
)
{
RefPtr
<
Selection
>
selection
=
aEditorBase
.
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
selection
-
>
StartBatchChanges
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
static
const
RawSelectionType
kIMESelections
[
]
=
{
nsISelectionController
:
:
SELECTION_IME_RAWINPUT
nsISelectionController
:
:
SELECTION_IME_SELECTEDRAWTEXT
nsISelectionController
:
:
SELECTION_IME_CONVERTEDTEXT
nsISelectionController
:
:
SELECTION_IME_SELECTEDCONVERTEDTEXT
}
;
nsCOMPtr
<
nsISelectionController
>
selCon
;
aEditorBase
.
GetSelectionController
(
getter_AddRefs
(
selCon
)
)
;
NS_ENSURE_TRUE
(
selCon
NS_ERROR_NOT_INITIALIZED
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kIMESelections
)
;
+
+
i
)
{
nsCOMPtr
<
nsISelection
>
selectionOfIME
;
if
(
NS_FAILED
(
selCon
-
>
GetSelection
(
kIMESelections
[
i
]
getter_AddRefs
(
selectionOfIME
)
)
)
)
{
continue
;
}
rv
=
selectionOfIME
-
>
RemoveAllRanges
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
all
ranges
of
IME
selection
"
)
;
}
bool
setCaret
=
false
;
uint32_t
countOfRanges
=
aRanges
?
aRanges
-
>
Length
(
)
:
0
;
#
ifdef
DEBUG
uint32_t
maxOffset
=
aTextNode
-
>
Length
(
)
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
countOfRanges
;
+
+
i
)
{
const
TextRange
&
textRange
=
aRanges
-
>
ElementAt
(
i
)
;
if
(
textRange
.
mRangeType
=
=
TextRangeType
:
:
eCaret
)
{
NS_ASSERTION
(
!
setCaret
"
The
ranges
already
has
caret
position
"
)
;
NS_ASSERTION
(
!
textRange
.
Length
(
)
"
EditorBase
doesn
'
t
support
wide
caret
"
)
;
int32_t
caretOffset
=
static_cast
<
int32_t
>
(
aOffsetInNode
+
std
:
:
min
(
textRange
.
mStartOffset
aLengthOfCompositionString
)
)
;
MOZ_ASSERT
(
caretOffset
>
=
0
&
&
static_cast
<
uint32_t
>
(
caretOffset
)
<
=
maxOffset
)
;
rv
=
selection
-
>
Collapse
(
aTextNode
caretOffset
)
;
setCaret
=
setCaret
|
|
NS_SUCCEEDED
(
rv
)
;
if
(
NS_WARN_IF
(
!
setCaret
)
)
{
continue
;
}
aEditorBase
.
HideCaret
(
false
)
;
continue
;
}
if
(
!
textRange
.
Length
(
)
)
{
NS_WARNING
(
"
Any
clauses
must
not
be
empty
"
)
;
continue
;
}
RefPtr
<
nsRange
>
clauseRange
;
int32_t
startOffset
=
static_cast
<
int32_t
>
(
aOffsetInNode
+
std
:
:
min
(
textRange
.
mStartOffset
aLengthOfCompositionString
)
)
;
MOZ_ASSERT
(
startOffset
>
=
0
&
&
static_cast
<
uint32_t
>
(
startOffset
)
<
=
maxOffset
)
;
int32_t
endOffset
=
static_cast
<
int32_t
>
(
aOffsetInNode
+
std
:
:
min
(
textRange
.
mEndOffset
aLengthOfCompositionString
)
)
;
MOZ_ASSERT
(
endOffset
>
=
startOffset
&
&
static_cast
<
uint32_t
>
(
endOffset
)
<
=
maxOffset
)
;
rv
=
nsRange
:
:
CreateRange
(
aTextNode
startOffset
aTextNode
endOffset
getter_AddRefs
(
clauseRange
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
a
DOM
range
for
a
clause
of
composition
"
)
;
break
;
}
nsCOMPtr
<
nsISelection
>
selectionOfIME
;
rv
=
selCon
-
>
GetSelection
(
ToRawSelectionType
(
textRange
.
mRangeType
)
getter_AddRefs
(
selectionOfIME
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
IME
selection
"
)
;
break
;
}
rv
=
selectionOfIME
-
>
AddRange
(
clauseRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
add
selection
range
for
a
clause
of
composition
"
)
;
break
;
}
nsCOMPtr
<
nsISelectionPrivate
>
selectionOfIMEPriv
=
do_QueryInterface
(
selectionOfIME
)
;
if
(
!
selectionOfIMEPriv
)
{
NS_WARNING
(
"
Failed
to
get
nsISelectionPrivate
interface
from
selection
"
)
;
continue
;
}
rv
=
selectionOfIMEPriv
-
>
SetTextRangeStyle
(
clauseRange
textRange
.
mRangeStyle
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
selection
style
"
)
;
break
;
}
}
if
(
!
setCaret
)
{
int32_t
caretOffset
=
static_cast
<
int32_t
>
(
aOffsetInNode
+
aLengthOfCompositionString
)
;
MOZ_ASSERT
(
caretOffset
>
=
0
&
&
static_cast
<
uint32_t
>
(
caretOffset
)
<
=
maxOffset
)
;
rv
=
selection
-
>
Collapse
(
aTextNode
caretOffset
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
caret
at
the
end
of
composition
string
"
)
;
if
(
countOfRanges
)
{
aEditorBase
.
HideCaret
(
true
)
;
}
}
rv
=
selection
-
>
EndBatchChangesInternal
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
end
batch
changes
"
)
;
return
rv
;
}
}
