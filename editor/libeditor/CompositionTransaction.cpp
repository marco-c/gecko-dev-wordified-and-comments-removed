#
include
"
CompositionTransaction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
using
namespace
dom
;
already_AddRefed
<
CompositionTransaction
>
CompositionTransaction
:
:
Create
(
EditorBase
&
aEditorBase
const
nsAString
&
aStringToInsert
const
EditorDOMPointInText
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
TextComposition
*
composition
=
aEditorBase
.
GetComposition
(
)
;
MOZ_RELEASE_ASSERT
(
composition
)
;
EditorDOMPointInText
pointToInsert
;
if
(
Text
*
textNode
=
composition
-
>
GetContainerTextNode
(
)
)
{
pointToInsert
.
Set
(
textNode
composition
-
>
XPOffsetInTextNode
(
)
)
;
NS_WARNING_ASSERTION
(
pointToInsert
.
GetContainerAs
<
Text
>
(
)
=
=
composition
-
>
GetContainerTextNode
(
)
"
The
editor
tries
to
insert
composition
string
into
different
node
"
)
;
NS_WARNING_ASSERTION
(
pointToInsert
.
Offset
(
)
=
=
composition
-
>
XPOffsetInTextNode
(
)
"
The
editor
tries
to
insert
composition
string
into
different
offset
"
)
;
}
else
{
pointToInsert
=
aPointToInsert
;
}
RefPtr
<
CompositionTransaction
>
transaction
=
new
CompositionTransaction
(
aEditorBase
aStringToInsert
pointToInsert
)
;
return
transaction
.
forget
(
)
;
}
CompositionTransaction
:
:
CompositionTransaction
(
EditorBase
&
aEditorBase
const
nsAString
&
aStringToInsert
const
EditorDOMPointInText
&
aPointToInsert
)
:
mTextNode
(
aPointToInsert
.
ContainerAsText
(
)
)
mOffset
(
aPointToInsert
.
Offset
(
)
)
mReplaceLength
(
aEditorBase
.
GetComposition
(
)
-
>
XPLengthInTextNode
(
)
)
mRanges
(
aEditorBase
.
GetComposition
(
)
-
>
GetRanges
(
)
)
mStringToInsert
(
aStringToInsert
)
mEditorBase
(
&
aEditorBase
)
mFixed
(
false
)
{
MOZ_ASSERT
(
mTextNode
-
>
TextLength
(
)
>
=
mOffset
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
CompositionTransaction
&
aTransaction
)
{
aStream
<
<
"
{
mTextNode
=
"
<
<
aTransaction
.
mTextNode
.
get
(
)
;
if
(
aTransaction
.
mTextNode
)
{
aStream
<
<
"
(
"
<
<
*
aTransaction
.
mTextNode
<
<
"
)
"
;
}
aStream
<
<
"
mOffset
=
"
<
<
aTransaction
.
mOffset
<
<
"
mReplaceLength
=
"
<
<
aTransaction
.
mReplaceLength
<
<
"
mRanges
=
{
Length
(
)
=
"
<
<
aTransaction
.
mRanges
-
>
Length
(
)
<
<
"
}
"
<
<
"
mStringToInsert
=
\
"
"
<
<
NS_ConvertUTF16toUTF8
(
aTransaction
.
mStringToInsert
)
.
get
(
)
<
<
"
\
"
"
<
<
"
mEditorBase
=
"
<
<
aTransaction
.
mEditorBase
.
get
(
)
<
<
"
}
"
;
return
aStream
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
CompositionTransaction
EditTransactionBase
mEditorBase
mTextNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CompositionTransaction
)
NS_INTERFACE_MAP_END_INHERITING
(
EditTransactionBase
)
NS_IMPL_ADDREF_INHERITED
(
CompositionTransaction
EditTransactionBase
)
NS_IMPL_RELEASE_INHERITED
(
CompositionTransaction
EditTransactionBase
)
NS_IMETHODIMP
CompositionTransaction
:
:
DoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CompositionTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mTextNode
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
NS_WARN_IF
(
!
mEditorBase
-
>
GetSelectionController
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
OwningNonNull
<
Text
>
textNode
=
*
mTextNode
;
if
(
mReplaceLength
=
=
0
)
{
ErrorResult
error
;
editorBase
-
>
DoInsertText
(
textNode
mOffset
mStringToInsert
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoInsertText
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjInsertText
(
textNode
mOffset
mStringToInsert
.
Length
(
)
)
;
}
else
{
uint32_t
replaceableLength
=
textNode
-
>
TextLength
(
)
-
mOffset
;
ErrorResult
error
;
editorBase
-
>
DoReplaceText
(
textNode
mOffset
mReplaceLength
mStringToInsert
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoReplaceText
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjDeleteText
(
textNode
mOffset
replaceableLength
)
;
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjInsertText
(
textNode
mOffset
mStringToInsert
.
Length
(
)
)
;
if
(
replaceableLength
<
mReplaceLength
)
{
uint32_t
remainLength
=
mReplaceLength
-
replaceableLength
;
IgnoredErrorResult
ignoredError
;
for
(
nsIContent
*
nextSibling
=
textNode
-
>
GetNextSibling
(
)
;
nextSibling
&
&
nextSibling
-
>
IsText
(
)
&
&
remainLength
;
nextSibling
=
nextSibling
-
>
GetNextSibling
(
)
)
{
OwningNonNull
<
Text
>
followingTextNode
=
*
static_cast
<
Text
*
>
(
nextSibling
)
;
uint32_t
textLength
=
followingTextNode
-
>
TextLength
(
)
;
editorBase
-
>
DoDeleteText
(
followingTextNode
0
remainLength
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoDeleteText
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
editorBase
-
>
RangeUpdaterRef
(
)
.
SelAdjDeleteText
(
followingTextNode
0
remainLength
)
;
remainLength
-
=
textLength
;
}
}
}
nsresult
rv
=
SetSelectionForRanges
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CompositionTransaction
:
:
SetSelectionForRanges
(
)
failed
"
)
;
if
(
TextComposition
*
composition
=
editorBase
-
>
GetComposition
(
)
)
{
composition
-
>
OnUpdateCompositionInEditor
(
mStringToInsert
textNode
mOffset
)
;
}
return
rv
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
UndoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CompositionTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mTextNode
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
OwningNonNull
<
Text
>
textNode
=
*
mTextNode
;
IgnoredErrorResult
error
;
editorBase
-
>
DoDeleteText
(
textNode
mOffset
mStringToInsert
.
Length
(
)
error
)
;
if
(
MOZ_UNLIKELY
(
error
.
Failed
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoDeleteText
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
editorBase
-
>
CollapseSelectionTo
(
EditorRawDOMPoint
(
textNode
mOffset
)
error
)
;
NS_ASSERTION
(
!
error
.
Failed
(
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
RedoTransaction
(
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Info
(
"
%
p
CompositionTransaction
:
:
%
s
this
=
%
s
"
this
__FUNCTION__
ToString
(
*
this
)
.
c_str
(
)
)
)
;
return
DoTransaction
(
)
;
}
NS_IMETHODIMP
CompositionTransaction
:
:
Merge
(
nsITransaction
*
aOtherTransaction
bool
*
aDidMerge
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Debug
(
"
%
p
CompositionTransaction
:
:
%
s
(
aOtherTransaction
=
%
p
)
this
=
%
s
"
this
__FUNCTION__
aOtherTransaction
ToString
(
*
this
)
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
!
aOtherTransaction
)
|
|
NS_WARN_IF
(
!
aDidMerge
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aDidMerge
=
false
;
if
(
mFixed
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Debug
(
"
%
p
CompositionTransaction
:
:
%
s
returned
false
due
to
fixed
"
this
__FUNCTION__
)
)
;
return
NS_OK
;
}
RefPtr
<
EditTransactionBase
>
otherTransactionBase
=
aOtherTransaction
-
>
GetAsEditTransactionBase
(
)
;
if
(
!
otherTransactionBase
)
{
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Debug
(
"
%
p
CompositionTransaction
:
:
%
s
returned
false
due
to
not
edit
"
"
transaction
"
this
__FUNCTION__
)
)
;
return
NS_OK
;
}
CompositionTransaction
*
otherCompositionTransaction
=
otherTransactionBase
-
>
GetAsCompositionTransaction
(
)
;
if
(
!
otherCompositionTransaction
)
{
return
NS_OK
;
}
mStringToInsert
=
otherCompositionTransaction
-
>
mStringToInsert
;
mRanges
=
otherCompositionTransaction
-
>
mRanges
;
*
aDidMerge
=
true
;
MOZ_LOG
(
GetLogModule
(
)
LogLevel
:
:
Debug
(
"
%
p
CompositionTransaction
:
:
%
s
returned
true
"
this
__FUNCTION__
)
)
;
return
NS_OK
;
}
void
CompositionTransaction
:
:
MarkFixed
(
)
{
mFixed
=
true
;
}
nsresult
CompositionTransaction
:
:
SetSelectionForRanges
(
)
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
|
|
NS_WARN_IF
(
!
mTextNode
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
OwningNonNull
<
EditorBase
>
editorBase
=
*
mEditorBase
;
OwningNonNull
<
Text
>
textNode
=
*
mTextNode
;
RefPtr
<
TextRangeArray
>
ranges
=
mRanges
;
nsresult
rv
=
SetIMESelection
(
editorBase
textNode
mOffset
mStringToInsert
.
Length
(
)
ranges
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CompositionTransaction
:
:
SetIMESelection
(
)
failed
"
)
;
return
rv
;
}
nsresult
CompositionTransaction
:
:
SetIMESelection
(
EditorBase
&
aEditorBase
Text
*
aTextNode
uint32_t
aOffsetInNode
uint32_t
aLengthOfCompositionString
const
TextRangeArray
*
aRanges
)
{
RefPtr
<
Selection
>
selection
=
aEditorBase
.
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
SelectionBatcher
selectionBatcher
(
selection
__FUNCTION__
)
;
static
const
RawSelectionType
kIMESelections
[
]
=
{
nsISelectionController
:
:
SELECTION_IME_RAWINPUT
nsISelectionController
:
:
SELECTION_IME_SELECTEDRAWTEXT
nsISelectionController
:
:
SELECTION_IME_CONVERTEDTEXT
nsISelectionController
:
:
SELECTION_IME_SELECTEDCONVERTEDTEXT
}
;
nsCOMPtr
<
nsISelectionController
>
selectionController
=
aEditorBase
.
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
IgnoredErrorResult
ignoredError
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kIMESelections
)
;
+
+
i
)
{
RefPtr
<
Selection
>
selectionOfIME
=
selectionController
-
>
GetSelection
(
kIMESelections
[
i
]
)
;
if
(
!
selectionOfIME
)
{
NS_WARNING
(
"
nsISelectionController
:
:
GetSelection
(
)
failed
"
)
;
continue
;
}
selectionOfIME
-
>
RemoveAllRanges
(
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
RemoveAllRanges
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
}
bool
setCaret
=
false
;
uint32_t
countOfRanges
=
aRanges
?
aRanges
-
>
Length
(
)
:
0
;
#
ifdef
DEBUG
uint32_t
maxOffset
=
aTextNode
-
>
Length
(
)
;
#
endif
nsresult
rv
=
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
countOfRanges
;
+
+
i
)
{
const
TextRange
&
textRange
=
aRanges
-
>
ElementAt
(
i
)
;
if
(
textRange
.
mRangeType
=
=
TextRangeType
:
:
eCaret
)
{
NS_ASSERTION
(
!
setCaret
"
The
ranges
already
has
caret
position
"
)
;
NS_ASSERTION
(
!
textRange
.
Length
(
)
"
EditorBase
doesn
'
t
support
wide
caret
"
)
;
CheckedUint32
caretOffset
(
aOffsetInNode
)
;
caretOffset
+
=
std
:
:
min
(
textRange
.
mStartOffset
aLengthOfCompositionString
)
;
MOZ_ASSERT
(
caretOffset
.
isValid
(
)
)
;
MOZ_ASSERT
(
caretOffset
.
value
(
)
<
=
maxOffset
)
;
rv
=
selection
-
>
CollapseInLimiter
(
aTextNode
caretOffset
.
value
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
CollapseInLimiter
(
)
failed
but
might
be
ignored
"
)
;
setCaret
=
setCaret
|
|
NS_SUCCEEDED
(
rv
)
;
if
(
!
setCaret
)
{
continue
;
}
aEditorBase
.
HideCaret
(
false
)
;
continue
;
}
if
(
!
textRange
.
Length
(
)
)
{
NS_WARNING
(
"
Any
clauses
must
not
be
empty
"
)
;
continue
;
}
RefPtr
<
nsRange
>
clauseRange
;
CheckedUint32
startOffset
=
aOffsetInNode
;
startOffset
+
=
std
:
:
min
(
textRange
.
mStartOffset
aLengthOfCompositionString
)
;
MOZ_ASSERT
(
startOffset
.
isValid
(
)
)
;
MOZ_ASSERT
(
startOffset
.
value
(
)
<
=
maxOffset
)
;
CheckedUint32
endOffset
=
aOffsetInNode
;
endOffset
+
=
std
:
:
min
(
textRange
.
mEndOffset
aLengthOfCompositionString
)
;
MOZ_ASSERT
(
endOffset
.
isValid
(
)
)
;
MOZ_ASSERT
(
endOffset
.
value
(
)
>
=
startOffset
.
value
(
)
)
;
MOZ_ASSERT
(
endOffset
.
value
(
)
<
=
maxOffset
)
;
clauseRange
=
nsRange
:
:
Create
(
aTextNode
startOffset
.
value
(
)
aTextNode
endOffset
.
value
(
)
IgnoreErrors
(
)
)
;
if
(
!
clauseRange
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
but
might
be
ignored
"
)
;
break
;
}
RefPtr
<
Selection
>
selectionOfIME
=
selectionController
-
>
GetSelection
(
ToRawSelectionType
(
textRange
.
mRangeType
)
)
;
if
(
!
selectionOfIME
)
{
NS_WARNING
(
"
nsISelectionController
:
:
GetSelection
(
)
failed
but
might
be
"
"
ignored
"
)
;
break
;
}
IgnoredErrorResult
ignoredError
;
selectionOfIME
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
clauseRange
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
but
"
"
might
be
ignored
"
)
;
break
;
}
rv
=
selectionOfIME
-
>
SetTextRangeStyle
(
clauseRange
textRange
.
mRangeStyle
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Selection
:
:
SetTextRangeStyle
(
)
failed
but
might
be
ignored
"
)
;
break
;
}
}
if
(
!
setCaret
)
{
CheckedUint32
caretOffset
=
aOffsetInNode
;
caretOffset
+
=
aLengthOfCompositionString
;
MOZ_ASSERT
(
caretOffset
.
isValid
(
)
)
;
MOZ_ASSERT
(
caretOffset
.
value
(
)
<
=
maxOffset
)
;
rv
=
selection
-
>
CollapseInLimiter
(
aTextNode
caretOffset
.
value
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Selection
:
:
CollapseInLimiter
(
)
failed
"
)
;
if
(
countOfRanges
)
{
aEditorBase
.
HideCaret
(
true
)
;
}
}
return
rv
;
}
}
