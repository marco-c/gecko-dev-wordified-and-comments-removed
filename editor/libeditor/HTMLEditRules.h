#
ifndef
HTMLEditRules_h
#
define
HTMLEditRules_h
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
mozilla
/
TypeInState
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsAtom
;
class
nsINode
;
class
nsRange
;
namespace
mozilla
{
class
EditActionResult
;
class
HTMLEditor
;
class
SplitNodeResult
;
class
TextEditor
;
enum
class
EditSubAction
:
int32_t
;
namespace
dom
{
class
Document
;
class
Element
;
class
Selection
;
}
class
HTMLEditRules
:
public
TextEditRules
{
public
:
HTMLEditRules
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
Init
(
TextEditor
*
aTextEditor
)
override
;
virtual
nsresult
DetachEditor
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
BeforeEdit
(
)
override
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
AfterEdit
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
WillDoAction
(
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
DidDoAction
(
EditSubActionInfo
&
aInfo
nsresult
aResult
)
override
;
virtual
bool
DocumentIsEmpty
(
)
const
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
DocumentModified
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MakeSureElemStartsAndEndsOnCR
(
nsINode
&
aNode
)
;
void
DidCreateNode
(
Element
&
aNewElement
)
;
void
DidInsertNode
(
nsIContent
&
aNode
)
;
void
WillDeleteNode
(
nsINode
&
aChild
)
;
void
DidSplitNode
(
nsINode
&
aExistingRightNode
nsINode
&
aNewLeftNode
)
;
void
WillJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
void
DidJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
void
DidInsertText
(
nsINode
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
;
void
DidDeleteText
(
nsINode
&
aTextNode
int32_t
aOffset
int32_t
aLength
)
;
void
WillDeleteSelection
(
)
;
protected
:
virtual
~
HTMLEditRules
(
)
=
default
;
HTMLEditor
&
HTMLEditorRef
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
mData
-
>
HTMLEditorRef
(
)
;
}
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DidDeleteSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillRemoveList
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillIndent
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillCSSIndent
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillHTMLIndent
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillOutdent
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
WillAlign
(
const
nsAString
&
aAlignType
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillRemoveAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillRelativeChangeZIndex
(
int32_t
aChange
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillAbsolutePosition
(
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
PrepareToMakeElementAbsolutePosition
(
bool
*
aHandled
RefPtr
<
Element
>
*
aTargetElement
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DidAbsolutePosition
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignInnerBlocks
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignBlockContents
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignContentsAtSelection
(
const
nsAString
&
aAlignType
)
;
nsresult
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
;
nsresult
GetFormatString
(
nsINode
*
aNode
nsAString
&
outFormat
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AfterEditInner
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
IndentAroundSelectionWithCSS
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
IndentAroundSelectionWithHTML
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
OutdentAroundSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
SplitRangeOffFromNodeResult
OutdentPartOfBlock
(
Element
&
aBlockElement
nsIContent
&
aStartOfOutdent
nsIContent
&
aEndOutdent
bool
aIsBlockIndentedWithCSS
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
;
void
MakeTransitionList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
InsertBRElementToEmptyListItemsAndTableCellsInRange
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
MOZ_MUST_USE
nsresult
PinSelectionToNewBlock
(
)
;
void
CheckInterlinePosition
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AdjustSelection
(
nsIEditor
:
:
EDirection
aAction
)
;
template
<
typename
PT
typename
CT
>
nsIContent
*
FindNearEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
RemoveEmptyNodesInChangedRange
(
)
;
nsresult
SelectionEndpointInNode
(
nsINode
*
aNode
bool
*
aResult
)
;
MOZ_MUST_USE
nsresult
ConfirmSelectionInBody
(
)
;
bool
IsEmptyInline
(
nsINode
&
aNode
)
;
bool
ListIsEmptyLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
RemoveAlignment
(
nsINode
&
aNode
const
nsAString
&
aAlignType
bool
aDescendantsOnly
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
bool
aStarts
)
;
enum
class
ResetAlignOf
{
ElementAndDescendants
OnlyDescendants
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
AlignBlock
(
Element
&
aElement
const
nsAString
&
aAlignType
ResetAlignOf
aResetAlignOf
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
IncreaseMarginToIndent
(
Element
&
aElement
)
{
return
ChangeMarginStart
(
aElement
true
)
;
}
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
DecreaseMarginToOutdent
(
Element
&
aElement
)
{
return
ChangeMarginStart
(
aElement
false
)
;
}
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
ChangeMarginStart
(
Element
&
aElement
bool
aIncrease
)
;
MOZ_CAN_RUN_SCRIPT
void
DocumentModifiedWorker
(
)
;
protected
:
HTMLEditor
*
mHTMLEditor
;
bool
mInitialized
;
}
;
}
#
endif
