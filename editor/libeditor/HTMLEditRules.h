#
ifndef
HTMLEditRules_h
#
define
HTMLEditRules_h
#
include
"
TypeInState
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
class
nsAtom
;
class
nsIEditor
;
class
nsINode
;
class
nsRange
;
namespace
mozilla
{
class
EditActionResult
;
class
HTMLEditor
;
class
RulesInfo
;
class
SplitNodeResult
;
class
TextEditor
;
enum
class
EditAction
:
int32_t
;
namespace
dom
{
class
Element
;
class
Selection
;
}
struct
StyleCache
final
:
public
PropItem
{
bool
mPresent
;
StyleCache
(
)
:
PropItem
(
)
mPresent
(
false
)
{
MOZ_COUNT_CTOR
(
StyleCache
)
;
}
StyleCache
(
nsAtom
*
aTag
nsAtom
*
aAttr
const
nsAString
&
aValue
)
:
PropItem
(
aTag
aAttr
aValue
)
mPresent
(
false
)
{
MOZ_COUNT_CTOR
(
StyleCache
)
;
}
StyleCache
(
nsAtom
*
aTag
nsAtom
*
aAttr
)
:
PropItem
(
aTag
aAttr
EmptyString
(
)
)
mPresent
(
false
)
{
MOZ_COUNT_CTOR
(
StyleCache
)
;
}
~
StyleCache
(
)
{
MOZ_COUNT_DTOR
(
StyleCache
)
;
}
}
;
#
define
SIZE_STYLE_TABLE
19
class
HTMLEditRules
:
public
TextEditRules
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLEditRules
TextEditRules
)
HTMLEditRules
(
)
;
virtual
nsresult
Init
(
TextEditor
*
aTextEditor
)
override
;
virtual
nsresult
DetachEditor
(
)
override
;
virtual
nsresult
BeforeEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
override
;
virtual
nsresult
AfterEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
override
;
virtual
nsresult
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
override
;
virtual
nsresult
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
override
;
virtual
bool
DocumentIsEmpty
(
)
override
;
virtual
nsresult
DocumentModified
(
)
override
;
nsresult
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
;
nsresult
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
;
nsresult
GetIndentState
(
bool
*
aCanIndent
bool
*
aCanOutdent
)
;
nsresult
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
;
nsresult
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
;
nsresult
MakeSureElemStartsAndEndsOnCR
(
nsINode
&
aNode
)
;
void
DidCreateNode
(
Selection
&
aSelection
Element
&
aNewElement
)
;
void
DidInsertNode
(
Selection
&
aSelection
nsIContent
&
aNode
)
;
void
WillDeleteNode
(
Selection
&
aSelection
nsINode
&
aChild
)
;
void
DidSplitNode
(
Selection
&
aSelection
nsINode
&
aExistingRightNode
nsINode
&
aNewLeftNode
)
;
void
WillJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
void
DidJoinNodes
(
Selection
&
aSelection
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
;
void
DidInsertText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
;
void
DidDeleteText
(
Selection
&
aSelection
nsINode
&
aTextNode
int32_t
aOffset
int32_t
aLength
)
;
void
WillDeleteSelection
(
Selection
&
aSelection
)
;
void
StartToListenToEditActions
(
)
{
mListenerEnabled
=
true
;
}
void
EndListeningToEditActions
(
)
{
mListenerEnabled
=
false
;
}
protected
:
virtual
~
HTMLEditRules
(
)
;
HTMLEditor
&
HTMLEditorRef
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
mData
-
>
HTMLEditorRef
(
)
;
}
enum
RulesEndpoint
{
kStart
kEnd
}
;
void
InitFields
(
)
;
void
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
;
nsresult
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
;
nsresult
WillLoadHTML
(
Selection
*
aSelection
bool
*
aCancel
)
;
nsresult
WillInsertBreak
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
void
DeleteNodeIfCollapsedText
(
nsINode
&
aNode
)
;
nsresult
InsertBRElement
(
Selection
&
aSelection
const
EditorDOMPoint
&
aInsertToBreak
)
;
nsresult
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
SplitMailCites
(
Selection
*
aSelection
bool
*
aHandled
)
;
nsresult
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
nsIEditor
:
:
EStripWrappers
aStripWrappers
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aDir
nsresult
aResult
)
;
nsresult
InsertBRIfNeeded
(
Selection
*
aSelection
)
;
bool
CanContainParagraph
(
Element
&
aElement
)
const
;
nsresult
InsertBRIfNeededInternal
(
nsINode
&
aNode
bool
aInsertMozBR
)
;
EditorDOMPoint
GetGoodSelPointForNode
(
nsINode
&
aNode
nsIEditor
:
:
EDirection
aAction
)
;
EditActionResult
TryToJoinBlocksWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
;
EditActionResult
MoveBlock
(
Element
&
aLeftBlock
Element
&
aRightBlock
int32_t
aLeftOffset
int32_t
aRightOffset
)
;
EditActionResult
MoveNodeSmart
(
nsIContent
&
aNode
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
;
EditActionResult
MoveContents
(
Element
&
aElement
Element
&
aDestElement
int32_t
*
aInOutDestOffset
)
;
nsresult
DeleteNonTableElements
(
nsINode
*
aNode
)
;
nsresult
WillMakeList
(
Selection
*
aSelection
const
nsAString
*
aListType
bool
aEntireList
const
nsAString
*
aBulletType
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
aItemType
=
nullptr
)
;
nsresult
WillRemoveList
(
Selection
*
aSelection
bool
aOrdered
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillCSSIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillHTMLIndent
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillOutdent
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillAlign
(
Selection
&
aSelection
const
nsAString
&
aAlignType
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillAbsolutePosition
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillRemoveAbsolutePosition
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillRelativeChangeZIndex
(
Selection
*
aSelection
int32_t
aChange
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillMakeDefListItem
(
Selection
*
aSelection
const
nsAString
*
aBlockType
bool
aEntireList
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillMakeBasicBlock
(
Selection
&
aSelection
const
nsAString
&
aBlockType
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
MakeBasicBlock
(
Selection
&
aSelection
nsAtom
&
aBlockType
)
;
nsresult
DidMakeBasicBlock
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
;
nsresult
DidAbsolutePosition
(
)
;
nsresult
AlignInnerBlocks
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
;
nsresult
AlignBlockContents
(
nsINode
&
aNode
const
nsAString
&
aAlignType
)
;
nsresult
AppendInnerFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aArray
nsINode
*
aNode
)
;
nsresult
GetFormatString
(
nsINode
*
aNode
nsAString
&
outFormat
)
;
enum
class
Lists
{
no
yes
}
;
enum
class
Tables
{
no
yes
}
;
void
GetInnerContent
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
int32_t
*
aIndex
Lists
aLists
=
Lists
:
:
yes
Tables
aTables
=
Tables
:
:
yes
)
;
Element
*
IsInListItem
(
nsINode
*
aNode
)
;
nsAtom
&
DefaultParagraphSeparator
(
)
;
nsresult
ReturnInHeader
(
Selection
&
aSelection
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
;
EditActionResult
ReturnInParagraph
(
Selection
&
aSelection
Element
&
aParentDivOrP
)
;
template
<
typename
PT
typename
CT
>
nsresult
SplitParagraph
(
Selection
&
aSelection
Element
&
aParentDivOrP
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfRightNode
nsIContent
*
aBRNode
)
;
nsresult
ReturnInListItem
(
Selection
&
aSelection
Element
&
aHeader
nsINode
&
aNode
int32_t
aOffset
)
;
nsresult
AfterEditInner
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
;
nsresult
RemovePartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
)
;
void
SplitBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
nsIContent
*
*
aOutLeftNode
=
nullptr
nsIContent
*
*
aOutRightNode
=
nullptr
nsIContent
*
*
aOutMiddleNode
=
nullptr
)
;
nsresult
OutdentPartOfBlock
(
Element
&
aBlock
nsIContent
&
aStartChild
nsIContent
&
aEndChild
bool
aIsBlockIndentedWithCSS
nsIContent
*
*
aOutLeftNode
nsIContent
*
*
aOutRightNode
)
;
already_AddRefed
<
Element
>
ConvertListType
(
Element
*
aList
nsAtom
*
aListType
nsAtom
*
aItemType
)
;
nsresult
CreateStyleForInsertText
(
Selection
&
aSelection
nsIDocument
&
aDoc
)
;
enum
class
IgnoreSingleBR
{
eYes
eNo
}
;
bool
IsEmptyBlockElement
(
Element
&
aElement
IgnoreSingleBR
aIgnoreSingleBR
)
;
nsresult
CheckForEmptyBlock
(
nsINode
*
aStartNode
Element
*
aBodyNode
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
bool
*
aHandled
)
;
enum
class
BRLocation
{
beforeBlock
blockEnd
}
;
Element
*
CheckForInvisibleBR
(
Element
&
aBlock
BRLocation
aWhere
int32_t
aOffset
=
0
)
;
nsresult
ExpandSelectionForDeletion
(
Selection
&
aSelection
)
;
nsresult
NormalizeSelection
(
Selection
*
aSelection
)
;
EditorDOMPoint
GetPromotedPoint
(
RulesEndpoint
aWhere
nsINode
&
aNode
int32_t
aOffset
EditAction
actionID
)
;
void
GetPromotedRanges
(
Selection
&
aSelection
nsTArray
<
RefPtr
<
nsRange
>
>
&
outArrayOfRanges
EditAction
inOperationType
)
;
void
PromoteRange
(
nsRange
&
aRange
EditAction
inOperationType
)
;
enum
class
TouchContent
{
no
yes
}
;
nsresult
GetNodesForOperation
(
nsTArray
<
RefPtr
<
nsRange
>
>
&
aArrayOfRanges
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EditAction
aOperationType
TouchContent
aTouchContent
=
TouchContent
:
:
yes
)
;
void
GetChildNodesForOperation
(
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
)
;
nsresult
GetNodesFromPoint
(
const
EditorDOMPoint
&
aPoint
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
)
;
nsresult
GetNodesFromSelection
(
Selection
&
aSelection
EditAction
aOperation
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
=
TouchContent
:
:
yes
)
;
enum
class
EntireList
{
no
yes
}
;
nsresult
GetListActionNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
EntireList
aEntireList
TouchContent
aTouchContent
=
TouchContent
:
:
yes
)
;
void
GetDefinitionListItemTypes
(
Element
*
aElement
bool
*
aDT
bool
*
aDD
)
;
nsresult
GetParagraphFormatNodes
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
outArrayOfNodes
TouchContent
aTouchContent
=
TouchContent
:
:
yes
)
;
void
LookInsideDivBQandList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
;
nsresult
BustUpInlinesAtRangeEndpoints
(
RangeItem
&
inRange
)
;
nsresult
BustUpInlinesAtBRs
(
nsIContent
&
aNode
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aOutArrayOfNodes
)
;
nsIContent
*
GetHighestInlineParent
(
nsINode
&
aNode
)
;
void
MakeTransitionList
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsTArray
<
bool
>
&
aTransitionArray
)
;
nsresult
RemoveBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
;
nsresult
ApplyBlockStyle
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
nsAtom
&
aBlockTag
)
;
nsresult
MakeBlockquote
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
aNodeArray
)
;
template
<
typename
PT
typename
CT
>
SplitNodeResult
MaybeSplitAncestorsForInsertWithTransaction
(
nsAtom
&
aTag
const
EditorDOMPointBase
<
PT
CT
>
&
aStartOfDeepestRightNode
)
;
EditorDOMPoint
JoinNearestEditableNodesWithTransaction
(
nsIContent
&
aLeftNode
nsIContent
&
aRightNode
)
;
Element
*
GetTopEnclosingMailCite
(
nsINode
&
aNode
)
;
nsresult
PopListItem
(
nsIContent
&
aListItem
bool
*
aOutOfList
=
nullptr
)
;
nsresult
RemoveListStructure
(
Element
&
aList
)
;
nsresult
CacheInlineStyles
(
nsINode
*
aNode
)
;
nsresult
ReapplyCachedStyles
(
)
;
void
ClearCachedStyles
(
)
;
void
AdjustSpecialBreaks
(
)
;
nsresult
AdjustWhitespace
(
Selection
*
aSelection
)
;
nsresult
PinSelectionToNewBlock
(
Selection
*
aSelection
)
;
void
CheckInterlinePosition
(
Selection
&
aSelection
)
;
nsresult
AdjustSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aAction
)
;
template
<
typename
PT
typename
CT
>
nsIContent
*
FindNearEditableNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
nsIEditor
:
:
EDirection
aDirection
)
;
bool
InDifferentTableElements
(
nsINode
*
aNode1
nsINode
*
aNode2
)
;
nsresult
RemoveEmptyNodes
(
)
;
nsresult
SelectionEndpointInNode
(
nsINode
*
aNode
bool
*
aResult
)
;
nsresult
UpdateDocChangeRange
(
nsRange
*
aRange
)
;
nsresult
ConfirmSelectionInBody
(
)
;
nsresult
InsertBRIfNeeded
(
nsINode
&
aNode
)
{
return
InsertBRIfNeededInternal
(
aNode
false
)
;
}
nsresult
InsertMozBRIfNeeded
(
nsINode
&
aNode
)
{
return
InsertBRIfNeededInternal
(
aNode
true
)
;
}
bool
IsEmptyInline
(
nsINode
&
aNode
)
;
bool
ListIsEmptyLine
(
nsTArray
<
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
;
nsresult
RemoveAlignment
(
nsINode
&
aNode
const
nsAString
&
aAlignType
bool
aChildrenOnly
)
;
nsresult
MakeSureElemStartsOrEndsOnCR
(
nsINode
&
aNode
bool
aStarts
)
;
enum
class
ContentsOnly
{
no
yes
}
;
nsresult
AlignBlock
(
Element
&
aElement
const
nsAString
&
aAlignType
ContentsOnly
aContentsOnly
)
;
enum
class
Change
{
minus
plus
}
;
nsresult
ChangeIndentation
(
Element
&
aElement
Change
aChange
)
;
void
DocumentModifiedWorker
(
)
;
void
InitStyleCacheArray
(
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
;
nsresult
GetInlineStyles
(
nsINode
*
aNode
StyleCache
aStyleCache
[
SIZE_STYLE_TABLE
]
)
;
protected
:
HTMLEditor
*
mHTMLEditor
;
RefPtr
<
nsRange
>
mDocChangeRange
;
bool
mListenerEnabled
;
bool
mReturnInEmptyLIKillsList
;
bool
mDidDeleteSelection
;
bool
mDidRangedDelete
;
bool
mRestoreContentEditableCount
;
RefPtr
<
nsRange
>
mUtilRange
;
uint32_t
mJoinOffset
;
nsCOMPtr
<
Element
>
mNewBlock
;
RefPtr
<
RangeItem
>
mRangeItem
;
StyleCache
mCachedStyles
[
SIZE_STYLE_TABLE
]
;
}
;
}
#
endif
