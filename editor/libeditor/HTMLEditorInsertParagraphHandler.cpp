#
include
"
EditorBase
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditorInlines
.
h
"
#
include
"
HTMLEditorNestedClasses
.
h
"
#
include
<
utility
>
#
include
"
AutoClonedRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorLineBreak
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
PendingStyles
.
h
"
#
include
"
WhiteSpaceVisibilityKeeper
.
h
"
#
include
"
WSRunScanner
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextNode
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
EmptyCheckOptions
=
HTMLEditUtils
:
:
EmptyCheckOptions
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
Err
(
NS_ERROR_NOT_INITIALIZED
)
;
}
{
Result
<
EditActionResult
nsresult
>
result
=
CanHandleHTMLEditSubAction
(
CheckSelectionInReplacedElement
:
:
OnlyWhenNotInSameNode
)
;
if
(
MOZ_UNLIKELY
(
result
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
;
}
if
(
result
.
inspect
(
)
.
Canceled
(
)
)
{
return
result
;
}
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertParagraphSeparator
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
Err
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
UndefineCaretBidiLevel
(
)
;
if
(
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
AutoInsertParagraphHandler
insertParagraphHandler
(
*
this
aEditingHost
)
;
Result
<
EditActionResult
nsresult
>
insertParagraphResult
=
insertParagraphHandler
.
Run
(
)
;
NS_WARNING_ASSERTION
(
insertParagraphResult
.
isOk
(
)
"
AutoInsertParagraphHandler
:
:
Run
(
)
failed
"
)
;
return
insertParagraphResult
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
Run
(
)
{
MOZ_ASSERT
(
mHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
mHTMLEditor
.
IsTopLevelEditSubActionDataAvailable
(
)
)
;
nsresult
rv
=
mHTMLEditor
.
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mHTMLEditor
.
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
mHTMLEditor
.
EnsureCaretNotAfterInvisibleBRElement
(
mEditingHost
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
mHTMLEditor
.
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
AutoClonedSelectionRangeArray
selectionRanges
(
mHTMLEditor
.
SelectionRef
(
)
)
;
selectionRanges
.
EnsureOnlyEditableRanges
(
mEditingHost
)
;
auto
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
while
(
true
)
{
Element
*
element
=
pointToInsert
.
GetContainerOrContainerParentElement
(
)
;
if
(
MOZ_UNLIKELY
(
!
element
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
element
*
nsGkAtoms
:
:
br
)
)
{
break
;
}
pointToInsert
=
pointToInsert
.
ParentPoint
(
)
;
}
if
(
mHTMLEditor
.
IsMailEditor
(
)
)
{
if
(
const
RefPtr
<
Element
>
mailCiteElement
=
mHTMLEditor
.
GetMostDistantAncestorMailCiteElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
Result
<
CaretPoint
nsresult
>
caretPointOrError
=
HandleInMailCiteElement
(
*
mailCiteElement
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
caretPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
HandleInMailCiteElement
(
)
failed
"
)
;
return
caretPointOrError
.
propagateErr
(
)
;
}
CaretPoint
caretPoint
=
caretPointOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
caretPoint
.
HasCaretPointSuggestion
(
)
)
;
MOZ_ASSERT
(
caretPoint
.
CaretPointRef
(
)
.
GetInterlinePosition
(
)
=
=
InterlinePosition
:
:
StartOfNextLine
)
;
MOZ_ASSERT
(
caretPoint
.
CaretPointRef
(
)
.
GetChild
(
)
)
;
MOZ_ASSERT
(
caretPoint
.
CaretPointRef
(
)
.
GetChild
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
nsresult
rv
=
caretPoint
.
SuggestCaretPointTo
(
mHTMLEditor
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CaretPoint
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
}
if
(
mEditingHost
.
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
mEditingHost
.
GetParentElement
(
)
)
&
&
!
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
&
mEditingHost
)
)
{
return
Err
(
NS_ERROR_EDITOR_NO_EDITABLE_RANGE
)
;
}
RefPtr
<
Element
>
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrButtonElement
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
ShouldInsertLineBreakInstead
(
editableBlockElement
pointToInsert
)
)
{
const
Maybe
<
LineBreakType
>
lineBreakType
=
mHTMLEditor
.
GetPreferredLineBreakType
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
mEditingHost
)
;
if
(
MOZ_UNLIKELY
(
!
lineBreakType
)
)
{
return
EditActionResult
:
:
IgnoredResult
(
)
;
}
if
(
lineBreakType
.
value
(
)
=
=
LineBreakType
:
:
Linefeed
)
{
Result
<
EditActionResult
nsresult
>
insertLinefeedResultOrError
=
HandleInsertLinefeed
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
insertLinefeedResultOrError
.
isOk
(
)
"
AutoInsertParagraphHandler
:
:
HandleInsertLinefeed
(
)
failed
"
)
;
return
insertLinefeedResultOrError
;
}
Result
<
EditActionResult
nsresult
>
insertBRElementResultOrError
=
HandleInsertBRElement
(
pointToInsert
)
;
NS_WARNING_ASSERTION
(
insertBRElementResultOrError
.
isOk
(
)
"
AutoInsertParagraphHandler
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
insertBRElementResultOrError
;
}
RefPtr
<
Element
>
blockElementToPutCaret
;
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
&
&
mDefaultParagraphSeparator
!
=
ParagraphSeparator
:
:
br
)
{
MOZ_ASSERT
(
mDefaultParagraphSeparator
=
=
ParagraphSeparator
:
:
div
|
|
mDefaultParagraphSeparator
=
=
ParagraphSeparator
:
:
p
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
suggestBlockElementToPutCaretOrError
=
mHTMLEditor
.
FormatBlockContainerWithTransaction
(
selectionRanges
MOZ_KnownLive
(
HTMLEditor
:
:
ToParagraphSeparatorTagName
(
mDefaultParagraphSeparator
)
)
FormatBlockMode
:
:
XULParagraphStateCommand
mEditingHost
)
;
if
(
MOZ_UNLIKELY
(
suggestBlockElementToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
failed
"
)
;
return
suggestBlockElementToPutCaretOrError
.
propagateErr
(
)
;
}
if
(
selectionRanges
.
HasSavedRanges
(
)
)
{
selectionRanges
.
RestoreFromSavedRanges
(
)
;
}
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
)
;
blockElementToPutCaret
=
suggestBlockElementToPutCaretOrError
.
unwrap
(
)
;
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrButtonElement
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
NS_WARN_IF
(
!
editableBlockElement
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
editableBlockElement
)
)
)
{
Result
<
EditActionResult
nsresult
>
insertBRElementResultOrError
=
HandleInsertBRElement
(
pointToInsert
blockElementToPutCaret
)
;
NS_WARNING_ASSERTION
(
insertBRElementResultOrError
.
isOk
(
)
"
AutoInsertParagraphHandler
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
insertBRElementResultOrError
;
}
blockElementToPutCaret
=
editableBlockElement
;
}
RefPtr
<
Element
>
insertedPaddingBRElement
;
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
InsertBRElementIfEmptyBlockElement
(
*
editableBlockElement
InsertBRElementIntoEmptyBlock
:
:
End
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
InsertBRElementIfEmptyBlockElement
(
"
"
InsertBRElementIntoEmptyBlock
:
:
End
"
"
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
insertBRElementResult
.
Handled
(
)
)
{
insertedPaddingBRElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
}
pointToInsert
=
selectionRanges
.
GetFirstRangeStartPoint
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
RefPtr
<
Element
>
maybeNonEditableListItem
=
HTMLEditUtils
:
:
GetClosestAncestorListItemElement
(
*
editableBlockElement
&
mEditingHost
)
;
if
(
maybeNonEditableListItem
&
&
HTMLEditUtils
:
:
IsSplittableNode
(
*
maybeNonEditableListItem
)
)
{
Result
<
InsertParagraphResult
nsresult
>
insertParagraphInListItemResult
=
HandleInListItemElement
(
*
maybeNonEditableListItem
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertParagraphInListItemResult
.
isErr
(
)
)
)
{
if
(
NS_WARN_IF
(
insertParagraphInListItemResult
.
unwrapErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
HandleInListItemElement
(
)
failed
but
"
"
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
InsertParagraphResult
unwrappedInsertParagraphInListItemResult
=
insertParagraphInListItemResult
.
unwrap
(
)
;
MOZ_ASSERT
(
unwrappedInsertParagraphInListItemResult
.
Handled
(
)
)
;
MOZ_ASSERT
(
unwrappedInsertParagraphInListItemResult
.
GetNewNode
(
)
)
;
const
RefPtr
<
Element
>
listItemOrParagraphElement
=
unwrappedInsertParagraphInListItemResult
.
UnwrapNewNode
(
)
;
const
EditorDOMPoint
pointToPutCaret
=
unwrappedInsertParagraphInListItemResult
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
pointToPutCaret
listItemOrParagraphElement
{
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
"
"
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CollapseSelection
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
HTMLEditUtils
:
:
IsHeader
(
*
editableBlockElement
)
)
{
Result
<
InsertParagraphResult
nsresult
>
insertParagraphInHeadingElementResult
=
HandleInHeadingElement
(
*
editableBlockElement
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertParagraphInHeadingElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
HandleInHeadingElement
(
)
failed
but
"
"
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
InsertParagraphResult
unwrappedInsertParagraphInHeadingElementResult
=
insertParagraphInHeadingElementResult
.
unwrap
(
)
;
if
(
unwrappedInsertParagraphInHeadingElementResult
.
Handled
(
)
)
{
MOZ_ASSERT
(
unwrappedInsertParagraphInHeadingElementResult
.
GetNewNode
(
)
)
;
blockElementToPutCaret
=
unwrappedInsertParagraphInHeadingElementResult
.
UnwrapNewNode
(
)
;
}
const
EditorDOMPoint
pointToPutCaret
=
unwrappedInsertParagraphInHeadingElementResult
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
pointToPutCaret
blockElementToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
"
"
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CollapseSelection
(
)
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
if
(
(
mDefaultParagraphSeparator
=
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
|
|
(
mDefaultParagraphSeparator
!
=
ParagraphSeparator
:
:
br
&
&
editableBlockElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
div
)
)
)
{
const
EditorDOMPoint
pointToSplit
=
GetBetterSplitPointToAvoidToContinueLink
(
insertedPaddingBRElement
?
EditorDOMPoint
(
insertedPaddingBRElement
)
:
pointToInsert
*
editableBlockElement
)
;
if
(
ShouldCreateNewParagraph
(
*
editableBlockElement
pointToSplit
)
)
{
MOZ_ASSERT
(
pointToSplit
.
IsInContentNodeAndValidInComposedDoc
(
)
)
;
Result
<
SplitNodeResult
nsresult
>
splitNodeResult
=
HandleInParagraph
(
*
editableBlockElement
pointToSplit
)
;
if
(
MOZ_UNLIKELY
(
splitNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
failed
"
)
;
return
splitNodeResult
.
propagateErr
(
)
;
}
if
(
splitNodeResult
.
inspect
(
)
.
Handled
(
)
)
{
SplitNodeResult
unwrappedSplitNodeResult
=
splitNodeResult
.
unwrap
(
)
;
const
RefPtr
<
Element
>
rightParagraphElement
=
unwrappedSplitNodeResult
.
DidSplit
(
)
?
unwrappedSplitNodeResult
.
GetNextContentAs
<
Element
>
(
)
:
blockElementToPutCaret
.
get
(
)
;
const
EditorDOMPoint
pointToPutCaret
=
unwrappedSplitNodeResult
.
UnwrapCaretPoint
(
)
;
nsresult
rv
=
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
pointToPutCaret
rightParagraphElement
{
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
"
"
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
)
"
"
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
AutoInsertParagraphHandler
:
:
"
"
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
)
"
"
failed
but
ignored
"
)
;
return
EditActionResult
:
:
HandledResult
(
)
;
}
MOZ_ASSERT
(
!
splitNodeResult
.
inspect
(
)
.
HasCaretPointSuggestion
(
)
)
;
}
MOZ_ASSERT
(
pointToInsert
.
IsSetAndValid
(
)
"
HTMLEditor
:
:
HandleInsertParagraphInParagraph
(
)
shouldn
'
t
touch
"
"
the
DOM
tree
if
it
returns
not
-
handled
state
"
)
;
}
Result
<
EditActionResult
nsresult
>
insertBRElementResultOrError
=
HandleInsertBRElement
(
pointToInsert
blockElementToPutCaret
)
;
NS_WARNING_ASSERTION
(
insertBRElementResultOrError
.
isOk
(
)
"
AutoInsertParagraphHandler
:
:
HandleInsertBRElement
(
)
failed
"
)
;
return
insertBRElementResultOrError
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInsertBRElement
(
const
EditorDOMPoint
&
aPointToInsert
const
Element
*
aBlockElementWhichShouldHaveCaret
)
{
Result
<
CreateElementResult
nsresult
>
insertBRElementResult
=
InsertBRElement
(
aPointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
InsertBRElement
(
)
failed
"
)
;
return
insertBRElementResult
.
propagateErr
(
)
;
}
const
EditorDOMPoint
pointToPutCaret
=
insertBRElementResult
.
unwrap
(
)
.
UnwrapCaretPoint
(
)
;
if
(
MOZ_UNLIKELY
(
!
pointToPutCaret
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
InsertBRElement
(
)
didn
'
t
suggest
a
"
"
point
to
put
caret
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
nsresult
rv
=
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
pointToPutCaret
aBlockElementWhichShouldHaveCaret
{
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
"
"
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
Result
<
EditActionResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInsertLinefeed
(
const
EditorDOMPoint
&
aPointToInsert
)
{
Result
<
EditorDOMPoint
nsresult
>
insertLineFeedResult
=
AutoInsertLineBreakHandler
:
:
InsertLinefeed
(
mHTMLEditor
aPointToInsert
mEditingHost
)
;
if
(
MOZ_UNLIKELY
(
insertLineFeedResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertLineBreakHandler
:
:
InsertLinefeed
(
)
failed
"
)
;
return
insertLineFeedResult
.
propagateErr
(
)
;
}
nsresult
rv
=
mHTMLEditor
.
CollapseSelectionTo
(
insertLineFeedResult
.
inspect
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
EditActionResult
:
:
HandledResult
(
)
;
}
bool
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
ShouldInsertLineBreakInstead
(
const
Element
*
aEditableBlockElement
const
EditorDOMPoint
&
aCandidatePointToSplit
)
{
if
(
!
aEditableBlockElement
)
{
return
true
;
}
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
aEditableBlockElement
)
)
{
return
mDefaultParagraphSeparator
=
=
ParagraphSeparator
:
:
br
|
|
!
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
aEditableBlockElement
)
|
|
(
aCandidatePointToSplit
.
IsInContentNode
(
)
&
&
mHTMLEditor
.
GetPreferredLineBreakType
(
*
aCandidatePointToSplit
.
ContainerAs
<
nsIContent
>
(
)
mEditingHost
)
.
valueOr
(
LineBreakType
:
:
BRElement
)
=
=
LineBreakType
:
:
Linefeed
&
&
HTMLEditUtils
:
:
IsDisplayOutsideInline
(
mEditingHost
)
)
;
}
if
(
HTMLEditUtils
:
:
IsSingleLineContainer
(
*
aEditableBlockElement
)
)
{
return
false
;
}
for
(
const
Element
*
editableBlockAncestor
=
aEditableBlockElement
;
editableBlockAncestor
;
editableBlockAncestor
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
editableBlockAncestor
HTMLEditUtils
:
:
ClosestEditableBlockElementOrButtonElement
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
if
(
HTMLEditUtils
:
:
CanElementContainParagraph
(
*
editableBlockAncestor
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
CollapseSelectionToPointOrIntoBlockWhichShouldHaveCaret
(
const
EditorDOMPoint
&
aCandidatePointToPutCaret
const
Element
*
aBlockElementShouldHaveCaret
const
SuggestCaretOptions
&
aOptions
)
{
if
(
!
aCandidatePointToPutCaret
.
IsSet
(
)
)
{
if
(
aOptions
.
contains
(
SuggestCaret
:
:
OnlyIfHasSuggestion
)
)
{
return
NS_OK
;
}
return
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
?
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
:
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToPutCaret
(
aCandidatePointToPutCaret
)
;
if
(
aBlockElementShouldHaveCaret
)
{
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorDOMPoint
>
(
*
aBlockElementShouldHaveCaret
aCandidatePointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
"
"
failed
but
ignored
"
)
;
}
else
if
(
pointToPutCaretOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
pointToPutCaretOrError
.
unwrap
(
)
;
}
}
nsresult
rv
=
mHTMLEditor
.
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
NS_FAILED
(
rv
)
&
&
MOZ_LIKELY
(
rv
!
=
NS_ERROR_EDITOR_DESTROYED
)
&
&
aOptions
.
contains
(
SuggestCaret
:
:
AndIgnoreTrivialError
)
)
{
rv
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
;
}
return
rv
;
}
Result
<
CreateElementResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
InsertBRElement
(
const
EditorDOMPoint
&
aPointToBreak
)
{
MOZ_ASSERT
(
aPointToBreak
.
IsInContentNode
(
)
)
;
const
bool
editingHostIsEmpty
=
HTMLEditUtils
:
:
IsEmptyNode
(
mEditingHost
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
;
const
WSRunScanner
wsRunScanner
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
aPointToBreak
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
const
WSScanResult
backwardScanResult
=
wsRunScanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aPointToBreak
)
;
if
(
MOZ_UNLIKELY
(
backwardScanResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
brElementIsAfterBlock
=
backwardScanResult
.
ReachedBlockBoundary
(
)
|
|
backwardScanResult
.
ReachedInlineEditingHostBoundary
(
)
;
const
WSScanResult
forwardScanResult
=
wsRunScanner
.
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
aPointToBreak
)
;
if
(
MOZ_UNLIKELY
(
forwardScanResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
brElementIsBeforeBlock
=
forwardScanResult
.
ReachedBlockBoundary
(
)
|
|
forwardScanResult
.
ReachedInlineEditingHostBoundary
(
)
;
RefPtr
<
Element
>
brElement
;
if
(
mHTMLEditor
.
IsPlaintextMailComposer
(
)
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
aPointToBreak
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
}
else
{
EditorDOMPoint
pointToBreak
(
aPointToBreak
)
;
RefPtr
<
Element
>
linkNode
=
HTMLEditor
:
:
GetLinkElement
(
pointToBreak
.
GetContainer
(
)
)
;
if
(
linkNode
)
{
Result
<
SplitNodeResult
nsresult
>
splitLinkNodeResult
=
mHTMLEditor
.
SplitNodeDeepWithTransaction
(
*
linkNode
pointToBreak
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitLinkNodeResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitLinkNodeResult
.
propagateErr
(
)
;
}
nsresult
rv
=
splitLinkNodeResult
.
inspect
(
)
.
SuggestCaretPointTo
(
mHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
pointToBreak
=
splitLinkNodeResult
.
inspect
(
)
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
InsertLineBreak
(
LineBreakType
:
:
BRElement
mHTMLEditor
pointToBreak
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
InsertLineBreak
(
LineBreakType
:
:
"
"
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
brElement
-
>
GetParentNode
(
)
)
)
{
NS_WARNING
(
"
Inserted
<
br
>
element
was
removed
by
the
web
app
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
auto
afterBRElement
=
EditorDOMPoint
:
:
After
(
brElement
)
;
const
auto
InsertAdditionalInvisibleLineBreak
=
[
this
&
afterBRElement
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
CreateLineBreakResult
nsresult
>
{
Result
<
CreateLineBreakResult
nsresult
>
insertPaddingBRElementResultOrError
=
WhiteSpaceVisibilityKeeper
:
:
InsertLineBreak
(
LineBreakType
:
:
BRElement
mHTMLEditor
afterBRElement
)
;
NS_WARNING_ASSERTION
(
insertPaddingBRElementResultOrError
.
isOk
(
)
"
WhiteSpaceVisibilityKeeper
:
:
InsertLineBreak
(
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
afterBRElement
=
insertPaddingBRElementResultOrError
.
inspect
(
)
.
AtLineBreak
<
EditorDOMPoint
>
(
)
;
return
insertPaddingBRElementResultOrError
;
}
;
if
(
brElementIsAfterBlock
&
&
brElementIsBeforeBlock
)
{
EditorDOMPoint
pointToPutCaret
;
if
(
editingHostIsEmpty
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertPaddingBRElementResultOrError
=
InsertAdditionalInvisibleLineBreak
(
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResultOrError
.
isErr
(
)
)
)
{
return
insertPaddingBRElementResultOrError
.
propagateErr
(
)
;
}
insertPaddingBRElementResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
pointToPutCaret
=
std
:
:
move
(
afterBRElement
)
;
}
else
{
pointToPutCaret
=
EditorDOMPoint
(
brElement
InterlinePosition
:
:
StartOfNextLine
)
;
}
return
CreateElementResult
(
std
:
:
move
(
brElement
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
const
WSScanResult
forwardScanFromAfterBRElementResult
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
afterBRElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromAfterBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromAfterBRElementResult
.
ReachedBRElement
(
)
)
{
if
(
brElement
-
>
GetNextSibling
(
)
!
=
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
{
MOZ_ASSERT
(
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
;
Result
<
MoveNodeResult
nsresult
>
moveBRElementResult
=
mHTMLEditor
.
MoveNodeWithTransaction
(
MOZ_KnownLive
(
*
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
afterBRElement
)
;
if
(
MOZ_UNLIKELY
(
moveBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveBRElementResult
.
propagateErr
(
)
;
}
nsresult
rv
=
moveBRElementResult
.
inspect
(
)
.
SuggestCaretPointTo
(
mHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
MoveNodeResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
afterBRElement
.
Set
(
forwardScanFromAfterBRElementResult
.
BRElementPtr
(
)
)
;
}
}
else
if
(
(
forwardScanFromAfterBRElementResult
.
ReachedBlockBoundary
(
)
|
|
forwardScanFromAfterBRElementResult
.
ReachedInlineEditingHostBoundary
(
)
)
&
&
!
brElementIsAfterBlock
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertPaddingBRElementResultOrError
=
InsertAdditionalInvisibleLineBreak
(
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResultOrError
.
isErr
(
)
)
)
{
return
insertPaddingBRElementResultOrError
.
propagateErr
(
)
;
}
insertPaddingBRElementResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
nsIContent
*
nextSiblingOfBRElement
=
brElement
-
>
GetNextSibling
(
)
;
afterBRElement
.
SetInterlinePosition
(
nextSiblingOfBRElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSiblingOfBRElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
?
InterlinePosition
:
:
EndOfLine
:
InterlinePosition
:
:
StartOfNextLine
)
;
return
CreateElementResult
(
std
:
:
move
(
brElement
)
afterBRElement
)
;
}
Result
<
CaretPoint
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInMailCiteElement
(
Element
&
aMailCiteElement
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
aPointToSplit
.
IsSet
(
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aMailCiteElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
"
The
mail
-
cite
element
will
be
deleted
does
it
expected
result
"
"
for
you
?
"
)
;
auto
splitCiteElementResult
=
SplitMailCiteElement
(
aPointToSplit
aMailCiteElement
)
;
if
(
MOZ_UNLIKELY
(
splitCiteElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
Failed
to
split
a
mail
-
cite
element
"
)
;
return
splitCiteElementResult
.
propagateErr
(
)
;
}
SplitNodeResult
unwrappedSplitCiteElementResult
=
splitCiteElementResult
.
unwrap
(
)
;
unwrappedSplitCiteElementResult
.
IgnoreCaretPointSuggestion
(
)
;
auto
*
const
leftCiteElement
=
unwrappedSplitCiteElementResult
.
GetPreviousContentAs
<
Element
>
(
)
;
auto
*
const
rightCiteElement
=
unwrappedSplitCiteElementResult
.
GetNextContentAs
<
Element
>
(
)
;
if
(
leftCiteElement
&
&
leftCiteElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
&
&
leftCiteElement
-
>
GetPrimaryFrame
(
)
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsIContent
*
lastChild
=
leftCiteElement
-
>
GetLastChild
(
)
;
if
(
lastChild
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertPaddingBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
EditorDOMPoint
:
:
AtEndOf
(
*
leftCiteElement
)
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertPaddingBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertPaddingBRElementResult
=
insertPaddingBRElementResultOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
insertPaddingBRElementResult
.
Handled
(
)
)
;
insertPaddingBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
}
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
unwrappedSplitCiteElementResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
Err
(
insertBRElementResultOrError
.
unwrapErr
(
)
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
Handled
(
)
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
{
nsresult
rvOfInsertPaddingBRElement
=
MaybeInsertPaddingBRElementToInlineMailCiteElement
(
insertBRElementResult
.
AtLineBreak
<
EditorDOMPoint
>
(
)
aMailCiteElement
)
;
if
(
NS_FAILED
(
rvOfInsertPaddingBRElement
)
)
{
NS_WARNING
(
"
Failed
to
insert
additional
<
br
>
element
before
the
inline
right
"
"
mail
-
cite
element
"
)
;
return
Err
(
rvOfInsertPaddingBRElement
)
;
}
}
if
(
leftCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftCiteElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
)
{
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
leftCiteElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
rightCiteElement
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
rightCiteElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
)
{
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightCiteElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
NS_WARN_IF
(
!
insertBRElementResult
.
LineBreakIsInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
auto
pointToPutCaret
=
insertBRElementResult
.
AtLineBreak
<
EditorDOMPoint
>
(
)
;
pointToPutCaret
.
SetInterlinePosition
(
InterlinePosition
:
:
StartOfNextLine
)
;
return
CaretPoint
(
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
SplitNodeResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
SplitMailCiteElement
(
const
EditorDOMPoint
&
aPointToSplit
Element
&
aMailCiteElement
)
{
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
const
WSScanResult
forwardScanFromPointToSplitResult
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
pointToSplit
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
;
if
(
forwardScanFromPointToSplitResult
.
Failed
(
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromPointToSplitResult
.
ReachedBRElement
(
)
&
&
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
!
=
&
aMailCiteElement
&
&
aMailCiteElement
.
Contains
(
forwardScanFromPointToSplitResult
.
BRElementPtr
(
)
)
)
{
pointToSplit
=
forwardScanFromPointToSplitResult
.
PointAfterReachedContent
<
EditorDOMPoint
>
(
)
;
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
mHTMLEditor
pointToSplit
{
WhiteSpaceVisibilityKeeper
:
:
NormalizeOption
:
:
StopIfPrecedingWhiteSpacesEndsWithNBP
WhiteSpaceVisibilityKeeper
:
:
NormalizeOption
:
:
StopIfFollowingWhiteSpacesStartsWithNBSP
}
)
;
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
NormalizeWhiteSpacesToSplitAt
(
)
"
"
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
Result
<
SplitNodeResult
nsresult
>
splitResult
=
mHTMLEditor
.
SplitNodeDeepWithTransaction
(
aMailCiteElement
pointToSplit
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aMailCiteElement
"
"
SplitAtEdges
:
:
eDoNotCreateEmptyContainer
)
failed
"
)
;
return
splitResult
;
}
nsresult
rv
=
splitResult
.
inspect
(
)
.
SuggestCaretPointTo
(
mHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
splitResult
;
}
nsresult
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
MaybeInsertPaddingBRElementToInlineMailCiteElement
(
const
EditorDOMPoint
&
aPointToInsertBRElement
Element
&
aMailCiteElement
)
{
if
(
!
HTMLEditUtils
:
:
IsInlineContent
(
aMailCiteElement
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
const
WSScanResult
backwardScanFromPointToCreateNewBRElementResult
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
aPointToInsertBRElement
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
;
if
(
MOZ_UNLIKELY
(
backwardScanFromPointToCreateNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
backwardScanFromPointToCreateNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
backwardScanFromPointToCreateNewBRElementResult
.
ReachedSpecialContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
const
WSScanResult
forwardScanFromPointAfterNewBRElementResult
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
EditorRawDOMPoint
:
:
After
(
aPointToInsertBRElement
)
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromPointAfterNewBRElementResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
forwardScanFromPointAfterNewBRElementResult
.
InVisibleOrCollapsibleCharacters
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedSpecialContent
(
)
&
&
!
forwardScanFromPointAfterNewBRElementResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
Result
<
CreateLineBreakResult
nsresult
>
insertAnotherBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
aPointToInsertBRElement
)
;
if
(
MOZ_UNLIKELY
(
insertAnotherBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertAnotherBRElementResultOrError
.
unwrapErr
(
)
;
}
CreateLineBreakResult
insertAnotherBRElementResult
=
insertAnotherBRElementResultOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
insertAnotherBRElementResult
.
Handled
(
)
)
;
insertAnotherBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
Result
<
InsertParagraphResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInHeadingElement
(
Element
&
aHeadingElement
const
EditorDOMPoint
&
aPointToSplit
)
{
auto
splitHeadingResult
=
[
this
&
aPointToSplit
&
aHeadingElement
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
SplitNodeResult
nsresult
>
{
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
mHTMLEditor
aPointToSplit
aHeadingElement
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
"
"
failed
"
)
;
return
preparationResult
.
propagateErr
(
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
Result
<
SplitNodeResult
nsresult
>
splitResult
=
mHTMLEditor
.
SplitNodeDeepWithTransaction
(
aHeadingElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
NS_WARNING_ASSERTION
(
splitResult
.
isOk
(
)
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
aHeadingElement
"
"
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
splitResult
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
splitHeadingResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
Failed
to
splitting
aHeadingElement
"
)
;
return
splitHeadingResult
.
propagateErr
(
)
;
}
SplitNodeResult
unwrappedSplitHeadingResult
=
splitHeadingResult
.
unwrap
(
)
;
unwrappedSplitHeadingResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
MOZ_UNLIKELY
(
!
unwrappedSplitHeadingResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
didn
'
t
split
aHeadingElement
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
auto
*
const
leftHeadingElement
=
unwrappedSplitHeadingResult
.
GetPreviousContentAs
<
Element
>
(
)
;
MOZ_ASSERT
(
leftHeadingElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
HTMLEditUtils
:
:
IsHeader
(
*
leftHeadingElement
)
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
leftHeadingElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
)
{
Result
<
CreateElementResult
nsresult
>
insertPaddingBRElementResult
=
mHTMLEditor
.
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
leftHeadingElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
insertPaddingBRElementResult
.
propagateErr
(
)
;
}
insertPaddingBRElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
auto
*
const
rightHeadingElement
=
unwrappedSplitHeadingResult
.
GetNextContentAs
<
Element
>
(
)
;
MOZ_ASSERT
(
rightHeadingElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
!
HTMLEditUtils
:
:
IsEmptyBlockElement
(
*
rightHeadingElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
return
InsertParagraphResult
(
rightHeadingElement
EditorDOMPoint
(
rightHeadingElement
0u
)
)
;
}
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
rightHeadingElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
rightHeadingElement
-
>
GetNextSibling
(
)
)
{
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
rightHeadingElement
-
>
GetNextSibling
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
nextEditableSibling
&
&
nextEditableSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
auto
afterEditableBRElement
=
EditorDOMPoint
:
:
After
(
*
nextEditableSibling
)
;
if
(
NS_WARN_IF
(
!
afterEditableBRElement
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
InsertParagraphResult
:
:
NotHandled
(
std
:
:
move
(
afterEditableBRElement
)
)
;
}
}
if
(
MOZ_UNLIKELY
(
!
leftHeadingElement
-
>
IsInComposedDoc
(
)
)
)
{
NS_WARNING
(
"
The
left
heading
element
was
unexpectedly
removed
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
mHTMLEditor
.
TopLevelEditSubActionDataRef
(
)
.
mCachedPendingStyles
-
>
Clear
(
)
;
mHTMLEditor
.
mPendingStylesToApplyToNewContent
-
>
ClearAllStyles
(
)
;
nsStaticAtom
&
newParagraphTagName
=
&
mDefaultParagraphSeparatorTagName
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
mDefaultParagraphSeparatorTagName
;
Result
<
CreateElementResult
nsresult
>
createNewParagraphElementResult
=
mHTMLEditor
.
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
EditorDOMPoint
:
:
After
(
*
leftHeadingElement
)
HTMLEditor
:
:
InsertNewBRElement
)
;
if
(
MOZ_UNLIKELY
(
createNewParagraphElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
createNewParagraphElementResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedCreateNewParagraphElementResult
=
createNewParagraphElementResult
.
unwrap
(
)
;
unwrappedCreateNewParagraphElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
unwrappedCreateNewParagraphElementResult
.
GetNewNode
(
)
)
;
EditorDOMPoint
pointToPutCaret
(
unwrappedCreateNewParagraphElementResult
.
GetNewNode
(
)
0u
)
;
return
InsertParagraphResult
(
unwrappedCreateNewParagraphElementResult
.
UnwrapNewNode
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
bool
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
const
dom
:
:
HTMLBRElement
*
aBRElement
)
{
return
!
aBRElement
|
|
HTMLEditUtils
:
:
IsInvisibleBRElement
(
*
aBRElement
)
|
|
EditorUtils
:
:
IsPaddingBRElementForEmptyLastLine
(
*
aBRElement
)
;
}
bool
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
ShouldCreateNewParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aPointToSplit
)
const
{
MOZ_ASSERT
(
aPointToSplit
.
IsInContentNodeAndValidInComposedDoc
(
)
)
;
if
(
MOZ_LIKELY
(
mHTMLEditor
.
GetReturnInParagraphCreatesNewParagraph
(
)
)
)
{
return
true
;
}
if
(
aPointToSplit
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
return
true
;
}
if
(
aPointToSplit
.
IsInTextNode
(
)
)
{
if
(
aPointToSplit
.
IsStartOfContainer
(
)
)
{
const
auto
*
const
precedingBRElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousSibling
(
*
aPointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
return
!
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
precedingBRElement
)
;
}
if
(
aPointToSplit
.
IsEndOfContainer
(
)
)
{
const
auto
*
const
followingBRElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextSibling
(
*
aPointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
return
!
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
followingBRElement
)
;
}
return
true
;
}
const
auto
*
const
precedingBRElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousContent
(
aPointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
Unused
&
mEditingHost
)
)
;
if
(
!
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
precedingBRElement
)
)
{
return
true
;
}
const
auto
*
followingBRElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextContent
(
aPointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
Unused
&
mEditingHost
)
)
;
return
!
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
followingBRElement
)
;
}
Result
<
SplitNodeResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInParagraph
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
aPointToSplit
.
IsInContentNodeAndValidInComposedDoc
(
)
)
;
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
RefPtr
<
HTMLBRElement
>
brElement
;
if
(
pointToSplit
.
GetContainer
(
)
=
=
&
aParentDivOrP
)
{
}
else
if
(
pointToSplit
.
IsInTextNode
(
)
)
{
if
(
pointToSplit
.
IsStartOfContainer
(
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousSibling
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
if
(
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
brElement
)
)
{
const
EditorDOMPoint
pointToInsertBR
=
pointToSplit
.
ParentPoint
(
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
if
(
pointToInsertBR
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsertBR
.
ContainerAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
br
)
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
pointToInsertBR
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
}
}
}
else
if
(
pointToSplit
.
IsEndOfContainer
(
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextSibling
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
;
if
(
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
brElement
)
)
{
const
auto
pointToInsertBR
=
EditorDOMPoint
:
:
After
(
*
pointToSplit
.
ContainerAs
<
Text
>
(
)
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
if
(
pointToInsertBR
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsertBR
.
ContainerAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
br
)
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
pointToInsertBR
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
}
}
}
else
{
Result
<
EditorDOMPoint
nsresult
>
pointToSplitOrError
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
mHTMLEditor
pointToSplit
aParentDivOrP
)
;
if
(
NS_WARN_IF
(
mHTMLEditor
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
pointToSplitOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
"
"
failed
"
)
;
return
pointToSplitOrError
.
propagateErr
(
)
;
}
MOZ_ASSERT
(
pointToSplitOrError
.
inspect
(
)
.
IsSetAndValid
(
)
)
;
if
(
pointToSplitOrError
.
inspect
(
)
.
IsSet
(
)
)
{
pointToSplit
=
pointToSplitOrError
.
unwrap
(
)
;
}
Result
<
SplitNodeResult
nsresult
>
splitParentDivOrPResult
=
mHTMLEditor
.
SplitNodeWithTransaction
(
pointToSplit
)
;
if
(
MOZ_UNLIKELY
(
splitParentDivOrPResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitParentDivOrPResult
;
}
splitParentDivOrPResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
pointToSplit
.
SetToEndOf
(
splitParentDivOrPResult
.
inspect
(
)
.
GetPreviousContent
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
const
auto
pointToInsertBR
=
EditorDOMPoint
:
:
After
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
)
;
MOZ_ASSERT
(
pointToInsertBR
.
IsSet
(
)
)
;
if
(
pointToInsertBR
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsertBR
.
ContainerAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
br
)
)
{
AutoTrackDOMPoint
trackPointToSplit
(
mHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
pointToInsertBR
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
trackPointToSplit
.
FlushAndStopTracking
(
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNodeAndValidInComposedDoc
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
}
else
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetPreviousContent
(
pointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
Unused
&
mEditingHost
)
)
;
if
(
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
brElement
)
)
{
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetNextContent
(
pointToSplit
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
BlockInlineCheck
:
:
Unused
&
mEditingHost
)
)
;
if
(
IsNullOrInvisibleBRElementOrPaddingOneForEmptyLastLine
(
brElement
)
)
{
if
(
pointToSplit
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
br
)
)
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
pointToSplit
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
CreateLineBreakResult
insertBRElementResult
=
insertBRElementResultOrError
.
unwrap
(
)
;
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
brElement
=
&
insertBRElementResult
-
>
BRElementRef
(
)
;
pointToSplit
.
SetAfter
(
brElement
)
;
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
}
}
}
Result
<
SplitNodeResult
nsresult
>
splitParagraphResult
=
SplitParagraphWithTransaction
(
aParentDivOrP
pointToSplit
brElement
)
;
if
(
MOZ_UNLIKELY
(
splitParagraphResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
SplitParagraphWithTransaction
(
)
failed
"
)
;
return
splitParagraphResult
;
}
if
(
MOZ_UNLIKELY
(
!
splitParagraphResult
.
inspect
(
)
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
AutoInsertParagraphHandler
:
:
SplitParagraphWithTransaction
(
)
didn
'
t
"
"
split
the
paragraph
"
)
;
splitParagraphResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
splitParagraphResult
.
inspect
(
)
.
Handled
(
)
)
;
return
splitParagraphResult
;
}
EditorDOMPoint
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
GetBetterSplitPointToAvoidToContinueLink
(
const
EditorDOMPoint
&
aCandidatePointToSplit
const
Element
&
aElementToSplit
)
{
EditorDOMPoint
pointToSplit
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
{
{
const
WSScanResult
prevVisibleThing
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
aCandidatePointToSplit
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
&
aElementToSplit
)
;
if
(
prevVisibleThing
.
GetContent
(
)
&
&
prevVisibleThing
.
GetContent
(
)
!
=
aCandidatePointToSplit
.
GetContainer
(
)
&
&
!
prevVisibleThing
.
GetContent
(
)
-
>
IsInclusiveDescendantOf
(
aCandidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
)
)
{
EditorRawDOMPoint
candidatePointToSplit
=
aCandidatePointToSplit
.
To
<
EditorRawDOMPoint
>
(
)
;
const
Element
*
const
commonAncestor
=
Element
:
:
FromNode
(
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
candidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
prevVisibleThing
.
GetContent
(
)
)
)
;
MOZ_ASSERT
(
commonAncestor
)
;
for
(
const
Element
*
container
=
candidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
;
container
&
&
container
!
=
commonAncestor
;
container
=
container
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
continue
;
}
candidatePointToSplit
.
Set
(
container
)
;
}
return
candidatePointToSplit
.
To
<
EditorDOMPoint
>
(
)
;
}
}
WSScanResult
nextVisibleThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
aCandidatePointToSplit
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
&
aElementToSplit
)
;
if
(
nextVisibleThing
.
ReachedInvisibleBRElement
(
)
)
{
nextVisibleThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
nextVisibleThing
.
PointAfterReachedContent
<
EditorRawDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
&
aElementToSplit
)
;
}
if
(
nextVisibleThing
.
GetContent
(
)
&
&
nextVisibleThing
.
GetContent
(
)
!
=
aCandidatePointToSplit
.
GetContainer
(
)
&
&
!
nextVisibleThing
.
GetContent
(
)
-
>
IsInclusiveDescendantOf
(
aCandidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
)
)
{
EditorRawDOMPoint
candidatePointToSplit
=
aCandidatePointToSplit
.
To
<
EditorRawDOMPoint
>
(
)
;
const
Element
*
const
commonAncestor
=
Element
:
:
FromNode
(
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
candidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
nextVisibleThing
.
GetContent
(
)
)
)
;
MOZ_ASSERT
(
commonAncestor
)
;
for
(
const
Element
*
container
=
candidatePointToSplit
.
GetContainerOrContainerParentElement
(
)
;
container
&
&
container
!
=
commonAncestor
;
container
=
container
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsLink
(
container
)
)
{
continue
;
}
candidatePointToSplit
.
SetAfter
(
container
)
;
}
return
candidatePointToSplit
.
To
<
EditorDOMPoint
>
(
)
;
}
return
aCandidatePointToSplit
;
}
(
)
;
for
(
const
nsIContent
*
container
=
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
;
container
&
&
container
!
=
&
aElementToSplit
&
&
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
container
)
;
container
=
container
-
>
GetParent
(
)
)
{
pointToSplit
=
pointToSplit
.
ParentPoint
(
)
;
}
return
pointToSplit
;
}
Result
<
SplitNodeResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
SplitParagraphWithTransaction
(
Element
&
aParentDivOrP
const
EditorDOMPoint
&
aStartOfRightNode
HTMLBRElement
*
aMayBecomeVisibleBRElement
)
{
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
mHTMLEditor
aStartOfRightNode
aParentDivOrP
)
;
if
(
MOZ_UNLIKELY
(
preparationResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
preparationResult
.
propagateErr
(
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
Result
<
SplitNodeResult
nsresult
>
splitDivOrPResult
=
mHTMLEditor
.
SplitNodeDeepWithTransaction
(
aParentDivOrP
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitDivOrPResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitDivOrPResult
;
}
SplitNodeResult
unwrappedSplitDivOrPResult
=
splitDivOrPResult
.
unwrap
(
)
;
if
(
MOZ_UNLIKELY
(
!
unwrappedSplitDivOrPResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
any
nodes
"
)
;
return
unwrappedSplitDivOrPResult
;
}
unwrappedSplitDivOrPResult
.
IgnoreCaretPointSuggestion
(
)
;
auto
*
const
leftDivOrParagraphElement
=
unwrappedSplitDivOrPResult
.
GetPreviousContentAs
<
Element
>
(
)
;
MOZ_ASSERT
(
leftDivOrParagraphElement
"
SplitNodeResult
:
:
GetPreviousContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
auto
*
const
rightDivOrParagraphElement
=
unwrappedSplitDivOrPResult
.
GetNextContentAs
<
Element
>
(
)
;
MOZ_ASSERT
(
rightDivOrParagraphElement
"
SplitNodeResult
:
:
GetNextContent
(
)
should
return
something
if
"
"
DidSplit
(
)
returns
true
"
)
;
if
(
aMayBecomeVisibleBRElement
&
&
HTMLEditUtils
:
:
IsVisibleBRElement
(
*
aMayBecomeVisibleBRElement
)
)
{
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
*
aMayBecomeVisibleBRElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
nsresult
rv
=
mHTMLEditor
.
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
*
nsGkAtoms
:
:
id
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
id
)
failed
"
)
;
return
Err
(
rv
)
;
}
{
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
leftDivOrParagraphElement
)
InsertBRElementIntoEmptyBlock
:
:
Start
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
InsertBRElementIfEmptyBlockElement
(
leftDivOrParagraphElement
"
"
InsertBRElementIntoEmptyBlock
:
:
Start
"
"
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
failed
"
)
;
return
Err
(
rv
)
;
}
insertBRElementResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
*
rightDivOrParagraphElement
)
)
{
if
(
const
RefPtr
<
Element
>
deepestInlineContainerElement
=
GetDeepestFirstChildInlineContainerElement
(
*
rightDivOrParagraphElement
)
)
{
const
Maybe
<
EditorLineBreak
>
lineBreak
=
HTMLEditUtils
:
:
GetFirstLineBreak
<
EditorLineBreak
>
(
*
rightDivOrParagraphElement
)
;
if
(
lineBreak
.
isSome
(
)
)
{
if
(
lineBreak
-
>
IsHTMLBRElement
(
)
&
&
lineBreak
-
>
BRElementRef
(
)
.
GetParentNode
(
)
=
=
deepestInlineContainerElement
)
{
auto
pointAtBRElement
=
lineBreak
-
>
To
<
EditorDOMPoint
>
(
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointAtBRElement
)
;
nsresult
rv
=
mHTMLEditor
.
UpdateBRElementType
(
MOZ_KnownLive
(
lineBreak
-
>
BRElementRef
(
)
)
BRElementType
:
:
PaddingForEmptyLastLine
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
UpdateBRElementType
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
return
SplitNodeResult
(
std
:
:
move
(
unwrappedSplitDivOrPResult
)
pointAtBRElement
)
;
}
Result
<
EditorDOMPoint
nsresult
>
lineBreakPointOrError
=
mHTMLEditor
.
DeleteLineBreakWithTransaction
(
lineBreak
.
ref
(
)
nsIEditor
:
:
eStrip
mEditingHost
)
;
if
(
MOZ_UNLIKELY
(
lineBreakPointOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteLineBreakWithTransaction
(
)
failed
"
)
;
return
lineBreakPointOrError
.
propagateErr
(
)
;
}
Result
<
CreateElementResult
nsresult
>
insertPaddingBRElementResult
=
mHTMLEditor
.
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
:
:
AtEndOf
(
deepestInlineContainerElement
)
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
"
"
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
)
failed
"
)
;
return
insertPaddingBRElementResult
.
propagateErr
(
)
;
}
insertPaddingBRElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitNodeResult
(
std
:
:
move
(
unwrappedSplitDivOrPResult
)
EditorDOMPoint
(
insertPaddingBRElementResult
.
inspect
(
)
.
GetNewNode
(
)
)
)
;
}
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
InsertBRElementIfEmptyBlockElement
(
MOZ_KnownLive
(
*
rightDivOrParagraphElement
)
InsertBRElementIntoEmptyBlock
:
:
Start
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
insertBRElementResultOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
InsertBRElementIfEmptyBlockElement
(
rightDivOrParagraphElement
"
"
InsertBRElementIntoEmptyBlock
:
:
Start
"
"
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
failed
"
)
;
return
insertBRElementResultOrError
.
propagateErr
(
)
;
}
insertBRElementResultOrError
.
unwrap
(
)
.
IgnoreCaretPointSuggestion
(
)
;
}
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
rightDivOrParagraphElement
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
!
child
)
)
{
return
SplitNodeResult
(
std
:
:
move
(
unwrappedSplitDivOrPResult
)
EditorDOMPoint
(
rightDivOrParagraphElement
0u
)
)
;
}
return
child
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
?
SplitNodeResult
(
std
:
:
move
(
unwrappedSplitDivOrPResult
)
EditorDOMPoint
(
child
0u
)
)
:
SplitNodeResult
(
std
:
:
move
(
unwrappedSplitDivOrPResult
)
EditorDOMPoint
(
child
)
)
;
}
Result
<
CreateLineBreakResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
InsertBRElementIfEmptyBlockElement
(
Element
&
aMaybeBlockElement
InsertBRElementIntoEmptyBlock
aInsertBRElementIntoEmptyBlock
BlockInlineCheck
aBlockInlineCheck
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aMaybeBlockElement
aBlockInlineCheck
)
)
{
return
CreateLineBreakResult
:
:
NotHandled
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsEmptyNode
(
aMaybeBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
CreateLineBreakResult
:
:
NotHandled
(
)
;
}
Result
<
CreateLineBreakResult
nsresult
>
insertBRElementResultOrError
=
mHTMLEditor
.
InsertLineBreak
(
WithTransaction
:
:
Yes
LineBreakType
:
:
BRElement
aInsertBRElementIntoEmptyBlock
=
=
InsertBRElementIntoEmptyBlock
:
:
Start
?
EditorDOMPoint
(
&
aMaybeBlockElement
0u
)
:
EditorDOMPoint
:
:
AtEndOf
(
aMaybeBlockElement
)
)
;
NS_WARNING_ASSERTION
(
insertBRElementResultOrError
.
isOk
(
)
"
HTMLEditor
:
:
InsertLineBreak
(
WithTransaction
:
:
Yes
"
"
LineBreakType
:
:
BRElement
)
failed
"
)
;
return
insertBRElementResultOrError
;
}
Element
*
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
GetDeepestFirstChildInlineContainerElement
(
Element
&
aBlockElement
)
{
Element
*
result
=
nullptr
;
for
(
Element
*
maybeDeepestInlineContainer
=
Element
:
:
FromNodeOrNull
(
aBlockElement
.
GetFirstChild
(
)
)
;
maybeDeepestInlineContainer
&
&
HTMLEditUtils
:
:
IsInlineContent
(
*
maybeDeepestInlineContainer
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
maybeDeepestInlineContainer
)
;
maybeDeepestInlineContainer
=
maybeDeepestInlineContainer
-
>
GetFirstElementChild
(
)
)
{
result
=
maybeDeepestInlineContainer
;
}
return
result
;
}
Result
<
InsertParagraphResult
nsresult
>
HTMLEditor
:
:
AutoInsertParagraphHandler
:
:
HandleInListItemElement
(
Element
&
aListItemElement
const
EditorDOMPoint
&
aPointToSplit
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsListItem
(
&
aListItemElement
)
)
;
if
(
&
mEditingHost
!
=
aListItemElement
.
GetParentElement
(
)
&
&
HTMLEditUtils
:
:
IsEmptyBlockElement
(
aListItemElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
RefPtr
<
Element
>
leftListElement
=
aListItemElement
.
GetParentElement
(
)
;
if
(
!
HTMLEditUtils
:
:
IsLastChild
(
aListItemElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
Result
<
SplitNodeResult
nsresult
>
splitListItemParentResult
=
mHTMLEditor
.
SplitNodeWithTransaction
(
EditorDOMPoint
(
&
aListItemElement
)
)
;
if
(
MOZ_UNLIKELY
(
splitListItemParentResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitListItemParentResult
.
propagateErr
(
)
;
}
SplitNodeResult
unwrappedSplitListItemParentResult
=
splitListItemParentResult
.
unwrap
(
)
;
if
(
MOZ_UNLIKELY
(
!
unwrappedSplitListItemParentResult
.
DidSplit
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
didn
'
t
split
the
parent
of
"
"
aListItemElement
"
)
;
MOZ_ASSERT
(
!
unwrappedSplitListItemParentResult
.
HasCaretPointSuggestion
(
)
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
unwrappedSplitListItemParentResult
.
IgnoreCaretPointSuggestion
(
)
;
leftListElement
=
unwrappedSplitListItemParentResult
.
GetPreviousContentAs
<
Element
>
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
leftListElement
)
;
}
auto
afterLeftListElement
=
EditorDOMPoint
:
:
After
(
leftListElement
)
;
if
(
MOZ_UNLIKELY
(
!
afterLeftListElement
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
afterLeftListElement
.
GetContainer
(
)
)
)
{
Result
<
MoveNodeResult
nsresult
>
moveListItemElementResult
=
mHTMLEditor
.
MoveNodeWithTransaction
(
aListItemElement
afterLeftListElement
)
;
if
(
MOZ_UNLIKELY
(
moveListItemElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
moveListItemElementResult
.
propagateErr
(
)
;
}
moveListItemElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
InsertParagraphResult
(
&
aListItemElement
EditorDOMPoint
(
&
aListItemElement
0u
)
)
;
}
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
aListItemElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
nsStaticAtom
&
newParagraphTagName
=
&
mDefaultParagraphSeparatorTagName
=
=
nsGkAtoms
:
:
br
?
*
nsGkAtoms
:
:
p
:
mDefaultParagraphSeparatorTagName
;
Result
<
CreateElementResult
nsresult
>
createNewParagraphElementResult
=
mHTMLEditor
.
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
newParagraphTagName
)
afterLeftListElement
HTMLEditor
:
:
InsertNewBRElement
)
;
if
(
MOZ_UNLIKELY
(
createNewParagraphElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
createNewParagraphElementResult
.
propagateErr
(
)
;
}
createNewParagraphElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
createNewParagraphElementResult
.
inspect
(
)
.
GetNewNode
(
)
)
;
EditorDOMPoint
pointToPutCaret
(
createNewParagraphElementResult
.
inspect
(
)
.
GetNewNode
(
)
0u
)
;
return
InsertParagraphResult
(
createNewParagraphElementResult
.
inspect
(
)
.
GetNewNode
(
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
preparationResult
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
mHTMLEditor
aPointToSplit
aListItemElement
)
;
if
(
preparationResult
.
isErr
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
)
failed
"
)
;
return
Err
(
preparationResult
.
unwrapErr
(
)
)
;
}
EditorDOMPoint
pointToSplit
=
preparationResult
.
unwrap
(
)
;
MOZ_ASSERT
(
pointToSplit
.
IsInContentNode
(
)
)
;
Result
<
SplitNodeResult
nsresult
>
splitListItemResult
=
mHTMLEditor
.
SplitNodeDeepWithTransaction
(
aListItemElement
pointToSplit
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
MOZ_UNLIKELY
(
splitListItemResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
splitListItemResult
.
propagateErr
(
)
;
}
SplitNodeResult
unwrappedSplitListItemElement
=
splitListItemResult
.
unwrap
(
)
;
unwrappedSplitListItemElement
.
IgnoreCaretPointSuggestion
(
)
;
if
(
MOZ_UNLIKELY
(
!
aListItemElement
.
GetParent
(
)
)
)
{
NS_WARNING
(
"
Somebody
disconnected
the
target
listitem
from
the
parent
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
!
unwrappedSplitListItemElement
.
DidSplit
(
)
)
|
|
NS_WARN_IF
(
!
unwrappedSplitListItemElement
.
GetNewContentAs
<
Element
>
(
)
)
|
|
NS_WARN_IF
(
!
unwrappedSplitListItemElement
.
GetOriginalContentAs
<
Element
>
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
didn
'
t
split
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
auto
&
leftListItemElement
=
*
unwrappedSplitListItemElement
.
GetPreviousContentAs
<
Element
>
(
)
;
auto
&
rightListItemElement
=
*
unwrappedSplitListItemElement
.
GetNextContentAs
<
Element
>
(
)
;
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
leftListItemElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
)
{
Result
<
CreateElementResult
nsresult
>
insertPaddingBRElementResult
=
mHTMLEditor
.
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
EditorDOMPoint
(
&
leftListItemElement
0u
)
)
;
if
(
MOZ_UNLIKELY
(
insertPaddingBRElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertPaddingBRElementForEmptyLastLineWithTransaction
(
"
"
)
failed
"
)
;
return
insertPaddingBRElementResult
.
propagateErr
(
)
;
}
insertPaddingBRElementResult
.
inspect
(
)
.
IgnoreCaretPointSuggestion
(
)
;
return
InsertParagraphResult
(
&
rightListItemElement
EditorDOMPoint
(
&
rightListItemElement
0u
)
)
;
}
if
(
HTMLEditUtils
:
:
IsEmptyNode
(
rightListItemElement
{
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
}
)
)
{
if
(
aListItemElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
)
{
nsStaticAtom
&
nextDefinitionListItemTagName
=
aListItemElement
.
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
?
*
nsGkAtoms
:
:
dd
:
*
nsGkAtoms
:
:
dt
;
Result
<
CreateElementResult
nsresult
>
createNewListItemElementResult
=
mHTMLEditor
.
CreateAndInsertElement
(
WithTransaction
:
:
Yes
MOZ_KnownLive
(
nextDefinitionListItemTagName
)
EditorDOMPoint
:
:
After
(
rightListItemElement
)
)
;
if
(
MOZ_UNLIKELY
(
createNewListItemElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
createNewListItemElementResult
.
propagateErr
(
)
;
}
CreateElementResult
unwrappedCreateNewListItemElementResult
=
createNewListItemElementResult
.
unwrap
(
)
;
unwrappedCreateNewListItemElementResult
.
IgnoreCaretPointSuggestion
(
)
;
RefPtr
<
Element
>
newListItemElement
=
unwrappedCreateNewListItemElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newListItemElement
)
;
nsresult
rv
=
mHTMLEditor
.
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
rightListItemElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
EditorDOMPoint
pointToPutCaret
(
newListItemElement
0u
)
;
return
InsertParagraphResult
(
std
:
:
move
(
newListItemElement
)
std
:
:
move
(
pointToPutCaret
)
)
;
}
Result
<
EditorDOMPoint
nsresult
>
pointToPutCaretOrError
=
mHTMLEditor
.
CopyLastEditableChildStylesWithTransaction
(
MOZ_KnownLive
(
leftListItemElement
)
MOZ_KnownLive
(
rightListItemElement
)
mEditingHost
)
;
if
(
MOZ_UNLIKELY
(
pointToPutCaretOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
)
failed
"
)
;
return
pointToPutCaretOrError
.
propagateErr
(
)
;
}
return
InsertParagraphResult
(
&
rightListItemElement
pointToPutCaretOrError
.
unwrap
(
)
)
;
}
const
WSScanResult
forwardScanFromStartOfListItemResult
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
EditorRawDOMPoint
(
&
rightListItemElement
0u
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
forwardScanFromStartOfListItemResult
.
Failed
(
)
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
forwardScanFromStartOfListItemResult
.
ReachedSpecialContent
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedBRElement
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedHRElement
(
)
)
{
auto
atFoundElement
=
forwardScanFromStartOfListItemResult
.
PointAtReachedContent
<
EditorDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atFoundElement
.
IsSetAndValid
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
InsertParagraphResult
(
&
rightListItemElement
std
:
:
move
(
atFoundElement
)
)
;
}
if
(
forwardScanFromStartOfListItemResult
.
ReachedBlockBoundary
(
)
|
|
forwardScanFromStartOfListItemResult
.
ReachedInlineEditingHostBoundary
(
)
)
{
return
InsertParagraphResult
(
&
rightListItemElement
HTMLEditUtils
:
:
GetDeepestEditableStartPointOf
<
EditorDOMPoint
>
(
forwardScanFromStartOfListItemResult
.
GetContent
(
)
?
*
forwardScanFromStartOfListItemResult
.
GetContent
(
)
:
rightListItemElement
)
)
;
}
return
InsertParagraphResult
(
&
rightListItemElement
forwardScanFromStartOfListItemResult
.
PointAtReachedContent
<
EditorDOMPoint
>
(
)
)
;
}
}
