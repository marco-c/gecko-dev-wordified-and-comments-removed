#
ifndef
mozilla_EditorUtils_h
#
define
mozilla_EditorUtils_h
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nscore
.
h
"
class
nsAtom
;
class
nsIContentIterator
;
class
nsIDOMDocument
;
class
nsIDOMEvent
;
class
nsISimpleEnumerator
;
class
nsITransferable
;
class
nsRange
;
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
class
MOZ_STACK_CLASS
EditActionResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Canceled
(
)
const
{
return
mCanceled
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
EditActionResult
SetResult
(
nsresult
aRv
)
{
mRv
=
aRv
;
return
*
this
;
}
EditActionResult
MarkAsCanceled
(
)
{
mCanceled
=
true
;
return
*
this
;
}
EditActionResult
MarkAsHandled
(
)
{
mHandled
=
true
;
return
*
this
;
}
explicit
EditActionResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
EditActionResult
&
operator
|
=
(
const
EditActionResult
&
aOther
)
{
mCanceled
|
=
aOther
.
mCanceled
;
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
return
*
this
;
}
if
(
Failed
(
)
|
|
aOther
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
}
else
{
mRv
=
NS_OK
;
}
return
*
this
;
}
private
:
nsresult
mRv
;
bool
mCanceled
;
bool
mHandled
;
EditActionResult
(
nsresult
aRv
bool
aCanceled
bool
aHandled
)
:
mRv
(
aRv
)
mCanceled
(
aCanceled
)
mHandled
(
aHandled
)
{
}
EditActionResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
friend
EditActionResult
EditActionIgnored
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionHandled
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionCanceled
(
nsresult
aRv
)
;
}
;
inline
EditActionResult
EditActionIgnored
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
false
)
;
}
inline
EditActionResult
EditActionHandled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
true
)
;
}
inline
EditActionResult
EditActionCanceled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
true
true
)
;
}
class
MOZ_STACK_CLASS
SplitNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
DidSplit
(
)
const
{
return
mPreviousNode
&
&
mNextNode
;
}
nsIContent
*
GetLeftNode
(
)
const
{
return
mPreviousNode
&
&
mNextNode
?
mPreviousNode
.
get
(
)
:
nullptr
;
}
nsIContent
*
GetRightNode
(
)
const
{
return
mPreviousNode
&
&
!
mNextNode
?
mPreviousNode
:
mNextNode
;
}
nsIContent
*
GetPreviousNode
(
)
const
{
return
mPreviousNode
;
}
nsIContent
*
GetNextNode
(
)
const
{
return
mNextNode
;
}
EditorRawDOMPoint
SplitPoint
(
)
const
{
if
(
Failed
(
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
mPreviousNode
)
{
return
EditorRawDOMPoint
(
mNextNode
)
;
}
EditorRawDOMPoint
point
(
mPreviousNode
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
previous
node
"
)
;
return
point
;
}
SplitNodeResult
(
nsIContent
*
aPreviousNodeOfSplitPoint
nsIContent
*
aNextNodeOfSplitPoint
)
:
mPreviousNode
(
aPreviousNodeOfSplitPoint
)
mNextNode
(
aNextNodeOfSplitPoint
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPreviousNode
|
|
mNextNode
)
;
}
explicit
SplitNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
private
:
nsCOMPtr
<
nsIContent
>
mPreviousNode
;
nsCOMPtr
<
nsIContent
>
mNextNode
;
nsresult
mRv
;
SplitNodeResult
(
)
=
delete
;
}
;
class
MOZ_RAII
AutoPlaceholderBatch
final
{
private
:
RefPtr
<
EditorBase
>
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoPlaceholderBatch
(
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
BeginPlaceholderTransaction
(
nullptr
)
;
}
AutoPlaceholderBatch
(
EditorBase
*
aEditorBase
nsAtom
*
aTransactionName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
BeginPlaceholderTransaction
(
aTransactionName
)
;
}
~
AutoPlaceholderBatch
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
EndPlaceholderTransaction
(
)
;
}
}
private
:
void
BeginPlaceholderTransaction
(
nsAtom
*
aTransactionName
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
BeginPlaceholderTransaction
(
aTransactionName
)
;
}
}
}
;
class
MOZ_RAII
AutoSelectionRestorer
final
{
private
:
RefPtr
<
dom
:
:
Selection
>
mSelection
;
EditorBase
*
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
AutoSelectionRestorer
(
dom
:
:
Selection
*
aSelection
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoSelectionRestorer
(
)
;
void
Abort
(
)
;
}
;
class
MOZ_RAII
AutoRules
final
{
public
:
AutoRules
(
EditorBase
*
aEditorBase
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
mDoNothing
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mEditorBase
&
&
!
mEditorBase
-
>
mAction
)
{
mEditorBase
-
>
StartOperation
(
aAction
aDirection
)
;
}
else
{
mDoNothing
=
true
;
}
}
~
AutoRules
(
)
{
if
(
mEditorBase
&
&
!
mDoNothing
)
{
mEditorBase
-
>
EndOperation
(
)
;
}
}
protected
:
EditorBase
*
mEditorBase
;
bool
mDoNothing
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoTransactionsConserveSelection
final
{
public
:
explicit
AutoTransactionsConserveSelection
(
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
mOldState
(
true
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mEditorBase
)
{
mOldState
=
mEditorBase
-
>
GetShouldTxnSetSelection
(
)
;
mEditorBase
-
>
SetShouldTxnSetSelection
(
false
)
;
}
}
~
AutoTransactionsConserveSelection
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
SetShouldTxnSetSelection
(
mOldState
)
;
}
}
protected
:
EditorBase
*
mEditorBase
;
bool
mOldState
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoUpdateViewBatch
final
{
public
:
explicit
AutoUpdateViewBatch
(
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
NS_ASSERTION
(
mEditorBase
"
null
mEditorBase
pointer
!
"
)
;
if
(
mEditorBase
)
{
mEditorBase
-
>
BeginUpdateViewBatch
(
)
;
}
}
~
AutoUpdateViewBatch
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
EndUpdateViewBatch
(
)
;
}
}
protected
:
EditorBase
*
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_STACK_CLASS
AutoRangeArray
final
{
public
:
explicit
AutoRangeArray
(
dom
:
:
Selection
*
aSelection
)
{
if
(
!
aSelection
)
{
return
;
}
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
mRanges
.
AppendElement
(
*
aSelection
-
>
GetRangeAt
(
i
)
)
;
}
}
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
}
;
class
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
=
0
;
}
;
class
MOZ_RAII
DOMIterator
{
public
:
explicit
DOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
explicit
DOMIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
virtual
~
DOMIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
void
AppendList
(
const
BoolDomIterFunctor
&
functor
nsTArray
<
mozilla
:
:
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
const
;
protected
:
nsCOMPtr
<
nsIContentIterator
>
mIter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
DOMSubtreeIterator
final
:
public
DOMIterator
{
public
:
explicit
DOMSubtreeIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
virtual
~
DOMSubtreeIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
}
;
class
TrivialFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
return
true
;
}
}
;
class
EditorUtils
final
{
public
:
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
=
nullptr
)
;
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
;
static
bool
IsLeafNode
(
nsIDOMNode
*
aNode
)
;
}
;
class
EditorHookUtils
final
{
public
:
static
bool
DoInsertionHook
(
nsIDOMDocument
*
aDoc
nsIDOMEvent
*
aEvent
nsITransferable
*
aTrans
)
;
private
:
static
nsresult
GetHookEnumeratorFromDocument
(
nsIDOMDocument
*
aDoc
nsISimpleEnumerator
*
*
aEnumerator
)
;
}
;
}
#
endif
