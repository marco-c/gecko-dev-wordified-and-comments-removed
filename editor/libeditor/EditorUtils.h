#
ifndef
mozilla_EditorUtils_h
#
define
mozilla_EditorUtils_h
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nscore
.
h
"
class
nsAtom
;
class
nsISimpleEnumerator
;
class
nsITransferable
;
namespace
mozilla
{
class
MoveNodeResult
;
template
<
class
T
>
class
OwningNonNull
;
namespace
dom
{
class
Element
;
class
Text
;
}
class
MOZ_STACK_CLASS
EditResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
const
EditorDOMPoint
&
PointRefToCollapseSelection
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mStartPoint
.
IsSet
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mStartPoint
=
=
mEndPoint
)
;
return
mStartPoint
;
}
const
EditorDOMPoint
&
StartPointRef
(
)
const
{
return
mStartPoint
;
}
const
EditorDOMPoint
&
EndPointRef
(
)
const
{
return
mEndPoint
;
}
already_AddRefed
<
dom
:
:
StaticRange
>
CreateStaticRange
(
)
const
{
return
dom
:
:
StaticRange
:
:
Create
(
mStartPoint
.
ToRawRangeBoundary
(
)
mEndPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
}
already_AddRefed
<
nsRange
>
CreateRange
(
)
const
{
return
nsRange
:
:
Create
(
mStartPoint
.
ToRawRangeBoundary
(
)
mEndPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
}
EditResult
(
)
=
delete
;
explicit
EditResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
template
<
typename
PT
typename
CT
>
explicit
EditResult
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToPutCaret
)
:
mRv
(
aPointToPutCaret
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mStartPoint
(
aPointToPutCaret
)
mEndPoint
(
aPointToPutCaret
)
{
}
template
<
typename
SPT
typename
SCT
typename
EPT
typename
ECT
>
EditResult
(
const
EditorDOMPointBase
<
SPT
SCT
>
&
aStartPoint
const
EditorDOMPointBase
<
EPT
ECT
>
&
aEndPoint
)
:
mRv
(
aStartPoint
.
IsSet
(
)
&
&
aEndPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mStartPoint
(
aStartPoint
)
mEndPoint
(
aEndPoint
)
{
}
EditResult
(
const
EditResult
&
aOther
)
=
delete
;
EditResult
&
operator
=
(
const
EditResult
&
aOther
)
=
delete
;
EditResult
(
EditResult
&
&
aOther
)
=
default
;
EditResult
&
operator
=
(
EditResult
&
&
aOther
)
=
default
;
private
:
nsresult
mRv
;
EditorDOMPoint
mStartPoint
;
EditorDOMPoint
mEndPoint
;
}
;
class
MOZ_STACK_CLASS
EditActionResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Canceled
(
)
const
{
return
mCanceled
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
bool
Ignored
(
)
const
{
return
!
mCanceled
&
&
!
mHandled
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
EditActionResult
SetResult
(
nsresult
aRv
)
{
mRv
=
aRv
;
return
*
this
;
}
EditActionResult
MarkAsCanceled
(
)
{
mCanceled
=
true
;
return
*
this
;
}
EditActionResult
MarkAsHandled
(
)
{
mHandled
=
true
;
return
*
this
;
}
explicit
EditActionResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
EditActionResult
&
operator
|
=
(
const
EditActionResult
&
aOther
)
{
mCanceled
|
=
aOther
.
mCanceled
;
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aOther
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
}
else
if
(
Failed
(
)
|
|
aOther
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
}
else
{
mRv
=
NS_OK
;
}
return
*
this
;
}
EditActionResult
&
operator
|
=
(
const
MoveNodeResult
&
aMoveNodeResult
)
;
private
:
nsresult
mRv
;
bool
mCanceled
;
bool
mHandled
;
EditActionResult
(
nsresult
aRv
bool
aCanceled
bool
aHandled
)
:
mRv
(
aRv
)
mCanceled
(
aCanceled
)
mHandled
(
aHandled
)
{
}
EditActionResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
friend
EditActionResult
EditActionIgnored
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionHandled
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionCanceled
(
nsresult
aRv
)
;
}
;
inline
EditActionResult
EditActionIgnored
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
false
)
;
}
inline
EditActionResult
EditActionHandled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
true
)
;
}
inline
EditActionResult
EditActionCanceled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
true
true
)
;
}
template
<
typename
NodeType
>
class
CreateNodeResultBase
;
typedef
CreateNodeResultBase
<
dom
:
:
Element
>
CreateElementResult
;
template
<
typename
NodeType
>
class
MOZ_STACK_CLASS
CreateNodeResultBase
final
{
typedef
CreateNodeResultBase
<
NodeType
>
SelfType
;
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
NodeType
*
GetNewNode
(
)
const
{
return
mNode
;
}
CreateNodeResultBase
(
)
=
delete
;
explicit
CreateNodeResultBase
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
explicit
CreateNodeResultBase
(
NodeType
*
aNode
)
:
mNode
(
aNode
)
mRv
(
aNode
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
explicit
CreateNodeResultBase
(
already_AddRefed
<
NodeType
>
&
&
aNode
)
:
mNode
(
aNode
)
mRv
(
mNode
.
get
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
CreateNodeResultBase
(
const
SelfType
&
aOther
)
=
delete
;
SelfType
&
operator
=
(
const
SelfType
&
aOther
)
=
delete
;
CreateNodeResultBase
(
SelfType
&
&
aOther
)
=
default
;
SelfType
&
operator
=
(
SelfType
&
&
aOther
)
=
default
;
already_AddRefed
<
NodeType
>
forget
(
)
{
mRv
=
NS_ERROR_NOT_INITIALIZED
;
return
mNode
.
forget
(
)
;
}
private
:
RefPtr
<
NodeType
>
mNode
;
nsresult
mRv
;
}
;
class
MOZ_STACK_CLASS
MoveNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
bool
Ignored
(
)
const
{
return
!
mHandled
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
const
EditorDOMPoint
&
NextInsertionPointRef
(
)
const
{
return
mNextInsertionPoint
;
}
EditorDOMPoint
NextInsertionPoint
(
)
const
{
return
mNextInsertionPoint
;
}
void
MarkAsHandled
(
)
{
mHandled
=
true
;
}
MoveNodeResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mHandled
(
false
)
{
}
explicit
MoveNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mHandled
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
MoveNodeResult
(
const
MoveNodeResult
&
aOther
)
=
delete
;
MoveNodeResult
&
operator
=
(
const
MoveNodeResult
&
aOther
)
=
delete
;
MoveNodeResult
(
MoveNodeResult
&
&
aOther
)
=
default
;
MoveNodeResult
&
operator
=
(
MoveNodeResult
&
&
aOther
)
=
default
;
MoveNodeResult
&
operator
|
=
(
const
MoveNodeResult
&
aOther
)
{
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aOther
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
mNextInsertionPoint
.
Clear
(
)
;
return
*
this
;
}
if
(
aOther
.
mRv
=
=
NS_ERROR_NOT_INITIALIZED
)
{
return
*
this
;
}
if
(
mRv
=
=
NS_ERROR_NOT_INITIALIZED
)
{
mRv
=
aOther
.
mRv
;
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
return
*
this
;
}
if
(
Failed
(
)
|
|
aOther
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
mNextInsertionPoint
.
Clear
(
)
;
return
*
this
;
}
mRv
=
NS_OK
;
mNextInsertionPoint
=
aOther
.
mNextInsertionPoint
;
return
*
this
;
}
private
:
template
<
typename
PT
typename
CT
>
explicit
MoveNodeResult
(
const
EditorDOMPointBase
<
PT
CT
>
&
aNextInsertionPoint
bool
aHandled
)
:
mNextInsertionPoint
(
aNextInsertionPoint
)
mRv
(
aNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
mHandled
(
aHandled
&
&
aNextInsertionPoint
.
IsSet
(
)
)
{
if
(
mNextInsertionPoint
.
IsSet
(
)
)
{
AutoEditorDOMPointChildInvalidator
computeOffsetAndForgetChild
(
mNextInsertionPoint
)
;
}
}
MoveNodeResult
(
nsINode
*
aParentNode
uint32_t
aOffsetOfNextInsertionPoint
bool
aHandled
)
{
if
(
!
aParentNode
)
{
mRv
=
NS_ERROR_FAILURE
;
mHandled
=
false
;
return
;
}
aOffsetOfNextInsertionPoint
=
std
:
:
min
(
aOffsetOfNextInsertionPoint
aParentNode
-
>
Length
(
)
)
;
mNextInsertionPoint
.
Set
(
aParentNode
aOffsetOfNextInsertionPoint
)
;
mRv
=
mNextInsertionPoint
.
IsSet
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
mHandled
=
aHandled
&
&
mNextInsertionPoint
.
IsSet
(
)
;
}
EditorDOMPoint
mNextInsertionPoint
;
nsresult
mRv
;
bool
mHandled
;
friend
MoveNodeResult
MoveNodeIgnored
(
nsINode
*
aParentNode
uint32_t
aOffsetOfNextInsertionPoint
)
;
friend
MoveNodeResult
MoveNodeHandled
(
nsINode
*
aParentNode
uint32_t
aOffsetOfNextInsertionPoint
)
;
template
<
typename
PT
typename
CT
>
friend
MoveNodeResult
MoveNodeIgnored
(
const
EditorDOMPointBase
<
PT
CT
>
&
aNextInsertionPoint
)
;
template
<
typename
PT
typename
CT
>
friend
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPointBase
<
PT
CT
>
&
aNextInsertionPoint
)
;
}
;
inline
MoveNodeResult
MoveNodeIgnored
(
nsINode
*
aParentNode
uint32_t
aOffsetOfNextInsertionPoint
)
{
return
MoveNodeResult
(
aParentNode
aOffsetOfNextInsertionPoint
false
)
;
}
template
<
typename
PT
typename
CT
>
inline
MoveNodeResult
MoveNodeIgnored
(
const
EditorDOMPointBase
<
PT
CT
>
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
aNextInsertionPoint
false
)
;
}
inline
MoveNodeResult
MoveNodeHandled
(
nsINode
*
aParentNode
uint32_t
aOffsetOfNextInsertionPoint
)
{
return
MoveNodeResult
(
aParentNode
aOffsetOfNextInsertionPoint
true
)
;
}
template
<
typename
PT
typename
CT
>
inline
MoveNodeResult
MoveNodeHandled
(
const
EditorDOMPointBase
<
PT
CT
>
&
aNextInsertionPoint
)
{
return
MoveNodeResult
(
aNextInsertionPoint
true
)
;
}
class
MOZ_STACK_CLASS
SplitNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Handled
(
)
const
{
return
mPreviousNode
|
|
mNextNode
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
bool
DidSplit
(
)
const
{
return
mPreviousNode
&
&
mNextNode
;
}
nsIContent
*
GetLeftNode
(
)
const
{
return
mPreviousNode
&
&
mNextNode
?
mPreviousNode
.
get
(
)
:
nullptr
;
}
nsIContent
*
GetRightNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
GetChild
(
)
;
}
return
mPreviousNode
&
&
!
mNextNode
?
mPreviousNode
:
mNextNode
;
}
nsIContent
*
GetPreviousNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mPreviousNode
;
}
nsIContent
*
GetNextNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
!
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mNextNode
;
}
EditorDOMPoint
SplitPoint
(
)
const
{
if
(
Failed
(
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
EditorDOMPoint
(
mGivenSplitPoint
)
;
}
if
(
!
mPreviousNode
)
{
return
EditorDOMPoint
(
mNextNode
)
;
}
EditorDOMPoint
point
(
mPreviousNode
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
previous
node
"
)
;
return
point
;
}
SplitNodeResult
(
nsIContent
*
aPreviousNodeOfSplitPoint
nsIContent
*
aNextNodeOfSplitPoint
)
:
mPreviousNode
(
aPreviousNodeOfSplitPoint
)
mNextNode
(
aNextNodeOfSplitPoint
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPreviousNode
|
|
mNextNode
)
;
}
explicit
SplitNodeResult
(
const
EditorRawDOMPoint
&
aGivenSplitPoint
)
:
mGivenSplitPoint
(
aGivenSplitPoint
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mGivenSplitPoint
.
IsSet
(
)
)
;
}
explicit
SplitNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
private
:
nsCOMPtr
<
nsIContent
>
mPreviousNode
;
nsCOMPtr
<
nsIContent
>
mNextNode
;
EditorDOMPoint
mGivenSplitPoint
;
nsresult
mRv
;
SplitNodeResult
(
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
SplitRangeOffFromNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
nsIContent
*
GetLeftContent
(
)
const
{
return
mLeftContent
;
}
dom
:
:
Element
*
GetLeftContentAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mLeftContent
)
;
}
nsIContent
*
GetMiddleContent
(
)
const
{
return
mMiddleContent
;
}
dom
:
:
Element
*
GetMiddleContentAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mMiddleContent
)
;
}
nsIContent
*
GetRightContent
(
)
const
{
return
mRightContent
;
}
dom
:
:
Element
*
GetRightContentAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mRightContent
)
;
}
SplitRangeOffFromNodeResult
(
nsIContent
*
aLeftContent
nsIContent
*
aMiddleContent
nsIContent
*
aRightContent
)
:
mLeftContent
(
aLeftContent
)
mMiddleContent
(
aMiddleContent
)
mRightContent
(
aRightContent
)
mRv
(
NS_OK
)
{
}
SplitRangeOffFromNodeResult
(
SplitNodeResult
&
aSplitResultAtLeftOfMiddleNode
SplitNodeResult
&
aSplitResultAtRightOfMiddleNode
)
:
mRv
(
NS_OK
)
{
if
(
aSplitResultAtLeftOfMiddleNode
.
Succeeded
(
)
)
{
mLeftContent
=
aSplitResultAtLeftOfMiddleNode
.
GetPreviousNode
(
)
;
}
if
(
aSplitResultAtRightOfMiddleNode
.
Succeeded
(
)
)
{
mRightContent
=
aSplitResultAtRightOfMiddleNode
.
GetNextNode
(
)
;
mMiddleContent
=
aSplitResultAtRightOfMiddleNode
.
GetPreviousNode
(
)
;
}
if
(
!
mMiddleContent
&
&
aSplitResultAtLeftOfMiddleNode
.
Succeeded
(
)
)
{
mMiddleContent
=
aSplitResultAtLeftOfMiddleNode
.
GetNextNode
(
)
;
}
}
explicit
SplitRangeOffFromNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitRangeOffFromNodeResult
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
&
operator
=
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
SplitRangeOffFromNodeResult
&
operator
=
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
private
:
nsCOMPtr
<
nsIContent
>
mLeftContent
;
nsCOMPtr
<
nsIContent
>
mMiddleContent
;
nsCOMPtr
<
nsIContent
>
mRightContent
;
nsresult
mRv
;
SplitRangeOffFromNodeResult
(
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
SplitRangeOffResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
const
EditorDOMPoint
&
SplitPointAtStart
(
)
const
{
return
mSplitPointAtStart
;
}
const
EditorDOMPoint
&
SplitPointAtEnd
(
)
const
{
return
mSplitPointAtEnd
;
}
SplitRangeOffResult
(
)
=
delete
;
SplitRangeOffResult
(
const
EditorDOMPoint
&
aTrackedRangeStart
const
SplitNodeResult
&
aSplitNodeResultAtStart
const
EditorDOMPoint
&
aTrackedRangeEnd
const
SplitNodeResult
&
aSplitNodeResultAtEnd
)
:
mSplitPointAtStart
(
aTrackedRangeStart
)
mSplitPointAtEnd
(
aTrackedRangeEnd
)
mRv
(
NS_OK
)
mHandled
(
aSplitNodeResultAtStart
.
Handled
(
)
|
|
aSplitNodeResultAtEnd
.
Handled
(
)
)
{
MOZ_ASSERT
(
mSplitPointAtStart
.
IsSet
(
)
)
;
MOZ_ASSERT
(
mSplitPointAtEnd
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aSplitNodeResultAtStart
.
Succeeded
(
)
)
;
MOZ_ASSERT
(
aSplitNodeResultAtEnd
.
Succeeded
(
)
)
;
}
explicit
SplitRangeOffResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mHandled
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitRangeOffResult
(
const
SplitRangeOffResult
&
aOther
)
=
delete
;
SplitRangeOffResult
&
operator
=
(
const
SplitRangeOffResult
&
aOther
)
=
delete
;
SplitRangeOffResult
(
SplitRangeOffResult
&
&
aOther
)
=
default
;
SplitRangeOffResult
&
operator
=
(
SplitRangeOffResult
&
&
aOther
)
=
default
;
private
:
EditorDOMPoint
mSplitPointAtStart
;
EditorDOMPoint
mSplitPointAtEnd
;
nsresult
mRv
;
bool
mHandled
;
}
;
class
MOZ_RAII
AutoTransactionBatchExternal
final
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
AutoTransactionBatchExternal
(
EditorBase
&
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mEditorBase
.
BeginTransaction
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoTransactionBatchExternal
(
)
{
MOZ_KnownLive
(
mEditorBase
)
.
EndTransaction
(
)
;
}
private
:
EditorBase
&
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_STACK_CLASS
AutoRangeArray
final
{
public
:
explicit
AutoRangeArray
(
dom
:
:
Selection
*
aSelection
)
{
if
(
!
aSelection
)
{
return
;
}
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
mRanges
.
AppendElement
(
*
aSelection
-
>
GetRangeAt
(
i
)
)
;
}
}
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
}
;
class
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
=
0
;
}
;
class
MOZ_RAII
DOMIterator
{
public
:
explicit
DOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
explicit
DOMIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
virtual
~
DOMIterator
(
)
=
default
;
nsresult
Init
(
nsRange
&
aRange
)
;
nsresult
Init
(
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
)
;
void
AppendList
(
const
BoolDomIterFunctor
&
functor
nsTArray
<
mozilla
:
:
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
const
;
protected
:
ContentIteratorBase
*
mIter
;
PostContentIterator
mPostOrderIter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
DOMSubtreeIterator
final
:
public
DOMIterator
{
public
:
explicit
DOMSubtreeIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
virtual
~
DOMSubtreeIterator
(
)
=
default
;
nsresult
Init
(
nsRange
&
aRange
)
;
private
:
ContentSubtreeIterator
mSubtreeIter
;
explicit
DOMSubtreeIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
=
delete
;
}
;
class
TrivialFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
true
;
}
}
;
class
EditorUtils
final
{
public
:
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
=
nullptr
)
;
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
;
static
void
MaskString
(
nsString
&
aString
dom
:
:
Text
*
aText
uint32_t
aStartOffsetInString
uint32_t
aStartOffsetInText
)
;
}
;
}
#
endif
