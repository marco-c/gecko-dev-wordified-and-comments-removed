#
ifndef
mozilla_EditorUtils_h
#
define
mozilla_EditorUtils_h
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
class
nsITransferable
;
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
class
MOZ_STACK_CLASS
EditActionResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Canceled
(
)
const
{
return
mCanceled
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
bool
Ignored
(
)
const
{
return
!
mCanceled
&
&
!
mHandled
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
EditActionResult
SetResult
(
nsresult
aRv
)
{
mRv
=
aRv
;
return
*
this
;
}
EditActionResult
MarkAsCanceled
(
)
{
mCanceled
=
true
;
return
*
this
;
}
EditActionResult
MarkAsHandled
(
)
{
mHandled
=
true
;
return
*
this
;
}
explicit
EditActionResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
EditActionResult
&
operator
|
=
(
const
EditActionResult
&
aOther
)
{
mCanceled
|
=
aOther
.
mCanceled
;
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aOther
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
}
else
if
(
Failed
(
)
|
|
aOther
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
}
else
{
mRv
=
NS_OK
;
}
return
*
this
;
}
EditActionResult
&
operator
|
=
(
const
MoveNodeResult
&
aMoveNodeResult
)
;
private
:
nsresult
mRv
;
bool
mCanceled
;
bool
mHandled
;
EditActionResult
(
nsresult
aRv
bool
aCanceled
bool
aHandled
)
:
mRv
(
aRv
)
mCanceled
(
aCanceled
)
mHandled
(
aHandled
)
{
}
EditActionResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
friend
EditActionResult
EditActionIgnored
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionHandled
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionCanceled
(
nsresult
aRv
)
;
}
;
inline
EditActionResult
EditActionIgnored
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
false
)
;
}
inline
EditActionResult
EditActionHandled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
true
)
;
}
inline
EditActionResult
EditActionCanceled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
true
true
)
;
}
template
<
typename
NodeType
>
class
CreateNodeResultBase
;
typedef
CreateNodeResultBase
<
dom
:
:
Element
>
CreateElementResult
;
template
<
typename
NodeType
>
class
MOZ_STACK_CLASS
CreateNodeResultBase
final
{
typedef
CreateNodeResultBase
<
NodeType
>
SelfType
;
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
NodeType
*
GetNewNode
(
)
const
{
return
mNode
;
}
CreateNodeResultBase
(
)
=
delete
;
explicit
CreateNodeResultBase
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
explicit
CreateNodeResultBase
(
NodeType
*
aNode
)
:
mNode
(
aNode
)
mRv
(
aNode
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
explicit
CreateNodeResultBase
(
RefPtr
<
NodeType
>
&
&
aNode
)
:
mNode
(
std
:
:
move
(
aNode
)
)
mRv
(
mNode
.
get
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
CreateNodeResultBase
(
const
SelfType
&
aOther
)
=
delete
;
SelfType
&
operator
=
(
const
SelfType
&
aOther
)
=
delete
;
CreateNodeResultBase
(
SelfType
&
&
aOther
)
=
default
;
SelfType
&
operator
=
(
SelfType
&
&
aOther
)
=
default
;
already_AddRefed
<
NodeType
>
forget
(
)
{
mRv
=
NS_ERROR_NOT_INITIALIZED
;
return
mNode
.
forget
(
)
;
}
private
:
RefPtr
<
NodeType
>
mNode
;
nsresult
mRv
;
}
;
class
MOZ_RAII
AutoTransactionBatchExternal
final
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
AutoTransactionBatchExternal
(
EditorBase
&
aEditorBase
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_KnownLive
(
mEditorBase
)
.
BeginTransaction
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoTransactionBatchExternal
(
)
{
MOZ_KnownLive
(
mEditorBase
)
.
EndTransaction
(
)
;
}
private
:
EditorBase
&
mEditorBase
;
}
;
class
MOZ_STACK_CLASS
AutoSelectionRangeArray
final
{
public
:
explicit
AutoSelectionRangeArray
(
dom
:
:
Selection
&
aSelection
)
{
for
(
const
uint32_t
i
:
IntegerRange
(
aSelection
.
RangeCount
(
)
)
)
{
MOZ_ASSERT
(
aSelection
.
GetRangeAt
(
i
)
)
;
mRanges
.
AppendElement
(
*
aSelection
.
GetRangeAt
(
i
)
)
;
}
}
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
}
;
class
MOZ_STACK_CLASS
AutoRangeArray
final
{
public
:
explicit
AutoRangeArray
(
const
dom
:
:
Selection
&
aSelection
)
{
Initialize
(
aSelection
)
;
}
void
Initialize
(
const
dom
:
:
Selection
&
aSelection
)
{
mDirection
=
aSelection
.
GetDirection
(
)
;
mRanges
.
Clear
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
aSelection
.
RangeCount
(
)
)
)
{
MOZ_ASSERT
(
aSelection
.
GetRangeAt
(
i
)
)
;
mRanges
.
AppendElement
(
aSelection
.
GetRangeAt
(
i
)
-
>
CloneRange
(
)
)
;
if
(
aSelection
.
GetRangeAt
(
i
)
=
=
aSelection
.
GetAnchorFocusRange
(
)
)
{
mAnchorFocusRange
=
mRanges
.
LastElement
(
)
;
}
}
}
void
EnsureOnlyEditableRanges
(
const
dom
:
:
Element
&
aEditingHost
)
;
void
EnsureRangesInTextNode
(
const
dom
:
:
Text
&
aTextNode
)
;
static
bool
IsEditableRange
(
const
dom
:
:
AbstractRange
&
aRange
const
dom
:
:
Element
&
aEditingHost
)
;
bool
IsAtLeastOneContainerOfRangeBoundariesInclusiveDescendantOf
(
const
nsIContent
&
aContent
)
const
{
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
&
&
startContainer
-
>
IsInclusiveDescendantOf
(
&
aContent
)
)
{
return
true
;
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
&
&
endContainer
-
>
IsInclusiveDescendantOf
(
&
aContent
)
)
{
return
true
;
}
}
return
false
;
}
auto
&
Ranges
(
)
{
return
mRanges
;
}
const
auto
&
Ranges
(
)
const
{
return
mRanges
;
}
auto
&
FirstRangeRef
(
)
{
return
mRanges
[
0
]
;
}
const
auto
&
FirstRangeRef
(
)
const
{
return
mRanges
[
0
]
;
}
template
<
template
<
typename
>
typename
StrongPtrType
>
AutoTArray
<
StrongPtrType
<
nsRange
>
8
>
CloneRanges
(
)
const
{
AutoTArray
<
StrongPtrType
<
nsRange
>
8
>
ranges
;
for
(
const
auto
&
range
:
mRanges
)
{
ranges
.
AppendElement
(
range
-
>
CloneRange
(
)
)
;
}
return
ranges
;
}
EditorDOMPoint
GetStartPointOfFirstRange
(
)
const
{
if
(
mRanges
.
IsEmpty
(
)
|
|
!
mRanges
[
0
]
-
>
IsPositioned
(
)
)
{
return
EditorDOMPoint
(
)
;
}
return
EditorDOMPoint
(
mRanges
[
0
]
-
>
StartRef
(
)
)
;
}
EditorDOMPoint
GetEndPointOfFirstRange
(
)
const
{
if
(
mRanges
.
IsEmpty
(
)
|
|
!
mRanges
[
0
]
-
>
IsPositioned
(
)
)
{
return
EditorDOMPoint
(
)
;
}
return
EditorDOMPoint
(
mRanges
[
0
]
-
>
EndRef
(
)
)
;
}
nsresult
SelectNode
(
nsINode
&
aNode
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
mAnchorFocusRange
=
nsRange
:
:
Create
(
&
aNode
)
;
if
(
!
mAnchorFocusRange
)
{
return
NS_ERROR_FAILURE
;
}
}
ErrorResult
error
;
mAnchorFocusRange
-
>
SelectNode
(
aNode
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
nsIEditor
:
:
EDirection
nsresult
>
ExtendAnchorFocusRangeFor
(
const
EditorBase
&
aEditorBase
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
enum
class
IfSelectingOnlyOneAtomicContent
{
Collapse
KeepSelecting
}
;
Result
<
bool
nsresult
>
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
IfSelectingOnlyOneAtomicContent
aIfSelectingOnlyOneAtomicContent
const
dom
:
:
Element
*
aEditingHost
)
;
bool
IsCollapsed
(
)
const
{
return
mRanges
.
IsEmpty
(
)
|
|
(
mRanges
.
Length
(
)
=
=
1
&
&
mRanges
[
0
]
-
>
Collapsed
(
)
)
;
}
template
<
typename
PT
typename
CT
>
nsresult
Collapse
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
ErrorResult
error
;
mAnchorFocusRange
=
nsRange
:
:
Create
(
aPoint
.
ToRawRangeBoundary
(
)
aPoint
.
ToRawRangeBoundary
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
mAnchorFocusRange
-
>
CollapseTo
(
aPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mAnchorFocusRange
=
nullptr
;
return
rv
;
}
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
template
<
typename
SPT
typename
SCT
typename
EPT
typename
ECT
>
nsresult
SetStartAndEnd
(
const
EditorDOMPointBase
<
SPT
SCT
>
&
aStart
const
EditorDOMPointBase
<
EPT
ECT
>
&
aEnd
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
ErrorResult
error
;
mAnchorFocusRange
=
nsRange
:
:
Create
(
aStart
.
ToRawRangeBoundary
(
)
aEnd
.
ToRawRangeBoundary
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
mAnchorFocusRange
-
>
SetStartAndEnd
(
aStart
.
ToRawRangeBoundary
(
)
aEnd
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mAnchorFocusRange
=
nullptr
;
return
rv
;
}
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
const
nsRange
*
GetAnchorFocusRange
(
)
const
{
return
mAnchorFocusRange
;
}
nsDirection
GetDirection
(
)
const
{
return
mDirection
;
}
const
RangeBoundary
&
AnchorRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmptyRangeBoundary
;
return
sEmptyRangeBoundary
;
}
return
mDirection
=
=
nsDirection
:
:
eDirNext
?
mAnchorFocusRange
-
>
StartRef
(
)
:
mAnchorFocusRange
-
>
EndRef
(
)
;
}
nsINode
*
GetAnchorNode
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
Container
(
)
:
nullptr
;
}
uint32_t
GetAnchorOffset
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
.
valueOr
(
0
)
:
0
;
}
nsIContent
*
GetChildAtAnchorOffset
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
GetChildAtOffset
(
)
:
nullptr
;
}
const
RangeBoundary
&
FocusRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmptyRangeBoundary
;
return
sEmptyRangeBoundary
;
}
return
mDirection
=
=
nsDirection
:
:
eDirNext
?
mAnchorFocusRange
-
>
EndRef
(
)
:
mAnchorFocusRange
-
>
StartRef
(
)
;
}
nsINode
*
GetFocusNode
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
Container
(
)
:
nullptr
;
}
uint32_t
FocusOffset
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
.
valueOr
(
0
)
:
0
;
}
nsIContent
*
GetChildAtFocusOffset
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
GetChildAtOffset
(
)
:
nullptr
;
}
void
RemoveAllRanges
(
)
{
mRanges
.
Clear
(
)
;
mAnchorFocusRange
=
nullptr
;
mDirection
=
nsDirection
:
:
eDirNext
;
}
private
:
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
RefPtr
<
nsRange
>
mAnchorFocusRange
;
nsDirection
mDirection
=
nsDirection
:
:
eDirNext
;
}
;
class
EditorUtils
final
{
public
:
using
EditorType
=
EditorBase
:
:
EditorType
;
using
Selection
=
dom
:
:
Selection
;
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
=
nullptr
)
;
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
;
static
bool
IsPaddingBRElementForEmptyEditor
(
const
nsIContent
&
aContent
)
{
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
;
return
brElement
&
&
brElement
-
>
IsPaddingForEmptyEditor
(
)
;
}
static
bool
IsPaddingBRElementForEmptyLastLine
(
const
nsIContent
&
aContent
)
{
const
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
&
aContent
)
;
return
brElement
&
&
brElement
-
>
IsPaddingForEmptyLastLine
(
)
;
}
static
bool
IsEditableContent
(
const
nsIContent
&
aContent
EditorType
aEditorType
)
{
if
(
aEditorType
=
=
EditorType
:
:
HTML
&
&
(
!
aContent
.
IsEditable
(
)
|
|
!
aContent
.
IsInComposedDoc
(
)
)
)
{
return
false
;
}
return
IsElementOrText
(
aContent
)
;
}
static
bool
IsElementOrText
(
const
nsIContent
&
aContent
)
{
if
(
aContent
.
IsText
(
)
)
{
return
true
;
}
return
aContent
.
IsElement
(
)
&
&
!
IsPaddingBRElementForEmptyEditor
(
aContent
)
;
}
static
bool
IsWhiteSpacePreformatted
(
const
nsIContent
&
aContent
)
;
static
bool
IsNewLinePreformatted
(
const
nsIContent
&
aContent
)
;
static
bool
IsOnlyNewLinePreformatted
(
const
nsIContent
&
aContent
)
;
static
void
MaskString
(
nsString
&
aString
const
dom
:
:
Text
&
aTextNode
uint32_t
aStartOffsetInString
uint32_t
aStartOffsetInText
)
;
static
nsStaticAtom
*
GetTagNameAtom
(
const
nsAString
&
aTagName
)
{
if
(
aTagName
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsAutoString
lowerTagName
;
nsContentUtils
:
:
ASCIIToLower
(
aTagName
lowerTagName
)
;
return
NS_GetStaticAtom
(
lowerTagName
)
;
}
static
nsStaticAtom
*
GetAttributeAtom
(
const
nsAString
&
aAttribute
)
{
if
(
aAttribute
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
NS_GetStaticAtom
(
aAttribute
)
;
}
template
<
typename
SelectionOrAutoRangeArray
>
static
bool
IsFrameSelectionRequiredToExtendSelection
(
nsIEditor
:
:
EDirection
aDirectionAndAmount
SelectionOrAutoRangeArray
&
aSelectionOrAutoRangeArray
)
{
switch
(
aDirectionAndAmount
)
{
case
nsIEditor
:
:
eNextWord
:
case
nsIEditor
:
:
ePreviousWord
:
case
nsIEditor
:
:
eToBeginningOfLine
:
case
nsIEditor
:
:
eToEndOfLine
:
return
true
;
case
nsIEditor
:
:
ePrevious
:
case
nsIEditor
:
:
eNext
:
return
aSelectionOrAutoRangeArray
.
IsCollapsed
(
)
;
default
:
return
false
;
}
}
static
bool
IsPointInSelection
(
const
Selection
&
aSelection
const
nsINode
&
aParentNode
uint32_t
aOffset
)
;
static
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
CreateTransferableForPlainText
(
const
dom
:
:
Document
&
aDocument
)
;
}
;
}
#
endif
