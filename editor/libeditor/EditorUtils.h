#
ifndef
EditorUtils_h
#
define
EditorUtils_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsEditor
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
class
nsIAtom
;
class
nsIContentIterator
;
class
nsIDOMDocument
;
class
nsIDOMEvent
;
class
nsISimpleEnumerator
;
class
nsITransferable
;
class
nsRange
;
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
namespace
dom
{
class
Selection
;
}
}
class
MOZ_RAII
nsAutoPlaceHolderBatch
{
private
:
nsCOMPtr
<
nsIEditor
>
mEd
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
nsAutoPlaceHolderBatch
(
nsIEditor
*
aEd
nsIAtom
*
atom
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEd
(
do_QueryInterface
(
aEd
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mEd
)
{
mEd
-
>
BeginPlaceHolderTransaction
(
atom
)
;
}
}
~
nsAutoPlaceHolderBatch
(
)
{
if
(
mEd
)
{
mEd
-
>
EndPlaceHolderTransaction
(
)
;
}
}
}
;
class
MOZ_RAII
nsAutoEditBatch
:
public
nsAutoPlaceHolderBatch
{
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
nsAutoEditBatch
(
nsIEditor
*
aEd
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
nsAutoPlaceHolderBatch
(
aEd
nullptr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
nsAutoEditBatch
(
)
{
}
}
;
class
MOZ_RAII
nsAutoSelectionReset
{
private
:
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mSel
;
nsEditor
*
mEd
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
nsAutoSelectionReset
(
mozilla
:
:
dom
:
:
Selection
*
aSel
nsEditor
*
aEd
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
nsAutoSelectionReset
(
)
;
void
Abort
(
)
;
}
;
class
MOZ_RAII
nsAutoRules
{
public
:
nsAutoRules
(
nsEditor
*
ed
EditAction
action
nsIEditor
:
:
EDirection
aDirection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEd
(
ed
)
mDoNothing
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mEd
&
&
!
mEd
-
>
mAction
)
{
mEd
-
>
StartOperation
(
action
aDirection
)
;
}
else
mDoNothing
=
true
;
}
~
nsAutoRules
(
)
{
if
(
mEd
&
&
!
mDoNothing
)
{
mEd
-
>
EndOperation
(
)
;
}
}
protected
:
nsEditor
*
mEd
;
bool
mDoNothing
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
nsAutoTxnsConserveSelection
{
public
:
explicit
nsAutoTxnsConserveSelection
(
nsEditor
*
ed
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEd
(
ed
)
mOldState
(
true
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mEd
)
{
mOldState
=
mEd
-
>
GetShouldTxnSetSelection
(
)
;
mEd
-
>
SetShouldTxnSetSelection
(
false
)
;
}
}
~
nsAutoTxnsConserveSelection
(
)
{
if
(
mEd
)
{
mEd
-
>
SetShouldTxnSetSelection
(
mOldState
)
;
}
}
protected
:
nsEditor
*
mEd
;
bool
mOldState
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
nsAutoUpdateViewBatch
{
public
:
explicit
nsAutoUpdateViewBatch
(
nsEditor
*
ed
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEd
(
ed
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
NS_ASSERTION
(
mEd
"
null
mEd
pointer
!
"
)
;
if
(
mEd
)
mEd
-
>
BeginUpdateViewBatch
(
)
;
}
~
nsAutoUpdateViewBatch
(
)
{
if
(
mEd
)
mEd
-
>
EndUpdateViewBatch
(
)
;
}
protected
:
nsEditor
*
mEd
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
nsBoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
=
0
;
}
;
class
MOZ_RAII
nsDOMIterator
{
public
:
explicit
nsDOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
explicit
nsDOMIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
virtual
~
nsDOMIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
void
AppendList
(
const
nsBoolDomIterFunctor
&
functor
nsTArray
<
mozilla
:
:
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
const
;
protected
:
nsCOMPtr
<
nsIContentIterator
>
mIter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
nsDOMSubtreeIterator
:
public
nsDOMIterator
{
public
:
explicit
nsDOMSubtreeIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
virtual
~
nsDOMSubtreeIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
}
;
namespace
mozilla
{
class
TrivialFunctor
final
:
public
nsBoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
{
return
true
;
}
}
;
struct
MOZ_STACK_CLASS
EditorDOMPoint
final
{
nsCOMPtr
<
nsINode
>
node
;
int32_t
offset
;
EditorDOMPoint
(
)
:
node
(
nullptr
)
offset
(
-
1
)
{
}
EditorDOMPoint
(
nsINode
*
aNode
int32_t
aOffset
)
:
node
(
aNode
)
offset
(
aOffset
)
{
}
EditorDOMPoint
(
nsIDOMNode
*
aNode
int32_t
aOffset
)
:
node
(
do_QueryInterface
(
aNode
)
)
offset
(
aOffset
)
{
}
void
SetPoint
(
nsINode
*
aNode
int32_t
aOffset
)
{
node
=
aNode
;
offset
=
aOffset
;
}
void
SetPoint
(
nsIDOMNode
*
aNode
int32_t
aOffset
)
{
node
=
do_QueryInterface
(
aNode
)
;
offset
=
aOffset
;
}
}
;
class
EditorUtils
final
{
public
:
static
bool
IsDescendantOf
(
nsINode
*
aNode
nsINode
*
aParent
int32_t
*
aOffset
=
0
)
;
static
bool
IsDescendantOf
(
nsIDOMNode
*
aNode
nsIDOMNode
*
aParent
int32_t
*
aOffset
=
0
)
;
static
bool
IsLeafNode
(
nsIDOMNode
*
aNode
)
;
}
;
class
EditorHookUtils
final
{
public
:
static
bool
DoInsertionHook
(
nsIDOMDocument
*
aDoc
nsIDOMEvent
*
aEvent
nsITransferable
*
aTrans
)
;
private
:
static
nsresult
GetHookEnumeratorFromDocument
(
nsIDOMDocument
*
aDoc
nsISimpleEnumerator
*
*
aEnumerator
)
;
}
;
}
#
endif
