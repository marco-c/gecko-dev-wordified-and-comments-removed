#
ifndef
mozilla_EditorUtils_h
#
define
mozilla_EditorUtils_h
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nscore
.
h
"
class
nsAtom
;
class
nsIContentIterator
;
class
nsISimpleEnumerator
;
class
nsITransferable
;
class
nsRange
;
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
namespace
dom
{
class
Element
;
class
Text
;
}
class
MOZ_STACK_CLASS
EditActionResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
Canceled
(
)
const
{
return
mCanceled
;
}
bool
Handled
(
)
const
{
return
mHandled
;
}
bool
EditorDestroyed
(
)
const
{
return
mRv
=
=
NS_ERROR_EDITOR_DESTROYED
;
}
EditActionResult
SetResult
(
nsresult
aRv
)
{
mRv
=
aRv
;
return
*
this
;
}
EditActionResult
MarkAsCanceled
(
)
{
mCanceled
=
true
;
return
*
this
;
}
EditActionResult
MarkAsHandled
(
)
{
mHandled
=
true
;
return
*
this
;
}
explicit
EditActionResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
EditActionResult
&
operator
|
=
(
const
EditActionResult
&
aOther
)
{
mCanceled
|
=
aOther
.
mCanceled
;
mHandled
|
=
aOther
.
mHandled
;
if
(
mRv
=
=
aOther
.
mRv
)
{
return
*
this
;
}
if
(
EditorDestroyed
(
)
|
|
aOther
.
EditorDestroyed
(
)
)
{
mRv
=
NS_ERROR_EDITOR_DESTROYED
;
}
else
if
(
Failed
(
)
|
|
aOther
.
Failed
(
)
)
{
mRv
=
NS_ERROR_FAILURE
;
}
else
{
mRv
=
NS_OK
;
}
return
*
this
;
}
private
:
nsresult
mRv
;
bool
mCanceled
;
bool
mHandled
;
EditActionResult
(
nsresult
aRv
bool
aCanceled
bool
aHandled
)
:
mRv
(
aRv
)
mCanceled
(
aCanceled
)
mHandled
(
aHandled
)
{
}
EditActionResult
(
)
:
mRv
(
NS_ERROR_NOT_INITIALIZED
)
mCanceled
(
false
)
mHandled
(
false
)
{
}
friend
EditActionResult
EditActionIgnored
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionHandled
(
nsresult
aRv
)
;
friend
EditActionResult
EditActionCanceled
(
nsresult
aRv
)
;
}
;
inline
EditActionResult
EditActionIgnored
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
false
)
;
}
inline
EditActionResult
EditActionHandled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
false
true
)
;
}
inline
EditActionResult
EditActionCanceled
(
nsresult
aRv
=
NS_OK
)
{
return
EditActionResult
(
aRv
true
true
)
;
}
template
<
typename
NodeType
>
class
CreateNodeResultBase
;
typedef
CreateNodeResultBase
<
dom
:
:
Element
>
CreateElementResult
;
template
<
typename
NodeType
>
class
MOZ_STACK_CLASS
CreateNodeResultBase
final
{
typedef
CreateNodeResultBase
<
NodeType
>
SelfType
;
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
NodeType
*
GetNewNode
(
)
const
{
return
mNode
;
}
CreateNodeResultBase
(
)
=
delete
;
explicit
CreateNodeResultBase
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
explicit
CreateNodeResultBase
(
NodeType
*
aNode
)
:
mNode
(
aNode
)
mRv
(
aNode
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
explicit
CreateNodeResultBase
(
already_AddRefed
<
NodeType
>
&
&
aNode
)
:
mNode
(
aNode
)
mRv
(
mNode
.
get
(
)
?
NS_OK
:
NS_ERROR_FAILURE
)
{
}
CreateNodeResultBase
(
const
SelfType
&
aOther
)
=
delete
;
SelfType
&
operator
=
(
const
SelfType
&
aOther
)
=
delete
;
CreateNodeResultBase
(
SelfType
&
&
aOther
)
=
default
;
SelfType
&
operator
=
(
SelfType
&
&
aOther
)
=
default
;
already_AddRefed
<
NodeType
>
forget
(
)
{
mRv
=
NS_ERROR_NOT_INITIALIZED
;
return
mNode
.
forget
(
)
;
}
private
:
RefPtr
<
NodeType
>
mNode
;
nsresult
mRv
;
}
;
class
MOZ_STACK_CLASS
SplitNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
bool
DidSplit
(
)
const
{
return
mPreviousNode
&
&
mNextNode
;
}
nsIContent
*
GetLeftNode
(
)
const
{
return
mPreviousNode
&
&
mNextNode
?
mPreviousNode
.
get
(
)
:
nullptr
;
}
nsIContent
*
GetRightNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
GetChild
(
)
;
}
return
mPreviousNode
&
&
!
mNextNode
?
mPreviousNode
:
mNextNode
;
}
nsIContent
*
GetPreviousNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mPreviousNode
;
}
nsIContent
*
GetNextNode
(
)
const
{
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
!
mGivenSplitPoint
.
IsEndOfContainer
(
)
?
mGivenSplitPoint
.
GetChild
(
)
:
nullptr
;
}
return
mNextNode
;
}
EditorRawDOMPoint
SplitPoint
(
)
const
{
if
(
Failed
(
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
mGivenSplitPoint
.
IsSet
(
)
)
{
return
EditorRawDOMPoint
(
mGivenSplitPoint
)
;
}
if
(
!
mPreviousNode
)
{
return
EditorRawDOMPoint
(
mNextNode
)
;
}
EditorRawDOMPoint
point
(
mPreviousNode
)
;
DebugOnly
<
bool
>
advanced
=
point
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
previous
node
"
)
;
return
point
;
}
SplitNodeResult
(
nsIContent
*
aPreviousNodeOfSplitPoint
nsIContent
*
aNextNodeOfSplitPoint
)
:
mPreviousNode
(
aPreviousNodeOfSplitPoint
)
mNextNode
(
aNextNodeOfSplitPoint
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPreviousNode
|
|
mNextNode
)
;
}
explicit
SplitNodeResult
(
const
EditorRawDOMPoint
&
aGivenSplitPoint
)
:
mGivenSplitPoint
(
aGivenSplitPoint
)
mRv
(
NS_OK
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mGivenSplitPoint
.
IsSet
(
)
)
;
}
explicit
SplitNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
private
:
nsCOMPtr
<
nsIContent
>
mPreviousNode
;
nsCOMPtr
<
nsIContent
>
mNextNode
;
EditorDOMPoint
mGivenSplitPoint
;
nsresult
mRv
;
SplitNodeResult
(
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
SplitRangeOffFromNodeResult
final
{
public
:
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mRv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mRv
)
;
}
nsresult
Rv
(
)
const
{
return
mRv
;
}
nsIContent
*
GetLeftContent
(
)
const
{
return
mLeftContent
;
}
dom
:
:
Element
*
GetLeftContentAsElement
(
)
const
{
return
Element
:
:
FromNodeOrNull
(
mLeftContent
)
;
}
nsIContent
*
GetMiddleContent
(
)
const
{
return
mMiddleContent
;
}
dom
:
:
Element
*
GetMiddleContentAsElement
(
)
const
{
return
Element
:
:
FromNodeOrNull
(
mMiddleContent
)
;
}
nsIContent
*
GetRightContent
(
)
const
{
return
mRightContent
;
}
dom
:
:
Element
*
GetRightContentAsElement
(
)
const
{
return
Element
:
:
FromNodeOrNull
(
mRightContent
)
;
}
SplitRangeOffFromNodeResult
(
nsIContent
*
aLeftContent
nsIContent
*
aMiddleContent
nsIContent
*
aRightContent
)
:
mLeftContent
(
aLeftContent
)
mMiddleContent
(
aMiddleContent
)
mRightContent
(
aRightContent
)
mRv
(
NS_OK
)
{
}
SplitRangeOffFromNodeResult
(
SplitNodeResult
&
aSplitResultAtLeftOfMiddleNode
SplitNodeResult
&
aSplitResultAtRightOfMiddleNode
)
:
mRv
(
NS_OK
)
{
if
(
aSplitResultAtLeftOfMiddleNode
.
Succeeded
(
)
)
{
mLeftContent
=
aSplitResultAtLeftOfMiddleNode
.
GetPreviousNode
(
)
;
}
if
(
aSplitResultAtRightOfMiddleNode
.
Succeeded
(
)
)
{
mRightContent
=
aSplitResultAtRightOfMiddleNode
.
GetNextNode
(
)
;
mMiddleContent
=
aSplitResultAtRightOfMiddleNode
.
GetPreviousNode
(
)
;
}
if
(
!
mMiddleContent
&
&
aSplitResultAtLeftOfMiddleNode
.
Succeeded
(
)
)
{
mMiddleContent
=
aSplitResultAtLeftOfMiddleNode
.
GetNextNode
(
)
;
}
}
explicit
SplitRangeOffFromNodeResult
(
nsresult
aRv
)
:
mRv
(
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
mRv
)
)
;
}
SplitRangeOffFromNodeResult
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
&
operator
=
(
const
SplitRangeOffFromNodeResult
&
aOther
)
=
delete
;
SplitRangeOffFromNodeResult
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
SplitRangeOffFromNodeResult
&
operator
=
(
SplitRangeOffFromNodeResult
&
&
aOther
)
=
default
;
private
:
nsCOMPtr
<
nsIContent
>
mLeftContent
;
nsCOMPtr
<
nsIContent
>
mMiddleContent
;
nsCOMPtr
<
nsIContent
>
mRightContent
;
nsresult
mRv
;
SplitRangeOffFromNodeResult
(
)
=
delete
;
}
;
class
MOZ_RAII
AutoPlaceholderBatch
final
{
private
:
RefPtr
<
EditorBase
>
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoPlaceholderBatch
(
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
BeginPlaceholderTransaction
(
nullptr
)
;
}
AutoPlaceholderBatch
(
EditorBase
*
aEditorBase
nsAtom
*
aTransactionName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
BeginPlaceholderTransaction
(
aTransactionName
)
;
}
~
AutoPlaceholderBatch
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
EndPlaceholderTransaction
(
)
;
}
}
private
:
void
BeginPlaceholderTransaction
(
nsAtom
*
aTransactionName
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
BeginPlaceholderTransaction
(
aTransactionName
)
;
}
}
}
;
class
MOZ_RAII
AutoSelectionRestorer
final
{
private
:
RefPtr
<
dom
:
:
Selection
>
mSelection
;
EditorBase
*
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
AutoSelectionRestorer
(
dom
:
:
Selection
*
aSelection
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
AutoSelectionRestorer
(
)
;
void
Abort
(
)
;
}
;
class
MOZ_RAII
AutoTopLevelEditSubActionNotifier
final
{
public
:
AutoTopLevelEditSubActionNotifier
(
EditorBase
&
aEditorBase
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
mDoNothing
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
!
mEditorBase
.
mTopLevelEditSubAction
)
{
mEditorBase
.
OnStartToHandleTopLevelEditSubAction
(
aEditSubAction
aDirection
)
;
}
else
{
mDoNothing
=
true
;
}
}
~
AutoTopLevelEditSubActionNotifier
(
)
{
if
(
!
mDoNothing
)
{
mEditorBase
.
OnEndHandlingTopLevelEditSubAction
(
)
;
}
}
protected
:
EditorBase
&
mEditorBase
;
bool
mDoNothing
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoTransactionsConserveSelection
final
{
public
:
explicit
AutoTransactionsConserveSelection
(
EditorBase
&
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
mAllowedTransactionsToChangeSelection
(
aEditorBase
.
AllowsTransactionsToChangeSelection
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mEditorBase
.
MakeThisAllowTransactionsToChangeSelection
(
false
)
;
}
~
AutoTransactionsConserveSelection
(
)
{
mEditorBase
.
MakeThisAllowTransactionsToChangeSelection
(
mAllowedTransactionsToChangeSelection
)
;
}
protected
:
EditorBase
&
mEditorBase
;
bool
mAllowedTransactionsToChangeSelection
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoUpdateViewBatch
final
{
public
:
explicit
AutoUpdateViewBatch
(
EditorBase
*
aEditorBase
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mEditorBase
(
aEditorBase
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
NS_ASSERTION
(
mEditorBase
"
null
mEditorBase
pointer
!
"
)
;
if
(
mEditorBase
)
{
mEditorBase
-
>
BeginUpdateViewBatch
(
)
;
}
}
~
AutoUpdateViewBatch
(
)
{
if
(
mEditorBase
)
{
mEditorBase
-
>
EndUpdateViewBatch
(
)
;
}
}
protected
:
EditorBase
*
mEditorBase
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_STACK_CLASS
AutoRangeArray
final
{
public
:
explicit
AutoRangeArray
(
dom
:
:
Selection
*
aSelection
)
{
if
(
!
aSelection
)
{
return
;
}
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
mRanges
.
AppendElement
(
*
aSelection
-
>
GetRangeAt
(
i
)
)
;
}
}
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
}
;
class
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
=
0
;
}
;
class
MOZ_RAII
DOMIterator
{
public
:
explicit
DOMIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
explicit
DOMIterator
(
nsINode
&
aNode
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
virtual
~
DOMIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
void
AppendList
(
const
BoolDomIterFunctor
&
functor
nsTArray
<
mozilla
:
:
OwningNonNull
<
nsINode
>
>
&
arrayOfNodes
)
const
;
protected
:
nsCOMPtr
<
nsIContentIterator
>
mIter
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
DOMSubtreeIterator
final
:
public
DOMIterator
{
public
:
explicit
DOMSubtreeIterator
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
virtual
~
DOMSubtreeIterator
(
)
;
nsresult
Init
(
nsRange
&
aRange
)
;
}
;
class
TrivialFunctor
final
:
public
BoolDomIterFunctor
{
public
:
virtual
bool
operator
(
)
(
nsINode
*
aNode
)
const
override
{
return
true
;
}
}
;
class
EditorUtils
final
{
public
:
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorRawDOMPoint
*
aOutPoint
=
nullptr
)
;
static
bool
IsDescendantOf
(
const
nsINode
&
aNode
const
nsINode
&
aParent
EditorDOMPoint
*
aOutPoint
)
;
}
;
}
#
endif
