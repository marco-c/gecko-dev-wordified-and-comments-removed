#
ifndef
mozilla_TextEditRules_h
#
define
mozilla_TextEditRules_h
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
class
EditSubActionInfo
;
class
HTMLEditor
;
class
HTMLEditRules
;
namespace
dom
{
class
HTMLBRElement
;
class
Selection
;
}
class
TextEditRules
{
protected
:
typedef
EditorBase
:
:
AutoSelectionRestorer
AutoSelectionRestorer
;
typedef
EditorBase
:
:
AutoEditSubActionNotifier
AutoEditSubActionNotifier
;
typedef
EditorBase
:
:
AutoTransactionsConserveSelection
AutoTransactionsConserveSelection
;
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
template
<
typename
T
>
using
OwningNonNull
=
OwningNonNull
<
T
>
;
NS_INLINE_DECL_REFCOUNTING
(
TextEditRules
)
TextEditRules
(
)
;
HTMLEditRules
*
AsHTMLEditRules
(
)
;
const
HTMLEditRules
*
AsHTMLEditRules
(
)
const
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
Init
(
TextEditor
*
aTextEditor
)
;
virtual
nsresult
DetachEditor
(
)
;
virtual
nsresult
BeforeEdit
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
AfterEdit
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
WillDoAction
(
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
DidDoAction
(
EditSubActionInfo
&
aInfo
nsresult
aResult
)
;
virtual
bool
DocumentIsEmpty
(
)
const
;
bool
DontEchoPassword
(
)
const
;
protected
:
virtual
~
TextEditRules
(
)
=
default
;
void
InitFields
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
WillSetText
(
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
int32_t
aMaxLength
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
CreateTrailingBRIfNeeded
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
CreatePaddingBRElementForEmptyEditorIfNeeded
(
)
;
MOZ_MUST_USE
nsresult
CollapseSelectionToTrailingBRIfNeeded
(
)
;
bool
IsPasswordEditor
(
)
const
;
bool
IsMaskingPassword
(
)
const
;
bool
IsSingleLineEditor
(
)
const
;
bool
IsPlaintextEditor
(
)
const
;
bool
IsReadonly
(
)
const
;
bool
IsDisabled
(
)
const
;
bool
IsMailEditor
(
)
const
;
private
:
TextEditor
*
MOZ_NON_OWNING_REF
mTextEditor
;
protected
:
class
MOZ_STACK_CLASS
AutoSafeEditorData
{
public
:
AutoSafeEditorData
(
TextEditRules
&
aTextEditRules
TextEditor
&
aTextEditor
)
:
mTextEditRules
(
aTextEditRules
)
mHTMLEditor
(
nullptr
)
{
if
(
mTextEditRules
.
mData
)
{
return
;
}
mTextEditor
=
&
aTextEditor
;
mHTMLEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
mTextEditRules
.
mData
=
this
;
}
~
AutoSafeEditorData
(
)
{
if
(
mTextEditRules
.
mData
!
=
this
)
{
return
;
}
mTextEditRules
.
mData
=
nullptr
;
}
TextEditor
&
TextEditorRef
(
)
const
{
return
*
mTextEditor
;
}
HTMLEditor
&
HTMLEditorRef
(
)
const
{
MOZ_ASSERT
(
mHTMLEditor
)
;
return
*
mHTMLEditor
;
}
private
:
TextEditRules
&
MOZ_NON_OWNING_REF
mTextEditRules
;
RefPtr
<
TextEditor
>
mTextEditor
;
HTMLEditor
*
MOZ_NON_OWNING_REF
mHTMLEditor
;
}
;
AutoSafeEditorData
*
mData
;
TextEditor
&
TextEditorRef
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
mData
-
>
TextEditorRef
(
)
;
}
const
RefPtr
<
Selection
>
&
SelectionRefPtr
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
TextEditorRef
(
)
.
SelectionRefPtr
(
)
;
}
bool
CanHandleEditAction
(
)
const
{
if
(
!
mTextEditor
)
{
return
false
;
}
if
(
mTextEditor
-
>
Destroyed
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mTextEditor
-
>
IsInitialized
(
)
)
;
return
true
;
}
#
ifdef
DEBUG
bool
IsEditorDataAvailable
(
)
const
{
return
!
!
mData
;
}
#
endif
#
ifdef
DEBUG
bool
mIsHandling
;
#
endif
bool
mIsHTMLEditRules
;
}
;
class
MOZ_STACK_CLASS
EditSubActionInfo
final
{
public
:
explicit
EditSubActionInfo
(
EditSubAction
aEditSubAction
)
:
mEditSubAction
(
aEditSubAction
)
inString
(
nullptr
)
outString
(
nullptr
)
outputFormat
(
nullptr
)
maxLength
(
-
1
)
flags
(
0
)
collapsedAction
(
nsIEditor
:
:
eNext
)
stripWrappers
(
nsIEditor
:
:
eStrip
)
entireList
(
false
)
bulletType
(
nullptr
)
alignType
(
nullptr
)
blockType
(
nullptr
)
{
}
EditSubAction
mEditSubAction
;
const
nsAString
*
inString
;
nsAString
*
outString
;
const
nsAString
*
outputFormat
;
int32_t
maxLength
;
uint32_t
flags
;
nsIEditor
:
:
EDirection
collapsedAction
;
nsIEditor
:
:
EStripWrappers
stripWrappers
;
bool
entireList
;
const
nsAString
*
bulletType
;
const
nsAString
*
alignType
;
const
nsAString
*
blockType
;
}
;
}
#
endif
