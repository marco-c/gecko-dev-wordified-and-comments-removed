#
ifndef
mozilla_TextEditRules_h
#
define
mozilla_TextEditRules_h
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
class
AutoLockRulesSniffing
;
class
EditSubActionInfo
;
class
HTMLEditor
;
class
HTMLEditRules
;
namespace
dom
{
class
Selection
;
}
class
TextEditRules
:
public
nsITimerCallback
public
nsINamed
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
template
<
typename
T
>
using
OwningNonNull
=
OwningNonNull
<
T
>
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
TextEditRules
nsITimerCallback
)
TextEditRules
(
)
;
HTMLEditRules
*
AsHTMLEditRules
(
)
;
const
HTMLEditRules
*
AsHTMLEditRules
(
)
const
;
virtual
nsresult
Init
(
TextEditor
*
aTextEditor
)
;
virtual
nsresult
SetInitialValue
(
const
nsAString
&
aValue
)
;
virtual
nsresult
DetachEditor
(
)
;
virtual
nsresult
BeforeEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
;
virtual
nsresult
AfterEdit
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
;
virtual
nsresult
WillDoAction
(
Selection
*
aSelection
EditSubActionInfo
&
aInfo
bool
*
aCancel
bool
*
aHandled
)
;
virtual
nsresult
DidDoAction
(
Selection
*
aSelection
EditSubActionInfo
&
aInfo
nsresult
aResult
)
;
virtual
bool
DocumentIsEmpty
(
)
;
virtual
nsresult
DocumentModified
(
)
;
protected
:
virtual
~
TextEditRules
(
)
;
public
:
void
ResetIMETextPWBuf
(
)
;
void
HandleNewLines
(
nsString
&
aString
)
;
static
void
FillBufWithPWChars
(
nsAString
*
aOutString
int32_t
aLength
)
;
bool
HasBogusNode
(
)
{
return
!
!
mBogusNode
;
}
protected
:
void
InitFields
(
)
;
MOZ_MUST_USE
nsresult
WillInsertText
(
EditSubAction
aEditSubAction
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
;
MOZ_MUST_USE
nsresult
WillInsertBreak
(
bool
*
aCancel
bool
*
aHandled
int32_t
aMaxLength
)
;
MOZ_MUST_USE
nsresult
WillSetText
(
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
int32_t
aMaxLength
)
;
MOZ_MUST_USE
nsresult
WillInsert
(
bool
*
aCancel
=
nullptr
)
;
MOZ_MUST_USE
nsresult
WillDeleteSelection
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_MUST_USE
nsresult
DeleteSelectionWithTransaction
(
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
;
MOZ_MUST_USE
nsresult
DidDeleteSelection
(
)
;
nsresult
WillSetTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillRemoveTextProperty
(
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
WillUndo
(
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidUndo
(
nsresult
aResult
)
;
nsresult
WillRedo
(
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidRedo
(
nsresult
aResult
)
;
nsresult
WillOutputText
(
const
nsAString
*
aInFormat
nsAString
*
aOutText
uint32_t
aFlags
bool
*
aOutCancel
bool
*
aHandled
)
;
MOZ_MUST_USE
nsresult
RemoveRedundantTrailingBR
(
)
;
MOZ_MUST_USE
nsresult
CreateTrailingBRIfNeeded
(
)
;
MOZ_MUST_USE
nsresult
CreateBogusNodeIfNeeded
(
)
;
nsresult
TruncateInsertionIfNeeded
(
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
;
void
RemoveIMETextFromPWBuf
(
uint32_t
&
aStart
nsAString
*
aIMEString
)
;
template
<
typename
PT
typename
CT
>
CreateElementResult
CreateBR
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
CreateElementResult
ret
=
CreateBRInternal
(
aPointToInsert
false
)
;
#
ifdef
DEBUG
if
(
!
CanHandleEditAction
(
)
)
{
MOZ_ASSERT
(
ret
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
#
endif
return
ret
;
}
template
<
typename
PT
typename
CT
>
CreateElementResult
CreateMozBR
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
)
{
CreateElementResult
ret
=
CreateBRInternal
(
aPointToInsert
true
)
;
#
ifdef
DEBUG
if
(
!
CanHandleEditAction
(
)
)
{
MOZ_ASSERT
(
ret
.
Rv
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
;
}
#
endif
return
ret
;
}
void
UndefineCaretBidiLevel
(
)
;
nsresult
CheckBidiLevelForDeletion
(
const
EditorRawDOMPoint
&
aSelectionPoint
nsIEditor
:
:
EDirection
aAction
bool
*
aCancel
)
;
MOZ_MUST_USE
nsresult
HideLastPWInput
(
)
;
MOZ_MUST_USE
nsresult
CollapseSelectionToTrailingBRIfNeeded
(
)
;
bool
IsPasswordEditor
(
)
const
;
bool
IsSingleLineEditor
(
)
const
;
bool
IsPlaintextEditor
(
)
const
;
bool
IsReadonly
(
)
const
;
bool
IsDisabled
(
)
const
;
bool
IsMailEditor
(
)
const
;
bool
DontEchoPassword
(
)
const
;
private
:
TextEditor
*
MOZ_NON_OWNING_REF
mTextEditor
;
template
<
typename
PT
typename
CT
>
CreateElementResult
CreateBRInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
bool
aCreateMozBR
)
;
protected
:
class
MOZ_STACK_CLASS
AutoSafeEditorData
{
public
:
AutoSafeEditorData
(
TextEditRules
&
aTextEditRules
TextEditor
&
aTextEditor
Selection
&
aSelection
)
:
mTextEditRules
(
aTextEditRules
)
mHTMLEditor
(
nullptr
)
{
if
(
mTextEditRules
.
mData
)
{
return
;
}
mTextEditor
=
&
aTextEditor
;
mHTMLEditor
=
aTextEditor
.
AsHTMLEditor
(
)
;
mSelection
=
&
aSelection
;
mTextEditRules
.
mData
=
this
;
}
~
AutoSafeEditorData
(
)
{
if
(
mTextEditRules
.
mData
!
=
this
)
{
return
;
}
mTextEditRules
.
mData
=
nullptr
;
}
TextEditor
&
TextEditorRef
(
)
const
{
return
*
mTextEditor
;
}
HTMLEditor
&
HTMLEditorRef
(
)
const
{
MOZ_ASSERT
(
mHTMLEditor
)
;
return
*
mHTMLEditor
;
}
Selection
&
SelectionRef
(
)
const
{
return
*
mSelection
;
}
private
:
TextEditRules
&
MOZ_NON_OWNING_REF
mTextEditRules
;
RefPtr
<
TextEditor
>
mTextEditor
;
HTMLEditor
*
MOZ_NON_OWNING_REF
mHTMLEditor
;
RefPtr
<
Selection
>
mSelection
;
}
;
AutoSafeEditorData
*
mData
;
TextEditor
&
TextEditorRef
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
mData
-
>
TextEditorRef
(
)
;
}
Selection
&
SelectionRef
(
)
const
{
MOZ_ASSERT
(
mData
)
;
return
mData
-
>
SelectionRef
(
)
;
}
bool
CanHandleEditAction
(
)
const
{
if
(
!
mTextEditor
)
{
return
false
;
}
if
(
mTextEditor
-
>
Destroyed
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mTextEditor
-
>
IsInitialized
(
)
)
;
return
true
;
}
#
ifdef
DEBUG
bool
IsEditorDataAvailable
(
)
const
{
return
!
!
mData
;
}
#
endif
inline
already_AddRefed
<
nsINode
>
GetTextNodeAroundSelectionStartContainer
(
)
;
nsString
mPasswordText
;
nsString
mPasswordIMEText
;
uint32_t
mPasswordIMEIndex
;
nsCOMPtr
<
nsIContent
>
mBogusNode
;
nsCOMPtr
<
nsINode
>
mCachedSelectionNode
;
uint32_t
mCachedSelectionOffset
;
uint32_t
mActionNesting
;
bool
mLockRulesSniffing
;
bool
mDidExplicitlySetInterline
;
bool
mDeleteBidiImmediately
;
bool
mIsHTMLEditRules
;
EditSubAction
mTopLevelEditSubAction
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mLastStart
;
uint32_t
mLastLength
;
friend
class
AutoLockRulesSniffing
;
}
;
class
MOZ_STACK_CLASS
EditSubActionInfo
final
{
public
:
explicit
EditSubActionInfo
(
EditSubAction
aEditSubAction
)
:
mEditSubAction
(
aEditSubAction
)
inString
(
nullptr
)
outString
(
nullptr
)
outputFormat
(
nullptr
)
maxLength
(
-
1
)
flags
(
0
)
collapsedAction
(
nsIEditor
:
:
eNext
)
stripWrappers
(
nsIEditor
:
:
eStrip
)
bOrdered
(
false
)
entireList
(
false
)
bulletType
(
nullptr
)
alignType
(
nullptr
)
blockType
(
nullptr
)
{
}
EditSubAction
mEditSubAction
;
const
nsAString
*
inString
;
nsAString
*
outString
;
const
nsAString
*
outputFormat
;
int32_t
maxLength
;
uint32_t
flags
;
nsIEditor
:
:
EDirection
collapsedAction
;
nsIEditor
:
:
EStripWrappers
stripWrappers
;
bool
bOrdered
;
bool
entireList
;
const
nsAString
*
bulletType
;
const
nsAString
*
alignType
;
const
nsAString
*
blockType
;
}
;
class
MOZ_STACK_CLASS
AutoLockRulesSniffing
final
{
public
:
explicit
AutoLockRulesSniffing
(
TextEditRules
*
aRules
)
:
mRules
(
aRules
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
true
;
}
}
~
AutoLockRulesSniffing
(
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
false
;
}
}
protected
:
TextEditRules
*
mRules
;
}
;
class
MOZ_STACK_CLASS
AutoLockListener
final
{
public
:
explicit
AutoLockListener
(
bool
*
aEnabled
)
:
mEnabled
(
aEnabled
)
mOldState
(
false
)
{
if
(
mEnabled
)
{
mOldState
=
*
mEnabled
;
*
mEnabled
=
false
;
}
}
~
AutoLockListener
(
)
{
if
(
mEnabled
)
{
*
mEnabled
=
mOldState
;
}
}
protected
:
bool
*
mEnabled
;
bool
mOldState
;
}
;
}
#
endif
