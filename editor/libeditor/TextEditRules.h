#
ifndef
mozilla_TextEditRules_h
#
define
mozilla_TextEditRules_h
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
class
nsIDOMNode
;
namespace
mozilla
{
class
AutoLockRulesSniffing
;
class
HTMLEditRules
;
class
RulesInfo
;
class
TextEditor
;
namespace
dom
{
class
Selection
;
}
class
TextEditRules
:
public
nsITimerCallback
public
nsINamed
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
template
<
typename
T
>
using
OwningNonNull
=
OwningNonNull
<
T
>
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
TextEditRules
nsITimerCallback
)
TextEditRules
(
)
;
HTMLEditRules
*
AsHTMLEditRules
(
)
;
const
HTMLEditRules
*
AsHTMLEditRules
(
)
const
;
virtual
nsresult
Init
(
TextEditor
*
aTextEditor
)
;
virtual
nsresult
SetInitialValue
(
const
nsAString
&
aValue
)
;
virtual
nsresult
DetachEditor
(
)
;
virtual
nsresult
BeforeEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
;
virtual
nsresult
AfterEdit
(
EditAction
aAction
nsIEditor
:
:
EDirection
aDirection
)
;
virtual
nsresult
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
;
virtual
nsresult
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
;
virtual
bool
DocumentIsEmpty
(
)
;
virtual
nsresult
DocumentModified
(
)
;
protected
:
virtual
~
TextEditRules
(
)
;
public
:
void
ResetIMETextPWBuf
(
)
;
static
void
HandleNewLines
(
nsString
&
aString
int32_t
aNewLineHandling
)
;
static
void
FillBufWithPWChars
(
nsAString
*
aOutString
int32_t
aLength
)
;
bool
HasBogusNode
(
)
{
return
!
!
mBogusNode
;
}
protected
:
void
InitFields
(
)
;
nsresult
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
;
nsresult
DidInsertText
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillInsertBreak
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
int32_t
aMaxLength
)
;
nsresult
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillSetText
(
Selection
&
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
int32_t
aMaxLength
)
;
nsresult
DidSetText
(
Selection
&
aSelection
nsresult
aResult
)
;
void
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
;
nsresult
DidInsert
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
nsresult
aResult
)
;
nsresult
WillSetTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidSetTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillRemoveTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidRemoveTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillUndo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidUndo
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillRedo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidRedo
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillOutputText
(
Selection
*
aSelection
const
nsAString
*
aInFormat
nsAString
*
aOutText
uint32_t
aFlags
bool
*
aOutCancel
bool
*
aHandled
)
;
nsresult
DidOutputText
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
RemoveRedundantTrailingBR
(
)
;
nsresult
CreateTrailingBRIfNeeded
(
)
;
nsresult
CreateBogusNodeIfNeeded
(
Selection
*
aSelection
)
;
nsresult
TruncateInsertionIfNeeded
(
Selection
*
aSelection
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
;
void
RemoveIMETextFromPWBuf
(
uint32_t
&
aStart
nsAString
*
aIMEString
)
;
already_AddRefed
<
Element
>
CreateBR
(
const
EditorRawDOMPoint
&
aPointToInsert
)
{
return
CreateBRInternal
(
aPointToInsert
false
)
;
}
already_AddRefed
<
Element
>
CreateMozBR
(
const
EditorRawDOMPoint
&
aPointToInsert
)
{
return
CreateBRInternal
(
aPointToInsert
true
)
;
}
already_AddRefed
<
Element
>
CreateBRInternal
(
const
EditorRawDOMPoint
&
aPointToInsert
bool
aCreateMozBR
)
;
void
UndefineCaretBidiLevel
(
Selection
*
aSelection
)
;
nsresult
CheckBidiLevelForDeletion
(
Selection
*
aSelection
nsIDOMNode
*
aSelNode
int32_t
aSelOffset
nsIEditor
:
:
EDirection
aAction
bool
*
aCancel
)
;
nsresult
HideLastPWInput
(
)
;
nsresult
CollapseSelectionToTrailingBRIfNeeded
(
Selection
*
aSelection
)
;
bool
IsPasswordEditor
(
)
const
;
bool
IsSingleLineEditor
(
)
const
;
bool
IsPlaintextEditor
(
)
const
;
bool
IsReadonly
(
)
const
;
bool
IsDisabled
(
)
const
;
bool
IsMailEditor
(
)
const
;
bool
DontEchoPassword
(
)
const
;
private
:
TextEditor
*
mTextEditor
;
protected
:
nsString
mPasswordText
;
nsString
mPasswordIMEText
;
uint32_t
mPasswordIMEIndex
;
nsCOMPtr
<
nsIContent
>
mBogusNode
;
nsCOMPtr
<
nsINode
>
mCachedSelectionNode
;
uint32_t
mCachedSelectionOffset
;
uint32_t
mActionNesting
;
bool
mLockRulesSniffing
;
bool
mDidExplicitlySetInterline
;
bool
mDeleteBidiImmediately
;
bool
mIsHTMLEditRules
;
EditAction
mTheAction
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mLastStart
;
uint32_t
mLastLength
;
friend
class
AutoLockRulesSniffing
;
}
;
class
RulesInfo
final
{
public
:
explicit
RulesInfo
(
EditAction
aAction
)
:
action
(
aAction
)
inString
(
nullptr
)
outString
(
nullptr
)
outputFormat
(
nullptr
)
maxLength
(
-
1
)
flags
(
0
)
collapsedAction
(
nsIEditor
:
:
eNext
)
stripWrappers
(
nsIEditor
:
:
eStrip
)
bOrdered
(
false
)
entireList
(
false
)
bulletType
(
nullptr
)
alignType
(
nullptr
)
blockType
(
nullptr
)
{
}
EditAction
action
;
const
nsAString
*
inString
;
nsAString
*
outString
;
const
nsAString
*
outputFormat
;
int32_t
maxLength
;
uint32_t
flags
;
nsIEditor
:
:
EDirection
collapsedAction
;
nsIEditor
:
:
EStripWrappers
stripWrappers
;
bool
bOrdered
;
bool
entireList
;
const
nsAString
*
bulletType
;
const
nsAString
*
alignType
;
const
nsAString
*
blockType
;
}
;
class
MOZ_STACK_CLASS
AutoLockRulesSniffing
final
{
public
:
explicit
AutoLockRulesSniffing
(
TextEditRules
*
aRules
)
:
mRules
(
aRules
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
true
;
}
}
~
AutoLockRulesSniffing
(
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
false
;
}
}
protected
:
TextEditRules
*
mRules
;
}
;
class
MOZ_STACK_CLASS
AutoLockListener
final
{
public
:
explicit
AutoLockListener
(
bool
*
aEnabled
)
:
mEnabled
(
aEnabled
)
mOldState
(
false
)
{
if
(
mEnabled
)
{
mOldState
=
*
mEnabled
;
*
mEnabled
=
false
;
}
}
~
AutoLockListener
(
)
{
if
(
mEnabled
)
{
*
mEnabled
=
mOldState
;
}
}
protected
:
bool
*
mEnabled
;
bool
mOldState
;
}
;
}
#
endif
