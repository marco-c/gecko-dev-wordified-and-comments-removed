#
ifndef
mozilla_TextEditRules_h
#
define
mozilla_TextEditRules_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsEditor
.
h
"
#
include
"
nsIEditRules
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
class
nsIDOMElement
;
class
nsIDOMNode
;
class
nsPlaintextEditor
;
namespace
mozilla
{
class
AutoLockRulesSniffing
;
namespace
dom
{
class
Selection
;
}
class
TextEditRules
:
public
nsIEditRules
public
nsITimerCallback
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
Selection
Selection
;
typedef
dom
:
:
Text
Text
;
template
<
typename
T
>
using
OwningNonNull
=
OwningNonNull
<
T
>
;
NS_DECL_NSITIMERCALLBACK
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
TextEditRules
nsIEditRules
)
TextEditRules
(
)
;
NS_IMETHOD
Init
(
nsPlaintextEditor
*
aTextEditor
)
override
;
NS_IMETHOD
SetInitialValue
(
const
nsAString
&
aValue
)
override
;
NS_IMETHOD
DetachEditor
(
)
override
;
NS_IMETHOD
BeforeEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
override
;
NS_IMETHOD
AfterEdit
(
EditAction
action
nsIEditor
:
:
EDirection
aDirection
)
override
;
NS_IMETHOD
WillDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
bool
*
aCancel
bool
*
aHandled
)
override
;
NS_IMETHOD
DidDoAction
(
Selection
*
aSelection
RulesInfo
*
aInfo
nsresult
aResult
)
override
;
NS_IMETHOD
DocumentIsEmpty
(
bool
*
aDocumentIsEmpty
)
override
;
NS_IMETHOD
DocumentModified
(
)
override
;
protected
:
virtual
~
TextEditRules
(
)
;
public
:
void
ResetIMETextPWBuf
(
)
;
static
void
HandleNewLines
(
nsString
&
aString
int32_t
aNewLineHandling
)
;
static
void
FillBufWithPWChars
(
nsAString
*
aOutString
int32_t
aLength
)
;
protected
:
void
InitFields
(
)
;
nsresult
WillInsertText
(
EditAction
aAction
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
const
nsAString
*
inString
nsAString
*
outString
int32_t
aMaxLength
)
;
nsresult
DidInsertText
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
GetTopEnclosingPre
(
nsIDOMNode
*
aNode
nsIDOMNode
*
*
aOutPreNode
)
;
nsresult
WillInsertBreak
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
int32_t
aMaxLength
)
;
nsresult
DidInsertBreak
(
Selection
*
aSelection
nsresult
aResult
)
;
void
WillInsert
(
Selection
&
aSelection
bool
*
aCancel
)
;
nsresult
DidInsert
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidDeleteSelection
(
Selection
*
aSelection
nsIEditor
:
:
EDirection
aCollapsedAction
nsresult
aResult
)
;
nsresult
WillSetTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidSetTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillRemoveTextProperty
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidRemoveTextProperty
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillUndo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidUndo
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillRedo
(
Selection
*
aSelection
bool
*
aCancel
bool
*
aHandled
)
;
nsresult
DidRedo
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
WillOutputText
(
Selection
*
aSelection
const
nsAString
*
aInFormat
nsAString
*
aOutText
bool
*
aOutCancel
bool
*
aHandled
)
;
nsresult
DidOutputText
(
Selection
*
aSelection
nsresult
aResult
)
;
nsresult
RemoveRedundantTrailingBR
(
)
;
nsresult
CreateTrailingBRIfNeeded
(
)
;
nsresult
CreateBogusNodeIfNeeded
(
Selection
*
aSelection
)
;
nsresult
TruncateInsertionIfNeeded
(
Selection
*
aSelection
const
nsAString
*
aInString
nsAString
*
aOutString
int32_t
aMaxLength
bool
*
aTruncated
)
;
void
RemoveIMETextFromPWBuf
(
int32_t
&
aStart
nsAString
*
aIMEString
)
;
nsresult
CreateMozBR
(
nsIDOMNode
*
inParent
int32_t
inOffset
nsIDOMNode
*
*
outBRNode
=
nullptr
)
;
void
UndefineCaretBidiLevel
(
Selection
*
aSelection
)
;
nsresult
CheckBidiLevelForDeletion
(
Selection
*
aSelection
nsIDOMNode
*
aSelNode
int32_t
aSelOffset
nsIEditor
:
:
EDirection
aAction
bool
*
aCancel
)
;
nsresult
HideLastPWInput
(
)
;
nsresult
CollapseSelectionToTrailingBRIfNeeded
(
Selection
*
aSelection
)
;
bool
IsPasswordEditor
(
)
const
;
bool
IsSingleLineEditor
(
)
const
;
bool
IsPlaintextEditor
(
)
const
;
bool
IsReadonly
(
)
const
;
bool
IsDisabled
(
)
const
;
bool
IsMailEditor
(
)
const
;
bool
DontEchoPassword
(
)
const
;
nsPlaintextEditor
*
mEditor
;
nsString
mPasswordText
;
nsString
mPasswordIMEText
;
uint32_t
mPasswordIMEIndex
;
nsCOMPtr
<
nsIDOMNode
>
mBogusNode
;
nsCOMPtr
<
nsIDOMNode
>
mCachedSelectionNode
;
int32_t
mCachedSelectionOffset
;
uint32_t
mActionNesting
;
bool
mLockRulesSniffing
;
bool
mDidExplicitlySetInterline
;
bool
mDeleteBidiImmediately
;
EditAction
mTheAction
;
nsCOMPtr
<
nsITimer
>
mTimer
;
uint32_t
mLastStart
;
uint32_t
mLastLength
;
friend
class
AutoLockRulesSniffing
;
}
;
class
TextRulesInfo
final
:
public
RulesInfo
{
public
:
explicit
TextRulesInfo
(
EditAction
aAction
)
:
RulesInfo
(
aAction
)
inString
(
nullptr
)
outString
(
nullptr
)
outputFormat
(
nullptr
)
maxLength
(
-
1
)
collapsedAction
(
nsIEditor
:
:
eNext
)
stripWrappers
(
nsIEditor
:
:
eStrip
)
bOrdered
(
false
)
entireList
(
false
)
bulletType
(
nullptr
)
alignType
(
nullptr
)
blockType
(
nullptr
)
insertElement
(
nullptr
)
{
}
const
nsAString
*
inString
;
nsAString
*
outString
;
const
nsAString
*
outputFormat
;
int32_t
maxLength
;
nsIEditor
:
:
EDirection
collapsedAction
;
nsIEditor
:
:
EStripWrappers
stripWrappers
;
bool
bOrdered
;
bool
entireList
;
const
nsAString
*
bulletType
;
const
nsAString
*
alignType
;
const
nsAString
*
blockType
;
const
nsIDOMElement
*
insertElement
;
}
;
class
MOZ_STACK_CLASS
AutoLockRulesSniffing
final
{
public
:
explicit
AutoLockRulesSniffing
(
TextEditRules
*
aRules
)
:
mRules
(
aRules
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
true
;
}
}
~
AutoLockRulesSniffing
(
)
{
if
(
mRules
)
{
mRules
-
>
mLockRulesSniffing
=
false
;
}
}
protected
:
TextEditRules
*
mRules
;
}
;
class
MOZ_STACK_CLASS
AutoLockListener
final
{
public
:
explicit
AutoLockListener
(
bool
*
aEnabled
)
:
mEnabled
(
aEnabled
)
mOldState
(
false
)
{
if
(
mEnabled
)
{
mOldState
=
*
mEnabled
;
*
mEnabled
=
false
;
}
}
~
AutoLockListener
(
)
{
if
(
mEnabled
)
{
*
mEnabled
=
mOldState
;
}
}
protected
:
bool
*
mEnabled
;
bool
mOldState
;
}
;
}
#
endif
