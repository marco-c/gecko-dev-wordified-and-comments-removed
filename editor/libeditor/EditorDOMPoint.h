#
ifndef
mozilla_EditorDOMPoint_h
#
define
mozilla_EditorDOMPoint_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
<
type_traits
>
namespace
mozilla
{
#
define
NS_INSTANTIATE_EDITOR_DOM_POINT_METHOD
(
aResultType
aMethodName
.
.
.
)
\
template
aResultType
EditorDOMPoint
:
:
aMethodName
(
__VA_ARGS__
)
;
\
template
aResultType
EditorRawDOMPoint
:
:
aMethodName
(
__VA_ARGS__
)
;
\
template
aResultType
EditorDOMPointInText
:
:
aMethodName
(
__VA_ARGS__
)
;
\
template
aResultType
EditorRawDOMPointInText
:
:
aMethodName
(
__VA_ARGS__
)
#
define
NS_INSTANTIATE_EDITOR_DOM_POINT_CONST_METHOD
(
aResultType
aMethodName
\
.
.
.
)
\
template
aResultType
EditorDOMPoint
:
:
aMethodName
(
__VA_ARGS__
)
const
;
\
template
aResultType
EditorRawDOMPoint
:
:
aMethodName
(
__VA_ARGS__
)
const
;
\
template
aResultType
EditorDOMPointInText
:
:
aMethodName
(
__VA_ARGS__
)
const
;
\
template
aResultType
EditorRawDOMPointInText
:
:
aMethodName
(
__VA_ARGS__
)
const
#
define
NS_INSTANTIATE_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
aMethodName
.
.
.
)
\
template
EditorDOMPoint
aMethodName
(
__VA_ARGS__
)
;
\
template
EditorRawDOMPoint
aMethodName
(
__VA_ARGS__
)
;
\
template
EditorDOMPointInText
aMethodName
(
__VA_ARGS__
)
;
\
template
EditorRawDOMPointInText
aMethodName
(
__VA_ARGS__
)
#
define
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
\
aMethodName
.
.
.
)
\
template
EditorDOMPoint
aMethodName
(
__VA_ARGS__
)
const
;
\
template
EditorRawDOMPoint
aMethodName
(
__VA_ARGS__
)
const
;
\
template
EditorDOMPointInText
aMethodName
(
__VA_ARGS__
)
const
;
\
template
EditorRawDOMPointInText
aMethodName
(
__VA_ARGS__
)
const
template
<
typename
ParentType
typename
ChildType
>
class
EditorDOMPointBase
final
{
typedef
EditorDOMPointBase
<
ParentType
ChildType
>
SelfType
;
public
:
using
InterlinePosition
=
dom
:
:
Selection
:
:
InterlinePosition
;
EditorDOMPointBase
(
)
=
default
;
template
<
typename
ContainerType
>
EditorDOMPointBase
(
const
ContainerType
*
aContainer
uint32_t
aOffset
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
:
mParent
(
const_cast
<
ContainerType
*
>
(
aContainer
)
)
mChild
(
nullptr
)
mOffset
(
Some
(
aOffset
)
)
mInterlinePosition
(
aInterlinePosition
)
{
NS_WARNING_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
larger
than
the
length
of
aContainer
or
negative
"
)
;
if
(
!
mParent
)
{
mOffset
.
reset
(
)
;
}
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
EditorDOMPointBase
(
const
StrongPtr
<
ContainerType
>
&
aContainer
uint32_t
aOffset
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
:
EditorDOMPointBase
(
aContainer
.
get
(
)
aOffset
aInterlinePosition
)
{
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
EditorDOMPointBase
(
const
StrongPtr
<
const
ContainerType
>
&
aContainer
uint32_t
aOffset
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
:
EditorDOMPointBase
(
aContainer
.
get
(
)
aOffset
aInterlinePosition
)
{
}
explicit
EditorDOMPointBase
(
const
nsINode
*
aPointedNode
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
:
mParent
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
aPointedNode
-
>
GetParentNode
(
)
:
nullptr
)
mChild
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
const_cast
<
nsIContent
*
>
(
aPointedNode
-
>
AsContent
(
)
)
:
nullptr
)
mInterlinePosition
(
aInterlinePosition
)
{
mIsChildInitialized
=
aPointedNode
&
&
mChild
;
NS_WARNING_ASSERTION
(
IsSet
(
)
"
The
child
is
nullptr
or
doesn
'
t
have
its
parent
"
)
;
NS_WARNING_ASSERTION
(
mChild
&
&
mChild
-
>
GetParentNode
(
)
=
=
mParent
"
Initializing
RangeBoundary
with
invalid
value
"
)
;
}
EditorDOMPointBase
(
nsINode
*
aContainer
nsIContent
*
aPointedNode
uint32_t
aOffset
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
:
mParent
(
aContainer
)
mChild
(
aPointedNode
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mInterlinePosition
(
aInterlinePosition
)
mIsChildInitialized
(
true
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aContainer
"
This
constructor
shouldn
'
t
be
used
when
pointing
nowhere
"
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
;
MOZ_ASSERT
(
!
mChild
|
|
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
template
<
typename
PT
typename
CT
>
explicit
EditorDOMPointBase
(
const
RangeBoundaryBase
<
PT
CT
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mChild
(
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
)
mOffset
(
aOther
.
mOffset
)
mIsChildInitialized
(
aOther
.
mRef
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
)
{
}
void
SetInterlinePosition
(
InterlinePosition
aInterlinePosition
)
{
MOZ_ASSERT
(
IsSet
(
)
)
;
mInterlinePosition
=
aInterlinePosition
;
}
InterlinePosition
GetInterlinePosition
(
)
const
{
return
IsSet
(
)
?
mInterlinePosition
:
InterlinePosition
:
:
Undefined
;
}
nsINode
*
GetContainer
(
)
const
{
return
mParent
;
}
template
<
typename
ContentNodeType
>
ContentNodeType
*
GetContainerAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
mParent
)
;
}
template
<
typename
ContentNodeType
>
ContentNodeType
*
ContainerAs
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ContentNodeType
:
:
FromNode
(
mParent
)
)
;
return
static_cast
<
ContentNodeType
*
>
(
GetContainer
(
)
)
;
}
nsINode
*
GetContainerParent
(
)
const
{
return
mParent
?
mParent
-
>
GetParent
(
)
:
nullptr
;
}
template
<
typename
ContentNodeType
>
ContentNodeType
*
GetContainerParentAs
(
)
const
{
return
ContentNodeType
:
:
FromNodeOrNull
(
GetContainerParent
(
)
)
;
}
dom
:
:
Element
*
GetContainerOrContainerParentElement
(
)
const
{
if
(
MOZ_UNLIKELY
(
!
mParent
)
)
{
return
nullptr
;
}
return
mParent
-
>
IsElement
(
)
?
ContainerAs
<
dom
:
:
Element
>
(
)
:
GetContainerParentAs
<
dom
:
:
Element
>
(
)
;
}
bool
CanContainerHaveChildren
(
)
const
{
return
mParent
&
&
mParent
-
>
IsContainerNode
(
)
;
}
bool
IsContainerEmpty
(
)
const
{
return
mParent
&
&
!
mParent
-
>
Length
(
)
;
}
bool
IsInContentNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsContent
(
)
;
}
bool
IsInDataNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsCharacterData
(
)
;
}
bool
IsInTextNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsText
(
)
;
}
bool
IsInNativeAnonymousSubtree
(
)
const
{
return
mParent
&
&
mParent
-
>
IsInNativeAnonymousSubtree
(
)
;
}
bool
IsContainerHTMLElement
(
nsAtom
*
aTag
)
const
{
return
mParent
&
&
mParent
-
>
IsHTMLElement
(
aTag
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
bool
IsContainerAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
mParent
&
&
mParent
-
>
IsAnyOfHTMLElements
(
aFirst
aArgs
.
.
.
)
;
}
nsIContent
*
GetChild
(
)
const
{
if
(
!
mParent
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
;
}
nsIContent
*
GetCurrentChildAtOffset
(
)
const
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
mOffset
.
isNothing
(
)
)
{
return
GetChild
(
)
;
}
return
mParent
?
mParent
-
>
GetChildAt_Deprecated
(
*
mOffset
)
:
nullptr
;
}
nsIContent
*
GetChildOrContainerIfDataNode
(
)
const
{
if
(
IsInDataNode
(
)
)
{
return
ContainerAs
<
nsIContent
>
(
)
;
}
return
GetChild
(
)
;
}
nsIContent
*
GetNextSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
nsIContent
*
GetPreviousSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
char16_t
Char
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAs
<
dom
:
:
Text
>
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
Char
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharNBSP
(
)
const
{
return
Char
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
Char
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharNewLine
(
)
const
{
return
Char
(
)
=
=
'
\
n
'
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharPreformattedNewLine
(
)
const
;
MOZ_NEVER_INLINE_DEBUG
bool
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
;
bool
IsCharCollapsibleASCIISpace
(
)
const
;
bool
IsCharCollapsibleNBSP
(
)
const
;
bool
IsCharCollapsibleASCIISpaceOrNBSP
(
)
const
;
MOZ_NEVER_INLINE_DEBUG
bool
IsCharHighSurrogateFollowedByLowSurrogate
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAs
<
dom
:
:
Text
>
(
)
-
>
TextFragment
(
)
.
IsHighSurrogateFollowedByLowSurrogateAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharLowSurrogateFollowingHighSurrogate
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAs
<
dom
:
:
Text
>
(
)
-
>
TextFragment
(
)
.
IsLowSurrogateFollowingHighSurrogateAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
char16_t
PreviousChar
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsStartOfContainer
(
)
)
;
return
ContainerAs
<
dom
:
:
Text
>
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
-
1
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
PreviousChar
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharNBSP
(
)
const
{
return
PreviousChar
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
PreviousChar
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharNewLine
(
)
const
{
return
PreviousChar
(
)
=
=
'
\
n
'
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharPreformattedNewLine
(
)
const
;
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
;
bool
IsPreviousCharCollapsibleASCIISpace
(
)
const
;
bool
IsPreviousCharCollapsibleNBSP
(
)
const
;
bool
IsPreviousCharCollapsibleASCIISpaceOrNBSP
(
)
const
;
MOZ_NEVER_INLINE_DEBUG
char16_t
NextChar
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsAtLastContent
(
)
&
&
!
IsEndOfContainer
(
)
)
;
return
ContainerAs
<
dom
:
:
Text
>
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
+
1
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
NextChar
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharNBSP
(
)
const
{
return
NextChar
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
NextChar
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharNewLine
(
)
const
{
return
NextChar
(
)
=
=
'
\
n
'
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharPreformattedNewLine
(
)
const
;
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
const
;
bool
IsNextCharCollapsibleASCIISpace
(
)
const
;
bool
IsNextCharCollapsibleNBSP
(
)
const
;
bool
IsNextCharCollapsibleASCIISpaceOrNBSP
(
)
const
;
uint32_t
Offset
(
)
const
{
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
mParent
)
)
{
MOZ_ASSERT
(
!
mChild
)
;
return
0u
;
}
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
If
the
container
cannot
have
children
mOffset
.
isSome
(
)
should
"
"
be
true
"
)
;
if
(
!
mChild
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
return
mOffset
.
value
(
)
;
}
MOZ_ASSERT
(
mChild
-
>
GetParentNode
(
)
=
=
mParent
)
;
if
(
mChild
=
=
mParent
-
>
GetFirstChild
(
)
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
0u
)
;
return
0u
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mParent
-
>
ComputeIndexOf
(
mChild
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
valueOr
(
0u
)
;
}
template
<
typename
ContainerType
>
void
Set
(
ContainerType
*
aContainer
uint32_t
aOffset
)
{
mParent
=
aContainer
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
aOffset
)
;
mIsChildInitialized
=
false
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
NS_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
out
of
bounds
"
)
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
void
Set
(
const
StrongPtr
<
ContainerType
>
&
aContainer
uint32_t
aOffset
)
{
Set
(
aContainer
.
get
(
)
aOffset
)
;
}
void
Set
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
if
(
NS_WARN_IF
(
!
aChild
-
>
IsContent
(
)
)
)
{
Clear
(
)
;
return
;
}
mParent
=
aChild
-
>
GetParentNode
(
)
;
mChild
=
const_cast
<
nsIContent
*
>
(
aChild
-
>
AsContent
(
)
)
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
true
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
}
template
<
typename
ContainerType
>
MOZ_NEVER_INLINE_DEBUG
void
SetToEndOf
(
const
ContainerType
*
aContainer
)
{
MOZ_ASSERT
(
aContainer
)
;
mParent
=
const_cast
<
ContainerType
*
>
(
aContainer
)
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
void
SetToEndOf
(
const
StrongPtr
<
ContainerType
>
&
aContainer
)
{
SetToEndOf
(
aContainer
.
get
(
)
)
;
}
template
<
typename
ContainerType
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
AtEndOf
(
const
ContainerType
&
aContainer
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
{
SelfType
point
;
point
.
SetToEndOf
(
&
aContainer
)
;
point
.
mInterlinePosition
=
aInterlinePosition
;
return
point
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
AtEndOf
(
const
StrongPtr
<
ContainerType
>
&
aContainer
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
{
MOZ_ASSERT
(
aContainer
.
get
(
)
)
;
return
AtEndOf
(
*
aContainer
.
get
(
)
aInterlinePosition
)
;
}
void
SetAfter
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
nsIContent
*
nextSibling
=
aChild
-
>
GetNextSibling
(
)
;
if
(
nextSibling
)
{
Set
(
nextSibling
)
;
return
;
}
nsINode
*
parentNode
=
aChild
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
Clear
(
)
;
return
;
}
SetToEndOf
(
parentNode
)
;
}
template
<
typename
ContainerType
>
static
SelfType
After
(
const
ContainerType
&
aContainer
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
{
SelfType
point
;
point
.
SetAfter
(
&
aContainer
)
;
point
.
mInterlinePosition
=
aInterlinePosition
;
return
point
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
After
(
const
StrongPtr
<
ContainerType
>
&
aContainer
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
{
MOZ_ASSERT
(
aContainer
.
get
(
)
)
;
return
After
(
*
aContainer
.
get
(
)
aInterlinePosition
)
;
}
template
<
typename
PT
typename
CT
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
After
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
InterlinePosition
aInterlinePosition
=
InterlinePosition
:
:
Undefined
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
mChild
)
{
return
After
(
*
aPoint
.
mChild
aInterlinePosition
)
;
}
if
(
NS_WARN_IF
(
aPoint
.
IsEndOfContainer
(
)
)
)
{
return
SelfType
(
)
;
}
auto
point
=
aPoint
.
NextPoint
(
)
.
template
To
<
SelfType
>
(
)
;
point
.
mInterlinePosition
=
aInterlinePosition
;
return
point
;
}
template
<
typename
EditorDOMPointType
=
SelfType
>
EditorDOMPointType
ParentPoint
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
if
(
MOZ_UNLIKELY
(
!
mParent
)
|
|
!
mParent
-
>
IsContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
return
EditorDOMPointType
(
ContainerAs
<
nsIContent
>
(
)
)
;
}
template
<
typename
EditorDOMPointType
=
SelfType
>
EditorDOMPointType
NextPoint
(
)
const
{
NS_ASSERTION
(
!
IsEndOfContainer
(
)
"
Should
not
be
at
end
of
the
container
"
)
;
auto
result
=
this
-
>
template
To
<
EditorDOMPointType
>
(
)
;
result
.
AdvanceOffset
(
)
;
return
result
;
}
template
<
typename
EditorDOMPointType
=
SelfType
>
EditorDOMPointType
PreviousPoint
(
)
const
{
NS_ASSERTION
(
!
IsStartOfContainer
(
)
"
Should
not
be
at
start
of
the
container
"
)
;
EditorDOMPointType
result
=
this
-
>
template
To
<
EditorDOMPointType
>
(
)
;
result
.
RewindOffset
(
)
;
return
result
;
}
void
Clear
(
)
{
mParent
=
nullptr
;
mChild
=
nullptr
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
false
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
}
bool
AdvanceOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
!
mChild
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
}
mChild
=
mChild
-
>
GetNextSibling
(
)
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
return
true
;
}
bool
RewindOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
!
mOffset
.
value
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
NS_ASSERTION
(
false
"
Failed
to
rewind
offset
"
)
;
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
mChild
&
&
!
mChild
-
>
GetPreviousSibling
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
!
mOffset
.
value
(
)
)
)
{
return
false
;
}
nsIContent
*
previousSibling
=
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
previousSibling
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
}
mChild
=
previousSibling
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
return
true
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
GetNonAnonymousSubtreePoint
(
)
const
{
if
(
NS_WARN_IF
(
!
IsSet
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
if
(
!
IsInNativeAnonymousSubtree
(
)
)
{
return
this
-
>
template
To
<
EditorDOMPointType
>
(
)
;
}
nsINode
*
parent
;
for
(
parent
=
mParent
-
>
GetParentNode
(
)
;
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
}
if
(
!
parent
)
{
return
EditorDOMPointType
(
)
;
}
return
EditorDOMPointType
(
parent
)
;
}
bool
IsSet
(
)
const
{
return
mParent
&
&
(
mIsChildInitialized
|
|
mOffset
.
isSome
(
)
)
;
}
bool
IsSetAndValid
(
)
const
{
if
(
!
IsSet
(
)
)
{
return
false
;
}
if
(
mChild
&
&
(
mChild
-
>
GetParentNode
(
)
!
=
mParent
|
|
mChild
-
>
IsBeingRemoved
(
)
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
{
return
false
;
}
return
true
;
}
bool
HasChildMovedFromContainer
(
)
const
{
return
mChild
&
&
mChild
-
>
GetParentNode
(
)
!
=
mParent
;
}
bool
IsStartOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
!
mOffset
.
value
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
mParent
-
>
GetFirstChild
(
)
=
=
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
!
mOffset
.
value
(
)
"
If
mOffset
was
initialized
it
should
be
0
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
!
mOffset
.
value
(
)
;
}
bool
IsEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
!
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
"
If
mOffset
was
initialized
it
should
be
length
of
the
container
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
bool
IsAtLastContent
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
mParent
-
>
IsContainerNode
(
)
&
&
mOffset
.
isSome
(
)
)
{
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
;
}
if
(
mIsChildInitialized
)
{
if
(
mChild
&
&
mChild
=
=
mParent
-
>
GetLastChild
(
)
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
"
If
mOffset
was
initialized
it
should
be
length
-
1
of
the
"
"
container
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
;
}
bool
IsBRElementAtEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
false
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
if
(
!
mChild
|
|
mChild
-
>
GetNextSibling
(
)
)
{
return
false
;
}
return
mChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
template
<
typename
A
typename
B
>
EditorDOMPointBase
&
operator
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mChild
=
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
&
&
aOther
.
mParent
-
>
IsContainerNode
(
)
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
;
mOffset
=
aOther
.
mOffset
;
mIsChildInitialized
=
aOther
.
mRef
|
|
(
aOther
.
mParent
&
&
!
aOther
.
mParent
-
>
IsContainerNode
(
)
)
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
;
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
return
*
this
;
}
template
<
typename
EditorDOMPointType
>
constexpr
EditorDOMPointType
To
(
)
const
{
if
(
std
:
:
is_same
<
SelfType
EditorDOMPointType
>
:
:
value
)
{
return
reinterpret_cast
<
const
EditorDOMPointType
&
>
(
*
this
)
;
}
EditorDOMPointType
result
;
result
.
mParent
=
mParent
;
result
.
mChild
=
mChild
;
result
.
mOffset
=
mOffset
;
result
.
mIsChildInitialized
=
mIsChildInitialized
;
result
.
mInterlinePosition
=
mInterlinePosition
;
return
result
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
mParent
!
=
aOther
.
mParent
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
aOther
.
mOffset
.
isSome
(
)
)
{
if
(
mOffset
!
=
aOther
.
mOffset
)
{
return
false
;
}
if
(
mChild
=
=
aOther
.
mChild
)
{
return
true
;
}
if
(
NS_WARN_IF
(
mIsChildInitialized
&
&
aOther
.
mIsChildInitialized
)
)
{
return
false
;
}
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
|
|
aOther
.
mIsChildInitialized
)
;
if
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
&
&
!
aOther
.
mOffset
.
isSome
(
)
&
&
aOther
.
mIsChildInitialized
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
if
(
!
mOffset
.
isSome
(
)
&
&
mIsChildInitialized
&
&
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mIsChildInitialized
)
{
const_cast
<
EditorDOMPointBase
<
A
B
>
&
>
(
aOther
)
.
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
return
mChild
=
=
aOther
.
mChild
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
*
this
=
=
SelfType
(
aOther
)
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
operator
const
RawRangeBoundary
(
)
const
{
return
ToRawRangeBoundary
(
)
;
}
const
RawRangeBoundary
ToRawRangeBoundary
(
)
const
{
if
(
!
IsSet
(
)
|
|
NS_WARN_IF
(
!
mIsChildInitialized
&
&
!
mOffset
.
isSome
(
)
)
)
{
return
RawRangeBoundary
(
)
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mIsChildInitialized
&
&
mOffset
.
isSome
(
)
)
{
#
ifdef
DEBUG
if
(
mChild
)
{
MOZ_ASSERT
(
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
else
{
MOZ_ASSERT
(
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
)
;
}
#
endif
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mOffset
.
isSome
(
)
)
{
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mChild
)
{
return
RawRangeBoundary
(
mParent
mChild
-
>
GetPreviousSibling
(
)
)
;
}
return
RawRangeBoundary
(
mParent
mParent
-
>
GetLastChild
(
)
)
;
}
already_AddRefed
<
nsRange
>
CreateCollapsedRange
(
ErrorResult
&
aRv
)
const
{
const
RawRangeBoundary
boundary
=
ToRawRangeBoundary
(
)
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
boundary
boundary
aRv
)
;
if
(
MOZ_UNLIKELY
(
aRv
.
Failed
(
)
|
|
!
range
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
EditorDOMPointInText
GetAsInText
(
)
const
{
return
IsInTextNode
(
)
?
EditorDOMPointInText
(
ContainerAs
<
dom
:
:
Text
>
(
)
Offset
(
)
mInterlinePosition
)
:
EditorDOMPointInText
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMPointInText
AsInText
(
)
const
{
MOZ_ASSERT
(
IsInTextNode
(
)
)
;
return
EditorDOMPointInText
(
ContainerAs
<
dom
:
:
Text
>
(
)
Offset
(
)
mInterlinePosition
)
;
}
template
<
typename
A
typename
B
>
bool
IsBefore
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
!
IsSetAndValid
(
)
|
|
!
aOther
.
IsSetAndValid
(
)
)
{
return
false
;
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
ToRawRangeBoundary
(
)
aOther
.
ToRawRangeBoundary
(
)
)
;
return
comp
.
isSome
(
)
&
&
comp
.
value
(
)
=
=
-
1
;
}
template
<
typename
A
typename
B
>
bool
EqualsOrIsBefore
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
!
IsSetAndValid
(
)
|
|
!
aOther
.
IsSetAndValid
(
)
)
{
return
false
;
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
ToRawRangeBoundary
(
)
aOther
.
ToRawRangeBoundary
(
)
)
;
return
comp
.
isSome
(
)
&
&
comp
.
value
(
)
<
=
0
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
SelfType
&
aDOMPoint
)
{
aStream
<
<
"
{
mParent
=
"
<
<
aDOMPoint
.
mParent
.
get
(
)
;
if
(
aDOMPoint
.
mParent
)
{
aStream
<
<
"
(
"
<
<
*
aDOMPoint
.
mParent
<
<
"
Length
(
)
=
"
<
<
aDOMPoint
.
mParent
-
>
Length
(
)
<
<
"
)
"
;
}
aStream
<
<
"
mChild
=
"
<
<
aDOMPoint
.
mChild
.
get
(
)
;
if
(
aDOMPoint
.
mChild
)
{
aStream
<
<
"
(
"
<
<
*
aDOMPoint
.
mChild
<
<
"
)
"
;
}
aStream
<
<
"
mOffset
=
"
<
<
aDOMPoint
.
mOffset
<
<
"
mIsChildInitialized
=
"
<
<
(
aDOMPoint
.
mIsChildInitialized
?
"
true
"
:
"
false
"
)
<
<
"
mInterlinePosition
=
"
<
<
aDOMPoint
.
mInterlinePosition
<
<
"
}
"
;
return
aStream
;
}
private
:
void
EnsureChild
(
)
{
if
(
mIsChildInitialized
)
{
return
;
}
if
(
!
mParent
)
{
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
)
;
return
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
;
}
mChild
=
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
)
;
}
ParentType
mParent
=
nullptr
;
ChildType
mChild
=
nullptr
;
Maybe
<
uint32_t
>
mOffset
;
InterlinePosition
mInterlinePosition
=
InterlinePosition
:
:
Undefined
;
bool
mIsChildInitialized
=
false
;
template
<
typename
PT
typename
CT
>
friend
class
EditorDOMPointBase
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
EditorDOMPoint
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mParent
)
;
ImplCycleCollectionUnlink
(
aField
.
mChild
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EditorDOMPoint
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mParent
"
mParent
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mChild
"
mChild
"
0
)
;
}
template
<
typename
EditorDOMPointType
>
class
EditorDOMRangeBase
final
{
public
:
using
PointType
=
EditorDOMPointType
;
EditorDOMRangeBase
(
)
=
default
;
template
<
typename
PT
typename
CT
>
explicit
EditorDOMRangeBase
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStart
)
:
mStart
(
aStart
)
mEnd
(
aStart
)
{
MOZ_ASSERT
(
!
mStart
.
IsSet
(
)
|
|
mStart
.
IsSetAndValid
(
)
)
;
}
template
<
typename
StartPointType
typename
EndPointType
>
explicit
EditorDOMRangeBase
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
)
:
mStart
(
aStart
.
template
To
<
PointType
>
(
)
)
mEnd
(
aEnd
.
template
To
<
PointType
>
(
)
)
{
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
mStart
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsSet
(
)
mEnd
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
mStart
.
EqualsOrIsBefore
(
mEnd
)
)
;
}
explicit
EditorDOMRangeBase
(
const
dom
:
:
AbstractRange
&
aRange
)
:
mStart
(
aRange
.
StartRef
(
)
)
mEnd
(
aRange
.
EndRef
(
)
)
{
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
mStart
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsSet
(
)
mEnd
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
mStart
.
EqualsOrIsBefore
(
mEnd
)
)
;
}
template
<
typename
MaybeOtherPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStart
(
const
MaybeOtherPointType
&
aStart
)
{
mStart
=
aStart
.
template
To
<
PointType
>
(
)
;
}
template
<
typename
MaybeOtherPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetEnd
(
const
MaybeOtherPointType
&
aEnd
)
{
mEnd
=
aEnd
.
template
To
<
PointType
>
(
)
;
}
template
<
typename
StartPointType
typename
EndPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStartAndEnd
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
)
{
MOZ_ASSERT_IF
(
aStart
.
IsSet
(
)
&
&
aEnd
.
IsSet
(
)
aStart
.
EqualsOrIsBefore
(
aEnd
)
)
;
mStart
=
aStart
.
template
To
<
PointType
>
(
)
;
mEnd
=
aEnd
.
template
To
<
PointType
>
(
)
;
}
void
Clear
(
)
{
mStart
.
Clear
(
)
;
mEnd
.
Clear
(
)
;
}
const
PointType
&
StartRef
(
)
const
{
return
mStart
;
}
const
PointType
&
EndRef
(
)
const
{
return
mEnd
;
}
bool
Collapsed
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
mStart
=
=
mEnd
;
}
bool
IsPositioned
(
)
const
{
return
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
;
}
bool
IsPositionedAndValid
(
)
const
{
return
mStart
.
IsSetAndValid
(
)
&
&
mEnd
.
IsSetAndValid
(
)
&
&
mStart
.
EqualsOrIsBefore
(
mEnd
)
;
}
template
<
typename
OtherPointType
>
MOZ_NEVER_INLINE_DEBUG
bool
Contains
(
const
OtherPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
IsPositioned
(
)
&
&
aPoint
.
IsSet
(
)
&
&
mStart
.
EqualsOrIsBefore
(
aPoint
)
&
&
aPoint
.
IsBefore
(
mEnd
)
;
}
bool
InSameContainer
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
GetContainer
(
)
=
=
mEnd
.
GetContainer
(
)
;
}
bool
IsInContentNodes
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
IsInContentNode
(
)
&
&
mEnd
.
IsInContentNode
(
)
;
}
bool
IsInTextNodes
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
IsInTextNode
(
)
&
&
mEnd
.
IsInTextNode
(
)
;
}
template
<
typename
OtherRangeType
>
bool
operator
=
=
(
const
OtherRangeType
&
aOther
)
const
{
return
(
!
IsPositioned
(
)
&
&
!
aOther
.
IsPositioned
(
)
)
|
|
(
mStart
=
=
aOther
.
mStart
&
&
mEnd
=
=
aOther
.
mEnd
)
;
}
template
<
typename
OtherRangeType
>
bool
operator
!
=
(
const
OtherRangeType
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
EditorDOMRangeInTexts
GetAsInTexts
(
)
const
{
return
IsInTextNodes
(
)
?
EditorDOMRangeInTexts
(
mStart
.
AsInText
(
)
mEnd
.
AsInText
(
)
)
:
EditorDOMRangeInTexts
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMRangeInTexts
AsInTexts
(
)
const
{
MOZ_ASSERT
(
IsInTextNodes
(
)
)
;
return
EditorDOMRangeInTexts
(
mStart
.
AsInText
(
)
mEnd
.
AsInText
(
)
)
;
}
bool
EnsureNotInNativeAnonymousSubtree
(
)
{
if
(
mStart
.
IsInNativeAnonymousSubtree
(
)
)
{
nsIContent
*
parent
=
nullptr
;
for
(
parent
=
mStart
.
template
ContainerAs
<
nsIContent
>
(
)
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
;
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
;
parent
=
parent
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
{
}
if
(
MOZ_UNLIKELY
(
!
parent
)
)
{
return
false
;
}
mStart
.
Set
(
parent
)
;
}
if
(
mEnd
.
IsInNativeAnonymousSubtree
(
)
)
{
nsIContent
*
parent
=
nullptr
;
for
(
parent
=
mEnd
.
template
ContainerAs
<
nsIContent
>
(
)
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
;
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
;
parent
=
parent
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
{
}
if
(
MOZ_UNLIKELY
(
!
parent
)
)
{
return
false
;
}
mEnd
.
SetAfter
(
parent
)
;
}
return
true
;
}
already_AddRefed
<
nsRange
>
CreateRange
(
ErrorResult
&
aRv
)
const
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
mStart
.
ToRawRangeBoundary
(
)
mEnd
.
ToRawRangeBoundary
(
)
aRv
)
;
if
(
MOZ_UNLIKELY
(
aRv
.
Failed
(
)
|
|
!
range
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
private
:
EditorDOMPointType
mStart
;
EditorDOMPointType
mEnd
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
EditorDOMRange
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
EditorDOMRange
&
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
EditorDOMRange
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mStart
)
;
ImplCycleCollectionUnlink
(
aField
.
mEnd
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EditorDOMRange
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mStart
"
mStart
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mEnd
"
mEnd
"
0
)
;
}
class
MOZ_STACK_CLASS
AutoEditorDOMPointOffsetInvalidator
final
{
public
:
explicit
AutoEditorDOMPointOffsetInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mPoint
.
CanContainerHaveChildren
(
)
)
;
mChild
=
mPoint
.
GetChild
(
)
;
}
~
AutoEditorDOMPointOffsetInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateOffset
(
)
;
}
}
void
InvalidateOffset
(
)
{
if
(
mChild
)
{
mPoint
.
Set
(
mChild
)
;
}
else
{
mPoint
.
SetToEndOf
(
mPoint
.
GetContainer
(
)
)
;
}
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
nsCOMPtr
<
nsIContent
>
mChild
;
bool
mCanceled
;
AutoEditorDOMPointOffsetInvalidator
(
)
=
delete
;
AutoEditorDOMPointOffsetInvalidator
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointOffsetInvalidator
&
operator
=
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
AutoEditorDOMPointChildInvalidator
final
{
public
:
explicit
AutoEditorDOMPointChildInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
Unused
<
<
mPoint
.
Offset
(
)
;
}
~
AutoEditorDOMPointChildInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateChild
(
)
;
}
}
void
InvalidateChild
(
)
{
mPoint
.
Set
(
mPoint
.
GetContainer
(
)
mPoint
.
Offset
(
)
)
;
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
bool
mCanceled
;
AutoEditorDOMPointChildInvalidator
(
)
=
delete
;
AutoEditorDOMPointChildInvalidator
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointChildInvalidator
&
operator
=
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
}
;
}
#
endif
