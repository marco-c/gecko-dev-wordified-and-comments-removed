#
ifndef
mozilla_EditorDOMPoint_h
#
define
mozilla_EditorDOMPoint_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsStyledElement
.
h
"
namespace
mozilla
{
template
<
typename
ParentType
typename
ChildType
>
class
EditorDOMPointBase
;
typedef
EditorDOMPointBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
EditorDOMPoint
;
typedef
EditorDOMPointBase
<
nsINode
*
nsIContent
*
>
EditorRawDOMPoint
;
typedef
EditorDOMPointBase
<
RefPtr
<
dom
:
:
Text
>
nsIContent
*
>
EditorDOMPointInText
;
typedef
EditorDOMPointBase
<
dom
:
:
Text
*
nsIContent
*
>
EditorRawDOMPointInText
;
template
<
typename
ParentType
typename
ChildType
>
class
EditorDOMPointBase
final
{
typedef
EditorDOMPointBase
<
ParentType
ChildType
>
SelfType
;
public
:
EditorDOMPointBase
(
)
:
mParent
(
nullptr
)
mChild
(
nullptr
)
mIsChildInitialized
(
false
)
{
}
template
<
typename
ContainerType
>
EditorDOMPointBase
(
ContainerType
*
aContainer
int32_t
aOffset
)
:
mParent
(
aContainer
)
mChild
(
nullptr
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsChildInitialized
(
false
)
{
NS_WARNING_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
larger
than
the
length
of
aContainer
or
negative
"
)
;
if
(
!
mParent
)
{
mOffset
.
reset
(
)
;
}
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
EditorDOMPointBase
(
const
StrongPtr
<
ContainerType
>
&
aContainer
int32_t
aOffset
)
:
EditorDOMPointBase
(
aContainer
.
get
(
)
aOffset
)
{
}
explicit
EditorDOMPointBase
(
nsINode
*
aPointedNode
)
:
mParent
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
aPointedNode
-
>
GetParentNode
(
)
:
nullptr
)
mChild
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
aPointedNode
-
>
AsContent
(
)
:
nullptr
)
mIsChildInitialized
(
false
)
{
mIsChildInitialized
=
aPointedNode
&
&
mChild
;
NS_WARNING_ASSERTION
(
IsSet
(
)
"
The
child
is
nullptr
or
doesn
'
t
have
its
parent
"
)
;
NS_WARNING_ASSERTION
(
mChild
&
&
mChild
-
>
GetParentNode
(
)
=
=
mParent
"
Initializing
RangeBoundary
with
invalid
value
"
)
;
}
EditorDOMPointBase
(
nsINode
*
aContainer
nsIContent
*
aPointedNode
int32_t
aOffset
)
:
mParent
(
aContainer
)
mChild
(
aPointedNode
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsChildInitialized
(
true
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aContainer
"
This
constructor
shouldn
'
t
be
used
when
pointing
nowhere
"
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
;
MOZ_ASSERT
(
!
mChild
|
|
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
template
<
typename
PT
typename
CT
>
explicit
EditorDOMPointBase
(
const
RangeBoundaryBase
<
PT
CT
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mChild
(
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
)
mOffset
(
aOther
.
mOffset
)
mIsChildInitialized
(
aOther
.
mRef
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
)
{
}
template
<
typename
PT
typename
CT
>
MOZ_IMPLICIT
EditorDOMPointBase
(
const
EditorDOMPointBase
<
PT
CT
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mChild
(
aOther
.
mChild
)
mOffset
(
aOther
.
mOffset
)
mIsChildInitialized
(
aOther
.
mIsChildInitialized
)
{
}
nsINode
*
GetContainer
(
)
const
{
return
mParent
;
}
nsIContent
*
GetContainerAsContent
(
)
const
{
return
nsIContent
:
:
FromNodeOrNull
(
mParent
)
;
}
MOZ_NEVER_INLINE_DEBUG
nsIContent
*
ContainerAsContent
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
IsContent
(
)
)
;
return
mParent
-
>
AsContent
(
)
;
}
dom
:
:
Element
*
GetContainerAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mParent
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Element
*
ContainerAsElement
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
IsElement
(
)
)
;
return
mParent
-
>
AsElement
(
)
;
}
nsStyledElement
*
GetContainerAsStyledElement
(
)
const
{
return
nsStyledElement
:
:
FromNodeOrNull
(
mParent
)
;
}
dom
:
:
Text
*
GetContainerAsText
(
)
const
{
return
dom
:
:
Text
:
:
FromNodeOrNull
(
mParent
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Text
*
ContainerAsText
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
IsInTextNode
(
)
)
;
return
mParent
-
>
AsText
(
)
;
}
nsINode
*
GetContainerParent
(
)
const
{
return
mParent
?
mParent
-
>
GetParent
(
)
:
nullptr
;
}
nsIContent
*
GetContainerParentAsContent
(
)
const
{
return
nsIContent
:
:
FromNodeOrNull
(
GetContainerParent
(
)
)
;
}
dom
:
:
Element
*
GetContainerParentAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
GetContainerParent
(
)
)
;
}
bool
CanContainerHaveChildren
(
)
const
{
return
mParent
&
&
mParent
-
>
IsContainerNode
(
)
;
}
bool
IsContainerEmpty
(
)
const
{
return
mParent
&
&
!
mParent
-
>
Length
(
)
;
}
bool
IsInContentNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsContent
(
)
;
}
bool
IsInDataNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsCharacterData
(
)
;
}
bool
IsInTextNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsText
(
)
;
}
bool
IsInNativeAnonymousSubtree
(
)
const
{
return
mParent
&
&
mParent
-
>
IsInNativeAnonymousSubtree
(
)
;
}
bool
IsContainerHTMLElement
(
nsAtom
*
aTag
)
const
{
return
mParent
&
&
mParent
-
>
IsHTMLElement
(
aTag
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
bool
IsContainerAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
mParent
&
&
mParent
-
>
IsAnyOfHTMLElements
(
aFirst
aArgs
.
.
.
)
;
}
nsIContent
*
GetChild
(
)
const
{
if
(
!
mParent
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
;
}
nsIContent
*
GetNextSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
nsIContent
*
GetPreviousSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
char16_t
Char
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAsText
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
Char
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharNBSP
(
)
const
{
return
Char
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
Char
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharHighSurrogateFollowedByLowSurrogate
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAsText
(
)
-
>
TextFragment
(
)
.
IsHighSurrogateFollowedByLowSurrogateAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsCharLowSurrogateFollowingHighSurrogate
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsEndOfContainer
(
)
)
;
return
ContainerAsText
(
)
-
>
TextFragment
(
)
.
IsLowSurrogateFollowingHighSurrogateAt
(
mOffset
.
value
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
char16_t
PreviousChar
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsStartOfContainer
(
)
)
;
return
ContainerAsText
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
-
1
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
PreviousChar
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharNBSP
(
)
const
{
return
PreviousChar
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsPreviousCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
PreviousChar
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
char16_t
NextChar
(
)
const
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
IsAtLastContent
(
)
&
&
!
IsEndOfContainer
(
)
)
;
return
ContainerAsText
(
)
-
>
TextFragment
(
)
.
CharAt
(
mOffset
.
value
(
)
+
1
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharASCIISpace
(
)
const
{
return
nsCRT
:
:
IsAsciiSpace
(
NextChar
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharNBSP
(
)
const
{
return
NextChar
(
)
=
=
0x00A0
;
}
MOZ_NEVER_INLINE_DEBUG
bool
IsNextCharASCIISpaceOrNBSP
(
)
const
{
char16_t
ch
=
NextChar
(
)
;
return
nsCRT
:
:
IsAsciiSpace
(
ch
)
|
|
ch
=
=
0x00A0
;
}
uint32_t
Offset
(
)
const
{
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
;
}
if
(
!
mParent
)
{
MOZ_ASSERT
(
!
mChild
)
;
return
0
;
}
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
If
the
container
cannot
have
children
mOffset
.
isSome
(
)
should
"
"
be
true
"
)
;
if
(
!
mChild
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
return
mOffset
.
value
(
)
;
}
MOZ_ASSERT
(
mChild
-
>
GetParentNode
(
)
=
=
mParent
)
;
if
(
mChild
=
=
mParent
-
>
GetFirstChild
(
)
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
0
)
;
}
else
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
ComputeIndexOf
(
mChild
)
)
;
}
return
mOffset
.
value
(
)
;
}
template
<
typename
ContainerType
>
void
Set
(
ContainerType
*
aContainer
int32_t
aOffset
)
{
mParent
=
aContainer
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
aOffset
)
;
mIsChildInitialized
=
false
;
NS_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
out
of
bounds
"
)
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
void
Set
(
const
StrongPtr
<
ContainerType
>
&
aContainer
int32_t
aOffset
)
{
Set
(
aContainer
.
get
(
)
aOffset
)
;
}
void
Set
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
if
(
NS_WARN_IF
(
!
aChild
-
>
IsContent
(
)
)
)
{
Clear
(
)
;
return
;
}
mParent
=
aChild
-
>
GetParentNode
(
)
;
mChild
=
const_cast
<
nsIContent
*
>
(
aChild
-
>
AsContent
(
)
)
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
true
;
}
template
<
typename
ContainerType
>
MOZ_NEVER_INLINE_DEBUG
void
SetToEndOf
(
const
ContainerType
*
aContainer
)
{
MOZ_ASSERT
(
aContainer
)
;
mParent
=
const_cast
<
ContainerType
*
>
(
aContainer
)
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
void
SetToEndOf
(
const
StrongPtr
<
ContainerType
>
&
aContainer
)
{
SetToEndOf
(
aContainer
.
get
(
)
)
;
}
template
<
typename
ContainerType
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
AtEndOf
(
const
ContainerType
&
aContainer
)
{
SelfType
point
;
point
.
SetToEndOf
(
&
aContainer
)
;
return
point
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
AtEndOf
(
const
StrongPtr
<
ContainerType
>
&
aContainer
)
{
MOZ_ASSERT
(
aContainer
.
get
(
)
)
;
return
AtEndOf
(
*
aContainer
.
get
(
)
)
;
}
void
SetAfter
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
nsIContent
*
nextSibling
=
aChild
-
>
GetNextSibling
(
)
;
if
(
nextSibling
)
{
Set
(
nextSibling
)
;
return
;
}
nsINode
*
parentNode
=
aChild
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
Clear
(
)
;
return
;
}
SetToEndOf
(
parentNode
)
;
}
template
<
typename
ContainerType
>
static
SelfType
After
(
const
ContainerType
&
aContainer
)
{
SelfType
point
;
point
.
SetAfter
(
&
aContainer
)
;
return
point
;
}
template
<
typename
ContainerType
template
<
typename
>
typename
StrongPtr
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
After
(
const
StrongPtr
<
ContainerType
>
&
aContainer
)
{
MOZ_ASSERT
(
aContainer
.
get
(
)
)
;
return
After
(
*
aContainer
.
get
(
)
)
;
}
template
<
typename
PT
typename
CT
>
MOZ_NEVER_INLINE_DEBUG
static
SelfType
After
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
aPoint
.
mChild
)
{
return
After
(
*
aPoint
.
mChild
)
;
}
if
(
NS_WARN_IF
(
aPoint
.
IsEndOfContainer
(
)
)
)
{
return
SelfType
(
)
;
}
SelfType
point
(
aPoint
)
;
MOZ_ALWAYS_TRUE
(
point
.
AdvanceOffset
(
)
)
;
return
point
;
}
MOZ_NEVER_INLINE_DEBUG
SelfType
NextPoint
(
)
const
{
NS_ASSERTION
(
!
IsEndOfContainer
(
)
"
Should
not
be
at
end
of
the
container
"
)
;
SelfType
result
(
*
this
)
;
result
.
AdvanceOffset
(
)
;
return
result
;
}
MOZ_NEVER_INLINE_DEBUG
SelfType
PreviousPoint
(
)
const
{
NS_ASSERTION
(
!
IsStartOfContainer
(
)
"
Should
not
be
at
start
of
the
container
"
)
;
SelfType
result
(
*
this
)
;
result
.
RewindOffset
(
)
;
return
result
;
}
void
Clear
(
)
{
mParent
=
nullptr
;
mChild
=
nullptr
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
false
;
}
bool
AdvanceOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
!
mChild
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
}
mChild
=
mChild
-
>
GetNextSibling
(
)
;
return
true
;
}
bool
RewindOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
!
mOffset
.
value
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
mChild
&
&
!
mChild
-
>
GetPreviousSibling
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
!
mOffset
.
value
(
)
)
)
{
return
false
;
}
nsIContent
*
previousSibling
=
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
previousSibling
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
}
mChild
=
previousSibling
;
return
true
;
}
EditorRawDOMPoint
GetNonAnonymousSubtreePoint
(
)
const
{
if
(
NS_WARN_IF
(
!
IsSet
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
IsInNativeAnonymousSubtree
(
)
)
{
return
EditorRawDOMPoint
(
*
this
)
;
}
nsINode
*
parent
;
for
(
parent
=
mParent
-
>
GetParentNode
(
)
;
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
}
if
(
!
parent
)
{
return
EditorRawDOMPoint
(
)
;
}
return
EditorRawDOMPoint
(
parent
)
;
}
bool
IsSet
(
)
const
{
return
mParent
&
&
(
mIsChildInitialized
|
|
mOffset
.
isSome
(
)
)
;
}
bool
IsSetAndValid
(
)
const
{
if
(
!
IsSet
(
)
)
{
return
false
;
}
if
(
mChild
&
&
mChild
-
>
GetParentNode
(
)
!
=
mParent
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
{
return
false
;
}
return
true
;
}
bool
HasChildMovedFromContainer
(
)
const
{
return
mChild
&
&
mChild
-
>
GetParentNode
(
)
!
=
mParent
;
}
bool
IsStartOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
!
mOffset
.
value
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
mParent
-
>
GetFirstChild
(
)
=
=
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
!
mOffset
.
value
(
)
"
If
mOffset
was
initialized
it
should
be
0
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
!
mOffset
.
value
(
)
;
}
bool
IsEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
!
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
"
If
mOffset
was
initialized
it
should
be
length
of
the
container
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
bool
IsAtLastContent
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
mParent
-
>
IsContainerNode
(
)
&
&
mOffset
.
isSome
(
)
)
{
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
;
}
if
(
mIsChildInitialized
)
{
if
(
mChild
&
&
mChild
=
=
mParent
-
>
GetLastChild
(
)
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
"
If
mOffset
was
initialized
it
should
be
length
-
1
of
the
"
"
container
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
-
1
;
}
bool
IsBRElementAtEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
false
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
if
(
!
mChild
|
|
mChild
-
>
GetNextSibling
(
)
)
{
return
false
;
}
return
mChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
template
<
typename
A
typename
B
>
EditorDOMPointBase
&
operator
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mChild
=
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
&
&
aOther
.
mParent
-
>
IsContainerNode
(
)
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
;
mOffset
=
aOther
.
mOffset
;
mIsChildInitialized
=
aOther
.
mRef
|
|
(
aOther
.
mParent
&
&
!
aOther
.
mParent
-
>
IsContainerNode
(
)
)
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
;
return
*
this
;
}
template
<
typename
A
typename
B
>
EditorDOMPointBase
&
operator
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mChild
=
aOther
.
mChild
;
mOffset
=
aOther
.
mOffset
;
mIsChildInitialized
=
aOther
.
mIsChildInitialized
;
return
*
this
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
mParent
!
=
aOther
.
mParent
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
aOther
.
mOffset
.
isSome
(
)
)
{
if
(
mOffset
!
=
aOther
.
mOffset
)
{
return
false
;
}
if
(
mChild
=
=
aOther
.
mChild
)
{
return
true
;
}
if
(
NS_WARN_IF
(
mIsChildInitialized
&
&
aOther
.
mIsChildInitialized
)
)
{
return
false
;
}
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
|
|
aOther
.
mIsChildInitialized
)
;
if
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
&
&
!
aOther
.
mOffset
.
isSome
(
)
&
&
aOther
.
mIsChildInitialized
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
if
(
!
mOffset
.
isSome
(
)
&
&
mIsChildInitialized
&
&
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mIsChildInitialized
)
{
const_cast
<
EditorDOMPointBase
<
A
B
>
&
>
(
aOther
)
.
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
return
mChild
=
=
aOther
.
mChild
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
*
this
=
=
SelfType
(
aOther
)
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
operator
const
RawRangeBoundary
(
)
const
{
return
ToRawRangeBoundary
(
)
;
}
const
RawRangeBoundary
ToRawRangeBoundary
(
)
const
{
if
(
!
IsSet
(
)
|
|
NS_WARN_IF
(
!
mIsChildInitialized
&
&
!
mOffset
.
isSome
(
)
)
)
{
return
RawRangeBoundary
(
)
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mIsChildInitialized
&
&
mOffset
.
isSome
(
)
)
{
#
ifdef
DEBUG
if
(
mChild
)
{
MOZ_ASSERT
(
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
else
{
MOZ_ASSERT
(
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
)
;
}
#
endif
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mOffset
.
isSome
(
)
)
{
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mChild
)
{
return
RawRangeBoundary
(
mParent
mChild
-
>
GetPreviousSibling
(
)
)
;
}
return
RawRangeBoundary
(
mParent
mParent
-
>
GetLastChild
(
)
)
;
}
EditorDOMPointInText
GetAsInText
(
)
const
{
return
IsInTextNode
(
)
?
EditorDOMPointInText
(
ContainerAsText
(
)
Offset
(
)
)
:
EditorDOMPointInText
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMPointInText
AsInText
(
)
const
{
MOZ_ASSERT
(
IsInTextNode
(
)
)
;
return
EditorDOMPointInText
(
ContainerAsText
(
)
Offset
(
)
)
;
}
template
<
typename
A
typename
B
>
bool
IsBefore
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
!
IsSetAndValid
(
)
|
|
!
aOther
.
IsSetAndValid
(
)
)
{
return
false
;
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
ToRawRangeBoundary
(
)
aOther
.
ToRawRangeBoundary
(
)
)
;
return
comp
.
isSome
(
)
&
&
comp
.
value
(
)
=
=
-
1
;
}
template
<
typename
A
typename
B
>
bool
EqualsOrIsBefore
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
!
IsSetAndValid
(
)
|
|
!
aOther
.
IsSetAndValid
(
)
)
{
return
false
;
}
Maybe
<
int32_t
>
comp
=
nsContentUtils
:
:
ComparePoints
(
ToRawRangeBoundary
(
)
aOther
.
ToRawRangeBoundary
(
)
)
;
return
comp
.
isSome
(
)
&
&
comp
.
value
(
)
<
=
0
;
}
private
:
void
EnsureChild
(
)
{
if
(
mIsChildInitialized
)
{
return
;
}
if
(
!
mParent
)
{
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
)
;
return
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
;
}
mChild
=
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
)
;
}
ParentType
mParent
;
ChildType
mChild
;
mozilla
:
:
Maybe
<
uint32_t
>
mOffset
;
bool
mIsChildInitialized
;
template
<
typename
PT
typename
CT
>
friend
class
EditorDOMPointBase
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
EditorDOMPoint
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mParent
)
;
ImplCycleCollectionUnlink
(
aField
.
mChild
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EditorDOMPoint
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mParent
"
mParent
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mChild
"
mChild
"
0
)
;
}
template
<
typename
EditorDOMPointType
>
class
EditorDOMRangeBase
;
typedef
EditorDOMRangeBase
<
EditorDOMPoint
>
EditorDOMRange
;
typedef
EditorDOMRangeBase
<
EditorRawDOMPoint
>
EditorRawDOMRange
;
typedef
EditorDOMRangeBase
<
EditorDOMPointInText
>
EditorDOMRangeInTexts
;
typedef
EditorDOMRangeBase
<
EditorRawDOMPointInText
>
EditorRawDOMRangeInTexts
;
template
<
typename
EditorDOMPointType
>
class
EditorDOMRangeBase
final
{
public
:
EditorDOMRangeBase
(
)
=
default
;
template
<
typename
PT
typename
CT
>
explicit
EditorDOMRangeBase
(
const
EditorDOMPointBase
<
PT
CT
>
&
aStart
)
:
mStart
(
aStart
)
mEnd
(
aStart
)
{
MOZ_ASSERT
(
!
mStart
.
IsSet
(
)
|
|
mStart
.
IsSetAndValid
(
)
)
;
}
template
<
typename
StartPointType
typename
EndPointType
>
explicit
EditorDOMRangeBase
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
mStart
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsSet
(
)
mEnd
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
mStart
.
EqualsOrIsBefore
(
mEnd
)
)
;
}
explicit
EditorDOMRangeBase
(
const
dom
:
:
AbstractRange
&
aRange
)
:
mStart
(
aRange
.
StartRef
(
)
)
mEnd
(
aRange
.
EndRef
(
)
)
{
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
mStart
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsSet
(
)
mEnd
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
mStart
.
EqualsOrIsBefore
(
mEnd
)
)
;
}
template
<
typename
PointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStart
(
const
PointType
&
aStart
)
{
mStart
=
aStart
;
}
template
<
typename
PointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetEnd
(
const
PointType
&
aEnd
)
{
mEnd
=
aEnd
;
}
template
<
typename
StartPointType
typename
EndPointType
>
MOZ_NEVER_INLINE_DEBUG
void
SetStartAndEnd
(
const
StartPointType
&
aStart
const
EndPointType
&
aEnd
)
{
MOZ_ASSERT_IF
(
aStart
.
IsSet
(
)
&
&
aEnd
.
IsSet
(
)
aStart
.
EqualsOrIsBefore
(
aEnd
)
)
;
mStart
=
aStart
;
mEnd
=
aEnd
;
}
const
EditorDOMPointType
&
StartRef
(
)
const
{
return
mStart
;
}
const
EditorDOMPointType
&
EndRef
(
)
const
{
return
mEnd
;
}
bool
Collapsed
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
mStart
=
=
mEnd
;
}
bool
IsPositioned
(
)
const
{
return
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
;
}
bool
IsPositionedAndValid
(
)
const
{
return
mStart
.
IsSetAndValid
(
)
&
&
mEnd
.
IsSetAndValid
(
)
&
&
mStart
.
EqualsOrIsBefore
(
mEnd
)
;
}
template
<
typename
OtherPointType
>
MOZ_NEVER_INLINE_DEBUG
bool
Contains
(
const
OtherPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
return
IsPositioned
(
)
&
&
aPoint
.
IsSet
(
)
&
&
mStart
.
EqualsOrIsBefore
(
aPoint
)
&
&
aPoint
.
IsBefore
(
mEnd
)
;
}
bool
InSameContainer
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
GetContainer
(
)
=
=
mEnd
.
GetContainer
(
)
;
}
bool
IsInContentNodes
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
IsInContentNode
(
)
&
&
mEnd
.
IsInContentNode
(
)
;
}
bool
IsInTextNodes
(
)
const
{
MOZ_ASSERT
(
IsPositioned
(
)
)
;
return
IsPositioned
(
)
&
&
mStart
.
IsInTextNode
(
)
&
&
mEnd
.
IsInTextNode
(
)
;
}
template
<
typename
OtherRangeType
>
bool
operator
=
=
(
const
OtherRangeType
&
aOther
)
const
{
return
(
!
IsPositioned
(
)
&
&
!
aOther
.
IsPositioned
(
)
)
|
|
(
mStart
=
=
aOther
.
mStart
&
&
mEnd
=
=
aOther
.
mEnd
)
;
}
template
<
typename
OtherRangeType
>
bool
operator
!
=
(
const
OtherRangeType
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
EditorDOMRangeInTexts
GetAsInTexts
(
)
const
{
return
IsInTextNodes
(
)
?
EditorDOMRangeInTexts
(
mStart
.
AsInText
(
)
mEnd
.
AsInText
(
)
)
:
EditorDOMRangeInTexts
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMRangeInTexts
AsInTexts
(
)
const
{
MOZ_ASSERT
(
IsInTextNodes
(
)
)
;
return
EditorDOMRangeInTexts
(
mStart
.
AsInText
(
)
mEnd
.
AsInText
(
)
)
;
}
private
:
EditorDOMPointType
mStart
;
EditorDOMPointType
mEnd
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
EditorDOMRange
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
EditorDOMRange
&
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
EditorDOMRange
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mStart
)
;
ImplCycleCollectionUnlink
(
aField
.
mEnd
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EditorDOMRange
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mStart
"
mStart
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mEnd
"
mEnd
"
0
)
;
}
class
MOZ_STACK_CLASS
AutoEditorDOMPointOffsetInvalidator
final
{
public
:
explicit
AutoEditorDOMPointOffsetInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mPoint
.
CanContainerHaveChildren
(
)
)
;
mChild
=
mPoint
.
GetChild
(
)
;
}
~
AutoEditorDOMPointOffsetInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateOffset
(
)
;
}
}
void
InvalidateOffset
(
)
{
if
(
mChild
)
{
mPoint
.
Set
(
mChild
)
;
}
else
{
mPoint
.
SetToEndOf
(
mPoint
.
GetContainer
(
)
)
;
}
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
nsCOMPtr
<
nsIContent
>
mChild
;
bool
mCanceled
;
AutoEditorDOMPointOffsetInvalidator
(
)
=
delete
;
AutoEditorDOMPointOffsetInvalidator
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointOffsetInvalidator
&
operator
=
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
AutoEditorDOMPointChildInvalidator
final
{
public
:
explicit
AutoEditorDOMPointChildInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
Unused
<
<
mPoint
.
Offset
(
)
;
}
~
AutoEditorDOMPointChildInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateChild
(
)
;
}
}
void
InvalidateChild
(
)
{
mPoint
.
Set
(
mPoint
.
GetContainer
(
)
mPoint
.
Offset
(
)
)
;
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
bool
mCanceled
;
AutoEditorDOMPointChildInvalidator
(
)
=
delete
;
AutoEditorDOMPointChildInvalidator
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointChildInvalidator
&
operator
=
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
}
;
}
#
endif
