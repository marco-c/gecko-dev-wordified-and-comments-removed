#
ifndef
mozilla_EditorDOMPoint_h
#
define
mozilla_EditorDOMPoint_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
namespace
mozilla
{
template
<
typename
ParentType
typename
ChildType
>
class
EditorDOMPointBase
;
typedef
EditorDOMPointBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
EditorDOMPoint
;
typedef
EditorDOMPointBase
<
nsINode
*
nsIContent
*
>
EditorRawDOMPoint
;
template
<
typename
ParentType
typename
ChildType
>
class
EditorDOMPointBase
final
{
typedef
EditorDOMPointBase
<
ParentType
ChildType
>
SelfType
;
public
:
EditorDOMPointBase
(
)
:
mParent
(
nullptr
)
mChild
(
nullptr
)
mIsChildInitialized
(
false
)
{
}
template
<
typename
ContainerType
>
EditorDOMPointBase
(
ContainerType
aContainer
int32_t
aOffset
)
:
mParent
(
aContainer
)
mChild
(
nullptr
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsChildInitialized
(
false
)
{
NS_WARNING_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
larger
than
the
length
of
aContainer
or
negative
"
)
;
if
(
!
mParent
)
{
mOffset
.
reset
(
)
;
}
}
explicit
EditorDOMPointBase
(
nsINode
*
aPointedNode
)
:
mParent
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
aPointedNode
-
>
GetParentNode
(
)
:
nullptr
)
mChild
(
aPointedNode
&
&
aPointedNode
-
>
IsContent
(
)
?
aPointedNode
-
>
AsContent
(
)
:
nullptr
)
mIsChildInitialized
(
false
)
{
mIsChildInitialized
=
aPointedNode
&
&
mChild
;
NS_WARNING_ASSERTION
(
IsSet
(
)
"
The
child
is
nullptr
or
doesn
'
t
have
its
parent
"
)
;
NS_WARNING_ASSERTION
(
mChild
&
&
mChild
-
>
GetParentNode
(
)
=
=
mParent
"
Initializing
RangeBoundary
with
invalid
value
"
)
;
}
EditorDOMPointBase
(
nsINode
*
aContainer
nsIContent
*
aPointedNode
int32_t
aOffset
)
:
mParent
(
aContainer
)
mChild
(
aPointedNode
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsChildInitialized
(
true
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aContainer
"
This
constructor
shouldn
'
t
be
used
when
pointing
nowhere
"
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
;
MOZ_ASSERT
(
!
mChild
|
|
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
template
<
typename
PT
typename
CT
>
explicit
EditorDOMPointBase
(
const
RangeBoundaryBase
<
PT
CT
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mChild
(
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
)
mOffset
(
aOther
.
mOffset
)
mIsChildInitialized
(
aOther
.
mRef
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
)
{
}
template
<
typename
PT
typename
CT
>
MOZ_IMPLICIT
EditorDOMPointBase
(
const
EditorDOMPointBase
<
PT
CT
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mChild
(
aOther
.
mChild
)
mOffset
(
aOther
.
mOffset
)
mIsChildInitialized
(
aOther
.
mIsChildInitialized
)
{
}
nsINode
*
GetContainer
(
)
const
{
return
mParent
;
}
nsIContent
*
GetContainerAsContent
(
)
const
{
return
nsIContent
:
:
FromNodeOrNull
(
mParent
)
;
}
dom
:
:
Element
*
GetContainerAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
mParent
)
;
}
dom
:
:
Text
*
GetContainerAsText
(
)
const
{
return
dom
:
:
Text
:
:
FromNodeOrNull
(
mParent
)
;
}
nsINode
*
GetContainerParent
(
)
const
{
return
mParent
?
mParent
-
>
GetParent
(
)
:
nullptr
;
}
nsIContent
*
GetContainerParentAsContent
(
)
const
{
return
nsIContent
:
:
FromNodeOrNull
(
GetContainerParent
(
)
)
;
}
dom
:
:
Element
*
GetContainerParentAsElement
(
)
const
{
return
dom
:
:
Element
:
:
FromNodeOrNull
(
GetContainerParent
(
)
)
;
}
bool
CanContainerHaveChildren
(
)
const
{
return
mParent
&
&
mParent
-
>
IsContainerNode
(
)
;
}
bool
IsInDataNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsCharacterData
(
)
;
}
bool
IsInTextNode
(
)
const
{
return
mParent
&
&
mParent
-
>
IsText
(
)
;
}
bool
IsInNativeAnonymousSubtree
(
)
const
{
return
mParent
&
&
mParent
-
>
IsInNativeAnonymousSubtree
(
)
;
}
bool
IsContainerHTMLElement
(
nsAtom
*
aTag
)
const
{
return
mParent
&
&
mParent
-
>
IsHTMLElement
(
aTag
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
bool
IsContainerAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
mParent
&
&
mParent
-
>
IsAnyOfHTMLElements
(
aFirst
aArgs
.
.
.
)
;
}
nsIContent
*
GetChild
(
)
const
{
if
(
!
mParent
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
;
}
nsIContent
*
GetNextSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetNextSibling
(
)
:
nullptr
;
}
nsIContent
*
GetPreviousSiblingOfChild
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
if
(
mIsChildInitialized
)
{
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
}
uint32_t
Offset
(
)
const
{
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
;
}
if
(
!
mParent
)
{
MOZ_ASSERT
(
!
mChild
)
;
return
0
;
}
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
If
the
container
cannot
have
children
mOffset
.
isSome
(
)
should
"
"
be
true
"
)
;
if
(
!
mChild
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
return
mOffset
.
value
(
)
;
}
MOZ_ASSERT
(
mChild
-
>
GetParentNode
(
)
=
=
mParent
)
;
if
(
mChild
=
=
mParent
-
>
GetFirstChild
(
)
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
0
)
;
}
else
{
const_cast
<
SelfType
*
>
(
this
)
-
>
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
ComputeIndexOf
(
mChild
)
)
;
}
return
mOffset
.
value
(
)
;
}
void
Set
(
nsINode
*
aContainer
int32_t
aOffset
)
{
mParent
=
aContainer
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
aOffset
)
;
mIsChildInitialized
=
false
;
NS_ASSERTION
(
!
mParent
|
|
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
"
The
offset
is
out
of
bounds
"
)
;
}
void
Set
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
if
(
NS_WARN_IF
(
!
aChild
-
>
IsContent
(
)
)
)
{
Clear
(
)
;
return
;
}
mParent
=
aChild
-
>
GetParentNode
(
)
;
mChild
=
const_cast
<
nsIContent
*
>
(
aChild
-
>
AsContent
(
)
)
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
true
;
}
void
SetToEndOf
(
const
nsINode
*
aContainer
)
{
MOZ_ASSERT
(
aContainer
)
;
mParent
=
const_cast
<
nsINode
*
>
(
aContainer
)
;
mChild
=
nullptr
;
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
}
static
SelfType
AtEndOf
(
const
nsINode
&
aContainer
)
{
SelfType
point
;
point
.
SetToEndOf
(
&
aContainer
)
;
return
point
;
}
void
SetAfter
(
const
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
nsIContent
*
nextSibling
=
aChild
-
>
GetNextSibling
(
)
;
if
(
nextSibling
)
{
Set
(
nextSibling
)
;
return
;
}
nsINode
*
parentNode
=
aChild
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
Clear
(
)
;
return
;
}
SetToEndOf
(
parentNode
)
;
}
void
Clear
(
)
{
mParent
=
nullptr
;
mChild
=
nullptr
;
mOffset
.
reset
(
)
;
mIsChildInitialized
=
false
;
}
bool
AdvanceOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
!
mChild
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
=
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
+
1
)
;
}
mChild
=
mChild
-
>
GetNextSibling
(
)
;
return
true
;
}
bool
RewindOffset
(
)
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
)
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
if
(
NS_WARN_IF
(
!
mOffset
.
value
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
)
{
return
false
;
}
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
)
;
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
!
mParent
-
>
HasChildren
(
)
)
|
|
NS_WARN_IF
(
mChild
&
&
!
mChild
-
>
GetPreviousSibling
(
)
)
|
|
NS_WARN_IF
(
mOffset
.
isSome
(
)
&
&
!
mOffset
.
value
(
)
)
)
{
return
false
;
}
nsIContent
*
previousSibling
=
mChild
?
mChild
-
>
GetPreviousSibling
(
)
:
mParent
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
previousSibling
)
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
)
{
mOffset
=
mozilla
:
:
Some
(
mOffset
.
value
(
)
-
1
)
;
}
mChild
=
previousSibling
;
return
true
;
}
EditorRawDOMPoint
GetNonAnonymousSubtreePoint
(
)
const
{
if
(
NS_WARN_IF
(
!
IsSet
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
IsInNativeAnonymousSubtree
(
)
)
{
return
EditorRawDOMPoint
(
*
this
)
;
}
nsINode
*
parent
;
for
(
parent
=
mParent
-
>
GetParentNode
(
)
;
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
;
parent
=
parent
-
>
GetParentNode
(
)
)
{
}
if
(
!
parent
)
{
return
EditorRawDOMPoint
(
)
;
}
return
EditorRawDOMPoint
(
parent
)
;
}
bool
IsSet
(
)
const
{
return
mParent
&
&
(
mIsChildInitialized
|
|
mOffset
.
isSome
(
)
)
;
}
bool
IsSetAndValid
(
)
const
{
if
(
!
IsSet
(
)
)
{
return
false
;
}
if
(
mChild
&
&
mChild
-
>
GetParentNode
(
)
!
=
mParent
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
>
mParent
-
>
Length
(
)
)
{
return
false
;
}
return
true
;
}
bool
HasChildMovedFromContainer
(
)
const
{
return
mChild
&
&
mChild
-
>
GetParentNode
(
)
!
=
mParent
;
}
bool
IsStartOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
!
mOffset
.
value
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
mParent
-
>
GetFirstChild
(
)
=
=
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
!
mOffset
.
value
(
)
"
If
mOffset
was
initialized
it
should
be
0
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
If
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
!
mOffset
.
value
(
)
;
}
bool
IsEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
if
(
mIsChildInitialized
)
{
if
(
!
mChild
)
{
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
"
If
mOffset
was
initialized
it
should
be
length
of
the
container
"
)
;
return
true
;
}
NS_WARNING_ASSERTION
(
!
mOffset
.
isSome
(
)
|
|
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
"
If
mOffset
and
mChild
are
mismatched
"
)
;
return
false
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
;
}
bool
IsBRElementAtEndOfContainer
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
)
{
return
false
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
false
;
}
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
if
(
!
mChild
|
|
mChild
-
>
GetNextSibling
(
)
)
{
return
false
;
}
return
mChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
}
template
<
typename
A
typename
B
>
EditorDOMPointBase
&
operator
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mChild
=
aOther
.
mRef
?
aOther
.
mRef
-
>
GetNextSibling
(
)
:
(
aOther
.
mParent
&
&
aOther
.
mParent
-
>
IsContainerNode
(
)
?
aOther
.
mParent
-
>
GetFirstChild
(
)
:
nullptr
)
;
mOffset
=
aOther
.
mOffset
;
mIsChildInitialized
=
aOther
.
mRef
|
|
(
aOther
.
mParent
&
&
!
aOther
.
mParent
-
>
IsContainerNode
(
)
)
|
|
(
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mOffset
.
value
(
)
)
;
return
*
this
;
}
template
<
typename
A
typename
B
>
EditorDOMPointBase
&
operator
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mChild
=
aOther
.
mChild
;
mOffset
=
aOther
.
mOffset
;
mIsChildInitialized
=
aOther
.
mIsChildInitialized
;
return
*
this
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
if
(
mParent
!
=
aOther
.
mParent
)
{
return
false
;
}
if
(
mOffset
.
isSome
(
)
&
&
aOther
.
mOffset
.
isSome
(
)
)
{
if
(
mOffset
!
=
aOther
.
mOffset
)
{
return
false
;
}
if
(
mChild
=
=
aOther
.
mChild
)
{
return
true
;
}
if
(
NS_WARN_IF
(
mIsChildInitialized
&
&
aOther
.
mIsChildInitialized
)
)
{
return
false
;
}
return
true
;
}
MOZ_ASSERT
(
mIsChildInitialized
|
|
aOther
.
mIsChildInitialized
)
;
if
(
mOffset
.
isSome
(
)
&
&
!
mIsChildInitialized
&
&
!
aOther
.
mOffset
.
isSome
(
)
&
&
aOther
.
mIsChildInitialized
)
{
const_cast
<
SelfType
*
>
(
this
)
-
>
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
if
(
!
mOffset
.
isSome
(
)
&
&
mIsChildInitialized
&
&
aOther
.
mOffset
.
isSome
(
)
&
&
!
aOther
.
mIsChildInitialized
)
{
const_cast
<
EditorDOMPointBase
<
A
B
>
&
>
(
aOther
)
.
EnsureChild
(
)
;
return
mChild
=
=
aOther
.
mChild
;
}
return
mChild
=
=
aOther
.
mChild
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
EditorDOMPointBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
operator
const
RawRangeBoundary
(
)
const
{
return
ToRawRangeBoundary
(
)
;
}
const
RawRangeBoundary
ToRawRangeBoundary
(
)
const
{
if
(
!
IsSet
(
)
|
|
NS_WARN_IF
(
!
mIsChildInitialized
&
&
!
mOffset
.
isSome
(
)
)
)
{
return
RawRangeBoundary
(
)
;
}
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mIsChildInitialized
&
&
mOffset
.
isSome
(
)
)
{
#
ifdef
DEBUG
if
(
mChild
)
{
MOZ_ASSERT
(
mParent
=
=
mChild
-
>
GetParentNode
(
)
)
;
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
=
=
mChild
)
;
}
else
{
MOZ_ASSERT
(
mParent
-
>
Length
(
)
=
=
mOffset
.
value
(
)
)
;
}
#
endif
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mOffset
.
isSome
(
)
)
{
return
RawRangeBoundary
(
mParent
mOffset
.
value
(
)
)
;
}
if
(
mChild
)
{
return
RawRangeBoundary
(
mParent
mChild
-
>
GetPreviousSibling
(
)
)
;
}
return
RawRangeBoundary
(
mParent
mParent
-
>
GetLastChild
(
)
)
;
}
private
:
void
EnsureChild
(
)
{
if
(
mIsChildInitialized
)
{
return
;
}
if
(
!
mParent
)
{
MOZ_ASSERT
(
!
mOffset
.
isSome
(
)
)
;
return
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
MOZ_ASSERT
(
mOffset
.
value
(
)
<
=
mParent
-
>
Length
(
)
)
;
mIsChildInitialized
=
true
;
if
(
!
mParent
-
>
IsContainerNode
(
)
)
{
return
;
}
mChild
=
mParent
-
>
GetChildAt_Deprecated
(
mOffset
.
value
(
)
)
;
MOZ_ASSERT
(
mChild
|
|
mOffset
.
value
(
)
=
=
mParent
-
>
Length
(
)
)
;
}
ParentType
mParent
;
ChildType
mChild
;
mozilla
:
:
Maybe
<
uint32_t
>
mOffset
;
bool
mIsChildInitialized
;
template
<
typename
PT
typename
CT
>
friend
class
EditorDOMPointBase
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
EditorDOMPoint
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
EditorDOMPoint
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mParent
)
;
ImplCycleCollectionUnlink
(
aField
.
mChild
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EditorDOMPoint
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mParent
"
mParent
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mChild
"
mChild
"
0
)
;
}
class
MOZ_STACK_CLASS
AutoEditorDOMPointOffsetInvalidator
final
{
public
:
explicit
AutoEditorDOMPointOffsetInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mPoint
.
CanContainerHaveChildren
(
)
)
;
mChild
=
mPoint
.
GetChild
(
)
;
}
~
AutoEditorDOMPointOffsetInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateOffset
(
)
;
}
}
void
InvalidateOffset
(
)
{
if
(
mChild
)
{
mPoint
.
Set
(
mChild
)
;
}
else
{
mPoint
.
SetToEndOf
(
mPoint
.
GetContainer
(
)
)
;
}
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
nsCOMPtr
<
nsIContent
>
mChild
;
bool
mCanceled
;
AutoEditorDOMPointOffsetInvalidator
(
)
=
delete
;
AutoEditorDOMPointOffsetInvalidator
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointOffsetInvalidator
&
operator
=
(
const
AutoEditorDOMPointOffsetInvalidator
&
aOther
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
AutoEditorDOMPointChildInvalidator
final
{
public
:
explicit
AutoEditorDOMPointChildInvalidator
(
EditorDOMPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mCanceled
(
false
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
Unused
<
<
mPoint
.
Offset
(
)
;
}
~
AutoEditorDOMPointChildInvalidator
(
)
{
if
(
!
mCanceled
)
{
InvalidateChild
(
)
;
}
}
void
InvalidateChild
(
)
{
mPoint
.
Set
(
mPoint
.
GetContainer
(
)
mPoint
.
Offset
(
)
)
;
}
void
Cancel
(
)
{
mCanceled
=
true
;
}
private
:
EditorDOMPoint
&
mPoint
;
bool
mCanceled
;
AutoEditorDOMPointChildInvalidator
(
)
=
delete
;
AutoEditorDOMPointChildInvalidator
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
const
AutoEditorDOMPointChildInvalidator
&
operator
=
(
const
AutoEditorDOMPointChildInvalidator
&
aOther
)
=
delete
;
}
;
}
#
endif
