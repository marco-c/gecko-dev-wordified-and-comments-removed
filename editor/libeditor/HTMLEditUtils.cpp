#
include
"
HTMLEditUtils
.
h
"
#
include
"
AutoClonedRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
WSRunScanner
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
EditorType
=
EditorBase
:
:
EditorType
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorRawDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorRawDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorRawDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorRawDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorDOMPointInText
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorRawDOMPointInText
&
aPoint
const
Element
&
aEditingHost
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPoint
&
aPoint
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPoint
&
aPoint
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
Result
<
EditorDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorRawDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorRawDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorRawDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorRawDOMPoint
&
aCurrentPoint
)
;
template
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsAString
&
aColorA
const
nsAString
&
aColorB
)
;
template
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsACString
&
aColorA
const
nsACString
&
aColorB
)
;
template
Maybe
<
EditorLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPoint
&
aPoint
)
;
template
Maybe
<
EditorLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
Maybe
<
EditorLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPointInText
&
aPoint
)
;
template
Maybe
<
EditorLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorRawDOMPointInText
&
aPoint
)
;
template
Maybe
<
EditorRawLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPoint
&
aPoint
)
;
template
Maybe
<
EditorRawLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
Maybe
<
EditorRawLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPointInText
&
aPoint
)
;
template
Maybe
<
EditorRawLineBreak
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorRawDOMPointInText
&
aPoint
)
;
template
bool
HTMLEditUtils
:
:
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorDOMPoint
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
;
template
bool
HTMLEditUtils
:
:
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorRawDOMPoint
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
;
template
bool
HTMLEditUtils
:
:
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorDOMPointInText
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
;
template
bool
HTMLEditUtils
:
:
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorRawDOMPointInText
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
;
template
Maybe
<
EditorLineBreak
>
HTMLEditUtils
:
:
GetUnnecessaryLineBreak
(
const
Element
&
aBlockElement
ScanLineBreak
aScanLineBreak
)
;
template
Maybe
<
EditorRawLineBreak
>
HTMLEditUtils
:
:
GetUnnecessaryLineBreak
(
const
Element
&
aBlockElement
ScanLineBreak
aScanLineBreak
)
;
bool
HTMLEditUtils
:
:
ElementIsEditableRoot
(
const
Element
&
aElement
)
{
MOZ_ASSERT
(
!
aElement
.
IsInNativeAnonymousSubtree
(
)
)
;
if
(
NS_WARN_IF
(
!
aElement
.
IsEditable
(
)
)
|
|
NS_WARN_IF
(
!
aElement
.
IsInComposedDoc
(
)
)
)
{
return
false
;
}
return
!
aElement
.
GetParent
(
)
|
|
!
aElement
.
GetParent
(
)
-
>
IsEditable
(
)
|
|
aElement
.
OwnerDoc
(
)
-
>
GetBody
(
)
=
=
&
aElement
;
}
bool
HTMLEditUtils
:
:
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
)
{
if
(
aLeftContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
aRightContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
false
;
}
if
(
!
aLeftContent
.
IsElement
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
aRightContent
.
IsElement
(
)
)
;
if
(
aLeftContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
font
)
{
const
nsAttrValue
*
const
leftSize
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
size
)
;
const
nsAttrValue
*
const
rightSize
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
size
)
;
if
(
!
leftSize
^
!
rightSize
|
|
(
leftSize
&
&
!
leftSize
-
>
Equals
(
*
rightSize
)
)
)
{
return
false
;
}
const
nsAttrValue
*
const
leftColor
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
color
)
;
const
nsAttrValue
*
const
rightColor
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
color
)
;
if
(
!
leftColor
^
!
rightColor
|
|
(
leftColor
&
&
!
leftColor
-
>
Equals
(
*
rightColor
)
)
)
{
return
false
;
}
const
nsAttrValue
*
const
leftFace
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
face
)
;
const
nsAttrValue
*
const
rightFace
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
face
)
;
if
(
!
leftFace
^
!
rightFace
|
|
(
leftFace
&
&
!
leftFace
-
>
Equals
(
*
rightFace
)
)
)
{
return
false
;
}
}
nsStyledElement
*
leftStyledElement
=
nsStyledElement
:
:
FromNode
(
const_cast
<
nsIContent
*
>
(
&
aLeftContent
)
)
;
if
(
!
leftStyledElement
)
{
return
false
;
}
nsStyledElement
*
rightStyledElement
=
nsStyledElement
:
:
FromNode
(
const_cast
<
nsIContent
*
>
(
&
aRightContent
)
)
;
if
(
!
rightStyledElement
)
{
return
false
;
}
return
CSSEditUtils
:
:
DoStyledElementsHaveSameStyle
(
*
leftStyledElement
*
rightStyledElement
)
;
}
static
bool
IsHTMLBlockElementByDefault
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
MOZ_ASSERT
(
!
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
CaseSensitiveAtomTagToId
(
nsGkAtoms
:
:
br
)
)
)
;
return
false
;
}
if
(
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
return
true
;
}
return
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
CaseSensitiveAtomTagToId
(
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
}
bool
HTMLEditUtils
:
:
IsBlockElement
(
const
nsIContent
&
aContent
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aBlockInlineCheck
!
=
BlockInlineCheck
:
:
Unused
)
;
if
(
MOZ_UNLIKELY
(
!
aContent
.
IsElement
(
)
)
)
{
return
false
;
}
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
false
;
}
if
(
aBlockInlineCheck
=
=
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
{
return
IsHTMLBlockElementByDefault
(
aContent
)
;
}
if
(
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
=
=
&
aContent
|
|
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
aContent
.
OwnerDoc
(
)
-
>
GetBodyElement
(
)
=
=
&
aContent
)
)
{
return
true
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aContent
.
AsElement
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
elementStyle
)
)
{
return
IsHTMLBlockElementByDefault
(
aContent
)
;
}
const
nsStyleDisplay
*
styleDisplay
=
elementStyle
-
>
StyleDisplay
(
)
;
if
(
MOZ_UNLIKELY
(
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
)
{
return
IsHTMLBlockElementByDefault
(
aContent
)
;
}
if
(
styleDisplay
-
>
IsRubyDisplayType
(
)
)
{
return
true
;
}
if
(
!
styleDisplay
-
>
IsInlineOutsideStyle
(
)
)
{
return
true
;
}
return
aBlockInlineCheck
=
=
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
&
styleDisplay
-
>
DisplayInside
(
)
=
=
StyleDisplayInside
:
:
FlowRoot
&
&
styleDisplay
-
>
EffectiveAppearance
(
)
=
=
StyleAppearance
:
:
None
;
}
bool
HTMLEditUtils
:
:
IsInlineContent
(
const
nsIContent
&
aContent
BlockInlineCheck
aBlockInlineCheck
)
{
MOZ_ASSERT
(
aBlockInlineCheck
!
=
BlockInlineCheck
:
:
Unused
)
;
if
(
!
aContent
.
IsElement
(
)
)
{
return
true
;
}
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
if
(
aBlockInlineCheck
=
=
BlockInlineCheck
:
:
UseHTMLDefaultStyle
)
{
return
!
IsHTMLBlockElementByDefault
(
aContent
)
;
}
if
(
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
=
=
&
aContent
|
|
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
aContent
.
OwnerDoc
(
)
-
>
GetBodyElement
(
)
=
=
&
aContent
)
)
{
return
false
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aContent
.
AsElement
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
elementStyle
)
)
{
return
!
IsHTMLBlockElementByDefault
(
aContent
)
;
}
const
nsStyleDisplay
*
styleDisplay
=
elementStyle
-
>
StyleDisplay
(
)
;
if
(
MOZ_UNLIKELY
(
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
)
{
return
!
IsHTMLBlockElementByDefault
(
aContent
)
;
}
return
styleDisplay
-
>
IsInlineOutsideStyle
(
)
|
|
styleDisplay
-
>
IsRubyDisplayType
(
)
;
}
bool
HTMLEditUtils
:
:
IsFlexOrGridItem
(
const
Element
&
aElement
)
{
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
return
frame
&
&
frame
-
>
IsFlexOrGridItem
(
)
;
}
bool
HTMLEditUtils
:
:
IsInclusiveAncestorCSSDisplayNone
(
const
nsIContent
&
aContent
)
{
if
(
NS_WARN_IF
(
!
aContent
.
IsInComposedDoc
(
)
)
)
{
return
true
;
}
for
(
const
Element
*
element
:
aContent
.
InclusiveFlatTreeAncestorsOfType
<
Element
>
(
)
)
{
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
element
)
;
if
(
NS_WARN_IF
(
!
elementStyle
)
)
{
continue
;
}
const
nsStyleDisplay
*
styleDisplay
=
elementStyle
-
>
StyleDisplay
(
)
;
if
(
MOZ_UNLIKELY
(
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
)
{
return
true
;
}
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsElement
(
)
)
{
return
false
;
}
if
(
!
aContent
.
IsHTMLElement
(
)
)
{
return
true
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
true
;
}
if
(
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
applet
nsGkAtoms
:
:
br
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
img
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
{
return
true
;
}
if
(
const
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
&
aContent
)
)
{
return
inputElement
-
>
ControlType
(
)
!
=
FormControlType
:
:
InputHidden
;
}
if
(
aContent
.
GetPrimaryFrame
(
)
&
&
!
aContent
.
GetPrimaryFrame
(
)
-
>
GetSize
(
)
.
IsEmpty
(
)
)
{
return
true
;
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsInlineStyle
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
s
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
font
)
;
}
bool
HTMLEditUtils
:
:
IsDisplayOutsideInline
(
const
Element
&
aElement
)
{
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
&
aElement
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleDisplay
(
)
-
>
DisplayOutside
(
)
=
=
StyleDisplayOutside
:
:
Inline
;
}
bool
HTMLEditUtils
:
:
IsDisplayInsideFlowRoot
(
const
Element
&
aElement
)
{
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
&
aElement
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleDisplay
(
)
-
>
DisplayInside
(
)
=
=
StyleDisplayInside
:
:
FlowRoot
;
}
bool
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
Element
&
aElement
)
{
if
(
!
aElement
.
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
b
nsGkAtoms
:
:
bdi
nsGkAtoms
:
:
bdo
nsGkAtoms
:
:
big
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
code
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
em
nsGkAtoms
:
:
font
nsGkAtoms
:
:
i
nsGkAtoms
:
:
ins
nsGkAtoms
:
:
kbd
nsGkAtoms
:
:
mark
nsGkAtoms
:
:
nobr
nsGkAtoms
:
:
q
nsGkAtoms
:
:
s
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
small
nsGkAtoms
:
:
span
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
u
nsGkAtoms
:
:
var
)
)
{
return
true
;
}
nsAutoString
tagName
;
aElement
.
GetTagName
(
tagName
)
;
return
tagName
.
LowerCaseEqualsASCII
(
"
blink
"
)
;
}
bool
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
blockquote
)
;
}
bool
HTMLEditUtils
:
:
IsHeader
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
bool
HTMLEditUtils
:
:
IsListItem
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
;
}
bool
HTMLEditUtils
:
:
IsAnyTableElement
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsTable
(
const
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
bool
HTMLEditUtils
:
:
IsTableRow
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
;
}
bool
HTMLEditUtils
:
:
IsTableCell
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
bool
HTMLEditUtils
:
:
IsTableCellOrCaption
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsAnyListElement
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
)
;
}
bool
HTMLEditUtils
:
:
IsPre
(
const
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
;
}
bool
HTMLEditUtils
:
:
IsImage
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
;
}
bool
HTMLEditUtils
:
:
IsLink
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
false
;
}
RefPtr
<
const
dom
:
:
HTMLAnchorElement
>
anchor
=
dom
:
:
HTMLAnchorElement
:
:
FromNodeOrNull
(
aNode
-
>
AsContent
(
)
)
;
if
(
!
anchor
)
{
return
false
;
}
nsAutoCString
tmpText
;
anchor
-
>
GetHref
(
tmpText
)
;
return
!
tmpText
.
IsEmpty
(
)
;
}
bool
HTMLEditUtils
:
:
IsNamedAnchor
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
return
false
;
}
nsAutoString
text
;
return
aNode
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
name
text
)
&
&
!
text
.
IsEmpty
(
)
;
}
bool
HTMLEditUtils
:
:
IsMozDiv
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
aNode
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
u
"
_moz
"
_ns
eIgnoreCase
)
;
}
bool
HTMLEditUtils
:
:
IsMailCite
(
const
Element
&
aElement
)
{
if
(
aElement
.
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
u
"
cite
"
_ns
eIgnoreCase
)
)
{
return
true
;
}
if
(
aElement
.
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozquote
u
"
true
"
_ns
eIgnoreCase
)
)
{
return
true
;
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsFormWidget
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
textarea
nsGkAtoms
:
:
select
nsGkAtoms
:
:
button
nsGkAtoms
:
:
output
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
input
)
;
}
bool
HTMLEditUtils
:
:
SupportsAlignAttr
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
div
nsGkAtoms
:
:
p
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
bool
HTMLEditUtils
:
:
IsVisibleTextNode
(
const
Text
&
aText
)
{
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
Maybe
<
uint32_t
>
visibleCharOffset
=
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
EditorDOMPointInText
(
&
aText
0
)
)
;
if
(
visibleCharOffset
.
isSome
(
)
)
{
return
true
;
}
return
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aText
WalkTreeDirection
:
:
Forward
)
&
&
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aText
WalkTreeDirection
:
:
Backward
)
;
}
bool
HTMLEditUtils
:
:
IsInVisibleTextFrames
(
nsPresContext
*
aPresContext
const
Text
&
aText
)
{
MOZ_ASSERT
(
aPresContext
)
;
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
nsTextFrame
*
textFrame
=
do_QueryFrame
(
aText
.
GetPrimaryFrame
(
)
)
;
if
(
!
textFrame
)
{
return
false
;
}
return
textFrame
-
>
HasVisibleText
(
)
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPoint
HTMLEditUtils
:
:
LineRequiresPaddingLineBreakToBeVisible
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
Element
&
aEditingHost
)
{
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
MOZ_ASSERT
(
HTMLEditUtils
:
:
NodeIsEditableOrNotInComposedDoc
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
;
EditorRawDOMPoint
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
if
(
point
.
IsContainerElement
(
)
)
{
for
(
nsIContent
*
child
=
point
.
GetChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
HTMLEditUtils
:
:
NodeIsEditableOrNotInComposedDoc
(
*
child
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
child
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
|
|
(
child
-
>
IsElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
)
)
{
break
;
}
point
.
Set
(
child
0
)
;
}
}
if
(
point
.
IsInTextNode
(
)
&
&
!
point
.
IsContainerEmpty
(
)
)
{
if
(
!
point
.
IsStartOfContainer
(
)
&
&
!
point
.
IsPreviousCharCollapsibleASCIISpace
(
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
point
.
IsEndOfContainer
(
)
)
{
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
point
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
const
nsTextFragment
&
fragment
=
point
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
const
uint32_t
inclusiveNextVisibleCharOffset
=
fragment
.
FindNonWhitespaceChar
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
point
.
ContainerAs
<
Text
>
(
)
)
?
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
WhitespaceOption
:
:
NewLineIsSignificant
}
:
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
}
point
.
Offset
(
)
)
;
if
(
inclusiveNextVisibleCharOffset
!
=
nsTextFragment
:
:
kNotFound
)
{
return
EditorDOMPoint
(
)
;
}
}
}
const
auto
AdjustPointToInsertPaddingLineBreak
=
[
]
(
EditorDOMPoint
&
aPointToInsertLineBreak
const
Element
*
aParentBlockElement
const
Element
&
aEditingHost
)
{
if
(
MOZ_UNLIKELY
(
!
aPointToInsertLineBreak
.
IsInContentNode
(
)
)
)
{
aPointToInsertLineBreak
.
Clear
(
)
;
return
;
}
while
(
MOZ_UNLIKELY
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPointToInsertLineBreak
.
GetContainer
(
)
*
nsGkAtoms
:
:
br
)
|
|
!
HTMLEditUtils
:
:
NodeIsEditableOrNotInComposedDoc
(
*
aPointToInsertLineBreak
.
GetContainer
(
)
)
)
)
{
if
(
MOZ_UNLIKELY
(
aPointToInsertLineBreak
.
GetContainer
(
)
=
=
aParentBlockElement
|
|
aPointToInsertLineBreak
.
GetContainer
(
)
=
=
&
aEditingHost
)
)
{
aPointToInsertLineBreak
.
Clear
(
)
;
return
;
}
aPointToInsertLineBreak
.
SetAfterContainer
(
)
;
if
(
MOZ_UNLIKELY
(
!
aPointToInsertLineBreak
.
IsInContentNode
(
)
)
)
{
aPointToInsertLineBreak
.
Clear
(
)
;
return
;
}
}
}
;
const
Element
*
maybeNonEditableBlock
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
maybeNonEditableBlock
&
&
HTMLEditUtils
:
:
IsEmptyNode
(
*
maybeNonEditableBlock
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
EditorDOMPoint
pointToInsertLineBreak
=
HTMLEditUtils
:
:
GetDeepestEditableEndPointOf
<
EditorDOMPoint
>
(
*
maybeNonEditableBlock
{
EditablePointOption
:
:
RecognizeInvisibleWhiteSpaces
EditablePointOption
:
:
StopAtComment
}
)
;
if
(
pointToInsertLineBreak
.
IsInTextNode
(
)
)
{
pointToInsertLineBreak
.
SetAfterContainer
(
)
;
}
AdjustPointToInsertPaddingLineBreak
(
pointToInsertLineBreak
maybeNonEditableBlock
aEditingHost
)
;
return
pointToInsertLineBreak
;
}
EditorDOMPoint
preferredPaddingLineBreakPoint
;
const
bool
followedByBlockBoundary
=
[
&
]
(
)
{
if
(
point
.
GetContainer
(
)
=
=
maybeNonEditableBlock
&
&
point
.
IsEndOfContainer
(
)
)
{
preferredPaddingLineBreakPoint
=
point
.
To
<
EditorDOMPoint
>
(
)
;
return
true
;
}
if
(
point
.
GetContainer
(
)
=
=
&
aEditingHost
&
&
point
.
IsEndOfContainer
(
)
)
{
return
false
;
}
const
WSScanResult
nextThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
point
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextThing
.
ReachedBlockBoundary
(
)
)
{
if
(
nextThing
.
ReachedCurrentBlockBoundary
(
)
)
{
preferredPaddingLineBreakPoint
=
point
.
AfterContainer
<
EditorDOMPoint
>
(
)
;
}
else
{
preferredPaddingLineBreakPoint
=
point
.
To
<
EditorDOMPoint
>
(
)
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
NodeIsEditableOrNotInComposedDoc
(
*
preferredPaddingLineBreakPoint
.
GetContainer
(
)
)
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
(
)
;
if
(
!
followedByBlockBoundary
)
{
return
EditorDOMPoint
(
)
;
}
const
bool
isFollowingBlockBoundary
=
[
&
]
(
)
{
if
(
point
.
GetContainer
(
)
=
=
maybeNonEditableBlock
&
&
point
.
IsStartOfContainer
(
)
)
{
return
true
;
}
nsIContent
*
const
previousVisibleLeafOrChildBlock
=
HTMLEditUtils
:
:
GetPreviousNonEmptyLeafContentOrPreviousBlockElement
(
preferredPaddingLineBreakPoint
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
!
previousVisibleLeafOrChildBlock
)
{
return
true
;
}
return
HTMLEditUtils
:
:
IsBlockElement
(
*
previousVisibleLeafOrChildBlock
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
}
(
)
;
if
(
!
isFollowingBlockBoundary
)
{
return
EditorDOMPoint
(
)
;
}
AdjustPointToInsertPaddingLineBreak
(
preferredPaddingLineBreakPoint
maybeNonEditableBlock
aEditingHost
)
;
return
preferredPaddingLineBreakPoint
;
}
Element
*
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
const
nsIContent
&
aContent
const
WalkTreeDirection
aDirection
)
{
MOZ_ASSERT
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
aContent
.
IsText
(
)
)
;
Element
*
maybeNonEditableAncestorBlock
=
HTMLEditUtils
:
:
GetAncestorElement
(
aContent
HTMLEditUtils
:
:
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
NS_WARN_IF
(
!
maybeNonEditableAncestorBlock
)
)
{
return
nullptr
;
}
auto
getNextContent
=
[
&
aDirection
&
maybeNonEditableAncestorBlock
]
(
const
nsIContent
&
aContent
)
-
>
nsIContent
*
{
return
aDirection
=
=
WalkTreeDirection
:
:
Forward
?
HTMLEditUtils
:
:
GetNextContent
(
aContent
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
StopAtBlockBoundary
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
maybeNonEditableAncestorBlock
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
aContent
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
StopAtBlockBoundary
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
maybeNonEditableAncestorBlock
)
;
}
;
const
bool
isBRElement
=
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
for
(
nsIContent
*
nextContent
=
getNextContent
(
aContent
)
;
nextContent
;
nextContent
=
getNextContent
(
*
nextContent
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
nextContent
-
>
AsElement
(
)
;
}
if
(
!
nextContent
-
>
IsHTMLElement
(
)
)
{
return
nextContent
-
>
AsElement
(
)
;
}
if
(
nextContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
isBRElement
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aContent
.
IsText
(
)
)
;
if
(
aDirection
=
=
WalkTreeDirection
:
:
Forward
)
{
return
nullptr
;
}
return
nextContent
-
>
AsElement
(
)
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
nextContent
)
)
{
return
nullptr
;
}
continue
;
}
switch
(
nextContent
-
>
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
CDATA_SECTION_NODE
:
break
;
default
:
continue
;
}
Text
*
textNode
=
Text
:
:
FromNode
(
nextContent
)
;
MOZ_ASSERT
(
textNode
)
;
if
(
!
textNode
-
>
TextDataLength
(
)
)
{
continue
;
}
if
(
HTMLEditUtils
:
:
IsInclusiveAncestorCSSDisplayNone
(
*
textNode
)
)
{
continue
;
}
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
textNode
)
)
{
return
nullptr
;
}
const
uint32_t
nonWhiteSpaceOffset
=
textNode
-
>
TextFragment
(
)
.
FindNonWhitespaceChar
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
?
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
WhitespaceOption
:
:
NewLineIsSignificant
}
:
WhitespaceOptions
{
WhitespaceOption
:
:
FormFeedIsSignificant
}
)
;
if
(
nonWhiteSpaceOffset
!
=
nsTextFragment
:
:
kNotFound
)
{
return
nullptr
;
}
}
return
maybeNonEditableAncestorBlock
;
}
template
<
typename
PT
typename
CT
>
bool
HTMLEditUtils
:
:
PointIsImmediatelyBeforeCurrentBlockBoundary
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
IgnoreInvisibleLineBreak
aIgnoreInvisibleLineBreak
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValidInComposedDoc
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInContentNode
(
)
)
)
{
return
false
;
}
const
WSScanResult
nextThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextThing
.
ReachedCurrentBlockBoundary
(
)
)
{
return
true
;
}
if
(
nextThing
.
ReachedInvisibleBRElement
(
)
)
{
if
(
aIgnoreInvisibleLineBreak
=
=
IgnoreInvisibleLineBreak
:
:
No
)
{
return
false
;
}
const
WSScanResult
afterInvisibleBRThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
nextThing
.
PointAfterReachedContent
<
EditorRawDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
return
afterInvisibleBRThing
.
ReachedCurrentBlockBoundary
(
)
;
}
if
(
nextThing
.
ReachedPreformattedLineBreak
(
)
)
{
if
(
aIgnoreInvisibleLineBreak
=
=
IgnoreInvisibleLineBreak
:
:
No
)
{
return
false
;
}
const
WSScanResult
afterPreformattedLineBreakThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
nextThing
.
PointAfterReachedContent
<
EditorRawDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
return
afterPreformattedLineBreakThing
.
ReachedCurrentBlockBoundary
(
)
;
}
return
false
;
}
template
<
typename
EditorLineBreakType
>
Maybe
<
EditorLineBreakType
>
HTMLEditUtils
:
:
GetUnnecessaryLineBreak
(
const
Element
&
aBlockElement
ScanLineBreak
aScanLineBreak
)
{
auto
*
lastLineBreakContent
=
[
&
]
(
)
-
>
nsIContent
*
{
const
WalkTreeOptions
onlyPrecedingLine
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
content
=
aScanLineBreak
=
=
ScanLineBreak
:
:
AtEndOfBlock
?
HTMLEditUtils
:
:
GetLastLeafContent
(
aBlockElement
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
aBlockElement
onlyPrecedingLine
BlockInlineCheck
:
:
UseComputedDisplayStyle
aBlockElement
.
GetParentElement
(
)
)
;
content
;
content
=
aScanLineBreak
=
=
ScanLineBreak
:
:
AtEndOfBlock
?
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
content
{
LeafNodeType
:
:
OnlyLeafNode
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
&
aBlockElement
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
*
content
onlyPrecedingLine
BlockInlineCheck
:
:
UseComputedDisplayStyle
aBlockElement
.
GetParentElement
(
)
)
)
{
if
(
aScanLineBreak
=
=
ScanLineBreak
:
:
BeforeBlock
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
nullptr
;
}
if
(
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
if
(
!
textNode
-
>
TextLength
(
)
)
{
continue
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
&
&
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
if
(
textFragment
.
GetLength
(
)
=
=
1u
)
{
return
textNode
;
}
return
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
2u
)
=
=
HTMLEditUtils
:
:
kNewLine
?
nullptr
:
textNode
;
}
if
(
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
textNode
)
)
{
return
nullptr
;
}
continue
;
}
if
(
content
-
>
IsCharacterData
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
content
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
content
)
)
{
return
nullptr
;
}
}
return
nullptr
;
}
(
)
;
if
(
!
lastLineBreakContent
)
{
return
Nothing
(
)
;
}
Text
*
const
lastLineBreakText
=
Text
:
:
FromNode
(
lastLineBreakContent
)
;
if
(
lastLineBreakText
&
&
lastLineBreakText
-
>
TextDataLength
(
)
!
=
1u
)
{
return
Some
(
EditorLineBreakType
:
:
AtLastChar
(
*
lastLineBreakText
)
)
;
}
HTMLBRElement
*
const
lastBRElement
=
lastLineBreakText
?
nullptr
:
HTMLBRElement
:
:
FromNode
(
lastLineBreakContent
)
;
MOZ_ASSERT_IF
(
!
lastLineBreakText
lastBRElement
)
;
const
Element
*
blockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
lastLineBreakContent
HTMLEditUtils
:
:
ClosestBlockElement
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
for
(
nsIContent
*
content
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
lastLineBreakContent
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
blockElement
)
;
content
;
content
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
content
{
LeafNodeType
:
:
LeafNodeOrChildBlock
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
blockElement
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
|
|
(
content
-
>
IsElement
(
)
&
&
!
content
-
>
IsHTMLElement
(
)
)
)
{
return
Nothing
(
)
;
}
if
(
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
if
(
!
textNode
-
>
TextDataLength
(
)
)
{
continue
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
&
&
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
return
Nothing
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
textNode
)
)
{
continue
;
}
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
textNode
)
)
{
return
Some
(
lastLineBreakText
?
EditorLineBreakType
:
:
AtLastChar
(
*
lastLineBreakText
)
:
EditorLineBreakType
(
*
lastBRElement
)
)
;
}
switch
(
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kNewLine
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
return
Nothing
(
)
;
default
:
return
Some
(
lastLineBreakText
?
EditorLineBreakType
:
:
AtLastChar
(
*
lastLineBreakText
)
:
EditorLineBreakType
(
*
lastBRElement
)
)
;
}
}
if
(
content
-
>
IsCharacterData
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
Nothing
(
)
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
content
)
)
{
return
Some
(
lastLineBreakText
?
EditorLineBreakType
:
:
AtLastChar
(
*
lastLineBreakText
)
:
EditorLineBreakType
(
*
lastBRElement
)
)
;
}
}
return
Nothing
(
)
;
}
template
<
typename
EditorLineBreakType
typename
EditorDOMPointType
>
Maybe
<
EditorLineBreakType
>
HTMLEditUtils
:
:
GetFollowingUnnecessaryLineBreak
(
const
EditorDOMPointType
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsInContentNode
(
)
)
;
const
WSScanResult
nextThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
nextThing
.
ReachedBRElement
(
)
&
&
!
(
nextThing
.
ReachedPreformattedLineBreak
(
)
&
&
nextThing
.
PointAtReachedContent
<
EditorRawDOMPoint
>
(
)
.
IsAtLastContent
(
)
)
)
{
return
Nothing
(
)
;
}
const
WSScanResult
nextThingOfLineBreak
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
nextThing
.
PointAfterReachedContent
<
EditorRawDOMPoint
>
(
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
const
Element
*
const
blockElement
=
nextThingOfLineBreak
.
ReachedBlockBoundary
(
)
?
nextThingOfLineBreak
.
ElementPtr
(
)
:
HTMLEditUtils
:
:
GetAncestorElement
(
*
nextThing
.
GetContent
(
)
{
AncestorType
:
:
ClosestBlockElement
}
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
MOZ_UNLIKELY
(
!
blockElement
)
)
{
return
Nothing
(
)
;
}
Maybe
<
EditorLineBreakType
>
unnecessaryLineBreak
=
GetUnnecessaryLineBreak
<
EditorLineBreakType
>
(
*
blockElement
nextThingOfLineBreak
.
ReachedOtherBlockElement
(
)
?
ScanLineBreak
:
:
BeforeBlock
:
ScanLineBreak
:
:
AtEndOfBlock
)
;
if
(
unnecessaryLineBreak
.
isSome
(
)
&
&
&
unnecessaryLineBreak
-
>
ContentRef
(
)
!
=
nextThing
.
GetContent
(
)
)
{
unnecessaryLineBreak
.
reset
(
)
;
}
return
unnecessaryLineBreak
;
}
uint32_t
HTMLEditUtils
:
:
GetFirstVisibleCharOffset
(
const
Text
&
aText
)
{
const
nsTextFragment
&
textFragment
=
aText
.
TextFragment
(
)
;
if
(
!
textFragment
.
GetLength
(
)
|
|
!
EditorRawDOMPointInText
(
&
aText
0u
)
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
return
0u
;
}
const
WSScanResult
previousThingOfText
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
EditorRawDOMPoint
(
&
aText
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
previousThingOfText
.
ReachedLineBoundary
(
)
)
{
return
0u
;
}
return
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
aText
0u
)
.
valueOr
(
textFragment
.
GetLength
(
)
)
;
}
uint32_t
HTMLEditUtils
:
:
GetOffsetAfterLastVisibleChar
(
const
Text
&
aText
)
{
const
nsTextFragment
&
textFragment
=
aText
.
TextFragment
(
)
;
if
(
!
textFragment
.
GetLength
(
)
)
{
return
0u
;
}
if
(
!
EditorRawDOMPointInText
:
:
AtLastContentOf
(
aText
)
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
)
{
return
textFragment
.
GetLength
(
)
;
}
const
WSScanResult
nextThingOfText
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
All
EditorRawDOMPoint
:
:
After
(
aText
)
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
!
nextThingOfText
.
ReachedLineBoundary
(
)
)
{
return
textFragment
.
GetLength
(
)
;
}
const
Maybe
<
uint32_t
>
lastNonCollapsibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
aText
textFragment
.
GetLength
(
)
)
;
if
(
lastNonCollapsibleCharOffset
.
isNothing
(
)
)
{
return
0u
;
}
if
(
*
lastNonCollapsibleCharOffset
=
=
textFragment
.
GetLength
(
)
-
1u
)
{
return
textFragment
.
GetLength
(
)
;
}
const
uint32_t
firstTrailingWhiteSpaceOffset
=
*
lastNonCollapsibleCharOffset
+
1u
;
MOZ_ASSERT
(
firstTrailingWhiteSpaceOffset
<
textFragment
.
GetLength
(
)
)
;
if
(
nextThingOfText
.
ReachedBlockBoundary
(
)
)
{
return
firstTrailingWhiteSpaceOffset
;
}
return
firstTrailingWhiteSpaceOffset
+
1u
;
}
uint32_t
HTMLEditUtils
:
:
GetInvisibleWhiteSpaceCount
(
const
Text
&
aText
uint32_t
aOffset
uint32_t
aLength
)
{
const
nsTextFragment
&
textFragment
=
aText
.
TextFragment
(
)
;
if
(
!
aLength
|
|
textFragment
.
GetLength
(
)
<
=
aOffset
)
{
return
0u
;
}
const
uint32_t
endOffset
=
static_cast
<
uint32_t
>
(
std
:
:
min
(
static_cast
<
uint64_t
>
(
aOffset
)
+
aLength
static_cast
<
uint64_t
>
(
textFragment
.
GetLength
(
)
)
)
)
;
const
auto
firstVisibleOffset
=
[
&
]
(
)
-
>
uint32_t
{
if
(
aOffset
&
&
textFragment
.
CharAt
(
aOffset
-
1u
)
=
=
HTMLEditUtils
:
:
kNewLine
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
aText
)
)
{
for
(
const
uint32_t
offset
:
IntegerRange
(
aOffset
endOffset
)
)
{
if
(
textFragment
.
CharAt
(
offset
)
=
=
HTMLEditUtils
:
:
kNBSP
)
{
return
offset
;
}
}
return
endOffset
;
}
if
(
aOffset
)
{
return
aOffset
-
1u
;
}
return
HTMLEditUtils
:
:
GetFirstVisibleCharOffset
(
aText
)
;
}
(
)
;
if
(
firstVisibleOffset
>
=
endOffset
)
{
return
endOffset
-
aOffset
;
}
const
auto
afterLastVisibleOffset
=
[
&
]
(
)
-
>
uint32_t
{
if
(
endOffset
<
textFragment
.
GetLength
(
)
&
&
textFragment
.
CharAt
(
endOffset
)
=
=
HTMLEditUtils
:
:
kNewLine
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
aText
)
)
{
for
(
const
uint32_t
offset
:
Reversed
(
IntegerRange
(
aOffset
endOffset
)
)
)
{
if
(
textFragment
.
CharAt
(
offset
)
=
=
HTMLEditUtils
:
:
kNBSP
)
{
return
offset
+
1u
;
}
}
return
aOffset
;
}
if
(
endOffset
<
textFragment
.
GetLength
(
)
-
1u
)
{
return
endOffset
;
}
return
HTMLEditUtils
:
:
GetOffsetAfterLastVisibleChar
(
aText
)
;
}
(
)
;
if
(
aOffset
>
=
afterLastVisibleOffset
)
{
return
endOffset
-
aOffset
;
}
enum
class
PrevChar
{
NotChar
Space
NBSP
}
;
PrevChar
prevChar
=
PrevChar
:
:
NotChar
;
uint32_t
invisibleChars
=
0u
;
for
(
const
uint32_t
offset
:
IntegerRange
(
aOffset
endOffset
)
)
{
if
(
textFragment
.
CharAt
(
offset
)
=
=
HTMLEditUtils
:
:
kNBSP
)
{
prevChar
=
PrevChar
:
:
NBSP
;
continue
;
}
MOZ_ASSERT
(
EditorRawDOMPointInText
(
&
aText
offset
)
.
IsCharCollapsibleASCIISpace
(
)
)
;
if
(
offset
<
firstVisibleOffset
|
|
offset
>
=
afterLastVisibleOffset
|
|
prevChar
=
=
PrevChar
:
:
Space
)
{
invisibleChars
+
+
;
}
prevChar
=
PrevChar
:
:
Space
;
}
return
invisibleChars
;
}
bool
HTMLEditUtils
:
:
IsEmptyNode
(
nsPresContext
*
aPresContext
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
bool
*
aSeenBR
)
{
MOZ_ASSERT_IF
(
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
aPresContext
)
;
if
(
aSeenBR
)
{
*
aSeenBR
=
false
;
}
if
(
const
Text
*
text
=
Text
:
:
FromNode
(
&
aNode
)
)
{
return
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
?
!
IsInVisibleTextFrames
(
aPresContext
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
}
if
(
!
aNode
.
IsElement
(
)
)
{
return
false
;
}
if
(
!
IsContainerNode
(
*
aNode
.
AsContent
(
)
)
|
|
IsNamedAnchor
(
&
aNode
)
|
|
IsFormWidget
(
&
aNode
)
)
{
return
false
;
}
const
auto
[
isListItem
isTableCell
hasAppearance
]
=
[
&
]
(
)
MOZ_NEVER_INLINE_DEBUG
-
>
std
:
:
tuple
<
bool
bool
bool
>
{
if
(
aNode
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
=
=
&
aNode
|
|
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
aNode
.
OwnerDoc
(
)
-
>
GetBodyElement
(
)
=
=
&
aNode
)
)
{
return
{
false
false
false
}
;
}
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aNode
.
AsElement
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
elementStyle
)
)
{
return
{
IsListItem
(
&
aNode
)
IsTableCell
(
&
aNode
)
false
}
;
}
const
nsStyleDisplay
*
styleDisplay
=
elementStyle
-
>
StyleDisplay
(
)
;
if
(
NS_WARN_IF
(
!
styleDisplay
)
)
{
return
{
IsListItem
(
&
aNode
)
IsTableCell
(
&
aNode
)
false
}
;
}
if
(
styleDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
None
&
&
styleDisplay
-
>
HasAppearance
(
)
)
{
return
{
false
false
true
}
;
}
if
(
styleDisplay
-
>
IsListItem
(
)
)
{
return
{
true
false
false
}
;
}
if
(
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCell
)
{
return
{
false
true
false
}
;
}
return
{
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
&
&
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
false
false
}
;
}
(
)
;
if
(
hasAppearance
)
{
return
false
;
}
if
(
isListItem
&
&
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatListItemAsVisible
)
)
{
return
false
;
}
if
(
isTableCell
&
&
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatTableCellAsVisible
)
)
{
return
false
;
}
bool
seenBR
=
aSeenBR
&
&
*
aSeenBR
;
for
(
nsIContent
*
childContent
=
aNode
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatNonEditableContentAsInvisible
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
childContent
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
Text
*
text
=
Text
:
:
FromNode
(
childContent
)
)
{
if
(
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
?
IsInVisibleTextFrames
(
aPresContext
*
text
)
:
IsVisibleTextNode
(
*
text
)
)
{
return
false
;
}
continue
;
}
MOZ_ASSERT
(
childContent
!
=
&
aNode
)
;
if
(
!
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
)
&
&
!
seenBR
&
&
childContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
seenBR
=
true
;
if
(
aSeenBR
)
{
*
aSeenBR
=
true
;
}
continue
;
}
if
(
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatBlockAsVisible
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
childContent
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
)
{
return
false
;
}
EmptyCheckOptions
options
(
aOptions
)
;
if
(
childContent
-
>
IsElement
(
)
&
&
(
isListItem
|
|
isTableCell
)
)
{
options
+
=
{
EmptyCheckOption
:
:
TreatListItemAsVisible
EmptyCheckOption
:
:
TreatTableCellAsVisible
}
;
}
if
(
!
IsEmptyNode
(
aPresContext
*
childContent
options
&
seenBR
)
)
{
if
(
aSeenBR
)
{
*
aSeenBR
=
seenBR
;
}
return
false
;
}
}
if
(
aSeenBR
)
{
*
aSeenBR
=
seenBR
;
}
return
true
;
}
bool
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
aPointToInsert
.
IsInContentNode
(
)
)
{
return
false
;
}
if
(
aEditingHost
.
IsContentEditablePlainTextOnly
(
)
)
{
return
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
}
Element
*
closestEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
return
(
!
closestEditableBlockElement
|
|
closestEditableBlockElement
=
=
&
aEditingHost
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
}
#
define
GROUP_NONE
0
#
define
GROUP_TOPLEVEL
(
1
<
<
1
)
#
define
GROUP_HEAD_CONTENT
(
1
<
<
2
)
#
define
GROUP_FONTSTYLE
(
1
<
<
3
)
#
define
GROUP_PHRASE
(
1
<
<
4
)
#
define
GROUP_SPECIAL
(
1
<
<
5
)
#
define
GROUP_FORMCONTROL
(
1
<
<
6
)
#
define
GROUP_BLOCK
(
1
<
<
7
)
#
define
GROUP_FRAME
(
1
<
<
8
)
#
define
GROUP_TABLE_CONTENT
(
1
<
<
9
)
#
define
GROUP_TBODY_CONTENT
(
1
<
<
10
)
#
define
GROUP_TR_CONTENT
(
1
<
<
11
)
#
define
GROUP_COLGROUP_CONTENT
(
1
<
<
12
)
#
define
GROUP_OBJECT_CONTENT
(
1
<
<
13
)
#
define
GROUP_LI
(
1
<
<
14
)
#
define
GROUP_MAP_CONTENT
(
1
<
<
15
)
#
define
GROUP_SELECT_CONTENT
(
1
<
<
16
)
#
define
GROUP_OPTIONS
(
1
<
<
17
)
#
define
GROUP_DL_CONTENT
(
1
<
<
18
)
#
define
GROUP_P
(
1
<
<
19
)
#
define
GROUP_LEAF
(
1
<
<
20
)
#
define
GROUP_OL_UL
(
1
<
<
21
)
#
define
GROUP_HEADING
(
1
<
<
22
)
#
define
GROUP_FIGCAPTION
(
1
<
<
23
)
#
define
GROUP_PICTURE_CONTENT
(
1
<
<
24
)
#
define
GROUP_INLINE_ELEMENT
\
(
GROUP_FONTSTYLE
|
GROUP_PHRASE
|
GROUP_SPECIAL
|
GROUP_FORMCONTROL
|
\
GROUP_LEAF
)
#
define
GROUP_FLOW_ELEMENT
(
GROUP_INLINE_ELEMENT
|
GROUP_BLOCK
)
struct
ElementInfo
final
{
#
ifdef
DEBUG
nsHTMLTag
mTag
;
#
endif
uint32_t
mGroup
;
uint32_t
mCanContainGroups
;
bool
mIsContainer
;
bool
mCanContainSelf
;
}
;
#
ifdef
DEBUG
#
define
ELEM
(
_tag
_isContainer
_canContainSelf
_group
_canContainGroups
)
\
{
eHTMLTag_
#
#
_tag
_group
_canContainGroups
_isContainer
_canContainSelf
}
#
else
#
define
ELEM
(
_tag
_isContainer
_canContainSelf
_group
_canContainGroups
)
\
{
_group
_canContainGroups
_isContainer
_canContainSelf
}
#
endif
static
const
ElementInfo
kElements
[
eHTMLTag_userdefined
]
=
{
ELEM
(
a
true
false
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
abbr
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
acronym
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
address
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
|
GROUP_P
)
ELEM
(
applet
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_OBJECT_CONTENT
)
ELEM
(
area
false
false
GROUP_MAP_CONTENT
GROUP_NONE
)
ELEM
(
article
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
aside
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
audio
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
b
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
base
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
basefont
false
false
GROUP_SPECIAL
GROUP_NONE
)
ELEM
(
bdi
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
bdo
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
bgsound
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
big
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
blockquote
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
body
true
true
GROUP_TOPLEVEL
GROUP_FLOW_ELEMENT
)
ELEM
(
br
false
false
GROUP_SPECIAL
GROUP_NONE
)
ELEM
(
button
true
true
GROUP_FORMCONTROL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
canvas
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
caption
true
true
GROUP_NONE
GROUP_INLINE_ELEMENT
)
ELEM
(
center
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
cite
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
code
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
col
false
false
GROUP_TABLE_CONTENT
|
GROUP_COLGROUP_CONTENT
GROUP_NONE
)
ELEM
(
colgroup
true
false
GROUP_NONE
GROUP_COLGROUP_CONTENT
)
ELEM
(
data
true
false
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
datalist
true
false
GROUP_PHRASE
GROUP_OPTIONS
|
GROUP_INLINE_ELEMENT
)
ELEM
(
dd
true
false
GROUP_DL_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
del
true
true
GROUP_PHRASE
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
details
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dfn
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
dialog
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dir
true
false
GROUP_BLOCK
GROUP_LI
)
ELEM
(
div
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dl
true
false
GROUP_BLOCK
GROUP_DL_CONTENT
)
ELEM
(
dt
true
true
GROUP_DL_CONTENT
GROUP_INLINE_ELEMENT
)
ELEM
(
em
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
embed
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
fieldset
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
figcaption
true
false
GROUP_FIGCAPTION
GROUP_FLOW_ELEMENT
)
ELEM
(
figure
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_FIGCAPTION
)
ELEM
(
font
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
footer
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
form
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
frame
false
false
GROUP_FRAME
GROUP_NONE
)
ELEM
(
frameset
true
true
GROUP_FRAME
GROUP_FRAME
)
ELEM
(
h1
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h2
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h3
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h4
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h5
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h6
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
head
true
false
GROUP_TOPLEVEL
GROUP_HEAD_CONTENT
)
ELEM
(
header
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
hgroup
true
false
GROUP_BLOCK
GROUP_HEADING
)
ELEM
(
hr
false
false
GROUP_BLOCK
GROUP_NONE
)
ELEM
(
html
true
false
GROUP_TOPLEVEL
GROUP_TOPLEVEL
)
ELEM
(
i
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
iframe
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
image
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
img
false
false
GROUP_SPECIAL
|
GROUP_PICTURE_CONTENT
GROUP_NONE
)
ELEM
(
input
false
false
GROUP_FORMCONTROL
GROUP_NONE
)
ELEM
(
ins
true
true
GROUP_PHRASE
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
kbd
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
keygen
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
label
true
false
GROUP_FORMCONTROL
GROUP_INLINE_ELEMENT
)
ELEM
(
legend
true
true
GROUP_NONE
GROUP_INLINE_ELEMENT
)
ELEM
(
li
true
false
GROUP_LI
GROUP_FLOW_ELEMENT
)
ELEM
(
link
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
listing
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
)
ELEM
(
main
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
map
true
true
GROUP_SPECIAL
GROUP_BLOCK
|
GROUP_MAP_CONTENT
)
ELEM
(
mark
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
marquee
true
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
menu
true
true
GROUP_BLOCK
GROUP_LI
|
GROUP_FLOW_ELEMENT
)
ELEM
(
meta
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
meter
true
false
GROUP_SPECIAL
GROUP_FLOW_ELEMENT
)
ELEM
(
multicol
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
nav
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
nobr
true
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
noembed
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
noframes
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
noscript
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
object
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_OBJECT_CONTENT
)
ELEM
(
ol
true
true
GROUP_BLOCK
|
GROUP_OL_UL
GROUP_LI
|
GROUP_OL_UL
)
ELEM
(
optgroup
true
false
GROUP_SELECT_CONTENT
GROUP_OPTIONS
)
ELEM
(
option
true
false
GROUP_SELECT_CONTENT
|
GROUP_OPTIONS
GROUP_LEAF
)
ELEM
(
output
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
p
true
false
GROUP_BLOCK
|
GROUP_P
GROUP_INLINE_ELEMENT
)
ELEM
(
param
false
false
GROUP_OBJECT_CONTENT
GROUP_NONE
)
ELEM
(
picture
true
false
GROUP_SPECIAL
GROUP_PICTURE_CONTENT
)
ELEM
(
plaintext
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
pre
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
)
ELEM
(
progress
true
false
GROUP_SPECIAL
GROUP_FLOW_ELEMENT
)
ELEM
(
q
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
rb
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rp
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rt
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rtc
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
ruby
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
s
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
samp
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
script
true
false
GROUP_HEAD_CONTENT
|
GROUP_SPECIAL
GROUP_LEAF
)
ELEM
(
search
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
section
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
select
true
false
GROUP_FORMCONTROL
GROUP_SELECT_CONTENT
)
ELEM
(
small
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
slot
true
false
GROUP_NONE
GROUP_FLOW_ELEMENT
)
ELEM
(
source
false
false
GROUP_PICTURE_CONTENT
GROUP_NONE
)
ELEM
(
span
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
strike
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
strong
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
style
true
false
GROUP_HEAD_CONTENT
GROUP_LEAF
)
ELEM
(
sub
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
summary
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
sup
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
table
true
false
GROUP_BLOCK
GROUP_TABLE_CONTENT
)
ELEM
(
tbody
true
false
GROUP_TABLE_CONTENT
GROUP_TBODY_CONTENT
)
ELEM
(
td
true
false
GROUP_TR_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
textarea
true
false
GROUP_FORMCONTROL
GROUP_LEAF
)
ELEM
(
tfoot
true
false
GROUP_NONE
GROUP_TBODY_CONTENT
)
ELEM
(
th
true
false
GROUP_TR_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
thead
true
false
GROUP_NONE
GROUP_TBODY_CONTENT
)
ELEM
(
template
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
time
true
false
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
title
true
false
GROUP_HEAD_CONTENT
GROUP_LEAF
)
ELEM
(
tr
true
false
GROUP_TBODY_CONTENT
GROUP_TR_CONTENT
)
ELEM
(
track
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
tt
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
u
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
ul
true
true
GROUP_BLOCK
|
GROUP_OL_UL
GROUP_LI
|
GROUP_OL_UL
)
ELEM
(
var
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
video
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
wbr
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
xmp
true
false
GROUP_BLOCK
GROUP_NONE
)
ELEM
(
text
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
whitespace
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
newline
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
comment
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
entity
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
doctypeDecl
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
markupDecl
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
instruction
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
userdefined
true
false
GROUP_NONE
GROUP_FLOW_ELEMENT
)
}
;
bool
HTMLEditUtils
:
:
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
{
NS_ASSERTION
(
aParentTagId
>
eHTMLTag_unknown
&
&
aParentTagId
<
=
eHTMLTag_userdefined
"
aParentTagId
out
of
range
!
"
)
;
NS_ASSERTION
(
aChildTagId
>
eHTMLTag_unknown
&
&
aChildTagId
<
=
eHTMLTag_userdefined
"
aChildTagId
out
of
range
!
"
)
;
#
ifdef
DEBUG
static
bool
checked
=
false
;
if
(
!
checked
)
{
checked
=
true
;
int32_t
i
;
for
(
i
=
1
;
i
<
=
eHTMLTag_userdefined
;
+
+
i
)
{
NS_ASSERTION
(
kElements
[
i
-
1
]
.
mTag
=
=
i
"
You
need
to
update
kElements
(
missing
tags
)
.
"
)
;
}
}
#
endif
if
(
aParentTagId
=
=
eHTMLTag_button
)
{
static
const
nsHTMLTag
kButtonExcludeKids
[
]
=
{
eHTMLTag_a
eHTMLTag_fieldset
eHTMLTag_form
eHTMLTag_iframe
eHTMLTag_input
eHTMLTag_select
eHTMLTag_textarea
}
;
uint32_t
j
;
for
(
j
=
0
;
j
<
std
:
:
size
(
kButtonExcludeKids
)
;
+
+
j
)
{
if
(
kButtonExcludeKids
[
j
]
=
=
aChildTagId
)
{
return
false
;
}
}
}
if
(
aChildTagId
=
=
eHTMLTag_bgsound
)
{
return
false
;
}
if
(
aChildTagId
=
=
eHTMLTag_userdefined
)
{
return
true
;
}
const
ElementInfo
&
parent
=
kElements
[
aParentTagId
-
1
]
;
if
(
aParentTagId
=
=
aChildTagId
)
{
return
parent
.
mCanContainSelf
;
}
const
ElementInfo
&
child
=
kElements
[
aChildTagId
-
1
]
;
return
!
!
(
parent
.
mCanContainGroups
&
child
.
mGroup
)
;
}
bool
HTMLEditUtils
:
:
ContentIsInert
(
const
nsIContent
&
aContent
)
{
for
(
nsIContent
*
content
:
aContent
.
InclusiveFlatTreeAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
)
{
return
frame
-
>
StyleUI
(
)
-
>
IsInert
(
)
;
}
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
if
(
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
INERT
)
)
{
return
true
;
}
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsContainerNode
(
nsHTMLTag
aTagId
)
{
NS_ASSERTION
(
aTagId
>
eHTMLTag_unknown
&
&
aTagId
<
=
eHTMLTag_userdefined
"
aTagId
out
of
range
!
"
)
;
return
kElements
[
aTagId
-
1
]
.
mIsContainer
;
}
bool
HTMLEditUtils
:
:
IsNonListSingleLineContainer
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
address
nsGkAtoms
:
:
div
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
nsGkAtoms
:
:
listing
nsGkAtoms
:
:
p
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
xmp
)
;
}
bool
HTMLEditUtils
:
:
IsSingleLineContainer
(
const
nsINode
&
aNode
)
{
return
IsNonListSingleLineContainer
(
aNode
)
|
|
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetPreviousContent
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
|
|
aPoint
.
IsInTextNode
(
)
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
aPoint
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
aPoint
.
GetContainer
(
)
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
if
(
aPoint
.
GetChild
(
)
)
{
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
aPoint
.
GetChild
(
)
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
nsIContent
*
lastLeafContent
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
aPoint
.
GetContainer
(
)
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
aBlockInlineCheck
)
;
if
(
!
lastLeafContent
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
lastLeafContent
aOptions
)
)
{
return
lastLeafContent
;
}
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
lastLeafContent
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetNextContent
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
auto
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
if
(
point
.
IsInTextNode
(
)
)
{
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
nullptr
;
}
}
if
(
point
.
GetChild
(
)
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
point
.
GetChild
(
)
aBlockInlineCheck
)
)
{
return
point
.
GetChild
(
)
;
}
nsIContent
*
firstLeafContent
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
point
.
GetChild
(
)
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
aBlockInlineCheck
)
;
if
(
!
firstLeafContent
)
{
return
point
.
GetChild
(
)
;
}
if
(
aAncestorLimiter
&
&
(
firstLeafContent
=
=
aAncestorLimiter
|
|
!
firstLeafContent
-
>
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
firstLeafContent
aOptions
)
)
{
return
firstLeafContent
;
}
return
HTMLEditUtils
:
:
GetNextContent
(
*
firstLeafContent
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
point
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
point
.
template
ContainerAs
<
nsIContent
>
(
)
aBlockInlineCheck
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetNextContent
(
*
point
.
GetContainer
(
)
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
nsIContent
*
HTMLEditUtils
:
:
GetAdjacentLeafContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
&
aNode
!
=
aAncestorLimiter
)
;
MOZ_ASSERT_IF
(
aAncestorLimiter
aAncestorLimiter
-
>
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
;
const
nsINode
*
node
=
&
aNode
;
for
(
;
;
)
{
nsIContent
*
sibling
=
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Forward
?
node
-
>
GetNextSibling
(
)
:
node
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
aBlockInlineCheck
)
)
{
return
sibling
;
}
const
LeafNodeTypes
leafNodeTypes
=
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
;
nsIContent
*
leafContent
=
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Forward
?
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
sibling
leafNodeTypes
aBlockInlineCheck
)
:
HTMLEditUtils
:
:
GetLastLeafContent
(
*
sibling
leafNodeTypes
aBlockInlineCheck
)
;
return
leafContent
?
leafContent
:
sibling
;
}
nsIContent
*
parent
=
node
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
parent
=
=
aAncestorLimiter
|
|
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
parent
aBlockInlineCheck
)
)
)
{
return
nullptr
;
}
node
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
What
part
of
for
(
;
;
)
do
you
not
understand
?
"
)
;
return
nullptr
;
}
nsIContent
*
HTMLEditUtils
:
:
GetAdjacentContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
if
(
&
aNode
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
leafContent
=
HTMLEditUtils
:
:
GetAdjacentLeafContent
(
aNode
aWalkTreeDirection
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
if
(
!
leafContent
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
leafContent
aOptions
)
)
{
return
leafContent
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
*
leafContent
aWalkTreeDirection
aOptions
aBlockInlineCheck
aAncestorLimiter
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
aContent
)
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
may
return
a
point
"
"
between
table
structure
elements
"
)
;
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
previousContent
=
aContent
.
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
if
(
!
aContent
.
GetParentElement
(
)
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
inclusiveAncestor
=
&
aContent
;
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
aAncestorLimiter
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
parentElement
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
parentElement
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parentElement
)
)
{
inclusiveAncestor
=
parentElement
;
}
previousContent
=
parentElement
-
>
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
previousContent
)
;
}
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
previousContent
aHowToTreatTableBoundary
)
)
{
return
inclusiveAncestor
=
=
&
aContent
?
EditorDOMPointType
(
inclusiveAncestor
)
:
EditorDOMPointType
(
inclusiveAncestor
0
)
;
}
break
;
}
if
(
!
previousContent
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
}
else
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
previousContent
)
;
}
else
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
previousContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
&
aContent
)
;
}
nsIContent
*
leafContent
=
previousContent
;
if
(
previousContent
-
>
GetChildCount
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
for
(
nsIContent
*
maybeLeafContent
=
previousContent
-
>
GetLastChild
(
)
;
maybeLeafContent
;
maybeLeafContent
=
maybeLeafContent
-
>
GetLastChild
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
maybeLeafContent
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
maybeLeafContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
*
maybeLeafContent
)
;
}
leafContent
=
maybeLeafContent
;
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
)
{
break
;
}
}
}
if
(
leafContent
-
>
IsText
(
)
)
{
Text
*
textNode
=
leafContent
-
>
AsText
(
)
;
if
(
aInvisibleWhiteSpaces
=
=
InvisibleWhiteSpaces
:
:
Preserve
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
textNode
)
;
}
return
WSRunScanner
:
:
GetAfterLastVisiblePoint
<
EditorDOMPointType
>
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
*
textNode
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
?
EditorDOMPointType
:
:
AtEndOf
(
*
leafContent
)
:
EditorDOMPointType
:
:
After
(
*
leafContent
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
aContent
)
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
may
return
a
point
"
"
between
table
structure
elements
"
)
;
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
nextContent
=
aContent
.
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
if
(
!
aContent
.
GetParentElement
(
)
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
inclusiveAncestor
=
&
aContent
;
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
parentElement
=
=
aAncestorLimiter
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
parentElement
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
parentElement
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parentElement
)
)
{
inclusiveAncestor
=
parentElement
;
}
nextContent
=
parentElement
-
>
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
parentElement
)
;
}
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
nextContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
*
inclusiveAncestor
)
;
}
break
;
}
if
(
!
nextContent
)
{
return
EditorDOMPointType
:
:
After
(
*
inclusiveAncestor
)
;
}
}
else
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
return
EditorDOMPointType
:
:
After
(
aContent
)
;
}
else
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
nextContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
aContent
)
;
}
nsIContent
*
leafContent
=
nextContent
;
if
(
nextContent
-
>
GetChildCount
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
for
(
nsIContent
*
maybeLeafContent
=
nextContent
-
>
GetFirstChild
(
)
;
maybeLeafContent
;
maybeLeafContent
=
maybeLeafContent
-
>
GetFirstChild
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
maybeLeafContent
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
maybeLeafContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
maybeLeafContent
)
;
}
leafContent
=
maybeLeafContent
;
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
)
{
break
;
}
}
}
if
(
leafContent
-
>
IsText
(
)
)
{
Text
*
textNode
=
leafContent
-
>
AsText
(
)
;
if
(
aInvisibleWhiteSpaces
=
=
InvisibleWhiteSpaces
:
:
Preserve
)
{
return
EditorDOMPointType
(
textNode
0
)
;
}
return
WSRunScanner
:
:
GetFirstVisiblePoint
<
EditorDOMPointType
>
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
*
textNode
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
?
EditorDOMPointType
(
leafContent
0
)
:
EditorDOMPointType
(
leafContent
)
;
}
Element
*
HTMLEditUtils
:
:
GetAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestContainerElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
AllowRootOrAncestorLimiterElement
)
)
;
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
const
Element
*
theBodyElement
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
;
const
Element
*
theDocumentElement
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
Element
*
lastAncestorElement
=
nullptr
;
const
bool
editableElementOnly
=
aAncestorTypes
.
contains
(
AncestorType
:
:
EditableElement
)
;
const
bool
lookingForClosestBlockElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
;
const
bool
lookingForClosestContainerElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestContainerElement
)
;
const
bool
lookingForMostDistantInlineElementInBlock
=
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
;
const
bool
ignoreHRElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
IgnoreHRElement
)
;
const
bool
lookingForButtonElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
;
const
bool
lookingForAnyElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
AllowRootOrAncestorLimiterElement
)
;
const
auto
IsSearchingElementType
=
[
&
]
(
const
nsIContent
&
aContent
)
-
>
bool
{
if
(
lookingForAnyElement
)
{
return
aContent
.
IsElement
(
)
;
}
if
(
!
aContent
.
IsElement
(
)
|
|
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
false
;
}
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorType
:
:
HTML
)
)
{
return
false
;
}
return
(
lookingForClosestBlockElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
aBlockInlineCheck
)
)
|
|
(
lookingForClosestContainerElement
&
&
aContent
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
)
|
|
(
lookingForMostDistantInlineElementInBlock
&
&
HTMLEditUtils
:
:
IsInlineContent
(
aContent
aBlockInlineCheck
)
)
|
|
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
;
}
;
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
element
EditorType
:
:
HTML
)
)
{
return
lastAncestorElement
&
&
IsSearchingElementType
(
*
lastAncestorElement
)
?
lastAncestorElement
:
nullptr
;
}
if
(
ignoreHRElement
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
element
=
=
aAncestorLimiter
)
{
if
(
lookingForAnyElement
)
{
lastAncestorElement
=
element
;
}
break
;
}
continue
;
}
if
(
lookingForButtonElement
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
{
return
element
;
}
if
(
lookingForClosestContainerElement
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
element
)
)
{
return
element
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
aBlockInlineCheck
)
)
{
if
(
lookingForClosestBlockElement
)
{
return
element
;
}
MOZ_ASSERT_IF
(
lastAncestorElement
HTMLEditUtils
:
:
IsInlineContent
(
*
lastAncestorElement
aBlockInlineCheck
)
)
;
return
lastAncestorElement
;
}
if
(
element
=
=
aAncestorLimiter
|
|
element
=
=
theBodyElement
|
|
element
=
=
theDocumentElement
)
{
if
(
lookingForAnyElement
)
{
lastAncestorElement
=
element
;
}
break
;
}
lastAncestorElement
=
element
;
}
return
lastAncestorElement
&
&
IsSearchingElementType
(
*
lastAncestorElement
)
?
lastAncestorElement
:
nullptr
;
}
Element
*
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
BlockInlineCheck
aBlockInlineCheck
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestContainerElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
AllowRootOrAncestorLimiterElement
)
)
;
const
Element
*
theBodyElement
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
;
const
Element
*
theDocumentElement
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
const
bool
editableElementOnly
=
aAncestorTypes
.
contains
(
AncestorType
:
:
EditableElement
)
;
const
bool
lookingForClosestBlockElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
;
const
bool
lookingForClosestContainerElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestContainerElement
)
;
const
bool
lookingForMostDistantInlineElementInBlock
=
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
;
const
bool
lookingForButtonElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
;
const
bool
ignoreHRElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
IgnoreHRElement
)
;
const
bool
lookingForAnyElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
AllowRootOrAncestorLimiterElement
)
;
auto
IsSearchingElementType
=
[
&
]
(
const
nsIContent
&
aContent
)
-
>
bool
{
if
(
lookingForAnyElement
)
{
return
aContent
.
IsElement
(
)
;
}
if
(
!
aContent
.
IsElement
(
)
|
|
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
false
;
}
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorType
:
:
HTML
)
)
{
return
false
;
}
return
(
lookingForClosestBlockElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
aBlockInlineCheck
)
)
|
|
(
lookingForClosestContainerElement
&
&
aContent
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
)
|
|
(
lookingForMostDistantInlineElementInBlock
&
&
HTMLEditUtils
:
:
IsInlineContent
(
aContent
aBlockInlineCheck
)
)
|
|
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
;
}
;
if
(
&
aContent
=
=
aAncestorLimiter
&
&
lookingForAnyElement
)
{
return
const_cast
<
Element
*
>
(
aAncestorLimiter
)
;
}
if
(
editableElementOnly
&
&
(
&
aContent
=
=
theBodyElement
|
|
&
aContent
=
=
theDocumentElement
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
if
(
lookingForClosestContainerElement
&
&
aContent
.
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
if
(
(
lookingForClosestBlockElement
|
|
lookingForMostDistantInlineElementInBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
aBlockInlineCheck
)
&
&
!
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
!
aContent
.
GetParent
(
)
|
|
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
aContent
.
GetParent
(
)
EditorType
:
:
HTML
)
)
|
|
(
!
lookingForClosestBlockElement
&
&
!
lookingForClosestContainerElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aContent
.
GetParent
(
)
aBlockInlineCheck
)
&
&
!
(
ignoreHRElement
&
&
aContent
.
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
aAncestorTypes
.
contains
(
AncestorType
:
:
AllowRootOrAncestorLimiterElement
)
?
Element
:
:
FromNode
(
const_cast
<
nsIContent
&
>
(
aContent
)
)
:
nullptr
;
}
return
HTMLEditUtils
:
:
GetAncestorElement
(
aContent
aAncestorTypes
aBlockInlineCheck
aAncestorLimiter
)
;
}
Element
*
HTMLEditUtils
:
:
GetClosestAncestorAnyListElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
Element
*
HTMLEditUtils
:
:
GetClosestInclusiveAncestorAnyListElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
{
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ul
)
{
return
EditAction
:
:
eInsertUnorderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ol
)
{
return
EditAction
:
:
eInsertOrderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
hr
)
{
return
EditAction
:
:
eInsertHorizontalRuleElement
;
}
return
EditAction
:
:
eInsertNode
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
{
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ul
)
{
return
EditAction
:
:
eRemoveUnorderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ol
)
{
return
EditAction
:
:
eRemoveOrderedListElement
;
}
return
EditAction
:
:
eRemoveListElement
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForInsert
(
const
Element
&
aElement
)
{
return
GetEditActionForInsert
(
*
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
{
if
(
&
aProperty
=
=
nsGkAtoms
:
:
b
)
{
return
aToSetStyle
?
EditAction
:
:
eSetFontWeightProperty
:
EditAction
:
:
eRemoveFontWeightProperty
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
i
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextStyleProperty
:
EditAction
:
:
eRemoveTextStyleProperty
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
u
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextDecorationPropertyUnderline
:
EditAction
:
:
eRemoveTextDecorationPropertyUnderline
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
strike
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextDecorationPropertyLineThrough
:
EditAction
:
:
eRemoveTextDecorationPropertyLineThrough
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
return
aToSetStyle
?
EditAction
:
:
eSetVerticalAlignPropertySuper
:
EditAction
:
:
eRemoveVerticalAlignPropertySuper
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
return
aToSetStyle
?
EditAction
:
:
eSetVerticalAlignPropertySub
:
EditAction
:
:
eRemoveVerticalAlignPropertySub
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
font
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
face
)
{
return
aToSetStyle
?
EditAction
:
:
eSetFontFamilyProperty
:
EditAction
:
:
eRemoveFontFamilyProperty
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
color
)
{
return
aToSetStyle
?
EditAction
:
:
eSetColorProperty
:
EditAction
:
:
eRemoveColorProperty
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
)
{
return
aToSetStyle
?
EditAction
:
:
eSetBackgroundColorPropertyInline
:
EditAction
:
:
eRemoveBackgroundColorPropertyInline
;
}
}
return
aToSetStyle
?
EditAction
:
:
eSetInlineStyleProperty
:
EditAction
:
:
eRemoveInlineStyleProperty
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
{
if
(
aAlignType
.
EqualsLiteral
(
"
left
"
)
)
{
return
EditAction
:
:
eAlignLeft
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
right
"
)
)
{
return
EditAction
:
:
eAlignRight
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
center
"
)
)
{
return
EditAction
:
:
eAlignCenter
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
justify
"
)
)
{
return
EditAction
:
:
eJustify
;
}
return
EditAction
:
:
eSetAlignment
;
}
template
<
typename
EditorDOMPointType
>
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInContentNode
(
)
)
)
{
return
nullptr
;
}
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
auto
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
point
.
IsSet
(
)
;
)
{
const
WSScanResult
nextVisibleThing
=
WSRunScanner
:
:
ScanInclusiveNextVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
point
BlockInlineCheck
:
:
UseComputedDisplayOutsideStyle
)
;
if
(
nextVisibleThing
.
InVisibleOrCollapsibleCharacters
(
)
)
{
return
nextVisibleThing
.
TextPtr
(
)
;
}
if
(
nextVisibleThing
.
IsContentEditableRoot
(
)
)
{
break
;
}
if
(
nextVisibleThing
.
ReachedSpecialContent
(
)
&
&
nextVisibleThing
.
IsContentEditable
(
)
&
&
nextVisibleThing
.
ContentIsElement
(
)
&
&
!
nextVisibleThing
.
ElementPtr
(
)
-
>
HasChildNodes
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
nextVisibleThing
.
ElementPtr
(
)
)
)
{
point
.
SetAfter
(
nextVisibleThing
.
ElementPtr
(
)
)
;
continue
;
}
break
;
}
return
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
EditorDOMPointType
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPointTypeInput
&
aPointToInsert
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
auto
pointToInsert
=
aPointToInsert
.
template
GetNonAnonymousSubtreePoint
<
EditorDOMPointType
>
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
pointToInsert
.
GetContainer
(
)
)
)
)
{
return
EditorDOMPointType
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aContentToInsert
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
)
{
return
pointToInsert
;
}
const
WSRunScanner
wsScannerForPointToInsert
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
pointToInsert
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
const
WSScanResult
forwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanInclusiveNextVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
!
forwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
)
{
return
pointToInsert
;
}
const
WSScanResult
backwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
NS_WARN_IF
(
backwardScanFromPointToInsertResult
.
Failed
(
)
)
|
|
backwardScanFromPointToInsertResult
.
ReachedInlineEditingHostBoundary
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
pointToInsert
;
}
return
forwardScanFromPointToInsertResult
.
template
PointAfterReachedContent
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
EditorDOMPointType
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPointTypeInput
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPoint
.
GetContainer
(
)
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
aPoint
.
template
To
<
EditorDOMPointType
>
(
)
;
}
if
(
!
aPoint
.
IsEndOfContainer
(
)
&
&
aPoint
.
GetChild
(
)
&
&
aPoint
.
GetChild
(
)
-
>
IsText
(
)
)
{
return
EditorDOMPointType
(
aPoint
.
GetChild
(
)
0u
)
;
}
if
(
aPoint
.
IsEndOfContainer
(
)
)
{
const
WSScanResult
previousThing
=
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundary
(
WSRunScanner
:
:
Scan
:
:
EditableNodes
aPoint
BlockInlineCheck
:
:
UseComputedDisplayStyle
)
;
if
(
previousThing
.
InVisibleOrCollapsibleCharacters
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
previousThing
.
TextPtr
(
)
)
;
}
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
aPoint
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
aPoint
.
template
To
<
EditorDOMPointType
>
(
)
;
}
if
(
MOZ_UNLIKELY
(
aPoint
.
GetContainer
(
)
-
>
IsEditingHost
(
)
|
|
!
aPoint
.
template
GetContainerParentAs
<
nsIContent
>
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPoint
.
template
ContainerParentAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
textTagName
)
)
)
{
return
EditorDOMPointType
(
)
;
}
return
aPoint
.
ParentPoint
(
)
.
template
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
Result
<
EditorDOMPointType
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPointTypeInput
&
aCurrentPoint
)
{
MOZ_ASSERT
(
aCurrentPoint
.
IsSet
(
)
)
;
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
ShadowIncludingDOM
>
(
const_cast
<
Element
*
>
(
&
aElement
)
aCurrentPoint
.
ToRawRangeBoundary
(
)
aCurrentPoint
.
ToRawRangeBoundary
(
)
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUtils
:
:
CompareNodeToRange
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
EditorDOMPointType
(
)
;
}
if
(
nodeBefore
)
{
const
nsIContent
*
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
lastEditableContent
)
{
lastEditableContent
=
&
aElement
;
}
if
(
lastEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
lastEditableContent
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
lastEditableContent
)
;
}
MOZ_ASSERT
(
lastEditableContent
-
>
GetParentNode
(
)
)
;
return
EditorDOMPointType
:
:
After
(
*
lastEditableContent
)
;
}
const
nsIContent
*
firstEditableContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
firstEditableContent
=
&
aElement
;
}
if
(
firstEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
firstEditableContent
)
)
{
MOZ_ASSERT
(
firstEditableContent
-
>
GetParentNode
(
)
)
;
return
EditorDOMPointType
(
firstEditableContent
)
;
}
return
EditorDOMPointType
(
firstEditableContent
0u
)
;
}
bool
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
const
nsIContent
&
aContent
const
EditorInlineStyle
&
aStyle
const
nsAString
*
aValue
nsAString
*
aOutValue
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
aStyle
.
mHTMLProperty
!
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
if
(
!
aStyle
.
mAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
aStyle
.
mAttribute
value
)
;
if
(
aOutValue
)
{
*
aOutValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
return
false
;
}
}
return
false
;
}
size_t
HTMLEditUtils
:
:
CollectChildren
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
const
CollectChildrenOptions
&
aOptions
)
{
size_t
numberOfFoundChildren
=
0
;
for
(
nsIContent
*
content
=
GetFirstChild
(
aNode
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
(
aOptions
.
contains
(
CollectChildrenOption
:
:
CollectListChildren
)
&
&
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
)
|
|
(
aOptions
.
contains
(
CollectChildrenOption
:
:
CollectTableChildren
)
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
)
)
{
numberOfFoundChildren
+
=
HTMLEditUtils
:
:
CollectChildren
(
*
content
aOutArrayOfContents
aIndexToInsertChildren
+
numberOfFoundChildren
aOptions
)
;
continue
;
}
if
(
aOptions
.
contains
(
CollectChildrenOption
:
:
IgnoreNonEditableChildren
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
CollectChildrenOption
:
:
IgnoreInvisibleTextNodes
)
&
&
content
-
>
IsText
(
)
&
&
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
content
-
>
AsText
(
)
)
)
{
continue
;
}
aOutArrayOfContents
.
InsertElementAt
(
aIndexToInsertChildren
+
numberOfFoundChildren
+
+
*
content
)
;
}
return
numberOfFoundChildren
;
}
size_t
HTMLEditUtils
:
:
CollectEmptyInlineContainerDescendants
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
const
EmptyCheckOptions
&
aOptions
BlockInlineCheck
aBlockInlineCheck
)
{
size_t
numberOfFoundElements
=
0
;
for
(
Element
*
element
=
aNode
.
GetFirstElementChild
(
)
;
element
;
)
{
if
(
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
*
element
aOptions
aBlockInlineCheck
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
element
)
;
numberOfFoundElements
+
+
;
nsIContent
*
nextContent
=
element
-
>
GetNextNonChildNode
(
&
aNode
)
;
element
=
nullptr
;
for
(
;
nextContent
;
nextContent
=
nextContent
-
>
GetNextNode
(
&
aNode
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
element
=
nextContent
-
>
AsElement
(
)
;
break
;
}
}
continue
;
}
nsIContent
*
nextContent
=
element
-
>
GetNextNode
(
&
aNode
)
;
element
=
nullptr
;
for
(
;
nextContent
;
nextContent
=
nextContent
-
>
GetNextNode
(
&
aNode
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
element
=
nextContent
-
>
AsElement
(
)
;
break
;
}
}
}
return
numberOfFoundElements
;
}
bool
HTMLEditUtils
:
:
ElementHasAttributeExcept
(
const
Element
&
aElement
const
nsAtom
&
aAttribute1
const
nsAtom
&
aAttribute2
const
nsAtom
&
aAttribute3
)
{
for
(
auto
i
:
IntegerRange
<
uint32_t
>
(
aElement
.
GetAttrCount
(
)
)
)
{
const
nsAttrName
*
name
=
aElement
.
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
true
;
}
if
(
name
-
>
LocalName
(
)
=
=
&
aAttribute1
|
|
name
-
>
LocalName
(
)
=
=
&
aAttribute2
|
|
name
-
>
LocalName
(
)
=
=
&
aAttribute3
)
{
continue
;
}
if
(
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
style
|
|
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
_class
|
|
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
id
)
{
if
(
aElement
.
HasNonEmptyAttr
(
name
-
>
LocalName
(
)
)
)
{
return
true
;
}
continue
;
}
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
u
"
_moz
"
_ns
)
)
{
return
true
;
}
}
return
false
;
}
bool
HTMLEditUtils
:
:
GetNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
{
nsAttrValue
value
;
if
(
!
value
.
ParseColor
(
aColorValue
)
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
nscolor
color
=
NS_RGB
(
0
0
0
)
;
MOZ_ALWAYS_TRUE
(
value
.
GetColorValue
(
color
)
)
;
aNormalizedValue
=
NS_ConvertASCIItoUTF16
(
nsPrintfCString
(
"
#
%
02x
%
02x
%
02x
"
NS_GET_R
(
color
)
NS_GET_G
(
color
)
NS_GET_B
(
color
)
)
)
;
return
true
;
}
bool
HTMLEditUtils
:
:
IsSameHTMLColorValue
(
const
nsAString
&
aColorA
const
nsAString
&
aColorB
TransparentKeyword
aTransparentKeyword
)
{
if
(
aTransparentKeyword
=
=
TransparentKeyword
:
:
Allowed
)
{
const
bool
isATransparent
=
aColorA
.
LowerCaseEqualsLiteral
(
"
transparent
"
)
;
const
bool
isBTransparent
=
aColorB
.
LowerCaseEqualsLiteral
(
"
transparent
"
)
;
if
(
isATransparent
|
|
isBTransparent
)
{
return
isATransparent
&
&
isBTransparent
;
}
}
nsAttrValue
valueA
valueB
;
if
(
!
valueA
.
ParseColor
(
aColorA
)
|
|
!
valueB
.
ParseColor
(
aColorB
)
)
{
return
false
;
}
nscolor
colorA
=
NS_RGB
(
0
0
0
)
colorB
=
NS_RGB
(
0
0
0
)
;
MOZ_ALWAYS_TRUE
(
valueA
.
GetColorValue
(
colorA
)
)
;
MOZ_ALWAYS_TRUE
(
valueB
.
GetColorValue
(
colorB
)
)
;
return
colorA
=
=
colorB
;
}
bool
HTMLEditUtils
:
:
MaybeCSSSpecificColorValue
(
const
nsAString
&
aColorValue
)
{
if
(
aColorValue
.
IsEmpty
(
)
|
|
aColorValue
.
First
(
)
=
=
'
#
'
)
{
return
false
;
}
nsAutoString
colorValue
(
aColorValue
)
;
colorValue
.
CompressWhitespace
(
true
true
)
;
if
(
colorValue
.
LowerCaseEqualsASCII
(
"
transparent
"
)
)
{
return
true
;
}
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
colorValue
.
IsEmpty
(
)
|
|
colorValue
.
First
(
)
=
=
'
#
'
)
{
return
false
;
}
const
NS_ConvertUTF16toUTF8
colorU8
(
colorValue
)
;
if
(
Servo_ColorNameToRgb
(
&
colorU8
&
color
)
)
{
return
false
;
}
if
(
colorValue
.
LowerCaseEqualsASCII
(
"
initial
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
inherit
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
unset
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
revert
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
currentcolor
"
)
)
{
return
true
;
}
return
ServoCSSParser
:
:
IsValidCSSColor
(
colorU8
)
;
}
static
bool
ComputeColor
(
const
nsAString
&
aColorValue
nscolor
*
aColor
bool
*
aIsCurrentColor
)
{
return
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
NS_ConvertUTF16toUTF8
(
aColorValue
)
aColor
aIsCurrentColor
)
;
}
static
bool
ComputeColor
(
const
nsACString
&
aColorValue
nscolor
*
aColor
bool
*
aIsCurrentColor
)
{
return
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
aColorValue
aColor
aIsCurrentColor
)
;
}
bool
HTMLEditUtils
:
:
CanConvertToHTMLColorValue
(
const
nsAString
&
aColorValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
return
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
&
&
!
isCurrentColor
&
&
NS_GET_A
(
color
)
=
=
0xFF
;
}
bool
HTMLEditUtils
:
:
ConvertToNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
|
|
isCurrentColor
|
|
NS_GET_A
(
color
)
!
=
0xFF
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
aNormalizedValue
.
Truncate
(
)
;
aNormalizedValue
.
AppendPrintf
(
"
#
%
02x
%
02x
%
02x
"
NS_GET_R
(
color
)
NS_GET_G
(
color
)
NS_GET_B
(
color
)
)
;
return
true
;
}
bool
HTMLEditUtils
:
:
GetNormalizedCSSColorValue
(
const
nsAString
&
aColorValue
ZeroAlphaColor
aZeroAlphaColor
nsAString
&
aNormalizedValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
if
(
isCurrentColor
)
{
aNormalizedValue
=
aColorValue
;
return
true
;
}
if
(
aZeroAlphaColor
=
=
ZeroAlphaColor
:
:
TransparentKeyword
&
&
NS_GET_A
(
color
)
=
=
0
)
{
aNormalizedValue
.
AssignLiteral
(
"
transparent
"
)
;
return
true
;
}
aNormalizedValue
.
Truncate
(
)
;
nsStyleUtil
:
:
GetSerializedColorValue
(
color
aNormalizedValue
)
;
return
true
;
}
template
<
typename
CharType
>
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsTSubstring
<
CharType
>
&
aColorA
const
nsTSubstring
<
CharType
>
&
aColorB
)
{
bool
isACurrentColor
=
false
;
nscolor
colorA
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorA
&
colorA
&
isACurrentColor
)
)
{
return
false
;
}
bool
isBCurrentColor
=
false
;
nscolor
colorB
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorB
&
colorB
&
isBCurrentColor
)
)
{
return
false
;
}
if
(
isACurrentColor
|
|
isBCurrentColor
)
{
return
isACurrentColor
&
&
isBCurrentColor
;
}
return
colorA
=
=
colorB
;
}
bool
HTMLEditUtils
:
:
IsTransparentCSSColor
(
const
nsAString
&
aColor
)
{
nsAutoString
normalizedCSSColorValue
;
return
GetNormalizedCSSColorValue
(
aColor
ZeroAlphaColor
:
:
TransparentKeyword
normalizedCSSColorValue
)
&
&
normalizedCSSColorValue
.
EqualsASCII
(
"
transparent
"
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
HTMLEditUtils
:
:
EditablePointOption
&
aOption
)
{
constexpr
static
const
char
*
names
[
]
=
{
"
RecognizeInvisibleWhiteSpaces
"
"
StopAtComment
"
"
StopAtListElement
"
"
StopAtListItemElement
"
"
StopAtTableElement
"
"
StopAtAnyTableElement
"
}
;
return
aStream
<
<
names
[
static_cast
<
uint32_t
>
(
aOption
)
]
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
HTMLEditUtils
:
:
EditablePointOptions
&
aOptions
)
{
aStream
<
<
"
{
"
;
bool
first
=
true
;
for
(
const
auto
option
:
aOptions
)
{
if
(
!
first
)
{
aStream
<
<
"
"
;
}
aStream
<
<
ToString
(
option
)
.
c_str
(
)
;
first
=
false
;
}
return
aStream
<
<
"
}
"
;
}
SelectedTableCellScanner
:
:
SelectedTableCellScanner
(
const
AutoClonedRangeArray
&
aRanges
)
{
if
(
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
;
}
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
aRanges
.
FirstRangeRef
(
)
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
for
(
uint32_t
i
=
1
;
i
<
aRanges
.
Ranges
(
)
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
aRanges
.
Ranges
(
)
[
i
]
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
continue
;
}
if
(
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
}
