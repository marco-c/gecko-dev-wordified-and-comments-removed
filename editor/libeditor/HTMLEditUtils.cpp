#
include
"
HTMLEditUtils
.
h
"
#
include
"
AutoRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
dom
/
StaticRange
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
EditorType
=
EditorBase
:
:
EditorType
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorRawDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorRawDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorRawDOMPoint
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorRawDOMPointInText
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
EditorRawDOMPoint
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorRawDOMPoint
&
aPoint
const
Element
&
aEditingHost
)
;
template
Result
<
EditorDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorRawDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorRawDOMPoint
&
aCurrentPoint
)
;
template
Result
<
EditorRawDOMPoint
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorRawDOMPoint
&
aCurrentPoint
)
;
template
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsAString
&
aColorA
const
nsAString
&
aColorB
)
;
template
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsACString
&
aColorA
const
nsACString
&
aColorB
)
;
bool
HTMLEditUtils
:
:
CanContentsBeJoined
(
const
nsIContent
&
aLeftContent
const
nsIContent
&
aRightContent
)
{
if
(
aLeftContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
aRightContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
false
;
}
if
(
!
aLeftContent
.
IsElement
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
aRightContent
.
IsElement
(
)
)
;
if
(
aLeftContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
font
)
{
const
nsAttrValue
*
const
leftSize
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
size
)
;
const
nsAttrValue
*
const
rightSize
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
size
)
;
if
(
!
leftSize
^
!
rightSize
|
|
(
leftSize
&
&
!
leftSize
-
>
Equals
(
*
rightSize
)
)
)
{
return
false
;
}
const
nsAttrValue
*
const
leftColor
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
color
)
;
const
nsAttrValue
*
const
rightColor
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
color
)
;
if
(
!
leftColor
^
!
rightColor
|
|
(
leftColor
&
&
!
leftColor
-
>
Equals
(
*
rightColor
)
)
)
{
return
false
;
}
const
nsAttrValue
*
const
leftFace
=
aLeftContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
face
)
;
const
nsAttrValue
*
const
rightFace
=
aRightContent
.
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
face
)
;
if
(
!
leftFace
^
!
rightFace
|
|
(
leftFace
&
&
!
leftFace
-
>
Equals
(
*
rightFace
)
)
)
{
return
false
;
}
}
nsStyledElement
*
leftStyledElement
=
nsStyledElement
:
:
FromNode
(
const_cast
<
nsIContent
*
>
(
&
aLeftContent
)
)
;
if
(
!
leftStyledElement
)
{
return
false
;
}
nsStyledElement
*
rightStyledElement
=
nsStyledElement
:
:
FromNode
(
const_cast
<
nsIContent
*
>
(
&
aRightContent
)
)
;
if
(
!
rightStyledElement
)
{
return
false
;
}
return
CSSEditUtils
:
:
DoStyledElementsHaveSameStyle
(
*
leftStyledElement
*
rightStyledElement
)
;
}
bool
HTMLEditUtils
:
:
IsBlockElement
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsElement
(
)
)
{
return
false
;
}
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
MOZ_ASSERT
(
!
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
nsGkAtoms
:
:
br
)
)
)
;
return
false
;
}
if
(
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
return
true
;
}
return
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
}
bool
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
const
nsIContent
&
aContent
)
{
if
(
!
aContent
.
IsElement
(
)
)
{
return
false
;
}
if
(
!
aContent
.
IsHTMLElement
(
)
)
{
return
true
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
)
{
return
true
;
}
if
(
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
applet
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
img
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
{
return
true
;
}
if
(
const
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
&
aContent
)
)
{
return
inputElement
-
>
ControlType
(
)
!
=
FormControlType
:
:
InputHidden
;
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsInlineStyle
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
s
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
font
)
;
}
bool
HTMLEditUtils
:
:
IsDisplayOutsideInline
(
const
Element
&
aElement
)
{
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
&
aElement
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleDisplay
(
)
-
>
DisplayOutside
(
)
=
=
StyleDisplayOutside
:
:
Inline
;
}
bool
HTMLEditUtils
:
:
IsDisplayInsideFlowRoot
(
const
Element
&
aElement
)
{
RefPtr
<
const
ComputedStyle
>
elementStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
&
aElement
)
;
if
(
!
elementStyle
)
{
return
false
;
}
return
elementStyle
-
>
StyleDisplay
(
)
-
>
DisplayInside
(
)
=
=
StyleDisplayInside
:
:
FlowRoot
;
}
bool
HTMLEditUtils
:
:
IsRemovableInlineStyleElement
(
Element
&
aElement
)
{
if
(
!
aElement
.
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
b
nsGkAtoms
:
:
bdi
nsGkAtoms
:
:
bdo
nsGkAtoms
:
:
big
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
code
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
em
nsGkAtoms
:
:
font
nsGkAtoms
:
:
i
nsGkAtoms
:
:
ins
nsGkAtoms
:
:
kbd
nsGkAtoms
:
:
mark
nsGkAtoms
:
:
nobr
nsGkAtoms
:
:
q
nsGkAtoms
:
:
s
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
small
nsGkAtoms
:
:
span
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
u
nsGkAtoms
:
:
var
)
)
{
return
true
;
}
nsAutoString
tagName
;
aElement
.
GetTagName
(
tagName
)
;
return
tagName
.
LowerCaseEqualsASCII
(
"
blink
"
)
;
}
bool
HTMLEditUtils
:
:
IsFormatNode
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
p
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
nsGkAtoms
:
:
address
)
;
}
bool
HTMLEditUtils
:
:
IsNodeThatCanOutdent
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
blockquote
)
;
}
bool
HTMLEditUtils
:
:
IsHeader
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
bool
HTMLEditUtils
:
:
IsListItem
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
dt
)
;
}
bool
HTMLEditUtils
:
:
IsAnyTableElement
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsAnyTableElementButNotTable
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsTable
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
bool
HTMLEditUtils
:
:
IsTableRow
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
;
}
bool
HTMLEditUtils
:
:
IsTableCell
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
bool
HTMLEditUtils
:
:
IsTableCellOrCaption
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
caption
)
;
}
bool
HTMLEditUtils
:
:
IsAnyListElement
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
dl
)
;
}
bool
HTMLEditUtils
:
:
IsPre
(
const
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
pre
)
;
}
bool
HTMLEditUtils
:
:
IsImage
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
;
}
bool
HTMLEditUtils
:
:
IsLink
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
false
;
}
RefPtr
<
const
dom
:
:
HTMLAnchorElement
>
anchor
=
dom
:
:
HTMLAnchorElement
:
:
FromNodeOrNull
(
aNode
-
>
AsContent
(
)
)
;
if
(
!
anchor
)
{
return
false
;
}
nsAutoString
tmpText
;
anchor
-
>
GetHref
(
tmpText
)
;
return
!
tmpText
.
IsEmpty
(
)
;
}
bool
HTMLEditUtils
:
:
IsNamedAnchor
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
return
false
;
}
nsAutoString
text
;
return
aNode
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
name
text
)
&
&
!
text
.
IsEmpty
(
)
;
}
bool
HTMLEditUtils
:
:
IsMozDiv
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
&
&
aNode
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
u
"
_moz
"
_ns
eIgnoreCase
)
;
}
bool
HTMLEditUtils
:
:
IsMailCite
(
const
Element
&
aElement
)
{
if
(
aElement
.
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
u
"
cite
"
_ns
eIgnoreCase
)
)
{
return
true
;
}
if
(
aElement
.
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozquote
u
"
true
"
_ns
eIgnoreCase
)
)
{
return
true
;
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsFormWidget
(
const
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
return
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
textarea
nsGkAtoms
:
:
select
nsGkAtoms
:
:
button
nsGkAtoms
:
:
output
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
input
)
;
}
bool
HTMLEditUtils
:
:
SupportsAlignAttr
(
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
nsGkAtoms
:
:
div
nsGkAtoms
:
:
p
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
bool
HTMLEditUtils
:
:
IsVisibleTextNode
(
const
Text
&
aText
)
{
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
Maybe
<
uint32_t
>
visibleCharOffset
=
HTMLEditUtils
:
:
GetInclusiveNextNonCollapsibleCharOffset
(
EditorDOMPointInText
(
&
aText
0
)
)
;
if
(
visibleCharOffset
.
isSome
(
)
)
{
return
true
;
}
return
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aText
WalkTreeDirection
:
:
Forward
)
&
&
!
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
aText
WalkTreeDirection
:
:
Backward
)
;
}
bool
HTMLEditUtils
:
:
IsInVisibleTextFrames
(
nsPresContext
*
aPresContext
const
Text
&
aText
)
{
MOZ_ASSERT
(
aPresContext
)
;
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
nsTextFrame
*
textFrame
=
do_QueryFrame
(
aText
.
GetPrimaryFrame
(
)
)
;
if
(
!
textFrame
)
{
return
false
;
}
return
textFrame
-
>
HasVisibleText
(
)
;
}
Element
*
HTMLEditUtils
:
:
GetElementOfImmediateBlockBoundary
(
const
nsIContent
&
aContent
const
WalkTreeDirection
aDirection
)
{
MOZ_ASSERT
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
|
|
aContent
.
IsText
(
)
)
;
Element
*
maybeNonEditableAncestorBlock
=
HTMLEditUtils
:
:
GetAncestorElement
(
aContent
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
NS_WARN_IF
(
!
maybeNonEditableAncestorBlock
)
)
{
return
nullptr
;
}
auto
getNextContent
=
[
&
aDirection
&
maybeNonEditableAncestorBlock
]
(
const
nsIContent
&
aContent
)
-
>
nsIContent
*
{
return
aDirection
=
=
WalkTreeDirection
:
:
Forward
?
HTMLEditUtils
:
:
GetNextContent
(
aContent
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
StopAtBlockBoundary
}
maybeNonEditableAncestorBlock
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
aContent
{
WalkTreeOption
:
:
IgnoreDataNodeExceptText
WalkTreeOption
:
:
StopAtBlockBoundary
}
maybeNonEditableAncestorBlock
)
;
}
;
const
bool
isBRElement
=
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
;
for
(
nsIContent
*
nextContent
=
getNextContent
(
aContent
)
;
nextContent
;
nextContent
=
getNextContent
(
*
nextContent
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
nextContent
-
>
AsElement
(
)
;
}
if
(
!
nextContent
-
>
IsHTMLElement
(
)
)
{
return
nextContent
-
>
AsElement
(
)
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
nextContent
)
)
{
return
nullptr
;
}
if
(
nextContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
isBRElement
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aContent
.
IsText
(
)
)
;
if
(
aDirection
=
=
WalkTreeDirection
:
:
Forward
)
{
return
nullptr
;
}
return
nextContent
-
>
AsElement
(
)
;
}
continue
;
}
Text
*
textNode
=
Text
:
:
FromNode
(
nextContent
)
;
if
(
NS_WARN_IF
(
!
textNode
)
)
{
continue
;
}
if
(
!
textNode
-
>
TextLength
(
)
)
{
continue
;
}
if
(
!
textNode
-
>
TextIsOnlyWhitespace
(
)
)
{
return
nullptr
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
const
bool
isWhiteSpacePreformatted
=
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
textNode
)
;
const
bool
isNewLinePreformatted
=
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
;
if
(
!
isWhiteSpacePreformatted
&
&
!
isNewLinePreformatted
)
{
continue
;
}
for
(
uint32_t
i
=
0
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
if
(
textFragment
.
CharAt
(
i
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
if
(
isNewLinePreformatted
)
{
return
nullptr
;
}
continue
;
}
if
(
isWhiteSpacePreformatted
)
{
return
nullptr
;
}
}
}
return
maybeNonEditableAncestorBlock
;
}
nsIContent
*
HTMLEditUtils
:
:
GetUnnecessaryLineBreakContent
(
const
Element
&
aBlockElement
ScanLineBreak
aScanLineBreak
)
{
auto
*
lastLineBreakContent
=
[
&
]
(
)
-
>
nsIContent
*
{
const
LeafNodeTypes
leafNodeOrNonEditableNode
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
;
const
WalkTreeOptions
onlyPrecedingLine
{
WalkTreeOption
:
:
StopAtBlockBoundary
}
;
for
(
nsIContent
*
content
=
aScanLineBreak
=
=
ScanLineBreak
:
:
AtEndOfBlock
?
HTMLEditUtils
:
:
GetLastLeafContent
(
aBlockElement
leafNodeOrNonEditableNode
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
aBlockElement
onlyPrecedingLine
aBlockElement
.
GetParentElement
(
)
)
;
content
;
content
=
aScanLineBreak
=
=
ScanLineBreak
:
:
AtEndOfBlock
?
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
content
aBlockElement
leafNodeOrNonEditableNode
)
:
HTMLEditUtils
:
:
GetPreviousContent
(
*
content
onlyPrecedingLine
aBlockElement
.
GetParentElement
(
)
)
)
{
if
(
aScanLineBreak
=
=
ScanLineBreak
:
:
BeforeBlock
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
)
{
return
nullptr
;
}
if
(
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
if
(
!
textNode
-
>
TextLength
(
)
)
{
continue
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
&
&
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
if
(
textFragment
.
GetLength
(
)
=
=
1u
)
{
return
textNode
;
}
return
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
2u
)
=
=
HTMLEditUtils
:
:
kNewLine
?
nullptr
:
textNode
;
}
if
(
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
textNode
)
)
{
return
nullptr
;
}
continue
;
}
if
(
content
-
>
IsCharacterData
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
content
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
content
)
)
{
return
nullptr
;
}
}
return
nullptr
;
}
(
)
;
if
(
!
lastLineBreakContent
)
{
return
nullptr
;
}
Text
*
lastLineBreakText
=
Text
:
:
FromNode
(
lastLineBreakContent
)
;
if
(
lastLineBreakText
&
&
lastLineBreakText
-
>
TextDataLength
(
)
!
=
1u
)
{
return
lastLineBreakText
;
}
const
LeafNodeTypes
leafNodeOrNonEditableNodeOrChildBlock
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
;
const
Element
*
blockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
lastLineBreakContent
HTMLEditUtils
:
:
ClosestBlockElement
)
;
for
(
nsIContent
*
content
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
lastLineBreakContent
*
blockElement
leafNodeOrNonEditableNodeOrChildBlock
)
;
content
;
content
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
content
*
blockElement
leafNodeOrNonEditableNodeOrChildBlock
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
content
)
|
|
(
content
-
>
IsElement
(
)
&
&
!
content
-
>
IsHTMLElement
(
)
)
)
{
return
nullptr
;
}
if
(
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
if
(
!
textNode
-
>
TextLength
(
)
)
{
continue
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
if
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
textNode
)
&
&
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
=
=
HTMLEditUtils
:
:
kNewLine
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
textNode
)
)
{
continue
;
}
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
textNode
)
)
{
return
lastLineBreakContent
;
}
switch
(
textFragment
.
CharAt
(
textFragment
.
GetLength
(
)
-
1u
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
case
HTMLEditUtils
:
:
kNBSP
:
return
nullptr
;
default
:
return
lastLineBreakContent
;
}
}
if
(
content
-
>
IsCharacterData
(
)
)
{
continue
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
if
(
HTMLEditUtils
:
:
IsVisibleElementEvenIfLeafNode
(
*
content
)
)
{
return
lastLineBreakContent
;
}
}
return
nullptr
;
}
bool
HTMLEditUtils
:
:
IsEmptyNode
(
nsPresContext
*
aPresContext
const
nsINode
&
aNode
const
EmptyCheckOptions
&
aOptions
bool
*
aSeenBR
)
{
MOZ_ASSERT_IF
(
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
aPresContext
)
;
if
(
aSeenBR
)
{
*
aSeenBR
=
false
;
}
if
(
const
Text
*
text
=
Text
:
:
FromNode
(
&
aNode
)
)
{
return
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
?
!
IsInVisibleTextFrames
(
aPresContext
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
}
if
(
!
aNode
.
IsContent
(
)
|
|
!
IsContainerNode
(
*
aNode
.
AsContent
(
)
)
|
|
IsNamedAnchor
(
&
aNode
)
|
|
IsFormWidget
(
&
aNode
)
|
|
(
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatListItemAsVisible
)
&
&
IsListItem
(
&
aNode
)
)
|
|
(
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatTableCellAsVisible
)
&
&
IsTableCell
(
&
aNode
)
)
)
{
return
false
;
}
const
bool
isListItem
=
IsListItem
(
&
aNode
)
;
const
bool
isTableCell
=
IsTableCell
(
&
aNode
)
;
bool
seenBR
=
aSeenBR
&
&
*
aSeenBR
;
for
(
nsIContent
*
childContent
=
aNode
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
aOptions
.
contains
(
EmptyCheckOption
:
:
IgnoreEditableState
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
childContent
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
Text
*
text
=
Text
:
:
FromNode
(
childContent
)
)
{
if
(
aOptions
.
contains
(
EmptyCheckOption
:
:
SafeToAskLayout
)
?
IsInVisibleTextFrames
(
aPresContext
*
text
)
:
IsVisibleTextNode
(
*
text
)
)
{
return
false
;
}
continue
;
}
if
(
childContent
=
=
&
aNode
)
{
break
;
}
if
(
!
aOptions
.
contains
(
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
)
&
&
!
seenBR
&
&
childContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
seenBR
=
true
;
if
(
aSeenBR
)
{
*
aSeenBR
=
true
;
}
continue
;
}
if
(
childContent
-
>
IsElement
(
)
)
{
if
(
isListItem
|
|
isTableCell
)
{
if
(
IsAnyListElement
(
childContent
)
|
|
childContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
false
;
}
}
else
if
(
IsFormWidget
(
childContent
)
)
{
return
false
;
}
}
if
(
!
IsEmptyNode
(
aPresContext
*
childContent
aOptions
&
seenBR
)
)
{
if
(
aSeenBR
)
{
*
aSeenBR
=
seenBR
;
}
return
false
;
}
}
if
(
aSeenBR
)
{
*
aSeenBR
=
seenBR
;
}
return
true
;
}
bool
HTMLEditUtils
:
:
ShouldInsertLinefeedCharacter
(
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
if
(
!
aPointToInsert
.
IsInContentNode
(
)
)
{
return
false
;
}
Element
*
closestEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
return
(
!
closestEditableBlockElement
|
|
closestEditableBlockElement
=
=
&
aEditingHost
)
&
&
HTMLEditUtils
:
:
IsDisplayOutsideInline
(
aEditingHost
)
&
&
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
}
#
define
GROUP_NONE
0
#
define
GROUP_TOPLEVEL
(
1
<
<
1
)
#
define
GROUP_HEAD_CONTENT
(
1
<
<
2
)
#
define
GROUP_FONTSTYLE
(
1
<
<
3
)
#
define
GROUP_PHRASE
(
1
<
<
4
)
#
define
GROUP_SPECIAL
(
1
<
<
5
)
#
define
GROUP_FORMCONTROL
(
1
<
<
6
)
#
define
GROUP_BLOCK
(
1
<
<
7
)
#
define
GROUP_FRAME
(
1
<
<
8
)
#
define
GROUP_TABLE_CONTENT
(
1
<
<
9
)
#
define
GROUP_TBODY_CONTENT
(
1
<
<
10
)
#
define
GROUP_TR_CONTENT
(
1
<
<
11
)
#
define
GROUP_COLGROUP_CONTENT
(
1
<
<
12
)
#
define
GROUP_OBJECT_CONTENT
(
1
<
<
13
)
#
define
GROUP_LI
(
1
<
<
14
)
#
define
GROUP_MAP_CONTENT
(
1
<
<
15
)
#
define
GROUP_SELECT_CONTENT
(
1
<
<
16
)
#
define
GROUP_OPTIONS
(
1
<
<
17
)
#
define
GROUP_DL_CONTENT
(
1
<
<
18
)
#
define
GROUP_P
(
1
<
<
19
)
#
define
GROUP_LEAF
(
1
<
<
20
)
#
define
GROUP_OL_UL
(
1
<
<
21
)
#
define
GROUP_HEADING
(
1
<
<
22
)
#
define
GROUP_FIGCAPTION
(
1
<
<
23
)
#
define
GROUP_PICTURE_CONTENT
(
1
<
<
24
)
#
define
GROUP_INLINE_ELEMENT
\
(
GROUP_FONTSTYLE
|
GROUP_PHRASE
|
GROUP_SPECIAL
|
GROUP_FORMCONTROL
|
\
GROUP_LEAF
)
#
define
GROUP_FLOW_ELEMENT
(
GROUP_INLINE_ELEMENT
|
GROUP_BLOCK
)
struct
ElementInfo
final
{
#
ifdef
DEBUG
nsHTMLTag
mTag
;
#
endif
uint32_t
mGroup
;
uint32_t
mCanContainGroups
;
bool
mIsContainer
;
bool
mCanContainSelf
;
}
;
#
ifdef
DEBUG
#
define
ELEM
(
_tag
_isContainer
_canContainSelf
_group
_canContainGroups
)
\
{
\
eHTMLTag_
#
#
_tag
_group
_canContainGroups
_isContainer
\
_canContainSelf
\
}
#
else
#
define
ELEM
(
_tag
_isContainer
_canContainSelf
_group
_canContainGroups
)
\
{
_group
_canContainGroups
_isContainer
_canContainSelf
}
#
endif
static
const
ElementInfo
kElements
[
eHTMLTag_userdefined
]
=
{
ELEM
(
a
true
false
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
abbr
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
acronym
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
address
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
|
GROUP_P
)
ELEM
(
applet
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_OBJECT_CONTENT
)
ELEM
(
area
false
false
GROUP_MAP_CONTENT
GROUP_NONE
)
ELEM
(
article
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
aside
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
audio
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
b
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
base
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
basefont
false
false
GROUP_SPECIAL
GROUP_NONE
)
ELEM
(
bdi
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
bdo
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
bgsound
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
big
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
blockquote
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
body
true
true
GROUP_TOPLEVEL
GROUP_FLOW_ELEMENT
)
ELEM
(
br
false
false
GROUP_SPECIAL
GROUP_NONE
)
ELEM
(
button
true
true
GROUP_FORMCONTROL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
canvas
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
caption
true
true
GROUP_NONE
GROUP_INLINE_ELEMENT
)
ELEM
(
center
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
cite
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
code
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
col
false
false
GROUP_TABLE_CONTENT
|
GROUP_COLGROUP_CONTENT
GROUP_NONE
)
ELEM
(
colgroup
true
false
GROUP_NONE
GROUP_COLGROUP_CONTENT
)
ELEM
(
data
true
false
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
datalist
true
false
GROUP_PHRASE
GROUP_OPTIONS
|
GROUP_INLINE_ELEMENT
)
ELEM
(
dd
true
false
GROUP_DL_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
del
true
true
GROUP_PHRASE
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
details
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dfn
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
dialog
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dir
true
false
GROUP_BLOCK
GROUP_LI
)
ELEM
(
div
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
dl
true
false
GROUP_BLOCK
GROUP_DL_CONTENT
)
ELEM
(
dt
true
true
GROUP_DL_CONTENT
GROUP_INLINE_ELEMENT
)
ELEM
(
em
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
embed
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
fieldset
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
figcaption
true
false
GROUP_FIGCAPTION
GROUP_FLOW_ELEMENT
)
ELEM
(
figure
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_FIGCAPTION
)
ELEM
(
font
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
footer
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
form
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
frame
false
false
GROUP_FRAME
GROUP_NONE
)
ELEM
(
frameset
true
true
GROUP_FRAME
GROUP_FRAME
)
ELEM
(
h1
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h2
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h3
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h4
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h5
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
h6
true
false
GROUP_BLOCK
|
GROUP_HEADING
GROUP_INLINE_ELEMENT
)
ELEM
(
head
true
false
GROUP_TOPLEVEL
GROUP_HEAD_CONTENT
)
ELEM
(
header
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
hgroup
true
false
GROUP_BLOCK
GROUP_HEADING
)
ELEM
(
hr
false
false
GROUP_BLOCK
GROUP_NONE
)
ELEM
(
html
true
false
GROUP_TOPLEVEL
GROUP_TOPLEVEL
)
ELEM
(
i
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
iframe
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
image
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
img
false
false
GROUP_SPECIAL
|
GROUP_PICTURE_CONTENT
GROUP_NONE
)
ELEM
(
input
false
false
GROUP_FORMCONTROL
GROUP_NONE
)
ELEM
(
ins
true
true
GROUP_PHRASE
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
kbd
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
keygen
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
label
true
false
GROUP_FORMCONTROL
GROUP_INLINE_ELEMENT
)
ELEM
(
legend
true
true
GROUP_NONE
GROUP_INLINE_ELEMENT
)
ELEM
(
li
true
false
GROUP_LI
GROUP_FLOW_ELEMENT
)
ELEM
(
link
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
listing
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
)
ELEM
(
main
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
map
true
true
GROUP_SPECIAL
GROUP_BLOCK
|
GROUP_MAP_CONTENT
)
ELEM
(
mark
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
marquee
true
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
menu
true
true
GROUP_BLOCK
GROUP_LI
|
GROUP_FLOW_ELEMENT
)
ELEM
(
meta
false
false
GROUP_HEAD_CONTENT
GROUP_NONE
)
ELEM
(
meter
true
false
GROUP_SPECIAL
GROUP_FLOW_ELEMENT
)
ELEM
(
multicol
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
nav
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
nobr
true
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
noembed
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
noframes
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
noscript
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
object
true
true
GROUP_SPECIAL
|
GROUP_BLOCK
GROUP_FLOW_ELEMENT
|
GROUP_OBJECT_CONTENT
)
ELEM
(
ol
true
true
GROUP_BLOCK
|
GROUP_OL_UL
GROUP_LI
|
GROUP_OL_UL
)
ELEM
(
optgroup
true
false
GROUP_SELECT_CONTENT
GROUP_OPTIONS
)
ELEM
(
option
true
false
GROUP_SELECT_CONTENT
|
GROUP_OPTIONS
GROUP_LEAF
)
ELEM
(
output
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
p
true
false
GROUP_BLOCK
|
GROUP_P
GROUP_INLINE_ELEMENT
)
ELEM
(
param
false
false
GROUP_OBJECT_CONTENT
GROUP_NONE
)
ELEM
(
picture
true
false
GROUP_SPECIAL
GROUP_PICTURE_CONTENT
)
ELEM
(
plaintext
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
pre
true
true
GROUP_BLOCK
GROUP_INLINE_ELEMENT
)
ELEM
(
progress
true
false
GROUP_SPECIAL
GROUP_FLOW_ELEMENT
)
ELEM
(
q
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
rb
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rp
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rt
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
rtc
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
ruby
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
s
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
samp
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
script
true
false
GROUP_HEAD_CONTENT
|
GROUP_SPECIAL
GROUP_LEAF
)
ELEM
(
section
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
select
true
false
GROUP_FORMCONTROL
GROUP_SELECT_CONTENT
)
ELEM
(
small
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
slot
true
false
GROUP_NONE
GROUP_FLOW_ELEMENT
)
ELEM
(
source
false
false
GROUP_PICTURE_CONTENT
GROUP_NONE
)
ELEM
(
span
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
strike
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
strong
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
style
true
false
GROUP_HEAD_CONTENT
GROUP_LEAF
)
ELEM
(
sub
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
summary
true
true
GROUP_BLOCK
GROUP_FLOW_ELEMENT
)
ELEM
(
sup
true
true
GROUP_SPECIAL
GROUP_INLINE_ELEMENT
)
ELEM
(
table
true
false
GROUP_BLOCK
GROUP_TABLE_CONTENT
)
ELEM
(
tbody
true
false
GROUP_TABLE_CONTENT
GROUP_TBODY_CONTENT
)
ELEM
(
td
true
false
GROUP_TR_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
textarea
true
false
GROUP_FORMCONTROL
GROUP_LEAF
)
ELEM
(
tfoot
true
false
GROUP_NONE
GROUP_TBODY_CONTENT
)
ELEM
(
th
true
false
GROUP_TR_CONTENT
GROUP_FLOW_ELEMENT
)
ELEM
(
thead
true
false
GROUP_NONE
GROUP_TBODY_CONTENT
)
ELEM
(
template
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
time
true
false
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
title
true
false
GROUP_HEAD_CONTENT
GROUP_LEAF
)
ELEM
(
tr
true
false
GROUP_TBODY_CONTENT
GROUP_TR_CONTENT
)
ELEM
(
track
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
tt
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
u
true
true
GROUP_FONTSTYLE
GROUP_INLINE_ELEMENT
)
ELEM
(
ul
true
true
GROUP_BLOCK
|
GROUP_OL_UL
GROUP_LI
|
GROUP_OL_UL
)
ELEM
(
var
true
true
GROUP_PHRASE
GROUP_INLINE_ELEMENT
)
ELEM
(
video
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
wbr
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
xmp
true
false
GROUP_BLOCK
GROUP_NONE
)
ELEM
(
text
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
whitespace
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
newline
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
comment
false
false
GROUP_LEAF
GROUP_NONE
)
ELEM
(
entity
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
doctypeDecl
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
markupDecl
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
instruction
false
false
GROUP_NONE
GROUP_NONE
)
ELEM
(
userdefined
true
false
GROUP_NONE
GROUP_FLOW_ELEMENT
)
}
;
bool
HTMLEditUtils
:
:
CanNodeContain
(
nsHTMLTag
aParentTagId
nsHTMLTag
aChildTagId
)
{
NS_ASSERTION
(
aParentTagId
>
eHTMLTag_unknown
&
&
aParentTagId
<
=
eHTMLTag_userdefined
"
aParentTagId
out
of
range
!
"
)
;
NS_ASSERTION
(
aChildTagId
>
eHTMLTag_unknown
&
&
aChildTagId
<
=
eHTMLTag_userdefined
"
aChildTagId
out
of
range
!
"
)
;
#
ifdef
DEBUG
static
bool
checked
=
false
;
if
(
!
checked
)
{
checked
=
true
;
int32_t
i
;
for
(
i
=
1
;
i
<
=
eHTMLTag_userdefined
;
+
+
i
)
{
NS_ASSERTION
(
kElements
[
i
-
1
]
.
mTag
=
=
i
"
You
need
to
update
kElements
(
missing
tags
)
.
"
)
;
}
}
#
endif
if
(
aParentTagId
=
=
eHTMLTag_button
)
{
static
const
nsHTMLTag
kButtonExcludeKids
[
]
=
{
eHTMLTag_a
eHTMLTag_fieldset
eHTMLTag_form
eHTMLTag_iframe
eHTMLTag_input
eHTMLTag_select
eHTMLTag_textarea
}
;
uint32_t
j
;
for
(
j
=
0
;
j
<
ArrayLength
(
kButtonExcludeKids
)
;
+
+
j
)
{
if
(
kButtonExcludeKids
[
j
]
=
=
aChildTagId
)
{
return
false
;
}
}
}
if
(
aChildTagId
=
=
eHTMLTag_bgsound
)
{
return
false
;
}
if
(
aChildTagId
=
=
eHTMLTag_userdefined
)
{
return
true
;
}
const
ElementInfo
&
parent
=
kElements
[
aParentTagId
-
1
]
;
if
(
aParentTagId
=
=
aChildTagId
)
{
return
parent
.
mCanContainSelf
;
}
const
ElementInfo
&
child
=
kElements
[
aChildTagId
-
1
]
;
return
!
!
(
parent
.
mCanContainGroups
&
child
.
mGroup
)
;
}
bool
HTMLEditUtils
:
:
ContentIsInert
(
const
nsIContent
&
aContent
)
{
for
(
nsIContent
*
content
:
aContent
.
InclusiveFlatTreeAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
)
{
return
frame
-
>
StyleUI
(
)
-
>
IsInert
(
)
;
}
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
if
(
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
INERT
)
)
{
return
true
;
}
}
return
false
;
}
bool
HTMLEditUtils
:
:
IsContainerNode
(
nsHTMLTag
aTagId
)
{
NS_ASSERTION
(
aTagId
>
eHTMLTag_unknown
&
&
aTagId
<
=
eHTMLTag_userdefined
"
aTagId
out
of
range
!
"
)
;
return
kElements
[
aTagId
-
1
]
.
mIsContainer
;
}
bool
HTMLEditUtils
:
:
IsNonListSingleLineContainer
(
const
nsINode
&
aNode
)
{
return
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
address
nsGkAtoms
:
:
div
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
nsGkAtoms
:
:
listing
nsGkAtoms
:
:
p
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
xmp
)
;
}
bool
HTMLEditUtils
:
:
IsSingleLineContainer
(
const
nsINode
&
aNode
)
{
return
IsNonListSingleLineContainer
(
aNode
)
|
|
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
li
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditUtils
:
:
GetPreviousContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetPreviousContent
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
if
(
aPoint
.
IsStartOfContainer
(
)
|
|
aPoint
.
IsInTextNode
(
)
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
aPoint
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
aPoint
.
GetContainer
(
)
aOptions
aAncestorLimiter
)
;
}
if
(
aPoint
.
GetChild
(
)
)
{
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
aPoint
.
GetChild
(
)
aOptions
aAncestorLimiter
)
;
}
nsIContent
*
lastLeafContent
=
HTMLEditUtils
:
:
GetLastLeafContent
(
*
aPoint
.
GetContainer
(
)
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
)
;
if
(
!
lastLeafContent
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
lastLeafContent
aOptions
)
)
{
return
lastLeafContent
;
}
return
HTMLEditUtils
:
:
GetPreviousContent
(
*
lastLeafContent
aOptions
aAncestorLimiter
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditUtils
:
:
GetNextContent
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
NS_WARNING_ASSERTION
(
!
aPoint
.
IsInDataNode
(
)
|
|
aPoint
.
IsInTextNode
(
)
"
GetNextContent
(
)
doesn
'
t
assume
that
the
start
point
is
a
"
"
data
node
except
text
node
"
)
;
auto
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
if
(
point
.
IsInTextNode
(
)
)
{
point
.
SetAfter
(
point
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
point
.
IsSet
(
)
)
)
{
return
nullptr
;
}
}
if
(
point
.
GetChild
(
)
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
point
.
GetChild
(
)
)
)
{
return
point
.
GetChild
(
)
;
}
nsIContent
*
firstLeafContent
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
point
.
GetChild
(
)
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
)
;
if
(
!
firstLeafContent
)
{
return
point
.
GetChild
(
)
;
}
if
(
aAncestorLimiter
&
&
(
firstLeafContent
=
=
aAncestorLimiter
|
|
!
firstLeafContent
-
>
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
firstLeafContent
aOptions
)
)
{
return
firstLeafContent
;
}
return
HTMLEditUtils
:
:
GetNextContent
(
*
firstLeafContent
aOptions
aAncestorLimiter
)
;
}
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
point
.
IsInContentNode
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
point
.
template
ContainerAs
<
nsIContent
>
(
)
)
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetNextContent
(
*
point
.
GetContainer
(
)
aOptions
aAncestorLimiter
)
;
}
nsIContent
*
HTMLEditUtils
:
:
GetAdjacentLeafContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
&
aNode
!
=
aAncestorLimiter
)
;
MOZ_ASSERT_IF
(
aAncestorLimiter
aAncestorLimiter
-
>
IsInclusiveDescendantOf
(
aAncestorLimiter
)
)
;
const
nsINode
*
node
=
&
aNode
;
for
(
;
;
)
{
nsIContent
*
sibling
=
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Forward
?
node
-
>
GetNextSibling
(
)
:
node
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
if
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
sibling
)
)
{
return
sibling
;
}
const
LeafNodeTypes
leafNodeTypes
=
{
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
?
LeafNodeType
:
:
LeafNodeOrChildBlock
:
LeafNodeType
:
:
OnlyLeafNode
}
;
nsIContent
*
leafContent
=
aWalkTreeDirection
=
=
WalkTreeDirection
:
:
Forward
?
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
sibling
leafNodeTypes
)
:
HTMLEditUtils
:
:
GetLastLeafContent
(
*
sibling
leafNodeTypes
)
;
return
leafContent
?
leafContent
:
sibling
;
}
nsIContent
*
parent
=
node
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
parent
=
=
aAncestorLimiter
|
|
(
aOptions
.
contains
(
WalkTreeOption
:
:
StopAtBlockBoundary
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
parent
)
)
)
{
return
nullptr
;
}
node
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
What
part
of
for
(
;
;
)
do
you
not
understand
?
"
)
;
return
nullptr
;
}
nsIContent
*
HTMLEditUtils
:
:
GetAdjacentContent
(
const
nsINode
&
aNode
WalkTreeDirection
aWalkTreeDirection
const
WalkTreeOptions
&
aOptions
const
Element
*
aAncestorLimiter
)
{
if
(
&
aNode
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsIContent
*
leafContent
=
HTMLEditUtils
:
:
GetAdjacentLeafContent
(
aNode
aWalkTreeDirection
aOptions
aAncestorLimiter
)
;
if
(
!
leafContent
)
{
return
nullptr
;
}
if
(
!
HTMLEditUtils
:
:
IsContentIgnored
(
*
leafContent
aOptions
)
)
{
return
leafContent
;
}
return
HTMLEditUtils
:
:
GetAdjacentContent
(
*
leafContent
aWalkTreeDirection
aOptions
aAncestorLimiter
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
aContent
)
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
may
return
a
point
"
"
between
table
structure
elements
"
)
;
nsIContent
*
previousContent
=
aContent
.
GetPreviousSibling
(
)
;
if
(
!
previousContent
)
{
if
(
!
aContent
.
GetParentElement
(
)
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
inclusiveAncestor
=
&
aContent
;
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
previousContent
=
parentElement
-
>
GetPreviousSibling
(
)
;
if
(
!
previousContent
&
&
(
parentElement
=
=
aAncestorLimiter
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
parentElement
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
parentElement
aHowToTreatTableBoundary
)
)
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parentElement
)
)
{
inclusiveAncestor
=
parentElement
;
}
if
(
!
previousContent
)
{
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
previousContent
)
;
}
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
previousContent
aHowToTreatTableBoundary
)
)
{
return
inclusiveAncestor
=
=
&
aContent
?
EditorDOMPointType
(
inclusiveAncestor
)
:
EditorDOMPointType
(
inclusiveAncestor
0
)
;
}
break
;
}
if
(
!
previousContent
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
}
else
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
previousContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
previousContent
)
;
}
else
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
previousContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
&
aContent
)
;
}
nsIContent
*
leafContent
=
previousContent
;
if
(
previousContent
-
>
GetChildCount
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
previousContent
)
)
{
for
(
nsIContent
*
maybeLeafContent
=
previousContent
-
>
GetLastChild
(
)
;
maybeLeafContent
;
maybeLeafContent
=
maybeLeafContent
-
>
GetLastChild
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
maybeLeafContent
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
maybeLeafContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
*
maybeLeafContent
)
;
}
leafContent
=
maybeLeafContent
;
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
)
{
break
;
}
}
}
if
(
leafContent
-
>
IsText
(
)
)
{
Text
*
textNode
=
leafContent
-
>
AsText
(
)
;
if
(
aInvisibleWhiteSpaces
=
=
InvisibleWhiteSpaces
:
:
Preserve
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
textNode
)
;
}
return
WSRunScanner
:
:
GetAfterLastVisiblePoint
<
EditorDOMPointType
>
(
*
textNode
aAncestorLimiter
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
?
EditorDOMPointType
:
:
AtEndOf
(
*
leafContent
)
:
EditorDOMPointType
:
:
After
(
*
leafContent
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
HTMLEditUtils
:
:
GetNextEditablePoint
(
nsIContent
&
aContent
const
Element
*
aAncestorLimiter
InvisibleWhiteSpaces
aInvisibleWhiteSpaces
TableBoundary
aHowToTreatTableBoundary
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
)
;
NS_ASSERTION
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
&
aContent
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
aContent
)
"
HTMLEditUtils
:
:
GetPreviousEditablePoint
(
)
may
return
a
point
"
"
between
table
structure
elements
"
)
;
nsIContent
*
nextContent
=
aContent
.
GetNextSibling
(
)
;
if
(
!
nextContent
)
{
if
(
!
aContent
.
GetParentElement
(
)
)
{
return
EditorDOMPointType
(
)
;
}
nsIContent
*
inclusiveAncestor
=
&
aContent
;
for
(
Element
*
parentElement
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parentElement
)
)
{
inclusiveAncestor
=
parentElement
;
}
nextContent
=
parentElement
-
>
GetNextSibling
(
)
;
if
(
!
nextContent
&
&
(
parentElement
=
=
aAncestorLimiter
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
parentElement
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
parentElement
aHowToTreatTableBoundary
)
)
)
{
return
EditorDOMPointType
(
inclusiveAncestor
)
;
}
if
(
!
HTMLEditUtils
:
:
IsAnyTableElement
(
parentElement
)
|
|
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
parentElement
)
)
{
inclusiveAncestor
=
parentElement
;
}
if
(
!
nextContent
)
{
continue
;
}
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
return
EditorDOMPointType
:
:
After
(
*
parentElement
)
;
}
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
nextContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
*
inclusiveAncestor
)
;
}
break
;
}
if
(
!
nextContent
)
{
return
EditorDOMPointType
:
:
After
(
*
inclusiveAncestor
)
;
}
}
else
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
nextContent
)
)
{
return
EditorDOMPointType
:
:
After
(
aContent
)
;
}
else
if
(
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
nextContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
:
:
After
(
aContent
)
;
}
nsIContent
*
leafContent
=
nextContent
;
if
(
nextContent
-
>
GetChildCount
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
nextContent
)
)
{
for
(
nsIContent
*
maybeLeafContent
=
nextContent
-
>
GetFirstChild
(
)
;
maybeLeafContent
;
maybeLeafContent
=
maybeLeafContent
-
>
GetFirstChild
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
maybeLeafContent
)
|
|
!
HTMLEditUtils
:
:
CanCrossContentBoundary
(
*
maybeLeafContent
aHowToTreatTableBoundary
)
)
{
return
EditorDOMPointType
(
maybeLeafContent
)
;
}
leafContent
=
maybeLeafContent
;
if
(
!
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
)
{
break
;
}
}
}
if
(
leafContent
-
>
IsText
(
)
)
{
Text
*
textNode
=
leafContent
-
>
AsText
(
)
;
if
(
aInvisibleWhiteSpaces
=
=
InvisibleWhiteSpaces
:
:
Preserve
)
{
return
EditorDOMPointType
(
textNode
0
)
;
}
return
WSRunScanner
:
:
GetFirstVisiblePoint
<
EditorDOMPointType
>
(
*
textNode
aAncestorLimiter
)
;
}
return
HTMLEditUtils
:
:
IsContainerNode
(
*
leafContent
)
?
EditorDOMPointType
(
leafContent
0
)
:
EditorDOMPointType
(
leafContent
)
;
}
Element
*
HTMLEditUtils
:
:
GetAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
)
;
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
const
Element
*
theBodyElement
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
;
const
Element
*
theDocumentElement
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
Element
*
lastAncestorElement
=
nullptr
;
const
bool
editableElementOnly
=
aAncestorTypes
.
contains
(
AncestorType
:
:
EditableElement
)
;
const
bool
lookingForClosestBlockElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
;
const
bool
lookingForMostDistantInlineElementInBlock
=
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
;
const
bool
ignoreHRElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
IgnoreHRElement
)
;
const
bool
lookingForButtonElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
;
auto
IsSearchingElementType
=
[
&
]
(
const
nsIContent
&
aContent
)
-
>
bool
{
if
(
!
aContent
.
IsElement
(
)
|
|
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
false
;
}
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorType
:
:
HTML
)
)
{
return
false
;
}
return
(
lookingForClosestBlockElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
)
|
|
(
lookingForMostDistantInlineElementInBlock
&
&
HTMLEditUtils
:
:
IsInlineElement
(
aContent
)
)
|
|
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
;
}
;
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
element
EditorType
:
:
HTML
)
)
{
return
lastAncestorElement
&
&
IsSearchingElementType
(
*
lastAncestorElement
)
?
lastAncestorElement
:
nullptr
;
}
if
(
ignoreHRElement
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
{
if
(
element
=
=
aAncestorLimiter
)
{
break
;
}
continue
;
}
if
(
lookingForButtonElement
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
{
return
element
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
)
)
{
if
(
lookingForClosestBlockElement
)
{
return
element
;
}
MOZ_ASSERT_IF
(
lastAncestorElement
HTMLEditUtils
:
:
IsInlineElement
(
*
lastAncestorElement
)
)
;
return
lastAncestorElement
;
}
if
(
element
=
=
aAncestorLimiter
|
|
element
=
=
theBodyElement
|
|
element
=
=
theDocumentElement
)
{
break
;
}
lastAncestorElement
=
element
;
}
return
lastAncestorElement
&
&
IsSearchingElementType
(
*
lastAncestorElement
)
?
lastAncestorElement
:
nullptr
;
}
Element
*
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
const
nsIContent
&
aContent
const
AncestorTypes
&
aAncestorTypes
const
Element
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
|
|
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
)
;
const
Element
*
theBodyElement
=
aContent
.
OwnerDoc
(
)
-
>
GetBody
(
)
;
const
Element
*
theDocumentElement
=
aContent
.
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
const
bool
editableElementOnly
=
aAncestorTypes
.
contains
(
AncestorType
:
:
EditableElement
)
;
const
bool
lookingForClosestBlockElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ClosestBlockElement
)
;
const
bool
lookingForMostDistantInlineElementInBlock
=
aAncestorTypes
.
contains
(
AncestorType
:
:
MostDistantInlineElementInBlock
)
;
const
bool
lookingForButtonElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
ButtonElement
)
;
const
bool
ignoreHRElement
=
aAncestorTypes
.
contains
(
AncestorType
:
:
IgnoreHRElement
)
;
auto
IsSearchingElementType
=
[
&
]
(
const
nsIContent
&
aContent
)
-
>
bool
{
if
(
!
aContent
.
IsElement
(
)
|
|
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
false
;
}
if
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorType
:
:
HTML
)
)
{
return
false
;
}
return
(
lookingForClosestBlockElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
)
|
|
(
lookingForMostDistantInlineElementInBlock
&
&
HTMLEditUtils
:
:
IsInlineElement
(
aContent
)
)
|
|
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
;
}
;
if
(
editableElementOnly
&
&
(
&
aContent
=
=
theBodyElement
|
|
&
aContent
=
=
theDocumentElement
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
lookingForButtonElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
button
)
)
{
return
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
;
}
if
(
(
lookingForClosestBlockElement
|
|
lookingForMostDistantInlineElementInBlock
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
&
&
!
(
ignoreHRElement
&
&
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
!
aContent
.
GetParent
(
)
|
|
(
editableElementOnly
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
aContent
.
GetParent
(
)
EditorType
:
:
HTML
)
)
|
|
(
!
lookingForClosestBlockElement
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aContent
.
GetParent
(
)
)
&
&
!
(
ignoreHRElement
&
&
aContent
.
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
)
)
)
{
return
IsSearchingElementType
(
aContent
)
?
const_cast
<
Element
*
>
(
aContent
.
AsElement
(
)
)
:
nullptr
;
}
if
(
&
aContent
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
return
HTMLEditUtils
:
:
GetAncestorElement
(
aContent
aAncestorTypes
aAncestorLimiter
)
;
}
Element
*
HTMLEditUtils
:
:
GetClosestAncestorAnyListElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
AncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
Element
*
HTMLEditUtils
:
:
GetClosestInclusiveAncestorAnyListElement
(
const
nsIContent
&
aContent
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
element
)
)
{
return
element
;
}
}
return
nullptr
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForInsert
(
const
nsAtom
&
aTagName
)
{
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ul
)
{
return
EditAction
:
:
eInsertUnorderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ol
)
{
return
EditAction
:
:
eInsertOrderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
hr
)
{
return
EditAction
:
:
eInsertHorizontalRuleElement
;
}
return
EditAction
:
:
eInsertNode
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForRemoveList
(
const
nsAtom
&
aTagName
)
{
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ul
)
{
return
EditAction
:
:
eRemoveUnorderedListElement
;
}
if
(
&
aTagName
=
=
nsGkAtoms
:
:
ol
)
{
return
EditAction
:
:
eRemoveOrderedListElement
;
}
return
EditAction
:
:
eRemoveListElement
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForInsert
(
const
Element
&
aElement
)
{
return
GetEditActionForInsert
(
*
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForFormatText
(
const
nsAtom
&
aProperty
const
nsAtom
*
aAttribute
bool
aToSetStyle
)
{
if
(
&
aProperty
=
=
nsGkAtoms
:
:
b
)
{
return
aToSetStyle
?
EditAction
:
:
eSetFontWeightProperty
:
EditAction
:
:
eRemoveFontWeightProperty
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
i
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextStyleProperty
:
EditAction
:
:
eRemoveTextStyleProperty
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
u
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextDecorationPropertyUnderline
:
EditAction
:
:
eRemoveTextDecorationPropertyUnderline
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
strike
)
{
return
aToSetStyle
?
EditAction
:
:
eSetTextDecorationPropertyLineThrough
:
EditAction
:
:
eRemoveTextDecorationPropertyLineThrough
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sup
)
{
return
aToSetStyle
?
EditAction
:
:
eSetVerticalAlignPropertySuper
:
EditAction
:
:
eRemoveVerticalAlignPropertySuper
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
sub
)
{
return
aToSetStyle
?
EditAction
:
:
eSetVerticalAlignPropertySub
:
EditAction
:
:
eRemoveVerticalAlignPropertySub
;
}
if
(
&
aProperty
=
=
nsGkAtoms
:
:
font
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
face
)
{
return
aToSetStyle
?
EditAction
:
:
eSetFontFamilyProperty
:
EditAction
:
:
eRemoveFontFamilyProperty
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
color
)
{
return
aToSetStyle
?
EditAction
:
:
eSetColorProperty
:
EditAction
:
:
eRemoveColorProperty
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
)
{
return
aToSetStyle
?
EditAction
:
:
eSetBackgroundColorPropertyInline
:
EditAction
:
:
eRemoveBackgroundColorPropertyInline
;
}
}
return
aToSetStyle
?
EditAction
:
:
eSetInlineStyleProperty
:
EditAction
:
:
eRemoveInlineStyleProperty
;
}
EditAction
HTMLEditUtils
:
:
GetEditActionForAlignment
(
const
nsAString
&
aAlignType
)
{
if
(
aAlignType
.
EqualsLiteral
(
"
left
"
)
)
{
return
EditAction
:
:
eAlignLeft
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
right
"
)
)
{
return
EditAction
:
:
eAlignRight
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
center
"
)
)
{
return
EditAction
:
:
eAlignCenter
;
}
if
(
aAlignType
.
EqualsLiteral
(
"
justify
"
)
)
{
return
EditAction
:
:
eJustify
;
}
return
EditAction
:
:
eSetAlignment
;
}
template
<
typename
EditorDOMPointType
>
nsIContent
*
HTMLEditUtils
:
:
GetContentToPreserveInlineStyles
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
aPoint
.
IsInContentNode
(
)
)
)
{
return
nullptr
;
}
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
auto
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
point
.
IsSet
(
)
;
)
{
WSScanResult
nextVisibleThing
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
&
aEditingHost
point
)
;
if
(
nextVisibleThing
.
InVisibleOrCollapsibleCharacters
(
)
)
{
return
nextVisibleThing
.
TextPtr
(
)
;
}
if
(
nextVisibleThing
.
ReachedSpecialContent
(
)
&
&
nextVisibleThing
.
IsContentEditable
(
)
&
&
nextVisibleThing
.
GetContent
(
)
-
>
IsElement
(
)
&
&
!
nextVisibleThing
.
GetContent
(
)
-
>
HasChildNodes
(
)
&
&
HTMLEditUtils
:
:
IsContainerNode
(
*
nextVisibleThing
.
ElementPtr
(
)
)
)
{
point
.
SetAfter
(
nextVisibleThing
.
ElementPtr
(
)
)
;
continue
;
}
break
;
}
return
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
EditorDOMPointType
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
const
nsIContent
&
aContentToInsert
const
EditorDOMPointTypeInput
&
aPointToInsert
const
Element
&
aEditingHost
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
auto
pointToInsert
=
aPointToInsert
.
template
GetNonAnonymousSubtreePoint
<
EditorDOMPointType
>
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsert
.
GetContainer
(
)
-
>
IsInclusiveDescendantOf
(
&
aEditingHost
)
)
)
)
{
return
EditorDOMPointType
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aContentToInsert
)
)
{
return
pointToInsert
;
}
WSRunScanner
wsScannerForPointToInsert
(
const_cast
<
Element
*
>
(
&
aEditingHost
)
pointToInsert
)
;
WSScanResult
forwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
!
forwardScanFromPointToInsertResult
.
GetContent
(
)
|
|
!
forwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
)
{
return
pointToInsert
;
}
WSScanResult
backwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
!
backwardScanFromPointToInsertResult
.
GetContent
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
pointToInsert
;
}
return
forwardScanFromPointToInsertResult
.
template
PointAfterContent
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
EditorDOMPointType
HTMLEditUtils
:
:
GetBetterCaretPositionToInsertText
(
const
EditorDOMPointTypeInput
&
aPoint
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aPoint
.
GetContainer
(
)
-
>
IsInclusiveFlatTreeDescendantOf
(
&
aEditingHost
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
aPoint
.
template
To
<
EditorDOMPointType
>
(
)
;
}
if
(
!
aPoint
.
IsEndOfContainer
(
)
&
&
aPoint
.
GetChild
(
)
&
&
aPoint
.
GetChild
(
)
-
>
IsText
(
)
)
{
return
EditorDOMPointType
(
aPoint
.
GetChild
(
)
0u
)
;
}
if
(
aPoint
.
IsEndOfContainer
(
)
)
{
WSRunScanner
scanner
(
&
aEditingHost
aPoint
)
;
WSScanResult
previousThing
=
scanner
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
if
(
previousThing
.
InVisibleOrCollapsibleCharacters
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
previousThing
.
TextPtr
(
)
)
;
}
}
if
(
HTMLEditUtils
:
:
CanNodeContain
(
*
aPoint
.
GetContainer
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
return
aPoint
.
template
To
<
EditorDOMPointType
>
(
)
;
}
if
(
MOZ_UNLIKELY
(
aPoint
.
GetContainer
(
)
=
=
&
aEditingHost
|
|
!
aPoint
.
template
GetContainerParentAs
<
nsIContent
>
(
)
|
|
!
HTMLEditUtils
:
:
CanNodeContain
(
*
aPoint
.
template
ContainerParentAs
<
nsIContent
>
(
)
*
nsGkAtoms
:
:
textTagName
)
)
)
{
return
EditorDOMPointType
(
)
;
}
return
aPoint
.
ParentPoint
(
)
.
template
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
typename
EditorDOMPointTypeInput
>
Result
<
EditorDOMPointType
nsresult
>
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
const
Element
&
aElement
const
EditorDOMPointTypeInput
&
aCurrentPoint
)
{
MOZ_ASSERT
(
aCurrentPoint
.
IsSet
(
)
)
;
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
const_cast
<
Element
*
>
(
&
aElement
)
aCurrentPoint
.
ToRawRangeBoundary
(
)
aCurrentPoint
.
ToRawRangeBoundary
(
)
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUtils
:
:
CompareNodeToRange
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
nodeBefore
&
&
nodeAfter
)
{
return
EditorDOMPointType
(
)
;
}
if
(
nodeBefore
)
{
const
nsIContent
*
lastEditableContent
=
HTMLEditUtils
:
:
GetLastChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
lastEditableContent
)
{
lastEditableContent
=
&
aElement
;
}
if
(
lastEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
lastEditableContent
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
*
lastEditableContent
)
;
}
MOZ_ASSERT
(
lastEditableContent
-
>
GetParentNode
(
)
)
;
return
EditorDOMPointType
:
:
After
(
*
lastEditableContent
)
;
}
const
nsIContent
*
firstEditableContent
=
HTMLEditUtils
:
:
GetFirstChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
!
firstEditableContent
)
{
firstEditableContent
=
&
aElement
;
}
if
(
firstEditableContent
-
>
IsText
(
)
|
|
HTMLEditUtils
:
:
IsContainerNode
(
*
firstEditableContent
)
)
{
MOZ_ASSERT
(
firstEditableContent
-
>
GetParentNode
(
)
)
;
return
EditorDOMPointType
(
firstEditableContent
)
;
}
return
EditorDOMPointType
(
firstEditableContent
0u
)
;
}
bool
HTMLEditUtils
:
:
IsInlineStyleSetByElement
(
const
nsIContent
&
aContent
const
EditorInlineStyle
&
aStyle
const
nsAString
*
aValue
nsAString
*
aOutValue
)
{
for
(
Element
*
element
:
aContent
.
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
aStyle
.
mHTMLProperty
!
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
if
(
!
aStyle
.
mAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
aStyle
.
mAttribute
value
)
;
if
(
aOutValue
)
{
*
aOutValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
return
false
;
}
}
return
false
;
}
size_t
HTMLEditUtils
:
:
CollectChildren
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
size_t
aIndexToInsertChildren
const
CollectChildrenOptions
&
aOptions
)
{
size_t
numberOfFoundChildren
=
0
;
for
(
nsIContent
*
content
=
GetFirstChild
(
aNode
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
(
aOptions
.
contains
(
CollectChildrenOption
:
:
CollectListChildren
)
&
&
(
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
)
|
|
(
aOptions
.
contains
(
CollectChildrenOption
:
:
CollectTableChildren
)
&
&
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
)
)
{
numberOfFoundChildren
+
=
HTMLEditUtils
:
:
CollectChildren
(
*
content
aOutArrayOfContents
aIndexToInsertChildren
+
numberOfFoundChildren
aOptions
)
;
continue
;
}
if
(
aOptions
.
contains
(
CollectChildrenOption
:
:
IgnoreNonEditableChildren
)
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
continue
;
}
if
(
aOptions
.
contains
(
CollectChildrenOption
:
:
IgnoreInvisibleTextNodes
)
&
&
content
-
>
IsText
(
)
&
&
!
HTMLEditUtils
:
:
IsVisibleTextNode
(
*
content
-
>
AsText
(
)
)
)
{
continue
;
}
aOutArrayOfContents
.
InsertElementAt
(
aIndexToInsertChildren
+
numberOfFoundChildren
+
+
*
content
)
;
}
return
numberOfFoundChildren
;
}
size_t
HTMLEditUtils
:
:
CollectEmptyInlineContainerDescendants
(
const
nsINode
&
aNode
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
const
EmptyCheckOptions
&
aOptions
)
{
size_t
numberOfFoundElements
=
0
;
for
(
Element
*
element
=
aNode
.
GetFirstElementChild
(
)
;
element
;
)
{
if
(
HTMLEditUtils
:
:
IsEmptyInlineContainer
(
*
element
aOptions
)
)
{
aOutArrayOfContents
.
AppendElement
(
*
element
)
;
numberOfFoundElements
+
+
;
nsIContent
*
nextContent
=
element
-
>
GetNextNonChildNode
(
&
aNode
)
;
element
=
nullptr
;
for
(
;
nextContent
;
nextContent
=
nextContent
-
>
GetNextNode
(
&
aNode
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
element
=
nextContent
-
>
AsElement
(
)
;
break
;
}
}
continue
;
}
nsIContent
*
nextContent
=
element
-
>
GetNextNode
(
&
aNode
)
;
element
=
nullptr
;
for
(
;
nextContent
;
nextContent
=
nextContent
-
>
GetNextNode
(
&
aNode
)
)
{
if
(
nextContent
-
>
IsElement
(
)
)
{
element
=
nextContent
-
>
AsElement
(
)
;
break
;
}
}
}
return
numberOfFoundElements
;
}
bool
HTMLEditUtils
:
:
ElementHasAttributeExcept
(
const
Element
&
aElement
const
nsAtom
&
aAttribute1
const
nsAtom
&
aAttribute2
const
nsAtom
&
aAttribute3
)
{
for
(
auto
i
:
IntegerRange
<
uint32_t
>
(
aElement
.
GetAttrCount
(
)
)
)
{
const
nsAttrName
*
name
=
aElement
.
GetAttrNameAt
(
i
)
;
if
(
!
name
-
>
NamespaceEquals
(
kNameSpaceID_None
)
)
{
return
true
;
}
if
(
name
-
>
LocalName
(
)
=
=
&
aAttribute1
|
|
name
-
>
LocalName
(
)
=
=
&
aAttribute2
|
|
name
-
>
LocalName
(
)
=
=
&
aAttribute3
)
{
continue
;
}
if
(
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
style
|
|
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
_class
|
|
name
-
>
LocalName
(
)
=
=
nsGkAtoms
:
:
id
)
{
if
(
aElement
.
HasNonEmptyAttr
(
name
-
>
LocalName
(
)
)
)
{
return
true
;
}
continue
;
}
nsAutoString
attrString
;
name
-
>
LocalName
(
)
-
>
ToString
(
attrString
)
;
if
(
!
StringBeginsWith
(
attrString
u
"
_moz
"
_ns
)
)
{
return
true
;
}
}
return
false
;
}
bool
HTMLEditUtils
:
:
GetNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
{
nsAttrValue
value
;
if
(
!
value
.
ParseColor
(
aColorValue
)
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
nscolor
color
=
NS_RGB
(
0
0
0
)
;
MOZ_ALWAYS_TRUE
(
value
.
GetColorValue
(
color
)
)
;
aNormalizedValue
=
NS_ConvertASCIItoUTF16
(
nsPrintfCString
(
"
#
%
02x
%
02x
%
02x
"
NS_GET_R
(
color
)
NS_GET_G
(
color
)
NS_GET_B
(
color
)
)
)
;
return
true
;
}
bool
HTMLEditUtils
:
:
IsSameHTMLColorValue
(
const
nsAString
&
aColorA
const
nsAString
&
aColorB
TransparentKeyword
aTransparentKeyword
)
{
if
(
aTransparentKeyword
=
=
TransparentKeyword
:
:
Allowed
)
{
const
bool
isATransparent
=
aColorA
.
LowerCaseEqualsLiteral
(
"
transparent
"
)
;
const
bool
isBTransparent
=
aColorB
.
LowerCaseEqualsLiteral
(
"
transparent
"
)
;
if
(
isATransparent
|
|
isBTransparent
)
{
return
isATransparent
&
&
isBTransparent
;
}
}
nsAttrValue
valueA
valueB
;
if
(
!
valueA
.
ParseColor
(
aColorA
)
|
|
!
valueB
.
ParseColor
(
aColorB
)
)
{
return
false
;
}
nscolor
colorA
=
NS_RGB
(
0
0
0
)
colorB
=
NS_RGB
(
0
0
0
)
;
MOZ_ALWAYS_TRUE
(
valueA
.
GetColorValue
(
colorA
)
)
;
MOZ_ALWAYS_TRUE
(
valueB
.
GetColorValue
(
colorB
)
)
;
return
colorA
=
=
colorB
;
}
bool
HTMLEditUtils
:
:
MaybeCSSSpecificColorValue
(
const
nsAString
&
aColorValue
)
{
if
(
aColorValue
.
IsEmpty
(
)
|
|
aColorValue
.
First
(
)
=
=
'
#
'
)
{
return
false
;
}
nsAutoString
colorValue
(
aColorValue
)
;
colorValue
.
CompressWhitespace
(
true
true
)
;
if
(
colorValue
.
LowerCaseEqualsASCII
(
"
transparent
"
)
)
{
return
true
;
}
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
colorValue
.
IsEmpty
(
)
|
|
colorValue
.
First
(
)
=
=
'
#
'
)
{
return
false
;
}
const
NS_ConvertUTF16toUTF8
colorU8
(
colorValue
)
;
if
(
Servo_ColorNameToRgb
(
&
colorU8
&
color
)
)
{
return
false
;
}
if
(
colorValue
.
LowerCaseEqualsASCII
(
"
initial
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
inherit
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
unset
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
revert
"
)
|
|
colorValue
.
LowerCaseEqualsASCII
(
"
currentcolor
"
)
)
{
return
true
;
}
return
ServoCSSParser
:
:
IsValidCSSColor
(
colorU8
)
;
}
static
bool
ComputeColor
(
const
nsAString
&
aColorValue
nscolor
*
aColor
bool
*
aIsCurrentColor
)
{
return
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
NS_ConvertUTF16toUTF8
(
aColorValue
)
aColor
aIsCurrentColor
)
;
}
static
bool
ComputeColor
(
const
nsACString
&
aColorValue
nscolor
*
aColor
bool
*
aIsCurrentColor
)
{
return
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
aColorValue
aColor
aIsCurrentColor
)
;
}
bool
HTMLEditUtils
:
:
CanConvertToHTMLColorValue
(
const
nsAString
&
aColorValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
return
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
&
&
!
isCurrentColor
&
&
NS_GET_A
(
color
)
=
=
0xFF
;
}
bool
HTMLEditUtils
:
:
ConvertToNormalizedHTMLColorValue
(
const
nsAString
&
aColorValue
nsAString
&
aNormalizedValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
|
|
isCurrentColor
|
|
NS_GET_A
(
color
)
!
=
0xFF
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
aNormalizedValue
.
Truncate
(
)
;
aNormalizedValue
.
AppendPrintf
(
"
#
%
02x
%
02x
%
02x
"
NS_GET_R
(
color
)
NS_GET_G
(
color
)
NS_GET_B
(
color
)
)
;
return
true
;
}
bool
HTMLEditUtils
:
:
GetNormalizedCSSColorValue
(
const
nsAString
&
aColorValue
ZeroAlphaColor
aZeroAlphaColor
nsAString
&
aNormalizedValue
)
{
bool
isCurrentColor
=
false
;
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorValue
&
color
&
isCurrentColor
)
)
{
aNormalizedValue
=
aColorValue
;
return
false
;
}
if
(
isCurrentColor
)
{
aNormalizedValue
=
aColorValue
;
return
true
;
}
if
(
aZeroAlphaColor
=
=
ZeroAlphaColor
:
:
TransparentKeyword
&
&
NS_GET_A
(
color
)
=
=
0
)
{
aNormalizedValue
.
AssignLiteral
(
"
transparent
"
)
;
return
true
;
}
aNormalizedValue
.
Truncate
(
)
;
nsStyleUtil
:
:
GetSerializedColorValue
(
color
aNormalizedValue
)
;
return
true
;
}
template
<
typename
CharType
>
bool
HTMLEditUtils
:
:
IsSameCSSColorValue
(
const
nsTSubstring
<
CharType
>
&
aColorA
const
nsTSubstring
<
CharType
>
&
aColorB
)
{
bool
isACurrentColor
=
false
;
nscolor
colorA
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorA
&
colorA
&
isACurrentColor
)
)
{
return
false
;
}
bool
isBCurrentColor
=
false
;
nscolor
colorB
=
NS_RGB
(
0
0
0
)
;
if
(
!
ComputeColor
(
aColorB
&
colorB
&
isBCurrentColor
)
)
{
return
false
;
}
if
(
isACurrentColor
|
|
isBCurrentColor
)
{
return
isACurrentColor
&
&
isBCurrentColor
;
}
return
colorA
=
=
colorB
;
}
SelectedTableCellScanner
:
:
SelectedTableCellScanner
(
const
AutoRangeArray
&
aRanges
)
{
if
(
aRanges
.
Ranges
(
)
.
IsEmpty
(
)
)
{
return
;
}
Element
*
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
aRanges
.
FirstRangeRef
(
)
)
;
if
(
!
firstSelectedCellElement
)
{
return
;
}
mSelectedCellElements
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
mSelectedCellElements
.
AppendElement
(
*
firstSelectedCellElement
)
;
for
(
uint32_t
i
=
1
;
i
<
aRanges
.
Ranges
(
)
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
aRanges
.
Ranges
(
)
[
i
]
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
continue
;
}
if
(
Element
*
selectedCellElement
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
)
{
mSelectedCellElements
.
AppendElement
(
*
selectedCellElement
)
;
}
}
}
}
