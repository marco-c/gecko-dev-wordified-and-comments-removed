#
include
"
HTMLEditor
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
AutoRangeArray
.
h
"
#
include
"
CSSEditUtils
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
using
EditorType
=
EditorUtils
:
:
EditorType
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
ListElementSelectionState
:
:
ListElementSelectionState
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
Element
*
editingHostOrRoot
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
!
editingHostOrRoot
)
{
editingHostOrRoot
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
!
editingHostOrRoot
)
{
return
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedSelectionRanges
(
aHTMLEditor
.
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrChangeList
*
editingHostOrRoot
)
;
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
aHTMLEditor
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
aRv
=
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
return
;
}
}
for
(
const
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
mIsOtherContentSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
mIsULElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
mIsOLElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
li
)
)
{
if
(
dom
:
:
Element
*
parent
=
content
-
>
GetParentElement
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ul
)
)
{
mIsULElementSelected
=
true
;
}
else
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
{
mIsOLElementSelected
=
true
;
}
}
}
else
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
mIsDLElementSelected
=
true
;
}
else
{
mIsOtherContentSelected
=
true
;
}
if
(
mIsULElementSelected
&
&
mIsOLElementSelected
&
&
mIsDLElementSelected
&
&
mIsOtherContentSelected
)
{
break
;
}
}
}
ListItemElementSelectionState
:
:
ListItemElementSelectionState
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
Element
*
editingHostOrRoot
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
!
editingHostOrRoot
)
{
editingHostOrRoot
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
!
editingHostOrRoot
)
{
return
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
{
AutoRangeArray
extendedSelectionRanges
(
aHTMLEditor
.
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrChangeList
*
editingHostOrRoot
)
;
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
aHTMLEditor
arrayOfContents
EditSubAction
:
:
eCreateOrChangeList
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
No
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrChangeList
CollectNonEditableNodes
:
:
No
)
failed
"
)
;
aRv
=
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
return
;
}
}
for
(
const
auto
&
content
:
arrayOfContents
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
mIsOtherElementSelected
=
true
;
}
else
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
li
)
)
{
mIsLIElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dt
)
)
{
mIsDTElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dd
)
)
{
mIsDDElementSelected
=
true
;
}
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dl
)
)
{
if
(
mIsDTElementSelected
&
&
mIsDDElementSelected
)
{
continue
;
}
DefinitionListItemScanner
scanner
(
*
content
-
>
AsElement
(
)
)
;
mIsDTElementSelected
|
=
scanner
.
DTElementFound
(
)
;
mIsDDElementSelected
|
=
scanner
.
DDElementFound
(
)
;
}
else
{
mIsOtherElementSelected
=
true
;
}
if
(
mIsLIElementSelected
&
&
mIsDTElementSelected
&
&
mIsDDElementSelected
&
&
mIsOtherElementSelected
)
{
break
;
}
}
}
AlignStateAtSelection
:
:
AlignStateAtSelection
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aHTMLEditor
.
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
;
}
if
(
NS_WARN_IF
(
!
aHTMLEditor
.
GetRoot
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
OwningNonNull
<
dom
:
:
Element
>
bodyOrDocumentElement
=
*
aHTMLEditor
.
GetRoot
(
)
;
EditorRawDOMPoint
atBodyOrDocumentElement
(
bodyOrDocumentElement
)
;
const
nsRange
*
firstRange
=
aHTMLEditor
.
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
mFoundSelectionRanges
=
!
!
firstRange
;
if
(
!
mFoundSelectionRanges
)
{
NS_WARNING
(
"
There
was
no
selection
range
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
MOZ_ASSERT
(
atStartOfSelection
.
IsSetAndValid
(
)
)
;
nsIContent
*
editTargetContent
=
nullptr
;
if
(
aHTMLEditor
.
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
atStartOfSelection
.
IsInTextNode
(
)
)
{
editTargetContent
=
atStartOfSelection
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
editTargetContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
else
if
(
atStartOfSelection
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
html
)
&
&
atBodyOrDocumentElement
.
IsSet
(
)
&
&
atStartOfSelection
.
Offset
(
)
=
=
atBodyOrDocumentElement
.
Offset
(
)
)
{
editTargetContent
=
HTMLEditUtils
:
:
GetNextContent
(
atStartOfSelection
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
aHTMLEditor
.
ComputeEditingHost
(
)
)
;
if
(
NS_WARN_IF
(
!
editTargetContent
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
else
{
Element
*
editingHostOrRoot
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
!
editingHostOrRoot
)
{
editingHostOrRoot
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
!
editingHostOrRoot
)
{
return
;
}
}
AutoRangeArray
extendedSelectionRanges
(
aHTMLEditor
.
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eSetOrClearAlignment
*
editingHostOrRoot
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
aHTMLEditor
arrayOfContents
EditSubAction
:
:
eSetOrClearAlignment
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
eSetOrClearAlignment
"
"
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
eSetOrClearAlignment
"
"
CollectNonEditableNodes
:
:
Yes
)
returned
no
contents
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
editTargetContent
=
arrayOfContents
[
0
]
;
}
const
RefPtr
<
dom
:
:
Element
>
maybeNonEditableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
editTargetContent
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
NS_WARN_IF
(
!
maybeNonEditableBlockElement
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
aHTMLEditor
.
IsCSSEnabled
(
)
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
maybeNonEditableBlockElement
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedCSSEquivalentToHTMLInlineStyleSet
(
*
maybeNonEditableBlockElement
nullptr
nsGkAtoms
:
:
align
value
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedCSSEquivalentToHTMLInlineStyleSet
(
nsGkAtoms
:
:
"
"
align
"
"
eComputed
)
failed
but
ignored
"
)
;
if
(
value
.
EqualsLiteral
(
"
center
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
center
"
)
|
|
value
.
EqualsLiteral
(
"
auto
auto
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
|
|
value
.
EqualsLiteral
(
"
-
moz
-
right
"
)
|
|
value
.
EqualsLiteral
(
"
auto
0px
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
for
(
nsIContent
*
containerContent
:
editTargetContent
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
containerContent
!
=
editTargetContent
&
&
containerContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
;
}
if
(
CSSEditUtils
:
:
IsCSSEditableProperty
(
containerContent
nullptr
nsGkAtoms
:
:
align
)
)
{
nsAutoString
value
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetSpecifiedProperty
(
*
containerContent
*
nsGkAtoms
:
:
textAlign
value
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetSpecifiedProperty
(
nsGkAtoms
:
:
"
"
textAlign
)
failed
but
ignored
"
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
EqualsLiteral
(
"
center
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
right
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
if
(
value
.
EqualsLiteral
(
"
left
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
}
}
if
(
!
HTMLEditUtils
:
:
SupportsAlignAttr
(
*
containerContent
)
)
{
continue
;
}
nsAutoString
alignAttributeValue
;
containerContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
align
alignAttributeValue
)
;
if
(
alignAttributeValue
.
IsEmpty
(
)
)
{
continue
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
center
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eCenter
;
return
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
right
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eRight
;
return
;
}
if
(
alignAttributeValue
.
LowerCaseEqualsASCII
(
"
justify
"
)
)
{
mFirstAlign
=
nsIHTMLEditor
:
:
eJustify
;
return
;
}
mFirstAlign
=
nsIHTMLEditor
:
:
eLeft
;
return
;
}
}
ParagraphStateAtSelection
:
:
ParagraphStateAtSelection
(
HTMLEditor
&
aHTMLEditor
ErrorResult
&
aRv
)
{
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
EditorBase
:
:
AutoEditActionDataSetter
editActionData
(
aHTMLEditor
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
aRv
=
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
return
;
}
if
(
aHTMLEditor
.
IsSelectionRangeContainerNotContent
(
)
)
{
NS_WARNING
(
"
Some
selection
containers
are
not
content
node
but
ignored
"
)
;
return
;
}
Element
*
editingHostOrRoot
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
if
(
!
editingHostOrRoot
)
{
editingHostOrRoot
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
!
editingHostOrRoot
)
{
return
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
nsresult
rv
=
CollectEditableFormatNodesInSelection
(
aHTMLEditor
*
editingHostOrRoot
arrayOfContents
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
ParagraphStateAtSelection
:
:
CollectEditableFormatNodesInSelection
(
)
"
"
failed
"
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
for
(
int32_t
i
=
arrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
auto
&
content
=
arrayOfContents
[
i
]
;
nsAutoString
format
;
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
&
&
!
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
arrayOfContents
*
content
-
>
AsElement
(
)
)
;
}
}
if
(
arrayOfContents
.
IsEmpty
(
)
)
{
const
auto
atCaret
=
aHTMLEditor
.
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atCaret
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
content
=
atCaret
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
arrayOfContents
.
AppendElement
(
*
content
)
;
}
dom
:
:
Element
*
bodyOrDocumentElement
=
aHTMLEditor
.
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
for
(
auto
&
content
:
Reversed
(
arrayOfContents
)
)
{
nsAtom
*
paragraphStateOfNode
=
nsGkAtoms
:
:
_empty
;
if
(
HTMLEditUtils
:
:
IsFormatNode
(
content
)
)
{
MOZ_ASSERT
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
paragraphStateOfNode
=
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
else
if
(
HTMLEditUtils
:
:
IsBlockElement
(
content
)
)
{
continue
;
}
else
{
for
(
nsINode
*
parentNode
=
content
-
>
GetParentNode
(
)
;
parentNode
;
parentNode
=
parentNode
-
>
GetParentNode
(
)
)
{
if
(
parentNode
=
=
bodyOrDocumentElement
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsFormatNode
(
parentNode
)
)
{
MOZ_ASSERT
(
parentNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
paragraphStateOfNode
=
parentNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
break
;
}
}
}
if
(
!
mFirstParagraphState
)
{
mFirstParagraphState
=
paragraphStateOfNode
;
continue
;
}
if
(
mFirstParagraphState
!
=
paragraphStateOfNode
)
{
mIsMixed
=
true
;
break
;
}
}
}
void
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
dom
:
:
Element
&
aNonFormatBlockElement
)
{
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsBlockElement
(
aNonFormatBlockElement
)
)
;
MOZ_ASSERT
(
!
HTMLEditUtils
:
:
IsFormatNode
(
&
aNonFormatBlockElement
)
)
;
bool
foundInline
=
false
;
for
(
nsIContent
*
childContent
=
aNonFormatBlockElement
.
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
bool
isBlock
=
HTMLEditUtils
:
:
IsBlockElement
(
*
childContent
)
;
bool
isFormat
=
HTMLEditUtils
:
:
IsFormatNode
(
childContent
)
;
if
(
isBlock
&
&
!
isFormat
)
{
ParagraphStateAtSelection
:
:
AppendDescendantFormatNodesAndFirstInlineNode
(
aArrayOfContents
*
childContent
-
>
AsElement
(
)
)
;
continue
;
}
if
(
isFormat
)
{
aArrayOfContents
.
AppendElement
(
*
childContent
)
;
continue
;
}
MOZ_ASSERT
(
!
isBlock
)
;
if
(
!
foundInline
)
{
foundInline
=
true
;
aArrayOfContents
.
AppendElement
(
*
childContent
)
;
continue
;
}
}
}
nsresult
ParagraphStateAtSelection
:
:
CollectEditableFormatNodesInSelection
(
HTMLEditor
&
aHTMLEditor
const
Element
&
aEditingHost
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfContents
)
{
{
AutoRangeArray
extendedSelectionRanges
(
aHTMLEditor
.
SelectionRef
(
)
)
;
extendedSelectionRanges
.
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
:
:
eCreateOrRemoveBlock
aEditingHost
)
;
nsresult
rv
=
extendedSelectionRanges
.
CollectEditTargetNodes
(
aHTMLEditor
aArrayOfContents
EditSubAction
:
:
eCreateOrRemoveBlock
AutoRangeArray
:
:
CollectNonEditableNodes
:
:
Yes
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
CollectEditTargetNodes
(
EditSubAction
:
:
"
"
eCreateOrRemoveBlock
CollectNonEditableNodes
:
:
Yes
)
failed
"
)
;
return
rv
;
}
}
for
(
int32_t
i
=
aArrayOfContents
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
OwningNonNull
<
nsIContent
>
content
=
aArrayOfContents
[
i
]
;
if
(
!
EditorUtils
:
:
IsEditableContent
(
content
EditorType
:
:
HTML
)
)
{
aArrayOfContents
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
content
)
|
|
HTMLEditUtils
:
:
IsAnyListElement
(
content
)
|
|
HTMLEditUtils
:
:
IsListItem
(
content
)
)
{
aArrayOfContents
.
RemoveElementAt
(
i
)
;
HTMLEditUtils
:
:
CollectChildren
(
content
aArrayOfContents
i
{
CollectChildrenOption
:
:
CollectListChildren
CollectChildrenOption
:
:
CollectTableChildren
}
)
;
}
}
return
NS_OK
;
}
}
