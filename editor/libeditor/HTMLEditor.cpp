#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditRules
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
HTMLURIRefObject
.
h
"
#
include
"
StyleSheetTransactions
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
nsIDOMMozNamedAttrMap
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMAttr
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIDOMHTMLDocument
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIDOMStyleSheet
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
HTMLEditorObjectResizerUtils
.
h
"
#
include
"
TextEditorTest
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
static
bool
IsLinkTag
(
const
nsString
&
s
)
{
return
s
.
EqualsIgnoreCase
(
"
href
"
)
;
}
static
bool
IsNamedAnchorTag
(
const
nsString
&
s
)
{
return
s
.
EqualsIgnoreCase
(
"
anchor
"
)
|
|
s
.
EqualsIgnoreCase
(
"
namedanchor
"
)
;
}
HTMLEditor
:
:
HTMLEditor
(
)
:
mCRInParagraphCreatesParagraph
(
false
)
mCSSAware
(
false
)
mSelectedCellIndex
(
0
)
mIsObjectResizingEnabled
(
true
)
mIsResizing
(
false
)
mPreserveRatio
(
false
)
mResizedObjectIsAnImage
(
false
)
mIsAbsolutelyPositioningEnabled
(
true
)
mResizedObjectIsAbsolutelyPositioned
(
false
)
mGrabberClicked
(
false
)
mIsMoving
(
false
)
mSnapToGridEnabled
(
false
)
mIsInlineTableEditingEnabled
(
true
)
mOriginalX
(
0
)
mOriginalY
(
0
)
mResizedObjectX
(
0
)
mResizedObjectY
(
0
)
mResizedObjectWidth
(
0
)
mResizedObjectHeight
(
0
)
mResizedObjectMarginLeft
(
0
)
mResizedObjectMarginTop
(
0
)
mResizedObjectBorderLeft
(
0
)
mResizedObjectBorderTop
(
0
)
mXIncrementFactor
(
0
)
mYIncrementFactor
(
0
)
mWidthIncrementFactor
(
0
)
mHeightIncrementFactor
(
0
)
mInfoXIncrement
(
20
)
mInfoYIncrement
(
20
)
mPositionedObjectX
(
0
)
mPositionedObjectY
(
0
)
mPositionedObjectWidth
(
0
)
mPositionedObjectHeight
(
0
)
mPositionedObjectMarginLeft
(
0
)
mPositionedObjectMarginTop
(
0
)
mPositionedObjectBorderLeft
(
0
)
mPositionedObjectBorderTop
(
0
)
mGridSize
(
0
)
mDefaultParagraphSeparator
(
Preferences
:
:
GetBool
(
"
editor
.
use_div_for_default_newlines
"
true
)
?
ParagraphSeparator
:
:
div
:
ParagraphSeparator
:
:
br
)
{
mIsHTMLEditorClass
=
true
;
}
HTMLEditor
:
:
~
HTMLEditor
(
)
{
nsCOMPtr
<
nsIEditActionListener
>
mListener
=
do_QueryInterface
(
mRules
)
;
RemoveEditActionListener
(
mListener
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
selection
)
{
nsCOMPtr
<
nsISelectionListener
>
listener
;
listener
=
do_QueryInterface
(
mTypeInState
)
;
if
(
listener
)
{
selection
-
>
RemoveSelectionListener
(
listener
)
;
}
listener
=
do_QueryInterface
(
mSelectionListenerP
)
;
if
(
listener
)
{
selection
-
>
RemoveSelectionListener
(
listener
)
;
}
}
mTypeInState
=
nullptr
;
mSelectionListenerP
=
nullptr
;
if
(
mLinkHandler
&
&
IsInitialized
(
)
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
if
(
ps
&
&
ps
-
>
GetPresContext
(
)
)
{
ps
-
>
GetPresContext
(
)
-
>
SetLinkHandler
(
mLinkHandler
)
;
}
}
RemoveEventListeners
(
)
;
HideAnonymousEditingUIs
(
)
;
}
void
HTMLEditor
:
:
HideAnonymousEditingUIs
(
)
{
if
(
mAbsolutelyPositionedObject
)
{
HideGrabber
(
)
;
}
if
(
mInlineEditedCell
)
{
HideInlineTableEditingUI
(
)
;
}
if
(
mResizedObject
)
{
HideResizers
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStyleSheets
)
tmp
-
>
HideAnonymousEditingUIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheets
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActivatedHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMouseMotionListenerP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectionListenerP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizeEventListenerP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAbsolutelyPositionedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGrabber
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositioningShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineEditedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveColumnButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveRowButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
HTMLEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLObjectResizer
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLAbsPosEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLInlineTableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorStyleSheets
)
NS_INTERFACE_MAP_ENTRY
(
nsICSSLoaderObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
TextEditor
)
NS_IMETHODIMP
HTMLEditor
:
:
Init
(
nsIDOMDocument
*
aDoc
nsIContent
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
{
NS_PRECONDITION
(
aDoc
&
&
!
aSelCon
"
bad
arg
"
)
;
NS_ENSURE_TRUE
(
aDoc
NS_ERROR_NULL_POINTER
)
;
MOZ_ASSERT
(
aInitialValue
.
IsEmpty
(
)
"
Non
-
empty
initial
values
not
supported
"
)
;
nsresult
rulesRv
=
NS_OK
;
{
AutoEditInitRulesTrigger
rulesTrigger
(
this
rulesRv
)
;
nsresult
rv
=
TextEditor
:
:
Init
(
aDoc
aRoot
nullptr
aFlags
aInitialValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
document
=
do_QueryInterface
(
aDoc
)
;
document
-
>
AddMutationObserverUnlessExists
(
this
)
;
if
(
!
mRootElement
)
{
UpdateRootElement
(
)
;
}
if
(
IsMailEditor
(
)
)
{
SetAbsolutePositioningEnabled
(
false
)
;
SetSnapToGridEnabled
(
false
)
;
}
mCSSEditUtils
=
MakeUnique
<
CSSEditUtils
>
(
this
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsPresContext
*
context
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
context
NS_ERROR_NULL_POINTER
)
;
if
(
!
IsPlaintextEditor
(
)
&
&
!
IsInteractionAllowed
(
)
)
{
mLinkHandler
=
context
-
>
GetLinkHandler
(
)
;
context
-
>
SetLinkHandler
(
nullptr
)
;
}
mTypeInState
=
new
TypeInState
(
)
;
mSelectionListenerP
=
new
ResizerSelectionListener
(
*
this
)
;
if
(
!
IsInteractionAllowed
(
)
)
{
AddOverrideStyleSheet
(
NS_LITERAL_STRING
(
"
resource
:
/
/
gre
/
res
/
EditorOverride
.
css
"
)
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
selection
)
{
nsCOMPtr
<
nsISelectionListener
>
listener
;
listener
=
do_QueryInterface
(
mTypeInState
)
;
if
(
listener
)
{
selection
-
>
AddSelectionListener
(
listener
)
;
}
listener
=
do_QueryInterface
(
mSelectionListenerP
)
;
if
(
listener
)
{
selection
-
>
AddSelectionListener
(
listener
)
;
}
}
}
NS_ENSURE_SUCCESS
(
rulesRv
rulesRv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
PreDestroy
(
bool
aDestroyingFrames
)
{
if
(
mDidPreDestroy
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
document
)
{
document
-
>
RemoveMutationObserver
(
this
)
;
}
while
(
!
mStyleSheetURLs
.
IsEmpty
(
)
)
{
RemoveOverrideStyleSheet
(
mStyleSheetURLs
[
0
]
)
;
}
HideAnonymousEditingUIs
(
)
;
return
TextEditor
:
:
PreDestroy
(
aDestroyingFrames
)
;
}
void
HTMLEditor
:
:
UpdateRootElement
(
)
{
nsCOMPtr
<
nsIDOMElement
>
rootElement
;
nsCOMPtr
<
nsIDOMHTMLElement
>
bodyElement
;
GetBodyElement
(
getter_AddRefs
(
bodyElement
)
)
;
if
(
bodyElement
)
{
rootElement
=
bodyElement
;
}
else
{
nsCOMPtr
<
nsIDOMDocument
>
domDocument
=
GetDOMDocument
(
)
;
if
(
domDocument
)
{
domDocument
-
>
GetDocumentElement
(
getter_AddRefs
(
rootElement
)
)
;
}
}
mRootElement
=
do_QueryInterface
(
rootElement
)
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
FindSelectionRoot
(
nsINode
*
aNode
)
{
NS_PRECONDITION
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
|
|
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
"
aNode
must
be
content
or
document
node
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
aNode
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
content
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
aNode
-
>
IsContent
(
)
)
{
content
=
doc
-
>
GetRootElement
(
)
;
return
content
.
forget
(
)
;
}
content
=
aNode
-
>
AsContent
(
)
;
if
(
IsReadonly
(
)
)
{
content
=
do_QueryInterface
(
GetRoot
(
)
)
;
return
content
.
forget
(
)
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_MOZ_READWRITE
)
)
{
return
content
.
forget
(
)
;
}
return
nullptr
;
}
content
=
content
-
>
GetEditingHost
(
)
;
return
content
.
forget
(
)
;
}
void
HTMLEditor
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
HTMLEditorEventListener
(
)
;
}
}
nsresult
HTMLEditor
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
HTMLEditorEventListener
*
listener
=
reinterpret_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
;
return
listener
-
>
Connect
(
this
)
;
}
void
HTMLEditor
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
GetDOMEventTarget
(
)
;
if
(
target
)
{
if
(
mMouseMotionListenerP
)
{
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
false
)
;
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
true
)
;
}
if
(
mResizeEventListenerP
)
{
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
resize
"
)
mResizeEventListenerP
false
)
;
}
}
mMouseMotionListenerP
=
nullptr
;
mResizeEventListenerP
=
nullptr
;
TextEditor
:
:
RemoveEventListeners
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetFlags
(
uint32_t
aFlags
)
{
nsresult
rv
=
TextEditor
:
:
SetFlags
(
aFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCSSAware
=
!
NoCSS
(
)
&
&
!
IsMailEditor
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InitRules
(
)
{
if
(
!
mRules
)
{
mRules
=
new
HTMLEditRules
(
)
;
}
return
mRules
-
>
Init
(
this
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BeginningOfDocument
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
!
rootElement
)
{
NS_WARNING
(
"
GetRoot
(
)
returned
a
null
pointer
(
mRootElement
is
null
)
"
)
;
return
NS_OK
;
}
bool
done
=
false
;
nsCOMPtr
<
nsINode
>
curNode
=
rootElement
.
get
(
)
selNode
;
int32_t
curOffset
=
0
selOffset
=
0
;
while
(
!
done
)
{
WSRunObject
wsObj
(
this
curNode
curOffset
)
;
int32_t
visOffset
=
0
;
WSType
visType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
NextVisibleNode
(
curNode
curOffset
address_of
(
visNode
)
&
visOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
normalWS
|
|
visType
=
=
WSType
:
:
text
)
{
selNode
=
visNode
;
selOffset
=
visOffset
;
done
=
true
;
}
else
if
(
visType
=
=
WSType
:
:
br
|
|
visType
=
=
WSType
:
:
special
)
{
selNode
=
visNode
-
>
GetParentNode
(
)
;
selOffset
=
selNode
?
selNode
-
>
IndexOf
(
visNode
)
:
-
1
;
done
=
true
;
}
else
if
(
visType
=
=
WSType
:
:
otherBlock
)
{
if
(
!
IsContainer
(
visNode
)
)
{
selNode
=
visNode
-
>
GetParentNode
(
)
;
selOffset
=
selNode
?
selNode
-
>
IndexOf
(
visNode
)
:
-
1
;
done
=
true
;
}
else
{
bool
isEmptyBlock
;
if
(
NS_SUCCEEDED
(
IsEmptyNode
(
visNode
&
isEmptyBlock
)
)
&
&
isEmptyBlock
)
{
curNode
=
visNode
-
>
GetParentNode
(
)
;
curOffset
=
curNode
?
curNode
-
>
IndexOf
(
visNode
)
:
-
1
;
curOffset
+
+
;
}
else
{
curNode
=
visNode
;
curOffset
=
0
;
}
}
}
else
{
selNode
=
curNode
;
selOffset
=
curOffset
;
done
=
true
;
}
}
return
selection
-
>
Collapse
(
selNode
selOffset
)
;
}
nsresult
HTMLEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
case
NS_VK_BACK
:
case
NS_VK_DELETE
:
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_TAB
:
{
if
(
IsPlaintextEditor
(
)
)
{
return
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
&
&
selection
-
>
RangeCount
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
node
)
;
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
node
)
;
if
(
!
blockParent
)
{
break
;
}
bool
handled
=
false
;
nsresult
rv
=
NS_OK
;
if
(
HTMLEditUtils
:
:
IsTableElement
(
blockParent
)
)
{
rv
=
TabInTable
(
aKeyboardEvent
-
>
IsShift
(
)
&
handled
)
;
if
(
Destroyed
(
)
)
{
return
NS_OK
;
}
if
(
handled
)
{
ScrollSelectionIntoView
(
false
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsListItem
(
blockParent
)
)
{
rv
=
Indent
(
aKeyboardEvent
-
>
IsShift
(
)
?
NS_LITERAL_STRING
(
"
outdent
"
)
:
NS_LITERAL_STRING
(
"
indent
"
)
)
;
handled
=
true
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
handled
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
TypedText
(
NS_LITERAL_STRING
(
"
\
t
"
)
eTypedText
)
;
}
case
NS_VK_RETURN
:
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
TypedText
(
EmptyString
(
)
eTypedBR
)
;
}
return
TypedText
(
EmptyString
(
)
eTypedBreak
)
;
}
if
(
!
aKeyboardEvent
-
>
mCharCode
|
|
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
aKeyboardEvent
-
>
mCharCode
)
;
return
TypedText
(
str
eTypedText
)
;
}
bool
HTMLEditor
:
:
NodeIsBlockStatic
(
const
nsINode
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
return
true
;
}
return
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
}
nsresult
HTMLEditor
:
:
NodeIsBlockStatic
(
nsIDOMNode
*
aNode
bool
*
aIsBlock
)
{
if
(
!
aNode
|
|
!
aIsBlock
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aNode
)
;
*
aIsBlock
=
element
&
&
NodeIsBlockStatic
(
element
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NodeIsBlock
(
nsIDOMNode
*
aNode
bool
*
aIsBlock
)
{
return
NodeIsBlockStatic
(
aNode
aIsBlock
)
;
}
bool
HTMLEditor
:
:
IsBlockNode
(
nsINode
*
aNode
)
{
return
aNode
&
&
NodeIsBlockStatic
(
aNode
)
;
}
Element
*
HTMLEditor
:
:
GetBlockNodeParent
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
p
=
aNode
-
>
GetParentNode
(
)
;
while
(
p
)
{
if
(
NodeIsBlockStatic
(
p
)
)
{
return
p
-
>
AsElement
(
)
;
}
p
=
p
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
nsIDOMNode
*
HTMLEditor
:
:
GetBlockNodeParent
(
nsIDOMNode
*
aNode
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
if
(
!
node
)
{
NS_NOTREACHED
(
"
null
node
passed
to
GetBlockNodeParent
(
)
"
)
;
return
nullptr
;
}
return
GetAsDOMNode
(
GetBlockNodeParent
(
node
)
)
;
}
Element
*
HTMLEditor
:
:
GetBlock
(
nsINode
&
aNode
)
{
if
(
NodeIsBlockStatic
(
&
aNode
)
)
{
return
aNode
.
AsElement
(
)
;
}
return
GetBlockNodeParent
(
&
aNode
)
;
}
void
HTMLEditor
:
:
IsNextCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
&
&
(
uint32_t
)
aOffset
<
aContent
-
>
Length
(
)
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
+
1
;
}
}
}
void
HTMLEditor
:
:
IsPrevCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
&
&
aOffset
>
0
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
-
1
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
-
1
;
}
}
}
bool
HTMLEditor
:
:
IsVisibleBRElement
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
TextEditUtils
:
:
IsBreak
(
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
nextNode
=
GetNextHTMLNode
(
aNode
true
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsBreak
(
nextNode
)
)
{
return
true
;
}
if
(
!
nextNode
)
{
return
false
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
GetPriorHTMLNode
(
aNode
true
)
;
if
(
priorNode
&
&
TextEditUtils
:
:
IsBreak
(
priorNode
)
)
{
return
true
;
}
int32_t
selOffset
;
nsCOMPtr
<
nsINode
>
selNode
=
GetNodeLocation
(
aNode
&
selOffset
)
;
selOffset
+
+
;
WSRunObject
wsObj
(
this
selNode
selOffset
)
;
nsCOMPtr
<
nsINode
>
unused
;
int32_t
visOffset
=
0
;
WSType
visType
;
wsObj
.
NextVisibleNode
(
selNode
selOffset
address_of
(
unused
)
&
visOffset
&
visType
)
;
if
(
visType
&
WSType
:
:
block
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP
HTMLEditor
:
:
UpdateBaseURL
(
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
RefPtr
<
nsContentList
>
nodeList
=
doc
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
base
"
)
)
;
if
(
!
nodeList
|
|
!
nodeList
-
>
Item
(
0
)
)
{
doc
-
>
SetBaseURI
(
doc
-
>
GetDocumentURI
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
TypedText
(
const
nsAString
&
aString
ETypingAction
aAction
)
{
MOZ_ASSERT
(
!
aString
.
IsEmpty
(
)
|
|
aAction
!
=
eTypedText
)
;
AutoPlaceholderBatch
batch
(
this
nsGkAtoms
:
:
TypingTxnName
)
;
if
(
aAction
=
=
eTypedBR
)
{
nsCOMPtr
<
nsIDOMNode
>
brNode
;
return
InsertBR
(
address_of
(
brNode
)
)
;
}
return
TextEditor
:
:
TypedText
(
aString
aAction
)
;
}
nsresult
HTMLEditor
:
:
TabInTable
(
bool
inIsShift
bool
*
outHandled
)
{
NS_ENSURE_TRUE
(
outHandled
NS_ERROR_NULL_POINTER
)
;
*
outHandled
=
false
;
nsCOMPtr
<
Element
>
cellElement
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
)
;
NS_ENSURE_TRUE
(
cellElement
NS_OK
)
;
nsCOMPtr
<
Element
>
table
=
GetEnclosingTable
(
cellElement
)
;
NS_ENSURE_TRUE
(
table
NS_OK
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
table
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
iter
-
>
PositionAt
(
cellElement
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
node
;
do
{
if
(
inIsShift
)
{
iter
-
>
Prev
(
)
;
}
else
{
iter
-
>
Next
(
)
;
}
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
&
&
HTMLEditUtils
:
:
IsTableCell
(
node
)
&
&
GetEnclosingTable
(
node
)
=
=
table
)
{
CollapseSelectionToDeepestNonTableFirstChild
(
nullptr
node
)
;
*
outHandled
=
true
;
return
NS_OK
;
}
}
while
(
!
iter
-
>
IsDone
(
)
)
;
if
(
!
(
*
outHandled
)
&
&
!
inIsShift
)
{
rv
=
InsertTableRow
(
1
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
outHandled
=
true
;
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
tblElement
cell
;
int32_t
row
;
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
tblElement
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
row
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetCellAt
(
tblElement
row
0
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
{
selection
-
>
Collapse
(
cell
0
)
;
}
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateBR
(
nsINode
*
aNode
int32_t
aOffset
EDirection
aSelect
)
{
nsCOMPtr
<
nsIDOMNode
>
parent
=
GetAsDOMNode
(
aNode
)
;
int32_t
offset
=
aOffset
;
nsCOMPtr
<
nsIDOMNode
>
outBRNode
;
CreateBRImpl
(
address_of
(
parent
)
&
offset
address_of
(
outBRNode
)
aSelect
)
;
nsCOMPtr
<
Element
>
ret
=
do_QueryInterface
(
outBRNode
)
;
return
ret
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateBR
(
nsIDOMNode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsIDOMNode
>
*
outBRNode
EDirection
aSelect
)
{
nsCOMPtr
<
nsIDOMNode
>
parent
=
aNode
;
int32_t
offset
=
aOffset
;
return
CreateBRImpl
(
address_of
(
parent
)
&
offset
outBRNode
aSelect
)
;
}
nsresult
HTMLEditor
:
:
InsertBR
(
nsCOMPtr
<
nsIDOMNode
>
*
outBRNode
)
{
NS_ENSURE_TRUE
(
outBRNode
NS_ERROR_NULL_POINTER
)
;
*
outBRNode
=
nullptr
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertText
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
if
(
!
selection
-
>
Collapsed
(
)
)
{
nsresult
rv
=
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDOMNode
>
selNode
;
int32_t
selOffset
;
nsresult
rv
=
GetStartNodeAndOffset
(
selection
getter_AddRefs
(
selNode
)
&
selOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CreateBR
(
selNode
selOffset
outBRNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
selNode
=
GetNodeLocation
(
*
outBRNode
&
selOffset
)
;
selection
-
>
SetInterlinePosition
(
true
)
;
return
selection
-
>
Collapse
(
selNode
selOffset
+
1
)
;
}
void
HTMLEditor
:
:
CollapseSelectionToDeepestNonTableFirstChild
(
Selection
*
aSelection
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
RefPtr
<
Selection
>
selection
=
aSelection
;
if
(
!
selection
)
{
selection
=
GetSelection
(
)
;
}
if
(
!
selection
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
aNode
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
node
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
child
)
|
|
!
IsContainer
(
child
)
)
{
break
;
}
node
=
child
;
}
selection
-
>
Collapse
(
node
0
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ReplaceHeadContentsWithHTML
(
const
nsAString
&
aSourceToInsert
)
{
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
ignore
nsIEditor
:
:
eNone
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
CommitComposition
(
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsContentList
>
nodeList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
head
"
)
)
;
NS_ENSURE_TRUE
(
nodeList
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
headNode
=
nodeList
-
>
Item
(
0
)
;
NS_ENSURE_TRUE
(
headNode
NS_ERROR_NULL_POINTER
)
;
nsAutoString
inputString
(
aSourceToInsert
)
;
inputString
.
ReplaceSubstring
(
u
"
\
r
\
n
"
u
"
\
n
"
)
;
inputString
.
ReplaceSubstring
(
u
"
\
r
"
u
"
\
n
"
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_NULL_POINTER
)
;
ErrorResult
err
;
RefPtr
<
DocumentFragment
>
docfrag
=
range
-
>
CreateContextualFragment
(
inputString
err
)
;
if
(
err
.
Failed
(
)
)
{
#
ifdef
DEBUG
printf
(
"
Couldn
'
t
create
contextual
fragment
:
error
was
%
X
\
n
"
err
.
ErrorCodeAsInt
(
)
)
;
#
endif
return
err
.
StealNSResult
(
)
;
}
NS_ENSURE_TRUE
(
docfrag
NS_ERROR_NULL_POINTER
)
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
headNode
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNode
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
offsetOfNewNode
=
0
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
docfrag
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
InsertNode
(
*
child
*
headNode
offsetOfNewNode
+
+
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RebuildDocumentFromSource
(
const
nsAString
&
aSourceString
)
{
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
Element
>
bodyElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
bodyElement
NS_ERROR_NULL_POINTER
)
;
nsReadingIterator
<
char16_t
>
beginbody
;
nsReadingIterator
<
char16_t
>
endbody
;
aSourceString
.
BeginReading
(
beginbody
)
;
aSourceString
.
EndReading
(
endbody
)
;
bool
foundbody
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
body
"
)
beginbody
endbody
)
;
nsReadingIterator
<
char16_t
>
beginhead
;
nsReadingIterator
<
char16_t
>
endhead
;
aSourceString
.
BeginReading
(
beginhead
)
;
aSourceString
.
EndReading
(
endhead
)
;
bool
foundhead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
head
"
)
beginhead
endhead
)
;
if
(
foundbody
&
&
beginhead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundhead
=
false
;
}
nsReadingIterator
<
char16_t
>
beginclosehead
;
nsReadingIterator
<
char16_t
>
endclosehead
;
aSourceString
.
BeginReading
(
beginclosehead
)
;
aSourceString
.
EndReading
(
endclosehead
)
;
bool
foundclosehead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
/
head
>
"
)
beginclosehead
endclosehead
)
;
if
(
foundhead
&
&
beginhead
.
get
(
)
>
beginclosehead
.
get
(
)
)
{
foundclosehead
=
false
;
}
if
(
foundbody
&
&
beginclosehead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundclosehead
=
false
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
nsReadingIterator
<
char16_t
>
endtotal
;
aSourceString
.
EndReading
(
endtotal
)
;
if
(
foundhead
)
{
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
Substring
(
beginhead
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
Substring
(
beginhead
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
Substring
(
beginhead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
else
{
nsReadingIterator
<
char16_t
>
begintotal
;
aSourceString
.
BeginReading
(
begintotal
)
;
NS_NAMED_LITERAL_STRING
(
head
"
<
head
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
head
+
Substring
(
begintotal
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
head
+
Substring
(
begintotal
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithHTML
(
head
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsresult
rv
=
SelectAll
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
foundbody
)
{
NS_NAMED_LITERAL_STRING
(
body
"
<
body
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
LoadHTML
(
body
+
Substring
(
endclosehead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundhead
)
{
nsresult
rv
=
LoadHTML
(
body
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
LoadHTML
(
body
+
aSourceString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
Element
>
divElement
=
CreateElementWithDefaults
(
NS_LITERAL_STRING
(
"
div
"
)
)
;
NS_ENSURE_TRUE
(
divElement
NS_ERROR_FAILURE
)
;
CloneAttributes
(
bodyElement
divElement
)
;
return
BeginningOfDocument
(
)
;
}
rv
=
LoadHTML
(
Substring
(
beginbody
endtotal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsReadingIterator
<
char16_t
>
beginclosebody
=
beginbody
;
nsReadingIterator
<
char16_t
>
endclosebody
;
aSourceString
.
EndReading
(
endclosebody
)
;
if
(
!
FindInReadable
(
NS_LITERAL_STRING
(
"
>
"
)
beginclosebody
endclosebody
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
bodyTag
;
bodyTag
.
AssignLiteral
(
"
<
div
"
)
;
bodyTag
.
Append
(
Substring
(
endbody
endclosebody
)
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
ErrorResult
erv
;
RefPtr
<
DocumentFragment
>
docfrag
=
range
-
>
CreateContextualFragment
(
bodyTag
erv
)
;
NS_ENSURE_TRUE
(
!
erv
.
Failed
(
)
erv
.
StealNSResult
(
)
)
;
NS_ENSURE_TRUE
(
docfrag
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
child
=
docfrag
-
>
GetFirstChild
(
)
;
NS_ENSURE_TRUE
(
child
&
&
child
-
>
IsElement
(
)
NS_ERROR_NULL_POINTER
)
;
CloneAttributes
(
bodyElement
child
-
>
AsElement
(
)
)
;
return
BeginningOfDocument
(
)
;
}
void
HTMLEditor
:
:
NormalizeEOLInsertPosition
(
nsINode
*
firstNodeToInsert
nsCOMPtr
<
nsIDOMNode
>
*
insertParentNode
int32_t
*
insertOffset
)
{
if
(
!
IsBlockNode
(
firstNodeToInsert
)
)
{
return
;
}
WSRunObject
wsObj
(
this
*
insertParentNode
*
insertOffset
)
;
nsCOMPtr
<
nsINode
>
nextVisNode
prevVisNode
;
int32_t
nextVisOffset
=
0
;
WSType
nextVisType
;
int32_t
prevVisOffset
=
0
;
WSType
prevVisType
;
nsCOMPtr
<
nsINode
>
parent
(
do_QueryInterface
(
*
insertParentNode
)
)
;
wsObj
.
NextVisibleNode
(
parent
*
insertOffset
address_of
(
nextVisNode
)
&
nextVisOffset
&
nextVisType
)
;
if
(
!
nextVisNode
)
{
return
;
}
if
(
!
(
nextVisType
&
WSType
:
:
br
)
)
{
return
;
}
wsObj
.
PriorVisibleNode
(
parent
*
insertOffset
address_of
(
prevVisNode
)
&
prevVisOffset
&
prevVisType
)
;
if
(
!
prevVisNode
)
{
return
;
}
if
(
prevVisType
&
WSType
:
:
br
)
{
return
;
}
if
(
prevVisType
&
WSType
:
:
thisBlock
)
{
return
;
}
int32_t
brOffset
=
0
;
nsCOMPtr
<
nsIDOMNode
>
brNode
=
GetNodeLocation
(
GetAsDOMNode
(
nextVisNode
)
&
brOffset
)
;
*
insertParentNode
=
brNode
;
*
insertOffset
=
brOffset
+
1
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertElementAtSelection
(
nsIDOMElement
*
aElement
bool
aDeleteSelection
)
{
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
NS_ENSURE_TRUE
(
element
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
node
=
do_QueryInterface
(
aElement
)
;
CommitComposition
(
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertElement
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
bool
cancel
handled
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
insertElement
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
if
(
aDeleteSelection
)
{
if
(
!
IsBlockNode
(
element
)
)
{
rv
=
DeleteSelection
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eNoStrip
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aDeleteSelection
)
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
node
)
)
{
selection
-
>
CollapseToStart
(
)
;
}
else
{
selection
-
>
CollapseToEnd
(
)
;
}
}
nsINode
*
parentSelectedNode
=
selection
-
>
GetAnchorNode
(
)
;
if
(
parentSelectedNode
)
{
int32_t
offsetForInsert
=
selection
-
>
AnchorOffset
(
)
;
nsCOMPtr
<
nsIDOMNode
>
parentSelectedDOMNode
=
GetAsDOMNode
(
parentSelectedNode
)
;
NormalizeEOLInsertPosition
(
element
address_of
(
parentSelectedDOMNode
)
&
offsetForInsert
)
;
rv
=
InsertNodeAtPoint
(
node
address_of
(
parentSelectedDOMNode
)
&
offsetForInsert
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
SetCaretInTableCell
(
aElement
)
)
{
rv
=
SetCaretAfterElement
(
aElement
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
node
)
)
{
if
(
IsLastEditableChild
(
element
)
)
{
nsCOMPtr
<
nsIDOMNode
>
brNode
;
rv
=
CreateBR
(
parentSelectedDOMNode
offsetForInsert
+
1
address_of
(
brNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
selection
-
>
Collapse
(
parentSelectedDOMNode
offsetForInsert
+
1
)
;
}
}
}
}
rv
=
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertNodeAtPoint
(
nsIDOMNode
*
aNode
nsCOMPtr
<
nsIDOMNode
>
*
ioParent
int32_t
*
ioOffset
bool
aNoEmptyNodes
nsCOMPtr
<
nsIDOMNode
>
*
ioChildAtOffset
)
{
nsCOMPtr
<
nsIContent
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
ioParent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
*
ioParent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
ioOffset
NS_ERROR_NULL_POINTER
)
;
bool
isDocumentFragment
=
false
;
if
(
ioChildAtOffset
)
{
*
ioChildAtOffset
=
aNode
;
uint16_t
nodeType
=
0
;
if
(
NS_SUCCEEDED
(
aNode
-
>
GetNodeType
(
&
nodeType
)
)
&
&
nodeType
=
=
nsIDOMNode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
isDocumentFragment
=
true
;
}
}
nsCOMPtr
<
nsIContent
>
parent
=
do_QueryInterface
(
*
ioParent
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
topChild
=
parent
;
nsCOMPtr
<
nsIContent
>
origParent
=
parent
;
while
(
!
CanContain
(
*
parent
*
node
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_TRUE
(
parent
-
>
GetParentNode
(
)
NS_ERROR_FAILURE
)
;
if
(
!
IsEditable
(
parent
-
>
GetParentNode
(
)
)
)
{
parent
=
topChild
=
origParent
;
break
;
}
topChild
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
!
=
topChild
)
{
nsCOMPtr
<
nsIContent
>
child
;
if
(
ioChildAtOffset
)
{
child
=
do_QueryInterface
(
*
ioChildAtOffset
)
;
}
int32_t
offset
=
SplitNodeDeep
(
*
topChild
*
origParent
*
ioOffset
aNoEmptyNodes
?
EmptyContainers
:
:
no
:
EmptyContainers
:
:
yes
nullptr
nullptr
address_of
(
child
)
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
*
ioParent
=
GetAsDOMNode
(
parent
)
;
*
ioOffset
=
offset
;
if
(
ioChildAtOffset
)
{
*
ioChildAtOffset
=
GetAsDOMNode
(
child
)
;
}
}
nsresult
rv
=
InsertNode
(
*
node
*
parent
*
ioOffset
)
;
if
(
isDocumentFragment
)
{
*
ioChildAtOffset
=
do_QueryInterface
(
parent
-
>
GetChildAt
(
*
ioOffset
)
)
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectElement
(
nsIDOMElement
*
aElement
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
NS_ENSURE_STATE
(
element
|
|
!
aElement
)
;
if
(
!
IsDescendantOfEditorRoot
(
element
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
nsINode
*
parent
=
element
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
offsetInParent
=
parent
-
>
IndexOf
(
element
)
;
nsresult
rv
=
selection
-
>
Collapse
(
parent
offsetInParent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
selection
-
>
Extend
(
parent
offsetInParent
+
1
)
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetCaretAfterElement
(
nsIDOMElement
*
aElement
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
NS_ENSURE_STATE
(
element
|
|
!
aElement
)
;
if
(
!
aElement
|
|
!
IsDescendantOfEditorRoot
(
element
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
parent
;
nsresult
rv
=
aElement
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
int32_t
offsetInParent
=
GetChildOffset
(
aElement
parent
)
;
return
selection
-
>
Collapse
(
parent
offsetInParent
+
1
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetParagraphFormat
(
const
nsAString
&
aParagraphFormat
)
{
nsAutoString
tag
;
tag
.
Assign
(
aParagraphFormat
)
;
ToLowerCase
(
tag
)
;
if
(
tag
.
EqualsLiteral
(
"
dd
"
)
|
|
tag
.
EqualsLiteral
(
"
dt
"
)
)
{
return
MakeDefinitionItem
(
tag
)
;
}
return
InsertBasicBlock
(
tag
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
=
static_cast
<
HTMLEditRules
*
>
(
mRules
.
get
(
)
)
;
return
htmlRules
-
>
GetParagraphState
(
aMixed
outFormat
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
IsCSSEnabled
(
)
)
{
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
true
)
;
}
return
GetHTMLBackgroundColorState
(
aMixed
aOutColor
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHighlightColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
if
(
!
IsCSSEnabled
(
)
)
{
return
NS_OK
;
}
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
false
)
;
}
nsresult
HTMLEditor
:
:
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
&
&
selection
-
>
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
selection
-
>
Collapsed
(
)
|
|
IsTextNode
(
parent
)
)
{
nodeToExamine
=
parent
;
}
else
{
nodeToExamine
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
}
NS_ENSURE_TRUE
(
nodeToExamine
NS_ERROR_NULL_POINTER
)
;
if
(
aBlockLevel
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
nodeToExamine
)
;
NS_ENSURE_TRUE
(
blockParent
NS_OK
)
;
do
{
mCSSEditUtils
-
>
GetComputedProperty
(
*
blockParent
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
blockParent
=
blockParent
-
>
GetParentElement
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
blockParent
)
;
if
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
mCSSEditUtils
-
>
GetDefaultBackgroundColor
(
aOutColor
)
;
}
}
else
{
if
(
IsTextNode
(
nodeToExamine
)
)
{
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
if
(
!
nodeToExamine
)
{
return
NS_OK
;
}
do
{
if
(
NodeIsBlockStatic
(
nodeToExamine
)
)
{
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
break
;
}
else
{
mCSSEditUtils
-
>
GetComputedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
nodeToExamine
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
aOutColor
.
Truncate
(
)
;
nsCOMPtr
<
nsIDOMElement
>
domElement
;
int32_t
selectedCount
;
nsAutoString
tagName
;
nsresult
rv
=
GetSelectedOrParentTableElement
(
tagName
&
selectedCount
getter_AddRefs
(
domElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
domElement
)
;
while
(
element
)
{
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
if
(
!
aOutColor
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
NS_OK
;
}
element
=
element
-
>
GetParentElement
(
)
;
}
dom
:
:
Element
*
bodyElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
bodyElement
NS_ERROR_NULL_POINTER
)
;
bodyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
=
static_cast
<
HTMLEditRules
*
>
(
mRules
.
get
(
)
)
;
return
htmlRules
-
>
GetListState
(
aMixed
aOL
aUL
aDL
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
=
static_cast
<
HTMLEditRules
*
>
(
mRules
.
get
(
)
)
;
return
htmlRules
-
>
GetListItemState
(
aMixed
aLI
aDT
aDD
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aAlign
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
=
static_cast
<
HTMLEditRules
*
>
(
mRules
.
get
(
)
)
;
return
htmlRules
-
>
GetAlignment
(
aMixed
aAlign
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetIndentState
(
bool
*
aCanIndent
bool
*
aCanOutdent
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aCanIndent
&
&
aCanOutdent
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
=
static_cast
<
HTMLEditRules
*
>
(
mRules
.
get
(
)
)
;
return
htmlRules
-
>
GetIndentState
(
aCanIndent
aCanOutdent
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MakeOrChangeList
(
const
nsAString
&
aListType
bool
entireList
const
nsAString
&
aBulletType
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
makeList
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
makeList
)
;
ruleInfo
.
blockType
=
&
aListType
;
ruleInfo
.
entireList
=
entireList
;
ruleInfo
.
bulletType
=
&
aBulletType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
NS_ENSURE_TRUE
(
selection
-
>
GetRangeAt
(
0
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
nsIContent
>
node
=
*
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
;
int32_t
offset
=
selection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsIContent
>
parent
=
node
;
nsCOMPtr
<
nsIContent
>
topChild
=
node
;
RefPtr
<
nsAtom
>
listAtom
=
NS_Atomize
(
aListType
)
;
while
(
!
CanContainTag
(
*
parent
*
listAtom
)
)
{
topChild
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
!
=
node
)
{
offset
=
SplitNodeDeep
(
*
topChild
*
node
offset
EmptyContainers
:
:
yes
nullptr
nullptr
address_of
(
child
)
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
}
nsCOMPtr
<
Element
>
newList
=
CreateNode
(
listAtom
parent
offset
child
)
;
NS_ENSURE_STATE
(
newList
)
;
nsCOMPtr
<
Element
>
newItem
=
CreateNode
(
nsGkAtoms
:
:
li
newList
0
newList
-
>
GetFirstChild
(
)
)
;
NS_ENSURE_STATE
(
newItem
)
;
rv
=
selection
-
>
Collapse
(
newItem
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveList
(
const
nsAString
&
aListType
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
removeList
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
removeList
)
;
if
(
aListType
.
LowerCaseEqualsLiteral
(
"
ol
"
)
)
{
ruleInfo
.
bOrdered
=
true
;
}
else
{
ruleInfo
.
bOrdered
=
false
;
}
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
nsresult
HTMLEditor
:
:
MakeDefinitionItem
(
const
nsAString
&
aItemType
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
makeDefListItem
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
makeDefListItem
)
;
ruleInfo
.
blockType
=
&
aItemType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertBasicBlock
(
const
nsAString
&
aBlockType
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
makeBasicBlock
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
makeBasicBlock
)
;
ruleInfo
.
blockType
=
&
aBlockType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
NS_ENSURE_TRUE
(
selection
-
>
GetRangeAt
(
0
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
nsIContent
>
node
=
*
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
;
int32_t
offset
=
selection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
if
(
isCollapsed
)
{
nsCOMPtr
<
nsIContent
>
parent
=
node
;
nsCOMPtr
<
nsIContent
>
topChild
=
node
;
RefPtr
<
nsAtom
>
blockAtom
=
NS_Atomize
(
aBlockType
)
;
while
(
!
CanContainTag
(
*
parent
*
blockAtom
)
)
{
NS_ENSURE_TRUE
(
parent
-
>
GetParent
(
)
NS_ERROR_FAILURE
)
;
topChild
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
!
=
node
)
{
offset
=
SplitNodeDeep
(
*
topChild
*
node
offset
EmptyContainers
:
:
yes
nullptr
nullptr
address_of
(
child
)
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
}
nsCOMPtr
<
Element
>
newBlock
=
CreateNode
(
blockAtom
parent
offset
child
)
;
NS_ENSURE_STATE
(
newBlock
)
;
rv
=
selection
-
>
Collapse
(
newBlock
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Indent
(
const
nsAString
&
aIndent
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
EditAction
opID
=
EditAction
:
:
indent
;
if
(
aIndent
.
LowerCaseEqualsLiteral
(
"
outdent
"
)
)
{
opID
=
EditAction
:
:
outdent
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
opID
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
opID
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
NS_ENSURE_TRUE
(
selection
-
>
GetRangeAt
(
0
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
&
&
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
NS_ERROR_FAILURE
)
;
OwningNonNull
<
nsIContent
>
node
=
*
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
-
>
AsContent
(
)
;
int32_t
offset
=
selection
-
>
GetRangeAt
(
0
)
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsIContent
>
child
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
if
(
aIndent
.
EqualsLiteral
(
"
indent
"
)
)
{
if
(
isCollapsed
)
{
nsCOMPtr
<
nsIContent
>
parent
=
node
;
nsCOMPtr
<
nsIContent
>
topChild
=
node
;
while
(
!
CanContainTag
(
*
parent
*
nsGkAtoms
:
:
blockquote
)
)
{
NS_ENSURE_TRUE
(
parent
-
>
GetParent
(
)
NS_ERROR_FAILURE
)
;
topChild
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
!
=
node
)
{
offset
=
SplitNodeDeep
(
*
topChild
*
node
offset
EmptyContainers
:
:
yes
nullptr
nullptr
address_of
(
child
)
)
;
NS_ENSURE_STATE
(
offset
!
=
-
1
)
;
}
nsCOMPtr
<
Element
>
newBQ
=
CreateNode
(
nsGkAtoms
:
:
blockquote
parent
offset
child
)
;
NS_ENSURE_STATE
(
newBQ
)
;
rv
=
selection
-
>
Collapse
(
newBQ
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InsertText
(
NS_LITERAL_STRING
(
"
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
selection
-
>
GetRangeAt
(
0
)
)
;
rv
=
selection
-
>
Collapse
(
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Align
(
const
nsAString
&
aAlignType
)
{
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
align
nsIEditor
:
:
eNext
)
;
bool
cancel
handled
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
align
)
;
ruleInfo
.
alignType
=
&
aAlignType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsINode
*
aNode
)
{
MOZ_ASSERT
(
!
aTagName
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
if
(
!
node
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
nullptr
)
;
nsCOMPtr
<
nsINode
>
anchorNode
=
selection
-
>
GetAnchorNode
(
)
;
NS_ENSURE_TRUE
(
anchorNode
nullptr
)
;
if
(
anchorNode
-
>
HasChildNodes
(
)
&
&
anchorNode
-
>
IsContent
(
)
)
{
node
=
selection
-
>
GetChildAtAnchorOffset
(
)
;
}
if
(
!
node
)
{
node
=
anchorNode
;
}
}
nsCOMPtr
<
Element
>
current
;
if
(
node
-
>
IsElement
(
)
)
{
current
=
node
-
>
AsElement
(
)
;
}
else
if
(
node
-
>
GetParentElement
(
)
)
{
current
=
node
-
>
GetParentElement
(
)
;
}
else
{
MOZ_ASSERT
(
!
node
-
>
GetParentNode
(
)
|
|
!
node
-
>
GetParentNode
(
)
-
>
GetParentNode
(
)
)
;
return
nullptr
;
}
nsAutoString
tagName
(
aTagName
)
;
ToLowerCase
(
tagName
)
;
bool
getLink
=
IsLinkTag
(
tagName
)
;
bool
getNamedAnchor
=
IsNamedAnchorTag
(
tagName
)
;
if
(
getLink
|
|
getNamedAnchor
)
{
tagName
.
Assign
(
'
a
'
)
;
}
bool
findTableCell
=
tagName
.
EqualsLiteral
(
"
td
"
)
;
bool
findList
=
tagName
.
EqualsLiteral
(
"
list
"
)
;
for
(
;
current
;
current
=
current
-
>
GetParentElement
(
)
)
{
if
(
(
getLink
&
&
HTMLEditUtils
:
:
IsLink
(
current
)
)
|
|
(
getNamedAnchor
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
current
)
)
)
{
return
current
.
forget
(
)
;
}
if
(
findList
)
{
if
(
HTMLEditUtils
:
:
IsList
(
current
)
)
{
return
current
.
forget
(
)
;
}
}
else
if
(
findTableCell
)
{
if
(
HTMLEditUtils
:
:
IsTableCell
(
current
)
)
{
return
current
.
forget
(
)
;
}
}
else
if
(
current
-
>
NodeName
(
)
.
Equals
(
tagName
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
current
.
forget
(
)
;
}
if
(
current
-
>
GetParentElement
(
)
&
&
current
-
>
GetParentElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsIDOMNode
*
aNode
nsIDOMElement
*
*
aReturn
)
{
NS_ENSURE_TRUE
(
!
aTagName
.
IsEmpty
(
)
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aReturn
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
nsCOMPtr
<
Element
>
parent
=
GetElementOrParentByTagName
(
aTagName
node
)
;
nsCOMPtr
<
nsIDOMElement
>
ret
=
do_QueryInterface
(
parent
)
;
if
(
!
ret
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
ret
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedElement
(
const
nsAString
&
aTagName
nsIDOMElement
*
*
aReturn
)
{
NS_ENSURE_TRUE
(
aReturn
NS_ERROR_NULL_POINTER
)
;
*
aReturn
=
nullptr
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
bool
bNodeFound
=
false
;
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
nsAutoString
domTagName
;
nsAutoString
TagName
(
aTagName
)
;
ToLowerCase
(
TagName
)
;
bool
anyTag
=
(
TagName
.
IsEmpty
(
)
)
;
bool
isLinkTag
=
IsLinkTag
(
TagName
)
;
bool
isNamedAnchorTag
=
IsNamedAnchorTag
(
TagName
)
;
nsCOMPtr
<
nsIDOMElement
>
selectedElement
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
range
-
>
GetStartContainer
(
)
;
nsIContent
*
startNode
=
range
-
>
GetChildAtStartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
range
-
>
GetEndContainer
(
)
;
nsIContent
*
endNode
=
range
-
>
GetChildAtEndOffset
(
)
;
if
(
startContainer
&
&
startContainer
=
=
endContainer
&
&
startNode
&
&
endNode
&
&
startNode
-
>
GetNextSibling
(
)
=
=
endNode
)
{
nsCOMPtr
<
nsINode
>
selectedNode
=
startNode
;
if
(
selectedNode
)
{
selectedNode
-
>
AsDOMNode
(
)
-
>
GetNodeName
(
domTagName
)
;
ToLowerCase
(
domTagName
)
;
if
(
anyTag
|
|
(
TagName
=
=
domTagName
)
|
|
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
selectedNode
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
selectedNode
)
)
)
{
bNodeFound
=
true
;
selectedElement
=
do_QueryInterface
(
selectedNode
)
;
}
}
}
if
(
!
bNodeFound
)
{
if
(
isLinkTag
)
{
nsCOMPtr
<
nsINode
>
anchorNode
=
selection
-
>
GetAnchorNode
(
)
;
nsIContent
*
anchorChild
=
selection
-
>
GetChildAtAnchorOffset
(
)
;
nsCOMPtr
<
nsINode
>
focusNode
=
selection
-
>
GetFocusNode
(
)
;
nsIContent
*
focusChild
=
selection
-
>
GetChildAtFocusOffset
(
)
;
if
(
anchorNode
)
{
nsCOMPtr
<
nsIDOMElement
>
parentLinkOfAnchor
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
href
"
)
GetAsDOMNode
(
anchorNode
)
getter_AddRefs
(
parentLinkOfAnchor
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
parentLinkOfAnchor
)
{
if
(
isCollapsed
)
{
bNodeFound
=
true
;
}
else
if
(
focusNode
)
{
nsCOMPtr
<
nsIDOMElement
>
parentLinkOfFocus
;
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
href
"
)
GetAsDOMNode
(
focusNode
)
getter_AddRefs
(
parentLinkOfFocus
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
parentLinkOfFocus
=
=
parentLinkOfAnchor
)
{
bNodeFound
=
true
;
}
}
if
(
bNodeFound
)
{
parentLinkOfAnchor
.
forget
(
aReturn
)
;
return
NS_OK
;
}
}
else
if
(
anchorChild
&
&
focusChild
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
anchorChild
)
&
&
anchorNode
=
=
focusNode
&
&
focusChild
=
=
anchorChild
-
>
GetNextSibling
(
)
)
{
selectedElement
=
do_QueryInterface
(
anchorChild
)
;
bNodeFound
=
true
;
}
}
}
}
if
(
!
isCollapsed
)
{
RefPtr
<
nsRange
>
currange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
currange
)
{
nsresult
rv
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
do_CreateInstance
(
"
mozilla
.
org
/
content
/
post
-
content
-
iterator
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
iter
-
>
Init
(
currange
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
selectedElement
=
do_QueryInterface
(
iter
-
>
GetCurrentNode
(
)
)
;
if
(
selectedElement
)
{
if
(
bNodeFound
)
{
bNodeFound
=
false
;
break
;
}
selectedElement
-
>
GetNodeName
(
domTagName
)
;
ToLowerCase
(
domTagName
)
;
if
(
anyTag
)
{
selectedElement
-
>
GetTagName
(
TagName
)
;
ToLowerCase
(
TagName
)
;
anyTag
=
false
;
}
nsCOMPtr
<
nsIDOMNode
>
selectedNode
=
do_QueryInterface
(
selectedElement
)
;
if
(
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
selectedNode
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
selectedNode
)
)
)
{
bNodeFound
=
true
;
}
else
if
(
TagName
=
=
domTagName
)
{
bNodeFound
=
true
;
}
if
(
!
bNodeFound
)
{
break
;
}
}
iter
-
>
Next
(
)
;
}
}
else
{
isCollapsed
=
true
;
NS_WARNING
(
"
isCollapsed
was
FALSE
but
no
elements
found
in
selection
\
n
"
)
;
}
}
}
if
(
!
bNodeFound
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
*
aReturn
=
selectedElement
;
if
(
selectedElement
)
{
NS_ADDREF
(
*
aReturn
)
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
)
{
MOZ_ASSERT
(
!
aTagName
.
IsEmpty
(
)
)
;
nsAutoString
tagName
(
aTagName
)
;
ToLowerCase
(
tagName
)
;
nsAutoString
realTagName
;
if
(
IsLinkTag
(
tagName
)
|
|
IsNamedAnchorTag
(
tagName
)
)
{
realTagName
.
Assign
(
'
a
'
)
;
}
else
{
realTagName
=
tagName
;
}
RefPtr
<
nsAtom
>
realTagAtom
=
NS_Atomize
(
realTagName
)
;
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
realTagAtom
)
;
if
(
!
newElement
)
{
return
nullptr
;
}
ErrorResult
rv
;
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
_moz_dirty
"
)
EmptyString
(
)
rv
)
;
if
(
tagName
.
EqualsLiteral
(
"
table
"
)
)
{
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellpadding
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellspacing
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
border
"
)
NS_LITERAL_STRING
(
"
1
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
}
else
if
(
tagName
.
EqualsLiteral
(
"
td
"
)
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
newElement
nsGkAtoms
:
:
valign
NS_LITERAL_STRING
(
"
top
"
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
nsIDOMElement
*
*
aReturn
)
{
NS_ENSURE_TRUE
(
!
aTagName
.
IsEmpty
(
)
&
&
aReturn
NS_ERROR_NULL_POINTER
)
;
*
aReturn
=
nullptr
;
nsCOMPtr
<
Element
>
newElement
=
CreateElementWithDefaults
(
aTagName
)
;
nsCOMPtr
<
nsIDOMElement
>
ret
=
do_QueryInterface
(
newElement
)
;
NS_ENSURE_TRUE
(
ret
NS_ERROR_FAILURE
)
;
ret
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLinkAroundSelection
(
nsIDOMElement
*
aAnchorElement
)
{
NS_ENSURE_TRUE
(
aAnchorElement
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
if
(
selection
-
>
Collapsed
(
)
)
{
NS_WARNING
(
"
InsertLinkAroundSelection
called
but
there
is
no
selection
!
!
!
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aAnchorElement
)
;
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromContentOrNull
(
content
)
;
if
(
!
anchor
)
{
return
NS_OK
;
}
nsAutoString
href
;
anchor
-
>
GetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
nsCOMPtr
<
nsIDOMMozNamedAttrMap
>
attrMap
;
aAnchorElement
-
>
GetAttributes
(
getter_AddRefs
(
attrMap
)
)
;
NS_ENSURE_TRUE
(
attrMap
NS_ERROR_FAILURE
)
;
uint32_t
count
;
attrMap
-
>
GetLength
(
&
count
)
;
nsAutoString
name
value
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsIDOMAttr
>
attribute
;
rv
=
attrMap
-
>
Item
(
i
getter_AddRefs
(
attribute
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
attribute
)
{
name
.
Truncate
(
)
;
value
.
Truncate
(
)
;
rv
=
attribute
-
>
GetName
(
name
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
attribute
-
>
GetValue
(
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetInlineProperty
(
nsGkAtoms
:
:
a
name
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetHTMLBackgroundColor
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
nsCOMPtr
<
nsIDOMElement
>
element
;
int32_t
selectedCount
;
nsAutoString
tagName
;
nsresult
rv
=
GetSelectedOrParentTableElement
(
tagName
&
selectedCount
getter_AddRefs
(
element
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
setColor
=
!
aColor
.
IsEmpty
(
)
;
NS_NAMED_LITERAL_STRING
(
bgcolor
"
bgcolor
"
)
;
if
(
element
)
{
if
(
selectedCount
>
0
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
while
(
cell
)
{
rv
=
setColor
?
SetAttribute
(
cell
bgcolor
aColor
)
:
RemoveAttribute
(
cell
bgcolor
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
}
return
NS_OK
;
}
}
}
else
{
element
=
do_QueryInterface
(
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
element
NS_ERROR_NULL_POINTER
)
;
}
return
setColor
?
SetAttribute
(
element
bgcolor
aColor
)
:
RemoveAttribute
(
element
bgcolor
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBodyAttribute
(
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
nsCOMPtr
<
nsIDOMElement
>
bodyElement
=
do_QueryInterface
(
GetRoot
(
)
)
;
NS_ENSURE_TRUE
(
bodyElement
NS_ERROR_NULL_POINTER
)
;
return
SetAttribute
(
bodyElement
aAttribute
aValue
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetLinkedObjects
(
nsIArray
*
*
aNodeList
)
{
NS_ENSURE_TRUE
(
aNodeList
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
;
nsCOMPtr
<
nsIMutableArray
>
nodes
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
do_CreateInstance
(
"
mozilla
.
org
/
content
/
post
-
content
-
iterator
;
1
"
&
rv
)
;
NS_ENSURE_TRUE
(
iter
NS_ERROR_NULL_POINTER
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_UNEXPECTED
)
;
iter
-
>
Init
(
doc
-
>
GetRootElement
(
)
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsIDOMNode
>
node
(
do_QueryInterface
(
iter
-
>
GetCurrentNode
(
)
)
)
;
if
(
node
)
{
nsCOMPtr
<
nsIURIRefObject
>
refObject
;
rv
=
NS_NewHTMLURIRefObject
(
getter_AddRefs
(
refObject
)
node
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nodes
-
>
AppendElement
(
refObject
false
)
;
}
}
iter
-
>
Next
(
)
;
}
}
nodes
.
forget
(
aNodeList
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddStyleSheet
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
return
NS_OK
;
}
mLastStyleSheetURL
.
Truncate
(
)
;
return
ReplaceStyleSheet
(
aURL
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ReplaceStyleSheet
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
if
(
!
mLastStyleSheetURL
.
IsEmpty
(
)
&
&
!
mLastStyleSheetURL
.
Equals
(
aURL
)
)
{
return
EnableStyleSheet
(
mLastStyleSheetURL
false
)
;
}
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIURI
>
uaURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
aURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ps
-
>
GetDocument
(
)
-
>
CSSLoader
(
)
-
>
LoadSheet
(
uaURI
false
nullptr
nullptr
this
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveStyleSheet
(
const
nsAString
&
aURL
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
NS_ENSURE_TRUE
(
sheet
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
RemoveStyleSheetTransaction
>
transaction
=
CreateTxnForRemoveStyleSheet
(
sheet
)
;
if
(
!
transaction
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsresult
rv
=
DoTransaction
(
transaction
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mLastStyleSheetURL
.
Truncate
(
)
;
}
return
RemoveStyleSheetFromList
(
aURL
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIURI
>
uaURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
aURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
StyleSheet
>
sheet
;
rv
=
ps
-
>
GetDocument
(
)
-
>
CSSLoader
(
)
-
>
LoadSheetSync
(
uaURI
mozilla
:
:
css
:
:
eAgentSheetFeatures
true
&
sheet
)
;
NS_ENSURE_TRUE
(
sheet
NS_ERROR_NULL_POINTER
)
;
ps
-
>
AddOverrideStyleSheet
(
sheet
)
;
ps
-
>
RestyleForCSSRuleChanges
(
)
;
mLastOverrideStyleSheetURL
=
aURL
;
return
AddNewStyleSheetToList
(
aURL
sheet
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ReplaceOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
&
&
!
mLastOverrideStyleSheetURL
.
Equals
(
aURL
)
)
{
return
EnableStyleSheet
(
mLastOverrideStyleSheetURL
false
)
;
}
return
NS_OK
;
}
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
)
{
RemoveOverrideStyleSheet
(
mLastOverrideStyleSheetURL
)
;
}
return
AddOverrideStyleSheet
(
aURL
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
nsresult
rv
=
RemoveStyleSheetFromList
(
aURL
)
;
NS_ENSURE_TRUE
(
sheet
NS_OK
)
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
ps
-
>
RemoveOverrideStyleSheet
(
sheet
)
;
ps
-
>
RestyleForCSSRuleChanges
(
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
EnableStyleSheet
(
const
nsAString
&
aURL
bool
aEnable
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
NS_ENSURE_TRUE
(
sheet
NS_OK
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocument
(
document
StyleSheet
:
:
NotOwnedByDocument
)
;
return
sheet
-
>
SetDisabled
(
!
aEnable
)
;
}
bool
HTMLEditor
:
:
EnableExistingStyleSheet
(
const
nsAString
&
aURL
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
if
(
!
sheet
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocument
(
document
StyleSheet
:
:
NotOwnedByDocument
)
;
if
(
sheet
-
>
IsServo
(
)
)
{
NS_ERROR
(
"
stylo
:
ServoStyleSheets
can
'
t
be
disabled
yet
"
)
;
return
true
;
}
sheet
-
>
AsGecko
(
)
-
>
SetDisabled
(
false
)
;
return
true
;
}
nsresult
HTMLEditor
:
:
AddNewStyleSheetToList
(
const
nsAString
&
aURL
StyleSheet
*
aStyleSheet
)
{
uint32_t
countSS
=
mStyleSheets
.
Length
(
)
;
uint32_t
countU
=
mStyleSheetURLs
.
Length
(
)
;
if
(
countSS
!
=
countU
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mStyleSheetURLs
.
AppendElement
(
aURL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mStyleSheets
.
AppendElement
(
aStyleSheet
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
nsresult
HTMLEditor
:
:
RemoveStyleSheetFromList
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
;
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
NS_ERROR_FAILURE
;
}
mStyleSheets
.
RemoveElementAt
(
foundIndex
)
;
mStyleSheetURLs
.
RemoveElementAt
(
foundIndex
)
;
return
NS_OK
;
}
StyleSheet
*
HTMLEditor
:
:
GetStyleSheetForURL
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
;
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mStyleSheets
[
foundIndex
]
)
;
return
mStyleSheets
[
foundIndex
]
;
}
void
HTMLEditor
:
:
GetURLForStyleSheet
(
StyleSheet
*
aStyleSheet
nsAString
&
aURL
)
{
int32_t
foundIndex
=
mStyleSheets
.
IndexOf
(
aStyleSheet
)
;
if
(
foundIndex
=
=
-
1
)
{
return
;
}
aURL
=
mStyleSheetURLs
[
foundIndex
]
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetEmbeddedObjects
(
nsIArray
*
*
aNodeList
)
{
NS_ENSURE_TRUE
(
aNodeList
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
;
nsCOMPtr
<
nsIMutableArray
>
nodes
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
do_CreateInstance
(
"
mozilla
.
org
/
content
/
post
-
content
-
iterator
;
1
"
&
rv
)
;
NS_ENSURE_TRUE
(
iter
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_UNEXPECTED
)
;
iter
-
>
Init
(
doc
-
>
GetRootElement
(
)
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
element
=
node
-
>
AsElement
(
)
;
if
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
a
)
|
|
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
background
)
)
)
{
nsCOMPtr
<
nsIDOMNode
>
domNode
=
do_QueryInterface
(
node
)
;
nodes
-
>
AppendElement
(
domNode
false
)
;
}
}
iter
-
>
Next
(
)
;
}
nodes
.
forget
(
aNodeList
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteSelectionImpl
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
nsresult
rv
=
EditorBase
:
:
DeleteSelectionImpl
(
aAction
aStripWrappers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aStripWrappers
=
=
eNoStrip
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorFocusRange
(
)
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorNode
(
)
-
>
IsContent
(
)
)
;
nsCOMPtr
<
nsIContent
>
content
=
selection
-
>
GetAnchorNode
(
)
-
>
AsContent
(
)
;
nsCOMPtr
<
nsIContent
>
blockParent
=
content
;
while
(
blockParent
&
&
!
IsBlockNode
(
blockParent
)
)
{
blockParent
=
blockParent
-
>
GetParent
(
)
;
}
if
(
!
blockParent
)
{
return
NS_OK
;
}
bool
emptyBlockParent
;
rv
=
IsEmptyNode
(
blockParent
&
emptyBlockParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
emptyBlockParent
)
{
return
NS_OK
;
}
if
(
content
&
&
!
IsBlockNode
(
content
)
&
&
!
content
-
>
Length
(
)
&
&
content
-
>
IsEditable
(
)
&
&
content
!
=
content
-
>
GetEditingHost
(
)
)
{
while
(
content
-
>
GetParent
(
)
&
&
!
IsBlockNode
(
content
-
>
GetParent
(
)
)
&
&
content
-
>
GetParent
(
)
-
>
Length
(
)
=
=
1
&
&
content
-
>
GetParent
(
)
-
>
IsEditable
(
)
&
&
content
-
>
GetParent
(
)
!
=
content
-
>
GetEditingHost
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
rv
=
DeleteNode
(
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteNode
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIDOMNode
>
node
=
do_QueryInterface
(
aNode
)
;
return
DeleteNode
(
node
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteNode
(
nsIDOMNode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
if
(
NS_WARN_IF
(
!
IsModifiableNode
(
aNode
)
&
&
!
IsMozEditorBogusNode
(
content
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
DeleteNode
(
aNode
)
;
}
nsresult
HTMLEditor
:
:
DeleteText
(
nsGenericDOMDataNode
&
aCharData
uint32_t
aOffset
uint32_t
aLength
)
{
if
(
!
IsModifiableNode
(
&
aCharData
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
DeleteText
(
aCharData
aOffset
aLength
)
;
}
nsresult
HTMLEditor
:
:
InsertTextImpl
(
const
nsAString
&
aStringToInsert
nsCOMPtr
<
nsINode
>
*
aInOutNode
nsCOMPtr
<
nsIContent
>
*
aInOutChildAtOffset
int32_t
*
aInOutOffset
nsIDocument
*
aDoc
)
{
if
(
!
IsModifiableNode
(
*
aInOutNode
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
InsertTextImpl
(
aStringToInsert
aInOutNode
aInOutChildAtOffset
aInOutOffset
aDoc
)
;
}
void
HTMLEditor
:
:
ContentAppended
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
{
DoContentInserted
(
aDocument
aContainer
aFirstNewContent
eAppended
)
;
}
void
HTMLEditor
:
:
ContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
DoContentInserted
(
aDocument
aContainer
aChild
eInserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
Element
*
root
=
GetRoot
(
)
;
if
(
root
&
&
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
GetBindingParent
(
)
!
=
aChild
-
>
GetBindingParent
(
)
)
)
{
return
false
;
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
GetBindingParent
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
InsertedOrAppended
aInsertedOrAppended
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
NODE_FROM
(
aContainer
aDocument
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aDocument
aContainer
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
ShouldReplaceRootElement
(
)
)
{
UpdateRootElement
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
mAction
&
&
container
-
>
IsEditable
(
)
)
{
if
(
IsMozEditorBogusNode
(
aChild
)
)
{
return
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
rules
-
>
DocumentModified
(
)
;
if
(
mInlineSpellChecker
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aChild
)
;
nsIContent
*
endContent
=
aChild
;
if
(
aInsertedOrAppended
=
=
eAppended
)
{
endContent
=
container
-
>
GetLastChild
(
)
;
}
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
}
}
}
void
HTMLEditor
:
:
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
IsInObservedSubtree
(
aDocument
aContainer
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
SameCOMIdentity
(
aChild
mRootElement
)
)
{
mRootElement
=
nullptr
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
mAction
&
&
(
aContainer
?
aContainer
-
>
IsEditable
(
)
:
aDocument
-
>
IsEditable
(
)
)
)
{
if
(
aChild
&
&
IsMozEditorBogusNode
(
aChild
)
)
{
return
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
rules
-
>
DocumentModified
(
)
;
}
}
NS_IMETHODIMP_
(
bool
)
HTMLEditor
:
:
IsModifiableNode
(
nsIDOMNode
*
aNode
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
return
IsModifiableNode
(
node
)
;
}
bool
HTMLEditor
:
:
IsModifiableNode
(
nsINode
*
aNode
)
{
return
!
aNode
|
|
aNode
-
>
IsEditable
(
)
;
}
static
nsresult
SetSelectionAroundHeadChildren
(
Selection
*
aSelection
nsCOMPtr
<
nsIDocument
>
&
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
dom
:
:
Element
*
headNode
=
aDocument
-
>
GetHeadElement
(
)
;
NS_ENSURE_STATE
(
headNode
)
;
nsresult
rv
=
aSelection
-
>
Collapse
(
headNode
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
childCount
=
headNode
-
>
GetChildCount
(
)
;
return
aSelection
-
>
Extend
(
headNode
childCount
+
1
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHeadContentsAsHTML
(
nsAString
&
aOutputString
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
SetSelectionAroundHeadChildren
(
selection
document
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
OutputToString
(
NS_LITERAL_STRING
(
"
text
/
html
"
)
nsIDocumentEncoder
:
:
OutputSelectionOnly
aOutputString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsReadingIterator
<
char16_t
>
findIter
endFindIter
;
aOutputString
.
BeginReading
(
findIter
)
;
aOutputString
.
EndReading
(
endFindIter
)
;
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
body
"
)
findIter
endFindIter
)
)
{
nsReadingIterator
<
char16_t
>
beginIter
;
aOutputString
.
BeginReading
(
beginIter
)
;
int32_t
offset
=
Distance
(
beginIter
findIter
)
;
nsWritingIterator
<
char16_t
>
writeIter
;
aOutputString
.
BeginWriting
(
writeIter
)
;
char16_t
newline
(
'
\
n
'
)
;
findIter
.
advance
(
-
1
)
;
if
(
!
offset
|
|
(
offset
>
0
&
&
(
*
findIter
)
!
=
newline
)
)
{
writeIter
.
advance
(
offset
)
;
*
writeIter
=
newline
;
aOutputString
.
Truncate
(
offset
+
1
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DebugUnitTests
(
int32_t
*
outNumTests
int32_t
*
outNumTestsFailed
)
{
#
ifdef
DEBUG
NS_ENSURE_TRUE
(
outNumTests
&
&
outNumTestsFailed
NS_ERROR_NULL_POINTER
)
;
TextEditorTest
*
tester
=
new
TextEditorTest
(
)
;
NS_ENSURE_TRUE
(
tester
NS_ERROR_OUT_OF_MEMORY
)
;
tester
-
>
Run
(
this
outNumTests
outNumTestsFailed
)
;
delete
tester
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
NS_IMETHODIMP
HTMLEditor
:
:
StyleSheetLoaded
(
StyleSheet
*
aSheet
bool
aWasAlternate
nsresult
aStatus
)
{
AutoPlaceholderBatch
batchIt
(
this
)
;
if
(
!
mLastStyleSheetURL
.
IsEmpty
(
)
)
RemoveStyleSheet
(
mLastStyleSheetURL
)
;
RefPtr
<
AddStyleSheetTransaction
>
transaction
=
CreateTxnForAddStyleSheet
(
aSheet
)
;
if
(
!
transaction
)
{
return
NS_OK
;
}
nsresult
rv
=
DoTransaction
(
transaction
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
spec
;
rv
=
aSheet
-
>
GetSheetURI
(
)
-
>
GetSpec
(
spec
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyASCIItoUTF16
(
spec
mLastStyleSheetURL
)
;
AddNewStyleSheetToList
(
mLastStyleSheetURL
aSheet
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
StartOperation
(
EditAction
opID
nsIEditor
:
:
EDirection
aDirection
)
{
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
EditorBase
:
:
StartOperation
(
opID
aDirection
)
;
if
(
rules
)
{
return
rules
-
>
BeforeEdit
(
mAction
mDirection
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
EndOperation
(
)
{
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
nsresult
rv
=
rules
?
rules
-
>
AfterEdit
(
mAction
mDirection
)
:
NS_OK
;
EditorBase
:
:
EndOperation
(
)
;
return
rv
;
}
bool
HTMLEditor
:
:
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
{
int32_t
childTagEnum
;
if
(
&
aChildTag
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildTag
)
;
}
int32_t
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentTag
)
;
return
HTMLEditUtils
:
:
CanContain
(
parentTagEnum
childTagEnum
)
;
}
bool
HTMLEditor
:
:
IsContainer
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
int32_t
tagEnum
;
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aNode
-
>
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainer
(
tagEnum
)
;
}
bool
HTMLEditor
:
:
IsContainer
(
nsIDOMNode
*
aNode
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
if
(
!
node
)
{
return
false
;
}
return
IsContainer
(
node
)
;
}
nsresult
HTMLEditor
:
:
SelectEntireDocument
(
Selection
*
aSelection
)
{
if
(
!
aSelection
|
|
!
mRules
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
if
(
rules
-
>
DocumentIsEmpty
(
)
)
{
Element
*
rootElement
=
GetRoot
(
)
;
return
aSelection
-
>
Collapse
(
rootElement
0
)
;
}
return
EditorBase
:
:
SelectEntireDocument
(
aSelection
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectAll
(
)
{
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
nsINode
*
anchorNode
=
selection
-
>
GetAnchorNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
anchorNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
anchorContent
=
anchorNode
-
>
AsContent
(
)
;
nsIContent
*
rootContent
;
if
(
anchorContent
-
>
HasIndependentSelection
(
)
)
{
nsresult
rv
=
selection
-
>
SetAncestorLimiter
(
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rootContent
=
mRootElement
;
}
else
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
rootContent
=
anchorContent
-
>
GetSelectionRootContent
(
ps
)
;
}
NS_ENSURE_TRUE
(
rootContent
NS_ERROR_UNEXPECTED
)
;
Maybe
<
mozilla
:
:
dom
:
:
Selection
:
:
AutoUserInitiated
>
userSelection
;
if
(
!
rootContent
-
>
IsEditable
(
)
)
{
userSelection
.
emplace
(
selection
)
;
}
ErrorResult
errorResult
;
selection
-
>
SelectAllChildren
(
*
rootContent
errorResult
)
;
return
errorResult
.
StealNSResult
(
)
;
}
bool
HTMLEditor
:
:
IsTextPropertySetByContent
(
nsINode
*
aNode
nsAtom
*
aProperty
const
nsAString
*
aAttribute
const
nsAString
*
aValue
nsAString
*
outValue
)
{
MOZ_ASSERT
(
aNode
&
&
aProperty
)
;
bool
isSet
;
IsTextPropertySetByContent
(
aNode
-
>
AsDOMNode
(
)
aProperty
aAttribute
aValue
isSet
outValue
)
;
return
isSet
;
}
void
HTMLEditor
:
:
IsTextPropertySetByContent
(
nsIDOMNode
*
aNode
nsAtom
*
aProperty
const
nsAString
*
aAttribute
const
nsAString
*
aValue
bool
&
aIsSet
nsAString
*
outValue
)
{
aIsSet
=
false
;
nsAutoString
propName
;
aProperty
-
>
ToString
(
propName
)
;
nsCOMPtr
<
nsIDOMNode
>
node
=
aNode
;
while
(
node
)
{
nsCOMPtr
<
nsIDOMElement
>
element
;
element
=
do_QueryInterface
(
node
)
;
if
(
element
)
{
nsAutoString
tag
value
;
element
-
>
GetTagName
(
tag
)
;
if
(
propName
.
Equals
(
tag
nsCaseInsensitiveStringComparator
(
)
)
)
{
bool
found
=
false
;
if
(
aAttribute
&
&
!
aAttribute
-
>
IsEmpty
(
)
)
{
element
-
>
GetAttribute
(
*
aAttribute
value
)
;
if
(
outValue
)
{
*
outValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
found
=
true
;
}
else
{
nsString
tString
(
*
aValue
)
;
if
(
tString
.
Equals
(
value
nsCaseInsensitiveStringComparator
(
)
)
)
{
found
=
true
;
}
else
{
break
;
}
}
}
}
else
{
found
=
true
;
}
if
(
found
)
{
aIsSet
=
true
;
break
;
}
}
}
nsCOMPtr
<
nsIDOMNode
>
temp
;
if
(
NS_SUCCEEDED
(
node
-
>
GetParentNode
(
getter_AddRefs
(
temp
)
)
)
&
&
temp
)
{
node
=
temp
;
}
else
{
node
=
nullptr
;
}
}
}
bool
HTMLEditor
:
:
SetCaretInTableCell
(
nsIDOMElement
*
aElement
)
{
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aElement
)
;
if
(
!
element
|
|
!
element
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
element
)
|
|
!
IsDescendantOfEditorRoot
(
element
)
)
{
return
false
;
}
nsIContent
*
node
=
element
;
while
(
node
-
>
HasChildren
(
)
)
{
node
=
node
-
>
GetFirstChild
(
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
false
)
;
return
NS_SUCCEEDED
(
selection
-
>
Collapse
(
node
0
)
)
;
}
Element
*
HTMLEditor
:
:
GetEnclosingTable
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
for
(
nsCOMPtr
<
Element
>
block
=
GetBlockNodeParent
(
aNode
)
;
block
;
block
=
GetBlockNodeParent
(
block
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
block
)
)
{
return
block
;
}
}
return
nullptr
;
}
nsIDOMNode
*
HTMLEditor
:
:
GetEnclosingTable
(
nsIDOMNode
*
aNode
)
{
NS_PRECONDITION
(
aNode
"
null
node
passed
to
HTMLEditor
:
:
GetEnclosingTable
"
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
node
nullptr
)
;
nsCOMPtr
<
Element
>
table
=
GetEnclosingTable
(
node
)
;
nsCOMPtr
<
nsIDOMNode
>
ret
=
do_QueryInterface
(
table
)
;
return
ret
;
}
nsresult
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
nsRange
*
aInRange
)
{
NS_ENSURE_TRUE
(
aInRange
NS_ERROR_NULL_POINTER
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
this
)
;
nsTArray
<
nsCOMPtr
<
nsIDOMNode
>
>
textNodes
;
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
do_CreateInstance
(
"
mozilla
.
org
/
content
/
subtree
-
content
-
iterator
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
iter
-
>
Init
(
aInRange
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
&
&
IsEditable
(
static_cast
<
nsIContent
*
>
(
node
)
)
)
{
nsCOMPtr
<
nsIDOMNode
>
domNode
=
do_QueryInterface
(
node
)
;
textNodes
.
AppendElement
(
domNode
)
;
}
iter
-
>
Next
(
)
;
}
while
(
textNodes
.
Length
(
)
>
1
)
{
nsIDOMNode
*
leftTextNode
=
textNodes
[
0
]
;
nsIDOMNode
*
rightTextNode
=
textNodes
[
1
]
;
NS_ASSERTION
(
leftTextNode
&
&
rightTextNode
"
left
or
rightTextNode
null
in
CollapseAdjacentTextNodes
"
)
;
nsCOMPtr
<
nsIDOMNode
>
prevSibOfRightNode
;
rv
=
rightTextNode
-
>
GetPreviousSibling
(
getter_AddRefs
(
prevSibOfRightNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
prevSibOfRightNode
&
&
prevSibOfRightNode
=
=
leftTextNode
)
{
nsCOMPtr
<
nsIDOMNode
>
parent
;
rv
=
rightTextNode
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
rv
=
JoinNodes
(
leftTextNode
rightTextNode
parent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
textNodes
.
RemoveElementAt
(
0
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
Selection
*
aSelection
)
{
dom
:
:
Element
*
rootElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootElement
NS_ERROR_NULL_POINTER
)
;
return
aSelection
-
>
Collapse
(
rootElement
0
)
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainer
(
nsIContent
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetFirstEditableChild
(
aNode
)
;
if
(
child
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aNode
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsBlockNode
(
child
)
)
{
nsCOMPtr
<
Element
>
br
=
CreateBR
(
&
aNode
0
)
;
NS_ENSURE_STATE
(
br
)
;
}
sibling
=
GetNextHTMLSibling
(
&
aNode
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
)
{
child
=
GetLastEditableChild
(
aNode
)
;
MOZ_ASSERT
(
child
"
aNode
has
first
editable
child
but
not
last
?
"
)
;
if
(
!
IsBlockNode
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
nsCOMPtr
<
Element
>
br
=
CreateBR
(
&
aNode
aNode
.
Length
(
)
)
;
NS_ENSURE_STATE
(
br
)
;
}
}
}
else
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aNode
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
sibling
=
GetNextHTMLSibling
(
&
aNode
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
nsCOMPtr
<
Element
>
br
=
CreateBR
(
&
aNode
0
)
;
NS_ENSURE_STATE
(
br
)
;
}
}
}
nsresult
rv
=
RemoveContainer
(
&
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLSibling
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetPreviousSibling
(
)
;
while
(
node
&
&
!
IsEditable
(
node
)
)
{
node
=
node
-
>
GetPreviousSibling
(
)
;
}
return
node
;
}
nsresult
HTMLEditor
:
:
GetPriorHTMLSibling
(
nsIDOMNode
*
inNode
nsCOMPtr
<
nsIDOMNode
>
*
outNode
)
{
NS_ENSURE_TRUE
(
outNode
NS_ERROR_NULL_POINTER
)
;
*
outNode
=
nullptr
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
inNode
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
*
outNode
=
do_QueryInterface
(
GetPriorHTMLSibling
(
node
)
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLSibling
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetNextSibling
(
)
;
while
(
node
&
&
!
IsEditable
(
node
)
)
{
node
=
node
-
>
GetNextSibling
(
)
;
}
return
node
;
}
nsresult
HTMLEditor
:
:
GetNextHTMLSibling
(
nsIDOMNode
*
inNode
nsCOMPtr
<
nsIDOMNode
>
*
outNode
)
{
NS_ENSURE_TRUE
(
outNode
NS_ERROR_NULL_POINTER
)
;
*
outNode
=
nullptr
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
inNode
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
*
outNode
=
do_QueryInterface
(
GetNextHTMLSibling
(
node
)
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLNode
(
nsINode
*
aNode
bool
aNoBlockCrossing
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
GetPriorNode
(
aNode
true
aNoBlockCrossing
)
;
}
nsresult
HTMLEditor
:
:
GetPriorHTMLNode
(
nsIDOMNode
*
aNode
nsCOMPtr
<
nsIDOMNode
>
*
aResultNode
bool
aNoBlockCrossing
)
{
NS_ENSURE_TRUE
(
aResultNode
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
*
aResultNode
=
do_QueryInterface
(
GetPriorHTMLNode
(
node
aNoBlockCrossing
)
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLNode
(
nsINode
*
aParent
int32_t
aOffset
nsINode
*
aChildAtOffset
bool
aNoBlockCrossing
)
{
MOZ_ASSERT
(
aParent
)
;
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
GetPriorNode
(
aParent
aOffset
aChildAtOffset
true
aNoBlockCrossing
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLNode
(
nsINode
*
aNode
bool
aNoBlockCrossing
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
result
=
GetNextNode
(
aNode
true
aNoBlockCrossing
)
;
if
(
result
&
&
!
IsDescendantOfEditorRoot
(
result
)
)
{
return
nullptr
;
}
return
result
;
}
nsresult
HTMLEditor
:
:
GetNextHTMLNode
(
nsIDOMNode
*
aNode
nsCOMPtr
<
nsIDOMNode
>
*
aResultNode
bool
aNoBlockCrossing
)
{
NS_ENSURE_TRUE
(
aResultNode
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_NULL_POINTER
)
;
*
aResultNode
=
do_QueryInterface
(
GetNextHTMLNode
(
node
aNoBlockCrossing
)
)
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLNode
(
nsINode
*
aParent
int32_t
aOffset
nsINode
*
aChildAtOffset
bool
aNoBlockCrossing
)
{
nsIContent
*
content
=
GetNextNode
(
aParent
aOffset
aChildAtOffset
true
aNoBlockCrossing
)
;
if
(
content
&
&
!
IsDescendantOfEditorRoot
(
content
)
)
{
return
nullptr
;
}
return
content
;
}
bool
HTMLEditor
:
:
IsFirstEditableChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetFirstEditableChild
(
*
parent
)
=
=
aNode
)
;
}
bool
HTMLEditor
:
:
IsLastEditableChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetLastEditableChild
(
*
parent
)
=
=
aNode
)
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableChild
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetNextSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableChild
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetLeftmostChild
(
&
aNode
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetNextHTMLNode
(
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetRightmostChild
(
&
aNode
false
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetPriorHTMLNode
(
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
nsresult
HTMLEditor
:
:
IsVisTextNode
(
nsIContent
*
aNode
bool
*
outIsEmptyNode
bool
aSafeToAskFrames
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aNode
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
;
MOZ_ASSERT
(
outIsEmptyNode
)
;
*
outIsEmptyNode
=
true
;
uint32_t
length
=
aNode
-
>
TextLength
(
)
;
if
(
aSafeToAskFrames
)
{
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
isVisible
=
false
;
nsresult
rv
=
selectionController
-
>
CheckVisibilityContent
(
aNode
0
length
&
isVisible
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isVisible
)
{
*
outIsEmptyNode
=
false
;
}
}
else
if
(
length
)
{
if
(
aNode
-
>
TextIsOnlyWhitespace
(
)
)
{
WSRunObject
wsRunObj
(
this
aNode
0
)
;
nsCOMPtr
<
nsINode
>
visNode
;
int32_t
outVisOffset
=
0
;
WSType
visType
;
wsRunObj
.
NextVisibleNode
(
aNode
0
address_of
(
visNode
)
&
outVisOffset
&
visType
)
;
if
(
visType
=
=
WSType
:
:
normalWS
|
|
visType
=
=
WSType
:
:
text
)
{
*
outIsEmptyNode
=
(
aNode
!
=
visNode
)
;
}
}
else
{
*
outIsEmptyNode
=
false
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
IsEmptyNode
(
nsIDOMNode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
return
IsEmptyNode
(
node
outIsEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
)
;
}
nsresult
HTMLEditor
:
:
IsEmptyNode
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
)
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
NS_ERROR_NULL_POINTER
)
;
*
outIsEmptyNode
=
true
;
bool
seenBR
=
false
;
return
IsEmptyNodeImpl
(
aNode
outIsEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
&
seenBR
)
;
}
nsresult
HTMLEditor
:
:
IsEmptyNodeImpl
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
bool
*
aSeenBR
)
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
&
&
aSeenBR
NS_ERROR_NULL_POINTER
)
;
if
(
aNode
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
{
return
IsVisTextNode
(
static_cast
<
nsIContent
*
>
(
aNode
)
outIsEmptyNode
aSafeToAskFrames
)
;
}
if
(
!
IsContainer
(
aNode
-
>
AsDOMNode
(
)
)
|
|
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aNode
)
|
|
HTMLEditUtils
:
:
IsFormWidget
(
aNode
)
|
|
(
aListOrCellNotEmpty
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
)
)
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
bool
isListItemOrCell
=
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorBase
:
:
IsEditable
(
child
)
)
{
if
(
child
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
{
nsresult
rv
=
IsVisTextNode
(
child
outIsEmptyNode
aSafeToAskFrames
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
*
outIsEmptyNode
)
{
return
NS_OK
;
}
}
else
{
if
(
child
=
=
aNode
)
{
break
;
}
if
(
aSingleBRDoesntCount
&
&
!
*
aSeenBR
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
*
aSeenBR
=
true
;
}
else
{
if
(
child
-
>
IsElement
(
)
)
{
if
(
isListItemOrCell
)
{
if
(
HTMLEditUtils
:
:
IsList
(
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
else
if
(
HTMLEditUtils
:
:
IsFormWidget
(
child
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
bool
isEmptyNode
=
true
;
nsresult
rv
=
IsEmptyNodeImpl
(
child
&
isEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
aSeenBR
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isEmptyNode
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
IsCSSEnabled
(
)
|
|
!
mCSSEditUtils
)
{
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttribute
(
aElement
aAttribute
aValue
)
;
}
int32_t
count
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
&
aValue
aSuppressTransaction
)
;
if
(
count
)
{
nsAutoString
existingValue
;
if
(
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
existingValue
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttribute
(
aElement
aAttribute
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
nsAutoString
existingValue
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
)
;
existingValue
.
Append
(
'
'
)
;
existingValue
.
Append
(
aValue
)
;
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
existingValue
true
)
:
SetAttribute
(
aElement
aAttribute
existingValue
)
;
}
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttribute
(
aElement
aAttribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttribute
(
aElement
aAttribute
)
;
}
nsresult
HTMLEditor
:
:
SetIsCSSEnabled
(
bool
aIsCSSPrefChecked
)
{
if
(
!
mCSSEditUtils
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mCSSEditUtils
-
>
SetCSSEnabled
(
aIsCSSPrefChecked
)
;
uint32_t
flags
=
mFlags
;
if
(
aIsCSSPrefChecked
)
{
flags
&
=
~
eEditorNoCSSMask
;
}
else
{
flags
|
=
eEditorNoCSSMask
;
}
return
SetFlags
(
flags
)
;
}
nsresult
HTMLEditor
:
:
SetCSSBackgroundColor
(
const
nsAString
&
aColor
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
CommitComposition
(
)
;
nsCOMPtr
<
nsIEditRules
>
rules
(
mRules
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
bool
isCollapsed
=
selection
-
>
Collapsed
(
)
;
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertElement
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
this
)
;
bool
cancel
handled
;
TextRulesInfo
ruleInfo
(
EditAction
:
:
setTextProperty
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
&
ruleInfo
&
cancel
&
handled
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cancel
&
&
!
handled
)
{
for
(
uint32_t
i
=
0
;
i
<
selection
-
>
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Element
>
cachedBlockParent
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
if
(
startNode
=
=
endNode
&
&
IsTextNode
(
startNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
else
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
isCollapsed
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
startNode
-
>
AsElement
(
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
else
if
(
startNode
=
=
endNode
&
&
(
endOffset
-
startOffset
=
=
1
|
|
(
!
startOffset
&
&
!
endOffset
)
)
)
{
nsCOMPtr
<
nsIContent
>
selectedNode
=
range
-
>
GetChildAtStartOffset
(
)
;
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
selectedNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
else
{
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsCOMPtr
<
nsINode
>
node
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
node
=
do_QueryInterface
(
iter
-
>
GetCurrentNode
(
)
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
IsTextNode
(
startNode
)
&
&
IsEditable
(
startNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
node
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
arrayOfNodes
.
Clear
(
)
;
if
(
IsTextNode
(
endNode
)
&
&
IsEditable
(
endNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
endNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
}
}
}
if
(
!
cancel
)
{
rv
=
rules
-
>
DidDoAction
(
selection
&
ruleInfo
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBackgroundColor
(
const
nsAString
&
aColor
)
{
if
(
IsCSSEnabled
(
)
)
{
return
SetCSSBackgroundColor
(
aColor
)
;
}
return
SetHTMLBackgroundColor
(
aColor
)
;
}
bool
HTMLEditor
:
:
AreNodesSameType
(
nsIContent
*
aNode1
nsIContent
*
aNode2
)
{
MOZ_ASSERT
(
aNode1
)
;
MOZ_ASSERT
(
aNode2
)
;
if
(
aNode1
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
aNode2
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
false
;
}
if
(
!
IsCSSEnabled
(
)
|
|
!
aNode1
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
return
true
;
}
return
mCSSEditUtils
-
>
ElementsSameStyle
(
aNode1
-
>
AsDOMNode
(
)
aNode2
-
>
AsDOMNode
(
)
)
;
}
nsresult
HTMLEditor
:
:
CopyLastEditableChildStyles
(
nsIDOMNode
*
aPreviousBlock
nsIDOMNode
*
aNewBlock
Element
*
*
aOutBrNode
)
{
nsCOMPtr
<
nsINode
>
newBlock
=
do_QueryInterface
(
aNewBlock
)
;
NS_ENSURE_STATE
(
newBlock
|
|
!
aNewBlock
)
;
*
aOutBrNode
=
nullptr
;
nsCOMPtr
<
nsIDOMNode
>
child
tmp
;
nsresult
rv
=
aNewBlock
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
child
)
{
rv
=
DeleteNode
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aNewBlock
-
>
GetFirstChild
(
getter_AddRefs
(
child
)
)
;
}
child
=
aPreviousBlock
;
tmp
=
aPreviousBlock
;
while
(
tmp
)
{
child
=
tmp
;
nsCOMPtr
<
nsINode
>
child_
=
do_QueryInterface
(
child
)
;
NS_ENSURE_STATE
(
child_
|
|
!
child
)
;
tmp
=
GetAsDOMNode
(
GetLastEditableChild
(
*
child_
)
)
;
}
while
(
child
&
&
TextEditUtils
:
:
IsBreak
(
child
)
)
{
nsCOMPtr
<
nsIDOMNode
>
priorNode
;
rv
=
GetPriorHTMLNode
(
child
address_of
(
priorNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
child
=
priorNode
;
}
nsCOMPtr
<
Element
>
newStyles
deepestStyle
;
nsCOMPtr
<
nsINode
>
childNode
=
do_QueryInterface
(
child
)
;
nsCOMPtr
<
Element
>
childElement
;
if
(
childNode
)
{
childElement
=
childNode
-
>
IsElement
(
)
?
childNode
-
>
AsElement
(
)
:
childNode
-
>
GetParentElement
(
)
;
}
while
(
childElement
&
&
(
childElement
-
>
AsDOMNode
(
)
!
=
aPreviousBlock
)
)
{
if
(
HTMLEditUtils
:
:
IsInlineStyle
(
childElement
)
|
|
childElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
if
(
newStyles
)
{
newStyles
=
InsertContainerAbove
(
newStyles
childElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
NS_ENSURE_STATE
(
newStyles
)
;
}
else
{
deepestStyle
=
newStyles
=
CreateNode
(
childElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
newBlock
0
newBlock
-
>
GetFirstChild
(
)
)
;
NS_ENSURE_STATE
(
newStyles
)
;
}
CloneAttributes
(
newStyles
childElement
)
;
}
childElement
=
childElement
-
>
GetParentElement
(
)
;
}
if
(
deepestStyle
)
{
RefPtr
<
Element
>
retVal
=
CreateBR
(
deepestStyle
0
)
;
retVal
.
forget
(
aOutBrNode
)
;
NS_ENSURE_STATE
(
*
aOutBrNode
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
{
aX
=
0
;
aY
=
0
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_OK
)
;
nsIFrame
*
container
=
ps
-
>
GetAbsoluteContainingBlock
(
frame
)
;
NS_ENSURE_TRUE
(
container
NS_OK
)
;
nsPoint
off
=
frame
-
>
GetOffsetTo
(
container
)
;
aX
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
x
)
;
aY
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
y
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
EndUpdateViewBatch
(
)
{
nsresult
rv
=
EditorBase
:
:
EndUpdateViewBatch
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mUpdateCount
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NOT_INITIALIZED
)
;
return
CheckSelectionStateForAnonymousButtons
(
selection
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectionContainer
(
nsIDOMElement
*
*
aReturn
)
{
nsCOMPtr
<
nsIDOMElement
>
container
=
static_cast
<
nsIDOMElement
*
>
(
GetAsDOMNode
(
GetSelectionContainer
(
)
)
)
;
NS_ENSURE_TRUE
(
container
NS_ERROR_FAILURE
)
;
container
.
forget
(
aReturn
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetSelectionContainer
(
)
{
NS_ENSURE_TRUE
(
GetSelection
(
)
nullptr
)
;
OwningNonNull
<
Selection
>
selection
=
*
GetSelection
(
)
;
nsCOMPtr
<
nsINode
>
focusNode
;
if
(
selection
-
>
Collapsed
(
)
)
{
focusNode
=
selection
-
>
GetFocusNode
(
)
;
}
else
{
int32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
if
(
rangeCount
=
=
1
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
range
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
if
(
startContainer
=
=
endContainer
&
&
startOffset
+
1
=
=
endOffset
)
{
nsCOMPtr
<
nsIDOMElement
>
focusElement
;
nsresult
rv
=
GetSelectedElement
(
EmptyString
(
)
getter_AddRefs
(
focusElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
focusElement
)
{
focusNode
=
do_QueryInterface
(
focusElement
)
;
}
}
if
(
!
focusNode
)
{
focusNode
=
range
-
>
GetCommonAncestor
(
)
;
}
}
else
{
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
!
focusNode
)
{
focusNode
=
startContainer
;
}
else
if
(
focusNode
!
=
startContainer
)
{
focusNode
=
startContainer
-
>
GetParentNode
(
)
;
break
;
}
}
}
}
if
(
focusNode
&
&
focusNode
-
>
GetAsText
(
)
)
{
focusNode
=
focusNode
-
>
GetParentNode
(
)
;
}
if
(
focusNode
&
&
focusNode
-
>
IsElement
(
)
)
{
return
focusNode
-
>
AsElement
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IsAnonymousElement
(
nsIDOMElement
*
aElement
bool
*
aReturn
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aElement
)
;
*
aReturn
=
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
bool
aCreatesNewParagraph
)
{
mCRInParagraphCreatesParagraph
=
aCreatesNewParagraph
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
{
return
mCRInParagraphCreatesParagraph
;
}
nsresult
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
bool
*
aCreatesNewParagraph
)
{
*
aCreatesNewParagraph
=
mCRInParagraphCreatesParagraph
;
return
NS_OK
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetFocusedContent
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
nullptr
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
fm
-
>
GetFocusedContent
(
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
!
focusedContent
)
{
if
(
inDesignMode
&
&
OurWindowHasFocus
(
)
)
{
nsCOMPtr
<
nsIContent
>
rootContent
=
document
-
>
GetRootElement
(
)
;
return
rootContent
.
forget
(
)
;
}
return
nullptr
;
}
if
(
inDesignMode
)
{
return
OurWindowHasFocus
(
)
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedContent
document
)
?
focusedContent
.
forget
(
)
:
nullptr
;
}
if
(
!
focusedContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
focusedContent
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
OurWindowHasFocus
(
)
?
focusedContent
.
forget
(
)
:
nullptr
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetFocusedContentForIME
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
?
nullptr
:
focusedContent
.
forget
(
)
;
}
bool
HTMLEditor
:
:
IsActiveInDOMWindow
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
inDesignMode
)
{
return
true
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
if
(
!
content
)
{
return
false
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
true
;
}
Element
*
HTMLEditor
:
:
GetActiveEditingHost
(
)
{
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
document
-
>
GetBodyElement
(
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
nullptr
)
;
nsINode
*
focusNode
=
selection
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
|
|
NS_WARN_IF
(
!
focusNode
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
focusNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
already_AddRefed
<
EventTarget
>
HTMLEditor
:
:
GetDOMEventTarget
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
has
not
been
initialized
yet
"
)
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
target
=
GetDocument
(
)
;
return
target
.
forget
(
)
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
{
if
(
!
mRootElement
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMHTMLElement
>
docBody
;
GetBodyElement
(
getter_AddRefs
(
docBody
)
)
;
return
!
SameCOMIdentity
(
docBody
mRootElement
)
;
}
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
UpdateRootElement
(
)
;
if
(
!
mRootElement
)
{
return
;
}
rv
=
BeginningOfDocument
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
do_QueryInterface
(
node
)
;
if
(
target
)
{
InitializeSelection
(
target
)
;
}
SyncRealTimeSpell
(
)
;
}
nsresult
HTMLEditor
:
:
GetBodyElement
(
nsIDOMHTMLElement
*
*
aBody
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIDOMHTMLDocument
>
domHTMLDocument
=
do_QueryInterface
(
document
)
;
if
(
!
domHTMLDocument
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
domHTMLDocument
-
>
GetBody
(
aBody
)
;
}
already_AddRefed
<
nsINode
>
HTMLEditor
:
:
GetFocusedNode
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ASSERTION
(
fm
"
Focus
manager
is
null
"
)
;
nsCOMPtr
<
nsIDOMElement
>
focusedElement
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
focusedElement
)
)
;
if
(
focusedElement
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
focusedElement
)
;
return
node
.
forget
(
)
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
return
document
.
forget
(
)
;
}
bool
HTMLEditor
:
:
OurWindowHasFocus
(
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
return
ourWindow
=
=
focusedWindow
;
}
bool
HTMLEditor
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
!
EditorBase
:
:
IsAcceptableInputEvent
(
aGUIEvent
)
)
{
return
false
;
}
if
(
mComposition
&
&
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
aGUIEvent
-
>
GetDOMEventTarget
(
)
;
NS_ENSURE_TRUE
(
target
false
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
nsCOMPtr
<
nsIDocument
>
targetDocument
=
do_QueryInterface
(
target
)
;
if
(
targetDocument
)
{
return
targetDocument
=
=
document
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
return
document
=
=
targetContent
-
>
GetUncomposedDoc
(
)
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
if
(
targetContent
=
=
document
-
>
GetRootElement
(
)
&
&
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
editingHost
=
=
document
-
>
GetBodyElement
(
)
)
{
targetContent
=
editingHost
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
targetContent
editingHost
)
)
{
return
false
;
}
if
(
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
aState
-
>
mEnabled
=
IMEState
:
:
DISABLED
;
}
else
{
aState
-
>
mEnabled
=
IMEState
:
:
ENABLED
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetInputEventTargetContent
(
)
{
nsCOMPtr
<
nsIContent
>
target
=
GetActiveEditingHost
(
)
;
return
target
.
forget
(
)
;
}
Element
*
HTMLEditor
:
:
GetEditorRoot
(
)
{
return
GetActiveEditingHost
(
)
;
}
}
