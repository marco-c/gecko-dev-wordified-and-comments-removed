#
include
"
HTMLEditor
.
h
"
#
include
"
AutoRangeArray
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
InsertNodeTransaction
.
h
"
#
include
"
JoinNodesTransaction
.
h
"
#
include
"
MoveNodeTransaction
.
h
"
#
include
"
ReplaceTextTransaction
.
h
"
#
include
"
SplitNodeTransaction
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextServicesDocument
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIEditActionListener
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
static
bool
IsLinkTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
href
;
}
static
bool
IsNamedAnchorTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
anchor
;
}
struct
MOZ_STACK_CLASS
SavedRange
final
{
RefPtr
<
Selection
>
mSelection
;
nsCOMPtr
<
nsINode
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
uint32_t
mStartOffset
=
0
;
uint32_t
mEndOffset
=
0
;
}
;
HTMLEditor
:
:
AutoSelectionRestorer
:
:
AutoSelectionRestorer
(
HTMLEditor
&
aHTMLEditor
)
:
mHTMLEditor
(
nullptr
)
{
if
(
aHTMLEditor
.
ArePreservingSelection
(
)
)
{
return
;
}
MOZ_ASSERT
(
aHTMLEditor
.
IsEditActionDataAvailable
(
)
)
;
mHTMLEditor
=
&
aHTMLEditor
;
mHTMLEditor
-
>
PreserveSelectionAcrossActions
(
)
;
}
HTMLEditor
:
:
AutoSelectionRestorer
:
:
~
AutoSelectionRestorer
(
)
{
if
(
!
mHTMLEditor
|
|
!
mHTMLEditor
-
>
ArePreservingSelection
(
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
mHTMLEditor
-
>
RestorePreservedSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
RestorePreservedSelection
(
)
failed
but
ignored
"
)
;
}
void
HTMLEditor
:
:
AutoSelectionRestorer
:
:
Abort
(
)
{
if
(
mHTMLEditor
)
{
mHTMLEditor
-
>
StopPreservingSelection
(
)
;
}
}
template
CreateContentResult
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
template
CreateElementResult
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
Element
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
template
CreateTextResult
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
Text
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
HTMLEditor
:
:
InitializeInsertingElement
HTMLEditor
:
:
DoNothingForNewElement
=
[
]
(
HTMLEditor
&
Element
&
const
EditorDOMPoint
&
)
{
return
NS_OK
;
}
;
HTMLEditor
:
:
HTMLEditor
(
)
:
EditorBase
(
EditorBase
:
:
EditorType
:
:
HTML
)
mCRInParagraphCreatesParagraph
(
false
)
mIsObjectResizingEnabled
(
StaticPrefs
:
:
editor_resizing_enabled_by_default
(
)
)
mIsResizing
(
false
)
mPreserveRatio
(
false
)
mResizedObjectIsAnImage
(
false
)
mIsAbsolutelyPositioningEnabled
(
StaticPrefs
:
:
editor_positioning_enabled_by_default
(
)
)
mResizedObjectIsAbsolutelyPositioned
(
false
)
mGrabberClicked
(
false
)
mIsMoving
(
false
)
mSnapToGridEnabled
(
false
)
mIsInlineTableEditingEnabled
(
StaticPrefs
:
:
editor_inline_table_editing_enabled_by_default
(
)
)
mOriginalX
(
0
)
mOriginalY
(
0
)
mResizedObjectX
(
0
)
mResizedObjectY
(
0
)
mResizedObjectWidth
(
0
)
mResizedObjectHeight
(
0
)
mResizedObjectMarginLeft
(
0
)
mResizedObjectMarginTop
(
0
)
mResizedObjectBorderLeft
(
0
)
mResizedObjectBorderTop
(
0
)
mXIncrementFactor
(
0
)
mYIncrementFactor
(
0
)
mWidthIncrementFactor
(
0
)
mHeightIncrementFactor
(
0
)
mInfoXIncrement
(
20
)
mInfoYIncrement
(
20
)
mPositionedObjectX
(
0
)
mPositionedObjectY
(
0
)
mPositionedObjectWidth
(
0
)
mPositionedObjectHeight
(
0
)
mPositionedObjectMarginLeft
(
0
)
mPositionedObjectMarginTop
(
0
)
mPositionedObjectBorderLeft
(
0
)
mPositionedObjectBorderTop
(
0
)
mGridSize
(
0
)
mDefaultParagraphSeparator
(
StaticPrefs
:
:
editor_use_div_for_default_newlines
(
)
?
ParagraphSeparator
:
:
div
:
ParagraphSeparator
:
:
br
)
{
}
HTMLEditor
:
:
~
HTMLEditor
(
)
{
if
(
StaticPrefs
:
:
dom_input_events_beforeinput_enabled
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_BEFOREINPUT_LISTENERS
MayHaveBeforeInputEventListenersForTelemetry
(
)
?
1
:
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_OVERRIDDEN_BY_BEFOREINPUT_LISTENERS
mHasBeforeInputBeenCanceled
?
1
:
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_MUTATION_LISTENERS_WITHOUT_BEFOREINPUT_LISTENERS
!
MayHaveBeforeInputEventListenersForTelemetry
(
)
&
&
MayHaveMutationEventListeners
(
)
?
1
:
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_MUTATION_OBSERVERS_WITHOUT_BEFOREINPUT_LISTENERS
!
MayHaveBeforeInputEventListenersForTelemetry
(
)
&
&
MutationObserverHasObservedNodeForTelemetry
(
)
?
1
:
0
)
;
}
mTypeInState
=
nullptr
;
if
(
mDisabledLinkHandling
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
doc
-
>
SetLinkHandlingEnabled
(
mOldLinkHandlingEnabled
)
;
}
}
RemoveEventListeners
(
)
;
HideAnonymousEditingUIs
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChangedRangeForTopLevelEditSubAction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPaddingBRElementForEmptyEditor
)
tmp
-
>
HideAnonymousEditingUIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChangedRangeForTopLevelEditSubAction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPaddingBRElementForEmptyEditor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActivatedHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAbsolutelyPositionedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGrabber
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositioningShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineEditedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveColumnButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveRowButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
HTMLEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLObjectResizer
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLAbsPosEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLInlineTableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorMailSupport
)
NS_INTERFACE_MAP_END_INHERITING
(
EditorBase
)
nsresult
HTMLEditor
:
:
Init
(
Document
&
aDocument
ComposerCommandsUpdater
&
aComposerCommandsUpdater
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
called
again
without
calling
PreDestroy
(
)
?
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mComposerCommandsUpdater
|
|
mComposerCommandsUpdater
=
=
&
aComposerCommandsUpdater
)
;
mComposerCommandsUpdater
=
&
aComposerCommandsUpdater
;
RefPtr
<
PresShell
>
presShell
=
aDocument
.
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InitInternal
(
aDocument
nullptr
*
presShell
aFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InitInternal
(
)
failed
"
)
;
return
rv
;
}
aDocument
.
AddMutationObserverUnlessExists
(
this
)
;
if
(
!
mRootElement
)
{
UpdateRootElement
(
)
;
}
if
(
IsMailEditor
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetAbsolutePositioningEnabled
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetAbsolutePositioningEnabled
(
false
)
failed
but
ignored
"
)
;
rvIgnored
=
SetSnapToGridEnabled
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetSnapToGridEnabled
(
false
)
failed
but
ignored
"
)
;
}
mCSSEditUtils
=
MakeUnique
<
CSSEditUtils
>
(
this
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsInPlaintextMode
(
)
&
&
!
IsInteractionAllowed
(
)
)
{
mDisabledLinkHandling
=
true
;
mOldLinkHandlingEnabled
=
document
-
>
LinkHandlingEnabled
(
)
;
document
-
>
SetLinkHandlingEnabled
(
false
)
;
}
mTypeInState
=
new
TypeInState
(
)
;
if
(
!
IsInteractionAllowed
(
)
)
{
nsCOMPtr
<
nsIURI
>
uaURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
"
resource
:
/
/
gre
/
res
/
EditorOverride
.
css
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
document
-
>
LoadAdditionalStyleSheet
(
Document
:
:
eAgentSheet
uaURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInitializing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
ClearUndoRedo
(
)
;
EnableUndoRedo
(
)
;
if
(
mTransactionManager
)
{
mTransactionManager
-
>
Attach
(
*
this
)
;
}
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
shouldn
'
t
be
nested
"
)
;
mInitSucceeded
=
true
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
PostCreate
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
PostCreateInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
PostCreatInternal
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
PreDestroy
(
)
{
if
(
mDidPreDestroy
)
{
return
;
}
mInitSucceeded
=
false
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
document
)
{
document
-
>
RemoveMutationObserver
(
this
)
;
if
(
!
IsInteractionAllowed
(
)
)
{
nsCOMPtr
<
nsIURI
>
uaURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
"
resource
:
/
/
gre
/
res
/
EditorOverride
.
css
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
document
-
>
RemoveAdditionalStyleSheet
(
Document
:
:
eAgentSheet
uaURI
)
;
}
}
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsDestroying
(
)
)
{
RefPtr
<
HTMLEditor
>
self
=
this
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
HTMLEditor
:
:
PreDestroy
"
[
self
]
(
)
{
self
-
>
HideAnonymousEditingUIs
(
)
;
}
)
)
;
}
else
{
HideAnonymousEditingUIs
(
)
;
}
mPaddingBRElementForEmptyEditor
=
nullptr
;
PreDestroyInternal
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetDocumentCharacterSet
(
nsACString
&
aCharacterSet
)
{
nsresult
rv
=
GetDocumentCharsetInternal
(
aCharacterSet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetDocumentCharsetInternal
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetDocumentCharacterSet
(
const
nsACString
&
aCharacterSet
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetCharacterSet
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_NOT_INITIALIZED
)
;
}
const
Encoding
*
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
aCharacterSet
)
;
if
(
!
encoding
)
{
NS_WARNING
(
"
Encoding
:
:
ForLabelNoReplacement
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_INVALID_ARG
)
;
}
document
-
>
SetDocumentCharacterSet
(
WrapNotNull
(
encoding
)
)
;
if
(
UpdateMetaCharsetWithTransaction
(
*
document
aCharacterSet
)
)
{
return
NS_OK
;
}
if
(
aCharacterSet
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsContentList
>
headElementList
=
document
-
>
GetElementsByTagName
(
u
"
head
"
_ns
)
;
if
(
NS_WARN_IF
(
!
headElementList
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
primaryHeadElement
=
headElementList
-
>
Item
(
0
)
;
if
(
NS_WARN_IF
(
!
primaryHeadElement
)
)
{
return
NS_OK
;
}
CreateElementResult
createNewMetaElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
*
nsGkAtoms
:
:
meta
EditorDOMPoint
(
primaryHeadElement
0
)
[
&
aCharacterSet
]
(
HTMLEditor
&
Element
&
aMetaElement
const
EditorDOMPoint
&
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
aMetaElement
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
httpEquiv
u
"
Content
-
Type
"
_ns
aMetaElement
.
IsInComposedDoc
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
nsPrintfCString
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
httpEquiv
\
"
Content
-
Type
\
"
"
"
%
s
)
failed
but
ignored
"
aMetaElement
.
IsInComposedDoc
(
)
?
"
true
"
:
"
false
"
)
.
get
(
)
)
;
rvIgnored
=
aMetaElement
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
content
u
"
text
/
html
;
charset
=
"
_ns
+
NS_ConvertASCIItoUTF16
(
aCharacterSet
)
aMetaElement
.
IsInComposedDoc
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
nsPrintfCString
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
content
"
"
\
"
text
/
html
;
charset
=
%
s
\
"
%
s
)
failed
but
ignored
"
nsPromiseFlatCString
(
aCharacterSet
)
.
get
(
)
aMetaElement
.
IsInComposedDoc
(
)
?
"
true
"
:
"
false
"
)
.
get
(
)
)
;
return
NS_OK
;
}
)
;
NS_WARNING_ASSERTION
(
createNewMetaElementResult
.
isOk
(
)
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
"
"
Yes
nsGkAtoms
:
:
meta
)
failed
but
ignored
"
)
;
createNewMetaElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
UpdateMetaCharsetWithTransaction
(
Document
&
aDocument
const
nsACString
&
aCharacterSet
)
{
RefPtr
<
nsContentList
>
metaElementList
=
aDocument
.
GetElementsByTagName
(
u
"
meta
"
_ns
)
;
if
(
NS_WARN_IF
(
!
metaElementList
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
metaElementList
-
>
Length
(
true
)
;
+
+
i
)
{
RefPtr
<
Element
>
metaElement
=
metaElementList
-
>
Item
(
i
)
-
>
AsElement
(
)
;
MOZ_ASSERT
(
metaElement
)
;
nsAutoString
currentValue
;
metaElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
httpEquiv
currentValue
)
;
if
(
!
FindInReadable
(
u
"
content
-
type
"
_ns
currentValue
nsCaseInsensitiveStringComparator
)
)
{
continue
;
}
metaElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
content
currentValue
)
;
constexpr
auto
charsetEquals
=
u
"
charset
=
"
_ns
;
nsAString
:
:
const_iterator
originalStart
start
end
;
originalStart
=
currentValue
.
BeginReading
(
start
)
;
currentValue
.
EndReading
(
end
)
;
if
(
!
FindInReadable
(
charsetEquals
start
end
nsCaseInsensitiveStringComparator
)
)
{
continue
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
metaElement
*
nsGkAtoms
:
:
content
Substring
(
originalStart
start
)
+
charsetEquals
+
NS_ConvertASCIItoUTF16
(
aCharacterSet
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
content
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
return
false
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NotifySelectionChanged
(
Document
*
aDocument
Selection
*
aSelection
int16_t
aReason
int32_t
aAmount
)
{
if
(
NS_WARN_IF
(
!
aDocument
)
|
|
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mTypeInState
)
{
RefPtr
<
TypeInState
>
typeInState
=
mTypeInState
;
typeInState
-
>
OnSelectionChange
(
*
this
aReason
)
;
if
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
&
&
aSelection
)
{
DebugOnly
<
nsresult
>
rv
=
RefreshEditingUI
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RefreshEditingUI
(
)
failed
but
ignored
"
)
;
}
}
if
(
mComposerCommandsUpdater
)
{
RefPtr
<
ComposerCommandsUpdater
>
updater
=
mComposerCommandsUpdater
;
updater
-
>
OnSelectionChange
(
)
;
}
nsresult
rv
=
EditorBase
:
:
NotifySelectionChanged
(
aDocument
aSelection
aReason
aAmount
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
NotifySelectionChanged
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
UpdateRootElement
(
)
{
mRootElement
=
GetBodyElement
(
)
;
if
(
!
mRootElement
)
{
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
mRootElement
=
doc
-
>
GetDocumentElement
(
)
;
}
}
}
nsresult
HTMLEditor
:
:
OnFocus
(
const
nsINode
&
aOriginalEventTargetNode
)
{
if
(
!
CanKeepHandlingFocusEvent
(
aOriginalEventTargetNode
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
OnFocus
(
aOriginalEventTargetNode
)
;
}
nsresult
HTMLEditor
:
:
OnBlur
(
const
EventTarget
*
aEventTarget
)
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
MOZ_UNLIKELY
(
!
focusManager
)
)
{
return
NS_OK
;
}
if
(
focusManager
-
>
GetFocusedElement
(
)
)
{
return
NS_OK
;
}
if
(
IsInDesignMode
(
)
&
&
Element
:
:
FromEventTargetOrNull
(
aEventTarget
)
)
{
return
NS_OK
;
}
nsresult
rv
=
FinalizeSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
FinalizeSelection
(
)
failed
"
)
;
return
rv
;
}
Element
*
HTMLEditor
:
:
FindSelectionRoot
(
const
nsINode
&
aNode
)
const
{
MOZ_ASSERT
(
aNode
.
IsDocument
(
)
|
|
aNode
.
IsContent
(
)
"
aNode
must
be
content
or
document
node
"
)
;
if
(
NS_WARN_IF
(
!
aNode
.
IsInComposedDoc
(
)
)
)
{
return
nullptr
;
}
if
(
aNode
.
IsInDesignMode
(
)
)
{
return
GetDocument
(
)
-
>
GetRootElement
(
)
;
}
if
(
IsReadonly
(
)
)
{
return
GetRoot
(
)
;
}
nsIContent
*
content
=
const_cast
<
nsIContent
*
>
(
aNode
.
AsContent
(
)
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
ElementState
:
:
READWRITE
)
)
{
return
content
-
>
AsElement
(
)
;
}
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
bool
HTMLEditor
:
:
IsInDesignMode
(
)
const
{
Document
*
document
=
GetDocument
(
)
;
return
document
&
&
document
-
>
IsInDesignMode
(
)
;
}
void
HTMLEditor
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
HTMLEditorEventListener
(
)
;
}
}
nsresult
HTMLEditor
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
HTMLEditorEventListener
*
listener
=
reinterpret_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
;
nsresult
rv
=
listener
-
>
Connect
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditorEventListener
:
:
Connect
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
EditorBase
:
:
RemoveEventListeners
(
)
;
}
void
HTMLEditor
:
:
Detach
(
const
ComposerCommandsUpdater
&
aComposerCommandsUpdater
)
{
MOZ_DIAGNOSTIC_ASSERT_IF
(
mComposerCommandsUpdater
&
aComposerCommandsUpdater
=
=
mComposerCommandsUpdater
)
;
if
(
mComposerCommandsUpdater
=
=
&
aComposerCommandsUpdater
)
{
mComposerCommandsUpdater
=
nullptr
;
if
(
mTransactionManager
)
{
mTransactionManager
-
>
Detach
(
*
this
)
;
}
}
}
NS_IMETHODIMP
HTMLEditor
:
:
BeginningOfDocument
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
tryToCollapseSelectionAtFirstEditableNode
=
true
;
if
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
1
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
Element
*
editingHost
=
ComputeEditingHost
(
)
;
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
range
-
>
GetStartContainer
(
)
=
=
editingHost
&
&
!
range
-
>
StartOffset
(
)
)
{
tryToCollapseSelectionAtFirstEditableNode
=
false
;
}
}
EditorBase
:
:
InitializeSelectionAncestorLimit
(
aAncestorLimit
)
;
if
(
tryToCollapseSelectionAtFirstEditableNode
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
failed
"
"
but
ignored
"
)
;
}
if
(
aAncestorLimit
.
HasIndependentSelection
(
)
)
{
SelectionRef
(
)
.
SetAncestorLimiter
(
nullptr
)
;
}
}
nsresult
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
bool
aIgnoreIfSelectionInEditingHost
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
LimitInBodyElement
:
:
No
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_OK
;
}
if
(
aIgnoreIfSelectionInEditingHost
&
&
SelectionRef
(
)
.
RangeCount
(
)
=
=
1
)
{
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
!
range
-
>
Collapsed
(
)
|
|
range
-
>
GetStartContainer
(
)
!
=
editingHost
.
get
(
)
|
|
range
-
>
StartOffset
(
)
)
{
return
NS_OK
;
}
}
for
(
nsIContent
*
leafContent
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
editingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
editingHost
)
;
leafContent
;
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
leafContent
EditorType
:
:
HTML
)
)
{
MOZ_ASSERT
(
leafContent
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
leafContent
-
>
GetParent
(
)
EditorType
:
:
HTML
)
)
;
if
(
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
leafContent
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
EditorDOMPoint
(
editableBlockElementOrInlineEditingHost
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING
(
"
Found
leaf
content
did
not
have
editable
parent
why
?
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
leafContent
-
>
IsElement
(
)
&
&
HTMLEditUtils
:
:
IsInlineElement
(
*
leafContent
)
&
&
!
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
leafContent
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
leafContent
*
nsGkAtoms
:
:
textTagName
)
)
{
leafContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
leafContent
*
editingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
editingHost
)
;
continue
;
}
if
(
Text
*
text
=
leafContent
-
>
GetAsText
(
)
)
{
WSScanResult
scanResultInTextNode
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
editingHost
EditorRawDOMPoint
(
text
0
)
)
;
if
(
(
scanResultInTextNode
.
InVisibleOrCollapsibleCharacters
(
)
|
|
scanResultInTextNode
.
ReachedPreformattedLineBreak
(
)
)
&
&
scanResultInTextNode
.
TextPtr
(
)
=
=
text
)
{
nsresult
rv
=
CollapseSelectionTo
(
scanResultInTextNode
.
Point
<
EditorRawDOMPoint
>
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
leafContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
leafContent
*
editingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
editingHost
)
;
continue
;
}
if
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
leafContent
*
nsGkAtoms
:
:
textTagName
)
|
|
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
leafContent
)
)
{
MOZ_ASSERT
(
leafContent
-
>
GetParent
(
)
)
;
if
(
EditorUtils
:
:
IsEditableContent
(
*
leafContent
EditorType
:
:
HTML
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
EditorDOMPoint
(
leafContent
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT_UNREACHABLE
(
"
How
do
we
reach
editable
leaf
in
non
-
editable
element
?
"
)
;
nsresult
rv
=
CollapseSelectionTo
(
EditorDOMPoint
(
editingHost
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
leafContent
)
&
&
!
HTMLEditUtils
:
:
IsEmptyNode
(
*
leafContent
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
&
&
!
HTMLEditUtils
:
:
IsNeverElementContentsEditableByUser
(
*
leafContent
)
)
{
leafContent
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
leafContent
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
editingHost
)
;
continue
;
}
leafContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
leafContent
*
editingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
LeafNodeType
:
:
LeafNodeOrChildBlock
}
editingHost
)
;
}
nsresult
rv
=
CollapseSelectionTo
(
EditorDOMPoint
(
editingHost
0
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
ArePreservingSelection
(
)
const
{
return
IsEditActionDataAvailable
(
)
&
&
SavedSelectionRef
(
)
.
RangeCount
(
)
;
}
void
HTMLEditor
:
:
PreserveSelectionAcrossActions
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
SavedSelectionRef
(
)
.
SaveSelection
(
SelectionRef
(
)
)
;
RangeUpdaterRef
(
)
.
RegisterSelectionState
(
SavedSelectionRef
(
)
)
;
}
nsresult
HTMLEditor
:
:
RestorePreservedSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
SavedSelectionRef
(
)
.
RangeCount
(
)
)
{
return
NS_ERROR_FAILURE
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SavedSelectionRef
(
)
.
RestoreSelection
(
SelectionRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
SelectionState
:
:
RestoreSelection
(
)
failed
but
ignored
"
)
;
StopPreservingSelection
(
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
StopPreservingSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RangeUpdaterRef
(
)
.
DropSelectionState
(
SavedSelectionRef
(
)
)
;
SavedSelectionRef
(
)
.
RemoveAllRanges
(
)
;
}
void
HTMLEditor
:
:
PreHandleMouseDown
(
const
MouseEvent
&
aMouseDownEvent
)
{
if
(
mTypeInState
)
{
mTypeInState
-
>
PreHandleMouseEvent
(
aMouseDownEvent
)
;
}
}
void
HTMLEditor
:
:
PreHandleMouseUp
(
const
MouseEvent
&
aMouseUpEvent
)
{
if
(
mTypeInState
)
{
mTypeInState
-
>
PreHandleMouseEvent
(
aMouseUpEvent
)
;
}
}
void
HTMLEditor
:
:
PreHandleSelectionChangeCommand
(
Command
aCommand
)
{
if
(
mTypeInState
)
{
mTypeInState
-
>
PreHandleSelectionChangeCommand
(
aCommand
)
;
}
}
void
HTMLEditor
:
:
PostHandleSelectionChangeCommand
(
Command
aCommand
)
{
if
(
!
mTypeInState
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
!
editActionData
.
CanHandle
(
)
)
{
return
;
}
mTypeInState
-
>
PostHandleSelectionChangeCommand
(
*
this
aCommand
)
;
}
nsresult
HTMLEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
IsReadonly
(
)
)
{
HandleKeyPressEventInReadOnlyMode
(
*
aKeyboardEvent
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
case
NS_VK_BACK
:
case
NS_VK_DELETE
:
{
nsresult
rv
=
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
case
NS_VK_TAB
:
{
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
IsInPlaintextMode
(
)
)
{
if
(
aKeyboardEvent
-
>
IsShift
(
)
|
|
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsresult
rv
=
OnInputText
(
u
"
\
t
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
OnInputText
(
\
\
t
)
failed
"
)
;
return
rv
;
}
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
|
|
NS_WARN_IF
(
!
selection
-
>
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
startContainer
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
startContainer
)
;
if
(
!
startContainer
-
>
IsContent
(
)
)
{
break
;
}
const
Element
*
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
startContainer
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
editableBlockElement
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsAnyTableElement
(
editableBlockElement
)
)
{
EditActionResult
result
=
HandleTabKeyPressInTable
(
aKeyboardEvent
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleTabKeyPressInTable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
if
(
!
result
.
Handled
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
editableBlockElement
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
!
aKeyboardEvent
-
>
IsShift
(
)
)
{
nsresult
rv
=
IndentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
IndentAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
OutdentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OutdentAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsresult
rv
=
OnInputText
(
u
"
\
t
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
OnInputText
(
\
\
t
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
case
NS_VK_RETURN
:
if
(
!
aKeyboardEvent
-
>
IsInputtingLineBreak
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
nsresult
rv
=
InsertLineBreakAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertLineBreakAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
InsertParagraphSeparatorAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
aKeyboardEvent
-
>
IsInputtingText
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
aKeyboardEvent
-
>
mCharCode
)
;
nsresult
rv
=
OnInputText
(
str
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
OnInputText
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NodeIsBlock
(
nsINode
*
aNode
bool
*
aIsBlock
)
{
*
aIsBlock
=
aNode
&
&
aNode
-
>
IsContent
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aNode
-
>
AsContent
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
UpdateBaseURL
(
)
{
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsContentList
>
baseElementList
=
document
-
>
GetElementsByTagName
(
u
"
base
"
_ns
)
;
if
(
!
baseElementList
|
|
!
baseElementList
-
>
Item
(
0
)
)
{
document
-
>
SetBaseURI
(
document
-
>
GetDocumentURI
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLineBreak
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
*
editingHost
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLineBreak
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
rv
=
InsertLineBreakAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertLineBreakAsSubAction
(
)
failed
"
)
;
return
NS_FAILED
(
rv
)
?
rv
:
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertParagraphSeparatorAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
*
editingHost
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
EditActionResult
HTMLEditor
:
:
HandleTabKeyPressInTable
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
AutoEditActionDataSetter
dummyEditActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
dummyEditActionData
.
CanHandle
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
const
RefPtr
<
Element
>
cellElement
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cellElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
"
"
returned
nullptr
"
)
;
return
EditActionIgnored
(
)
;
}
RefPtr
<
Element
>
table
=
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
cellElement
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetClosestAncestorTableElement
(
)
failed
"
)
;
return
EditActionIgnored
(
)
;
}
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
table
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
Init
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
rv
=
postOrderIter
.
PositionAt
(
cellElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
PositionAt
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
do
{
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
postOrderIter
.
Prev
(
)
;
}
else
{
postOrderIter
.
Next
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
postOrderIter
.
GetCurrentNode
(
)
;
if
(
node
&
&
HTMLEditUtils
:
:
IsTableCell
(
node
)
&
&
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
node
-
>
AsElement
(
)
)
=
=
table
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
CollapseSelectionToDeepestNonTableFirstChild
(
node
)
;
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
}
while
(
!
postOrderIter
.
IsDone
(
)
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
EditActionIgnored
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableRowElement
)
;
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
InsertTableRowsWithTransaction
(
*
cellElement
1
InsertPosition
:
:
eAfterSelectedCell
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTableRowsWithTransaction
(
*
cellElement
1
"
"
InsertPosition
:
:
eAfterSelectedCell
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
RefPtr
<
Element
>
tblElement
cell
;
int32_t
row
;
rv
=
GetCellContext
(
getter_AddRefs
(
tblElement
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
row
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
!
tblElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
table
element
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
cell
=
GetTableCellElementAt
(
*
tblElement
row
0
)
;
if
(
cell
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
cell
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
caused
destroying
the
"
"
editor
"
)
;
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
void
HTMLEditor
:
:
CollapseSelectionToDeepestNonTableFirstChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
for
(
nsIContent
*
child
=
node
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
child
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
)
{
break
;
}
node
=
child
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionToStartOf
(
*
node
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
nsresult
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
const
nsAString
&
aSourceToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eReplaceHeadWithHTMLSource
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
CommitComposition
(
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsContentList
>
headElementList
=
document
-
>
GetElementsByTagName
(
u
"
head
"
_ns
)
;
if
(
NS_WARN_IF
(
!
headElementList
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
primaryHeadElement
=
headElementList
-
>
Item
(
0
)
-
>
AsElement
(
)
;
if
(
NS_WARN_IF
(
!
primaryHeadElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
inputString
(
aSourceToInsert
)
;
inputString
.
ReplaceSubstring
(
u
"
\
r
\
n
"
_ns
u
"
\
n
"
_ns
)
;
inputString
.
ReplaceSubstring
(
u
"
\
r
"
_ns
u
"
\
n
"
_ns
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
RefPtr
<
const
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
inputString
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
documentFragment
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
didn
'
t
create
DocumentFragment
"
)
;
return
NS_ERROR_FAILURE
;
}
while
(
nsCOMPtr
<
nsIContent
>
child
=
primaryHeadElement
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
int32_t
offsetOfNewNode
=
0
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
documentFragment
-
>
GetFirstChild
(
)
)
{
CreateContentResult
insertChildContentResult
=
InsertNodeWithTransaction
(
*
child
EditorDOMPoint
(
primaryHeadElement
offsetOfNewNode
+
+
)
)
;
if
(
insertChildContentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertChildContentResult
.
unwrapErr
(
)
;
}
insertChildContentResult
.
IgnoreCaretPointSuggestion
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RebuildDocumentFromSource
(
const
nsAString
&
aSourceString
)
{
CommitComposition
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetHTML
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsReadingIterator
<
char16_t
>
beginbody
;
nsReadingIterator
<
char16_t
>
endbody
;
aSourceString
.
BeginReading
(
beginbody
)
;
aSourceString
.
EndReading
(
endbody
)
;
bool
foundbody
=
CaseInsensitiveFindInReadable
(
u
"
<
body
"
_ns
beginbody
endbody
)
;
nsReadingIterator
<
char16_t
>
beginhead
;
nsReadingIterator
<
char16_t
>
endhead
;
aSourceString
.
BeginReading
(
beginhead
)
;
aSourceString
.
EndReading
(
endhead
)
;
bool
foundhead
=
CaseInsensitiveFindInReadable
(
u
"
<
head
"
_ns
beginhead
endhead
)
;
if
(
foundbody
&
&
beginhead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundhead
=
false
;
}
nsReadingIterator
<
char16_t
>
beginclosehead
;
nsReadingIterator
<
char16_t
>
endclosehead
;
aSourceString
.
BeginReading
(
beginclosehead
)
;
aSourceString
.
EndReading
(
endclosehead
)
;
bool
foundclosehead
=
CaseInsensitiveFindInReadable
(
u
"
<
/
head
>
"
_ns
beginclosehead
endclosehead
)
;
if
(
foundhead
&
&
beginhead
.
get
(
)
>
beginclosehead
.
get
(
)
)
{
foundclosehead
=
false
;
}
if
(
foundbody
&
&
beginclosehead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundclosehead
=
false
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
nsReadingIterator
<
char16_t
>
endtotal
;
aSourceString
.
EndReading
(
endtotal
)
;
if
(
foundhead
)
{
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginclosehead
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginbody
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
else
{
nsReadingIterator
<
char16_t
>
begintotal
;
aSourceString
.
BeginReading
(
begintotal
)
;
constexpr
auto
head
=
u
"
<
head
>
"
_ns
;
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginclosehead
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginbody
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
rv
=
SelectAll
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SelectAll
(
)
failed
"
)
;
return
rv
;
}
if
(
!
foundbody
)
{
constexpr
auto
body
=
u
"
<
body
>
"
_ns
;
if
(
foundclosehead
)
{
nsresult
rv
=
LoadHTML
(
body
+
Substring
(
endclosehead
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
foundhead
)
{
nsresult
rv
=
LoadHTML
(
body
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
LoadHTML
(
body
+
aSourceString
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
RefPtr
<
Element
>
divElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
div
)
;
if
(
!
divElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
*
divElement
)
;
nsresult
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
rv
=
LoadHTML
(
Substring
(
beginbody
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
nsReadingIterator
<
char16_t
>
beginclosebody
=
beginbody
;
nsReadingIterator
<
char16_t
>
endclosebody
;
aSourceString
.
EndReading
(
endclosebody
)
;
if
(
!
FindInReadable
(
u
"
>
"
_ns
beginclosebody
endclosebody
)
)
{
NS_WARNING
(
"
'
>
'
was
not
found
"
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
bodyTag
;
bodyTag
.
AssignLiteral
(
"
<
div
"
)
;
bodyTag
.
Append
(
Substring
(
endbody
endclosebody
)
)
;
RefPtr
<
const
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
bodyTag
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
!
documentFragment
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
didn
'
t
create
DocumentFagement
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstChild
=
documentFragment
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
|
|
!
firstChild
-
>
IsElement
(
)
)
{
NS_WARNING
(
"
First
child
of
DocumentFragment
was
not
an
Element
node
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
MOZ_KnownLive
(
*
firstChild
-
>
AsElement
(
)
)
)
;
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertElementAtSelection
(
Element
*
aElement
bool
aDeleteSelection
)
{
nsresult
rv
=
InsertElementAtSelectionAsAction
(
aElement
aDeleteSelection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertElementAtSelectionAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertElementAtSelectionAsAction
(
Element
*
aElement
bool
aDeleteSelection
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
*
aElement
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
IsReadonly
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
UndefineCaretBidiLevel
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
aDeleteSelection
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
aElement
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
failed
"
)
;
return
rv
;
}
}
else
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aElement
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
CollapseToStart
(
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseToStart
(
)
failed
but
ignored
"
)
;
}
else
{
IgnoredErrorResult
ignoredError
;
SelectionRef
(
)
.
CollapseToEnd
(
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseToEnd
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
SelectionRef
(
)
.
GetAnchorNode
(
)
)
{
return
NS_OK
;
}
Element
*
editingHost
=
ComputeEditingHost
(
LimitInBodyElement
:
:
No
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_FAILURE
)
;
}
EditorRawDOMPoint
atAnchor
(
SelectionRef
(
)
.
AnchorRef
(
)
)
;
EditorDOMPoint
pointToInsert
=
HTMLEditUtils
:
:
GetBetterInsertionPointFor
<
EditorDOMPoint
>
(
*
aElement
atAnchor
*
editingHost
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetBetterInsertionPointFor
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
const
CreateElementResult
insertElementResult
=
InsertNodeIntoProperAncestorWithTransaction
<
Element
>
(
*
aElement
pointToInsert
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
insertElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
insertElementResult
.
unwrapErr
(
)
)
;
}
insertElementResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
!
SetCaretInTableCell
(
aElement
)
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsresult
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
:
:
After
(
*
aElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
if
(
!
HTMLEditUtils
:
:
IsTable
(
aElement
)
|
|
!
HTMLEditUtils
:
:
IsLastChild
(
*
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
return
NS_OK
;
}
const
auto
afterElement
=
EditorDOMPoint
:
:
After
(
*
aElement
)
;
const
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
afterElement
ePrevious
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
ePrevious
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
*
this
{
}
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
template
<
typename
NodeType
>
CreateNodeResultBase
<
NodeType
>
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
NodeType
&
aContentToInsert
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
{
using
ResultType
=
CreateNodeResultBase
<
NodeType
>
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
ResultType
(
NS_ERROR_FAILURE
)
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
while
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
aContentToInsert
)
)
{
if
(
MOZ_UNLIKELY
(
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
HTMLEditUtils
:
:
IsAnyTableElement
(
pointToInsert
.
GetContainer
(
)
)
)
)
{
NS_WARNING
(
"
There
was
no
proper
container
element
to
insert
the
content
node
in
"
"
the
document
"
)
;
return
ResultType
(
NS_ERROR_FAILURE
)
;
}
pointToInsert
=
pointToInsert
.
ParentPoint
(
)
;
if
(
MOZ_UNLIKELY
(
!
pointToInsert
.
IsInContentNode
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
pointToInsert
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
)
{
NS_WARNING
(
"
There
was
no
proper
container
element
to
insert
the
content
node
in
"
"
the
editing
host
"
)
;
return
ResultType
(
NS_ERROR_FAILURE
)
;
}
}
if
(
pointToInsert
!
=
aPointToInsert
)
{
MOZ_ASSERT
(
pointToInsert
.
GetChild
(
)
)
;
const
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aPointToInsert
aSplitAtEdges
)
;
if
(
splitNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
ResultType
(
splitNodeResult
.
unwrapErr
(
)
)
;
}
pointToInsert
=
splitNodeResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
splitNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
ResultType
insertContentNodeResult
=
InsertNodeWithTransaction
<
NodeType
>
(
aContentToInsert
pointToInsert
)
;
if
(
MOZ_LIKELY
(
insertContentNodeResult
.
isOk
(
)
)
&
&
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aContentToInsert
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
aContentToInsert
.
GetParentNode
(
)
!
=
pointToInsert
.
GetContainer
(
)
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
succeeded
but
the
inserted
"
"
node
was
moved
or
removed
by
the
web
app
"
)
;
insertContentNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
return
ResultType
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
NS_WARNING_ASSERTION
(
insertContentNodeResult
.
isOk
(
)
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertContentNodeResult
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
SelectContentInternal
(
MOZ_KnownLive
(
*
aElement
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SelectContentInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SelectContentInternal
(
nsIContent
&
aContentToSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
|
|
NS_WARN_IF
(
!
aContentToSelect
.
IsInclusiveDescendantOf
(
editingHost
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionStart
(
&
aContentToSelect
)
;
if
(
NS_WARN_IF
(
!
newSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionEnd
(
EditorRawDOMPoint
:
:
After
(
aContentToSelect
)
)
;
MOZ_ASSERT
(
newSelectionEnd
.
IsSet
(
)
)
;
ErrorResult
error
;
SelectionRef
(
)
.
SetStartAndEndInLimiter
(
newSelectionStart
newSelectionEnd
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SetStartAndEndInLimiter
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorRawDOMPoint
atContent
(
&
aContent
)
;
if
(
NS_WARN_IF
(
!
atContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
atContent
.
ToRawRangeBoundary
(
)
atContent
.
NextPoint
(
)
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRef
(
)
.
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
if
(
error
.
Failed
(
)
)
{
error
.
SuppressException
(
)
;
}
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
add
range
to
Selection
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
ClearSelection
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
ErrorResult
error
;
SelectionRef
(
)
.
RemoveAllRanges
(
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
if
(
error
.
Failed
(
)
)
{
error
.
SuppressException
(
)
;
}
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
SetParagraphFormatAsAction
(
const
nsAString
&
aParagraphFormat
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertBlockElement
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsAutoString
lowerCaseTagName
(
aParagraphFormat
)
;
ToLowerCase
(
lowerCaseTagName
)
;
RefPtr
<
nsAtom
>
tagName
=
NS_Atomize
(
lowerCaseTagName
)
;
MOZ_ASSERT
(
tagName
)
;
if
(
tagName
=
=
nsGkAtoms
:
:
dd
|
|
tagName
=
=
nsGkAtoms
:
:
dt
)
{
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
*
tagName
u
"
"
_ns
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
"
"
SelectAllOfCurrentList
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
rv
=
FormatBlockContainerAsSubAction
(
*
tagName
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
FormatBlockContainerAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
aFirstParagraphState
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ParagraphStateAtSelection
paragraphState
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ParagraphStateAtSelection
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
paragraphState
.
IsMixed
(
)
;
if
(
NS_WARN_IF
(
!
paragraphState
.
GetFirstParagraphStateAtSelection
(
)
)
)
{
aFirstParagraphState
.
AssignASCII
(
"
x
"
)
;
}
else
{
paragraphState
.
GetFirstParagraphStateAtSelection
(
)
-
>
ToString
(
aFirstParagraphState
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
GetCSSBackgroundColorState
(
aMixed
aOutColor
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
GetHTMLBackgroundColorState
(
aMixed
aOutColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHighlightColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
if
(
!
IsCSSEnabled
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
GetCSSBackgroundColorState
(
aMixed
aOutColor
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
RefPtr
<
const
nsRange
>
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startContainer
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startContainer
)
|
|
NS_WARN_IF
(
!
startContainer
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
contentToExamine
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
|
|
startContainer
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
!
startContainer
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
contentToExamine
=
startContainer
-
>
AsContent
(
)
;
}
else
{
contentToExamine
=
firstRange
-
>
GetChildAtStartOffset
(
)
;
}
if
(
NS_WARN_IF
(
!
contentToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aBlockLevel
)
{
Element
*
const
closestBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
contentToExamine
HTMLEditUtils
:
:
ClosestBlockElement
)
;
if
(
NS_WARN_IF
(
!
closestBlockElement
)
)
{
return
NS_OK
;
}
for
(
RefPtr
<
Element
>
blockElement
=
closestBlockElement
;
blockElement
;
)
{
RefPtr
<
Element
>
nextBlockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
blockElement
HTMLEditUtils
:
:
ClosestBlockElement
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
blockElement
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
MayHaveMutationEventListeners
(
)
&
&
NS_WARN_IF
(
nextBlockElement
!
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
blockElement
HTMLEditUtils
:
:
ClosestBlockElement
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
"
"
backgroundColor
)
failed
but
ignored
"
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
!
aOutColor
.
EqualsLiteral
(
"
rgba
(
0
0
0
0
)
"
)
)
{
break
;
}
blockElement
=
std
:
:
move
(
nextBlockElement
)
;
}
if
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
|
|
aOutColor
.
EqualsLiteral
(
"
rgba
(
0
0
0
0
)
"
)
)
{
CSSEditUtils
:
:
GetDefaultBackgroundColor
(
aOutColor
)
;
}
}
else
{
if
(
contentToExamine
-
>
IsText
(
)
)
{
contentToExamine
=
contentToExamine
-
>
GetParent
(
)
;
}
if
(
!
contentToExamine
)
{
return
NS_OK
;
}
for
(
RefPtr
<
Element
>
element
=
contentToExamine
-
>
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
)
)
{
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
break
;
}
nsCOMPtr
<
nsINode
>
parentNode
=
element
-
>
GetParentNode
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
element
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
parentNode
!
=
element
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
"
"
backgroundColor
)
failed
but
ignored
"
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
Truncate
(
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
cellOrRowOrTableElementOrError
=
GetSelectedOrParentTableElement
(
)
;
if
(
cellOrRowOrTableElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
returned
error
"
)
;
return
cellOrRowOrTableElementOrError
.
unwrapErr
(
)
;
}
for
(
RefPtr
<
Element
>
element
=
cellOrRowOrTableElementOrError
.
unwrap
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
if
(
!
aOutColor
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
NS_OK
;
}
}
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
rootElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aOL
)
|
|
NS_WARN_IF
(
!
aUL
)
|
|
NS_WARN_IF
(
!
aDL
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListElementSelectionState
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ListElementSelectionState
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeListElementSelected
(
)
;
*
aOL
=
state
.
IsOLElementSelected
(
)
;
*
aUL
=
state
.
IsULElementSelected
(
)
;
*
aDL
=
state
.
IsDLElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aLI
)
|
|
NS_WARN_IF
(
!
aDT
)
|
|
NS_WARN_IF
(
!
aDD
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListItemElementSelectionState
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ListItemElementSelectionState
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeDefinitionListItemElementSelected
(
)
;
*
aLI
=
state
.
IsLIElementSelected
(
)
;
*
aDT
=
state
.
IsDTElementSelected
(
)
;
*
aDD
=
state
.
IsDDElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aAlign
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
AlignStateAtSelection
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
AlignStateAtSelection
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
false
;
*
aAlign
=
state
.
AlignmentAtSelectionStart
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MakeOrChangeList
(
const
nsAString
&
aListType
bool
aEntireList
const
nsAString
&
aBulletType
)
{
RefPtr
<
nsAtom
>
listTagName
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listTagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
MakeOrChangeListAsAction
(
*
listTagName
aBulletType
aEntireList
?
SelectAllOfCurrentList
:
:
Yes
:
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MakeOrChangeListAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MakeOrChangeListAsAction
(
nsAtom
&
aListTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
aListTagName
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
aListTagName
aBulletType
aSelectAllOfCurrentList
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveList
(
const
nsAString
&
aListType
)
{
nsresult
rv
=
RemoveListAsAction
(
aListType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveListAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveListAsAction
(
const
nsAString
&
aListType
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
listAtom
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listAtom
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForRemoveList
(
*
listAtom
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
rv
=
RemoveListAtSelectionAsSubAction
(
*
editingHost
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
"
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerAsSubAction
(
nsAtom
&
aTagName
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
dd
&
&
&
aTagName
!
=
nsGkAtoms
:
:
dt
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrRemoveBlock
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterInvisibleBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterInvisibleBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
MOZ_UNLIKELY
(
!
editingHost
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
AutoRangeArray
selectionRanges
(
SelectionRef
(
)
)
;
Result
<
RefPtr
<
Element
>
nsresult
>
suggestBlockElementToPutCaretOrError
=
FormatBlockContainerWithTransaction
(
selectionRanges
aTagName
*
editingHost
)
;
if
(
suggestBlockElementToPutCaretOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
failed
"
)
;
return
suggestBlockElementToPutCaretOrError
.
unwrapErr
(
)
;
}
if
(
selectionRanges
.
HasSavedRanges
(
)
)
{
selectionRanges
.
RestoreFromSavedRanges
(
)
;
}
rv
=
selectionRanges
.
ApplyTo
(
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
AutoRangeArray
:
:
ApplyTo
(
SelectionRef
(
)
)
failed
but
ignored
"
)
;
return
rv
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
if
(
!
suggestBlockElementToPutCaretOrError
.
inspect
(
)
|
|
!
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
rv
;
}
const
auto
firstSelectionStartPoint
=
GetFirstSelectionStartPoint
<
EditorRawDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
firstSelectionStartPoint
.
IsSet
(
)
)
)
{
return
rv
;
}
Result
<
EditorRawDOMPoint
nsresult
>
pointInBlockElementOrError
=
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
<
EditorRawDOMPoint
>
(
*
suggestBlockElementToPutCaretOrError
.
inspect
(
)
firstSelectionStartPoint
)
;
if
(
MOZ_UNLIKELY
(
pointInBlockElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
ComputePointToPutCaretInElementIfOutside
(
)
failed
but
"
"
ignored
"
)
;
return
rv
;
}
if
(
pointInBlockElementOrError
.
inspect
(
)
.
IsSet
(
)
)
{
nsresult
rvOfCollapseSelection
=
CollapseSelectionTo
(
pointInBlockElementOrError
.
inspect
(
)
)
;
if
(
MOZ_UNLIKELY
(
rvOfCollapseSelection
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvOfCollapseSelection
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
return
rv
;
}
nsresult
HTMLEditor
:
:
IndentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIndent
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditActionResult
result
=
IndentAsSubAction
(
*
editingHost
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
IndentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
OutdentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eOutdent
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditActionResult
result
=
OutdentAsSubAction
(
*
editingHost
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
OutdentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
AlignAsAction
(
const
nsAString
&
aAlignType
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForAlignment
(
aAlignType
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditActionResult
result
=
AlignAsSubAction
(
aAlignType
*
editingHost
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
AlignAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagName
(
const
nsStaticAtom
&
aTagName
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
return
GetInclusiveAncestorByTagNameInternal
(
aTagName
aContent
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
const
nsStaticAtom
&
aTagName
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
const
EditorRawDOMPoint
atAnchor
(
SelectionRef
(
)
.
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
atAnchor
.
GetContainerAsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
nullptr
;
if
(
atAnchor
.
GetContainer
(
)
-
>
HasChildNodes
(
)
&
&
atAnchor
.
GetContainerAsContent
(
)
)
{
content
=
atAnchor
.
GetChild
(
)
;
}
if
(
!
content
)
{
content
=
atAnchor
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
return
nullptr
;
}
}
return
GetInclusiveAncestorByTagNameInternal
(
aTagName
*
content
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
const
nsStaticAtom
&
aTagName
const
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
Element
*
currentElement
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
NS_WARN_IF
(
!
currentElement
)
)
{
MOZ_ASSERT
(
!
aContent
.
GetParentNode
(
)
)
;
return
nullptr
;
}
bool
lookForLink
=
IsLinkTag
(
aTagName
)
;
bool
lookForNamedAnchor
=
IsNamedAnchorTag
(
aTagName
)
;
for
(
Element
*
element
:
currentElement
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
nullptr
;
}
if
(
lookForLink
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
element
)
)
{
return
element
;
}
}
else
if
(
lookForNamedAnchor
)
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
list_
)
{
if
(
HTMLEditUtils
:
:
IsAnyListElement
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
td
)
{
if
(
HTMLEditUtils
:
:
IsTableCell
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
element
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsINode
*
aNode
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
tagName
=
=
nsGkAtoms
:
:
_empty
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aNode
)
{
AutoEditActionDataSetter
dummyEditAction
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
dummyEditAction
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
Element
>
parentElement
=
GetInclusiveAncestorByTagNameAtSelection
(
*
tagName
)
;
if
(
!
parentElement
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parentElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
if
(
!
aNode
-
>
IsContent
(
)
|
|
!
aNode
-
>
GetAsElementOrParentElement
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
Element
>
parentElement
=
GetInclusiveAncestorByTagName
(
*
tagName
*
aNode
-
>
AsContent
(
)
)
;
if
(
!
parentElement
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parentElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedElement
(
const
nsAString
&
aTagName
nsISupports
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
!
aTagName
.
IsEmpty
(
)
&
&
!
tagName
)
{
return
NS_OK
;
}
RefPtr
<
nsINode
>
selectedNode
=
GetSelectedElement
(
tagName
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
GetSelectedElement
(
)
failed
"
)
;
selectedNode
.
forget
(
aReturn
)
;
return
error
.
StealNSResult
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetSelectedElement
(
const
nsAtom
*
aTagName
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
SelectionRef
(
)
.
RangeCount
(
)
!
=
1
)
{
return
nullptr
;
}
bool
isLinkTag
=
aTagName
&
&
IsLinkTag
(
*
aTagName
)
;
bool
isNamedAnchorTag
=
aTagName
&
&
IsNamedAnchorTag
(
*
aTagName
)
;
RefPtr
<
nsRange
>
firstRange
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
MOZ_ASSERT
(
firstRange
)
;
const
RangeBoundary
&
startRef
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
startRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
const
RangeBoundary
&
endRef
=
firstRange
-
>
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
endRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
)
{
nsIContent
*
startContent
=
startRef
.
GetChildAtOffset
(
)
;
nsIContent
*
endContent
=
endRef
.
GetChildAtOffset
(
)
;
if
(
startContent
&
&
endContent
&
&
startContent
-
>
GetNextSibling
(
)
=
=
endContent
)
{
if
(
!
aTagName
)
{
if
(
!
startContent
-
>
IsElement
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
if
(
aTagName
=
=
startContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
|
|
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
startContent
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
startContent
)
)
)
{
MOZ_ASSERT
(
startContent
-
>
IsElement
(
)
)
;
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
}
}
if
(
isLinkTag
&
&
startRef
.
Container
(
)
-
>
IsContent
(
)
&
&
endRef
.
Container
(
)
-
>
IsContent
(
)
)
{
Element
*
parentLinkOfStart
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
startRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
parentLinkOfStart
)
{
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
Element
*
parentLinkOfEnd
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
endRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
parentLinkOfStart
=
=
parentLinkOfEnd
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
}
}
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
return
nullptr
;
}
PostContentIterator
postOrderIter
;
postOrderIter
.
Init
(
firstRange
)
;
RefPtr
<
Element
>
lastElementInRange
;
for
(
nsINode
*
lastNodeInRange
=
nullptr
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
lastElementInRange
)
{
return
nullptr
;
}
nsINode
*
currentNode
=
postOrderIter
.
GetCurrentNode
(
)
;
MOZ_ASSERT
(
currentNode
)
;
if
(
lastNodeInRange
&
&
lastNodeInRange
-
>
GetParentNode
(
)
!
=
currentNode
&
&
lastNodeInRange
-
>
GetNextSibling
(
)
!
=
currentNode
)
{
return
nullptr
;
}
lastNodeInRange
=
currentNode
;
lastElementInRange
=
Element
:
:
FromNodeOrNull
(
lastNodeInRange
)
;
if
(
!
lastElementInRange
)
{
continue
;
}
if
(
nsIContent
*
nextSibling
=
lastElementInRange
-
>
GetNextSibling
(
)
)
{
if
(
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
nsIContent
*
firstEditableLeaf
=
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
nextSibling
{
LeafNodeType
:
:
OnlyLeafNode
}
)
;
if
(
firstEditableLeaf
&
&
firstEditableLeaf
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
}
if
(
!
aTagName
)
{
continue
;
}
if
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
lastElementInRange
)
)
{
continue
;
}
if
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
lastElementInRange
)
)
{
continue
;
}
if
(
aTagName
=
=
lastElementInRange
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
return
nullptr
;
}
return
lastElementInRange
.
forget
(
)
;
}
CreateElementResult
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
aWithTransaction
nsAtom
&
aTagName
const
EditorDOMPoint
&
aPointToInsert
const
InitializeInsertingElement
&
aInitializer
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
Unused
<
<
aPointToInsert
.
Offset
(
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreateNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
CreateElementResult
createNewElementResult
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
MOZ_UNLIKELY
(
!
newElement
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateHTMLContent
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
nsresult
rv
=
MarkElementDirty
(
*
newElement
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
MarkElementDirty
(
)
caused
destroying
the
editor
"
)
;
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MarkElementDirty
(
)
failed
but
ignored
"
)
;
if
(
StaticPrefs
:
:
editor_initialize_element_before_connect
(
)
)
{
rv
=
aInitializer
(
*
this
*
newElement
aPointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
aInitializer
failed
"
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
}
RefPtr
<
InsertNodeTransaction
>
transaction
=
InsertNodeTransaction
:
:
Create
(
*
this
*
newElement
aPointToInsert
)
;
rv
=
aWithTransaction
=
=
WithTransaction
:
:
Yes
?
DoTransactionInternal
(
transaction
)
:
transaction
-
>
DoTransaction
(
)
;
if
(
MOZ_UNLIKELY
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
InsertNodeTransaction
:
:
DoTransaction
(
)
caused
destroying
the
"
"
editor
"
)
;
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
InsertNodeTransaction
:
:
DoTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
if
(
newElement
&
&
newElement
-
>
GetParentNode
(
)
!
=
aPointToInsert
.
GetContainer
(
)
)
{
NS_WARNING
(
"
The
new
element
was
not
inserted
into
the
expected
node
"
)
;
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
CreateElementResult
(
std
:
:
move
(
newElement
)
transaction
-
>
SuggestPointToPutCaret
<
EditorDOMPoint
>
(
)
)
;
}
(
)
;
if
(
createNewElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjCreateNode
(
aPointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Rangeupdater
:
:
SelAdjCreateNode
(
)
failed
"
)
;
return
createNewElementResult
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjCreateNode
(
EditorRawDOMPoint
(
aPointToInsert
.
GetContainer
(
)
aPointToInsert
.
Offset
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Rangeupdater
:
:
SelAdjCreateNode
(
)
failed
but
ignored
"
)
;
if
(
createNewElementResult
.
GetNewNode
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
DidCreateElement
(
*
this
*
createNewElementResult
.
GetNewNode
(
)
)
;
}
if
(
!
StaticPrefs
:
:
editor_initialize_element_before_connect
(
)
&
&
createNewElementResult
.
GetNewNode
(
)
)
{
nsresult
rv
=
aInitializer
(
*
this
MOZ_KnownLive
(
*
createNewElementResult
.
GetNewNode
(
)
)
aPointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
aInitializer
failed
"
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
CreateElementResult
(
rv
)
;
}
}
return
createNewElementResult
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAtom
&
aTagName
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
const
nsAtom
*
realTagName
=
IsLinkTag
(
aTagName
)
|
|
IsNamedAnchorTag
(
aTagName
)
?
nsGkAtoms
:
:
a
:
&
aTagName
;
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
realTagName
)
;
if
(
!
newElement
)
{
return
nullptr
;
}
IgnoredErrorResult
ignoredError
;
newElement
-
>
SetAttribute
(
u
"
_moz_dirty
"
_ns
u
"
"
_ns
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Element
:
:
SetAttribute
(
_moz_dirty
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
if
(
realTagName
=
=
nsGkAtoms
:
:
table
)
{
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
cellpadding
u
"
2
"
_ns
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
cellpadding
2
)
failed
"
)
;
return
nullptr
;
}
ignoredError
.
SuppressException
(
)
;
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
cellspacing
u
"
2
"
_ns
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
cellspacing
2
)
failed
"
)
;
return
nullptr
;
}
ignoredError
.
SuppressException
(
)
;
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
border
u
"
1
"
_ns
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
border
1
)
failed
"
)
;
return
nullptr
;
}
}
else
if
(
realTagName
=
=
nsGkAtoms
:
:
td
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
newElement
nsGkAtoms
:
:
valign
u
"
top
"
_ns
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
valign
top
)
"
"
failed
"
)
;
return
nullptr
;
}
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
newElement
=
CreateElementWithDefaults
(
MOZ_KnownLive
(
*
tagName
)
)
;
if
(
!
newElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
newElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLinkAroundSelection
(
Element
*
aAnchorElement
)
{
nsresult
rv
=
InsertLinkAroundSelectionAsAction
(
aAnchorElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertLinkAroundSelectionAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertLinkAroundSelectionAsAction
(
Element
*
aAnchorElement
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aAnchorElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLinkElement
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
NS_WARNING
(
"
Selection
was
collapsed
"
)
;
return
NS_OK
;
}
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNodeOrNull
(
aAnchorElement
)
;
if
(
!
anchor
)
{
return
NS_OK
;
}
nsAutoString
rawHref
;
anchor
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
rawHref
)
;
editActionData
.
SetData
(
rawHref
)
;
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsAutoString
href
;
anchor
-
>
GetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
RefPtr
<
nsDOMAttributeMap
>
attributeMap
=
anchor
-
>
Attributes
(
)
;
if
(
NS_WARN_IF
(
!
attributeMap
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
count
=
attributeMap
-
>
Length
(
)
;
nsAutoString
value
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
Attr
>
attribute
=
attributeMap
-
>
Item
(
i
)
;
if
(
!
attribute
)
{
continue
;
}
value
.
Truncate
(
)
;
nsAtom
*
attributeName
=
attribute
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
attribute
-
>
GetValue
(
value
)
;
nsresult
rv
=
SetInlinePropertyInternal
(
*
nsGkAtoms
:
:
a
MOZ_KnownLive
(
attributeName
)
value
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetInlinePropertyInternal
(
nsGkAtoms
:
:
a
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
isCellSelected
=
false
;
Result
<
RefPtr
<
Element
>
nsresult
>
cellOrRowOrTableElementOrError
=
GetSelectedOrParentTableElement
(
&
isCellSelected
)
;
if
(
cellOrRowOrTableElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
failed
"
)
;
return
cellOrRowOrTableElementOrError
.
unwrapErr
(
)
;
}
bool
setColor
=
!
aColor
.
IsEmpty
(
)
;
RefPtr
<
Element
>
rootElementOfBackgroundColor
=
cellOrRowOrTableElementOrError
.
unwrap
(
)
;
if
(
rootElementOfBackgroundColor
)
{
if
(
isCellSelected
|
|
rootElementOfBackgroundColor
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
)
)
{
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
scanner
.
IsInTableCellSelectionMode
(
)
)
{
if
(
setColor
)
{
for
(
const
OwningNonNull
<
Element
>
&
cellElement
:
scanner
.
ElementsRef
(
)
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
MOZ_KnownLive
(
cellElement
)
*
nsGkAtoms
:
:
bgcolor
aColor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
"
"
bgcolor
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
for
(
const
OwningNonNull
<
Element
>
&
cellElement
:
scanner
.
ElementsRef
(
)
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
MOZ_KnownLive
(
cellElement
)
*
nsGkAtoms
:
:
bgcolor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
"
"
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
}
}
else
{
rootElementOfBackgroundColor
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElementOfBackgroundColor
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
setColor
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyInclusiveAncestorInlineElements
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aContent
.
Length
(
)
)
;
Element
*
editingHost
=
aContent
.
GetEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
&
aContent
=
=
editingHost
|
|
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
aContent
EditorType
:
:
HTML
)
|
|
!
aContent
.
GetParent
(
)
)
{
return
NS_OK
;
}
{
const
Element
*
editableBlockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
aContent
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
!
editableBlockElement
|
|
HTMLEditUtils
:
:
IsEmptyNode
(
*
editableBlockElement
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
)
{
return
NS_OK
;
}
}
OwningNonNull
<
nsIContent
>
content
=
aContent
;
for
(
nsIContent
*
parentContent
:
aContent
.
AncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
parentContent
)
|
|
parentContent
-
>
Length
(
)
!
=
1
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
parentContent
EditorType
:
:
HTML
)
|
|
parentContent
=
=
editingHost
)
{
break
;
}
content
=
*
parentContent
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
content
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteAllChildrenWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
aElement
.
GetLastChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteNode
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveNode
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
aNode
-
>
AsContent
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteTextWithTransaction
(
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
{
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aTextNode
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteTextWithTransaction
(
aTextNode
aOffset
aLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ReplaceTextWithTransaction
(
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
const
nsAString
&
aStringToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aLength
>
0
|
|
!
aStringToInsert
.
IsEmpty
(
)
)
;
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
nsresult
rv
=
DeleteTextWithTransaction
(
aTextNode
aOffset
aLength
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
aLength
)
{
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
InsertTextWithTransaction
(
*
document
aStringToInsert
EditorDOMPoint
(
&
aTextNode
aOffset
)
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
insertTextResult
.
unwrapErr
(
)
;
}
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aTextNode
)
)
)
{
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditorDOMPointInText
pointToInsert
(
&
aTextNode
aOffset
)
;
Maybe
<
AutoSelectionRestorer
>
restoreSelection
;
if
(
!
AllowsTransactionsToChangeSelection
(
)
&
&
!
ArePreservingSelection
(
)
)
{
const
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
if
(
MOZ_UNLIKELY
(
!
range
)
)
{
continue
;
}
if
(
(
range
-
>
GetStartContainer
(
)
=
=
&
aTextNode
&
&
range
-
>
StartOffset
(
)
>
=
aOffset
)
|
|
(
range
-
>
GetEndContainer
(
)
=
=
&
aTextNode
&
&
range
-
>
EndOffset
(
)
>
=
aOffset
)
)
{
restoreSelection
.
emplace
(
*
this
)
;
break
;
}
}
}
RefPtr
<
ReplaceTextTransaction
>
transaction
=
ReplaceTextTransaction
:
:
Create
(
*
this
aStringToInsert
aTextNode
aOffset
aLength
)
;
MOZ_ASSERT
(
transaction
)
;
if
(
aLength
&
&
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
WillDeleteText
(
&
aTextNode
aOffset
aLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
WillDeleteText
(
)
failed
but
ignored
"
)
;
}
}
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
if
(
pointToInsert
.
IsSet
(
)
)
{
auto
[
begin
end
]
=
ComputeInsertedRange
(
pointToInsert
aStringToInsert
)
;
if
(
begin
.
IsSet
(
)
&
&
end
.
IsSet
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
DidDeleteText
(
*
this
begin
.
To
<
EditorRawDOMPoint
>
(
)
)
;
TopLevelEditSubActionDataRef
(
)
.
DidInsertText
(
*
this
begin
.
To
<
EditorRawDOMPoint
>
(
)
end
.
To
<
EditorRawDOMPoint
>
(
)
)
;
}
}
restoreSelection
.
reset
(
)
;
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidInsertText
(
&
aTextNode
aOffset
aStringToInsert
rv
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidInsertText
(
)
failed
but
ignored
"
)
;
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
rv
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorDOMPoint
&
aPointToInsert
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPointToInsert
.
GetContainer
(
)
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
EditorBase
:
:
InsertTextWithTransaction
(
aDocument
aStringToInsert
aPointToInsert
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
PrepareToInsertBRElement
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aPointToInsert
.
IsInTextNode
(
)
)
{
return
aPointToInsert
;
}
if
(
aPointToInsert
.
IsStartOfContainer
(
)
)
{
EditorDOMPoint
pointInContainer
(
aPointToInsert
.
GetContainer
(
)
)
;
if
(
!
pointInContainer
.
IsSet
(
)
)
{
NS_WARNING
(
"
Failed
to
climb
up
the
DOM
tree
from
text
node
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
pointInContainer
;
}
if
(
aPointToInsert
.
IsEndOfContainer
(
)
)
{
EditorDOMPoint
pointInContainer
(
aPointToInsert
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointInContainer
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
Failed
to
climb
up
the
DOM
tree
from
text
node
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
MOZ_ALWAYS_TRUE
(
pointInContainer
.
AdvanceOffset
(
)
)
;
return
pointInContainer
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
const
SplitNodeResult
splitTextNodeResult
=
SplitNodeWithTransaction
(
aPointToInsert
)
;
if
(
splitTextNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
splitTextNodeResult
.
unwrapErr
(
)
)
;
}
nsresult
rv
=
splitTextNodeResult
.
SuggestCaretPointTo
(
*
this
{
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SplitNodeResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
auto
atNextContent
=
splitTextNodeResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
;
if
(
MOZ_UNLIKELY
(
!
atNextContent
.
IsSet
(
)
)
)
{
NS_WARNING
(
"
The
next
node
seems
not
in
the
DOM
tree
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
atNextContent
;
}
CreateElementResult
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
aWithTransaction
const
EditorDOMPoint
&
aPointToInsert
EDirection
aSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Result
<
EditorDOMPoint
nsresult
>
maybePointToInsert
=
PrepareToInsertBRElement
(
aPointToInsert
)
;
if
(
maybePointToInsert
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
PrepareToInsertBRElement
(
%
s
)
failed
"
ToString
(
aWithTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
CreateElementResult
(
maybePointToInsert
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
maybePointToInsert
.
inspect
(
)
.
IsSetAndValid
(
)
)
;
CreateElementResult
createNewBRElementResult
=
CreateAndInsertElement
(
aWithTransaction
*
nsGkAtoms
:
:
br
maybePointToInsert
.
inspect
(
)
)
;
if
(
createNewBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
%
s
)
failed
"
ToString
(
aWithTransaction
)
.
c_str
(
)
)
.
get
(
)
)
;
return
CreateElementResult
(
createNewBRElementResult
.
unwrapErr
(
)
)
;
}
RefPtr
<
Element
>
newBRElement
=
createNewBRElementResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
newBRElement
)
;
createNewBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
switch
(
aSelect
)
{
case
eNext
:
{
const
auto
pointToPutCaret
=
EditorDOMPoint
:
:
After
(
*
newBRElement
Selection
:
:
InterlinePosition
:
:
StartOfNextLine
)
;
return
CreateElementResult
(
std
:
:
move
(
newBRElement
)
pointToPutCaret
)
;
}
case
ePrevious
:
{
const
auto
pointToPutCaret
=
EditorDOMPoint
(
newBRElement
Selection
:
:
InterlinePosition
:
:
StartOfNextLine
)
;
return
CreateElementResult
(
std
:
:
move
(
newBRElement
)
pointToPutCaret
)
;
}
default
:
NS_WARNING
(
"
aSelect
has
invalid
value
the
caller
need
to
set
selection
"
"
by
itself
"
)
;
[
[
fallthrough
]
]
;
case
eNone
:
return
CreateElementResult
(
std
:
:
move
(
newBRElement
)
createNewBRElementResult
.
UnwrapCaretPoint
(
)
)
;
}
}
CreateElementResult
HTMLEditor
:
:
InsertContainerWithTransactionInternal
(
nsIContent
&
aContentToBeWrapped
nsAtom
&
aWrapperTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
{
EditorDOMPoint
pointToInsertNewContainer
(
&
aContentToBeWrapped
)
;
if
(
NS_WARN_IF
(
!
pointToInsertNewContainer
.
IsSet
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
MOZ_ALWAYS_TRUE
(
pointToInsertNewContainer
.
AdvanceOffset
(
)
)
;
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aWrapperTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
}
AutoInsertContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
aContentToBeWrapped
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
{
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
CreateContentResult
insertContentNodeResult
=
InsertNodeWithTransaction
(
aContentToBeWrapped
EditorDOMPoint
(
newContainer
0u
)
)
;
if
(
insertContentNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
insertContentNodeResult
.
unwrapErr
(
)
)
;
}
insertContentNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
}
CreateElementResult
insertNewContainerElementResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newContainer
pointToInsertNewContainer
)
;
NS_WARNING_ASSERTION
(
insertNewContainerElementResult
.
isOk
(
)
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertNewContainerElementResult
;
}
CreateElementResult
HTMLEditor
:
:
ReplaceContainerWithTransactionInternal
(
Element
&
aOldContainer
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
bool
aCloneAllAttributes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
aOldContainer
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aOldContainer
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
const
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aCloneAllAttributes
)
{
MOZ_ASSERT
(
&
aAttribute
=
=
nsGkAtoms
:
:
_empty
)
;
CloneAttributesWithTransaction
(
*
newContainer
aOldContainer
)
;
}
else
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
}
const
OwningNonNull
<
nsINode
>
parentNode
=
*
aOldContainer
.
GetParentNode
(
)
;
const
nsCOMPtr
<
nsINode
>
referenceNode
=
aOldContainer
.
GetNextSibling
(
)
;
AutoReplaceContainerSelNotify
selStateNotify
(
RangeUpdaterRef
(
)
aOldContainer
*
newContainer
)
;
{
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfChildren
;
HTMLEditUtils
:
:
CollectChildren
(
aOldContainer
arrayOfChildren
0u
{
}
)
;
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
child
:
Reversed
(
arrayOfChildren
)
)
{
MoveNodeResult
moveChildResult
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
child
)
EditorDOMPoint
(
newContainer
0u
)
)
;
if
(
moveChildResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
moveChildResult
.
unwrapErr
(
)
)
;
}
moveChildResult
.
IgnoreCaretPointSuggestion
(
)
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
aOldContainer
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
if
(
referenceNode
&
&
(
!
referenceNode
-
>
GetParentNode
(
)
|
|
parentNode
!
=
referenceNode
-
>
GetParentNode
(
)
)
)
{
NS_WARNING
(
"
The
reference
node
for
insertion
has
been
moved
to
different
parent
"
"
so
we
got
lost
the
insertion
point
"
)
;
return
CreateElementResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
CreateElementResult
insertNewContainerElementResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newContainer
referenceNode
?
EditorDOMPoint
(
referenceNode
)
:
EditorDOMPoint
:
:
AtEndOf
(
*
parentNode
)
)
;
NS_WARNING_ASSERTION
(
insertNewContainerElementResult
.
isOk
(
)
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
MOZ_ASSERT_IF
(
insertNewContainerElementResult
.
isOk
(
)
insertNewContainerElementResult
.
GetNewNode
(
)
=
=
newContainer
)
;
return
insertNewContainerElementResult
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
RemoveContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
aElement
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aElement
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
AutoRemoveContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
EditorRawDOMPoint
(
&
aElement
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
arrayOfChildren
;
HTMLEditUtils
:
:
CollectChildren
(
aElement
arrayOfChildren
0u
{
}
)
;
const
OwningNonNull
<
nsINode
>
parentNode
=
*
aElement
.
GetParentNode
(
)
;
nsCOMPtr
<
nsIContent
>
previousChild
=
aElement
.
GetPreviousSibling
(
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
child
:
Reversed
(
arrayOfChildren
)
)
{
MoveNodeResult
moveChildResult
=
MoveNodeWithTransaction
(
MOZ_KnownLive
(
child
)
previousChild
?
EditorDOMPoint
:
:
After
(
previousChild
)
:
EditorDOMPoint
(
parentNode
0u
)
)
;
if
(
moveChildResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
moveChildResult
.
unwrapErr
(
)
)
;
}
if
(
previousChild
&
&
MOZ_UNLIKELY
(
previousChild
-
>
GetParentNode
(
)
!
=
parentNode
)
)
{
if
(
MOZ_UNLIKELY
(
child
-
>
GetParentNode
(
)
!
=
parentNode
)
)
{
NS_WARNING
(
"
Neither
the
reference
(
previous
)
sibling
nor
the
moved
child
was
"
"
in
the
expected
parent
node
"
)
;
moveChildResult
.
IgnoreCaretPointSuggestion
(
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
previousChild
=
child
-
>
GetPreviousSibling
(
)
;
}
moveChildResult
.
IgnoreCaretPointSuggestion
(
)
;
}
if
(
aElement
.
GetParentNode
(
)
&
&
aElement
.
GetParentNode
(
)
!
=
parentNode
)
{
NS_WARNING
(
"
The
removing
element
has
already
been
moved
to
another
element
"
)
;
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
auto
GetNextSiblingOf
=
[
]
(
const
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aArrayOfMovedContent
const
nsINode
&
aExpectedParentNode
)
-
>
nsIContent
*
{
for
(
const
OwningNonNull
<
nsIContent
>
&
movedChild
:
Reversed
(
aArrayOfMovedContent
)
)
{
if
(
movedChild
!
=
&
aExpectedParentNode
)
{
continue
;
}
return
movedChild
-
>
GetNextSibling
(
)
;
}
return
nullptr
;
}
;
nsCOMPtr
<
nsIContent
>
nextSibling
=
aElement
.
GetParentNode
(
)
?
aElement
.
GetNextSibling
(
)
:
GetNextSiblingOf
(
arrayOfChildren
*
parentNode
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
aElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
if
(
nextSibling
&
&
nextSibling
-
>
GetParentNode
(
)
!
=
parentNode
)
{
nextSibling
=
GetNextSiblingOf
(
arrayOfChildren
*
parentNode
)
;
}
return
nextSibling
?
EditorDOMPoint
(
nextSibling
)
:
EditorDOMPoint
:
:
AtEndOf
(
*
parentNode
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
DoContentInserted
(
aFirstNewContent
eAppended
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
DoContentInserted
(
aChild
eInserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
if
(
Element
*
root
=
GetRoot
(
)
)
{
if
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
IsInNativeAnonymousSubtree
(
)
!
=
aChild
-
>
IsInNativeAnonymousSubtree
(
)
|
|
root
-
>
IsInShadowTree
(
)
!
=
aChild
-
>
IsInShadowTree
(
)
)
{
return
false
;
}
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
IsInShadowTree
(
)
&
&
!
aChild
-
>
IsInNativeAnonymousSubtree
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIContent
*
aChild
InsertedOrAppended
aInsertedOrAppended
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
ShouldReplaceRootElement
(
)
)
{
UpdateRootElement
(
)
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
container
-
>
IsEditable
(
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnDocumentModified
(
)
failed
but
ignored
"
)
;
if
(
mInlineSpellChecker
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aChild
)
;
nsIContent
*
endContent
=
aChild
;
if
(
aInsertedOrAppended
=
=
eAppended
)
{
endContent
=
container
-
>
GetLastChild
(
)
;
}
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
NS_WARNING_ASSERTION
(
rvIgnored
=
=
NS_ERROR_NOT_INITIALIZED
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
mozInlineSpellChecker
:
:
SpellCheckRange
(
)
failed
but
ignored
"
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
SameCOMIdentity
(
aChild
mRootElement
)
)
{
mRootElement
=
nullptr
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
aChild
-
>
GetParentNode
(
)
-
>
IsEditable
(
)
)
{
if
(
aChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnDocumentModified
(
)
failed
but
ignored
"
)
;
}
}
nsresult
HTMLEditor
:
:
SelectEntireDocument
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsEmpty
(
)
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
ErrorResult
error
;
SelectionRef
(
)
.
SelectAllChildren
(
*
bodyOrDocumentElement
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
SelectAllInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
CommitComposition
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsINode
*
anchorNode
=
SelectionRef
(
)
.
GetAnchorNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
anchorNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
anchorContent
=
anchorNode
-
>
AsContent
(
)
;
nsCOMPtr
<
nsIContent
>
rootContent
;
if
(
anchorContent
-
>
HasIndependentSelection
(
)
)
{
SelectionRef
(
)
.
SetAncestorLimiter
(
nullptr
)
;
rootContent
=
mRootElement
;
if
(
NS_WARN_IF
(
!
rootContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
else
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
rootContent
=
anchorContent
-
>
GetSelectionRootContent
(
presShell
)
;
if
(
NS_WARN_IF
(
!
rootContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
Document
*
document
=
GetDocument
(
)
)
{
if
(
document
-
>
IsHTMLDocument
(
)
)
{
if
(
HTMLBodyElement
*
bodyElement
=
document
-
>
GetBodyElement
(
)
)
{
if
(
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
bodyElement
rootContent
)
)
{
rootContent
=
bodyElement
;
}
}
}
}
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
userSelection
;
if
(
!
rootContent
-
>
IsEditable
(
)
)
{
userSelection
.
emplace
(
SelectionRef
(
)
)
;
}
ErrorResult
error
;
SelectionRef
(
)
.
SelectAllChildren
(
*
rootContent
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
bool
HTMLEditor
:
:
SetCaretInTableCell
(
Element
*
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aElement
|
|
!
aElement
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsAnyTableElement
(
aElement
)
)
{
return
false
;
}
const
RefPtr
<
Element
>
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
|
|
!
aElement
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
deepestFirstChild
=
aElement
;
while
(
deepestFirstChild
-
>
HasChildren
(
)
)
{
deepestFirstChild
=
deepestFirstChild
-
>
GetFirstChild
(
)
;
}
nsresult
rv
=
CollapseSelectionToStartOf
(
*
deepestFirstChild
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
nsresult
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
nsRange
&
aInRange
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
DOMSubtreeIterator
subtreeIter
;
if
(
NS_FAILED
(
subtreeIter
.
Init
(
aInRange
)
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoTArray
<
OwningNonNull
<
Text
>
8
>
textNodes
;
subtreeIter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
-
>
bool
{
return
EditorUtils
:
:
IsEditableContent
(
*
aNode
.
AsText
(
)
EditorType
:
:
HTML
)
;
}
textNodes
)
;
while
(
textNodes
.
Length
(
)
>
1u
)
{
OwningNonNull
<
Text
>
&
leftTextNode
=
textNodes
[
0u
]
;
OwningNonNull
<
Text
>
&
rightTextNode
=
textNodes
[
1u
]
;
if
(
rightTextNode
-
>
GetPreviousSibling
(
)
!
=
leftTextNode
)
{
textNodes
.
RemoveElementAt
(
0u
)
;
continue
;
}
JoinNodesResult
result
=
JoinNodesWithTransaction
(
MOZ_KnownLive
(
*
leftTextNode
)
MOZ_KnownLive
(
*
rightTextNode
)
)
;
if
(
MOZ_UNLIKELY
(
result
.
Failed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
if
(
MOZ_LIKELY
(
result
.
RemovedContent
(
)
=
=
leftTextNode
)
)
{
textNodes
.
RemoveElementAt
(
0u
)
;
}
else
if
(
MOZ_LIKELY
(
result
.
RemovedContent
(
)
=
=
rightTextNode
)
)
{
textNodes
.
RemoveElementAt
(
1u
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
removed
unexpected
node
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionToStartOf
(
*
rootElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToPutCaret
;
if
(
nsCOMPtr
<
nsIContent
>
child
=
HTMLEditUtils
:
:
GetFirstChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
nsIContent
*
previousSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousSibling
)
&
&
!
previousSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
child
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
if
(
nsIContent
*
nextSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
nextSibling
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSibling
)
)
{
if
(
nsIContent
*
lastChild
=
HTMLEditUtils
:
:
GetLastChild
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
lastChild
)
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
:
:
AtEndOf
(
aElement
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
}
}
}
else
if
(
nsIContent
*
previousSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousSibling
)
&
&
!
previousSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
nsIContent
*
nextSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
aElement
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSibling
)
&
&
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
&
aElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
MoveCaretPointTo
(
pointToPutCaret
{
SuggestCaret
:
:
OnlyIfHasSuggestion
}
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
}
}
}
Result
<
EditorDOMPoint
nsresult
>
unwrapBlockElementResult
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
unwrapBlockElementResult
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
unwrapBlockElementResult
;
}
if
(
AllowsTransactionsToChangeSelection
(
)
&
&
unwrapBlockElementResult
.
inspect
(
)
.
IsSet
(
)
)
{
pointToPutCaret
=
unwrapBlockElementResult
.
unwrap
(
)
;
}
return
pointToPutCaret
;
}
SplitNodeResult
HTMLEditor
:
:
SplitNodeWithTransaction
(
const
EditorDOMPoint
&
aStartOfRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsInContentNode
(
)
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
aStartOfRightNode
.
ContainerAsContent
(
)
)
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSplitNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
RefPtr
<
SplitNodeTransaction
>
transaction
=
SplitNodeTransaction
:
:
Create
(
*
this
aStartOfRightNode
)
;
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoTransactionInternal
(
)
caused
destroying
the
editor
"
)
;
return
SplitNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
return
SplitNodeResult
(
rv
)
;
}
nsCOMPtr
<
nsIContent
>
newContent
=
transaction
-
>
GetNewContent
(
)
;
nsCOMPtr
<
nsIContent
>
splitContent
=
transaction
-
>
GetSplitContent
(
)
;
if
(
NS_WARN_IF
(
!
newContent
)
|
|
NS_WARN_IF
(
!
splitContent
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
TopLevelEditSubActionDataRef
(
)
.
DidSplitContent
(
*
this
*
splitContent
*
newContent
transaction
-
>
GetSplitNodeDirection
(
)
)
;
return
SplitNodeResult
(
std
:
:
move
(
newContent
)
std
:
:
move
(
splitContent
)
transaction
-
>
GetSplitNodeDirection
(
)
)
;
}
SplitNodeResult
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorDOMPoint
&
aStartOfDeepestRightNode
SplitAtEdges
aSplitAtEdges
)
{
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
GetContainer
(
)
=
=
&
aMostAncestorToSplit
|
|
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
aMostAncestorToSplit
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
nsCOMPtr
<
nsIContent
>
newLeftNodeOfMostAncestor
;
EditorDOMPoint
atStartOfRightNode
(
aStartOfDeepestRightNode
)
;
SplitNodeResult
lastResult
=
SplitNodeResult
:
:
NotHandled
(
atStartOfRightNode
GetSplitNodeDirection
(
)
)
;
while
(
true
)
{
nsIContent
*
splittingContent
=
atStartOfRightNode
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
splittingContent
)
)
{
lastResult
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
splittingContent
!
=
&
aMostAncestorToSplit
&
&
!
atStartOfRightNode
.
GetContainerParentAsContent
(
)
)
)
{
lastResult
.
IgnoreCaretPointSuggestion
(
)
;
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
splittingContent
)
)
{
if
(
splittingContent
=
=
&
aMostAncestorToSplit
)
{
return
lastResult
;
}
atStartOfRightNode
.
Set
(
splittingContent
)
;
continue
;
}
if
(
(
aSplitAtEdges
=
=
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
&
&
!
atStartOfRightNode
.
GetContainerAsText
(
)
)
|
|
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
&
&
!
atStartOfRightNode
.
IsEndOfContainer
(
)
)
)
{
lastResult
=
SplitNodeResult
:
:
MergeWithDeeperSplitNodeResult
(
SplitNodeWithTransaction
(
atStartOfRightNode
)
lastResult
)
;
if
(
lastResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
lastResult
;
}
MOZ_ASSERT
(
lastResult
.
HasCaretPointSuggestion
(
)
)
;
MOZ_ASSERT
(
lastResult
.
GetOriginalContent
(
)
=
=
splittingContent
)
;
if
(
splittingContent
=
=
&
aMostAncestorToSplit
)
{
return
lastResult
;
}
atStartOfRightNode
=
lastResult
.
AtNextContent
<
EditorDOMPoint
>
(
)
;
}
else
if
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
)
{
lastResult
=
SplitNodeResult
:
:
HandledButDidNotSplitDueToEndOfContainer
(
*
splittingContent
GetSplitNodeDirection
(
)
&
lastResult
)
;
if
(
splittingContent
=
=
&
aMostAncestorToSplit
)
{
return
lastResult
;
}
atStartOfRightNode
.
SetAfter
(
splittingContent
)
;
}
else
{
if
(
splittingContent
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
:
:
HandledButDidNotSplitDueToStartOfContainer
(
*
splittingContent
GetSplitNodeDirection
(
)
&
lastResult
)
;
}
lastResult
=
SplitNodeResult
:
:
NotHandled
(
atStartOfRightNode
GetSplitNodeDirection
(
)
&
lastResult
)
;
atStartOfRightNode
.
Set
(
splittingContent
)
;
}
}
}
SplitNodeResult
HTMLEditor
:
:
DoSplitNode
(
const
EditorDOMPoint
&
aStartOfRightNode
nsIContent
&
aNewNode
)
{
Unused
<
<
aStartOfRightNode
.
Offset
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsInContentNode
(
)
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
savingRange
;
savingRange
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
savingRange
.
mSelection
&
&
selectionType
=
=
SelectionType
:
:
eNormal
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
!
savingRange
.
mSelection
)
{
continue
;
}
for
(
uint32_t
j
:
IntegerRange
(
savingRange
.
mSelection
-
>
RangeCount
(
)
)
)
{
const
nsRange
*
r
=
savingRange
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
savingRange
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
savingRange
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
savingRange
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
savingRange
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
savedRanges
.
AppendElement
(
savingRange
)
;
}
}
nsCOMPtr
<
nsINode
>
parent
=
aStartOfRightNode
.
GetContainerParent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
parent
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
nsIContent
*
firstChildOfRightNode
=
aStartOfRightNode
.
GetChild
(
)
;
IgnoredErrorResult
error
;
parent
-
>
InsertBefore
(
aNewNode
aStartOfRightNode
.
GetContainer
(
)
error
)
;
if
(
MOZ_UNLIKELY
(
error
.
Failed
(
)
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
if
(
!
aStartOfRightNode
.
IsStartOfContainer
(
)
)
{
Text
*
rightAsText
=
aStartOfRightNode
.
GetContainerAsText
(
)
;
Text
*
leftAsText
=
aNewNode
.
GetAsText
(
)
;
if
(
rightAsText
&
&
leftAsText
)
{
nsAutoString
leftText
;
IgnoredErrorResult
ignoredError
;
rightAsText
-
>
SubstringData
(
0
aStartOfRightNode
.
Offset
(
)
leftText
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Text
:
:
SubstringData
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
DoDeleteText
(
MOZ_KnownLive
(
*
rightAsText
)
0
aStartOfRightNode
.
Offset
(
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoDeleteText
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
DoSetText
(
MOZ_KnownLive
(
*
leftAsText
)
leftText
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoSetText
(
)
failed
but
ignored
"
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
!
rightAsText
&
&
!
leftAsText
)
;
if
(
!
firstChildOfRightNode
)
{
IgnoredErrorResult
ignoredError
;
MoveAllChildren
(
*
aStartOfRightNode
.
GetContainer
(
)
EditorRawDOMPoint
(
&
aNewNode
0u
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
MoveAllChildren
(
)
failed
but
ignored
"
)
;
}
else
if
(
NS_WARN_IF
(
aStartOfRightNode
.
GetContainer
(
)
!
=
firstChildOfRightNode
-
>
GetParentNode
(
)
)
)
{
}
else
{
IgnoredErrorResult
ignoredError
;
MovePreviousSiblings
(
*
firstChildOfRightNode
EditorRawDOMPoint
(
&
aNewNode
0u
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
MovePreviousSiblings
(
)
failed
but
ignored
"
)
;
}
}
}
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
NS_WARNING_ASSERTION
(
!
Destroyed
(
)
"
The
editor
is
destroyed
during
splitting
a
node
"
)
;
const
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
SavedRange
&
savedRange
:
savedRanges
)
{
if
(
savedRange
.
mSelection
!
=
previousSelection
)
{
MOZ_KnownLive
(
savedRange
.
mSelection
)
-
>
RemoveAllRanges
(
error
)
;
if
(
MOZ_UNLIKELY
(
error
.
Failed
(
)
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
previousSelection
=
savedRange
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
savedRange
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
savedRange
.
mStartContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
savedRange
.
mStartOffset
<
aStartOfRightNode
.
Offset
(
)
)
{
savedRange
.
mStartContainer
=
&
aNewNode
;
}
else
if
(
savedRange
.
mStartOffset
>
=
aStartOfRightNode
.
Offset
(
)
)
{
savedRange
.
mStartOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
else
{
NS_WARNING
(
"
The
stored
start
offset
was
smaller
than
the
right
node
offset
"
)
;
savedRange
.
mStartOffset
=
0u
;
}
}
if
(
savedRange
.
mEndContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
savedRange
.
mEndOffset
<
aStartOfRightNode
.
Offset
(
)
)
{
savedRange
.
mEndContainer
=
&
aNewNode
;
}
else
if
(
savedRange
.
mEndOffset
>
=
aStartOfRightNode
.
Offset
(
)
)
{
savedRange
.
mEndOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
else
{
NS_WARNING
(
"
The
stored
end
offset
was
smaller
than
the
right
node
offset
"
)
;
savedRange
.
mEndOffset
=
0u
;
}
}
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
savedRange
.
mStartContainer
savedRange
.
mStartOffset
savedRange
.
mEndContainer
savedRange
.
mEndOffset
error
)
;
if
(
MOZ_UNLIKELY
(
error
.
Failed
(
)
)
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
MOZ_KnownLive
(
savedRange
.
mSelection
)
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
error
)
;
if
(
MOZ_UNLIKELY
(
error
.
Failed
(
)
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
parent
!
=
aStartOfRightNode
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
parent
!
=
aNewNode
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
aNewNode
.
GetNextSibling
(
)
!
=
aStartOfRightNode
.
GetContainer
(
)
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjSplitNode
(
*
aStartOfRightNode
.
ContainerAsContent
(
)
aStartOfRightNode
.
Offset
(
)
aNewNode
GetSplitNodeDirection
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
RangeUpdater
:
:
SelAdjSplitNode
(
)
failed
but
ignored
"
)
;
return
SplitNodeResult
(
aNewNode
*
aStartOfRightNode
.
ContainerAsContent
(
)
GetSplitNodeDirection
(
)
)
;
}
JoinNodesResult
HTMLEditor
:
:
JoinNodesWithTransaction
(
nsIContent
&
aLeftContent
nsIContent
&
aRightContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aLeftContent
!
=
&
aRightContent
)
;
MOZ_ASSERT
(
aLeftContent
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aRightContent
.
GetParentNode
(
)
)
;
MOZ_ASSERT
(
aLeftContent
.
GetParentNode
(
)
=
=
aRightContent
.
GetParentNode
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eJoinNodes
nsIEditor
:
:
ePrevious
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
JoinNodesResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aRightContent
.
GetParentNode
(
)
)
)
)
{
return
JoinNodesResult
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
JoinNodesTransaction
>
transaction
=
JoinNodesTransaction
:
:
MaybeCreate
(
*
this
aLeftContent
aRightContent
)
;
if
(
MOZ_UNLIKELY
(
!
transaction
)
)
{
NS_WARNING
(
"
JoinNodesTransaction
:
:
MaybeCreate
(
)
failed
"
)
;
return
JoinNodesResult
(
NS_ERROR_FAILURE
)
;
}
const
nsresult
rv
=
DoTransactionInternal
(
transaction
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
JoinNodesResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
transaction
-
>
GetRemovedContent
(
)
)
|
|
NS_WARN_IF
(
!
transaction
-
>
GetExistingContent
(
)
)
)
)
{
return
JoinNodesResult
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
transaction
-
>
GetExistingContent
(
)
-
>
GetParent
(
)
!
=
transaction
-
>
GetParentNode
(
)
)
)
)
{
return
JoinNodesResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
return
JoinNodesResult
(
rv
)
;
}
return
JoinNodesResult
(
transaction
-
>
CreateJoinedPoint
<
EditorDOMPoint
>
(
)
*
transaction
-
>
GetRemovedContent
(
)
transaction
-
>
GetJoinNodesDirection
(
)
)
;
}
void
HTMLEditor
:
:
DidJoinNodesTransaction
(
const
JoinNodesTransaction
&
aTransaction
nsresult
aDoJoinNodesResult
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aTransaction
.
GetRemovedContent
(
)
)
|
|
NS_WARN_IF
(
!
aTransaction
.
GetExistingContent
(
)
)
)
)
{
return
;
}
if
(
MOZ_UNLIKELY
(
aTransaction
.
GetExistingContent
(
)
-
>
GetParentNode
(
)
!
=
aTransaction
.
GetParentNode
(
)
)
)
{
return
;
}
TopLevelEditSubActionDataRef
(
)
.
DidJoinContents
(
*
this
aTransaction
.
CreateJoinedPoint
<
EditorRawDOMPoint
>
(
)
)
;
if
(
NS_SUCCEEDED
(
aDoJoinNodesResult
)
)
{
if
(
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
mTextServicesDocument
)
{
textServicesDocument
-
>
DidJoinContents
(
aTransaction
.
CreateJoinedPoint
<
EditorRawDOMPoint
>
(
)
*
aTransaction
.
GetRemovedContent
(
)
aTransaction
.
GetJoinNodesDirection
(
)
)
;
}
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidJoinContents
(
aTransaction
.
CreateJoinedPoint
<
EditorRawDOMPoint
>
(
)
aTransaction
.
GetRemovedContent
(
)
aTransaction
.
GetJoinNodesDirection
(
)
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidJoinContents
(
)
failed
but
ignored
"
)
;
}
}
}
nsresult
HTMLEditor
:
:
DoJoinNodes
(
nsIContent
&
aContentToKeep
nsIContent
&
aContentToRemove
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
const
uint32_t
removingContentLength
=
aContentToRemove
.
Length
(
)
;
const
Maybe
<
uint32_t
>
removingContentIndex
=
aContentToRemove
.
ComputeIndexInParentNode
(
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
{
EditorRawDOMPoint
atRemovingNode
(
&
aContentToRemove
)
;
EditorRawDOMPoint
atNodeToKeep
(
&
aContentToKeep
)
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
savingRange
;
savingRange
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
selectionType
=
=
SelectionType
:
:
eNormal
)
{
if
(
NS_WARN_IF
(
!
savingRange
.
mSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
savingRange
.
mSelection
)
{
continue
;
}
const
uint32_t
rangeCount
=
savingRange
.
mSelection
-
>
RangeCount
(
)
;
for
(
const
uint32_t
j
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
savingRange
.
mSelection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
const
RefPtr
<
nsRange
>
r
=
savingRange
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
savingRange
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
savingRange
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
savingRange
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
savingRange
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
if
(
savingRange
.
mStartContainer
)
{
if
(
savingRange
.
mStartContainer
=
=
atNodeToKeep
.
GetContainer
(
)
&
&
atRemovingNode
.
Offset
(
)
<
savingRange
.
mStartOffset
&
&
savingRange
.
mStartOffset
<
=
atNodeToKeep
.
Offset
(
)
)
{
savingRange
.
mStartContainer
=
&
aContentToRemove
;
savingRange
.
mStartOffset
=
removingContentLength
;
}
if
(
savingRange
.
mEndContainer
=
=
atNodeToKeep
.
GetContainer
(
)
&
&
atRemovingNode
.
Offset
(
)
<
savingRange
.
mEndOffset
&
&
savingRange
.
mEndOffset
<
=
atNodeToKeep
.
Offset
(
)
)
{
savingRange
.
mEndContainer
=
&
aContentToRemove
;
savingRange
.
mEndOffset
=
removingContentLength
;
}
}
savedRanges
.
AppendElement
(
savingRange
)
;
}
}
}
nsresult
rv
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
if
(
aContentToKeep
.
IsText
(
)
&
&
aContentToRemove
.
IsText
(
)
)
{
nsAutoString
rightText
;
nsAutoString
leftText
;
aContentToKeep
.
AsText
(
)
-
>
GetData
(
rightText
)
;
aContentToRemove
.
AsText
(
)
-
>
GetData
(
leftText
)
;
leftText
+
=
rightText
;
IgnoredErrorResult
ignoredError
;
DoSetText
(
MOZ_KnownLive
(
*
aContentToKeep
.
AsText
(
)
)
leftText
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoSetText
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINodeList
>
childNodes
=
aContentToRemove
.
ChildNodes
(
)
;
MOZ_ASSERT
(
childNodes
)
;
nsCOMPtr
<
nsIContent
>
firstChild
=
aContentToKeep
.
GetFirstChild
(
)
;
for
(
uint32_t
i
=
childNodes
-
>
Length
(
)
;
i
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
childNode
=
childNodes
-
>
Item
(
i
-
1
)
;
if
(
childNode
)
{
IgnoredErrorResult
error
;
aContentToKeep
.
InsertBefore
(
*
childNode
firstChild
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
firstChild
=
std
:
:
move
(
childNode
)
;
}
}
return
NS_OK
;
}
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aContentToRemove
.
Remove
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
if
(
MOZ_LIKELY
(
removingContentIndex
.
isSome
(
)
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjJoinNodes
(
EditorRawDOMPoint
(
&
aContentToKeep
std
:
:
min
(
removingContentLength
aContentToKeep
.
Length
(
)
)
)
aContentToRemove
*
removingContentIndex
GetJoinNodesDirection
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
RangeUpdater
:
:
SelAdjJoinNodes
(
)
failed
but
ignored
"
)
;
}
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
const
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
SavedRange
&
savedRange
:
savedRanges
)
{
if
(
savedRange
.
mSelection
!
=
previousSelection
)
{
IgnoredErrorResult
error
;
MOZ_KnownLive
(
savedRange
.
mSelection
)
-
>
RemoveAllRanges
(
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
previousSelection
=
savedRange
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
savedRange
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
savedRange
.
mStartContainer
=
=
&
aContentToRemove
)
{
savedRange
.
mStartContainer
=
&
aContentToKeep
;
}
else
if
(
savedRange
.
mStartContainer
=
=
&
aContentToKeep
)
{
savedRange
.
mStartOffset
+
=
removingContentLength
;
}
if
(
savedRange
.
mEndContainer
=
=
&
aContentToRemove
)
{
savedRange
.
mEndContainer
=
&
aContentToKeep
;
}
else
if
(
savedRange
.
mEndContainer
=
=
&
aContentToKeep
)
{
savedRange
.
mEndOffset
+
=
removingContentLength
;
}
const
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
savedRange
.
mStartContainer
savedRange
.
mStartOffset
savedRange
.
mEndContainer
savedRange
.
mEndOffset
IgnoreErrors
(
)
)
;
if
(
!
newRange
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
IgnoredErrorResult
error
;
MOZ_KnownLive
(
savedRange
.
mSelection
)
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
if
(
allowedTransactionsToChangeSelection
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionTo
(
EditorRawDOMPoint
(
&
aContentToKeep
removingContentLength
)
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBases
:
:
CollapseSelectionTos
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
MoveNodeResult
HTMLEditor
:
:
MoveNodeWithTransaction
(
nsIContent
&
aContentToMove
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
oldPoint
(
&
aContentToMove
)
;
if
(
NS_WARN_IF
(
!
oldPoint
.
IsSet
(
)
)
)
{
return
MoveNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
aPointToInsert
=
=
oldPoint
)
{
return
MoveNodeIgnored
(
aPointToInsert
.
NextPoint
(
)
)
;
}
RefPtr
<
MoveNodeTransaction
>
moveNodeTransaction
=
MoveNodeTransaction
:
:
MaybeCreate
(
*
this
aContentToMove
aPointToInsert
)
;
if
(
MOZ_UNLIKELY
(
!
moveNodeTransaction
)
)
{
NS_WARNING
(
"
MoveNodeTransaction
:
:
MaybeCreate
(
)
failed
"
)
;
return
MoveNodeResult
(
NS_ERROR_FAILURE
)
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eMoveNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
MoveNodeResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
TopLevelEditSubActionDataRef
(
)
.
WillDeleteContent
(
*
this
aContentToMove
)
;
nsresult
rv
=
DoTransactionInternal
(
moveNodeTransaction
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
mTextServicesDocument
)
{
const
OwningNonNull
<
TextServicesDocument
>
textServicesDocument
=
*
mTextServicesDocument
;
textServicesDocument
-
>
DidDeleteContent
(
aContentToMove
)
;
}
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidDeleteNode
(
&
aContentToMove
rv
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidDeleteNode
(
)
failed
but
ignored
"
)
;
}
}
if
(
MOZ_UNLIKELY
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
MoveNodeTransaction
:
:
DoTransaction
(
)
caused
destroying
the
editor
"
)
;
return
MoveNodeResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
MoveNodeTransaction
:
:
DoTransaction
(
)
failed
"
)
;
return
MoveNodeResult
(
rv
)
;
}
TopLevelEditSubActionDataRef
(
)
.
DidInsertContent
(
*
this
aContentToMove
)
;
return
MoveNodeHandled
(
moveNodeTransaction
-
>
SuggestNextInsertionPoint
<
EditorDOMPoint
>
(
)
moveNodeTransaction
-
>
SuggestPointToPutCaret
<
EditorDOMPoint
>
(
)
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
DeleteSelectionAndCreateElement
(
nsAtom
&
aTag
const
InitializeInsertingElement
&
aInitializer
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
EditorDOMPoint
pointToInsert
(
SelectionRef
(
)
.
AnchorRef
(
)
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
CreateElementResult
createNewElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
aTag
pointToInsert
aInitializer
)
;
if
(
createNewElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
createNewElementResult
.
unwrapErr
(
)
)
;
}
MOZ_ASSERT
(
createNewElementResult
.
GetNewNode
(
)
)
;
createNewElementResult
.
IgnoreCaretPointSuggestion
(
)
;
rv
=
CollapseSelectionTo
(
EditorRawDOMPoint
:
:
After
(
*
createNewElementResult
.
GetNewNode
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
createNewElementResult
.
UnwrapNewNode
(
)
;
}
nsresult
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
&
&
SelectionRef
(
)
.
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
"
Selection
not
collapsed
after
delete
"
)
;
}
EditorDOMPoint
atAnchor
(
SelectionRef
(
)
.
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
|
|
!
atAnchor
.
IsInDataNode
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
atAnchor
.
GetContainerParent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atAnchor
.
IsStartOfContainer
(
)
)
{
const
EditorRawDOMPoint
atAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchorContainer
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
atAnchorContainer
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
if
(
atAnchor
.
IsEndOfContainer
(
)
)
{
EditorRawDOMPoint
afterAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
afterAnchorContainer
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
afterAnchorContainer
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
const
SplitNodeResult
splitAtAnchorResult
=
SplitNodeWithTransaction
(
atAnchor
)
;
if
(
splitAtAnchorResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
splitAtAnchorResult
.
unwrapErr
(
)
;
}
const
EditorRawDOMPoint
&
atRightContent
=
splitAtAnchorResult
.
AtNextContent
<
EditorRawDOMPoint
>
(
)
;
if
(
NS_WARN_IF
(
!
atRightContent
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atRightContent
.
IsSetAndValid
(
)
)
;
splitAtAnchorResult
.
IgnoreCaretPointSuggestion
(
)
;
nsresult
rv
=
CollapseSelectionTo
(
atRightContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
bool
HTMLEditor
:
:
IsEmpty
(
)
const
{
if
(
mPaddingBRElementForEmptyEditor
)
{
return
true
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
!
bodyOrDocumentElement
)
{
return
true
;
}
for
(
nsIContent
*
childContent
=
bodyOrDocumentElement
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsText
(
)
|
|
childContent
-
>
Length
(
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
nsAutoScriptBlocker
scriptBlocker
;
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
aElement
)
;
if
(
!
IsCSSEnabled
(
)
|
|
!
mCSSEditUtils
)
{
if
(
mCSSEditUtils
&
&
styledElement
)
{
nsresult
rv
=
aSuppressTransaction
?
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyleWithoutTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
nullptr
)
:
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
nullptr
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyle
*
Transaction
(
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyle
*
Transaction
(
)
"
"
failed
but
ignored
"
)
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
styledElement
)
{
Result
<
int32_t
nsresult
>
count
=
aSuppressTransaction
?
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithoutTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
&
aValue
)
:
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
&
aValue
)
;
if
(
count
.
isErr
(
)
)
{
if
(
count
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyle
*
Transaction
(
)
failed
but
"
"
ignored
"
)
;
}
if
(
count
.
inspect
(
)
)
{
nsAutoString
existingValue
;
if
(
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
existingValue
)
)
{
return
NS_OK
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
UnsetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
nsAutoString
existingValue
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
)
;
existingValue
.
Append
(
HTMLEditUtils
:
:
kSpace
)
;
existingValue
.
Append
(
aValue
)
;
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
style
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
nsGkAtoms
:
:
style
existingValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
style
)
failed
"
)
;
return
rv
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
&
&
CSSEditUtils
:
:
IsCSSEditableProperty
(
aElement
nullptr
aAttribute
)
)
{
nsStyledElement
*
styledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
aElement
)
;
if
(
NS_WARN_IF
(
!
styledElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
aSuppressTransaction
?
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyleWithoutTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
nullptr
)
:
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
styledElement
)
nullptr
aAttribute
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyle
*
Transaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
return
NS_OK
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
UnsetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetIsCSSEnabled
(
bool
aIsCSSPrefChecked
)
{
if
(
!
mCSSEditUtils
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableCSS
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mCSSEditUtils
-
>
SetCSSEnabled
(
aIsCSSPrefChecked
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
IsInPlaintextMode
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
bool
selectionIsCollapsed
=
SelectionRef
(
)
.
IsCollapsed
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
"
"
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRef
(
)
.
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
startOfRange
(
range
-
>
StartRef
(
)
)
;
EditorDOMPoint
endOfRange
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
)
{
if
(
startOfRange
.
IsInTextNode
(
)
)
{
if
(
const
RefPtr
<
nsStyledElement
>
editableBlockStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetAncestorElement
(
*
startOfRange
.
ContainerAsText
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
*
editableBlockStyledElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
selectionIsCollapsed
)
{
if
(
RefPtr
<
nsStyledElement
>
styledElement
=
startOfRange
.
GetContainerAsStyledElement
(
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
*
styledElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
continue
;
}
if
(
(
startOfRange
.
IsStartOfContainer
(
)
&
&
endOfRange
.
IsStartOfContainer
(
)
)
|
|
startOfRange
.
Offset
(
)
+
1
=
=
endOfRange
.
Offset
(
)
)
{
if
(
NS_WARN_IF
(
startOfRange
.
IsInDataNode
(
)
)
)
{
continue
;
}
if
(
const
RefPtr
<
nsStyledElement
>
editableBlockStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
startOfRange
.
GetChild
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
*
editableBlockStyledElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
continue
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
ContentSubtreeIterator
subtreeIter
;
nsresult
rv
=
subtreeIter
.
Init
(
range
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ContentSubtreeIterator
:
:
Init
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
RefPtr
<
Element
>
handledBlockParent
;
if
(
startOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
startOfRange
.
ContainerAsText
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
editableBlockElement
&
&
handledBlockParent
!
=
editableBlockElement
)
{
handledBlockParent
=
editableBlockElement
;
if
(
nsStyledElement
*
blockStyledElement
=
nsStyledElement
:
:
FromNode
(
handledBlockParent
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
blockStyledElement
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
content
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
editableBlockElement
&
&
handledBlockParent
!
=
editableBlockElement
)
{
handledBlockParent
=
editableBlockElement
;
if
(
nsStyledElement
*
blockStyledElement
=
nsStyledElement
:
:
FromNode
(
handledBlockParent
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
MOZ_KnownLive
(
*
blockStyledElement
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
}
}
if
(
endOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
endOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
Element
*
const
editableBlockElement
=
HTMLEditUtils
:
:
GetAncestorElement
(
*
endOfRange
.
ContainerAsText
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
;
if
(
editableBlockElement
&
&
handledBlockParent
!
=
editableBlockElement
)
{
if
(
RefPtr
<
nsStyledElement
>
blockStyledElement
=
nsStyledElement
:
:
FromNode
(
editableBlockElement
)
)
{
Result
<
int32_t
nsresult
>
result
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyleWithTransaction
(
*
blockStyledElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSEquivalentToHTMLStyleWithTransaction
(
"
"
nsGkAtoms
:
:
bgcolor
)
failed
but
ignored
"
)
;
}
}
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBackgroundColor
(
const
nsAString
&
aColor
)
{
nsresult
rv
=
SetBackgroundColorAsAction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBackgroundColorAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetBackgroundColorAsAction
(
const
nsAString
&
aColor
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetBackgroundColor
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
SetCSSBackgroundColorWithTransaction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetHTMLBackgroundColorWithTransaction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
Result
<
EditorDOMPoint
nsresult
>
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
Element
&
aPreviousBlock
Element
&
aNewBlock
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
AutoTArray
<
OwningNonNull
<
nsIContent
>
32
>
newBlockChildren
;
HTMLEditor
:
:
GetChildNodesOf
(
aNewBlock
newBlockChildren
)
;
for
(
const
OwningNonNull
<
nsIContent
>
&
child
:
newBlockChildren
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
child
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
MOZ_UNLIKELY
(
aNewBlock
.
GetFirstChild
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
nsIContent
*
deepestEditableContent
=
nullptr
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
&
aPreviousBlock
;
child
;
child
=
HTMLEditUtils
:
:
GetLastChild
(
*
child
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
)
{
deepestEditableContent
=
child
;
}
while
(
deepestEditableContent
&
&
deepestEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
deepestEditableContent
=
HTMLEditUtils
:
:
GetPreviousContent
(
*
deepestEditableContent
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
&
aEditingHost
)
;
}
if
(
!
deepestEditableContent
)
{
return
EditorDOMPoint
(
&
aNewBlock
0u
)
;
}
Element
*
deepestVisibleEditableElement
=
deepestEditableContent
-
>
GetAsElementOrParentElement
(
)
;
if
(
!
deepestVisibleEditableElement
)
{
return
EditorDOMPoint
(
&
aNewBlock
0u
)
;
}
RefPtr
<
Element
>
lastClonedElement
firstClonedElement
;
for
(
RefPtr
<
Element
>
elementInPreviousBlock
=
deepestVisibleEditableElement
;
elementInPreviousBlock
&
&
elementInPreviousBlock
!
=
&
aPreviousBlock
;
elementInPreviousBlock
=
elementInPreviousBlock
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsInlineStyle
(
elementInPreviousBlock
)
&
&
!
elementInPreviousBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
continue
;
}
OwningNonNull
<
nsAtom
>
tagName
=
*
elementInPreviousBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
!
firstClonedElement
)
{
CreateElementResult
createNewElementResult
=
CreateAndInsertElement
(
WithTransaction
:
:
Yes
tagName
EditorDOMPoint
(
&
aNewBlock
0u
)
[
&
elementInPreviousBlock
]
(
HTMLEditor
&
aHTMLEditor
Element
&
aNewElement
const
EditorDOMPoint
&
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
aHTMLEditor
.
CloneAttributesWithTransaction
(
aNewElement
*
elementInPreviousBlock
)
;
return
NS_OK
;
}
)
;
if
(
createNewElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAndInsertElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
createNewElementResult
.
unwrapErr
(
)
)
;
}
createNewElementResult
.
IgnoreCaretPointSuggestion
(
)
;
firstClonedElement
=
lastClonedElement
=
createNewElementResult
.
UnwrapNewNode
(
)
;
continue
;
}
CreateElementResult
wrapClonedElementResult
=
InsertContainerWithTransaction
(
*
lastClonedElement
tagName
)
;
if
(
wrapClonedElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
Err
(
wrapClonedElementResult
.
unwrapErr
(
)
)
;
}
wrapClonedElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
wrapClonedElementResult
.
GetNewNode
(
)
)
;
lastClonedElement
=
wrapClonedElementResult
.
UnwrapNewNode
(
)
;
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
}
if
(
!
firstClonedElement
)
{
return
EditorDOMPoint
(
&
aNewBlock
0u
)
;
}
CreateElementResult
insertBRElementResult
=
InsertBRElement
(
WithTransaction
:
:
Yes
EditorDOMPoint
(
firstClonedElement
0u
)
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
Err
(
insertBRElementResult
.
unwrapErr
(
)
)
;
}
insertBRElementResult
.
IgnoreCaretPointSuggestion
(
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
return
EditorDOMPoint
(
insertBRElementResult
.
GetNewNode
(
)
)
;
}
nsresult
HTMLEditor
:
:
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
{
aX
=
0
;
aY
=
0
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
NS_OK
;
}
nsIFrame
*
absoluteContainerBlockFrame
=
presShell
-
>
GetAbsoluteContainingBlock
(
frame
)
;
if
(
NS_WARN_IF
(
!
absoluteContainerBlockFrame
)
)
{
return
NS_OK
;
}
nsPoint
off
=
frame
-
>
GetOffsetTo
(
absoluteContainerBlockFrame
)
;
aX
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
x
)
;
aY
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
y
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetSelectionContainerElement
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsINode
*
focusNode
=
nullptr
;
if
(
SelectionRef
(
)
.
IsCollapsed
(
)
)
{
focusNode
=
SelectionRef
(
)
.
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
else
{
const
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
If
0
Selection
:
:
IsCollapsed
(
)
should
return
true
"
)
;
if
(
rangeCount
=
=
1
)
{
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
const
RangeBoundary
&
startRef
=
range
-
>
StartRef
(
)
;
const
RangeBoundary
&
endRef
=
range
-
>
EndRef
(
)
;
if
(
startRef
.
Container
(
)
-
>
IsElement
(
)
&
&
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
&
&
startRef
.
GetChildAtOffset
(
)
&
&
startRef
.
GetChildAtOffset
(
)
-
>
GetNextSibling
(
)
=
=
endRef
.
GetChildAtOffset
(
)
)
{
focusNode
=
startRef
.
GetChildAtOffset
(
)
;
MOZ_ASSERT
(
focusNode
"
Start
container
must
not
be
nullptr
"
)
;
}
else
{
focusNode
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
focusNode
)
{
NS_WARNING
(
"
AbstractRange
:
:
GetClosestCommonInclusiveAncestor
(
)
returned
"
"
nullptr
"
)
;
return
nullptr
;
}
}
}
else
{
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
range
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
!
focusNode
)
{
focusNode
=
startContainer
;
}
else
if
(
focusNode
!
=
startContainer
)
{
focusNode
=
startContainer
-
>
GetParentNode
(
)
;
break
;
}
}
if
(
!
focusNode
)
{
NS_WARNING
(
"
Focused
node
of
selection
was
not
found
"
)
;
return
nullptr
;
}
}
}
if
(
focusNode
-
>
IsText
(
)
)
{
focusNode
=
focusNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
return
focusNode
-
>
AsElement
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IsAnonymousElement
(
Element
*
aElement
bool
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
bool
aCreatesNewParagraph
)
{
mCRInParagraphCreatesParagraph
=
aCreatesNewParagraph
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
const
{
return
mCRInParagraphCreatesParagraph
;
}
nsresult
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
bool
*
aCreatesNewParagraph
)
{
*
aCreatesNewParagraph
=
mCRInParagraphCreatesParagraph
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetFocusedElement
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
nullptr
;
}
Element
*
const
focusedElement
=
focusManager
-
>
GetFocusedElement
(
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
const
bool
inDesignMode
=
IsInDesignMode
(
)
;
if
(
!
focusedElement
)
{
if
(
inDesignMode
&
&
OurWindowHasFocus
(
)
)
{
return
document
-
>
GetRootElement
(
)
;
}
return
nullptr
;
}
if
(
inDesignMode
)
{
return
OurWindowHasFocus
(
)
&
&
focusedElement
-
>
IsInclusiveDescendantOf
(
document
)
?
focusedElement
:
nullptr
;
}
if
(
!
focusedElement
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
focusedElement
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
OurWindowHasFocus
(
)
?
focusedElement
:
nullptr
;
}
bool
HTMLEditor
:
:
IsActiveInDOMWindow
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
const
bool
inDesignMode
=
IsInDesignMode
(
)
;
if
(
inDesignMode
)
{
return
true
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
if
(
!
content
)
{
return
false
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
true
;
}
Element
*
HTMLEditor
:
:
ComputeEditingHostInternal
(
const
nsIContent
*
aContent
LimitInBodyElement
aLimitInBodyElement
)
const
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
auto
MaybeLimitInBodyElement
=
[
&
]
(
const
Element
*
aCandidiateEditingHost
)
-
>
Element
*
{
if
(
!
aCandidiateEditingHost
)
{
return
nullptr
;
}
if
(
aLimitInBodyElement
!
=
LimitInBodyElement
:
:
Yes
)
{
return
const_cast
<
Element
*
>
(
aCandidiateEditingHost
)
;
}
if
(
document
-
>
GetBodyElement
(
)
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
aCandidiateEditingHost
document
-
>
GetBodyElement
(
)
)
)
{
return
const_cast
<
Element
*
>
(
aCandidiateEditingHost
)
;
}
return
document
-
>
GetBodyElement
(
)
;
}
;
if
(
IsInDesignMode
(
)
)
{
return
document
-
>
GetBodyElement
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
const
nsIContent
*
const
content
=
aContent
?
aContent
:
nsIContent
:
:
FromNodeOrNull
(
SelectionRef
(
)
.
GetFocusNode
(
)
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
return
nullptr
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
nullptr
;
}
if
(
MOZ_UNLIKELY
(
content
-
>
IsInNativeAnonymousSubtree
(
)
)
)
{
return
nullptr
;
}
return
MaybeLimitInBodyElement
(
const_cast
<
nsIContent
*
>
(
content
)
-
>
GetEditingHost
(
)
)
;
}
void
HTMLEditor
:
:
NotifyEditingHostMaybeChanged
(
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
GetDocument
(
)
)
)
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
nsIContent
*
ancestorLimiter
=
SelectionRef
(
)
.
GetAncestorLimiter
(
)
;
if
(
!
ancestorLimiter
)
{
return
;
}
nsIContent
*
editingHost
=
ComputeEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
;
}
if
(
ancestorLimiter
-
>
IsInclusiveDescendantOf
(
editingHost
)
|
|
(
ancestorLimiter
-
>
IsInDesignMode
(
)
!
=
editingHost
-
>
IsInDesignMode
(
)
)
)
{
EditorBase
:
:
InitializeSelectionAncestorLimit
(
*
editingHost
)
;
}
}
EventTarget
*
HTMLEditor
:
:
GetDOMEventTarget
(
)
const
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
has
not
been
initialized
yet
"
)
;
return
GetDocument
(
)
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
const
{
if
(
!
mRootElement
)
{
return
true
;
}
return
mRootElement
!
=
GetBodyElement
(
)
;
}
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
MOZ_ASSERT
(
mPendingRootElementUpdatedRunner
"
HTMLEditor
:
:
NotifyRootChanged
(
)
should
be
called
via
a
runner
"
)
;
mPendingRootElementUpdatedRunner
=
nullptr
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InstallEventListeners
(
)
failed
but
ignored
"
)
;
return
;
}
UpdateRootElement
(
)
;
if
(
!
mRootElement
)
{
return
;
}
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
"
"
failed
"
"
but
ignored
"
)
;
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
if
(
node
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
InitializeSelection
(
*
node
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
InitializeSelection
(
)
failed
but
ignored
"
)
;
}
SyncRealTimeSpell
(
)
;
}
Element
*
HTMLEditor
:
:
GetBodyElement
(
)
const
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
GetBody
(
)
;
}
nsINode
*
HTMLEditor
:
:
GetFocusedNode
(
)
const
{
Element
*
focusedElement
=
GetFocusedElement
(
)
;
if
(
!
focusedElement
)
{
return
nullptr
;
}
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ASSERTION
(
focusManager
"
Focus
manager
is
null
"
)
;
if
(
(
focusedElement
=
focusManager
-
>
GetFocusedElement
(
)
)
)
{
return
focusedElement
;
}
return
GetDocument
(
)
;
}
bool
HTMLEditor
:
:
OurWindowHasFocus
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
focusedWindow
=
focusManager
-
>
GetFocusedWindow
(
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
return
ourWindow
=
=
focusedWindow
;
}
bool
HTMLEditor
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
const
{
if
(
!
EditorBase
:
:
IsAcceptableInputEvent
(
aGUIEvent
)
)
{
return
false
;
}
if
(
mComposition
&
&
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsINode
>
eventTargetNode
=
nsINode
:
:
FromEventTargetOrNull
(
aGUIEvent
-
>
GetOriginalDOMEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
!
eventTargetNode
)
)
{
return
false
;
}
if
(
eventTargetNode
-
>
IsContent
(
)
)
{
eventTargetNode
=
eventTargetNode
-
>
AsContent
(
)
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
NS_WARN_IF
(
!
eventTargetNode
)
)
{
return
false
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
if
(
IsInDesignMode
(
)
)
{
if
(
eventTargetNode
-
>
IsDocument
(
)
)
{
return
eventTargetNode
=
=
document
;
}
if
(
NS_WARN_IF
(
!
eventTargetNode
-
>
IsContent
(
)
)
)
{
return
false
;
}
if
(
document
=
=
eventTargetNode
-
>
GetUncomposedDoc
(
)
)
{
return
true
;
}
if
(
!
eventTargetNode
-
>
IsInShadowTree
(
)
)
{
return
false
;
}
}
if
(
NS_WARN_IF
(
!
eventTargetNode
-
>
IsContent
(
)
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
nsIContent
*
editingHost
=
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
if
(
eventTargetNode
=
=
document
-
>
GetRootElement
(
)
&
&
!
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
editingHost
=
=
document
-
>
GetBodyElement
(
)
)
{
eventTargetNode
=
editingHost
;
}
if
(
!
eventTargetNode
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
false
;
}
if
(
eventTargetNode
-
>
AsContent
(
)
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
!
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
eventTargetNode
-
>
AsContent
(
)
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
nsresult
HTMLEditor
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
)
{
aState
-
>
mEnabled
=
IMEEnabled
:
:
Disabled
;
}
else
{
aState
-
>
mEnabled
=
IMEEnabled
:
:
Enabled
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetInputEventTargetElement
(
)
const
{
RefPtr
<
Element
>
target
=
ComputeEditingHost
(
LimitInBodyElement
:
:
No
)
;
if
(
target
)
{
return
target
.
forget
(
)
;
}
nsIContent
*
focusContent
=
nsIContent
:
:
FromNodeOrNull
(
SelectionRef
(
)
.
GetFocusNode
(
)
)
;
if
(
!
focusContent
|
|
focusContent
-
>
IsEditable
(
)
)
{
return
nullptr
;
}
for
(
Element
*
element
:
focusContent
-
>
AncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsEditable
(
)
)
{
target
=
element
-
>
GetEditingHost
(
)
;
return
target
.
forget
(
)
;
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
OnModifyDocument
(
)
{
MOZ_ASSERT
(
mPendingDocumentModifiedRunner
"
HTMLEditor
:
:
OnModifyDocument
(
)
should
be
called
via
a
runner
"
)
;
mPendingDocumentModifiedRunner
=
nullptr
;
if
(
IsEditActionDataAvailable
(
)
)
{
return
OnModifyDocumentInternal
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eCreatePaddingBRElementForEmptyEditor
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
OnModifyDocumentInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnModifyDocumentInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnModifyDocumentInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
mPendingDocumentModifiedRunner
)
;
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
rv
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
}
