#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
const
char16_t
kNBSP
=
160
;
static
already_AddRefed
<
nsAtom
>
GetLowerCaseNameAtom
(
const
nsAString
&
aTagName
)
{
if
(
aTagName
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsAutoString
lowerTagName
;
nsContentUtils
:
:
ASCIIToLower
(
aTagName
lowerTagName
)
;
return
NS_Atomize
(
lowerTagName
)
;
}
static
bool
IsLinkTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
href
;
}
static
bool
IsNamedAnchorTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
anchor
;
}
HTMLEditor
:
:
HTMLEditor
(
)
:
mCRInParagraphCreatesParagraph
(
false
)
mCSSAware
(
false
)
mSelectedCellIndex
(
0
)
mIsObjectResizingEnabled
(
StaticPrefs
:
:
editor_resizing_enabled_by_default
(
)
)
mIsResizing
(
false
)
mPreserveRatio
(
false
)
mResizedObjectIsAnImage
(
false
)
mIsAbsolutelyPositioningEnabled
(
StaticPrefs
:
:
editor_positioning_enabled_by_default
(
)
)
mResizedObjectIsAbsolutelyPositioned
(
false
)
mGrabberClicked
(
false
)
mIsMoving
(
false
)
mSnapToGridEnabled
(
false
)
mIsInlineTableEditingEnabled
(
StaticPrefs
:
:
editor_inline_table_editing_enabled_by_default
(
)
)
mOriginalX
(
0
)
mOriginalY
(
0
)
mResizedObjectX
(
0
)
mResizedObjectY
(
0
)
mResizedObjectWidth
(
0
)
mResizedObjectHeight
(
0
)
mResizedObjectMarginLeft
(
0
)
mResizedObjectMarginTop
(
0
)
mResizedObjectBorderLeft
(
0
)
mResizedObjectBorderTop
(
0
)
mXIncrementFactor
(
0
)
mYIncrementFactor
(
0
)
mWidthIncrementFactor
(
0
)
mHeightIncrementFactor
(
0
)
mInfoXIncrement
(
20
)
mInfoYIncrement
(
20
)
mPositionedObjectX
(
0
)
mPositionedObjectY
(
0
)
mPositionedObjectWidth
(
0
)
mPositionedObjectHeight
(
0
)
mPositionedObjectMarginLeft
(
0
)
mPositionedObjectMarginTop
(
0
)
mPositionedObjectBorderLeft
(
0
)
mPositionedObjectBorderTop
(
0
)
mGridSize
(
0
)
mDefaultParagraphSeparator
(
Preferences
:
:
GetBool
(
"
editor
.
use_div_for_default_newlines
"
true
)
?
ParagraphSeparator
:
:
div
:
ParagraphSeparator
:
:
br
)
{
mIsHTMLEditorClass
=
true
;
}
HTMLEditor
:
:
~
HTMLEditor
(
)
{
mTypeInState
=
nullptr
;
if
(
mDisabledLinkHandling
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
doc
-
>
SetLinkHandlingEnabled
(
mOldLinkHandlingEnabled
)
;
}
}
RemoveEventListeners
(
)
;
HideAnonymousEditingUIs
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChangedRangeForTopLevelEditSubAction
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStyleSheets
)
tmp
-
>
HideAnonymousEditingUIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChangedRangeForTopLevelEditSubAction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheets
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActivatedHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAbsolutelyPositionedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGrabber
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositioningShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineEditedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveColumnButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveRowButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
HTMLEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLObjectResizer
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLAbsPosEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLInlineTableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorStyleSheets
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorMailSupport
)
NS_INTERFACE_MAP_END_INHERITING
(
TextEditor
)
nsresult
HTMLEditor
:
:
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
{
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
called
again
without
calling
PreDestroy
(
)
?
"
)
;
MOZ_ASSERT
(
aInitialValue
.
IsEmpty
(
)
"
Non
-
empty
initial
values
not
supported
"
)
;
nsresult
rv
=
EditorBase
:
:
Init
(
aDoc
aRoot
nullptr
aFlags
aInitialValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aDoc
.
AddMutationObserverUnlessExists
(
this
)
;
if
(
!
mRootElement
)
{
UpdateRootElement
(
)
;
}
if
(
IsMailEditor
(
)
)
{
SetAbsolutePositioningEnabled
(
false
)
;
SetSnapToGridEnabled
(
false
)
;
}
mCSSEditUtils
=
MakeUnique
<
CSSEditUtils
>
(
this
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsPlaintextEditor
(
)
&
&
!
IsInteractionAllowed
(
)
)
{
mDisabledLinkHandling
=
true
;
mOldLinkHandlingEnabled
=
document
-
>
LinkHandlingEnabled
(
)
;
document
-
>
SetLinkHandlingEnabled
(
false
)
;
}
mTypeInState
=
new
TypeInState
(
)
;
if
(
!
IsInteractionAllowed
(
)
)
{
AddOverrideStyleSheetInternal
(
NS_LITERAL_STRING
(
"
resource
:
/
/
gre
/
res
/
EditorOverride
.
css
"
)
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
InitEditorContentAndSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
ClearUndoRedo
(
)
;
EnableUndoRedo
(
)
;
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
shouldn
'
t
be
nested
"
)
;
mInitSucceeded
=
true
;
return
NS_OK
;
}
void
HTMLEditor
:
:
PreDestroy
(
bool
aDestroyingFrames
)
{
if
(
mDidPreDestroy
)
{
return
;
}
mInitSucceeded
=
false
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
document
)
{
document
-
>
RemoveMutationObserver
(
this
)
;
}
while
(
!
mStyleSheetURLs
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
RemoveOverrideStyleSheetInternal
(
mStyleSheetURLs
[
0
]
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
an
override
style
sheet
"
)
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsDestroying
(
)
)
{
RefPtr
<
HTMLEditor
>
self
=
this
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
HTMLEditor
:
:
PreDestroy
"
[
self
]
(
)
{
self
-
>
HideAnonymousEditingUIs
(
)
;
}
)
)
;
}
else
{
HideAnonymousEditingUIs
(
)
;
}
EditorBase
:
:
PreDestroy
(
aDestroyingFrames
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NotifySelectionChanged
(
Document
*
aDocument
Selection
*
aSelection
int16_t
aReason
)
{
if
(
NS_WARN_IF
(
!
aDocument
)
|
|
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mTypeInState
)
{
RefPtr
<
TypeInState
>
typeInState
=
mTypeInState
;
typeInState
-
>
OnSelectionChange
(
*
aSelection
)
;
if
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
&
&
aSelection
)
{
DebugOnly
<
nsresult
>
rv
=
RefreshEditingUI
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RefreshEditingUI
(
)
failed
"
)
;
}
}
if
(
mComposerCommandsUpdater
)
{
RefPtr
<
ComposerCommandsUpdater
>
updater
=
mComposerCommandsUpdater
;
updater
-
>
OnSelectionChange
(
)
;
}
return
EditorBase
:
:
NotifySelectionChanged
(
aDocument
aSelection
aReason
)
;
}
void
HTMLEditor
:
:
UpdateRootElement
(
)
{
mRootElement
=
GetBodyElement
(
)
;
if
(
!
mRootElement
)
{
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
mRootElement
=
doc
-
>
GetDocumentElement
(
)
;
}
}
}
Element
*
HTMLEditor
:
:
FindSelectionRoot
(
nsINode
*
aNode
)
const
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aNode
-
>
IsDocument
(
)
|
|
aNode
-
>
IsContent
(
)
"
aNode
must
be
content
or
document
node
"
)
;
Document
*
doc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsInUncomposedDoc
(
)
&
&
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
aNode
-
>
IsContent
(
)
)
)
{
return
doc
-
>
GetRootElement
(
)
;
}
if
(
IsReadonly
(
)
)
{
return
GetRoot
(
)
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_MOZ_READWRITE
)
)
{
return
content
-
>
AsElement
(
)
;
}
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
void
HTMLEditor
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
HTMLEditorEventListener
(
)
;
}
}
nsresult
HTMLEditor
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
HTMLEditorEventListener
*
listener
=
reinterpret_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
;
return
listener
-
>
Connect
(
this
)
;
}
void
HTMLEditor
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
TextEditor
:
:
RemoveEventListeners
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetFlags
(
uint32_t
aFlags
)
{
nsresult
rv
=
TextEditor
:
:
SetFlags
(
aFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCSSAware
=
!
NoCSS
(
)
&
&
!
IsMailEditor
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BeginningOfDocument
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
void
HTMLEditor
:
:
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
tryToCollapseSelectionAtFirstEditableNode
=
true
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
=
=
1
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
range
-
>
GetStartContainer
(
)
=
=
editingHost
&
&
!
range
-
>
StartOffset
(
)
)
{
tryToCollapseSelectionAtFirstEditableNode
=
false
;
}
}
EditorBase
:
:
InitializeSelectionAncestorLimit
(
aAncestorLimit
)
;
if
(
tryToCollapseSelectionAtFirstEditableNode
)
{
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
;
}
}
nsresult
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
bool
aIgnoreIfSelectionInEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_OK
;
}
if
(
aIgnoreIfSelectionInEditingHost
&
&
SelectionRefPtr
(
)
-
>
RangeCount
(
)
=
=
1
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
!
range
-
>
Collapsed
(
)
|
|
range
-
>
GetStartContainer
(
)
!
=
editingHost
.
get
(
)
|
|
range
-
>
StartOffset
(
)
)
{
return
NS_OK
;
}
}
EditorRawDOMPoint
pointToPutCaret
(
editingHost
0
)
;
for
(
;
;
)
{
WSRunObject
wsObj
(
this
pointToPutCaret
.
GetContainer
(
)
pointToPutCaret
.
Offset
(
)
)
;
int32_t
visOffset
=
0
;
WSType
visType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
NextVisibleNode
(
pointToPutCaret
address_of
(
visNode
)
&
visOffset
&
visType
)
;
if
(
visNode
&
&
!
visNode
-
>
IsEditable
(
)
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
visType
=
=
WSType
:
:
special
&
&
visNode
&
&
TagCanContainTag
(
*
visNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
pointToPutCaret
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToPutCaret
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
found
empty
inline
container
element
"
)
;
continue
;
}
if
(
visType
=
=
WSType
:
:
normalWS
|
|
visType
=
=
WSType
:
:
text
)
{
pointToPutCaret
.
Set
(
visNode
visOffset
)
;
break
;
}
if
(
visType
=
=
WSType
:
:
br
|
|
visType
=
=
WSType
:
:
special
)
{
pointToPutCaret
.
Set
(
visNode
)
;
break
;
}
if
(
visType
!
=
WSType
:
:
otherBlock
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
!
IsContainer
(
visNode
)
)
{
pointToPutCaret
.
Set
(
visNode
)
;
break
;
}
bool
isEmptyBlock
;
if
(
NS_SUCCEEDED
(
IsEmptyNode
(
visNode
&
isEmptyBlock
)
)
&
&
isEmptyBlock
)
{
pointToPutCaret
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToPutCaret
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
the
found
empty
block
node
"
)
;
}
else
{
pointToPutCaret
.
Set
(
visNode
0
)
;
}
}
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
pointToPutCaret
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_BACK
:
case
NS_VK_DELETE
:
return
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_TAB
:
{
if
(
IsPlaintextEditor
(
)
)
{
return
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
|
|
NS_WARN_IF
(
!
selection
-
>
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
node
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
node
)
;
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
node
)
;
if
(
!
blockParent
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
blockParent
)
)
{
EditActionResult
result
=
HandleTabKeyPressInTable
(
aKeyboardEvent
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
if
(
!
result
.
Handled
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
blockParent
)
)
{
nsresult
rv
=
!
aKeyboardEvent
-
>
IsShift
(
)
?
IndentAsAction
(
)
:
OutdentAsAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsresult
rv
=
OnInputText
(
NS_LITERAL_STRING
(
"
\
t
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
OnInputText
(
)
with
tab
character
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
case
NS_VK_RETURN
:
if
(
!
aKeyboardEvent
-
>
IsInputtingLineBreak
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
nsresult
rv
=
InsertLineBreakAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertLineBreakAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
InsertParagraphSeparatorAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
InsertParagraphSeparatorAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
aKeyboardEvent
-
>
IsInputtingText
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
aKeyboardEvent
-
>
mCharCode
)
;
return
OnInputText
(
str
)
;
}
bool
HTMLEditor
:
:
NodeIsBlockStatic
(
const
nsINode
&
aElement
)
{
if
(
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
return
true
;
}
return
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NodeIsBlock
(
nsINode
*
aNode
bool
*
aIsBlock
)
{
*
aIsBlock
=
IsBlockNode
(
aNode
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsBlockNode
(
nsINode
*
aNode
)
const
{
return
aNode
&
&
HTMLEditor
:
:
NodeIsBlockStatic
(
*
aNode
)
;
}
Element
*
HTMLEditor
:
:
GetBlockNodeParent
(
nsINode
*
aNode
nsINode
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
aNode
=
=
aAncestorLimiter
|
|
EditorUtils
:
:
IsDescendantOf
(
*
aNode
*
aAncestorLimiter
)
"
aNode
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
aNode
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
p
=
aNode
-
>
GetParentNode
(
)
;
while
(
p
)
{
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
p
)
)
{
return
p
-
>
AsElement
(
)
;
}
if
(
p
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
p
=
p
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
Element
*
HTMLEditor
:
:
GetBlock
(
nsINode
&
aNode
nsINode
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
&
aNode
=
=
aAncestorLimiter
|
|
EditorUtils
:
:
IsDescendantOf
(
aNode
*
aAncestorLimiter
)
"
aNode
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
aNode
)
)
{
return
aNode
.
AsElement
(
)
;
}
return
GetBlockNodeParent
(
&
aNode
aAncestorLimiter
)
;
}
void
HTMLEditor
:
:
IsNextCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
(
uint32_t
)
aOffset
<
aContent
-
>
Length
(
)
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
+
1
;
}
}
}
void
HTMLEditor
:
:
IsPrevCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
aOffset
>
0
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
-
1
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
-
1
;
}
}
}
bool
HTMLEditor
:
:
IsVisibleBRElement
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
nextNode
=
GetNextHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
nextNode
&
&
nextNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
if
(
!
nextNode
)
{
return
false
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
GetPreviousHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
priorNode
&
&
priorNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
int32_t
selOffset
;
nsCOMPtr
<
nsINode
>
selNode
=
GetNodeLocation
(
aNode
&
selOffset
)
;
selOffset
+
+
;
WSRunObject
wsObj
(
this
selNode
selOffset
)
;
WSType
visType
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
selNode
selOffset
)
&
visType
)
;
if
(
visType
&
WSType
:
:
block
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP
HTMLEditor
:
:
UpdateBaseURL
(
)
{
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
RefPtr
<
nsContentList
>
nodeList
=
doc
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
base
"
)
)
;
if
(
!
nodeList
|
|
!
nodeList
-
>
Item
(
0
)
)
{
doc
-
>
SetBaseURI
(
doc
-
>
GetDocumentURI
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLineBreak
(
)
{
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLineBreak
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
)
;
nsresult
rv
=
InsertBrElementAtSelectionWithTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertParagraphSeparatorAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
EditActionResult
HTMLEditor
:
:
HandleTabKeyPressInTable
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
AutoEditActionDataSetter
dummyEditActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
dummyEditActionData
.
CanHandle
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
Element
*
cellElement
=
GetElementOrParentByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
NS_WARN_IF
(
!
cellElement
)
)
{
return
EditActionIgnored
(
)
;
}
RefPtr
<
Element
>
table
=
GetEnclosingTable
(
cellElement
)
;
if
(
NS_WARN_IF
(
!
table
)
)
{
return
EditActionIgnored
(
)
;
}
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
table
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
rv
=
postOrderIter
.
PositionAt
(
cellElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionResult
(
rv
)
;
}
do
{
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
postOrderIter
.
Prev
(
)
;
}
else
{
postOrderIter
.
Next
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
postOrderIter
.
GetCurrentNode
(
)
;
if
(
node
&
&
HTMLEditUtils
:
:
IsTableCell
(
node
)
&
&
GetEnclosingTable
(
node
)
=
=
table
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
CollapseSelectionToDeepestNonTableFirstChild
(
node
)
;
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
}
while
(
!
postOrderIter
.
IsDone
(
)
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
EditActionIgnored
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableRowElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_FAILURE
)
;
}
rv
=
InsertTableRowsWithTransaction
(
1
InsertPosition
:
:
eAfterSelectedCell
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
RefPtr
<
Element
>
tblElement
cell
;
int32_t
row
;
rv
=
GetCellContext
(
getter_AddRefs
(
tblElement
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
row
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditActionHandled
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
tblElement
)
)
{
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
cell
=
GetTableCellElementAt
(
*
tblElement
row
0
)
;
if
(
cell
)
{
SelectionRefPtr
(
)
-
>
Collapse
(
cell
0
)
;
}
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
nsresult
HTMLEditor
:
:
InsertBrElementAtSelectionWithTransaction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
EditorDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
newBrElement
=
InsertBRElementWithTransaction
(
atStartOfSelection
eNext
)
;
if
(
NS_WARN_IF
(
!
newBrElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
CollapseSelectionToDeepestNonTableFirstChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
node
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
child
)
|
|
!
IsContainer
(
child
)
)
{
break
;
}
node
=
child
;
}
SelectionRefPtr
(
)
-
>
Collapse
(
node
0
)
;
}
nsresult
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
const
nsAString
&
aSourceToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eReplaceHeadWithHTMLSource
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
CommitComposition
(
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsContentList
>
nodeList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
head
"
)
)
;
if
(
NS_WARN_IF
(
!
nodeList
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
headNode
=
nodeList
-
>
Item
(
0
)
;
if
(
NS_WARN_IF
(
!
headNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
inputString
(
aSourceToInsert
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
err
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
inputString
err
)
;
if
(
err
.
Failed
(
)
)
{
return
err
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
documentFragment
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
nsCOMPtr
<
nsIContent
>
child
=
headNode
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
int32_t
offsetOfNewNode
=
0
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
documentFragment
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
InsertNodeWithTransaction
(
*
child
EditorDOMPoint
(
headNode
offsetOfNewNode
+
+
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RebuildDocumentFromSource
(
const
nsAString
&
aSourceString
)
{
CommitComposition
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetHTML
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsReadingIterator
<
char16_t
>
beginbody
;
nsReadingIterator
<
char16_t
>
endbody
;
aSourceString
.
BeginReading
(
beginbody
)
;
aSourceString
.
EndReading
(
endbody
)
;
bool
foundbody
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
body
"
)
beginbody
endbody
)
;
nsReadingIterator
<
char16_t
>
beginhead
;
nsReadingIterator
<
char16_t
>
endhead
;
aSourceString
.
BeginReading
(
beginhead
)
;
aSourceString
.
EndReading
(
endhead
)
;
bool
foundhead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
head
"
)
beginhead
endhead
)
;
if
(
foundbody
&
&
beginhead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundhead
=
false
;
}
nsReadingIterator
<
char16_t
>
beginclosehead
;
nsReadingIterator
<
char16_t
>
endclosehead
;
aSourceString
.
BeginReading
(
beginclosehead
)
;
aSourceString
.
EndReading
(
endclosehead
)
;
bool
foundclosehead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
/
head
>
"
)
beginclosehead
endclosehead
)
;
if
(
foundhead
&
&
beginhead
.
get
(
)
>
beginclosehead
.
get
(
)
)
{
foundclosehead
=
false
;
}
if
(
foundbody
&
&
beginclosehead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundclosehead
=
false
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
nsReadingIterator
<
char16_t
>
endtotal
;
aSourceString
.
EndReading
(
endtotal
)
;
if
(
foundhead
)
{
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
else
{
nsReadingIterator
<
char16_t
>
begintotal
;
aSourceString
.
BeginReading
(
begintotal
)
;
NS_NAMED_LITERAL_STRING
(
head
"
<
head
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsresult
rv
=
SelectAll
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
foundbody
)
{
NS_NAMED_LITERAL_STRING
(
body
"
<
body
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
LoadHTML
(
body
+
Substring
(
endclosehead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundhead
)
{
nsresult
rv
=
LoadHTML
(
body
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
LoadHTML
(
body
+
aSourceString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
RefPtr
<
Element
>
divElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
div
)
;
if
(
NS_WARN_IF
(
!
divElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
*
divElement
)
;
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
rv
=
LoadHTML
(
Substring
(
beginbody
endtotal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsReadingIterator
<
char16_t
>
beginclosebody
=
beginbody
;
nsReadingIterator
<
char16_t
>
endclosebody
;
aSourceString
.
EndReading
(
endclosebody
)
;
if
(
!
FindInReadable
(
NS_LITERAL_STRING
(
"
>
"
)
beginclosebody
endclosebody
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
bodyTag
;
bodyTag
.
AssignLiteral
(
"
<
div
"
)
;
bodyTag
.
Append
(
Substring
(
endbody
endclosebody
)
)
;
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
erv
;
RefPtr
<
DocumentFragment
>
docfrag
=
range
-
>
CreateContextualFragment
(
bodyTag
erv
)
;
NS_ENSURE_TRUE
(
!
erv
.
Failed
(
)
erv
.
StealNSResult
(
)
)
;
NS_ENSURE_TRUE
(
docfrag
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
child
=
docfrag
-
>
GetFirstChild
(
)
;
NS_ENSURE_TRUE
(
child
&
&
child
-
>
IsElement
(
)
NS_ERROR_NULL_POINTER
)
;
CloneAttributesWithTransaction
(
*
rootElement
MOZ_KnownLive
(
*
child
-
>
AsElement
(
)
)
)
;
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
EditorRawDOMPoint
HTMLEditor
:
:
GetBetterInsertionPointFor
(
nsINode
&
aNodeToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
aPointToInsert
;
}
EditorRawDOMPoint
pointToInsert
(
aPointToInsert
.
GetNonAnonymousSubtreePoint
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
IsBlockNode
(
&
aNodeToInsert
)
)
{
return
pointToInsert
;
}
WSRunObject
wsObj
(
this
pointToInsert
.
GetContainer
(
)
pointToInsert
.
Offset
(
)
)
;
nsCOMPtr
<
nsINode
>
nextVisibleNode
;
WSType
nextVisibleType
;
wsObj
.
NextVisibleNode
(
pointToInsert
address_of
(
nextVisibleNode
)
nullptr
&
nextVisibleType
)
;
if
(
!
nextVisibleNode
|
|
!
(
nextVisibleType
&
WSType
:
:
br
)
)
{
return
pointToInsert
;
}
nsCOMPtr
<
nsINode
>
previousVisibleNode
;
WSType
previousVisibleType
;
wsObj
.
PriorVisibleNode
(
pointToInsert
address_of
(
previousVisibleNode
)
nullptr
&
previousVisibleType
)
;
if
(
!
previousVisibleNode
|
|
(
previousVisibleType
&
WSType
:
:
br
)
|
|
(
previousVisibleType
&
WSType
:
:
thisBlock
)
)
{
return
pointToInsert
;
}
EditorRawDOMPoint
afterBRNode
(
nextVisibleNode
)
;
DebugOnly
<
bool
>
advanced
=
afterBRNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
<
br
>
node
"
)
;
return
afterBRNode
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertElementAtSelection
(
Element
*
aElement
bool
aDeleteSelection
)
{
nsresult
rv
=
InsertElementAtSelectionAsAction
(
aElement
aDeleteSelection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
element
at
selection
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertElementAtSelectionAsAction
(
Element
*
aElement
bool
aDeleteSelection
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
*
aElement
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
.
Rv
(
)
;
}
UndefineCaretBidiLevel
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
aDeleteSelection
)
{
if
(
!
IsBlockNode
(
aElement
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aElement
)
)
{
SelectionRefPtr
(
)
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
}
else
{
SelectionRefPtr
(
)
-
>
CollapseToEnd
(
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
}
}
if
(
!
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
EditorDOMPoint
pointToInsert
=
GetBetterInsertionPointFor
(
*
aElement
atAnchor
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
aElement
pointToInsert
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
insertedPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
SetCaretInTableCell
(
aElement
)
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
rv
=
CollapseSelectionAfter
(
*
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
aElement
)
&
&
IsLastEditableChild
(
aElement
)
)
{
DebugOnly
<
bool
>
advanced
=
insertedPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
RefPtr
<
Element
>
newBRElement
=
InsertBRElementWithTransaction
(
insertedPoint
ePrevious
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
while
(
!
CanContain
(
*
pointToInsert
.
GetContainer
(
)
aNode
)
)
{
if
(
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
pointToInsert
.
GetContainer
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
IsEditable
(
pointToInsert
.
GetContainer
(
)
)
)
{
pointToInsert
=
aPointToInsert
;
break
;
}
}
if
(
pointToInsert
!
=
aPointToInsert
)
{
MOZ_ASSERT
(
pointToInsert
.
GetChild
(
)
)
;
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aPointToInsert
aSplitAtEdges
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
pointToInsert
=
splitNodeResult
.
SplitPoint
(
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
}
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
aNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
}
return
pointToInsert
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
SelectContentInternal
(
MOZ_KnownLive
(
*
aElement
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SelectContentInternal
(
nsIContent
&
aContentToSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
IsDescendantOfEditorRoot
(
&
aContentToSelect
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionStart
(
&
aContentToSelect
)
;
if
(
NS_WARN_IF
(
!
newSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionEnd
(
&
aContentToSelect
)
;
MOZ_ASSERT
(
newSelectionEnd
.
IsSet
(
)
)
;
DebugOnly
<
bool
>
advanced
=
newSelectionEnd
.
AdvanceOffset
(
)
;
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetStartAndEndInLimiter
(
newSelectionStart
newSelectionEnd
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
select
the
given
content
"
)
;
return
error
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetCaretAfterElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
CollapseSelectionAfter
(
*
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CollapseSelectionAfter
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsDescendantOfEditorRoot
(
&
aElement
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsINode
*
parent
=
aElement
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
afterElement
(
&
aElement
)
;
if
(
NS_WARN_IF
(
!
afterElement
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterElement
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetParagraphFormat
(
const
nsAString
&
aParagraphFormat
)
{
nsresult
rv
=
SetParagraphFormatAsAction
(
aParagraphFormat
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
paragraph
format
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetParagraphFormatAsAction
(
const
nsAString
&
aParagraphFormat
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertBlockElement
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsAutoString
lowerCaseTagName
(
aParagraphFormat
)
;
ToLowerCase
(
lowerCaseTagName
)
;
RefPtr
<
nsAtom
>
tagName
=
NS_Atomize
(
lowerCaseTagName
)
;
MOZ_ASSERT
(
tagName
)
;
if
(
tagName
=
=
nsGkAtoms
:
:
dd
|
|
tagName
=
=
nsGkAtoms
:
:
dt
)
{
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
*
tagName
EmptyString
(
)
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
MakeOrChangeListAndListItemAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
rv
=
FormatBlockContainerAsSubAction
(
*
tagName
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
FormatBlockContainerAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
aFirstParagraphState
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ParagraphStateAtSelection
state
(
*
this
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsMixed
(
)
;
if
(
NS_WARN_IF
(
!
state
.
GetFirstParagraphStateAtSelection
(
)
)
)
{
aFirstParagraphState
.
AssignASCII
(
"
x
"
)
;
}
else
{
state
.
GetFirstParagraphStateAtSelection
(
)
-
>
ToString
(
aFirstParagraphState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsCSSEnabled
(
)
)
{
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
true
)
;
}
return
GetHTMLBackgroundColorState
(
aMixed
aOutColor
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHighlightColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
if
(
!
IsCSSEnabled
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
false
)
;
}
nsresult
HTMLEditor
:
:
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
RefPtr
<
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
parent
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
|
|
IsTextNode
(
parent
)
)
{
nodeToExamine
=
parent
;
}
else
{
nodeToExamine
=
firstRange
-
>
GetChildAtStartOffset
(
)
;
}
if
(
NS_WARN_IF
(
!
nodeToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aBlockLevel
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
nodeToExamine
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_OK
;
}
do
{
CSSEditUtils
:
:
GetComputedProperty
(
*
blockParent
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
blockParent
=
blockParent
-
>
GetParentElement
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
blockParent
)
;
if
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
CSSEditUtils
:
:
GetDefaultBackgroundColor
(
aOutColor
)
;
}
}
else
{
if
(
IsTextNode
(
nodeToExamine
)
)
{
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
if
(
!
nodeToExamine
)
{
return
NS_OK
;
}
do
{
if
(
HTMLEditor
:
:
NodeIsBlockStatic
(
*
nodeToExamine
)
)
{
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
break
;
}
else
{
CSSEditUtils
:
:
GetComputedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
nodeToExamine
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
Truncate
(
)
;
ErrorResult
error
;
RefPtr
<
Element
>
cellOrRowOrTableElement
=
GetSelectedOrParentTableElement
(
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
for
(
RefPtr
<
Element
>
element
=
std
:
:
move
(
cellOrRowOrTableElement
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
if
(
!
aOutColor
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
NS_OK
;
}
}
Element
*
bodyElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyElement
)
)
{
return
NS_ERROR_FAILURE
;
}
bodyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aOL
)
|
|
NS_WARN_IF
(
!
aUL
)
|
|
NS_WARN_IF
(
!
aDL
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListElementSelectionState
state
(
*
this
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeListElementSelected
(
)
;
*
aOL
=
state
.
IsOLElementSelected
(
)
;
*
aUL
=
state
.
IsULElementSelected
(
)
;
*
aDL
=
state
.
IsDLElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aLI
)
|
|
NS_WARN_IF
(
!
aDT
)
|
|
NS_WARN_IF
(
!
aDD
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListItemElementSelectionState
state
(
*
this
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeDefinitionListItemElementSelected
(
)
;
*
aLI
=
state
.
IsLIElementSelected
(
)
;
*
aDT
=
state
.
IsDTElementSelected
(
)
;
*
aDD
=
state
.
IsDDElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aAlign
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
AlignStateAtSelection
state
(
*
this
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
false
;
*
aAlign
=
state
.
AlignmentAtSelectionStart
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MakeOrChangeList
(
const
nsAString
&
aListType
bool
aEntireList
const
nsAString
&
aBulletType
)
{
RefPtr
<
nsAtom
>
listTagName
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listTagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
MakeOrChangeListAsAction
(
*
listTagName
aBulletType
aEntireList
?
SelectAllOfCurrentList
:
:
Yes
:
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
make
or
change
list
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MakeOrChangeListAsAction
(
nsAtom
&
aListTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
aListTagName
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
aListTagName
aBulletType
aSelectAllOfCurrentList
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
MakeOrChangeListAndListItemAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveList
(
const
nsAString
&
aListType
)
{
nsresult
rv
=
RemoveListAsAction
(
aListType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
list
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveListAsAction
(
const
nsAString
&
aListType
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
listAtom
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listAtom
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForRemoveList
(
*
listAtom
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RemoveListAtSelectionAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
"
RemoveListAtSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerAsSubAction
(
nsAtom
&
aTagName
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
dd
&
&
&
aTagName
!
=
nsGkAtoms
:
:
dt
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrRemoveBlock
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Canceled
(
)
|
|
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
result
.
Rv
(
)
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureNoPaddingBRElementForEmptyEditor
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EnsureCaretNotAfterPaddingBRElement
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
rv
=
FormatBlockContainerWithTransaction
(
aTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Indent
(
const
nsAString
&
aIndent
)
{
if
(
aIndent
.
LowerCaseEqualsLiteral
(
"
indent
"
)
)
{
nsresult
rv
=
IndentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
indent
"
)
;
return
rv
;
}
if
(
aIndent
.
LowerCaseEqualsLiteral
(
"
outdent
"
)
)
{
nsresult
rv
=
OutdentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
outdent
"
)
;
return
rv
;
}
return
NS_ERROR_INVALID_ARG
;
}
nsresult
HTMLEditor
:
:
IndentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIndent
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
IndentAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
IndentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
OutdentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eOutdent
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
OutdentAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
OutdentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Align
(
const
nsAString
&
aAlignType
)
{
nsresult
rv
=
AlignAsAction
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
align
content
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
AlignAsAction
(
const
nsAString
&
aAlignType
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForAlignment
(
aAlignType
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EditActionResult
result
=
AlignAsSubAction
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
AlignAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAtom
&
aTagName
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
if
(
aNode
)
{
return
GetElementOrParentByTagNameInternal
(
aTagName
*
aNode
)
;
}
return
GetElementOrParentByTagNameAtSelection
(
aTagName
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagNameAtSelection
(
const
nsAtom
&
aTagName
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
const
EditorRawDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
node
;
if
(
atAnchor
.
GetContainer
(
)
-
>
HasChildNodes
(
)
&
&
atAnchor
.
GetContainerAsContent
(
)
)
{
node
=
atAnchor
.
GetChild
(
)
;
}
if
(
!
node
)
{
node
=
atAnchor
.
GetContainer
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
nullptr
;
}
}
return
GetElementOrParentByTagNameInternal
(
aTagName
*
node
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagNameInternal
(
const
nsAtom
&
aTagName
nsINode
&
aNode
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
Element
*
currentElement
=
aNode
.
IsElement
(
)
?
aNode
.
AsElement
(
)
:
aNode
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
currentElement
)
)
{
MOZ_ASSERT
(
!
aNode
.
GetParentNode
(
)
|
|
!
aNode
.
GetParentNode
(
)
-
>
GetParentNode
(
)
)
;
return
nullptr
;
}
bool
getLink
=
IsLinkTag
(
aTagName
)
;
bool
getNamedAnchor
=
IsNamedAnchorTag
(
aTagName
)
;
for
(
;
currentElement
;
currentElement
=
currentElement
-
>
GetParentElement
(
)
)
{
if
(
getLink
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
getNamedAnchor
)
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
list_
)
{
if
(
HTMLEditUtils
:
:
IsList
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
td
)
{
if
(
HTMLEditUtils
:
:
IsTableCell
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
&
aTagName
=
=
currentElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
currentElement
;
}
if
(
currentElement
-
>
GetParentElement
(
)
&
&
currentElement
-
>
GetParentElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsINode
*
aNode
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
|
|
NS_WARN_IF
(
tagName
=
=
nsGkAtoms
:
:
_empty
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
parent
=
GetElementOrParentByTagName
(
*
tagName
aNode
)
;
if
(
!
parent
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parent
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedElement
(
const
nsAString
&
aTagName
nsISupports
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
RefPtr
<
nsINode
>
selectedNode
=
GetSelectedElement
(
tagName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
selectedNode
.
forget
(
aReturn
)
;
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetSelectedElement
(
const
nsAtom
*
aTagName
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
!
=
1
)
{
return
nullptr
;
}
bool
isLinkTag
=
aTagName
&
&
IsLinkTag
(
*
aTagName
)
;
bool
isNamedAnchorTag
=
aTagName
&
&
IsNamedAnchorTag
(
*
aTagName
)
;
RefPtr
<
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
MOZ_ASSERT
(
firstRange
)
;
const
RangeBoundary
&
startRef
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
startRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
const
RangeBoundary
&
endRef
=
firstRange
-
>
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
endRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
)
{
nsIContent
*
startContent
=
startRef
.
GetChildAtOffset
(
)
;
nsIContent
*
endContent
=
endRef
.
GetChildAtOffset
(
)
;
if
(
startContent
&
&
endContent
&
&
startContent
-
>
GetNextSibling
(
)
=
=
endContent
)
{
if
(
!
aTagName
)
{
if
(
!
startContent
-
>
IsElement
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
if
(
aTagName
=
=
startContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
|
|
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
startContent
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
startContent
)
)
)
{
MOZ_ASSERT
(
startContent
-
>
IsElement
(
)
)
;
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
}
}
if
(
isLinkTag
)
{
Element
*
parentLinkOfStart
=
GetElementOrParentByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
startRef
.
Container
(
)
)
;
if
(
parentLinkOfStart
)
{
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
Element
*
parentLinkOfEnd
=
GetElementOrParentByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
endRef
.
Container
(
)
)
;
if
(
parentLinkOfStart
=
=
parentLinkOfEnd
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
}
}
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
nullptr
;
}
PostContentIterator
postOrderIter
;
postOrderIter
.
Init
(
firstRange
)
;
RefPtr
<
Element
>
lastElementInRange
;
for
(
nsINode
*
lastNodeInRange
=
nullptr
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
lastElementInRange
)
{
return
nullptr
;
}
nsINode
*
currentNode
=
postOrderIter
.
GetCurrentNode
(
)
;
MOZ_ASSERT
(
currentNode
)
;
if
(
lastNodeInRange
&
&
lastNodeInRange
-
>
GetParentNode
(
)
!
=
currentNode
&
&
lastNodeInRange
-
>
GetNextSibling
(
)
!
=
currentNode
)
{
return
nullptr
;
}
lastNodeInRange
=
currentNode
;
lastElementInRange
=
Element
:
:
FromNodeOrNull
(
lastNodeInRange
)
;
if
(
!
lastElementInRange
)
{
continue
;
}
if
(
lastElementInRange
-
>
GetNextSibling
(
)
&
&
lastElementInRange
-
>
GetNextSibling
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
if
(
!
aTagName
)
{
continue
;
}
if
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
lastElementInRange
)
)
{
continue
;
}
if
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
lastElementInRange
)
)
{
continue
;
}
if
(
aTagName
=
=
lastElementInRange
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
return
nullptr
;
}
return
lastElementInRange
.
forget
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAtom
&
aTagName
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
const
nsAtom
*
realTagName
=
IsLinkTag
(
aTagName
)
|
|
IsNamedAnchorTag
(
aTagName
)
?
nsGkAtoms
:
:
a
:
&
aTagName
;
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
realTagName
)
;
if
(
!
newElement
)
{
return
nullptr
;
}
IgnoredErrorResult
rv
;
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
_moz_dirty
"
)
EmptyString
(
)
rv
)
;
if
(
realTagName
=
=
nsGkAtoms
:
:
table
)
{
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellpadding
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellspacing
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
border
"
)
NS_LITERAL_STRING
(
"
1
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
else
if
(
realTagName
=
=
nsGkAtoms
:
:
td
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
newElement
nsGkAtoms
:
:
valign
NS_LITERAL_STRING
(
"
top
"
)
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
newElement
=
CreateElementWithDefaults
(
*
tagName
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
newElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLinkAroundSelection
(
Element
*
aAnchorElement
)
{
nsresult
rv
=
InsertLinkAroundSelectionAsAction
(
aAnchorElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
link
around
selection
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertLinkAroundSelectionAsAction
(
Element
*
aAnchorElement
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aAnchorElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLinkElement
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
NS_WARN_IF
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
)
{
return
NS_OK
;
}
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNodeOrNull
(
aAnchorElement
)
;
if
(
!
anchor
)
{
return
NS_OK
;
}
nsAutoString
rawHref
;
anchor
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
rawHref
)
;
editActionData
.
SetData
(
rawHref
)
;
nsAutoString
href
;
anchor
-
>
GetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
RefPtr
<
nsDOMAttributeMap
>
attrMap
=
anchor
-
>
Attributes
(
)
;
NS_ENSURE_TRUE
(
attrMap
NS_ERROR_FAILURE
)
;
uint32_t
count
=
attrMap
-
>
Length
(
)
;
nsAutoString
value
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
Attr
>
attribute
=
attrMap
-
>
Item
(
i
)
;
if
(
attribute
)
{
value
.
Truncate
(
)
;
nsAtom
*
name
=
attribute
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
attribute
-
>
GetValue
(
value
)
;
rv
=
SetInlinePropertyInternal
(
*
nsGkAtoms
:
:
a
MOZ_KnownLive
(
name
)
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
ErrorResult
error
;
bool
isCellSelected
=
false
;
RefPtr
<
Element
>
cellOrRowOrTableElement
=
GetSelectedOrParentTableElement
(
error
&
isCellSelected
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
bool
setColor
=
!
aColor
.
IsEmpty
(
)
;
RefPtr
<
Element
>
rootElementOfBackgroundColor
;
if
(
cellOrRowOrTableElement
)
{
rootElementOfBackgroundColor
=
std
:
:
move
(
cellOrRowOrTableElement
)
;
if
(
isCellSelected
|
|
rootElementOfBackgroundColor
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
)
)
{
IgnoredErrorResult
ignoredError
;
RefPtr
<
Element
>
cellElement
=
GetFirstSelectedTableCellElement
(
ignoredError
)
;
if
(
cellElement
)
{
if
(
setColor
)
{
while
(
cellElement
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
*
cellElement
*
nsGkAtoms
:
:
bgcolor
aColor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
cellElement
=
GetNextSelectedTableCellElement
(
ignoredError
)
;
}
return
NS_OK
;
}
while
(
cellElement
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
cellElement
*
nsGkAtoms
:
:
bgcolor
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
cellElement
=
GetNextSelectedTableCellElement
(
ignoredError
)
;
}
return
NS_OK
;
}
}
}
else
{
rootElementOfBackgroundColor
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElementOfBackgroundColor
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
setColor
?
SetAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
aColor
)
:
RemoveAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eAddOverrideStyleSheet
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
AddOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AddOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIURI
>
uaURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
auto
result
=
presShell
-
>
GetDocument
(
)
-
>
CSSLoader
(
)
-
>
LoadSheetSync
(
uaURI
css
:
:
eAgentSheetFeatures
css
:
:
Loader
:
:
UseSystemPrincipal
:
:
Yes
)
;
if
(
NS_WARN_IF
(
result
.
isErr
(
)
)
)
{
return
result
.
unwrapErr
(
)
;
}
RefPtr
<
StyleSheet
>
sheet
=
result
.
unwrap
(
)
;
presShell
-
>
AddOverrideStyleSheet
(
sheet
)
;
presShell
-
>
GetDocument
(
)
-
>
ApplicableStylesChanged
(
)
;
mLastOverrideStyleSheetURL
=
aURL
;
rv
=
AddNewStyleSheetToList
(
aURL
sheet
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ReplaceOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eReplaceOverrideStyleSheet
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
&
&
!
mLastOverrideStyleSheetURL
.
Equals
(
aURL
)
)
{
EnableStyleSheetInternal
(
mLastOverrideStyleSheetURL
false
)
;
}
return
NS_OK
;
}
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
RemoveOverrideStyleSheetInternal
(
mLastOverrideStyleSheetURL
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
last
override
style
sheet
"
)
;
}
nsresult
rv
=
AddOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveOverrideStyleSheet
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RemoveOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
StyleSheet
>
sheet
=
RemoveStyleSheetFromList
(
aURL
)
;
if
(
!
sheet
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
presShell
-
>
RemoveOverrideStyleSheet
(
sheet
)
;
presShell
-
>
GetDocument
(
)
-
>
ApplicableStylesChanged
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
EnableStyleSheet
(
const
nsAString
&
aURL
bool
aEnable
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableStyleSheet
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
EnableStyleSheetInternal
(
aURL
aEnable
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
EnableStyleSheetInternal
(
const
nsAString
&
aURL
bool
aEnable
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
if
(
!
sheet
)
{
return
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
document
StyleSheet
:
:
NotOwnedByDocumentOrShadowRoot
)
;
sheet
-
>
SetDisabled
(
!
aEnable
)
;
}
bool
HTMLEditor
:
:
EnableExistingStyleSheet
(
const
nsAString
&
aURL
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
if
(
!
sheet
)
{
return
false
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
document
StyleSheet
:
:
NotOwnedByDocumentOrShadowRoot
)
;
return
true
;
}
nsresult
HTMLEditor
:
:
AddNewStyleSheetToList
(
const
nsAString
&
aURL
StyleSheet
*
aStyleSheet
)
{
uint32_t
countSS
=
mStyleSheets
.
Length
(
)
;
uint32_t
countU
=
mStyleSheetURLs
.
Length
(
)
;
if
(
countSS
!
=
countU
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mStyleSheetURLs
.
AppendElement
(
aURL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mStyleSheets
.
AppendElement
(
aStyleSheet
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
already_AddRefed
<
StyleSheet
>
HTMLEditor
:
:
RemoveStyleSheetFromList
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
nullptr
;
}
RefPtr
<
StyleSheet
>
removingStyleSheet
=
mStyleSheets
[
foundIndex
]
;
MOZ_ASSERT
(
removingStyleSheet
)
;
mStyleSheets
.
RemoveElementAt
(
foundIndex
)
;
mStyleSheetURLs
.
RemoveElementAt
(
foundIndex
)
;
return
removingStyleSheet
.
forget
(
)
;
}
StyleSheet
*
HTMLEditor
:
:
GetStyleSheetForURL
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
;
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mStyleSheets
[
foundIndex
]
)
;
return
mStyleSheets
[
foundIndex
]
;
}
nsresult
HTMLEditor
:
:
DeleteSelectionWithTransaction
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
nsresult
rv
=
TextEditor
:
:
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aStripWrappers
=
=
eNoStrip
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
)
|
|
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
|
|
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
content
=
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
-
>
AsContent
(
)
;
nsCOMPtr
<
nsIContent
>
blockParent
=
content
;
while
(
blockParent
&
&
!
IsBlockNode
(
blockParent
)
)
{
blockParent
=
blockParent
-
>
GetParent
(
)
;
}
if
(
!
blockParent
)
{
return
NS_OK
;
}
bool
emptyBlockParent
;
rv
=
IsEmptyNode
(
blockParent
&
emptyBlockParent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
emptyBlockParent
)
{
return
NS_OK
;
}
if
(
content
&
&
!
IsBlockNode
(
content
)
&
&
!
content
-
>
Length
(
)
&
&
content
-
>
IsEditable
(
)
&
&
content
!
=
content
-
>
GetEditingHost
(
)
)
{
while
(
content
-
>
GetParent
(
)
&
&
!
IsBlockNode
(
content
-
>
GetParent
(
)
)
&
&
content
-
>
GetParent
(
)
-
>
Length
(
)
=
=
1
&
&
content
-
>
GetParent
(
)
-
>
IsEditable
(
)
&
&
content
-
>
GetParent
(
)
!
=
content
-
>
GetEditingHost
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
rv
=
DeleteNodeWithTransaction
(
*
content
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteNodeWithTransaction
(
nsINode
&
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
IsModifiableNode
(
*
aNode
.
AsContent
(
)
)
&
&
!
EditorBase
:
:
IsPaddingBRElementForEmptyEditor
(
aNode
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteAllChildrenWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
while
(
nsCOMPtr
<
nsINode
>
child
=
aElement
.
GetLastChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
)
;
WSRunObject
wsObj
(
this
aPoint
)
;
if
(
!
(
wsObj
.
mStartReason
&
WSType
:
:
thisBlock
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
!
wsObj
.
mStartReasonNode
)
|
|
NS_WARN_IF
(
!
wsObj
.
mStartReasonNode
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
wsObj
.
GetEditingHost
(
)
=
=
wsObj
.
mStartReasonNode
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
wsObj
.
mStartReasonNode
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
WSType
wsType
=
WSType
:
:
none
;
wsObj
.
NextVisibleNode
(
aPoint
&
wsType
)
;
if
(
wsType
=
=
WSType
:
:
br
)
{
if
(
IsVisibleBRElement
(
wsObj
.
mEndReasonNode
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
wsObj
.
mEndReasonNode
-
>
GetNextSibling
(
)
)
{
EditorRawDOMPoint
afterBRElement
;
afterBRElement
.
SetAfter
(
wsObj
.
mEndReasonNode
)
;
WSRunObject
wsRunObjAfterBR
(
this
afterBRElement
)
;
WSType
wsTypeAfterBR
=
WSType
:
:
none
;
wsRunObjAfterBR
.
NextVisibleNode
(
afterBRElement
&
wsTypeAfterBR
)
;
if
(
wsTypeAfterBR
!
=
WSType
:
:
thisBlock
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
}
}
else
if
(
wsType
!
=
WSType
:
:
thisBlock
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
EditorDOMPoint
nextPoint
(
wsObj
.
mStartReasonNode
-
>
GetParentNode
(
)
0
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
wsObj
.
mStartReasonNode
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
nextPoint
.
GetContainer
(
)
=
=
wsObj
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
if
(
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
|
|
NS_WARN_IF
(
editingHost
!
=
wsObj
.
GetEditingHost
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
*
nextPoint
.
GetContainer
(
)
*
editingHost
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
}
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
nextPoint
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteNode
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveNode
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteTextWithTransaction
(
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
{
if
(
!
IsModifiableNode
(
aTextNode
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
DeleteTextWithTransaction
(
aTextNode
aOffset
aLength
)
;
}
nsresult
HTMLEditor
:
:
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsModifiableNode
(
*
aPointToInsert
.
GetContainer
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
InsertTextWithTransaction
(
aDocument
aStringToInsert
aPointToInsert
aPointAfterInsertedString
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
InsertBRElementWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
EDirection
aSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToInsert
=
PrepareToInsertBRElement
(
aPointToInsert
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newBRElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
br
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
nullptr
;
}
switch
(
aSelect
)
{
case
eNone
:
break
;
case
eNext
:
{
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
EditorRawDOMPoint
afterBRElement
(
newBRElement
)
;
if
(
afterBRElement
.
IsSet
(
)
)
{
DebugOnly
<
bool
>
advanced
=
afterBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
the
<
br
>
element
"
)
;
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterBRElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
after
the
<
br
>
element
"
)
;
}
else
{
NS_WARNING
(
"
The
<
br
>
node
is
not
in
the
DOM
tree
?
"
)
;
}
break
;
}
case
ePrevious
:
{
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
EditorRawDOMPoint
atBRElement
(
newBRElement
)
;
if
(
atBRElement
.
IsSet
(
)
)
{
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atBRElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
collapse
selection
at
the
<
br
>
element
"
)
;
}
else
{
NS_WARNING
(
"
The
<
br
>
node
is
not
in
the
DOM
tree
?
"
)
;
}
break
;
}
default
:
NS_WARNING
(
"
aSelect
has
invalid
value
the
caller
need
to
set
selection
"
"
by
itself
"
)
;
break
;
}
return
newBRElement
.
forget
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
DoContentInserted
(
aFirstNewContent
eAppended
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
DoContentInserted
(
aChild
eInserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
Element
*
root
=
GetRoot
(
)
;
if
(
root
&
&
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
GetBindingParent
(
)
!
=
aChild
-
>
GetBindingParent
(
)
)
)
{
return
false
;
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
GetBindingParent
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIContent
*
aChild
InsertedOrAppended
aInsertedOrAppended
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
ShouldReplaceRootElement
(
)
)
{
UpdateRootElement
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
GetTopLevelEditSubAction
(
)
&
&
container
-
>
IsEditable
(
)
)
{
if
(
EditorBase
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
OnDocumentModified
(
)
failed
but
ignored
"
)
;
if
(
mInlineSpellChecker
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aChild
)
;
nsIContent
*
endContent
=
aChild
;
if
(
aInsertedOrAppended
=
=
eAppended
)
{
endContent
=
container
-
>
GetLastChild
(
)
;
}
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
SameCOMIdentity
(
aChild
mRootElement
)
)
{
mRootElement
=
nullptr
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
GetTopLevelEditSubAction
(
)
&
&
aChild
-
>
GetParentNode
(
)
-
>
IsEditable
(
)
)
{
if
(
aChild
&
&
EditorBase
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
OnDocumentModified
(
)
failed
but
ignored
"
)
;
}
}
bool
HTMLEditor
:
:
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
const
{
int32_t
childTagEnum
;
if
(
&
aChildTag
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildTag
)
;
}
int32_t
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentTag
)
;
return
HTMLEditUtils
:
:
CanContain
(
parentTagEnum
childTagEnum
)
;
}
bool
HTMLEditor
:
:
IsContainer
(
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
aNode
)
;
int32_t
tagEnum
;
if
(
aNode
-
>
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aNode
-
>
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainer
(
tagEnum
)
;
}
nsresult
HTMLEditor
:
:
SelectEntireDocument
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsEmpty
(
)
)
{
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
bodyOrDocumentElement
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
move
caret
to
start
of
the
editor
root
element
"
)
;
return
rv
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
bodyOrDocumentElement
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Failed
to
select
all
children
of
the
editor
root
element
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
SelectAllInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
CommitComposition
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsINode
*
anchorNode
=
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
anchorNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
anchorContent
=
anchorNode
-
>
AsContent
(
)
;
nsIContent
*
rootContent
;
if
(
anchorContent
-
>
HasIndependentSelection
(
)
)
{
SelectionRefPtr
(
)
-
>
SetAncestorLimiter
(
nullptr
)
;
rootContent
=
mRootElement
;
}
else
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
rootContent
=
anchorContent
-
>
GetSelectionRootContent
(
presShell
)
;
}
if
(
NS_WARN_IF
(
!
rootContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
userSelection
;
if
(
!
rootContent
-
>
IsEditable
(
)
)
{
userSelection
.
emplace
(
SelectionRefPtr
(
)
)
;
}
ErrorResult
errorResult
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
rootContent
errorResult
)
;
NS_WARNING_ASSERTION
(
!
errorResult
.
Failed
(
)
"
SelectAllChildren
(
)
failed
"
)
;
return
errorResult
.
StealNSResult
(
)
;
}
bool
HTMLEditor
:
:
IsTextPropertySetByContent
(
nsINode
*
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
nsAString
*
outValue
)
{
MOZ_ASSERT
(
aNode
&
&
aProperty
)
;
while
(
aNode
)
{
if
(
aNode
-
>
IsElement
(
)
)
{
Element
*
element
=
aNode
-
>
AsElement
(
)
;
if
(
aProperty
=
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
if
(
!
aAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
value
)
;
if
(
outValue
)
{
*
outValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
break
;
}
}
}
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
false
;
}
bool
HTMLEditor
:
:
SetCaretInTableCell
(
Element
*
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aElement
|
|
!
aElement
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
aElement
)
|
|
!
IsDescendantOfEditorRoot
(
aElement
)
)
{
return
false
;
}
nsIContent
*
node
=
aElement
;
while
(
node
-
>
HasChildren
(
)
)
{
node
=
node
-
>
GetFirstChild
(
)
;
}
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
node
0
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
collapse
Selection
in
aElement
"
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
Element
*
HTMLEditor
:
:
GetEnclosingTable
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
for
(
nsCOMPtr
<
Element
>
block
=
GetBlockNodeParent
(
aNode
)
;
block
;
block
=
GetBlockNodeParent
(
block
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
block
)
)
{
return
block
;
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
nsRange
*
aInRange
)
{
NS_ENSURE_TRUE
(
aInRange
NS_ERROR_NULL_POINTER
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsTArray
<
nsCOMPtr
<
nsINode
>
>
textNodes
;
ContentSubtreeIterator
subtreeIter
;
subtreeIter
.
Init
(
aInRange
)
;
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
node
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
IsEditable
(
node
-
>
AsContent
(
)
)
)
{
textNodes
.
AppendElement
(
node
)
;
}
}
while
(
textNodes
.
Length
(
)
>
1
)
{
nsINode
*
leftTextNode
=
textNodes
[
0
]
;
nsINode
*
rightTextNode
=
textNodes
[
1
]
;
NS_ASSERTION
(
leftTextNode
&
&
rightTextNode
"
left
or
rightTextNode
null
in
CollapseAdjacentTextNodes
"
)
;
nsCOMPtr
<
nsINode
>
prevSibOfRightNode
=
rightTextNode
-
>
GetPreviousSibling
(
)
;
if
(
prevSibOfRightNode
&
&
prevSibOfRightNode
=
=
leftTextNode
)
{
nsresult
rv
=
JoinNodesWithTransaction
(
MOZ_KnownLive
(
*
leftTextNode
)
MOZ_KnownLive
(
*
rightTextNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
textNodes
.
RemoveElementAt
(
0
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
dom
:
:
Element
*
rootElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootElement
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
SelectionRefPtr
(
)
-
>
Collapse
(
rootElement
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
child
=
GetFirstEditableChild
(
aElement
)
;
if
(
child
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsBlockNode
(
child
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
sibling
=
GetNextHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
)
{
child
=
GetLastEditableChild
(
aElement
)
;
MOZ_ASSERT
(
child
"
aNode
has
first
editable
child
but
not
last
?
"
)
;
if
(
!
IsBlockNode
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorDOMPoint
endOfNode
;
endOfNode
.
SetToEndOf
(
&
aElement
)
;
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
endOfNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
}
else
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
sibling
=
GetNextHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLSibling
(
nsINode
*
aNode
SkipWhitespace
aSkipWS
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetPreviousSibling
(
)
;
while
(
node
&
&
(
!
IsEditable
(
node
)
|
|
SkippableWhitespace
(
node
aSkipWS
)
)
)
{
node
=
node
-
>
GetPreviousSibling
(
)
;
}
return
node
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLSibling
(
nsINode
*
aNode
SkipWhitespace
aSkipWS
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetNextSibling
(
)
;
while
(
node
&
&
(
!
IsEditable
(
node
)
|
|
SkippableWhitespace
(
node
aSkipWS
)
)
)
{
node
=
node
-
>
GetNextSibling
(
)
;
}
return
node
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aNode
)
:
GetPreviousElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aPoint
)
:
GetPreviousElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aNode
)
:
GetPreviousEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aPoint
)
:
GetPreviousEditableNode
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aNode
)
:
GetNextElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aPoint
)
:
GetNextElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aNode
)
:
GetNextEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aPoint
)
:
GetNextEditableNode
(
aPoint
)
;
}
bool
HTMLEditor
:
:
IsFirstEditableChild
(
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetFirstEditableChild
(
*
parent
)
=
=
aNode
)
;
}
bool
HTMLEditor
:
:
IsLastEditableChild
(
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetLastEditableChild
(
*
parent
)
=
=
aNode
)
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableChild
(
nsINode
&
aNode
)
const
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetNextSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableChild
(
nsINode
&
aNode
)
const
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetLeftmostChild
(
&
aNode
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetNextEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetRightmostChild
(
&
aNode
false
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetPreviousEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
bool
HTMLEditor
:
:
IsInVisibleTextFrames
(
Text
&
aText
)
const
{
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
false
;
}
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
bool
isVisible
=
false
;
nsresult
rv
=
selectionController
-
>
CheckVisibilityContent
(
&
aText
0
aText
.
TextDataLength
(
)
&
isVisible
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
isVisible
;
}
bool
HTMLEditor
:
:
IsVisibleTextNode
(
Text
&
aText
)
const
{
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
if
(
!
aText
.
TextIsOnlyWhitespace
(
)
)
{
return
true
;
}
WSRunScanner
wsRunScanner
(
this
&
aText
0
)
;
nsCOMPtr
<
nsINode
>
nextVisibleNode
;
WSType
visibleNodeType
;
wsRunScanner
.
NextVisibleNode
(
EditorRawDOMPoint
(
&
aText
0
)
address_of
(
nextVisibleNode
)
nullptr
&
visibleNodeType
)
;
return
(
visibleNodeType
=
=
WSType
:
:
normalWS
|
|
visibleNodeType
=
=
WSType
:
:
text
)
&
&
&
aText
=
=
nextVisibleNode
;
}
bool
HTMLEditor
:
:
IsEmpty
(
)
const
{
if
(
mPaddingBRElementForEmptyEditor
)
{
return
true
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
!
bodyOrDocumentElement
)
{
return
true
;
}
for
(
nsIContent
*
childContent
=
bodyOrDocumentElement
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsText
(
)
|
|
childContent
-
>
Length
(
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
IsEmptyNode
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
)
const
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
NS_ERROR_NULL_POINTER
)
;
*
outIsEmptyNode
=
true
;
bool
seenBR
=
false
;
return
IsEmptyNodeImpl
(
aNode
outIsEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
&
seenBR
)
;
}
nsresult
HTMLEditor
:
:
IsEmptyNodeImpl
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
bool
*
aSeenBR
)
const
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
&
&
aSeenBR
NS_ERROR_NULL_POINTER
)
;
if
(
Text
*
text
=
aNode
-
>
GetAsText
(
)
)
{
*
outIsEmptyNode
=
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
return
NS_OK
;
}
if
(
!
IsContainer
(
aNode
)
|
|
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aNode
)
|
|
HTMLEditUtils
:
:
IsFormWidget
(
aNode
)
|
|
(
aListOrCellNotEmpty
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
)
)
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
bool
isListItemOrCell
=
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorBase
:
:
IsEditable
(
child
)
)
{
if
(
Text
*
text
=
child
-
>
GetAsText
(
)
)
{
*
outIsEmptyNode
=
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
if
(
!
*
outIsEmptyNode
)
{
return
NS_OK
;
}
}
else
{
if
(
child
=
=
aNode
)
{
break
;
}
if
(
aSingleBRDoesntCount
&
&
!
*
aSeenBR
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
*
aSeenBR
=
true
;
}
else
{
if
(
child
-
>
IsElement
(
)
)
{
if
(
isListItemOrCell
)
{
if
(
HTMLEditUtils
:
:
IsList
(
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
else
if
(
HTMLEditUtils
:
:
IsFormWidget
(
child
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
bool
isEmptyNode
=
true
;
nsresult
rv
=
IsEmptyNodeImpl
(
child
&
isEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
aSeenBR
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isEmptyNode
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
IsCSSEnabled
(
)
|
|
!
mCSSEditUtils
)
{
if
(
mCSSEditUtils
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
}
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
}
int32_t
count
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
&
aValue
aSuppressTransaction
)
;
if
(
count
)
{
nsAutoString
existingValue
;
if
(
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
existingValue
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
nsAutoString
existingValue
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
)
;
existingValue
.
Append
(
'
'
)
;
existingValue
.
Append
(
aValue
)
;
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
existingValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
existingValue
)
;
}
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetIsCSSEnabled
(
bool
aIsCSSPrefChecked
)
{
if
(
!
mCSSEditUtils
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableCSS
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mCSSEditUtils
-
>
SetCSSEnabled
(
aIsCSSPrefChecked
)
;
uint32_t
flags
=
mFlags
;
if
(
aIsCSSPrefChecked
)
{
flags
&
=
~
eEditorNoCSSMask
;
}
else
{
flags
|
=
eEditorNoCSSMask
;
}
return
SetFlags
(
flags
)
;
}
nsresult
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
result
.
Canceled
(
)
)
{
return
result
.
Rv
(
)
;
}
bool
selectionIsCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
startOfRange
(
range
-
>
StartRef
(
)
)
;
EditorDOMPoint
endOfRange
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
)
{
if
(
startOfRange
.
IsInTextNode
(
)
)
{
if
(
RefPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startOfRange
.
GetContainer
(
)
)
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
selectionIsCollapsed
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
MOZ_KnownLive
(
startOfRange
.
GetContainerAsElement
(
)
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
continue
;
}
if
(
(
startOfRange
.
IsStartOfContainer
(
)
&
&
endOfRange
.
IsStartOfContainer
(
)
)
|
|
startOfRange
.
Offset
(
)
+
1
=
=
endOfRange
.
Offset
(
)
)
{
if
(
NS_WARN_IF
(
startOfRange
.
IsInDataNode
(
)
)
)
{
continue
;
}
if
(
RefPtr
<
Element
>
blockParent
=
GetBlock
(
*
startOfRange
.
GetChild
(
)
)
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
continue
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
ContentSubtreeIterator
subtreeIter
;
if
(
NS_SUCCEEDED
(
subtreeIter
.
Init
(
range
)
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
IsEditable
(
node
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
RefPtr
<
Element
>
handledBlockParent
;
if
(
startOfRange
.
IsInTextNode
(
)
&
&
IsEditable
(
startOfRange
.
GetContainer
(
)
)
)
{
RefPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startOfRange
.
GetContainer
(
)
)
;
if
(
blockParent
&
&
handledBlockParent
!
=
blockParent
)
{
handledBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
for
(
auto
&
content
:
arrayOfContents
)
{
RefPtr
<
Element
>
blockParent
=
GetBlock
(
content
)
;
if
(
blockParent
&
&
handledBlockParent
!
=
blockParent
)
{
handledBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
if
(
endOfRange
.
IsInTextNode
(
)
&
&
IsEditable
(
endOfRange
.
GetContainer
(
)
)
)
{
RefPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
endOfRange
.
GetContainer
(
)
)
;
if
(
blockParent
&
&
handledBlockParent
!
=
blockParent
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBackgroundColor
(
const
nsAString
&
aColor
)
{
nsresult
rv
=
SetBackgroundColorAsAction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
background
color
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetBackgroundColorAsAction
(
const
nsAString
&
aColor
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetBackgroundColor
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
SetCSSBackgroundColorWithTransaction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
SetCSSBackgroundColorWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
EditorBase
:
:
ToGenericNSResult
(
SetHTMLBackgroundColorWithTransaction
(
aColor
)
)
;
}
nsresult
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
Element
&
aPreviousBlock
Element
&
aNewBlock
RefPtr
<
Element
>
*
aNewBrElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aNewBrElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aNewBrElement
=
nullptr
;
RefPtr
<
Element
>
previousBlock
(
&
aPreviousBlock
)
;
RefPtr
<
Element
>
newBlock
(
&
aNewBlock
)
;
for
(
nsCOMPtr
<
nsINode
>
child
=
newBlock
-
>
GetFirstChild
(
)
;
child
;
child
=
newBlock
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsIContent
*
deepestEditableContent
=
nullptr
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
previousBlock
.
get
(
)
;
child
;
child
=
GetLastEditableChild
(
*
child
)
)
{
deepestEditableContent
=
child
;
}
while
(
deepestEditableContent
&
&
deepestEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
deepestEditableContent
=
GetPreviousEditableHTMLNode
(
*
deepestEditableContent
)
;
}
Element
*
deepestVisibleEditableElement
=
nullptr
;
if
(
deepestEditableContent
)
{
deepestVisibleEditableElement
=
deepestEditableContent
-
>
IsElement
(
)
?
deepestEditableContent
-
>
AsElement
(
)
:
deepestEditableContent
-
>
GetParentElement
(
)
;
}
RefPtr
<
Element
>
lastClonedElement
firstClonsedElement
;
for
(
RefPtr
<
Element
>
elementInPreviousBlock
=
deepestVisibleEditableElement
;
elementInPreviousBlock
&
&
elementInPreviousBlock
!
=
previousBlock
;
elementInPreviousBlock
=
elementInPreviousBlock
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsInlineStyle
(
elementInPreviousBlock
)
&
&
!
elementInPreviousBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
continue
;
}
nsAtom
*
tagName
=
elementInPreviousBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
!
firstClonsedElement
)
{
firstClonsedElement
=
lastClonedElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
tagName
)
EditorDOMPoint
(
newBlock
0
)
)
;
if
(
NS_WARN_IF
(
!
firstClonsedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
continue
;
}
lastClonedElement
=
InsertContainerWithTransaction
(
*
lastClonedElement
MOZ_KnownLive
(
*
tagName
)
)
;
if
(
NS_WARN_IF
(
!
lastClonedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
}
if
(
!
firstClonsedElement
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
firstClonsedElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aNewBrElement
=
brElement
.
forget
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
{
aX
=
0
;
aY
=
0
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_OK
)
;
nsIFrame
*
container
=
presShell
-
>
GetAbsoluteContainingBlock
(
frame
)
;
if
(
NS_WARN_IF
(
!
container
)
)
{
return
NS_OK
;
}
nsPoint
off
=
frame
-
>
GetOffsetTo
(
container
)
;
aX
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
x
)
;
aY
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
y
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetSelectionContainerElement
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsINode
*
focusNode
=
nullptr
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
focusNode
=
SelectionRefPtr
(
)
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
else
{
uint32_t
rangeCount
=
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
If
0
Selection
:
:
IsCollapsed
(
)
should
return
true
"
)
;
if
(
rangeCount
=
=
1
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
const
RangeBoundary
&
startRef
=
range
-
>
StartRef
(
)
;
const
RangeBoundary
&
endRef
=
range
-
>
EndRef
(
)
;
if
(
startRef
.
Container
(
)
-
>
IsElement
(
)
&
&
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
&
&
startRef
.
GetChildAtOffset
(
)
&
&
startRef
.
GetChildAtOffset
(
)
-
>
GetNextSibling
(
)
=
=
endRef
.
GetChildAtOffset
(
)
)
{
focusNode
=
startRef
.
GetChildAtOffset
(
)
;
MOZ_ASSERT
(
focusNode
"
Start
container
must
not
be
nullptr
"
)
;
}
else
{
focusNode
=
range
-
>
GetCommonAncestor
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
!
focusNode
)
{
focusNode
=
startContainer
;
}
else
if
(
focusNode
!
=
startContainer
)
{
focusNode
=
startContainer
-
>
GetParentNode
(
)
;
break
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
}
if
(
focusNode
-
>
GetAsText
(
)
)
{
focusNode
=
focusNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
return
focusNode
-
>
AsElement
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IsAnonymousElement
(
Element
*
aElement
bool
*
aReturn
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_NULL_POINTER
)
;
*
aReturn
=
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
bool
aCreatesNewParagraph
)
{
mCRInParagraphCreatesParagraph
=
aCreatesNewParagraph
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
{
return
mCRInParagraphCreatesParagraph
;
}
nsresult
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
bool
*
aCreatesNewParagraph
)
{
*
aCreatesNewParagraph
=
mCRInParagraphCreatesParagraph
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetFocusedContent
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
nullptr
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
fm
-
>
GetFocusedElement
(
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
!
focusedContent
)
{
if
(
inDesignMode
&
&
OurWindowHasFocus
(
)
)
{
return
document
-
>
GetRootElement
(
)
;
}
return
nullptr
;
}
if
(
inDesignMode
)
{
return
OurWindowHasFocus
(
)
&
&
focusedContent
-
>
IsInclusiveDescendantOf
(
document
)
?
focusedContent
.
get
(
)
:
nullptr
;
}
if
(
!
focusedContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
focusedContent
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
OurWindowHasFocus
(
)
?
focusedContent
.
get
(
)
:
nullptr
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetFocusedContentForIME
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
?
nullptr
:
focusedContent
.
forget
(
)
;
}
bool
HTMLEditor
:
:
IsActiveInDOMWindow
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
inDesignMode
)
{
return
true
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
if
(
!
content
)
{
return
false
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
true
;
}
Element
*
HTMLEditor
:
:
GetActiveEditingHost
(
)
const
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
document
-
>
GetBodyElement
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
nsINode
*
focusNode
=
SelectionRefPtr
(
)
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
|
|
NS_WARN_IF
(
!
focusNode
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
focusNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
void
HTMLEditor
:
:
NotifyEditingHostMaybeChanged
(
)
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
|
|
NS_WARN_IF
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
nsIContent
*
ancestorLimiter
=
SelectionRefPtr
(
)
-
>
GetAncestorLimiter
(
)
;
if
(
!
ancestorLimiter
)
{
return
;
}
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
;
}
if
(
ancestorLimiter
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
EditorBase
:
:
InitializeSelectionAncestorLimit
(
*
editingHost
)
;
}
}
EventTarget
*
HTMLEditor
:
:
GetDOMEventTarget
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
has
not
been
initialized
yet
"
)
;
nsCOMPtr
<
EventTarget
>
target
=
GetDocument
(
)
;
return
target
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
{
if
(
!
mRootElement
)
{
return
true
;
}
return
mRootElement
!
=
GetBodyElement
(
)
;
}
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
UpdateRootElement
(
)
;
if
(
!
mRootElement
)
{
return
;
}
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
if
(
node
)
{
InitializeSelection
(
node
)
;
}
SyncRealTimeSpell
(
)
;
}
Element
*
HTMLEditor
:
:
GetBodyElement
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
GetBody
(
)
;
}
already_AddRefed
<
nsINode
>
HTMLEditor
:
:
GetFocusedNode
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ASSERTION
(
fm
"
Focus
manager
is
null
"
)
;
RefPtr
<
Element
>
focusedElement
=
fm
-
>
GetFocusedElement
(
)
;
if
(
focusedElement
)
{
return
focusedElement
.
forget
(
)
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
return
document
.
forget
(
)
;
}
bool
HTMLEditor
:
:
OurWindowHasFocus
(
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
return
ourWindow
=
=
focusedWindow
;
}
bool
HTMLEditor
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
!
EditorBase
:
:
IsAcceptableInputEvent
(
aGUIEvent
)
)
{
return
false
;
}
if
(
mComposition
&
&
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
true
;
}
RefPtr
<
EventTarget
>
target
=
aGUIEvent
-
>
GetOriginalDOMEventTarget
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
target
)
;
if
(
content
)
{
target
=
content
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
NS_ENSURE_TRUE
(
target
false
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
nsCOMPtr
<
Document
>
targetDocument
=
do_QueryInterface
(
target
)
;
if
(
targetDocument
)
{
return
targetDocument
=
=
document
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
return
document
=
=
targetContent
-
>
GetUncomposedDoc
(
)
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
if
(
targetContent
=
=
document
-
>
GetRootElement
(
)
&
&
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
editingHost
=
=
document
-
>
GetBodyElement
(
)
)
{
targetContent
=
editingHost
;
}
if
(
!
targetContent
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
false
;
}
if
(
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
nsresult
HTMLEditor
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
aState
-
>
mEnabled
=
IMEState
:
:
DISABLED
;
}
else
{
aState
-
>
mEnabled
=
IMEState
:
:
ENABLED
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetInputEventTargetElement
(
)
{
RefPtr
<
Element
>
target
=
GetActiveEditingHost
(
)
;
return
target
.
forget
(
)
;
}
Element
*
HTMLEditor
:
:
GetEditorRoot
(
)
const
{
return
GetActiveEditingHost
(
)
;
}
nsHTMLDocument
*
HTMLEditor
:
:
GetHTMLDocument
(
)
const
{
Document
*
doc
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
if
(
!
doc
-
>
IsHTMLOrXHTML
(
)
)
{
return
nullptr
;
}
return
doc
-
>
AsHTMLDocument
(
)
;
}
nsresult
HTMLEditor
:
:
OnModifyDocument
(
)
{
if
(
IsEditActionDataAvailable
(
)
)
{
return
OnModifyDocumentInternal
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eCreatePaddingBRElementForEmptyEditor
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
OnModifyDocumentInternal
(
)
;
}
nsresult
HTMLEditor
:
:
OnModifyDocumentInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
padding
<
br
>
element
"
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
rv
;
}
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
NS_WARNING_ASSERTION
(
rv
!
=
NS_ERROR_EDITOR_DESTROYED
"
The
editor
has
been
destroyed
during
creating
a
padding
<
br
>
element
"
)
;
return
rv
;
}
}
