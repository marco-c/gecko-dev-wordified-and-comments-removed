#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditRules
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
HTMLURIRefObject
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
HTMLEditorObjectResizerUtils
.
h
"
#
include
"
TextEditorTest
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
const
char16_t
kNBSP
=
160
;
static
already_AddRefed
<
nsAtom
>
GetLowerCaseNameAtom
(
const
nsAString
&
aTagName
)
{
if
(
aTagName
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsAutoString
lowerTagName
;
nsContentUtils
:
:
ASCIIToLower
(
aTagName
lowerTagName
)
;
return
NS_Atomize
(
lowerTagName
)
;
}
static
bool
IsLinkTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
href
;
}
static
bool
IsNamedAnchorTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
anchor
;
}
class
HTMLEditorPrefs
final
{
public
:
static
bool
IsResizingUIEnabledByDefault
(
)
{
EnsurePrefValues
(
)
;
return
sUserWantsToEnableResizingUIByDefault
;
}
static
bool
IsInlineTableEditingUIEnabledByDefault
(
)
{
EnsurePrefValues
(
)
;
return
sUserWantsToEnableInlineTableEditingUIByDefault
;
}
static
bool
IsAbsolutePositioningUIEnabledByDefault
(
)
{
EnsurePrefValues
(
)
;
return
sUserWantsToEnableAbsolutePositioningUIByDefault
;
}
private
:
static
bool
sUserWantsToEnableResizingUIByDefault
;
static
bool
sUserWantsToEnableInlineTableEditingUIByDefault
;
static
bool
sUserWantsToEnableAbsolutePositioningUIByDefault
;
static
void
EnsurePrefValues
(
)
{
static
bool
sInitialized
=
false
;
if
(
sInitialized
)
{
return
;
}
Preferences
:
:
AddBoolVarCache
(
&
sUserWantsToEnableResizingUIByDefault
"
editor
.
resizing
.
enabled_by_default
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sUserWantsToEnableInlineTableEditingUIByDefault
"
editor
.
inline_table_editing
.
enabled_by_default
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sUserWantsToEnableAbsolutePositioningUIByDefault
"
editor
.
positioning
.
enabled_by_default
"
)
;
sInitialized
=
true
;
}
}
;
bool
HTMLEditorPrefs
:
:
sUserWantsToEnableResizingUIByDefault
=
false
;
bool
HTMLEditorPrefs
:
:
sUserWantsToEnableInlineTableEditingUIByDefault
=
false
;
bool
HTMLEditorPrefs
:
:
sUserWantsToEnableAbsolutePositioningUIByDefault
=
false
;
template
EditorDOMPoint
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
template
EditorDOMPoint
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorRawDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
;
HTMLEditor
:
:
HTMLEditor
(
)
:
mCRInParagraphCreatesParagraph
(
false
)
mCSSAware
(
false
)
mSelectedCellIndex
(
0
)
mHasShownResizers
(
false
)
mIsObjectResizingEnabled
(
HTMLEditorPrefs
:
:
IsResizingUIEnabledByDefault
(
)
)
mIsResizing
(
false
)
mPreserveRatio
(
false
)
mResizedObjectIsAnImage
(
false
)
mIsAbsolutelyPositioningEnabled
(
HTMLEditorPrefs
:
:
IsAbsolutePositioningUIEnabledByDefault
(
)
)
mResizedObjectIsAbsolutelyPositioned
(
false
)
mHasShownGrabber
(
false
)
mGrabberClicked
(
false
)
mIsMoving
(
false
)
mSnapToGridEnabled
(
false
)
mHasShownInlineTableEditor
(
false
)
mIsInlineTableEditingEnabled
(
HTMLEditorPrefs
:
:
IsInlineTableEditingUIEnabledByDefault
(
)
)
mOriginalX
(
0
)
mOriginalY
(
0
)
mResizedObjectX
(
0
)
mResizedObjectY
(
0
)
mResizedObjectWidth
(
0
)
mResizedObjectHeight
(
0
)
mResizedObjectMarginLeft
(
0
)
mResizedObjectMarginTop
(
0
)
mResizedObjectBorderLeft
(
0
)
mResizedObjectBorderTop
(
0
)
mXIncrementFactor
(
0
)
mYIncrementFactor
(
0
)
mWidthIncrementFactor
(
0
)
mHeightIncrementFactor
(
0
)
mResizerUsedCount
(
0
)
mGrabberUsedCount
(
0
)
mInlineTableEditorUsedCount
(
0
)
mInfoXIncrement
(
20
)
mInfoYIncrement
(
20
)
mPositionedObjectX
(
0
)
mPositionedObjectY
(
0
)
mPositionedObjectWidth
(
0
)
mPositionedObjectHeight
(
0
)
mPositionedObjectMarginLeft
(
0
)
mPositionedObjectMarginTop
(
0
)
mPositionedObjectBorderLeft
(
0
)
mPositionedObjectBorderTop
(
0
)
mGridSize
(
0
)
mDefaultParagraphSeparator
(
Preferences
:
:
GetBool
(
"
editor
.
use_div_for_default_newlines
"
true
)
?
ParagraphSeparator
:
:
div
:
ParagraphSeparator
:
:
br
)
{
mIsHTMLEditorClass
=
true
;
}
HTMLEditor
:
:
~
HTMLEditor
(
)
{
if
(
mRules
&
&
mRules
-
>
AsHTMLEditRules
(
)
)
{
mRules
-
>
AsHTMLEditRules
(
)
-
>
EndListeningToEditSubActions
(
)
;
}
mTypeInState
=
nullptr
;
if
(
mLinkHandler
&
&
IsInitialized
(
)
)
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
if
(
ps
&
&
ps
-
>
GetPresContext
(
)
)
{
ps
-
>
GetPresContext
(
)
-
>
SetLinkHandler
(
mLinkHandler
)
;
}
}
RemoveEventListeners
(
)
;
HideAnonymousEditingUIs
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_RESIZERS
mHasShownResizers
?
1
:
0
)
;
if
(
mHasShownResizers
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WHOSE_RESIZERS_USED_BY_USER
mResizerUsedCount
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_ABSOLUTE_POSITIONER
mHasShownGrabber
?
1
:
0
)
;
if
(
mHasShownGrabber
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WHOSE_ABSOLUTE_POSITIONER_USED_BY_USER
mGrabberUsedCount
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WITH_INLINE_TABLE_EDITOR
mHasShownInlineTableEditor
?
1
:
0
)
;
if
(
mHasShownInlineTableEditor
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HTMLEDITORS_WHOSE_INLINE_TABLE_EDITOR_USED_BY_USER
mInlineTableEditorUsedCount
)
;
}
}
void
HTMLEditor
:
:
HideAnonymousEditingUIs
(
)
{
if
(
mAbsolutelyPositionedObject
)
{
HideGrabber
(
)
;
}
if
(
mInlineEditedCell
)
{
HideInlineTableEditingUI
(
)
;
}
if
(
mResizedObject
)
{
HideResizers
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStyleSheets
)
tmp
-
>
HideAnonymousEditingUIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLinkHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheets
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActivatedHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMouseMotionListenerP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizeEventListenerP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAbsolutelyPositionedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGrabber
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositioningShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineEditedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveColumnButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveRowButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLinkHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
HTMLEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLObjectResizer
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLAbsPosEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLInlineTableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorStyleSheets
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorMailSupport
)
NS_INTERFACE_MAP_END_INHERITING
(
TextEditor
)
nsresult
HTMLEditor
:
:
Init
(
nsIDocument
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
{
MOZ_ASSERT
(
aInitialValue
.
IsEmpty
(
)
"
Non
-
empty
initial
values
not
supported
"
)
;
nsresult
rulesRv
=
NS_OK
;
{
AutoEditInitRulesTrigger
rulesTrigger
(
this
rulesRv
)
;
nsresult
rv
=
TextEditor
:
:
Init
(
aDoc
aRoot
nullptr
aFlags
aInitialValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aDoc
.
AddMutationObserverUnlessExists
(
this
)
;
if
(
!
mRootElement
)
{
UpdateRootElement
(
)
;
}
if
(
IsMailEditor
(
)
)
{
SetAbsolutePositioningEnabled
(
false
)
;
SetSnapToGridEnabled
(
false
)
;
}
mCSSEditUtils
=
MakeUnique
<
CSSEditUtils
>
(
this
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsPresContext
*
context
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
context
NS_ERROR_NULL_POINTER
)
;
if
(
!
IsPlaintextEditor
(
)
&
&
!
IsInteractionAllowed
(
)
)
{
mLinkHandler
=
context
-
>
GetLinkHandler
(
)
;
context
-
>
SetLinkHandler
(
nullptr
)
;
}
mTypeInState
=
new
TypeInState
(
)
;
if
(
!
IsInteractionAllowed
(
)
)
{
AddOverrideStyleSheetInternal
(
NS_LITERAL_STRING
(
"
resource
:
/
/
gre
/
res
/
EditorOverride
.
css
"
)
)
;
}
}
NS_ENSURE_SUCCESS
(
rulesRv
rulesRv
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
PreDestroy
(
bool
aDestroyingFrames
)
{
if
(
mDidPreDestroy
)
{
return
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
document
)
{
document
-
>
RemoveMutationObserver
(
this
)
;
}
while
(
!
mStyleSheetURLs
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
RemoveOverrideStyleSheetInternal
(
mStyleSheetURLs
[
0
]
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
an
override
style
sheet
"
)
;
}
HideAnonymousEditingUIs
(
)
;
EditorBase
:
:
PreDestroy
(
aDestroyingFrames
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NotifySelectionChanged
(
nsIDocument
*
aDocument
Selection
*
aSelection
int16_t
aReason
)
{
if
(
NS_WARN_IF
(
!
aDocument
)
|
|
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
mTypeInState
)
{
RefPtr
<
TypeInState
>
typeInState
=
mTypeInState
;
typeInState
-
>
OnSelectionChange
(
*
aSelection
)
;
if
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
&
&
aSelection
)
{
CheckSelectionStateForAnonymousButtons
(
aSelection
)
;
}
}
if
(
mComposerCommandsUpdater
)
{
RefPtr
<
ComposerCommandsUpdater
>
updater
=
mComposerCommandsUpdater
;
updater
-
>
OnSelectionChange
(
)
;
}
return
EditorBase
:
:
NotifySelectionChanged
(
aDocument
aSelection
aReason
)
;
}
void
HTMLEditor
:
:
UpdateRootElement
(
)
{
mRootElement
=
GetBodyElement
(
)
;
if
(
!
mRootElement
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
mRootElement
=
doc
-
>
GetDocumentElement
(
)
;
}
}
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
FindSelectionRoot
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aNode
-
>
IsDocument
(
)
|
|
aNode
-
>
IsContent
(
)
"
aNode
must
be
content
or
document
node
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
content
;
if
(
aNode
-
>
IsInUncomposedDoc
(
)
&
&
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
aNode
-
>
IsContent
(
)
)
)
{
content
=
doc
-
>
GetRootElement
(
)
;
return
content
.
forget
(
)
;
}
content
=
aNode
-
>
AsContent
(
)
;
if
(
IsReadonly
(
)
)
{
content
=
do_QueryInterface
(
GetRoot
(
)
)
;
return
content
.
forget
(
)
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_MOZ_READWRITE
)
)
{
return
content
.
forget
(
)
;
}
return
nullptr
;
}
content
=
content
-
>
GetEditingHost
(
)
;
return
content
.
forget
(
)
;
}
void
HTMLEditor
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
HTMLEditorEventListener
(
)
;
}
}
nsresult
HTMLEditor
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
HTMLEditorEventListener
*
listener
=
reinterpret_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
;
return
listener
-
>
Connect
(
this
)
;
}
void
HTMLEditor
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
RefPtr
<
EventTarget
>
target
=
GetDOMEventTarget
(
)
;
if
(
target
)
{
if
(
mMouseMotionListenerP
)
{
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
false
)
;
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
true
)
;
}
if
(
mResizeEventListenerP
)
{
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
resize
"
)
mResizeEventListenerP
false
)
;
}
}
mMouseMotionListenerP
=
nullptr
;
mResizeEventListenerP
=
nullptr
;
TextEditor
:
:
RemoveEventListeners
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetFlags
(
uint32_t
aFlags
)
{
nsresult
rv
=
TextEditor
:
:
SetFlags
(
aFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCSSAware
=
!
NoCSS
(
)
&
&
!
IsMailEditor
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InitRules
(
)
{
if
(
!
mRules
)
{
mRules
=
new
HTMLEditRules
(
)
;
}
return
mRules
-
>
Init
(
this
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BeginningOfDocument
(
)
{
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
void
HTMLEditor
:
:
InitializeSelectionAncestorLimit
(
Selection
&
aSelection
nsIContent
&
aAncestorLimit
)
{
bool
tryToCollapseSelectionAtFirstEditableNode
=
true
;
if
(
aSelection
.
RangeCount
(
)
=
=
1
&
&
aSelection
.
IsCollapsed
(
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
nsRange
*
range
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
range
-
>
GetStartContainer
(
)
=
=
editingHost
&
&
!
range
-
>
StartOffset
(
)
)
{
tryToCollapseSelectionAtFirstEditableNode
=
false
;
}
}
EditorBase
:
:
InitializeSelectionAncestorLimit
(
aSelection
aAncestorLimit
)
;
if
(
tryToCollapseSelectionAtFirstEditableNode
)
{
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
;
}
}
nsresult
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
bool
aIgnoreIfSelectionInEditingHost
)
{
if
(
!
IsInitialized
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_OK
;
}
if
(
aIgnoreIfSelectionInEditingHost
&
&
selection
-
>
RangeCount
(
)
=
=
1
)
{
nsRange
*
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
!
range
-
>
Collapsed
(
)
|
|
range
-
>
GetStartContainer
(
)
!
=
editingHost
.
get
(
)
|
|
range
-
>
StartOffset
(
)
)
{
return
NS_OK
;
}
}
EditorRawDOMPoint
pointToPutCaret
(
editingHost
0
)
;
for
(
;
;
)
{
WSRunObject
wsObj
(
this
pointToPutCaret
.
GetContainer
(
)
pointToPutCaret
.
Offset
(
)
)
;
int32_t
visOffset
=
0
;
WSType
visType
;
nsCOMPtr
<
nsINode
>
visNode
;
wsObj
.
NextVisibleNode
(
pointToPutCaret
address_of
(
visNode
)
&
visOffset
&
visType
)
;
if
(
visNode
&
&
!
visNode
-
>
IsEditable
(
)
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
visType
=
=
WSType
:
:
special
&
&
visNode
&
&
TagCanContainTag
(
*
visNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
pointToPutCaret
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToPutCaret
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
found
empty
inline
container
element
"
)
;
continue
;
}
if
(
visType
=
=
WSType
:
:
normalWS
|
|
visType
=
=
WSType
:
:
text
)
{
pointToPutCaret
.
Set
(
visNode
visOffset
)
;
break
;
}
if
(
visType
=
=
WSType
:
:
br
|
|
visType
=
=
WSType
:
:
special
)
{
pointToPutCaret
.
Set
(
visNode
)
;
break
;
}
if
(
visType
!
=
WSType
:
:
otherBlock
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
!
IsContainer
(
visNode
)
)
{
pointToPutCaret
.
Set
(
visNode
)
;
break
;
}
bool
isEmptyBlock
;
if
(
NS_SUCCEEDED
(
IsEmptyNode
(
visNode
&
isEmptyBlock
)
)
&
&
isEmptyBlock
)
{
pointToPutCaret
.
Set
(
visNode
)
;
DebugOnly
<
bool
>
advanced
=
pointToPutCaret
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
the
found
empty
block
node
"
)
;
}
else
{
pointToPutCaret
.
Set
(
visNode
0
)
;
}
}
return
selection
-
>
Collapse
(
pointToPutCaret
)
;
}
nsresult
HTMLEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
return
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_BACK
:
case
NS_VK_DELETE
:
return
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
case
NS_VK_TAB
:
{
if
(
IsPlaintextEditor
(
)
)
{
return
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
}
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
&
&
selection
-
>
RangeCount
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINode
>
node
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
node
)
;
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
node
)
;
if
(
!
blockParent
)
{
break
;
}
bool
handled
=
false
;
nsresult
rv
=
NS_OK
;
if
(
HTMLEditUtils
:
:
IsTableElement
(
blockParent
)
)
{
rv
=
TabInTable
(
aKeyboardEvent
-
>
IsShift
(
)
&
handled
)
;
if
(
Destroyed
(
)
)
{
return
NS_OK
;
}
if
(
handled
)
{
ScrollSelectionIntoView
(
false
)
;
}
}
else
if
(
HTMLEditUtils
:
:
IsListItem
(
blockParent
)
)
{
rv
=
!
aKeyboardEvent
-
>
IsShift
(
)
?
IndentAsAction
(
)
:
OutdentAsAction
(
)
;
handled
=
true
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
handled
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
return
OnInputText
(
NS_LITERAL_STRING
(
"
\
t
"
)
)
;
}
case
NS_VK_RETURN
:
if
(
!
aKeyboardEvent
-
>
IsInputtingLineBreak
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
OnInputLineBreak
(
)
;
}
return
OnInputParagraphSeparator
(
)
;
}
if
(
!
aKeyboardEvent
-
>
IsInputtingText
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
aKeyboardEvent
-
>
mCharCode
)
;
return
OnInputText
(
str
)
;
}
bool
HTMLEditor
:
:
NodeIsBlockStatic
(
const
nsINode
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
head
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
th
nsGkAtoms
:
:
td
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
dd
)
)
{
return
true
;
}
return
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NodeIsBlock
(
nsINode
*
aNode
bool
*
aIsBlock
)
{
*
aIsBlock
=
IsBlockNode
(
aNode
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsBlockNode
(
nsINode
*
aNode
)
{
return
aNode
&
&
NodeIsBlockStatic
(
aNode
)
;
}
Element
*
HTMLEditor
:
:
GetBlockNodeParent
(
nsINode
*
aNode
nsINode
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
aNode
=
=
aAncestorLimiter
|
|
EditorUtils
:
:
IsDescendantOf
(
*
aNode
*
aAncestorLimiter
)
"
aNode
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
aNode
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
p
=
aNode
-
>
GetParentNode
(
)
;
while
(
p
)
{
if
(
NodeIsBlockStatic
(
p
)
)
{
return
p
-
>
AsElement
(
)
;
}
if
(
p
=
=
aAncestorLimiter
)
{
return
nullptr
;
}
p
=
p
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
Element
*
HTMLEditor
:
:
GetBlock
(
nsINode
&
aNode
nsINode
*
aAncestorLimiter
)
{
MOZ_ASSERT
(
!
aAncestorLimiter
|
|
&
aNode
=
=
aAncestorLimiter
|
|
EditorUtils
:
:
IsDescendantOf
(
aNode
*
aAncestorLimiter
)
"
aNode
isn
'
t
in
aAncestorLimiter
"
)
;
if
(
NodeIsBlockStatic
(
&
aNode
)
)
{
return
aNode
.
AsElement
(
)
;
}
return
GetBlockNodeParent
(
&
aNode
aAncestorLimiter
)
;
}
void
HTMLEditor
:
:
IsNextCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
(
uint32_t
)
aOffset
<
aContent
-
>
Length
(
)
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
+
1
;
}
}
}
void
HTMLEditor
:
:
IsPrevCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
aOffset
>
0
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
-
1
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
-
1
;
}
}
}
bool
HTMLEditor
:
:
IsVisibleBRElement
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
TextEditUtils
:
:
IsBreak
(
aNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
nextNode
=
GetNextHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
nextNode
&
&
TextEditUtils
:
:
IsBreak
(
nextNode
)
)
{
return
true
;
}
if
(
!
nextNode
)
{
return
false
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
GetPreviousHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
priorNode
&
&
TextEditUtils
:
:
IsBreak
(
priorNode
)
)
{
return
true
;
}
int32_t
selOffset
;
nsCOMPtr
<
nsINode
>
selNode
=
GetNodeLocation
(
aNode
&
selOffset
)
;
selOffset
+
+
;
WSRunObject
wsObj
(
this
selNode
selOffset
)
;
WSType
visType
;
wsObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
selNode
selOffset
)
&
visType
)
;
if
(
visType
&
WSType
:
:
block
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP
HTMLEditor
:
:
UpdateBaseURL
(
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
RefPtr
<
nsContentList
>
nodeList
=
doc
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
base
"
)
)
;
if
(
!
nodeList
|
|
!
nodeList
-
>
Item
(
0
)
)
{
doc
-
>
SetBaseURI
(
doc
-
>
GetDocumentURI
(
)
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
OnInputLineBreak
(
)
{
AutoPlaceholderBatch
batch
(
this
nsGkAtoms
:
:
TypingTxnName
)
;
nsresult
rv
=
InsertBrElementAtSelectionWithTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
TabInTable
(
bool
inIsShift
bool
*
outHandled
)
{
NS_ENSURE_TRUE
(
outHandled
NS_ERROR_NULL_POINTER
)
;
*
outHandled
=
false
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_OK
;
}
Element
*
cellElement
=
GetElementOrParentByTagNameAtSelection
(
*
selection
*
nsGkAtoms
:
:
td
)
;
if
(
NS_WARN_IF
(
!
cellElement
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
table
=
GetEnclosingTable
(
cellElement
)
;
if
(
NS_WARN_IF
(
!
table
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
table
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
iter
-
>
PositionAt
(
cellElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
node
;
do
{
if
(
inIsShift
)
{
iter
-
>
Prev
(
)
;
}
else
{
iter
-
>
Next
(
)
;
}
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
&
&
HTMLEditUtils
:
:
IsTableCell
(
node
)
&
&
GetEnclosingTable
(
node
)
=
=
table
)
{
CollapseSelectionToDeepestNonTableFirstChild
(
nullptr
node
)
;
*
outHandled
=
true
;
return
NS_OK
;
}
}
while
(
!
iter
-
>
IsDone
(
)
)
;
if
(
!
(
*
outHandled
)
&
&
!
inIsShift
)
{
rv
=
InsertTableRow
(
1
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
outHandled
=
true
;
RefPtr
<
Selection
>
selection
;
RefPtr
<
Element
>
tblElement
cell
;
int32_t
row
;
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
tblElement
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
row
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetCellAt
(
tblElement
row
0
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
{
selection
-
>
Collapse
(
cell
0
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertBrElementAtSelectionWithTransaction
(
)
{
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
if
(
!
selection
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
EditorRawDOMPoint
atStartOfSelection
(
GetStartPoint
(
selection
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
newBrElement
=
InsertBrElementWithTransaction
(
*
selection
atStartOfSelection
eNext
)
;
if
(
NS_WARN_IF
(
!
newBrElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
CollapseSelectionToDeepestNonTableFirstChild
(
Selection
*
aSelection
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
RefPtr
<
Selection
>
selection
=
aSelection
;
if
(
!
selection
)
{
selection
=
GetSelection
(
)
;
}
if
(
!
selection
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
aNode
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
node
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
child
)
|
|
!
IsContainer
(
child
)
)
{
break
;
}
node
=
child
;
}
selection
-
>
Collapse
(
node
0
)
;
}
nsresult
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
const
nsAString
&
aSourceToInsert
)
{
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eReplaceHeadWithHTMLSource
nsIEditor
:
:
eNone
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
CommitComposition
(
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsContentList
>
nodeList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
head
"
)
)
;
if
(
NS_WARN_IF
(
!
nodeList
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
headNode
=
nodeList
-
>
Item
(
0
)
;
if
(
NS_WARN_IF
(
!
headNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
inputString
(
aSourceToInsert
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
err
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
inputString
err
)
;
if
(
err
.
Failed
(
)
)
{
return
err
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
documentFragment
)
)
{
return
NS_ERROR_FAILURE
;
}
while
(
nsCOMPtr
<
nsIContent
>
child
=
headNode
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
int32_t
offsetOfNewNode
=
0
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
documentFragment
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
InsertNodeWithTransaction
(
*
child
EditorRawDOMPoint
(
headNode
offsetOfNewNode
+
+
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RebuildDocumentFromSource
(
const
nsAString
&
aSourceString
)
{
CommitComposition
(
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsReadingIterator
<
char16_t
>
beginbody
;
nsReadingIterator
<
char16_t
>
endbody
;
aSourceString
.
BeginReading
(
beginbody
)
;
aSourceString
.
EndReading
(
endbody
)
;
bool
foundbody
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
body
"
)
beginbody
endbody
)
;
nsReadingIterator
<
char16_t
>
beginhead
;
nsReadingIterator
<
char16_t
>
endhead
;
aSourceString
.
BeginReading
(
beginhead
)
;
aSourceString
.
EndReading
(
endhead
)
;
bool
foundhead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
head
"
)
beginhead
endhead
)
;
if
(
foundbody
&
&
beginhead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundhead
=
false
;
}
nsReadingIterator
<
char16_t
>
beginclosehead
;
nsReadingIterator
<
char16_t
>
endclosehead
;
aSourceString
.
BeginReading
(
beginclosehead
)
;
aSourceString
.
EndReading
(
endclosehead
)
;
bool
foundclosehead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
/
head
>
"
)
beginclosehead
endclosehead
)
;
if
(
foundhead
&
&
beginhead
.
get
(
)
>
beginclosehead
.
get
(
)
)
{
foundclosehead
=
false
;
}
if
(
foundbody
&
&
beginclosehead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundclosehead
=
false
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
nsReadingIterator
<
char16_t
>
endtotal
;
aSourceString
.
EndReading
(
endtotal
)
;
if
(
foundhead
)
{
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
else
{
nsReadingIterator
<
char16_t
>
begintotal
;
aSourceString
.
BeginReading
(
begintotal
)
;
NS_NAMED_LITERAL_STRING
(
head
"
<
head
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginclosehead
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginbody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
nsresult
rv
=
SelectAll
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
foundbody
)
{
NS_NAMED_LITERAL_STRING
(
body
"
<
body
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
LoadHTML
(
body
+
Substring
(
endclosehead
endtotal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
foundhead
)
{
nsresult
rv
=
LoadHTML
(
body
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
LoadHTML
(
body
+
aSourceString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
RefPtr
<
Element
>
divElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
div
)
;
if
(
NS_WARN_IF
(
!
divElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
*
divElement
)
;
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
rv
=
LoadHTML
(
Substring
(
beginbody
endtotal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsReadingIterator
<
char16_t
>
beginclosebody
=
beginbody
;
nsReadingIterator
<
char16_t
>
endclosebody
;
aSourceString
.
EndReading
(
endclosebody
)
;
if
(
!
FindInReadable
(
NS_LITERAL_STRING
(
"
>
"
)
beginclosebody
endclosebody
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
bodyTag
;
bodyTag
.
AssignLiteral
(
"
<
div
"
)
;
bodyTag
.
Append
(
Substring
(
endbody
endclosebody
)
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
ErrorResult
erv
;
RefPtr
<
DocumentFragment
>
docfrag
=
range
-
>
CreateContextualFragment
(
bodyTag
erv
)
;
NS_ENSURE_TRUE
(
!
erv
.
Failed
(
)
erv
.
StealNSResult
(
)
)
;
NS_ENSURE_TRUE
(
docfrag
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIContent
>
child
=
docfrag
-
>
GetFirstChild
(
)
;
NS_ENSURE_TRUE
(
child
&
&
child
-
>
IsElement
(
)
NS_ERROR_NULL_POINTER
)
;
CloneAttributesWithTransaction
(
*
rootElement
*
child
-
>
AsElement
(
)
)
;
return
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
}
EditorRawDOMPoint
HTMLEditor
:
:
GetBetterInsertionPointFor
(
nsINode
&
aNodeToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
aPointToInsert
;
}
EditorRawDOMPoint
pointToInsert
(
aPointToInsert
.
GetNonAnonymousSubtreePoint
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
IsBlockNode
(
&
aNodeToInsert
)
)
{
return
pointToInsert
;
}
WSRunObject
wsObj
(
this
pointToInsert
.
GetContainer
(
)
pointToInsert
.
Offset
(
)
)
;
nsCOMPtr
<
nsINode
>
nextVisibleNode
;
WSType
nextVisibleType
;
wsObj
.
NextVisibleNode
(
pointToInsert
address_of
(
nextVisibleNode
)
nullptr
&
nextVisibleType
)
;
if
(
!
nextVisibleNode
|
|
!
(
nextVisibleType
&
WSType
:
:
br
)
)
{
return
pointToInsert
;
}
nsCOMPtr
<
nsINode
>
previousVisibleNode
;
WSType
previousVisibleType
;
wsObj
.
PriorVisibleNode
(
pointToInsert
address_of
(
previousVisibleNode
)
nullptr
&
previousVisibleType
)
;
if
(
!
previousVisibleNode
|
|
(
previousVisibleType
&
WSType
:
:
br
)
|
|
(
previousVisibleType
&
WSType
:
:
thisBlock
)
)
{
return
pointToInsert
;
}
EditorRawDOMPoint
afterBRNode
(
nextVisibleNode
)
;
DebugOnly
<
bool
>
advanced
=
afterBRNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
<
br
>
node
"
)
;
return
afterBRNode
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertElementAtSelection
(
Element
*
aElement
bool
aDeleteSelection
)
{
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
NS_ENSURE_TRUE
(
aElement
NS_ERROR_NULL_POINTER
)
;
CommitComposition
(
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
bool
cancel
handled
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eInsertElement
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
if
(
aDeleteSelection
)
{
if
(
!
IsBlockNode
(
aElement
)
)
{
rv
=
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aDeleteSelection
)
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aElement
)
)
{
selection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
else
{
selection
-
>
CollapseToEnd
(
IgnoreErrors
(
)
)
;
}
}
if
(
selection
-
>
GetAnchorNode
(
)
)
{
EditorRawDOMPoint
atAnchor
(
selection
-
>
AnchorRef
(
)
)
;
EditorRawDOMPoint
pointToInsert
=
GetBetterInsertionPointFor
(
*
aElement
atAnchor
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
aElement
pointToInsert
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
!
insertedPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
SetCaretInTableCell
(
aElement
)
)
{
rv
=
CollapseSelectionAfter
(
*
selection
*
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
HTMLEditUtils
:
:
IsTable
(
aElement
)
&
&
IsLastEditableChild
(
aElement
)
)
{
DebugOnly
<
bool
>
advanced
=
insertedPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
RefPtr
<
Element
>
newBrElement
=
InsertBrElementWithTransaction
(
*
selection
insertedPoint
ePrevious
)
;
if
(
NS_WARN_IF
(
!
newBrElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
}
rv
=
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
return
rv
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPoint
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorDOMPointBase
<
PT
CT
>
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
while
(
!
CanContain
(
*
pointToInsert
.
GetContainer
(
)
aNode
)
)
{
if
(
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
pointToInsert
.
GetContainer
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
IsEditable
(
pointToInsert
.
GetContainer
(
)
)
)
{
pointToInsert
=
aPointToInsert
;
break
;
}
}
if
(
pointToInsert
!
=
aPointToInsert
)
{
MOZ_ASSERT
(
pointToInsert
.
GetChild
(
)
)
;
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
pointToInsert
.
GetChild
(
)
aPointToInsert
aSplitAtEdges
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
pointToInsert
=
splitNodeResult
.
SplitPoint
(
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
}
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
aNode
pointToInsert
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorDOMPoint
(
)
;
}
}
return
pointToInsert
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
SelectContentInternal
(
*
selection
*
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SelectContentInternal
(
Selection
&
aSelection
nsIContent
&
aContentToSelect
)
{
if
(
!
IsDescendantOfEditorRoot
(
&
aContentToSelect
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
parent
=
aContentToSelect
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoUpdateViewBatch
notifySelectionChangeOnce
(
this
)
;
int32_t
offsetInParent
=
parent
-
>
ComputeIndexOf
(
&
aContentToSelect
)
;
nsresult
rv
=
aSelection
.
Collapse
(
parent
offsetInParent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aSelection
.
Extend
(
parent
offsetInParent
+
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetCaretAfterElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionAfter
(
*
selection
*
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CollapseSelectionAfter
(
Selection
&
aSelection
Element
&
aElement
)
{
if
(
NS_WARN_IF
(
!
IsDescendantOfEditorRoot
(
&
aElement
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsINode
*
parent
=
aElement
.
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
afterElement
(
&
aElement
)
;
if
(
NS_WARN_IF
(
!
afterElement
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
aSelection
.
Collapse
(
afterElement
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetParagraphFormat
(
const
nsAString
&
aParagraphFormat
)
{
nsAutoString
lowerCaseTagName
(
aParagraphFormat
)
;
ToLowerCase
(
lowerCaseTagName
)
;
RefPtr
<
nsAtom
>
tagName
=
NS_Atomize
(
lowerCaseTagName
)
;
MOZ_ASSERT
(
tagName
)
;
if
(
tagName
=
=
nsGkAtoms
:
:
dd
|
|
tagName
=
=
nsGkAtoms
:
:
dt
)
{
return
MakeDefinitionListItemWithTransaction
(
*
tagName
)
;
}
return
InsertBasicBlockWithTransaction
(
*
tagName
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
outFormat
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
(
mRules
-
>
AsHTMLEditRules
(
)
)
;
return
htmlRules
-
>
GetParagraphState
(
aMixed
outFormat
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
IsCSSEnabled
(
)
)
{
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
true
)
;
}
return
GetHTMLBackgroundColorState
(
aMixed
aOutColor
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHighlightColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
if
(
!
IsCSSEnabled
(
)
)
{
return
NS_OK
;
}
return
GetCSSBackgroundColorState
(
aMixed
aOutColor
false
)
;
}
nsresult
HTMLEditor
:
:
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
&
&
selection
-
>
GetRangeAt
(
0
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
parent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
nodeToExamine
;
if
(
selection
-
>
IsCollapsed
(
)
|
|
IsTextNode
(
parent
)
)
{
nodeToExamine
=
parent
;
}
else
{
nodeToExamine
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetChildAtStartOffset
(
)
;
}
NS_ENSURE_TRUE
(
nodeToExamine
NS_ERROR_NULL_POINTER
)
;
if
(
aBlockLevel
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
nodeToExamine
)
;
NS_ENSURE_TRUE
(
blockParent
NS_OK
)
;
do
{
CSSEditUtils
:
:
GetComputedProperty
(
*
blockParent
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
blockParent
=
blockParent
-
>
GetParentElement
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
blockParent
)
;
if
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
CSSEditUtils
:
:
GetDefaultBackgroundColor
(
aOutColor
)
;
}
}
else
{
if
(
IsTextNode
(
nodeToExamine
)
)
{
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
if
(
!
nodeToExamine
)
{
return
NS_OK
;
}
do
{
if
(
NodeIsBlockStatic
(
nodeToExamine
)
)
{
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
break
;
}
else
{
CSSEditUtils
:
:
GetComputedProperty
(
*
nodeToExamine
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
nodeToExamine
=
nodeToExamine
-
>
GetParentNode
(
)
;
}
while
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
&
&
nodeToExamine
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
NS_ENSURE_TRUE
(
aMixed
NS_ERROR_NULL_POINTER
)
;
*
aMixed
=
false
;
aOutColor
.
Truncate
(
)
;
RefPtr
<
Element
>
element
;
int32_t
selectedCount
;
nsAutoString
tagName
;
nsresult
rv
=
GetSelectedOrParentTableElement
(
tagName
&
selectedCount
getter_AddRefs
(
element
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
element
)
{
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
if
(
!
aOutColor
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
NS_OK
;
}
element
=
element
-
>
GetParentElement
(
)
;
}
dom
:
:
Element
*
bodyElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
bodyElement
NS_ERROR_NULL_POINTER
)
;
bodyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aOL
&
&
aUL
&
&
aDL
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
(
mRules
-
>
AsHTMLEditRules
(
)
)
;
return
htmlRules
-
>
GetListState
(
aMixed
aOL
aUL
aDL
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aLI
&
&
aDT
&
&
aDD
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
(
mRules
-
>
AsHTMLEditRules
(
)
)
;
return
htmlRules
-
>
GetListItemState
(
aMixed
aLI
aDT
aDD
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
NS_ENSURE_TRUE
(
aMixed
&
&
aAlign
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
HTMLEditRules
>
htmlRules
(
mRules
-
>
AsHTMLEditRules
(
)
)
;
return
htmlRules
-
>
GetAlignment
(
aMixed
aAlign
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MakeOrChangeList
(
const
nsAString
&
aListType
bool
entireList
const
nsAString
&
aBulletType
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrChangeList
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eCreateOrChangeList
)
;
subActionInfo
.
blockType
=
&
aListType
;
subActionInfo
.
entireList
=
entireList
;
subActionInfo
.
bulletType
=
&
aBulletType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
&
&
selection
-
>
IsCollapsed
(
)
)
{
nsRange
*
firstRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
atStartOfSelection
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertList
(
atStartOfSelection
)
;
RefPtr
<
nsAtom
>
listAtom
=
NS_Atomize
(
aListType
)
;
while
(
!
CanContainTag
(
*
pointToInsertList
.
GetContainer
(
)
*
listAtom
)
)
{
pointToInsertList
.
Set
(
pointToInsertList
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsertList
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsertList
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
pointToInsertList
.
GetContainer
(
)
!
=
atStartOfSelection
.
GetContainer
(
)
)
{
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
*
pointToInsertList
.
GetChild
(
)
atStartOfSelection
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitNodeResult
.
Failed
(
)
)
)
{
return
splitNodeResult
.
Rv
(
)
;
}
pointToInsertList
=
splitNodeResult
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsertList
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
newList
=
CreateNodeWithTransaction
(
*
listAtom
pointToInsertList
)
;
if
(
NS_WARN_IF
(
!
newList
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfNewList
(
newList
0
)
;
RefPtr
<
Element
>
newItem
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
li
atStartOfNewList
)
;
if
(
NS_WARN_IF
(
!
newItem
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
selection
-
>
Collapse
(
RawRangeBoundary
(
newItem
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveList
(
const
nsAString
&
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eRemoveList
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eRemoveList
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
nsresult
HTMLEditor
:
:
MakeDefinitionListItemWithTransaction
(
nsAtom
&
aTagName
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
&
aTagName
=
=
nsGkAtoms
:
:
dt
|
|
&
aTagName
=
=
nsGkAtoms
:
:
dd
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrChangeDefinitionList
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsDependentAtomString
tagName
(
&
aTagName
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eCreateOrChangeDefinitionList
)
;
subActionInfo
.
blockType
=
&
tagName
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
)
{
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertBasicBlockWithTransaction
(
nsAtom
&
aTagName
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
dd
&
&
&
aTagName
!
=
nsGkAtoms
:
:
dt
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrRemoveBlock
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
nsDependentAtomString
tagName
(
&
aTagName
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eCreateOrRemoveBlock
)
;
subActionInfo
.
blockType
=
&
tagName
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
&
&
selection
-
>
IsCollapsed
(
)
)
{
nsRange
*
firstRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
atStartOfSelection
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlock
(
atStartOfSelection
)
;
while
(
!
CanContainTag
(
*
pointToInsertBlock
.
GetContainer
(
)
aTagName
)
)
{
pointToInsertBlock
.
Set
(
pointToInsertBlock
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsertBlock
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsertBlock
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
pointToInsertBlock
.
GetContainer
(
)
!
=
atStartOfSelection
.
GetContainer
(
)
)
{
SplitNodeResult
splitBlockResult
=
SplitNodeDeepWithTransaction
(
*
pointToInsertBlock
.
GetChild
(
)
atStartOfSelection
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitBlockResult
.
Failed
(
)
)
)
{
return
splitBlockResult
.
Rv
(
)
;
}
pointToInsertBlock
=
splitBlockResult
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsertBlock
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
newBlock
=
CreateNodeWithTransaction
(
aTagName
pointToInsertBlock
)
;
if
(
NS_WARN_IF
(
!
newBlock
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
selection
-
>
Collapse
(
RawRangeBoundary
(
newBlock
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Indent
(
const
nsAString
&
aIndent
)
{
if
(
aIndent
.
LowerCaseEqualsLiteral
(
"
indent
"
)
)
{
nsresult
rv
=
IndentAsAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
aIndent
.
LowerCaseEqualsLiteral
(
"
outdent
"
)
)
{
nsresult
rv
=
OutdentAsAction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
return
NS_ERROR_INVALID_ARG
;
}
nsresult
HTMLEditor
:
:
IndentAsAction
(
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
nsresult
rv
=
IndentOrOutdentAsSubAction
(
EditSubAction
:
:
eIndent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
OutdentAsAction
(
)
{
if
(
!
mRules
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoPlaceholderBatch
beginBatching
(
this
)
;
nsresult
rv
=
IndentOrOutdentAsSubAction
(
EditSubAction
:
:
eOutdent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
IndentOrOutdentAsSubAction
(
EditSubAction
aIndentOrOutdent
)
{
MOZ_ASSERT
(
mRules
)
;
MOZ_ASSERT
(
mPlaceholderBatch
)
;
MOZ_ASSERT
(
aIndentOrOutdent
=
=
EditSubAction
:
:
eIndent
|
|
aIndentOrOutdent
=
=
EditSubAction
:
:
eOutdent
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
bool
cancel
handled
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
aIndentOrOutdent
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
EditSubActionInfo
subActionInfo
(
aIndentOrOutdent
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
handled
&
&
selection
-
>
IsCollapsed
(
)
&
&
aIndentOrOutdent
=
=
EditSubAction
:
:
eIndent
)
{
nsRange
*
firstRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
atStartOfSelection
(
firstRange
-
>
StartRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
atStartOfSelection
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
pointToInsertBlockquote
(
atStartOfSelection
)
;
while
(
!
CanContainTag
(
*
pointToInsertBlockquote
.
GetContainer
(
)
*
nsGkAtoms
:
:
blockquote
)
)
{
pointToInsertBlockquote
.
Set
(
pointToInsertBlockquote
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsertBlockquote
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
pointToInsertBlockquote
.
GetContainerAsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
pointToInsertBlockquote
.
GetContainer
(
)
!
=
atStartOfSelection
.
GetContainer
(
)
)
{
SplitNodeResult
splitBlockquoteResult
=
SplitNodeDeepWithTransaction
(
*
pointToInsertBlockquote
.
GetChild
(
)
atStartOfSelection
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
NS_WARN_IF
(
splitBlockquoteResult
.
Failed
(
)
)
)
{
return
splitBlockquoteResult
.
Rv
(
)
;
}
pointToInsertBlockquote
=
splitBlockquoteResult
.
SplitPoint
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsertBlockquote
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
newBQ
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
blockquote
pointToInsertBlockquote
)
;
if
(
NS_WARN_IF
(
!
newBQ
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
selection
-
>
Collapse
(
RawRangeBoundary
(
newBQ
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
rv
=
InsertTextAsSubAction
(
NS_LITERAL_STRING
(
"
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
firstRange
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
selection
-
>
Collapse
(
RawRangeBoundary
(
firstRange
-
>
GetStartContainer
(
)
0
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
rv
=
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
Align
(
const
nsAString
&
aAlignType
)
{
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eSetOrClearAlignment
nsIEditor
:
:
eNext
)
;
bool
cancel
handled
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eSetOrClearAlignment
)
;
subActionInfo
.
alignType
=
&
aAlignType
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
cancel
|
|
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAtom
&
aTagName
nsINode
*
aNode
)
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
aNode
)
{
return
GetElementOrParentByTagNameInternal
(
aTagName
*
aNode
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
nullptr
;
}
return
GetElementOrParentByTagNameAtSelection
(
*
selection
aTagName
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagNameAtSelection
(
Selection
&
aSelection
const
nsAtom
&
aTagName
)
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
const
EditorRawDOMPoint
atAnchor
(
aSelection
.
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
node
;
if
(
atAnchor
.
GetContainer
(
)
-
>
HasChildNodes
(
)
&
&
atAnchor
.
GetContainerAsContent
(
)
)
{
node
=
atAnchor
.
GetChild
(
)
;
}
if
(
!
node
)
{
node
=
atAnchor
.
GetContainer
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
nullptr
;
}
}
return
GetElementOrParentByTagNameInternal
(
aTagName
*
node
)
;
}
Element
*
HTMLEditor
:
:
GetElementOrParentByTagNameInternal
(
const
nsAtom
&
aTagName
nsINode
&
aNode
)
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
Element
*
currentElement
=
aNode
.
IsElement
(
)
?
aNode
.
AsElement
(
)
:
aNode
.
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
currentElement
)
)
{
MOZ_ASSERT
(
!
aNode
.
GetParentNode
(
)
|
|
!
aNode
.
GetParentNode
(
)
-
>
GetParentNode
(
)
)
;
return
nullptr
;
}
bool
getLink
=
IsLinkTag
(
aTagName
)
;
bool
getNamedAnchor
=
IsNamedAnchorTag
(
aTagName
)
;
const
nsAtom
&
tagName
=
getLink
|
|
getNamedAnchor
?
*
nsGkAtoms
:
:
a
:
aTagName
;
for
(
;
currentElement
;
currentElement
=
currentElement
-
>
GetParentElement
(
)
)
{
if
(
(
getLink
&
&
HTMLEditUtils
:
:
IsLink
(
currentElement
)
)
|
|
(
getNamedAnchor
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
currentElement
)
)
)
{
return
currentElement
;
}
if
(
&
tagName
=
=
nsGkAtoms
:
:
list_
)
{
if
(
HTMLEditUtils
:
:
IsList
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
&
tagName
=
=
nsGkAtoms
:
:
td
)
{
if
(
HTMLEditUtils
:
:
IsTableCell
(
currentElement
)
)
{
return
currentElement
;
}
}
else
if
(
&
tagName
=
=
currentElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
currentElement
;
}
if
(
currentElement
-
>
GetParentElement
(
)
&
&
currentElement
-
>
GetParentElement
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
break
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsINode
*
aNode
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
|
|
NS_WARN_IF
(
tagName
=
=
nsGkAtoms
:
:
_empty
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
parent
=
GetElementOrParentByTagName
(
*
tagName
aNode
)
;
if
(
!
parent
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parent
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedElement
(
const
nsAString
&
aTagName
nsISupports
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
RefPtr
<
nsINode
>
selectedNode
=
GetSelectedElement
(
*
selection
tagName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
selectedNode
.
forget
(
aReturn
)
;
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetSelectedElement
(
Selection
&
aSelection
const
nsAtom
*
aTagName
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
bool
isLinkTag
=
aTagName
&
&
IsLinkTag
(
*
aTagName
)
;
bool
isNamedAnchorTag
=
aTagName
&
&
IsNamedAnchorTag
(
*
aTagName
)
;
RefPtr
<
nsRange
>
firstRange
=
aSelection
.
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
startContainer
=
firstRange
-
>
GetStartContainer
(
)
;
nsIContent
*
startNode
=
firstRange
-
>
GetChildAtStartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
firstRange
-
>
GetEndContainer
(
)
;
nsIContent
*
endNode
=
firstRange
-
>
GetChildAtEndOffset
(
)
;
if
(
startContainer
&
&
startContainer
=
=
endContainer
&
&
startNode
&
&
endNode
&
&
startNode
-
>
GetNextSibling
(
)
=
=
endNode
)
{
if
(
!
aTagName
)
{
if
(
NS_WARN_IF
(
!
startNode
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
selectedElement
=
startNode
-
>
AsElement
(
)
;
return
selectedElement
.
forget
(
)
;
}
if
(
aTagName
=
=
startNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
|
|
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
startNode
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
startNode
)
)
)
{
MOZ_ASSERT
(
startNode
-
>
IsElement
(
)
)
;
RefPtr
<
Element
>
selectedElement
=
startNode
-
>
AsElement
(
)
;
return
selectedElement
.
forget
(
)
;
}
}
RefPtr
<
Element
>
selectedElement
;
if
(
isLinkTag
)
{
const
RangeBoundary
&
anchor
=
aSelection
.
AnchorRef
(
)
;
const
RangeBoundary
&
focus
=
aSelection
.
FocusRef
(
)
;
if
(
anchor
.
IsSet
(
)
)
{
Element
*
parentLinkOfAnchor
=
GetElementOrParentByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
anchor
.
Container
(
)
)
;
if
(
parentLinkOfAnchor
)
{
if
(
aSelection
.
IsCollapsed
(
)
)
{
return
do_AddRef
(
parentLinkOfAnchor
)
;
}
if
(
focus
.
IsSet
(
)
)
{
Element
*
parentLinkOfFocus
=
GetElementOrParentByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
focus
.
Container
(
)
)
;
if
(
parentLinkOfFocus
=
=
parentLinkOfAnchor
)
{
return
do_AddRef
(
parentLinkOfAnchor
)
;
}
}
}
else
if
(
anchor
.
GetChildAtOffset
(
)
&
&
focus
.
GetChildAtOffset
(
)
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
anchor
.
GetChildAtOffset
(
)
)
&
&
anchor
.
Container
(
)
=
=
focus
.
Container
(
)
&
&
focus
.
GetChildAtOffset
(
)
=
=
anchor
.
GetChildAtOffset
(
)
-
>
GetNextSibling
(
)
)
{
selectedElement
=
Element
:
:
FromNodeOrNull
(
anchor
.
GetChildAtOffset
(
)
)
;
}
}
}
}
if
(
aSelection
.
IsCollapsed
(
)
)
{
return
selectedElement
.
forget
(
)
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
bool
found
=
!
!
selectedElement
;
const
nsAtom
*
tagNameLookingFor
=
aTagName
;
iter
-
>
Init
(
firstRange
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
selectedElement
=
Element
:
:
FromNodeOrNull
(
iter
-
>
GetCurrentNode
(
)
)
;
if
(
selectedElement
)
{
if
(
found
)
{
break
;
}
if
(
!
tagNameLookingFor
)
{
tagNameLookingFor
=
selectedElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
if
(
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
selectedElement
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
selectedElement
)
)
)
{
found
=
true
;
}
else
if
(
tagNameLookingFor
=
=
selectedElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
found
=
true
;
}
if
(
!
found
)
{
break
;
}
}
iter
-
>
Next
(
)
;
}
return
selectedElement
.
forget
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAtom
&
aTagName
)
{
const
nsAtom
*
realTagName
=
IsLinkTag
(
aTagName
)
|
|
IsNamedAnchorTag
(
aTagName
)
?
nsGkAtoms
:
:
a
:
&
aTagName
;
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
realTagName
)
;
if
(
!
newElement
)
{
return
nullptr
;
}
IgnoredErrorResult
rv
;
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
_moz_dirty
"
)
EmptyString
(
)
rv
)
;
if
(
realTagName
=
=
nsGkAtoms
:
:
table
)
{
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellpadding
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
cellspacing
"
)
NS_LITERAL_STRING
(
"
2
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
border
"
)
NS_LITERAL_STRING
(
"
1
"
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
else
if
(
realTagName
=
=
nsGkAtoms
:
:
td
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
newElement
nsGkAtoms
:
:
valign
NS_LITERAL_STRING
(
"
top
"
)
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
RefPtr
<
nsAtom
>
tagName
=
GetLowerCaseNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
newElement
=
CreateElementWithDefaults
(
*
tagName
)
;
if
(
NS_WARN_IF
(
!
newElement
)
)
{
return
NS_ERROR_FAILURE
;
}
newElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLinkAroundSelection
(
Element
*
aAnchorElement
)
{
NS_ENSURE_TRUE
(
aAnchorElement
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_NULL_POINTER
)
;
if
(
selection
-
>
IsCollapsed
(
)
)
{
NS_WARNING
(
"
InsertLinkAroundSelection
called
but
there
is
no
selection
!
!
!
"
)
;
return
NS_OK
;
}
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNodeOrNull
(
aAnchorElement
)
;
if
(
!
anchor
)
{
return
NS_OK
;
}
nsAutoString
href
;
anchor
-
>
GetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
AutoPlaceholderBatch
beginBatching
(
this
)
;
RefPtr
<
nsDOMAttributeMap
>
attrMap
=
anchor
-
>
Attributes
(
)
;
NS_ENSURE_TRUE
(
attrMap
NS_ERROR_FAILURE
)
;
uint32_t
count
=
attrMap
-
>
Length
(
)
;
nsAutoString
value
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
Attr
>
attribute
=
attrMap
-
>
Item
(
i
)
;
if
(
attribute
)
{
value
.
Truncate
(
)
;
nsAtom
*
name
=
attribute
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
attribute
-
>
GetValue
(
value
)
;
rv
=
SetInlinePropertyInternal
(
*
nsGkAtoms
:
:
a
name
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
RefPtr
<
Element
>
element
;
int32_t
selectedCount
;
nsAutoString
tagName
;
nsresult
rv
=
GetSelectedOrParentTableElement
(
tagName
&
selectedCount
getter_AddRefs
(
element
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
setColor
=
!
aColor
.
IsEmpty
(
)
;
RefPtr
<
nsAtom
>
bgColorAtom
=
NS_Atomize
(
"
bgcolor
"
)
;
if
(
element
)
{
if
(
selectedCount
>
0
)
{
RefPtr
<
Element
>
cell
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
cell
)
{
while
(
cell
)
{
rv
=
setColor
?
SetAttributeWithTransaction
(
*
cell
*
bgColorAtom
aColor
)
:
RemoveAttributeWithTransaction
(
*
cell
*
bgColorAtom
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
}
return
NS_OK
;
}
}
}
else
{
element
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
}
return
setColor
?
SetAttributeWithTransaction
(
*
element
*
bgColorAtom
aColor
)
:
RemoveAttributeWithTransaction
(
*
element
*
bgColorAtom
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetLinkedObjects
(
nsIArray
*
*
aNodeList
)
{
NS_ENSURE_TRUE
(
aNodeList
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
;
nsCOMPtr
<
nsIMutableArray
>
nodes
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_UNEXPECTED
)
;
iter
-
>
Init
(
doc
-
>
GetRootElement
(
)
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
)
{
nsCOMPtr
<
nsIURIRefObject
>
refObject
;
rv
=
NS_NewHTMLURIRefObject
(
getter_AddRefs
(
refObject
)
node
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nodes
-
>
AppendElement
(
refObject
)
;
}
}
iter
-
>
Next
(
)
;
}
nodes
.
forget
(
aNodeList
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
AddOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
nsresult
rv
=
AddOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
AddOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIURI
>
uaURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uaURI
)
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
StyleSheet
>
sheet
;
DebugOnly
<
nsresult
>
ignoredRv
=
presShell
-
>
GetDocument
(
)
-
>
CSSLoader
(
)
-
>
LoadSheetSync
(
uaURI
css
:
:
eAgentSheetFeatures
true
&
sheet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
ignoredRv
)
"
LoadSheetSync
(
)
failed
"
)
;
if
(
NS_WARN_IF
(
!
sheet
)
)
{
return
NS_ERROR_FAILURE
;
}
presShell
-
>
AddOverrideStyleSheet
(
sheet
)
;
presShell
-
>
ApplicableStylesChanged
(
)
;
mLastOverrideStyleSheetURL
=
aURL
;
rv
=
AddNewStyleSheetToList
(
aURL
sheet
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ReplaceOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
if
(
EnableExistingStyleSheet
(
aURL
)
)
{
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
&
&
!
mLastOverrideStyleSheetURL
.
Equals
(
aURL
)
)
{
EnableStyleSheetInternal
(
mLastOverrideStyleSheetURL
false
)
;
}
return
NS_OK
;
}
if
(
!
mLastOverrideStyleSheetURL
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
RemoveOverrideStyleSheetInternal
(
mLastOverrideStyleSheetURL
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
last
override
style
sheet
"
)
;
}
nsresult
rv
=
AddOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveOverrideStyleSheet
(
const
nsAString
&
aURL
)
{
nsresult
rv
=
RemoveOverrideStyleSheetInternal
(
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RemoveOverrideStyleSheetInternal
(
const
nsAString
&
aURL
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
StyleSheet
>
sheet
=
RemoveStyleSheetFromList
(
aURL
)
;
if
(
!
sheet
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
presShell
-
>
RemoveOverrideStyleSheet
(
sheet
)
;
presShell
-
>
ApplicableStylesChanged
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
EnableStyleSheet
(
const
nsAString
&
aURL
bool
aEnable
)
{
EnableStyleSheetInternal
(
aURL
aEnable
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
EnableStyleSheetInternal
(
const
nsAString
&
aURL
bool
aEnable
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
if
(
!
sheet
)
{
return
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
document
StyleSheet
:
:
NotOwnedByDocumentOrShadowRoot
)
;
sheet
-
>
SetDisabled
(
!
aEnable
)
;
}
bool
HTMLEditor
:
:
EnableExistingStyleSheet
(
const
nsAString
&
aURL
)
{
RefPtr
<
StyleSheet
>
sheet
=
GetStyleSheetForURL
(
aURL
)
;
if
(
!
sheet
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
document
StyleSheet
:
:
NotOwnedByDocumentOrShadowRoot
)
;
return
true
;
}
nsresult
HTMLEditor
:
:
AddNewStyleSheetToList
(
const
nsAString
&
aURL
StyleSheet
*
aStyleSheet
)
{
uint32_t
countSS
=
mStyleSheets
.
Length
(
)
;
uint32_t
countU
=
mStyleSheetURLs
.
Length
(
)
;
if
(
countSS
!
=
countU
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mStyleSheetURLs
.
AppendElement
(
aURL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mStyleSheets
.
AppendElement
(
aStyleSheet
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
already_AddRefed
<
StyleSheet
>
HTMLEditor
:
:
RemoveStyleSheetFromList
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
nullptr
;
}
RefPtr
<
StyleSheet
>
removingStyleSheet
=
mStyleSheets
[
foundIndex
]
;
MOZ_ASSERT
(
removingStyleSheet
)
;
mStyleSheets
.
RemoveElementAt
(
foundIndex
)
;
mStyleSheetURLs
.
RemoveElementAt
(
foundIndex
)
;
return
removingStyleSheet
.
forget
(
)
;
}
StyleSheet
*
HTMLEditor
:
:
GetStyleSheetForURL
(
const
nsAString
&
aURL
)
{
size_t
foundIndex
;
foundIndex
=
mStyleSheetURLs
.
IndexOf
(
aURL
)
;
if
(
foundIndex
=
=
mStyleSheetURLs
.
NoIndex
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mStyleSheets
[
foundIndex
]
)
;
return
mStyleSheets
[
foundIndex
]
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetEmbeddedObjects
(
nsIArray
*
*
aNodeList
)
{
if
(
NS_WARN_IF
(
!
aNodeList
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
;
nsCOMPtr
<
nsIMutableArray
>
nodes
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
iter
-
>
Init
(
doc
-
>
GetRootElement
(
)
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
element
=
node
-
>
AsElement
(
)
;
if
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
img
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
a
)
|
|
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
background
)
)
)
{
nodes
-
>
AppendElement
(
node
)
;
}
}
iter
-
>
Next
(
)
;
}
nodes
.
forget
(
aNodeList
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteSelectionWithTransaction
(
EDirection
aAction
EStripWrappers
aStripWrappers
)
{
MOZ_ASSERT
(
aStripWrappers
=
=
eStrip
|
|
aStripWrappers
=
=
eNoStrip
)
;
nsresult
rv
=
TextEditor
:
:
DeleteSelectionWithTransaction
(
aAction
aStripWrappers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aStripWrappers
=
=
eNoStrip
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorFocusRange
(
)
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
;
NS_ENSURE_STATE
(
selection
-
>
GetAnchorNode
(
)
-
>
IsContent
(
)
)
;
nsCOMPtr
<
nsIContent
>
content
=
selection
-
>
GetAnchorNode
(
)
-
>
AsContent
(
)
;
nsCOMPtr
<
nsIContent
>
blockParent
=
content
;
while
(
blockParent
&
&
!
IsBlockNode
(
blockParent
)
)
{
blockParent
=
blockParent
-
>
GetParent
(
)
;
}
if
(
!
blockParent
)
{
return
NS_OK
;
}
bool
emptyBlockParent
;
rv
=
IsEmptyNode
(
blockParent
&
emptyBlockParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
emptyBlockParent
)
{
return
NS_OK
;
}
if
(
content
&
&
!
IsBlockNode
(
content
)
&
&
!
content
-
>
Length
(
)
&
&
content
-
>
IsEditable
(
)
&
&
content
!
=
content
-
>
GetEditingHost
(
)
)
{
while
(
content
-
>
GetParent
(
)
&
&
!
IsBlockNode
(
content
-
>
GetParent
(
)
)
&
&
content
-
>
GetParent
(
)
-
>
Length
(
)
=
=
1
&
&
content
-
>
GetParent
(
)
-
>
IsEditable
(
)
&
&
content
-
>
GetParent
(
)
!
=
content
-
>
GetEditingHost
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
rv
=
DeleteNodeWithTransaction
(
*
content
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteNodeWithTransaction
(
nsINode
&
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
IsModifiableNode
(
*
aNode
.
AsContent
(
)
)
&
&
!
IsMozEditorBogusNode
(
aNode
.
AsContent
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteNode
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
aNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteTextWithTransaction
(
CharacterData
&
aCharData
uint32_t
aOffset
uint32_t
aLength
)
{
if
(
!
IsModifiableNode
(
aCharData
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
DeleteTextWithTransaction
(
aCharData
aOffset
aLength
)
;
}
nsresult
HTMLEditor
:
:
InsertTextWithTransaction
(
nsIDocument
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
IsModifiableNode
(
*
aPointToInsert
.
GetContainer
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EditorBase
:
:
InsertTextWithTransaction
(
aDocument
aStringToInsert
aPointToInsert
aPointAfterInsertedString
)
;
}
void
HTMLEditor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
DoContentInserted
(
aFirstNewContent
eAppended
)
;
}
void
HTMLEditor
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
DoContentInserted
(
aChild
eInserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
Element
*
root
=
GetRoot
(
)
;
if
(
root
&
&
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
GetBindingParent
(
)
!
=
aChild
-
>
GetBindingParent
(
)
)
)
{
return
false
;
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
GetBindingParent
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIContent
*
aChild
InsertedOrAppended
aInsertedOrAppended
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
ShouldReplaceRootElement
(
)
)
{
UpdateRootElement
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
mTopLevelEditSubAction
&
&
container
-
>
IsEditable
(
)
)
{
if
(
IsMozEditorBogusNode
(
aChild
)
)
{
return
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
rules
-
>
DocumentModified
(
)
;
if
(
mInlineSpellChecker
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aChild
)
;
nsIContent
*
endContent
=
aChild
;
if
(
aInsertedOrAppended
=
=
eAppended
)
{
endContent
=
container
-
>
GetLastChild
(
)
;
}
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
}
}
}
void
HTMLEditor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
if
(
SameCOMIdentity
(
aChild
mRootElement
)
)
{
mRootElement
=
nullptr
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
)
;
}
else
if
(
!
mTopLevelEditSubAction
&
&
aChild
-
>
GetParentNode
(
)
-
>
IsEditable
(
)
)
{
if
(
aChild
&
&
IsMozEditorBogusNode
(
aChild
)
)
{
return
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
rules
-
>
DocumentModified
(
)
;
}
}
NS_IMETHODIMP
HTMLEditor
:
:
DebugUnitTests
(
int32_t
*
outNumTests
int32_t
*
outNumTestsFailed
)
{
#
ifdef
DEBUG
NS_ENSURE_TRUE
(
outNumTests
&
&
outNumTestsFailed
NS_ERROR_NULL_POINTER
)
;
TextEditorTest
*
tester
=
new
TextEditorTest
(
)
;
NS_ENSURE_TRUE
(
tester
NS_ERROR_OUT_OF_MEMORY
)
;
tester
-
>
Run
(
this
outNumTests
outNumTestsFailed
)
;
delete
tester
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
void
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
EditSubAction
aEditSubAction
nsIEditor
:
:
EDirection
aDirection
)
{
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
EditorBase
:
:
OnStartToHandleTopLevelEditSubAction
(
aEditSubAction
aDirection
)
;
if
(
!
rules
)
{
return
;
}
MOZ_ASSERT
(
mTopLevelEditSubAction
=
=
aEditSubAction
)
;
MOZ_ASSERT
(
mDirection
=
=
aDirection
)
;
DebugOnly
<
nsresult
>
rv
=
rules
-
>
BeforeEdit
(
mTopLevelEditSubAction
mDirection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditRules
:
:
BeforeEdit
(
)
failed
to
handle
something
"
)
;
}
void
HTMLEditor
:
:
OnEndHandlingTopLevelEditSubAction
(
)
{
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
DebugOnly
<
nsresult
>
rv
=
rules
?
rules
-
>
AfterEdit
(
mTopLevelEditSubAction
mDirection
)
:
NS_OK
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditRules
:
:
AfterEdit
(
)
failed
to
handle
something
"
)
;
EditorBase
:
:
OnEndHandlingTopLevelEditSubAction
(
)
;
MOZ_ASSERT
(
!
mTopLevelEditSubAction
)
;
MOZ_ASSERT
(
mDirection
=
=
eNone
)
;
}
bool
HTMLEditor
:
:
TagCanContainTag
(
nsAtom
&
aParentTag
nsAtom
&
aChildTag
)
const
{
int32_t
childTagEnum
;
if
(
&
aChildTag
=
=
nsGkAtoms
:
:
textTagName
)
{
childTagEnum
=
eHTMLTag_text
;
}
else
{
childTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aChildTag
)
;
}
int32_t
parentTagEnum
=
nsHTMLTags
:
:
AtomTagToId
(
&
aParentTag
)
;
return
HTMLEditUtils
:
:
CanContain
(
parentTagEnum
childTagEnum
)
;
}
bool
HTMLEditor
:
:
IsContainer
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
int32_t
tagEnum
;
if
(
aNode
-
>
IsText
(
)
)
{
tagEnum
=
eHTMLTag_text
;
}
else
{
tagEnum
=
nsHTMLTags
:
:
StringTagToId
(
aNode
-
>
NodeName
(
)
)
;
}
return
HTMLEditUtils
:
:
IsContainer
(
tagEnum
)
;
}
nsresult
HTMLEditor
:
:
SelectEntireDocument
(
Selection
*
aSelection
)
{
if
(
!
aSelection
|
|
!
mRules
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
if
(
rules
-
>
DocumentIsEmpty
(
)
)
{
Element
*
rootElement
=
GetRoot
(
)
;
return
aSelection
-
>
Collapse
(
rootElement
0
)
;
}
return
EditorBase
:
:
SelectEntireDocument
(
aSelection
)
;
}
nsresult
HTMLEditor
:
:
SelectAllInternal
(
)
{
CommitComposition
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
anchorNode
=
selection
-
>
GetAnchorNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
anchorNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
anchorContent
=
anchorNode
-
>
AsContent
(
)
;
nsIContent
*
rootContent
;
if
(
anchorContent
-
>
HasIndependentSelection
(
)
)
{
selection
-
>
SetAncestorLimiter
(
nullptr
)
;
rootContent
=
mRootElement
;
}
else
{
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
rootContent
=
anchorContent
-
>
GetSelectionRootContent
(
ps
)
;
}
if
(
NS_WARN_IF
(
!
rootContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
Maybe
<
mozilla
:
:
dom
:
:
Selection
:
:
AutoUserInitiated
>
userSelection
;
if
(
!
rootContent
-
>
IsEditable
(
)
)
{
userSelection
.
emplace
(
selection
)
;
}
ErrorResult
errorResult
;
selection
-
>
SelectAllChildren
(
*
rootContent
errorResult
)
;
NS_WARNING_ASSERTION
(
!
errorResult
.
Failed
(
)
"
SelectAllChildren
(
)
failed
"
)
;
return
errorResult
.
StealNSResult
(
)
;
}
bool
HTMLEditor
:
:
IsTextPropertySetByContent
(
nsINode
*
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
nsAString
*
outValue
)
{
MOZ_ASSERT
(
aNode
&
&
aProperty
)
;
while
(
aNode
)
{
if
(
aNode
-
>
IsElement
(
)
)
{
Element
*
element
=
aNode
-
>
AsElement
(
)
;
if
(
aProperty
=
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
if
(
!
aAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
value
)
;
if
(
outValue
)
{
*
outValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
break
;
}
}
}
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
false
;
}
bool
HTMLEditor
:
:
SetCaretInTableCell
(
Element
*
aElement
)
{
if
(
!
aElement
|
|
!
aElement
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
aElement
)
|
|
!
IsDescendantOfEditorRoot
(
aElement
)
)
{
return
false
;
}
nsIContent
*
node
=
aElement
;
while
(
node
-
>
HasChildren
(
)
)
{
node
=
node
-
>
GetFirstChild
(
)
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
false
)
;
return
NS_SUCCEEDED
(
selection
-
>
Collapse
(
node
0
)
)
;
}
Element
*
HTMLEditor
:
:
GetEnclosingTable
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
for
(
nsCOMPtr
<
Element
>
block
=
GetBlockNodeParent
(
aNode
)
;
block
;
block
=
GetBlockNodeParent
(
block
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
block
)
)
{
return
block
;
}
}
return
nullptr
;
}
nsresult
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
nsRange
*
aInRange
)
{
NS_ENSURE_TRUE
(
aInRange
NS_ERROR_NULL_POINTER
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
nsTArray
<
nsCOMPtr
<
nsINode
>
>
textNodes
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
iter
-
>
Init
(
aInRange
)
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
node
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
IsEditable
(
node
-
>
AsContent
(
)
)
)
{
textNodes
.
AppendElement
(
node
)
;
}
iter
-
>
Next
(
)
;
}
while
(
textNodes
.
Length
(
)
>
1
)
{
nsINode
*
leftTextNode
=
textNodes
[
0
]
;
nsINode
*
rightTextNode
=
textNodes
[
1
]
;
NS_ASSERTION
(
leftTextNode
&
&
rightTextNode
"
left
or
rightTextNode
null
in
CollapseAdjacentTextNodes
"
)
;
nsCOMPtr
<
nsINode
>
prevSibOfRightNode
=
rightTextNode
-
>
GetPreviousSibling
(
)
;
if
(
prevSibOfRightNode
&
&
prevSibOfRightNode
=
=
leftTextNode
)
{
nsresult
rv
=
JoinNodesWithTransaction
(
*
leftTextNode
*
rightTextNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
textNodes
.
RemoveElementAt
(
0
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
Selection
*
aSelection
)
{
dom
:
:
Element
*
rootElement
=
GetRoot
(
)
;
NS_ENSURE_TRUE
(
rootElement
NS_ERROR_NULL_POINTER
)
;
return
aSelection
-
>
Collapse
(
rootElement
0
)
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
Element
&
aElement
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
child
=
GetFirstEditableChild
(
aElement
)
;
if
(
child
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsBlockNode
(
child
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBrElementWithTransaction
(
*
selection
EditorRawDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
sibling
=
GetNextHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
)
{
child
=
GetLastEditableChild
(
aElement
)
;
MOZ_ASSERT
(
child
"
aNode
has
first
editable
child
but
not
last
?
"
)
;
if
(
!
IsBlockNode
(
child
)
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
EditorRawDOMPoint
endOfNode
;
endOfNode
.
SetToEndOf
(
&
aElement
)
;
RefPtr
<
Element
>
brElement
=
InsertBrElementWithTransaction
(
*
selection
endOfNode
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
}
else
{
nsCOMPtr
<
nsIContent
>
sibling
=
GetPriorHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
sibling
=
GetNextHTMLSibling
(
&
aElement
)
;
if
(
sibling
&
&
!
IsBlockNode
(
sibling
)
&
&
!
sibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBrElementWithTransaction
(
*
selection
EditorRawDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLSibling
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetPreviousSibling
(
)
;
while
(
node
&
&
!
IsEditable
(
node
)
)
{
node
=
node
-
>
GetPreviousSibling
(
)
;
}
return
node
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLSibling
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
node
=
aNode
-
>
GetNextSibling
(
)
;
while
(
node
&
&
!
IsEditable
(
node
)
)
{
node
=
node
-
>
GetNextSibling
(
)
;
}
return
node
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aNode
)
:
GetPreviousElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aPoint
)
:
GetPreviousElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aNode
)
:
GetPreviousEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aPoint
)
:
GetPreviousEditableNode
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aNode
)
:
GetNextElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aPoint
)
:
GetNextElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aNode
)
:
GetNextEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
{
if
(
!
GetActiveEditingHost
(
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aPoint
)
:
GetNextEditableNode
(
aPoint
)
;
}
bool
HTMLEditor
:
:
IsFirstEditableChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetFirstEditableChild
(
*
parent
)
=
=
aNode
)
;
}
bool
HTMLEditor
:
:
IsLastEditableChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
return
(
GetLastEditableChild
(
*
parent
)
=
=
aNode
)
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableChild
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetNextSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableChild
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
&
&
!
IsEditable
(
child
)
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetLeftmostChild
(
&
aNode
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetNextEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableLeaf
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
child
=
GetRightmostChild
(
&
aNode
false
)
;
while
(
child
&
&
(
!
IsEditable
(
child
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetPreviousEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
bool
HTMLEditor
:
:
IsInVisibleTextFrames
(
Text
&
aText
)
{
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
false
;
}
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
bool
isVisible
=
false
;
nsresult
rv
=
selectionController
-
>
CheckVisibilityContent
(
&
aText
0
aText
.
TextDataLength
(
)
&
isVisible
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
isVisible
;
}
bool
HTMLEditor
:
:
IsVisibleTextNode
(
Text
&
aText
)
{
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
if
(
!
aText
.
TextIsOnlyWhitespace
(
)
)
{
return
true
;
}
WSRunObject
wsRunObj
(
this
&
aText
0
)
;
nsCOMPtr
<
nsINode
>
nextVisibleNode
;
WSType
visibleNodeType
;
wsRunObj
.
NextVisibleNode
(
EditorRawDOMPoint
(
&
aText
0
)
address_of
(
nextVisibleNode
)
nullptr
&
visibleNodeType
)
;
return
(
visibleNodeType
=
=
WSType
:
:
normalWS
|
|
visibleNodeType
=
=
WSType
:
:
text
)
&
&
&
aText
=
=
nextVisibleNode
;
}
nsresult
HTMLEditor
:
:
IsEmptyNode
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
)
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
NS_ERROR_NULL_POINTER
)
;
*
outIsEmptyNode
=
true
;
bool
seenBR
=
false
;
return
IsEmptyNodeImpl
(
aNode
outIsEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
&
seenBR
)
;
}
nsresult
HTMLEditor
:
:
IsEmptyNodeImpl
(
nsINode
*
aNode
bool
*
outIsEmptyNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
bool
*
aSeenBR
)
{
NS_ENSURE_TRUE
(
aNode
&
&
outIsEmptyNode
&
&
aSeenBR
NS_ERROR_NULL_POINTER
)
;
if
(
Text
*
text
=
aNode
-
>
GetAsText
(
)
)
{
*
outIsEmptyNode
=
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
return
NS_OK
;
}
if
(
!
IsContainer
(
aNode
)
|
|
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aNode
)
|
|
HTMLEditUtils
:
:
IsFormWidget
(
aNode
)
|
|
(
aListOrCellNotEmpty
&
&
(
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
)
)
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
bool
isListItemOrCell
=
HTMLEditUtils
:
:
IsListItem
(
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
aNode
)
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorBase
:
:
IsEditable
(
child
)
)
{
if
(
Text
*
text
=
child
-
>
GetAsText
(
)
)
{
*
outIsEmptyNode
=
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
if
(
!
*
outIsEmptyNode
)
{
return
NS_OK
;
}
}
else
{
if
(
child
=
=
aNode
)
{
break
;
}
if
(
aSingleBRDoesntCount
&
&
!
*
aSeenBR
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
*
aSeenBR
=
true
;
}
else
{
if
(
child
-
>
IsElement
(
)
)
{
if
(
isListItemOrCell
)
{
if
(
HTMLEditUtils
:
:
IsList
(
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
else
if
(
HTMLEditUtils
:
:
IsFormWidget
(
child
)
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
bool
isEmptyNode
=
true
;
nsresult
rv
=
IsEmptyNodeImpl
(
child
&
isEmptyNode
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
aSeenBR
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isEmptyNode
)
{
*
outIsEmptyNode
=
false
;
return
NS_OK
;
}
}
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
IsCSSEnabled
(
)
|
|
!
mCSSEditUtils
)
{
if
(
mCSSEditUtils
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
}
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
}
int32_t
count
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
&
aValue
aSuppressTransaction
)
;
if
(
count
)
{
nsAutoString
existingValue
;
if
(
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
existingValue
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
nsAutoString
existingValue
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
)
;
existingValue
.
Append
(
'
'
)
;
existingValue
.
Append
(
aValue
)
;
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
existingValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
existingValue
)
;
}
return
aSuppressTransaction
?
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
:
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
}
nsresult
HTMLEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
return
NS_OK
;
}
return
aSuppressTransaction
?
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
:
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetIsCSSEnabled
(
bool
aIsCSSPrefChecked
)
{
if
(
!
mCSSEditUtils
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mCSSEditUtils
-
>
SetCSSEnabled
(
aIsCSSPrefChecked
)
;
uint32_t
flags
=
mFlags
;
if
(
aIsCSSPrefChecked
)
{
flags
&
=
~
eEditorNoCSSMask
;
}
else
{
flags
|
=
eEditorNoCSSMask
;
}
return
SetFlags
(
flags
)
;
}
nsresult
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
NS_ENSURE_TRUE
(
mRules
NS_ERROR_NOT_INITIALIZED
)
;
CommitComposition
(
)
;
RefPtr
<
TextEditRules
>
rules
(
mRules
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_STATE
(
selection
)
;
bool
isCollapsed
=
selection
-
>
IsCollapsed
(
)
;
AutoPlaceholderBatch
batchIt
(
this
)
;
AutoTopLevelEditSubActionNotifier
maybeTopLevelEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
bool
cancel
handled
;
EditSubActionInfo
subActionInfo
(
EditSubAction
:
:
eSetTextProperty
)
;
nsresult
rv
=
rules
-
>
WillDoAction
(
selection
subActionInfo
&
cancel
&
handled
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
cancel
&
&
!
handled
)
{
for
(
uint32_t
i
=
0
;
i
<
selection
-
>
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Element
>
cachedBlockParent
;
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
if
(
startNode
=
=
endNode
&
&
IsTextNode
(
startNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
else
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
isCollapsed
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
startNode
-
>
AsElement
(
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
else
if
(
startNode
=
=
endNode
&
&
(
endOffset
-
startOffset
=
=
1
|
|
(
!
startOffset
&
&
!
endOffset
)
)
)
{
nsCOMPtr
<
nsIContent
>
selectedNode
=
range
-
>
GetChildAtStartOffset
(
)
;
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
*
selectedNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
else
{
OwningNonNull
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
nsTArray
<
OwningNonNull
<
nsINode
>
>
arrayOfNodes
;
nsCOMPtr
<
nsINode
>
node
;
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
node
=
iter
-
>
GetCurrentNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
IsEditable
(
node
)
)
{
arrayOfNodes
.
AppendElement
(
*
node
)
;
}
}
}
if
(
IsTextNode
(
startNode
)
&
&
IsEditable
(
startNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
startNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
for
(
auto
&
node
:
arrayOfNodes
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlock
(
node
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
arrayOfNodes
.
Clear
(
)
;
if
(
IsTextNode
(
endNode
)
&
&
IsEditable
(
endNode
)
)
{
nsCOMPtr
<
Element
>
blockParent
=
GetBlockNodeParent
(
endNode
)
;
if
(
blockParent
&
&
cachedBlockParent
!
=
blockParent
)
{
cachedBlockParent
=
blockParent
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockParent
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
}
}
}
}
}
if
(
!
cancel
)
{
rv
=
rules
-
>
DidDoAction
(
selection
subActionInfo
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBackgroundColor
(
const
nsAString
&
aColor
)
{
if
(
IsCSSEnabled
(
)
)
{
return
SetCSSBackgroundColorWithTransaction
(
aColor
)
;
}
return
SetHTMLBackgroundColorWithTransaction
(
aColor
)
;
}
nsresult
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
Element
&
aPreviousBlock
Element
&
aNewBlock
RefPtr
<
Element
>
*
aNewBrElement
)
{
if
(
NS_WARN_IF
(
!
aNewBrElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aNewBrElement
=
nullptr
;
RefPtr
<
Element
>
previousBlock
(
&
aPreviousBlock
)
;
RefPtr
<
Element
>
newBlock
(
&
aNewBlock
)
;
for
(
nsCOMPtr
<
nsINode
>
child
=
newBlock
-
>
GetFirstChild
(
)
;
child
;
child
=
newBlock
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsIContent
*
deepestEditableContent
=
nullptr
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
previousBlock
.
get
(
)
;
child
;
child
=
GetLastEditableChild
(
*
child
)
)
{
deepestEditableContent
=
child
;
}
while
(
deepestEditableContent
&
&
TextEditUtils
:
:
IsBreak
(
deepestEditableContent
)
)
{
deepestEditableContent
=
GetPreviousEditableHTMLNode
(
*
deepestEditableContent
)
;
}
Element
*
deepestVisibleEditableElement
=
nullptr
;
if
(
deepestEditableContent
)
{
deepestVisibleEditableElement
=
deepestEditableContent
-
>
IsElement
(
)
?
deepestEditableContent
-
>
AsElement
(
)
:
deepestEditableContent
-
>
GetParentElement
(
)
;
}
RefPtr
<
Element
>
lastClonedElement
firstClonsedElement
;
for
(
RefPtr
<
Element
>
elementInPreviousBlock
=
deepestVisibleEditableElement
;
elementInPreviousBlock
&
&
elementInPreviousBlock
!
=
previousBlock
;
elementInPreviousBlock
=
elementInPreviousBlock
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsInlineStyle
(
elementInPreviousBlock
)
&
&
!
elementInPreviousBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
continue
;
}
nsAtom
*
tagName
=
elementInPreviousBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
!
firstClonsedElement
)
{
EditorRawDOMPoint
atStartOfNewBlock
(
newBlock
0
)
;
firstClonsedElement
=
lastClonedElement
=
CreateNodeWithTransaction
(
*
tagName
atStartOfNewBlock
)
;
if
(
NS_WARN_IF
(
!
firstClonsedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
continue
;
}
lastClonedElement
=
InsertContainerWithTransaction
(
*
lastClonedElement
*
tagName
)
;
if
(
NS_WARN_IF
(
!
lastClonedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
}
if
(
!
firstClonsedElement
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
brElement
=
InsertBrElementWithTransaction
(
*
selection
EditorRawDOMPoint
(
firstClonsedElement
0
)
)
;
if
(
NS_WARN_IF
(
!
brElement
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aNewBrElement
=
brElement
.
forget
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
{
aX
=
0
;
aY
=
0
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_OK
)
;
nsIFrame
*
container
=
ps
-
>
GetAbsoluteContainingBlock
(
frame
)
;
NS_ENSURE_TRUE
(
container
NS_OK
)
;
nsPoint
off
=
frame
-
>
GetOffsetTo
(
container
)
;
aX
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
x
)
;
aY
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
y
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetSelectionContainerElement
(
Selection
&
aSelection
)
const
{
nsINode
*
focusNode
=
nullptr
;
if
(
aSelection
.
IsCollapsed
(
)
)
{
focusNode
=
aSelection
.
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
else
{
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
If
0
Selection
:
:
IsCollapsed
(
)
should
return
true
"
)
;
if
(
rangeCount
=
=
1
)
{
nsRange
*
range
=
aSelection
.
GetRangeAt
(
0
)
;
const
RangeBoundary
&
startRef
=
range
-
>
StartRef
(
)
;
const
RangeBoundary
&
endRef
=
range
-
>
EndRef
(
)
;
if
(
startRef
.
Container
(
)
-
>
IsElement
(
)
&
&
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
&
&
startRef
.
GetChildAtOffset
(
)
&
&
startRef
.
GetChildAtOffset
(
)
-
>
GetNextSibling
(
)
=
=
endRef
.
GetChildAtOffset
(
)
)
{
focusNode
=
startRef
.
GetChildAtOffset
(
)
;
MOZ_ASSERT
(
focusNode
"
Start
container
must
not
be
nullptr
"
)
;
}
else
{
focusNode
=
range
-
>
GetCommonAncestor
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
!
focusNode
)
{
focusNode
=
startContainer
;
}
else
if
(
focusNode
!
=
startContainer
)
{
focusNode
=
startContainer
-
>
GetParentNode
(
)
;
break
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
}
if
(
focusNode
-
>
GetAsText
(
)
)
{
focusNode
=
focusNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
return
focusNode
-
>
AsElement
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IsAnonymousElement
(
Element
*
aElement
bool
*
aReturn
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_NULL_POINTER
)
;
*
aReturn
=
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
bool
aCreatesNewParagraph
)
{
mCRInParagraphCreatesParagraph
=
aCreatesNewParagraph
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
{
return
mCRInParagraphCreatesParagraph
;
}
nsresult
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
bool
*
aCreatesNewParagraph
)
{
*
aCreatesNewParagraph
=
mCRInParagraphCreatesParagraph
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetFocusedContent
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
nullptr
)
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
fm
-
>
GetFocusedElement
(
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
!
focusedContent
)
{
if
(
inDesignMode
&
&
OurWindowHasFocus
(
)
)
{
return
document
-
>
GetRootElement
(
)
;
}
return
nullptr
;
}
if
(
inDesignMode
)
{
return
OurWindowHasFocus
(
)
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedContent
document
)
?
focusedContent
.
get
(
)
:
nullptr
;
}
if
(
!
focusedContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
focusedContent
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
OurWindowHasFocus
(
)
?
focusedContent
.
get
(
)
:
nullptr
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetFocusedContentForIME
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
?
nullptr
:
focusedContent
.
forget
(
)
;
}
bool
HTMLEditor
:
:
IsActiveInDOMWindow
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
inDesignMode
)
{
return
true
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
if
(
!
content
)
{
return
false
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
true
;
}
Element
*
HTMLEditor
:
:
GetActiveEditingHost
(
)
const
{
nsIDocument
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
document
-
>
GetBodyElement
(
)
;
}
Selection
*
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
nullptr
;
}
nsINode
*
focusNode
=
selection
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
|
|
NS_WARN_IF
(
!
focusNode
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
focusNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
EventTarget
*
HTMLEditor
:
:
GetDOMEventTarget
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
has
not
been
initialized
yet
"
)
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
target
=
GetDocument
(
)
;
return
target
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
{
if
(
!
mRootElement
)
{
return
true
;
}
return
mRootElement
!
=
GetBodyElement
(
)
;
}
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
UpdateRootElement
(
)
;
if
(
!
mRootElement
)
{
return
;
}
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
if
(
node
)
{
InitializeSelection
(
node
)
;
}
SyncRealTimeSpell
(
)
;
}
Element
*
HTMLEditor
:
:
GetBodyElement
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
GetBody
(
)
;
}
already_AddRefed
<
nsINode
>
HTMLEditor
:
:
GetFocusedNode
(
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ASSERTION
(
fm
"
Focus
manager
is
null
"
)
;
RefPtr
<
Element
>
focusedElement
=
fm
-
>
GetFocusedElement
(
)
;
if
(
focusedElement
)
{
return
focusedElement
.
forget
(
)
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
return
document
.
forget
(
)
;
}
bool
HTMLEditor
:
:
OurWindowHasFocus
(
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ENSURE_TRUE
(
fm
false
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
return
ourWindow
=
=
focusedWindow
;
}
bool
HTMLEditor
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
!
EditorBase
:
:
IsAcceptableInputEvent
(
aGUIEvent
)
)
{
return
false
;
}
if
(
mComposition
&
&
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
true
;
}
RefPtr
<
EventTarget
>
target
=
aGUIEvent
-
>
GetOriginalDOMEventTarget
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
target
)
;
if
(
content
)
{
target
=
content
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
NS_ENSURE_TRUE
(
target
false
)
;
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
nsCOMPtr
<
nsIDocument
>
targetDocument
=
do_QueryInterface
(
target
)
;
if
(
targetDocument
)
{
return
targetDocument
=
=
document
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
return
document
=
=
targetContent
-
>
GetUncomposedDoc
(
)
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
NS_ENSURE_TRUE
(
targetContent
false
)
;
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
if
(
targetContent
=
=
document
-
>
GetRootElement
(
)
&
&
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
editingHost
=
=
document
-
>
GetBodyElement
(
)
)
{
targetContent
=
editingHost
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
targetContent
editingHost
)
)
{
return
false
;
}
if
(
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
!
targetContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
targetContent
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
nsresult
HTMLEditor
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
|
|
IsDisabled
(
)
)
{
aState
-
>
mEnabled
=
IMEState
:
:
DISABLED
;
}
else
{
aState
-
>
mEnabled
=
IMEState
:
:
ENABLED
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
GetInputEventTargetContent
(
)
{
nsCOMPtr
<
nsIContent
>
target
=
GetActiveEditingHost
(
)
;
return
target
.
forget
(
)
;
}
Element
*
HTMLEditor
:
:
GetEditorRoot
(
)
const
{
return
GetActiveEditingHost
(
)
;
}
nsHTMLDocument
*
HTMLEditor
:
:
GetHTMLDocument
(
)
const
{
nsIDocument
*
doc
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
if
(
!
doc
-
>
IsHTMLOrXHTML
(
)
)
{
return
nullptr
;
}
return
doc
-
>
AsHTMLDocument
(
)
;
}
}
