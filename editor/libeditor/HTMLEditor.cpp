#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
JoinNodeTransaction
.
h
"
#
include
"
SplitNodeTransaction
.
h
"
#
include
"
TypeInState
.
h
"
#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextServicesDocument
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIEditActionListener
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
using
ChildBlockBoundary
=
HTMLEditUtils
:
:
ChildBlockBoundary
;
const
char16_t
kNBSP
=
160
;
static
bool
IsLinkTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
href
;
}
static
bool
IsNamedAnchorTag
(
const
nsAtom
&
aTagName
)
{
return
&
aTagName
=
=
nsGkAtoms
:
:
anchor
;
}
HTMLEditor
:
:
HTMLEditor
(
)
:
mCRInParagraphCreatesParagraph
(
false
)
mCSSAware
(
false
)
mSelectedCellIndex
(
0
)
mIsObjectResizingEnabled
(
StaticPrefs
:
:
editor_resizing_enabled_by_default
(
)
)
mIsResizing
(
false
)
mPreserveRatio
(
false
)
mResizedObjectIsAnImage
(
false
)
mIsAbsolutelyPositioningEnabled
(
StaticPrefs
:
:
editor_positioning_enabled_by_default
(
)
)
mResizedObjectIsAbsolutelyPositioned
(
false
)
mGrabberClicked
(
false
)
mIsMoving
(
false
)
mSnapToGridEnabled
(
false
)
mIsInlineTableEditingEnabled
(
StaticPrefs
:
:
editor_inline_table_editing_enabled_by_default
(
)
)
mOriginalX
(
0
)
mOriginalY
(
0
)
mResizedObjectX
(
0
)
mResizedObjectY
(
0
)
mResizedObjectWidth
(
0
)
mResizedObjectHeight
(
0
)
mResizedObjectMarginLeft
(
0
)
mResizedObjectMarginTop
(
0
)
mResizedObjectBorderLeft
(
0
)
mResizedObjectBorderTop
(
0
)
mXIncrementFactor
(
0
)
mYIncrementFactor
(
0
)
mWidthIncrementFactor
(
0
)
mHeightIncrementFactor
(
0
)
mInfoXIncrement
(
20
)
mInfoYIncrement
(
20
)
mPositionedObjectX
(
0
)
mPositionedObjectY
(
0
)
mPositionedObjectWidth
(
0
)
mPositionedObjectHeight
(
0
)
mPositionedObjectMarginLeft
(
0
)
mPositionedObjectMarginTop
(
0
)
mPositionedObjectBorderLeft
(
0
)
mPositionedObjectBorderTop
(
0
)
mGridSize
(
0
)
mDefaultParagraphSeparator
(
Preferences
:
:
GetBool
(
"
editor
.
use_div_for_default_newlines
"
true
)
?
ParagraphSeparator
:
:
div
:
ParagraphSeparator
:
:
br
)
{
mIsHTMLEditorClass
=
true
;
}
HTMLEditor
:
:
~
HTMLEditor
(
)
{
mTypeInState
=
nullptr
;
if
(
mDisabledLinkHandling
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
doc
-
>
SetLinkHandlingEnabled
(
mOldLinkHandlingEnabled
)
;
}
}
RemoveEventListeners
(
)
;
HideAnonymousEditingUIs
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChangedRangeForTopLevelEditSubAction
)
tmp
-
>
HideAnonymousEditingUIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEditor
TextEditor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTypeInState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChangedRangeForTopLevelEditSubAction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomLeftHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBottomRightHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mActivatedHandle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizingInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResizedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAbsolutelyPositionedObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGrabber
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositioningShadow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInlineEditedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveColumnButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddColumnAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowBeforeButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRemoveRowButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAddRowAfterButton
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
HTMLEditor
EditorBase
)
NS_IMPL_RELEASE_INHERITED
(
HTMLEditor
EditorBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLObjectResizer
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLAbsPosEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIHTMLInlineTableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsITableEditor
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorMailSupport
)
NS_INTERFACE_MAP_END_INHERITING
(
TextEditor
)
nsresult
HTMLEditor
:
:
Init
(
Document
&
aDoc
Element
*
aRoot
nsISelectionController
*
aSelCon
uint32_t
aFlags
const
nsAString
&
aInitialValue
)
{
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
called
again
without
calling
PreDestroy
(
)
?
"
)
;
MOZ_ASSERT
(
aInitialValue
.
IsEmpty
(
)
"
Non
-
empty
initial
values
not
supported
"
)
;
nsresult
rv
=
EditorBase
:
:
Init
(
aDoc
aRoot
nullptr
aFlags
aInitialValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
aDoc
.
AddMutationObserverUnlessExists
(
this
)
;
if
(
!
mRootElement
)
{
UpdateRootElement
(
)
;
}
if
(
IsMailEditor
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetAbsolutePositioningEnabled
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetAbsolutePositioningEnabled
(
false
)
failed
but
ignored
"
)
;
rvIgnored
=
SetSnapToGridEnabled
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetSnapToGridEnabled
(
false
)
failed
but
ignored
"
)
;
}
mCSSEditUtils
=
MakeUnique
<
CSSEditUtils
>
(
this
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsPlaintextEditor
(
)
&
&
!
IsInteractionAllowed
(
)
)
{
mDisabledLinkHandling
=
true
;
mOldLinkHandlingEnabled
=
document
-
>
LinkHandlingEnabled
(
)
;
document
-
>
SetLinkHandlingEnabled
(
false
)
;
}
mTypeInState
=
new
TypeInState
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
InitEditorContentAndSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InitEditorContentAndSelection
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
ClearUndoRedo
(
)
;
EnableUndoRedo
(
)
;
MOZ_ASSERT
(
!
mInitSucceeded
"
HTMLEditor
:
:
Init
(
)
shouldn
'
t
be
nested
"
)
;
mInitSucceeded
=
true
;
return
NS_OK
;
}
void
HTMLEditor
:
:
PreDestroy
(
bool
aDestroyingFrames
)
{
if
(
mDidPreDestroy
)
{
return
;
}
mInitSucceeded
=
false
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
document
)
{
document
-
>
RemoveMutationObserver
(
this
)
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsDestroying
(
)
)
{
RefPtr
<
HTMLEditor
>
self
=
this
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
HTMLEditor
:
:
PreDestroy
"
[
self
]
(
)
{
self
-
>
HideAnonymousEditingUIs
(
)
;
}
)
)
;
}
else
{
HideAnonymousEditingUIs
(
)
;
}
EditorBase
:
:
PreDestroy
(
aDestroyingFrames
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NotifySelectionChanged
(
Document
*
aDocument
Selection
*
aSelection
int16_t
aReason
)
{
if
(
NS_WARN_IF
(
!
aDocument
)
|
|
NS_WARN_IF
(
!
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mTypeInState
)
{
RefPtr
<
TypeInState
>
typeInState
=
mTypeInState
;
typeInState
-
>
OnSelectionChange
(
*
aSelection
aReason
)
;
if
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
&
&
aSelection
)
{
DebugOnly
<
nsresult
>
rv
=
RefreshEditingUI
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RefreshEditingUI
(
)
failed
but
ignored
"
)
;
}
}
if
(
mComposerCommandsUpdater
)
{
RefPtr
<
ComposerCommandsUpdater
>
updater
=
mComposerCommandsUpdater
;
updater
-
>
OnSelectionChange
(
)
;
}
nsresult
rv
=
EditorBase
:
:
NotifySelectionChanged
(
aDocument
aSelection
aReason
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
NotifySelectionChanged
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
UpdateRootElement
(
)
{
mRootElement
=
GetBodyElement
(
)
;
if
(
!
mRootElement
)
{
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
mRootElement
=
doc
-
>
GetDocumentElement
(
)
;
}
}
}
Element
*
HTMLEditor
:
:
FindSelectionRoot
(
nsINode
*
aNode
)
const
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aNode
-
>
IsDocument
(
)
|
|
aNode
-
>
IsContent
(
)
"
aNode
must
be
content
or
document
node
"
)
;
Document
*
document
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsInUncomposedDoc
(
)
&
&
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
aNode
-
>
IsContent
(
)
)
)
{
return
document
-
>
GetRootElement
(
)
;
}
if
(
IsReadonly
(
)
)
{
return
GetRoot
(
)
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_READWRITE
)
)
{
return
content
-
>
AsElement
(
)
;
}
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
void
HTMLEditor
:
:
CreateEventListeners
(
)
{
if
(
!
mEventListener
)
{
mEventListener
=
new
HTMLEditorEventListener
(
)
;
}
}
nsresult
HTMLEditor
:
:
InstallEventListeners
(
)
{
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
HTMLEditorEventListener
*
listener
=
reinterpret_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
;
nsresult
rv
=
listener
-
>
Connect
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditorEventListener
:
:
Connect
(
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
RemoveEventListeners
(
)
{
if
(
!
IsInitialized
(
)
)
{
return
;
}
TextEditor
:
:
RemoveEventListeners
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetFlags
(
uint32_t
aFlags
)
{
nsresult
rv
=
TextEditor
:
:
SetFlags
(
aFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
SetFlags
(
)
failed
"
)
;
return
rv
;
}
mCSSAware
=
!
NoCSS
(
)
&
&
!
IsMailEditor
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
BeginningOfDocument
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
InitializeSelectionAncestorLimit
(
nsIContent
&
aAncestorLimit
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
bool
tryToCollapseSelectionAtFirstEditableNode
=
true
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
=
=
1
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
range
-
>
GetStartContainer
(
)
=
=
editingHost
&
&
!
range
-
>
StartOffset
(
)
)
{
tryToCollapseSelectionAtFirstEditableNode
=
false
;
}
}
EditorBase
:
:
InitializeSelectionAncestorLimit
(
aAncestorLimit
)
;
if
(
tryToCollapseSelectionAtFirstEditableNode
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
true
)
failed
"
"
but
ignored
"
)
;
}
}
nsresult
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
bool
aIgnoreIfSelectionInEditingHost
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_OK
;
}
if
(
aIgnoreIfSelectionInEditingHost
&
&
SelectionRefPtr
(
)
-
>
RangeCount
(
)
=
=
1
)
{
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
!
range
-
>
Collapsed
(
)
|
|
range
-
>
GetStartContainer
(
)
!
=
editingHost
.
get
(
)
|
|
range
-
>
StartOffset
(
)
)
{
return
NS_OK
;
}
}
EditorRawDOMPoint
pointToPutCaret
(
editingHost
0
)
;
for
(
;
;
)
{
WSScanResult
forwardScanFromPointToPutCaretResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
pointToPutCaret
)
;
if
(
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
&
&
!
forwardScanFromPointToPutCaretResult
.
IsContentEditable
(
)
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
forwardScanFromPointToPutCaretResult
.
ReachedSpecialContent
(
)
&
&
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
&
&
HTMLEditUtils
:
:
CanNodeContain
(
*
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
*
nsGkAtoms
:
:
textTagName
)
)
{
pointToPutCaret
=
forwardScanFromPointToPutCaretResult
.
RawPointAfterContent
(
)
;
continue
;
}
if
(
forwardScanFromPointToPutCaretResult
.
InNormalWhiteSpacesOrText
(
)
)
{
pointToPutCaret
=
forwardScanFromPointToPutCaretResult
.
RawPoint
(
)
;
break
;
}
if
(
forwardScanFromPointToPutCaretResult
.
ReachedBRElement
(
)
|
|
forwardScanFromPointToPutCaretResult
.
ReachedSpecialContent
(
)
)
{
pointToPutCaret
=
forwardScanFromPointToPutCaretResult
.
RawPointAtContent
(
)
;
break
;
}
if
(
!
forwardScanFromPointToPutCaretResult
.
ReachedOtherBlockElement
(
)
)
{
pointToPutCaret
.
Set
(
editingHost
0
)
;
break
;
}
if
(
!
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
)
)
{
pointToPutCaret
=
forwardScanFromPointToPutCaretResult
.
RawPointAtContent
(
)
;
break
;
}
if
(
IsEmptyNode
(
*
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
)
)
{
pointToPutCaret
=
forwardScanFromPointToPutCaretResult
.
RawPointAfterContent
(
)
;
}
else
{
pointToPutCaret
.
Set
(
forwardScanFromPointToPutCaretResult
.
GetContent
(
)
0
)
;
}
}
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
HandleKeyPressEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
if
(
IsReadonly
(
)
)
{
nsresult
rv
=
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
!
aKeyboardEvent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyPress
"
HandleKeyPressEvent
gets
non
-
keypress
event
"
)
;
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_META
:
case
NS_VK_WIN
:
case
NS_VK_SHIFT
:
case
NS_VK_CONTROL
:
case
NS_VK_ALT
:
{
nsresult
rv
=
EditorBase
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
case
NS_VK_BACK
:
case
NS_VK_DELETE
:
{
nsresult
rv
=
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
case
NS_VK_TAB
:
{
if
(
IsPlaintextEditor
(
)
)
{
nsresult
rv
=
TextEditor
:
:
HandleKeyPressEvent
(
aKeyboardEvent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
HandleKeyPressEvent
(
)
failed
"
)
;
return
rv
;
}
if
(
IsTabbable
(
)
)
{
return
NS_OK
;
}
if
(
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
IsAlt
(
)
|
|
aKeyboardEvent
-
>
IsMeta
(
)
|
|
aKeyboardEvent
-
>
IsOS
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
|
|
NS_WARN_IF
(
!
selection
-
>
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
startContainer
=
selection
-
>
GetRangeAt
(
0
)
-
>
GetStartContainer
(
)
;
MOZ_ASSERT
(
startContainer
)
;
if
(
!
startContainer
-
>
IsContent
(
)
)
{
break
;
}
Element
*
blockParent
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
startContainer
-
>
AsContent
(
)
)
;
if
(
!
blockParent
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsTableElement
(
blockParent
)
)
{
EditActionResult
result
=
HandleTabKeyPressInTable
(
aKeyboardEvent
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
HandleTabKeyPressInTable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
if
(
!
result
.
Handled
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ScrollSelectionFocusIntoView
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ScrollSelectionFocusIntoView
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
HTMLEditUtils
:
:
IsListItem
(
blockParent
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
!
aKeyboardEvent
-
>
IsShift
(
)
)
{
nsresult
rv
=
IndentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
IndentAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
OutdentAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OutdentAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsresult
rv
=
OnInputText
(
NS_LITERAL_STRING
(
"
\
t
"
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
OnInputText
(
\
\
t
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
case
NS_VK_RETURN
:
if
(
!
aKeyboardEvent
-
>
IsInputtingLineBreak
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
nsresult
rv
=
InsertLineBreakAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertLineBreakAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
InsertParagraphSeparatorAsAction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
aKeyboardEvent
-
>
IsInputtingText
(
)
)
{
return
NS_OK
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
nsAutoString
str
(
aKeyboardEvent
-
>
mCharCode
)
;
nsresult
rv
=
OnInputText
(
str
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
OnInputText
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NodeIsBlock
(
nsINode
*
aNode
bool
*
aIsBlock
)
{
*
aIsBlock
=
aNode
&
&
aNode
-
>
IsContent
(
)
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
aNode
-
>
AsContent
(
)
)
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
IsEmptyInlineNode
(
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
HTMLEditUtils
:
:
IsInlineElement
(
aContent
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
aContent
)
)
{
return
false
;
}
return
IsEmptyNode
(
aContent
)
;
}
void
HTMLEditor
:
:
IsNextCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
(
uint32_t
)
aOffset
<
aContent
-
>
Length
(
)
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
+
1
;
}
}
}
void
HTMLEditor
:
:
IsPrevCharInNodeWhitespace
(
nsIContent
*
aContent
int32_t
aOffset
bool
*
outIsSpace
bool
*
outIsNBSP
nsIContent
*
*
outNode
int32_t
*
outOffset
)
{
MOZ_ASSERT
(
aContent
&
&
outIsSpace
&
&
outIsNBSP
)
;
MOZ_ASSERT
(
(
outNode
&
&
outOffset
)
|
|
(
!
outNode
&
&
!
outOffset
)
)
;
*
outIsSpace
=
false
;
*
outIsNBSP
=
false
;
if
(
outNode
&
&
outOffset
)
{
*
outNode
=
nullptr
;
*
outOffset
=
-
1
;
}
if
(
aContent
-
>
IsText
(
)
&
&
aOffset
>
0
)
{
char16_t
ch
=
aContent
-
>
GetText
(
)
-
>
CharAt
(
aOffset
-
1
)
;
*
outIsSpace
=
nsCRT
:
:
IsAsciiSpace
(
ch
)
;
*
outIsNBSP
=
(
ch
=
=
kNBSP
)
;
if
(
outNode
&
&
outOffset
)
{
NS_IF_ADDREF
(
*
outNode
=
aContent
)
;
*
outOffset
=
aOffset
-
1
;
}
}
}
bool
HTMLEditor
:
:
IsVisibleBRElement
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
!
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
false
;
}
nsIContent
*
nextContent
=
GetNextHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
nextContent
&
&
nextContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
if
(
!
nextContent
)
{
return
false
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextContent
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
priorNode
=
GetPreviousHTMLElementOrTextInBlock
(
*
aNode
)
;
if
(
priorNode
&
&
priorNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
EditorRawDOMPoint
afterBRElement
(
EditorRawDOMPoint
:
:
After
(
*
aNode
)
)
;
if
(
NS_WARN_IF
(
!
afterBRElement
.
IsSet
(
)
)
)
{
return
false
;
}
return
!
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
afterBRElement
)
.
ReachedBlockBoundary
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
UpdateBaseURL
(
)
{
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsContentList
>
baseElementList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
base
"
)
)
;
if
(
!
baseElementList
|
|
!
baseElementList
-
>
Item
(
0
)
)
{
document
-
>
SetBaseURI
(
document
-
>
GetDocumentURI
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLineBreak
(
)
{
MOZ_ASSERT
(
!
IsSingleLineEditor
(
)
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
InsertLineBreakAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLineBreak
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
*
nsGkAtoms
:
:
TypingTxnName
)
;
rv
=
InsertBRElementAtSelectionWithTransaction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertBRElementAtSelectionWithTransaction
(
)
failed
"
)
;
return
NS_FAILED
(
rv
)
?
rv
:
NS_OK
;
}
nsresult
HTMLEditor
:
:
InsertParagraphSeparatorAsAction
(
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertParagraphSeparator
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
InsertParagraphSeparatorAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
InsertParagraphSeparatorAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
EditActionResult
HTMLEditor
:
:
HandleTabKeyPressInTable
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
AutoEditActionDataSetter
dummyEditActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
dummyEditActionData
.
CanHandle
(
)
)
)
{
return
EditActionIgnored
(
)
;
}
Element
*
cellElement
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cellElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
"
"
returned
nullptr
"
)
;
return
EditActionIgnored
(
)
;
}
RefPtr
<
Element
>
table
=
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
cellElement
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetClosestAncestorTableElement
(
)
failed
"
)
;
return
EditActionIgnored
(
)
;
}
PostContentIterator
postOrderIter
;
nsresult
rv
=
postOrderIter
.
Init
(
table
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
Init
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
rv
=
postOrderIter
.
PositionAt
(
cellElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
PostContentIterator
:
:
PositionAt
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
do
{
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
postOrderIter
.
Prev
(
)
;
}
else
{
postOrderIter
.
Next
(
)
;
}
nsCOMPtr
<
nsINode
>
node
=
postOrderIter
.
GetCurrentNode
(
)
;
if
(
node
&
&
HTMLEditUtils
:
:
IsTableCell
(
node
)
&
&
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
node
-
>
AsElement
(
)
)
=
=
table
)
{
aKeyboardEvent
-
>
PreventDefault
(
)
;
CollapseSelectionToDeepestNonTableFirstChild
(
node
)
;
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
}
while
(
!
postOrderIter
.
IsDone
(
)
)
;
if
(
aKeyboardEvent
-
>
IsShift
(
)
)
{
return
EditActionIgnored
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableRowElement
)
;
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
rv
=
InsertTableRowsWithTransaction
(
1
InsertPosition
:
:
eAfterSelectedCell
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditActionHandled
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTableRowsWithTransaction
(
1
"
"
InsertPosition
:
:
eAfterSelectedCell
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
aKeyboardEvent
-
>
PreventDefault
(
)
;
RefPtr
<
Element
>
tblElement
cell
;
int32_t
row
;
rv
=
GetCellContext
(
getter_AddRefs
(
tblElement
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
row
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditActionHandled
(
rv
)
;
}
if
(
!
tblElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
table
element
"
)
;
return
EditActionHandled
(
NS_ERROR_FAILURE
)
;
}
cell
=
GetTableCellElementAt
(
*
tblElement
row
0
)
;
if
(
cell
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionToStartOf
(
*
cell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
return
EditActionHandled
(
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
)
;
}
nsresult
HTMLEditor
:
:
InsertBRElementAtSelectionWithTransaction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
IsSelectionRangeContainerNotContent
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertText
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eStrip
)
failed
"
)
;
return
rv
;
}
}
EditorDOMPoint
atStartOfSelection
(
EditorBase
:
:
GetStartPoint
(
*
SelectionRefPtr
(
)
)
)
;
if
(
NS_WARN_IF
(
!
atStartOfSelection
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
newBRElement
=
InsertBRElementWithTransaction
(
atStartOfSelection
eNext
)
;
NS_WARNING_ASSERTION
(
newBRElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
newBRElement
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
HTMLEditor
:
:
CollapseSelectionToDeepestNonTableFirstChild
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
for
(
nsIContent
*
child
=
node
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetFirstChild
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTable
(
child
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
child
)
)
{
break
;
}
node
=
child
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionToStartOf
(
*
node
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
but
ignored
"
)
;
}
nsresult
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
const
nsAString
&
aSourceToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eReplaceHeadWithHTMLSource
nsIEditor
:
:
eNone
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
CommitComposition
(
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsContentList
>
headElementList
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
head
"
)
)
;
if
(
NS_WARN_IF
(
!
headElementList
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
primaryHeadElement
=
headElementList
-
>
Item
(
0
)
-
>
AsElement
(
)
;
if
(
NS_WARN_IF
(
!
primaryHeadElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
inputString
(
aSourceToInsert
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
inputString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
RefPtr
<
const
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
inputString
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
documentFragment
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
didn
'
t
create
DocumentFragment
"
)
;
return
NS_ERROR_FAILURE
;
}
while
(
nsCOMPtr
<
nsIContent
>
child
=
primaryHeadElement
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
int32_t
offsetOfNewNode
=
0
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
documentFragment
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
InsertNodeWithTransaction
(
*
child
EditorDOMPoint
(
primaryHeadElement
offsetOfNewNode
+
+
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RebuildDocumentFromSource
(
const
nsAString
&
aSourceString
)
{
CommitComposition
(
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetHTML
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsReadingIterator
<
char16_t
>
beginbody
;
nsReadingIterator
<
char16_t
>
endbody
;
aSourceString
.
BeginReading
(
beginbody
)
;
aSourceString
.
EndReading
(
endbody
)
;
bool
foundbody
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
body
"
)
beginbody
endbody
)
;
nsReadingIterator
<
char16_t
>
beginhead
;
nsReadingIterator
<
char16_t
>
endhead
;
aSourceString
.
BeginReading
(
beginhead
)
;
aSourceString
.
EndReading
(
endhead
)
;
bool
foundhead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
head
"
)
beginhead
endhead
)
;
if
(
foundbody
&
&
beginhead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundhead
=
false
;
}
nsReadingIterator
<
char16_t
>
beginclosehead
;
nsReadingIterator
<
char16_t
>
endclosehead
;
aSourceString
.
BeginReading
(
beginclosehead
)
;
aSourceString
.
EndReading
(
endclosehead
)
;
bool
foundclosehead
=
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
<
/
head
>
"
)
beginclosehead
endclosehead
)
;
if
(
foundhead
&
&
beginhead
.
get
(
)
>
beginclosehead
.
get
(
)
)
{
foundclosehead
=
false
;
}
if
(
foundbody
&
&
beginclosehead
.
get
(
)
>
beginbody
.
get
(
)
)
{
foundclosehead
=
false
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
nsReadingIterator
<
char16_t
>
endtotal
;
aSourceString
.
EndReading
(
endtotal
)
;
if
(
foundhead
)
{
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginclosehead
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
beginbody
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
Substring
(
beginhead
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
else
{
nsReadingIterator
<
char16_t
>
begintotal
;
aSourceString
.
BeginReading
(
begintotal
)
;
NS_NAMED_LITERAL_STRING
(
head
"
<
head
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginclosehead
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
if
(
foundbody
)
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
+
Substring
(
begintotal
beginbody
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
ReplaceHeadContentsWithSourceWithTransaction
(
head
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceHeadContentsWithSourceWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
rv
=
SelectAll
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
SelectAll
(
)
failed
"
)
;
return
rv
;
}
if
(
!
foundbody
)
{
NS_NAMED_LITERAL_STRING
(
body
"
<
body
>
"
)
;
if
(
foundclosehead
)
{
nsresult
rv
=
LoadHTML
(
body
+
Substring
(
endclosehead
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
foundhead
)
{
nsresult
rv
=
LoadHTML
(
body
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
else
{
nsresult
rv
=
LoadHTML
(
body
+
aSourceString
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
}
RefPtr
<
Element
>
divElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
div
)
;
if
(
!
divElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
div
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
*
divElement
)
;
nsresult
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
rv
=
LoadHTML
(
Substring
(
beginbody
endtotal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
LoadHTML
(
)
failed
"
)
;
return
rv
;
}
nsReadingIterator
<
char16_t
>
beginclosebody
=
beginbody
;
nsReadingIterator
<
char16_t
>
endclosebody
;
aSourceString
.
EndReading
(
endclosebody
)
;
if
(
!
FindInReadable
(
NS_LITERAL_STRING
(
"
>
"
)
beginclosebody
endclosebody
)
)
{
NS_WARNING
(
"
'
>
'
was
not
found
"
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
bodyTag
;
bodyTag
.
AssignLiteral
(
"
<
div
"
)
;
bodyTag
.
Append
(
Substring
(
endbody
endclosebody
)
)
;
RefPtr
<
const
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
DocumentFragment
>
documentFragment
=
range
-
>
CreateContextualFragment
(
bodyTag
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
!
documentFragment
)
{
NS_WARNING
(
"
nsRange
:
:
CreateContextualFragment
(
)
didn
'
t
create
DocumentFagement
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
firstChild
=
documentFragment
-
>
GetFirstChild
(
)
;
if
(
!
firstChild
|
|
!
firstChild
-
>
IsElement
(
)
)
{
NS_WARNING
(
"
First
child
of
DocumentFragment
was
not
an
Element
node
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
rootElement
MOZ_KnownLive
(
*
firstChild
-
>
AsElement
(
)
)
)
;
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
failed
"
)
;
return
rv
;
}
EditorRawDOMPoint
HTMLEditor
:
:
GetBetterInsertionPointFor
(
nsIContent
&
aContentToInsert
const
EditorRawDOMPoint
&
aPointToInsert
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
aPointToInsert
;
}
EditorRawDOMPoint
pointToInsert
(
aPointToInsert
.
GetNonAnonymousSubtreePoint
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorRawDOMPoint
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aContentToInsert
)
)
{
return
pointToInsert
;
}
WSRunScanner
wsScannerForPointToInsert
(
this
pointToInsert
)
;
WSScanResult
forwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
!
forwardScanFromPointToInsertResult
.
GetContent
(
)
|
|
!
forwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
)
{
return
pointToInsert
;
}
WSScanResult
backwardScanFromPointToInsertResult
=
wsScannerForPointToInsert
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
pointToInsert
)
;
if
(
!
backwardScanFromPointToInsertResult
.
GetContent
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedBRElement
(
)
|
|
backwardScanFromPointToInsertResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
pointToInsert
;
}
return
forwardScanFromPointToInsertResult
.
RawPointAfterContent
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertElementAtSelection
(
Element
*
aElement
bool
aDeleteSelection
)
{
nsresult
rv
=
InsertElementAtSelectionAsAction
(
aElement
aDeleteSelection
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertElementAtSelectionAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertElementAtSelectionAsAction
(
Element
*
aElement
bool
aDeleteSelection
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
*
aElement
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CommitComposition
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CommitComposition
(
)
failed
but
ignored
"
)
;
if
(
IsReadonly
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
UndefineCaretBidiLevel
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
if
(
aDeleteSelection
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
aElement
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNone
eNoStrip
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
failed
"
)
;
return
rv
;
}
}
else
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
aElement
)
)
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
CollapseToStart
(
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseToStart
(
)
failed
but
ignored
"
)
;
}
else
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
CollapseToEnd
(
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
CollapseToEnd
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
EditorDOMPoint
pointToInsert
=
GetBetterInsertionPointFor
(
*
aElement
atAnchor
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetBetterInsertionPointFor
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
insertedPoint
=
InsertNodeIntoProperAncestorWithTransaction
(
*
aElement
pointToInsert
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
)
;
if
(
!
insertedPoint
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
SplitAtEdges
:
:
"
"
eAllowToCreateEmptyContainer
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
SetCaretInTableCell
(
aElement
)
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
nsresult
rv
=
CollapseSelectionAfter
(
*
aElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CollapseSelectionAfter
(
)
failed
"
)
;
return
rv
;
}
}
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
aElement
)
&
&
IsLastEditableChild
(
aElement
)
)
{
DebugOnly
<
bool
>
advanced
=
insertedPoint
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
from
inserted
point
"
)
;
RefPtr
<
Element
>
newBRElement
=
InsertBRElementWithTransaction
(
insertedPoint
ePrevious
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
!
newBRElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
ePrevious
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
EditorDOMPoint
HTMLEditor
:
:
InsertNodeIntoProperAncestorWithTransaction
(
nsIContent
&
aNode
const
EditorDOMPoint
&
aPointToInsert
SplitAtEdges
aSplitAtEdges
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
while
(
!
HTMLEditUtils
:
:
CanNodeContain
(
*
pointToInsert
.
GetContainer
(
)
aNode
)
)
{
if
(
pointToInsert
.
IsContainerHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
HTMLEditUtils
:
:
IsTableElement
(
pointToInsert
.
GetContainer
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
pointToInsert
.
Set
(
pointToInsert
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
pointToInsert
.
IsInContentNode
(
)
|
|
!
EditorUtils
:
:
IsEditableContent
(
*
pointToInsert
.
ContainerAsContent
(
)
EditorType
:
:
HTML
)
)
{
pointToInsert
=
aPointToInsert
;
break
;
}
}
if
(
pointToInsert
!
=
aPointToInsert
)
{
MOZ_ASSERT
(
pointToInsert
.
GetChild
(
)
)
;
SplitNodeResult
splitNodeResult
=
SplitNodeDeepWithTransaction
(
MOZ_KnownLive
(
*
pointToInsert
.
GetChild
(
)
)
aPointToInsert
aSplitAtEdges
)
;
if
(
splitNodeResult
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
)
failed
"
)
;
return
EditorDOMPoint
(
)
;
}
pointToInsert
=
splitNodeResult
.
SplitPoint
(
)
;
MOZ_ASSERT
(
pointToInsert
.
IsSet
(
)
)
;
}
{
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
aNode
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
EditorDOMPoint
(
)
;
}
}
return
pointToInsert
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
SelectContentInternal
(
MOZ_KnownLive
(
*
aElement
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SelectContentInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SelectContentInternal
(
nsIContent
&
aContentToSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsDescendantOfEditorRoot
(
&
aContentToSelect
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionStart
(
&
aContentToSelect
)
;
if
(
NS_WARN_IF
(
!
newSelectionStart
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
newSelectionEnd
(
EditorRawDOMPoint
:
:
After
(
aContentToSelect
)
)
;
MOZ_ASSERT
(
newSelectionEnd
.
IsSet
(
)
)
;
ErrorResult
error
;
MOZ_KnownLive
(
SelectionRefPtr
(
)
)
-
>
SetStartAndEndInLimiter
(
newSelectionStart
newSelectionEnd
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SetStartAndEndInLimiter
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
HTMLEditor
:
:
SetCaretAfterElement
(
Element
*
aElement
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
CollapseSelectionAfter
(
*
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionAfter
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
CollapseSelectionAfter
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
IsDescendantOfEditorRoot
(
&
aElement
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aElement
.
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorRawDOMPoint
afterElement
(
EditorRawDOMPoint
:
:
After
(
aElement
)
)
;
if
(
NS_WARN_IF
(
!
afterElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionTo
(
afterElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetParagraphFormatAsAction
(
const
nsAString
&
aParagraphFormat
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertBlockElement
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsAutoString
lowerCaseTagName
(
aParagraphFormat
)
;
ToLowerCase
(
lowerCaseTagName
)
;
RefPtr
<
nsAtom
>
tagName
=
NS_Atomize
(
lowerCaseTagName
)
;
MOZ_ASSERT
(
tagName
)
;
if
(
tagName
=
=
nsGkAtoms
:
:
dd
|
|
tagName
=
=
nsGkAtoms
:
:
dt
)
{
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
*
tagName
EmptyString
(
)
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
"
"
SelectAllOfCurrentList
:
:
No
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
rv
=
FormatBlockContainerAsSubAction
(
*
tagName
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
FormatBlockContainerAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetParagraphState
(
bool
*
aMixed
nsAString
&
aFirstParagraphState
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ParagraphStateAtSelection
paragraphState
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ParagraphStateAtSelection
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
paragraphState
.
IsMixed
(
)
;
if
(
NS_WARN_IF
(
!
paragraphState
.
GetFirstParagraphStateAtSelection
(
)
)
)
{
aFirstParagraphState
.
AssignASCII
(
"
x
"
)
;
}
else
{
paragraphState
.
GetFirstParagraphStateAtSelection
(
)
-
>
ToString
(
aFirstParagraphState
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
GetCSSBackgroundColorState
(
aMixed
aOutColor
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rv
=
GetHTMLBackgroundColorState
(
aMixed
aOutColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetHighlightColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
if
(
!
IsCSSEnabled
(
)
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
GetCSSBackgroundColorState
(
aMixed
aOutColor
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GetCSSBackgroundColorState
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
GetCSSBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
bool
aBlockLevel
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
RefPtr
<
const
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
firstRange
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
startContainer
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
startContainer
)
|
|
NS_WARN_IF
(
!
startContainer
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
contentToExamine
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
|
|
startContainer
-
>
IsText
(
)
)
{
if
(
NS_WARN_IF
(
!
startContainer
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
contentToExamine
=
startContainer
-
>
AsContent
(
)
;
}
else
{
contentToExamine
=
firstRange
-
>
GetChildAtStartOffset
(
)
;
}
if
(
NS_WARN_IF
(
!
contentToExamine
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aBlockLevel
)
{
Element
*
blockParent
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
contentToExamine
)
;
if
(
NS_WARN_IF
(
!
blockParent
)
)
{
return
NS_OK
;
}
for
(
RefPtr
<
Element
>
element
=
blockParent
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
nsCOMPtr
<
nsINode
>
parentNode
=
element
-
>
GetParentNode
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
element
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
parentNode
!
=
element
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
"
"
backgroundColor
)
failed
but
ignored
"
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
if
(
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
CSSEditUtils
:
:
GetDefaultBackgroundColor
(
aOutColor
)
;
}
}
else
{
if
(
contentToExamine
-
>
IsText
(
)
)
{
contentToExamine
=
contentToExamine
-
>
GetParent
(
)
;
}
if
(
!
contentToExamine
)
{
return
NS_OK
;
}
for
(
RefPtr
<
Element
>
element
=
contentToExamine
-
>
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
element
)
)
{
aOutColor
.
AssignLiteral
(
"
transparent
"
)
;
break
;
}
nsCOMPtr
<
nsINode
>
parentNode
=
element
-
>
GetParentNode
(
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
element
*
nsGkAtoms
:
:
backgroundColor
aOutColor
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
parentNode
!
=
element
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
"
"
backgroundColor
)
failed
but
ignored
"
)
;
if
(
!
aOutColor
.
EqualsLiteral
(
"
transparent
"
)
)
{
break
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetHTMLBackgroundColorState
(
bool
*
aMixed
nsAString
&
aOutColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aMixed
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMixed
=
false
;
aOutColor
.
Truncate
(
)
;
ErrorResult
error
;
RefPtr
<
Element
>
cellOrRowOrTableElement
=
GetSelectedOrParentTableElement
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
returned
nullptr
"
)
;
return
error
.
StealNSResult
(
)
;
}
for
(
RefPtr
<
Element
>
element
=
std
:
:
move
(
cellOrRowOrTableElement
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
if
(
!
aOutColor
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
NS_OK
;
}
}
Element
*
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
rootElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
bgcolor
aOutColor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListState
(
bool
*
aMixed
bool
*
aOL
bool
*
aUL
bool
*
aDL
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aOL
)
|
|
NS_WARN_IF
(
!
aUL
)
|
|
NS_WARN_IF
(
!
aDL
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListElementSelectionState
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ListElementSelectionState
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeListElementSelected
(
)
;
*
aOL
=
state
.
IsOLElementSelected
(
)
;
*
aUL
=
state
.
IsULElementSelected
(
)
;
*
aDL
=
state
.
IsDLElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetListItemState
(
bool
*
aMixed
bool
*
aLI
bool
*
aDT
bool
*
aDD
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aLI
)
|
|
NS_WARN_IF
(
!
aDT
)
|
|
NS_WARN_IF
(
!
aDD
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
ListItemElementSelectionState
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
ListItemElementSelectionState
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
state
.
IsNotOneTypeDefinitionListItemElementSelected
(
)
;
*
aLI
=
state
.
IsLIElementSelected
(
)
;
*
aDT
=
state
.
IsDTElementSelected
(
)
;
*
aDD
=
state
.
IsDDElementSelected
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetAlignment
(
bool
*
aMixed
nsIHTMLEditor
:
:
EAlignment
*
aAlign
)
{
if
(
NS_WARN_IF
(
!
aMixed
)
|
|
NS_WARN_IF
(
!
aAlign
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
AlignStateAtSelection
state
(
*
this
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
AlignStateAtSelection
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
*
aMixed
=
false
;
*
aAlign
=
state
.
AlignmentAtSelectionStart
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MakeOrChangeList
(
const
nsAString
&
aListType
bool
aEntireList
const
nsAString
&
aBulletType
)
{
RefPtr
<
nsAtom
>
listTagName
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listTagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
MakeOrChangeListAsAction
(
*
listTagName
aBulletType
aEntireList
?
SelectAllOfCurrentList
:
:
Yes
:
SelectAllOfCurrentList
:
:
No
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MakeOrChangeListAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
MakeOrChangeListAsAction
(
nsAtom
&
aListTagName
const
nsAString
&
aBulletType
SelectAllOfCurrentList
aSelectAllOfCurrentList
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForInsert
(
aListTagName
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
MakeOrChangeListAndListItemAsSubAction
(
aListTagName
aBulletType
aSelectAllOfCurrentList
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
MakeOrChangeListAndListItemAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RemoveList
(
const
nsAString
&
aListType
)
{
nsresult
rv
=
RemoveListAsAction
(
aListType
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveListAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveListAsAction
(
const
nsAString
&
aListType
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsAtom
>
listAtom
=
NS_Atomize
(
aListType
)
;
if
(
NS_WARN_IF
(
!
listAtom
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForRemoveList
(
*
listAtom
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
RemoveListAtSelectionAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
NS_FAILED
(
rv
)
"
HTMLEditor
:
:
RemoveListAtSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
FormatBlockContainerAsSubAction
(
nsAtom
&
aTagName
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
dd
&
&
&
aTagName
!
=
nsGkAtoms
:
:
dt
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eCreateOrRemoveBlock
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
if
(
IsSelectionRangeContainerNotContent
(
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
nsresult
rv
=
EnsureCaretNotAfterPaddingBRElement
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
EnsureCaretNotAfterPaddingBRElement
(
)
"
"
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsresult
rv
=
PrepareInlineStylesForCaret
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
PrepareInlineStylesForCaret
(
)
failed
but
ignored
"
)
;
}
}
rv
=
FormatBlockContainerWithTransaction
(
aTagName
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FormatBlockContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rv
=
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
MaybeInsertPaddingBRElementForEmptyLastLineAtSelection
(
)
"
"
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
IndentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eIndent
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
IndentAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
IndentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
OutdentAsAction
(
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eOutdent
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
OutdentAsSubAction
(
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
OutdentAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
nsresult
HTMLEditor
:
:
AlignAsAction
(
const
nsAString
&
aAlignType
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
HTMLEditUtils
:
:
GetEditActionForAlignment
(
aAlignType
)
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
EditActionResult
result
=
AlignAsSubAction
(
aAlignType
)
;
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
AlignAsSubAction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
result
.
Rv
(
)
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagName
(
const
nsStaticAtom
&
aTagName
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
return
GetInclusiveAncestorByTagNameInternal
(
aTagName
aContent
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
const
nsStaticAtom
&
aTagName
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
const
EditorRawDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
atAnchor
.
GetContainerAsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
nullptr
;
if
(
atAnchor
.
GetContainer
(
)
-
>
HasChildNodes
(
)
&
&
atAnchor
.
GetContainerAsContent
(
)
)
{
content
=
atAnchor
.
GetChild
(
)
;
}
if
(
!
content
)
{
content
=
atAnchor
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
return
nullptr
;
}
}
return
GetInclusiveAncestorByTagNameInternal
(
aTagName
*
content
)
;
}
Element
*
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
const
nsStaticAtom
&
aTagName
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
&
aTagName
!
=
nsGkAtoms
:
:
_empty
)
;
Element
*
currentElement
=
aContent
.
GetAsElementOrParentElement
(
)
;
if
(
NS_WARN_IF
(
!
currentElement
)
)
{
MOZ_ASSERT
(
!
aContent
.
GetParentNode
(
)
)
;
return
nullptr
;
}
bool
lookForLink
=
IsLinkTag
(
aTagName
)
;
bool
lookForNamedAnchor
=
IsNamedAnchorTag
(
aTagName
)
;
for
(
Element
*
element
:
currentElement
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
nullptr
;
}
if
(
lookForLink
)
{
if
(
HTMLEditUtils
:
:
IsLink
(
element
)
)
{
return
element
;
}
}
else
if
(
lookForNamedAnchor
)
{
if
(
HTMLEditUtils
:
:
IsNamedAnchor
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
list_
)
{
if
(
HTMLEditUtils
:
:
IsList
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
nsGkAtoms
:
:
td
)
{
if
(
HTMLEditUtils
:
:
IsTableCell
(
element
)
)
{
return
element
;
}
}
else
if
(
&
aTagName
=
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
return
element
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetElementOrParentByTagName
(
const
nsAString
&
aTagName
nsINode
*
aNode
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
tagName
=
=
nsGkAtoms
:
:
_empty
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aNode
)
{
AutoEditActionDataSetter
dummyEditAction
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
dummyEditAction
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
Element
>
parentElement
=
GetInclusiveAncestorByTagNameAtSelection
(
*
tagName
)
;
if
(
!
parentElement
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parentElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
if
(
!
aNode
-
>
IsContent
(
)
|
|
!
aNode
-
>
GetAsElementOrParentElement
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
Element
>
parentElement
=
GetInclusiveAncestorByTagName
(
*
tagName
*
aNode
-
>
AsContent
(
)
)
;
if
(
!
parentElement
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
parentElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedElement
(
const
nsAString
&
aTagName
nsISupports
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
ErrorResult
error
;
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
!
aTagName
.
IsEmpty
(
)
&
&
!
tagName
)
{
return
NS_OK
;
}
RefPtr
<
nsINode
>
selectedNode
=
GetSelectedElement
(
tagName
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
GetSelectedElement
(
)
failed
"
)
;
selectedNode
.
forget
(
aReturn
)
;
return
error
.
StealNSResult
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetSelectedElement
(
const
nsAtom
*
aTagName
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
SelectionRefPtr
(
)
-
>
RangeCount
(
)
!
=
1
)
{
return
nullptr
;
}
bool
isLinkTag
=
aTagName
&
&
IsLinkTag
(
*
aTagName
)
;
bool
isNamedAnchorTag
=
aTagName
&
&
IsNamedAnchorTag
(
*
aTagName
)
;
RefPtr
<
nsRange
>
firstRange
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
MOZ_ASSERT
(
firstRange
)
;
const
RangeBoundary
&
startRef
=
firstRange
-
>
StartRef
(
)
;
if
(
NS_WARN_IF
(
!
startRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
const
RangeBoundary
&
endRef
=
firstRange
-
>
EndRef
(
)
;
if
(
NS_WARN_IF
(
!
endRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
)
{
nsIContent
*
startContent
=
startRef
.
GetChildAtOffset
(
)
;
nsIContent
*
endContent
=
endRef
.
GetChildAtOffset
(
)
;
if
(
startContent
&
&
endContent
&
&
startContent
-
>
GetNextSibling
(
)
=
=
endContent
)
{
if
(
!
aTagName
)
{
if
(
!
startContent
-
>
IsElement
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
if
(
aTagName
=
=
startContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
|
|
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
startContent
)
)
|
|
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
startContent
)
)
)
{
MOZ_ASSERT
(
startContent
-
>
IsElement
(
)
)
;
return
do_AddRef
(
startContent
-
>
AsElement
(
)
)
;
}
}
}
if
(
isLinkTag
&
&
startRef
.
Container
(
)
-
>
IsContent
(
)
&
&
endRef
.
Container
(
)
-
>
IsContent
(
)
)
{
Element
*
parentLinkOfStart
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
startRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
parentLinkOfStart
)
{
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
Element
*
parentLinkOfEnd
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
href
*
endRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
parentLinkOfStart
=
=
parentLinkOfEnd
)
{
return
do_AddRef
(
parentLinkOfStart
)
;
}
}
}
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
return
nullptr
;
}
PostContentIterator
postOrderIter
;
postOrderIter
.
Init
(
firstRange
)
;
RefPtr
<
Element
>
lastElementInRange
;
for
(
nsINode
*
lastNodeInRange
=
nullptr
;
!
postOrderIter
.
IsDone
(
)
;
postOrderIter
.
Next
(
)
)
{
if
(
lastElementInRange
)
{
return
nullptr
;
}
nsINode
*
currentNode
=
postOrderIter
.
GetCurrentNode
(
)
;
MOZ_ASSERT
(
currentNode
)
;
if
(
lastNodeInRange
&
&
lastNodeInRange
-
>
GetParentNode
(
)
!
=
currentNode
&
&
lastNodeInRange
-
>
GetNextSibling
(
)
!
=
currentNode
)
{
return
nullptr
;
}
lastNodeInRange
=
currentNode
;
lastElementInRange
=
Element
:
:
FromNodeOrNull
(
lastNodeInRange
)
;
if
(
!
lastElementInRange
)
{
continue
;
}
if
(
nsIContent
*
nextSibling
=
lastElementInRange
-
>
GetNextSibling
(
)
)
{
if
(
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
nsIContent
*
firstEditableLeaf
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
nextSibling
ChildBlockBoundary
:
:
Ignore
)
;
if
(
firstEditableLeaf
&
&
firstEditableLeaf
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
nullptr
;
}
}
if
(
!
aTagName
)
{
continue
;
}
if
(
isLinkTag
&
&
HTMLEditUtils
:
:
IsLink
(
lastElementInRange
)
)
{
continue
;
}
if
(
isNamedAnchorTag
&
&
HTMLEditUtils
:
:
IsNamedAnchor
(
lastElementInRange
)
)
{
continue
;
}
if
(
aTagName
=
=
lastElementInRange
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
return
nullptr
;
}
return
lastElementInRange
.
forget
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAtom
&
aTagName
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
const
nsAtom
*
realTagName
=
IsLinkTag
(
aTagName
)
|
|
IsNamedAnchorTag
(
aTagName
)
?
nsGkAtoms
:
:
a
:
&
aTagName
;
RefPtr
<
Element
>
newElement
=
CreateHTMLContent
(
realTagName
)
;
if
(
!
newElement
)
{
return
nullptr
;
}
IgnoredErrorResult
ignoredError
;
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
_moz_dirty
"
)
EmptyString
(
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Element
:
:
SetAttribute
(
_moz_dirty
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
if
(
realTagName
=
=
nsGkAtoms
:
:
table
)
{
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
cellpadding
NS_LITERAL_STRING
(
"
2
"
)
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
cellpadding
2
)
failed
"
)
;
return
nullptr
;
}
ignoredError
.
SuppressException
(
)
;
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
cellspacing
NS_LITERAL_STRING
(
"
2
"
)
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
cellspacing
2
)
failed
"
)
;
return
nullptr
;
}
ignoredError
.
SuppressException
(
)
;
newElement
-
>
SetAttr
(
nsGkAtoms
:
:
border
NS_LITERAL_STRING
(
"
1
"
)
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
border
1
)
failed
"
)
;
return
nullptr
;
}
}
else
if
(
realTagName
=
=
nsGkAtoms
:
:
td
)
{
nsresult
rv
=
SetAttributeOrEquivalent
(
newElement
nsGkAtoms
:
:
valign
NS_LITERAL_STRING
(
"
top
"
)
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAttributeOrEquivalent
(
nsGkAtoms
:
:
valign
top
)
"
"
failed
"
)
;
return
nullptr
;
}
}
return
newElement
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
CreateElementWithDefaults
(
const
nsAString
&
aTagName
Element
*
*
aReturn
)
{
if
(
NS_WARN_IF
(
aTagName
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
aReturn
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
nullptr
;
nsStaticAtom
*
tagName
=
EditorUtils
:
:
GetTagNameAtom
(
aTagName
)
;
if
(
NS_WARN_IF
(
!
tagName
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
newElement
=
CreateElementWithDefaults
(
MOZ_KnownLive
(
*
tagName
)
)
;
if
(
!
newElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
newElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertLinkAroundSelection
(
Element
*
aAnchorElement
)
{
nsresult
rv
=
InsertLinkAroundSelectionAsAction
(
aAnchorElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertLinkAroundSelectionAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertLinkAroundSelectionAsAction
(
Element
*
aAnchorElement
nsIPrincipal
*
aPrincipal
)
{
if
(
NS_WARN_IF
(
!
aAnchorElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertLinkElement
aPrincipal
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
NS_WARNING
(
"
Selection
was
collapsed
"
)
;
return
NS_OK
;
}
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNodeOrNull
(
aAnchorElement
)
;
if
(
!
anchor
)
{
return
NS_OK
;
}
nsAutoString
rawHref
;
anchor
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
rawHref
)
;
editActionData
.
SetData
(
rawHref
)
;
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsAutoString
href
;
anchor
-
>
GetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
RefPtr
<
nsDOMAttributeMap
>
attributeMap
=
anchor
-
>
Attributes
(
)
;
if
(
NS_WARN_IF
(
!
attributeMap
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
count
=
attributeMap
-
>
Length
(
)
;
nsAutoString
value
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
Attr
>
attribute
=
attributeMap
-
>
Item
(
i
)
;
if
(
!
attribute
)
{
continue
;
}
value
.
Truncate
(
)
;
nsAtom
*
attributeName
=
attribute
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
attribute
-
>
GetValue
(
value
)
;
nsresult
rv
=
SetInlinePropertyInternal
(
*
nsGkAtoms
:
:
a
MOZ_KnownLive
(
attributeName
)
value
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetInlinePropertyInternal
(
nsGkAtoms
:
:
a
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
ErrorResult
error
;
bool
isCellSelected
=
false
;
RefPtr
<
Element
>
cellOrRowOrTableElement
=
GetSelectedOrParentTableElement
(
error
&
isCellSelected
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
bool
setColor
=
!
aColor
.
IsEmpty
(
)
;
RefPtr
<
Element
>
rootElementOfBackgroundColor
;
if
(
cellOrRowOrTableElement
)
{
rootElementOfBackgroundColor
=
std
:
:
move
(
cellOrRowOrTableElement
)
;
if
(
isCellSelected
|
|
rootElementOfBackgroundColor
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
)
)
{
IgnoredErrorResult
ignoredError
;
RefPtr
<
Element
>
cellElement
=
GetFirstSelectedTableCellElement
(
ignoredError
)
;
if
(
cellElement
)
{
if
(
setColor
)
{
while
(
cellElement
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
*
cellElement
*
nsGkAtoms
:
:
bgcolor
aColor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
"
"
bgcolor
)
failed
"
)
;
return
rv
;
}
cellElement
=
GetNextSelectedTableCellElement
(
ignoredError
)
;
}
return
NS_OK
;
}
while
(
cellElement
)
{
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
cellElement
*
nsGkAtoms
:
:
bgcolor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
"
"
failed
"
)
;
return
rv
;
}
cellElement
=
GetNextSelectedTableCellElement
(
ignoredError
)
;
}
return
NS_OK
;
}
}
}
else
{
rootElementOfBackgroundColor
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElementOfBackgroundColor
)
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
setColor
)
{
nsresult
rv
=
SetAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
rootElementOfBackgroundColor
*
nsGkAtoms
:
:
bgcolor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveEmptyInclusiveAncestorInlineElements
(
nsIContent
&
aContent
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
aContent
.
Length
(
)
)
;
Element
*
editingHost
=
aContent
.
GetEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
&
aContent
=
=
editingHost
|
|
HTMLEditUtils
:
:
IsBlockElement
(
aContent
)
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
|
|
!
aContent
.
GetParent
(
)
)
{
return
NS_OK
;
}
Element
*
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
aContent
editingHost
)
;
if
(
!
blockElement
|
|
IsEmptyNode
(
*
blockElement
)
)
{
return
NS_OK
;
}
OwningNonNull
<
nsIContent
>
content
=
aContent
;
for
(
nsIContent
*
parentContent
:
aContent
.
AncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
parentContent
)
|
|
parentContent
-
>
Length
(
)
!
=
1
|
|
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
parentContent
)
|
|
parentContent
=
=
editingHost
)
{
break
;
}
content
=
*
parentContent
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
content
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteNodeWithTransaction
(
nsIContent
&
aContent
)
{
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aContent
)
&
&
!
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
aContent
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteAllChildrenWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
while
(
nsCOMPtr
<
nsIContent
>
child
=
aElement
.
GetLastChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
MOZ_ASSERT
(
mPlaceholderBatch
)
;
WSRunScanner
wsScannerForPoint
(
this
aPoint
)
;
if
(
!
wsScannerForPoint
.
StartsFromCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
)
|
|
NS_WARN_IF
(
!
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
wsScannerForPoint
.
GetEditingHost
(
)
=
=
wsScannerForPoint
.
GetStartReasonContent
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
HTMLEditUtils
:
:
IsTableCellOrCaption
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
WSScanResult
forwardScanFromPointResult
=
wsScannerForPoint
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
if
(
forwardScanFromPointResult
.
ReachedBRElement
(
)
)
{
NS_ASSERTION
(
wsScannerForPoint
.
GetEndReasonContent
(
)
=
=
forwardScanFromPointResult
.
BRElementPtr
(
)
"
End
reason
is
not
the
reached
<
br
>
element
"
)
;
if
(
IsVisibleBRElement
(
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
wsScannerForPoint
.
GetEndReasonContent
(
)
-
>
GetNextSibling
(
)
)
{
if
(
!
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
EditorRawDOMPoint
:
:
After
(
*
wsScannerForPoint
.
GetEndReasonContent
(
)
)
)
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
}
}
else
if
(
!
forwardScanFromPointResult
.
ReachedCurrentBlockBoundary
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
EditorDOMPoint
nextPoint
(
wsScannerForPoint
.
GetStartReasonContent
(
)
-
>
GetParentNode
(
)
0
)
;
nsresult
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
wsScannerForPoint
.
GetStartReasonContent
(
)
)
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
nextPoint
.
GetContainer
(
)
=
=
wsScannerForPoint
.
GetEditingHost
(
)
)
{
return
NS_OK
;
}
if
(
MaybeHasMutationEventListeners
(
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
Element
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
|
|
NS_WARN_IF
(
editingHost
!
=
wsScannerForPoint
.
GetEditingHost
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsDescendantOf
(
*
nextPoint
.
GetContainer
(
)
*
editingHost
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
}
rv
=
DeleteParentBlocksWithTransactionIfEmpty
(
nextPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteParentBlocksWithTransactionIfEmpty
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteNode
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveNode
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteNodeWithTransaction
(
MOZ_KnownLive
(
*
aNode
-
>
AsContent
(
)
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteTextWithTransaction
(
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aLength
)
{
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
aTextNode
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteTextWithTransaction
(
aTextNode
aOffset
aLength
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
InsertTextWithTransaction
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPointToInsert
.
GetContainer
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
InsertTextWithTransaction
(
aDocument
aStringToInsert
aPointToInsert
aPointAfterInsertedString
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
HTMLEditor
:
:
PrepareToInsertBRElement
(
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
EditorDOMPoint
(
)
;
}
if
(
!
aPointToInsert
.
IsInTextNode
(
)
)
{
return
aPointToInsert
;
}
if
(
aPointToInsert
.
IsStartOfContainer
(
)
)
{
EditorDOMPoint
pointInContainer
(
aPointToInsert
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
pointInContainer
.
IsSet
(
)
"
Failed
to
climb
up
the
DOM
tree
from
text
node
"
)
;
return
pointInContainer
;
}
if
(
aPointToInsert
.
IsEndOfContainer
(
)
)
{
EditorDOMPoint
pointInContainer
(
aPointToInsert
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
pointInContainer
.
IsSet
(
)
)
)
{
return
pointInContainer
;
}
DebugOnly
<
bool
>
advanced
=
pointInContainer
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
text
node
"
)
;
return
pointInContainer
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
IgnoredErrorResult
ignoredError
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
aPointToInsert
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
if
(
ignoredError
.
Failed
(
)
)
{
return
EditorDOMPoint
(
)
;
}
Unused
<
<
newLeftNode
;
EditorDOMPoint
pointInContainer
(
aPointToInsert
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
pointInContainer
.
IsSet
(
)
"
Failed
to
split
the
text
node
"
)
;
return
pointInContainer
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
InsertBRElementWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
EDirection
aSelect
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToInsert
=
PrepareToInsertBRElement
(
aPointToInsert
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newBRElement
=
CreateNodeWithTransaction
(
*
nsGkAtoms
:
:
br
pointToInsert
)
;
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
nullptr
;
}
switch
(
aSelect
)
{
case
eNone
:
break
;
case
eNext
:
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
EditorRawDOMPoint
afterBRElement
(
EditorRawDOMPoint
:
:
After
(
*
newBRElement
)
)
;
NS_WARNING_ASSERTION
(
afterBRElement
.
IsSet
(
)
"
Setting
after
<
br
>
element
failed
but
ignored
"
)
;
if
(
afterBRElement
.
IsSet
(
)
)
{
ignoredError
.
SuppressException
(
)
;
CollapseSelectionTo
(
afterBRElement
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
nullptr
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
break
;
}
case
ePrevious
:
{
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
SetInterlinePosition
(
true
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
SetInterlinePosition
(
true
)
failed
but
ignored
"
)
;
EditorRawDOMPoint
atBRElement
(
newBRElement
)
;
NS_WARNING_ASSERTION
(
atBRElement
.
IsSet
(
)
"
Setting
at
<
br
>
element
failed
but
ignored
"
)
;
if
(
atBRElement
.
IsSet
(
)
)
{
ignoredError
.
SuppressException
(
)
;
CollapseSelectionTo
(
atBRElement
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
nullptr
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
break
;
}
default
:
NS_WARNING
(
"
aSelect
has
invalid
value
the
caller
need
to
set
selection
"
"
by
itself
"
)
;
break
;
}
return
newBRElement
.
forget
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
InsertContainerWithTransactionInternal
(
nsIContent
&
aContent
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
)
{
EditorDOMPoint
pointToInsertNewContainer
(
&
aContent
)
;
if
(
NS_WARN_IF
(
!
pointToInsertNewContainer
.
IsSet
(
)
)
)
{
return
nullptr
;
}
DebugOnly
<
bool
>
advanced
=
pointToInsertNewContainer
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
aContent
"
)
;
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
nullptr
;
}
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
nullptr
;
}
}
AutoInsertContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
)
;
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
{
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
rv
=
InsertNodeWithTransaction
(
aContent
EditorDOMPoint
(
newContainer
0
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
}
rv
=
InsertNodeWithTransaction
(
*
newContainer
pointToInsertNewContainer
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
return
newContainer
.
forget
(
)
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
ReplaceContainerWithTransactionInternal
(
Element
&
aOldContainer
nsAtom
&
aTagName
nsAtom
&
aAttribute
const
nsAString
&
aAttributeValue
bool
aCloneAllAttributes
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
atOldContainer
(
&
aOldContainer
)
;
if
(
NS_WARN_IF
(
!
atOldContainer
.
IsSet
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newContainer
=
CreateHTMLContent
(
&
aTagName
)
;
if
(
NS_WARN_IF
(
!
newContainer
)
)
{
return
nullptr
;
}
if
(
aCloneAllAttributes
)
{
MOZ_ASSERT
(
&
aAttribute
=
=
nsGkAtoms
:
:
_empty
)
;
CloneAttributesWithTransaction
(
*
newContainer
aOldContainer
)
;
}
else
if
(
&
aAttribute
!
=
nsGkAtoms
:
:
_empty
)
{
nsresult
rv
=
newContainer
-
>
SetAttr
(
kNameSpaceID_None
&
aAttribute
aAttributeValue
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
nullptr
;
}
}
AutoReplaceContainerSelNotify
selStateNotify
(
RangeUpdaterRef
(
)
aOldContainer
*
newContainer
)
;
{
AutoTransactionsConserveSelection
conserveSelection
(
*
this
)
;
while
(
aOldContainer
.
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aOldContainer
.
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
nullptr
;
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
rv
=
InsertNodeWithTransaction
(
*
child
EditorDOMPoint
(
newContainer
newContainer
-
>
Length
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
}
}
NS_WARNING_ASSERTION
(
atOldContainer
.
IsSetAndValid
(
)
"
The
old
container
might
be
moved
by
mutation
observer
"
)
;
nsresult
rv
=
InsertNodeWithTransaction
(
*
newContainer
atOldContainer
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aOldContainer
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
return
newContainer
.
forget
(
)
;
}
nsresult
HTMLEditor
:
:
RemoveContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
EditorDOMPoint
pointToInsertChildren
(
&
aElement
)
;
if
(
NS_WARN_IF
(
!
pointToInsertChildren
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoRemoveContainerSelNotify
selNotify
(
RangeUpdaterRef
(
)
pointToInsertChildren
)
;
while
(
aElement
.
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
aElement
.
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
child
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rv
=
InsertNodeWithTransaction
(
*
child
EditorDOMPoint
(
pointToInsertChildren
.
GetContainer
(
)
pointToInsertChildren
.
Offset
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
DoContentInserted
(
aFirstNewContent
eAppended
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
DoContentInserted
(
aChild
eInserted
)
;
}
bool
HTMLEditor
:
:
IsInObservedSubtree
(
nsIContent
*
aChild
)
{
if
(
!
aChild
)
{
return
false
;
}
if
(
Element
*
root
=
GetRoot
(
)
)
{
if
(
root
-
>
ChromeOnlyAccess
(
)
!
=
aChild
-
>
ChromeOnlyAccess
(
)
|
|
root
-
>
IsInNativeAnonymousSubtree
(
)
!
=
aChild
-
>
IsInNativeAnonymousSubtree
(
)
|
|
root
-
>
IsInShadowTree
(
)
!
=
aChild
-
>
IsInShadowTree
(
)
)
{
return
false
;
}
}
return
!
aChild
-
>
ChromeOnlyAccess
(
)
&
&
!
aChild
-
>
IsInShadowTree
(
)
&
&
!
aChild
-
>
IsInNativeAnonymousSubtree
(
)
;
}
void
HTMLEditor
:
:
DoContentInserted
(
nsIContent
*
aChild
InsertedOrAppended
aInsertedOrAppended
)
{
MOZ_ASSERT
(
aChild
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
ShouldReplaceRootElement
(
)
)
{
UpdateRootElement
(
)
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
container
-
>
IsEditable
(
)
)
{
if
(
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnDocumentModified
(
)
failed
but
ignored
"
)
;
if
(
mInlineSpellChecker
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aChild
)
;
nsIContent
*
endContent
=
aChild
;
if
(
aInsertedOrAppended
=
=
eAppended
)
{
endContent
=
container
-
>
GetLastChild
(
)
;
}
range
-
>
SelectNodesInContainer
(
container
aChild
endContent
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
mInlineSpellChecker
-
>
SpellCheckRange
(
range
)
;
NS_WARNING_ASSERTION
(
rvIgnored
=
=
NS_ERROR_NOT_INITIALIZED
|
|
NS_SUCCEEDED
(
rvIgnored
)
"
mozInlineSpellChecker
:
:
SpellCheckRange
(
)
failed
but
ignored
"
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HTMLEditor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
IsInObservedSubtree
(
aChild
)
)
{
return
;
}
RefPtr
<
HTMLEditor
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
if
(
SameCOMIdentity
(
aChild
mRootElement
)
)
{
mRootElement
=
nullptr
;
if
(
mPendingRootElementUpdatedRunner
)
{
return
;
}
mPendingRootElementUpdatedRunner
=
NewRunnableMethod
(
"
HTMLEditor
:
:
NotifyRootChanged
"
this
&
HTMLEditor
:
:
NotifyRootChanged
)
;
nsContentUtils
:
:
AddScriptRunner
(
do_AddRef
(
mPendingRootElementUpdatedRunner
)
)
;
return
;
}
if
(
!
GetTopLevelEditSubAction
(
)
&
&
aChild
-
>
GetParentNode
(
)
-
>
IsEditable
(
)
)
{
if
(
aChild
&
&
EditorUtils
:
:
IsPaddingBRElementForEmptyEditor
(
*
aChild
)
)
{
return
;
}
nsresult
rv
=
OnDocumentModified
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnDocumentModified
(
)
failed
but
ignored
"
)
;
}
}
nsresult
HTMLEditor
:
:
SelectEntireDocument
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
mInitSucceeded
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
Element
>
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
bodyOrDocumentElement
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
IsEmpty
(
)
)
{
nsresult
rv
=
CollapseSelectionToStartOf
(
*
bodyOrDocumentElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
bodyOrDocumentElement
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
HTMLEditor
:
:
SelectAllInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
CommitComposition
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
nsINode
*
anchorNode
=
SelectionRefPtr
(
)
-
>
GetAnchorNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
anchorNode
-
>
IsContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
anchorContent
=
anchorNode
-
>
AsContent
(
)
;
nsIContent
*
rootContent
;
if
(
anchorContent
-
>
HasIndependentSelection
(
)
)
{
SelectionRefPtr
(
)
-
>
SetAncestorLimiter
(
nullptr
)
;
rootContent
=
mRootElement
;
}
else
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
rootContent
=
anchorContent
-
>
GetSelectionRootContent
(
presShell
)
;
}
if
(
NS_WARN_IF
(
!
rootContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
userSelection
;
if
(
!
rootContent
-
>
IsEditable
(
)
)
{
userSelection
.
emplace
(
SelectionRefPtr
(
)
)
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
SelectAllChildren
(
*
rootContent
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
SelectAllChildren
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
bool
HTMLEditor
:
:
IsTextPropertySetByContent
(
nsINode
*
aNode
nsAtom
*
aProperty
nsAtom
*
aAttribute
const
nsAString
*
aValue
nsAString
*
outValue
)
{
MOZ_ASSERT
(
aNode
&
&
aProperty
)
;
for
(
Element
*
element
=
aNode
-
>
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
aProperty
!
=
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
continue
;
}
if
(
!
aAttribute
)
{
return
true
;
}
nsAutoString
value
;
element
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
value
)
;
if
(
outValue
)
{
*
outValue
=
value
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
aValue
)
{
return
true
;
}
if
(
aValue
-
>
Equals
(
value
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
return
false
;
}
}
return
false
;
}
bool
HTMLEditor
:
:
SetCaretInTableCell
(
Element
*
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
!
aElement
|
|
!
aElement
-
>
IsHTMLElement
(
)
|
|
!
HTMLEditUtils
:
:
IsTableElement
(
aElement
)
|
|
!
IsDescendantOfEditorRoot
(
aElement
)
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
deepestFirstChild
=
aElement
;
while
(
deepestFirstChild
-
>
HasChildren
(
)
)
{
deepestFirstChild
=
deepestFirstChild
-
>
GetFirstChild
(
)
;
}
nsresult
rv
=
CollapseSelectionToStartOf
(
*
deepestFirstChild
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
nsresult
HTMLEditor
:
:
CollapseAdjacentTextNodes
(
nsRange
&
aInRange
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
DOMSubtreeIterator
subtreeIter
;
if
(
NS_FAILED
(
subtreeIter
.
Init
(
aInRange
)
)
)
{
NS_WARNING
(
"
DOMSubtreeIterator
:
:
Init
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoTArray
<
OwningNonNull
<
Text
>
8
>
textNodes
;
subtreeIter
.
AppendNodesToArray
(
+
[
]
(
nsINode
&
aNode
void
*
)
-
>
bool
{
return
EditorUtils
:
:
IsEditableContent
(
*
aNode
.
AsText
(
)
EditorType
:
:
HTML
)
;
}
textNodes
)
;
while
(
textNodes
.
Length
(
)
>
1
)
{
Text
*
leftTextNode
=
textNodes
[
0
]
;
Text
*
rightTextNode
=
textNodes
[
1
]
;
NS_ASSERTION
(
leftTextNode
&
&
rightTextNode
"
left
or
rightTextNode
null
in
CollapseAdjacentTextNodes
"
)
;
nsIContent
*
previousSiblingOfRightTextNode
=
rightTextNode
-
>
GetPreviousSibling
(
)
;
if
(
previousSiblingOfRightTextNode
&
&
previousSiblingOfRightTextNode
=
=
leftTextNode
)
{
nsresult
rv
=
JoinNodesWithTransaction
(
MOZ_KnownLive
(
*
leftTextNode
)
MOZ_KnownLive
(
*
rightTextNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
textNodes
.
RemoveElementAt
(
0
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
rootElement
=
GetRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CollapseSelectionToStartOf
(
*
rootElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CollapseSelectionToStartOf
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveBlockContainerWithTransaction
(
Element
&
aElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsCOMPtr
<
nsIContent
>
child
=
GetFirstEditableChild
(
aElement
)
;
if
(
child
)
{
if
(
nsIContent
*
previousSibling
=
GetPriorHTMLSibling
(
&
aElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousSibling
)
&
&
!
previousSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
child
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
if
(
nsIContent
*
nextSibling
=
GetNextHTMLSibling
(
&
aElement
)
)
{
if
(
nextSibling
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSibling
)
)
{
if
(
nsIContent
*
lastChild
=
GetLastEditableChild
(
aElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
lastChild
)
&
&
!
lastChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
:
:
AtEndOf
(
aElement
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
}
}
}
else
if
(
nsIContent
*
previousSibling
=
GetPriorHTMLSibling
(
&
aElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
previousSibling
)
&
&
!
previousSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
if
(
nsIContent
*
nextSibling
=
GetNextHTMLSibling
(
&
aElement
)
)
{
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
*
nextSibling
)
&
&
!
nextSibling
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
&
aElement
0
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
}
}
nsresult
rv
=
RemoveContainerWithTransaction
(
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RemoveContainerWithTransaction
(
)
failed
"
)
;
return
rv
;
}
already_AddRefed
<
nsIContent
>
HTMLEditor
:
:
SplitNodeWithTransaction
(
const
EditorDOMPoint
&
aStartOfRightNode
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsInContentNode
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
nullptr
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eSplitNode
nsIEditor
:
:
eNext
aError
)
;
if
(
NS_WARN_IF
(
aError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
nullptr
;
}
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
aError
.
SuppressException
(
)
;
Unused
<
<
aStartOfRightNode
.
Offset
(
)
;
RefPtr
<
SplitNodeTransaction
>
transaction
=
SplitNodeTransaction
:
:
Create
(
*
this
aStartOfRightNode
)
;
aError
=
DoTransactionInternal
(
transaction
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
nsCOMPtr
<
nsIContent
>
newLeftContent
=
transaction
-
>
GetNewLeftContent
(
)
;
NS_WARNING_ASSERTION
(
newLeftContent
"
Failed
to
create
a
new
left
node
"
)
;
if
(
newLeftContent
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjSplitNode
(
*
aStartOfRightNode
.
GetContainerAsContent
(
)
*
newLeftContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
RangeUpdater
:
:
SelAdjSplitNode
(
)
failed
but
ignored
"
)
;
}
if
(
AsHTMLEditor
(
)
&
&
newLeftContent
)
{
TopLevelEditSubActionDataRef
(
)
.
DidSplitContent
(
*
this
*
aStartOfRightNode
.
GetContainerAsContent
(
)
*
newLeftContent
)
;
}
if
(
mInlineSpellChecker
)
{
RefPtr
<
mozInlineSpellChecker
>
spellChecker
=
mInlineSpellChecker
;
spellChecker
-
>
DidSplitNode
(
aStartOfRightNode
.
GetContainer
(
)
newLeftContent
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidSplitNode
(
aStartOfRightNode
.
GetContainer
(
)
newLeftContent
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidSplitNode
(
)
failed
but
ignored
"
)
;
}
}
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
return
newLeftContent
.
forget
(
)
;
}
SplitNodeResult
HTMLEditor
:
:
SplitNodeDeepWithTransaction
(
nsIContent
&
aMostAncestorToSplit
const
EditorDOMPoint
&
aStartOfDeepestRightNode
SplitAtEdges
aSplitAtEdges
)
{
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStartOfDeepestRightNode
.
GetContainer
(
)
=
=
&
aMostAncestorToSplit
|
|
EditorUtils
:
:
IsDescendantOf
(
*
aStartOfDeepestRightNode
.
GetContainer
(
)
aMostAncestorToSplit
)
)
;
if
(
NS_WARN_IF
(
!
aStartOfDeepestRightNode
.
IsSet
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_INVALID_ARG
)
;
}
nsCOMPtr
<
nsIContent
>
newLeftNodeOfMostAncestor
;
EditorDOMPoint
atStartOfRightNode
(
aStartOfDeepestRightNode
)
;
while
(
true
)
{
if
(
NS_WARN_IF
(
!
atStartOfRightNode
.
GetContainerAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_WARN_IF
(
atStartOfRightNode
.
GetContainer
(
)
!
=
&
aMostAncestorToSplit
&
&
!
atStartOfRightNode
.
GetContainerParentAsContent
(
)
)
)
{
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
nsIContent
*
currentRightNode
=
atStartOfRightNode
.
GetContainerAsContent
(
)
;
if
(
(
aSplitAtEdges
=
=
SplitAtEdges
:
:
eAllowToCreateEmptyContainer
&
&
!
atStartOfRightNode
.
GetContainerAsText
(
)
)
|
|
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
&
&
!
atStartOfRightNode
.
IsEndOfContainer
(
)
)
)
{
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atStartOfRightNode
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
SplitNodeResult
(
error
.
StealNSResult
(
)
)
;
}
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
newLeftNode
&
aMostAncestorToSplit
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
}
else
if
(
!
atStartOfRightNode
.
IsStartOfContainer
(
)
)
{
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
&
aMostAncestorToSplit
nullptr
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
DebugOnly
<
bool
>
advanced
=
atStartOfRightNode
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
after
current
node
"
)
;
}
else
{
if
(
currentRightNode
=
=
&
aMostAncestorToSplit
)
{
return
SplitNodeResult
(
nullptr
&
aMostAncestorToSplit
)
;
}
atStartOfRightNode
.
Set
(
currentRightNode
)
;
}
}
return
SplitNodeResult
(
NS_ERROR_FAILURE
)
;
}
void
HTMLEditor
:
:
DoSplitNode
(
const
EditorDOMPoint
&
aStartOfRightNode
nsIContent
&
aNewLeftNode
ErrorResult
&
aError
)
{
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aStartOfRightNode
.
IsSet
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
MOZ_ASSERT
(
aStartOfRightNode
.
IsSetAndValid
(
)
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
range
;
range
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
NS_WARN_IF
(
!
range
.
mSelection
&
&
selectionType
=
=
SelectionType
:
:
eNormal
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
!
range
.
mSelection
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
range
.
mSelection
-
>
RangeCount
(
)
;
+
+
j
)
{
RefPtr
<
const
nsRange
>
r
=
range
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
range
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
range
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
range
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
range
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
savedRanges
.
AppendElement
(
range
)
;
}
}
nsCOMPtr
<
nsINode
>
parent
=
aStartOfRightNode
.
GetContainerParent
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIContent
*
firstChildOfRightNode
=
aStartOfRightNode
.
GetChild
(
)
;
parent
-
>
InsertBefore
(
aNewLeftNode
aStartOfRightNode
.
GetContainer
(
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
;
}
if
(
!
aStartOfRightNode
.
IsStartOfContainer
(
)
)
{
Text
*
rightAsText
=
aStartOfRightNode
.
GetContainerAsText
(
)
;
Text
*
leftAsText
=
aNewLeftNode
.
GetAsText
(
)
;
if
(
rightAsText
&
&
leftAsText
)
{
MOZ_DIAGNOSTIC_ASSERT
(
AsHTMLEditor
(
)
"
Text
node
in
TextEditor
shouldn
'
t
be
split
"
)
;
nsAutoString
leftText
;
IgnoredErrorResult
ignoredError
;
rightAsText
-
>
SubstringData
(
0
aStartOfRightNode
.
Offset
(
)
leftText
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Text
:
:
SubstringData
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
DoDeleteText
(
MOZ_KnownLive
(
*
rightAsText
)
0
aStartOfRightNode
.
Offset
(
)
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoDeleteText
(
)
failed
but
ignored
"
)
;
ignoredError
.
SuppressException
(
)
;
DoSetText
(
MOZ_KnownLive
(
*
leftAsText
)
leftText
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoSetText
(
)
failed
but
ignored
"
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
!
rightAsText
&
&
!
leftAsText
)
;
if
(
!
firstChildOfRightNode
)
{
MoveAllChildren
(
*
aStartOfRightNode
.
GetContainer
(
)
EditorRawDOMPoint
(
&
aNewLeftNode
0
)
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MoveAllChildren
(
)
failed
"
)
;
}
else
if
(
NS_WARN_IF
(
aStartOfRightNode
.
GetContainer
(
)
!
=
firstChildOfRightNode
-
>
GetParentNode
(
)
)
)
{
}
else
{
MovePreviousSiblings
(
*
firstChildOfRightNode
EditorRawDOMPoint
(
&
aNewLeftNode
0
)
aError
)
;
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
HTMLEditor
:
:
MovePreviousSiblings
(
)
failed
"
)
;
}
}
}
NS_WARNING_ASSERTION
(
!
aError
.
Failed
(
)
"
The
previous
error
is
ignored
"
)
;
aError
.
SuppressException
(
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
NS_WARNING_ASSERTION
(
!
Destroyed
(
)
"
The
editor
is
destroyed
during
splitting
a
node
"
)
;
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
size_t
i
=
0
;
i
<
savedRanges
.
Length
(
)
;
+
+
i
)
{
SavedRange
&
range
=
savedRanges
[
i
]
;
if
(
range
.
mSelection
!
=
previousSelection
)
{
range
.
mSelection
-
>
RemoveAllRanges
(
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
;
}
previousSelection
=
range
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
range
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
range
.
mStartContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
static_cast
<
uint32_t
>
(
range
.
mStartOffset
)
<
aStartOfRightNode
.
Offset
(
)
)
{
range
.
mStartContainer
=
&
aNewLeftNode
;
}
else
{
range
.
mStartOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
}
if
(
range
.
mEndContainer
=
=
aStartOfRightNode
.
GetContainer
(
)
)
{
if
(
static_cast
<
uint32_t
>
(
range
.
mEndOffset
)
<
aStartOfRightNode
.
Offset
(
)
)
{
range
.
mEndContainer
=
&
aNewLeftNode
;
}
else
{
range
.
mEndOffset
-
=
aStartOfRightNode
.
Offset
(
)
;
}
}
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
range
.
mStartContainer
range
.
mStartOffset
range
.
mEndContainer
range
.
mEndOffset
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
;
}
MOZ_KnownLive
(
range
.
mSelection
)
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
aError
)
;
if
(
aError
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
;
}
}
if
(
NS_WARN_IF
(
parent
!
=
aStartOfRightNode
.
GetContainer
(
)
-
>
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
parent
!
=
aNewLeftNode
.
GetParentNode
(
)
)
|
|
NS_WARN_IF
(
aNewLeftNode
.
GetNextSibling
(
)
!
=
aStartOfRightNode
.
GetContainer
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
nsresult
HTMLEditor
:
:
JoinNodesWithTransaction
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aLeftNode
.
IsContent
(
)
)
;
MOZ_ASSERT
(
aRightNode
.
IsContent
(
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
aLeftNode
.
GetParentNode
(
)
;
MOZ_ASSERT
(
parent
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eJoinNodes
nsIEditor
:
:
ePrevious
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
TextEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
int32_t
offset
=
parent
-
>
ComputeIndexOf
(
&
aRightNode
)
;
uint32_t
oldLeftNodeLen
=
aLeftNode
.
Length
(
)
;
if
(
AsHTMLEditor
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
WillJoinContents
(
*
this
*
aLeftNode
.
AsContent
(
)
*
aRightNode
.
AsContent
(
)
)
;
}
RefPtr
<
JoinNodeTransaction
>
transaction
=
JoinNodeTransaction
:
:
MaybeCreate
(
*
this
*
aLeftNode
.
AsContent
(
)
*
aRightNode
.
AsContent
(
)
)
;
NS_WARNING_ASSERTION
(
transaction
"
JoinNodeTransaction
:
:
MaybeCreate
(
)
failed
but
ignored
"
)
;
nsresult
rv
=
NS_OK
;
if
(
transaction
)
{
rv
=
DoTransactionInternal
(
transaction
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DoTransactionInternal
(
)
failed
"
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
RangeUpdaterRef
(
)
.
SelAdjJoinNodes
(
aLeftNode
aRightNode
*
parent
offset
static_cast
<
int32_t
>
(
oldLeftNodeLen
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
RangeUpdater
:
:
SelAdjJoinNodes
(
)
failed
but
ignored
"
)
;
if
(
AsHTMLEditor
(
)
)
{
TopLevelEditSubActionDataRef
(
)
.
DidJoinContents
(
*
this
*
aLeftNode
.
AsContent
(
)
*
aRightNode
.
AsContent
(
)
)
;
}
if
(
mInlineSpellChecker
)
{
RefPtr
<
mozInlineSpellChecker
>
spellChecker
=
mInlineSpellChecker
;
spellChecker
-
>
DidJoinNodes
(
aLeftNode
aRightNode
)
;
}
if
(
mTextServicesDocument
&
&
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
mTextServicesDocument
;
textServicesDocument
-
>
DidJoinNodes
(
aLeftNode
aRightNode
)
;
}
if
(
!
mActionListeners
.
IsEmpty
(
)
)
{
for
(
auto
&
listener
:
mActionListeners
.
Clone
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
listener
-
>
DidJoinNodes
(
&
aLeftNode
&
aRightNode
parent
rv
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIEditActionListener
:
:
DidJoinNodes
(
)
failed
but
ignored
"
)
;
}
}
return
rv
;
}
nsresult
HTMLEditor
:
:
DoJoinNodes
(
nsIContent
&
aContentToKeep
nsIContent
&
aContentToJoin
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
AsHTMLEditor
(
)
)
;
uint32_t
firstNodeLength
=
aContentToJoin
.
Length
(
)
;
EditorRawDOMPoint
atNodeToJoin
(
&
aContentToJoin
)
;
EditorRawDOMPoint
atNodeToKeep
(
&
aContentToKeep
)
;
AutoTArray
<
SavedRange
10
>
savedRanges
;
for
(
SelectionType
selectionType
:
kPresentSelectionTypes
)
{
SavedRange
range
;
range
.
mSelection
=
GetSelection
(
selectionType
)
;
if
(
selectionType
=
=
SelectionType
:
:
eNormal
)
{
if
(
NS_WARN_IF
(
!
range
.
mSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
range
.
mSelection
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
range
.
mSelection
-
>
RangeCount
(
)
;
+
+
j
)
{
const
RefPtr
<
nsRange
>
r
=
range
.
mSelection
-
>
GetRangeAt
(
j
)
;
MOZ_ASSERT
(
r
-
>
IsPositioned
(
)
)
;
range
.
mStartContainer
=
r
-
>
GetStartContainer
(
)
;
range
.
mStartOffset
=
r
-
>
StartOffset
(
)
;
range
.
mEndContainer
=
r
-
>
GetEndContainer
(
)
;
range
.
mEndOffset
=
r
-
>
EndOffset
(
)
;
if
(
range
.
mStartContainer
)
{
if
(
range
.
mStartContainer
=
=
atNodeToKeep
.
GetContainer
(
)
&
&
atNodeToJoin
.
Offset
(
)
<
static_cast
<
uint32_t
>
(
range
.
mStartOffset
)
&
&
static_cast
<
uint32_t
>
(
range
.
mStartOffset
)
<
=
atNodeToKeep
.
Offset
(
)
)
{
range
.
mStartContainer
=
&
aContentToJoin
;
range
.
mStartOffset
=
firstNodeLength
;
}
if
(
range
.
mEndContainer
=
=
atNodeToKeep
.
GetContainer
(
)
&
&
atNodeToJoin
.
Offset
(
)
<
static_cast
<
uint32_t
>
(
range
.
mEndOffset
)
&
&
static_cast
<
uint32_t
>
(
range
.
mEndOffset
)
<
=
atNodeToKeep
.
Offset
(
)
)
{
range
.
mEndContainer
=
&
aContentToJoin
;
range
.
mEndOffset
=
firstNodeLength
;
}
}
savedRanges
.
AppendElement
(
range
)
;
}
}
if
(
aContentToKeep
.
IsText
(
)
&
&
aContentToJoin
.
IsText
(
)
)
{
nsAutoString
rightText
;
nsAutoString
leftText
;
aContentToKeep
.
AsText
(
)
-
>
GetData
(
rightText
)
;
aContentToJoin
.
AsText
(
)
-
>
GetData
(
leftText
)
;
leftText
+
=
rightText
;
IgnoredErrorResult
ignoredError
;
DoSetText
(
MOZ_KnownLive
(
*
aContentToKeep
.
AsText
(
)
)
leftText
ignoredError
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
EditorBase
:
:
DoSetText
(
)
failed
but
ignored
"
)
;
}
else
{
nsCOMPtr
<
nsINodeList
>
childNodes
=
aContentToJoin
.
ChildNodes
(
)
;
MOZ_ASSERT
(
childNodes
)
;
nsCOMPtr
<
nsIContent
>
firstNode
=
aContentToKeep
.
GetFirstChild
(
)
;
for
(
uint32_t
i
=
childNodes
-
>
Length
(
)
;
i
;
-
-
i
)
{
nsCOMPtr
<
nsIContent
>
childNode
=
childNodes
-
>
Item
(
i
-
1
)
;
if
(
childNode
)
{
ErrorResult
error
;
aContentToKeep
.
InsertBefore
(
*
childNode
firstNode
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
InsertBefore
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
firstNode
=
std
:
:
move
(
childNode
)
;
}
}
}
aContentToJoin
.
Remove
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
bool
allowedTransactionsToChangeSelection
=
AllowsTransactionsToChangeSelection
(
)
;
RefPtr
<
Selection
>
previousSelection
;
for
(
size_t
i
=
0
;
i
<
savedRanges
.
Length
(
)
;
+
+
i
)
{
SavedRange
&
range
=
savedRanges
[
i
]
;
if
(
range
.
mSelection
!
=
previousSelection
)
{
ErrorResult
error
;
range
.
mSelection
-
>
RemoveAllRanges
(
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
previousSelection
=
range
.
mSelection
;
}
if
(
allowedTransactionsToChangeSelection
&
&
range
.
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
continue
;
}
if
(
range
.
mStartContainer
=
=
&
aContentToJoin
)
{
range
.
mStartContainer
=
&
aContentToKeep
;
}
else
if
(
range
.
mStartContainer
=
=
&
aContentToKeep
)
{
range
.
mStartOffset
+
=
firstNodeLength
;
}
if
(
range
.
mEndContainer
=
=
&
aContentToJoin
)
{
range
.
mEndContainer
=
&
aContentToKeep
;
}
else
if
(
range
.
mEndContainer
=
=
&
aContentToKeep
)
{
range
.
mEndOffset
+
=
firstNodeLength
;
}
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
range
.
mStartContainer
range
.
mStartOffset
range
.
mEndContainer
range
.
mEndOffset
IgnoreErrors
(
)
)
;
if
(
!
newRange
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
MOZ_KnownLive
(
range
.
mSelection
)
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
error
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
if
(
allowedTransactionsToChangeSelection
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SelectionRefPtr
(
)
-
>
Collapse
(
&
aContentToKeep
AssertedCast
<
int32_t
>
(
firstNodeLength
)
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Selection
:
:
Collapse
(
)
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MoveNodeWithTransaction
(
nsIContent
&
aContent
const
EditorDOMPoint
&
aPointToInsert
)
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
EditorDOMPoint
oldPoint
(
&
aContent
)
;
if
(
NS_WARN_IF
(
!
oldPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aPointToInsert
=
=
oldPoint
)
{
return
NS_OK
;
}
AutoMoveNodeSelNotify
selNotify
(
RangeUpdaterRef
(
)
oldPoint
aPointToInsert
)
;
nsresult
rv
=
EditorBase
:
:
DeleteNodeWithTransaction
(
aContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
pointToInsert
(
selNotify
.
ComputeInsertionPoint
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSetAndValid
(
)
)
)
{
pointToInsert
.
SetToEndOf
(
pointToInsert
.
GetContainer
(
)
)
;
}
rv
=
InsertNodeWithTransaction
(
aContent
pointToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
DeleteSelectionAndCreateElement
(
nsAtom
&
aTag
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsresult
rv
=
DeleteSelectionAndPrepareToCreateNode
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
failed
"
)
;
return
nullptr
;
}
EditorDOMPoint
pointToInsert
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newElement
=
CreateNodeWithTransaction
(
aTag
pointToInsert
)
;
if
(
!
newElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
EditorRawDOMPoint
afterNewElement
(
EditorRawDOMPoint
:
:
After
(
newElement
)
)
;
MOZ_ASSERT
(
afterNewElement
.
IsSetAndValid
(
)
)
;
IgnoredErrorResult
ignoredError
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterNewElement
ignoredError
)
;
if
(
ignoredError
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
nullptr
;
}
return
newElement
.
forget
(
)
;
}
nsresult
HTMLEditor
:
:
DeleteSelectionAndPrepareToCreateNode
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
IsHTMLEditor
(
)
)
;
if
(
NS_WARN_IF
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
)
)
{
return
NS_OK
;
}
if
(
!
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
)
{
nsresult
rv
=
DeleteSelectionAsSubAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
&
&
SelectionRefPtr
(
)
-
>
GetAnchorFocusRange
(
)
-
>
Collapsed
(
)
"
Selection
not
collapsed
after
delete
"
)
;
}
EditorDOMPoint
atAnchor
(
SelectionRefPtr
(
)
-
>
AnchorRef
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchor
.
IsSet
(
)
)
|
|
!
atAnchor
.
IsInDataNode
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
atAnchor
.
GetContainerParent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
atAnchor
.
IsStartOfContainer
(
)
)
{
EditorRawDOMPoint
atAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atAnchorContainer
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
atAnchorContainer
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
if
(
atAnchor
.
IsEndOfContainer
(
)
)
{
EditorRawDOMPoint
afterAnchorContainer
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
afterAnchorContainer
.
AdvanceOffset
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
SelectionRefPtr
(
)
-
>
Collapse
(
afterAnchorContainer
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
ErrorResult
error
;
nsCOMPtr
<
nsIContent
>
newLeftNode
=
SplitNodeWithTransaction
(
atAnchor
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitNodeWithTransaction
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
EditorRawDOMPoint
atRightNode
(
atAnchor
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
atRightNode
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
atRightNode
.
IsSetAndValid
(
)
)
;
SelectionRefPtr
(
)
-
>
Collapse
(
atRightNode
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
Collapse
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsIContent
*
HTMLEditor
:
:
GetPriorHTMLSibling
(
nsINode
*
aNode
SkipWhitespace
aSkipWS
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
content
=
aNode
-
>
GetPreviousSibling
(
)
;
while
(
content
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
SkippableWhitespace
(
content
aSkipWS
)
)
)
{
content
=
content
-
>
GetPreviousSibling
(
)
;
}
return
content
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLSibling
(
nsINode
*
aNode
SkipWhitespace
aSkipWS
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsIContent
*
content
=
aNode
-
>
GetNextSibling
(
)
;
while
(
content
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
|
|
SkippableWhitespace
(
content
aSkipWS
)
)
)
{
content
=
content
-
>
GetNextSibling
(
)
;
}
return
content
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aNode
)
:
GetPreviousElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousElementOrTextInBlock
(
aPoint
)
:
GetPreviousElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aNode
)
:
GetPreviousEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetPreviousEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetPreviousEditableNodeInBlock
(
aPoint
)
:
GetPreviousEditableNode
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aNode
)
:
GetNextElementOrText
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextHTMLElementOrTextInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextElementOrTextInBlock
(
aPoint
)
:
GetNextElementOrText
(
aPoint
)
;
}
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
nsINode
&
aNode
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aNode
)
:
GetNextEditableNode
(
aNode
)
;
}
template
<
typename
PT
typename
CT
>
nsIContent
*
HTMLEditor
:
:
GetNextEditableHTMLNodeInternal
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aNoBlockCrossing
)
const
{
if
(
NS_WARN_IF
(
!
GetActiveEditingHost
(
)
)
)
{
return
nullptr
;
}
return
aNoBlockCrossing
?
GetNextEditableNodeInBlock
(
aPoint
)
:
GetNextEditableNode
(
aPoint
)
;
}
bool
HTMLEditor
:
:
IsFirstEditableChild
(
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
return
false
;
}
return
GetFirstEditableChild
(
*
parentNode
)
=
=
aNode
;
}
bool
HTMLEditor
:
:
IsLastEditableChild
(
nsINode
*
aNode
)
const
{
MOZ_ASSERT
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
)
{
return
false
;
}
return
GetLastEditableChild
(
*
parentNode
)
=
=
aNode
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableChild
(
nsINode
&
aNode
)
const
{
nsIContent
*
child
=
aNode
.
GetFirstChild
(
)
;
while
(
child
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
)
{
child
=
child
-
>
GetNextSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableChild
(
nsINode
&
aNode
)
const
{
nsIContent
*
child
=
aNode
.
GetLastChild
(
)
;
while
(
child
&
&
!
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetFirstEditableLeaf
(
nsINode
&
aNode
)
const
{
nsIContent
*
child
=
HTMLEditUtils
:
:
GetFirstLeafChild
(
aNode
ChildBlockBoundary
:
:
Ignore
)
;
while
(
child
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetNextEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
nsIContent
*
HTMLEditor
:
:
GetLastEditableLeaf
(
nsINode
&
aNode
)
const
{
nsIContent
*
child
=
HTMLEditUtils
:
:
GetLastLeafChild
(
aNode
ChildBlockBoundary
:
:
Ignore
)
;
while
(
child
&
&
(
!
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
|
|
child
-
>
HasChildren
(
)
)
)
{
child
=
GetPreviousEditableHTMLNode
(
*
child
)
;
if
(
!
aNode
.
Contains
(
child
)
)
{
return
nullptr
;
}
}
return
child
;
}
bool
HTMLEditor
:
:
IsInVisibleTextFrames
(
Text
&
aText
)
const
{
nsISelectionController
*
selectionController
=
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
false
;
}
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
bool
isVisible
=
false
;
nsresult
rv
=
selectionController
-
>
CheckVisibilityContent
(
&
aText
0
aText
.
TextDataLength
(
)
&
isVisible
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsISelectionController
:
:
CheckVisibilityContent
(
)
failed
but
ignored
"
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
isVisible
;
}
bool
HTMLEditor
:
:
IsVisibleTextNode
(
Text
&
aText
)
const
{
if
(
!
aText
.
TextDataLength
(
)
)
{
return
false
;
}
if
(
!
aText
.
TextIsOnlyWhitespace
(
)
)
{
return
true
;
}
WSScanResult
nextWSScanResult
=
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundary
(
*
this
EditorRawDOMPoint
(
&
aText
0
)
)
;
return
nextWSScanResult
.
InNormalWhiteSpacesOrText
(
)
&
&
nextWSScanResult
.
TextPtr
(
)
=
=
&
aText
;
}
bool
HTMLEditor
:
:
IsEmpty
(
)
const
{
if
(
mPaddingBRElementForEmptyEditor
)
{
return
true
;
}
Element
*
bodyOrDocumentElement
=
GetRoot
(
)
;
if
(
!
bodyOrDocumentElement
)
{
return
true
;
}
for
(
nsIContent
*
childContent
=
bodyOrDocumentElement
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
if
(
!
childContent
-
>
IsText
(
)
|
|
childContent
-
>
Length
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
HTMLEditor
:
:
IsEmptyNodeImpl
(
nsINode
&
aNode
bool
aSingleBRDoesntCount
bool
aListOrCellNotEmpty
bool
aSafeToAskFrames
bool
*
aSeenBR
)
const
{
MOZ_ASSERT
(
aSeenBR
)
;
if
(
Text
*
text
=
aNode
.
GetAsText
(
)
)
{
return
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
;
}
if
(
!
aNode
.
IsContent
(
)
|
|
!
HTMLEditUtils
:
:
IsContainerNode
(
*
aNode
.
AsContent
(
)
)
|
|
(
HTMLEditUtils
:
:
IsNamedAnchor
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsFormWidget
(
&
aNode
)
|
|
(
aListOrCellNotEmpty
&
&
(
HTMLEditUtils
:
:
IsListItem
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
&
aNode
)
)
)
)
)
{
return
false
;
}
bool
isListItemOrCell
=
HTMLEditUtils
:
:
IsListItem
(
&
aNode
)
|
|
HTMLEditUtils
:
:
IsTableCell
(
&
aNode
)
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
.
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
EditorUtils
:
:
IsEditableContent
(
*
child
EditorType
:
:
HTML
)
)
{
if
(
Text
*
text
=
child
-
>
GetAsText
(
)
)
{
if
(
!
(
aSafeToAskFrames
?
!
IsInVisibleTextFrames
(
*
text
)
:
!
IsVisibleTextNode
(
*
text
)
)
)
{
return
false
;
}
}
else
{
if
(
child
=
=
&
aNode
)
{
break
;
}
if
(
aSingleBRDoesntCount
&
&
!
*
aSeenBR
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
*
aSeenBR
=
true
;
}
else
{
if
(
child
-
>
IsElement
(
)
)
{
if
(
isListItemOrCell
)
{
if
(
HTMLEditUtils
:
:
IsList
(
child
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
false
;
}
}
else
if
(
HTMLEditUtils
:
:
IsFormWidget
(
child
)
)
{
return
false
;
}
}
if
(
!
IsEmptyNodeImpl
(
*
child
aSingleBRDoesntCount
aListOrCellNotEmpty
aSafeToAskFrames
aSeenBR
)
)
{
return
false
;
}
}
}
}
}
return
true
;
}
nsresult
HTMLEditor
:
:
SetAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
const
nsAString
&
aValue
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
IsCSSEnabled
(
)
|
|
!
mCSSEditUtils
)
{
if
(
mCSSEditUtils
)
{
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
int32_t
count
=
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
&
aValue
aSuppressTransaction
)
;
if
(
count
)
{
nsAutoString
existingValue
;
if
(
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
existingValue
)
)
{
return
NS_OK
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
UnsetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
nsAutoString
existingValue
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
)
;
existingValue
.
Append
(
'
'
)
;
existingValue
.
Append
(
aValue
)
;
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
existingValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
style
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
nsGkAtoms
:
:
style
existingValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
style
)
failed
"
)
;
return
rv
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
aValue
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
SetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
SetAttributeWithTransaction
(
*
aElement
*
aAttribute
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
RemoveAttributeOrEquivalent
(
Element
*
aElement
nsAtom
*
aAttribute
bool
aSuppressTransaction
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
aAttribute
)
;
if
(
IsCSSEnabled
(
)
&
&
mCSSEditUtils
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSEquivalentToHTMLStyle
(
aElement
nullptr
aAttribute
nullptr
aSuppressTransaction
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSEquivalentToHTMLStyle
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttribute
)
)
{
return
NS_OK
;
}
if
(
aSuppressTransaction
)
{
nsresult
rv
=
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
UnsetAttr
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
RemoveAttributeWithTransaction
(
*
aElement
*
aAttribute
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetIsCSSEnabled
(
bool
aIsCSSPrefChecked
)
{
if
(
!
mCSSEditUtils
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eEnableOrDisableCSS
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mCSSEditUtils
-
>
SetCSSEnabled
(
aIsCSSPrefChecked
)
;
uint32_t
flags
=
mFlags
;
if
(
aIsCSSPrefChecked
)
{
flags
&
=
~
eEditorNoCSSMask
;
}
else
{
flags
|
=
eEditorNoCSSMask
;
}
nsresult
rv
=
SetFlags
(
flags
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetFlags
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
const
nsAString
&
aColor
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
mInitSucceeded
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
CommitComposition
(
)
;
if
(
IsPlaintextEditor
(
)
)
{
return
NS_OK
;
}
EditActionResult
result
=
CanHandleHTMLEditSubAction
(
)
;
if
(
result
.
Failed
(
)
|
|
result
.
Canceled
(
)
)
{
NS_WARNING_ASSERTION
(
result
.
Succeeded
(
)
"
HTMLEditor
:
:
CanHandleHTMLEditSubAction
(
)
failed
"
)
;
return
result
.
Rv
(
)
;
}
bool
selectionIsCollapsed
=
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertElement
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
"
"
failed
but
ignored
"
)
;
{
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
*
this
)
;
for
(
uint32_t
i
=
0
;
i
<
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPoint
startOfRange
(
range
-
>
StartRef
(
)
)
;
EditorDOMPoint
endOfRange
(
range
-
>
EndRef
(
)
)
;
if
(
NS_WARN_IF
(
!
startOfRange
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
endOfRange
.
IsSet
(
)
)
)
{
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
=
=
endOfRange
.
GetContainer
(
)
)
{
if
(
startOfRange
.
IsInTextNode
(
)
)
{
if
(
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
startOfRange
.
ContainerAsText
(
)
)
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
continue
;
}
if
(
startOfRange
.
GetContainer
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
&
&
selectionIsCollapsed
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
MOZ_KnownLive
(
startOfRange
.
GetContainerAsElement
(
)
)
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
continue
;
}
if
(
(
startOfRange
.
IsStartOfContainer
(
)
&
&
endOfRange
.
IsStartOfContainer
(
)
)
|
|
startOfRange
.
Offset
(
)
+
1
=
=
endOfRange
.
Offset
(
)
)
{
if
(
NS_WARN_IF
(
startOfRange
.
IsInDataNode
(
)
)
)
{
continue
;
}
if
(
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
*
startOfRange
.
GetChild
(
)
)
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
continue
;
}
}
AutoTArray
<
OwningNonNull
<
nsIContent
>
64
>
arrayOfContents
;
ContentSubtreeIterator
subtreeIter
;
nsresult
rv
=
subtreeIter
.
Init
(
range
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
ContentSubtreeIterator
:
:
Init
(
)
failed
but
ignored
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
node
-
>
IsContent
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
node
-
>
AsContent
(
)
EditorType
:
:
HTML
)
)
{
arrayOfContents
.
AppendElement
(
*
node
-
>
AsContent
(
)
)
;
}
}
}
RefPtr
<
Element
>
handledBlockParent
;
if
(
startOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
startOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
startOfRange
.
ContainerAsText
(
)
)
;
if
(
blockElement
&
&
handledBlockParent
!
=
blockElement
)
{
handledBlockParent
=
blockElement
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
for
(
OwningNonNull
<
nsIContent
>
&
content
:
arrayOfContents
)
{
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetInclusiveAncestorBlockElement
(
content
)
;
if
(
blockElement
&
&
handledBlockParent
!
=
blockElement
)
{
handledBlockParent
=
blockElement
;
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
if
(
endOfRange
.
IsInTextNode
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
endOfRange
.
ContainerAsText
(
)
EditorType
:
:
HTML
)
)
{
RefPtr
<
Element
>
blockElement
=
HTMLEditUtils
:
:
GetAncestorBlockElement
(
*
endOfRange
.
ContainerAsText
(
)
)
;
if
(
blockElement
&
&
handledBlockParent
!
=
blockElement
)
{
mCSSEditUtils
-
>
SetCSSEquivalentToHTMLStyle
(
blockElement
nullptr
nsGkAtoms
:
:
bgcolor
&
aColor
false
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
}
}
}
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetBackgroundColor
(
const
nsAString
&
aColor
)
{
nsresult
rv
=
SetBackgroundColorAsAction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetBackgroundColorAsAction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetBackgroundColorAsAction
(
const
nsAString
&
aColor
nsIPrincipal
*
aPrincipal
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetBackgroundColor
aPrincipal
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
IsCSSEnabled
(
)
)
{
nsresult
rv
=
SetCSSBackgroundColorWithTransaction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetCSSBackgroundColorWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetHTMLBackgroundColorWithTransaction
(
aColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetHTMLBackgroundColorWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
CopyLastEditableChildStylesWithTransaction
(
Element
&
aPreviousBlock
Element
&
aNewBlock
RefPtr
<
Element
>
*
aNewBRElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aNewBRElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aNewBRElement
=
nullptr
;
RefPtr
<
Element
>
previousBlock
(
&
aPreviousBlock
)
;
RefPtr
<
Element
>
newBlock
(
&
aNewBlock
)
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
newBlock
-
>
GetFirstChild
(
)
;
child
;
child
=
newBlock
-
>
GetFirstChild
(
)
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
nsIContent
*
deepestEditableContent
=
nullptr
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
previousBlock
.
get
(
)
;
child
;
child
=
GetLastEditableChild
(
*
child
)
)
{
deepestEditableContent
=
child
;
}
while
(
deepestEditableContent
&
&
deepestEditableContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
deepestEditableContent
=
GetPreviousEditableHTMLNode
(
*
deepestEditableContent
)
;
}
if
(
!
deepestEditableContent
)
{
return
NS_OK
;
}
Element
*
deepestVisibleEditableElement
=
deepestEditableContent
-
>
GetAsElementOrParentElement
(
)
;
if
(
!
deepestVisibleEditableElement
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
lastClonedElement
firstClonsedElement
;
for
(
RefPtr
<
Element
>
elementInPreviousBlock
=
deepestVisibleEditableElement
;
elementInPreviousBlock
&
&
elementInPreviousBlock
!
=
previousBlock
;
elementInPreviousBlock
=
elementInPreviousBlock
-
>
GetParentElement
(
)
)
{
if
(
!
HTMLEditUtils
:
:
IsInlineStyle
(
elementInPreviousBlock
)
&
&
!
elementInPreviousBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
span
)
)
{
continue
;
}
nsAtom
*
tagName
=
elementInPreviousBlock
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
!
firstClonsedElement
)
{
firstClonsedElement
=
lastClonedElement
=
CreateNodeWithTransaction
(
MOZ_KnownLive
(
*
tagName
)
EditorDOMPoint
(
newBlock
0
)
)
;
if
(
!
firstClonsedElement
)
{
NS_WARNING
(
"
EditorBase
:
:
CreateNodeWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
continue
;
}
lastClonedElement
=
InsertContainerWithTransaction
(
*
lastClonedElement
MOZ_KnownLive
(
*
tagName
)
)
;
if
(
!
lastClonedElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertContainerWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
CloneAttributesWithTransaction
(
*
lastClonedElement
*
elementInPreviousBlock
)
;
}
if
(
!
firstClonsedElement
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
brElement
=
InsertBRElementWithTransaction
(
EditorDOMPoint
(
firstClonsedElement
0
)
)
;
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
*
aNewBRElement
=
std
:
:
move
(
brElement
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetElementOrigin
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
)
{
aX
=
0
;
aY
=
0
;
if
(
NS_WARN_IF
(
!
IsInitialized
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
NS_OK
;
}
nsIFrame
*
absoluteContainerBlockFrame
=
presShell
-
>
GetAbsoluteContainingBlock
(
frame
)
;
if
(
NS_WARN_IF
(
!
absoluteContainerBlockFrame
)
)
{
return
NS_OK
;
}
nsPoint
off
=
frame
-
>
GetOffsetTo
(
absoluteContainerBlockFrame
)
;
aX
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
x
)
;
aY
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
off
.
y
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetSelectionContainerElement
(
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
nsINode
*
focusNode
=
nullptr
;
if
(
SelectionRefPtr
(
)
-
>
IsCollapsed
(
)
)
{
focusNode
=
SelectionRefPtr
(
)
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
else
{
uint32_t
rangeCount
=
SelectionRefPtr
(
)
-
>
RangeCount
(
)
;
MOZ_ASSERT
(
rangeCount
"
If
0
Selection
:
:
IsCollapsed
(
)
should
return
true
"
)
;
if
(
rangeCount
=
=
1
)
{
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
0
)
;
const
RangeBoundary
&
startRef
=
range
-
>
StartRef
(
)
;
const
RangeBoundary
&
endRef
=
range
-
>
EndRef
(
)
;
if
(
startRef
.
Container
(
)
-
>
IsElement
(
)
&
&
startRef
.
Container
(
)
=
=
endRef
.
Container
(
)
&
&
startRef
.
GetChildAtOffset
(
)
&
&
startRef
.
GetChildAtOffset
(
)
-
>
GetNextSibling
(
)
=
=
endRef
.
GetChildAtOffset
(
)
)
{
focusNode
=
startRef
.
GetChildAtOffset
(
)
;
MOZ_ASSERT
(
focusNode
"
Start
container
must
not
be
nullptr
"
)
;
}
else
{
focusNode
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
focusNode
)
{
NS_WARNING
(
"
AbstractRange
:
:
GetClosestCommonInclusiveAncestor
(
)
returned
"
"
nullptr
"
)
;
return
nullptr
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
const
nsRange
*
range
=
SelectionRefPtr
(
)
-
>
GetRangeAt
(
i
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
!
focusNode
)
{
focusNode
=
startContainer
;
}
else
if
(
focusNode
!
=
startContainer
)
{
focusNode
=
startContainer
-
>
GetParentNode
(
)
;
break
;
}
}
if
(
!
focusNode
)
{
NS_WARNING
(
"
Focused
node
of
selection
was
not
found
"
)
;
return
nullptr
;
}
}
}
if
(
focusNode
-
>
IsText
(
)
)
{
focusNode
=
focusNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
)
{
return
nullptr
;
}
}
if
(
NS_WARN_IF
(
!
focusNode
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
return
focusNode
-
>
AsElement
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
IsAnonymousElement
(
Element
*
aElement
bool
*
aReturn
)
{
if
(
NS_WARN_IF
(
!
aElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aReturn
=
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetReturnInParagraphCreatesNewParagraph
(
bool
aCreatesNewParagraph
)
{
mCRInParagraphCreatesParagraph
=
aCreatesNewParagraph
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
)
{
return
mCRInParagraphCreatesParagraph
;
}
nsresult
HTMLEditor
:
:
GetReturnInParagraphCreatesNewParagraph
(
bool
*
aCreatesNewParagraph
)
{
*
aCreatesNewParagraph
=
mCRInParagraphCreatesParagraph
;
return
NS_OK
;
}
nsIContent
*
HTMLEditor
:
:
GetFocusedContent
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
nullptr
;
}
nsIContent
*
focusedContent
=
focusManager
-
>
GetFocusedElement
(
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
!
focusedContent
)
{
if
(
inDesignMode
&
&
OurWindowHasFocus
(
)
)
{
return
document
-
>
GetRootElement
(
)
;
}
return
nullptr
;
}
if
(
inDesignMode
)
{
return
OurWindowHasFocus
(
)
&
&
focusedContent
-
>
IsInclusiveDescendantOf
(
document
)
?
focusedContent
:
nullptr
;
}
if
(
!
focusedContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
focusedContent
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
OurWindowHasFocus
(
)
?
focusedContent
:
nullptr
;
}
nsIContent
*
HTMLEditor
:
:
GetFocusedContentForIME
(
)
const
{
nsIContent
*
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
?
nullptr
:
focusedContent
;
}
bool
HTMLEditor
:
:
IsActiveInDOMWindow
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
bool
inDesignMode
=
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
inDesignMode
)
{
return
true
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
nsIContent
*
content
=
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
win
)
)
;
if
(
!
content
)
{
return
false
;
}
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
true
;
}
Element
*
HTMLEditor
:
:
GetActiveEditingHost
(
)
const
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
document
-
>
GetBodyElement
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
nullptr
;
}
nsINode
*
focusNode
=
SelectionRefPtr
(
)
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
focusNode
)
|
|
NS_WARN_IF
(
!
focusNode
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
focusNode
-
>
AsContent
(
)
;
if
(
!
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
content
-
>
HasIndependentSelection
(
)
)
{
return
nullptr
;
}
return
content
-
>
GetEditingHost
(
)
;
}
void
HTMLEditor
:
:
NotifyEditingHostMaybeChanged
(
)
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
|
|
NS_WARN_IF
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
)
{
return
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
nsIContent
*
ancestorLimiter
=
SelectionRefPtr
(
)
-
>
GetAncestorLimiter
(
)
;
if
(
!
ancestorLimiter
)
{
return
;
}
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
NS_WARN_IF
(
!
editingHost
)
)
{
return
;
}
if
(
ancestorLimiter
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
EditorBase
:
:
InitializeSelectionAncestorLimit
(
*
editingHost
)
;
}
}
EventTarget
*
HTMLEditor
:
:
GetDOMEventTarget
(
)
const
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
has
not
been
initialized
yet
"
)
;
return
GetDocument
(
)
;
}
bool
HTMLEditor
:
:
ShouldReplaceRootElement
(
)
const
{
if
(
!
mRootElement
)
{
return
true
;
}
return
mRootElement
!
=
GetBodyElement
(
)
;
}
void
HTMLEditor
:
:
NotifyRootChanged
(
)
{
MOZ_ASSERT
(
mPendingRootElementUpdatedRunner
"
HTMLEditor
:
:
NotifyRootChanged
(
)
should
be
called
via
a
runner
"
)
;
mPendingRootElementUpdatedRunner
=
nullptr
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
;
}
RemoveEventListeners
(
)
;
nsresult
rv
=
InstallEventListeners
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InstallEventListeners
(
)
failed
but
ignored
"
)
;
return
;
}
UpdateRootElement
(
)
;
if
(
!
mRootElement
)
{
return
;
}
rv
=
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MaybeCollapseSelectionAtFirstEditableNode
(
false
)
"
"
failed
"
"
but
ignored
"
)
;
return
;
}
nsCOMPtr
<
nsINode
>
node
=
GetFocusedNode
(
)
;
if
(
node
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
InitializeSelection
(
*
node
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
InitializeSelection
(
)
failed
but
ignored
"
)
;
}
SyncRealTimeSpell
(
)
;
}
Element
*
HTMLEditor
:
:
GetBodyElement
(
)
const
{
MOZ_ASSERT
(
IsInitialized
(
)
"
The
HTMLEditor
hasn
'
t
been
initialized
yet
"
)
;
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
return
document
-
>
GetBody
(
)
;
}
nsINode
*
HTMLEditor
:
:
GetFocusedNode
(
)
const
{
nsIContent
*
focusedContent
=
GetFocusedContent
(
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
NS_ASSERTION
(
focusManager
"
Focus
manager
is
null
"
)
;
Element
*
focusedElement
=
focusManager
-
>
GetFocusedElement
(
)
;
if
(
focusedElement
)
{
return
focusedElement
;
}
return
GetDocument
(
)
;
}
bool
HTMLEditor
:
:
OurWindowHasFocus
(
)
const
{
nsFocusManager
*
focusManager
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
focusManager
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
focusedWindow
=
focusManager
-
>
GetFocusedWindow
(
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
ourWindow
=
document
-
>
GetWindow
(
)
;
return
ourWindow
=
=
focusedWindow
;
}
bool
HTMLEditor
:
:
IsAcceptableInputEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
!
EditorBase
:
:
IsAcceptableInputEvent
(
aGUIEvent
)
)
{
return
false
;
}
if
(
mComposition
&
&
aGUIEvent
-
>
AsCompositionEvent
(
)
)
{
return
true
;
}
RefPtr
<
EventTarget
>
eventTarget
=
aGUIEvent
-
>
GetOriginalDOMEventTarget
(
)
;
if
(
NS_WARN_IF
(
!
eventTarget
)
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
eventTargetNode
=
do_QueryInterface
(
eventTarget
)
;
if
(
NS_WARN_IF
(
!
eventTargetNode
)
)
{
return
false
;
}
if
(
eventTargetNode
-
>
IsContent
(
)
)
{
eventTargetNode
=
eventTargetNode
-
>
AsContent
(
)
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
if
(
NS_WARN_IF
(
!
eventTargetNode
)
)
{
return
false
;
}
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
false
;
}
if
(
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
eventTargetNode
-
>
IsDocument
(
)
)
{
return
eventTargetNode
=
=
document
;
}
if
(
NS_WARN_IF
(
!
eventTargetNode
-
>
IsContent
(
)
)
)
{
return
false
;
}
return
document
=
=
eventTargetNode
-
>
GetUncomposedDoc
(
)
;
}
if
(
NS_WARN_IF
(
!
eventTargetNode
-
>
IsContent
(
)
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
AsMouseEventBase
(
)
)
{
nsIContent
*
editingHost
=
GetActiveEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
if
(
eventTargetNode
=
=
document
-
>
GetRootElement
(
)
&
&
!
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
editingHost
=
=
document
-
>
GetBodyElement
(
)
)
{
eventTargetNode
=
editingHost
;
}
if
(
!
eventTargetNode
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
return
false
;
}
if
(
eventTargetNode
-
>
AsContent
(
)
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
!
eventTargetNode
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
eventTargetNode
-
>
AsContent
(
)
-
>
HasIndependentSelection
(
)
)
{
return
false
;
}
return
IsActiveInDOMWindow
(
)
;
}
nsresult
HTMLEditor
:
:
GetPreferredIMEState
(
IMEState
*
aState
)
{
aState
-
>
mOpen
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
if
(
IsReadonly
(
)
)
{
aState
-
>
mEnabled
=
IMEState
:
:
DISABLED
;
}
else
{
aState
-
>
mEnabled
=
IMEState
:
:
ENABLED
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
HTMLEditor
:
:
GetInputEventTargetElement
(
)
const
{
RefPtr
<
Element
>
target
=
GetActiveEditingHost
(
)
;
return
target
.
forget
(
)
;
}
Element
*
HTMLEditor
:
:
GetEditorRoot
(
)
const
{
return
GetActiveEditingHost
(
)
;
}
nsHTMLDocument
*
HTMLEditor
:
:
GetHTMLDocument
(
)
const
{
Document
*
document
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
if
(
!
document
-
>
IsHTMLOrXHTML
(
)
)
{
return
nullptr
;
}
return
document
-
>
AsHTMLDocument
(
)
;
}
nsresult
HTMLEditor
:
:
OnModifyDocument
(
)
{
MOZ_ASSERT
(
mPendingDocumentModifiedRunner
"
HTMLEditor
:
:
OnModifyDocument
(
)
should
be
called
via
a
runner
"
)
;
mPendingDocumentModifiedRunner
=
nullptr
;
if
(
IsEditActionDataAvailable
(
)
)
{
return
OnModifyDocumentInternal
(
)
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eCreatePaddingBRElementForEmptyEditor
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
OnModifyDocumentInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
OnModifyDocumentInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnModifyDocumentInternal
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
!
mPendingDocumentModifiedRunner
)
;
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsresult
rv
=
EnsureNoPaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
rv
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
EnsureNoPaddingBRElementForEmptyEditor
(
)
"
"
failed
but
ignored
"
)
;
rv
=
MaybeCreatePaddingBRElementForEmptyEditor
(
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
MaybeCreatePaddingBRElementForEmptyEditor
(
)
failed
"
)
;
return
rv
;
}
}
