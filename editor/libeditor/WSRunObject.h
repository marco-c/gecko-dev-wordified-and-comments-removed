#
ifndef
WSRunObject_h
#
define
WSRunObject_h
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditAction
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
namespace
mozilla
{
class
WSRunScanner
;
class
MOZ_STACK_CLASS
WSScanResult
final
{
private
:
enum
class
WSType
:
uint8_t
{
NotInitialized
LeadingWhiteSpaces
TrailingWhiteSpaces
NormalWhiteSpaces
NormalText
SpecialContent
BRElement
OtherBlockBoundary
CurrentBlockBoundary
}
;
friend
class
WSRunScanner
;
public
:
WSScanResult
(
)
=
delete
;
MOZ_NEVER_INLINE_DEBUG
WSScanResult
(
nsIContent
*
aContent
WSType
aReason
)
:
mContent
(
aContent
)
mReason
(
aReason
)
{
AssertIfInvalidData
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
WSScanResult
(
const
EditorDOMPoint
&
aPoint
WSType
aReason
)
:
mContent
(
aPoint
.
GetContainerAsContent
(
)
)
mOffset
(
Some
(
aPoint
.
Offset
(
)
)
)
mReason
(
aReason
)
{
AssertIfInvalidData
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
void
AssertIfInvalidData
(
)
const
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mReason
=
=
WSType
:
:
NormalText
|
|
mReason
=
=
WSType
:
:
NormalWhiteSpaces
|
|
mReason
=
=
WSType
:
:
BRElement
|
|
mReason
=
=
WSType
:
:
SpecialContent
|
|
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
NormalText
|
|
mReason
=
=
WSType
:
:
NormalWhiteSpaces
mContent
&
&
mContent
-
>
IsText
(
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
BRElement
mContent
&
&
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
SpecialContent
mContent
&
&
(
(
mContent
-
>
IsText
(
)
&
&
!
mContent
-
>
IsEditable
(
)
)
|
|
(
!
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
)
)
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
OtherBlockBoundary
mContent
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
)
)
;
MOZ_ASSERT_IF
(
mReason
=
=
WSType
:
:
CurrentBlockBoundary
!
mContent
|
|
!
mContent
-
>
GetParentElement
(
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
)
|
|
HTMLEditUtils
:
:
IsBlockElement
(
*
mContent
-
>
GetParentElement
(
)
)
|
|
!
mContent
-
>
GetParentElement
(
)
-
>
IsEditable
(
)
)
;
#
endif
}
nsIContent
*
GetContent
(
)
const
{
return
mContent
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Element
*
ElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsElement
(
)
)
;
return
mContent
-
>
AsElement
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
HTMLBRElement
*
BRElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
return
static_cast
<
dom
:
:
HTMLBRElement
*
>
(
mContent
.
get
(
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Text
*
TextPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mContent
-
>
IsText
(
)
)
;
return
mContent
-
>
AsText
(
)
;
}
bool
IsContentEditable
(
)
const
{
return
mContent
&
&
mContent
-
>
IsEditable
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
uint32_t
Offset
(
)
const
{
NS_ASSERTION
(
mOffset
.
isSome
(
)
"
Retrieved
non
-
meaningful
offset
"
)
;
return
mOffset
.
valueOr
(
0
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMPoint
Point
(
)
const
{
NS_ASSERTION
(
mOffset
.
isSome
(
)
"
Retrieved
non
-
meaningful
point
"
)
;
return
EditorDOMPoint
(
mContent
mOffset
.
valueOr
(
0
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorRawDOMPoint
RawPoint
(
)
const
{
NS_ASSERTION
(
mOffset
.
isSome
(
)
"
Retrieved
non
-
meaningful
raw
point
"
)
;
return
EditorRawDOMPoint
(
mContent
mOffset
.
valueOr
(
0
)
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMPoint
PointAtContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
return
EditorDOMPoint
(
mContent
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorRawDOMPoint
RawPointAtContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
return
EditorRawDOMPoint
(
mContent
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorDOMPoint
PointAfterContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
return
mContent
?
EditorDOMPoint
:
:
After
(
mContent
)
:
EditorDOMPoint
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
EditorRawDOMPoint
RawPointAfterContent
(
)
const
{
MOZ_ASSERT
(
mContent
)
;
return
mContent
?
EditorRawDOMPoint
:
:
After
(
mContent
)
:
EditorRawDOMPoint
(
)
;
}
bool
ReachedSpecialContent
(
)
const
{
return
mReason
=
=
WSType
:
:
SpecialContent
;
}
bool
InNormalWhiteSpacesOrText
(
)
const
{
return
mReason
=
=
WSType
:
:
NormalWhiteSpaces
|
|
mReason
=
=
WSType
:
:
NormalText
;
}
bool
InNormalWhiteSpaces
(
)
const
{
return
mReason
=
=
WSType
:
:
NormalWhiteSpaces
;
}
bool
InNormalText
(
)
const
{
return
mReason
=
=
WSType
:
:
NormalText
;
}
bool
ReachedBRElement
(
)
const
{
return
mReason
=
=
WSType
:
:
BRElement
;
}
bool
ReachedHRElement
(
)
const
{
return
mContent
&
&
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
hr
)
;
}
bool
ReachedBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
ReachedCurrentBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
;
}
bool
ReachedOtherBlockElement
(
)
const
{
return
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
ReachedSomething
(
)
const
{
return
!
InNormalWhiteSpacesOrText
(
)
;
}
private
:
nsCOMPtr
<
nsIContent
>
mContent
;
Maybe
<
uint32_t
>
mOffset
;
WSType
mReason
;
}
;
class
MOZ_STACK_CLASS
WSRunScanner
{
public
:
using
WSType
=
WSScanResult
:
:
WSType
;
template
<
typename
PT
typename
CT
>
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
;
template
<
typename
PT
typename
CT
>
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
)
:
WSRunScanner
(
aHTMLEditor
aScanStartPoint
aScanStartPoint
)
{
}
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
nsINode
*
aScanStartNode
int32_t
aScanStartOffset
nsINode
*
aScanEndNode
int32_t
aScanEndOffset
)
:
WSRunScanner
(
aHTMLEditor
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
EditorRawDOMPoint
(
aScanEndNode
aScanEndOffset
)
)
{
}
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
nsINode
*
aScanStartNode
int32_t
aScanStartOffset
)
:
WSRunScanner
(
aHTMLEditor
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
)
{
}
template
<
typename
PT
typename
CT
>
WSScanResult
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
static
WSScanResult
ScanNextVisibleNodeOrBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
WSRunScanner
(
&
aHTMLEditor
aPoint
)
.
ScanNextVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
static
WSScanResult
ScanPreviousVisibleNodeOrBlockBoundary
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
WSRunScanner
(
&
aHTMLEditor
aPoint
)
.
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
aPoint
)
;
}
template
<
typename
PT
typename
CT
>
static
EditorDOMPointInText
GetInclusiveNextEditableCharPoint
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPoint
.
ContainerAsText
(
)
)
)
{
return
EditorDOMPointInText
(
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
)
;
}
WSRunScanner
scanner
(
&
aHTMLEditor
aPoint
)
;
return
scanner
.
GetInclusiveNextEditableCharPoint
(
aPoint
)
;
}
template
<
typename
PT
typename
CT
>
static
EditorDOMPointInText
GetPreviousEditableCharPoint
(
const
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
&
&
HTMLEditUtils
:
:
IsSimplyEditableNode
(
*
aPoint
.
ContainerAsText
(
)
)
)
{
return
EditorDOMPointInText
(
aPoint
.
ContainerAsText
(
)
aPoint
.
Offset
(
)
-
1
)
;
}
WSRunScanner
scanner
(
&
aHTMLEditor
aPoint
)
;
return
scanner
.
GetPreviousEditableCharPoint
(
aPoint
)
;
}
nsIContent
*
GetStartReasonContent
(
)
const
{
return
mStart
.
GetReasonContent
(
)
;
}
nsIContent
*
GetEndReasonContent
(
)
const
{
return
mEnd
.
GetReasonContent
(
)
;
}
bool
StartsFromNormalText
(
)
const
{
return
mStart
.
IsNormalText
(
)
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
mStart
.
IsSpecialContent
(
)
;
}
bool
StartsFromBRElement
(
)
const
{
return
mStart
.
IsBRElement
(
)
;
}
bool
StartsFromCurrentBlockBoundary
(
)
const
{
return
mStart
.
IsCurrentBlockBoundary
(
)
;
}
bool
StartsFromOtherBlockElement
(
)
const
{
return
mStart
.
IsOtherBlockBoundary
(
)
;
}
bool
StartsFromBlockBoundary
(
)
const
{
return
mStart
.
IsBlockBoundary
(
)
;
}
bool
StartsFromHardLineBreak
(
)
const
{
return
mStart
.
IsHardLineBreak
(
)
;
}
bool
EndsByNormalText
(
)
const
{
return
mEnd
.
IsNormalText
(
)
;
}
bool
EndsBySpecialContent
(
)
const
{
return
mEnd
.
IsSpecialContent
(
)
;
}
bool
EndsByBRElement
(
)
const
{
return
mEnd
.
IsBRElement
(
)
;
}
bool
EndsByCurrentBlockBoundary
(
)
const
{
return
mEnd
.
IsCurrentBlockBoundary
(
)
;
}
bool
EndsByOtherBlockElement
(
)
const
{
return
mEnd
.
IsOtherBlockBoundary
(
)
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
mEnd
.
IsBlockBoundary
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Element
*
StartReasonOtherBlockElementPtr
(
)
const
{
return
mStart
.
OtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
HTMLBRElement
*
StartReasonBRElementPtr
(
)
const
{
return
mStart
.
BRElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Element
*
EndReasonOtherBlockElementPtr
(
)
const
{
return
mEnd
.
OtherBlockElementPtr
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
HTMLBRElement
*
EndReasonBRElementPtr
(
)
const
{
return
mEnd
.
BRElementPtr
(
)
;
}
dom
:
:
Element
*
GetEditingHost
(
)
const
{
return
mEditingHost
;
}
protected
:
using
EditorType
=
EditorBase
:
:
EditorType
;
struct
MOZ_STACK_CLASS
WSFragment
final
{
nsCOMPtr
<
nsINode
>
mStartNode
;
nsCOMPtr
<
nsINode
>
mEndNode
;
int32_t
mStartOffset
;
int32_t
mEndOffset
;
WSFragment
(
)
:
mStartOffset
(
0
)
mEndOffset
(
0
)
mLeftWSType
(
WSType
:
:
NotInitialized
)
mRightWSType
(
WSType
:
:
NotInitialized
)
mIsVisible
(
Visible
:
:
No
)
mIsStartOfHardLine
(
StartOfHardLine
:
:
No
)
mIsEndOfHardLine
(
EndOfHardLine
:
:
No
)
{
}
EditorDOMPoint
StartPoint
(
)
const
{
return
EditorDOMPoint
(
mStartNode
mStartOffset
)
;
}
EditorDOMPoint
EndPoint
(
)
const
{
return
EditorDOMPoint
(
mEndNode
mEndOffset
)
;
}
EditorRawDOMPoint
RawStartPoint
(
)
const
{
return
EditorRawDOMPoint
(
mStartNode
mStartOffset
)
;
}
EditorRawDOMPoint
RawEndPoint
(
)
const
{
return
EditorRawDOMPoint
(
mEndNode
mEndOffset
)
;
}
enum
class
Visible
:
bool
{
No
Yes
}
;
enum
class
StartOfHardLine
:
bool
{
No
Yes
}
;
enum
class
EndOfHardLine
:
bool
{
No
Yes
}
;
void
MarkAsVisible
(
)
{
mIsVisible
=
Visible
:
:
Yes
;
}
void
MarkAsStartOfHardLine
(
)
{
mIsStartOfHardLine
=
StartOfHardLine
:
:
Yes
;
}
void
MarkAsEndOfHardLine
(
)
{
mIsEndOfHardLine
=
EndOfHardLine
:
:
Yes
;
}
bool
IsVisible
(
)
const
{
return
mIsVisible
=
=
Visible
:
:
Yes
;
}
bool
IsStartOfHardLine
(
)
const
{
return
mIsStartOfHardLine
=
=
StartOfHardLine
:
:
Yes
;
}
bool
IsMiddleOfHardLine
(
)
const
{
return
!
IsStartOfHardLine
(
)
&
&
!
IsEndOfHardLine
(
)
;
}
bool
IsEndOfHardLine
(
)
const
{
return
mIsEndOfHardLine
=
=
EndOfHardLine
:
:
Yes
;
}
bool
IsVisibleAndMiddleOfHardLine
(
)
const
{
return
IsVisible
(
)
&
&
IsMiddleOfHardLine
(
)
;
}
void
SetStartFrom
(
WSType
aLeftWSType
)
{
mLeftWSType
=
aLeftWSType
;
}
void
SetStartFromLeadingWhiteSpaces
(
)
{
mLeftWSType
=
WSType
:
:
LeadingWhiteSpaces
;
}
void
SetStartFromNormalWhiteSpaces
(
)
{
mLeftWSType
=
WSType
:
:
NormalWhiteSpaces
;
}
bool
StartsFromNormalText
(
)
const
{
return
mLeftWSType
=
=
WSType
:
:
NormalText
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
mLeftWSType
=
=
WSType
:
:
SpecialContent
;
}
void
SetEndBy
(
WSType
aRightWSType
)
{
mRightWSType
=
aRightWSType
;
}
void
SetEndByNormalWiteSpaces
(
)
{
mRightWSType
=
WSType
:
:
NormalWhiteSpaces
;
}
void
SetEndByTrailingWhiteSpaces
(
)
{
mRightWSType
=
WSType
:
:
TrailingWhiteSpaces
;
}
bool
EndsByNormalText
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
NormalText
;
}
bool
EndsByTrailingWhiteSpaces
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
TrailingWhiteSpaces
;
}
bool
EndsBySpecialContent
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
SpecialContent
;
}
bool
EndsByBRElement
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
BRElement
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
mRightWSType
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mRightWSType
=
=
WSType
:
:
OtherBlockBoundary
;
}
enum
class
PointPosition
{
BeforeStartOfFragment
StartOfFragment
MiddleOfFragment
EndOfFragment
AfterEndOfFragment
NotInSameDOMTree
}
;
template
<
typename
EditorDOMPointType
>
PointPosition
ComparePoint
(
const
EditorDOMPointType
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
const
EditorRawDOMPoint
start
=
RawStartPoint
(
)
;
if
(
start
=
=
aPoint
)
{
return
PointPosition
:
:
StartOfFragment
;
}
const
EditorRawDOMPoint
end
=
RawEndPoint
(
)
;
if
(
end
=
=
aPoint
)
{
return
PointPosition
:
:
EndOfFragment
;
}
const
bool
startIsBeforePoint
=
start
.
IsBefore
(
aPoint
)
;
const
bool
pointIsBeforeEnd
=
aPoint
.
IsBefore
(
end
)
;
if
(
startIsBeforePoint
&
&
pointIsBeforeEnd
)
{
return
PointPosition
:
:
MiddleOfFragment
;
}
if
(
startIsBeforePoint
)
{
return
PointPosition
:
:
AfterEndOfFragment
;
}
if
(
pointIsBeforeEnd
)
{
return
PointPosition
:
:
BeforeStartOfFragment
;
}
return
PointPosition
:
:
NotInSameDOMTree
;
}
private
:
WSType
mLeftWSType
mRightWSType
;
Visible
mIsVisible
;
StartOfHardLine
mIsStartOfHardLine
;
EndOfHardLine
mIsEndOfHardLine
;
}
;
using
PointPosition
=
WSFragment
:
:
PointPosition
;
using
WSFragmentArray
=
AutoTArray
<
WSFragment
3
>
;
const
WSFragmentArray
&
WSFragmentArrayRef
(
)
const
{
const_cast
<
WSRunScanner
*
>
(
this
)
-
>
EnsureWSFragments
(
)
;
return
mFragments
;
}
template
<
typename
PT
typename
CT
>
const
WSFragment
*
FindNearestFragment
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aForward
)
const
{
WSFragmentArray
:
:
index_type
index
=
FindNearestFragmentIndex
(
aPoint
aForward
)
;
if
(
index
=
=
WSFragmentArray
:
:
NoIndex
)
{
return
nullptr
;
}
return
&
mFragments
[
index
]
;
}
template
<
typename
PT
typename
CT
>
WSFragmentArray
:
:
index_type
FindNearestFragmentIndex
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aForward
)
const
;
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
GetInclusiveNextEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
GetPreviousEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
;
EditorDOMPointInText
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
)
const
;
EditorDOMPointInText
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
)
const
;
nsresult
GetWSNodes
(
)
;
nsIContent
*
GetEditableBlockParentOrTopmotEditableInlineContent
(
nsIContent
*
aContent
)
const
;
EditorDOMPointInText
GetPreviousCharPointFromPointInText
(
const
EditorDOMPointInText
&
aPoint
)
const
;
char16_t
GetCharAt
(
dom
:
:
Text
*
aTextNode
int32_t
aOffset
)
const
;
class
MOZ_STACK_CLASS
BoundaryData
final
{
public
:
BoundaryData
(
)
:
mReason
(
WSType
:
:
NotInitialized
)
{
}
template
<
typename
EditorDOMPointType
>
BoundaryData
(
const
EditorDOMPointType
&
aPoint
nsIContent
&
aReasonContent
WSType
aReason
)
:
mReasonContent
(
&
aReasonContent
)
mPoint
(
aPoint
)
mReason
(
aReason
)
{
}
bool
Initialized
(
)
const
{
return
mReasonContent
&
&
mPoint
.
IsSet
(
)
;
}
nsIContent
*
GetReasonContent
(
)
const
{
return
mReasonContent
;
}
const
EditorDOMPoint
&
PointRef
(
)
const
{
return
mPoint
;
}
WSType
RawReason
(
)
const
{
return
mReason
;
}
bool
IsNormalText
(
)
const
{
return
mReason
=
=
WSType
:
:
NormalText
;
}
bool
IsSpecialContent
(
)
const
{
return
mReason
=
=
WSType
:
:
SpecialContent
;
}
bool
IsBRElement
(
)
const
{
return
mReason
=
=
WSType
:
:
BRElement
;
}
bool
IsCurrentBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
;
}
bool
IsOtherBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
IsBlockBoundary
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
;
}
bool
IsHardLineBreak
(
)
const
{
return
mReason
=
=
WSType
:
:
CurrentBlockBoundary
|
|
mReason
=
=
WSType
:
:
OtherBlockBoundary
|
|
mReason
=
=
WSType
:
:
BRElement
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
Element
*
OtherBlockElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mReasonContent
-
>
IsElement
(
)
)
;
return
mReasonContent
-
>
AsElement
(
)
;
}
MOZ_NEVER_INLINE_DEBUG
dom
:
:
HTMLBRElement
*
BRElementPtr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mReasonContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
;
return
static_cast
<
dom
:
:
HTMLBRElement
*
>
(
mReasonContent
.
get
(
)
)
;
}
private
:
nsCOMPtr
<
nsIContent
>
mReasonContent
;
EditorDOMPoint
mPoint
;
WSType
mReason
;
}
;
class
MOZ_STACK_CLASS
NoBreakingSpaceData
final
{
public
:
enum
class
Scanning
{
Forward
Backward
}
;
void
NotifyNBSP
(
const
EditorDOMPointInText
&
aPoint
Scanning
aScanningDirection
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aPoint
.
IsCharNBSP
(
)
)
;
if
(
!
mFirst
.
IsSet
(
)
|
|
aScanningDirection
=
=
Scanning
:
:
Backward
)
{
mFirst
=
aPoint
;
}
if
(
!
mLast
.
IsSet
(
)
|
|
aScanningDirection
=
=
Scanning
:
:
Forward
)
{
mLast
=
aPoint
;
}
}
const
EditorDOMPointInText
&
FirstPointRef
(
)
const
{
return
mFirst
;
}
const
EditorDOMPointInText
&
LastPointRef
(
)
const
{
return
mLast
;
}
bool
FoundNBSP
(
)
const
{
MOZ_ASSERT
(
mFirst
.
IsSet
(
)
=
=
mLast
.
IsSet
(
)
)
;
return
mFirst
.
IsSet
(
)
;
}
private
:
EditorDOMPointInText
mFirst
;
EditorDOMPointInText
mLast
;
}
;
class
MOZ_STACK_CLASS
TextFragmentData
final
{
public
:
TextFragmentData
(
)
=
delete
;
TextFragmentData
(
const
BoundaryData
&
aStartBoundaryData
const
BoundaryData
&
aEndBoundaryData
const
NoBreakingSpaceData
&
aNBSPData
bool
aIsPreformatted
)
:
mStart
(
aStartBoundaryData
)
mEnd
(
aEndBoundaryData
)
mNBSPData
(
aNBSPData
)
mIsPreformatted
(
aIsPreformatted
)
{
}
void
InitializeWSFragmentArray
(
WSFragmentArray
&
aFragments
)
const
;
bool
StartsFromNormalText
(
)
const
{
return
mStart
.
IsNormalText
(
)
;
}
bool
StartsFromSpecialContent
(
)
const
{
return
mStart
.
IsSpecialContent
(
)
;
}
bool
StartsFromHardLineBreak
(
)
const
{
return
mStart
.
IsHardLineBreak
(
)
;
}
bool
EndsByNormalText
(
)
const
{
return
mEnd
.
IsNormalText
(
)
;
}
bool
EndsBySpecialContent
(
)
const
{
return
mEnd
.
IsSpecialContent
(
)
;
}
bool
EndsByBRElement
(
)
const
{
return
mEnd
.
IsBRElement
(
)
;
}
bool
EndsByBlockBoundary
(
)
const
{
return
mEnd
.
IsBlockBoundary
(
)
;
}
template
<
typename
EditorDOMRangeType
>
EditorDOMRangeType
GetInvisibleLeadingWhiteSpaceRange
(
)
const
;
template
<
typename
EditorDOMRangeType
>
EditorDOMRangeType
GetInvisibleTrailingWhiteSpaceRange
(
)
const
;
Maybe
<
WSFragment
>
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
const
;
private
:
BoundaryData
mStart
;
BoundaryData
mEnd
;
NoBreakingSpaceData
mNBSPData
;
bool
mIsPreformatted
;
}
;
void
EnsureWSFragments
(
)
;
template
<
typename
EditorDOMPointType
>
void
InitializeRangeStart
(
const
EditorDOMPointType
&
aPoint
const
nsIContent
&
aEditableBlockParentOrTopmostEditableInlineContent
)
;
template
<
typename
EditorDOMPointType
>
void
InitializeRangeEnd
(
const
EditorDOMPointType
&
aPoint
const
nsIContent
&
aEditableBlockParentOrTopmostEditableInlineContent
)
;
template
<
typename
EditorDOMPointType
>
bool
InitializeRangeStartWithTextNode
(
const
EditorDOMPointType
&
aPoint
)
;
template
<
typename
EditorDOMPointType
>
bool
InitializeRangeEndWithTextNode
(
const
EditorDOMPointType
&
aPoint
)
;
EditorDOMPoint
mScanStartPoint
;
EditorDOMPoint
mScanEndPoint
;
RefPtr
<
dom
:
:
Element
>
mEditingHost
;
bool
mPRE
;
const
HTMLEditor
*
mHTMLEditor
;
protected
:
BoundaryData
mStart
;
BoundaryData
mEnd
;
NoBreakingSpaceData
mNBSPData
;
private
:
WSFragmentArray
mFragments
;
}
;
class
MOZ_STACK_CLASS
WSRunObject
final
:
public
WSRunScanner
{
protected
:
typedef
EditorBase
:
:
AutoTransactionsConserveSelection
AutoTransactionsConserveSelection
;
public
:
enum
BlockBoundary
{
kBeforeBlock
kBlockStart
kBlockEnd
kAfterBlock
}
;
template
<
typename
PT
typename
CT
>
MOZ_CAN_RUN_SCRIPT
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
;
template
<
typename
PT
typename
CT
>
MOZ_CAN_RUN_SCRIPT
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
)
:
WSRunObject
(
aHTMLEditor
aScanStartPoint
aScanStartPoint
)
{
}
MOZ_CAN_RUN_SCRIPT
WSRunObject
(
HTMLEditor
&
aHTMLEditor
nsINode
*
aScanStartNode
int32_t
aScanStartOffset
nsINode
*
aScanEndNode
int32_t
aScanEndOffset
)
:
WSRunObject
(
aHTMLEditor
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
EditorRawDOMPoint
(
aScanEndNode
aScanEndOffset
)
)
{
}
MOZ_CAN_RUN_SCRIPT
WSRunObject
(
HTMLEditor
&
aHTMLEditor
nsINode
*
aScanStartNode
int32_t
aScanStartOffset
)
:
WSRunObject
(
aHTMLEditor
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
EditorRawDOMPoint
(
aScanStartNode
aScanStartOffset
)
)
{
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsresult
DeleteInvisibleASCIIWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsresult
PrepareToJoinBlocks
(
HTMLEditor
&
aHTMLEditor
dom
:
:
Element
&
aLeftBlockElement
dom
:
:
Element
&
aRightBlockElement
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
PrepareToDeleteRange
(
HTMLEditor
&
aHTMLEditor
EditorDOMPoint
*
aStartPoint
EditorDOMPoint
*
aEndPoint
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
PrepareToDeleteNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
*
aContent
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
PrepareToSplitAcrossBlocks
(
HTMLEditor
&
aHTMLEditor
nsCOMPtr
<
nsINode
>
*
aSplitNode
int32_t
*
aSplitOffset
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
dom
:
:
Element
>
InsertBreak
(
dom
:
:
Selection
&
aSelection
const
EditorDOMPoint
&
aPointToInsert
nsIEditor
:
:
EDirection
aSelect
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InsertText
(
dom
:
:
Document
&
aDocument
const
nsAString
&
aStringToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteWSBackward
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteWSForward
(
)
;
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsresult
NormalizeWhiteSpacesAround
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointType
&
aSacnStartPoint
)
;
protected
:
MOZ_CAN_RUN_SCRIPT
nsresult
PrepareToDeleteRangePriv
(
WSRunObject
*
aEndObject
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PrepareToSplitAcrossBlocksPriv
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
ReplaceASCIIWhiteSpacesWithOneNBSP
(
const
EditorDOMPointInText
&
aAtFirstASCIIWhiteSpace
const
EditorDOMPointInText
&
aEndOfCollapsibleASCIIWhiteSpaces
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
NormalizeWhiteSpacesAtEndOf
(
const
WSFragment
&
aRun
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
const
WSFragment
&
aRun
const
EditorDOMPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeReplaceInclusiveNextNBSPWithASCIIWhiteSpace
(
const
WSFragment
&
aRun
const
EditorDOMPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
DeleteInvisibleASCIIWhiteSpacesInternal
(
)
;
HTMLEditor
&
mHTMLEditor
;
}
;
}
#
endif
