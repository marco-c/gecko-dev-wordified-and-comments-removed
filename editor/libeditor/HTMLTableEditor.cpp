#
include
<
stdio
.
h
>
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsITableEditor
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nscore
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
dom
;
class
MOZ_STACK_CLASS
AutoSelectionSetterAfterTableEdit
final
{
private
:
nsCOMPtr
<
nsITableEditor
>
mTableEditor
;
nsCOMPtr
<
nsIDOMElement
>
mTable
;
int32_t
mCol
mRow
mDirection
mSelected
;
public
:
AutoSelectionSetterAfterTableEdit
(
nsITableEditor
*
aTableEditor
nsIDOMElement
*
aTable
int32_t
aRow
int32_t
aCol
int32_t
aDirection
bool
aSelected
)
:
mTableEditor
(
aTableEditor
)
mTable
(
aTable
)
mCol
(
aCol
)
mRow
(
aRow
)
mDirection
(
aDirection
)
mSelected
(
aSelected
)
{
}
~
AutoSelectionSetterAfterTableEdit
(
)
{
if
(
mTableEditor
)
{
mTableEditor
-
>
SetSelectionAfterTableEdit
(
mTable
mRow
mCol
mDirection
mSelected
)
;
}
}
void
CancelSetCaret
(
)
{
mTableEditor
=
nullptr
;
mTable
=
nullptr
;
}
}
;
NS_IMETHODIMP
HTMLEditor
:
:
InsertCell
(
nsIDOMElement
*
aCell
int32_t
aRowSpan
int32_t
aColSpan
bool
aAfter
bool
aIsHeader
nsIDOMElement
*
*
aNewCell
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
if
(
aNewCell
)
*
aNewCell
=
nullptr
;
nsCOMPtr
<
nsIDOMNode
>
cellParent
;
nsresult
rv
=
aCell
-
>
GetParentNode
(
getter_AddRefs
(
cellParent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cellParent
NS_ERROR_NULL_POINTER
)
;
int32_t
cellOffset
=
GetChildOffset
(
aCell
cellParent
)
;
nsCOMPtr
<
nsIDOMElement
>
newCell
;
rv
=
CreateElementWithDefaults
(
aIsHeader
?
NS_LITERAL_STRING
(
"
th
"
)
:
NS_LITERAL_STRING
(
"
tb
"
)
getter_AddRefs
(
newCell
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
newCell
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNewCell
)
{
*
aNewCell
=
newCell
.
get
(
)
;
NS_ADDREF
(
*
aNewCell
)
;
}
if
(
aRowSpan
>
1
)
{
nsAutoString
newRowSpan
;
newRowSpan
.
AppendInt
(
aRowSpan
10
)
;
newCell
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
rowspan
"
)
newRowSpan
)
;
}
if
(
aColSpan
>
1
)
{
nsAutoString
newColSpan
;
newColSpan
.
AppendInt
(
aColSpan
10
)
;
newCell
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
colspan
"
)
newColSpan
)
;
}
if
(
aAfter
)
cellOffset
+
+
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
return
InsertNode
(
newCell
cellParent
cellOffset
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetColSpan
(
nsIDOMElement
*
aCell
int32_t
aColSpan
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
nsAutoString
newSpan
;
newSpan
.
AppendInt
(
aColSpan
10
)
;
return
SetAttribute
(
aCell
NS_LITERAL_STRING
(
"
colspan
"
)
newSpan
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetRowSpan
(
nsIDOMElement
*
aCell
int32_t
aRowSpan
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
nsAutoString
newSpan
;
newSpan
.
AppendInt
(
aRowSpan
10
)
;
return
SetAttribute
(
aCell
NS_LITERAL_STRING
(
"
rowspan
"
)
newSpan
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableCell
(
int32_t
aNumber
bool
aAfter
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
curCell
;
nsCOMPtr
<
nsIDOMNode
>
cellParent
;
int32_t
cellOffset
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
nullptr
getter_AddRefs
(
table
)
getter_AddRefs
(
curCell
)
getter_AddRefs
(
cellParent
)
&
cellOffset
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
int32_t
curStartRowIndex
curStartColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
rv
=
GetCellDataAt
(
table
startRowIndex
startColIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_ERROR_FAILURE
)
;
int32_t
newCellIndex
=
aAfter
?
(
startColIndex
+
colSpan
)
:
startColIndex
;
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
newCellIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
int32_t
i
;
for
(
i
=
0
;
i
<
aNumber
;
i
+
+
)
{
nsCOMPtr
<
nsIDOMElement
>
newCell
;
rv
=
CreateElementWithDefaults
(
NS_LITERAL_STRING
(
"
td
"
)
getter_AddRefs
(
newCell
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
newCell
)
{
if
(
aAfter
)
{
cellOffset
+
+
;
}
rv
=
InsertNode
(
newCell
cellParent
cellOffset
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFirstRow
(
nsIDOMElement
*
aTableElement
nsIDOMNode
*
*
aRowNode
)
{
NS_ENSURE_TRUE
(
aRowNode
NS_ERROR_NULL_POINTER
)
;
*
aRowNode
=
nullptr
;
NS_ENSURE_TRUE
(
aTableElement
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMElement
>
tableElement
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
aTableElement
getter_AddRefs
(
tableElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
tableElement
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
tableChild
;
rv
=
tableElement
-
>
GetFirstChild
(
getter_AddRefs
(
tableChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
tableChild
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
tableChild
)
;
if
(
content
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
*
aRowNode
=
tableChild
;
NS_ADDREF
(
*
aRowNode
)
;
return
NS_OK
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
)
)
{
nsCOMPtr
<
nsIDOMNode
>
rowNode
;
rv
=
tableChild
-
>
GetFirstChild
(
getter_AddRefs
(
rowNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
rowNode
&
&
!
HTMLEditUtils
:
:
IsTableRow
(
rowNode
)
)
{
nsCOMPtr
<
nsIDOMNode
>
nextNode
;
rv
=
rowNode
-
>
GetNextSibling
(
getter_AddRefs
(
nextNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rowNode
=
nextNode
;
}
if
(
rowNode
)
{
*
aRowNode
=
rowNode
.
get
(
)
;
NS_ADDREF
(
*
aRowNode
)
;
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIDOMNode
>
nextChild
;
rv
=
tableChild
-
>
GetNextSibling
(
getter_AddRefs
(
nextChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
tableChild
=
nextChild
;
}
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetNextRow
(
nsIDOMNode
*
aCurrentRowNode
nsIDOMNode
*
*
aRowNode
)
{
NS_ENSURE_TRUE
(
aRowNode
NS_ERROR_NULL_POINTER
)
;
*
aRowNode
=
nullptr
;
NS_ENSURE_TRUE
(
aCurrentRowNode
NS_ERROR_NULL_POINTER
)
;
if
(
!
HTMLEditUtils
:
:
IsTableRow
(
aCurrentRowNode
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDOMNode
>
nextRow
;
nsresult
rv
=
aCurrentRowNode
-
>
GetNextSibling
(
getter_AddRefs
(
nextRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
nextNode
;
while
(
nextRow
&
&
!
HTMLEditUtils
:
:
IsTableRow
(
nextRow
)
)
{
rv
=
nextRow
-
>
GetNextSibling
(
getter_AddRefs
(
nextNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nextRow
=
nextNode
;
}
if
(
nextRow
)
{
*
aRowNode
=
nextRow
.
get
(
)
;
NS_ADDREF
(
*
aRowNode
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMNode
>
rowParent
;
rv
=
aCurrentRowNode
-
>
GetParentNode
(
getter_AddRefs
(
rowParent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
rowParent
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
parentSibling
;
rv
=
rowParent
-
>
GetNextSibling
(
getter_AddRefs
(
parentSibling
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
parentSibling
)
{
rv
=
parentSibling
-
>
GetFirstChild
(
getter_AddRefs
(
nextRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
nextRow
&
&
!
HTMLEditUtils
:
:
IsTableRow
(
nextRow
)
)
{
rv
=
nextRow
-
>
GetNextSibling
(
getter_AddRefs
(
nextNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nextRow
=
nextNode
;
}
if
(
nextRow
)
{
*
aRowNode
=
nextRow
.
get
(
)
;
NS_ADDREF
(
*
aRowNode
)
;
return
NS_OK
;
}
rv
=
parentSibling
-
>
GetNextSibling
(
getter_AddRefs
(
nextNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
parentSibling
=
nextNode
;
}
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
nsresult
HTMLEditor
:
:
GetLastCellInRow
(
nsIDOMNode
*
aRowNode
nsIDOMNode
*
*
aCellNode
)
{
NS_ENSURE_TRUE
(
aCellNode
NS_ERROR_NULL_POINTER
)
;
*
aCellNode
=
nullptr
;
NS_ENSURE_TRUE
(
aRowNode
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMNode
>
rowChild
;
nsresult
rv
=
aRowNode
-
>
GetLastChild
(
getter_AddRefs
(
rowChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
rowChild
&
&
!
HTMLEditUtils
:
:
IsTableCell
(
rowChild
)
)
{
nsCOMPtr
<
nsIDOMNode
>
previousChild
;
rv
=
rowChild
-
>
GetPreviousSibling
(
getter_AddRefs
(
previousChild
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rowChild
=
previousChild
;
}
if
(
rowChild
)
{
*
aCellNode
=
rowChild
.
get
(
)
;
NS_ADDREF
(
*
aCellNode
)
;
return
NS_OK
;
}
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableColumn
(
int32_t
aNumber
bool
aAfter
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
curCell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
curCell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
int32_t
curStartRowIndex
curStartColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
rv
=
GetCellDataAt
(
table
startRowIndex
startColIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_ERROR_FAILURE
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertNode
nsIEditor
:
:
eNext
)
;
if
(
aAfter
)
{
startColIndex
+
=
actualColSpan
;
if
(
colSpan
=
=
0
)
SetColSpan
(
curCell
actualColSpan
)
;
}
int32_t
rowCount
colCount
rowIndex
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousRow
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
if
(
startColIndex
>
=
colCount
)
NormalizeTable
(
table
)
;
nsCOMPtr
<
nsIDOMNode
>
rowNode
;
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
+
)
{
if
(
startColIndex
<
colCount
)
{
rv
=
GetCellDataAt
(
table
rowIndex
startColIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
curCell
)
{
if
(
curStartColIndex
<
startColIndex
)
{
if
(
colSpan
>
0
)
SetColSpan
(
curCell
colSpan
+
aNumber
)
;
}
else
{
selection
-
>
Collapse
(
curCell
0
)
;
rv
=
InsertTableCell
(
aNumber
false
)
;
}
}
}
else
{
if
(
!
rowIndex
)
{
rv
=
GetFirstRow
(
table
.
get
(
)
getter_AddRefs
(
rowNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsCOMPtr
<
nsIDOMNode
>
nextRow
;
rv
=
GetNextRow
(
rowNode
.
get
(
)
getter_AddRefs
(
nextRow
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rowNode
=
nextRow
;
}
if
(
rowNode
)
{
nsCOMPtr
<
nsIDOMNode
>
lastCell
;
rv
=
GetLastCellInRow
(
rowNode
getter_AddRefs
(
lastCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
lastCell
NS_ERROR_FAILURE
)
;
curCell
=
do_QueryInterface
(
lastCell
)
;
if
(
curCell
)
{
selection
-
>
Collapse
(
curCell
0
)
;
rv
=
InsertTableCell
(
aNumber
true
)
;
}
}
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableRow
(
int32_t
aNumber
bool
aAfter
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
curCell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
nullptr
getter_AddRefs
(
table
)
getter_AddRefs
(
curCell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
int32_t
curStartRowIndex
curStartColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
rv
=
GetCellDataAt
(
table
startRowIndex
startColIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
curCell
NS_ERROR_FAILURE
)
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertNode
nsIEditor
:
:
eNext
)
;
if
(
aAfter
)
{
startRowIndex
+
=
actualRowSpan
;
if
(
rowSpan
=
=
0
)
SetRowSpan
(
curCell
actualRowSpan
)
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
nsCOMPtr
<
nsIDOMElement
>
cellForRowParent
;
int32_t
cellsInRow
=
0
;
if
(
startRowIndex
<
rowCount
)
{
int32_t
colIndex
=
0
;
while
(
NS_OK
=
=
GetCellDataAt
(
table
startRowIndex
colIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
)
{
if
(
curCell
)
{
if
(
curStartRowIndex
<
startRowIndex
)
{
if
(
rowSpan
>
0
)
SetRowSpan
(
curCell
rowSpan
+
aNumber
)
;
}
else
{
cellsInRow
+
=
actualColSpan
;
if
(
!
cellForRowParent
)
cellForRowParent
=
curCell
;
}
colIndex
+
=
actualColSpan
;
}
else
colIndex
+
+
;
}
}
else
{
cellsInRow
=
colCount
;
int32_t
lastRow
=
rowCount
-
1
;
int32_t
tempColIndex
=
0
;
while
(
NS_OK
=
=
GetCellDataAt
(
table
lastRow
tempColIndex
getter_AddRefs
(
curCell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
)
{
if
(
rowSpan
=
=
0
)
cellsInRow
-
=
actualColSpan
;
tempColIndex
+
=
actualColSpan
;
if
(
!
cellForRowParent
&
&
curStartRowIndex
=
=
lastRow
)
cellForRowParent
=
curCell
;
}
}
if
(
cellsInRow
>
0
)
{
nsCOMPtr
<
nsIDOMNode
>
parentOfRow
;
int32_t
newRowOffset
;
NS_NAMED_LITERAL_STRING
(
trStr
"
tr
"
)
;
if
(
cellForRowParent
)
{
nsCOMPtr
<
nsIDOMElement
>
parentRow
;
rv
=
GetElementOrParentByTagName
(
trStr
cellForRowParent
getter_AddRefs
(
parentRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parentRow
NS_ERROR_NULL_POINTER
)
;
parentRow
-
>
GetParentNode
(
getter_AddRefs
(
parentOfRow
)
)
;
NS_ENSURE_TRUE
(
parentOfRow
NS_ERROR_NULL_POINTER
)
;
newRowOffset
=
GetChildOffset
(
parentRow
parentOfRow
)
;
if
(
aAfter
&
&
startRowIndex
>
=
rowCount
)
newRowOffset
+
+
;
}
else
return
NS_ERROR_FAILURE
;
for
(
int32_t
row
=
0
;
row
<
aNumber
;
row
+
+
)
{
nsCOMPtr
<
nsIDOMElement
>
newRow
;
rv
=
CreateElementWithDefaults
(
trStr
getter_AddRefs
(
newRow
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ENSURE_TRUE
(
newRow
NS_ERROR_FAILURE
)
;
for
(
int32_t
i
=
0
;
i
<
cellsInRow
;
i
+
+
)
{
nsCOMPtr
<
nsIDOMElement
>
newCell
;
rv
=
CreateElementWithDefaults
(
NS_LITERAL_STRING
(
"
td
"
)
getter_AddRefs
(
newCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
newCell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMNode
>
resultNode
;
rv
=
newRow
-
>
AppendChild
(
newCell
getter_AddRefs
(
resultNode
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
InsertNode
(
newRow
parentOfRow
newRowOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
rv
;
}
nsresult
HTMLEditor
:
:
DeleteTable2
(
nsIDOMElement
*
aTable
Selection
*
aSelection
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
ClearSelection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
AppendNodeToSelectionAsRange
(
aTable
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DeleteSelection
(
nsIEditor
:
:
eNext
nsIEditor
:
:
eStrip
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTable
(
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
nullptr
nullptr
nullptr
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoEditBatch
beginBatching
(
this
)
;
return
DeleteTable2
(
table
selection
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableCell
(
int32_t
aNumber
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
&
&
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
nsCOMPtr
<
nsIDOMElement
>
firstCell
;
nsCOMPtr
<
nsIDOMRange
>
range
;
rv
=
GetFirstSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
firstCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
firstCell
&
&
rangeCount
>
1
)
{
cell
=
firstCell
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
bool
checkToDeleteRow
=
true
;
bool
checkToDeleteColumn
=
true
;
while
(
cell
)
{
bool
deleteRow
=
false
;
bool
deleteCol
=
false
;
if
(
checkToDeleteRow
)
{
checkToDeleteRow
=
false
;
deleteRow
=
AllCellsInRowSelected
(
table
startRowIndex
colCount
)
;
if
(
deleteRow
)
{
int32_t
nextRow
=
startRowIndex
;
while
(
nextRow
=
=
startRowIndex
)
{
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell
)
break
;
rv
=
GetCellIndexes
(
cell
&
nextRow
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
DeleteRow
(
table
startRowIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
{
startRowIndex
=
nextRow
-
1
;
checkToDeleteRow
=
true
;
}
}
}
if
(
!
deleteRow
)
{
if
(
checkToDeleteColumn
)
{
checkToDeleteColumn
=
false
;
deleteCol
=
AllCellsInColumnSelected
(
table
startColIndex
colCount
)
;
if
(
deleteCol
)
{
int32_t
nextCol
=
startColIndex
;
while
(
nextCol
=
=
startColIndex
)
{
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell
)
break
;
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
nextCol
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
DeleteColumn
(
table
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
{
startColIndex
=
nextCol
-
1
;
checkToDeleteColumn
=
true
;
}
}
}
if
(
!
deleteCol
)
{
nsCOMPtr
<
nsIDOMElement
>
nextCell
;
rv
=
GetNextSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
nextCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
DeleteNode
(
cell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
cell
=
nextCell
;
if
(
cell
)
{
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
}
}
else
for
(
int32_t
i
=
0
;
i
<
aNumber
;
i
+
+
)
{
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
if
(
1
=
=
GetNumberOfCellsInRow
(
table
startRowIndex
)
)
{
nsCOMPtr
<
nsIDOMElement
>
parentRow
;
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
tr
"
)
cell
getter_AddRefs
(
parentRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
parentRow
NS_ERROR_NULL_POINTER
)
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rowCount
=
=
1
)
return
DeleteTable2
(
table
selection
)
;
rv
=
DeleteTableRow
(
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
rv
=
DeleteNode
(
cell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableCellContents
(
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
nsCOMPtr
<
nsIDOMElement
>
firstCell
;
nsCOMPtr
<
nsIDOMRange
>
range
;
rv
=
GetFirstSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
firstCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
firstCell
)
{
cell
=
firstCell
;
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
while
(
cell
)
{
DeleteCellContents
(
cell
)
;
if
(
firstCell
)
{
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
cell
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteCellContents
(
nsIDOMElement
*
aCell
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
nsCOMPtr
<
nsIDOMNode
>
child
;
bool
hasChild
;
aCell
-
>
HasChildNodes
(
&
hasChild
)
;
while
(
hasChild
)
{
aCell
-
>
GetLastChild
(
getter_AddRefs
(
child
)
)
;
nsresult
rv
=
DeleteNode
(
child
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aCell
-
>
HasChildNodes
(
&
hasChild
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableColumn
(
int32_t
aNumber
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowCount
colCount
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
&
&
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startColIndex
=
=
0
&
&
aNumber
>
=
colCount
)
return
DeleteTable2
(
table
selection
)
;
aNumber
=
std
:
:
min
(
aNumber
(
colCount
-
startColIndex
)
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
nsCOMPtr
<
nsIDOMElement
>
firstCell
;
nsCOMPtr
<
nsIDOMRange
>
range
;
rv
=
GetFirstSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
firstCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
firstCell
&
&
rangeCount
>
1
)
{
rv
=
GetCellIndexes
(
firstCell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousRow
false
)
;
if
(
firstCell
&
&
rangeCount
>
1
)
{
cell
=
firstCell
;
while
(
cell
)
{
if
(
cell
!
=
firstCell
)
{
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
nextCol
=
startColIndex
;
while
(
nextCol
=
=
startColIndex
)
{
rv
=
GetNextSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell
)
break
;
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
nextCol
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
DeleteColumn
(
table
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
for
(
int32_t
i
=
0
;
i
<
aNumber
;
i
+
+
)
{
rv
=
DeleteColumn
(
table
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteColumn
(
nsIDOMElement
*
aTable
int32_t
aColIndex
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
int32_t
rowIndex
=
0
;
do
{
nsresult
rv
=
GetCellDataAt
(
aTable
rowIndex
aColIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
{
if
(
startColIndex
<
aColIndex
|
|
colSpan
>
1
|
|
colSpan
=
=
0
)
{
if
(
colSpan
>
0
)
{
NS_ASSERTION
(
(
colSpan
>
1
)
"
Bad
COLSPAN
in
DeleteTableColumn
"
)
;
SetColSpan
(
cell
colSpan
-
1
)
;
}
if
(
startColIndex
=
=
aColIndex
)
{
DeleteCellContents
(
cell
)
;
}
rowIndex
+
=
actualRowSpan
;
}
else
{
if
(
1
=
=
GetNumberOfCellsInRow
(
aTable
rowIndex
)
)
{
nsCOMPtr
<
nsIDOMElement
>
parentRow
;
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
tr
"
)
cell
getter_AddRefs
(
parentRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
parentRow
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
aTable
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rowCount
=
=
1
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
return
DeleteTable2
(
aTable
selection
)
;
}
rv
=
DeleteRow
(
aTable
startRowIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
DeleteNode
(
cell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rowIndex
+
=
actualRowSpan
;
}
}
}
}
while
(
cell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableRow
(
int32_t
aNumber
)
{
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
;
int32_t
rowCount
colCount
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startRowIndex
=
=
0
&
&
aNumber
>
=
rowCount
)
return
DeleteTable2
(
table
selection
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
nsCOMPtr
<
nsIDOMElement
>
firstCell
;
nsCOMPtr
<
nsIDOMRange
>
range
;
rv
=
GetFirstSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
firstCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
firstCell
&
&
rangeCount
>
1
)
{
rv
=
GetCellIndexes
(
firstCell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousRow
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
if
(
firstCell
&
&
rangeCount
>
1
)
{
cell
=
firstCell
;
while
(
cell
)
{
if
(
cell
!
=
firstCell
)
{
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
nextRow
=
startRowIndex
;
while
(
nextRow
=
=
startRowIndex
)
{
rv
=
GetNextSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell
)
break
;
rv
=
GetCellIndexes
(
cell
&
nextRow
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
DeleteRow
(
table
startRowIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
aNumber
=
std
:
:
min
(
aNumber
(
rowCount
-
startRowIndex
)
)
;
for
(
int32_t
i
=
0
;
i
<
aNumber
;
i
+
+
)
{
rv
=
DeleteRow
(
table
startRowIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
startRowIndex
+
+
;
}
rv
=
GetCellAt
(
table
startRowIndex
startColIndex
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell
)
{
break
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteRow
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsCOMPtr
<
nsIDOMElement
>
cellInDeleteRow
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
int32_t
colIndex
=
0
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
nsTArray
<
nsCOMPtr
<
nsIDOMElement
>
>
spanCellList
;
nsTArray
<
int32_t
>
newSpanList
;
int32_t
rowCount
colCount
;
nsresult
rv
=
GetTableSize
(
aTable
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
do
{
if
(
aRowIndex
>
=
rowCount
|
|
colIndex
>
=
colCount
)
break
;
rv
=
GetCellDataAt
(
aTable
aRowIndex
colIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
cell
)
{
if
(
startRowIndex
<
aRowIndex
)
{
if
(
rowSpan
>
0
)
{
spanCellList
.
AppendElement
(
cell
)
;
newSpanList
.
AppendElement
(
std
:
:
max
(
(
aRowIndex
-
startRowIndex
)
actualRowSpan
-
1
)
)
;
}
}
else
{
if
(
rowSpan
>
1
)
{
int32_t
aboveRowToInsertNewCellInto
=
aRowIndex
-
startRowIndex
+
1
;
int32_t
numOfRawSpanRemainingBelow
=
actualRowSpan
-
1
;
rv
=
SplitCellIntoRows
(
aTable
startRowIndex
startColIndex
aboveRowToInsertNewCellInto
numOfRawSpanRemainingBelow
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
cellInDeleteRow
)
cellInDeleteRow
=
cell
;
}
colIndex
+
=
actualColSpan
;
}
}
while
(
cell
)
;
NS_ENSURE_TRUE
(
cellInDeleteRow
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMElement
>
parentRow
;
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
tr
"
)
cellInDeleteRow
getter_AddRefs
(
parentRow
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
parentRow
)
{
rv
=
DeleteNode
(
parentRow
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
uint32_t
i
=
0
n
=
spanCellList
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
nsIDOMElement
*
cellPtr
=
spanCellList
[
i
]
;
if
(
cellPtr
)
{
rv
=
SetRowSpan
(
cellPtr
newSpanList
[
i
]
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTable
(
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
nullptr
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_OK
)
;
rv
=
ClearSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
AppendNodeToSelectionAsRange
(
table
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableCell
(
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
rv
=
ClearSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
AppendNodeToSelectionAsRange
(
cell
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectBlockOfCells
(
nsIDOMElement
*
aStartCell
nsIDOMElement
*
aEndCell
)
{
NS_ENSURE_TRUE
(
aStartCell
&
&
aEndCell
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
NS_NAMED_LITERAL_STRING
(
tableStr
"
table
"
)
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
tableStr
aStartCell
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMElement
>
endTable
;
rv
=
GetElementOrParentByTagName
(
tableStr
aEndCell
getter_AddRefs
(
endTable
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
endTable
NS_ERROR_FAILURE
)
;
if
(
table
!
=
endTable
)
return
NS_OK
;
int32_t
startRowIndex
startColIndex
endRowIndex
endColIndex
;
rv
=
GetCellIndexes
(
aStartCell
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
GetCellIndexes
(
aEndCell
&
endRowIndex
&
endColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
SelectionBatcher
selectionBatcher
(
selection
)
;
int32_t
minColumn
=
std
:
:
min
(
startColIndex
endColIndex
)
;
int32_t
minRow
=
std
:
:
min
(
startRowIndex
endRowIndex
)
;
int32_t
maxColumn
=
std
:
:
max
(
startColIndex
endColIndex
)
;
int32_t
maxRow
=
std
:
:
max
(
startRowIndex
endRowIndex
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
currentRowIndex
currentColIndex
;
nsCOMPtr
<
nsIDOMRange
>
range
;
rv
=
GetFirstSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
=
=
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
{
return
NS_OK
;
}
while
(
cell
)
{
rv
=
GetCellIndexes
(
cell
&
currentRowIndex
&
currentColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
currentRowIndex
<
maxRow
|
|
currentRowIndex
>
maxRow
|
|
currentColIndex
<
maxColumn
|
|
currentColIndex
>
maxColumn
)
{
selection
-
>
RemoveRange
(
range
)
;
mSelectedCellIndex
-
-
;
}
rv
=
GetNextSelectedCell
(
getter_AddRefs
(
range
)
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
for
(
int32_t
row
=
minRow
;
row
<
=
maxRow
;
row
+
+
)
{
for
(
int32_t
col
=
minColumn
;
col
<
=
maxColumn
;
col
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
rv
=
GetCellDataAt
(
table
row
col
getter_AddRefs
(
cell
)
&
currentRowIndex
&
currentColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
if
(
!
isSelected
&
&
cell
&
&
row
=
=
currentRowIndex
&
&
col
=
=
currentColIndex
)
{
rv
=
AppendNodeToSelectionAsRange
(
cell
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
}
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectAllTableCells
(
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
nsCOMPtr
<
nsIDOMElement
>
startCell
=
cell
;
nsCOMPtr
<
nsIDOMElement
>
table
;
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
cell
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
table
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
SelectionBatcher
selectionBatcher
(
selection
)
;
rv
=
ClearSelection
(
)
;
bool
cellSelected
=
false
;
int32_t
rowSpan
colSpan
actualRowSpan
actualColSpan
currentRowIndex
currentColIndex
;
bool
isSelected
;
for
(
int32_t
row
=
0
;
row
<
rowCount
;
row
+
+
)
{
for
(
int32_t
col
=
0
;
col
<
colCount
;
col
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
rv
=
GetCellDataAt
(
table
row
col
getter_AddRefs
(
cell
)
&
currentRowIndex
&
currentColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
if
(
cell
&
&
row
=
=
currentRowIndex
&
&
col
=
=
currentColIndex
)
{
rv
=
AppendNodeToSelectionAsRange
(
cell
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
cellSelected
=
true
;
}
}
}
if
(
!
cellSelected
)
{
return
AppendNodeToSelectionAsRange
(
startCell
)
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableRow
(
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
nsCOMPtr
<
nsIDOMElement
>
startCell
=
cell
;
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SelectionBatcher
selectionBatcher
(
selection
)
;
rv
=
ClearSelection
(
)
;
bool
cellSelected
=
false
;
int32_t
rowSpan
colSpan
actualRowSpan
actualColSpan
currentRowIndex
currentColIndex
;
bool
isSelected
;
for
(
int32_t
col
=
0
;
col
<
colCount
;
col
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
rv
=
GetCellDataAt
(
table
startRowIndex
col
getter_AddRefs
(
cell
)
&
currentRowIndex
&
currentColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
if
(
cell
&
&
currentRowIndex
=
=
startRowIndex
&
&
currentColIndex
=
=
col
)
{
rv
=
AppendNodeToSelectionAsRange
(
cell
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
cellSelected
=
true
;
}
}
if
(
!
cellSelected
)
{
return
AppendNodeToSelectionAsRange
(
startCell
)
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableColumn
(
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
nsCOMPtr
<
nsIDOMElement
>
startCell
=
cell
;
RefPtr
<
Selection
>
selection
;
nsCOMPtr
<
nsIDOMElement
>
table
;
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellContext
(
getter_AddRefs
(
selection
)
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SelectionBatcher
selectionBatcher
(
selection
)
;
rv
=
ClearSelection
(
)
;
bool
cellSelected
=
false
;
int32_t
rowSpan
colSpan
actualRowSpan
actualColSpan
currentRowIndex
currentColIndex
;
bool
isSelected
;
for
(
int32_t
row
=
0
;
row
<
rowCount
;
row
+
=
std
:
:
max
(
actualRowSpan
1
)
)
{
rv
=
GetCellDataAt
(
table
row
startColIndex
getter_AddRefs
(
cell
)
&
currentRowIndex
&
currentColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
if
(
cell
&
&
currentRowIndex
=
=
row
&
&
currentColIndex
=
=
startColIndex
)
{
rv
=
AppendNodeToSelectionAsRange
(
cell
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
cellSelected
=
true
;
}
}
if
(
!
cellSelected
)
{
return
AppendNodeToSelectionAsRange
(
startCell
)
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SplitTableCell
(
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
actualRowSpan
actualColSpan
;
nsresult
rv
=
GetCellContext
(
nullptr
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
table
|
|
!
cell
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
rv
=
GetCellSpansAt
(
table
startRowIndex
startColIndex
actualRowSpan
actualColSpan
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
actualRowSpan
<
=
1
&
&
actualColSpan
<
=
1
)
return
NS_OK
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertNode
nsIEditor
:
:
eNext
)
;
AutoSelectionSetterAfterTableEdit
setCaret
(
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
nsCOMPtr
<
nsIDOMElement
>
newCell
;
int32_t
rowIndex
=
startRowIndex
;
int32_t
rowSpanBelow
colSpanAfter
;
for
(
rowSpanBelow
=
actualRowSpan
-
1
;
rowSpanBelow
>
=
0
;
rowSpanBelow
-
-
)
{
if
(
rowSpanBelow
>
0
)
{
rv
=
SplitCellIntoRows
(
table
rowIndex
startColIndex
1
rowSpanBelow
getter_AddRefs
(
newCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyCellBackgroundColor
(
newCell
cell
)
;
}
int32_t
colIndex
=
startColIndex
;
for
(
colSpanAfter
=
actualColSpan
-
1
;
colSpanAfter
>
0
;
colSpanAfter
-
-
)
{
rv
=
SplitCellIntoColumns
(
table
rowIndex
colIndex
1
colSpanAfter
getter_AddRefs
(
newCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyCellBackgroundColor
(
newCell
cell
)
;
colIndex
+
+
;
}
rowIndex
+
+
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CopyCellBackgroundColor
(
nsIDOMElement
*
destCell
nsIDOMElement
*
sourceCell
)
{
NS_ENSURE_TRUE
(
destCell
&
&
sourceCell
NS_ERROR_NULL_POINTER
)
;
NS_NAMED_LITERAL_STRING
(
bgcolor
"
bgcolor
"
)
;
nsAutoString
color
;
bool
isSet
;
nsresult
rv
=
GetAttributeValue
(
sourceCell
bgcolor
color
&
isSet
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
isSet
)
{
return
NS_OK
;
}
return
SetAttribute
(
destCell
bgcolor
color
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SplitCellIntoColumns
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aColSpanLeft
int32_t
aColSpanRight
nsIDOMElement
*
*
aNewCell
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
if
(
aNewCell
)
*
aNewCell
=
nullptr
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
nsresult
rv
=
GetCellDataAt
(
aTable
aRowIndex
aColIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_ERROR_NULL_POINTER
)
;
if
(
actualColSpan
<
=
1
|
|
(
aColSpanLeft
+
aColSpanRight
)
>
actualColSpan
)
return
NS_OK
;
rv
=
SetColSpan
(
cell
aColSpanLeft
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
newCell
;
rv
=
InsertCell
(
cell
actualRowSpan
aColSpanRight
true
false
getter_AddRefs
(
newCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
newCell
)
{
return
NS_OK
;
}
if
(
aNewCell
)
{
NS_ADDREF
(
*
aNewCell
=
newCell
.
get
(
)
)
;
}
return
CopyCellBackgroundColor
(
newCell
cell
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SplitCellIntoRows
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aRowSpanAbove
int32_t
aRowSpanBelow
nsIDOMElement
*
*
aNewCell
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
if
(
aNewCell
)
*
aNewCell
=
nullptr
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
nsresult
rv
=
GetCellDataAt
(
aTable
aRowIndex
aColIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_ERROR_NULL_POINTER
)
;
if
(
actualRowSpan
<
=
1
|
|
(
aRowSpanAbove
+
aRowSpanBelow
)
>
actualRowSpan
)
return
NS_OK
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
aTable
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
cell2
;
nsCOMPtr
<
nsIDOMElement
>
lastCellFound
;
int32_t
startRowIndex2
startColIndex2
rowSpan2
colSpan2
actualRowSpan2
actualColSpan2
;
bool
isSelected2
;
int32_t
colIndex
=
0
;
bool
insertAfter
=
(
startColIndex
>
0
)
;
int32_t
rowBelowIndex
=
startRowIndex
+
aRowSpanAbove
;
do
{
rv
=
GetCellDataAt
(
aTable
rowBelowIndex
colIndex
getter_AddRefs
(
cell2
)
&
startRowIndex2
&
startColIndex2
&
rowSpan2
&
colSpan2
&
actualRowSpan2
&
actualColSpan2
&
isSelected2
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
cell
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cell2
&
&
startRowIndex2
=
=
rowBelowIndex
)
{
if
(
insertAfter
)
{
if
(
(
startColIndex2
+
actualColSpan2
)
=
=
startColIndex
)
break
;
if
(
startColIndex2
>
startColIndex
)
{
insertAfter
=
false
;
break
;
}
}
else
{
break
;
}
lastCellFound
=
cell2
;
}
colIndex
+
=
std
:
:
max
(
actualColSpan2
1
)
;
if
(
colIndex
>
colCount
)
break
;
}
while
(
true
)
;
if
(
!
cell2
&
&
lastCellFound
)
{
cell2
=
lastCellFound
;
insertAfter
=
true
;
}
rv
=
SetRowSpan
(
cell
aRowSpanAbove
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
newCell
;
rv
=
InsertCell
(
cell2
aRowSpanBelow
actualColSpan
insertAfter
false
getter_AddRefs
(
newCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
newCell
)
{
return
NS_OK
;
}
if
(
aNewCell
)
{
NS_ADDREF
(
*
aNewCell
=
newCell
.
get
(
)
)
;
}
return
CopyCellBackgroundColor
(
newCell
cell2
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SwitchTableCellHeaderType
(
nsIDOMElement
*
aSourceCell
nsIDOMElement
*
*
aNewCell
)
{
nsCOMPtr
<
Element
>
sourceCell
=
do_QueryInterface
(
aSourceCell
)
;
NS_ENSURE_TRUE
(
sourceCell
NS_ERROR_NULL_POINTER
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertNode
nsIEditor
:
:
eNext
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
nsCOMPtr
<
nsIAtom
>
atom
=
EditorBase
:
:
GetTag
(
aSourceCell
)
;
nsIAtom
*
newCellType
=
atom
=
=
nsGkAtoms
:
:
td
?
nsGkAtoms
:
:
th
:
nsGkAtoms
:
:
td
;
nsCOMPtr
<
Element
>
newNode
=
ReplaceContainer
(
sourceCell
newCellType
nullptr
nullptr
EditorBase
:
:
eCloneAttributes
)
;
NS_ENSURE_TRUE
(
newNode
NS_ERROR_FAILURE
)
;
if
(
aNewCell
)
{
nsCOMPtr
<
nsIDOMElement
>
newElement
=
do_QueryInterface
(
newNode
)
;
*
aNewCell
=
newElement
.
get
(
)
;
NS_ADDREF
(
*
aNewCell
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
JoinTableCells
(
bool
aMergeNonContiguousContents
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
targetCell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
nsCOMPtr
<
nsIDOMElement
>
cell2
;
int32_t
startRowIndex2
startColIndex2
rowSpan2
colSpan2
actualRowSpan2
actualColSpan2
;
bool
isSelected2
;
nsresult
rv
=
GetCellContext
(
nullptr
getter_AddRefs
(
table
)
getter_AddRefs
(
targetCell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
table
|
|
!
targetCell
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
AutoEditBatch
beginBatching
(
this
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
this
)
;
nsCOMPtr
<
nsIDOMElement
>
firstCell
;
int32_t
firstRowIndex
firstColIndex
;
rv
=
GetFirstSelectedCellInTable
(
&
firstRowIndex
&
firstColIndex
getter_AddRefs
(
firstCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
joinSelectedCells
=
false
;
if
(
firstCell
)
{
nsCOMPtr
<
nsIDOMElement
>
secondCell
;
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
secondCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
joinSelectedCells
=
(
secondCell
!
=
nullptr
)
;
}
if
(
joinSelectedCells
)
{
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
firstRowSpan
firstColSpan
;
rv
=
GetCellSpansAt
(
table
firstRowIndex
firstColIndex
firstRowSpan
firstColSpan
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
lastRowIndex
=
firstRowIndex
;
int32_t
lastColIndex
=
firstColIndex
;
int32_t
rowIndex
colIndex
;
for
(
rowIndex
=
firstRowIndex
;
rowIndex
<
=
lastRowIndex
;
rowIndex
+
+
)
{
int32_t
currentRowCount
=
rowCount
;
rv
=
FixBadRowSpan
(
table
rowIndex
rowCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
lastRowIndex
-
=
(
currentRowCount
-
rowCount
)
;
bool
cellFoundInRow
=
false
;
bool
lastRowIsSet
=
false
;
int32_t
lastColInRow
=
0
;
int32_t
firstColInRow
=
firstColIndex
;
for
(
colIndex
=
firstColIndex
;
colIndex
<
colCount
;
colIndex
+
=
std
:
:
max
(
actualColSpan2
1
)
)
{
rv
=
GetCellDataAt
(
table
rowIndex
colIndex
getter_AddRefs
(
cell2
)
&
startRowIndex2
&
startColIndex2
&
rowSpan2
&
colSpan2
&
actualRowSpan2
&
actualColSpan2
&
isSelected2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isSelected2
)
{
if
(
!
cellFoundInRow
)
firstColInRow
=
colIndex
;
if
(
rowIndex
>
firstRowIndex
&
&
firstColInRow
!
=
firstColIndex
)
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
lastRowIsSet
=
true
;
break
;
}
lastColInRow
=
colIndex
+
(
actualColSpan2
-
1
)
;
cellFoundInRow
=
true
;
}
else
if
(
cellFoundInRow
)
{
if
(
rowIndex
>
(
firstRowIndex
+
1
)
&
&
colIndex
<
=
lastColIndex
)
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
lastRowIsSet
=
true
;
}
break
;
}
}
if
(
cellFoundInRow
)
{
if
(
rowIndex
=
=
firstRowIndex
)
{
lastColIndex
=
lastColInRow
;
}
if
(
!
lastRowIsSet
)
{
if
(
colIndex
<
lastColIndex
)
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
}
else
{
lastRowIndex
=
rowIndex
+
1
;
}
}
lastColIndex
=
std
:
:
min
(
lastColIndex
lastColInRow
)
;
}
else
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
}
}
nsTArray
<
nsCOMPtr
<
nsIDOMElement
>
>
deleteList
;
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
+
)
{
for
(
colIndex
=
0
;
colIndex
<
colCount
;
colIndex
+
=
std
:
:
max
(
actualColSpan2
1
)
)
{
rv
=
GetCellDataAt
(
table
rowIndex
colIndex
getter_AddRefs
(
cell2
)
&
startRowIndex2
&
startColIndex2
&
rowSpan2
&
colSpan2
&
actualRowSpan2
&
actualColSpan2
&
isSelected2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
actualColSpan2
=
=
0
)
break
;
if
(
isSelected2
&
&
cell2
!
=
firstCell
)
{
if
(
rowIndex
>
=
firstRowIndex
&
&
rowIndex
<
=
lastRowIndex
&
&
colIndex
>
=
firstColIndex
&
&
colIndex
<
=
lastColIndex
)
{
NS_ASSERTION
(
startRowIndex2
=
=
rowIndex
"
JoinTableCells
:
StartRowIndex
is
in
row
above
"
)
;
if
(
actualColSpan2
>
1
)
{
int32_t
extraColSpan
=
(
startColIndex2
+
actualColSpan2
)
-
(
lastColIndex
+
1
)
;
if
(
extraColSpan
>
0
)
{
rv
=
SplitCellIntoColumns
(
table
startRowIndex2
startColIndex2
actualColSpan2
-
extraColSpan
extraColSpan
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
rv
=
MergeCells
(
firstCell
cell2
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
deleteList
.
AppendElement
(
cell2
.
get
(
)
)
;
}
else
if
(
aMergeNonContiguousContents
)
{
rv
=
MergeCells
(
firstCell
cell2
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
}
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
for
(
uint32_t
i
=
0
n
=
deleteList
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
nsIDOMElement
*
elementPtr
=
deleteList
[
i
]
;
if
(
elementPtr
)
{
nsCOMPtr
<
nsIDOMNode
>
node
=
do_QueryInterface
(
elementPtr
)
;
rv
=
DeleteNode
(
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
int32_t
rangeCount
;
rv
=
selection
-
>
GetRangeCount
(
&
rangeCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsRange
>
range
;
int32_t
i
;
for
(
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
range
=
selection
-
>
GetRangeAt
(
i
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMElement
>
deletedCell
;
GetCellFromRange
(
range
getter_AddRefs
(
deletedCell
)
)
;
if
(
!
deletedCell
)
{
selection
-
>
RemoveRange
(
range
)
;
rangeCount
-
-
;
i
-
-
;
}
}
rv
=
SetRowSpan
(
firstCell
lastRowIndex
-
firstRowIndex
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetColSpan
(
firstCell
lastColIndex
-
firstColIndex
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NormalizeTable
(
table
)
;
}
else
{
rv
=
GetCellDataAt
(
table
startRowIndex
startColIndex
getter_AddRefs
(
targetCell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
targetCell
NS_ERROR_NULL_POINTER
)
;
rv
=
GetCellDataAt
(
table
startRowIndex
startColIndex
+
actualColSpan
getter_AddRefs
(
cell2
)
&
startRowIndex2
&
startColIndex2
&
rowSpan2
&
colSpan2
&
actualRowSpan2
&
actualColSpan2
&
isSelected2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cell2
)
{
return
NS_OK
;
}
NS_ASSERTION
(
(
startRowIndex
>
=
startRowIndex2
)
"
JoinCells
:
startRowIndex
<
startRowIndex2
"
)
;
int32_t
spanAboveMergedCell
=
startRowIndex
-
startRowIndex2
;
int32_t
effectiveRowSpan2
=
actualRowSpan2
-
spanAboveMergedCell
;
if
(
effectiveRowSpan2
>
actualRowSpan
)
{
rv
=
SplitCellIntoRows
(
table
startRowIndex2
startColIndex2
spanAboveMergedCell
+
actualRowSpan
effectiveRowSpan2
-
actualRowSpan
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
MergeCells
(
targetCell
cell2
(
startRowIndex2
=
=
startRowIndex
)
&
&
(
effectiveRowSpan2
>
=
actualRowSpan
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
effectiveRowSpan2
<
actualRowSpan
)
{
return
NS_OK
;
}
if
(
spanAboveMergedCell
>
0
)
{
rv
=
SetRowSpan
(
cell2
spanAboveMergedCell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SetColSpan
(
targetCell
actualColSpan
+
actualColSpan2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MergeCells
(
nsCOMPtr
<
nsIDOMElement
>
aTargetCell
nsCOMPtr
<
nsIDOMElement
>
aCellToMerge
bool
aDeleteCellToMerge
)
{
nsCOMPtr
<
dom
:
:
Element
>
targetCell
=
do_QueryInterface
(
aTargetCell
)
;
nsCOMPtr
<
dom
:
:
Element
>
cellToMerge
=
do_QueryInterface
(
aCellToMerge
)
;
NS_ENSURE_TRUE
(
targetCell
&
&
cellToMerge
NS_ERROR_NULL_POINTER
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
deleteNode
nsIEditor
:
:
eNext
)
;
if
(
!
IsEmptyCell
(
cellToMerge
)
)
{
int32_t
insertIndex
=
0
;
uint32_t
len
=
targetCell
-
>
GetChildCount
(
)
;
if
(
len
=
=
1
&
&
IsEmptyCell
(
targetCell
)
)
{
nsIContent
*
cellChild
=
targetCell
-
>
GetFirstChild
(
)
;
nsresult
rv
=
DeleteNode
(
cellChild
-
>
AsDOMNode
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
insertIndex
=
0
;
}
else
{
insertIndex
=
(
int32_t
)
len
;
}
while
(
cellToMerge
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIDOMNode
>
cellChild
=
cellToMerge
-
>
GetLastChild
(
)
-
>
AsDOMNode
(
)
;
nsresult
rv
=
DeleteNode
(
cellChild
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InsertNode
(
cellChild
aTargetCell
insertIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
aDeleteCellToMerge
)
return
DeleteNode
(
aCellToMerge
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
FixBadRowSpan
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
&
aNewRowCount
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
int32_t
rowCount
colCount
;
nsresult
rv
=
GetTableSize
(
aTable
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
int32_t
minRowSpan
=
-
1
;
int32_t
colIndex
;
for
(
colIndex
=
0
;
colIndex
<
colCount
;
colIndex
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
rv
=
GetCellDataAt
(
aTable
aRowIndex
colIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
cell
)
{
break
;
}
if
(
rowSpan
>
0
&
&
startRowIndex
=
=
aRowIndex
&
&
(
rowSpan
<
minRowSpan
|
|
minRowSpan
=
=
-
1
)
)
{
minRowSpan
=
rowSpan
;
}
NS_ASSERTION
(
(
actualColSpan
>
0
)
"
ActualColSpan
=
0
in
FixBadRowSpan
"
)
;
}
if
(
minRowSpan
>
1
)
{
int32_t
rowsReduced
=
minRowSpan
-
1
;
for
(
colIndex
=
0
;
colIndex
<
colCount
;
colIndex
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
rv
=
GetCellDataAt
(
aTable
aRowIndex
colIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
cell
&
&
rowSpan
>
0
&
&
startRowIndex
=
=
aRowIndex
&
&
startColIndex
=
=
colIndex
)
{
rv
=
SetRowSpan
(
cell
rowSpan
-
rowsReduced
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
NS_ASSERTION
(
(
actualColSpan
>
0
)
"
ActualColSpan
=
0
in
FixBadRowSpan
"
)
;
}
}
return
GetTableSize
(
aTable
&
aNewRowCount
&
colCount
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
FixBadColSpan
(
nsIDOMElement
*
aTable
int32_t
aColIndex
int32_t
&
aNewColCount
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NULL_POINTER
)
;
int32_t
rowCount
colCount
;
nsresult
rv
=
GetTableSize
(
aTable
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
int32_t
minColSpan
=
-
1
;
int32_t
rowIndex
;
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
=
std
:
:
max
(
actualRowSpan
1
)
)
{
rv
=
GetCellDataAt
(
aTable
rowIndex
aColIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
cell
)
{
break
;
}
if
(
colSpan
>
0
&
&
startColIndex
=
=
aColIndex
&
&
(
colSpan
<
minColSpan
|
|
minColSpan
=
=
-
1
)
)
{
minColSpan
=
colSpan
;
}
NS_ASSERTION
(
(
actualRowSpan
>
0
)
"
ActualRowSpan
=
0
in
FixBadColSpan
"
)
;
}
if
(
minColSpan
>
1
)
{
int32_t
colsReduced
=
minColSpan
-
1
;
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
=
std
:
:
max
(
actualRowSpan
1
)
)
{
rv
=
GetCellDataAt
(
aTable
rowIndex
aColIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
cell
&
&
colSpan
>
0
&
&
startColIndex
=
=
aColIndex
&
&
startRowIndex
=
=
rowIndex
)
{
rv
=
SetColSpan
(
cell
colSpan
-
colsReduced
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
NS_ASSERTION
(
(
actualRowSpan
>
0
)
"
ActualRowSpan
=
0
in
FixBadColSpan
"
)
;
}
}
return
GetTableSize
(
aTable
&
rowCount
&
aNewColCount
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NormalizeTable
(
nsIDOMElement
*
aTable
)
{
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
aTable
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_OK
)
;
int32_t
rowCount
colCount
rowIndex
colIndex
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoSelectionRestorer
selectionRestorer
(
selection
this
)
;
AutoEditBatch
beginBatching
(
this
)
;
AutoRules
beginRulesSniffing
(
this
EditAction
:
:
insertNode
nsIEditor
:
:
eNext
)
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
+
)
{
rv
=
FixBadRowSpan
(
table
rowIndex
rowCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
colIndex
=
0
;
colIndex
<
colCount
;
colIndex
+
+
)
{
rv
=
FixBadColSpan
(
table
colIndex
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
for
(
rowIndex
=
0
;
rowIndex
<
rowCount
;
rowIndex
+
+
)
{
nsCOMPtr
<
nsIDOMElement
>
previousCellInRow
;
for
(
colIndex
=
0
;
colIndex
<
colCount
;
colIndex
+
+
)
{
rv
=
GetCellDataAt
(
table
rowIndex
colIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
cell
)
{
#
ifdef
DEBUG
printf
(
"
NormalizeTable
found
missing
cell
at
row
=
%
d
col
=
%
d
\
n
"
rowIndex
colIndex
)
;
#
endif
if
(
previousCellInRow
)
{
rv
=
InsertCell
(
previousCellInRow
1
1
true
false
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cell
)
startRowIndex
=
rowIndex
;
}
else
{
#
ifdef
DEBUG
printf
(
"
NormalizeTable
found
no
cells
in
row
=
%
d
col
=
%
d
\
n
"
rowIndex
colIndex
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
}
if
(
startRowIndex
=
=
rowIndex
)
{
previousCellInRow
=
cell
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellIndexes
(
nsIDOMElement
*
aCell
int32_t
*
aRowIndex
int32_t
*
aColIndex
)
{
NS_ENSURE_ARG_POINTER
(
aRowIndex
)
;
*
aColIndex
=
0
;
NS_ENSURE_ARG_POINTER
(
aColIndex
)
;
*
aRowIndex
=
0
;
if
(
!
aCell
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cell
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
cell
)
{
return
NS_ERROR_FAILURE
;
}
aCell
=
cell
;
}
NS_ENSURE_TRUE
(
mDocWeak
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIContent
>
nodeAsContent
(
do_QueryInterface
(
aCell
)
)
;
NS_ENSURE_TRUE
(
nodeAsContent
NS_ERROR_FAILURE
)
;
nsIFrame
*
layoutObject
=
nodeAsContent
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
layoutObject
NS_ERROR_FAILURE
)
;
nsITableCellLayout
*
cellLayoutObject
=
do_QueryFrame
(
layoutObject
)
;
NS_ENSURE_TRUE
(
cellLayoutObject
NS_ERROR_FAILURE
)
;
return
cellLayoutObject
-
>
GetCellIndexes
(
*
aRowIndex
*
aColIndex
)
;
}
nsTableWrapperFrame
*
HTMLEditor
:
:
GetTableFrame
(
nsIDOMElement
*
aTable
)
{
NS_ENSURE_TRUE
(
aTable
nullptr
)
;
nsCOMPtr
<
nsIContent
>
nodeAsContent
(
do_QueryInterface
(
aTable
)
)
;
NS_ENSURE_TRUE
(
nodeAsContent
nullptr
)
;
return
do_QueryFrame
(
nodeAsContent
-
>
GetPrimaryFrame
(
)
)
;
}
int32_t
HTMLEditor
:
:
GetNumberOfCellsInRow
(
nsIDOMElement
*
aTable
int32_t
rowIndex
)
{
int32_t
cellCount
=
0
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
int32_t
colIndex
=
0
;
do
{
int32_t
startRowIndex
startColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
nsresult
rv
=
GetCellDataAt
(
aTable
rowIndex
colIndex
getter_AddRefs
(
cell
)
&
startRowIndex
&
startColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
if
(
cell
)
{
if
(
startRowIndex
=
=
rowIndex
)
cellCount
+
+
;
colIndex
+
=
actualColSpan
;
}
else
colIndex
+
+
;
}
while
(
cell
)
;
return
cellCount
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetTableSize
(
nsIDOMElement
*
aTable
int32_t
*
aRowCount
int32_t
*
aColCount
)
{
NS_ENSURE_ARG_POINTER
(
aRowCount
)
;
NS_ENSURE_ARG_POINTER
(
aColCount
)
;
*
aRowCount
=
0
;
*
aColCount
=
0
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
aTable
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
nsTableWrapperFrame
*
tableFrame
=
GetTableFrame
(
table
.
get
(
)
)
;
NS_ENSURE_TRUE
(
tableFrame
NS_ERROR_FAILURE
)
;
*
aRowCount
=
tableFrame
-
>
GetRowCount
(
)
;
*
aColCount
=
tableFrame
-
>
GetColCount
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellDataAt
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
nsIDOMElement
*
*
aCell
int32_t
*
aStartRowIndex
int32_t
*
aStartColIndex
int32_t
*
aRowSpan
int32_t
*
aColSpan
int32_t
*
aActualRowSpan
int32_t
*
aActualColSpan
bool
*
aIsSelected
)
{
NS_ENSURE_ARG_POINTER
(
aStartRowIndex
)
;
NS_ENSURE_ARG_POINTER
(
aStartColIndex
)
;
NS_ENSURE_ARG_POINTER
(
aRowSpan
)
;
NS_ENSURE_ARG_POINTER
(
aColSpan
)
;
NS_ENSURE_ARG_POINTER
(
aActualRowSpan
)
;
NS_ENSURE_ARG_POINTER
(
aActualColSpan
)
;
NS_ENSURE_ARG_POINTER
(
aIsSelected
)
;
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
*
aStartRowIndex
=
0
;
*
aStartColIndex
=
0
;
*
aRowSpan
=
0
;
*
aColSpan
=
0
;
*
aActualRowSpan
=
0
;
*
aActualColSpan
=
0
;
*
aIsSelected
=
false
;
*
aCell
=
nullptr
;
if
(
!
aTable
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
nullptr
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
table
)
aTable
=
table
;
else
return
NS_ERROR_FAILURE
;
}
nsTableWrapperFrame
*
tableFrame
=
GetTableFrame
(
aTable
)
;
NS_ENSURE_TRUE
(
tableFrame
NS_ERROR_FAILURE
)
;
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
aRowIndex
aColIndex
)
;
if
(
!
cellFrame
)
return
NS_ERROR_FAILURE
;
*
aIsSelected
=
cellFrame
-
>
IsSelected
(
)
;
cellFrame
-
>
GetRowIndex
(
*
aStartRowIndex
)
;
cellFrame
-
>
GetColIndex
(
*
aStartColIndex
)
;
*
aRowSpan
=
cellFrame
-
>
GetRowSpan
(
)
;
*
aColSpan
=
cellFrame
-
>
GetColSpan
(
)
;
*
aActualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
aRowIndex
aColIndex
)
;
*
aActualColSpan
=
tableFrame
-
>
GetEffectiveColSpanAt
(
aRowIndex
aColIndex
)
;
nsCOMPtr
<
nsIDOMElement
>
domCell
=
do_QueryInterface
(
cellFrame
-
>
GetContent
(
)
)
;
domCell
.
forget
(
aCell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellAt
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
nsIDOMElement
*
*
aCell
)
{
NS_ENSURE_ARG_POINTER
(
aCell
)
;
*
aCell
=
nullptr
;
if
(
!
aTable
)
{
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
nullptr
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
aTable
=
table
;
}
nsTableWrapperFrame
*
tableFrame
=
GetTableFrame
(
aTable
)
;
if
(
!
tableFrame
)
{
*
aCell
=
nullptr
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
nsCOMPtr
<
nsIDOMElement
>
domCell
=
do_QueryInterface
(
tableFrame
-
>
GetCellAt
(
aRowIndex
aColIndex
)
)
;
domCell
.
forget
(
aCell
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellSpansAt
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
&
aActualRowSpan
int32_t
&
aActualColSpan
)
{
nsTableWrapperFrame
*
tableFrame
=
GetTableFrame
(
aTable
)
;
if
(
!
tableFrame
)
return
NS_ERROR_FAILURE
;
aActualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
aRowIndex
aColIndex
)
;
aActualColSpan
=
tableFrame
-
>
GetEffectiveColSpanAt
(
aRowIndex
aColIndex
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetCellContext
(
Selection
*
*
aSelection
nsIDOMElement
*
*
aTable
nsIDOMElement
*
*
aCell
nsIDOMNode
*
*
aCellParent
int32_t
*
aCellOffset
int32_t
*
aRowIndex
int32_t
*
aColIndex
)
{
if
(
aSelection
)
*
aSelection
=
nullptr
;
if
(
aTable
)
*
aTable
=
nullptr
;
if
(
aCell
)
*
aCell
=
nullptr
;
if
(
aCellParent
)
*
aCellParent
=
nullptr
;
if
(
aCellOffset
)
*
aCellOffset
=
0
;
if
(
aRowIndex
)
*
aRowIndex
=
0
;
if
(
aColIndex
)
*
aColIndex
=
0
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
if
(
aSelection
)
{
*
aSelection
=
selection
.
get
(
)
;
NS_ADDREF
(
*
aSelection
)
;
}
nsCOMPtr
<
nsIDOMElement
>
table
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
if
(
aCell
&
&
*
aCell
)
cell
=
*
aCell
;
if
(
!
cell
)
{
nsCOMPtr
<
nsIDOMElement
>
cellOrTableElement
;
int32_t
selectedCount
;
nsAutoString
tagName
;
nsresult
rv
=
GetSelectedOrParentTableElement
(
tagName
&
selectedCount
getter_AddRefs
(
cellOrTableElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
tagName
.
EqualsLiteral
(
"
table
"
)
)
{
if
(
aTable
)
{
*
aTable
=
cellOrTableElement
.
get
(
)
;
NS_ADDREF
(
*
aTable
)
;
}
return
NS_OK
;
}
if
(
!
tagName
.
EqualsLiteral
(
"
td
"
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
cell
=
cellOrTableElement
;
}
if
(
aCell
)
{
*
aCell
=
cell
.
get
(
)
;
NS_ADDREF
(
*
aCell
)
;
}
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
cell
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
table
NS_ERROR_FAILURE
)
;
if
(
aTable
)
{
*
aTable
=
table
.
get
(
)
;
NS_ADDREF
(
*
aTable
)
;
}
if
(
aRowIndex
|
|
aColIndex
)
{
int32_t
rowIndex
colIndex
;
rv
=
GetCellIndexes
(
cell
&
rowIndex
&
colIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aRowIndex
)
{
*
aRowIndex
=
rowIndex
;
}
if
(
aColIndex
)
{
*
aColIndex
=
colIndex
;
}
}
if
(
aCellParent
)
{
nsCOMPtr
<
nsIDOMNode
>
cellParent
;
rv
=
cell
-
>
GetParentNode
(
getter_AddRefs
(
cellParent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cellParent
NS_ERROR_FAILURE
)
;
*
aCellParent
=
cellParent
.
get
(
)
;
NS_ADDREF
(
*
aCellParent
)
;
if
(
aCellOffset
)
{
*
aCellOffset
=
GetChildOffset
(
cell
cellParent
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetCellFromRange
(
nsRange
*
aRange
nsIDOMElement
*
*
aCell
)
{
NS_ENSURE_TRUE
(
aRange
&
&
aCell
NS_ERROR_NULL_POINTER
)
;
*
aCell
=
nullptr
;
nsCOMPtr
<
nsIDOMNode
>
startParent
;
nsresult
rv
=
aRange
-
>
GetStartContainer
(
getter_AddRefs
(
startParent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
startParent
NS_ERROR_FAILURE
)
;
int32_t
startOffset
;
rv
=
aRange
-
>
GetStartOffset
(
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
childNode
=
GetChildAt
(
startParent
startOffset
)
;
if
(
!
childNode
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDOMNode
>
endParent
;
rv
=
aRange
-
>
GetEndContainer
(
getter_AddRefs
(
endParent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
startParent
NS_ERROR_FAILURE
)
;
int32_t
endOffset
;
rv
=
aRange
-
>
GetEndOffset
(
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startParent
=
=
endParent
&
&
endOffset
=
=
startOffset
+
1
&
&
HTMLEditUtils
:
:
IsTableCell
(
childNode
)
)
{
nsCOMPtr
<
nsIDOMElement
>
cellElement
=
do_QueryInterface
(
childNode
)
;
*
aCell
=
cellElement
.
get
(
)
;
NS_ADDREF
(
*
aCell
)
;
return
NS_OK
;
}
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFirstSelectedCell
(
nsIDOMRange
*
*
aRange
nsIDOMElement
*
*
aCell
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
*
aCell
=
nullptr
;
if
(
aRange
)
*
aRange
=
nullptr
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
mSelectedCellIndex
=
0
;
nsresult
rv
=
GetCellFromRange
(
range
aCell
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
!
*
aCell
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
aRange
)
{
*
aRange
=
range
.
get
(
)
;
NS_ADDREF
(
*
aRange
)
;
}
mSelectedCellIndex
=
1
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetNextSelectedCell
(
nsIDOMRange
*
*
aRange
nsIDOMElement
*
*
aCell
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
*
aCell
=
nullptr
;
if
(
aRange
)
*
aRange
=
nullptr
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
int32_t
rangeCount
=
selection
-
>
RangeCount
(
)
;
if
(
mSelectedCellIndex
>
=
rangeCount
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
nsRange
>
range
;
for
(
;
mSelectedCellIndex
<
rangeCount
;
mSelectedCellIndex
+
+
)
{
range
=
selection
-
>
GetRangeAt
(
mSelectedCellIndex
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
nsresult
rv
=
GetCellFromRange
(
range
aCell
)
;
NS_ENSURE_SUCCESS
(
rv
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
if
(
*
aCell
)
break
;
}
NS_ENSURE_TRUE
(
*
aCell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
if
(
aRange
)
{
*
aRange
=
range
.
get
(
)
;
NS_ADDREF
(
*
aRange
)
;
}
mSelectedCellIndex
+
+
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFirstSelectedCellInTable
(
int32_t
*
aRowIndex
int32_t
*
aColIndex
nsIDOMElement
*
*
aCell
)
{
NS_ENSURE_TRUE
(
aCell
NS_ERROR_NULL_POINTER
)
;
*
aCell
=
nullptr
;
if
(
aRowIndex
)
*
aRowIndex
=
0
;
if
(
aColIndex
)
*
aColIndex
=
0
;
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
cell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
cell
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
;
*
aCell
=
cell
.
get
(
)
;
NS_ADDREF
(
*
aCell
)
;
if
(
aRowIndex
|
|
aColIndex
)
{
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellIndexes
(
cell
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aRowIndex
)
*
aRowIndex
=
startRowIndex
;
if
(
aColIndex
)
*
aColIndex
=
startColIndex
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetSelectionAfterTableEdit
(
nsIDOMElement
*
aTable
int32_t
aRow
int32_t
aCol
int32_t
aDirection
bool
aSelected
)
{
NS_ENSURE_TRUE
(
aTable
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDOMElement
>
cell
;
bool
done
=
false
;
do
{
nsresult
rv
=
GetCellAt
(
aTable
aRow
aCol
getter_AddRefs
(
cell
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
if
(
cell
)
{
if
(
aSelected
)
{
return
SelectElement
(
cell
)
;
}
else
{
nsCOMPtr
<
nsINode
>
cellNode
=
do_QueryInterface
(
cell
)
;
if
(
cellNode
)
{
CollapseSelectionToDeepestNonTableFirstChild
(
selection
cellNode
)
;
}
return
NS_OK
;
}
}
else
{
switch
(
aDirection
)
{
case
ePreviousColumn
:
if
(
!
aCol
)
{
if
(
aRow
>
0
)
{
aRow
-
-
;
}
else
{
done
=
true
;
}
}
else
{
aCol
-
-
;
}
break
;
case
ePreviousRow
:
if
(
!
aRow
)
{
if
(
aCol
>
0
)
{
aCol
-
-
;
}
else
{
done
=
true
;
}
}
else
{
aRow
-
-
;
}
break
;
default
:
done
=
true
;
}
}
}
while
(
!
done
)
;
nsCOMPtr
<
nsIDOMNode
>
tableParent
;
nsresult
rv
=
aTable
-
>
GetParentNode
(
getter_AddRefs
(
tableParent
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
tableParent
)
{
int32_t
tableOffset
=
GetChildOffset
(
aTable
tableParent
)
;
return
selection
-
>
Collapse
(
tableParent
tableOffset
)
;
}
return
SetSelectionAtDocumentStart
(
selection
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
nsAString
&
aTagName
int32_t
*
aSelectedCount
nsIDOMElement
*
*
aTableElement
)
{
NS_ENSURE_ARG_POINTER
(
aTableElement
)
;
NS_ENSURE_ARG_POINTER
(
aSelectedCount
)
;
*
aTableElement
=
nullptr
;
aTagName
.
Truncate
(
)
;
*
aSelectedCount
=
0
;
RefPtr
<
Selection
>
selection
=
GetSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMElement
>
tableOrCellElement
;
nsresult
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
tableOrCellElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_NAMED_LITERAL_STRING
(
tdName
"
td
"
)
;
if
(
tableOrCellElement
)
{
rv
=
selection
-
>
GetRangeCount
(
aSelectedCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aTagName
=
tdName
;
}
else
{
nsCOMPtr
<
nsIDOMNode
>
anchorNode
;
rv
=
selection
-
>
GetAnchorNode
(
getter_AddRefs
(
anchorNode
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_ENSURE_TRUE
(
anchorNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDOMNode
>
selectedNode
;
bool
hasChildren
;
anchorNode
-
>
HasChildNodes
(
&
hasChildren
)
;
if
(
hasChildren
)
{
int32_t
anchorOffset
;
rv
=
selection
-
>
GetAnchorOffset
(
&
anchorOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
selectedNode
=
GetChildAt
(
anchorNode
anchorOffset
)
;
if
(
!
selectedNode
)
{
selectedNode
=
anchorNode
;
}
else
{
nsCOMPtr
<
nsIAtom
>
atom
=
EditorBase
:
:
GetTag
(
selectedNode
)
;
if
(
atom
=
=
nsGkAtoms
:
:
td
)
{
tableOrCellElement
=
do_QueryInterface
(
selectedNode
)
;
aTagName
=
tdName
;
rv
=
selection
-
>
GetRangeCount
(
aSelectedCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
atom
=
=
nsGkAtoms
:
:
table
)
{
tableOrCellElement
=
do_QueryInterface
(
selectedNode
)
;
aTagName
.
AssignLiteral
(
"
table
"
)
;
*
aSelectedCount
=
1
;
}
else
if
(
atom
=
=
nsGkAtoms
:
:
tr
)
{
tableOrCellElement
=
do_QueryInterface
(
selectedNode
)
;
aTagName
.
AssignLiteral
(
"
tr
"
)
;
*
aSelectedCount
=
1
;
}
}
}
if
(
!
tableOrCellElement
)
{
rv
=
GetElementOrParentByTagName
(
tdName
anchorNode
getter_AddRefs
(
tableOrCellElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
tableOrCellElement
)
{
aTagName
=
tdName
;
}
}
}
if
(
tableOrCellElement
)
{
*
aTableElement
=
tableOrCellElement
.
get
(
)
;
NS_ADDREF
(
*
aTableElement
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedCellsType
(
nsIDOMElement
*
aElement
uint32_t
*
aSelectionType
)
{
NS_ENSURE_ARG_POINTER
(
aSelectionType
)
;
*
aSelectionType
=
0
;
nsCOMPtr
<
nsIDOMElement
>
table
;
nsresult
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
table
"
)
aElement
getter_AddRefs
(
table
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
rowCount
colCount
;
rv
=
GetTableSize
(
table
&
rowCount
&
colCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMElement
>
selectedCell
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
selectedCell
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
=
=
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
)
{
return
NS_OK
;
}
*
aSelectionType
=
nsISelectionPrivate
:
:
TABLESELECTION_CELL
;
nsTArray
<
int32_t
>
indexArray
;
bool
allCellsInRowAreSelected
=
false
;
bool
allCellsInColAreSelected
=
false
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
selectedCell
)
{
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellIndexes
(
selectedCell
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
indexArray
.
Contains
(
startColIndex
)
)
{
indexArray
.
AppendElement
(
startColIndex
)
;
allCellsInRowAreSelected
=
AllCellsInRowSelected
(
table
startRowIndex
colCount
)
;
if
(
!
allCellsInRowAreSelected
)
break
;
}
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
selectedCell
)
)
;
}
if
(
allCellsInRowAreSelected
)
{
*
aSelectionType
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
;
return
NS_OK
;
}
indexArray
.
Clear
(
)
;
rv
=
GetFirstSelectedCell
(
nullptr
getter_AddRefs
(
selectedCell
)
)
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
selectedCell
)
{
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellIndexes
(
selectedCell
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
indexArray
.
Contains
(
startRowIndex
)
)
{
indexArray
.
AppendElement
(
startColIndex
)
;
allCellsInColAreSelected
=
AllCellsInColumnSelected
(
table
startColIndex
rowCount
)
;
if
(
!
allCellsInRowAreSelected
)
break
;
}
rv
=
GetNextSelectedCell
(
nullptr
getter_AddRefs
(
selectedCell
)
)
;
}
if
(
allCellsInColAreSelected
)
*
aSelectionType
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
;
return
NS_OK
;
}
bool
HTMLEditor
:
:
AllCellsInRowSelected
(
nsIDOMElement
*
aTable
int32_t
aRowIndex
int32_t
aNumberOfColumns
)
{
NS_ENSURE_TRUE
(
aTable
false
)
;
int32_t
curStartRowIndex
curStartColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
for
(
int32_t
col
=
0
;
col
<
aNumberOfColumns
;
col
+
=
std
:
:
max
(
actualColSpan
1
)
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetCellDataAt
(
aTable
aRowIndex
col
getter_AddRefs
(
cell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
cell
(
col
>
0
)
?
true
:
false
)
;
NS_ENSURE_TRUE
(
isSelected
false
)
;
NS_ASSERTION
(
(
actualColSpan
>
0
)
"
ActualColSpan
=
0
in
AllCellsInRowSelected
"
)
;
}
return
true
;
}
bool
HTMLEditor
:
:
AllCellsInColumnSelected
(
nsIDOMElement
*
aTable
int32_t
aColIndex
int32_t
aNumberOfRows
)
{
NS_ENSURE_TRUE
(
aTable
false
)
;
int32_t
curStartRowIndex
curStartColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
;
bool
isSelected
;
for
(
int32_t
row
=
0
;
row
<
aNumberOfRows
;
row
+
=
std
:
:
max
(
actualRowSpan
1
)
)
{
nsCOMPtr
<
nsIDOMElement
>
cell
;
nsresult
rv
=
GetCellDataAt
(
aTable
row
aColIndex
getter_AddRefs
(
cell
)
&
curStartRowIndex
&
curStartColIndex
&
rowSpan
&
colSpan
&
actualRowSpan
&
actualColSpan
&
isSelected
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
cell
(
row
>
0
)
?
true
:
false
)
;
NS_ENSURE_TRUE
(
isSelected
false
)
;
}
return
true
;
}
bool
HTMLEditor
:
:
IsEmptyCell
(
dom
:
:
Element
*
aCell
)
{
MOZ_ASSERT
(
aCell
)
;
nsCOMPtr
<
nsINode
>
cellChild
=
aCell
-
>
GetFirstChild
(
)
;
if
(
!
cellChild
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
nextChild
=
cellChild
-
>
GetNextSibling
(
)
;
if
(
nextChild
)
{
return
false
;
}
if
(
cellChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
bool
isEmpty
;
nsresult
rv
=
IsEmptyNode
(
cellChild
&
isEmpty
false
false
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
isEmpty
;
}
}
