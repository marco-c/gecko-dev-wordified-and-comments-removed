#
include
<
stdio
.
h
>
#
include
"
HTMLEditor
.
h
"
#
include
"
EditAction
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nscore
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
dom
;
using
EmptyCheckOption
=
HTMLEditUtils
:
:
EmptyCheckOption
;
class
MOZ_STACK_CLASS
AutoSelectionSetterAfterTableEdit
final
{
private
:
const
RefPtr
<
HTMLEditor
>
mHTMLEditor
;
const
RefPtr
<
Element
>
mTable
;
int32_t
mCol
mRow
mDirection
mSelected
;
public
:
AutoSelectionSetterAfterTableEdit
(
HTMLEditor
&
aHTMLEditor
Element
*
aTable
int32_t
aRow
int32_t
aCol
int32_t
aDirection
bool
aSelected
)
:
mHTMLEditor
(
&
aHTMLEditor
)
mTable
(
aTable
)
mCol
(
aCol
)
mRow
(
aRow
)
mDirection
(
aDirection
)
mSelected
(
aSelected
)
{
}
MOZ_CAN_RUN_SCRIPT
~
AutoSelectionSetterAfterTableEdit
(
)
{
if
(
mHTMLEditor
)
{
mHTMLEditor
-
>
SetSelectionAfterTableEdit
(
mTable
mRow
mCol
mDirection
mSelected
)
;
}
}
}
;
void
HTMLEditor
:
:
CellIndexes
:
:
Update
(
HTMLEditor
&
aHTMLEditor
Selection
&
aSelection
)
{
RefPtr
<
Element
>
cellElement
=
aHTMLEditor
.
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cellElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
td
)
"
"
failed
"
)
;
return
;
}
RefPtr
<
PresShell
>
presShell
{
aHTMLEditor
.
GetPresShell
(
)
}
;
Update
(
*
cellElement
presShell
)
;
}
void
HTMLEditor
:
:
CellIndexes
:
:
Update
(
Element
&
aCellElement
PresShell
*
aPresShell
)
{
if
(
NS_WARN_IF
(
!
aPresShell
)
)
{
return
;
}
aPresShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsIFrame
*
frameOfCell
=
aCellElement
.
GetPrimaryFrame
(
)
;
if
(
!
frameOfCell
)
{
NS_WARNING
(
"
There
was
no
layout
information
of
aCellElement
"
)
;
return
;
}
nsITableCellLayout
*
tableCellLayout
=
do_QueryFrame
(
frameOfCell
)
;
if
(
!
tableCellLayout
)
{
NS_WARNING
(
"
aCellElement
was
not
a
table
cell
"
)
;
return
;
}
if
(
NS_FAILED
(
tableCellLayout
-
>
GetCellIndexes
(
mRow
mColumn
)
)
)
{
NS_WARNING
(
"
nsITableCellLayout
:
:
GetCellIndexes
(
)
failed
"
)
;
mRow
=
mColumn
=
-
1
;
return
;
}
MOZ_ASSERT
(
!
isErr
(
)
)
;
}
HTMLEditor
:
:
CellData
HTMLEditor
:
:
CellData
:
:
AtIndexInTableElement
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
)
{
nsTableWrapperFrame
*
tableFrame
=
HTMLEditor
:
:
GetTableFrame
(
&
aTableElement
)
;
if
(
!
tableFrame
)
{
NS_WARNING
(
"
There
was
no
layout
information
of
the
table
"
)
;
return
CellData
:
:
Error
(
aRowIndex
aColumnIndex
)
;
}
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
aRowIndex
aColumnIndex
)
;
if
(
!
cellFrame
)
{
return
CellData
:
:
NotFound
(
aRowIndex
aColumnIndex
)
;
}
Element
*
cellElement
=
Element
:
:
FromNodeOrNull
(
cellFrame
-
>
GetContent
(
)
)
;
if
(
!
cellElement
)
{
return
CellData
:
:
Error
(
aRowIndex
aColumnIndex
)
;
}
return
CellData
(
*
cellElement
aRowIndex
aColumnIndex
*
cellFrame
*
tableFrame
)
;
}
HTMLEditor
:
:
CellData
:
:
CellData
(
Element
&
aElement
int32_t
aRowIndex
int32_t
aColumnIndex
nsTableCellFrame
&
aTableCellFrame
nsTableWrapperFrame
&
aTableWrapperFrame
)
:
mElement
(
&
aElement
)
mCurrent
(
aRowIndex
aColumnIndex
)
mFirst
(
aTableCellFrame
.
RowIndex
(
)
aTableCellFrame
.
ColIndex
(
)
)
mRowSpan
(
aTableCellFrame
.
GetRowSpan
(
)
)
mColSpan
(
aTableCellFrame
.
GetColSpan
(
)
)
mEffectiveRowSpan
(
aTableWrapperFrame
.
GetEffectiveRowSpanAt
(
aRowIndex
aColumnIndex
)
)
mEffectiveColSpan
(
aTableWrapperFrame
.
GetEffectiveColSpanAt
(
aRowIndex
aColumnIndex
)
)
mIsSelected
(
aTableCellFrame
.
IsSelected
(
)
)
{
MOZ_ASSERT
(
!
mCurrent
.
isErr
(
)
)
;
}
Result
<
HTMLEditor
:
:
TableSize
nsresult
>
HTMLEditor
:
:
TableSize
:
:
Create
(
HTMLEditor
&
aHTMLEditor
Element
&
aTableOrElementInTable
)
{
RefPtr
<
Element
>
tableElement
=
aHTMLEditor
.
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
aTableOrElementInTable
)
;
if
(
!
tableElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
tableElement
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
{
NS_WARNING
(
"
There
was
no
layout
information
of
the
<
table
>
element
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
int32_t
rowCount
=
tableFrame
-
>
GetRowCount
(
)
;
const
int32_t
columnCount
=
tableFrame
-
>
GetColCount
(
)
;
if
(
NS_WARN_IF
(
rowCount
<
0
)
|
|
NS_WARN_IF
(
columnCount
<
0
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
TableSize
(
rowCount
columnCount
)
;
}
nsresult
HTMLEditor
:
:
InsertCell
(
Element
*
aCell
int32_t
aRowSpan
int32_t
aColSpan
bool
aAfter
bool
aIsHeader
Element
*
*
aNewCell
)
{
if
(
aNewCell
)
{
*
aNewCell
=
nullptr
;
}
if
(
NS_WARN_IF
(
!
aCell
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorDOMPoint
pointToInsert
(
aCell
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
Element
>
newCell
=
CreateElementWithDefaults
(
aIsHeader
?
*
nsGkAtoms
:
:
th
:
*
nsGkAtoms
:
:
td
)
;
if
(
!
newCell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
th
or
td
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aNewCell
)
{
*
aNewCell
=
do_AddRef
(
newCell
)
.
take
(
)
;
}
if
(
aRowSpan
>
1
)
{
nsAutoString
newRowSpan
;
newRowSpan
.
AppendInt
(
aRowSpan
10
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
newCell
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
rowspan
newRowSpan
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
rawspan
)
failed
but
ignored
"
)
;
}
if
(
aColSpan
>
1
)
{
nsAutoString
newColSpan
;
newColSpan
.
AppendInt
(
aColSpan
10
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
newCell
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
colspan
newColSpan
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
colspan
)
failed
but
ignored
"
)
;
}
if
(
aAfter
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
old
cell
"
)
;
}
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
CreateElementResult
insertNewCellResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newCell
pointToInsert
)
;
if
(
insertNewCellResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertNewCellResult
.
unwrapErr
(
)
;
}
insertNewCellResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetColSpan
(
Element
*
aCell
int32_t
aColSpan
)
{
if
(
NS_WARN_IF
(
!
aCell
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
newSpan
;
newSpan
.
AppendInt
(
aColSpan
10
)
;
nsresult
rv
=
SetAttributeWithTransaction
(
*
aCell
*
nsGkAtoms
:
:
colspan
newSpan
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
colspan
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetRowSpan
(
Element
*
aCell
int32_t
aRowSpan
)
{
if
(
NS_WARN_IF
(
!
aCell
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
newSpan
;
newSpan
.
AppendInt
(
aRowSpan
10
)
;
nsresult
rv
=
SetAttributeWithTransaction
(
*
aCell
*
nsGkAtoms
:
:
rowspan
newSpan
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
rowspan
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableCell
(
int32_t
aNumberOfCellsToInsert
bool
aInsertAfterSelectedCell
)
{
if
(
aNumberOfCellsToInsert
<
=
0
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableCellElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
cellElementOrError
=
GetFirstSelectedCellElementInTable
(
)
;
if
(
cellElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstSelectedCellElementInTable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
cellElementOrError
.
unwrapErr
(
)
)
;
}
if
(
!
cellElementOrError
.
inspect
(
)
)
{
return
NS_OK
;
}
EditorDOMPoint
pointToInsert
(
cellElementOrError
.
inspect
(
)
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
NS_WARNING
(
"
Found
an
orphan
cell
element
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aInsertAfterSelectedCell
&
&
!
pointToInsert
.
IsEndOfContainer
(
)
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
set
insertion
point
after
current
cell
but
ignored
"
)
;
}
const
CreateElementResult
insertCellElementResult
=
InsertTableCellsWithTransaction
(
pointToInsert
aNumberOfCellsToInsert
)
;
if
(
insertCellElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTableCellsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
insertCellElementResult
.
inspectErr
(
)
)
;
}
insertCellElementResult
.
IgnoreCaretPointSuggestion
(
)
;
return
NS_OK
;
}
CreateElementResult
HTMLEditor
:
:
InsertTableCellsWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
int32_t
aNumberOfCellsToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aNumberOfCellsToInsert
>
0
)
;
if
(
!
HTMLEditUtils
:
:
IsTableRow
(
aPointToInsert
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Tried
to
insert
cell
elements
to
non
-
<
tr
>
element
"
)
;
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
CreateElementResult
(
error
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
error
.
SuppressException
(
)
;
RefPtr
<
Element
>
cellToPutCaret
=
aPointToInsert
.
IsEndOfContainer
(
)
?
nullptr
:
HTMLEditUtils
:
:
GetPreviousTableCellElementSibling
(
*
aPointToInsert
.
GetChild
(
)
)
;
RefPtr
<
Element
>
firstCellElement
lastCellElement
;
nsresult
rv
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
nsAutoScriptBlockerSuppressNodeRemoved
blockToRunScript
;
nsIContent
*
referenceContent
=
aPointToInsert
.
GetChild
(
)
;
for
(
[
[
maybe_unused
]
]
const
auto
i
:
IntegerRange
<
uint32_t
>
(
aNumberOfCellsToInsert
)
)
{
RefPtr
<
Element
>
newCell
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
newCell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
td
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
CreateElementResult
insertNewCellResult
=
InsertNodeWithTransaction
(
*
newCell
referenceContent
?
EditorDOMPoint
(
referenceContent
)
:
EditorDOMPoint
:
:
AtEndOf
(
*
aPointToInsert
.
ContainerAs
<
Element
>
(
)
)
)
;
if
(
insertNewCellResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertNewCellResult
.
unwrapErr
(
)
;
}
lastCellElement
=
insertNewCellResult
.
UnwrapNewNode
(
)
;
if
(
!
firstCellElement
)
{
firstCellElement
=
lastCellElement
;
}
insertNewCellResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
!
cellToPutCaret
)
{
cellToPutCaret
=
std
:
:
move
(
newCell
)
;
}
}
MOZ_ASSERT
(
cellToPutCaret
)
;
MOZ_ASSERT
(
cellToPutCaret
-
>
GetParent
(
)
)
;
CollapseSelectionToDeepestNonTableFirstChild
(
cellToPutCaret
)
;
return
NS_OK
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
)
{
return
CreateElementResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
CreateElementResult
(
rv
)
;
}
MOZ_ASSERT
(
firstCellElement
)
;
MOZ_ASSERT
(
lastCellElement
)
;
return
CreateElementResult
(
std
:
:
move
(
firstCellElement
)
EditorDOMPoint
(
lastCellElement
0u
)
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFirstRow
(
Element
*
aTableOrElementInTable
Element
*
*
aFirstRowElement
)
{
if
(
NS_WARN_IF
(
!
aTableOrElementInTable
)
|
|
NS_WARN_IF
(
!
aFirstRowElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetFirstRow
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstRow
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
firstRowElementOrError
=
GetFirstTableRowElement
(
*
aTableOrElementInTable
)
;
NS_WARNING_ASSERTION
(
!
firstRowElementOrError
.
isErr
(
)
"
HTMLEditor
:
:
GetFirstTableRowElement
(
)
failed
"
)
;
if
(
firstRowElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstTableRowElement
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
firstRowElementOrError
.
unwrapErr
(
)
)
;
}
firstRowElementOrError
.
unwrap
(
)
.
forget
(
aFirstRowElement
)
;
return
NS_OK
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
GetFirstTableRowElement
(
const
Element
&
aTableOrElementInTable
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
Element
*
tableElement
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
aTableOrElementInTable
)
;
if
(
!
tableElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
for
(
nsIContent
*
tableChild
=
tableElement
-
>
GetFirstChild
(
)
;
tableChild
;
tableChild
=
tableChild
-
>
GetNextSibling
(
)
)
{
if
(
tableChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
tableChild
-
>
AsElement
(
)
)
;
}
if
(
tableChild
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
)
)
{
for
(
nsIContent
*
tableSectionChild
=
tableChild
-
>
GetFirstChild
(
)
;
tableSectionChild
;
tableSectionChild
=
tableSectionChild
-
>
GetNextSibling
(
)
)
{
if
(
tableSectionChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
tableSectionChild
-
>
AsElement
(
)
)
;
}
}
}
}
return
RefPtr
<
Element
>
(
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
GetNextTableRowElement
(
const
Element
&
aTableRowElement
)
const
{
if
(
NS_WARN_IF
(
!
aTableRowElement
.
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
for
(
nsIContent
*
maybeNextRow
=
aTableRowElement
.
GetNextSibling
(
)
;
maybeNextRow
;
maybeNextRow
=
maybeNextRow
-
>
GetNextSibling
(
)
)
{
if
(
maybeNextRow
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
maybeNextRow
-
>
AsElement
(
)
)
;
}
}
Element
*
parentElementOfRow
=
aTableRowElement
.
GetParentElement
(
)
;
if
(
!
parentElementOfRow
)
{
NS_WARNING
(
"
aTableRowElement
was
an
orphan
node
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
parentElementOfRow
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
for
(
nsIContent
*
maybeNextTableSection
=
parentElementOfRow
-
>
GetNextSibling
(
)
;
maybeNextTableSection
;
maybeNextTableSection
=
maybeNextTableSection
-
>
GetNextSibling
(
)
)
{
if
(
maybeNextTableSection
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tfoot
)
)
{
for
(
nsIContent
*
maybeNextRow
=
maybeNextTableSection
-
>
GetFirstChild
(
)
;
maybeNextRow
;
maybeNextRow
=
maybeNextRow
-
>
GetNextSibling
(
)
)
{
if
(
maybeNextRow
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
maybeNextRow
-
>
AsElement
(
)
)
;
}
}
}
else
if
(
maybeNextTableSection
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
maybeNextTableSection
-
>
AsElement
(
)
)
;
}
}
return
RefPtr
<
Element
>
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableColumn
(
int32_t
aNumberOfColumnsToInsert
bool
aInsertAfterSelectedCell
)
{
if
(
aNumberOfColumnsToInsert
<
=
0
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableColumn
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
cellElementOrError
=
GetFirstSelectedCellElementInTable
(
)
;
if
(
cellElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstSelectedCellElementInTable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
cellElementOrError
.
unwrapErr
(
)
)
;
}
if
(
!
cellElementOrError
.
inspect
(
)
)
{
return
NS_OK
;
}
EditorDOMPoint
pointToInsert
(
cellElementOrError
.
inspect
(
)
)
;
if
(
!
pointToInsert
.
IsSet
(
)
)
{
NS_WARNING
(
"
Found
an
orphan
cell
element
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aInsertAfterSelectedCell
&
&
!
pointToInsert
.
IsEndOfContainer
(
)
)
{
DebugOnly
<
bool
>
advanced
=
pointToInsert
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
set
insertion
point
after
current
cell
but
ignored
"
)
;
}
rv
=
InsertTableColumnsWithTransaction
(
pointToInsert
aNumberOfColumnsToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertTableColumnsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertTableColumnsWithTransaction
(
const
EditorDOMPoint
&
aPointToInsert
int32_t
aNumberOfColumnsToInsert
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aNumberOfColumnsToInsert
>
0
)
;
const
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsTableRow
(
aPointToInsert
.
GetContainer
(
)
)
)
{
NS_WARNING
(
"
Tried
to
insert
columns
to
non
-
<
tr
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
const
RefPtr
<
Element
>
tableElement
=
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
aPointToInsert
.
ContainerAs
<
Element
>
(
)
)
;
if
(
!
tableElement
)
{
NS_WARNING
(
"
There
was
no
ancestor
<
table
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
tableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
if
(
NS_WARN_IF
(
tableSize
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
bool
insertAfterPreviousCell
=
[
&
]
(
)
{
if
(
!
aPointToInsert
.
IsEndOfContainer
(
)
&
&
HTMLEditUtils
:
:
IsTableCell
(
aPointToInsert
.
GetChild
(
)
)
)
{
return
false
;
}
Element
*
previousCellElement
=
aPointToInsert
.
IsEndOfContainer
(
)
?
HTMLEditUtils
:
:
GetLastTableCellElementChild
(
*
aPointToInsert
.
ContainerAs
<
Element
>
(
)
)
:
HTMLEditUtils
:
:
GetPreviousTableCellElementSibling
(
*
aPointToInsert
.
GetChild
(
)
)
;
return
previousCellElement
!
=
nullptr
;
}
(
)
;
auto
referenceColumnIndexOrError
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
int32_t
nsresult
>
{
if
(
!
insertAfterPreviousCell
)
{
if
(
aPointToInsert
.
IsEndOfContainer
(
)
)
{
return
tableSize
.
mColumnCount
;
}
const
OwningNonNull
<
Element
>
tableCellElement
=
*
aPointToInsert
.
GetChild
(
)
-
>
AsElement
(
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsTableCell
(
tableCellElement
)
)
;
CellIndexes
cellIndexes
(
*
tableCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
cellIndexes
.
mColumn
;
}
Element
*
previousCellElement
=
aPointToInsert
.
IsEndOfContainer
(
)
?
HTMLEditUtils
:
:
GetLastTableCellElementChild
(
*
aPointToInsert
.
ContainerAs
<
Element
>
(
)
)
:
HTMLEditUtils
:
:
GetPreviousTableCellElementSibling
(
*
aPointToInsert
.
GetChild
(
)
)
;
MOZ_ASSERT
(
previousCellElement
)
;
CellIndexes
cellIndexes
(
*
previousCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
cellIndexes
.
mColumn
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
referenceColumnIndexOrError
.
isErr
(
)
)
)
{
return
referenceColumnIndexOrError
.
unwrapErr
(
)
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
error
.
SuppressException
(
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
if
(
referenceColumnIndexOrError
.
inspect
(
)
>
=
tableSize
.
mColumnCount
)
{
DebugOnly
<
nsresult
>
rv
=
NormalizeTableInternal
(
*
tableElement
)
;
if
(
MOZ_UNLIKELY
(
Destroyed
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
NormalizeTableInternal
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
NormalizeTableInternal
(
)
failed
but
ignored
"
)
;
}
AutoTArray
<
CellData
32
>
arrayOfCellData
;
{
arrayOfCellData
.
SetCapacity
(
tableSize
.
mRowCount
)
;
for
(
const
int32_t
rowIndex
:
IntegerRange
(
tableSize
.
mRowCount
)
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
tableElement
rowIndex
referenceColumnIndexOrError
.
inspect
(
)
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
arrayOfCellData
.
AppendElement
(
cellData
)
;
}
}
auto
cellElementToPutCaretOrError
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
RefPtr
<
Element
>
nsresult
>
{
nsAutoScriptBlockerSuppressNodeRemoved
blockToRunScript
;
RefPtr
<
Element
>
cellElementToPutCaret
;
for
(
const
CellData
&
cellData
:
arrayOfCellData
)
{
if
(
!
cellData
.
mElement
)
{
continue
;
}
if
(
(
!
insertAfterPreviousCell
&
&
cellData
.
IsSpannedFromOtherColumn
(
)
)
|
|
(
insertAfterPreviousCell
&
&
cellData
.
IsNextColumnSpannedFromOtherColumn
(
)
)
)
{
if
(
cellData
.
mColSpan
>
0
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetColSpan
(
cellData
.
mElement
cellData
.
mColSpan
+
aNumberOfColumnsToInsert
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetColSpan
(
)
failed
but
ignored
"
)
;
}
continue
;
}
EditorDOMPoint
pointToInsert
=
[
&
]
(
)
{
if
(
!
insertAfterPreviousCell
)
{
return
EditorDOMPoint
(
cellData
.
mElement
)
;
}
if
(
!
cellData
.
mElement
-
>
GetNextSibling
(
)
)
{
return
EditorDOMPoint
:
:
AtEndOf
(
*
cellData
.
mElement
-
>
GetParentNode
(
)
)
;
}
return
EditorDOMPoint
(
cellData
.
mElement
-
>
GetNextSibling
(
)
)
;
}
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
CreateElementResult
insertCellElementsResult
=
InsertTableCellsWithTransaction
(
pointToInsert
aNumberOfColumnsToInsert
)
;
if
(
insertCellElementsResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTableCellsWithTransaction
(
)
failed
"
)
;
return
Err
(
insertCellElementsResult
.
unwrapErr
(
)
)
;
}
insertCellElementsResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
pointToInsert
.
ContainerAs
<
Element
>
(
)
=
=
aPointToInsert
.
ContainerAs
<
Element
>
(
)
)
{
cellElementToPutCaret
=
insertCellElementsResult
.
UnwrapNewNode
(
)
;
MOZ_ASSERT
(
cellElementToPutCaret
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsTableCell
(
cellElementToPutCaret
)
)
;
}
}
return
cellElementToPutCaret
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
cellElementToPutCaretOrError
.
isErr
(
)
)
)
{
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
cellElementToPutCaretOrError
.
unwrapErr
(
)
;
}
const
RefPtr
<
Element
>
cellElementToPutCaret
=
cellElementToPutCaretOrError
.
unwrap
(
)
;
NS_WARNING_ASSERTION
(
cellElementToPutCaret
"
Didn
'
t
find
the
first
inserted
cell
element
in
the
specified
row
"
)
;
if
(
MOZ_LIKELY
(
cellElementToPutCaret
)
)
{
CollapseSelectionToDeepestNonTableFirstChild
(
cellElementToPutCaret
)
;
}
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
InsertTableRow
(
int32_t
aNumberOfRowsToInsert
bool
aInsertAfterSelectedCell
)
{
if
(
aNumberOfRowsToInsert
<
=
0
)
{
return
NS_OK
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eInsertTableRowElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
cellElementOrError
=
GetFirstSelectedCellElementInTable
(
)
;
if
(
cellElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstSelectedCellElementInTable
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
cellElementOrError
.
unwrapErr
(
)
)
;
}
if
(
!
cellElementOrError
.
inspect
(
)
)
{
return
NS_OK
;
}
rv
=
InsertTableRowsWithTransaction
(
MOZ_KnownLive
(
*
cellElementOrError
.
inspect
(
)
)
aNumberOfRowsToInsert
aInsertAfterSelectedCell
?
InsertPosition
:
:
eAfterSelectedCell
:
InsertPosition
:
:
eBeforeSelectedCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
InsertTableRowsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
InsertTableRowsWithTransaction
(
Element
&
aCellElement
int32_t
aNumberOfRowsToInsert
InsertPosition
aInsertPosition
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
MOZ_ASSERT
(
HTMLEditUtils
:
:
IsTableCell
(
&
aCellElement
)
)
;
const
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
presShell
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
MOZ_UNLIKELY
(
!
HTMLEditUtils
:
:
IsTableRow
(
aCellElement
.
GetParentElement
(
)
)
)
)
{
NS_WARNING
(
"
Tried
to
insert
columns
to
non
-
<
tr
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
const
RefPtr
<
Element
>
tableElement
=
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
aCellElement
)
;
if
(
MOZ_UNLIKELY
(
!
tableElement
)
)
{
return
NS_OK
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
tableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
MOZ_ASSERT
(
!
tableSize
.
IsEmpty
(
)
)
;
const
CellIndexes
cellIndexes
(
aCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
tableElement
cellIndexes
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
&
aCellElement
=
=
cellData
.
mElement
)
;
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
struct
ElementWithNewRowSpan
final
{
const
OwningNonNull
<
Element
>
mCellElement
;
const
int32_t
mNewRowSpan
;
ElementWithNewRowSpan
(
Element
&
aCellElement
int32_t
aNewRowSpan
)
:
mCellElement
(
aCellElement
)
mNewRowSpan
(
aNewRowSpan
)
{
}
}
;
AutoTArray
<
ElementWithNewRowSpan
16
>
cellElementsToModifyRowSpan
;
if
(
aInsertPosition
=
=
InsertPosition
:
:
eAfterSelectedCell
&
&
!
cellData
.
mRowSpan
)
{
cellElementsToModifyRowSpan
.
AppendElement
(
ElementWithNewRowSpan
(
aCellElement
cellData
.
mEffectiveRowSpan
)
)
;
}
struct
MOZ_STACK_CLASS
TableRowData
{
RefPtr
<
Element
>
mElement
;
int32_t
mNumberOfCellsInStartRow
;
int32_t
mOffsetInTRElementToPutCaret
;
}
;
const
auto
referenceRowDataOrError
=
[
&
]
(
)
-
>
Result
<
TableRowData
nsresult
>
{
const
int32_t
startRowIndex
=
aInsertPosition
=
=
InsertPosition
:
:
eBeforeSelectedCell
?
cellData
.
mCurrent
.
mRow
:
cellData
.
mCurrent
.
mRow
+
cellData
.
mEffectiveRowSpan
;
if
(
startRowIndex
<
tableSize
.
mRowCount
)
{
RefPtr
<
Element
>
referenceRowElement
;
int32_t
numberOfCellsInStartRow
=
0
;
int32_t
offsetInTRElementToPutCaret
=
0
;
for
(
int32_t
colIndex
=
0
;
;
)
{
const
auto
cellDataInStartRow
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
tableElement
startRowIndex
colIndex
)
;
if
(
cellDataInStartRow
.
FailedOrNotFound
(
)
)
{
break
;
}
if
(
!
cellDataInStartRow
.
mElement
)
{
NS_WARNING
(
"
CellData
:
:
Update
(
)
succeeded
but
didn
'
t
set
mElement
"
)
;
break
;
}
if
(
cellDataInStartRow
.
IsSpannedFromOtherRow
(
)
)
{
if
(
cellDataInStartRow
.
mRowSpan
>
0
)
{
cellElementsToModifyRowSpan
.
AppendElement
(
ElementWithNewRowSpan
(
*
cellDataInStartRow
.
mElement
cellDataInStartRow
.
mRowSpan
+
aNumberOfRowsToInsert
)
)
;
}
colIndex
=
cellDataInStartRow
.
NextColumnIndex
(
)
;
continue
;
}
if
(
colIndex
<
cellDataInStartRow
.
mCurrent
.
mColumn
)
{
offsetInTRElementToPutCaret
+
+
;
}
numberOfCellsInStartRow
+
=
cellDataInStartRow
.
mEffectiveColSpan
;
if
(
!
referenceRowElement
)
{
if
(
Element
*
maybeTableRowElement
=
cellDataInStartRow
.
mElement
-
>
GetParentElement
(
)
)
{
if
(
HTMLEditUtils
:
:
IsTableRow
(
maybeTableRowElement
)
)
{
referenceRowElement
=
maybeTableRowElement
;
}
}
}
MOZ_ASSERT
(
colIndex
<
cellDataInStartRow
.
NextColumnIndex
(
)
)
;
colIndex
=
cellDataInStartRow
.
NextColumnIndex
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
referenceRowElement
)
)
{
NS_WARNING
(
"
Reference
row
element
to
insert
new
row
elements
was
not
found
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
TableRowData
{
std
:
:
move
(
referenceRowElement
)
numberOfCellsInStartRow
offsetInTRElementToPutCaret
}
;
}
int32_t
numberOfCellsInStartRow
=
tableSize
.
mColumnCount
;
int32_t
offsetInTRElementToPutCaret
=
0
;
const
int32_t
lastRowIndex
=
tableSize
.
mRowCount
-
1
;
for
(
int32_t
colIndex
=
0
;
;
)
{
const
auto
cellDataInLastRow
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
tableElement
lastRowIndex
colIndex
)
;
if
(
cellDataInLastRow
.
FailedOrNotFound
(
)
)
{
break
;
}
if
(
!
cellDataInLastRow
.
mRowSpan
)
{
MOZ_ASSERT
(
numberOfCellsInStartRow
>
=
cellDataInLastRow
.
mEffectiveColSpan
)
;
numberOfCellsInStartRow
-
=
cellDataInLastRow
.
mEffectiveColSpan
;
}
else
if
(
colIndex
<
cellDataInLastRow
.
mCurrent
.
mColumn
)
{
offsetInTRElementToPutCaret
+
+
;
}
MOZ_ASSERT
(
colIndex
<
cellDataInLastRow
.
NextColumnIndex
(
)
)
;
colIndex
=
cellDataInLastRow
.
NextColumnIndex
(
)
;
}
return
TableRowData
{
nullptr
numberOfCellsInStartRow
offsetInTRElementToPutCaret
}
;
}
(
)
;
if
(
MOZ_UNLIKELY
(
referenceRowDataOrError
.
isErr
(
)
)
)
{
return
referenceRowDataOrError
.
inspectErr
(
)
;
}
const
TableRowData
&
referenceRowData
=
referenceRowDataOrError
.
inspect
(
)
;
if
(
MOZ_UNLIKELY
(
!
referenceRowData
.
mNumberOfCellsInStartRow
)
)
{
NS_WARNING
(
"
There
was
no
cell
element
in
the
row
"
)
;
return
NS_OK
;
}
MOZ_ASSERT_IF
(
referenceRowData
.
mElement
HTMLEditUtils
:
:
IsTableRow
(
referenceRowData
.
mElement
)
)
;
if
(
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsTableRow
(
aCellElement
.
GetParentElement
(
)
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
EditorDOMPoint
pointToInsert
=
[
&
]
(
)
{
if
(
aInsertPosition
=
=
InsertPosition
:
:
eBeforeSelectedCell
)
{
MOZ_ASSERT
(
referenceRowData
.
mElement
)
;
return
EditorDOMPoint
(
referenceRowData
.
mElement
)
;
}
Element
*
lastRowElement
=
nullptr
;
for
(
Element
*
rowElement
=
aCellElement
.
GetParentElement
(
)
;
rowElement
&
&
rowElement
!
=
referenceRowData
.
mElement
;
)
{
lastRowElement
=
rowElement
;
const
Result
<
RefPtr
<
Element
>
nsresult
>
nextRowElementOrError
=
GetNextTableRowElement
(
*
rowElement
)
;
if
(
MOZ_UNLIKELY
(
nextRowElementOrError
.
isErr
(
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetNextTableRowElement
(
)
failed
"
)
;
return
EditorDOMPoint
(
)
;
}
rowElement
=
nextRowElementOrError
.
inspect
(
)
;
}
MOZ_ASSERT
(
lastRowElement
)
;
return
EditorDOMPoint
:
:
After
(
*
lastRowElement
)
;
}
(
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
firstInsertedTRElementOrError
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
-
>
Result
<
RefPtr
<
Element
>
nsresult
>
{
nsAutoScriptBlockerSuppressNodeRemoved
blockToRunScript
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
for
(
const
ElementWithNewRowSpan
&
cellElementAndNewRowSpan
:
cellElementsToModifyRowSpan
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
SetRowSpan
(
MOZ_KnownLive
(
cellElementAndNewRowSpan
.
mCellElement
)
cellElementAndNewRowSpan
.
mNewRowSpan
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetRowSpan
(
)
failed
but
ignored
"
)
;
}
RefPtr
<
Element
>
firstInsertedTRElement
;
IgnoredErrorResult
error
;
for
(
[
[
maybe_unused
]
]
const
int32_t
rowIndex
:
Reversed
(
IntegerRange
(
aNumberOfRowsToInsert
)
)
)
{
RefPtr
<
Element
>
newRowElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
tr
)
;
if
(
!
newRowElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
tr
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
for
(
[
[
maybe_unused
]
]
const
int32_t
i
:
IntegerRange
(
referenceRowData
.
mNumberOfCellsInStartRow
)
)
{
const
RefPtr
<
Element
>
newCellElement
=
CreateElementWithDefaults
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
newCellElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateElementWithDefaults
(
nsGkAtoms
:
:
td
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
newRowElement
-
>
AppendChild
(
*
newCellElement
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
AppendChild
(
)
failed
"
)
;
return
Err
(
error
.
StealNSResult
(
)
)
;
}
}
AutoEditorDOMPointChildInvalidator
lockOffset
(
pointToInsert
)
;
CreateElementResult
insertNewRowResult
=
InsertNodeWithTransaction
<
Element
>
(
*
newRowElement
pointToInsert
)
;
if
(
insertNewRowResult
.
isErr
(
)
&
&
!
insertNewRowResult
.
EditorDestroyed
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
Err
(
insertNewRowResult
.
unwrapErr
(
)
)
;
}
firstInsertedTRElement
=
std
:
:
move
(
newRowElement
)
;
insertNewRowResult
.
IgnoreCaretPointSuggestion
(
)
;
}
return
firstInsertedTRElement
;
}
(
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
MOZ_UNLIKELY
(
firstInsertedTRElementOrError
.
isErr
(
)
)
)
{
return
firstInsertedTRElementOrError
.
unwrapErr
(
)
;
}
const
OwningNonNull
<
Element
>
cellElementToPutCaret
=
[
&
]
(
)
{
if
(
MOZ_LIKELY
(
firstInsertedTRElementOrError
.
inspect
(
)
)
)
{
EditorRawDOMPoint
point
(
firstInsertedTRElementOrError
.
inspect
(
)
referenceRowData
.
mOffsetInTRElementToPutCaret
)
;
if
(
MOZ_LIKELY
(
point
.
IsSetAndValid
(
)
)
&
&
MOZ_LIKELY
(
!
point
.
IsEndOfContainer
(
)
)
&
&
MOZ_LIKELY
(
HTMLEditUtils
:
:
IsTableCell
(
point
.
GetChild
(
)
)
)
)
{
return
OwningNonNull
<
Element
>
(
*
point
.
GetChild
(
)
-
>
AsElement
(
)
)
;
}
}
return
OwningNonNull
<
Element
>
(
aCellElement
)
;
}
(
)
;
CollapseSelectionToDeepestNonTableFirstChild
(
cellElementToPutCaret
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
Element
&
aTableElement
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
{
AutoHideSelectionChanges
hideSelection
(
SelectionRef
(
)
)
;
if
(
SelectionRef
(
)
.
RangeCount
(
)
)
{
ErrorResult
error
;
SelectionRef
(
)
.
RemoveAllRanges
(
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
RemoveAllRanges
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
&
aTableElement
)
;
ErrorResult
error
;
range
-
>
SelectNode
(
aTableElement
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsRange
:
:
SelectNode
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
SelectionRef
(
)
.
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
#
ifdef
DEBUG
range
=
SelectionRef
(
)
.
GetRangeAt
(
0
)
;
MOZ_ASSERT
(
range
)
;
MOZ_ASSERT
(
range
-
>
GetStartContainer
(
)
=
=
aTableElement
.
GetParent
(
)
)
;
MOZ_ASSERT
(
range
-
>
GetEndContainer
(
)
=
=
aTableElement
.
GetParent
(
)
)
;
MOZ_ASSERT
(
range
-
>
GetChildAtStartOffset
(
)
=
=
&
aTableElement
)
;
MOZ_ASSERT
(
range
-
>
GetChildAtEndOffset
(
)
=
=
aTableElement
.
GetNextSibling
(
)
)
;
#
endif
}
nsresult
rv
=
DeleteSelectionAsSubAction
(
eNext
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteSelectionAsSubAction
(
eNext
eStrip
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTable
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveTableElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
table
;
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
nullptr
nullptr
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
rv
=
DeleteTableElementAndChildrenWithTransaction
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableCell
(
int32_t
aNumberOfCellsToDelete
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveTableCellElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteTableCellWithTransaction
(
aNumberOfCellsToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableCellWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DeleteTableCellWithTransaction
(
int32_t
aNumberOfCellsToDelete
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
rv
;
}
if
(
!
table
|
|
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
SelectionRef
(
)
.
RangeCount
(
)
)
;
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
unwrapErr
(
)
;
}
TableSize
tableSize
=
tableSizeOrError
.
unwrap
(
)
;
MOZ_ASSERT
(
!
tableSize
.
IsEmpty
(
)
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
|
|
SelectionRef
(
)
.
RangeCount
(
)
=
=
1
)
{
for
(
int32_t
i
=
0
;
i
<
aNumberOfCellsToDelete
;
i
+
+
)
{
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
rv
;
}
if
(
!
table
|
|
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_OK
;
}
int32_t
numberOfCellsInRow
=
GetNumberOfCellsInRow
(
*
table
startRowIndex
)
;
NS_WARNING_ASSERTION
(
numberOfCellsInRow
>
=
0
"
HTMLEditor
:
:
GetNumberOfCellsInRow
(
)
failed
but
ignored
"
)
;
if
(
numberOfCellsInRow
=
=
1
)
{
if
(
tableSize
.
mRowCount
=
=
1
)
{
nsresult
rv
=
DeleteTableElementAndChildrenWithTransaction
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
DeleteSelectedTableRowsWithTransaction
(
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteSelectedTableRowsWithTransaction
(
1
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
tableSize
.
mRowCount
)
;
tableSize
.
mRowCount
-
-
;
continue
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
rv
=
DeleteNodeWithTransaction
(
*
cell
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
firstCellIndexes
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
presShell
)
;
if
(
NS_WARN_IF
(
firstCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
firstCellIndexes
.
mRow
;
startColIndex
=
firstCellIndexes
.
mColumn
;
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
bool
checkToDeleteRow
=
true
;
bool
checkToDeleteColumn
=
true
;
for
(
RefPtr
<
Element
>
selectedCellElement
=
scanner
.
GetFirstElement
(
)
;
selectedCellElement
;
)
{
if
(
checkToDeleteRow
)
{
checkToDeleteRow
=
false
;
if
(
AllCellsInRowSelected
(
table
startRowIndex
tableSize
.
mColumnCount
)
)
{
int32_t
nextRow
=
startRowIndex
;
while
(
nextRow
=
=
startRowIndex
)
{
selectedCellElement
=
scanner
.
GetNextElement
(
)
;
if
(
!
selectedCellElement
)
{
break
;
}
const
CellIndexes
nextSelectedCellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
nextSelectedCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nextRow
=
nextSelectedCellIndexes
.
mRow
;
startColIndex
=
nextSelectedCellIndexes
.
mColumn
;
}
if
(
tableSize
.
mRowCount
=
=
1
)
{
nsresult
rv
=
DeleteTableElementAndChildrenWithTransaction
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
nsresult
rv
=
DeleteTableRowWithTransaction
(
*
table
startRowIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableRowWithTransaction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
tableSize
.
mRowCount
)
;
tableSize
.
mRowCount
-
-
;
if
(
!
selectedCellElement
)
{
break
;
}
startRowIndex
=
nextRow
-
1
;
checkToDeleteRow
=
true
;
continue
;
}
}
if
(
checkToDeleteColumn
)
{
checkToDeleteColumn
=
false
;
if
(
AllCellsInColumnSelected
(
table
startColIndex
tableSize
.
mColumnCount
)
)
{
int32_t
nextCol
=
startColIndex
;
while
(
nextCol
=
=
startColIndex
)
{
selectedCellElement
=
scanner
.
GetNextElement
(
)
;
if
(
!
selectedCellElement
)
{
break
;
}
const
CellIndexes
nextSelectedCellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
nextSelectedCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
nextSelectedCellIndexes
.
mRow
;
nextCol
=
nextSelectedCellIndexes
.
mColumn
;
}
nsresult
rv
=
DeleteTableColumnWithTransaction
(
*
table
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableColumnWithTransaction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
tableSize
.
mColumnCount
)
;
tableSize
.
mColumnCount
-
-
;
if
(
!
selectedCellElement
)
{
break
;
}
startColIndex
=
nextCol
-
1
;
checkToDeleteColumn
=
true
;
continue
;
}
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
selectedCellElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
selectedCellElement
=
scanner
.
GetNextElement
(
)
;
if
(
!
selectedCellElement
)
{
return
NS_OK
;
}
const
CellIndexes
nextCellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
nextCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
nextCellIndexes
.
mRow
;
startColIndex
=
nextCellIndexes
.
mColumn
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableCellContents
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eDeleteTableCellContents
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteTableCellContentsWithTransaction
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableCellContentsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DeleteTableCellContentsWithTransaction
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
rv
;
}
if
(
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
cell
element
"
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
scanner
.
IsInTableCellSelectionMode
(
)
)
{
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
firstCellIndexes
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
presShell
)
;
if
(
NS_WARN_IF
(
firstCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
cell
=
scanner
.
ElementsRef
(
)
[
0
]
;
startRowIndex
=
firstCellIndexes
.
mRow
;
startColIndex
=
firstCellIndexes
.
mColumn
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
for
(
RefPtr
<
Element
>
selectedCellElement
=
std
:
:
move
(
cell
)
;
selectedCellElement
;
selectedCellElement
=
scanner
.
GetNextElement
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteAllChildrenWithTransaction
(
*
selectedCellElement
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteAllChildrenWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
)
{
break
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableColumn
(
int32_t
aNumberOfColumnsToDelete
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveTableColumn
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteSelectedTableColumnsWithTransaction
(
aNumberOfColumnsToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteSelectedTableColumnsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DeleteSelectedTableColumnsWithTransaction
(
int32_t
aNumberOfColumnsToDelete
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
rv
;
}
if
(
!
table
|
|
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_OK
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
startColIndex
&
&
aNumberOfColumnsToDelete
>
=
tableSize
.
mColumnCount
)
{
nsresult
rv
=
DeleteTableElementAndChildrenWithTransaction
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
scanner
.
IsInTableCellSelectionMode
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
>
1
)
{
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
firstCellIndexes
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
presShell
)
;
if
(
NS_WARN_IF
(
firstCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
firstCellIndexes
.
mRow
;
startColIndex
=
firstCellIndexes
.
mColumn
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousRow
false
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
|
|
SelectionRef
(
)
.
RangeCount
(
)
=
=
1
)
{
int32_t
columnCountToRemove
=
std
:
:
min
(
aNumberOfColumnsToDelete
tableSize
.
mColumnCount
-
startColIndex
)
;
for
(
int32_t
i
=
0
;
i
<
columnCountToRemove
;
i
+
+
)
{
nsresult
rv
=
DeleteTableColumnWithTransaction
(
*
table
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableColumnWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
for
(
RefPtr
<
Element
>
selectedCellElement
=
scanner
.
GetFirstElement
(
)
;
selectedCellElement
;
)
{
if
(
selectedCellElement
!
=
scanner
.
ElementsRef
(
)
[
0
]
)
{
const
CellIndexes
cellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
cellIndexes
.
mRow
;
startColIndex
=
cellIndexes
.
mColumn
;
}
int32_t
nextCol
=
startColIndex
;
while
(
nextCol
=
=
startColIndex
)
{
selectedCellElement
=
scanner
.
GetNextElement
(
)
;
if
(
!
selectedCellElement
)
{
break
;
}
const
CellIndexes
cellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
cellIndexes
.
mRow
;
nextCol
=
cellIndexes
.
mColumn
;
}
nsresult
rv
=
DeleteTableColumnWithTransaction
(
*
table
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableColumnWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteTableColumnWithTransaction
(
Element
&
aTableElement
int32_t
aColumnIndex
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
for
(
int32_t
rowIndex
=
0
;
;
rowIndex
+
+
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
aTableElement
rowIndex
aColumnIndex
)
;
if
(
cellData
.
FailedOrNotFound
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
cellData
.
mColSpan
>
=
0
)
;
if
(
cellData
.
IsSpannedFromOtherColumn
(
)
|
|
cellData
.
mColSpan
!
=
1
)
{
if
(
cellData
.
mColSpan
>
0
)
{
NS_WARNING_ASSERTION
(
cellData
.
mColSpan
>
1
"
colspan
should
be
2
or
larger
"
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
SetColSpan
(
cellData
.
mElement
cellData
.
mColSpan
-
1
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetColSpan
(
)
failed
but
ignored
"
)
;
}
if
(
!
cellData
.
IsSpannedFromOtherColumn
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
DeleteAllChildrenWithTransaction
(
*
cellData
.
mElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
DeleteAllChildrenWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
}
rowIndex
+
=
cellData
.
NumberOfFollowingRows
(
)
;
continue
;
}
int32_t
numberOfCellsInRow
=
GetNumberOfCellsInRow
(
aTableElement
cellData
.
mCurrent
.
mRow
)
;
NS_WARNING_ASSERTION
(
numberOfCellsInRow
>
0
"
HTMLEditor
:
:
GetNumberOfCellsInRow
(
)
failed
but
ignored
"
)
;
if
(
numberOfCellsInRow
!
=
1
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
cellData
.
mElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rowIndex
+
=
cellData
.
NumberOfFollowingRows
(
)
;
continue
;
}
Element
*
parentRow
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
tr
*
cellData
.
mElement
)
;
if
(
!
parentRow
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
tr
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
aTableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
if
(
tableSize
.
mRowCount
=
=
1
)
{
nsresult
rv
=
DeleteTableElementAndChildrenWithTransaction
(
aTableElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
DeleteTableRowWithTransaction
(
aTableElement
cellData
.
mFirst
.
mRow
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableRowWithTransaction
(
)
failed
"
)
;
return
rv
;
}
rowIndex
-
-
;
}
}
NS_IMETHODIMP
HTMLEditor
:
:
DeleteTableRow
(
int32_t
aNumberOfRowsToDelete
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eRemoveTableRowElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
DeleteSelectedTableRowsWithTransaction
(
aNumberOfRowsToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteSelectedTableRowsWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
DeleteSelectedTableRowsWithTransaction
(
int32_t
aNumberOfRowsToDelete
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
int32_t
startRowIndex
startColIndex
;
nsresult
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
rv
;
}
if
(
!
table
|
|
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_OK
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
startRowIndex
&
&
aNumberOfRowsToDelete
>
=
tableSize
.
mRowCount
)
{
nsresult
rv
=
DeleteTableElementAndChildrenWithTransaction
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTableElementAndChildrenWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
scanner
.
IsInTableCellSelectionMode
(
)
&
&
SelectionRef
(
)
.
RangeCount
(
)
>
1
)
{
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
firstCellIndexes
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
presShell
)
;
if
(
NS_WARN_IF
(
firstCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
firstCellIndexes
.
mRow
;
startColIndex
=
firstCellIndexes
.
mColumn
;
}
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousRow
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
|
|
SelectionRef
(
)
.
RangeCount
(
)
=
=
1
)
{
int32_t
rowCountToRemove
=
std
:
:
min
(
aNumberOfRowsToDelete
tableSize
.
mRowCount
-
startRowIndex
)
;
for
(
int32_t
i
=
0
;
i
<
rowCountToRemove
;
i
+
+
)
{
nsresult
rv
=
DeleteTableRowWithTransaction
(
*
table
startRowIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableRowWithTransaction
(
)
failed
but
trying
"
"
next
.
.
.
"
)
;
startRowIndex
+
+
;
}
cell
=
GetTableCellElementAt
(
*
table
startRowIndex
startColIndex
)
;
if
(
!
cell
)
{
return
NS_OK
;
}
}
return
NS_OK
;
}
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
for
(
RefPtr
<
Element
>
selectedCellElement
=
scanner
.
GetFirstElement
(
)
;
selectedCellElement
;
)
{
if
(
selectedCellElement
!
=
scanner
.
ElementsRef
(
)
[
0
]
)
{
const
CellIndexes
cellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
startRowIndex
=
cellIndexes
.
mRow
;
startColIndex
=
cellIndexes
.
mColumn
;
}
int32_t
nextRow
=
startRowIndex
;
while
(
nextRow
=
=
startRowIndex
)
{
selectedCellElement
=
scanner
.
GetNextElement
(
)
;
if
(
!
selectedCellElement
)
{
break
;
}
const
CellIndexes
cellIndexes
(
*
selectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nextRow
=
cellIndexes
.
mRow
;
startColIndex
=
cellIndexes
.
mColumn
;
}
nsresult
rv
=
DeleteTableRowWithTransaction
(
*
table
startRowIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTableRowWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
DeleteTableRowWithTransaction
(
Element
&
aTableElement
int32_t
aRowIndex
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
aTableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
error
.
SuppressException
(
)
;
struct
MOZ_STACK_CLASS
SpanCell
final
{
RefPtr
<
Element
>
mElement
;
int32_t
mNewRowSpanValue
;
SpanCell
(
Element
*
aSpanCellElement
int32_t
aNewRowSpanValue
)
:
mElement
(
aSpanCellElement
)
mNewRowSpanValue
(
aNewRowSpanValue
)
{
}
}
;
AutoTArray
<
SpanCell
10
>
spanCellArray
;
RefPtr
<
Element
>
cellInDeleteRow
;
int32_t
columnIndex
=
0
;
while
(
aRowIndex
<
tableSize
.
mRowCount
&
&
columnIndex
<
tableSize
.
mColumnCount
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
aTableElement
aRowIndex
columnIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
cellData
.
mElement
)
{
break
;
}
if
(
cellData
.
IsSpannedFromOtherRow
(
)
)
{
if
(
cellData
.
mRowSpan
>
0
)
{
int32_t
newRowSpanValue
=
std
:
:
max
(
cellData
.
NumberOfPrecedingRows
(
)
cellData
.
NumberOfFollowingRows
(
)
)
;
spanCellArray
.
AppendElement
(
SpanCell
(
cellData
.
mElement
newRowSpanValue
)
)
;
}
}
else
{
if
(
cellData
.
mRowSpan
>
1
)
{
int32_t
aboveRowToInsertNewCellInto
=
cellData
.
NumberOfPrecedingRows
(
)
+
1
;
nsresult
rv
=
SplitCellIntoRows
(
&
aTableElement
cellData
.
mFirst
.
mRow
cellData
.
mFirst
.
mColumn
aboveRowToInsertNewCellInto
cellData
.
NumberOfFollowingRows
(
)
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitCellIntoRows
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
cellInDeleteRow
)
{
cellInDeleteRow
=
std
:
:
move
(
cellData
.
mElement
)
;
}
}
columnIndex
+
=
cellData
.
mEffectiveColSpan
;
}
if
(
!
cellInDeleteRow
)
{
NS_WARNING
(
"
There
was
no
cell
in
deleting
row
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
parentRow
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
tr
*
cellInDeleteRow
)
;
if
(
parentRow
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
parentRow
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
tr
)
"
"
failed
"
)
;
return
rv
;
}
}
for
(
SpanCell
&
spanCell
:
spanCellArray
)
{
if
(
NS_WARN_IF
(
!
spanCell
.
mElement
)
)
{
continue
;
}
nsresult
rv
=
SetRowSpan
(
MOZ_KnownLive
(
spanCell
.
mElement
)
spanCell
.
mNewRowSpanValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetRawSpan
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTable
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSelectTable
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectTable
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
table
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
NS_OK
;
}
rv
=
ClearSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearSelection
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
AppendContentToSelectionAsRange
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableCell
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSelectTableCell
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectTableCell
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
cell
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
td
)
"
"
failed
"
)
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
rv
=
ClearSelection
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearSelection
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
AppendContentToSelectionAsRange
(
*
cell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectAllTableCells
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSelectAllTableCells
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectAllTableCells
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
cell
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
td
)
"
"
failed
"
)
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
Element
>
startCell
=
cell
;
RefPtr
<
Element
>
table
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
*
cell
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
SelectionBatcher
selectionBatcher
(
SelectionRef
(
)
__FUNCTION__
)
;
rv
=
ClearSelection
(
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearSelection
(
)
caused
destroying
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ClearSelection
(
)
failed
but
might
be
ignored
"
)
;
bool
cellSelected
=
false
;
auto
AppendContentToStartCell
=
[
&
]
(
)
MOZ_CAN_RUN_SCRIPT
{
MOZ_ASSERT
(
!
cellSelected
)
;
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
startCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
;
for
(
int32_t
row
=
0
;
row
<
tableSize
.
mRowCount
;
row
+
+
)
{
for
(
int32_t
col
=
0
;
col
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
row
col
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
!
cellSelected
?
AppendContentToStartCell
(
)
:
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mElement
&
&
!
cellData
.
IsSpannedFromOtherRowOrColumn
(
)
)
{
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
cellData
.
mElement
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
caused
"
"
destroying
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
but
"
"
might
be
ignored
"
)
;
return
!
cellSelected
?
AppendContentToStartCell
(
)
:
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
cellSelected
=
true
;
}
MOZ_ASSERT
(
col
<
cellData
.
NextColumnIndex
(
)
)
;
col
=
cellData
.
NextColumnIndex
(
)
;
}
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableRow
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSelectTableRow
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectTableRow
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
cell
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
td
)
"
"
failed
"
)
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
Element
>
startCell
=
cell
;
RefPtr
<
Element
>
table
;
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
SelectionBatcher
selectionBatcher
(
SelectionRef
(
)
__FUNCTION__
)
;
rv
=
ClearSelection
(
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearSelection
(
)
caused
destroying
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ClearSelection
(
)
failed
but
might
be
ignored
"
)
;
bool
cellSelected
=
false
;
for
(
int32_t
col
=
0
;
col
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
startRowIndex
col
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
if
(
cellSelected
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
startCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
NS_WARNING_ASSERTION
(
cellData
.
isOk
(
)
|
|
NS_SUCCEEDED
(
rv
)
|
|
NS_FAILED
(
EditorBase
:
:
ToGenericNSResult
(
rv
)
)
"
CellData
:
:
AtIndexInTableElement
(
)
failed
but
ignored
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
cellData
.
mElement
&
&
!
cellData
.
IsSpannedFromOtherRowOrColumn
(
)
)
{
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
cellData
.
mElement
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
caused
destroying
"
"
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
cellSelected
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rvTryAgain
=
AppendContentToSelectionAsRange
(
*
startCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
EditorBase
:
:
ToGenericNSResult
(
rv
)
)
|
|
NS_SUCCEEDED
(
rvTryAgain
)
|
|
NS_FAILED
(
EditorBase
:
:
ToGenericNSResult
(
rvTryAgain
)
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
*
cellData
.
mElement
)
"
"
failed
but
ignored
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rvTryAgain
)
;
}
cellSelected
=
true
;
}
MOZ_ASSERT
(
col
<
cellData
.
NextColumnIndex
(
)
)
;
col
=
cellData
.
NextColumnIndex
(
)
;
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SelectTableColumn
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSelectTableColumn
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SelectTableColumn
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
cell
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
if
(
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
td
)
"
"
failed
"
)
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
RefPtr
<
Element
>
startCell
=
cell
;
RefPtr
<
Element
>
table
;
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
element
"
)
;
return
NS_ERROR_FAILURE
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
SelectionBatcher
selectionBatcher
(
SelectionRef
(
)
__FUNCTION__
)
;
rv
=
ClearSelection
(
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ClearSelection
(
)
caused
destroying
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ClearSelection
(
)
failed
but
might
be
ignored
"
)
;
bool
cellSelected
=
false
;
for
(
int32_t
row
=
0
;
row
<
tableSize
.
mRowCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
row
startColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
if
(
cellSelected
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
startCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
NS_WARNING_ASSERTION
(
cellData
.
isOk
(
)
|
|
NS_SUCCEEDED
(
rv
)
|
|
NS_FAILED
(
EditorBase
:
:
ToGenericNSResult
(
rv
)
)
"
CellData
:
:
AtIndexInTableElement
(
)
failed
but
ignored
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
cellData
.
mElement
&
&
!
cellData
.
IsSpannedFromOtherRowOrColumn
(
)
)
{
nsresult
rv
=
AppendContentToSelectionAsRange
(
*
cellData
.
mElement
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
caused
destroying
"
"
the
editor
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
cellSelected
)
{
NS_WARNING
(
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
rvTryAgain
=
AppendContentToSelectionAsRange
(
*
startCell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
)
failed
"
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
EditorBase
:
:
ToGenericNSResult
(
rv
)
)
|
|
NS_SUCCEEDED
(
rvTryAgain
)
|
|
NS_FAILED
(
EditorBase
:
:
ToGenericNSResult
(
rvTryAgain
)
)
"
HTMLEditor
:
:
AppendContentToSelectionAsRange
(
*
cellData
.
mElement
)
"
"
failed
but
ignored
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rvTryAgain
)
;
}
cellSelected
=
true
;
}
MOZ_ASSERT
(
row
<
cellData
.
NextRowIndex
(
)
)
;
row
=
cellData
.
NextRowIndex
(
)
;
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SplitTableCell
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSplitTableCellElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
int32_t
startRowIndex
startColIndex
actualRowSpan
actualColSpan
;
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
cell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
table
|
|
!
cell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
rv
=
GetCellSpansAt
(
table
startRowIndex
startColIndex
actualRowSpan
actualColSpan
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellSpansAt
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
actualRowSpan
<
=
1
&
&
actualColSpan
<
=
1
)
{
return
NS_OK
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoSelectionSetterAfterTableEdit
setCaret
(
*
this
table
startRowIndex
startColIndex
ePreviousColumn
false
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
RefPtr
<
Element
>
newCell
;
int32_t
rowIndex
=
startRowIndex
;
int32_t
rowSpanBelow
colSpanAfter
;
for
(
rowSpanBelow
=
actualRowSpan
-
1
;
rowSpanBelow
>
=
0
;
rowSpanBelow
-
-
)
{
if
(
rowSpanBelow
>
0
)
{
nsresult
rv
=
SplitCellIntoRows
(
table
rowIndex
startColIndex
1
rowSpanBelow
getter_AddRefs
(
newCell
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitCellIntoRows
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CopyCellBackgroundColor
(
newCell
cell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
CopyCellBackgroundColor
(
)
failed
but
ignored
"
)
;
}
int32_t
colIndex
=
startColIndex
;
for
(
colSpanAfter
=
actualColSpan
-
1
;
colSpanAfter
>
0
;
colSpanAfter
-
-
)
{
nsresult
rv
=
SplitCellIntoColumns
(
table
rowIndex
colIndex
1
colSpanAfter
getter_AddRefs
(
newCell
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitCellIntoColumns
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CopyCellBackgroundColor
(
newCell
cell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CopyCellBackgroundColor
(
)
failed
but
ignored
"
)
;
colIndex
+
+
;
}
rowIndex
+
+
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
CopyCellBackgroundColor
(
Element
*
aDestCell
Element
*
aSourceCell
)
{
if
(
NS_WARN_IF
(
!
aDestCell
)
|
|
NS_WARN_IF
(
!
aSourceCell
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aSourceCell
-
>
HasAttr
(
nsGkAtoms
:
:
bgcolor
)
)
{
return
NS_OK
;
}
nsString
backgroundColor
;
aSourceCell
-
>
GetAttr
(
nsGkAtoms
:
:
bgcolor
backgroundColor
)
;
nsresult
rv
=
SetAttributeWithTransaction
(
*
aDestCell
*
nsGkAtoms
:
:
bgcolor
backgroundColor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
bgcolor
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SplitCellIntoColumns
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aColSpanLeft
int32_t
aColSpanRight
Element
*
*
aNewCell
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aNewCell
)
{
*
aNewCell
=
nullptr
;
}
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
aRowIndex
aColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mEffectiveColSpan
<
=
1
|
|
aColSpanLeft
+
aColSpanRight
>
cellData
.
mEffectiveColSpan
)
{
return
NS_OK
;
}
nsresult
rv
=
SetColSpan
(
cellData
.
mElement
aColSpanLeft
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetColSpan
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
newCellElement
;
rv
=
InsertCell
(
cellData
.
mElement
cellData
.
mEffectiveRowSpan
aColSpanRight
true
false
getter_AddRefs
(
newCellElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertCell
(
)
failed
"
)
;
return
rv
;
}
if
(
!
newCellElement
)
{
return
NS_OK
;
}
if
(
aNewCell
)
{
*
aNewCell
=
do_AddRef
(
newCellElement
)
.
take
(
)
;
}
rv
=
CopyCellBackgroundColor
(
newCellElement
cellData
.
mElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CopyCellBackgroundColor
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SplitCellIntoRows
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
aRowSpanAbove
int32_t
aRowSpanBelow
Element
*
*
aNewCell
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aNewCell
)
{
*
aNewCell
=
nullptr
;
}
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
aRowIndex
aColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mEffectiveRowSpan
<
=
1
|
|
aRowSpanAbove
+
aRowSpanBelow
>
cellData
.
mEffectiveRowSpan
)
{
return
NS_OK
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
aTable
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
RefPtr
<
Element
>
cellElementAtInsertionPoint
;
RefPtr
<
Element
>
lastCellFound
;
bool
insertAfter
=
(
cellData
.
mFirst
.
mColumn
>
0
)
;
for
(
int32_t
colIndex
=
0
rowBelowIndex
=
cellData
.
mFirst
.
mRow
+
aRowSpanAbove
;
colIndex
<
=
tableSize
.
mColumnCount
;
)
{
const
auto
cellDataAtInsertionPoint
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
rowBelowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellDataAtInsertionPoint
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
cellElementAtInsertionPoint
=
cellDataAtInsertionPoint
.
mElement
;
if
(
cellDataAtInsertionPoint
.
mElement
&
&
!
cellDataAtInsertionPoint
.
IsSpannedFromOtherRow
(
)
)
{
if
(
!
insertAfter
)
{
break
;
}
if
(
cellDataAtInsertionPoint
.
NextColumnIndex
(
)
=
=
cellData
.
mFirst
.
mColumn
)
{
break
;
}
if
(
cellDataAtInsertionPoint
.
mFirst
.
mColumn
>
cellData
.
mFirst
.
mColumn
)
{
insertAfter
=
false
;
break
;
}
lastCellFound
=
cellDataAtInsertionPoint
.
mElement
;
}
MOZ_ASSERT
(
colIndex
<
cellDataAtInsertionPoint
.
NextColumnIndex
(
)
)
;
colIndex
=
cellDataAtInsertionPoint
.
NextColumnIndex
(
)
;
}
if
(
!
cellElementAtInsertionPoint
&
&
lastCellFound
)
{
cellElementAtInsertionPoint
=
std
:
:
move
(
lastCellFound
)
;
insertAfter
=
true
;
}
nsresult
rv
=
SetRowSpan
(
cellData
.
mElement
aRowSpanAbove
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetRowSpan
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
Element
>
newCell
;
rv
=
InsertCell
(
cellElementAtInsertionPoint
aRowSpanBelow
cellData
.
mEffectiveColSpan
insertAfter
false
getter_AddRefs
(
newCell
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertCell
(
)
failed
"
)
;
return
rv
;
}
if
(
!
newCell
)
{
return
NS_OK
;
}
if
(
aNewCell
)
{
*
aNewCell
=
do_AddRef
(
newCell
)
.
take
(
)
;
}
rv
=
CopyCellBackgroundColor
(
newCell
cellElementAtInsertionPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
CopyCellBackgroundColor
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SwitchTableCellHeaderType
(
Element
*
aSourceCell
Element
*
*
aNewCell
)
{
if
(
NS_WARN_IF
(
!
aSourceCell
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eSetTableCellElementType
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
ignoredError
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
nsAtom
*
newCellName
=
aSourceCell
-
>
IsHTMLElement
(
nsGkAtoms
:
:
td
)
?
nsGkAtoms
:
:
th
:
nsGkAtoms
:
:
td
;
CreateElementResult
newCellElementOrError
=
ReplaceContainerAndCloneAttributesWithTransaction
(
*
aSourceCell
MOZ_KnownLive
(
*
newCellName
)
)
;
if
(
newCellElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
ReplaceContainerAndCloneAttributesWithTransaction
(
)
"
"
failed
"
)
;
return
newCellElementOrError
.
unwrapErr
(
)
;
}
newCellElementOrError
.
IgnoreCaretPointSuggestion
(
)
;
if
(
aNewCell
)
{
newCellElementOrError
.
UnwrapNewNode
(
)
.
forget
(
aNewCell
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
JoinTableCells
(
bool
aMergeNonContiguousContents
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eJoinTableCellElements
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
targetCell
;
int32_t
startRowIndex
startColIndex
;
rv
=
GetCellContext
(
getter_AddRefs
(
table
)
getter_AddRefs
(
targetCell
)
nullptr
nullptr
&
startRowIndex
&
startColIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
table
|
|
!
targetCell
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellContext
(
)
didn
'
t
return
<
table
>
and
/
or
cell
"
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
AutoTransactionsConserveSelection
dontChangeSelection
(
*
this
)
;
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
scanner
.
ElementsRef
(
)
.
Length
(
)
>
1
)
{
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
unwrapErr
(
)
)
;
}
TableSize
tableSize
=
tableSizeOrError
.
unwrap
(
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
const
CellIndexes
firstSelectedCellIndexes
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
presShell
)
;
if
(
NS_WARN_IF
(
firstSelectedCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
firstRowSpan
firstColSpan
;
nsresult
rv
=
GetCellSpansAt
(
table
firstSelectedCellIndexes
.
mRow
firstSelectedCellIndexes
.
mColumn
firstRowSpan
firstColSpan
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellSpansAt
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
int32_t
lastRowIndex
=
firstSelectedCellIndexes
.
mRow
;
int32_t
lastColIndex
=
firstSelectedCellIndexes
.
mColumn
;
for
(
int32_t
rowIndex
=
firstSelectedCellIndexes
.
mRow
;
rowIndex
<
=
lastRowIndex
;
rowIndex
+
+
)
{
int32_t
currentRowCount
=
tableSize
.
mRowCount
;
rv
=
FixBadRowSpan
(
table
rowIndex
tableSize
.
mRowCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FixBadRowSpan
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
lastRowIndex
-
=
currentRowCount
-
tableSize
.
mRowCount
;
bool
cellFoundInRow
=
false
;
bool
lastRowIsSet
=
false
;
int32_t
lastColInRow
=
0
;
int32_t
firstColInRow
=
firstSelectedCellIndexes
.
mColumn
;
int32_t
colIndex
=
firstSelectedCellIndexes
.
mColumn
;
for
(
;
colIndex
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
rowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mIsSelected
)
{
if
(
!
cellFoundInRow
)
{
firstColInRow
=
cellData
.
mCurrent
.
mColumn
;
}
if
(
cellData
.
mCurrent
.
mRow
>
firstSelectedCellIndexes
.
mRow
&
&
firstColInRow
!
=
firstSelectedCellIndexes
.
mColumn
)
{
lastRowIndex
=
std
:
:
max
(
0
cellData
.
mCurrent
.
mRow
-
1
)
;
lastRowIsSet
=
true
;
break
;
}
lastColInRow
=
cellData
.
LastColumnIndex
(
)
;
cellFoundInRow
=
true
;
}
else
if
(
cellFoundInRow
)
{
if
(
cellData
.
mCurrent
.
mRow
>
firstSelectedCellIndexes
.
mRow
+
1
&
&
cellData
.
mCurrent
.
mColumn
<
=
lastColIndex
)
{
lastRowIndex
=
std
:
:
max
(
0
cellData
.
mCurrent
.
mRow
-
1
)
;
lastRowIsSet
=
true
;
}
break
;
}
MOZ_ASSERT
(
colIndex
<
cellData
.
NextColumnIndex
(
)
)
;
colIndex
=
cellData
.
NextColumnIndex
(
)
;
}
if
(
cellFoundInRow
)
{
if
(
rowIndex
=
=
firstSelectedCellIndexes
.
mRow
)
{
lastColIndex
=
lastColInRow
;
}
if
(
!
lastRowIsSet
)
{
if
(
colIndex
<
lastColIndex
)
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
}
else
{
lastRowIndex
=
rowIndex
+
1
;
}
}
lastColIndex
=
std
:
:
min
(
lastColIndex
lastColInRow
)
;
}
else
{
lastRowIndex
=
std
:
:
max
(
0
rowIndex
-
1
)
;
}
}
nsTArray
<
RefPtr
<
Element
>
>
deleteList
;
for
(
int32_t
rowIndex
=
0
;
rowIndex
<
tableSize
.
mRowCount
;
rowIndex
+
+
)
{
for
(
int32_t
colIndex
=
0
;
colIndex
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
rowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
cellData
.
mEffectiveColSpan
)
{
break
;
}
if
(
cellData
.
mIsSelected
&
&
cellData
.
mElement
!
=
scanner
.
ElementsRef
(
)
[
0
]
)
{
if
(
cellData
.
mCurrent
.
mRow
>
=
firstSelectedCellIndexes
.
mRow
&
&
cellData
.
mCurrent
.
mRow
<
=
lastRowIndex
&
&
cellData
.
mCurrent
.
mColumn
>
=
firstSelectedCellIndexes
.
mColumn
&
&
cellData
.
mCurrent
.
mColumn
<
=
lastColIndex
)
{
NS_ASSERTION
(
!
cellData
.
IsSpannedFromOtherRow
(
)
"
JoinTableCells
:
StartRowIndex
is
in
row
above
"
)
;
if
(
cellData
.
mEffectiveColSpan
>
1
)
{
int32_t
extraColSpan
=
cellData
.
mFirst
.
mColumn
+
cellData
.
mEffectiveColSpan
-
(
lastColIndex
+
1
)
;
if
(
extraColSpan
>
0
)
{
nsresult
rv
=
SplitCellIntoColumns
(
table
cellData
.
mFirst
.
mRow
cellData
.
mFirst
.
mColumn
cellData
.
mEffectiveColSpan
-
extraColSpan
extraColSpan
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitCellIntoColumns
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
}
nsresult
rv
=
MergeCells
(
scanner
.
ElementsRef
(
)
[
0
]
cellData
.
mElement
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MergeCells
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
deleteList
.
AppendElement
(
cellData
.
mElement
.
get
(
)
)
;
}
else
if
(
aMergeNonContiguousContents
)
{
nsresult
rv
=
MergeCells
(
scanner
.
ElementsRef
(
)
[
0
]
cellData
.
mElement
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MergeCells
(
)
failed
"
)
;
return
rv
;
}
}
}
MOZ_ASSERT
(
colIndex
<
cellData
.
NextColumnIndex
(
)
)
;
colIndex
=
cellData
.
NextColumnIndex
(
)
;
}
}
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
error
.
StealNSResult
(
)
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
"
"
failed
but
ignored
"
)
;
for
(
uint32_t
i
=
0
n
=
deleteList
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
RefPtr
<
Element
>
nodeToBeRemoved
=
deleteList
[
i
]
;
if
(
nodeToBeRemoved
)
{
nsresult
rv
=
DeleteNodeWithTransaction
(
*
nodeToBeRemoved
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
}
uint32_t
rangeCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
RefPtr
<
nsRange
>
range
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
range
=
SelectionRef
(
)
.
GetRangeAt
(
i
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
deletedCell
=
HTMLEditUtils
:
:
GetTableCellElementIfOnlyOneSelected
(
*
range
)
;
if
(
!
deletedCell
)
{
SelectionRef
(
)
.
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
error
)
;
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
Selection
:
:
RemoveRangeAndUnselectFramesAndNotifyListeners
(
)
"
"
failed
but
ignored
"
)
;
rangeCount
-
-
;
i
-
-
;
}
}
rv
=
SetRowSpan
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
lastRowIndex
-
firstSelectedCellIndexes
.
mRow
+
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetRowSpan
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetColSpan
(
MOZ_KnownLive
(
scanner
.
ElementsRef
(
)
[
0
]
)
lastColIndex
-
firstSelectedCellIndexes
.
mColumn
+
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetColSpan
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
NormalizeTableInternal
(
*
table
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
NormalizeTableInternal
(
)
failed
but
ignored
"
)
;
}
else
{
const
auto
leftCellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
startRowIndex
startColIndex
)
;
if
(
NS_WARN_IF
(
leftCellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
auto
rightCellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
leftCellData
.
mFirst
.
mRow
leftCellData
.
mFirst
.
mColumn
+
leftCellData
.
mEffectiveColSpan
)
;
if
(
NS_WARN_IF
(
rightCellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
rightCellData
.
mElement
)
{
return
NS_OK
;
}
NS_ASSERTION
(
rightCellData
.
mCurrent
.
mRow
>
=
rightCellData
.
mFirst
.
mRow
"
JoinCells
:
rightCellData
.
mCurrent
.
mRow
<
rightCellData
.
mFirst
.
mRow
"
)
;
int32_t
spanAboveMergedCell
=
rightCellData
.
NumberOfPrecedingRows
(
)
;
int32_t
effectiveRowSpan2
=
rightCellData
.
mEffectiveRowSpan
-
spanAboveMergedCell
;
if
(
effectiveRowSpan2
>
leftCellData
.
mEffectiveRowSpan
)
{
nsresult
rv
=
SplitCellIntoRows
(
table
rightCellData
.
mFirst
.
mRow
rightCellData
.
mFirst
.
mColumn
spanAboveMergedCell
+
leftCellData
.
mEffectiveRowSpan
effectiveRowSpan2
-
leftCellData
.
mEffectiveRowSpan
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitCellIntoRows
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
nsresult
rv
=
MergeCells
(
leftCellData
.
mElement
rightCellData
.
mElement
!
rightCellData
.
IsSpannedFromOtherRow
(
)
&
&
effectiveRowSpan2
>
=
leftCellData
.
mEffectiveRowSpan
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MergeCells
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
effectiveRowSpan2
<
leftCellData
.
mEffectiveRowSpan
)
{
return
NS_OK
;
}
if
(
spanAboveMergedCell
>
0
)
{
nsresult
rv
=
SetRowSpan
(
rightCellData
.
mElement
spanAboveMergedCell
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetRowSpan
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
rv
=
SetColSpan
(
leftCellData
.
mElement
leftCellData
.
mEffectiveColSpan
+
rightCellData
.
mEffectiveColSpan
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetColSpan
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
MergeCells
(
RefPtr
<
Element
>
aTargetCell
RefPtr
<
Element
>
aCellToMerge
bool
aDeleteCellToMerge
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aTargetCell
)
|
|
NS_WARN_IF
(
!
aCellToMerge
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
IgnoredErrorResult
ignoredError
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eDeleteNode
nsIEditor
:
:
eNext
ignoredError
)
;
if
(
NS_WARN_IF
(
ignoredError
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
ignoredError
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
if
(
!
IsEmptyCell
(
aCellToMerge
)
)
{
int32_t
insertIndex
=
0
;
uint32_t
len
=
aTargetCell
-
>
GetChildCount
(
)
;
if
(
len
=
=
1
&
&
IsEmptyCell
(
aTargetCell
)
)
{
nsCOMPtr
<
nsIContent
>
cellChild
=
aTargetCell
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
cellChild
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
cellChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
insertIndex
=
0
;
}
else
{
insertIndex
=
(
int32_t
)
len
;
}
EditorDOMPoint
pointToPutCaret
;
while
(
aCellToMerge
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
cellChild
=
aCellToMerge
-
>
GetLastChild
(
)
;
if
(
NS_WARN_IF
(
!
cellChild
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
cellChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
CreateContentResult
insertChildContentResult
=
InsertNodeWithTransaction
(
*
cellChild
EditorDOMPoint
(
aTargetCell
insertIndex
)
)
;
if
(
insertChildContentResult
.
isErr
(
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertNodeWithTransaction
(
)
failed
"
)
;
return
insertChildContentResult
.
unwrapErr
(
)
;
}
insertChildContentResult
.
MoveCaretPointTo
(
pointToPutCaret
*
this
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
}
)
;
}
if
(
pointToPutCaret
.
IsSet
(
)
)
{
nsresult
rv
=
CollapseSelectionTo
(
pointToPutCaret
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
EditorBase
:
:
CollapseSelectionTo
(
)
caused
destroying
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
}
}
if
(
!
aDeleteCellToMerge
)
{
return
NS_OK
;
}
nsresult
rv
=
DeleteNodeWithTransaction
(
*
aCellToMerge
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
FixBadRowSpan
(
Element
*
aTable
int32_t
aRowIndex
int32_t
&
aNewRowCount
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
aTable
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
int32_t
minRowSpan
=
-
1
;
for
(
int32_t
colIndex
=
0
;
colIndex
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
aRowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
cellData
.
mElement
)
{
break
;
}
if
(
cellData
.
mRowSpan
>
0
&
&
!
cellData
.
IsSpannedFromOtherRow
(
)
&
&
(
cellData
.
mRowSpan
<
minRowSpan
|
|
minRowSpan
=
=
-
1
)
)
{
minRowSpan
=
cellData
.
mRowSpan
;
}
MOZ_ASSERT
(
colIndex
<
cellData
.
NextColumnIndex
(
)
)
;
colIndex
=
cellData
.
NextColumnIndex
(
)
;
}
if
(
minRowSpan
>
1
)
{
int32_t
rowsReduced
=
minRowSpan
-
1
;
for
(
int32_t
colIndex
=
0
;
colIndex
<
tableSize
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
aRowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mElement
&
&
cellData
.
mRowSpan
>
0
&
&
!
cellData
.
IsSpannedFromOtherRowOrColumn
(
)
)
{
nsresult
rv
=
SetRowSpan
(
cellData
.
mElement
cellData
.
mRowSpan
-
rowsReduced
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetRawSpan
(
)
failed
"
)
;
return
rv
;
}
}
MOZ_ASSERT
(
colIndex
<
cellData
.
NextColumnIndex
(
)
)
;
colIndex
=
cellData
.
NextColumnIndex
(
)
;
}
}
const
Result
<
TableSize
nsresult
>
newTableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
aTable
)
;
if
(
NS_WARN_IF
(
newTableSizeOrError
.
isErr
(
)
)
)
{
return
newTableSizeOrError
.
inspectErr
(
)
;
}
aNewRowCount
=
newTableSizeOrError
.
inspect
(
)
.
mRowCount
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
FixBadColSpan
(
Element
*
aTable
int32_t
aColIndex
int32_t
&
aNewColCount
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
aTable
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
inspectErr
(
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
int32_t
minColSpan
=
-
1
;
for
(
int32_t
rowIndex
=
0
;
rowIndex
<
tableSize
.
mRowCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
rowIndex
aColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
cellData
.
mElement
)
{
break
;
}
if
(
cellData
.
mColSpan
>
0
&
&
!
cellData
.
IsSpannedFromOtherColumn
(
)
&
&
(
cellData
.
mColSpan
<
minColSpan
|
|
minColSpan
=
=
-
1
)
)
{
minColSpan
=
cellData
.
mColSpan
;
}
MOZ_ASSERT
(
rowIndex
<
cellData
.
NextRowIndex
(
)
)
;
rowIndex
=
cellData
.
NextRowIndex
(
)
;
}
if
(
minColSpan
>
1
)
{
int32_t
colsReduced
=
minColSpan
-
1
;
for
(
int32_t
rowIndex
=
0
;
rowIndex
<
tableSize
.
mRowCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
rowIndex
aColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mElement
&
&
cellData
.
mColSpan
>
0
&
&
!
cellData
.
IsSpannedFromOtherRowOrColumn
(
)
)
{
nsresult
rv
=
SetColSpan
(
cellData
.
mElement
cellData
.
mColSpan
-
colsReduced
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetColSpan
(
)
failed
"
)
;
return
rv
;
}
}
MOZ_ASSERT
(
rowIndex
<
cellData
.
NextRowIndex
(
)
)
;
rowIndex
=
cellData
.
NextRowIndex
(
)
;
}
}
const
Result
<
TableSize
nsresult
>
newTableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
aTable
)
;
if
(
NS_WARN_IF
(
newTableSizeOrError
.
isErr
(
)
)
)
{
return
newTableSizeOrError
.
inspectErr
(
)
;
}
aNewColCount
=
newTableSizeOrError
.
inspect
(
)
.
mColumnCount
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
NormalizeTable
(
Element
*
aTableOrElementInTable
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNormalizeTable
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
!
aTableOrElementInTable
)
{
aTableOrElementInTable
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
aTableOrElementInTable
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
"
"
table
)
failed
"
)
;
return
NS_OK
;
}
}
rv
=
NormalizeTableInternal
(
*
aTableOrElementInTable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
NormalizeTableInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
NormalizeTableInternal
(
Element
&
aTableOrElementInTable
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
RefPtr
<
Element
>
tableElement
;
if
(
aTableOrElementInTable
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
table
)
{
tableElement
=
&
aTableOrElementInTable
;
}
else
{
tableElement
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
aTableOrElementInTable
)
;
if
(
!
tableElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
NS_OK
;
}
}
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
tableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
tableSizeOrError
.
unwrapErr
(
)
;
}
TableSize
tableSize
=
tableSizeOrError
.
unwrap
(
)
;
AutoSelectionRestorer
restoreSelectionLater
(
*
this
)
;
AutoPlaceholderBatch
treateAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
__FUNCTION__
)
;
IgnoredErrorResult
error
;
AutoEditSubActionNotifier
startToHandleEditSubAction
(
*
this
EditSubAction
:
:
eInsertNode
nsIEditor
:
:
eNext
error
)
;
if
(
NS_WARN_IF
(
error
.
ErrorCodeIs
(
NS_ERROR_EDITOR_DESTROYED
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
NS_WARNING_ASSERTION
(
!
error
.
Failed
(
)
"
HTMLEditor
:
:
OnStartToHandleTopLevelEditSubAction
(
)
failed
but
ignored
"
)
;
for
(
int32_t
rowIndex
=
0
;
rowIndex
<
tableSize
.
mRowCount
;
rowIndex
+
+
)
{
nsresult
rv
=
FixBadRowSpan
(
tableElement
rowIndex
tableSize
.
mRowCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FixBadRowSpan
(
)
failed
"
)
;
return
rv
;
}
}
for
(
int32_t
colIndex
=
0
;
colIndex
<
tableSize
.
mColumnCount
;
colIndex
+
+
)
{
nsresult
rv
=
FixBadColSpan
(
tableElement
colIndex
tableSize
.
mColumnCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
FixBadColSpan
(
)
failed
"
)
;
return
rv
;
}
}
for
(
int32_t
rowIndex
=
0
;
rowIndex
<
tableSize
.
mRowCount
;
rowIndex
+
+
)
{
RefPtr
<
Element
>
previousCellElementInRow
;
for
(
int32_t
colIndex
=
0
;
colIndex
<
tableSize
.
mColumnCount
;
colIndex
+
+
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
tableElement
rowIndex
colIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
cellData
.
mElement
)
{
if
(
!
cellData
.
IsSpannedFromOtherRow
(
)
)
{
previousCellElementInRow
=
std
:
:
move
(
cellData
.
mElement
)
;
}
continue
;
}
if
(
NS_WARN_IF
(
!
previousCellElementInRow
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
newCellElement
;
nsresult
rv
=
InsertCell
(
previousCellElementInRow
1
1
true
false
getter_AddRefs
(
newCellElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertCell
(
)
failed
"
)
;
return
rv
;
}
if
(
newCellElement
)
{
previousCellElementInRow
=
std
:
:
move
(
newCellElement
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellIndexes
(
Element
*
aCellElement
int32_t
*
aRowIndex
int32_t
*
aColumnIndex
)
{
if
(
NS_WARN_IF
(
!
aRowIndex
)
|
|
NS_WARN_IF
(
!
aColumnIndex
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetCellIndexes
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellIndexes
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
*
aRowIndex
=
0
;
*
aColumnIndex
=
0
;
if
(
!
aCellElement
)
{
const
CellIndexes
cellIndexes
(
*
this
SelectionRef
(
)
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aRowIndex
=
cellIndexes
.
mRow
;
*
aColumnIndex
=
cellIndexes
.
mColumn
;
return
NS_OK
;
}
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
cellIndexes
(
*
aCellElement
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aRowIndex
=
cellIndexes
.
mRow
;
*
aColumnIndex
=
cellIndexes
.
mColumn
;
return
NS_OK
;
}
nsTableWrapperFrame
*
HTMLEditor
:
:
GetTableFrame
(
const
Element
*
aTableElement
)
{
if
(
NS_WARN_IF
(
!
aTableElement
)
)
{
return
nullptr
;
}
return
do_QueryFrame
(
aTableElement
-
>
GetPrimaryFrame
(
)
)
;
}
int32_t
HTMLEditor
:
:
GetNumberOfCellsInRow
(
Element
&
aTableElement
int32_t
aRowIndex
)
{
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
aTableElement
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
-
1
;
}
int32_t
numberOfCells
=
0
;
for
(
int32_t
columnIndex
=
0
;
columnIndex
<
tableSizeOrError
.
inspect
(
)
.
mColumnCount
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
aTableElement
aRowIndex
columnIndex
)
;
if
(
cellData
.
FailedOrNotFound
(
)
)
{
break
;
}
if
(
cellData
.
mElement
&
&
!
cellData
.
IsSpannedFromOtherRow
(
)
)
{
numberOfCells
+
+
;
}
MOZ_ASSERT
(
columnIndex
<
cellData
.
NextColumnIndex
(
)
)
;
columnIndex
=
cellData
.
NextColumnIndex
(
)
;
}
return
numberOfCells
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetTableSize
(
Element
*
aTableOrElementInTable
int32_t
*
aRowCount
int32_t
*
aColumnCount
)
{
if
(
NS_WARN_IF
(
!
aRowCount
)
|
|
NS_WARN_IF
(
!
aColumnCount
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetTableSize
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetTableSize
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
*
aRowCount
=
0
;
*
aColumnCount
=
0
;
Element
*
tableOrElementInTable
=
aTableOrElementInTable
;
if
(
!
tableOrElementInTable
)
{
tableOrElementInTable
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
tableOrElementInTable
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
"
"
table
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
tableOrElementInTable
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
*
aRowCount
=
tableSizeOrError
.
inspect
(
)
.
mRowCount
;
*
aColumnCount
=
tableSizeOrError
.
inspect
(
)
.
mColumnCount
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellDataAt
(
Element
*
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
Element
*
*
aCellElement
int32_t
*
aStartRowIndex
int32_t
*
aStartColumnIndex
int32_t
*
aRowSpan
int32_t
*
aColSpan
int32_t
*
aEffectiveRowSpan
int32_t
*
aEffectiveColSpan
bool
*
aIsSelected
)
{
if
(
NS_WARN_IF
(
!
aCellElement
)
|
|
NS_WARN_IF
(
!
aStartRowIndex
)
|
|
NS_WARN_IF
(
!
aStartColumnIndex
)
|
|
NS_WARN_IF
(
!
aRowSpan
)
|
|
NS_WARN_IF
(
!
aColSpan
)
|
|
NS_WARN_IF
(
!
aEffectiveRowSpan
)
|
|
NS_WARN_IF
(
!
aEffectiveColSpan
)
|
|
NS_WARN_IF
(
!
aIsSelected
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetCellDataAt
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellDataAt
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
*
aStartRowIndex
=
0
;
*
aStartColumnIndex
=
0
;
*
aRowSpan
=
0
;
*
aColSpan
=
0
;
*
aEffectiveRowSpan
=
0
;
*
aEffectiveColSpan
=
0
;
*
aIsSelected
=
false
;
*
aCellElement
=
nullptr
;
RefPtr
<
Element
>
table
=
aTableElement
;
if
(
!
table
)
{
table
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
"
"
table
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
const
CellData
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
table
aRowIndex
aColumnIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ADDREF
(
*
aCellElement
=
cellData
.
mElement
.
get
(
)
)
;
*
aIsSelected
=
cellData
.
mIsSelected
;
*
aStartRowIndex
=
cellData
.
mFirst
.
mRow
;
*
aStartColumnIndex
=
cellData
.
mFirst
.
mColumn
;
*
aRowSpan
=
cellData
.
mRowSpan
;
*
aColSpan
=
cellData
.
mColSpan
;
*
aEffectiveRowSpan
=
cellData
.
mEffectiveRowSpan
;
*
aEffectiveColSpan
=
cellData
.
mEffectiveColSpan
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetCellAt
(
Element
*
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
Element
*
*
aCellElement
)
{
if
(
NS_WARN_IF
(
!
aCellElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetCellAt
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetCellAt
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
*
aCellElement
=
nullptr
;
Element
*
tableElement
=
aTableElement
;
if
(
!
tableElement
)
{
tableElement
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
tableElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
"
"
table
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
Element
>
cellElement
=
GetTableCellElementAt
(
*
tableElement
aRowIndex
aColumnIndex
)
;
cellElement
.
forget
(
aCellElement
)
;
return
NS_OK
;
}
Element
*
HTMLEditor
:
:
GetTableCellElementAt
(
Element
&
aTableElement
int32_t
aRowIndex
int32_t
aColumnIndex
)
const
{
OwningNonNull
<
Element
>
tableElement
(
aTableElement
)
;
nsTableWrapperFrame
*
tableFrame
=
HTMLEditor
:
:
GetTableFrame
(
tableElement
)
;
if
(
!
tableFrame
)
{
NS_WARNING
(
"
There
was
no
table
layout
information
"
)
;
return
nullptr
;
}
nsIContent
*
cell
=
tableFrame
-
>
GetCellAt
(
aRowIndex
aColumnIndex
)
;
return
Element
:
:
FromNodeOrNull
(
cell
)
;
}
nsresult
HTMLEditor
:
:
GetCellSpansAt
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aColIndex
int32_t
&
aActualRowSpan
int32_t
&
aActualColSpan
)
{
nsTableWrapperFrame
*
tableFrame
=
HTMLEditor
:
:
GetTableFrame
(
aTable
)
;
if
(
!
tableFrame
)
{
NS_WARNING
(
"
There
was
no
table
layout
information
"
)
;
return
NS_ERROR_FAILURE
;
}
aActualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
aRowIndex
aColIndex
)
;
aActualColSpan
=
tableFrame
-
>
GetEffectiveColSpanAt
(
aRowIndex
aColIndex
)
;
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetCellContext
(
Element
*
*
aTable
Element
*
*
aCell
nsINode
*
*
aCellParent
int32_t
*
aCellOffset
int32_t
*
aRowIndex
int32_t
*
aColumnIndex
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
aTable
)
{
*
aTable
=
nullptr
;
}
if
(
aCell
)
{
*
aCell
=
nullptr
;
}
if
(
aCellParent
)
{
*
aCellParent
=
nullptr
;
}
if
(
aCellOffset
)
{
*
aCellOffset
=
0
;
}
if
(
aRowIndex
)
{
*
aRowIndex
=
0
;
}
if
(
aColumnIndex
)
{
*
aColumnIndex
=
0
;
}
RefPtr
<
Element
>
table
;
RefPtr
<
Element
>
cell
;
if
(
aCell
&
&
*
aCell
)
{
cell
=
*
aCell
;
}
if
(
!
cell
)
{
Result
<
RefPtr
<
Element
>
nsresult
>
cellOrRowOrTableElementOrError
=
GetSelectedOrParentTableElement
(
)
;
if
(
cellOrRowOrTableElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
failed
"
)
;
return
cellOrRowOrTableElementOrError
.
unwrapErr
(
)
;
}
if
(
!
cellOrRowOrTableElementOrError
.
inspect
(
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
cellOrRowOrTableElementOrError
.
inspect
(
)
)
)
{
if
(
aTable
)
{
cellOrRowOrTableElementOrError
.
unwrap
(
)
.
forget
(
aTable
)
;
}
return
NS_OK
;
}
if
(
!
HTMLEditUtils
:
:
IsTableCell
(
cellOrRowOrTableElementOrError
.
inspect
(
)
)
)
{
return
NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND
;
}
cell
=
cellOrRowOrTableElementOrError
.
unwrap
(
)
;
}
if
(
aCell
)
{
*
aCell
=
do_AddRef
(
cell
)
.
take
(
)
;
}
table
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
*
cell
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aTable
)
{
table
.
forget
(
aTable
)
;
}
if
(
aRowIndex
|
|
aColumnIndex
)
{
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
const
CellIndexes
cellIndexes
(
*
cell
presShell
)
;
if
(
NS_WARN_IF
(
cellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aRowIndex
)
{
*
aRowIndex
=
cellIndexes
.
mRow
;
}
if
(
aColumnIndex
)
{
*
aColumnIndex
=
cellIndexes
.
mColumn
;
}
}
if
(
aCellParent
)
{
EditorRawDOMPoint
atCellElement
(
cell
)
;
if
(
NS_WARN_IF
(
!
atCellElement
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aCellOffset
)
{
*
aCellOffset
=
atCellElement
.
Offset
(
)
;
}
*
aCellParent
=
do_AddRef
(
atCellElement
.
GetContainer
(
)
)
.
take
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedCells
(
nsTArray
<
RefPtr
<
Element
>
>
&
aOutSelectedCellElements
)
{
MOZ_ASSERT
(
aOutSelectedCellElements
.
IsEmpty
(
)
)
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetSelectedCells
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedCells
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
)
{
return
NS_OK
;
}
aOutSelectedCellElements
.
SetCapacity
(
scanner
.
ElementsRef
(
)
.
Length
(
)
)
;
for
(
const
OwningNonNull
<
Element
>
&
cellElement
:
scanner
.
ElementsRef
(
)
)
{
aOutSelectedCellElements
.
AppendElement
(
cellElement
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetFirstSelectedCellInTable
(
int32_t
*
aRowIndex
int32_t
*
aColumnIndex
Element
*
*
aCellElement
)
{
if
(
NS_WARN_IF
(
!
aRowIndex
)
|
|
NS_WARN_IF
(
!
aColumnIndex
)
|
|
NS_WARN_IF
(
!
aCellElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetFirstSelectedCellInTable
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetFirstSelectedCellInTable
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aRowIndex
=
0
;
*
aColumnIndex
=
0
;
*
aCellElement
=
nullptr
;
RefPtr
<
Element
>
firstSelectedCellElement
=
HTMLEditUtils
:
:
GetFirstSelectedTableCellElement
(
SelectionRef
(
)
)
;
if
(
!
firstSelectedCellElement
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
const
CellIndexes
indexes
(
*
firstSelectedCellElement
presShell
)
;
if
(
NS_WARN_IF
(
indexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
firstSelectedCellElement
.
forget
(
aCellElement
)
;
*
aRowIndex
=
indexes
.
mRow
;
*
aColumnIndex
=
indexes
.
mColumn
;
return
NS_OK
;
}
void
HTMLEditor
:
:
SetSelectionAfterTableEdit
(
Element
*
aTable
int32_t
aRow
int32_t
aCol
int32_t
aDirection
bool
aSelected
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
NS_WARN_IF
(
!
aTable
)
|
|
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
;
}
RefPtr
<
Element
>
cell
;
bool
done
=
false
;
do
{
cell
=
GetTableCellElementAt
(
*
aTable
aRow
aCol
)
;
if
(
cell
)
{
if
(
aSelected
)
{
DebugOnly
<
nsresult
>
rv
=
SelectContentInternal
(
*
cell
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SelectContentInternal
(
)
failed
but
ignored
"
)
;
return
;
}
CollapseSelectionToDeepestNonTableFirstChild
(
cell
)
;
return
;
}
switch
(
aDirection
)
{
case
ePreviousColumn
:
if
(
!
aCol
)
{
if
(
aRow
>
0
)
{
aRow
-
-
;
}
else
{
done
=
true
;
}
}
else
{
aCol
-
-
;
}
break
;
case
ePreviousRow
:
if
(
!
aRow
)
{
if
(
aCol
>
0
)
{
aCol
-
-
;
}
else
{
done
=
true
;
}
}
else
{
aRow
-
-
;
}
break
;
default
:
done
=
true
;
}
}
while
(
!
done
)
;
if
(
aTable
-
>
GetParentNode
(
)
)
{
EditorRawDOMPoint
atTable
(
aTable
)
;
if
(
NS_WARN_IF
(
!
atTable
.
IsSetAndValid
(
)
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
CollapseSelectionTo
(
atTable
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
but
ignored
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
SetSelectionAtDocumentStart
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
SetSelectionAtDocumentStart
(
)
failed
but
ignored
"
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
nsAString
&
aTagName
int32_t
*
aSelectedCount
Element
*
*
aCellOrRowOrTableElement
)
{
if
(
NS_WARN_IF
(
!
aSelectedCount
)
|
|
NS_WARN_IF
(
!
aCellOrRowOrTableElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
aTagName
.
Truncate
(
)
;
*
aCellOrRowOrTableElement
=
nullptr
;
*
aSelectedCount
=
0
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetSelectedOrParentTableElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
couldn
'
t
handle
the
"
"
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
bool
isCellSelected
=
false
;
Result
<
RefPtr
<
Element
>
nsresult
>
cellOrRowOrTableElementOrError
=
GetSelectedOrParentTableElement
(
&
isCellSelected
)
;
if
(
cellOrRowOrTableElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
cellOrRowOrTableElementOrError
.
unwrapErr
(
)
)
;
}
if
(
!
cellOrRowOrTableElementOrError
.
inspect
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
cellOrRowOrTableElement
=
cellOrRowOrTableElementOrError
.
unwrap
(
)
;
if
(
isCellSelected
)
{
aTagName
.
AssignLiteral
(
"
td
"
)
;
*
aSelectedCount
=
SelectionRef
(
)
.
RangeCount
(
)
;
cellOrRowOrTableElement
.
forget
(
aCellOrRowOrTableElement
)
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsTableCell
(
cellOrRowOrTableElement
)
)
{
aTagName
.
AssignLiteral
(
"
td
"
)
;
cellOrRowOrTableElement
.
forget
(
aCellOrRowOrTableElement
)
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsTable
(
cellOrRowOrTableElement
)
)
{
aTagName
.
AssignLiteral
(
"
table
"
)
;
*
aSelectedCount
=
1
;
cellOrRowOrTableElement
.
forget
(
aCellOrRowOrTableElement
)
;
return
NS_OK
;
}
if
(
HTMLEditUtils
:
:
IsTableRow
(
cellOrRowOrTableElement
)
)
{
aTagName
.
AssignLiteral
(
"
tr
"
)
;
*
aSelectedCount
=
1
;
cellOrRowOrTableElement
.
forget
(
aCellOrRowOrTableElement
)
;
return
NS_OK
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Which
element
was
returned
?
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
bool
*
aIsCellSelected
)
const
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
if
(
aIsCellSelected
)
{
*
aIsCellSelected
=
false
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
Element
>
cellElement
=
HTMLEditUtils
:
:
GetFirstSelectedTableCellElement
(
SelectionRef
(
)
)
;
if
(
cellElement
)
{
if
(
aIsCellSelected
)
{
*
aIsCellSelected
=
true
;
}
return
cellElement
;
}
const
RangeBoundary
&
anchorRef
=
SelectionRef
(
)
.
AnchorRef
(
)
;
if
(
NS_WARN_IF
(
!
anchorRef
.
IsSet
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
anchorRef
.
Container
(
)
-
>
HasChildNodes
(
)
)
{
nsIContent
*
selectedContent
=
anchorRef
.
GetChildAtOffset
(
)
;
if
(
selectedContent
)
{
if
(
selectedContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
td
)
)
{
if
(
aIsCellSelected
)
{
*
aIsCellSelected
=
true
;
}
return
RefPtr
<
Element
>
(
selectedContent
-
>
AsElement
(
)
)
;
}
if
(
selectedContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
tr
)
)
{
return
RefPtr
<
Element
>
(
selectedContent
-
>
AsElement
(
)
)
;
}
}
}
if
(
NS_WARN_IF
(
!
anchorRef
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
cellElement
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
td
*
anchorRef
.
Container
(
)
-
>
AsContent
(
)
)
;
if
(
!
cellElement
)
{
return
RefPtr
<
Element
>
(
)
;
}
return
cellElement
;
}
Result
<
RefPtr
<
Element
>
nsresult
>
HTMLEditor
:
:
GetFirstSelectedCellElementInTable
(
)
const
{
Result
<
RefPtr
<
Element
>
nsresult
>
cellOrRowOrTableElementOrError
=
GetSelectedOrParentTableElement
(
)
;
if
(
cellOrRowOrTableElementOrError
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedOrParentTableElement
(
)
failed
"
)
;
return
cellOrRowOrTableElementOrError
;
}
if
(
!
cellOrRowOrTableElementOrError
.
inspect
(
)
)
{
return
cellOrRowOrTableElementOrError
;
}
const
RefPtr
<
Element
>
&
element
=
cellOrRowOrTableElementOrError
.
inspect
(
)
;
if
(
!
HTMLEditUtils
:
:
IsTableCell
(
element
)
)
{
return
RefPtr
<
Element
>
(
)
;
}
if
(
!
HTMLEditUtils
:
:
IsTableRow
(
element
-
>
GetParentNode
(
)
)
)
{
NS_WARNING
(
"
There
was
no
parent
<
tr
>
element
for
the
found
cell
"
)
;
return
RefPtr
<
Element
>
(
)
;
}
if
(
!
HTMLEditUtils
:
:
GetClosestAncestorTableElement
(
*
element
)
)
{
NS_WARNING
(
"
There
was
no
ancestor
<
table
>
element
for
the
found
cell
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
cellOrRowOrTableElementOrError
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetSelectedCellsType
(
Element
*
aElement
uint32_t
*
aSelectionType
)
{
if
(
NS_WARN_IF
(
!
aSelectionType
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aSelectionType
=
0
;
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eGetSelectedCellsType
)
;
nsresult
rv
=
editActionData
.
CanHandleAndFlushPendingNotifications
(
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetSelectedCellsType
(
)
couldn
'
t
handle
the
job
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
NS_WARN_IF
(
!
SelectionRef
(
)
.
RangeCount
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
table
;
if
(
aElement
)
{
table
=
GetInclusiveAncestorByTagNameInternal
(
*
nsGkAtoms
:
:
table
*
aElement
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameInternal
(
nsGkAtoms
:
:
table
)
"
"
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
table
=
GetInclusiveAncestorByTagNameAtSelection
(
*
nsGkAtoms
:
:
table
)
;
if
(
!
table
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetInclusiveAncestorByTagNameAtSelection
(
nsGkAtoms
:
:
"
"
table
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
const
Result
<
TableSize
nsresult
>
tableSizeOrError
=
TableSize
:
:
Create
(
*
this
*
table
)
;
if
(
NS_WARN_IF
(
tableSizeOrError
.
isErr
(
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
tableSizeOrError
.
inspectErr
(
)
)
;
}
const
TableSize
&
tableSize
=
tableSizeOrError
.
inspect
(
)
;
SelectedTableCellScanner
scanner
(
SelectionRef
(
)
)
;
if
(
!
scanner
.
IsInTableCellSelectionMode
(
)
)
{
return
NS_OK
;
}
*
aSelectionType
=
static_cast
<
uint32_t
>
(
TableSelectionMode
:
:
Cell
)
;
nsTArray
<
int32_t
>
indexArray
;
const
RefPtr
<
PresShell
>
presShell
{
GetPresShell
(
)
}
;
bool
allCellsInRowAreSelected
=
false
;
for
(
const
OwningNonNull
<
Element
>
&
selectedCellElement
:
scanner
.
ElementsRef
(
)
)
{
const
CellIndexes
selectedCellIndexes
(
MOZ_KnownLive
(
selectedCellElement
)
presShell
)
;
if
(
NS_WARN_IF
(
selectedCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
indexArray
.
Contains
(
selectedCellIndexes
.
mColumn
)
)
{
indexArray
.
AppendElement
(
selectedCellIndexes
.
mColumn
)
;
allCellsInRowAreSelected
=
AllCellsInRowSelected
(
table
selectedCellIndexes
.
mRow
tableSize
.
mColumnCount
)
;
if
(
!
allCellsInRowAreSelected
)
{
break
;
}
}
}
if
(
allCellsInRowAreSelected
)
{
*
aSelectionType
=
static_cast
<
uint32_t
>
(
TableSelectionMode
:
:
Row
)
;
return
NS_OK
;
}
indexArray
.
Clear
(
)
;
bool
allCellsInColAreSelected
=
false
;
for
(
const
OwningNonNull
<
Element
>
&
selectedCellElement
:
scanner
.
ElementsRef
(
)
)
{
const
CellIndexes
selectedCellIndexes
(
MOZ_KnownLive
(
selectedCellElement
)
presShell
)
;
if
(
NS_WARN_IF
(
selectedCellIndexes
.
isErr
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
indexArray
.
Contains
(
selectedCellIndexes
.
mRow
)
)
{
indexArray
.
AppendElement
(
selectedCellIndexes
.
mColumn
)
;
allCellsInColAreSelected
=
AllCellsInColumnSelected
(
table
selectedCellIndexes
.
mColumn
tableSize
.
mRowCount
)
;
if
(
!
allCellsInRowAreSelected
)
{
break
;
}
}
}
if
(
allCellsInColAreSelected
)
{
*
aSelectionType
=
static_cast
<
uint32_t
>
(
TableSelectionMode
:
:
Column
)
;
}
return
NS_OK
;
}
bool
HTMLEditor
:
:
AllCellsInRowSelected
(
Element
*
aTable
int32_t
aRowIndex
int32_t
aNumberOfColumns
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
false
;
}
for
(
int32_t
col
=
0
;
col
<
aNumberOfColumns
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
aRowIndex
col
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
false
;
}
if
(
!
cellData
.
mElement
)
{
NS_WARNING
(
"
CellData
didn
'
t
set
mElement
"
)
;
return
cellData
.
mCurrent
.
mColumn
>
0
;
}
if
(
!
cellData
.
mIsSelected
)
{
NS_WARNING
(
"
CellData
didn
'
t
set
mIsSelected
"
)
;
return
false
;
}
MOZ_ASSERT
(
col
<
cellData
.
NextColumnIndex
(
)
)
;
col
=
cellData
.
NextColumnIndex
(
)
;
}
return
true
;
}
bool
HTMLEditor
:
:
AllCellsInColumnSelected
(
Element
*
aTable
int32_t
aColIndex
int32_t
aNumberOfRows
)
{
if
(
NS_WARN_IF
(
!
aTable
)
)
{
return
false
;
}
for
(
int32_t
row
=
0
;
row
<
aNumberOfRows
;
)
{
const
auto
cellData
=
CellData
:
:
AtIndexInTableElement
(
*
this
*
aTable
row
aColIndex
)
;
if
(
NS_WARN_IF
(
cellData
.
FailedOrNotFound
(
)
)
)
{
return
false
;
}
if
(
!
cellData
.
mElement
)
{
NS_WARNING
(
"
CellData
didn
'
t
set
mElement
"
)
;
return
cellData
.
mCurrent
.
mRow
>
0
;
}
if
(
!
cellData
.
mIsSelected
)
{
NS_WARNING
(
"
CellData
didn
'
t
set
mIsSelected
"
)
;
return
false
;
}
MOZ_ASSERT
(
row
<
cellData
.
NextRowIndex
(
)
)
;
row
=
cellData
.
NextRowIndex
(
)
;
}
return
true
;
}
bool
HTMLEditor
:
:
IsEmptyCell
(
dom
:
:
Element
*
aCell
)
{
MOZ_ASSERT
(
aCell
)
;
nsCOMPtr
<
nsINode
>
cellChild
=
aCell
-
>
GetFirstChild
(
)
;
if
(
!
cellChild
)
{
return
false
;
}
nsCOMPtr
<
nsINode
>
nextChild
=
cellChild
-
>
GetNextSibling
(
)
;
if
(
nextChild
)
{
return
false
;
}
if
(
cellChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
true
;
}
return
HTMLEditUtils
:
:
IsEmptyNode
(
*
cellChild
{
EmptyCheckOption
:
:
TreatSingleBRElementAsVisible
}
)
;
}
}
