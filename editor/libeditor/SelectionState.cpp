#
include
"
SelectionState
.
h
"
#
include
"
AutoRangeArray
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
nsINode
*
RangeItem
:
:
GetRoot
(
)
const
{
if
(
MOZ_UNLIKELY
(
!
IsPositioned
(
)
)
)
{
return
nullptr
;
}
nsINode
*
rootNode
=
RangeUtils
:
:
ComputeRootNode
(
mStartContainer
)
;
if
(
mStartContainer
=
=
mEndContainer
)
{
return
rootNode
;
}
return
MOZ_LIKELY
(
rootNode
=
=
RangeUtils
:
:
ComputeRootNode
(
mEndContainer
)
)
?
rootNode
:
nullptr
;
}
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
SelectionState
:
:
SelectionState
(
const
AutoRangeArray
&
aRanges
)
:
mDirection
(
aRanges
.
GetDirection
(
)
)
{
mArray
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
aRanges
.
Ranges
(
)
)
{
RefPtr
<
RangeItem
>
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
range
)
;
mArray
.
AppendElement
(
std
:
:
move
(
rangeItem
)
)
;
}
}
void
SelectionState
:
:
SaveSelection
(
Selection
&
aSelection
)
{
if
(
mArray
.
Length
(
)
<
aSelection
.
RangeCount
(
)
)
{
for
(
uint32_t
i
=
mArray
.
Length
(
)
;
i
<
aSelection
.
RangeCount
(
)
;
i
+
+
)
{
mArray
.
AppendElement
(
)
;
mArray
[
i
]
=
new
RangeItem
(
)
;
}
}
else
if
(
mArray
.
Length
(
)
>
aSelection
.
RangeCount
(
)
)
{
mArray
.
TruncateLength
(
aSelection
.
RangeCount
(
)
)
;
}
const
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
.
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
range
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
)
{
continue
;
}
mArray
[
i
]
-
>
StoreRange
(
*
range
)
;
}
mDirection
=
aSelection
.
GetDirection
(
)
;
}
nsresult
SelectionState
:
:
RestoreSelection
(
Selection
&
aSelection
)
{
IgnoredErrorResult
ignoredError
;
aSelection
.
RemoveAllRanges
(
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
RemoveAllRanges
(
)
failed
but
ignored
"
)
;
aSelection
.
SetDirection
(
mDirection
)
;
ErrorResult
error
;
const
CopyableAutoTArray
<
RefPtr
<
RangeItem
>
10
>
rangeItems
(
mArray
)
;
for
(
const
RefPtr
<
RangeItem
>
&
rangeItem
:
rangeItems
)
{
RefPtr
<
nsRange
>
range
=
rangeItem
-
>
GetRange
(
)
;
if
(
!
range
)
{
NS_WARNING
(
"
RangeItem
:
:
GetRange
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
aSelection
.
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
void
SelectionState
:
:
ApplyTo
(
AutoRangeArray
&
aRanges
)
{
aRanges
.
RemoveAllRanges
(
)
;
aRanges
.
SetDirection
(
mDirection
)
;
for
(
const
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
RefPtr
<
nsRange
>
range
=
rangeItem
-
>
GetRange
(
)
;
if
(
MOZ_UNLIKELY
(
!
range
)
)
{
continue
;
}
aRanges
.
Ranges
(
)
.
AppendElement
(
std
:
:
move
(
range
)
)
;
}
}
bool
SelectionState
:
:
Equals
(
const
SelectionState
&
aOther
)
const
{
if
(
mArray
.
Length
(
)
!
=
aOther
.
mArray
.
Length
(
)
)
{
return
false
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
mDirection
!
=
aOther
.
mDirection
)
{
return
false
;
}
for
(
uint32_t
i
:
IntegerRange
(
mArray
.
Length
(
)
)
)
{
if
(
NS_WARN_IF
(
!
mArray
[
i
]
)
|
|
NS_WARN_IF
(
!
aOther
.
mArray
[
i
]
)
|
|
!
mArray
[
i
]
-
>
Equals
(
*
aOther
.
mArray
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
RangeUpdater
:
:
RangeUpdater
(
)
:
mLocked
(
false
)
{
}
void
RangeUpdater
:
:
RegisterRangeItem
(
RangeItem
&
aRangeItem
)
{
if
(
mArray
.
Contains
(
&
aRangeItem
)
)
{
NS_ERROR
(
"
tried
to
register
an
already
registered
range
"
)
;
return
;
}
mArray
.
AppendElement
(
&
aRangeItem
)
;
}
void
RangeUpdater
:
:
DropRangeItem
(
RangeItem
&
aRangeItem
)
{
NS_WARNING_ASSERTION
(
mArray
.
Contains
(
&
aRangeItem
)
"
aRangeItem
is
not
in
the
range
but
tried
to
removed
from
it
"
)
;
mArray
.
RemoveElement
(
&
aRangeItem
)
;
}
void
RangeUpdater
:
:
RegisterSelectionState
(
SelectionState
&
aSelectionState
)
{
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
aSelectionState
.
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
continue
;
}
RegisterRangeItem
(
*
rangeItem
)
;
}
}
void
RangeUpdater
:
:
DropSelectionState
(
SelectionState
&
aSelectionState
)
{
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
aSelectionState
.
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
continue
;
}
DropRangeItem
(
*
rangeItem
)
;
}
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
aPoint
.
GetContainer
(
)
&
&
rangeItem
-
>
mStartOffset
>
aPoint
.
Offset
(
)
)
{
rangeItem
-
>
mStartOffset
+
+
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
aPoint
.
GetContainer
(
)
&
&
rangeItem
-
>
mEndOffset
>
aPoint
.
Offset
(
)
)
{
rangeItem
-
>
mEndOffset
+
+
;
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
nsresult
rv
=
SelAdjCreateNode
(
aPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RangeUpdater
:
:
SelAdjCreateNode
(
)
failed
"
)
;
return
rv
;
}
void
RangeUpdater
:
:
SelAdjDeleteNode
(
nsINode
&
aNodeToDelete
)
{
if
(
mLocked
)
{
return
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
;
}
EditorRawDOMPoint
atNodeToDelete
(
&
aNodeToDelete
)
;
NS_ASSERTION
(
atNodeToDelete
.
IsSetAndValid
(
)
"
aNodeToDelete
must
be
an
orphan
node
or
this
is
called
"
"
during
mutation
"
)
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
atNodeToDelete
.
GetContainer
(
)
&
&
rangeItem
-
>
mStartOffset
>
atNodeToDelete
.
Offset
(
)
)
{
rangeItem
-
>
mStartOffset
-
-
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
atNodeToDelete
.
GetContainer
(
)
&
&
rangeItem
-
>
mEndOffset
>
atNodeToDelete
.
Offset
(
)
)
{
rangeItem
-
>
mEndOffset
-
-
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aNodeToDelete
)
{
rangeItem
-
>
mStartContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mStartOffset
=
atNodeToDelete
.
Offset
(
)
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aNodeToDelete
)
{
rangeItem
-
>
mEndContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mEndOffset
=
atNodeToDelete
.
Offset
(
)
;
}
bool
updateEndBoundaryToo
=
false
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rangeItem
-
>
mStartContainer
aNodeToDelete
)
)
{
updateEndBoundaryToo
=
rangeItem
-
>
mStartContainer
=
=
rangeItem
-
>
mEndContainer
;
rangeItem
-
>
mStartContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mStartOffset
=
atNodeToDelete
.
Offset
(
)
;
}
if
(
updateEndBoundaryToo
|
|
EditorUtils
:
:
IsDescendantOf
(
*
rangeItem
-
>
mEndContainer
aNodeToDelete
)
)
{
rangeItem
-
>
mEndContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mEndOffset
=
atNodeToDelete
.
Offset
(
)
;
}
}
}
nsresult
RangeUpdater
:
:
SelAdjSplitNode
(
nsIContent
&
aOriginalContent
uint32_t
aSplitOffset
nsIContent
&
aNewContent
SplitNodeDirection
aSplitNodeDirection
)
{
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atNewNode
(
&
aNewContent
)
;
nsresult
rv
=
SelAdjInsertNode
(
atNewNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUpdater
:
:
SelAdjInsertNode
(
)
failed
"
)
;
return
rv
;
}
auto
AdjustDOMPoint
=
[
&
]
(
nsCOMPtr
<
nsINode
>
&
aContainer
uint32_t
&
aOffset
)
-
>
void
{
if
(
aContainer
!
=
&
aOriginalContent
)
{
return
;
}
if
(
aSplitNodeDirection
=
=
SplitNodeDirection
:
:
LeftNodeIsNewOne
)
{
if
(
aOffset
>
aSplitOffset
)
{
aOffset
-
=
aSplitOffset
;
}
else
{
aContainer
=
&
aNewContent
;
}
}
else
if
(
aOffset
>
=
aSplitOffset
)
{
aContainer
=
&
aNewContent
;
aOffset
=
aSplitOffset
-
aOffset
;
}
}
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
AdjustDOMPoint
(
rangeItem
-
>
mStartContainer
rangeItem
-
>
mStartOffset
)
;
AdjustDOMPoint
(
rangeItem
-
>
mEndContainer
rangeItem
-
>
mEndOffset
)
;
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjJoinNodes
(
const
EditorRawDOMPoint
&
aStartOfRightContent
const
nsIContent
&
aRemovedContent
uint32_t
aOffsetOfRemovedContent
JoinNodesDirection
aJoinNodesDirection
)
{
MOZ_ASSERT
(
aStartOfRightContent
.
IsSetAndValid
(
)
)
;
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
auto
AdjustDOMPoint
=
[
&
]
(
nsCOMPtr
<
nsINode
>
&
aContainer
uint32_t
&
aOffset
)
-
>
void
{
if
(
aContainer
=
=
aStartOfRightContent
.
GetContainerParent
(
)
)
{
if
(
aOffset
>
aOffsetOfRemovedContent
)
{
aOffset
-
-
;
}
else
if
(
aOffset
=
=
aOffsetOfRemovedContent
)
{
aContainer
=
aStartOfRightContent
.
GetContainer
(
)
;
aOffset
=
aStartOfRightContent
.
Offset
(
)
;
}
}
else
if
(
aContainer
=
=
aStartOfRightContent
.
GetContainer
(
)
)
{
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
LeftNodeIntoRightNode
)
{
aOffset
+
=
aStartOfRightContent
.
Offset
(
)
;
}
}
else
if
(
aContainer
=
=
&
aRemovedContent
)
{
aContainer
=
aStartOfRightContent
.
GetContainer
(
)
;
if
(
aJoinNodesDirection
=
=
JoinNodesDirection
:
:
RightNodeIntoLeftNode
)
{
aOffset
+
=
aStartOfRightContent
.
Offset
(
)
;
}
}
}
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
AdjustDOMPoint
(
rangeItem
-
>
mStartContainer
rangeItem
-
>
mStartOffset
)
;
AdjustDOMPoint
(
rangeItem
-
>
mEndContainer
rangeItem
-
>
mEndOffset
)
;
}
return
NS_OK
;
}
void
RangeUpdater
:
:
SelAdjReplaceText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aReplacedLength
uint32_t
aInsertedLength
)
{
if
(
mLocked
)
{
return
;
}
SelAdjInsertText
(
aTextNode
aOffset
aInsertedLength
)
;
SelAdjDeleteText
(
aTextNode
aOffset
aReplacedLength
)
;
}
void
RangeUpdater
:
:
SelAdjInsertText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aInsertedLength
)
{
if
(
mLocked
)
{
return
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mStartOffset
>
aOffset
)
{
rangeItem
-
>
mStartOffset
+
=
aInsertedLength
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mEndOffset
>
aOffset
)
{
rangeItem
-
>
mEndOffset
+
=
aInsertedLength
;
}
}
}
void
RangeUpdater
:
:
SelAdjDeleteText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aDeletedLength
)
{
if
(
mLocked
)
{
return
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mStartOffset
>
aOffset
)
{
if
(
rangeItem
-
>
mStartOffset
>
=
aDeletedLength
)
{
rangeItem
-
>
mStartOffset
-
=
aDeletedLength
;
}
else
{
rangeItem
-
>
mStartOffset
=
0
;
}
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mEndOffset
>
aOffset
)
{
if
(
rangeItem
-
>
mEndOffset
>
=
aDeletedLength
)
{
rangeItem
-
>
mEndOffset
-
=
aDeletedLength
;
}
else
{
rangeItem
-
>
mEndOffset
=
0
;
}
}
}
}
void
RangeUpdater
:
:
DidReplaceContainer
(
const
Element
&
aRemovedElement
Element
&
aInsertedElement
)
{
if
(
NS_WARN_IF
(
!
mLocked
)
)
{
return
;
}
mLocked
=
false
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mStartContainer
=
&
aInsertedElement
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mEndContainer
=
&
aInsertedElement
;
}
}
}
void
RangeUpdater
:
:
DidRemoveContainer
(
const
Element
&
aRemovedElement
nsINode
&
aRemovedElementContainerNode
uint32_t
aOldOffsetOfRemovedElement
uint32_t
aOldChildCountOfRemovedElement
)
{
if
(
NS_WARN_IF
(
!
mLocked
)
)
{
return
;
}
mLocked
=
false
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mStartContainer
=
&
aRemovedElementContainerNode
;
rangeItem
-
>
mStartOffset
+
=
aOldOffsetOfRemovedElement
;
}
else
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElementContainerNode
&
&
rangeItem
-
>
mStartOffset
>
aOldOffsetOfRemovedElement
)
{
rangeItem
-
>
mStartOffset
+
=
aOldChildCountOfRemovedElement
-
1
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mEndContainer
=
&
aRemovedElementContainerNode
;
rangeItem
-
>
mEndOffset
+
=
aOldOffsetOfRemovedElement
;
}
else
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElementContainerNode
&
&
rangeItem
-
>
mEndOffset
>
aOldOffsetOfRemovedElement
)
{
rangeItem
-
>
mEndOffset
+
=
aOldChildCountOfRemovedElement
-
1
;
}
}
}
void
RangeUpdater
:
:
DidMoveNode
(
const
nsINode
&
aOldParent
uint32_t
aOldOffset
const
nsINode
&
aNewParent
uint32_t
aNewOffset
)
{
if
(
mLocked
)
{
return
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aOldParent
&
&
rangeItem
-
>
mStartOffset
>
aOldOffset
)
{
rangeItem
-
>
mStartOffset
-
-
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aOldParent
&
&
rangeItem
-
>
mEndOffset
>
aOldOffset
)
{
rangeItem
-
>
mEndOffset
-
-
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aNewParent
&
&
rangeItem
-
>
mStartOffset
>
aNewOffset
)
{
rangeItem
-
>
mStartOffset
+
+
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aNewParent
&
&
rangeItem
-
>
mEndOffset
>
aNewOffset
)
{
rangeItem
-
>
mEndOffset
+
+
;
}
}
}
NS_IMPL_CYCLE_COLLECTION
(
RangeItem
mStartContainer
mEndContainer
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
RangeItem
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
RangeItem
Release
)
void
RangeItem
:
:
StoreRange
(
const
nsRange
&
aRange
)
{
mStartContainer
=
aRange
.
GetStartContainer
(
)
;
mStartOffset
=
aRange
.
StartOffset
(
)
;
mEndContainer
=
aRange
.
GetEndContainer
(
)
;
mEndOffset
=
aRange
.
EndOffset
(
)
;
}
already_AddRefed
<
nsRange
>
RangeItem
:
:
GetRange
(
)
const
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
}
