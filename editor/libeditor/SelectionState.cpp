#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMCharacterData
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
SelectionState
:
:
SelectionState
(
)
{
}
SelectionState
:
:
~
SelectionState
(
)
{
MakeEmpty
(
)
;
}
void
SelectionState
:
:
SaveSelection
(
Selection
*
aSel
)
{
MOZ_ASSERT
(
aSel
)
;
int32_t
arrayCount
=
mArray
.
Length
(
)
;
int32_t
rangeCount
=
aSel
-
>
RangeCount
(
)
;
if
(
arrayCount
<
rangeCount
)
{
for
(
int32_t
i
=
arrayCount
;
i
<
rangeCount
;
i
+
+
)
{
mArray
.
AppendElement
(
)
;
mArray
[
i
]
=
new
RangeItem
(
)
;
}
}
else
if
(
arrayCount
>
rangeCount
)
{
for
(
int32_t
i
=
arrayCount
-
1
;
i
>
=
rangeCount
;
i
-
-
)
{
mArray
.
RemoveElementAt
(
i
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
mArray
[
i
]
-
>
StoreRange
(
aSel
-
>
GetRangeAt
(
i
)
)
;
}
}
nsresult
SelectionState
:
:
RestoreSelection
(
Selection
*
aSel
)
{
NS_ENSURE_TRUE
(
aSel
NS_ERROR_NULL_POINTER
)
;
aSel
-
>
RemoveAllRanges
(
)
;
size_t
arrayCount
=
mArray
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
arrayCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
mArray
[
i
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
aSel
-
>
AddRange
(
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
bool
SelectionState
:
:
IsCollapsed
(
)
{
if
(
mArray
.
Length
(
)
!
=
1
)
{
return
false
;
}
RefPtr
<
nsRange
>
range
=
mArray
[
0
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
range
false
)
;
bool
bIsCollapsed
=
false
;
range
-
>
GetCollapsed
(
&
bIsCollapsed
)
;
return
bIsCollapsed
;
}
bool
SelectionState
:
:
IsEqual
(
SelectionState
*
aSelState
)
{
NS_ENSURE_TRUE
(
aSelState
false
)
;
size_t
myCount
=
mArray
.
Length
(
)
itsCount
=
aSelState
-
>
mArray
.
Length
(
)
;
if
(
myCount
!
=
itsCount
)
{
return
false
;
}
if
(
!
myCount
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
myCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
myRange
=
mArray
[
i
]
-
>
GetRange
(
)
;
RefPtr
<
nsRange
>
itsRange
=
aSelState
-
>
mArray
[
i
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
myRange
&
&
itsRange
false
)
;
int16_t
compResult
;
nsresult
rv
;
rv
=
myRange
-
>
CompareBoundaryPoints
(
nsIDOMRange
:
:
START_TO_START
itsRange
&
compResult
)
;
if
(
NS_FAILED
(
rv
)
|
|
compResult
)
{
return
false
;
}
rv
=
myRange
-
>
CompareBoundaryPoints
(
nsIDOMRange
:
:
END_TO_END
itsRange
&
compResult
)
;
if
(
NS_FAILED
(
rv
)
|
|
compResult
)
{
return
false
;
}
}
return
true
;
}
void
SelectionState
:
:
MakeEmpty
(
)
{
mArray
.
Clear
(
)
;
}
bool
SelectionState
:
:
IsEmpty
(
)
{
return
mArray
.
IsEmpty
(
)
;
}
RangeUpdater
:
:
RangeUpdater
(
)
:
mLock
(
false
)
{
}
RangeUpdater
:
:
~
RangeUpdater
(
)
{
}
void
RangeUpdater
:
:
RegisterRangeItem
(
RangeItem
*
aRangeItem
)
{
if
(
!
aRangeItem
)
{
return
;
}
if
(
mArray
.
Contains
(
aRangeItem
)
)
{
NS_ERROR
(
"
tried
to
register
an
already
registered
range
"
)
;
return
;
}
mArray
.
AppendElement
(
aRangeItem
)
;
}
void
RangeUpdater
:
:
DropRangeItem
(
RangeItem
*
aRangeItem
)
{
if
(
!
aRangeItem
)
{
return
;
}
mArray
.
RemoveElement
(
aRangeItem
)
;
}
nsresult
RangeUpdater
:
:
RegisterSelectionState
(
SelectionState
&
aSelState
)
{
size_t
theCount
=
aSelState
.
mArray
.
Length
(
)
;
if
(
theCount
<
1
)
{
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
theCount
;
i
+
+
)
{
RegisterRangeItem
(
aSelState
.
mArray
[
i
]
)
;
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DropSelectionState
(
SelectionState
&
aSelState
)
{
size_t
theCount
=
aSelState
.
mArray
.
Length
(
)
;
if
(
theCount
<
1
)
{
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
theCount
;
i
+
+
)
{
DropRangeItem
(
aSelState
.
mArray
[
i
]
)
;
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
nsINode
*
aParent
int32_t
aPosition
)
{
if
(
mLock
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aParent
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aParent
&
&
item
-
>
mStartOffset
>
aPosition
)
{
item
-
>
mStartOffset
+
+
;
}
if
(
item
-
>
mEndContainer
=
=
aParent
&
&
item
-
>
mEndOffset
>
aPosition
)
{
item
-
>
mEndOffset
+
+
;
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
nsINode
*
aParent
int32_t
aPosition
)
{
return
SelAdjCreateNode
(
aParent
aPosition
)
;
}
void
RangeUpdater
:
:
SelAdjDeleteNode
(
nsINode
*
aNode
)
{
if
(
mLock
)
{
return
;
}
MOZ_ASSERT
(
aNode
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
;
}
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
IndexOf
(
aNode
)
:
-
1
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
MOZ_ASSERT
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
parent
&
&
item
-
>
mStartOffset
>
offset
)
{
item
-
>
mStartOffset
-
-
;
}
if
(
item
-
>
mEndContainer
=
=
parent
&
&
item
-
>
mEndOffset
>
offset
)
{
item
-
>
mEndOffset
-
-
;
}
if
(
item
-
>
mStartContainer
=
=
aNode
)
{
item
-
>
mStartContainer
=
parent
;
item
-
>
mStartOffset
=
offset
;
}
if
(
item
-
>
mEndContainer
=
=
aNode
)
{
item
-
>
mEndContainer
=
parent
;
item
-
>
mEndOffset
=
offset
;
}
nsCOMPtr
<
nsINode
>
oldStart
;
if
(
EditorUtils
:
:
IsDescendantOf
(
item
-
>
mStartContainer
aNode
)
)
{
oldStart
=
item
-
>
mStartContainer
;
item
-
>
mStartContainer
=
parent
;
item
-
>
mStartOffset
=
offset
;
}
if
(
item
-
>
mEndContainer
=
=
oldStart
|
|
EditorUtils
:
:
IsDescendantOf
(
item
-
>
mEndContainer
aNode
)
)
{
item
-
>
mEndContainer
=
parent
;
item
-
>
mEndOffset
=
offset
;
}
}
}
nsresult
RangeUpdater
:
:
SelAdjSplitNode
(
nsIContent
&
aOldRightNode
int32_t
aOffset
nsIContent
*
aNewLeftNode
)
{
if
(
mLock
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aNewLeftNode
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
parent
=
aOldRightNode
.
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
IndexOf
(
&
aOldRightNode
)
:
-
1
;
nsresult
rv
=
SelAdjInsertNode
(
parent
offset
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
&
aOldRightNode
)
{
if
(
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
-
=
aOffset
;
}
else
{
item
-
>
mStartContainer
=
aNewLeftNode
;
}
}
if
(
item
-
>
mEndContainer
=
=
&
aOldRightNode
)
{
if
(
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
-
=
aOffset
;
}
else
{
item
-
>
mEndContainer
=
aNewLeftNode
;
}
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
nsINode
&
aParent
int32_t
aOffset
int32_t
aOldLeftNodeLength
)
{
if
(
mLock
)
{
return
NS_OK
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
&
aParent
)
{
if
(
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
-
-
;
}
else
if
(
item
-
>
mStartOffset
=
=
aOffset
)
{
item
-
>
mStartContainer
=
&
aRightNode
;
item
-
>
mStartOffset
=
aOldLeftNodeLength
;
}
}
else
if
(
item
-
>
mStartContainer
=
=
&
aRightNode
)
{
item
-
>
mStartOffset
+
=
aOldLeftNodeLength
;
}
else
if
(
item
-
>
mStartContainer
=
=
&
aLeftNode
)
{
item
-
>
mStartContainer
=
&
aRightNode
;
}
if
(
item
-
>
mEndContainer
=
=
&
aParent
)
{
if
(
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
-
-
;
}
else
if
(
item
-
>
mEndOffset
=
=
aOffset
)
{
item
-
>
mEndContainer
=
&
aRightNode
;
item
-
>
mEndOffset
=
aOldLeftNodeLength
;
}
}
else
if
(
item
-
>
mEndContainer
=
=
&
aRightNode
)
{
item
-
>
mEndOffset
+
=
aOldLeftNodeLength
;
}
else
if
(
item
-
>
mEndContainer
=
=
&
aLeftNode
)
{
item
-
>
mEndContainer
=
&
aRightNode
;
}
}
return
NS_OK
;
}
void
RangeUpdater
:
:
SelAdjInsertText
(
Text
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
if
(
mLock
)
{
return
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
;
}
size_t
len
=
aString
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
MOZ_ASSERT
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
&
aTextNode
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
+
=
len
;
}
if
(
item
-
>
mEndContainer
=
=
&
aTextNode
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
+
=
len
;
}
}
return
;
}
nsresult
RangeUpdater
:
:
SelAdjDeleteText
(
nsIContent
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
if
(
mLock
)
{
return
NS_OK
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aTextNode
NS_ERROR_NULL_POINTER
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aTextNode
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
-
=
aLength
;
if
(
item
-
>
mStartOffset
<
0
)
{
item
-
>
mStartOffset
=
0
;
}
}
if
(
item
-
>
mEndContainer
=
=
aTextNode
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
-
=
aLength
;
if
(
item
-
>
mEndOffset
<
0
)
{
item
-
>
mEndOffset
=
0
;
}
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjDeleteText
(
nsIDOMCharacterData
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
nsCOMPtr
<
nsIContent
>
textNode
=
do_QueryInterface
(
aTextNode
)
;
return
SelAdjDeleteText
(
textNode
aOffset
aLength
)
;
}
nsresult
RangeUpdater
:
:
WillReplaceContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidReplaceContainer
(
Element
*
aOriginalNode
Element
*
aNewNode
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
NS_ENSURE_TRUE
(
aOriginalNode
&
&
aNewNode
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aOriginalNode
)
{
item
-
>
mStartContainer
=
aNewNode
;
}
if
(
item
-
>
mEndContainer
=
=
aOriginalNode
)
{
item
-
>
mEndContainer
=
aNewNode
;
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
WillRemoveContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidRemoveContainer
(
nsINode
*
aNode
nsINode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
NS_ENSURE_TRUE
(
aNode
&
&
aParent
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aNode
)
{
item
-
>
mStartContainer
=
aParent
;
item
-
>
mStartOffset
+
=
aOffset
;
}
else
if
(
item
-
>
mStartContainer
=
=
aParent
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
+
=
(
int32_t
)
aNodeOrigLen
-
1
;
}
if
(
item
-
>
mEndContainer
=
=
aNode
)
{
item
-
>
mEndContainer
=
aParent
;
item
-
>
mEndOffset
+
=
aOffset
;
}
else
if
(
item
-
>
mEndContainer
=
=
aParent
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
+
=
(
int32_t
)
aNodeOrigLen
-
1
;
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidRemoveContainer
(
nsIDOMNode
*
aNode
nsIDOMNode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
nsCOMPtr
<
nsINode
>
parent
=
do_QueryInterface
(
aParent
)
;
return
DidRemoveContainer
(
node
parent
aOffset
aNodeOrigLen
)
;
}
nsresult
RangeUpdater
:
:
WillInsertContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidInsertContainer
(
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
return
NS_OK
;
}
void
RangeUpdater
:
:
WillMoveNode
(
)
{
mLock
=
true
;
}
void
RangeUpdater
:
:
DidMoveNode
(
nsINode
*
aOldParent
int32_t
aOldOffset
nsINode
*
aNewParent
int32_t
aNewOffset
)
{
MOZ_ASSERT
(
aOldParent
)
;
MOZ_ASSERT
(
aNewParent
)
;
NS_ENSURE_TRUE_VOID
(
mLock
)
;
mLock
=
false
;
for
(
size_t
i
=
0
count
=
mArray
.
Length
(
)
;
i
<
count
;
+
+
i
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE_VOID
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
aOldParent
&
&
item
-
>
mStartOffset
>
aOldOffset
)
{
item
-
>
mStartOffset
-
-
;
}
if
(
item
-
>
mEndContainer
=
=
aOldParent
&
&
item
-
>
mEndOffset
>
aOldOffset
)
{
item
-
>
mEndOffset
-
-
;
}
if
(
item
-
>
mStartContainer
=
=
aNewParent
&
&
item
-
>
mStartOffset
>
aNewOffset
)
{
item
-
>
mStartOffset
+
+
;
}
if
(
item
-
>
mEndContainer
=
=
aNewParent
&
&
item
-
>
mEndOffset
>
aNewOffset
)
{
item
-
>
mEndOffset
+
+
;
}
}
}
RangeItem
:
:
RangeItem
(
)
{
}
RangeItem
:
:
~
RangeItem
(
)
{
}
NS_IMPL_CYCLE_COLLECTION
(
RangeItem
mStartContainer
mEndContainer
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
RangeItem
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
RangeItem
Release
)
void
RangeItem
:
:
StoreRange
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
mStartContainer
=
aRange
-
>
GetStartContainer
(
)
;
mStartOffset
=
aRange
-
>
StartOffset
(
)
;
mEndContainer
=
aRange
-
>
GetEndContainer
(
)
;
mEndOffset
=
aRange
-
>
EndOffset
(
)
;
}
already_AddRefed
<
nsRange
>
RangeItem
:
:
GetRange
(
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mStartContainer
)
;
if
(
NS_FAILED
(
range
-
>
SetStartAndEnd
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
}
