#
include
"
SelectionState
.
h
"
#
include
"
AutoClonedRangeArray
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
EditorLineBreak
.
h
"
#
include
"
HTMLEditHelpers
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
nsINode
*
RangeItem
:
:
GetRoot
(
)
const
{
if
(
MOZ_UNLIKELY
(
!
IsPositioned
(
)
)
)
{
return
nullptr
;
}
nsINode
*
rootNode
=
RangeUtils
:
:
ComputeRootNode
(
mStartContainer
)
;
if
(
mStartContainer
=
=
mEndContainer
)
{
return
rootNode
;
}
return
MOZ_LIKELY
(
rootNode
=
=
RangeUtils
:
:
ComputeRootNode
(
mEndContainer
)
)
?
rootNode
:
nullptr
;
}
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
SelectionState
:
:
SelectionState
(
const
AutoClonedSelectionRangeArray
&
aRanges
)
:
mDirection
(
aRanges
.
GetDirection
(
)
)
{
mArray
.
SetCapacity
(
aRanges
.
Ranges
(
)
.
Length
(
)
)
;
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
aRanges
.
Ranges
(
)
)
{
RefPtr
<
RangeItem
>
rangeItem
=
new
RangeItem
(
)
;
rangeItem
-
>
StoreRange
(
range
)
;
mArray
.
AppendElement
(
std
:
:
move
(
rangeItem
)
)
;
}
}
void
SelectionState
:
:
SaveSelection
(
Selection
&
aSelection
)
{
if
(
mArray
.
Length
(
)
<
aSelection
.
RangeCount
(
)
)
{
for
(
uint32_t
i
=
mArray
.
Length
(
)
;
i
<
aSelection
.
RangeCount
(
)
;
i
+
+
)
{
mArray
.
AppendElement
(
)
;
mArray
[
i
]
=
new
RangeItem
(
)
;
}
}
else
if
(
mArray
.
Length
(
)
>
aSelection
.
RangeCount
(
)
)
{
mArray
.
TruncateLength
(
aSelection
.
RangeCount
(
)
)
;
}
const
uint32_t
rangeCount
=
aSelection
.
RangeCount
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
.
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
aSelection
.
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
range
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
range
)
)
)
{
continue
;
}
mArray
[
i
]
-
>
StoreRange
(
*
range
)
;
}
mDirection
=
aSelection
.
GetDirection
(
)
;
}
nsresult
SelectionState
:
:
RestoreSelection
(
Selection
&
aSelection
)
{
IgnoredErrorResult
ignoredError
;
aSelection
.
RemoveAllRanges
(
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
RemoveAllRanges
(
)
failed
but
ignored
"
)
;
aSelection
.
SetDirection
(
mDirection
)
;
ErrorResult
error
;
const
CopyableAutoTArray
<
RefPtr
<
RangeItem
>
10
>
rangeItems
(
mArray
)
;
for
(
const
RefPtr
<
RangeItem
>
&
rangeItem
:
rangeItems
)
{
RefPtr
<
nsRange
>
range
=
rangeItem
-
>
GetRange
(
)
;
if
(
!
range
)
{
NS_WARNING
(
"
RangeItem
:
:
GetRange
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
aSelection
.
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
void
SelectionState
:
:
ApplyTo
(
AutoClonedSelectionRangeArray
&
aRanges
)
{
aRanges
.
RemoveAllRanges
(
)
;
aRanges
.
SetDirection
(
mDirection
)
;
for
(
const
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
RefPtr
<
nsRange
>
range
=
rangeItem
-
>
GetRange
(
)
;
if
(
MOZ_UNLIKELY
(
!
range
)
)
{
continue
;
}
aRanges
.
Ranges
(
)
.
AppendElement
(
std
:
:
move
(
range
)
)
;
}
}
bool
SelectionState
:
:
Equals
(
const
SelectionState
&
aOther
)
const
{
if
(
mArray
.
Length
(
)
!
=
aOther
.
mArray
.
Length
(
)
)
{
return
false
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
mDirection
!
=
aOther
.
mDirection
)
{
return
false
;
}
for
(
uint32_t
i
:
IntegerRange
(
mArray
.
Length
(
)
)
)
{
if
(
NS_WARN_IF
(
!
mArray
[
i
]
)
|
|
NS_WARN_IF
(
!
aOther
.
mArray
[
i
]
)
|
|
!
mArray
[
i
]
-
>
Equals
(
*
aOther
.
mArray
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
RangeUpdater
:
:
RangeUpdater
(
)
:
mLocked
(
false
)
{
}
void
RangeUpdater
:
:
RegisterRangeItem
(
RangeItem
&
aRangeItem
)
{
if
(
mArray
.
Contains
(
&
aRangeItem
)
)
{
NS_ERROR
(
"
tried
to
register
an
already
registered
range
"
)
;
return
;
}
mArray
.
AppendElement
(
&
aRangeItem
)
;
}
void
RangeUpdater
:
:
DropRangeItem
(
RangeItem
&
aRangeItem
)
{
NS_WARNING_ASSERTION
(
mArray
.
Contains
(
&
aRangeItem
)
"
aRangeItem
is
not
in
the
range
but
tried
to
removed
from
it
"
)
;
mArray
.
RemoveElement
(
&
aRangeItem
)
;
}
void
RangeUpdater
:
:
RegisterSelectionState
(
SelectionState
&
aSelectionState
)
{
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
aSelectionState
.
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
continue
;
}
RegisterRangeItem
(
*
rangeItem
)
;
}
}
void
RangeUpdater
:
:
DropSelectionState
(
SelectionState
&
aSelectionState
)
{
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
aSelectionState
.
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
continue
;
}
DropRangeItem
(
*
rangeItem
)
;
}
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
aPoint
.
GetContainer
(
)
&
&
rangeItem
-
>
mStartOffset
>
aPoint
.
Offset
(
)
)
{
rangeItem
-
>
mStartOffset
+
+
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
aPoint
.
GetContainer
(
)
&
&
rangeItem
-
>
mEndOffset
>
aPoint
.
Offset
(
)
)
{
rangeItem
-
>
mEndOffset
+
+
;
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
nsresult
rv
=
SelAdjCreateNode
(
aPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
RangeUpdater
:
:
SelAdjCreateNode
(
)
failed
"
)
;
return
rv
;
}
void
RangeUpdater
:
:
SelAdjDeleteNode
(
nsINode
&
aNodeToDelete
)
{
if
(
mLocked
)
{
return
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
;
}
EditorRawDOMPoint
atNodeToDelete
(
&
aNodeToDelete
)
;
NS_ASSERTION
(
atNodeToDelete
.
IsSetAndValid
(
)
"
aNodeToDelete
must
be
an
orphan
node
or
this
is
called
"
"
during
mutation
"
)
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
atNodeToDelete
.
GetContainer
(
)
&
&
rangeItem
-
>
mStartOffset
>
atNodeToDelete
.
Offset
(
)
)
{
rangeItem
-
>
mStartOffset
-
-
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
atNodeToDelete
.
GetContainer
(
)
&
&
rangeItem
-
>
mEndOffset
>
atNodeToDelete
.
Offset
(
)
)
{
rangeItem
-
>
mEndOffset
-
-
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aNodeToDelete
)
{
rangeItem
-
>
mStartContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mStartOffset
=
atNodeToDelete
.
Offset
(
)
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aNodeToDelete
)
{
rangeItem
-
>
mEndContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mEndOffset
=
atNodeToDelete
.
Offset
(
)
;
}
bool
updateEndBoundaryToo
=
false
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
rangeItem
-
>
mStartContainer
aNodeToDelete
)
)
{
updateEndBoundaryToo
=
rangeItem
-
>
mStartContainer
=
=
rangeItem
-
>
mEndContainer
;
rangeItem
-
>
mStartContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mStartOffset
=
atNodeToDelete
.
Offset
(
)
;
}
if
(
updateEndBoundaryToo
|
|
EditorUtils
:
:
IsDescendantOf
(
*
rangeItem
-
>
mEndContainer
aNodeToDelete
)
)
{
rangeItem
-
>
mEndContainer
=
atNodeToDelete
.
GetContainer
(
)
;
rangeItem
-
>
mEndOffset
=
atNodeToDelete
.
Offset
(
)
;
}
}
}
nsresult
RangeUpdater
:
:
SelAdjSplitNode
(
nsIContent
&
aOriginalContent
uint32_t
aSplitOffset
nsIContent
&
aNewContent
)
{
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atNewNode
(
&
aNewContent
)
;
if
(
NS_WARN_IF
(
!
atNewNode
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
auto
AdjustDOMPoint
=
[
&
]
(
nsCOMPtr
<
nsINode
>
&
aContainer
uint32_t
&
aOffset
)
-
>
void
{
if
(
aContainer
=
=
atNewNode
.
GetContainer
(
)
)
{
if
(
aOffset
>
=
atNewNode
.
Offset
(
)
)
{
aOffset
+
+
;
}
}
if
(
aContainer
!
=
&
aOriginalContent
)
{
return
;
}
if
(
aOffset
>
=
aSplitOffset
)
{
aContainer
=
&
aNewContent
;
aOffset
-
=
aSplitOffset
;
}
}
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
AdjustDOMPoint
(
rangeItem
-
>
mStartContainer
rangeItem
-
>
mStartOffset
)
;
AdjustDOMPoint
(
rangeItem
-
>
mEndContainer
rangeItem
-
>
mEndOffset
)
;
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjJoinNodes
(
const
EditorRawDOMPoint
&
aStartOfRightContent
const
nsIContent
&
aRemovedContent
const
EditorDOMPoint
&
aOldPointAtRightContent
)
{
MOZ_ASSERT
(
aStartOfRightContent
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aOldPointAtRightContent
.
IsSet
(
)
)
;
MOZ_ASSERT
(
aOldPointAtRightContent
.
HasOffset
(
)
)
;
if
(
mLocked
)
{
return
NS_OK
;
}
if
(
mArray
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
auto
AdjustDOMPoint
=
[
&
]
(
nsCOMPtr
<
nsINode
>
&
aContainer
uint32_t
&
aOffset
)
-
>
void
{
if
(
aContainer
=
=
&
aRemovedContent
)
{
aContainer
=
aStartOfRightContent
.
GetContainer
(
)
;
aOffset
+
=
aStartOfRightContent
.
Offset
(
)
;
}
else
if
(
aContainer
=
=
aOldPointAtRightContent
.
GetContainer
(
)
)
{
if
(
aOffset
>
aOldPointAtRightContent
.
Offset
(
)
)
{
aOffset
-
-
;
}
else
if
(
aOffset
=
=
aOldPointAtRightContent
.
Offset
(
)
)
{
aContainer
=
aStartOfRightContent
.
GetContainer
(
)
;
aOffset
=
aStartOfRightContent
.
Offset
(
)
;
}
}
}
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
NS_ERROR_FAILURE
;
}
AdjustDOMPoint
(
rangeItem
-
>
mStartContainer
rangeItem
-
>
mStartOffset
)
;
AdjustDOMPoint
(
rangeItem
-
>
mEndContainer
rangeItem
-
>
mEndOffset
)
;
}
return
NS_OK
;
}
void
RangeUpdater
:
:
SelAdjReplaceText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aReplacedLength
uint32_t
aInsertedLength
)
{
if
(
mLocked
)
{
return
;
}
SelAdjInsertText
(
aTextNode
aOffset
aInsertedLength
)
;
SelAdjDeleteText
(
aTextNode
aOffset
aReplacedLength
)
;
}
void
RangeUpdater
:
:
SelAdjInsertText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aInsertedLength
)
{
if
(
mLocked
)
{
return
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mStartOffset
>
aOffset
)
{
rangeItem
-
>
mStartOffset
+
=
aInsertedLength
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mEndOffset
>
aOffset
)
{
rangeItem
-
>
mEndOffset
+
=
aInsertedLength
;
}
}
}
void
RangeUpdater
:
:
SelAdjDeleteText
(
const
Text
&
aTextNode
uint32_t
aOffset
uint32_t
aDeletedLength
)
{
if
(
mLocked
)
{
return
;
}
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
MOZ_ASSERT
(
rangeItem
)
;
if
(
rangeItem
-
>
mStartContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mStartOffset
>
aOffset
)
{
if
(
rangeItem
-
>
mStartOffset
>
=
aDeletedLength
)
{
rangeItem
-
>
mStartOffset
-
=
aDeletedLength
;
}
else
{
rangeItem
-
>
mStartOffset
=
0
;
}
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aTextNode
&
&
rangeItem
-
>
mEndOffset
>
aOffset
)
{
if
(
rangeItem
-
>
mEndOffset
>
=
aDeletedLength
)
{
rangeItem
-
>
mEndOffset
-
=
aDeletedLength
;
}
else
{
rangeItem
-
>
mEndOffset
=
0
;
}
}
}
}
void
RangeUpdater
:
:
DidReplaceContainer
(
const
Element
&
aRemovedElement
Element
&
aInsertedElement
)
{
if
(
NS_WARN_IF
(
!
mLocked
)
)
{
return
;
}
mLocked
=
false
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mStartContainer
=
&
aInsertedElement
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mEndContainer
=
&
aInsertedElement
;
}
}
}
void
RangeUpdater
:
:
DidRemoveContainer
(
const
Element
&
aRemovedElement
nsINode
&
aRemovedElementContainerNode
uint32_t
aOldOffsetOfRemovedElement
uint32_t
aOldChildCountOfRemovedElement
)
{
if
(
NS_WARN_IF
(
!
mLocked
)
)
{
return
;
}
mLocked
=
false
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mStartContainer
=
&
aRemovedElementContainerNode
;
rangeItem
-
>
mStartOffset
+
=
aOldOffsetOfRemovedElement
;
}
else
if
(
rangeItem
-
>
mStartContainer
=
=
&
aRemovedElementContainerNode
&
&
rangeItem
-
>
mStartOffset
>
aOldOffsetOfRemovedElement
)
{
rangeItem
-
>
mStartOffset
+
=
aOldChildCountOfRemovedElement
-
1
;
}
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElement
)
{
rangeItem
-
>
mEndContainer
=
&
aRemovedElementContainerNode
;
rangeItem
-
>
mEndOffset
+
=
aOldOffsetOfRemovedElement
;
}
else
if
(
rangeItem
-
>
mEndContainer
=
=
&
aRemovedElementContainerNode
&
&
rangeItem
-
>
mEndOffset
>
aOldOffsetOfRemovedElement
)
{
rangeItem
-
>
mEndOffset
+
=
aOldChildCountOfRemovedElement
-
1
;
}
}
}
void
RangeUpdater
:
:
DidMoveNodes
(
const
nsTArray
<
SimpleEditorDOMPoint
>
&
aOldPoints
const
SimpleEditorDOMPoint
&
aExpectedDestination
const
nsTArray
<
SimpleEditorDOMPoint
>
&
aNewPoints
)
{
if
(
mLocked
)
{
return
;
}
AutoTArray
<
SimpleEditorRawDOMPoint
12
>
oldPoints
;
oldPoints
.
SetCapacity
(
aOldPoints
.
Length
(
)
)
;
for
(
const
size_t
i
:
IntegerRange
(
aOldPoints
.
Length
(
)
)
)
{
const
SimpleEditorDOMPoint
&
oldPoint
=
aOldPoints
[
i
]
;
if
(
MOZ_UNLIKELY
(
oldPoints
.
IsEmpty
(
)
)
)
{
oldPoints
.
AppendElement
(
SimpleEditorRawDOMPoint
(
oldPoint
.
mContainer
oldPoint
.
mChild
oldPoint
.
Offset
(
)
)
)
;
continue
;
}
if
(
MOZ_UNLIKELY
(
aExpectedDestination
.
mContainer
=
=
oldPoint
.
mContainer
)
&
&
aExpectedDestination
.
Offset
(
)
<
oldPoint
.
Offset
(
)
)
{
oldPoints
.
AppendElement
(
SimpleEditorRawDOMPoint
(
oldPoint
.
mContainer
oldPoint
.
mChild
oldPoint
.
Offset
(
)
)
)
;
continue
;
}
if
(
oldPoints
.
LastElement
(
)
.
mChild
-
>
GetNextSibling
(
)
=
=
oldPoint
.
mChild
)
{
oldPoints
.
AppendElement
(
SimpleEditorRawDOMPoint
(
oldPoint
.
mContainer
oldPoint
.
mChild
oldPoints
.
LastElement
(
)
.
Offset
(
)
)
)
;
continue
;
}
uint32_t
offset
=
oldPoint
.
Offset
(
)
;
for
(
const
SimpleEditorRawDOMPoint
&
precedingPoint
:
oldPoints
)
{
if
(
precedingPoint
.
mContainer
=
=
oldPoint
.
mContainer
&
&
precedingPoint
.
Offset
(
)
<
oldPoint
.
Offset
(
)
)
{
offset
-
-
;
}
}
oldPoints
.
AppendElement
(
SimpleEditorRawDOMPoint
{
oldPoint
.
mContainer
oldPoint
.
mChild
offset
}
)
;
}
size_t
newPointIndex
=
0
;
for
(
const
SimpleEditorRawDOMPoint
&
oldPoint
:
oldPoints
)
{
const
SimpleEditorDOMPoint
*
newPoint
=
newPointIndex
<
aNewPoints
.
Length
(
)
&
&
oldPoint
.
mChild
=
=
aNewPoints
[
newPointIndex
]
.
mChild
?
&
aNewPoints
[
newPointIndex
+
+
]
:
nullptr
;
auto
AdjustDOMPoint
=
[
&
]
(
nsCOMPtr
<
nsINode
>
&
aNode
uint32_t
&
aOffset
)
{
if
(
!
newPoint
|
|
!
newPoint
-
>
mContainer
)
{
if
(
aNode
-
>
IsInclusiveDescendantOf
(
oldPoint
.
mChild
)
)
{
aNode
=
oldPoint
.
mContainer
;
aOffset
=
std
:
:
min
(
oldPoint
.
Offset
(
)
aNode
-
>
Length
(
)
)
;
return
;
}
if
(
aNode
=
=
oldPoint
.
mContainer
)
{
if
(
aOffset
>
oldPoint
.
Offset
(
)
)
{
aOffset
-
-
;
}
if
(
aOffset
>
aNode
-
>
Length
(
)
)
{
aOffset
=
aNode
-
>
Length
(
)
;
}
return
;
}
return
;
}
if
(
aNode
=
=
oldPoint
.
mContainer
)
{
if
(
aOffset
=
=
oldPoint
.
Offset
(
)
)
{
aNode
=
newPoint
-
>
mContainer
;
aOffset
=
newPoint
-
>
Offset
(
)
;
}
else
if
(
aOffset
>
oldPoint
.
Offset
(
)
)
{
aOffset
-
-
;
}
return
;
}
if
(
aNode
=
=
newPoint
-
>
mContainer
)
{
if
(
aOffset
>
newPoint
-
>
Offset
(
)
)
{
aOffset
+
+
;
}
}
}
;
for
(
RefPtr
<
RangeItem
>
&
rangeItem
:
mArray
)
{
if
(
NS_WARN_IF
(
!
rangeItem
)
)
{
return
;
}
AdjustDOMPoint
(
rangeItem
-
>
mStartContainer
rangeItem
-
>
mStartOffset
)
;
AdjustDOMPoint
(
rangeItem
-
>
mEndContainer
rangeItem
-
>
mEndOffset
)
;
}
}
}
NS_IMPL_CYCLE_COLLECTION
(
RangeItem
mStartContainer
mEndContainer
)
void
RangeItem
:
:
StoreRange
(
const
nsRange
&
aRange
)
{
mStartContainer
=
aRange
.
GetStartContainer
(
)
;
mStartOffset
=
aRange
.
StartOffset
(
)
;
mEndContainer
=
aRange
.
GetEndContainer
(
)
;
mEndOffset
=
aRange
.
EndOffset
(
)
;
}
already_AddRefed
<
nsRange
>
RangeItem
:
:
GetRange
(
)
const
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
range
.
forget
(
)
;
}
AutoTrackDOMPoint
:
:
AutoTrackDOMPoint
(
RangeUpdater
&
aRangeUpdater
CaretPoint
*
aCaretPoint
)
:
AutoTrackDOMPoint
(
aRangeUpdater
&
aCaretPoint
-
>
mCaretPoint
)
{
}
AutoTrackDOMMoveNodeResult
:
:
AutoTrackDOMMoveNodeResult
(
RangeUpdater
&
aRangeUpdater
MoveNodeResult
*
aMoveNodeResult
)
:
mTrackCaretPoint
(
aRangeUpdater
static_cast
<
CaretPoint
*
>
(
aMoveNodeResult
)
)
mTrackNextInsertionPoint
(
aRangeUpdater
&
aMoveNodeResult
-
>
mNextInsertionPoint
)
mTrackMovedContentRange
(
aRangeUpdater
&
aMoveNodeResult
-
>
mMovedContentRange
)
{
}
AutoTrackDOMDeleteRangeResult
:
:
AutoTrackDOMDeleteRangeResult
(
RangeUpdater
&
aRangeUpdater
DeleteRangeResult
*
aDeleteRangeResult
)
:
mTrackCaretPoint
(
aRangeUpdater
static_cast
<
CaretPoint
*
>
(
aDeleteRangeResult
)
)
mTrackDeleteRange
(
aRangeUpdater
&
aDeleteRangeResult
-
>
mDeleteRange
)
{
}
AutoTrackLineBreak
:
:
AutoTrackLineBreak
(
RangeUpdater
&
aRangeUpdater
EditorLineBreak
*
aLineBreak
)
:
mLineBreak
(
aLineBreak
-
>
IsPreformattedLineBreak
(
)
?
aLineBreak
:
nullptr
)
mPoint
(
mLineBreak
?
mLineBreak
-
>
To
<
EditorDOMPoint
>
(
)
:
EditorDOMPoint
(
)
)
mTracker
(
aRangeUpdater
&
mPoint
)
{
MOZ_ASSERT
(
aLineBreak
-
>
IsPreformattedLineBreak
(
)
)
;
}
void
AutoTrackLineBreak
:
:
FlushAndStopTracking
(
)
{
if
(
!
mLineBreak
)
{
return
;
}
mTracker
.
FlushAndStopTracking
(
)
;
if
(
mPoint
.
GetContainer
(
)
=
=
mLineBreak
-
>
mContent
)
{
mLineBreak
-
>
mOffsetInText
=
Some
(
mPoint
.
Offset
(
)
)
;
}
mLineBreak
=
nullptr
;
}
}
