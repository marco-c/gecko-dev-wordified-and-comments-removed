#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPoint
&
aPoint
)
;
template
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorRawDOMPoint
&
aPoint
)
;
SelectionState
:
:
SelectionState
(
)
:
mDirection
(
eDirNext
)
{
}
SelectionState
:
:
~
SelectionState
(
)
{
MakeEmpty
(
)
;
}
void
SelectionState
:
:
SaveSelection
(
Selection
*
aSel
)
{
MOZ_ASSERT
(
aSel
)
;
int32_t
arrayCount
=
mArray
.
Length
(
)
;
int32_t
rangeCount
=
aSel
-
>
RangeCount
(
)
;
if
(
arrayCount
<
rangeCount
)
{
for
(
int32_t
i
=
arrayCount
;
i
<
rangeCount
;
i
+
+
)
{
mArray
.
AppendElement
(
)
;
mArray
[
i
]
=
new
RangeItem
(
)
;
}
}
else
if
(
arrayCount
>
rangeCount
)
{
for
(
int32_t
i
=
arrayCount
-
1
;
i
>
=
rangeCount
;
i
-
-
)
{
mArray
.
RemoveElementAt
(
i
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
mArray
[
i
]
-
>
StoreRange
(
aSel
-
>
GetRangeAt
(
i
)
)
;
}
mDirection
=
aSel
-
>
GetDirection
(
)
;
}
nsresult
SelectionState
:
:
RestoreSelection
(
Selection
*
aSel
)
{
NS_ENSURE_TRUE
(
aSel
NS_ERROR_NULL_POINTER
)
;
aSel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
aSel
-
>
SetDirection
(
mDirection
)
;
size_t
arrayCount
=
mArray
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
arrayCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
mArray
[
i
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
aSel
-
>
AddRange
(
*
range
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
bool
SelectionState
:
:
IsCollapsed
(
)
{
if
(
mArray
.
Length
(
)
!
=
1
)
{
return
false
;
}
RefPtr
<
nsRange
>
range
=
mArray
[
0
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
range
false
)
;
return
range
-
>
Collapsed
(
)
;
}
bool
SelectionState
:
:
IsEqual
(
SelectionState
*
aSelState
)
{
NS_ENSURE_TRUE
(
aSelState
false
)
;
size_t
myCount
=
mArray
.
Length
(
)
itsCount
=
aSelState
-
>
mArray
.
Length
(
)
;
if
(
myCount
!
=
itsCount
)
{
return
false
;
}
if
(
!
myCount
)
{
return
false
;
}
if
(
mDirection
!
=
aSelState
-
>
mDirection
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
myCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
myRange
=
mArray
[
i
]
-
>
GetRange
(
)
;
RefPtr
<
nsRange
>
itsRange
=
aSelState
-
>
mArray
[
i
]
-
>
GetRange
(
)
;
NS_ENSURE_TRUE
(
myRange
&
&
itsRange
false
)
;
IgnoredErrorResult
rv
;
int16_t
compResult
=
myRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
START_TO_START
*
itsRange
rv
)
;
if
(
rv
.
Failed
(
)
|
|
compResult
)
{
return
false
;
}
compResult
=
myRange
-
>
CompareBoundaryPoints
(
Range_Binding
:
:
END_TO_END
*
itsRange
rv
)
;
if
(
rv
.
Failed
(
)
|
|
compResult
)
{
return
false
;
}
}
return
true
;
}
void
SelectionState
:
:
MakeEmpty
(
)
{
mArray
.
Clear
(
)
;
mDirection
=
eDirNext
;
}
bool
SelectionState
:
:
IsEmpty
(
)
{
return
mArray
.
IsEmpty
(
)
;
}
RangeUpdater
:
:
RangeUpdater
(
)
:
mLock
(
false
)
{
}
RangeUpdater
:
:
~
RangeUpdater
(
)
{
}
void
RangeUpdater
:
:
RegisterRangeItem
(
RangeItem
*
aRangeItem
)
{
if
(
!
aRangeItem
)
{
return
;
}
if
(
mArray
.
Contains
(
aRangeItem
)
)
{
NS_ERROR
(
"
tried
to
register
an
already
registered
range
"
)
;
return
;
}
mArray
.
AppendElement
(
aRangeItem
)
;
}
void
RangeUpdater
:
:
DropRangeItem
(
RangeItem
*
aRangeItem
)
{
if
(
!
aRangeItem
)
{
return
;
}
mArray
.
RemoveElement
(
aRangeItem
)
;
}
nsresult
RangeUpdater
:
:
RegisterSelectionState
(
SelectionState
&
aSelState
)
{
size_t
theCount
=
aSelState
.
mArray
.
Length
(
)
;
if
(
theCount
<
1
)
{
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
theCount
;
i
+
+
)
{
RegisterRangeItem
(
aSelState
.
mArray
[
i
]
)
;
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DropSelectionState
(
SelectionState
&
aSelState
)
{
size_t
theCount
=
aSelState
.
mArray
.
Length
(
)
;
if
(
theCount
<
1
)
{
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
theCount
;
i
+
+
)
{
DropRangeItem
(
aSelState
.
mArray
[
i
]
)
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjCreateNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
if
(
mLock
)
{
return
NS_OK
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
IsSetAndValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aPoint
.
GetContainer
(
)
&
&
item
-
>
mStartOffset
>
static_cast
<
int32_t
>
(
aPoint
.
Offset
(
)
)
)
{
item
-
>
mStartOffset
+
+
;
}
if
(
item
-
>
mEndContainer
=
=
aPoint
.
GetContainer
(
)
&
&
item
-
>
mEndOffset
>
static_cast
<
int32_t
>
(
aPoint
.
Offset
(
)
)
)
{
item
-
>
mEndOffset
+
+
;
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
nsresult
RangeUpdater
:
:
SelAdjInsertNode
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
return
SelAdjCreateNode
(
aPoint
)
;
}
void
RangeUpdater
:
:
SelAdjDeleteNode
(
nsINode
*
aNode
)
{
if
(
mLock
)
{
return
;
}
MOZ_ASSERT
(
aNode
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
;
}
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
int32_t
offset
=
parent
?
parent
-
>
ComputeIndexOf
(
aNode
)
:
-
1
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
MOZ_ASSERT
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
parent
&
&
item
-
>
mStartOffset
>
offset
)
{
item
-
>
mStartOffset
-
-
;
}
if
(
item
-
>
mEndContainer
=
=
parent
&
&
item
-
>
mEndOffset
>
offset
)
{
item
-
>
mEndOffset
-
-
;
}
if
(
item
-
>
mStartContainer
=
=
aNode
)
{
item
-
>
mStartContainer
=
parent
;
item
-
>
mStartOffset
=
offset
;
}
if
(
item
-
>
mEndContainer
=
=
aNode
)
{
item
-
>
mEndContainer
=
parent
;
item
-
>
mEndOffset
=
offset
;
}
nsCOMPtr
<
nsINode
>
oldStart
;
if
(
EditorUtils
:
:
IsDescendantOf
(
*
item
-
>
mStartContainer
*
aNode
)
)
{
oldStart
=
item
-
>
mStartContainer
;
item
-
>
mStartContainer
=
parent
;
item
-
>
mStartOffset
=
offset
;
}
if
(
item
-
>
mEndContainer
=
=
oldStart
|
|
EditorUtils
:
:
IsDescendantOf
(
*
item
-
>
mEndContainer
*
aNode
)
)
{
item
-
>
mEndContainer
=
parent
;
item
-
>
mEndOffset
=
offset
;
}
}
}
nsresult
RangeUpdater
:
:
SelAdjSplitNode
(
nsIContent
&
aRightNode
nsIContent
*
aNewLeftNode
)
{
if
(
mLock
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
aNewLeftNode
)
)
{
return
NS_ERROR_FAILURE
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
EditorRawDOMPoint
atLeftNode
(
aNewLeftNode
)
;
nsresult
rv
=
SelAdjInsertNode
(
atLeftNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
lengthOfLeftNode
=
aNewLeftNode
-
>
Length
(
)
;
for
(
RefPtr
<
RangeItem
>
&
item
:
mArray
)
{
if
(
NS_WARN_IF
(
!
item
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
item
-
>
mStartContainer
=
=
&
aRightNode
)
{
if
(
item
-
>
mStartOffset
>
lengthOfLeftNode
)
{
item
-
>
mStartOffset
-
=
lengthOfLeftNode
;
}
else
{
item
-
>
mStartContainer
=
aNewLeftNode
;
}
}
if
(
item
-
>
mEndContainer
=
=
&
aRightNode
)
{
if
(
item
-
>
mEndOffset
>
lengthOfLeftNode
)
{
item
-
>
mEndOffset
-
=
lengthOfLeftNode
;
}
else
{
item
-
>
mEndContainer
=
aNewLeftNode
;
}
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
SelAdjJoinNodes
(
nsINode
&
aLeftNode
nsINode
&
aRightNode
nsINode
&
aParent
int32_t
aOffset
int32_t
aOldLeftNodeLength
)
{
if
(
mLock
)
{
return
NS_OK
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
&
aParent
)
{
if
(
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
-
-
;
}
else
if
(
item
-
>
mStartOffset
=
=
aOffset
)
{
item
-
>
mStartContainer
=
&
aRightNode
;
item
-
>
mStartOffset
=
aOldLeftNodeLength
;
}
}
else
if
(
item
-
>
mStartContainer
=
=
&
aRightNode
)
{
item
-
>
mStartOffset
+
=
aOldLeftNodeLength
;
}
else
if
(
item
-
>
mStartContainer
=
=
&
aLeftNode
)
{
item
-
>
mStartContainer
=
&
aRightNode
;
}
if
(
item
-
>
mEndContainer
=
=
&
aParent
)
{
if
(
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
-
-
;
}
else
if
(
item
-
>
mEndOffset
=
=
aOffset
)
{
item
-
>
mEndContainer
=
&
aRightNode
;
item
-
>
mEndOffset
=
aOldLeftNodeLength
;
}
}
else
if
(
item
-
>
mEndContainer
=
=
&
aRightNode
)
{
item
-
>
mEndOffset
+
=
aOldLeftNodeLength
;
}
else
if
(
item
-
>
mEndContainer
=
=
&
aLeftNode
)
{
item
-
>
mEndContainer
=
&
aRightNode
;
}
}
return
NS_OK
;
}
void
RangeUpdater
:
:
SelAdjInsertText
(
Text
&
aTextNode
int32_t
aOffset
const
nsAString
&
aString
)
{
if
(
mLock
)
{
return
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
;
}
size_t
len
=
aString
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
MOZ_ASSERT
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
&
aTextNode
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
+
=
len
;
}
if
(
item
-
>
mEndContainer
=
=
&
aTextNode
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
+
=
len
;
}
}
}
nsresult
RangeUpdater
:
:
SelAdjDeleteText
(
nsIContent
*
aTextNode
int32_t
aOffset
int32_t
aLength
)
{
if
(
mLock
)
{
return
NS_OK
;
}
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aTextNode
NS_ERROR_NULL_POINTER
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aTextNode
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
-
=
aLength
;
if
(
item
-
>
mStartOffset
<
0
)
{
item
-
>
mStartOffset
=
0
;
}
}
if
(
item
-
>
mEndContainer
=
=
aTextNode
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
-
=
aLength
;
if
(
item
-
>
mEndOffset
<
0
)
{
item
-
>
mEndOffset
=
0
;
}
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
WillReplaceContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidReplaceContainer
(
Element
*
aOriginalNode
Element
*
aNewNode
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
NS_ENSURE_TRUE
(
aOriginalNode
&
&
aNewNode
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aOriginalNode
)
{
item
-
>
mStartContainer
=
aNewNode
;
}
if
(
item
-
>
mEndContainer
=
=
aOriginalNode
)
{
item
-
>
mEndContainer
=
aNewNode
;
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
WillRemoveContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidRemoveContainer
(
nsINode
*
aNode
nsINode
*
aParent
int32_t
aOffset
uint32_t
aNodeOrigLen
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
NS_ENSURE_TRUE
(
aNode
&
&
aParent
NS_ERROR_NULL_POINTER
)
;
size_t
count
=
mArray
.
Length
(
)
;
if
(
!
count
)
{
return
NS_OK
;
}
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE
(
item
NS_ERROR_NULL_POINTER
)
;
if
(
item
-
>
mStartContainer
=
=
aNode
)
{
item
-
>
mStartContainer
=
aParent
;
item
-
>
mStartOffset
+
=
aOffset
;
}
else
if
(
item
-
>
mStartContainer
=
=
aParent
&
&
item
-
>
mStartOffset
>
aOffset
)
{
item
-
>
mStartOffset
+
=
(
int32_t
)
aNodeOrigLen
-
1
;
}
if
(
item
-
>
mEndContainer
=
=
aNode
)
{
item
-
>
mEndContainer
=
aParent
;
item
-
>
mEndOffset
+
=
aOffset
;
}
else
if
(
item
-
>
mEndContainer
=
=
aParent
&
&
item
-
>
mEndOffset
>
aOffset
)
{
item
-
>
mEndOffset
+
=
(
int32_t
)
aNodeOrigLen
-
1
;
}
}
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
WillInsertContainer
(
)
{
if
(
mLock
)
{
return
NS_ERROR_UNEXPECTED
;
}
mLock
=
true
;
return
NS_OK
;
}
nsresult
RangeUpdater
:
:
DidInsertContainer
(
)
{
NS_ENSURE_TRUE
(
mLock
NS_ERROR_UNEXPECTED
)
;
mLock
=
false
;
return
NS_OK
;
}
void
RangeUpdater
:
:
WillMoveNode
(
)
{
mLock
=
true
;
}
void
RangeUpdater
:
:
DidMoveNode
(
nsINode
*
aOldParent
int32_t
aOldOffset
nsINode
*
aNewParent
int32_t
aNewOffset
)
{
MOZ_ASSERT
(
aOldParent
)
;
MOZ_ASSERT
(
aNewParent
)
;
NS_ENSURE_TRUE_VOID
(
mLock
)
;
mLock
=
false
;
for
(
size_t
i
=
0
count
=
mArray
.
Length
(
)
;
i
<
count
;
+
+
i
)
{
RangeItem
*
item
=
mArray
[
i
]
;
NS_ENSURE_TRUE_VOID
(
item
)
;
if
(
item
-
>
mStartContainer
=
=
aOldParent
&
&
item
-
>
mStartOffset
>
aOldOffset
)
{
item
-
>
mStartOffset
-
-
;
}
if
(
item
-
>
mEndContainer
=
=
aOldParent
&
&
item
-
>
mEndOffset
>
aOldOffset
)
{
item
-
>
mEndOffset
-
-
;
}
if
(
item
-
>
mStartContainer
=
=
aNewParent
&
&
item
-
>
mStartOffset
>
aNewOffset
)
{
item
-
>
mStartOffset
+
+
;
}
if
(
item
-
>
mEndContainer
=
=
aNewParent
&
&
item
-
>
mEndOffset
>
aNewOffset
)
{
item
-
>
mEndOffset
+
+
;
}
}
}
RangeItem
:
:
RangeItem
(
)
:
mStartOffset
{
0
}
mEndOffset
{
0
}
{
}
RangeItem
:
:
~
RangeItem
(
)
{
}
NS_IMPL_CYCLE_COLLECTION
(
RangeItem
mStartContainer
mEndContainer
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
RangeItem
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
RangeItem
Release
)
void
RangeItem
:
:
StoreRange
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
mStartContainer
=
aRange
-
>
GetStartContainer
(
)
;
mStartOffset
=
aRange
-
>
StartOffset
(
)
;
mEndContainer
=
aRange
-
>
GetEndContainer
(
)
;
mEndOffset
=
aRange
-
>
EndOffset
(
)
;
}
already_AddRefed
<
nsRange
>
RangeItem
:
:
GetRange
(
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mStartContainer
)
;
if
(
NS_FAILED
(
range
-
>
SetStartAndEnd
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
}
