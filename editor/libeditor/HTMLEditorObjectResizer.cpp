#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditorEventListener
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nscore
.
h
"
#
include
<
algorithm
>
#
define
kTopLeft
u
"
nw
"
_ns
#
define
kTop
u
"
n
"
_ns
#
define
kTopRight
u
"
ne
"
_ns
#
define
kLeft
u
"
w
"
_ns
#
define
kRight
u
"
e
"
_ns
#
define
kBottomLeft
u
"
sw
"
_ns
#
define
kBottom
u
"
s
"
_ns
#
define
kBottomRight
u
"
se
"
_ns
namespace
mozilla
{
using
namespace
dom
;
ManualNACPtr
HTMLEditor
:
:
CreateResizer
(
int16_t
aLocation
nsIContent
&
aParentContent
)
{
ManualNACPtr
resizer
=
CreateAnonymousElement
(
nsGkAtoms
:
:
span
aParentContent
u
"
mozResizer
"
_ns
false
)
;
if
(
!
resizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateAnonymousElement
(
nsGkAtoms
:
:
span
mozResizer
)
"
"
failed
"
)
;
return
nullptr
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
resizer
-
>
AddEventListener
(
u
"
mousedown
"
_ns
mEventListener
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EventTarget
:
:
AddEventListener
(
mousedown
)
failed
but
ignored
"
)
;
nsAutoString
locationStr
;
switch
(
aLocation
)
{
case
nsIHTMLObjectResizer
:
:
eTopLeft
:
locationStr
=
kTopLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eTop
:
locationStr
=
kTop
;
break
;
case
nsIHTMLObjectResizer
:
:
eTopRight
:
locationStr
=
kTopRight
;
break
;
case
nsIHTMLObjectResizer
:
:
eLeft
:
locationStr
=
kLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eRight
:
locationStr
=
kRight
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottomLeft
:
locationStr
=
kBottomLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottom
:
locationStr
=
kBottom
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottomRight
:
locationStr
=
kBottomRight
;
break
;
}
if
(
NS_FAILED
(
resizer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
anonlocation
locationStr
true
)
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
anonlocation
)
failed
"
)
;
return
nullptr
;
}
return
resizer
;
}
ManualNACPtr
HTMLEditor
:
:
CreateShadow
(
nsIContent
&
aParentContent
Element
&
aOriginalObject
)
{
RefPtr
<
nsAtom
>
name
;
if
(
HTMLEditUtils
:
:
IsImage
(
&
aOriginalObject
)
)
{
name
=
nsGkAtoms
:
:
img
;
}
else
{
name
=
nsGkAtoms
:
:
span
;
}
return
CreateAnonymousElement
(
name
aParentContent
u
"
mozResizingShadow
"
_ns
true
)
;
}
ManualNACPtr
HTMLEditor
:
:
CreateResizingInfo
(
nsIContent
&
aParentContent
)
{
return
CreateAnonymousElement
(
nsGkAtoms
:
:
span
aParentContent
u
"
mozResizingInfo
"
_ns
true
)
;
}
nsresult
HTMLEditor
:
:
SetAllResizersPosition
(
)
{
if
(
NS_WARN_IF
(
!
mTopLeftHandle
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
x
=
mResizedObjectX
;
int32_t
y
=
mResizedObjectY
;
int32_t
w
=
mResizedObjectWidth
;
int32_t
h
=
mResizedObjectHeight
;
nsAutoString
value
;
float
resizerWidth
resizerHeight
;
RefPtr
<
nsAtom
>
dummyUnit
;
DebugOnly
<
nsresult
>
rvIgnored
=
NS_OK
;
OwningNonNull
<
Element
>
topLeftHandle
=
*
mTopLeftHandle
.
get
(
)
;
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
topLeftHandle
*
nsGkAtoms
:
:
width
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
topLeftHandle
!
=
mTopLeftHandle
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
rvIgnored
=
CSSEditUtils
:
:
GetComputedProperty
(
*
topLeftHandle
*
nsGkAtoms
:
:
height
value
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_WARN_IF
(
topLeftHandle
!
=
mTopLeftHandle
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
CSSEditUtils
:
:
GetComputedProperty
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
CSSEditUtils
:
:
ParseLength
(
value
&
resizerWidth
getter_AddRefs
(
dummyUnit
)
)
;
CSSEditUtils
:
:
ParseLength
(
value
&
resizerHeight
getter_AddRefs
(
dummyUnit
)
)
;
int32_t
rw
=
static_cast
<
int32_t
>
(
(
resizerWidth
+
1
)
/
2
)
;
int32_t
rh
=
static_cast
<
int32_t
>
(
(
resizerHeight
+
1
)
/
2
)
;
auto
setHandlePosition
=
[
this
]
(
ManualNACPtr
&
aHandleElement
int32_t
aNewX
int32_t
aNewY
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
nsresult
{
RefPtr
<
nsStyledElement
>
handleStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
aHandleElement
.
get
(
)
)
;
if
(
!
handleStyledElement
)
{
return
NS_OK
;
}
nsresult
rv
=
SetAnonymousElementPositionWithoutTransaction
(
*
handleStyledElement
aNewX
aNewY
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAnonymousElementPositionWithoutTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
return
NS_WARN_IF
(
handleStyledElement
!
=
aHandleElement
.
get
(
)
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
;
nsresult
rv
;
rv
=
setHandlePosition
(
mTopLeftHandle
x
-
rw
y
-
rh
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
top
-
left
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mTopHandle
x
+
w
/
2
-
rw
y
-
rh
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
top
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mTopRightHandle
x
+
w
-
rw
-
1
y
-
rh
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
top
-
right
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mLeftHandle
x
-
rw
y
+
h
/
2
-
rh
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
left
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mRightHandle
x
+
w
-
rw
-
1
y
+
h
/
2
-
rh
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
right
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mBottomLeftHandle
x
-
rw
y
+
h
-
rh
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
bottom
-
left
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mBottomHandle
x
+
w
/
2
-
rw
y
+
h
-
rh
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
bottom
handle
position
"
)
;
return
rv
;
}
rv
=
setHandlePosition
(
mBottomRightHandle
x
+
w
-
rw
-
1
y
+
h
-
rh
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
set
bottom
-
right
handle
position
"
)
;
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RefreshResizers
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RefreshResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
RefreshResizersInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
RefreshResizersInternal
(
)
{
if
(
!
mResizedObject
)
{
return
NS_OK
;
}
OwningNonNull
<
Element
>
resizedObject
=
*
mResizedObject
;
nsresult
rv
=
GetPositionAndDimensions
(
resizedObject
mResizedObjectX
mResizedObjectY
mResizedObjectWidth
mResizedObjectHeight
mResizedObjectBorderLeft
mResizedObjectBorderTop
mResizedObjectMarginLeft
mResizedObjectMarginTop
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetPositionAndDimensions
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
resizedObject
!
=
mResizedObject
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
SetAllResizersPosition
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAllResizersPosition
(
)
failed
"
)
;
return
rv
;
}
if
(
NS_WARN_IF
(
resizedObject
!
=
mResizedObject
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mResizingShadow
"
SetAllResizersPosition
(
)
should
return
error
if
resizers
are
hidden
"
)
;
RefPtr
<
Element
>
resizingShadow
=
mResizingShadow
.
get
(
)
;
rv
=
SetShadowPosition
(
*
resizingShadow
resizedObject
mResizedObjectX
mResizedObjectY
)
;
if
(
NS_WARN_IF
(
resizedObject
!
=
mResizedObject
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetShadowPosition
(
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
ShowResizersInternal
(
Element
&
aResizedElement
)
{
if
(
NS_WARN_IF
(
mResizedObject
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIContent
>
parentContent
=
aResizedElement
.
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
IsDescendantOfEditorRoot
(
&
aResizedElement
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
do
{
mResizedObject
=
&
aResizedElement
;
ManualNACPtr
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTopLeft
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eTopLeft
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mTopLeftHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mTopLeftHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTop
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eTop
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mTopHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mTopHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTopRight
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eTopRight
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mTopRightHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mTopRightHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eLeft
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eLeft
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mLeftHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mLeftHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eRight
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eRight
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mRightHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mRightHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottomLeft
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eBottomLeft
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mBottomLeftHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mBottomLeftHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottom
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eBottom
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mBottomHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mBottomHandle
=
std
:
:
move
(
newResizer
)
;
newResizer
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottomRight
*
parentContent
)
;
if
(
!
newResizer
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizer
(
eBottomRight
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mBottomRightHandle
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mBottomRightHandle
=
std
:
:
move
(
newResizer
)
;
RefPtr
<
Element
>
createdBottomRightHandle
=
mBottomRightHandle
.
get
(
)
;
nsresult
rv
=
GetPositionAndDimensions
(
aResizedElement
mResizedObjectX
mResizedObjectY
mResizedObjectWidth
mResizedObjectHeight
mResizedObjectBorderLeft
mResizedObjectBorderTop
mResizedObjectMarginLeft
mResizedObjectMarginTop
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
GetPositionAndDimensions
(
)
failed
"
)
;
break
;
}
rv
=
SetAllResizersPosition
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAllResizersPosition
(
)
failed
"
)
;
if
(
NS_WARN_IF
(
mBottomRightHandle
.
get
(
)
!
=
createdBottomRightHandle
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
ManualNACPtr
newShadow
=
CreateShadow
(
*
parentContent
aResizedElement
)
;
if
(
!
newShadow
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateShadow
(
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mResizingShadow
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mResizingShadow
=
std
:
:
move
(
newShadow
)
;
RefPtr
<
Element
>
resizingShadow
=
mResizingShadow
.
get
(
)
;
rv
=
SetShadowPosition
(
*
resizingShadow
aResizedElement
mResizedObjectX
mResizedObjectY
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetShadowPosition
(
)
failed
"
)
;
if
(
NS_WARN_IF
(
mBottomRightHandle
.
get
(
)
!
=
createdBottomRightHandle
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
ManualNACPtr
newResizingInfo
=
CreateResizingInfo
(
*
parentContent
)
;
if
(
!
newResizingInfo
)
{
NS_WARNING
(
"
HTMLEditor
:
:
CreateResizingInfo
(
)
failed
"
)
;
break
;
}
if
(
NS_WARN_IF
(
mResizingInfo
)
|
|
NS_WARN_IF
(
mResizedObject
!
=
&
aResizedElement
)
)
{
return
NS_ERROR_FAILURE
;
}
mResizingInfo
=
std
:
:
move
(
newResizingInfo
)
;
if
(
NS_WARN_IF
(
!
mEventListener
)
)
{
break
;
}
rv
=
static_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
-
>
ListenToWindowResizeEvent
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditorEventListener
:
:
ListenToWindowResizeEvent
(
true
)
failed
"
)
;
break
;
}
MOZ_ASSERT
(
mResizedObject
=
=
&
aResizedElement
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
aResizedElement
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_resizing
u
"
true
"
_ns
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
_moz_resizing
true
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
while
(
true
)
;
DebugOnly
<
nsresult
>
rv
=
HideResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HideResizersInternal
(
)
failed
to
clean
up
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
HTMLEditor
:
:
HideResizers
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
HideResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
HideResizersInternal
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
nsresult
HTMLEditor
:
:
HideResizersInternal
(
)
{
if
(
!
mResizedObject
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
NS_WARNING_ASSERTION
(
presShell
"
There
is
no
presShell
"
)
;
constexpr
auto
mousedown
=
u
"
mousedown
"
_ns
;
ManualNACPtr
topLeftHandle
(
std
:
:
move
(
mTopLeftHandle
)
)
;
ManualNACPtr
topHandle
(
std
:
:
move
(
mTopHandle
)
)
;
ManualNACPtr
topRightHandle
(
std
:
:
move
(
mTopRightHandle
)
)
;
ManualNACPtr
leftHandle
(
std
:
:
move
(
mLeftHandle
)
)
;
ManualNACPtr
rightHandle
(
std
:
:
move
(
mRightHandle
)
)
;
ManualNACPtr
bottomLeftHandle
(
std
:
:
move
(
mBottomLeftHandle
)
)
;
ManualNACPtr
bottomHandle
(
std
:
:
move
(
mBottomHandle
)
)
;
ManualNACPtr
bottomRightHandle
(
std
:
:
move
(
mBottomRightHandle
)
)
;
ManualNACPtr
resizingShadow
(
std
:
:
move
(
mResizingShadow
)
)
;
ManualNACPtr
resizingInfo
(
std
:
:
move
(
mResizingInfo
)
)
;
RefPtr
<
Element
>
activatedHandle
(
std
:
:
move
(
mActivatedHandle
)
)
;
RefPtr
<
Element
>
resizedObject
(
std
:
:
move
(
mResizedObject
)
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
topLeftHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
topHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
topRightHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
leftHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
rightHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
bottomLeftHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
bottomHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
bottomRightHandle
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
resizingShadow
)
presShell
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
std
:
:
move
(
resizingInfo
)
presShell
)
;
if
(
activatedHandle
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
activatedHandle
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
UnsetAttr
(
nsGkAtoms
:
:
_moz_activated
)
failed
but
ignored
"
)
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
resizedObject
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_resizing
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
UnsetAttr
(
nsGkAtoms
:
:
_moz_resizing
)
failed
but
ignored
"
)
;
if
(
!
mEventListener
)
{
return
NS_OK
;
}
nsresult
rv
=
static_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
-
>
ListenToMouseMoveEventForResizers
(
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditorEventListener
:
:
ListenToMouseMoveEventForResizers
(
false
)
"
"
failed
"
)
;
return
rv
;
}
if
(
!
mEventListener
)
{
return
NS_OK
;
}
rv
=
static_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
-
>
ListenToWindowResizeEvent
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditorEventListener
:
:
ListenToWindowResizeEvent
(
false
)
failed
"
)
;
return
rv
;
}
void
HTMLEditor
:
:
HideShadowAndInfo
(
)
{
if
(
mResizingShadow
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mResizingShadow
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
u
"
hidden
"
_ns
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
_class
hidden
)
failed
but
ignored
"
)
;
}
if
(
mResizingInfo
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mResizingInfo
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
u
"
hidden
"
_ns
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
_class
hidden
)
failed
but
ignored
"
)
;
}
}
nsresult
HTMLEditor
:
:
StartResizing
(
Element
&
aHandleElement
)
{
mIsResizing
=
true
;
mActivatedHandle
=
&
aHandleElement
;
DebugOnly
<
nsresult
>
rvIgnored
=
mActivatedHandle
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
u
"
true
"
_ns
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
_moz_activated
true
)
failed
"
)
;
bool
preserveRatio
=
HTMLEditUtils
:
:
IsImage
(
mResizedObject
)
&
&
Preferences
:
:
GetBool
(
"
editor
.
resizing
.
preserve_ratio
"
true
)
;
nsAutoString
locationStr
;
mActivatedHandle
-
>
GetAttr
(
nsGkAtoms
:
:
anonlocation
locationStr
)
;
if
(
locationStr
.
Equals
(
kTopLeft
)
)
{
SetResizeIncrements
(
1
1
-
1
-
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kTop
)
)
{
SetResizeIncrements
(
0
1
0
-
1
false
)
;
}
else
if
(
locationStr
.
Equals
(
kTopRight
)
)
{
SetResizeIncrements
(
0
1
1
-
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kLeft
)
)
{
SetResizeIncrements
(
1
0
-
1
0
false
)
;
}
else
if
(
locationStr
.
Equals
(
kRight
)
)
{
SetResizeIncrements
(
0
0
1
0
false
)
;
}
else
if
(
locationStr
.
Equals
(
kBottomLeft
)
)
{
SetResizeIncrements
(
1
0
-
1
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kBottom
)
)
{
SetResizeIncrements
(
0
0
0
1
false
)
;
}
else
if
(
locationStr
.
Equals
(
kBottomRight
)
)
{
SetResizeIncrements
(
0
0
1
1
preserveRatio
)
;
}
rvIgnored
=
mResizingShadow
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
UnsetAttr
(
nsGkAtoms
:
:
_class
)
failed
"
)
;
if
(
RefPtr
<
nsStyledElement
>
resizingShadowStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
mResizingShadow
.
get
(
)
)
)
{
nsresult
rv
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
width
mResizedObjectWidth
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithoutTransaction
(
"
"
nsGkAtoms
:
:
width
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithoutTransaction
(
"
"
nsGkAtoms
:
:
width
)
failed
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
height
mResizedObjectHeight
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithoutTransaction
(
"
"
nsGkAtoms
:
:
height
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithoutTransaction
(
"
"
nsGkAtoms
:
:
height
)
failed
"
)
;
}
if
(
NS_WARN_IF
(
!
mEventListener
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
static_cast
<
HTMLEditorEventListener
*
>
(
mEventListener
.
get
(
)
)
-
>
ListenToMouseMoveEventForResizers
(
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditorEventListener
:
:
"
"
ListenToMouseMoveEventForResizers
(
true
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
OnMouseDown
(
int32_t
aClientX
int32_t
aClientY
Element
*
aTarget
Event
*
aEvent
)
{
if
(
NS_WARN_IF
(
!
aTarget
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
anonclass
;
aTarget
-
>
GetAttr
(
nsGkAtoms
:
:
_moz_anonclass
anonclass
)
;
if
(
anonclass
.
EqualsLiteral
(
"
mozResizer
"
)
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eResizingElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
aEvent
-
>
PreventDefault
(
)
;
mOriginalX
=
aClientX
;
mOriginalY
=
aClientY
;
nsresult
rv
=
StartResizing
(
*
aTarget
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
StartResizing
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
anonclass
.
EqualsLiteral
(
"
mozGrabber
"
)
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eMovingElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mOriginalX
=
aClientX
;
mOriginalY
=
aClientY
;
nsresult
rv
=
GrabberClicked
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
GrabberClicked
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
OnMouseUp
(
int32_t
aClientX
int32_t
aClientY
)
{
if
(
mIsResizing
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eResizeElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mIsResizing
=
false
;
HideShadowAndInfo
(
)
;
nsresult
rv
=
editActionData
.
MaybeDispatchBeforeInputEvent
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING_ASSERTION
(
rv
=
=
NS_ERROR_EDITOR_ACTION_CANCELED
"
EditorBase
:
:
MaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
rv
=
SetFinalSizeWithTransaction
(
aClientX
aClientY
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetFinalSizeWithTransaction
(
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetFinalSizeWithTransaction
(
)
failed
but
ignored
"
)
;
return
NS_OK
;
}
if
(
mIsMoving
|
|
mGrabberClicked
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eMoveElement
)
;
nsresult
rv
=
editActionData
.
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
;
if
(
rv
!
=
NS_ERROR_EDITOR_ACTION_CANCELED
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
CanHandleAndMaybeDispatchBeforeInputEvent
(
)
failed
"
)
;
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
if
(
mIsMoving
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mPositioningShadow
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
u
"
hidden
"
_ns
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
_class
hidden
)
failed
"
)
;
if
(
rv
!
=
NS_ERROR_EDITOR_ACTION_CANCELED
)
{
SetFinalPosition
(
aClientX
aClientY
)
;
}
}
if
(
mGrabberClicked
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
EndMoving
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
EndMoving
(
)
failed
"
)
;
}
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetResizeIncrements
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
bool
aPreserveRatio
)
{
mXIncrementFactor
=
aX
;
mYIncrementFactor
=
aY
;
mWidthIncrementFactor
=
aW
;
mHeightIncrementFactor
=
aH
;
mPreserveRatio
=
aPreserveRatio
;
}
nsresult
HTMLEditor
:
:
SetResizingInfoPosition
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
)
{
int32_t
infoXPosition
;
int32_t
infoYPosition
;
if
(
mActivatedHandle
=
=
mTopLeftHandle
|
|
mActivatedHandle
=
=
mLeftHandle
|
|
mActivatedHandle
=
=
mBottomLeftHandle
)
{
infoXPosition
=
aX
;
}
else
if
(
mActivatedHandle
=
=
mTopHandle
|
|
mActivatedHandle
=
=
mBottomHandle
)
{
infoXPosition
=
aX
+
(
aW
/
2
)
;
}
else
{
infoXPosition
=
aX
+
aW
;
}
if
(
mActivatedHandle
=
=
mTopLeftHandle
|
|
mActivatedHandle
=
=
mTopHandle
|
|
mActivatedHandle
=
=
mTopRightHandle
)
{
infoYPosition
=
aY
;
}
else
if
(
mActivatedHandle
=
=
mLeftHandle
|
|
mActivatedHandle
=
=
mRightHandle
)
{
infoYPosition
=
aY
+
(
aH
/
2
)
;
}
else
{
infoYPosition
=
aY
+
aH
;
}
const
int
mouseCursorOffset
=
20
;
if
(
RefPtr
<
nsStyledElement
>
resizingInfoStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
mResizingInfo
.
get
(
)
)
)
{
nsresult
rv
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingInfoStyledElement
*
nsGkAtoms
:
:
left
infoXPosition
+
mouseCursorOffset
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
failed
but
ignored
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingInfoStyledElement
*
nsGkAtoms
:
:
top
infoYPosition
+
mouseCursorOffset
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
failed
but
ignored
"
)
;
}
nsCOMPtr
<
nsIContent
>
textInfo
=
mResizingInfo
-
>
GetFirstChild
(
)
;
ErrorResult
error
;
if
(
textInfo
)
{
mResizingInfo
-
>
RemoveChild
(
*
textInfo
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
RemoveChild
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
textInfo
=
nullptr
;
}
nsAutoString
widthStr
heightStr
diffWidthStr
diffHeightStr
;
widthStr
.
AppendInt
(
aW
)
;
heightStr
.
AppendInt
(
aH
)
;
int32_t
diffWidth
=
aW
-
mResizedObjectWidth
;
int32_t
diffHeight
=
aH
-
mResizedObjectHeight
;
if
(
diffWidth
>
0
)
{
diffWidthStr
.
Assign
(
'
+
'
)
;
}
if
(
diffHeight
>
0
)
{
diffHeightStr
.
Assign
(
'
+
'
)
;
}
diffWidthStr
.
AppendInt
(
diffWidth
)
;
diffHeightStr
.
AppendInt
(
diffHeight
)
;
nsAutoString
info
(
widthStr
+
u
"
x
"
_ns
+
heightStr
+
u
"
(
"
_ns
+
diffWidthStr
+
u
"
"
_ns
+
diffHeightStr
+
u
"
)
"
_ns
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
textInfo
=
document
-
>
CreateTextNode
(
info
)
;
if
(
!
textInfo
)
{
NS_WARNING
(
"
Document
:
:
CreateTextNode
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
mResizingInfo
-
>
AppendChild
(
*
textInfo
error
)
;
if
(
error
.
Failed
(
)
)
{
NS_WARNING
(
"
nsINode
:
:
AppendChild
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
rv
=
mResizingInfo
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Element
:
:
UnsetAttr
(
nsGkAtoms
:
:
_class
)
failed
"
)
;
return
rv
;
}
nsresult
HTMLEditor
:
:
SetShadowPosition
(
Element
&
aShadowElement
Element
&
aElement
int32_t
aElementX
int32_t
aElementY
)
{
MOZ_ASSERT
(
&
aShadowElement
=
=
mResizingShadow
|
|
&
aShadowElement
=
=
mPositioningShadow
)
;
RefPtr
<
Element
>
handlingShadowElement
=
&
aShadowElement
=
=
mResizingShadow
?
mResizingShadow
.
get
(
)
:
mPositioningShadow
.
get
(
)
;
if
(
nsStyledElement
*
styledShadowElement
=
nsStyledElement
:
:
FromNode
(
&
aShadowElement
)
)
{
nsresult
rv
=
SetAnonymousElementPositionWithoutTransaction
(
MOZ_KnownLive
(
*
styledShadowElement
)
aElementX
aElementY
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SetAnonymousElementPositionWithoutTransaction
(
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
!
HTMLEditUtils
:
:
IsImage
(
&
aElement
)
)
{
return
NS_OK
;
}
nsAutoString
imageSource
;
aElement
.
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
imageSource
)
;
nsresult
rv
=
aShadowElement
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
imageSource
true
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Element
:
:
SetAttr
(
nsGkAtoms
:
:
src
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_WARN_IF
(
&
aShadowElement
!
=
handlingShadowElement
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
int32_t
HTMLEditor
:
:
GetNewResizingIncrement
(
int32_t
aX
int32_t
aY
ResizeAt
aResizeAt
)
{
int32_t
result
=
0
;
if
(
!
mPreserveRatio
)
{
switch
(
aResizeAt
)
{
case
ResizeAt
:
:
eX
:
case
ResizeAt
:
:
eWidth
:
result
=
aX
-
mOriginalX
;
break
;
case
ResizeAt
:
:
eY
:
case
ResizeAt
:
:
eHeight
:
result
=
aY
-
mOriginalY
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
resizing
request
"
)
;
}
return
result
;
}
int32_t
xi
=
(
aX
-
mOriginalX
)
*
mWidthIncrementFactor
;
int32_t
yi
=
(
aY
-
mOriginalY
)
*
mHeightIncrementFactor
;
float
objectSizeRatio
=
(
(
float
)
mResizedObjectWidth
)
/
(
(
float
)
mResizedObjectHeight
)
;
result
=
(
xi
>
yi
)
?
xi
:
yi
;
switch
(
aResizeAt
)
{
case
ResizeAt
:
:
eX
:
case
ResizeAt
:
:
eWidth
:
if
(
result
=
=
yi
)
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
objectSizeRatio
)
;
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
mWidthIncrementFactor
)
;
break
;
case
ResizeAt
:
:
eY
:
case
ResizeAt
:
:
eHeight
:
if
(
result
=
=
xi
)
result
=
(
int32_t
)
(
(
(
float
)
result
)
/
objectSizeRatio
)
;
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
mHeightIncrementFactor
)
;
break
;
}
return
result
;
}
int32_t
HTMLEditor
:
:
GetNewResizingX
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectX
+
GetNewResizingIncrement
(
aX
aY
ResizeAt
:
:
eX
)
*
mXIncrementFactor
;
int32_t
max
=
mResizedObjectX
+
mResizedObjectWidth
;
return
std
:
:
min
(
resized
max
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingY
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectY
+
GetNewResizingIncrement
(
aX
aY
ResizeAt
:
:
eY
)
*
mYIncrementFactor
;
int32_t
max
=
mResizedObjectY
+
mResizedObjectHeight
;
return
std
:
:
min
(
resized
max
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingWidth
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectWidth
+
GetNewResizingIncrement
(
aX
aY
ResizeAt
:
:
eWidth
)
*
mWidthIncrementFactor
;
return
std
:
:
max
(
resized
1
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingHeight
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectHeight
+
GetNewResizingIncrement
(
aX
aY
ResizeAt
:
:
eHeight
)
*
mHeightIncrementFactor
;
return
std
:
:
max
(
resized
1
)
;
}
nsresult
HTMLEditor
:
:
OnMouseMove
(
MouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
if
(
mIsResizing
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eResizingElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
int32_t
clientX
=
aMouseEvent
-
>
ClientX
(
)
;
int32_t
clientY
=
aMouseEvent
-
>
ClientY
(
)
;
int32_t
newX
=
GetNewResizingX
(
clientX
clientY
)
;
int32_t
newY
=
GetNewResizingY
(
clientX
clientY
)
;
int32_t
newWidth
=
GetNewResizingWidth
(
clientX
clientY
)
;
int32_t
newHeight
=
GetNewResizingHeight
(
clientX
clientY
)
;
if
(
RefPtr
<
nsStyledElement
>
resizingShadowStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
mResizingShadow
.
get
(
)
)
)
{
nsresult
rv
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
left
newX
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
failed
but
ignored
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
top
newY
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
failed
but
ignored
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
width
newWidth
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
width
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
resizingShadowStyledElement
*
nsGkAtoms
:
:
height
newHeight
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
height
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
}
nsresult
rv
=
SetResizingInfoPosition
(
newX
newY
newWidth
newHeight
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
SetResizingInfoPosition
(
)
failed
"
)
;
return
rv
;
}
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eMovingElement
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mGrabberClicked
)
{
int32_t
clientX
=
aMouseEvent
-
>
ClientX
(
)
;
int32_t
clientY
=
aMouseEvent
-
>
ClientY
(
)
;
int32_t
xThreshold
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
DragThresholdX
1
)
;
int32_t
yThreshold
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
DragThresholdY
1
)
;
if
(
DeprecatedAbs
(
clientX
-
mOriginalX
)
*
2
>
=
xThreshold
|
|
DeprecatedAbs
(
clientY
-
mOriginalY
)
*
2
>
=
yThreshold
)
{
mGrabberClicked
=
false
;
DebugOnly
<
nsresult
>
rvIgnored
=
StartMoving
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
StartMoving
(
)
failed
but
ignored
"
)
;
}
}
if
(
mIsMoving
)
{
int32_t
clientX
=
aMouseEvent
-
>
ClientX
(
)
;
int32_t
clientY
=
aMouseEvent
-
>
ClientY
(
)
;
int32_t
newX
=
mPositionedObjectX
+
clientX
-
mOriginalX
;
int32_t
newY
=
mPositionedObjectY
+
clientY
-
mOriginalY
;
SnapToGrid
(
newX
newY
)
;
if
(
RefPtr
<
nsStyledElement
>
positioningShadowStyledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
mPositioningShadow
.
get
(
)
)
)
{
nsresult
rv
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
positioningShadowStyledElement
*
nsGkAtoms
:
:
left
newX
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
failed
but
ignored
"
)
;
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithoutTransaction
(
*
positioningShadowStyledElement
*
nsGkAtoms
:
:
top
newY
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
failed
but
ignored
"
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
SetFinalSizeWithTransaction
(
int32_t
aX
int32_t
aY
)
{
if
(
!
mResizedObject
)
{
return
NS_OK
;
}
if
(
mActivatedHandle
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
mActivatedHandle
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
true
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Element
:
:
UnsetAttr
(
nsGkAtoms
:
:
_moz_activated
)
failed
but
ignored
"
)
;
mActivatedHandle
=
nullptr
;
}
int32_t
left
=
GetNewResizingX
(
aX
aY
)
;
int32_t
top
=
GetNewResizingY
(
aX
aY
)
;
int32_t
width
=
GetNewResizingWidth
(
aX
aY
)
;
int32_t
height
=
GetNewResizingHeight
(
aX
aY
)
;
bool
setWidth
=
!
mResizedObjectIsAbsolutelyPositioned
|
|
(
width
!
=
mResizedObjectWidth
)
;
bool
setHeight
=
!
mResizedObjectIsAbsolutelyPositioned
|
|
(
height
!
=
mResizedObjectHeight
)
;
int32_t
x
y
;
x
=
left
-
(
(
mResizedObjectIsAbsolutelyPositioned
)
?
mResizedObjectBorderLeft
+
mResizedObjectMarginLeft
:
0
)
;
y
=
top
-
(
(
mResizedObjectIsAbsolutelyPositioned
)
?
mResizedObjectBorderTop
+
mResizedObjectMarginTop
:
0
)
;
AutoPlaceholderBatch
treatAsOneTransaction
(
*
this
ScrollSelectionIntoView
:
:
Yes
)
;
RefPtr
<
Element
>
resizedElement
(
mResizedObject
)
;
RefPtr
<
nsStyledElement
>
resizedStyleElement
=
nsStyledElement
:
:
FromNodeOrNull
(
mResizedObject
)
;
if
(
mResizedObjectIsAbsolutelyPositioned
&
&
resizedStyleElement
)
{
if
(
setHeight
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
top
y
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
top
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
top
)
"
"
failed
but
ignored
"
)
;
}
if
(
setWidth
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
left
x
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
left
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
left
)
"
"
"
"
failed
but
ignored
"
)
;
}
}
if
(
IsCSSEnabled
(
)
|
|
mResizedObjectIsAbsolutelyPositioned
)
{
if
(
setWidth
&
&
resizedElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
width
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RemoveAttributeWithTransaction
(
*
resizedElement
*
nsGkAtoms
:
:
width
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
}
if
(
setHeight
&
&
resizedElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
height
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
RemoveAttributeWithTransaction
(
*
resizedElement
*
nsGkAtoms
:
:
height
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
RemoveAttributeWithTransaction
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
}
if
(
resizedStyleElement
)
{
if
(
setWidth
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
width
width
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
width
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixels
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
}
if
(
setHeight
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
height
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
height
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixels
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
}
}
}
else
{
if
(
resizedStyleElement
)
{
if
(
setWidth
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
width
width
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
width
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
width
)
failed
but
ignored
"
)
;
}
if
(
setHeight
)
{
nsresult
rv
=
mCSSEditUtils
-
>
SetCSSPropertyPixelsWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
height
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
height
)
destoyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
SetCSSPropertyPixelsWithTransaction
(
nsGkAtoms
:
:
"
"
height
)
failed
but
ignored
"
)
;
}
}
if
(
setWidth
)
{
nsAutoString
w
;
w
.
AppendInt
(
width
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
SetAttributeWithTransaction
(
*
resizedElement
*
nsGkAtoms
:
:
width
w
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
}
if
(
setHeight
)
{
nsAutoString
h
;
h
.
AppendInt
(
height
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
SetAttributeWithTransaction
(
*
resizedElement
*
nsGkAtoms
:
:
height
h
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
EditorBase
:
:
SetAttributeWithTransaction
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
}
if
(
resizedStyleElement
)
{
if
(
setWidth
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSPropertyWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
width
u
"
"
_ns
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
nsGkAtoms
:
:
width
)
"
"
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
nsGkAtoms
:
:
width
)
"
"
failed
but
ignored
"
)
;
}
if
(
setHeight
)
{
nsresult
rv
=
mCSSEditUtils
-
>
RemoveCSSPropertyWithTransaction
(
*
resizedStyleElement
*
nsGkAtoms
:
:
height
u
"
"
_ns
)
;
if
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
{
NS_WARNING
(
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
nsGkAtoms
:
:
"
"
height
)
destroyed
the
editor
"
)
;
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
CSSEditUtils
:
:
RemoveCSSPropertyWithTransaction
(
nsGkAtoms
:
:
height
)
"
"
failed
but
ignored
"
)
;
}
}
}
mResizedObjectWidth
=
width
;
mResizedObjectHeight
=
height
;
DebugOnly
<
nsresult
>
rvIgnored
=
RefreshResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
RefreshResizersInternal
(
)
failed
but
ignored
"
)
;
return
NS_WARN_IF
(
Destroyed
(
)
)
?
NS_ERROR_EDITOR_DESTROYED
:
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetObjectResizingEnabled
(
bool
*
aIsObjectResizingEnabled
)
{
*
aIsObjectResizingEnabled
=
IsObjectResizerEnabled
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetObjectResizingEnabled
(
bool
aObjectResizingEnabled
)
{
EnableObjectResizer
(
aObjectResizingEnabled
)
;
return
NS_OK
;
}
#
undef
kTopLeft
#
undef
kTop
#
undef
kTopRight
#
undef
kLeft
#
undef
kRight
#
undef
kBottomLeft
#
undef
kBottom
#
undef
kBottomRight
}
