#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
HTMLEditorObjectResizerUtils
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMMouseEvent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsSubstringTuple
.
h
"
#
include
"
nscore
.
h
"
#
include
<
algorithm
>
class
nsISelection
;
namespace
mozilla
{
using
namespace
dom
;
NS_IMPL_ISUPPORTS
(
DocumentResizeEventListener
nsIDOMEventListener
)
DocumentResizeEventListener
:
:
DocumentResizeEventListener
(
HTMLEditor
&
aHTMLEditor
)
:
mHTMLEditorWeak
(
&
aHTMLEditor
)
{
}
NS_IMETHODIMP
DocumentResizeEventListener
:
:
HandleEvent
(
nsIDOMEvent
*
aMouseEvent
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditorWeak
.
get
(
)
;
if
(
htmlEditor
)
{
return
htmlEditor
-
>
RefreshResizers
(
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
ResizerSelectionListener
nsISelectionListener
)
ResizerSelectionListener
:
:
ResizerSelectionListener
(
HTMLEditor
&
aHTMLEditor
)
:
mHTMLEditorWeak
(
&
aHTMLEditor
)
{
}
NS_IMETHODIMP
ResizerSelectionListener
:
:
NotifySelectionChanged
(
nsIDOMDocument
*
aDOMDocument
nsISelection
*
aSelection
int16_t
aReason
)
{
if
(
(
aReason
&
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
&
&
aSelection
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditorWeak
.
get
(
)
;
if
(
htmlEditor
)
{
htmlEditor
-
>
CheckSelectionStateForAnonymousButtons
(
aSelection
)
;
}
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
ResizerMouseMotionListener
nsIDOMEventListener
)
ResizerMouseMotionListener
:
:
ResizerMouseMotionListener
(
HTMLEditor
&
aHTMLEditor
)
:
mHTMLEditorWeak
(
&
aHTMLEditor
)
{
}
NS_IMETHODIMP
ResizerMouseMotionListener
:
:
HandleEvent
(
nsIDOMEvent
*
aMouseEvent
)
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aMouseEvent
)
;
if
(
!
mouseEvent
)
{
return
NS_OK
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditorWeak
.
get
(
)
;
if
(
htmlEditor
)
{
htmlEditor
-
>
MouseMove
(
mouseEvent
)
;
}
return
NS_OK
;
}
ManualNACPtr
HTMLEditor
:
:
CreateResizer
(
int16_t
aLocation
nsIContent
&
aParentContent
)
{
ManualNACPtr
ret
=
CreateAnonymousElement
(
nsGkAtoms
:
:
span
aParentContent
NS_LITERAL_STRING
(
"
mozResizer
"
)
false
)
;
if
(
NS_WARN_IF
(
!
ret
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
evtTarget
=
do_QueryInterface
(
ret
)
;
evtTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
mEventListener
true
)
;
nsAutoString
locationStr
;
switch
(
aLocation
)
{
case
nsIHTMLObjectResizer
:
:
eTopLeft
:
locationStr
=
kTopLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eTop
:
locationStr
=
kTop
;
break
;
case
nsIHTMLObjectResizer
:
:
eTopRight
:
locationStr
=
kTopRight
;
break
;
case
nsIHTMLObjectResizer
:
:
eLeft
:
locationStr
=
kLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eRight
:
locationStr
=
kRight
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottomLeft
:
locationStr
=
kBottomLeft
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottom
:
locationStr
=
kBottom
;
break
;
case
nsIHTMLObjectResizer
:
:
eBottomRight
:
locationStr
=
kBottomRight
;
break
;
}
nsresult
rv
=
ret
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
anonlocation
locationStr
true
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
Move
(
ret
)
;
}
ManualNACPtr
HTMLEditor
:
:
CreateShadow
(
nsIContent
&
aParentContent
Element
&
aOriginalObject
)
{
nsCOMPtr
<
nsIAtom
>
name
;
if
(
HTMLEditUtils
:
:
IsImage
(
&
aOriginalObject
)
)
{
name
=
nsGkAtoms
:
:
img
;
}
else
{
name
=
nsGkAtoms
:
:
span
;
}
return
CreateAnonymousElement
(
name
aParentContent
NS_LITERAL_STRING
(
"
mozResizingShadow
"
)
true
)
;
}
ManualNACPtr
HTMLEditor
:
:
CreateResizingInfo
(
nsIContent
&
aParentContent
)
{
return
CreateAnonymousElement
(
nsGkAtoms
:
:
span
aParentContent
NS_LITERAL_STRING
(
"
mozResizingInfo
"
)
true
)
;
}
nsresult
HTMLEditor
:
:
SetAllResizersPosition
(
)
{
NS_ENSURE_TRUE
(
mTopLeftHandle
NS_ERROR_FAILURE
)
;
int32_t
x
=
mResizedObjectX
;
int32_t
y
=
mResizedObjectY
;
int32_t
w
=
mResizedObjectWidth
;
int32_t
h
=
mResizedObjectHeight
;
nsAutoString
value
;
float
resizerWidth
resizerHeight
;
nsCOMPtr
<
nsIAtom
>
dummyUnit
;
mCSSEditUtils
-
>
GetComputedProperty
(
*
mTopLeftHandle
*
nsGkAtoms
:
:
width
value
)
;
mCSSEditUtils
-
>
ParseLength
(
value
&
resizerWidth
getter_AddRefs
(
dummyUnit
)
)
;
mCSSEditUtils
-
>
GetComputedProperty
(
*
mTopLeftHandle
*
nsGkAtoms
:
:
height
value
)
;
mCSSEditUtils
-
>
ParseLength
(
value
&
resizerHeight
getter_AddRefs
(
dummyUnit
)
)
;
int32_t
rw
=
(
int32_t
)
(
(
resizerWidth
+
1
)
/
2
)
;
int32_t
rh
=
(
int32_t
)
(
(
resizerHeight
+
1
)
/
2
)
;
SetAnonymousElementPosition
(
x
-
rw
y
-
rh
mTopLeftHandle
)
;
SetAnonymousElementPosition
(
x
+
w
/
2
-
rw
y
-
rh
mTopHandle
)
;
SetAnonymousElementPosition
(
x
+
w
-
rw
-
1
y
-
rh
mTopRightHandle
)
;
SetAnonymousElementPosition
(
x
-
rw
y
+
h
/
2
-
rh
mLeftHandle
)
;
SetAnonymousElementPosition
(
x
+
w
-
rw
-
1
y
+
h
/
2
-
rh
mRightHandle
)
;
SetAnonymousElementPosition
(
x
-
rw
y
+
h
-
rh
-
1
mBottomLeftHandle
)
;
SetAnonymousElementPosition
(
x
+
w
/
2
-
rw
y
+
h
-
rh
-
1
mBottomHandle
)
;
SetAnonymousElementPosition
(
x
+
w
-
rw
-
1
y
+
h
-
rh
-
1
mBottomRightHandle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
RefreshResizers
(
)
{
NS_ENSURE_TRUE
(
mResizedObject
NS_OK
)
;
nsresult
rv
=
GetPositionAndDimensions
(
*
mResizedObject
mResizedObjectX
mResizedObjectY
mResizedObjectWidth
mResizedObjectHeight
mResizedObjectBorderLeft
mResizedObjectBorderTop
mResizedObjectMarginLeft
mResizedObjectMarginTop
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetAllResizersPosition
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
SetShadowPosition
(
mResizingShadow
mResizedObject
mResizedObjectX
mResizedObjectY
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
ShowResizers
(
nsIDOMElement
*
aResizedElement
)
{
if
(
NS_WARN_IF
(
!
aResizedElement
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aResizedElement
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
ShowResizersInner
(
*
element
)
;
if
(
NS_FAILED
(
rv
)
)
{
HideResizers
(
)
;
}
return
rv
;
}
nsresult
HTMLEditor
:
:
ShowResizersInner
(
Element
&
aResizedElement
)
{
if
(
mResizedObject
)
{
NS_ERROR
(
"
call
HideResizers
first
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIContent
>
parentContent
=
aResizedElement
.
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
mResizedObject
=
&
aResizedElement
;
mTopLeftHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTopLeft
*
parentContent
)
;
NS_ENSURE_TRUE
(
mTopLeftHandle
NS_ERROR_FAILURE
)
;
mTopHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTop
*
parentContent
)
;
NS_ENSURE_TRUE
(
mTopHandle
NS_ERROR_FAILURE
)
;
mTopRightHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eTopRight
*
parentContent
)
;
NS_ENSURE_TRUE
(
mTopRightHandle
NS_ERROR_FAILURE
)
;
mLeftHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eLeft
*
parentContent
)
;
NS_ENSURE_TRUE
(
mLeftHandle
NS_ERROR_FAILURE
)
;
mRightHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eRight
*
parentContent
)
;
NS_ENSURE_TRUE
(
mRightHandle
NS_ERROR_FAILURE
)
;
mBottomLeftHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottomLeft
*
parentContent
)
;
NS_ENSURE_TRUE
(
mBottomLeftHandle
NS_ERROR_FAILURE
)
;
mBottomHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottom
*
parentContent
)
;
NS_ENSURE_TRUE
(
mBottomHandle
NS_ERROR_FAILURE
)
;
mBottomRightHandle
=
CreateResizer
(
nsIHTMLObjectResizer
:
:
eBottomRight
*
parentContent
)
;
NS_ENSURE_TRUE
(
mBottomRightHandle
NS_ERROR_FAILURE
)
;
nsresult
rv
=
GetPositionAndDimensions
(
aResizedElement
mResizedObjectX
mResizedObjectY
mResizedObjectWidth
mResizedObjectHeight
mResizedObjectBorderLeft
mResizedObjectBorderTop
mResizedObjectMarginLeft
mResizedObjectMarginTop
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetAllResizersPosition
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mResizingShadow
=
CreateShadow
(
*
parentContent
aResizedElement
)
;
NS_ENSURE_TRUE
(
mResizingShadow
NS_ERROR_FAILURE
)
;
rv
=
SetShadowPosition
(
mResizingShadow
&
aResizedElement
mResizedObjectX
mResizedObjectY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mResizingInfo
=
CreateResizingInfo
(
*
parentContent
)
;
NS_ENSURE_TRUE
(
mResizingInfo
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
do_QueryInterface
(
doc
-
>
GetWindow
(
)
)
;
if
(
!
target
)
{
return
NS_ERROR_NULL_POINTER
;
}
mResizeEventListenerP
=
new
DocumentResizeEventListener
(
*
this
)
;
rv
=
target
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
resize
"
)
mResizeEventListenerP
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aResizedElement
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_resizing
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
MOZ_ASSERT
(
mResizedObject
=
=
&
aResizedElement
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
HideResizers
(
)
{
NS_ENSURE_TRUE
(
mResizedObject
NS_OK
)
;
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_NAMED_LITERAL_STRING
(
mousedown
"
mousedown
"
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mTopLeftHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mTopHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mTopRightHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mLeftHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mRightHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mBottomLeftHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mBottomHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mBottomRightHandle
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mResizingShadow
)
ps
)
;
RemoveListenerAndDeleteRef
(
mousedown
mEventListener
true
Move
(
mResizingInfo
)
ps
)
;
if
(
mActivatedHandle
)
{
mActivatedHandle
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
true
)
;
mActivatedHandle
=
nullptr
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
GetDOMEventTarget
(
)
;
if
(
target
&
&
mMouseMotionListenerP
)
{
DebugOnly
<
nsresult
>
rv
=
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
true
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
failed
to
remove
mouse
motion
listener
"
)
;
}
mMouseMotionListenerP
=
nullptr
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_NULL_POINTER
;
}
target
=
do_QueryInterface
(
doc
-
>
GetWindow
(
)
)
;
if
(
!
target
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mResizeEventListenerP
)
{
DebugOnly
<
nsresult
>
rv
=
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
resize
"
)
mResizeEventListenerP
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
failed
to
remove
resize
event
listener
"
)
;
}
mResizeEventListenerP
=
nullptr
;
mResizedObject
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_resizing
true
)
;
mResizedObject
=
nullptr
;
return
NS_OK
;
}
void
HTMLEditor
:
:
HideShadowAndInfo
(
)
{
if
(
mResizingShadow
)
{
mResizingShadow
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
hidden
"
)
true
)
;
}
if
(
mResizingInfo
)
{
mResizingInfo
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
hidden
"
)
true
)
;
}
}
nsresult
HTMLEditor
:
:
StartResizing
(
nsIDOMElement
*
aHandle
)
{
mIsResizing
=
true
;
mActivatedHandle
=
do_QueryInterface
(
aHandle
)
;
NS_ENSURE_STATE
(
mActivatedHandle
|
|
!
aHandle
)
;
mActivatedHandle
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
bool
preserveRatio
=
HTMLEditUtils
:
:
IsImage
(
mResizedObject
)
&
&
Preferences
:
:
GetBool
(
"
editor
.
resizing
.
preserve_ratio
"
true
)
;
nsAutoString
locationStr
;
aHandle
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
anonlocation
"
)
locationStr
)
;
if
(
locationStr
.
Equals
(
kTopLeft
)
)
{
SetResizeIncrements
(
1
1
-
1
-
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kTop
)
)
{
SetResizeIncrements
(
0
1
0
-
1
false
)
;
}
else
if
(
locationStr
.
Equals
(
kTopRight
)
)
{
SetResizeIncrements
(
0
1
1
-
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kLeft
)
)
{
SetResizeIncrements
(
1
0
-
1
0
false
)
;
}
else
if
(
locationStr
.
Equals
(
kRight
)
)
{
SetResizeIncrements
(
0
0
1
0
false
)
;
}
else
if
(
locationStr
.
Equals
(
kBottomLeft
)
)
{
SetResizeIncrements
(
1
0
-
1
1
preserveRatio
)
;
}
else
if
(
locationStr
.
Equals
(
kBottom
)
)
{
SetResizeIncrements
(
0
0
0
1
false
)
;
}
else
if
(
locationStr
.
Equals
(
kBottomRight
)
)
{
SetResizeIncrements
(
0
0
1
1
preserveRatio
)
;
}
mResizingShadow
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
true
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
width
mResizedObjectWidth
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
height
mResizedObjectHeight
)
;
nsresult
result
=
NS_OK
;
if
(
!
mMouseMotionListenerP
)
{
mMouseMotionListenerP
=
new
ResizerMouseMotionListener
(
*
this
)
;
if
(
!
mMouseMotionListenerP
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
target
=
GetDOMEventTarget
(
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_FAILURE
)
;
result
=
target
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mMouseMotionListenerP
true
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
result
)
"
failed
to
register
mouse
motion
listener
"
)
;
}
return
result
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MouseDown
(
int32_t
aClientX
int32_t
aClientY
nsIDOMElement
*
aTarget
nsIDOMEvent
*
aEvent
)
{
bool
anonElement
=
false
;
if
(
aTarget
&
&
NS_SUCCEEDED
(
aTarget
-
>
HasAttribute
(
NS_LITERAL_STRING
(
"
_moz_anonclass
"
)
&
anonElement
)
)
)
if
(
anonElement
)
{
nsAutoString
anonclass
;
nsresult
rv
=
aTarget
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
_moz_anonclass
"
)
anonclass
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
anonclass
.
EqualsLiteral
(
"
mozResizer
"
)
)
{
aEvent
-
>
PreventDefault
(
)
;
mOriginalX
=
aClientX
;
mOriginalY
=
aClientY
;
return
StartResizing
(
aTarget
)
;
}
if
(
anonclass
.
EqualsLiteral
(
"
mozGrabber
"
)
)
{
mOriginalX
=
aClientX
;
mOriginalY
=
aClientY
;
return
GrabberClicked
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MouseUp
(
int32_t
aClientX
int32_t
aClientY
nsIDOMElement
*
aTarget
)
{
if
(
mIsResizing
)
{
mIsResizing
=
false
;
HideShadowAndInfo
(
)
;
SetFinalSize
(
aClientX
aClientY
)
;
}
else
if
(
mIsMoving
|
|
mGrabberClicked
)
{
if
(
mIsMoving
)
{
mPositioningShadow
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
hidden
"
)
true
)
;
SetFinalPosition
(
aClientX
aClientY
)
;
}
if
(
mGrabberClicked
)
{
EndMoving
(
)
;
}
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetResizeIncrements
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
bool
aPreserveRatio
)
{
mXIncrementFactor
=
aX
;
mYIncrementFactor
=
aY
;
mWidthIncrementFactor
=
aW
;
mHeightIncrementFactor
=
aH
;
mPreserveRatio
=
aPreserveRatio
;
}
nsresult
HTMLEditor
:
:
SetResizingInfoPosition
(
int32_t
aX
int32_t
aY
int32_t
aW
int32_t
aH
)
{
int32_t
infoXPosition
;
int32_t
infoYPosition
;
if
(
mActivatedHandle
=
=
mTopLeftHandle
|
|
mActivatedHandle
=
=
mLeftHandle
|
|
mActivatedHandle
=
=
mBottomLeftHandle
)
{
infoXPosition
=
aX
;
}
else
if
(
mActivatedHandle
=
=
mTopHandle
|
|
mActivatedHandle
=
=
mBottomHandle
)
{
infoXPosition
=
aX
+
(
aW
/
2
)
;
}
else
{
infoXPosition
=
aX
+
aW
;
}
if
(
mActivatedHandle
=
=
mTopLeftHandle
|
|
mActivatedHandle
=
=
mTopHandle
|
|
mActivatedHandle
=
=
mTopRightHandle
)
{
infoYPosition
=
aY
;
}
else
if
(
mActivatedHandle
=
=
mLeftHandle
|
|
mActivatedHandle
=
=
mRightHandle
)
{
infoYPosition
=
aY
+
(
aH
/
2
)
;
}
else
{
infoYPosition
=
aY
+
aH
;
}
const
int
mouseCursorOffset
=
20
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingInfo
*
nsGkAtoms
:
:
left
infoXPosition
+
mouseCursorOffset
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingInfo
*
nsGkAtoms
:
:
top
infoYPosition
+
mouseCursorOffset
)
;
nsCOMPtr
<
nsIContent
>
textInfo
=
mResizingInfo
-
>
GetFirstChild
(
)
;
ErrorResult
erv
;
if
(
textInfo
)
{
mResizingInfo
-
>
RemoveChild
(
*
textInfo
erv
)
;
NS_ENSURE_TRUE
(
!
erv
.
Failed
(
)
erv
.
StealNSResult
(
)
)
;
textInfo
=
nullptr
;
}
nsAutoString
widthStr
heightStr
diffWidthStr
diffHeightStr
;
widthStr
.
AppendInt
(
aW
)
;
heightStr
.
AppendInt
(
aH
)
;
int32_t
diffWidth
=
aW
-
mResizedObjectWidth
;
int32_t
diffHeight
=
aH
-
mResizedObjectHeight
;
if
(
diffWidth
>
0
)
{
diffWidthStr
.
Assign
(
'
+
'
)
;
}
if
(
diffHeight
>
0
)
{
diffHeightStr
.
Assign
(
'
+
'
)
;
}
diffWidthStr
.
AppendInt
(
diffWidth
)
;
diffHeightStr
.
AppendInt
(
diffHeight
)
;
nsAutoString
info
(
widthStr
+
NS_LITERAL_STRING
(
"
x
"
)
+
heightStr
+
NS_LITERAL_STRING
(
"
(
"
)
+
diffWidthStr
+
NS_LITERAL_STRING
(
"
"
)
+
diffHeightStr
+
NS_LITERAL_STRING
(
"
)
"
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
textInfo
=
doc
-
>
CreateTextNode
(
info
)
;
if
(
NS_WARN_IF
(
!
textInfo
)
)
{
return
NS_ERROR_FAILURE
;
}
mResizingInfo
-
>
AppendChild
(
*
textInfo
erv
)
;
if
(
NS_WARN_IF
(
erv
.
Failed
(
)
)
)
{
return
erv
.
StealNSResult
(
)
;
}
return
mResizingInfo
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
true
)
;
}
nsresult
HTMLEditor
:
:
SetShadowPosition
(
Element
*
aShadow
Element
*
aOriginalObject
int32_t
aOriginalObjectX
int32_t
aOriginalObjectY
)
{
SetAnonymousElementPosition
(
aOriginalObjectX
aOriginalObjectY
aShadow
)
;
if
(
HTMLEditUtils
:
:
IsImage
(
aOriginalObject
)
)
{
nsAutoString
imageSource
;
aOriginalObject
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
imageSource
)
;
nsresult
rv
=
aShadow
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
imageSource
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
int32_t
HTMLEditor
:
:
GetNewResizingIncrement
(
int32_t
aX
int32_t
aY
int32_t
aID
)
{
int32_t
result
=
0
;
if
(
!
mPreserveRatio
)
{
switch
(
aID
)
{
case
kX
:
case
kWidth
:
result
=
aX
-
mOriginalX
;
break
;
case
kY
:
case
kHeight
:
result
=
aY
-
mOriginalY
;
break
;
}
return
result
;
}
int32_t
xi
=
(
aX
-
mOriginalX
)
*
mWidthIncrementFactor
;
int32_t
yi
=
(
aY
-
mOriginalY
)
*
mHeightIncrementFactor
;
float
objectSizeRatio
=
(
(
float
)
mResizedObjectWidth
)
/
(
(
float
)
mResizedObjectHeight
)
;
result
=
(
xi
>
yi
)
?
xi
:
yi
;
switch
(
aID
)
{
case
kX
:
case
kWidth
:
if
(
result
=
=
yi
)
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
objectSizeRatio
)
;
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
mWidthIncrementFactor
)
;
break
;
case
kY
:
case
kHeight
:
if
(
result
=
=
xi
)
result
=
(
int32_t
)
(
(
(
float
)
result
)
/
objectSizeRatio
)
;
result
=
(
int32_t
)
(
(
(
float
)
result
)
*
mHeightIncrementFactor
)
;
break
;
}
return
result
;
}
int32_t
HTMLEditor
:
:
GetNewResizingX
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectX
+
GetNewResizingIncrement
(
aX
aY
kX
)
*
mXIncrementFactor
;
int32_t
max
=
mResizedObjectX
+
mResizedObjectWidth
;
return
std
:
:
min
(
resized
max
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingY
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectY
+
GetNewResizingIncrement
(
aX
aY
kY
)
*
mYIncrementFactor
;
int32_t
max
=
mResizedObjectY
+
mResizedObjectHeight
;
return
std
:
:
min
(
resized
max
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingWidth
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectWidth
+
GetNewResizingIncrement
(
aX
aY
kWidth
)
*
mWidthIncrementFactor
;
return
std
:
:
max
(
resized
1
)
;
}
int32_t
HTMLEditor
:
:
GetNewResizingHeight
(
int32_t
aX
int32_t
aY
)
{
int32_t
resized
=
mResizedObjectHeight
+
GetNewResizingIncrement
(
aX
aY
kHeight
)
*
mHeightIncrementFactor
;
return
std
:
:
max
(
resized
1
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
MouseMove
(
nsIDOMEvent
*
aMouseEvent
)
{
nsCOMPtr
<
nsIDOMMouseEvent
>
mouseEvent
=
do_QueryInterface
(
aMouseEvent
)
;
if
(
NS_WARN_IF
(
!
mouseEvent
)
)
{
return
NS_OK
;
}
return
MouseMove
(
mouseEvent
)
;
}
nsresult
HTMLEditor
:
:
MouseMove
(
nsIDOMMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
NS_NAMED_LITERAL_STRING
(
leftStr
"
left
"
)
;
NS_NAMED_LITERAL_STRING
(
topStr
"
top
"
)
;
if
(
mIsResizing
)
{
int32_t
clientX
clientY
;
aMouseEvent
-
>
GetClientX
(
&
clientX
)
;
aMouseEvent
-
>
GetClientY
(
&
clientY
)
;
int32_t
newX
=
GetNewResizingX
(
clientX
clientY
)
;
int32_t
newY
=
GetNewResizingY
(
clientX
clientY
)
;
int32_t
newWidth
=
GetNewResizingWidth
(
clientX
clientY
)
;
int32_t
newHeight
=
GetNewResizingHeight
(
clientX
clientY
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
left
newX
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
top
newY
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
width
newWidth
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizingShadow
*
nsGkAtoms
:
:
height
newHeight
)
;
return
SetResizingInfoPosition
(
newX
newY
newWidth
newHeight
)
;
}
if
(
mGrabberClicked
)
{
int32_t
clientX
clientY
;
aMouseEvent
-
>
GetClientX
(
&
clientX
)
;
aMouseEvent
-
>
GetClientY
(
&
clientY
)
;
int32_t
xThreshold
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_DragThresholdX
1
)
;
int32_t
yThreshold
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_DragThresholdY
1
)
;
if
(
DeprecatedAbs
(
clientX
-
mOriginalX
)
*
2
>
=
xThreshold
|
|
DeprecatedAbs
(
clientY
-
mOriginalY
)
*
2
>
=
yThreshold
)
{
mGrabberClicked
=
false
;
StartMoving
(
nullptr
)
;
}
}
if
(
mIsMoving
)
{
int32_t
clientX
clientY
;
aMouseEvent
-
>
GetClientX
(
&
clientX
)
;
aMouseEvent
-
>
GetClientY
(
&
clientY
)
;
int32_t
newX
=
mPositionedObjectX
+
clientX
-
mOriginalX
;
int32_t
newY
=
mPositionedObjectY
+
clientY
-
mOriginalY
;
SnapToGrid
(
newX
newY
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mPositioningShadow
*
nsGkAtoms
:
:
left
newX
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mPositioningShadow
*
nsGkAtoms
:
:
top
newY
)
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetFinalSize
(
int32_t
aX
int32_t
aY
)
{
if
(
!
mResizedObject
)
{
return
;
}
if
(
mActivatedHandle
)
{
mActivatedHandle
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_activated
true
)
;
mActivatedHandle
=
nullptr
;
}
int32_t
left
=
GetNewResizingX
(
aX
aY
)
;
int32_t
top
=
GetNewResizingY
(
aX
aY
)
;
int32_t
width
=
GetNewResizingWidth
(
aX
aY
)
;
int32_t
height
=
GetNewResizingHeight
(
aX
aY
)
;
bool
setWidth
=
!
mResizedObjectIsAbsolutelyPositioned
|
|
(
width
!
=
mResizedObjectWidth
)
;
bool
setHeight
=
!
mResizedObjectIsAbsolutelyPositioned
|
|
(
height
!
=
mResizedObjectHeight
)
;
int32_t
x
y
;
x
=
left
-
(
(
mResizedObjectIsAbsolutelyPositioned
)
?
mResizedObjectBorderLeft
+
mResizedObjectMarginLeft
:
0
)
;
y
=
top
-
(
(
mResizedObjectIsAbsolutelyPositioned
)
?
mResizedObjectBorderTop
+
mResizedObjectMarginTop
:
0
)
;
AutoPlaceholderBatch
batchIt
(
this
)
;
if
(
mResizedObjectIsAbsolutelyPositioned
)
{
if
(
setHeight
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
top
y
)
;
}
if
(
setWidth
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
left
x
)
;
}
}
if
(
IsCSSEnabled
(
)
|
|
mResizedObjectIsAbsolutelyPositioned
)
{
if
(
setWidth
&
&
mResizedObject
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
width
)
)
{
RemoveAttribute
(
mResizedObject
nsGkAtoms
:
:
width
)
;
}
if
(
setHeight
&
&
mResizedObject
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
height
)
)
{
RemoveAttribute
(
mResizedObject
nsGkAtoms
:
:
height
)
;
}
if
(
setWidth
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
width
width
)
;
}
if
(
setHeight
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
height
height
)
;
}
}
else
{
if
(
setWidth
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
width
width
)
;
}
if
(
setHeight
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
mResizedObject
*
nsGkAtoms
:
:
height
height
)
;
}
if
(
setWidth
)
{
nsAutoString
w
;
w
.
AppendInt
(
width
)
;
SetAttribute
(
mResizedObject
nsGkAtoms
:
:
width
w
)
;
}
if
(
setHeight
)
{
nsAutoString
h
;
h
.
AppendInt
(
height
)
;
SetAttribute
(
mResizedObject
nsGkAtoms
:
:
height
h
)
;
}
if
(
setWidth
)
{
mCSSEditUtils
-
>
RemoveCSSProperty
(
*
mResizedObject
*
nsGkAtoms
:
:
width
EmptyString
(
)
)
;
}
if
(
setHeight
)
{
mCSSEditUtils
-
>
RemoveCSSProperty
(
*
mResizedObject
*
nsGkAtoms
:
:
height
EmptyString
(
)
)
;
}
}
mResizedObjectWidth
=
width
;
mResizedObjectHeight
=
height
;
RefreshResizers
(
)
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetResizedObject
(
nsIDOMElement
*
*
aResizedObject
)
{
nsCOMPtr
<
nsIDOMElement
>
ret
=
static_cast
<
nsIDOMElement
*
>
(
GetAsDOMNode
(
mResizedObject
)
)
;
ret
.
forget
(
aResizedObject
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
GetObjectResizingEnabled
(
bool
*
aIsObjectResizingEnabled
)
{
*
aIsObjectResizingEnabled
=
mIsObjectResizingEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLEditor
:
:
SetObjectResizingEnabled
(
bool
aObjectResizingEnabled
)
{
mIsObjectResizingEnabled
=
aObjectResizingEnabled
;
return
NS_OK
;
}
}
