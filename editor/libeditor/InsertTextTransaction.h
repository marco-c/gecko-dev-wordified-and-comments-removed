#
ifndef
InsertTextTransaction_h
#
define
InsertTextTransaction_h
#
include
"
EditTransactionBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Text
;
}
class
InsertTextTransaction
final
:
public
EditTransactionBase
{
protected
:
InsertTextTransaction
(
EditorBase
&
aEditorBase
const
nsAString
&
aStringToInsert
const
EditorDOMPointInText
&
aPointToInsert
)
;
public
:
static
already_AddRefed
<
InsertTextTransaction
>
Create
(
EditorBase
&
aEditorBase
const
nsAString
&
aStringToInsert
const
EditorDOMPointInText
&
aPointToInsert
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
InsertTextTransaction
EditTransactionBase
)
NS_DECL_EDITTRANSACTIONBASE
NS_DECL_EDITTRANSACTIONBASE_GETASMETHODS_OVERRIDE
(
InsertTextTransaction
)
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
RedoTransaction
(
)
override
;
NS_IMETHOD
Merge
(
nsITransaction
*
aOtherTransaction
bool
*
aDidMerge
)
override
;
const
nsString
&
GetData
(
)
const
{
return
mStringToInsert
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
SuggestPointToPutCaret
(
)
const
{
if
(
NS_WARN_IF
(
!
mTextNode
)
)
{
return
EditorDOMPointType
(
)
;
}
return
EditorDOMPointType
(
mTextNode
mOffset
+
mStringToInsert
.
Length
(
)
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
InsertTextTransaction
&
aTransaction
)
;
private
:
virtual
~
InsertTextTransaction
(
)
=
default
;
bool
IsSequentialInsert
(
InsertTextTransaction
&
aOtherTransaction
)
const
;
RefPtr
<
dom
:
:
Text
>
mTextNode
;
uint32_t
mOffset
;
nsString
mStringToInsert
;
RefPtr
<
EditorBase
>
mEditorBase
;
}
;
}
#
endif
