#
ifndef
AutoRangeArray_h
#
define
AutoRangeArray_h
#
include
"
EditAction
.
h
"
#
include
"
EditorBase
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorForwards
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
class
MOZ_STACK_CLASS
AutoRangeArray
final
{
public
:
explicit
AutoRangeArray
(
const
dom
:
:
Selection
&
aSelection
)
;
template
<
typename
PointType
>
explicit
AutoRangeArray
(
const
EditorDOMRangeBase
<
PointType
>
&
aRange
)
;
template
<
typename
PT
typename
CT
>
explicit
AutoRangeArray
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
;
explicit
AutoRangeArray
(
const
AutoRangeArray
&
aOther
)
;
~
AutoRangeArray
(
)
;
void
Initialize
(
const
dom
:
:
Selection
&
aSelection
)
{
ClearSavedRanges
(
)
;
mDirection
=
aSelection
.
GetDirection
(
)
;
mRanges
.
Clear
(
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
aSelection
.
RangeCount
(
)
)
)
{
MOZ_ASSERT
(
aSelection
.
GetRangeAt
(
i
)
)
;
mRanges
.
AppendElement
(
aSelection
.
GetRangeAt
(
i
)
-
>
CloneRange
(
)
)
;
if
(
aSelection
.
GetRangeAt
(
i
)
=
=
aSelection
.
GetAnchorFocusRange
(
)
)
{
mAnchorFocusRange
=
mRanges
.
LastElement
(
)
;
}
}
}
[
[
nodiscard
]
]
bool
IsInContent
(
)
const
{
if
(
mRanges
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
if
(
MOZ_UNLIKELY
(
!
range
-
>
IsPositioned
(
)
|
|
!
range
-
>
GetStartContainer
(
)
|
|
!
range
-
>
GetStartContainer
(
)
-
>
IsContent
(
)
|
|
!
range
-
>
GetEndContainer
(
)
|
|
!
range
-
>
GetEndContainer
(
)
-
>
IsContent
(
)
)
)
{
return
false
;
}
}
return
true
;
}
void
EnsureOnlyEditableRanges
(
const
dom
:
:
Element
&
aEditingHost
)
;
void
EnsureRangesInTextNode
(
const
dom
:
:
Text
&
aTextNode
)
;
void
ExtendRangesToWrapLinesToHandleBlockLevelEditAction
(
EditSubAction
aEditSubAction
const
dom
:
:
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
static
bool
IsEditableRange
(
const
dom
:
:
AbstractRange
&
aRange
const
dom
:
:
Element
&
aEditingHost
)
;
[
[
nodiscard
]
]
bool
IsFirstRangeEditable
(
const
dom
:
:
Element
&
aEditingHost
)
const
{
return
IsEditableRange
(
FirstRangeRef
(
)
aEditingHost
)
;
}
[
[
nodiscard
]
]
bool
IsAtLeastOneContainerOfRangeBoundariesInclusiveDescendantOf
(
const
nsIContent
&
aContent
)
const
{
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
if
(
startContainer
&
&
startContainer
-
>
IsInclusiveDescendantOf
(
&
aContent
)
)
{
return
true
;
}
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
startContainer
=
=
endContainer
)
{
continue
;
}
if
(
endContainer
&
&
endContainer
-
>
IsInclusiveDescendantOf
(
&
aContent
)
)
{
return
true
;
}
}
return
false
;
}
[
[
nodiscard
]
]
auto
&
Ranges
(
)
{
return
mRanges
;
}
[
[
nodiscard
]
]
const
auto
&
Ranges
(
)
const
{
return
mRanges
;
}
[
[
nodiscard
]
]
OwningNonNull
<
nsRange
>
&
FirstRangeRef
(
)
{
return
mRanges
[
0
]
;
}
[
[
nodiscard
]
]
const
OwningNonNull
<
nsRange
>
&
FirstRangeRef
(
)
const
{
return
mRanges
[
0
]
;
}
template
<
template
<
typename
>
typename
StrongPtrType
>
[
[
nodiscard
]
]
AutoTArray
<
StrongPtrType
<
nsRange
>
8
>
CloneRanges
(
)
const
{
AutoTArray
<
StrongPtrType
<
nsRange
>
8
>
ranges
;
for
(
const
auto
&
range
:
mRanges
)
{
ranges
.
AppendElement
(
range
-
>
CloneRange
(
)
)
;
}
return
ranges
;
}
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
EditorDOMPointType
GetFirstRangeStartPoint
(
)
const
{
if
(
mRanges
.
IsEmpty
(
)
|
|
!
mRanges
[
0
]
-
>
IsPositioned
(
)
)
{
return
EditorDOMPointType
(
)
;
}
return
EditorDOMPointType
(
mRanges
[
0
]
-
>
StartRef
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
[
[
nodiscard
]
]
EditorDOMPointType
GetFirstRangeEndPoint
(
)
const
{
if
(
mRanges
.
IsEmpty
(
)
|
|
!
mRanges
[
0
]
-
>
IsPositioned
(
)
)
{
return
EditorDOMPointType
(
)
;
}
return
EditorDOMPointType
(
mRanges
[
0
]
-
>
EndRef
(
)
)
;
}
nsresult
SelectNode
(
nsINode
&
aNode
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
mAnchorFocusRange
=
nsRange
:
:
Create
(
&
aNode
)
;
if
(
!
mAnchorFocusRange
)
{
return
NS_ERROR_FAILURE
;
}
}
ErrorResult
error
;
mAnchorFocusRange
-
>
SelectNode
(
aNode
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
nsIEditor
:
:
EDirection
nsresult
>
ExtendAnchorFocusRangeFor
(
const
EditorBase
&
aEditorBase
nsIEditor
:
:
EDirection
aDirectionAndAmount
)
;
enum
class
IfSelectingOnlyOneAtomicContent
{
Collapse
KeepSelecting
}
;
Result
<
bool
nsresult
>
ShrinkRangesIfStartFromOrEndAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsIEditor
:
:
EDirection
aDirectionAndAmount
IfSelectingOnlyOneAtomicContent
aIfSelectingOnlyOneAtomicContent
const
dom
:
:
Element
*
aEditingHost
)
;
[
[
nodiscard
]
]
bool
IsCollapsed
(
)
const
{
return
mRanges
.
IsEmpty
(
)
|
|
(
mRanges
.
Length
(
)
=
=
1
&
&
mRanges
[
0
]
-
>
Collapsed
(
)
)
;
}
template
<
typename
PT
typename
CT
>
nsresult
Collapse
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
ErrorResult
error
;
mAnchorFocusRange
=
nsRange
:
:
Create
(
aPoint
.
ToRawRangeBoundary
(
)
aPoint
.
ToRawRangeBoundary
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
mAnchorFocusRange
-
>
CollapseTo
(
aPoint
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mAnchorFocusRange
=
nullptr
;
return
rv
;
}
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
template
<
typename
SPT
typename
SCT
typename
EPT
typename
ECT
>
nsresult
SetStartAndEnd
(
const
EditorDOMPointBase
<
SPT
SCT
>
&
aStart
const
EditorDOMPointBase
<
EPT
ECT
>
&
aEnd
)
{
mRanges
.
Clear
(
)
;
if
(
!
mAnchorFocusRange
)
{
ErrorResult
error
;
mAnchorFocusRange
=
nsRange
:
:
Create
(
aStart
.
ToRawRangeBoundary
(
)
aEnd
.
ToRawRangeBoundary
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
mAnchorFocusRange
=
nullptr
;
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsresult
rv
=
mAnchorFocusRange
-
>
SetStartAndEnd
(
aStart
.
ToRawRangeBoundary
(
)
aEnd
.
ToRawRangeBoundary
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mAnchorFocusRange
=
nullptr
;
return
rv
;
}
}
mRanges
.
AppendElement
(
*
mAnchorFocusRange
)
;
return
NS_OK
;
}
template
<
typename
SPT
typename
SCT
typename
EPT
typename
ECT
>
nsresult
SetBaseAndExtent
(
const
EditorDOMPointBase
<
SPT
SCT
>
&
aAnchor
const
EditorDOMPointBase
<
EPT
ECT
>
&
aFocus
)
{
if
(
MOZ_UNLIKELY
(
!
aAnchor
.
IsSet
(
)
)
|
|
MOZ_UNLIKELY
(
!
aFocus
.
IsSet
(
)
)
)
{
mRanges
.
Clear
(
)
;
mAnchorFocusRange
=
nullptr
;
return
NS_ERROR_INVALID_ARG
;
}
return
aAnchor
.
EqualsOrIsBefore
(
aFocus
)
?
SetStartAndEnd
(
aAnchor
aFocus
)
:
SetStartAndEnd
(
aFocus
aAnchor
)
;
}
[
[
nodiscard
]
]
const
nsRange
*
GetAnchorFocusRange
(
)
const
{
return
mAnchorFocusRange
;
}
[
[
nodiscard
]
]
nsDirection
GetDirection
(
)
const
{
return
mDirection
;
}
void
SetDirection
(
nsDirection
aDirection
)
{
mDirection
=
aDirection
;
}
[
[
nodiscard
]
]
const
RangeBoundary
&
AnchorRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmptyRangeBoundary
;
return
sEmptyRangeBoundary
;
}
return
mDirection
=
=
nsDirection
:
:
eDirNext
?
mAnchorFocusRange
-
>
StartRef
(
)
:
mAnchorFocusRange
-
>
EndRef
(
)
;
}
[
[
nodiscard
]
]
nsINode
*
GetAnchorNode
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
Container
(
)
:
nullptr
;
}
[
[
nodiscard
]
]
uint32_t
GetAnchorOffset
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
.
valueOr
(
0
)
:
0
;
}
[
[
nodiscard
]
]
nsIContent
*
GetChildAtAnchorOffset
(
)
const
{
return
AnchorRef
(
)
.
IsSet
(
)
?
AnchorRef
(
)
.
GetChildAtOffset
(
)
:
nullptr
;
}
[
[
nodiscard
]
]
const
RangeBoundary
&
FocusRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmptyRangeBoundary
;
return
sEmptyRangeBoundary
;
}
return
mDirection
=
=
nsDirection
:
:
eDirNext
?
mAnchorFocusRange
-
>
EndRef
(
)
:
mAnchorFocusRange
-
>
StartRef
(
)
;
}
[
[
nodiscard
]
]
nsINode
*
GetFocusNode
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
Container
(
)
:
nullptr
;
}
[
[
nodiscard
]
]
uint32_t
FocusOffset
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
.
valueOr
(
0
)
:
0
;
}
[
[
nodiscard
]
]
nsIContent
*
GetChildAtFocusOffset
(
)
const
{
return
FocusRef
(
)
.
IsSet
(
)
?
FocusRef
(
)
.
GetChildAtOffset
(
)
:
nullptr
;
}
void
RemoveAllRanges
(
)
{
mRanges
.
Clear
(
)
;
mAnchorFocusRange
=
nullptr
;
mDirection
=
nsDirection
:
:
eDirNext
;
}
[
[
nodiscard
]
]
bool
SaveAndTrackRanges
(
HTMLEditor
&
aHTMLEditor
)
;
[
[
nodiscard
]
]
bool
HasSavedRanges
(
)
const
{
return
mSavedRanges
.
isSome
(
)
;
}
void
ClearSavedRanges
(
)
;
void
RestoreFromSavedRanges
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSavedRanges
.
isSome
(
)
)
;
if
(
mSavedRanges
.
isNothing
(
)
)
{
return
;
}
mSavedRanges
-
>
ApplyTo
(
*
this
)
;
ClearSavedRanges
(
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
ApplyTo
(
dom
:
:
Selection
&
aSelection
)
{
dom
:
:
SelectionBatcher
selectionBatcher
(
aSelection
__FUNCTION__
)
;
aSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
MOZ_ASSERT
(
!
aSelection
.
RangeCount
(
)
)
;
aSelection
.
SetDirection
(
mDirection
)
;
IgnoredErrorResult
error
;
for
(
const
OwningNonNull
<
nsRange
>
&
range
:
mRanges
)
{
aSelection
.
AddRangeAndSelectFramesAndNotifyListeners
(
MOZ_KnownLive
(
range
)
error
)
;
if
(
error
.
Failed
(
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
static
void
UpdatePointsToSelectAllChildrenIfCollapsedInEmptyBlockElement
(
EditorDOMPoint
&
aStartPoint
EditorDOMPoint
&
aEndPoint
const
dom
:
:
Element
&
aEditingHost
)
;
static
already_AddRefed
<
nsRange
>
CreateRangeWrappingStartAndEndLinesContainingBoundaries
(
const
EditorDOMRange
&
aRange
EditSubAction
aEditSubAction
const
dom
:
:
Element
&
aEditingHost
)
{
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
nullptr
;
}
return
CreateRangeWrappingStartAndEndLinesContainingBoundaries
(
aRange
.
StartRef
(
)
aRange
.
EndRef
(
)
aEditSubAction
aEditingHost
)
;
}
static
already_AddRefed
<
nsRange
>
CreateRangeWrappingStartAndEndLinesContainingBoundaries
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
EditSubAction
aEditSubAction
const
dom
:
:
Element
&
aEditingHost
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aStartPoint
.
ToRawRangeBoundary
(
)
aEndPoint
.
ToRawRangeBoundary
(
)
IgnoreErrors
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
range
)
)
{
return
nullptr
;
}
if
(
NS_FAILED
(
ExtendRangeToWrapStartAndEndLinesContainingBoundaries
(
*
range
aEditSubAction
aEditingHost
)
)
|
|
MOZ_UNLIKELY
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
nullptr
;
}
return
range
.
forget
(
)
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Result
<
EditorDOMPoint
nsresult
>
SplitTextNodesAtEndBoundariesAndParentInlineElementsAtBoundaries
(
HTMLEditor
&
aHTMLEditor
)
;
enum
class
CollectNonEditableNodes
{
No
Yes
}
;
nsresult
CollectEditTargetNodes
(
const
HTMLEditor
&
aHTMLEditor
nsTArray
<
OwningNonNull
<
nsIContent
>
>
&
aOutArrayOfContents
EditSubAction
aEditSubAction
CollectNonEditableNodes
aCollectNonEditableNodes
)
const
;
dom
:
:
Element
*
GetClosestAncestorAnyListElementOfRange
(
)
const
;
private
:
static
nsresult
ExtendRangeToWrapStartAndEndLinesContainingBoundaries
(
nsRange
&
aRange
EditSubAction
aEditSubAction
const
dom
:
:
Element
&
aEditingHost
)
;
AutoTArray
<
mozilla
:
:
OwningNonNull
<
nsRange
>
8
>
mRanges
;
RefPtr
<
nsRange
>
mAnchorFocusRange
;
nsDirection
mDirection
=
nsDirection
:
:
eDirNext
;
Maybe
<
SelectionState
>
mSavedRanges
;
RefPtr
<
HTMLEditor
>
mTrackingHTMLEditor
;
}
;
}
#
endif
