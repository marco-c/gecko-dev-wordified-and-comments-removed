#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsIHTMLInlineTableEditor
.
h
"
#
include
"
nsIHTMLObjectResizer
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsROCSSPrimitiveValue
.
h
"
class
nsIDOMEventListener
;
namespace
mozilla
{
using
namespace
dom
;
static
int32_t
GetCSSFloatValue
(
nsComputedDOMStyle
*
aComputedStyle
const
nsAString
&
aProperty
)
{
MOZ_ASSERT
(
aComputedStyle
)
;
nsAutoString
value
;
nsresult
rv
=
aComputedStyle
-
>
GetPropertyValue
(
aProperty
value
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
0
;
}
int32_t
val
=
value
.
ToInteger
(
&
rv
)
;
return
NS_SUCCEEDED
(
rv
)
?
val
:
0
;
}
class
ElementDeletionObserver
final
:
public
nsStubMutationObserver
{
public
:
ElementDeletionObserver
(
nsIContent
*
aNativeAnonNode
Element
*
aObservedElement
)
:
mNativeAnonNode
(
aNativeAnonNode
)
mObservedElement
(
aObservedElement
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
protected
:
~
ElementDeletionObserver
(
)
{
}
nsIContent
*
mNativeAnonNode
;
Element
*
mObservedElement
;
}
;
NS_IMPL_ISUPPORTS
(
ElementDeletionObserver
nsIMutationObserver
)
void
ElementDeletionObserver
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
if
(
aContent
=
=
mObservedElement
&
&
mNativeAnonNode
&
&
mNativeAnonNode
-
>
GetParentNode
(
)
=
=
aContent
)
{
if
(
mNativeAnonNode
-
>
OwnerDoc
(
)
!
=
mObservedElement
-
>
OwnerDoc
(
)
)
{
mObservedElement
-
>
RemoveMutationObserver
(
this
)
;
mObservedElement
=
nullptr
;
mNativeAnonNode
-
>
RemoveMutationObserver
(
this
)
;
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
mNativeAnonNode
=
nullptr
;
NS_RELEASE_THIS
(
)
;
return
;
}
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
BindContext
context
(
*
mObservedElement
BindContext
:
:
ForNativeAnonymous
)
;
mNativeAnonNode
-
>
BindToTree
(
context
*
mObservedElement
)
;
}
}
void
ElementDeletionObserver
:
:
NodeWillBeDestroyed
(
const
nsINode
*
aNode
)
{
NS_ASSERTION
(
aNode
=
=
mNativeAnonNode
|
|
aNode
=
=
mObservedElement
"
Wrong
aNode
!
"
)
;
if
(
aNode
=
=
mNativeAnonNode
)
{
mObservedElement
-
>
RemoveMutationObserver
(
this
)
;
mObservedElement
=
nullptr
;
}
else
{
mNativeAnonNode
-
>
RemoveMutationObserver
(
this
)
;
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
mNativeAnonNode
=
nullptr
;
}
NS_RELEASE_THIS
(
)
;
}
ManualNACPtr
HTMLEditor
:
:
CreateAnonymousElement
(
nsAtom
*
aTag
nsIContent
&
aParentContent
const
nsAString
&
aAnonClass
bool
aIsCreatedHidden
)
{
if
(
!
aParentContent
.
IsHTMLElement
(
)
)
{
return
nullptr
;
}
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newContentRaw
=
CreateHTMLContent
(
aTag
)
;
if
(
NS_WARN_IF
(
!
newContentRaw
)
)
{
return
nullptr
;
}
if
(
aIsCreatedHidden
)
{
nsresult
rv
=
newContentRaw
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
hidden
"
)
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
if
(
!
aAnonClass
.
IsEmpty
(
)
)
{
nsresult
rv
=
newContentRaw
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_anonclass
aAnonClass
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
{
nsAutoScriptBlocker
scriptBlocker
;
newContentRaw
-
>
SetIsNativeAnonymousRoot
(
)
;
BindContext
context
(
*
aParentContent
.
AsElement
(
)
BindContext
:
:
ForNativeAnonymous
)
;
nsresult
rv
=
newContentRaw
-
>
BindToTree
(
context
aParentContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
newContentRaw
-
>
UnbindFromTree
(
)
;
return
nullptr
;
}
}
ManualNACPtr
newContent
(
newContentRaw
.
forget
(
)
)
;
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
if
(
ServoStyleSet
:
:
MayTraverseFrom
(
newContent
)
)
{
styleSet
-
>
StyleNewSubtree
(
newContent
)
;
}
ElementDeletionObserver
*
observer
=
new
ElementDeletionObserver
(
newContent
aParentContent
.
AsElement
(
)
)
;
NS_ADDREF
(
observer
)
;
aParentContent
.
AddMutationObserver
(
observer
)
;
newContent
-
>
AddMutationObserver
(
observer
)
;
#
ifdef
DEBUG
newContent
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
presShell
-
>
PostRecreateFramesFor
(
newContent
)
;
return
newContent
;
}
void
HTMLEditor
:
:
RemoveListenerAndDeleteRef
(
const
nsAString
&
aEvent
nsIDOMEventListener
*
aListener
bool
aUseCapture
ManualNACPtr
aElement
PresShell
*
aPresShell
)
{
if
(
aElement
)
{
aElement
-
>
RemoveEventListener
(
aEvent
aListener
aUseCapture
)
;
}
DeleteRefToAnonymousNode
(
std
:
:
move
(
aElement
)
aPresShell
)
;
}
void
HTMLEditor
:
:
DeleteRefToAnonymousNode
(
ManualNACPtr
aContent
PresShell
*
aPresShell
)
{
if
(
NS_WARN_IF
(
!
aContent
)
)
{
return
;
}
nsIContent
*
parentContent
=
aContent
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
aContent
-
>
IsInComposedDoc
(
)
&
&
aPresShell
&
&
!
aPresShell
-
>
IsDestroying
(
)
)
{
MOZ_ASSERT
(
aContent
-
>
IsRootOfAnonymousSubtree
(
)
)
;
MOZ_ASSERT
(
!
aContent
-
>
GetPreviousSibling
(
)
"
NAC
has
no
siblings
"
)
;
aPresShell
-
>
ContentRemoved
(
aContent
nullptr
)
;
}
}
void
HTMLEditor
:
:
HideAnonymousEditingUIs
(
)
{
if
(
mAbsolutelyPositionedObject
)
{
HideGrabberInternal
(
)
;
NS_ASSERTION
(
!
mAbsolutelyPositionedObject
"
HideGrabber
failed
"
)
;
}
if
(
mInlineEditedCell
)
{
HideInlineTableEditingUIInternal
(
)
;
NS_ASSERTION
(
!
mInlineEditedCell
"
HideInlineTableEditingUIInternal
failed
"
)
;
}
if
(
mResizedObject
)
{
DebugOnly
<
nsresult
>
rv
=
HideResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HideResizersInternal
(
)
failed
"
)
;
NS_ASSERTION
(
!
mResizedObject
"
HideResizersInternal
(
)
failed
"
)
;
}
}
void
HTMLEditor
:
:
HideAnonymousEditingUIsIfUnnecessary
(
)
{
if
(
!
IsAbsolutePositionEditorEnabled
(
)
&
&
mAbsolutelyPositionedObject
)
{
HideGrabberInternal
(
)
;
NS_ASSERTION
(
!
mAbsolutelyPositionedObject
"
HideGrabber
failed
"
)
;
}
if
(
!
IsInlineTableEditorEnabled
(
)
&
&
mInlineEditedCell
)
{
HideInlineTableEditingUIInternal
(
)
;
NS_ASSERTION
(
!
mInlineEditedCell
"
HideInlineTableEditingUIInternal
failed
"
)
;
}
if
(
!
IsObjectResizerEnabled
(
)
&
&
mResizedObject
)
{
DebugOnly
<
nsresult
>
rv
=
HideResizersInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HideResizersInternal
(
)
failed
"
)
;
NS_ASSERTION
(
!
mResizedObject
"
HideResizersInternal
(
)
failed
"
)
;
}
}
NS_IMETHODIMP
HTMLEditor
:
:
CheckSelectionStateForAnonymousButtons
(
)
{
AutoEditActionDataSetter
editActionData
(
*
this
EditAction
:
:
eNotEditing
)
;
if
(
NS_WARN_IF
(
!
editActionData
.
CanHandle
(
)
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
=
RefreshEditingUI
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
EditorBase
:
:
ToGenericNSResult
(
rv
)
;
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
RefreshEditingUI
(
)
{
MOZ_ASSERT
(
IsEditActionDataAvailable
(
)
)
;
HideAnonymousEditingUIsIfUnnecessary
(
)
;
if
(
!
IsObjectResizerEnabled
(
)
&
&
!
IsAbsolutePositionEditorEnabled
(
)
&
&
!
IsInlineTableEditorEnabled
(
)
)
{
return
NS_OK
;
}
if
(
mIsMoving
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
focusElement
=
GetSelectionContainerElement
(
)
;
if
(
NS_WARN_IF
(
!
focusElement
)
)
{
return
NS_OK
;
}
if
(
!
focusElement
-
>
IsInUncomposedDoc
(
)
)
{
return
NS_OK
;
}
nsAtom
*
focusTagAtom
=
focusElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
RefPtr
<
Element
>
absPosElement
;
if
(
IsAbsolutePositionEditorEnabled
(
)
)
{
absPosElement
=
GetAbsolutelyPositionedSelectionContainer
(
)
;
}
RefPtr
<
Element
>
cellElement
;
if
(
IsObjectResizerEnabled
(
)
|
|
IsInlineTableEditorEnabled
(
)
)
{
cellElement
=
GetElementOrParentByTagNameAtSelection
(
*
nsGkAtoms
:
:
td
)
;
}
if
(
IsObjectResizerEnabled
(
)
&
&
cellElement
)
{
if
(
nsGkAtoms
:
:
img
!
=
focusTagAtom
)
{
focusElement
=
GetEnclosingTable
(
cellElement
)
;
focusTagAtom
=
nsGkAtoms
:
:
table
;
}
}
if
(
nsGkAtoms
:
:
img
!
=
focusTagAtom
&
&
nsGkAtoms
:
:
table
!
=
focusTagAtom
)
{
focusElement
=
absPosElement
;
}
if
(
IsAbsolutePositionEditorEnabled
(
)
&
&
mAbsolutelyPositionedObject
&
&
absPosElement
!
=
mAbsolutelyPositionedObject
)
{
HideGrabberInternal
(
)
;
NS_ASSERTION
(
!
mAbsolutelyPositionedObject
"
HideGrabber
failed
"
)
;
}
if
(
IsObjectResizerEnabled
(
)
&
&
mResizedObject
&
&
mResizedObject
!
=
focusElement
)
{
nsresult
rv
=
HideResizersInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ASSERTION
(
!
mResizedObject
"
HideResizersInternal
(
)
failed
"
)
;
}
if
(
IsInlineTableEditorEnabled
(
)
&
&
mInlineEditedCell
&
&
mInlineEditedCell
!
=
cellElement
)
{
HideInlineTableEditingUIInternal
(
)
;
NS_ASSERTION
(
!
mInlineEditedCell
"
HideInlineTableEditingUIInternal
failed
"
)
;
}
nsIContent
*
hostContent
=
GetActiveEditingHost
(
)
;
if
(
IsObjectResizerEnabled
(
)
&
&
focusElement
&
&
IsModifiableNode
(
*
focusElement
)
&
&
focusElement
!
=
hostContent
)
{
if
(
nsGkAtoms
:
:
img
=
=
focusTagAtom
)
{
mResizedObjectIsAnImage
=
true
;
}
if
(
mResizedObject
)
{
nsresult
rv
=
RefreshResizersInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowResizersInternal
(
*
focusElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
IsAbsolutePositionEditorEnabled
(
)
&
&
absPosElement
&
&
IsModifiableNode
(
*
absPosElement
)
&
&
absPosElement
!
=
hostContent
)
{
if
(
mAbsolutelyPositionedObject
)
{
nsresult
rv
=
RefreshGrabberInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowGrabberInternal
(
*
absPosElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
IsInlineTableEditorEnabled
(
)
&
&
cellElement
&
&
IsModifiableNode
(
*
cellElement
)
&
&
cellElement
!
=
hostContent
)
{
if
(
mInlineEditedCell
)
{
nsresult
rv
=
RefreshInlineTableEditingUIInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowInlineTableEditingUIInternal
(
*
cellElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetPositionAndDimensions
(
Element
&
aElement
int32_t
&
aX
int32_t
&
aY
int32_t
&
aW
int32_t
&
aH
int32_t
&
aBorderLeft
int32_t
&
aBorderTop
int32_t
&
aMarginLeft
int32_t
&
aMarginTop
)
{
bool
isPositioned
=
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_moz_abspos
)
;
if
(
!
isPositioned
)
{
nsAutoString
positionStr
;
CSSEditUtils
:
:
GetComputedProperty
(
aElement
*
nsGkAtoms
:
:
position
positionStr
)
;
isPositioned
=
positionStr
.
EqualsLiteral
(
"
absolute
"
)
;
}
if
(
isPositioned
)
{
mResizedObjectIsAbsolutelyPositioned
=
true
;
RefPtr
<
nsComputedDOMStyle
>
cssDecl
=
CSSEditUtils
:
:
GetComputedStyle
(
&
aElement
)
;
NS_ENSURE_STATE
(
cssDecl
)
;
aBorderLeft
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
border
-
left
-
width
"
)
)
;
aBorderTop
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
border
-
top
-
width
"
)
)
;
aMarginLeft
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
margin
-
left
"
)
)
;
aMarginTop
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
margin
-
top
"
)
)
;
aX
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
left
"
)
)
+
aMarginLeft
+
aBorderLeft
;
aY
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
top
"
)
)
+
aMarginTop
+
aBorderTop
;
aW
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
width
"
)
)
;
aH
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
height
"
)
)
;
}
else
{
mResizedObjectIsAbsolutelyPositioned
=
false
;
RefPtr
<
nsGenericHTMLElement
>
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
aElement
)
;
if
(
!
htmlElement
)
{
return
NS_ERROR_NULL_POINTER
;
}
GetElementOrigin
(
aElement
aX
aY
)
;
aW
=
htmlElement
-
>
OffsetWidth
(
)
;
aH
=
htmlElement
-
>
OffsetHeight
(
)
;
aBorderLeft
=
0
;
aBorderTop
=
0
;
aMarginLeft
=
0
;
aMarginTop
=
0
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetAnonymousElementPosition
(
int32_t
aX
int32_t
aY
Element
*
aElement
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
aElement
*
nsGkAtoms
:
:
left
aX
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
*
aElement
*
nsGkAtoms
:
:
top
aY
)
;
}
}
