#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMCSSPrimitiveValue
.
h
"
#
include
"
nsIDOMCSSStyleDeclaration
.
h
"
#
include
"
nsIDOMCSSValue
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMHTMLElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIHTMLAbsPosEditor
.
h
"
#
include
"
nsIHTMLInlineTableEditor
.
h
"
#
include
"
nsIHTMLObjectResizer
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsIDOMEventListener
;
class
nsISelection
;
namespace
mozilla
{
using
namespace
dom
;
static
int32_t
GetCSSFloatValue
(
nsIDOMCSSStyleDeclaration
*
aDecl
const
nsAString
&
aProperty
)
{
MOZ_ASSERT
(
aDecl
)
;
nsCOMPtr
<
nsIDOMCSSValue
>
value
;
nsresult
rv
=
aDecl
-
>
GetPropertyCSSValue
(
aProperty
getter_AddRefs
(
value
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
value
)
{
return
0
;
}
nsCOMPtr
<
nsIDOMCSSPrimitiveValue
>
val
=
do_QueryInterface
(
value
)
;
uint16_t
type
;
val
-
>
GetPrimitiveType
(
&
type
)
;
float
f
=
0
;
switch
(
type
)
{
case
nsIDOMCSSPrimitiveValue
:
:
CSS_PX
:
rv
=
val
-
>
GetFloatValue
(
nsIDOMCSSPrimitiveValue
:
:
CSS_PX
&
f
)
;
NS_ENSURE_SUCCESS
(
rv
0
)
;
break
;
case
nsIDOMCSSPrimitiveValue
:
:
CSS_IDENT
:
{
nsAutoString
str
;
val
-
>
GetStringValue
(
str
)
;
if
(
str
.
EqualsLiteral
(
"
thin
"
)
)
f
=
1
;
else
if
(
str
.
EqualsLiteral
(
"
medium
"
)
)
f
=
3
;
else
if
(
str
.
EqualsLiteral
(
"
thick
"
)
)
f
=
5
;
break
;
}
}
return
(
int32_t
)
f
;
}
class
ElementDeletionObserver
final
:
public
nsStubMutationObserver
{
public
:
ElementDeletionObserver
(
nsIContent
*
aNativeAnonNode
nsIContent
*
aObservedNode
)
:
mNativeAnonNode
(
aNativeAnonNode
)
mObservedNode
(
aObservedNode
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
protected
:
~
ElementDeletionObserver
(
)
{
}
nsIContent
*
mNativeAnonNode
;
nsIContent
*
mObservedNode
;
}
;
NS_IMPL_ISUPPORTS
(
ElementDeletionObserver
nsIMutationObserver
)
void
ElementDeletionObserver
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
if
(
aContent
=
=
mObservedNode
&
&
mNativeAnonNode
&
&
mNativeAnonNode
-
>
GetParentNode
(
)
=
=
aContent
)
{
if
(
mNativeAnonNode
-
>
OwnerDoc
(
)
!
=
mObservedNode
-
>
OwnerDoc
(
)
)
{
mObservedNode
-
>
RemoveMutationObserver
(
this
)
;
mObservedNode
=
nullptr
;
mNativeAnonNode
-
>
RemoveMutationObserver
(
this
)
;
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
mNativeAnonNode
=
nullptr
;
NS_RELEASE_THIS
(
)
;
return
;
}
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
mNativeAnonNode
-
>
BindToTree
(
mObservedNode
-
>
GetUncomposedDoc
(
)
mObservedNode
mObservedNode
true
)
;
}
}
void
ElementDeletionObserver
:
:
NodeWillBeDestroyed
(
const
nsINode
*
aNode
)
{
NS_ASSERTION
(
aNode
=
=
mNativeAnonNode
|
|
aNode
=
=
mObservedNode
"
Wrong
aNode
!
"
)
;
if
(
aNode
=
=
mNativeAnonNode
)
{
mObservedNode
-
>
RemoveMutationObserver
(
this
)
;
mObservedNode
=
nullptr
;
}
else
{
mNativeAnonNode
-
>
RemoveMutationObserver
(
this
)
;
mNativeAnonNode
-
>
UnbindFromTree
(
)
;
mNativeAnonNode
=
nullptr
;
}
NS_RELEASE_THIS
(
)
;
}
nsresult
HTMLEditor
:
:
CreateAnonymousElement
(
const
nsAString
&
aTag
nsIDOMNode
*
aParentNode
const
nsAString
&
aAnonClass
bool
aIsCreatedHidden
nsIDOMElement
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aParentNode
)
;
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
*
aReturn
=
nullptr
;
nsCOMPtr
<
nsIContent
>
parentContent
(
do_QueryInterface
(
aParentNode
)
)
;
NS_ENSURE_TRUE
(
parentContent
NS_OK
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsIPresShell
>
ps
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
ps
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIAtom
>
tagAtom
=
NS_Atomize
(
aTag
)
;
nsCOMPtr
<
Element
>
newContent
=
CreateHTMLContent
(
tagAtom
)
;
NS_ENSURE_STATE
(
newContent
)
;
nsCOMPtr
<
nsIDOMElement
>
newElement
=
do_QueryInterface
(
newContent
)
;
NS_ENSURE_TRUE
(
newElement
NS_ERROR_FAILURE
)
;
if
(
aIsCreatedHidden
)
{
nsresult
rv
=
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
class
"
)
NS_LITERAL_STRING
(
"
hidden
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aAnonClass
.
IsEmpty
(
)
)
{
nsresult
rv
=
newElement
-
>
SetAttribute
(
NS_LITERAL_STRING
(
"
_moz_anonclass
"
)
aAnonClass
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
{
nsAutoScriptBlocker
scriptBlocker
;
newContent
-
>
SetIsNativeAnonymousRoot
(
)
;
nsresult
rv
=
newContent
-
>
BindToTree
(
doc
parentContent
parentContent
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
newContent
-
>
UnbindFromTree
(
)
;
return
rv
;
}
}
ElementDeletionObserver
*
observer
=
new
ElementDeletionObserver
(
newContent
parentContent
)
;
NS_ADDREF
(
observer
)
;
parentContent
-
>
AddMutationObserver
(
observer
)
;
newContent
-
>
AddMutationObserver
(
observer
)
;
#
ifdef
DEBUG
newContent
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
ps
-
>
RecreateFramesFor
(
newContent
)
;
newElement
.
forget
(
aReturn
)
;
return
NS_OK
;
}
void
HTMLEditor
:
:
RemoveListenerAndDeleteRef
(
const
nsAString
&
aEvent
nsIDOMEventListener
*
aListener
bool
aUseCapture
Element
*
aElement
nsIContent
*
aParentContent
nsIPresShell
*
aShell
)
{
nsCOMPtr
<
nsIDOMEventTarget
>
evtTarget
(
do_QueryInterface
(
aElement
)
)
;
if
(
evtTarget
)
{
evtTarget
-
>
RemoveEventListener
(
aEvent
aListener
aUseCapture
)
;
}
DeleteRefToAnonymousNode
(
static_cast
<
nsIDOMElement
*
>
(
GetAsDOMNode
(
aElement
)
)
aParentContent
aShell
)
;
}
void
HTMLEditor
:
:
DeleteRefToAnonymousNode
(
nsIDOMElement
*
aElement
nsIContent
*
aParentContent
nsIPresShell
*
aShell
)
{
if
(
aElement
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aElement
)
;
if
(
content
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
content
-
>
IsInComposedDoc
(
)
&
&
aShell
&
&
aShell
-
>
GetPresContext
(
)
&
&
aShell
-
>
GetPresContext
(
)
-
>
GetPresShell
(
)
=
=
aShell
)
{
nsCOMPtr
<
nsIDocumentObserver
>
docObserver
=
do_QueryInterface
(
aShell
)
;
if
(
docObserver
)
{
nsCOMPtr
<
nsIDocument
>
document
=
GetDocument
(
)
;
if
(
document
)
docObserver
-
>
BeginUpdate
(
document
UPDATE_CONTENT_MODEL
)
;
docObserver
-
>
ContentRemoved
(
content
-
>
GetComposedDoc
(
)
aParentContent
content
-
1
content
-
>
GetPreviousSibling
(
)
)
;
if
(
document
)
docObserver
-
>
EndUpdate
(
document
UPDATE_CONTENT_MODEL
)
;
}
}
content
-
>
UnbindFromTree
(
)
;
}
}
}
NS_IMETHODIMP
HTMLEditor
:
:
CheckSelectionStateForAnonymousButtons
(
nsISelection
*
aSelection
)
{
NS_ENSURE_ARG_POINTER
(
aSelection
)
;
NS_ENSURE_TRUE
(
mIsObjectResizingEnabled
|
|
mIsAbsolutelyPositioningEnabled
|
|
mIsInlineTableEditingEnabled
NS_OK
)
;
if
(
mIsMoving
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMElement
>
focusElement
;
nsresult
rv
=
GetSelectionContainer
(
getter_AddRefs
(
focusElement
)
)
;
NS_ENSURE_TRUE
(
focusElement
NS_OK
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
dom
:
:
Element
>
focusElementNode
=
do_QueryInterface
(
focusElement
)
;
NS_ENSURE_STATE
(
focusElementNode
)
;
if
(
!
focusElementNode
-
>
IsInUncomposedDoc
(
)
)
{
return
NS_OK
;
}
nsAutoString
focusTagName
;
rv
=
focusElement
-
>
GetTagName
(
focusTagName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ToLowerCase
(
focusTagName
)
;
nsCOMPtr
<
nsIAtom
>
focusTagAtom
=
NS_Atomize
(
focusTagName
)
;
nsCOMPtr
<
nsIDOMElement
>
absPosElement
;
if
(
mIsAbsolutelyPositioningEnabled
)
{
rv
=
GetAbsolutelyPositionedSelectionContainer
(
getter_AddRefs
(
absPosElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDOMElement
>
cellElement
;
if
(
mIsObjectResizingEnabled
|
|
mIsInlineTableEditingEnabled
)
{
rv
=
GetElementOrParentByTagName
(
NS_LITERAL_STRING
(
"
td
"
)
nullptr
getter_AddRefs
(
cellElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mIsObjectResizingEnabled
&
&
cellElement
)
{
if
(
nsGkAtoms
:
:
img
!
=
focusTagAtom
)
{
nsCOMPtr
<
nsIDOMNode
>
tableNode
=
GetEnclosingTable
(
cellElement
)
;
focusElement
=
do_QueryInterface
(
tableNode
)
;
focusTagAtom
=
nsGkAtoms
:
:
table
;
}
}
if
(
nsGkAtoms
:
:
img
!
=
focusTagAtom
&
&
nsGkAtoms
:
:
table
!
=
focusTagAtom
)
{
focusElement
=
absPosElement
;
}
if
(
mIsAbsolutelyPositioningEnabled
&
&
mAbsolutelyPositionedObject
&
&
absPosElement
!
=
GetAsDOMNode
(
mAbsolutelyPositionedObject
)
)
{
rv
=
HideGrabber
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mAbsolutelyPositionedObject
"
HideGrabber
failed
"
)
;
}
if
(
mIsObjectResizingEnabled
&
&
mResizedObject
&
&
GetAsDOMNode
(
mResizedObject
)
!
=
focusElement
)
{
rv
=
HideResizers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mResizedObject
"
HideResizers
failed
"
)
;
}
if
(
mIsInlineTableEditingEnabled
&
&
mInlineEditedCell
&
&
mInlineEditedCell
!
=
cellElement
)
{
rv
=
HideInlineTableEditingUI
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mInlineEditedCell
"
HideInlineTableEditingUI
failed
"
)
;
}
nsIContent
*
hostContent
=
GetActiveEditingHost
(
)
;
nsCOMPtr
<
nsIDOMNode
>
hostNode
=
do_QueryInterface
(
hostContent
)
;
if
(
mIsObjectResizingEnabled
&
&
focusElement
&
&
IsModifiableNode
(
focusElement
)
&
&
focusElement
!
=
hostNode
)
{
if
(
nsGkAtoms
:
:
img
=
=
focusTagAtom
)
{
mResizedObjectIsAnImage
=
true
;
}
if
(
mResizedObject
)
{
nsresult
rv
=
RefreshResizers
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowResizers
(
focusElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
mIsAbsolutelyPositioningEnabled
&
&
absPosElement
&
&
IsModifiableNode
(
absPosElement
)
&
&
absPosElement
!
=
hostNode
)
{
if
(
mAbsolutelyPositionedObject
)
{
nsresult
rv
=
RefreshGrabber
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowGrabberOnElement
(
absPosElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
mIsInlineTableEditingEnabled
&
&
cellElement
&
&
IsModifiableNode
(
cellElement
)
&
&
cellElement
!
=
hostNode
)
{
if
(
mInlineEditedCell
)
{
nsresult
rv
=
RefreshInlineTableEditingUI
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsresult
rv
=
ShowInlineTableEditingUI
(
cellElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
HTMLEditor
:
:
GetPositionAndDimensions
(
nsIDOMElement
*
aElement
int32_t
&
aX
int32_t
&
aY
int32_t
&
aW
int32_t
&
aH
int32_t
&
aBorderLeft
int32_t
&
aBorderTop
int32_t
&
aMarginLeft
int32_t
&
aMarginTop
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
NS_ENSURE_ARG_POINTER
(
element
)
;
bool
isPositioned
=
false
;
nsresult
rv
=
aElement
-
>
HasAttribute
(
NS_LITERAL_STRING
(
"
_moz_abspos
"
)
&
isPositioned
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isPositioned
)
{
nsAutoString
positionStr
;
mCSSEditUtils
-
>
GetComputedProperty
(
*
element
*
nsGkAtoms
:
:
position
positionStr
)
;
isPositioned
=
positionStr
.
EqualsLiteral
(
"
absolute
"
)
;
}
if
(
isPositioned
)
{
mResizedObjectIsAbsolutelyPositioned
=
true
;
RefPtr
<
nsComputedDOMStyle
>
cssDecl
=
mCSSEditUtils
-
>
GetComputedStyle
(
element
)
;
NS_ENSURE_STATE
(
cssDecl
)
;
aBorderLeft
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
border
-
left
-
width
"
)
)
;
aBorderTop
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
border
-
top
-
width
"
)
)
;
aMarginLeft
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
margin
-
left
"
)
)
;
aMarginTop
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
margin
-
top
"
)
)
;
aX
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
left
"
)
)
+
aMarginLeft
+
aBorderLeft
;
aY
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
top
"
)
)
+
aMarginTop
+
aBorderTop
;
aW
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
width
"
)
)
;
aH
=
GetCSSFloatValue
(
cssDecl
NS_LITERAL_STRING
(
"
height
"
)
)
;
}
else
{
mResizedObjectIsAbsolutelyPositioned
=
false
;
nsCOMPtr
<
nsIDOMHTMLElement
>
htmlElement
=
do_QueryInterface
(
aElement
)
;
if
(
!
htmlElement
)
{
return
NS_ERROR_NULL_POINTER
;
}
GetElementOrigin
(
aElement
aX
aY
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
htmlElement
-
>
GetOffsetWidth
(
&
aW
)
)
)
|
|
NS_WARN_IF
(
NS_FAILED
(
htmlElement
-
>
GetOffsetHeight
(
&
aH
)
)
)
)
{
return
rv
;
}
aBorderLeft
=
0
;
aBorderTop
=
0
;
aMarginLeft
=
0
;
aMarginTop
=
0
;
}
return
NS_OK
;
}
void
HTMLEditor
:
:
SetAnonymousElementPosition
(
int32_t
aX
int32_t
aY
nsIDOMElement
*
aElement
)
{
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
aElement
NS_LITERAL_STRING
(
"
left
"
)
aX
)
;
mCSSEditUtils
-
>
SetCSSPropertyPixels
(
aElement
NS_LITERAL_STRING
(
"
top
"
)
aY
)
;
}
}
