#
include
"
WSRunObject
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
ChildBlockBoundary
=
HTMLEditUtils
:
:
ChildBlockBoundary
;
const
char16_t
kNBSP
=
160
;
template
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
const
EditorDOMPoint
&
aScanEndPoint
)
;
template
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
const
EditorRawDOMPoint
&
aScanEndPoint
)
;
template
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPointInText
&
aScanStartPoint
const
EditorDOMPointInText
&
aScanEndPoint
)
;
template
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
const
EditorDOMPoint
&
aScanEndPoint
)
;
template
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
const
EditorRawDOMPoint
&
aScanEndPoint
)
;
template
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aScanStartPoint
const
EditorDOMPointInText
&
aScanEndPoint
)
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
nsresult
WSRunObject
:
:
NormalizeWhiteSpacesAround
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
)
;
template
nsresult
WSRunObject
:
:
NormalizeWhiteSpacesAround
(
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
)
;
template
nsresult
WSRunObject
:
:
NormalizeWhiteSpacesAround
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aScanStartPoint
)
;
template
<
typename
PT
typename
CT
>
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
:
mScanStartPoint
(
aScanStartPoint
)
mScanEndPoint
(
aScanEndPoint
)
mEditingHost
(
aHTMLEditor
-
>
GetActiveEditingHost
(
)
)
mPRE
(
mScanStartPoint
.
IsInContentNode
(
)
&
&
EditorUtils
:
:
IsContentPreformatted
(
*
mScanStartPoint
.
ContainerAsContent
(
)
)
)
mHTMLEditor
(
aHTMLEditor
)
{
MOZ_ASSERT
(
*
nsContentUtils
:
:
ComparePoints
(
aScanStartPoint
.
ToRawRangeBoundary
(
)
aScanEndPoint
.
ToRawRangeBoundary
(
)
)
<
=
0
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
GetWSNodes
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
WSRunScanner
:
:
GetWSNodes
(
)
failed
but
ignored
"
)
;
}
template
<
typename
PT
typename
CT
>
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
:
WSRunScanner
(
&
aHTMLEditor
aScanStartPoint
aScanEndPoint
)
mHTMLEditor
(
aHTMLEditor
)
{
}
nsresult
WSRunObject
:
:
DeleteInvisibleASCIIWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
WSRunObject
wsRunObject
(
aHTMLEditor
aPoint
)
;
nsresult
rv
=
wsRunObject
.
DeleteInvisibleASCIIWhiteSpacesInternal
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteInvisibleASCIIWhiteSpacesInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToJoinBlocks
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
)
{
WSRunObject
leftWSObj
(
aHTMLEditor
EditorRawDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
EditorRawDOMPoint
(
&
aRightBlockElement
0
)
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRange
(
HTMLEditor
&
aHTMLEditor
EditorDOMPoint
*
aStartPoint
EditorDOMPoint
*
aEndPoint
)
{
MOZ_ASSERT
(
aStartPoint
)
;
MOZ_ASSERT
(
aEndPoint
)
;
if
(
NS_WARN_IF
(
!
aStartPoint
-
>
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
-
>
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoTrackDOMPoint
trackerStart
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aStartPoint
)
;
AutoTrackDOMPoint
trackerEnd
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aEndPoint
)
;
WSRunObject
leftWSObj
(
aHTMLEditor
*
aStartPoint
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
*
aEndPoint
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
*
aContent
)
{
if
(
NS_WARN_IF
(
!
aContent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
atContent
(
aContent
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
aContent
was
an
orphan
node
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
WSRunObject
leftWSObj
(
aHTMLEditor
atContent
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
atContent
.
NextPoint
(
)
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
HTMLEditor
&
aHTMLEditor
nsCOMPtr
<
nsINode
>
*
aSplitNode
int32_t
*
aSplitOffset
)
{
if
(
NS_WARN_IF
(
!
aSplitNode
)
|
|
NS_WARN_IF
(
!
*
aSplitNode
)
|
|
NS_WARN_IF
(
!
aSplitOffset
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aSplitNode
aSplitOffset
)
;
WSRunObject
wsObj
(
aHTMLEditor
MOZ_KnownLive
(
*
aSplitNode
)
*
aSplitOffset
)
;
nsresult
rv
=
wsObj
.
PrepareToSplitAcrossBlocksPriv
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToSplitAcrossBlocksPriv
(
)
failed
"
)
;
return
rv
;
}
already_AddRefed
<
Element
>
WSRunObject
:
:
InsertBreak
(
Selection
&
aSelection
const
EditorDOMPoint
&
aPointToInsert
nsIEditor
:
:
EDirection
aSelect
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
nullptr
;
}
TextFragmentData
textFragmentData
(
mStart
mEnd
mNBSPData
mPRE
)
;
const
EditorDOMRange
invisibleLeadingWhiteSpaceRangeOfNewLine
=
textFragmentData
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
const
EditorDOMRange
invisibleTrailingWhiteSpaceRangeOfCurrentLine
=
textFragmentData
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
const
Maybe
<
const
WSFragment
>
visibleWSFragmentInMiddleOfLine
=
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
|
|
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
?
textFragmentData
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWSFragmentInMiddleOfLine
.
isSome
(
)
?
visibleWSFragmentInMiddleOfLine
.
ref
(
)
.
ComparePoint
(
aPointToInsert
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
}
}
else
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNextCharOfInsertionPoint
=
GetInclusiveNextEditableCharPoint
(
pointToInsert
)
;
if
(
atNextCharOfInsertionPoint
.
IsSet
(
)
&
&
!
atNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
&
&
atNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
atPreviousCharOfNextCharOfInsertionPoint
=
GetPreviousEditableCharPoint
(
atNextCharOfInsertionPoint
)
;
if
(
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsSet
(
)
|
|
atPreviousCharOfNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atNextCharOfInsertionPoint
)
;
nsresult
rv
=
ReplaceASCIIWhiteSpacesWithOneNBSP
(
atNextCharOfInsertionPoint
endOfCollapsibleASCIIWhiteSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
)
failed
"
)
;
return
nullptr
;
}
}
}
}
if
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
nullptr
;
}
}
}
else
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
{
nsresult
rv
=
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
visibleWSFragmentInMiddleOfLine
.
ref
(
)
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
)
"
"
failed
"
)
;
return
nullptr
;
}
}
}
RefPtr
<
Element
>
newBRElement
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertBRElementWithTransaction
(
pointToInsert
aSelect
)
;
NS_WARNING_ASSERTION
(
newBRElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
newBRElement
.
forget
(
)
;
}
nsresult
WSRunObject
:
:
InsertText
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
mScanStartPoint
;
}
return
NS_OK
;
}
TextFragmentData
textFragmentDataAtStart
(
mStart
mEnd
mNBSPData
mPRE
)
;
const
bool
insertionPointEqualsOrIsBeforeStartOfText
=
mScanStartPoint
.
EqualsOrIsBefore
(
textFragmentDataAtStart
.
StartRef
(
)
)
;
WSRunObject
afterRunObject
(
MOZ_KnownLive
(
mHTMLEditor
)
mScanEndPoint
)
;
TextFragmentData
textFragmentDataAtEnd
(
afterRunObject
.
mStart
afterRunObject
.
mEnd
afterRunObject
.
mNBSPData
afterRunObject
.
mPRE
)
;
const
bool
insertionPointAfterEndOfText
=
textFragmentDataAtEnd
.
EndRef
(
)
.
EqualsOrIsBefore
(
mScanEndPoint
)
;
const
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
textFragmentDataAtStart
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
mScanStartPoint
)
;
const
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
textFragmentDataAtEnd
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
mScanEndPoint
)
;
const
Maybe
<
const
WSFragment
>
visibleWSFragmentInMiddleOfLineAtStart
=
!
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
?
textFragmentDataAtStart
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtStart
=
visibleWSFragmentInMiddleOfLineAtStart
.
isSome
(
)
?
visibleWSFragmentInMiddleOfLineAtStart
.
ref
(
)
.
ComparePoint
(
mScanStartPoint
)
:
PointPosition
:
:
NotInSameDOMTree
;
const
Maybe
<
const
WSFragment
>
visibleWSFragmentInMiddleOfLineAtEnd
=
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
?
textFragmentDataAtEnd
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtEnd
=
visibleWSFragmentInMiddleOfLineAtEnd
.
isSome
(
)
?
visibleWSFragmentInMiddleOfLineAtEnd
.
ref
(
)
.
ComparePoint
(
mScanEndPoint
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
pointToInsert
(
mScanStartPoint
)
;
nsAutoString
theString
(
aStringToInsert
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeAtEnd
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
MiddleOfFragment
)
{
nsresult
rv
=
MaybeReplaceInclusiveNextNBSPWithASCIIWhiteSpace
(
visibleWSFragmentInMiddleOfLineAtEnd
.
ref
(
)
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
MaybeReplaceInclusiveNextNBSPWithASCIIWhiteSpace
(
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeAtStart
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
{
nsresult
rv
=
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
visibleWSFragmentInMiddleOfLineAtStart
.
ref
(
)
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
0
]
)
)
{
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
{
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
pointToInsert
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
}
else
if
(
textFragmentDataAtStart
.
StartsFromHardLineBreak
(
)
&
&
insertionPointEqualsOrIsBeforeStartOfText
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
}
uint32_t
lastCharIndex
=
theString
.
Length
(
)
-
1
;
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
lastCharIndex
]
)
)
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
if
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNextChar
=
GetInclusiveNextEditableCharPoint
(
pointToInsert
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
}
else
if
(
textFragmentDataAtEnd
.
EndsByBlockBoundary
(
)
&
&
insertionPointAfterEndOfText
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
}
bool
prevWS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
=
lastCharIndex
;
i
+
+
)
{
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
i
]
)
)
{
if
(
prevWS
)
{
theString
.
SetCharAt
(
kNBSP
i
-
1
)
;
}
else
{
prevWS
=
true
;
}
}
else
{
prevWS
=
false
;
}
}
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextWithTransaction
(
aDocument
theString
pointToInsert
aPointAfterInsertedString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
pointToInsert
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSBackward
(
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
mScanStartPoint
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
mPRE
)
{
if
(
!
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
&
&
!
atPreviousCharOfStart
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
atPreviousCharOfStart
atPreviousCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPoint
startToDelete
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
)
;
EditorDOMPoint
endToDelete
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atPreviousCharOfStart
.
IsCharNBSP
(
)
)
{
EditorDOMPoint
startToDelete
(
atPreviousCharOfStart
)
;
EditorDOMPoint
endToDelete
(
startToDelete
.
NextPoint
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSForward
(
)
{
EditorDOMPointInText
atNextCharOfStart
=
GetInclusiveNextEditableCharPoint
(
mScanStartPoint
)
;
if
(
!
atNextCharOfStart
.
IsSet
(
)
|
|
atNextCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
mPRE
)
{
if
(
!
atNextCharOfStart
.
IsCharASCIISpace
(
)
&
&
!
atNextCharOfStart
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
atNextCharOfStart
atNextCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atNextCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPoint
startToDelete
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atNextCharOfStart
)
;
EditorDOMPoint
endToDelete
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atNextCharOfStart
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atNextCharOfStart
.
IsCharNBSP
(
)
)
{
EditorDOMPoint
startToDelete
(
atNextCharOfStart
)
;
EditorDOMPoint
endToDelete
(
startToDelete
.
NextPoint
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
Maybe
<
WSFragment
>
visibleWSFragmentInMiddleOfLine
=
TextFragmentData
(
mStart
mEnd
mNBSPData
mPRE
)
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
;
if
(
visibleWSFragmentInMiddleOfLine
.
isSome
(
)
&
&
visibleWSFragmentInMiddleOfLine
.
ref
(
)
.
RawStartPoint
(
)
.
IsBefore
(
aPoint
)
)
{
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsContainerEmpty
(
)
)
{
MOZ_ASSERT
(
!
atPreviousChar
.
IsEndOfContainer
(
)
)
;
return
WSScanResult
(
atPreviousChar
.
NextPoint
(
)
atPreviousChar
.
IsCharASCIISpaceOrNBSP
(
)
?
WSType
:
:
NormalWhiteSpaces
:
WSType
:
:
NormalText
)
;
}
}
if
(
mStart
.
GetReasonContent
(
)
!
=
mStart
.
PointRef
(
)
.
GetContainer
(
)
)
{
return
WSScanResult
(
mStart
.
GetReasonContent
(
)
mStart
.
RawReason
(
)
)
;
}
return
WSScanResult
(
mStart
.
PointRef
(
)
mStart
.
RawReason
(
)
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
Maybe
<
WSFragment
>
visibleWSFragmentInMiddleOfLine
=
TextFragmentData
(
mStart
mEnd
mNBSPData
mPRE
)
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
;
if
(
visibleWSFragmentInMiddleOfLine
.
isSome
(
)
&
&
aPoint
.
EqualsOrIsBefore
(
visibleWSFragmentInMiddleOfLine
.
ref
(
)
.
RawEndPoint
(
)
)
)
{
EditorDOMPointInText
atNextChar
=
GetInclusiveNextEditableCharPoint
(
aPoint
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsContainerEmpty
(
)
)
{
return
WSScanResult
(
atNextChar
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpaceOrNBSP
(
)
?
WSType
:
:
NormalWhiteSpaces
:
WSType
:
:
NormalText
)
;
}
}
if
(
mEnd
.
GetReasonContent
(
)
!
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
)
{
return
WSScanResult
(
mEnd
.
GetReasonContent
(
)
mEnd
.
RawReason
(
)
)
;
}
return
WSScanResult
(
mEnd
.
PointRef
(
)
mEnd
.
RawReason
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
nsresult
WSRunObject
:
:
NormalizeWhiteSpacesAround
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointType
&
aScanStartPoint
)
{
WSRunObject
wsRunObject
(
aHTMLEditor
aScanStartPoint
)
;
if
(
!
wsRunObject
.
mNBSPData
.
FoundNBSP
(
)
)
{
return
NS_OK
;
}
Maybe
<
WSFragment
>
visibleWSFragmentInMiddleOfLine
=
TextFragmentData
(
wsRunObject
.
mStart
wsRunObject
.
mEnd
wsRunObject
.
mNBSPData
wsRunObject
.
mPRE
)
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
;
if
(
visibleWSFragmentInMiddleOfLine
.
isNothing
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
wsRunObject
.
NormalizeWhiteSpacesAtEndOf
(
visibleWSFragmentInMiddleOfLine
.
ref
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
NormalizeWhiteSpacesAtEndOf
(
)
failed
"
)
;
return
rv
;
}
nsIContent
*
WSRunScanner
:
:
GetEditableBlockParentOrTopmotEditableInlineContent
(
nsIContent
*
aContent
)
const
{
if
(
NS_WARN_IF
(
!
aContent
)
)
{
return
nullptr
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
aContent
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
nullptr
;
for
(
nsIContent
*
content
:
aContent
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
!
EditorUtils
:
:
IsEditableContent
(
*
content
EditorType
:
:
HTML
)
)
{
break
;
}
editableBlockParentOrTopmotEditableInlineContent
=
content
;
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
editableBlockParentOrTopmotEditableInlineContent
)
)
{
break
;
}
}
return
editableBlockParentOrTopmotEditableInlineContent
;
}
nsresult
WSRunScanner
:
:
GetWSNodes
(
)
{
EditorDOMPoint
start
(
mScanStartPoint
)
end
(
mScanStartPoint
)
;
nsIContent
*
scanStartContent
=
mScanStartPoint
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
scanStartContent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
GetEditableBlockParentOrTopmotEditableInlineContent
(
scanStartContent
)
;
if
(
NS_WARN_IF
(
!
editableBlockParentOrTopmotEditableInlineContent
)
)
{
editableBlockParentOrTopmotEditableInlineContent
=
scanStartContent
;
}
InitializeRangeStart
(
mScanStartPoint
*
editableBlockParentOrTopmotEditableInlineContent
)
;
InitializeRangeEnd
(
mScanStartPoint
*
editableBlockParentOrTopmotEditableInlineContent
)
;
return
NS_OK
;
}
template
<
typename
EditorDOMPointType
>
bool
WSRunScanner
:
:
InitializeRangeStartWithTextNode
(
const
EditorDOMPointType
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
ContainerAsText
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
std
:
:
min
(
aPoint
.
Offset
(
)
textFragment
.
GetLength
(
)
)
;
i
;
i
-
-
)
{
char16_t
ch
=
textFragment
.
CharAt
(
i
-
1
)
;
if
(
nsCRT
:
:
IsAsciiSpace
(
ch
)
)
{
continue
;
}
if
(
ch
=
=
HTMLEditUtils
:
:
kNBSP
)
{
mNBSPData
.
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
ContainerAsText
(
)
i
-
1
)
NoBreakingSpaceData
:
:
Scanning
:
:
Backward
)
;
continue
;
}
mStart
=
BoundaryData
(
EditorDOMPoint
(
aPoint
.
ContainerAsText
(
)
i
)
*
aPoint
.
ContainerAsText
(
)
WSType
:
:
NormalText
)
;
return
true
;
}
return
false
;
}
template
<
typename
EditorDOMPointType
>
void
WSRunScanner
:
:
InitializeRangeStart
(
const
EditorDOMPointType
&
aPoint
const
nsIContent
&
aEditableBlockParentOrTopmostEditableInlineContent
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
)
{
if
(
InitializeRangeStartWithTextNode
(
aPoint
)
)
{
return
;
}
InitializeRangeStart
(
EditorDOMPoint
(
aPoint
.
ContainerAsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
return
;
}
nsIContent
*
previousLeafContentOrBlock
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineContent
mEditingHost
)
;
if
(
!
previousLeafContentOrBlock
)
{
mStart
=
BoundaryData
(
aPoint
const_cast
<
nsIContent
&
>
(
aEditableBlockParentOrTopmostEditableInlineContent
)
WSType
:
:
CurrentBlockBoundary
)
;
return
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousLeafContentOrBlock
)
)
{
mStart
=
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
return
;
}
if
(
!
previousLeafContentOrBlock
-
>
IsText
(
)
|
|
!
previousLeafContentOrBlock
-
>
IsEditable
(
)
)
{
mStart
=
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
previousLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
return
;
}
if
(
!
previousLeafContentOrBlock
-
>
AsText
(
)
-
>
TextFragment
(
)
.
GetLength
(
)
)
{
InitializeRangeStart
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
return
;
}
if
(
InitializeRangeStartWithTextNode
(
EditorDOMPointInText
:
:
AtEndOf
(
*
previousLeafContentOrBlock
-
>
AsText
(
)
)
)
)
{
return
;
}
InitializeRangeStart
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
}
template
<
typename
EditorDOMPointType
>
bool
WSRunScanner
:
:
InitializeRangeEndWithTextNode
(
const
EditorDOMPointType
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
ContainerAsText
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
aPoint
.
Offset
(
)
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
char16_t
ch
=
textFragment
.
CharAt
(
i
)
;
if
(
nsCRT
:
:
IsAsciiSpace
(
ch
)
)
{
continue
;
}
if
(
ch
=
=
HTMLEditUtils
:
:
kNBSP
)
{
mNBSPData
.
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
ContainerAsText
(
)
i
)
NoBreakingSpaceData
:
:
Scanning
:
:
Forward
)
;
continue
;
}
mEnd
=
BoundaryData
(
EditorDOMPoint
(
aPoint
.
ContainerAsText
(
)
i
)
*
aPoint
.
ContainerAsText
(
)
WSType
:
:
NormalText
)
;
return
true
;
}
return
false
;
}
template
<
typename
EditorDOMPointType
>
void
WSRunScanner
:
:
InitializeRangeEnd
(
const
EditorDOMPointType
&
aPoint
const
nsIContent
&
aEditableBlockParentOrTopmostEditableInlineContent
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
if
(
InitializeRangeEndWithTextNode
(
aPoint
)
)
{
return
;
}
InitializeRangeEnd
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aPoint
.
ContainerAsText
(
)
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
return
;
}
nsIContent
*
nextLeafContentOrBlock
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineContent
mEditingHost
)
;
if
(
!
nextLeafContentOrBlock
)
{
mEnd
=
BoundaryData
(
aPoint
const_cast
<
nsIContent
&
>
(
aEditableBlockParentOrTopmostEditableInlineContent
)
WSType
:
:
CurrentBlockBoundary
)
;
return
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextLeafContentOrBlock
)
)
{
mEnd
=
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
return
;
}
if
(
!
nextLeafContentOrBlock
-
>
IsText
(
)
|
|
!
nextLeafContentOrBlock
-
>
IsEditable
(
)
)
{
mEnd
=
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
nextLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
return
;
}
if
(
!
nextLeafContentOrBlock
-
>
AsText
(
)
-
>
TextFragment
(
)
.
GetLength
(
)
)
{
InitializeRangeEnd
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
return
;
}
if
(
InitializeRangeEndWithTextNode
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
)
)
{
return
;
}
InitializeRangeEnd
(
EditorDOMPointInText
:
:
AtEndOf
(
*
nextLeafContentOrBlock
-
>
AsText
(
)
)
aEditableBlockParentOrTopmostEditableInlineContent
)
;
}
void
WSRunScanner
:
:
EnsureWSFragments
(
)
{
if
(
!
mFragments
.
IsEmpty
(
)
)
{
return
;
}
TextFragmentData
textFragmentData
(
mStart
mEnd
mNBSPData
mPRE
)
;
textFragmentData
.
InitializeWSFragmentArray
(
mFragments
)
;
}
EditorDOMRange
WSRunScanner
:
:
TextFragmentData
:
:
GetInvisibleLeadingWhiteSpaceRange
(
)
const
{
if
(
mLeadingWhiteSpaceRange
.
isSome
(
)
)
{
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
mIsPreformatted
|
|
!
StartsFromHardLineBreak
(
)
)
{
mLeadingWhiteSpaceRange
.
emplace
(
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mNBSPData
.
FirstPointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
EditorDOMRange
WSRunScanner
:
:
TextFragmentData
:
:
GetInvisibleTrailingWhiteSpaceRange
(
)
const
{
if
(
mTrailingWhiteSpaceRange
.
isSome
(
)
)
{
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
mIsPreformatted
|
|
!
EndsByBlockBoundary
(
)
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
GetContainer
(
)
=
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
Offset
(
)
=
=
mEnd
.
PointRef
(
)
.
Offset
(
)
-
1
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
!
mNBSPData
.
LastPointRef
(
)
.
IsEndOfContainer
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mNBSPData
.
LastPointRef
(
)
.
NextPoint
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
Maybe
<
WSRunScanner
:
:
WSFragment
>
WSRunScanner
:
:
TextFragmentData
:
:
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
const
{
WSFragment
fragment
;
if
(
IsPreformattedOrSurrondedByVisibleContent
(
)
)
{
fragment
.
MarkAsVisible
(
)
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
fragment
.
mStartNode
=
mStart
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mStartOffset
=
mStart
.
PointRef
(
)
.
Offset
(
)
;
}
fragment
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
fragment
.
mEndNode
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
mEnd
.
PointRef
(
)
.
Offset
(
)
;
}
fragment
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
Some
(
fragment
)
;
}
const
EditorDOMRange
leadingWhiteSpaceRange
=
GetInvisibleLeadingWhiteSpaceRange
(
)
;
const
bool
maybeHaveLeadingWhiteSpaces
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveLeadingWhiteSpaces
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
return
Nothing
(
)
;
}
const
EditorDOMRange
trailingWhiteSpaceRange
=
GetInvisibleTrailingWhiteSpaceRange
(
)
;
const
bool
maybeHaveTrailingWhiteSpaces
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveTrailingWhiteSpaces
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
return
Nothing
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
)
{
fragment
.
MarkAsVisible
(
)
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
fragment
.
mStartNode
=
mStart
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mStartOffset
=
mStart
.
PointRef
(
)
.
Offset
(
)
;
}
fragment
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
fragment
.
mEndNode
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
mEnd
.
PointRef
(
)
.
Offset
(
)
;
fragment
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
Some
(
fragment
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
fragment
.
mEndNode
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
Offset
(
)
;
}
fragment
.
SetEndByTrailingWhiteSpaces
(
)
;
return
Some
(
fragment
)
;
}
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
)
;
MOZ_ASSERT
(
maybeHaveLeadingWhiteSpaces
)
;
fragment
.
MarkAsVisible
(
)
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
fragment
.
mStartNode
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
GetContainer
(
)
;
fragment
.
mStartOffset
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
Offset
(
)
;
}
fragment
.
SetStartFromLeadingWhiteSpaces
(
)
;
if
(
!
EndsByBlockBoundary
(
)
)
{
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
fragment
.
mEndNode
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
mEnd
.
PointRef
(
)
.
Offset
(
)
;
}
fragment
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
Some
(
fragment
)
;
}
MOZ_ASSERT
(
EndsByBlockBoundary
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
fragment
.
mEndNode
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
mEnd
.
PointRef
(
)
.
Offset
(
)
;
fragment
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
Some
(
fragment
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
fragment
.
mEndNode
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
GetContainer
(
)
;
fragment
.
mEndOffset
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
Offset
(
)
;
}
fragment
.
SetEndByTrailingWhiteSpaces
(
)
;
return
Some
(
fragment
)
;
}
void
WSRunScanner
:
:
TextFragmentData
:
:
InitializeWSFragmentArray
(
WSFragmentArray
&
aFragments
)
const
{
MOZ_ASSERT
(
aFragments
.
IsEmpty
(
)
)
;
if
(
IsPreformattedOrSurrondedByVisibleContent
(
)
)
{
aFragments
.
AppendElement
(
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
.
ref
(
)
)
;
return
;
}
const
EditorDOMRange
leadingWhiteSpaceRange
=
GetInvisibleLeadingWhiteSpaceRange
(
)
;
const
EditorDOMRange
trailingWhiteSpaceRange
=
GetInvisibleTrailingWhiteSpaceRange
(
)
;
const
bool
maybeHaveLeadingWhiteSpaces
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
const
bool
maybeHaveTrailingWhiteSpaces
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveLeadingWhiteSpaces
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
)
;
WSFragment
*
startRun
=
aFragments
.
AppendElement
(
)
;
startRun
-
>
MarkAsStartOfHardLine
(
)
;
if
(
EndsByBlockBoundary
(
)
)
{
MOZ_ASSERT
(
leadingWhiteSpaceRange
=
=
trailingWhiteSpaceRange
)
;
startRun
-
>
MarkAsEndOfHardLine
(
)
;
}
if
(
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mStartNode
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mStartOffset
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mEndNode
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mEndOffset
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
;
}
if
(
maybeHaveTrailingWhiteSpaces
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
MOZ_ASSERT
(
!
StartsFromHardLineBreak
(
)
)
;
MOZ_ASSERT
(
EndsByBlockBoundary
(
)
)
;
WSFragment
*
startRun
=
aFragments
.
AppendElement
(
)
;
startRun
-
>
MarkAsEndOfHardLine
(
)
;
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mStartNode
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mStartOffset
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mEndNode
=
trailingWhiteSpaceRange
.
EndRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mEndOffset
=
trailingWhiteSpaceRange
.
EndRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
;
}
if
(
!
StartsFromHardLineBreak
(
)
)
{
aFragments
.
AppendElement
(
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
.
ref
(
)
)
;
if
(
!
aFragments
[
0
]
.
EndsByTrailingWhiteSpaces
(
)
)
{
return
;
}
WSFragment
*
lastRun
=
aFragments
.
AppendElement
(
)
;
lastRun
-
>
MarkAsEndOfHardLine
(
)
;
lastRun
-
>
mStartNode
=
aFragments
[
0
]
.
mEndNode
;
lastRun
-
>
mStartOffset
=
aFragments
[
0
]
.
mEndOffset
;
lastRun
-
>
SetStartFromNormalWhiteSpaces
(
)
;
lastRun
-
>
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
return
;
}
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
)
;
MOZ_ASSERT
(
maybeHaveLeadingWhiteSpaces
)
;
WSFragment
*
startRun
=
aFragments
.
AppendElement
(
)
;
startRun
-
>
MarkAsStartOfHardLine
(
)
;
if
(
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mStartNode
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mStartOffset
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
startRun
-
>
mEndNode
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
GetContainer
(
)
;
startRun
-
>
mEndOffset
=
leadingWhiteSpaceRange
.
EndRef
(
)
.
Offset
(
)
;
}
startRun
-
>
SetEndByNormalWiteSpaces
(
)
;
aFragments
.
AppendElement
(
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
.
ref
(
)
)
;
if
(
!
aFragments
[
1
]
.
EndsByTrailingWhiteSpaces
(
)
)
{
return
;
}
WSFragment
*
lastRun
=
aFragments
.
AppendElement
(
)
;
lastRun
-
>
MarkAsEndOfHardLine
(
)
;
lastRun
-
>
mStartNode
=
aFragments
[
1
]
.
mEndNode
;
lastRun
-
>
mStartOffset
=
aFragments
[
1
]
.
mEndOffset
;
lastRun
-
>
SetStartFromNormalWhiteSpaces
(
)
;
if
(
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
lastRun
-
>
mEndNode
=
trailingWhiteSpaceRange
.
EndRef
(
)
.
GetContainer
(
)
;
lastRun
-
>
mEndOffset
=
trailingWhiteSpaceRange
.
EndRef
(
)
.
Offset
(
)
;
}
lastRun
-
>
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRangePriv
(
WSRunObject
*
aEndObject
)
{
if
(
NS_WARN_IF
(
!
aEndObject
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
WSFragment
*
beforeRun
=
FindNearestFragment
(
mScanStartPoint
false
)
;
const
WSFragment
*
afterRun
=
aEndObject
-
>
FindNearestFragment
(
aEndObject
-
>
mScanStartPoint
true
)
;
if
(
!
beforeRun
&
&
!
afterRun
)
{
return
NS_OK
;
}
if
(
afterRun
)
{
if
(
afterRun
-
>
IsStartOfHardLine
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
aEndObject
-
>
mScanStartPoint
afterRun
-
>
EndPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
afterRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
&
&
!
aEndObject
-
>
mPRE
)
{
if
(
(
beforeRun
&
&
beforeRun
-
>
IsStartOfHardLine
(
)
)
|
|
(
!
beforeRun
&
&
StartsFromHardLineBreak
(
)
)
)
{
EditorDOMPointInText
nextCharOfStartOfEnd
=
aEndObject
-
>
GetInclusiveNextEditableCharPoint
(
aEndObject
-
>
mScanStartPoint
)
;
if
(
nextCharOfStartOfEnd
.
IsSet
(
)
&
&
!
nextCharOfStartOfEnd
.
IsEndOfContainer
(
)
&
&
nextCharOfStartOfEnd
.
IsCharASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
if
(
nextCharOfStartOfEnd
.
IsStartOfContainer
(
)
|
|
nextCharOfStartOfEnd
.
IsPreviousCharASCIISpace
(
)
)
{
nextCharOfStartOfEnd
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
nextCharOfStartOfEnd
)
;
}
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
nextCharOfStartOfEnd
)
;
nsresult
rv
=
aEndObject
-
>
ReplaceASCIIWhiteSpacesWithOneNBSP
(
nextCharOfStartOfEnd
endOfCollapsibleASCIIWhiteSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
)
failed
"
)
;
return
rv
;
}
}
}
}
}
if
(
!
beforeRun
)
{
return
NS_OK
;
}
if
(
beforeRun
-
>
IsEndOfHardLine
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
beforeRun
-
>
StartPoint
(
)
mScanStartPoint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
beforeRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
&
&
!
mPRE
)
{
if
(
(
afterRun
&
&
(
afterRun
-
>
IsEndOfHardLine
(
)
|
|
afterRun
-
>
IsVisible
(
)
)
)
|
|
(
!
afterRun
&
&
aEndObject
-
>
EndsByBlockBoundary
(
)
)
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
mScanStartPoint
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
)
;
}
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
)
;
nsresult
rv
=
ReplaceASCIIWhiteSpacesWithOneNBSP
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
)
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocksPriv
(
)
{
Maybe
<
WSFragment
>
visibleWSFragmentInMiddleOfLine
=
TextFragmentData
(
mStart
mEnd
mNBSPData
mPRE
)
.
CreateWSFragmentForVisibleAndMiddleOfLine
(
)
;
if
(
visibleWSFragmentInMiddleOfLine
.
isNothing
(
)
)
{
return
NS_OK
;
}
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWSFragmentInMiddleOfLine
.
ref
(
)
.
ComparePoint
(
mScanStartPoint
)
;
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNextCharOfStart
=
GetInclusiveNextEditableCharPoint
(
mScanStartPoint
)
;
if
(
atNextCharOfStart
.
IsSet
(
)
&
&
!
atNextCharOfStart
.
IsEndOfContainer
(
)
&
&
atNextCharOfStart
.
IsCharASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
if
(
atNextCharOfStart
.
IsStartOfContainer
(
)
|
|
atNextCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atNextCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atNextCharOfStart
)
;
}
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atNextCharOfStart
)
;
nsresult
rv
=
ReplaceASCIIWhiteSpacesWithOneNBSP
(
atNextCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
)
failed
"
)
;
return
rv
;
}
}
}
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
mScanStartPoint
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
)
;
}
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
)
;
nsresult
rv
=
ReplaceASCIIWhiteSpacesWithOneNBSP
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
)
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
GetInclusiveNextEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
child
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
child
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetFirstLeafChild
(
*
child
ChildBlockBoundary
:
:
Ignore
)
:
child
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointInText
(
)
;
}
point
.
Set
(
leafContent
0
)
;
}
else
{
point
=
aPoint
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsEndOfContainer
(
)
)
{
return
EditorDOMPointInText
(
point
.
ContainerAsText
(
)
point
.
Offset
(
)
)
;
}
if
(
point
.
GetContainer
(
)
=
=
mEnd
.
GetReasonContent
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
GetEditableBlockParentOrTopmotEditableInlineContent
(
mScanStartPoint
.
ContainerAsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
editableBlockParentOrTopmotEditableInlineContent
)
)
{
editableBlockParentOrTopmotEditableInlineContent
=
mScanStartPoint
.
ContainerAsContent
(
)
;
}
for
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
point
.
ContainerAsContent
(
)
*
editableBlockParentOrTopmotEditableInlineContent
mEditingHost
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
nextContent
*
editableBlockParentOrTopmotEditableInlineContent
mEditingHost
)
)
{
if
(
!
nextContent
-
>
IsText
(
)
|
|
!
nextContent
-
>
IsEditable
(
)
)
{
if
(
nextContent
=
=
mEnd
.
GetReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointInText
(
nextContent
-
>
AsText
(
)
0
)
;
}
return
EditorDOMPointInText
(
)
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
GetPreviousEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
previousChild
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetPreviousSiblingOfChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
previousChild
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetLastLeafChild
(
*
previousChild
ChildBlockBoundary
:
:
Ignore
)
:
previousChild
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointInText
(
)
;
}
point
.
SetToEndOf
(
leafContent
)
;
}
else
{
point
=
aPoint
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsStartOfContainer
(
)
)
{
return
EditorDOMPointInText
(
point
.
ContainerAsText
(
)
point
.
Offset
(
)
-
1
)
;
}
if
(
point
.
GetContainer
(
)
=
=
mStart
.
GetReasonContent
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
GetEditableBlockParentOrTopmotEditableInlineContent
(
mScanStartPoint
.
ContainerAsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
editableBlockParentOrTopmotEditableInlineContent
)
)
{
editableBlockParentOrTopmotEditableInlineContent
=
mScanStartPoint
.
ContainerAsContent
(
)
;
}
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
point
.
ContainerAsContent
(
)
*
editableBlockParentOrTopmotEditableInlineContent
mEditingHost
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
*
editableBlockParentOrTopmotEditableInlineContent
mEditingHost
)
)
{
if
(
!
previousContent
-
>
IsText
(
)
|
|
!
previousContent
-
>
IsEditable
(
)
)
{
if
(
previousContent
=
=
mStart
.
GetReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointInText
(
previousContent
-
>
AsText
(
)
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
?
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
-
1
:
0
)
;
}
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
WSRunScanner
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
)
const
{
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsAtLastContent
(
)
)
{
Maybe
<
uint32_t
>
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextCharOffsetExceptASCIIWhiteSpaces
(
aPointAtASCIIWhiteSpace
)
;
if
(
nextVisibleCharOffset
.
isSome
(
)
)
{
return
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAsText
(
)
nextVisibleCharOffset
.
value
(
)
)
;
}
}
EditorDOMPointInText
afterLastWhiteSpace
=
EditorDOMPointInText
:
:
AtEndOf
(
*
aPointAtASCIIWhiteSpace
.
ContainerAsText
(
)
)
;
for
(
EditorDOMPointInText
atEndOfPreviousTextNode
=
afterLastWhiteSpace
;
;
)
{
EditorDOMPointInText
atStartOfNextTextNode
=
GetInclusiveNextEditableCharPoint
(
atEndOfPreviousTextNode
)
;
if
(
!
atStartOfNextTextNode
.
IsSet
(
)
)
{
return
afterLastWhiteSpace
;
}
if
(
atStartOfNextTextNode
.
IsContainerEmpty
(
)
)
{
atEndOfPreviousTextNode
=
atStartOfNextTextNode
;
continue
;
}
if
(
!
atStartOfNextTextNode
.
IsCharASCIISpace
(
)
)
{
return
afterLastWhiteSpace
;
}
Maybe
<
uint32_t
>
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextCharOffsetExceptASCIIWhiteSpaces
(
atStartOfNextTextNode
)
;
if
(
nextVisibleCharOffset
.
isSome
(
)
)
{
return
EditorDOMPointInText
(
atStartOfNextTextNode
.
ContainerAsText
(
)
nextVisibleCharOffset
.
value
(
)
)
;
}
afterLastWhiteSpace
=
atEndOfPreviousTextNode
=
EditorDOMPointInText
:
:
AtEndOf
(
*
atStartOfNextTextNode
.
ContainerAsText
(
)
)
;
}
}
EditorDOMPointInText
WSRunScanner
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
)
const
{
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsStartOfContainer
(
)
)
{
uint32_t
firstASCIIWhiteSpaceOffset
=
HTMLEditUtils
:
:
GetFirstASCIIWhiteSpaceOffsetCollapsedWith
(
aPointAtASCIIWhiteSpace
)
;
if
(
firstASCIIWhiteSpaceOffset
)
{
return
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAsText
(
)
firstASCIIWhiteSpaceOffset
)
;
}
}
EditorDOMPointInText
atLastWhiteSpace
=
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAsText
(
)
0
)
;
for
(
EditorDOMPointInText
atStartOfPreviousTextNode
=
atLastWhiteSpace
;
;
)
{
EditorDOMPointInText
atLastCharOfNextTextNode
=
GetPreviousEditableCharPoint
(
atStartOfPreviousTextNode
)
;
if
(
!
atLastCharOfNextTextNode
.
IsSet
(
)
)
{
return
atLastWhiteSpace
;
}
if
(
atLastCharOfNextTextNode
.
IsContainerEmpty
(
)
)
{
atStartOfPreviousTextNode
=
atLastCharOfNextTextNode
;
continue
;
}
if
(
!
atLastCharOfNextTextNode
.
IsCharASCIISpace
(
)
)
{
return
atLastWhiteSpace
;
}
uint32_t
firstASCIIWhiteSpaceOffset
=
HTMLEditUtils
:
:
GetFirstASCIIWhiteSpaceOffsetCollapsedWith
(
atLastCharOfNextTextNode
)
;
if
(
firstASCIIWhiteSpaceOffset
)
{
return
EditorDOMPointInText
(
atLastCharOfNextTextNode
.
ContainerAsText
(
)
firstASCIIWhiteSpaceOffset
)
;
}
atLastWhiteSpace
=
atStartOfPreviousTextNode
=
EditorDOMPointInText
(
atLastCharOfNextTextNode
.
ContainerAsText
(
)
0
)
;
}
}
nsresult
WSRunObject
:
:
ReplaceASCIIWhiteSpacesWithOneNBSP
(
const
EditorDOMPointInText
&
aAtFirstASCIIWhiteSpace
const
EditorDOMPointInText
&
aEndOfCollapsibleASCIIWhiteSpaces
)
{
MOZ_ASSERT
(
aAtFirstASCIIWhiteSpace
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
!
aAtFirstASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT
(
aAtFirstASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
MOZ_ASSERT
(
aEndOfCollapsibleASCIIWhiteSpaces
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndOfCollapsibleASCIIWhiteSpaces
.
IsEndOfContainer
(
)
|
|
!
aEndOfCollapsibleASCIIWhiteSpaces
.
IsCharASCIISpace
(
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
aAtFirstASCIIWhiteSpace
.
ContainerAsText
(
)
)
aAtFirstASCIIWhiteSpace
.
Offset
(
)
aAtFirstASCIIWhiteSpace
.
ContainerAsText
(
)
=
=
aEndOfCollapsibleASCIIWhiteSpaces
.
ContainerAsText
(
)
?
aEndOfCollapsibleASCIIWhiteSpaces
.
Offset
(
)
-
aAtFirstASCIIWhiteSpace
.
Offset
(
)
:
aAtFirstASCIIWhiteSpace
.
ContainerAsText
(
)
-
>
TextLength
(
)
-
aAtFirstASCIIWhiteSpace
.
Offset
(
)
nsDependentSubstring
(
&
kNBSP
1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aAtFirstASCIIWhiteSpace
.
GetContainer
(
)
=
=
aEndOfCollapsibleASCIIWhiteSpaces
.
GetContainer
(
)
)
{
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aAtFirstASCIIWhiteSpace
.
ContainerAsText
(
)
)
aEndOfCollapsibleASCIIWhiteSpaces
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
PT
typename
CT
>
WSRunScanner
:
:
WSFragmentArray
:
:
index_type
WSRunScanner
:
:
FindNearestFragmentIndex
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aForward
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
for
(
WSFragmentArray
:
:
index_type
i
=
0
;
i
<
WSFragmentArrayRef
(
)
.
Length
(
)
;
i
+
+
)
{
const
WSFragment
&
fragment
=
WSFragmentArrayRef
(
)
[
i
]
;
int32_t
comp
=
fragment
.
mStartNode
?
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
fragment
.
StartPoint
(
)
.
ToRawRangeBoundary
(
)
)
:
-
1
;
if
(
comp
<
=
0
)
{
return
aForward
?
i
:
WSFragmentArray
:
:
NoIndex
;
}
comp
=
fragment
.
mEndNode
?
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
fragment
.
EndPoint
(
)
.
ToRawRangeBoundary
(
)
)
:
-
1
;
if
(
comp
<
0
)
{
return
i
;
}
if
(
!
comp
)
{
return
aForward
?
(
i
+
1
<
WSFragmentArrayRef
(
)
.
Length
(
)
?
i
+
1
:
WSFragmentArray
:
:
NoIndex
)
:
i
;
}
if
(
i
=
=
WSFragmentArrayRef
(
)
.
Length
(
)
-
1
)
{
return
aForward
?
WSFragmentArray
:
:
NoIndex
:
i
;
}
}
return
WSFragmentArray
:
:
NoIndex
;
}
char16_t
WSRunScanner
:
:
GetCharAt
(
Text
*
aTextNode
int32_t
aOffset
)
const
{
if
(
NS_WARN_IF
(
!
aTextNode
)
|
|
NS_WARN_IF
(
aOffset
<
0
)
|
|
NS_WARN_IF
(
aOffset
>
=
static_cast
<
int32_t
>
(
aTextNode
-
>
TextDataLength
(
)
)
)
)
{
return
0
;
}
return
aTextNode
-
>
TextFragment
(
)
.
CharAt
(
aOffset
)
;
}
nsresult
WSRunObject
:
:
NormalizeWhiteSpacesAtEndOf
(
const
WSFragment
&
aRun
)
{
MOZ_ASSERT
(
aRun
.
IsVisibleAndMiddleOfHardLine
(
)
)
;
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
EditorDOMPoint
atEndOfRun
=
aRun
.
EndPoint
(
)
;
EditorDOMPointInText
atPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atEndOfRun
)
;
if
(
!
atPreviousCharOfEndOfRun
.
IsSet
(
)
|
|
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfRun
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
atPreviousCharOfPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfRun
)
;
bool
isPreviousCharASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfRun
.
IsCharASCIISpace
(
)
;
bool
maybeNBSPFollowingVisibleContent
=
(
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
!
isPreviousCharASCIIWhiteSpace
)
|
|
(
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
(
aRun
.
StartsFromNormalText
(
)
|
|
aRun
.
StartsFromSpecialContent
(
)
)
)
;
bool
followedByVisibleContentOrBRElement
=
false
;
if
(
maybeNBSPFollowingVisibleContent
|
|
isPreviousCharASCIIWhiteSpace
)
{
followedByVisibleContentOrBRElement
=
aRun
.
EndsByNormalText
(
)
|
|
aRun
.
EndsBySpecialContent
(
)
|
|
aRun
.
EndsByBRElement
(
)
;
if
(
aRun
.
EndsByBlockBoundary
(
)
&
&
mScanStartPoint
.
IsInContentNode
(
)
)
{
bool
insertBRElement
=
HTMLEditUtils
:
:
IsBlockElement
(
*
mScanStartPoint
.
ContainerAsContent
(
)
)
;
if
(
!
insertBRElement
)
{
nsIContent
*
blockParentOrTopmostEditableInlineContent
=
GetEditableBlockParentOrTopmotEditableInlineContent
(
mScanStartPoint
.
ContainerAsContent
(
)
)
;
insertBRElement
=
blockParentOrTopmostEditableInlineContent
&
&
HTMLEditUtils
:
:
IsBlockElement
(
*
blockParentOrTopmostEditableInlineContent
)
;
}
if
(
insertBRElement
)
{
RefPtr
<
Element
>
brElement
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertBRElementWithTransaction
(
atEndOfRun
)
;
if
(
NS_WARN_IF
(
mHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
atPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atEndOfRun
)
;
atPreviousCharOfPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfRun
)
;
isPreviousCharASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfRun
.
IsCharASCIISpace
(
)
;
followedByVisibleContentOrBRElement
=
true
;
}
}
if
(
maybeNBSPFollowingVisibleContent
&
&
followedByVisibleContentOrBRElement
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atPreviousCharOfEndOfRun
.
ContainerAsText
(
)
)
atPreviousCharOfEndOfRun
.
Offset
(
)
1
u
"
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
mPRE
|
|
maybeNBSPFollowingVisibleContent
|
|
!
isPreviousCharASCIIWhiteSpace
|
|
!
followedByVisibleContentOrBRElement
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
)
;
EditorDOMPointInText
atFirstASCIIWhiteSpace
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfPreviousCharOfEndOfRun
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
uint32_t
numberOfASCIIWhiteSpacesInStartNode
=
atFirstASCIIWhiteSpace
.
ContainerAsText
(
)
=
=
atPreviousCharOfEndOfRun
.
ContainerAsText
(
)
?
atPreviousCharOfEndOfRun
.
Offset
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
:
atFirstASCIIWhiteSpace
.
ContainerAsText
(
)
-
>
Length
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
;
uint32_t
replaceLengthInStartNode
=
numberOfASCIIWhiteSpacesInStartNode
+
(
atFirstASCIIWhiteSpace
.
ContainerAsText
(
)
=
=
atPreviousCharOfEndOfRun
.
ContainerAsText
(
)
?
1
:
0
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atFirstASCIIWhiteSpace
.
ContainerAsText
(
)
)
atFirstASCIIWhiteSpace
.
Offset
(
)
replaceLengthInStartNode
u
"
\
x00A0
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atFirstASCIIWhiteSpace
.
GetContainer
(
)
=
=
atPreviousCharOfEndOfRun
.
GetContainer
(
)
)
{
return
NS_OK
;
}
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
atFirstASCIIWhiteSpace
.
ContainerAsText
(
)
)
atPreviousCharOfEndOfRun
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
EditorDOMPoint
atEndOfRun
=
aRun
.
EndPoint
(
)
;
EditorDOMPointInText
atPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atEndOfRun
)
;
if
(
!
atPreviousCharOfEndOfRun
.
IsSet
(
)
|
|
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfRun
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
startToDelete
endToDelete
;
EditorDOMPointInText
atPreviousCharOfPreviousCharOfEndOfRun
=
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfRun
)
;
if
(
atPreviousCharOfEndOfRun
.
IsCharNBSP
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfRun
.
IsCharASCIISpace
(
)
)
{
startToDelete
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfPreviousCharOfEndOfRun
)
;
endToDelete
=
atPreviousCharOfPreviousCharOfEndOfRun
;
}
else
{
startToDelete
=
endToDelete
=
atPreviousCharOfEndOfRun
.
NextPoint
(
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
MaybeReplacePreviousNBSPWithASCIIWhiteSpace
(
const
WSFragment
&
aRun
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
aPoint
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
|
|
atPreviousChar
.
IsEndOfContainer
(
)
|
|
!
atPreviousChar
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
atPreviousCharOfPreviousChar
=
GetPreviousEditableCharPoint
(
atPreviousChar
)
;
if
(
atPreviousCharOfPreviousChar
.
IsSet
(
)
)
{
if
(
!
atPreviousCharOfPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousChar
.
IsCharASCIISpace
(
)
)
{
return
NS_OK
;
}
}
else
if
(
!
aRun
.
StartsFromNormalText
(
)
&
&
!
aRun
.
StartsFromSpecialContent
(
)
)
{
return
NS_OK
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atPreviousChar
.
ContainerAsText
(
)
)
atPreviousChar
.
Offset
(
)
1
u
"
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
MaybeReplaceInclusiveNextNBSPWithASCIIWhiteSpace
(
const
WSFragment
&
aRun
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
EditorDOMPointInText
atNextChar
=
GetInclusiveNextEditableCharPoint
(
aPoint
)
;
if
(
!
atNextChar
.
IsSet
(
)
|
|
NS_WARN_IF
(
atNextChar
.
IsEndOfContainer
(
)
)
|
|
!
atNextChar
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
atNextCharOfNextCharOfNBSP
=
GetInclusiveNextEditableCharPoint
(
atNextChar
.
NextPoint
(
)
)
;
if
(
atNextCharOfNextCharOfNBSP
.
IsSet
(
)
)
{
if
(
!
atNextCharOfNextCharOfNBSP
.
IsEndOfContainer
(
)
&
&
atNextCharOfNextCharOfNBSP
.
IsCharASCIISpace
(
)
)
{
return
NS_OK
;
}
}
else
if
(
!
aRun
.
EndsByNormalText
(
)
&
&
!
aRun
.
EndsBySpecialContent
(
)
&
&
!
aRun
.
EndsByBRElement
(
)
)
{
return
NS_OK
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNextChar
.
ContainerAsText
(
)
)
atNextChar
.
Offset
(
)
1
u
"
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
DeleteInvisibleASCIIWhiteSpacesInternal
(
)
{
TextFragmentData
textFragment
(
mStart
mEnd
mNBSPData
mPRE
)
;
EditorDOMRange
leadingWhiteSpaceRange
=
textFragment
.
GetInvisibleLeadingWhiteSpaceRange
(
)
;
EditorDOMRange
trailingWhiteSpaceRange
=
textFragment
.
GetInvisibleTrailingWhiteSpaceRange
(
)
;
DebugOnly
<
bool
>
leadingWhiteSpacesDeleted
=
false
;
if
(
leadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
leadingWhiteSpaceRange
.
Collapsed
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
leadingWhiteSpaceRange
.
StartRef
(
)
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
to
"
"
delete
leading
white
-
spaces
"
)
;
return
rv
;
}
leadingWhiteSpacesDeleted
=
true
;
}
if
(
trailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
trailingWhiteSpaceRange
.
Collapsed
(
)
&
&
leadingWhiteSpaceRange
!
=
trailingWhiteSpaceRange
)
{
NS_ASSERTION
(
!
leadingWhiteSpacesDeleted
"
We
'
re
trying
to
remove
trailing
white
-
spaces
with
maybe
"
"
outdated
range
"
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextAndTextNodesWithTransaction
(
trailingWhiteSpaceRange
.
StartRef
(
)
trailingWhiteSpaceRange
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
to
"
"
delete
trailing
white
-
spaces
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
}
