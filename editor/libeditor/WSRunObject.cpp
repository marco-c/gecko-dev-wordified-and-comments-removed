#
include
"
WSRunObject
.
h
"
#
include
"
EditorDOMPoint
.
h
"
#
include
"
EditorUtils
.
h
"
#
include
"
HTMLEditor
.
h
"
#
include
"
HTMLEditUtils
.
h
"
#
include
"
SelectionState
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
LeafNodeType
=
HTMLEditUtils
:
:
LeafNodeType
;
using
LeafNodeTypes
=
HTMLEditUtils
:
:
LeafNodeTypes
;
using
WalkTreeOption
=
HTMLEditUtils
:
:
WalkTreeOption
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
EditorDOMPoint
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorRawDOMPoint
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorDOMPoint
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
EditorRawDOMPoint
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
;
template
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
)
;
template
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
)
;
template
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointInText
&
aScanStartPoint
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPoint
&
aPoint
const
Element
*
aEditingHost
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorRawDOMPoint
&
aPoint
const
Element
*
aEditingHost
)
;
template
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointInText
&
aPoint
const
Element
*
aEditingHost
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPoint
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorDOMPointInText
&
aPoint
)
;
NS_INSTANTIATE_CONST_METHOD_RETURNING_ANY_EDITOR_DOM_POINT
(
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
const
EditorRawDOMPointInText
&
aPoint
)
;
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
PrepareToSplitBlockElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
const
Element
&
aSplittingBlockElement
)
{
if
(
NS_WARN_IF
(
!
aPointToSplit
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
aPointToSplit
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
for
(
nsIContent
*
content
:
aPointToSplit
.
ContainerAs
<
nsIContent
>
(
)
-
>
InclusiveAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
content
=
=
&
aSplittingBlockElement
)
{
break
;
}
if
(
HTMLEditUtils
:
:
IsSplittableNode
(
*
content
)
)
{
break
;
}
pointToSplit
.
Set
(
content
)
;
}
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
aHTMLEditor
pointToSplit
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
if
(
NS_WARN_IF
(
!
pointToSplit
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
-
>
IsInclusiveDescendantOf
(
&
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
aSplittingBlockElement
)
)
|
|
NS_WARN_IF
(
!
HTMLEditUtils
:
:
IsSplittableNode
(
*
pointToSplit
.
ContainerAs
<
nsIContent
>
(
)
)
)
)
{
return
Err
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
return
pointToSplit
;
}
EditActionResult
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoDescendantLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aAtRightBlockChild
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
)
)
;
MOZ_ASSERT
(
&
aRightBlockElement
=
=
aAtRightBlockChild
.
GetContainer
(
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
at
left
block
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
)
{
EditorDOMPoint
leftBlockContainingPointInRightBlockElement
;
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
&
leftBlockContainingPointInRightBlockElement
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
moving
the
left
block
element
outside
the
right
block
element
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
leftBlockContainingPointInRightBlockElement
!
=
aAtRightBlockChild
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
changing
the
left
block
element
in
the
right
block
element
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
aRightBlockElement
EditorType
:
:
HTML
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
making
the
right
block
element
non
-
editable
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
aLeftBlockElement
EditorType
:
:
HTML
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
end
of
left
block
element
caused
"
"
making
the
left
block
element
non
-
editable
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
OwningNonNull
<
Element
>
rightBlockElement
=
aRightBlockElement
;
EditorDOMPoint
afterRightBlockChild
=
aAtRightBlockChild
.
NextPoint
(
)
;
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
afterRightBlockChild
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
afterRightBlockChild
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
at
right
block
child
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
afterRightBlockChild
.
GetContainerAs
<
Element
>
(
)
)
{
rightBlockElement
=
*
afterRightBlockChild
.
ContainerAs
<
Element
>
(
)
;
}
else
if
(
NS_WARN_IF
(
!
afterRightBlockChild
.
GetContainerParentAs
<
Element
>
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
}
else
{
rightBlockElement
=
*
afterRightBlockChild
.
GetContainerParentAs
<
Element
>
(
)
;
}
}
RefPtr
<
HTMLBRElement
>
invisibleBRElementAtEndOfLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementAtEndOfLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
NS_WARN_IF
(
aListElementTagName
.
isSome
(
)
)
)
{
ret
.
MarkAsHandled
(
)
;
}
else
{
NS_ASSERTION
(
rightBlockElement
=
=
afterRightBlockChild
.
GetContainer
(
)
"
The
relation
is
not
guaranteed
but
assumed
"
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
aHTMLEditor
.
CanMoveOrDeleteSomethingInHardLine
(
EditorDOMPoint
(
rightBlockElement
afterRightBlockChild
.
Offset
(
)
)
aEditingHost
)
;
#
endif
MoveNodeResult
moveNodeResult
=
aHTMLEditor
.
MoveOneHardLineContentsWithTransaction
(
EditorDOMPoint
(
rightBlockElement
afterRightBlockChild
.
Offset
(
)
)
EditorDOMPoint
(
&
aLeftBlockElement
0u
)
aEditingHost
HTMLEditor
:
:
MoveToEndOfContainer
:
:
Yes
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveOneHardLineContentsWithTransaction
(
"
"
MoveToEndOfContainer
:
:
Yes
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveNodeResult
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveNodeResult
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
ret
|
=
moveNodeResult
;
afterRightBlockChild
.
Clear
(
)
;
}
if
(
!
invisibleBRElementAtEndOfLeftBlockElement
)
{
return
ret
;
}
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementAtEndOfLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoAncestorLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aAtLeftBlockChild
nsIContent
&
aLeftContentInBlock
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
)
)
;
MOZ_ASSERT
(
&
aLeftBlockElement
=
=
&
aLeftContentInBlock
|
|
EditorUtils
:
:
IsDescendantOf
(
aLeftContentInBlock
aLeftBlockElement
)
)
;
MOZ_ASSERT
(
&
aLeftBlockElement
=
=
aAtLeftBlockChild
.
GetContainer
(
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
(
&
aRightBlockElement
0
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
failed
"
"
at
right
block
"
)
;
return
EditActionResult
(
rv
)
;
}
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
)
{
EditorDOMPoint
rightBlockContainingPointInLeftBlockElement
;
if
(
aHTMLEditor
.
MayHaveMutationEventListeners
(
)
&
&
!
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
&
rightBlockContainingPointInLeftBlockElement
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
moving
the
right
block
element
outside
the
left
block
"
"
element
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
rightBlockContainingPointInLeftBlockElement
!
=
aAtLeftBlockChild
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
changing
the
right
block
element
position
in
the
left
block
"
"
element
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
aLeftBlockElement
EditorType
:
:
HTML
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
making
the
left
block
element
non
-
editable
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
!
EditorUtils
:
:
IsEditableContent
(
aRightBlockElement
EditorType
:
:
HTML
)
)
{
NS_WARNING
(
"
Deleting
invisible
whitespace
at
start
of
right
block
element
"
"
caused
making
the
right
block
element
non
-
editable
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
}
OwningNonNull
<
Element
>
originalLeftBlockElement
=
aLeftBlockElement
;
OwningNonNull
<
Element
>
leftBlockElement
=
aLeftBlockElement
;
EditorDOMPoint
atLeftBlockChild
(
aAtLeftBlockChild
)
;
{
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atLeftBlockChild
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
aHTMLEditor
EditorDOMPoint
(
atLeftBlockChild
.
GetContainer
(
)
atLeftBlockChild
.
Offset
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
"
"
failed
at
left
block
child
"
)
;
return
EditActionResult
(
rv
)
;
}
}
if
(
!
atLeftBlockChild
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
)
caused
"
"
unexpected
DOM
tree
"
)
;
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
Element
*
nearestAncestor
=
atLeftBlockChild
.
GetContainerOrContainerParentElement
(
)
)
{
leftBlockElement
=
*
nearestAncestor
;
}
else
{
return
EditActionResult
(
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
HTMLBRElement
>
invisibleBRElementBeforeLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
atLeftBlockChild
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementBeforeLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
aListElementTagName
.
isSome
(
)
)
{
MOZ_ASSERT
(
originalLeftBlockElement
=
=
atLeftBlockChild
.
GetContainer
(
)
"
This
is
not
guaranteed
but
assumed
"
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
rightBlockHasContent
=
aHTMLEditor
.
CanMoveChildren
(
aRightBlockElement
aLeftBlockElement
)
;
#
endif
MoveNodeResult
moveNodeResult
=
aHTMLEditor
.
MoveChildrenWithTransaction
(
aRightBlockElement
EditorDOMPoint
(
atLeftBlockChild
.
GetContainer
(
)
atLeftBlockChild
.
Offset
(
)
)
)
;
if
(
NS_WARN_IF
(
moveNodeResult
.
EditorDestroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
moveNodeResult
.
isOk
(
)
"
HTMLEditor
:
:
MoveChildrenWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
moveNodeResult
.
isOk
(
)
)
{
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
ret
|
=
moveNodeResult
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
rightBlockHasContent
.
isErr
(
)
)
;
if
(
rightBlockHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveNodeResult
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
children
"
)
;
}
else
{
NS_ASSERTION
(
moveNodeResult
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
children
"
)
;
}
#
endif
}
atLeftBlockChild
.
Clear
(
)
;
}
else
{
EditorDOMPoint
atPreviousContent
;
if
(
&
aLeftContentInBlock
=
=
leftBlockElement
)
{
atPreviousContent
=
atLeftBlockChild
;
}
else
{
atPreviousContent
.
Set
(
&
aLeftContentInBlock
)
;
atPreviousContent
.
AdvanceOffset
(
)
;
}
MOZ_ASSERT
(
atPreviousContent
.
IsSetAndValid
(
)
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
aHTMLEditor
.
CanMoveOrDeleteSomethingInHardLine
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
#
endif
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
HTMLEditor
:
:
LimitInBodyElement
:
:
No
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
editingHost
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
)
;
}
if
(
&
aLeftContentInBlock
!
=
editingHost
)
{
SplitNodeResult
splitResult
=
aHTMLEditor
.
SplitAncestorStyledInlineElementsAt
(
atPreviousContent
nullptr
nullptr
)
;
if
(
splitResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
SplitAncestorStyledInlineElementsAt
(
)
failed
"
)
;
return
EditActionResult
(
splitResult
.
unwrapErr
(
)
)
;
}
splitResult
.
IgnoreCaretPointSuggestion
(
)
;
if
(
splitResult
.
Handled
(
)
)
{
if
(
nsIContent
*
nextContentAtSplitPoint
=
splitResult
.
GetNextContent
(
)
)
{
atPreviousContent
.
Set
(
nextContentAtSplitPoint
)
;
if
(
!
atPreviousContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
Next
node
of
split
point
was
orphaned
"
)
;
return
EditActionResult
(
NS_ERROR_NULL_POINTER
)
;
}
}
else
{
atPreviousContent
=
splitResult
.
AtSplitPoint
<
EditorDOMPoint
>
(
)
;
if
(
!
atPreviousContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
Split
node
was
orphaned
"
)
;
return
EditActionResult
(
NS_ERROR_NULL_POINTER
)
;
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
atPreviousContent
.
IsSetAndValid
(
)
)
;
}
MoveNodeResult
moveNodeResult
=
aHTMLEditor
.
MoveOneHardLineContentsWithTransaction
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
atPreviousContent
aEditingHost
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveOneHardLineContentsWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveNodeResult
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveNodeResult
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
ret
|
=
moveNodeResult
;
}
if
(
!
invisibleBRElementBeforeLeftBlockElement
)
{
return
ret
;
}
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementBeforeLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
but
ignored
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
EditActionResult
WhiteSpaceVisibilityKeeper
:
:
MergeFirstLineOfRightBlockElementIntoLeftBlockElement
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
const
Maybe
<
nsAtom
*
>
&
aListElementTagName
const
HTMLBRElement
*
aPrecedingInvisibleBRElement
const
Element
&
aEditingHost
)
{
MOZ_ASSERT
(
!
EditorUtils
:
:
IsDescendantOf
(
aLeftBlockElement
aRightBlockElement
)
)
;
MOZ_ASSERT
(
!
EditorUtils
:
:
IsDescendantOf
(
aRightBlockElement
aLeftBlockElement
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
aHTMLEditor
EditorDOMRange
(
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
EditorDOMPoint
(
&
aRightBlockElement
0
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
RefPtr
<
HTMLBRElement
>
invisibleBRElementAtEndOfLeftBlockElement
=
WSRunScanner
:
:
GetPrecedingBRElementUnlessVisibleContentFound
(
aHTMLEditor
.
ComputeEditingHost
(
)
EditorDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
NS_ASSERTION
(
aPrecedingInvisibleBRElement
=
=
invisibleBRElementAtEndOfLeftBlockElement
"
The
preceding
invisible
BR
element
computation
was
different
"
)
;
EditActionResult
ret
(
NS_OK
)
;
if
(
aListElementTagName
.
isSome
(
)
|
|
aLeftBlockElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
aRightBlockElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
EditorDOMPoint
atFirstChildOfRightNode
;
nsresult
rv
=
aHTMLEditor
.
JoinNearestEditableNodesWithTransaction
(
aLeftBlockElement
aRightBlockElement
&
atFirstChildOfRightNode
)
;
if
(
NS_WARN_IF
(
rv
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
"
"
failed
but
ignored
"
)
;
if
(
aListElementTagName
.
isSome
(
)
&
&
atFirstChildOfRightNode
.
IsSet
(
)
)
{
CreateElementResult
convertListTypeResult
=
aHTMLEditor
.
ChangeListElementType
(
aRightBlockElement
MOZ_KnownLive
(
*
aListElementTagName
.
ref
(
)
)
*
nsGkAtoms
:
:
li
)
;
if
(
NS_WARN_IF
(
convertListTypeResult
.
EditorDestroyed
(
)
)
)
{
return
EditActionResult
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
convertListTypeResult
.
IgnoreCaretPointSuggestion
(
)
;
NS_WARNING_ASSERTION
(
convertListTypeResult
.
isOk
(
)
"
HTMLEditor
:
:
ChangeListElementType
(
)
failed
but
ignored
"
)
;
}
ret
.
MarkAsHandled
(
)
;
}
else
{
#
ifdef
DEBUG
Result
<
bool
nsresult
>
firstLineHasContent
=
aHTMLEditor
.
CanMoveOrDeleteSomethingInHardLine
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
aEditingHost
)
;
#
endif
MoveNodeResult
moveNodeResult
=
aHTMLEditor
.
MoveOneHardLineContentsWithTransaction
(
EditorDOMPoint
(
&
aRightBlockElement
0u
)
EditorDOMPoint
(
&
aLeftBlockElement
0u
)
aEditingHost
HTMLEditor
:
:
MoveToEndOfContainer
:
:
Yes
)
;
if
(
moveNodeResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
MoveOneHardLineContentsWithTransaction
(
"
"
MoveToEndOfContainer
:
:
Yes
)
failed
"
)
;
return
EditActionResult
(
moveNodeResult
.
unwrapErr
(
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
firstLineHasContent
.
isErr
(
)
)
;
if
(
firstLineHasContent
.
inspect
(
)
)
{
NS_ASSERTION
(
moveNodeResult
.
Handled
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
else
{
NS_ASSERTION
(
moveNodeResult
.
Ignored
(
)
"
Failed
to
consider
whether
moving
or
not
something
"
)
;
}
#
endif
moveNodeResult
.
IgnoreCaretPointSuggestion
(
)
;
ret
|
=
moveNodeResult
;
}
if
(
!
invisibleBRElementAtEndOfLeftBlockElement
)
{
return
ret
.
MarkAsHandled
(
)
;
}
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
*
invisibleBRElementAtEndOfLeftBlockElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
EditActionResult
(
rv
)
;
}
return
EditActionHandled
(
)
;
}
CreateElementResult
WhiteSpaceVisibilityKeeper
:
:
InsertBRElement
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToInsert
const
Element
&
aEditingHost
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
)
{
return
CreateElementResult
(
NS_ERROR_INVALID_ARG
)
;
}
TextFragmentData
textFragmentDataAtInsertionPoint
(
aPointToInsert
&
aEditingHost
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textFragmentDataAtInsertionPoint
.
IsInitialized
(
)
)
)
)
{
return
CreateElementResult
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRange
invisibleLeadingWhiteSpaceRangeOfNewLine
=
textFragmentDataAtInsertionPoint
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
EditorDOMRange
invisibleTrailingWhiteSpaceRangeOfCurrentLine
=
textFragmentDataAtInsertionPoint
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
aPointToInsert
)
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpaces
=
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
|
|
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
?
Some
(
textFragmentDataAtInsertionPoint
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWhiteSpaces
.
isSome
(
)
&
&
visibleWhiteSpaces
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpaces
.
ref
(
)
.
ComparePoint
(
aPointToInsert
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
EditorDOMPoint
atNBSPReplacableWithSP
;
if
(
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
&
&
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
)
{
atNBSPReplacableWithSP
=
textFragmentDataAtInsertionPoint
.
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
pointToInsert
)
.
To
<
EditorDOMPoint
>
(
)
;
}
{
if
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
=
=
pointToInsert
)
;
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackEndOfLineNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplacableWithSP
)
;
AutoTrackDOMRange
trackLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeOfNewLine
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
else
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
auto
atNextCharOfInsertionPoint
=
textFragmentDataAtInsertionPoint
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
pointToInsert
)
;
if
(
atNextCharOfInsertionPoint
.
IsSet
(
)
&
&
!
atNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
&
&
atNextCharOfInsertionPoint
.
IsCharCollapsibleASCIISpace
(
)
)
{
const
EditorDOMPointInText
atPreviousCharOfNextCharOfInsertionPoint
=
textFragmentDataAtInsertionPoint
.
GetPreviousEditableCharPoint
(
atNextCharOfInsertionPoint
)
;
if
(
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsSet
(
)
|
|
atPreviousCharOfNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackEndOfLineNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplacableWithSP
)
;
AutoTrackDOMRange
trackLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeOfNewLine
)
;
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtInsertionPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atNextCharOfInsertionPoint
nsIEditor
:
:
eNone
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atNextCharOfInsertionPoint
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
ReplaceTextAndRemoveEmptyTextNodes
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
}
if
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeOfNewLine
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeOfNewLine
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
atNBSPReplacableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Clear
(
)
;
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
else
if
(
atNBSPReplacableWithSP
.
IsInTextNode
(
)
)
{
const
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
atNBSPReplacableWithSP
.
AsInText
(
)
;
if
(
!
atNBSPReplacedWithASCIIWhiteSpace
.
IsEndOfContainer
(
)
&
&
atNBSPReplacedWithASCIIWhiteSpace
.
IsCharNBSP
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
failed
"
)
;
return
CreateElementResult
(
rv
)
;
}
atNBSPReplacableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeOfNewLine
.
Clear
(
)
;
invisibleTrailingWhiteSpaceRangeOfCurrentLine
.
Clear
(
)
;
}
}
}
CreateElementResult
insertBRElementResult
=
aHTMLEditor
.
InsertBRElement
(
HTMLEditor
:
:
WithTransaction
:
:
Yes
pointToInsert
)
;
NS_WARNING_ASSERTION
(
insertBRElementResult
.
isOk
(
)
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
eNone
)
failed
"
)
;
return
insertBRElementResult
;
}
Result
<
EditorDOMPoint
nsresult
>
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
HTMLEditor
&
aHTMLEditor
const
nsAString
&
aStringToInsert
const
EditorDOMRange
&
aRangeToBeReplaced
)
{
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aRangeToBeReplaced
.
Collapsed
(
)
)
;
return
EditorDOMPoint
(
aRangeToBeReplaced
.
StartRef
(
)
)
;
}
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentDataAtStart
(
aRangeToBeReplaced
.
StartRef
(
)
editingHost
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
isInsertionPointEqualsOrIsBeforeStartOfText
=
aRangeToBeReplaced
.
StartRef
(
)
.
EqualsOrIsBefore
(
textFragmentDataAtStart
.
StartRef
(
)
)
;
TextFragmentData
textFragmentDataAtEnd
=
aRangeToBeReplaced
.
Collapsed
(
)
?
textFragmentDataAtStart
:
TextFragmentData
(
aRangeToBeReplaced
.
EndRef
(
)
editingHost
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
bool
isInsertionPointEqualsOrAfterEndOfText
=
textFragmentDataAtEnd
.
EndRef
(
)
.
EqualsOrIsBefore
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
textFragmentDataAtStart
.
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
aRangeToBeReplaced
.
StartRef
(
)
)
;
const
bool
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
=
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
;
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
textFragmentDataAtEnd
.
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
const
bool
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
=
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpacesAtStart
=
!
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
?
Some
(
textFragmentDataAtStart
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtStart
=
visibleWhiteSpacesAtStart
.
isSome
(
)
&
&
visibleWhiteSpacesAtStart
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpacesAtStart
.
ref
(
)
.
ComparePoint
(
aRangeToBeReplaced
.
StartRef
(
)
)
:
PointPosition
:
:
NotInSameDOMTree
;
const
Maybe
<
const
VisibleWhiteSpacesData
>
visibleWhiteSpacesAtEnd
=
!
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
?
Some
(
textFragmentDataAtEnd
.
VisibleWhiteSpacesDataRef
(
)
)
:
Nothing
(
)
;
const
PointPosition
pointPositionWithVisibleWhiteSpacesAtEnd
=
visibleWhiteSpacesAtEnd
.
isSome
(
)
&
&
visibleWhiteSpacesAtEnd
.
ref
(
)
.
IsInitialized
(
)
?
visibleWhiteSpacesAtEnd
.
ref
(
)
.
ComparePoint
(
aRangeToBeReplaced
.
EndRef
(
)
)
:
PointPosition
:
:
NotInSameDOMTree
;
EditorDOMPoint
pointToInsert
(
aRangeToBeReplaced
.
StartRef
(
)
)
;
EditorDOMPoint
atNBSPReplaceableWithSP
;
if
(
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
&
&
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
)
{
atNBSPReplaceableWithSP
=
textFragmentDataAtStart
.
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
pointToInsert
)
.
To
<
EditorDOMPoint
>
(
)
;
}
nsAutoString
theString
(
aStringToInsert
)
;
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
!
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackPrecedingNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackInvisibleLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeAtStart
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
invisibleTrailingWhiteSpaceRangeAtEnd
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
textFragmentDataAtEnd
.
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
aRangeToBeReplaced
.
EndRef
(
)
)
;
if
(
atNBSPReplacedWithASCIIWhiteSpace
.
IsSet
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMPoint
trackPrecedingNBSP
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
atNBSPReplaceableWithSP
)
;
AutoTrackDOMRange
trackInvisibleLeadingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleLeadingWhiteSpaceRangeAtStart
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
}
}
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
!
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
MOZ_ASSERT
(
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
=
=
pointToInsert
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
invisibleLeadingWhiteSpaceRangeAtStart
.
StartRef
(
)
invisibleLeadingWhiteSpaceRangeAtStart
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeAtStart
.
Clear
(
)
;
}
}
else
if
(
atNBSPReplaceableWithSP
.
IsInTextNode
(
)
)
{
EditorDOMPointInText
atNBSPReplacedWithASCIIWhiteSpace
=
atNBSPReplaceableWithSP
.
AsInText
(
)
;
if
(
!
atNBSPReplacedWithASCIIWhiteSpace
.
IsEndOfContainer
(
)
&
&
atNBSPReplacedWithASCIIWhiteSpace
.
IsCharNBSP
(
)
)
{
AutoTrackDOMPoint
trackPointToInsert
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
AutoTrackDOMRange
trackInvisibleTrailingWhiteSpaceRange
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
invisibleTrailingWhiteSpaceRangeAtEnd
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atNBSPReplacedWithASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atNBSPReplacedWithASCIIWhiteSpace
.
Offset
(
)
1
u
"
"
_ns
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
failed
"
)
;
return
Err
(
rv
)
;
}
atNBSPReplaceableWithSP
.
Clear
(
)
;
invisibleLeadingWhiteSpaceRangeAtStart
.
Clear
(
)
;
}
}
}
MOZ_DIAGNOSTIC_ASSERT
(
!
theString
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
pointToInsert
.
IsInContentNode
(
)
)
|
|
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
)
{
const
bool
isNewLineCollapsible
=
!
pointToInsert
.
IsInContentNode
(
)
|
|
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
pointToInsert
.
ContainerAs
<
nsIContent
>
(
)
)
;
auto
isCollapsibleChar
=
[
&
isNewLineCollapsible
]
(
char16_t
aChar
)
-
>
bool
{
return
nsCRT
:
:
IsAsciiSpace
(
aChar
)
&
&
(
isNewLineCollapsible
|
|
aChar
!
=
HTMLEditUtils
:
:
kNewLine
)
;
}
;
if
(
isCollapsibleChar
(
theString
[
0
]
)
)
{
if
(
isInvisibleLeadingWhiteSpaceRangeAtStartPositioned
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
else
if
(
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtStart
=
=
PointPosition
:
:
EndOfFragment
)
{
const
auto
atPreviousChar
=
textFragmentDataAtStart
.
GetPreviousEditableCharPoint
<
EditorRawDOMPointInText
>
(
pointToInsert
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
}
else
if
(
textFragmentDataAtStart
.
StartsFromHardLineBreak
(
)
&
&
isInsertionPointEqualsOrIsBeforeStartOfText
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
0
)
;
}
}
const
uint32_t
lastCharIndex
=
theString
.
Length
(
)
-
1
;
if
(
isCollapsibleChar
(
theString
[
lastCharIndex
]
)
)
{
if
(
isInvisibleTrailingWhiteSpaceRangeAtEndPositioned
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
if
(
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpacesAtEnd
=
=
PointPosition
:
:
MiddleOfFragment
)
{
const
auto
atNextChar
=
textFragmentDataAtEnd
.
GetInclusiveNextEditableCharPoint
<
EditorRawDOMPointInText
>
(
pointToInsert
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
}
else
if
(
textFragmentDataAtEnd
.
EndsByBlockBoundary
(
)
&
&
isInsertionPointEqualsOrAfterEndOfText
)
{
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
lastCharIndex
)
;
}
}
enum
class
PreviousChar
{
NonCollapsibleChar
CollapsibleChar
PreformattedNewLine
}
;
PreviousChar
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
for
(
uint32_t
i
=
0
;
i
<
=
lastCharIndex
;
i
+
+
)
{
if
(
isCollapsibleChar
(
theString
[
i
]
)
)
{
if
(
previousChar
=
=
PreviousChar
:
:
CollapsibleChar
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
-
1
)
;
continue
;
}
if
(
previousChar
=
=
PreviousChar
:
:
PreformattedNewLine
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
)
;
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
continue
;
}
previousChar
=
PreviousChar
:
:
CollapsibleChar
;
continue
;
}
if
(
theString
[
i
]
!
=
HTMLEditUtils
:
:
kNewLine
)
{
previousChar
=
PreviousChar
:
:
NonCollapsibleChar
;
continue
;
}
MOZ_ASSERT
(
!
isNewLineCollapsible
)
;
if
(
previousChar
=
=
PreviousChar
:
:
CollapsibleChar
)
{
MOZ_ASSERT
(
i
>
0
)
;
theString
.
SetCharAt
(
HTMLEditUtils
:
:
kNBSP
i
-
1
)
;
}
previousChar
=
PreviousChar
:
:
PreformattedNewLine
;
}
}
if
(
MOZ_UNLIKELY
(
!
aHTMLEditor
.
GetDocument
(
)
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceText
(
)
lost
proper
document
"
)
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
OwningNonNull
<
Document
>
document
=
*
aHTMLEditor
.
GetDocument
(
)
;
Result
<
EditorDOMPoint
nsresult
>
insertTextResult
=
aHTMLEditor
.
InsertTextWithTransaction
(
document
theString
pointToInsert
)
;
if
(
MOZ_UNLIKELY
(
insertTextResult
.
isErr
(
)
&
&
insertTextResult
.
inspectErr
(
)
=
=
NS_ERROR_EDITOR_DESTROYED
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
caused
destroying
the
editor
"
)
;
return
Err
(
NS_ERROR_EDITOR_DESTROYED
)
;
}
if
(
insertTextResult
.
isOk
(
)
)
{
return
insertTextResult
.
unwrap
(
)
;
}
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
but
ignored
"
)
;
return
pointToInsert
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
DeletePreviousWhiteSpace
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentDataAtDeletion
(
aPoint
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtDeletion
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMPointInText
atPreviousCharOfStart
=
textFragmentDataAtDeletion
.
GetPreviousEditableCharPoint
(
aPoint
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
|
|
atPreviousCharOfStart
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
auto
startToDelete
=
textFragmentDataAtDeletion
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPoint
>
(
atPreviousCharOfStart
nsIEditor
:
:
ePrevious
)
;
auto
endToDelete
=
textFragmentDataAtDeletion
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPoint
>
(
atPreviousCharOfStart
nsIEditor
:
:
ePrevious
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atPreviousCharOfStart
.
IsCharCollapsibleNBSP
(
)
)
{
auto
startToDelete
=
atPreviousCharOfStart
.
To
<
EditorDOMPoint
>
(
)
;
auto
endToDelete
=
startToDelete
.
NextPoint
<
EditorDOMPoint
>
(
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
atPreviousCharOfStart
atPreviousCharOfStart
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
DeleteInclusiveNextWhiteSpace
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentDataAtDeletion
(
aPoint
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtDeletion
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
atNextCharOfStart
=
textFragmentDataAtDeletion
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPoint
)
;
if
(
!
atNextCharOfStart
.
IsSet
(
)
|
|
atNextCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
atNextCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
|
|
atNextCharOfStart
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
auto
startToDelete
=
textFragmentDataAtDeletion
.
GetFirstASCIIWhiteSpacePointCollapsedTo
<
EditorDOMPoint
>
(
atNextCharOfStart
nsIEditor
:
:
eNext
)
;
auto
endToDelete
=
textFragmentDataAtDeletion
.
GetEndOfCollapsibleASCIIWhiteSpaces
<
EditorDOMPoint
>
(
atNextCharOfStart
nsIEditor
:
:
eNext
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atNextCharOfStart
.
IsCharCollapsibleNBSP
(
)
)
{
auto
startToDelete
=
atNextCharOfStart
.
To
<
EditorDOMPoint
>
(
)
;
auto
endToDelete
=
startToDelete
.
NextPoint
<
EditorDOMPoint
>
(
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
aHTMLEditor
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
PrepareToDeleteRangeAndTrackPoints
(
)
"
"
failed
"
)
;
return
rv
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
atNextCharOfStart
atNextCharOfStart
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
DeleteContentNodeAndJoinTextNodesAroundIt
(
HTMLEditor
&
aHTMLEditor
nsIContent
&
aContentToDelete
const
EditorDOMPoint
&
aCaretPoint
)
{
EditorDOMPoint
atContent
(
&
aContentToDelete
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
Deleting
content
node
was
an
orphan
node
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
HTMLEditUtils
:
:
IsRemovableNode
(
aContentToDelete
)
)
{
NS_WARNING
(
"
Deleting
content
node
wasn
'
t
removable
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
aHTMLEditor
EditorDOMRange
(
atContent
atContent
.
NextPoint
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
)
failed
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIContent
>
previousEditableSibling
=
HTMLEditUtils
:
:
GetPreviousSibling
(
aContentToDelete
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
rv
=
aHTMLEditor
.
DeleteNodeWithTransaction
(
aContentToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
aCaretPoint
.
IsInTextNode
(
)
|
|
!
previousEditableSibling
|
|
!
previousEditableSibling
-
>
IsText
(
)
)
{
return
NS_OK
;
}
nsIContent
*
nextEditableSibling
=
HTMLEditUtils
:
:
GetNextSibling
(
*
previousEditableSibling
{
WalkTreeOption
:
:
IgnoreNonEditableNode
}
)
;
if
(
aCaretPoint
.
GetContainer
(
)
!
=
nextEditableSibling
)
{
return
NS_OK
;
}
EditorDOMPoint
atFirstChildOfRightNode
;
rv
=
aHTMLEditor
.
JoinNearestEditableNodesWithTransaction
(
*
previousEditableSibling
MOZ_KnownLive
(
*
aCaretPoint
.
ContainerAs
<
Text
>
(
)
)
&
atFirstChildOfRightNode
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
atFirstChildOfRightNode
.
IsSet
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
JoinNearestEditableNodesWithTransaction
(
)
didn
'
t
return
"
"
right
node
position
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
aHTMLEditor
.
CollapseSelectionTo
(
atFirstChildOfRightNode
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
CollapseSelectionTo
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
!
TextFragmentDataAtStartRef
(
)
.
IsInitialized
(
)
)
{
return
WSScanResult
(
nullptr
WSType
:
:
UnexpectedError
)
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
TextFragmentDataAtStartRef
(
)
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
visibleWhiteSpaces
.
IsInitialized
(
)
&
&
visibleWhiteSpaces
.
StartRef
(
)
.
IsBefore
(
aPoint
)
)
{
if
(
aPoint
.
GetChild
(
)
&
&
!
aPoint
.
GetChild
(
)
-
>
IsEditable
(
)
)
{
return
WSScanResult
(
aPoint
.
GetChild
(
)
WSType
:
:
SpecialContent
)
;
}
const
auto
atPreviousChar
=
GetPreviousEditableCharPoint
<
EditorRawDOMPointInText
>
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsContainerEmpty
(
)
)
{
MOZ_ASSERT
(
!
atPreviousChar
.
IsEndOfContainer
(
)
)
;
return
WSScanResult
(
atPreviousChar
.
template
NextPoint
<
EditorDOMPoint
>
(
)
atPreviousChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
?
WSType
:
:
CollapsibleWhiteSpaces
:
WSType
:
:
NonCollapsibleCharacters
)
;
}
}
if
(
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
!
=
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
.
GetContainer
(
)
)
{
return
WSScanResult
(
TextFragmentDataAtStartRef
(
)
.
GetStartReasonContent
(
)
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
)
;
}
return
WSScanResult
(
TextFragmentDataAtStartRef
(
)
.
StartRef
(
)
TextFragmentDataAtStartRef
(
)
.
StartRawReason
(
)
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
if
(
!
TextFragmentDataAtStartRef
(
)
.
IsInitialized
(
)
)
{
return
WSScanResult
(
nullptr
WSType
:
:
UnexpectedError
)
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
TextFragmentDataAtStartRef
(
)
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
visibleWhiteSpaces
.
IsInitialized
(
)
&
&
aPoint
.
EqualsOrIsBefore
(
visibleWhiteSpaces
.
EndRef
(
)
)
)
{
if
(
aPoint
.
GetChild
(
)
&
&
!
aPoint
.
GetChild
(
)
-
>
IsEditable
(
)
)
{
return
WSScanResult
(
aPoint
.
GetChild
(
)
WSType
:
:
SpecialContent
)
;
}
const
auto
atNextChar
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPoint
>
(
aPoint
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsContainerEmpty
(
)
)
{
return
WSScanResult
(
atNextChar
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharCollapsibleASCIISpaceOrNBSP
(
)
?
WSType
:
:
CollapsibleWhiteSpaces
:
WSType
:
:
NonCollapsibleCharacters
)
;
}
}
if
(
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
!
=
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
.
GetContainer
(
)
)
{
return
WSScanResult
(
TextFragmentDataAtStartRef
(
)
.
GetEndReasonContent
(
)
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
)
;
}
return
WSScanResult
(
TextFragmentDataAtStartRef
(
)
.
EndRef
(
)
TextFragmentDataAtStartRef
(
)
.
EndRawReason
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
TextFragmentData
(
const
EditorDOMPointType
&
aPoint
const
Element
*
aEditingHost
)
:
mEditingHost
(
aEditingHost
)
{
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
NS_WARNING
(
"
aPoint
was
invalid
"
)
;
return
;
}
if
(
!
aPoint
.
IsInContentNode
(
)
)
{
NS_WARNING
(
"
aPoint
was
in
Document
or
DocumentFragment
"
)
;
return
;
}
mScanStartPoint
=
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
;
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
if
(
NS_WARN_IF
(
!
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
)
{
return
;
}
const
Element
*
editableBlockElementOrInlineEditingHost
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
;
if
(
!
editableBlockElementOrInlineEditingHost
)
{
NS_WARNING
(
"
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
HTMLEditUtils
:
:
"
"
ClosestEditableBlockElementOrInlineEditingHost
)
couldn
'
t
find
"
"
editing
host
"
)
;
return
;
}
mStart
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
)
;
MOZ_ASSERT_IF
(
mStart
.
IsNonCollapsibleCharacters
(
)
!
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mStart
.
IsPreformattedLineBreak
(
)
mStart
.
PointRef
(
)
.
IsPreviousCharPreformattedNewLine
(
)
)
;
mEnd
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
mScanStartPoint
*
editableBlockElementOrInlineEditingHost
mEditingHost
&
mNBSPData
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsNonCollapsibleCharacters
(
)
!
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
MOZ_ASSERT_IF
(
mEnd
.
IsPreformattedLineBreak
(
)
mEnd
.
PointRef
(
)
.
IsCharPreformattedNewLine
(
)
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
std
:
:
min
(
aPoint
.
Offset
(
)
textFragment
.
GetLength
(
)
)
;
i
;
i
-
-
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
-
1
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
-
1
)
NoBreakingSpaceData
:
:
Scanning
:
:
Backward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
-
1
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineContent
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsStartOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
aPoint
aNBSPData
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
aEditingHost
aNBSPData
)
;
}
nsIContent
*
previousLeafContentOrBlock
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineContent
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aEditingHost
)
;
if
(
!
previousLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineContent
)
WSType
:
:
CurrentBlockBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
previousLeafContentOrBlock
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
IsText
(
)
|
|
!
previousLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
previousLeafContentOrBlock
previousLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
previousLeafContentOrBlock
-
>
AsText
(
)
-
>
TextLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
aEditingHost
aNBSPData
)
;
}
Maybe
<
BoundaryData
>
startInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartInTextNode
(
EditorDOMPointInText
:
:
AtEndOf
(
*
previousLeafContentOrBlock
-
>
AsText
(
)
)
aNBSPData
)
;
if
(
startInTextNode
.
isSome
(
)
)
{
return
startInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceStartFrom
(
EditorDOMPointInText
(
previousLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineContent
aEditingHost
aNBSPData
)
;
}
template
<
typename
EditorDOMPointType
>
Maybe
<
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
const
EditorDOMPointType
&
aPoint
NoBreakingSpaceData
*
aNBSPData
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPoint
.
IsInTextNode
(
)
)
;
const
bool
isWhiteSpaceCollapsible
=
!
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
bool
isNewLineCollapsible
=
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
;
const
nsTextFragment
&
textFragment
=
aPoint
.
template
ContainerAs
<
Text
>
(
)
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
aPoint
.
Offset
(
)
;
i
<
textFragment
.
GetLength
(
)
;
i
+
+
)
{
WSType
wsTypeOfNonCollapsibleChar
;
switch
(
textFragment
.
CharAt
(
i
)
)
{
case
HTMLEditUtils
:
:
kSpace
:
case
HTMLEditUtils
:
:
kCarriageReturn
:
case
HTMLEditUtils
:
:
kTab
:
if
(
isWhiteSpaceCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
case
HTMLEditUtils
:
:
kNewLine
:
if
(
isNewLineCollapsible
)
{
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
PreformattedLineBreak
;
break
;
case
HTMLEditUtils
:
:
kNBSP
:
if
(
isWhiteSpaceCollapsible
)
{
if
(
aNBSPData
)
{
aNBSPData
-
>
NotifyNBSP
(
EditorDOMPointInText
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
NoBreakingSpaceData
:
:
Scanning
:
:
Forward
)
;
}
continue
;
}
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
default
:
MOZ_ASSERT
(
!
nsCRT
:
:
IsAsciiSpace
(
textFragment
.
CharAt
(
i
)
)
)
;
wsTypeOfNonCollapsibleChar
=
WSType
:
:
NonCollapsibleCharacters
;
break
;
}
return
Some
(
BoundaryData
(
EditorDOMPoint
(
aPoint
.
template
ContainerAs
<
Text
>
(
)
i
)
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
wsTypeOfNonCollapsibleChar
)
)
;
}
return
Nothing
(
)
;
}
template
<
typename
EditorDOMPointType
>
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
WSRunScanner
:
:
TextFragmentData
:
:
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
const
EditorDOMPointType
&
aPoint
const
Element
&
aEditableBlockParentOrTopmostEditableInlineElement
const
Element
*
aEditingHost
NoBreakingSpaceData
*
aNBSPData
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
aPoint
.
IsInTextNode
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
aPoint
aNBSPData
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aPoint
.
template
ContainerAs
<
Text
>
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
)
;
}
nsIContent
*
nextLeafContentOrBlock
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
aPoint
aEditableBlockParentOrTopmostEditableInlineElement
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
aEditingHost
)
;
if
(
!
nextLeafContentOrBlock
)
{
return
BoundaryData
(
aPoint
.
template
To
<
EditorDOMPoint
>
(
)
const_cast
<
Element
&
>
(
aEditableBlockParentOrTopmostEditableInlineElement
)
WSType
:
:
CurrentBlockBoundary
)
;
}
if
(
HTMLEditUtils
:
:
IsBlockElement
(
*
nextLeafContentOrBlock
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
WSType
:
:
OtherBlockBoundary
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
IsText
(
)
|
|
!
nextLeafContentOrBlock
-
>
IsEditable
(
)
)
{
return
BoundaryData
(
aPoint
*
nextLeafContentOrBlock
nextLeafContentOrBlock
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
?
WSType
:
:
BRElement
:
WSType
:
:
SpecialContent
)
;
}
if
(
!
nextLeafContentOrBlock
-
>
AsText
(
)
-
>
TextFragment
(
)
.
GetLength
(
)
)
{
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
)
;
}
Maybe
<
BoundaryData
>
endInTextNode
=
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndInTextNode
(
EditorDOMPointInText
(
nextLeafContentOrBlock
-
>
AsText
(
)
0
)
aNBSPData
)
;
if
(
endInTextNode
.
isSome
(
)
)
{
return
endInTextNode
.
ref
(
)
;
}
return
BoundaryData
:
:
ScanCollapsibleWhiteSpaceEndFrom
(
EditorDOMPointInText
:
:
AtEndOf
(
*
nextLeafContentOrBlock
-
>
AsText
(
)
)
aEditableBlockParentOrTopmostEditableInlineElement
aEditingHost
aNBSPData
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleLeadingWhiteSpaceRangeRef
(
)
const
{
if
(
mLeadingWhiteSpaceRange
.
isSome
(
)
)
{
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
)
{
mLeadingWhiteSpaceRange
.
emplace
(
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
mLeadingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mNBSPData
.
FirstPointRef
(
)
)
;
return
mLeadingWhiteSpaceRange
.
ref
(
)
;
}
const
EditorDOMRange
&
WSRunScanner
:
:
TextFragmentData
:
:
InvisibleTrailingWhiteSpaceRangeRef
(
)
const
{
if
(
mTrailingWhiteSpaceRange
.
isSome
(
)
)
{
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
EndsByBlockBoundary
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
if
(
!
mNBSPData
.
FoundNBSP
(
)
)
{
MOZ_ASSERT
(
mStart
.
PointRef
(
)
.
IsSet
(
)
|
|
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mStart
.
PointRef
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
mNBSPData
.
LastPointRef
(
)
.
IsSetAndValid
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
GetContainer
(
)
=
=
mEnd
.
PointRef
(
)
.
GetContainer
(
)
&
&
mNBSPData
.
LastPointRef
(
)
.
Offset
(
)
=
=
mEnd
.
PointRef
(
)
.
Offset
(
)
-
1
)
{
mTrailingWhiteSpaceRange
.
emplace
(
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
MOZ_ASSERT
(
!
mNBSPData
.
LastPointRef
(
)
.
IsEndOfContainer
(
)
)
;
mTrailingWhiteSpaceRange
.
emplace
(
mNBSPData
.
LastPointRef
(
)
.
NextPoint
(
)
mEnd
.
PointRef
(
)
)
;
return
mTrailingWhiteSpaceRange
.
ref
(
)
;
}
EditorDOMRangeInTexts
WSRunScanner
:
:
TextFragmentData
:
:
GetNonCollapsedRangeInTexts
(
const
EditorDOMRange
&
aRange
)
const
{
if
(
!
aRange
.
IsPositioned
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
aRange
.
IsInTextNodes
(
)
)
{
return
aRange
.
GetAsInTexts
(
)
;
}
const
auto
firstPoint
=
aRange
.
StartRef
(
)
.
IsInTextNode
(
)
?
aRange
.
StartRef
(
)
.
AsInText
(
)
:
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aRange
.
StartRef
(
)
)
;
if
(
!
firstPoint
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
endPoint
;
if
(
aRange
.
EndRef
(
)
.
IsInTextNode
(
)
)
{
endPoint
=
aRange
.
EndRef
(
)
.
AsInText
(
)
;
}
else
{
endPoint
=
GetPreviousEditableCharPoint
(
aRange
.
EndRef
(
)
)
;
if
(
endPoint
.
IsSet
(
)
&
&
endPoint
.
IsAtLastContent
(
)
)
{
MOZ_ALWAYS_TRUE
(
endPoint
.
AdvanceOffset
(
)
)
;
}
}
if
(
!
endPoint
.
IsSet
(
)
|
|
firstPoint
=
=
endPoint
)
{
return
EditorDOMRangeInTexts
(
)
;
}
return
EditorDOMRangeInTexts
(
firstPoint
endPoint
)
;
}
const
WSRunScanner
:
:
VisibleWhiteSpacesData
&
WSRunScanner
:
:
TextFragmentData
:
:
VisibleWhiteSpacesDataRef
(
)
const
{
if
(
mVisibleWhiteSpacesData
.
isSome
(
)
)
{
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
{
const
bool
mayHaveInvisibleLeadingSpace
=
!
StartsFromNonCollapsibleCharacters
(
)
&
&
!
StartsFromSpecialContent
(
)
;
const
bool
mayHaveInvisibleTrailingWhiteSpace
=
!
EndsByNonCollapsibleCharacters
(
)
&
&
!
EndsBySpecialContent
(
)
&
&
!
EndsByBRElement
(
)
&
&
!
EndsByInvisiblePreformattedLineBreak
(
)
;
if
(
!
mayHaveInvisibleLeadingSpace
&
&
!
mayHaveInvisibleTrailingWhiteSpace
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveLeadingWhiteSpaces
=
leadingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveLeadingWhiteSpaces
&
&
leadingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
leadingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
const
bool
maybeHaveTrailingWhiteSpaces
=
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
|
|
trailingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
;
if
(
maybeHaveTrailingWhiteSpaces
&
&
trailingWhiteSpaceRange
.
StartRef
(
)
=
=
mStart
.
PointRef
(
)
&
&
trailingWhiteSpaceRange
.
EndRef
(
)
=
=
mEnd
.
PointRef
(
)
)
{
mVisibleWhiteSpacesData
.
emplace
(
VisibleWhiteSpacesData
(
)
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
!
StartsFromHardLineBreak
(
)
)
{
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
mStart
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
mStart
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFrom
(
mStart
.
RawReason
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
=
Some
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
StartsFromHardLineBreak
(
)
)
;
MOZ_ASSERT
(
maybeHaveLeadingWhiteSpaces
)
;
VisibleWhiteSpacesData
visibleWhiteSpaces
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetStartPoint
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
visibleWhiteSpaces
.
SetStartFromLeadingWhiteSpaces
(
)
;
if
(
!
EndsByBlockBoundary
(
)
)
{
if
(
mEnd
.
PointRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
MOZ_ASSERT
(
EndsByBlockBoundary
(
)
)
;
if
(
!
maybeHaveTrailingWhiteSpaces
)
{
visibleWhiteSpaces
.
SetEndPoint
(
mEnd
.
PointRef
(
)
)
;
visibleWhiteSpaces
.
SetEndBy
(
mEnd
.
RawReason
(
)
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
visibleWhiteSpaces
.
SetEndPoint
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
visibleWhiteSpaces
.
SetEndByTrailingWhiteSpaces
(
)
;
mVisibleWhiteSpacesData
.
emplace
(
visibleWhiteSpaces
)
;
return
mVisibleWhiteSpacesData
.
ref
(
)
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleStateOfWhiteSpacesAroundDeletingRange
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRange
&
aRangeToDelete
)
{
if
(
NS_WARN_IF
(
!
aRangeToDelete
.
IsPositionedAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aRangeToDelete
.
IsInContentNodes
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorDOMRange
rangeToDelete
(
aRangeToDelete
)
;
bool
mayBecomeUnexpectedDOMTree
=
aHTMLEditor
.
MayHaveMutationEventListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
)
;
RefPtr
<
Element
>
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentDataAtStart
(
rangeToDelete
.
StartRef
(
)
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
TextFragmentData
textFragmentDataAtEnd
(
rangeToDelete
.
EndRef
(
)
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ReplaceRangeData
replaceRangeDataAtEnd
=
textFragmentDataAtEnd
.
GetReplaceRangeDataAtEndOfDeletionRange
(
textFragmentDataAtStart
)
;
if
(
replaceRangeDataAtEnd
.
IsSet
(
)
&
&
!
replaceRangeDataAtEnd
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
rangeToDelete
.
EndRef
(
)
.
EqualsOrIsBefore
(
replaceRangeDataAtEnd
.
EndRef
(
)
)
)
;
MOZ_ASSERT_IF
(
rangeToDelete
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
!
rangeToDelete
.
EndRef
(
)
.
IsEndOfContainer
(
)
replaceRangeDataAtEnd
.
StartRef
(
)
.
EqualsOrIsBefore
(
rangeToDelete
.
EndRef
(
)
)
)
;
MOZ_ASSERT_IF
(
rangeToDelete
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
rangeToDelete
.
EndRef
(
)
.
IsEndOfContainer
(
)
rangeToDelete
.
EndRef
(
)
=
=
replaceRangeDataAtEnd
.
StartRef
(
)
|
|
replaceRangeDataAtEnd
.
StartRef
(
)
.
IsStartOfContainer
(
)
)
;
MOZ_ASSERT
(
rangeToDelete
.
StartRef
(
)
.
EqualsOrIsBefore
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
)
;
if
(
!
replaceRangeDataAtEnd
.
HasReplaceString
(
)
)
{
EditorDOMPoint
startToDelete
(
aRangeToDelete
.
StartRef
(
)
)
;
EditorDOMPoint
endToDelete
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
;
{
AutoEditorDOMPointChildInvalidator
lockOffsetOfStart
(
startToDelete
)
;
AutoEditorDOMPointChildInvalidator
lockOffsetOfEnd
(
endToDelete
)
;
AutoTrackDOMPoint
trackStartToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startToDelete
)
;
AutoTrackDOMPoint
trackEndToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
endToDelete
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
replaceRangeDataAtEnd
.
StartRef
(
)
replaceRangeDataAtEnd
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
mayBecomeUnexpectedDOMTree
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
rangeToDelete
.
SetStartAndEnd
(
startToDelete
endToDelete
)
;
}
else
{
MOZ_ASSERT
(
replaceRangeDataAtEnd
.
RangeRef
(
)
.
IsInTextNodes
(
)
)
;
EditorDOMPoint
startToDelete
(
aRangeToDelete
.
StartRef
(
)
)
;
EditorDOMPoint
endToDelete
(
replaceRangeDataAtEnd
.
StartRef
(
)
)
;
{
AutoTrackDOMPoint
trackStartToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
startToDelete
)
;
AutoTrackDOMPoint
trackEndToDelete
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
endToDelete
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
replaceRangeDataAtEnd
.
RangeRef
(
)
.
AsInTexts
(
)
replaceRangeDataAtEnd
.
ReplaceStringRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAtEndOfDeletingRange
(
)
"
"
failed
"
)
;
return
rv
;
}
}
if
(
mayBecomeUnexpectedDOMTree
&
&
(
NS_WARN_IF
(
!
startToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
endToDelete
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
rangeToDelete
.
SetStartAndEnd
(
startToDelete
endToDelete
)
;
}
if
(
mayBecomeUnexpectedDOMTree
)
{
if
(
editingHost
!
=
aHTMLEditor
.
ComputeEditingHost
(
)
)
{
NS_WARNING
(
"
Active
editing
host
was
changed
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
if
(
!
rangeToDelete
.
IsInContentNodes
(
)
)
{
NS_WARNING
(
"
The
modified
range
was
not
in
content
"
)
;
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
textFragmentDataAtStart
=
TextFragmentData
(
rangeToDelete
.
StartRef
(
)
editingHost
)
;
textFragmentDataAtEnd
=
TextFragmentData
(
rangeToDelete
.
EndRef
(
)
editingHost
)
;
}
}
ReplaceRangeData
replaceRangeDataAtStart
=
textFragmentDataAtStart
.
GetReplaceRangeDataAtStartOfDeletionRange
(
textFragmentDataAtEnd
)
;
if
(
!
replaceRangeDataAtStart
.
IsSet
(
)
|
|
replaceRangeDataAtStart
.
Collapsed
(
)
)
{
return
NS_OK
;
}
if
(
!
replaceRangeDataAtStart
.
HasReplaceString
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
replaceRangeDataAtStart
.
StartRef
(
)
replaceRangeDataAtStart
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
MOZ_ASSERT
(
replaceRangeDataAtStart
.
RangeRef
(
)
.
IsInTextNodes
(
)
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
replaceRangeDataAtStart
.
RangeRef
(
)
.
AsInTexts
(
)
replaceRangeDataAtStart
.
ReplaceStringRef
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WhiteSpaceVisibilityKeeper
:
:
"
"
MakeSureToKeepVisibleStateOfWhiteSpacesAtStartOfDeletingRange
(
)
failed
"
)
;
return
rv
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtEndOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtStartToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
aTextFragmentDataAtStartToDelete
.
ScanStartRef
(
)
;
const
EditorDOMPoint
&
endToDelete
=
mScanStartPoint
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
EndRef
(
)
.
EqualsOrIsBefore
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleTrailingWhiteSpaceRangeAtEnd
=
GetNewInvisibleTrailingWhiteSpaceRangeIfSplittingAt
(
endToDelete
)
;
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
IsPositioned
(
)
)
{
if
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
MOZ_ASSERT
(
invisibleTrailingWhiteSpaceRangeAtEnd
.
StartRef
(
)
=
=
endToDelete
)
;
return
ReplaceRangeData
(
invisibleTrailingWhiteSpaceRangeAtEnd
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtEnd
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtEnd
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
=
nonPreformattedVisibleWhiteSpacesAtEnd
.
ComparePoint
(
endToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
StartOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtEnd
!
=
PointPosition
:
:
MiddleOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtStartToDelete
.
FollowingContentMayBecomeFirstVisibleContent
(
startToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
auto
nextCharOfStartOfEnd
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
endToDelete
)
;
if
(
!
nextCharOfStartOfEnd
.
IsSet
(
)
|
|
nextCharOfStartOfEnd
.
IsEndOfContainer
(
)
|
|
!
nextCharOfStartOfEnd
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
nextCharOfStartOfEnd
.
IsStartOfContainer
(
)
|
|
nextCharOfStartOfEnd
.
IsPreviousCharCollapsibleASCIISpace
(
)
)
{
nextCharOfStartOfEnd
=
aTextFragmentDataAtStartToDelete
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
aTextFragmentDataAtStartToDelete
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
nextCharOfStartOfEnd
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
nextCharOfStartOfEnd
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
ReplaceRangeData
WSRunScanner
:
:
TextFragmentData
:
:
GetReplaceRangeDataAtStartOfDeletionRange
(
const
TextFragmentData
&
aTextFragmentDataAtEndToDelete
)
const
{
const
EditorDOMPoint
&
startToDelete
=
mScanStartPoint
;
const
EditorDOMPoint
&
endToDelete
=
aTextFragmentDataAtEndToDelete
.
ScanStartRef
(
)
;
MOZ_ASSERT
(
startToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
endToDelete
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
startToDelete
.
EqualsOrIsBefore
(
endToDelete
)
)
;
if
(
startToDelete
.
EqualsOrIsBefore
(
StartRef
(
)
)
)
{
return
ReplaceRangeData
(
)
;
}
const
EditorDOMRange
invisibleLeadingWhiteSpaceRangeAtStart
=
GetNewInvisibleLeadingWhiteSpaceRangeIfSplittingAt
(
startToDelete
)
;
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
IsPositioned
(
)
)
{
if
(
invisibleLeadingWhiteSpaceRangeAtStart
.
Collapsed
(
)
)
{
return
ReplaceRangeData
(
)
;
}
return
ReplaceRangeData
(
invisibleLeadingWhiteSpaceRangeAtStart
u
"
"
_ns
)
;
}
const
VisibleWhiteSpacesData
&
nonPreformattedVisibleWhiteSpacesAtStart
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
nonPreformattedVisibleWhiteSpacesAtStart
.
IsInitialized
(
)
)
{
return
ReplaceRangeData
(
)
;
}
const
PointPosition
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
=
nonPreformattedVisibleWhiteSpacesAtStart
.
ComparePoint
(
startToDelete
)
;
if
(
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
MiddleOfFragment
&
&
pointPositionWithNonPreformattedVisibleWhiteSpacesAtStart
!
=
PointPosition
:
:
EndOfFragment
)
{
return
ReplaceRangeData
(
)
;
}
if
(
!
aTextFragmentDataAtEndToDelete
.
PrecedingContentMayBecomeInvisible
(
endToDelete
)
)
{
return
ReplaceRangeData
(
)
;
}
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousEditableCharPoint
(
startToDelete
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
ReplaceRangeData
(
)
;
}
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
return
ReplaceRangeData
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
MakeSureToKeepVisibleWhiteSpacesVisibleAfterSplit
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPointToSplit
)
{
TextFragmentData
textFragmentDataAtSplitPoint
(
aPointToSplit
aHTMLEditor
.
ComputeEditingHost
(
)
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtSplitPoint
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
textFragmentDataAtSplitPoint
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
IsInitialized
(
)
)
{
return
NS_OK
;
}
PointPosition
pointPositionWithVisibleWhiteSpaces
=
visibleWhiteSpaces
.
ComparePoint
(
aPointToSplit
)
;
EditorDOMPoint
pointToSplit
(
aPointToSplit
)
;
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
StartOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
)
{
EditorDOMPointInText
atNextCharOfStart
=
textFragmentDataAtSplitPoint
.
GetInclusiveNextEditableCharPoint
(
pointToSplit
)
;
if
(
atNextCharOfStart
.
IsSet
(
)
&
&
!
atNextCharOfStart
.
IsEndOfContainer
(
)
&
&
atNextCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
pointToSplit
)
;
AutoTrackDOMPoint
trackSplitPoint
(
aHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToSplit
)
;
if
(
atNextCharOfStart
.
IsStartOfContainer
(
)
|
|
atNextCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atNextCharOfStart
=
textFragmentDataAtSplitPoint
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atNextCharOfStart
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtSplitPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atNextCharOfStart
nsIEditor
:
:
eNone
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atNextCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
if
(
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
MiddleOfFragment
|
|
pointPositionWithVisibleWhiteSpaces
=
=
PointPosition
:
:
EndOfFragment
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
textFragmentDataAtSplitPoint
.
GetPreviousEditableCharPoint
(
pointToSplit
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharCollapsibleASCIISpace
(
)
)
{
if
(
atPreviousCharOfStart
.
IsStartOfContainer
(
)
|
|
atPreviousCharOfStart
.
IsPreviousCharASCIISpace
(
)
)
{
atPreviousCharOfStart
=
textFragmentDataAtSplitPoint
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
}
const
EditorDOMPointInText
endOfCollapsibleASCIIWhiteSpaces
=
textFragmentDataAtSplitPoint
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousCharOfStart
nsIEditor
:
:
eNone
)
;
nsresult
rv
=
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
aHTMLEditor
EditorDOMRangeInTexts
(
atPreviousCharOfStart
endOfCollapsibleASCIIWhiteSpaces
)
nsDependentSubstring
(
&
HTMLEditUtils
:
:
kNBSP
1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
child
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
child
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetFirstLeafContent
(
*
child
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
child
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
Set
(
leafContent
0
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsEndOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetEndReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mEditingHost
)
;
nextContent
;
nextContent
=
HTMLEditUtils
:
:
GetNextLeafContentOrNextBlockElement
(
*
nextContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mEditingHost
)
)
{
if
(
!
nextContent
-
>
IsText
(
)
|
|
!
nextContent
-
>
IsEditable
(
)
)
{
if
(
nextContent
=
=
GetEndReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
nextContent
-
>
AsText
(
)
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
typename
PT
typename
CT
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousEditableCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
if
(
NS_WARN_IF
(
!
aPoint
.
IsInContentNode
(
)
)
|
|
NS_WARN_IF
(
!
mScanStartPoint
.
IsInContentNode
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
EditorRawDOMPoint
point
;
if
(
nsIContent
*
previousChild
=
aPoint
.
CanContainerHaveChildren
(
)
?
aPoint
.
GetPreviousSiblingOfChild
(
)
:
nullptr
)
{
nsIContent
*
leafContent
=
previousChild
-
>
HasChildren
(
)
?
HTMLEditUtils
:
:
GetLastLeafContent
(
*
previousChild
{
LeafNodeType
:
:
OnlyLeafNode
}
)
:
previousChild
;
if
(
NS_WARN_IF
(
!
leafContent
)
)
{
return
EditorDOMPointType
(
)
;
}
point
.
SetToEndOf
(
leafContent
)
;
}
else
{
point
=
aPoint
.
template
To
<
EditorRawDOMPoint
>
(
)
;
}
if
(
point
.
IsInTextNode
(
)
&
&
point
.
GetContainer
(
)
-
>
IsEditable
(
)
&
&
!
point
.
IsStartOfContainer
(
)
)
{
return
EditorDOMPointType
(
point
.
ContainerAs
<
Text
>
(
)
point
.
Offset
(
)
-
1
)
;
}
if
(
point
.
GetContainer
(
)
=
=
GetStartReasonContent
(
)
)
{
return
EditorDOMPointType
(
)
;
}
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
nsIContent
*
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
&
&
EditorUtils
:
:
IsEditableContent
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementOrInlineEditingHost
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
editableBlockElementOrInlineEditingHost
)
)
{
editableBlockElementOrInlineEditingHost
=
mScanStartPoint
.
ContainerAs
<
nsIContent
>
(
)
;
}
for
(
nsIContent
*
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
point
.
ContainerAs
<
nsIContent
>
(
)
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mEditingHost
)
;
previousContent
;
previousContent
=
HTMLEditUtils
:
:
GetPreviousLeafContentOrPreviousBlockElement
(
*
previousContent
*
editableBlockElementOrInlineEditingHost
{
LeafNodeType
:
:
LeafNodeOrNonEditableNode
}
mEditingHost
)
)
{
if
(
!
previousContent
-
>
IsText
(
)
|
|
!
previousContent
-
>
IsEditable
(
)
)
{
if
(
previousContent
=
=
GetStartReasonContent
(
)
)
{
break
;
}
continue
;
}
return
EditorDOMPointType
(
previousContent
-
>
AsText
(
)
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
?
previousContent
-
>
AsText
(
)
-
>
TextLength
(
)
-
1
:
0
)
;
}
return
EditorDOMPointType
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
GetAfterLastVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
{
EditorDOMPoint
atLastCharOfTextNode
(
&
aTextNode
AssertedCast
<
uint32_t
>
(
std
:
:
max
<
int64_t
>
(
static_cast
<
int64_t
>
(
aTextNode
.
Length
(
)
)
-
1
0
)
)
)
;
if
(
!
atLastCharOfTextNode
.
IsContainerEmpty
(
)
&
&
!
atLastCharOfTextNode
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
aTextNode
)
;
}
TextFragmentData
textFragmentData
(
atLastCharOfTextNode
aAncestorLimiter
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
EditorDOMRange
&
invisibleWhiteSpaceRange
=
textFragmentData
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
!
invisibleWhiteSpaceRange
.
IsPositioned
(
)
|
|
invisibleWhiteSpaceRange
.
Collapsed
(
)
)
{
return
EditorDOMPointType
:
:
AtEndOf
(
aTextNode
)
;
}
return
invisibleWhiteSpaceRange
.
StartRef
(
)
.
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
GetFirstVisiblePoint
(
Text
&
aTextNode
const
Element
*
aAncestorLimiter
)
{
EditorDOMPoint
atStartOfTextNode
(
&
aTextNode
0
)
;
if
(
!
atStartOfTextNode
.
IsContainerEmpty
(
)
&
&
atStartOfTextNode
.
IsCharCollapsibleASCIISpace
(
)
)
{
return
atStartOfTextNode
.
To
<
EditorDOMPointType
>
(
)
;
}
TextFragmentData
textFragmentData
(
atStartOfTextNode
aAncestorLimiter
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
EditorDOMPointType
(
)
;
}
const
EditorDOMRange
&
invisibleWhiteSpaceRange
=
textFragmentData
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
!
invisibleWhiteSpaceRange
.
IsPositioned
(
)
|
|
invisibleWhiteSpaceRange
.
Collapsed
(
)
)
{
return
atStartOfTextNode
.
To
<
EditorDOMPointType
>
(
)
;
}
return
invisibleWhiteSpaceRange
.
EndRef
(
)
.
To
<
EditorDOMPointType
>
(
)
;
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanFollowingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtNextVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtNextVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
&
&
aAtNextVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanNextNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanFollowingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
aPoint
)
;
if
(
!
nextVisibleCharOffset
.
isSome
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atNextVisibleChar
(
aPoint
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanFollowingWhiteSpaces
(
atNextVisibleChar
)
)
{
return
atNextVisibleChar
;
}
hasSeenPreformattedNewLine
|
=
atNextVisibleChar
.
IsCharPreformattedNewLine
(
)
;
nextVisibleCharOffset
=
HTMLEditUtils
:
:
GetNextNonCollapsibleCharOffset
(
atNextVisibleChar
)
;
if
(
nextVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atNextVisibleChar
.
ContainerAs
<
Text
>
(
)
nextVisibleCharOffset
.
value
(
)
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsAtLastContent
(
)
)
{
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
afterLastWhiteSpace
=
EditorDOMPointInText
:
:
AtEndOf
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
;
for
(
EditorDOMPointInText
atEndOfPreviousTextNode
=
afterLastWhiteSpace
;
;
)
{
const
auto
atStartOfNextTextNode
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atEndOfPreviousTextNode
)
;
if
(
!
atStartOfNextTextNode
.
IsSet
(
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atStartOfNextTextNode
.
IsContainerEmpty
(
)
)
{
atEndOfPreviousTextNode
=
atStartOfNextTextNode
;
continue
;
}
if
(
!
atStartOfNextTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanFollowingWhiteSpaces
(
atStartOfNextTextNode
)
)
{
return
afterLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atNextVisibleChar
(
ScanNextNonCollapsibleChar
(
atStartOfNextTextNode
)
)
;
if
(
atNextVisibleChar
.
IsSet
(
)
)
{
return
atNextVisibleChar
.
To
<
EditorDOMPointType
>
(
)
;
}
afterLastWhiteSpace
=
atEndOfPreviousTextNode
=
EditorDOMPointInText
:
:
AtEndOf
(
*
atStartOfNextTextNode
.
ContainerAs
<
Text
>
(
)
)
;
}
}
template
<
typename
EditorDOMPointType
>
EditorDOMPointType
WSRunScanner
:
:
TextFragmentData
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
const
EditorDOMPointInText
&
aPointAtASCIIWhiteSpace
nsIEditor
:
:
EDirection
aDirectionToDelete
)
const
{
MOZ_ASSERT
(
aDirectionToDelete
=
=
nsIEditor
:
:
eNone
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
eNext
|
|
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
)
;
MOZ_ASSERT
(
aPointAtASCIIWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
!
aPointAtASCIIWhiteSpace
.
IsEndOfContainer
(
)
)
;
MOZ_ASSERT_IF
(
!
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharCollapsibleASCIISpace
(
)
)
;
MOZ_ASSERT_IF
(
EditorUtils
:
:
IsNewLinePreformatted
(
*
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
aPointAtASCIIWhiteSpace
.
IsCharASCIISpace
(
)
)
;
bool
hasSeenPreformattedNewLine
=
aPointAtASCIIWhiteSpace
.
IsCharPreformattedNewLine
(
)
;
auto
NeedToScanPrecedingWhiteSpaces
=
[
&
hasSeenPreformattedNewLine
&
aDirectionToDelete
]
(
const
EditorDOMPointInText
&
aAtPreviousVisibleCharacter
)
-
>
bool
{
MOZ_ASSERT
(
!
aAtPreviousVisibleCharacter
.
IsEndOfContainer
(
)
)
;
return
!
hasSeenPreformattedNewLine
&
&
aDirectionToDelete
=
=
nsIEditor
:
:
ePrevious
&
&
aAtPreviousVisibleCharacter
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
;
}
;
auto
ScanPreviousNonCollapsibleChar
=
[
&
hasSeenPreformattedNewLine
&
NeedToScanPrecedingWhiteSpaces
]
(
const
EditorDOMPointInText
&
aPoint
)
-
>
EditorDOMPointInText
{
Maybe
<
uint32_t
>
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
aPoint
)
;
if
(
previousVisibleCharOffset
.
isNothing
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
EditorDOMPointInText
atPreviousVisibleCharacter
(
aPoint
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
)
;
if
(
!
NeedToScanPrecedingWhiteSpaces
(
atPreviousVisibleCharacter
)
)
{
return
atPreviousVisibleCharacter
.
NextPoint
(
)
;
}
hasSeenPreformattedNewLine
|
=
atPreviousVisibleCharacter
.
IsCharPreformattedNewLine
(
)
;
previousVisibleCharOffset
=
HTMLEditUtils
:
:
GetPreviousNonCollapsibleCharOffset
(
atPreviousVisibleCharacter
)
;
if
(
previousVisibleCharOffset
.
isSome
(
)
)
{
MOZ_ASSERT
(
aPoint
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
)
;
return
EditorDOMPointInText
(
atPreviousVisibleCharacter
.
ContainerAs
<
Text
>
(
)
previousVisibleCharOffset
.
value
(
)
+
1
)
;
}
return
EditorDOMPointInText
(
)
;
}
;
if
(
!
aPointAtASCIIWhiteSpace
.
IsStartOfContainer
(
)
)
{
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
aPointAtASCIIWhiteSpace
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
}
EditorDOMPointInText
atLastWhiteSpace
=
EditorDOMPointInText
(
aPointAtASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
0u
)
;
for
(
EditorDOMPointInText
atStartOfPreviousTextNode
=
atLastWhiteSpace
;
;
)
{
const
EditorDOMPointInText
atLastCharOfPreviousTextNode
=
GetPreviousEditableCharPoint
(
atStartOfPreviousTextNode
)
;
if
(
!
atLastCharOfPreviousTextNode
.
IsSet
(
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
if
(
atLastCharOfPreviousTextNode
.
IsContainerEmpty
(
)
)
{
atStartOfPreviousTextNode
=
atLastCharOfPreviousTextNode
;
continue
;
}
if
(
!
atLastCharOfPreviousTextNode
.
IsCharCollapsibleASCIISpace
(
)
&
&
!
NeedToScanPrecedingWhiteSpaces
(
atLastCharOfPreviousTextNode
)
)
{
return
atLastWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
const
EditorDOMPointInText
atFirstASCIIWhiteSpace
(
ScanPreviousNonCollapsibleChar
(
atLastCharOfPreviousTextNode
)
)
;
if
(
atFirstASCIIWhiteSpace
.
IsSet
(
)
)
{
return
atFirstASCIIWhiteSpace
.
To
<
EditorDOMPointType
>
(
)
;
}
atLastWhiteSpace
=
atStartOfPreviousTextNode
=
EditorDOMPointInText
(
atLastCharOfPreviousTextNode
.
ContainerAs
<
Text
>
(
)
0u
)
;
}
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
ReplaceTextAndRemoveEmptyTextNodes
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMRangeInTexts
&
aRangeToReplace
const
nsAString
&
aReplaceString
)
{
MOZ_ASSERT
(
aRangeToReplace
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
StartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
EndRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRangeToReplace
.
StartRef
(
)
.
IsBefore
(
aRangeToReplace
.
EndRef
(
)
)
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
aRangeToReplace
.
InSameContainer
(
)
?
aRangeToReplace
.
EndRef
(
)
.
Offset
(
)
-
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
:
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
-
>
TextLength
(
)
-
aRangeToReplace
.
StartRef
(
)
.
Offset
(
)
aReplaceString
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
aRangeToReplace
.
InSameContainer
(
)
)
{
return
NS_OK
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
aRangeToReplace
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
aRangeToReplace
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
char16_t
WSRunScanner
:
:
GetCharAt
(
Text
*
aTextNode
uint32_t
aOffset
)
const
{
if
(
NS_WARN_IF
(
!
aTextNode
)
|
|
NS_WARN_IF
(
aOffset
>
=
aTextNode
-
>
TextDataLength
(
)
)
)
{
return
0
;
}
return
aTextNode
-
>
TextFragment
(
)
.
CharAt
(
aOffset
)
;
}
template
<
typename
EditorDOMPointType
>
nsresult
WhiteSpaceVisibilityKeeper
:
:
NormalizeVisibleWhiteSpacesAt
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointType
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsInContentNode
(
)
)
;
MOZ_ASSERT
(
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
)
;
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentData
(
aPoint
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
textFragmentData
.
FoundNoBreakingWhiteSpaces
(
)
)
{
return
NS_OK
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
textFragmentData
.
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
IsInitialized
(
)
)
{
return
NS_OK
;
}
if
(
!
StaticPrefs
:
:
editor_white_space_normalization_blink_compatible
(
)
)
{
const
EditorDOMPoint
&
atEndOfVisibleWhiteSpaces
=
visibleWhiteSpaces
.
EndRef
(
)
;
EditorDOMPointInText
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atEndOfVisibleWhiteSpaces
)
;
if
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
|
|
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfVisibleWhiteSpaces
)
;
bool
isPreviousCharCollapsibleASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
;
const
bool
maybeNBSPFollowsVisibleContent
=
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
isPreviousCharCollapsibleASCIIWhiteSpace
)
|
|
(
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
(
visibleWhiteSpaces
.
StartsFromNonCollapsibleCharacters
(
)
|
|
visibleWhiteSpaces
.
StartsFromSpecialContent
(
)
)
)
;
bool
followedByVisibleContent
=
visibleWhiteSpaces
.
EndsByNonCollapsibleCharacters
(
)
|
|
visibleWhiteSpaces
.
EndsBySpecialContent
(
)
;
bool
followedByBRElement
=
visibleWhiteSpaces
.
EndsByBRElement
(
)
;
bool
followedByPreformattedLineBreak
=
visibleWhiteSpaces
.
EndsByPreformattedLineBreak
(
)
;
if
(
maybeNBSPFollowsVisibleContent
|
|
isPreviousCharCollapsibleASCIIWhiteSpace
)
{
if
(
visibleWhiteSpaces
.
EndsByBlockBoundary
(
)
&
&
aPoint
.
IsInContentNode
(
)
)
{
bool
insertBRElement
=
HTMLEditUtils
:
:
IsBlockElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
)
;
if
(
!
insertBRElement
)
{
NS_ASSERTION
(
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
"
Given
content
is
not
editable
"
)
;
NS_ASSERTION
(
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
-
>
GetAsElementOrParentElement
(
)
"
Given
content
is
not
an
element
and
an
orphan
node
"
)
;
const
Element
*
editableBlockElement
=
EditorUtils
:
:
IsEditableContent
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
EditorType
:
:
HTML
)
?
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aPoint
.
template
ContainerAs
<
nsIContent
>
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElement
)
:
nullptr
;
insertBRElement
=
!
!
editableBlockElement
;
}
if
(
insertBRElement
)
{
const
CreateElementResult
insertBRElementResult
=
aHTMLEditor
.
InsertBRElement
(
HTMLEditor
:
:
WithTransaction
:
:
Yes
atEndOfVisibleWhiteSpaces
)
;
if
(
insertBRElementResult
.
isErr
(
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElement
(
WithTransaction
:
:
Yes
)
failed
"
)
;
return
insertBRElementResult
.
unwrapErr
(
)
;
}
nsresult
rv
=
insertBRElementResult
.
SuggestCaretPointTo
(
aHTMLEditor
{
SuggestCaret
:
:
OnlyIfHasSuggestion
SuggestCaret
:
:
OnlyIfTransactionsAllowedToDoIt
SuggestCaret
:
:
AndIgnoreTrivialError
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
"
)
;
return
rv
;
}
NS_WARNING_ASSERTION
(
rv
!
=
NS_SUCCESS_EDITOR_BUT_IGNORED_TRIVIAL_ERROR
"
CreateElementResult
:
:
SuggestCaretPointTo
(
)
failed
but
ignored
"
)
;
MOZ_ASSERT
(
insertBRElementResult
.
GetNewNode
(
)
)
;
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atEndOfVisibleWhiteSpaces
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
)
)
)
{
return
NS_ERROR_EDITOR_UNEXPECTED_DOM_TREE
;
}
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfVisibleWhiteSpaces
)
;
isPreviousCharCollapsibleASCIIWhiteSpace
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
;
followedByBRElement
=
true
;
followedByVisibleContent
=
followedByPreformattedLineBreak
=
false
;
}
}
if
(
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
)
{
return
NS_OK
;
}
if
(
maybeNBSPFollowsVisibleContent
&
&
(
followedByVisibleContent
|
|
followedByBRElement
)
&
&
!
visibleWhiteSpaces
.
StartsFromPreformattedLineBreak
(
)
)
{
MOZ_ASSERT
(
!
followedByPreformattedLineBreak
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
atPreviousCharOfEndOfVisibleWhiteSpaces
.
Offset
(
)
1
u
"
"
_ns
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
if
(
maybeNBSPFollowsVisibleContent
|
|
!
isPreviousCharCollapsibleASCIIWhiteSpace
|
|
!
(
followedByVisibleContent
|
|
followedByBRElement
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
)
;
const
EditorDOMPointInText
atFirstASCIIWhiteSpace
=
textFragmentData
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
nsIEditor
:
:
eNone
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
uint32_t
numberOfASCIIWhiteSpacesInStartNode
=
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
?
atPreviousCharOfEndOfVisibleWhiteSpaces
.
Offset
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
:
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
-
>
Length
(
)
-
atFirstASCIIWhiteSpace
.
Offset
(
)
;
uint32_t
replaceLengthInStartNode
=
numberOfASCIIWhiteSpacesInStartNode
+
(
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
ContainerAs
<
Text
>
(
)
?
1
:
0
)
;
nsresult
rv
=
aHTMLEditor
.
ReplaceTextWithTransaction
(
MOZ_KnownLive
(
*
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atFirstASCIIWhiteSpace
.
Offset
(
)
replaceLengthInStartNode
textFragmentData
.
StartsFromPreformattedLineBreak
(
)
&
&
textFragmentData
.
EndsByPreformattedLineBreak
(
)
?
u
"
\
x00A0
\
x00A0
"
_ns
:
(
textFragmentData
.
EndsByPreformattedLineBreak
(
)
?
u
"
\
x00A0
"
_ns
:
u
"
\
x00A0
"
_ns
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
ReplaceTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
atFirstASCIIWhiteSpace
.
GetContainer
(
)
=
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
GetContainer
(
)
)
{
return
NS_OK
;
}
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
EditorDOMPointInText
:
:
AtEndOf
(
*
atFirstASCIIWhiteSpace
.
ContainerAs
<
Text
>
(
)
)
atPreviousCharOfEndOfVisibleWhiteSpaces
.
NextPoint
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
"
)
;
return
rv
;
}
const
EditorDOMPoint
&
atEndOfVisibleWhiteSpaces
=
visibleWhiteSpaces
.
EndRef
(
)
;
const
EditorDOMPointInText
atPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atEndOfVisibleWhiteSpaces
)
;
if
(
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
|
|
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleNBSP
(
)
|
|
visibleWhiteSpaces
.
EndsByPreformattedLineBreak
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
startToDelete
endToDelete
;
const
EditorDOMPointInText
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
=
textFragmentData
.
GetPreviousEditableCharPoint
(
atPreviousCharOfEndOfVisibleWhiteSpaces
)
;
if
(
atPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharNBSP
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsSet
(
)
&
&
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
.
IsCharCollapsibleASCIISpace
(
)
)
{
startToDelete
=
textFragmentData
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
nsIEditor
:
:
eNone
)
;
endToDelete
=
atPreviousCharOfPreviousCharOfEndOfVisibleWhiteSpaces
;
}
else
{
startToDelete
=
endToDelete
=
atPreviousCharOfEndOfVisibleWhiteSpaces
.
NextPoint
(
)
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
aHTMLEditor
)
;
Result
<
EditorDOMPoint
nsresult
>
result
=
aHTMLEditor
.
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
startToDelete
endToDelete
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
HTMLEditor
:
:
DeleteDirection
:
:
Forward
)
;
NS_WARNING_ASSERTION
(
!
result
.
isOk
(
)
"
HTMLEditor
:
:
DeleteTextAndNormalizeSurroundingWhiteSpaces
(
)
failed
"
)
;
return
result
.
isErr
(
)
?
result
.
unwrapErr
(
)
:
NS_OK
;
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetPreviousNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
EndOfFragment
"
Previous
char
of
aPoint
should
be
in
the
visible
white
-
spaces
"
)
;
const
EditorDOMPointInText
atPreviousChar
=
GetPreviousEditableCharPoint
(
aPointToInsert
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
|
|
atPreviousChar
.
IsEndOfContainer
(
)
|
|
!
atPreviousChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
EditorDOMPointInText
atPreviousCharOfPreviousChar
=
GetPreviousEditableCharPoint
(
atPreviousChar
)
;
if
(
atPreviousCharOfPreviousChar
.
IsSet
(
)
)
{
if
(
atPreviousChar
.
ContainerAs
<
Text
>
(
)
!
=
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atPreviousCharOfPreviousChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atPreviousCharOfPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfPreviousChar
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
StartsFromNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
StartsFromSpecialContent
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atPreviousChar
;
}
EditorDOMPointInText
WSRunScanner
:
:
TextFragmentData
:
:
GetInclusiveNextNBSPPointIfNeedToReplaceWithASCIIWhiteSpace
(
const
EditorDOMPoint
&
aPointToInsert
)
const
{
MOZ_ASSERT
(
aPointToInsert
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
VisibleWhiteSpacesDataRef
(
)
.
IsInitialized
(
)
)
;
NS_ASSERTION
(
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
StartOfFragment
|
|
VisibleWhiteSpacesDataRef
(
)
.
ComparePoint
(
aPointToInsert
)
=
=
PointPosition
:
:
MiddleOfFragment
"
Inclusive
next
char
of
aPointToInsert
should
be
in
the
visible
"
"
white
-
spaces
"
)
;
auto
atNextChar
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPointToInsert
)
;
if
(
!
atNextChar
.
IsSet
(
)
|
|
NS_WARN_IF
(
atNextChar
.
IsEndOfContainer
(
)
)
|
|
!
atNextChar
.
IsCharNBSP
(
)
|
|
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextChar
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
const
auto
atNextCharOfNextCharOfNBSP
=
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
atNextChar
.
NextPoint
<
EditorRawDOMPointInText
>
(
)
)
;
if
(
atNextCharOfNextCharOfNBSP
.
IsSet
(
)
)
{
if
(
atNextChar
.
ContainerAs
<
Text
>
(
)
!
=
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
&
&
EditorUtils
:
:
IsWhiteSpacePreformatted
(
*
atNextCharOfNextCharOfNBSP
.
ContainerAs
<
Text
>
(
)
)
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
atNextCharOfNextCharOfNBSP
.
IsEndOfContainer
(
)
&
&
atNextCharOfNextCharOfNBSP
.
IsCharASCIISpace
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
const
VisibleWhiteSpacesData
&
visibleWhiteSpaces
=
VisibleWhiteSpacesDataRef
(
)
;
if
(
!
visibleWhiteSpaces
.
EndsByNonCollapsibleCharacters
(
)
&
&
!
visibleWhiteSpaces
.
EndsBySpecialContent
(
)
&
&
!
visibleWhiteSpaces
.
EndsByBRElement
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
atNextChar
;
}
nsresult
WhiteSpaceVisibilityKeeper
:
:
DeleteInvisibleASCIIWhiteSpaces
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
TextFragmentData
textFragmentData
(
aPoint
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentData
.
IsInitialized
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
textFragmentData
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
textFragmentData
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
DebugOnly
<
bool
>
leadingWhiteSpacesDeleted
=
false
;
if
(
leadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
leadingWhiteSpaceRange
.
Collapsed
(
)
)
{
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
leadingWhiteSpaceRange
.
StartRef
(
)
leadingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
to
"
"
delete
leading
white
-
spaces
"
)
;
return
rv
;
}
leadingWhiteSpacesDeleted
=
true
;
}
if
(
trailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
trailingWhiteSpaceRange
.
Collapsed
(
)
&
&
leadingWhiteSpaceRange
!
=
trailingWhiteSpaceRange
)
{
NS_ASSERTION
(
!
leadingWhiteSpacesDeleted
"
We
'
re
trying
to
remove
trailing
white
-
spaces
with
maybe
"
"
outdated
range
"
)
;
nsresult
rv
=
aHTMLEditor
.
DeleteTextAndTextNodesWithTransaction
(
trailingWhiteSpaceRange
.
StartRef
(
)
trailingWhiteSpaceRange
.
EndRef
(
)
HTMLEditor
:
:
TreatEmptyTextNodes
:
:
KeepIfContainerOfRangeBoundaries
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextAndTextNodesWithTransaction
(
)
failed
to
"
"
delete
trailing
white
-
spaces
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
EditorDOMRangeInTexts
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
const
TextFragmentData
&
aStart
const
TextFragmentData
&
aEnd
)
{
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEnd
.
ScanStartRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
EqualsOrIsBefore
(
aEnd
.
ScanStartRef
(
)
)
)
;
MOZ_ASSERT
(
aStart
.
ScanStartRef
(
)
.
IsInTextNode
(
)
)
;
MOZ_ASSERT
(
aEnd
.
ScanStartRef
(
)
.
IsInTextNode
(
)
)
;
const
EditorDOMRange
&
invisibleLeadingWhiteSpaceRange
=
aStart
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
const
EditorDOMRange
&
invisibleTrailingWhiteSpaceRange
=
aEnd
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
const
bool
hasInvisibleLeadingWhiteSpaces
=
invisibleLeadingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpaceRange
.
Collapsed
(
)
;
const
bool
hasInvisibleTrailingWhiteSpaces
=
invisibleLeadingWhiteSpaceRange
!
=
invisibleTrailingWhiteSpaceRange
&
&
invisibleTrailingWhiteSpaceRange
.
IsPositioned
(
)
&
&
!
invisibleTrailingWhiteSpaceRange
.
Collapsed
(
)
;
EditorDOMRangeInTexts
result
(
aStart
.
ScanStartRef
(
)
.
AsInText
(
)
aEnd
.
ScanStartRef
(
)
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
if
(
!
hasInvisibleLeadingWhiteSpaces
&
&
!
hasInvisibleTrailingWhiteSpaces
)
{
return
result
;
}
MOZ_ASSERT_IF
(
hasInvisibleLeadingWhiteSpaces
&
&
hasInvisibleTrailingWhiteSpaces
invisibleLeadingWhiteSpaceRange
.
StartRef
(
)
.
IsBefore
(
invisibleTrailingWhiteSpaceRange
.
StartRef
(
)
)
)
;
const
EditorDOMPoint
&
aroundFirstInvisibleWhiteSpace
=
hasInvisibleLeadingWhiteSpaces
?
invisibleLeadingWhiteSpaceRange
.
StartRef
(
)
:
invisibleTrailingWhiteSpaceRange
.
StartRef
(
)
;
if
(
aroundFirstInvisibleWhiteSpace
.
IsBefore
(
result
.
StartRef
(
)
)
)
{
if
(
aroundFirstInvisibleWhiteSpace
.
IsInTextNode
(
)
)
{
result
.
SetStart
(
aroundFirstInvisibleWhiteSpace
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
}
else
{
const
auto
atFirstInvisibleWhiteSpace
=
hasInvisibleLeadingWhiteSpaces
?
aStart
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aroundFirstInvisibleWhiteSpace
)
:
aEnd
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aroundFirstInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
atFirstInvisibleWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
atFirstInvisibleWhiteSpace
.
EqualsOrIsBefore
(
result
.
StartRef
(
)
)
)
;
result
.
SetStart
(
atFirstInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
}
}
MOZ_ASSERT_IF
(
hasInvisibleLeadingWhiteSpaces
&
&
hasInvisibleTrailingWhiteSpaces
invisibleLeadingWhiteSpaceRange
.
EndRef
(
)
.
IsBefore
(
invisibleTrailingWhiteSpaceRange
.
EndRef
(
)
)
)
;
const
EditorDOMPoint
&
afterLastInvisibleWhiteSpace
=
hasInvisibleTrailingWhiteSpaces
?
invisibleTrailingWhiteSpaceRange
.
EndRef
(
)
:
invisibleLeadingWhiteSpaceRange
.
EndRef
(
)
;
if
(
afterLastInvisibleWhiteSpace
.
EqualsOrIsBefore
(
result
.
EndRef
(
)
)
)
{
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
if
(
afterLastInvisibleWhiteSpace
.
IsInTextNode
(
)
)
{
result
.
SetEnd
(
afterLastInvisibleWhiteSpace
.
AsInText
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
const
auto
atLastInvisibleWhiteSpace
=
hasInvisibleTrailingWhiteSpaces
?
aEnd
.
GetPreviousEditableCharPoint
(
afterLastInvisibleWhiteSpace
)
:
aStart
.
GetPreviousEditableCharPoint
(
afterLastInvisibleWhiteSpace
)
;
MOZ_ASSERT
(
atLastInvisibleWhiteSpace
.
IsSet
(
)
)
;
MOZ_ASSERT
(
atLastInvisibleWhiteSpace
.
IsContainerEmpty
(
)
|
|
atLastInvisibleWhiteSpace
.
IsAtLastContent
(
)
)
;
MOZ_ASSERT
(
result
.
EndRef
(
)
.
EqualsOrIsBefore
(
atLastInvisibleWhiteSpace
)
)
;
result
.
SetEnd
(
atLastInvisibleWhiteSpace
.
IsEndOfContainer
(
)
?
atLastInvisibleWhiteSpace
:
atLastInvisibleWhiteSpace
.
NextPoint
(
)
)
;
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
Result
<
EditorDOMRangeInTexts
nsresult
>
WSRunScanner
:
:
GetRangeInTextNodesToBackspaceFrom
(
Element
*
aEditingHost
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
TextFragmentData
textFragmentDataAtCaret
(
aPoint
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtCaret
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMPointInText
atPreviousChar
=
textFragmentDataAtCaret
.
GetPreviousEditableCharPoint
(
aPoint
)
;
if
(
!
atPreviousChar
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
atPreviousChar
.
IsEndOfContainer
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
atNextChar
=
atPreviousChar
.
NextPoint
(
)
;
if
(
!
atPreviousChar
.
IsStartOfContainer
(
)
)
{
if
(
atPreviousChar
.
IsCharLowSurrogateFollowingHighSurrogate
(
)
)
{
atPreviousChar
=
atPreviousChar
.
PreviousPoint
(
)
;
}
else
if
(
atPreviousChar
.
IsCharHighSurrogateFollowedByLowSurrogate
(
)
)
{
atNextChar
=
atNextChar
.
NextPoint
(
)
;
}
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
atPreviousChar
.
IsCharCollapsibleASCIISpace
(
)
|
|
atPreviousChar
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
const
EditorDOMPointInText
startToDelete
=
textFragmentDataAtCaret
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atPreviousChar
nsIEditor
:
:
ePrevious
)
;
if
(
!
startToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMPointInText
endToDelete
=
textFragmentDataAtCaret
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atPreviousChar
nsIEditor
:
:
ePrevious
)
;
if
(
!
endToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rangeToDelete
=
EditorDOMRangeInTexts
(
startToDelete
endToDelete
)
;
}
else
{
rangeToDelete
=
EditorDOMRangeInTexts
(
atPreviousChar
atNextChar
)
;
}
if
(
rangeToDelete
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
TextFragmentData
textFragmentDataAtStart
=
rangeToDelete
.
StartRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
StartRef
(
)
aEditingHost
)
:
textFragmentDataAtCaret
;
TextFragmentData
textFragmentDataAtEnd
=
rangeToDelete
.
EndRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
EndRef
(
)
aEditingHost
)
:
textFragmentDataAtCaret
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRangeInTexts
extendedRangeToDelete
=
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
textFragmentDataAtStart
textFragmentDataAtEnd
)
;
MOZ_ASSERT
(
extendedRangeToDelete
.
IsPositionedAndValid
(
)
)
;
return
extendedRangeToDelete
.
IsPositioned
(
)
?
extendedRangeToDelete
:
rangeToDelete
;
}
Result
<
EditorDOMRangeInTexts
nsresult
>
WSRunScanner
:
:
GetRangeInTextNodesToForwardDeleteFrom
(
Element
*
aEditingHost
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
TextFragmentData
textFragmentDataAtCaret
(
aPoint
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtCaret
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
auto
atCaret
=
textFragmentDataAtCaret
.
GetInclusiveNextEditableCharPoint
<
EditorDOMPointInText
>
(
aPoint
)
;
if
(
!
atCaret
.
IsSet
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
if
(
!
atCaret
.
IsEndOfContainer
(
)
&
&
atCaret
.
IsCharLowSurrogateFollowingHighSurrogate
(
)
)
{
atCaret
=
atCaret
.
NextPoint
(
)
;
}
if
(
atCaret
.
IsEndOfContainer
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
EditorDOMPointInText
atNextChar
=
atCaret
.
NextPoint
(
)
;
if
(
atCaret
.
IsCharHighSurrogateFollowedByLowSurrogate
(
)
)
{
atNextChar
=
atNextChar
.
NextPoint
(
)
;
}
EditorDOMRangeInTexts
rangeToDelete
;
if
(
atCaret
.
IsCharCollapsibleASCIISpace
(
)
|
|
atCaret
.
IsCharPreformattedNewLineCollapsedWithWhiteSpaces
(
)
)
{
const
EditorDOMPointInText
startToDelete
=
textFragmentDataAtCaret
.
GetFirstASCIIWhiteSpacePointCollapsedTo
(
atCaret
nsIEditor
:
:
eNext
)
;
if
(
!
startToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetFirstASCIIWhiteSpacePointCollapsedTo
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
const
EditorDOMPointInText
endToDelete
=
textFragmentDataAtCaret
.
GetEndOfCollapsibleASCIIWhiteSpaces
(
atCaret
nsIEditor
:
:
eNext
)
;
if
(
!
endToDelete
.
IsSet
(
)
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetEndOfCollapsibleASCIIWhiteSpaces
(
)
failed
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
rangeToDelete
=
EditorDOMRangeInTexts
(
startToDelete
endToDelete
)
;
}
else
{
rangeToDelete
=
EditorDOMRangeInTexts
(
atCaret
atNextChar
)
;
}
if
(
rangeToDelete
.
Collapsed
(
)
)
{
return
EditorDOMRangeInTexts
(
)
;
}
TextFragmentData
textFragmentDataAtStart
=
rangeToDelete
.
StartRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
StartRef
(
)
aEditingHost
)
:
textFragmentDataAtCaret
;
TextFragmentData
textFragmentDataAtEnd
=
rangeToDelete
.
EndRef
(
)
!
=
aPoint
?
TextFragmentData
(
rangeToDelete
.
EndRef
(
)
aEditingHost
)
:
textFragmentDataAtCaret
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
|
|
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
EditorDOMRangeInTexts
extendedRangeToDelete
=
WSRunScanner
:
:
ComputeRangeInTextNodesContainingInvisibleWhiteSpaces
(
textFragmentDataAtStart
textFragmentDataAtEnd
)
;
MOZ_ASSERT
(
extendedRangeToDelete
.
IsPositionedAndValid
(
)
)
;
return
extendedRangeToDelete
.
IsPositioned
(
)
?
extendedRangeToDelete
:
rangeToDelete
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangesForDeletingAtomicContent
(
Element
*
aEditingHost
const
nsIContent
&
aAtomicContent
)
{
if
(
aAtomicContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
TextFragmentData
textFragmentDataAfterBRElement
(
EditorDOMPoint
:
:
After
(
aAtomicContent
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAfterBRElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
followingInvisibleWhiteSpaces
=
textFragmentDataAfterBRElement
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAfterBRElement
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
return
followingInvisibleWhiteSpaces
.
IsPositioned
(
)
&
&
!
followingInvisibleWhiteSpaces
.
Collapsed
(
)
?
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
:
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
if
(
!
HTMLEditUtils
:
:
IsBlockElement
(
aAtomicContent
)
)
{
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
TextFragmentData
textFragmentDataBeforeAtomicContent
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataBeforeAtomicContent
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
precedingInvisibleWhiteSpaces
=
textFragmentDataBeforeAtomicContent
.
GetNonCollapsedRangeInTexts
(
textFragmentDataBeforeAtomicContent
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
TextFragmentData
textFragmentDataAfterAtomicContent
(
EditorDOMPoint
:
:
After
(
aAtomicContent
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAfterAtomicContent
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
followingInvisibleWhiteSpaces
=
textFragmentDataAfterAtomicContent
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAfterAtomicContent
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
.
IsSet
(
)
&
&
followingInvisibleWhiteSpaces
.
EndRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
;
}
if
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
precedingInvisibleWhiteSpaces
.
StartRef
(
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
if
(
followingInvisibleWhiteSpaces
.
EndRef
(
)
.
IsSet
(
)
)
{
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
followingInvisibleWhiteSpaces
.
EndRef
(
)
)
;
}
return
EditorDOMRange
(
EditorDOMPoint
(
const_cast
<
nsIContent
*
>
(
&
aAtomicContent
)
)
EditorDOMPoint
:
:
After
(
aAtomicContent
)
)
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangeForDeletingBlockElementBoundaries
(
const
HTMLEditor
&
aHTMLEditor
const
Element
&
aLeftBlockElement
const
Element
&
aRightBlockElement
const
EditorDOMPoint
&
aPointContainingTheOtherBlock
)
{
MOZ_ASSERT
(
&
aLeftBlockElement
!
=
&
aRightBlockElement
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
IsSet
(
)
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
|
|
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
aRightBlockElement
.
IsInclusiveDescendantOf
(
aPointContainingTheOtherBlock
.
GetChild
(
)
)
)
;
MOZ_ASSERT_IF
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
aLeftBlockElement
.
IsInclusiveDescendantOf
(
aPointContainingTheOtherBlock
.
GetChild
(
)
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
!
aRightBlockElement
.
IsInclusiveDescendantOf
(
&
aLeftBlockElement
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
!
aLeftBlockElement
.
IsInclusiveDescendantOf
(
&
aRightBlockElement
)
)
;
MOZ_ASSERT_IF
(
!
aPointContainingTheOtherBlock
.
IsSet
(
)
EditorRawDOMPoint
(
const_cast
<
Element
*
>
(
&
aLeftBlockElement
)
)
.
IsBefore
(
EditorRawDOMPoint
(
const_cast
<
Element
*
>
(
&
aRightBlockElement
)
)
)
)
;
const
Element
*
editingHost
=
aHTMLEditor
.
ComputeEditingHost
(
)
;
EditorDOMRange
range
;
TextFragmentData
textFragmentDataAtEndOfLeftBlockElement
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aLeftBlockElement
?
aPointContainingTheOtherBlock
:
EditorDOMPoint
:
:
AtEndOf
(
const_cast
<
Element
&
>
(
aLeftBlockElement
)
)
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEndOfLeftBlockElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
if
(
textFragmentDataAtEndOfLeftBlockElement
.
StartsFromInvisibleBRElement
(
)
)
{
range
.
SetStart
(
EditorDOMPoint
(
textFragmentDataAtEndOfLeftBlockElement
.
StartReasonBRElementPtr
(
)
)
)
;
}
else
{
const
EditorDOMRange
&
trailingWhiteSpaceRange
=
textFragmentDataAtEndOfLeftBlockElement
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
;
if
(
trailingWhiteSpaceRange
.
StartRef
(
)
.
IsSet
(
)
)
{
range
.
SetStart
(
trailingWhiteSpaceRange
.
StartRef
(
)
)
;
}
else
{
range
.
SetStart
(
textFragmentDataAtEndOfLeftBlockElement
.
ScanStartRef
(
)
)
;
}
}
TextFragmentData
textFragmentDataAtStartOfRightBlockElement
(
aPointContainingTheOtherBlock
.
GetContainer
(
)
=
=
&
aRightBlockElement
&
&
!
aPointContainingTheOtherBlock
.
IsEndOfContainer
(
)
?
aPointContainingTheOtherBlock
.
NextPoint
(
)
:
EditorDOMPoint
(
const_cast
<
Element
*
>
(
&
aRightBlockElement
)
0u
)
editingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStartOfRightBlockElement
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRange
&
leadingWhiteSpaceRange
=
textFragmentDataAtStartOfRightBlockElement
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
;
if
(
leadingWhiteSpaceRange
.
EndRef
(
)
.
IsSet
(
)
)
{
range
.
SetEnd
(
leadingWhiteSpaceRange
.
EndRef
(
)
)
;
}
else
{
range
.
SetEnd
(
textFragmentDataAtStartOfRightBlockElement
.
ScanStartRef
(
)
)
;
}
return
range
;
}
EditorDOMRange
WSRunScanner
:
:
GetRangeContainingInvisibleWhiteSpacesAtRangeBoundaries
(
Element
*
aEditingHost
const
EditorDOMRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
.
IsPositionedAndValid
(
)
)
;
MOZ_ASSERT
(
aRange
.
EndRef
(
)
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aRange
.
StartRef
(
)
.
IsSetAndValid
(
)
)
;
EditorDOMRange
result
;
TextFragmentData
textFragmentDataAtStart
(
aRange
.
StartRef
(
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtStart
=
textFragmentDataAtStart
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtStart
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtStart
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtStart
.
Collapsed
(
)
)
{
result
.
SetStart
(
invisibleLeadingWhiteSpacesAtStart
.
StartRef
(
)
)
;
}
else
{
const
EditorDOMRangeInTexts
invisibleTrailingWhiteSpacesAtStart
=
textFragmentDataAtStart
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtStart
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleTrailingWhiteSpacesAtStart
.
IsPositioned
(
)
&
&
!
invisibleTrailingWhiteSpacesAtStart
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
invisibleTrailingWhiteSpacesAtStart
.
StartRef
(
)
.
EqualsOrIsBefore
(
aRange
.
StartRef
(
)
)
)
;
result
.
SetStart
(
invisibleTrailingWhiteSpacesAtStart
.
StartRef
(
)
)
;
}
else
if
(
!
aRange
.
StartRef
(
)
.
IsInTextNode
(
)
&
&
textFragmentDataAtStart
.
StartsFromBlockBoundary
(
)
&
&
textFragmentDataAtStart
.
EndRef
(
)
.
IsInTextNode
(
)
)
{
result
.
SetStart
(
textFragmentDataAtStart
.
EndRef
(
)
)
;
}
}
if
(
!
result
.
StartRef
(
)
.
IsSet
(
)
)
{
result
.
SetStart
(
aRange
.
StartRef
(
)
)
;
}
TextFragmentData
textFragmentDataAtEnd
(
aRange
.
EndRef
(
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
EditorDOMRange
(
)
;
}
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtEnd
=
textFragmentDataAtEnd
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtEnd
.
InvisibleTrailingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtEnd
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtEnd
.
Collapsed
(
)
)
{
result
.
SetEnd
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
;
}
else
{
const
EditorDOMRangeInTexts
invisibleLeadingWhiteSpacesAtEnd
=
textFragmentDataAtEnd
.
GetNonCollapsedRangeInTexts
(
textFragmentDataAtEnd
.
InvisibleLeadingWhiteSpaceRangeRef
(
)
)
;
if
(
invisibleLeadingWhiteSpacesAtEnd
.
IsPositioned
(
)
&
&
!
invisibleLeadingWhiteSpacesAtEnd
.
Collapsed
(
)
)
{
MOZ_ASSERT
(
aRange
.
EndRef
(
)
.
EqualsOrIsBefore
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
)
;
result
.
SetEnd
(
invisibleLeadingWhiteSpacesAtEnd
.
EndRef
(
)
)
;
}
else
if
(
!
aRange
.
EndRef
(
)
.
IsInTextNode
(
)
&
&
textFragmentDataAtEnd
.
EndsByBlockBoundary
(
)
&
&
textFragmentDataAtEnd
.
StartRef
(
)
.
IsInTextNode
(
)
)
{
result
.
SetEnd
(
EditorDOMPoint
:
:
AtEndOf
(
*
textFragmentDataAtEnd
.
StartRef
(
)
.
ContainerAs
<
Text
>
(
)
)
)
;
}
}
if
(
!
result
.
EndRef
(
)
.
IsSet
(
)
)
{
result
.
SetEnd
(
aRange
.
EndRef
(
)
)
;
}
MOZ_ASSERT
(
result
.
IsPositionedAndValid
(
)
)
;
return
result
;
}
Result
<
bool
nsresult
>
WSRunScanner
:
:
ShrinkRangeIfStartsFromOrEndsAfterAtomicContent
(
const
HTMLEditor
&
aHTMLEditor
nsRange
&
aRange
const
Element
*
aEditingHost
)
{
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
MOZ_ASSERT
(
!
aRange
.
IsInSelection
(
)
"
Changing
range
in
selection
may
cause
running
script
"
)
;
if
(
NS_WARN_IF
(
!
aRange
.
GetStartContainer
(
)
)
|
|
NS_WARN_IF
(
!
aRange
.
GetEndContainer
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
aRange
.
GetStartContainer
(
)
-
>
IsContent
(
)
|
|
!
aRange
.
GetEndContainer
(
)
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRange
.
GetStartContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
)
!
=
HTMLEditUtils
:
:
GetInclusiveAncestorElement
(
*
aRange
.
GetEndContainer
(
)
-
>
AsContent
(
)
HTMLEditUtils
:
:
ClosestEditableBlockElementExceptHRElement
)
)
{
return
false
;
}
nsIContent
*
startContent
=
nullptr
;
if
(
aRange
.
GetStartContainer
(
)
&
&
aRange
.
GetStartContainer
(
)
-
>
IsText
(
)
&
&
aRange
.
GetStartContainer
(
)
-
>
AsText
(
)
-
>
Length
(
)
=
=
aRange
.
StartOffset
(
)
)
{
TextFragmentData
textFragmentDataAtStart
(
EditorRawDOMPoint
(
aRange
.
StartRef
(
)
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtStart
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
textFragmentDataAtStart
.
EndsByVisibleBRElement
(
)
)
{
startContent
=
textFragmentDataAtStart
.
EndReasonBRElementPtr
(
)
;
}
else
if
(
textFragmentDataAtStart
.
EndsBySpecialContent
(
)
|
|
(
textFragmentDataAtStart
.
EndsByOtherBlockElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
*
textFragmentDataAtStart
.
EndReasonOtherBlockElementPtr
(
)
)
)
)
{
startContent
=
textFragmentDataAtStart
.
GetEndReasonContent
(
)
;
}
}
nsIContent
*
endContent
=
nullptr
;
if
(
aRange
.
GetEndContainer
(
)
&
&
aRange
.
GetEndContainer
(
)
-
>
IsText
(
)
&
&
!
aRange
.
EndOffset
(
)
)
{
TextFragmentData
textFragmentDataAtEnd
(
EditorRawDOMPoint
(
aRange
.
EndRef
(
)
)
aEditingHost
)
;
if
(
NS_WARN_IF
(
!
textFragmentDataAtEnd
.
IsInitialized
(
)
)
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
textFragmentDataAtEnd
.
StartsFromVisibleBRElement
(
)
)
{
endContent
=
textFragmentDataAtEnd
.
StartReasonBRElementPtr
(
)
;
}
else
if
(
textFragmentDataAtEnd
.
StartsFromSpecialContent
(
)
|
|
(
textFragmentDataAtEnd
.
StartsFromOtherBlockElement
(
)
&
&
!
HTMLEditUtils
:
:
IsContainerNode
(
*
textFragmentDataAtEnd
.
StartReasonOtherBlockElementPtr
(
)
)
)
)
{
endContent
=
textFragmentDataAtEnd
.
GetStartReasonContent
(
)
;
}
}
if
(
!
startContent
&
&
!
endContent
)
{
return
false
;
}
nsresult
rv
=
aRange
.
SetStartAndEnd
(
startContent
?
RangeBoundary
(
startContent
-
>
GetParentNode
(
)
startContent
-
>
GetPreviousSibling
(
)
)
:
aRange
.
StartRef
(
)
endContent
?
RangeBoundary
(
endContent
-
>
GetParentNode
(
)
endContent
)
:
aRange
.
EndRef
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsRange
:
:
SetStartAndEnd
(
)
failed
"
)
;
return
Err
(
rv
)
;
}
return
true
;
}
}
