#
include
"
WSRunObject
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
const
char16_t
kNBSP
=
160
;
template
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
const
EditorDOMPoint
&
aScanEndPoint
)
;
template
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
const
EditorRawDOMPoint
&
aScanEndPoint
)
;
template
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aScanStartPoint
const
EditorDOMPoint
&
aScanEndPoint
)
;
template
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorRawDOMPoint
&
aScanStartPoint
const
EditorRawDOMPoint
&
aScanEndPoint
)
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPoint
&
aPoint
)
const
;
template
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorRawDOMPoint
&
aPoint
)
const
;
template
<
typename
PT
typename
CT
>
WSRunScanner
:
:
WSRunScanner
(
const
HTMLEditor
*
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
:
mScanStartPoint
(
aScanStartPoint
)
mScanEndPoint
(
aScanEndPoint
)
mEditingHost
(
aHTMLEditor
-
>
GetActiveEditingHost
(
)
)
mPRE
(
false
)
mStartOffset
(
0
)
mEndOffset
(
0
)
mFirstNBSPOffset
(
0
)
mLastNBSPOffset
(
0
)
mStartRun
(
nullptr
)
mEndRun
(
nullptr
)
mHTMLEditor
(
aHTMLEditor
)
mStartReason
(
WSType
:
:
none
)
mEndReason
(
WSType
:
:
none
)
{
MOZ_ASSERT
(
*
nsContentUtils
:
:
ComparePoints
(
aScanStartPoint
.
ToRawRangeBoundary
(
)
aScanEndPoint
.
ToRawRangeBoundary
(
)
)
<
=
0
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
GetWSNodes
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
WSRunScanner
:
:
GetWSNodes
(
)
failed
but
ignored
"
)
;
GetRuns
(
)
;
}
WSRunScanner
:
:
~
WSRunScanner
(
)
{
ClearRuns
(
)
;
}
template
<
typename
PT
typename
CT
>
WSRunObject
:
:
WSRunObject
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPointBase
<
PT
CT
>
&
aScanStartPoint
const
EditorDOMPointBase
<
PT
CT
>
&
aScanEndPoint
)
:
WSRunScanner
(
&
aHTMLEditor
aScanStartPoint
aScanEndPoint
)
mHTMLEditor
(
aHTMLEditor
)
{
}
nsresult
WSRunObject
:
:
Scrub
(
HTMLEditor
&
aHTMLEditor
const
EditorDOMPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
WSRunObject
wsRunObject
(
aHTMLEditor
aPoint
)
;
nsresult
rv
=
wsRunObject
.
Scrub
(
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
Scrub
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToJoinBlocks
(
HTMLEditor
&
aHTMLEditor
Element
&
aLeftBlockElement
Element
&
aRightBlockElement
)
{
WSRunObject
leftWSObj
(
aHTMLEditor
EditorRawDOMPoint
:
:
AtEndOf
(
aLeftBlockElement
)
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
EditorRawDOMPoint
(
&
aRightBlockElement
0
)
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
if
(
NS_WARN_IF
(
aHTMLEditor
.
Destroyed
(
)
)
)
{
return
NS_ERROR_EDITOR_DESTROYED
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRange
(
HTMLEditor
&
aHTMLEditor
EditorDOMPoint
*
aStartPoint
EditorDOMPoint
*
aEndPoint
)
{
MOZ_ASSERT
(
aStartPoint
)
;
MOZ_ASSERT
(
aEndPoint
)
;
if
(
NS_WARN_IF
(
!
aStartPoint
-
>
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
-
>
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoTrackDOMPoint
trackerStart
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aStartPoint
)
;
AutoTrackDOMPoint
trackerEnd
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aEndPoint
)
;
WSRunObject
leftWSObj
(
aHTMLEditor
*
aStartPoint
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
*
aEndPoint
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteNode
(
HTMLEditor
&
aHTMLEditor
nsIContent
*
aContent
)
{
if
(
NS_WARN_IF
(
!
aContent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
EditorRawDOMPoint
atContent
(
aContent
)
;
if
(
!
atContent
.
IsSet
(
)
)
{
NS_WARNING
(
"
aContent
was
an
orphan
node
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
WSRunObject
leftWSObj
(
aHTMLEditor
atContent
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
atContent
.
NextPoint
(
)
)
;
nsresult
rv
=
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToDeleteRangePriv
(
)
failed
"
)
;
return
rv
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
HTMLEditor
&
aHTMLEditor
nsCOMPtr
<
nsINode
>
*
aSplitNode
int32_t
*
aSplitOffset
)
{
if
(
NS_WARN_IF
(
!
aSplitNode
)
|
|
NS_WARN_IF
(
!
*
aSplitNode
)
|
|
NS_WARN_IF
(
!
aSplitOffset
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
AutoTrackDOMPoint
tracker
(
aHTMLEditor
.
RangeUpdaterRef
(
)
aSplitNode
aSplitOffset
)
;
WSRunObject
wsObj
(
aHTMLEditor
MOZ_KnownLive
(
*
aSplitNode
)
*
aSplitOffset
)
;
nsresult
rv
=
wsObj
.
PrepareToSplitAcrossBlocksPriv
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
PrepareToSplitAcrossBlocksPriv
(
)
failed
"
)
;
return
rv
;
}
already_AddRefed
<
Element
>
WSRunObject
:
:
InsertBreak
(
Selection
&
aSelection
const
EditorDOMPoint
&
aPointToInsert
nsIEditor
:
:
EDirection
aSelect
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
nullptr
;
}
WSFragment
*
beforeRun
=
FindNearestRun
(
aPointToInsert
false
)
;
WSFragment
*
afterRun
=
FindNearestRun
(
aPointToInsert
true
)
;
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
!
afterRun
|
|
afterRun
-
>
IsEndOfHardLine
(
)
)
{
}
else
if
(
afterRun
-
>
IsStartOfHardLine
(
)
)
{
nsresult
rv
=
DeleteRange
(
pointToInsert
afterRun
-
>
EndPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
nullptr
;
}
}
else
if
(
afterRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
EditorDOMPointInText
atNextCharOfInsertionPoint
=
GetNextCharPoint
(
pointToInsert
)
;
if
(
atNextCharOfInsertionPoint
.
IsSet
(
)
&
&
!
atNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
&
&
atNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
atPreviousCharOfNextCharOfInsertionPoint
=
GetPreviousCharPointFromPointInText
(
atNextCharOfInsertionPoint
)
;
if
(
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsSet
(
)
|
|
atPreviousCharOfNextCharOfInsertionPoint
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfNextCharOfInsertionPoint
.
IsCharASCIISpace
(
)
)
{
nsresult
rv
=
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
atNextCharOfInsertionPoint
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
)
"
"
failed
"
)
;
return
nullptr
;
}
}
}
}
if
(
!
beforeRun
|
|
beforeRun
-
>
IsStartOfHardLine
(
)
)
{
}
else
if
(
beforeRun
-
>
IsEndOfHardLine
(
)
)
{
nsresult
rv
=
DeleteRange
(
beforeRun
-
>
StartPoint
(
)
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
nullptr
;
}
}
else
if
(
beforeRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
nsresult
rv
=
ReplacePreviousNBSPIfUnnecessary
(
beforeRun
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplacePreviousNBSPIfUnnecessary
(
)
failed
"
)
;
return
nullptr
;
}
}
}
RefPtr
<
Element
>
newBRElement
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertBRElementWithTransaction
(
pointToInsert
aSelect
)
;
NS_WARNING_ASSERTION
(
newBRElement
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
newBRElement
.
forget
(
)
;
}
nsresult
WSRunObject
:
:
InsertText
(
Document
&
aDocument
const
nsAString
&
aStringToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
mScanStartPoint
;
}
return
NS_OK
;
}
WSFragment
*
beforeRun
=
FindNearestRun
(
mScanStartPoint
false
)
;
WSRunObject
afterRunObject
(
MOZ_KnownLive
(
mHTMLEditor
)
mScanEndPoint
)
;
WSFragment
*
afterRun
=
afterRunObject
.
FindNearestRun
(
mScanEndPoint
true
)
;
EditorDOMPoint
pointToInsert
(
mScanStartPoint
)
;
nsAutoString
theString
(
aStringToInsert
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
.
RangeUpdaterRef
(
)
&
pointToInsert
)
;
if
(
!
afterRun
|
|
afterRun
-
>
IsEndOfHardLine
(
)
)
{
}
else
if
(
afterRun
-
>
IsStartOfHardLine
(
)
)
{
nsresult
rv
=
DeleteRange
(
pointToInsert
afterRun
-
>
EndPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
afterRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
nsresult
rv
=
CheckLeadingNBSP
(
afterRun
MOZ_KnownLive
(
pointToInsert
.
GetContainer
(
)
)
pointToInsert
.
Offset
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
CheckLeadingNBSP
(
)
failed
"
)
;
return
rv
;
}
}
if
(
!
beforeRun
|
|
beforeRun
-
>
IsStartOfHardLine
(
)
)
{
}
else
if
(
beforeRun
-
>
IsEndOfHardLine
(
)
)
{
nsresult
rv
=
DeleteRange
(
beforeRun
-
>
StartPoint
(
)
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
beforeRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
nsresult
rv
=
ReplacePreviousNBSPIfUnnecessary
(
beforeRun
pointToInsert
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
ReplacePreviousNBSPIfUnnecessary
(
)
failed
"
)
;
return
rv
;
}
}
}
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
0
]
)
)
{
if
(
beforeRun
)
{
if
(
beforeRun
-
>
IsStartOfHardLine
(
)
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
else
if
(
beforeRun
-
>
IsVisible
(
)
)
{
EditorDOMPointInText
atPreviousChar
=
GetPreviousCharPoint
(
pointToInsert
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
}
}
else
if
(
StartsFromHardLineBreak
(
)
)
{
theString
.
SetCharAt
(
kNBSP
0
)
;
}
}
uint32_t
lastCharIndex
=
theString
.
Length
(
)
-
1
;
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
lastCharIndex
]
)
)
{
if
(
afterRun
)
{
if
(
afterRun
-
>
IsEndOfHardLine
(
)
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
else
if
(
afterRun
-
>
IsVisible
(
)
)
{
EditorDOMPointInText
atNextChar
=
GetNextCharPoint
(
pointToInsert
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpace
(
)
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
}
}
else
if
(
afterRunObject
.
EndsByBlockBoundary
(
)
)
{
theString
.
SetCharAt
(
kNBSP
lastCharIndex
)
;
}
}
bool
prevWS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
=
lastCharIndex
;
i
+
+
)
{
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
i
]
)
)
{
if
(
prevWS
)
{
theString
.
SetCharAt
(
kNBSP
i
-
1
)
;
}
else
{
prevWS
=
true
;
}
}
else
{
prevWS
=
false
;
}
}
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextWithTransaction
(
aDocument
theString
pointToInsert
aPointAfterInsertedString
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
NS_WARNING
(
"
HTMLEditor
:
:
InsertTextWithTransaction
(
)
failed
but
ignored
"
)
;
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
pointToInsert
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSBackward
(
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousCharPoint
(
mScanStartPoint
)
;
if
(
!
atPreviousCharOfStart
.
IsSet
(
)
|
|
atPreviousCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
mPRE
)
{
if
(
!
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
&
&
!
atPreviousCharOfStart
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
DeleteRange
(
atPreviousCharOfStart
atPreviousCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
if
(
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eBoth
atPreviousCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
start
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
start
position
but
ignored
"
)
;
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
end
position
but
ignored
"
)
;
EditorDOMPoint
startToDelete
(
start
)
endToDelete
(
end
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
DeleteRange
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
if
(
atPreviousCharOfStart
.
IsCharNBSP
(
)
)
{
EditorDOMPoint
startToDelete
(
atPreviousCharOfStart
)
;
EditorDOMPoint
endToDelete
(
startToDelete
.
NextPoint
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
DeleteRange
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSForward
(
)
{
EditorDOMPointInText
atNextCharOfStart
=
GetNextCharPoint
(
mScanStartPoint
)
;
if
(
!
atNextCharOfStart
.
IsSet
(
)
|
|
atNextCharOfStart
.
IsEndOfContainer
(
)
)
{
return
NS_OK
;
}
if
(
mPRE
)
{
if
(
!
atNextCharOfStart
.
IsCharASCIISpace
(
)
&
&
!
atNextCharOfStart
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
DeleteRange
(
atNextCharOfStart
atNextCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
if
(
atNextCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eBoth
atNextCharOfStart
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
start
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
start
position
but
ignored
"
)
;
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
end
position
but
ignored
"
)
;
EditorDOMPoint
startToDelete
(
start
)
endToDelete
(
end
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
DeleteRange
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
if
(
atNextCharOfStart
.
IsCharNBSP
(
)
)
{
EditorDOMPoint
startToDelete
(
atNextCharOfStart
)
;
EditorDOMPoint
endToDelete
(
startToDelete
.
NextPoint
(
)
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
MOZ_KnownLive
(
mHTMLEditor
)
&
startToDelete
&
endToDelete
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
PrepareToDeleteRange
(
)
failed
"
)
;
return
rv
;
}
rv
=
DeleteRange
(
startToDelete
endToDelete
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanPreviousVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
WSFragment
*
run
=
FindNearestRun
(
aPoint
false
)
;
for
(
;
run
;
run
=
run
-
>
mLeft
)
{
if
(
run
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
EditorDOMPointInText
atPreviousChar
=
GetPreviousCharPoint
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsContainerEmpty
(
)
)
{
MOZ_ASSERT
(
!
atPreviousChar
.
IsEndOfContainer
(
)
)
;
return
WSScanResult
(
atPreviousChar
.
NextPoint
(
)
atPreviousChar
.
IsCharASCIISpace
(
)
|
|
atPreviousChar
.
IsCharNBSP
(
)
?
WSType
:
:
normalWS
:
WSType
:
:
text
)
;
}
}
}
if
(
mStartReasonContent
!
=
mStartNode
)
{
return
WSScanResult
(
mStartReasonContent
mStartReason
)
;
}
return
WSScanResult
(
EditorDOMPoint
(
mStartReasonContent
mStartOffset
)
mStartReason
)
;
}
template
<
typename
PT
typename
CT
>
WSScanResult
WSRunScanner
:
:
ScanNextVisibleNodeOrBlockBoundaryFrom
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
WSFragment
*
run
=
FindNearestRun
(
aPoint
true
)
;
for
(
;
run
;
run
=
run
-
>
mRight
)
{
if
(
run
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
EditorDOMPointInText
atNextChar
=
GetNextCharPoint
(
aPoint
)
;
if
(
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsContainerEmpty
(
)
)
{
return
WSScanResult
(
atNextChar
!
atNextChar
.
IsEndOfContainer
(
)
&
&
(
atNextChar
.
IsCharASCIISpace
(
)
|
|
atNextChar
.
IsCharNBSP
(
)
)
?
WSType
:
:
normalWS
:
WSType
:
:
text
)
;
}
}
}
if
(
mEndReasonContent
!
=
mEndNode
)
{
return
WSScanResult
(
mEndReasonContent
mEndReason
)
;
}
return
WSScanResult
(
EditorDOMPoint
(
mEndReasonContent
mEndOffset
)
mEndReason
)
;
}
nsresult
WSRunObject
:
:
AdjustWhitespace
(
)
{
if
(
!
mLastNBSPNode
)
{
return
NS_OK
;
}
for
(
WSFragment
*
run
=
mStartRun
;
run
;
run
=
run
-
>
mRight
)
{
if
(
!
run
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
continue
;
}
nsresult
rv
=
CheckTrailingNBSPOfRun
(
run
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
CheckTrailingNBSPOfRun
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsIContent
*
WSRunScanner
:
:
GetEditableBlockParentOrTopmotEditableInlineContent
(
nsIContent
*
aContent
)
const
{
if
(
NS_WARN_IF
(
!
aContent
)
)
{
return
nullptr
;
}
NS_ASSERTION
(
mHTMLEditor
-
>
IsEditable
(
aContent
)
"
Given
content
is
not
editable
"
)
;
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
nullptr
;
for
(
nsIContent
*
content
=
aContent
;
content
&
&
mHTMLEditor
-
>
IsEditable
(
content
)
;
content
=
content
-
>
GetParent
(
)
)
{
editableBlockParentOrTopmotEditableInlineContent
=
content
;
if
(
IsBlockNode
(
editableBlockParentOrTopmotEditableInlineContent
)
)
{
break
;
}
}
return
editableBlockParentOrTopmotEditableInlineContent
;
}
nsresult
WSRunScanner
:
:
GetWSNodes
(
)
{
EditorDOMPoint
start
(
mScanStartPoint
)
end
(
mScanStartPoint
)
;
nsIContent
*
scanStartContent
=
mScanStartPoint
.
GetContainerAsContent
(
)
;
if
(
NS_WARN_IF
(
!
scanStartContent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
editableBlockParentOrTopmotEditableInlineContent
=
GetEditableBlockParentOrTopmotEditableInlineContent
(
scanStartContent
)
;
if
(
NS_WARN_IF
(
!
editableBlockParentOrTopmotEditableInlineContent
)
)
{
editableBlockParentOrTopmotEditableInlineContent
=
scanStartContent
;
}
if
(
Text
*
textNode
=
mScanStartPoint
.
GetContainerAsText
(
)
)
{
const
nsTextFragment
*
textFrag
=
&
textNode
-
>
TextFragment
(
)
;
mNodeArray
.
InsertElementAt
(
0
textNode
)
;
if
(
!
mScanStartPoint
.
IsStartOfContainer
(
)
)
{
for
(
uint32_t
i
=
mScanStartPoint
.
Offset
(
)
;
i
;
i
-
-
)
{
if
(
i
>
textFrag
-
>
GetLength
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
i
-
1
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
kNBSP
)
{
mStartNode
=
textNode
;
mStartOffset
=
i
;
mStartReason
=
WSType
:
:
text
;
mStartReasonContent
=
textNode
;
break
;
}
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
i
-
1
;
if
(
!
mLastNBSPNode
)
{
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
i
-
1
;
}
}
start
.
Set
(
textNode
i
-
1
)
;
}
}
}
while
(
!
mStartNode
)
{
nsCOMPtr
<
nsIContent
>
priorNode
=
GetPreviousWSNode
(
start
editableBlockParentOrTopmotEditableInlineContent
)
;
if
(
priorNode
)
{
if
(
IsBlockNode
(
priorNode
)
)
{
mStartNode
=
start
.
GetContainer
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
mStartReason
=
WSType
:
:
otherBlock
;
mStartReasonContent
=
priorNode
;
}
else
if
(
priorNode
-
>
IsText
(
)
&
&
priorNode
-
>
IsEditable
(
)
)
{
RefPtr
<
Text
>
textNode
=
priorNode
-
>
AsText
(
)
;
mNodeArray
.
InsertElementAt
(
0
textNode
)
;
const
nsTextFragment
*
textFrag
=
&
textNode
-
>
TextFragment
(
)
;
uint32_t
len
=
textNode
-
>
TextLength
(
)
;
if
(
len
<
1
)
{
start
.
Set
(
priorNode
0
)
;
}
else
{
for
(
int32_t
pos
=
len
-
1
;
pos
>
=
0
;
pos
-
-
)
{
if
(
uint32_t
(
pos
)
>
=
textFrag
-
>
GetLength
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
kNBSP
)
{
mStartNode
=
textNode
;
mStartOffset
=
pos
+
1
;
mStartReason
=
WSType
:
:
text
;
mStartReasonContent
=
textNode
;
break
;
}
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
if
(
!
mLastNBSPNode
)
{
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
}
}
start
.
Set
(
textNode
pos
)
;
}
}
}
else
{
mStartNode
=
start
.
GetContainer
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
if
(
priorNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
mStartReason
=
WSType
:
:
br
;
}
else
{
mStartReason
=
WSType
:
:
special
;
}
mStartReasonContent
=
priorNode
;
}
}
else
{
mStartNode
=
start
.
GetContainer
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
mStartReason
=
WSType
:
:
thisBlock
;
mStartReasonContent
=
editableBlockParentOrTopmotEditableInlineContent
;
}
}
if
(
Text
*
textNode
=
end
.
GetContainerAsText
(
)
)
{
const
nsTextFragment
*
textFrag
=
&
textNode
-
>
TextFragment
(
)
;
if
(
!
end
.
IsEndOfContainer
(
)
)
{
for
(
uint32_t
i
=
end
.
Offset
(
)
;
i
<
textNode
-
>
TextLength
(
)
;
i
+
+
)
{
if
(
i
>
=
textFrag
-
>
GetLength
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
i
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
kNBSP
)
{
mEndNode
=
textNode
;
mEndOffset
=
i
;
mEndReason
=
WSType
:
:
text
;
mEndReasonContent
=
textNode
;
break
;
}
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
i
;
if
(
!
mFirstNBSPNode
)
{
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
i
;
}
}
end
.
Set
(
textNode
i
+
1
)
;
}
}
}
while
(
!
mEndNode
)
{
nsCOMPtr
<
nsIContent
>
nextNode
=
GetNextWSNode
(
end
editableBlockParentOrTopmotEditableInlineContent
)
;
if
(
nextNode
)
{
if
(
IsBlockNode
(
nextNode
)
)
{
mEndNode
=
end
.
GetContainer
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
mEndReason
=
WSType
:
:
otherBlock
;
mEndReasonContent
=
nextNode
;
}
else
if
(
nextNode
-
>
IsText
(
)
&
&
nextNode
-
>
IsEditable
(
)
)
{
RefPtr
<
Text
>
textNode
=
nextNode
-
>
AsText
(
)
;
mNodeArray
.
AppendElement
(
textNode
)
;
const
nsTextFragment
*
textFrag
=
&
textNode
-
>
TextFragment
(
)
;
uint32_t
len
=
textNode
-
>
TextLength
(
)
;
if
(
len
<
1
)
{
end
.
Set
(
textNode
0
)
;
}
else
{
for
(
uint32_t
pos
=
0
;
pos
<
len
;
pos
+
+
)
{
if
(
pos
>
=
textFrag
-
>
GetLength
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
kNBSP
)
{
mEndNode
=
textNode
;
mEndOffset
=
pos
;
mEndReason
=
WSType
:
:
text
;
mEndReasonContent
=
textNode
;
break
;
}
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
if
(
!
mFirstNBSPNode
)
{
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
}
}
end
.
Set
(
textNode
pos
+
1
)
;
}
}
}
else
{
mEndNode
=
end
.
GetContainer
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
if
(
nextNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
mEndReason
=
WSType
:
:
br
;
}
else
{
mEndReason
=
WSType
:
:
special
;
}
mEndReasonContent
=
nextNode
;
}
}
else
{
mEndNode
=
end
.
GetContainer
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
mEndReason
=
WSType
:
:
thisBlock
;
mEndReasonContent
=
editableBlockParentOrTopmotEditableInlineContent
;
}
}
return
NS_OK
;
}
void
WSRunScanner
:
:
GetRuns
(
)
{
ClearRuns
(
)
;
mPRE
=
EditorBase
:
:
IsPreformatted
(
mScanStartPoint
.
GetContainer
(
)
)
;
if
(
mPRE
|
|
(
(
StartsFromNormalText
(
)
|
|
StartsFromSpecialContent
(
)
)
&
&
(
EndsByNormalText
(
)
|
|
EndsBySpecialContent
(
)
|
|
EndsByBRElement
(
)
)
)
)
{
InitializeWithSingleFragment
(
WSFragment
:
:
Visible
:
:
Yes
WSFragment
:
:
StartOfHardLine
:
:
No
WSFragment
:
:
EndOfHardLine
:
:
No
)
;
return
;
}
if
(
!
mFirstNBSPNode
&
&
!
mLastNBSPNode
&
&
(
StartsFromHardLineBreak
(
)
|
|
EndsByBlockBoundary
(
)
)
)
{
InitializeWithSingleFragment
(
WSFragment
:
:
Visible
:
:
No
StartsFromHardLineBreak
(
)
?
WSFragment
:
:
StartOfHardLine
:
:
Yes
:
WSFragment
:
:
StartOfHardLine
:
:
No
EndsByBlockBoundary
(
)
?
WSFragment
:
:
EndOfHardLine
:
:
Yes
:
WSFragment
:
:
EndOfHardLine
:
:
No
)
;
return
;
}
mStartRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mStartNode
=
mStartNode
;
mStartRun
-
>
mStartOffset
=
mStartOffset
;
if
(
StartsFromHardLineBreak
(
)
)
{
mStartRun
-
>
MarkAsStartOfHardLine
(
)
;
mStartRun
-
>
mEndNode
=
mFirstNBSPNode
;
mStartRun
-
>
mEndOffset
=
mFirstNBSPOffset
;
mStartRun
-
>
SetStartFrom
(
mStartReason
)
;
mStartRun
-
>
SetEndByNormalWiteSpaces
(
)
;
WSFragment
*
normalRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mRight
=
normalRun
;
normalRun
-
>
MarkAsVisible
(
)
;
normalRun
-
>
mStartNode
=
mFirstNBSPNode
;
normalRun
-
>
mStartOffset
=
mFirstNBSPOffset
;
normalRun
-
>
SetStartFromLeadingWhiteSpaces
(
)
;
normalRun
-
>
mLeft
=
mStartRun
;
if
(
!
EndsByBlockBoundary
(
)
)
{
normalRun
-
>
SetEndBy
(
mEndReason
)
;
normalRun
-
>
mEndNode
=
mEndNode
;
normalRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
normalRun
;
}
else
{
if
(
mLastNBSPNode
=
=
mEndNode
&
&
mLastNBSPOffset
=
=
mEndOffset
-
1
)
{
normalRun
-
>
SetEndBy
(
mEndReason
)
;
normalRun
-
>
mEndNode
=
mEndNode
;
normalRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
normalRun
;
}
else
{
normalRun
-
>
mEndNode
=
mLastNBSPNode
;
normalRun
-
>
mEndOffset
=
mLastNBSPOffset
+
1
;
normalRun
-
>
SetEndByTrailingWhiteSpaces
(
)
;
WSFragment
*
lastRun
=
new
WSFragment
(
)
;
lastRun
-
>
MarkAsEndOfHardLine
(
)
;
lastRun
-
>
mStartNode
=
mLastNBSPNode
;
lastRun
-
>
mStartOffset
=
mLastNBSPOffset
+
1
;
lastRun
-
>
mEndNode
=
mEndNode
;
lastRun
-
>
mEndOffset
=
mEndOffset
;
lastRun
-
>
SetStartFromNormalWhiteSpaces
(
)
;
lastRun
-
>
mLeft
=
normalRun
;
lastRun
-
>
SetEndBy
(
mEndReason
)
;
mEndRun
=
lastRun
;
normalRun
-
>
mRight
=
lastRun
;
}
}
}
else
{
MOZ_ASSERT
(
!
StartsFromHardLineBreak
(
)
)
;
mStartRun
-
>
MarkAsVisible
(
)
;
mStartRun
-
>
mEndNode
=
mLastNBSPNode
;
mStartRun
-
>
mEndOffset
=
mLastNBSPOffset
+
1
;
mStartRun
-
>
SetStartFrom
(
mStartReason
)
;
if
(
mLastNBSPNode
=
=
mEndNode
&
&
mLastNBSPOffset
=
=
(
mEndOffset
-
1
)
)
{
mStartRun
-
>
SetEndBy
(
mEndReason
)
;
mStartRun
-
>
mEndNode
=
mEndNode
;
mStartRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
mStartRun
;
}
else
{
WSFragment
*
lastRun
=
new
WSFragment
(
)
;
lastRun
-
>
MarkAsEndOfHardLine
(
)
;
lastRun
-
>
mStartNode
=
mLastNBSPNode
;
lastRun
-
>
mStartOffset
=
mLastNBSPOffset
+
1
;
lastRun
-
>
SetStartFromNormalWhiteSpaces
(
)
;
lastRun
-
>
mLeft
=
mStartRun
;
lastRun
-
>
SetEndBy
(
mEndReason
)
;
mEndRun
=
lastRun
;
mStartRun
-
>
mRight
=
lastRun
;
mStartRun
-
>
SetEndByTrailingWhiteSpaces
(
)
;
}
}
}
void
WSRunScanner
:
:
ClearRuns
(
)
{
WSFragment
*
tmp
*
run
;
run
=
mStartRun
;
while
(
run
)
{
tmp
=
run
-
>
mRight
;
delete
run
;
run
=
tmp
;
}
mStartRun
=
0
;
mEndRun
=
0
;
}
void
WSRunScanner
:
:
InitializeWithSingleFragment
(
WSFragment
:
:
Visible
aIsVisible
WSFragment
:
:
StartOfHardLine
aIsStartOfHardLine
WSFragment
:
:
EndOfHardLine
aIsEndOfHardLine
)
{
MOZ_ASSERT
(
!
mStartRun
)
;
MOZ_ASSERT
(
!
mEndRun
)
;
mStartRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mStartNode
=
mStartNode
;
mStartRun
-
>
mStartOffset
=
mStartOffset
;
if
(
aIsVisible
=
=
WSFragment
:
:
Visible
:
:
Yes
)
{
mStartRun
-
>
MarkAsVisible
(
)
;
}
if
(
aIsStartOfHardLine
=
=
WSFragment
:
:
StartOfHardLine
:
:
Yes
)
{
mStartRun
-
>
MarkAsStartOfHardLine
(
)
;
}
if
(
aIsEndOfHardLine
=
=
WSFragment
:
:
EndOfHardLine
:
:
Yes
)
{
mStartRun
-
>
MarkAsEndOfHardLine
(
)
;
}
mStartRun
-
>
mEndNode
=
mEndNode
;
mStartRun
-
>
mEndOffset
=
mEndOffset
;
mStartRun
-
>
SetStartFrom
(
mStartReason
)
;
mStartRun
-
>
SetEndBy
(
mEndReason
)
;
mEndRun
=
mStartRun
;
}
nsIContent
*
WSRunScanner
:
:
GetPreviousWSNodeInner
(
nsINode
*
aStartNode
nsINode
*
aBlockParent
)
const
{
MOZ_ASSERT
(
aStartNode
&
&
aBlockParent
)
;
if
(
aStartNode
=
=
mEditingHost
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetPreviousWSNodeInner
(
)
was
called
with
editing
host
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
priorNode
=
aStartNode
-
>
GetPreviousSibling
(
)
;
OwningNonNull
<
nsINode
>
curNode
=
*
aStartNode
;
while
(
!
priorNode
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
if
(
!
curParent
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
if
(
curParent
=
=
aBlockParent
)
{
return
nullptr
;
}
if
(
curParent
=
=
mEditingHost
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
priorNode
=
curParent
-
>
GetPreviousSibling
(
)
;
curNode
=
curParent
;
}
if
(
IsBlockNode
(
priorNode
)
)
{
return
priorNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
priorNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetRightmostChild
(
priorNode
)
;
if
(
child
)
{
return
child
;
}
}
return
priorNode
;
}
nsIContent
*
WSRunScanner
:
:
GetPreviousWSNode
(
const
EditorDOMPoint
&
aPoint
nsINode
*
aBlockParent
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
&
&
aBlockParent
)
;
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
GetPreviousWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
!
mHTMLEditor
-
>
IsContainer
(
aPoint
.
GetContainer
(
)
)
)
{
return
GetPreviousWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
!
aPoint
.
Offset
(
)
)
{
if
(
aPoint
.
GetContainer
(
)
=
=
aBlockParent
)
{
return
nullptr
;
}
return
GetPreviousWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
GetContainerAsContent
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
priorNode
=
aPoint
.
GetPreviousSiblingOfChild
(
)
;
if
(
NS_WARN_IF
(
!
priorNode
)
)
{
return
nullptr
;
}
if
(
IsBlockNode
(
priorNode
)
)
{
return
priorNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
priorNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetRightmostChild
(
priorNode
)
;
if
(
child
)
{
return
child
;
}
}
return
priorNode
;
}
nsIContent
*
WSRunScanner
:
:
GetNextWSNodeInner
(
nsINode
*
aStartNode
nsINode
*
aBlockParent
)
const
{
MOZ_ASSERT
(
aStartNode
&
&
aBlockParent
)
;
if
(
aStartNode
=
=
mEditingHost
)
{
NS_WARNING
(
"
WSRunScanner
:
:
GetNextWSNodeInner
(
)
was
called
with
editing
host
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
aStartNode
-
>
GetNextSibling
(
)
;
nsCOMPtr
<
nsINode
>
curNode
=
aStartNode
;
while
(
!
nextNode
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
if
(
!
curParent
)
{
NS_WARNING
(
"
Reached
orphan
node
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
if
(
curParent
=
=
aBlockParent
)
{
return
nullptr
;
}
if
(
curParent
=
=
mEditingHost
)
{
NS_WARNING
(
"
Reached
editing
host
while
climbing
up
the
DOM
tree
"
)
;
return
nullptr
;
}
nextNode
=
curParent
-
>
GetNextSibling
(
)
;
curNode
=
curParent
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
nextNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
nextNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetLeftmostChild
(
nextNode
)
;
if
(
child
)
{
return
child
;
}
}
return
nextNode
;
}
nsIContent
*
WSRunScanner
:
:
GetNextWSNode
(
const
EditorDOMPoint
&
aPoint
nsINode
*
aBlockParent
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
&
&
aBlockParent
)
;
if
(
aPoint
.
IsInTextNode
(
)
)
{
return
GetNextWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
!
mHTMLEditor
-
>
IsContainer
(
aPoint
.
GetContainer
(
)
)
)
{
return
GetNextWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
GetContainerAsContent
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
aPoint
.
GetChild
(
)
;
if
(
!
nextNode
)
{
if
(
aPoint
.
GetContainer
(
)
=
=
aBlockParent
)
{
return
nullptr
;
}
return
GetNextWSNodeInner
(
aPoint
.
GetContainer
(
)
aBlockParent
)
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
nextNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
nextNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetLeftmostChild
(
nextNode
)
;
if
(
child
)
{
return
child
;
}
}
return
nextNode
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRangePriv
(
WSRunObject
*
aEndObject
)
{
if
(
NS_WARN_IF
(
!
aEndObject
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
WSFragment
*
beforeRun
=
FindNearestRun
(
mScanStartPoint
false
)
;
WSFragment
*
afterRun
=
aEndObject
-
>
FindNearestRun
(
aEndObject
-
>
mScanStartPoint
true
)
;
if
(
!
beforeRun
&
&
!
afterRun
)
{
return
NS_OK
;
}
if
(
afterRun
)
{
if
(
afterRun
-
>
IsStartOfHardLine
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
nsresult
rv
=
aEndObject
-
>
DeleteRange
(
aEndObject
-
>
mScanStartPoint
afterRun
-
>
EndPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
else
if
(
afterRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
&
&
!
aEndObject
-
>
mPRE
)
{
if
(
(
beforeRun
&
&
beforeRun
-
>
IsStartOfHardLine
(
)
)
|
|
(
!
beforeRun
&
&
StartsFromHardLineBreak
(
)
)
)
{
EditorDOMPointInText
nextCharOfStartOfEnd
=
aEndObject
-
>
GetNextCharPoint
(
aEndObject
-
>
mScanStartPoint
)
;
if
(
nextCharOfStartOfEnd
.
IsSet
(
)
&
&
!
nextCharOfStartOfEnd
.
IsEndOfContainer
(
)
&
&
nextCharOfStartOfEnd
.
IsCharASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
nsresult
rv
=
aEndObject
-
>
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
nextCharOfStartOfEnd
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
}
}
if
(
!
beforeRun
)
{
return
NS_OK
;
}
if
(
beforeRun
-
>
IsEndOfHardLine
(
)
)
{
nsresult
rv
=
DeleteRange
(
beforeRun
-
>
StartPoint
(
)
mScanStartPoint
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
if
(
beforeRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
&
&
!
mPRE
)
{
if
(
(
afterRun
&
&
(
afterRun
-
>
IsEndOfHardLine
(
)
|
|
afterRun
-
>
IsVisible
(
)
)
)
|
|
(
!
afterRun
&
&
aEndObject
-
>
EndsByBlockBoundary
(
)
)
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousCharPoint
(
mScanStartPoint
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eBoth
mScanStartPoint
)
;
NS_WARNING_ASSERTION
(
start
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
start
point
but
ignored
"
)
;
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
end
point
but
ignored
"
)
;
nsresult
rv
=
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
start
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocksPriv
(
)
{
WSFragment
*
beforeRun
=
FindNearestRun
(
mScanStartPoint
false
)
;
WSFragment
*
afterRun
=
FindNearestRun
(
mScanStartPoint
true
)
;
if
(
afterRun
&
&
afterRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
EditorDOMPointInText
atNextCharOfStart
=
GetNextCharPoint
(
mScanStartPoint
)
;
if
(
atNextCharOfStart
.
IsSet
(
)
&
&
!
atNextCharOfStart
.
IsEndOfContainer
(
)
&
&
atNextCharOfStart
.
IsCharASCIISpace
(
)
)
{
AutoEditorDOMPointChildInvalidator
forgetChild
(
mScanStartPoint
)
;
nsresult
rv
=
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
atNextCharOfStart
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
if
(
beforeRun
&
&
beforeRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
EditorDOMPointInText
atPreviousCharOfStart
=
GetPreviousCharPoint
(
mScanStartPoint
)
;
if
(
atPreviousCharOfStart
.
IsSet
(
)
&
&
!
atPreviousCharOfStart
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfStart
.
IsCharASCIISpace
(
)
)
{
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eBoth
mScanStartPoint
)
;
NS_WARNING_ASSERTION
(
start
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
start
point
but
ignored
"
)
;
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
end
point
but
ignored
"
)
;
nsresult
rv
=
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
start
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
)
"
"
failed
"
)
;
return
rv
;
}
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteRange
(
const
EditorDOMPoint
&
aStartPoint
const
EditorDOMPoint
&
aEndPoint
)
{
if
(
NS_WARN_IF
(
!
aStartPoint
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
aStartPoint
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
aEndPoint
.
IsSetAndValid
(
)
)
;
if
(
aStartPoint
=
=
aEndPoint
)
{
return
NS_OK
;
}
if
(
aStartPoint
.
GetContainer
(
)
=
=
aEndPoint
.
GetContainer
(
)
&
&
aStartPoint
.
IsInTextNode
(
)
)
{
RefPtr
<
Text
>
textNode
=
aStartPoint
.
ContainerAsText
(
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextWithTransaction
(
*
textNode
aStartPoint
.
Offset
(
)
aEndPoint
.
Offset
(
)
-
aStartPoint
.
Offset
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
RefPtr
<
nsRange
>
range
;
int32_t
count
=
mNodeArray
.
Length
(
)
;
int32_t
idx
=
mNodeArray
.
IndexOf
(
aStartPoint
.
GetContainer
(
)
)
;
if
(
idx
=
=
-
1
)
{
idx
=
0
;
}
for
(
;
idx
<
count
;
idx
+
+
)
{
RefPtr
<
Text
>
node
=
mNodeArray
[
idx
]
;
if
(
!
node
)
{
return
NS_OK
;
}
if
(
node
=
=
aStartPoint
.
GetContainer
(
)
)
{
if
(
!
aStartPoint
.
IsEndOfContainer
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextWithTransaction
(
*
node
aStartPoint
.
Offset
(
)
aStartPoint
.
GetContainer
(
)
-
>
Length
(
)
-
aStartPoint
.
Offset
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
else
if
(
node
=
=
aEndPoint
.
GetContainer
(
)
)
{
if
(
!
aEndPoint
.
IsStartOfContainer
(
)
)
{
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteTextWithTransaction
(
*
node
0
aEndPoint
.
Offset
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteTextWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
break
;
}
else
{
if
(
!
range
)
{
ErrorResult
error
;
range
=
nsRange
:
:
Create
(
aStartPoint
.
ToRawRangeBoundary
(
)
aEndPoint
.
ToRawRangeBoundary
(
)
error
)
;
if
(
!
range
)
{
NS_WARNING
(
"
nsRange
:
:
Create
(
)
failed
"
)
;
return
error
.
StealNSResult
(
)
;
}
}
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
node
range
&
nodeBefore
&
nodeAfter
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
RangeUtils
:
:
CompareNodeToRange
(
)
failed
"
)
;
return
rv
;
}
if
(
nodeAfter
)
{
break
;
}
if
(
!
nodeBefore
)
{
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
DeleteNodeWithTransaction
(
*
node
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
HTMLEditor
:
:
DeleteNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
mNodeArray
.
RemoveElement
(
node
)
;
-
-
count
;
-
-
idx
;
}
}
}
return
NS_OK
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
GetNextCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
size_t
index
=
aPoint
.
IsInTextNode
(
)
?
mNodeArray
.
IndexOf
(
aPoint
.
GetContainer
(
)
)
:
decltype
(
mNodeArray
)
:
:
NoIndex
;
if
(
index
=
=
decltype
(
mNodeArray
)
:
:
NoIndex
)
{
return
LookForNextCharPointWithinAllTextNodes
(
aPoint
)
;
}
return
GetNextCharPointFromPointInText
(
EditorDOMPointInText
(
mNodeArray
[
index
]
aPoint
.
Offset
(
)
)
)
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
GetPreviousCharPoint
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
size_t
index
=
aPoint
.
IsInTextNode
(
)
?
mNodeArray
.
IndexOf
(
aPoint
.
GetContainer
(
)
)
:
decltype
(
mNodeArray
)
:
:
NoIndex
;
if
(
index
=
=
decltype
(
mNodeArray
)
:
:
NoIndex
)
{
return
LookForPreviousCharPointWithinAllTextNodes
(
aPoint
)
;
}
return
GetPreviousCharPointFromPointInText
(
EditorDOMPointInText
(
mNodeArray
[
index
]
aPoint
.
Offset
(
)
)
)
;
}
EditorDOMPointInText
WSRunScanner
:
:
GetNextCharPointFromPointInText
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
size_t
index
=
mNodeArray
.
IndexOf
(
aPoint
.
GetContainer
(
)
)
;
if
(
index
=
=
decltype
(
mNodeArray
)
:
:
NoIndex
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
aPoint
.
IsSetAndValid
(
)
&
&
!
aPoint
.
IsEndOfContainer
(
)
)
{
return
aPoint
;
}
if
(
index
+
1
=
=
mNodeArray
.
Length
(
)
)
{
return
EditorDOMPointInText
(
)
;
}
return
EditorDOMPointInText
(
mNodeArray
[
index
+
1
]
0
)
;
}
EditorDOMPointInText
WSRunScanner
:
:
GetPreviousCharPointFromPointInText
(
const
EditorDOMPointInText
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
size_t
index
=
mNodeArray
.
IndexOf
(
aPoint
.
GetContainer
(
)
)
;
if
(
index
=
=
decltype
(
mNodeArray
)
:
:
NoIndex
)
{
return
EditorDOMPointInText
(
)
;
}
if
(
!
aPoint
.
IsStartOfContainer
(
)
)
{
return
aPoint
.
PreviousPoint
(
)
;
}
if
(
!
index
)
{
return
EditorDOMPointInText
(
)
;
}
return
EditorDOMPointInText
(
mNodeArray
[
index
-
1
]
mNodeArray
[
index
-
1
]
-
>
TextLength
(
)
?
mNodeArray
[
index
-
1
]
-
>
TextLength
(
)
-
1
:
0
)
;
}
nsresult
WSRunObject
:
:
InsertNBSPAndRemoveFollowingASCIIWhitespaces
(
const
EditorDOMPointInText
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextIntoTextNodeWithTransaction
(
nsDependentSubstring
(
&
kNBSP
1
)
aPoint
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
if
(
!
aPoint
.
IsSetAndValid
(
)
|
|
aPoint
.
IsEndOfContainer
(
)
|
|
!
aPoint
.
IsCharNBSP
(
)
)
{
return
NS_OK
;
}
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eAfter
aPoint
.
NextPoint
(
)
)
;
if
(
!
start
.
IsSet
(
)
)
{
return
NS_OK
;
}
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
return
"
"
end
point
but
ignored
"
)
;
rv
=
DeleteRange
(
start
end
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
template
<
typename
PT
typename
CT
>
Tuple
<
EditorDOMPointInText
EditorDOMPointInText
>
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
int16_t
aDir
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
)
;
EditorDOMPointInText
start
end
;
if
(
aDir
&
eAfter
)
{
EditorDOMPointInText
atNextChar
=
GetNextCharPoint
(
aPoint
)
;
if
(
atNextChar
.
IsSet
(
)
)
{
start
=
end
=
atNextChar
;
for
(
;
atNextChar
.
IsSet
(
)
&
&
!
atNextChar
.
IsEndOfContainer
(
)
&
&
atNextChar
.
IsCharASCIISpace
(
)
;
atNextChar
=
GetNextCharPointFromPointInText
(
atNextChar
)
)
{
end
=
atNextChar
=
atNextChar
.
NextPoint
(
)
;
}
}
}
if
(
aDir
&
eBefore
)
{
EditorDOMPointInText
atPreviousChar
=
GetPreviousCharPoint
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
)
{
start
=
atPreviousChar
.
NextPoint
(
)
;
if
(
!
end
.
IsSet
(
)
)
{
end
=
start
;
}
for
(
;
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharASCIISpace
(
)
;
atPreviousChar
=
GetPreviousCharPointFromPointInText
(
atPreviousChar
)
)
{
start
=
atPreviousChar
;
}
}
}
return
MakeTuple
(
start
end
)
;
}
template
<
typename
PT
typename
CT
>
WSRunScanner
:
:
WSFragment
*
WSRunScanner
:
:
FindNearestRun
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
bool
aForward
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
for
(
WSFragment
*
run
=
mStartRun
;
run
;
run
=
run
-
>
mRight
)
{
int32_t
comp
=
run
-
>
mStartNode
?
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
run
-
>
StartPoint
(
)
.
ToRawRangeBoundary
(
)
)
:
-
1
;
if
(
comp
<
=
0
)
{
return
aForward
?
run
:
nullptr
;
}
comp
=
run
-
>
mEndNode
?
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
run
-
>
EndPoint
(
)
.
ToRawRangeBoundary
(
)
)
:
-
1
;
if
(
comp
<
0
)
{
return
run
;
}
if
(
!
comp
)
{
return
aForward
?
run
-
>
mRight
:
run
;
}
if
(
!
run
-
>
mRight
)
{
return
aForward
?
nullptr
:
run
;
}
}
return
nullptr
;
}
char16_t
WSRunScanner
:
:
GetCharAt
(
Text
*
aTextNode
int32_t
aOffset
)
const
{
if
(
NS_WARN_IF
(
!
aTextNode
)
|
|
NS_WARN_IF
(
aOffset
<
0
)
|
|
NS_WARN_IF
(
aOffset
>
=
static_cast
<
int32_t
>
(
aTextNode
-
>
TextDataLength
(
)
)
)
)
{
return
0
;
}
return
aTextNode
-
>
TextFragment
(
)
.
CharAt
(
aOffset
)
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
LookForNextCharPointWithinAllTextNodes
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
uint32_t
numNodes
=
mNodeArray
.
Length
(
)
;
if
(
!
numNodes
)
{
return
EditorDOMPointInText
(
)
;
}
uint32_t
firstNum
=
0
curNum
=
numNodes
/
2
lastNum
=
numNodes
;
while
(
curNum
!
=
lastNum
)
{
Text
*
curNode
=
mNodeArray
[
curNum
]
;
int16_t
cmp
=
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
RawRangeBoundary
(
curNode
0u
)
)
;
if
(
cmp
<
0
)
{
lastNum
=
curNum
;
}
else
{
firstNum
=
curNum
+
1
;
}
curNum
=
(
lastNum
-
firstNum
)
/
2
+
firstNum
;
MOZ_ASSERT
(
firstNum
<
=
curNum
&
&
curNum
<
=
lastNum
"
Bad
binary
search
"
)
;
}
if
(
curNum
=
=
mNodeArray
.
Length
(
)
)
{
return
GetNextCharPointFromPointInText
(
EditorDOMPointInText
:
:
AtEndOf
(
mNodeArray
[
curNum
-
1
]
)
)
;
}
return
GetNextCharPointFromPointInText
(
EditorDOMPointInText
(
mNodeArray
[
curNum
]
0
)
)
;
}
template
<
typename
PT
typename
CT
>
EditorDOMPointInText
WSRunScanner
:
:
LookForPreviousCharPointWithinAllTextNodes
(
const
EditorDOMPointBase
<
PT
CT
>
&
aPoint
)
const
{
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
uint32_t
numNodes
=
mNodeArray
.
Length
(
)
;
if
(
!
numNodes
)
{
return
EditorDOMPointInText
(
)
;
}
uint32_t
firstNum
=
0
curNum
=
numNodes
/
2
lastNum
=
numNodes
;
int16_t
cmp
=
0
;
while
(
curNum
!
=
lastNum
)
{
Text
*
curNode
=
mNodeArray
[
curNum
]
;
cmp
=
*
nsContentUtils
:
:
ComparePoints
(
aPoint
.
ToRawRangeBoundary
(
)
RawRangeBoundary
(
curNode
0u
)
)
;
if
(
cmp
<
0
)
{
lastNum
=
curNum
;
}
else
{
firstNum
=
curNum
+
1
;
}
curNum
=
(
lastNum
-
firstNum
)
/
2
+
firstNum
;
MOZ_ASSERT
(
firstNum
<
=
curNum
&
&
curNum
<
=
lastNum
"
Bad
binary
search
"
)
;
}
if
(
curNum
=
=
mNodeArray
.
Length
(
)
)
{
return
GetPreviousCharPointFromPointInText
(
EditorDOMPointInText
:
:
AtEndOf
(
mNodeArray
[
curNum
-
1
]
)
)
;
}
return
GetPreviousCharPointFromPointInText
(
EditorDOMPointInText
(
mNodeArray
[
curNum
]
0
)
)
;
}
nsresult
WSRunObject
:
:
CheckTrailingNBSPOfRun
(
WSFragment
*
aRun
)
{
if
(
NS_WARN_IF
(
!
aRun
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
leftCheck
=
false
;
bool
spaceNBSP
=
false
;
bool
rightCheck
=
false
;
if
(
!
aRun
-
>
IsVisibleAndMiddleOfHardLine
(
)
)
{
return
NS_ERROR_FAILURE
;
}
EditorDOMPointInText
atPreviousCharOfEndOfRun
=
GetPreviousCharPoint
(
aRun
-
>
EndPoint
(
)
)
;
if
(
atPreviousCharOfEndOfRun
.
IsSet
(
)
&
&
!
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
&
&
atPreviousCharOfEndOfRun
.
IsCharNBSP
(
)
)
{
EditorDOMPointInText
atPreviousCharOfPreviousCharOfEndOfRun
=
GetPreviousCharPointFromPointInText
(
atPreviousCharOfEndOfRun
)
;
if
(
atPreviousCharOfPreviousCharOfEndOfRun
.
IsSet
(
)
)
{
if
(
atPreviousCharOfPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsCharASCIISpace
(
)
)
{
leftCheck
=
true
;
}
else
{
spaceNBSP
=
true
;
}
}
else
if
(
aRun
-
>
StartsFromNormalText
(
)
|
|
aRun
-
>
StartsFromSpecialContent
(
)
)
{
leftCheck
=
true
;
}
if
(
leftCheck
|
|
spaceNBSP
)
{
if
(
aRun
-
>
EndsByNormalText
(
)
|
|
aRun
-
>
EndsBySpecialContent
(
)
|
|
aRun
-
>
EndsByBRElement
(
)
)
{
rightCheck
=
true
;
}
if
(
(
aRun
-
>
EndsByBlockBoundary
(
)
)
&
&
(
IsBlockNode
(
GetEditableBlockParentOrTopmotEditableInlineContent
(
mScanStartPoint
.
GetContainerAsContent
(
)
)
)
|
|
IsBlockNode
(
mScanStartPoint
.
GetContainerAsContent
(
)
)
)
)
{
RefPtr
<
Element
>
brElement
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertBRElementWithTransaction
(
aRun
-
>
EndPoint
(
)
)
;
if
(
!
brElement
)
{
NS_WARNING
(
"
HTMLEditor
:
:
InsertBRElementWithTransaction
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
atPreviousCharOfEndOfRun
=
GetPreviousCharPoint
(
aRun
-
>
EndPoint
(
)
)
;
atPreviousCharOfPreviousCharOfEndOfRun
=
GetPreviousCharPointFromPointInText
(
atPreviousCharOfEndOfRun
)
;
rightCheck
=
true
;
}
}
if
(
leftCheck
&
&
rightCheck
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextIntoTextNodeWithTransaction
(
NS_LITERAL_STRING
(
"
"
)
atPreviousCharOfEndOfRun
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_ASSERTION
(
!
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
&
&
!
atPreviousCharOfEndOfRun
.
IsAtLastContent
(
)
"
The
text
node
was
modified
by
mutation
event
listener
"
)
;
if
(
!
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
&
&
!
atPreviousCharOfEndOfRun
.
IsAtLastContent
(
)
)
{
NS_ASSERTION
(
atPreviousCharOfEndOfRun
.
IsNextCharNBSP
(
)
"
Trying
to
remove
an
NBSP
but
it
'
s
gone
from
the
"
"
expected
position
"
)
;
EditorDOMPointInText
atNextCharOfPreviousCharOfEndOfRun
=
atPreviousCharOfEndOfRun
.
NextPoint
(
)
;
nsresult
rv
=
DeleteRange
(
atNextCharOfPreviousCharOfEndOfRun
atNextCharOfPreviousCharOfEndOfRun
.
NextPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
}
else
if
(
!
mPRE
&
&
spaceNBSP
&
&
rightCheck
)
{
MOZ_ASSERT
(
!
atPreviousCharOfPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
)
;
EditorDOMPointInText
start
end
;
Tie
(
start
end
)
=
GetASCIIWhitespacesBounds
(
eBoth
atPreviousCharOfPreviousCharOfEndOfRun
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
start
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
return
start
point
"
)
;
NS_WARNING_ASSERTION
(
end
.
IsSet
(
)
"
WSRunObject
:
:
GetASCIIWhitespacesBounds
(
)
didn
'
t
"
"
return
end
point
but
ignored
"
)
;
NS_ASSERTION
(
!
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
"
The
text
node
was
modified
by
mutation
event
listener
"
)
;
if
(
!
atPreviousCharOfEndOfRun
.
IsEndOfContainer
(
)
)
{
NS_ASSERTION
(
atPreviousCharOfEndOfRun
.
IsCharNBSP
(
)
"
Trying
to
remove
an
NBSP
but
it
'
s
gone
from
the
"
"
expected
position
"
)
;
nsresult
rv
=
DeleteRange
(
atPreviousCharOfEndOfRun
atPreviousCharOfEndOfRun
.
NextPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
NS_ASSERTION
(
start
.
IsSetAndValid
(
)
"
The
text
node
was
modified
by
mutation
event
listener
"
)
;
if
(
start
.
IsSetAndValid
(
)
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextIntoTextNodeWithTransaction
(
nsDependentSubstring
(
&
kNBSP
1
)
start
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
}
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
ReplacePreviousNBSPIfUnnecessary
(
WSFragment
*
aRun
const
EditorDOMPoint
&
aPoint
)
{
if
(
NS_WARN_IF
(
!
aRun
)
|
|
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
aPoint
.
IsSetAndValid
(
)
)
;
bool
canConvert
=
false
;
EditorDOMPointInText
atPreviousChar
=
GetPreviousCharPoint
(
aPoint
)
;
if
(
atPreviousChar
.
IsSet
(
)
&
&
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
atPreviousChar
.
IsCharNBSP
(
)
)
{
EditorDOMPointInText
atPreviousCharOfPreviousChar
=
GetPreviousCharPointFromPointInText
(
atPreviousChar
)
;
if
(
atPreviousCharOfPreviousChar
.
IsSet
(
)
)
{
if
(
atPreviousCharOfPreviousChar
.
IsEndOfContainer
(
)
|
|
!
atPreviousCharOfPreviousChar
.
IsCharASCIISpace
(
)
)
{
canConvert
=
true
;
}
}
else
if
(
aRun
-
>
StartsFromNormalText
(
)
|
|
aRun
-
>
StartsFromSpecialContent
(
)
)
{
canConvert
=
true
;
}
}
if
(
!
canConvert
)
{
return
NS_OK
;
}
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextIntoTextNodeWithTransaction
(
NS_LITERAL_STRING
(
"
"
)
atPreviousChar
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_ASSERTION
(
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
!
atPreviousChar
.
IsAtLastContent
(
)
"
The
text
node
was
modified
by
mutation
event
listener
"
)
;
if
(
!
atPreviousChar
.
IsEndOfContainer
(
)
&
&
!
atPreviousChar
.
IsAtLastContent
(
)
)
{
NS_ASSERTION
(
atPreviousChar
.
IsNextCharNBSP
(
)
"
Trying
to
remove
an
NBSP
but
it
'
s
gone
from
the
expected
position
"
)
;
EditorDOMPointInText
atNextCharOfPreviousChar
=
atPreviousChar
.
NextPoint
(
)
;
nsresult
rv
=
DeleteRange
(
atNextCharOfPreviousChar
atNextCharOfPreviousChar
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
CheckLeadingNBSP
(
WSFragment
*
aRun
nsINode
*
aNode
int32_t
aOffset
)
{
bool
canConvert
=
false
;
EditorDOMPointInText
atNextChar
=
GetNextCharPoint
(
EditorRawDOMPoint
(
aNode
aOffset
)
)
;
if
(
!
atNextChar
.
IsSet
(
)
|
|
NS_WARN_IF
(
atNextChar
.
IsEndOfContainer
(
)
)
)
{
return
NS_OK
;
}
if
(
atNextChar
.
IsCharNBSP
(
)
)
{
EditorDOMPointInText
atNextCharOfNextCharOfNBSP
=
GetNextCharPointFromPointInText
(
atNextChar
.
NextPoint
(
)
)
;
if
(
atNextCharOfNextCharOfNBSP
.
IsSet
(
)
)
{
if
(
atNextCharOfNextCharOfNBSP
.
IsEndOfContainer
(
)
|
|
!
atNextCharOfNextCharOfNBSP
.
IsCharASCIISpace
(
)
)
{
canConvert
=
true
;
}
}
else
if
(
aRun
-
>
EndsByNormalText
(
)
|
|
aRun
-
>
EndsBySpecialContent
(
)
|
|
aRun
-
>
EndsByBRElement
(
)
)
{
canConvert
=
true
;
}
}
if
(
canConvert
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsresult
rv
=
MOZ_KnownLive
(
mHTMLEditor
)
.
InsertTextIntoTextNodeWithTransaction
(
NS_LITERAL_STRING
(
"
"
)
atNextChar
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
EditorBase
:
:
InsertTextIntoTextNodeWithTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_ASSERTION
(
!
atNextChar
.
IsEndOfContainer
(
)
&
&
!
atNextChar
.
IsAtLastContent
(
)
"
The
text
node
was
modified
by
mutation
event
listener
"
)
;
if
(
!
atNextChar
.
IsEndOfContainer
(
)
&
&
!
atNextChar
.
IsAtLastContent
(
)
)
{
NS_ASSERTION
(
atNextChar
.
IsNextCharNBSP
(
)
"
Trying
to
remove
an
NBSP
but
it
'
s
gone
from
the
expected
position
"
)
;
EditorDOMPointInText
atNextCharOfNextChar
=
atNextChar
.
NextPoint
(
)
;
rv
=
DeleteRange
(
atNextCharOfNextChar
atNextCharOfNextChar
.
NextPoint
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
Scrub
(
)
{
for
(
WSFragment
*
run
=
mStartRun
;
run
;
run
=
run
-
>
mRight
)
{
if
(
run
-
>
IsMiddleOfHardLine
(
)
)
{
continue
;
}
nsresult
rv
=
DeleteRange
(
run
-
>
StartPoint
(
)
run
-
>
EndPoint
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
WSRunObject
:
:
DeleteRange
(
)
failed
"
)
;
return
rv
;
}
}
return
NS_OK
;
}
}
