#
include
"
WSRunObject
.
h
"
#
include
"
TextEditUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
EditorDOMPoint
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
SelectionState
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTextFragment
.
h
"
namespace
mozilla
{
using
namespace
dom
;
const
char16_t
nbsp
=
160
;
WSRunObject
:
:
WSRunObject
(
HTMLEditor
*
aHTMLEditor
nsINode
*
aNode
int32_t
aOffset
)
:
mNode
(
aNode
)
mOffset
(
aOffset
)
mPRE
(
false
)
mStartOffset
(
0
)
mEndOffset
(
0
)
mFirstNBSPOffset
(
0
)
mLastNBSPOffset
(
0
)
mStartRun
(
nullptr
)
mEndRun
(
nullptr
)
mHTMLEditor
(
aHTMLEditor
)
{
GetWSNodes
(
)
;
GetRuns
(
)
;
}
WSRunObject
:
:
WSRunObject
(
HTMLEditor
*
aHTMLEditor
nsIDOMNode
*
aNode
int32_t
aOffset
)
:
mNode
(
do_QueryInterface
(
aNode
)
)
mOffset
(
aOffset
)
mPRE
(
false
)
mStartOffset
(
0
)
mEndOffset
(
0
)
mFirstNBSPOffset
(
0
)
mLastNBSPOffset
(
0
)
mStartRun
(
nullptr
)
mEndRun
(
nullptr
)
mHTMLEditor
(
aHTMLEditor
)
{
GetWSNodes
(
)
;
GetRuns
(
)
;
}
WSRunObject
:
:
~
WSRunObject
(
)
{
ClearRuns
(
)
;
}
nsresult
WSRunObject
:
:
ScrubBlockBoundary
(
HTMLEditor
*
aHTMLEditor
BlockBoundary
aBoundary
nsINode
*
aBlock
int32_t
aOffset
)
{
NS_ENSURE_TRUE
(
aHTMLEditor
&
&
aBlock
NS_ERROR_NULL_POINTER
)
;
int32_t
offset
;
if
(
aBoundary
=
=
kBlockStart
)
{
offset
=
0
;
}
else
if
(
aBoundary
=
=
kBlockEnd
)
{
offset
=
aBlock
-
>
Length
(
)
;
}
else
{
NS_ENSURE_STATE
(
aOffset
>
=
0
)
;
offset
=
aOffset
;
}
WSRunObject
theWSObj
(
aHTMLEditor
aBlock
offset
)
;
return
theWSObj
.
Scrub
(
)
;
}
nsresult
WSRunObject
:
:
PrepareToJoinBlocks
(
HTMLEditor
*
aHTMLEditor
Element
*
aLeftBlock
Element
*
aRightBlock
)
{
NS_ENSURE_TRUE
(
aLeftBlock
&
&
aRightBlock
&
&
aHTMLEditor
NS_ERROR_NULL_POINTER
)
;
WSRunObject
leftWSObj
(
aHTMLEditor
aLeftBlock
aLeftBlock
-
>
Length
(
)
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
aRightBlock
0
)
;
return
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRange
(
HTMLEditor
*
aHTMLEditor
nsCOMPtr
<
nsINode
>
*
aStartNode
int32_t
*
aStartOffset
nsCOMPtr
<
nsINode
>
*
aEndNode
int32_t
*
aEndOffset
)
{
NS_ENSURE_TRUE
(
aHTMLEditor
&
&
aStartNode
&
&
*
aStartNode
&
&
aStartOffset
&
&
aEndNode
&
&
*
aEndNode
&
&
aEndOffset
NS_ERROR_NULL_POINTER
)
;
AutoTrackDOMPoint
trackerStart
(
aHTMLEditor
-
>
mRangeUpdater
aStartNode
aStartOffset
)
;
AutoTrackDOMPoint
trackerEnd
(
aHTMLEditor
-
>
mRangeUpdater
aEndNode
aEndOffset
)
;
WSRunObject
leftWSObj
(
aHTMLEditor
*
aStartNode
*
aStartOffset
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
*
aEndNode
*
aEndOffset
)
;
return
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteNode
(
HTMLEditor
*
aHTMLEditor
nsIContent
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
&
&
aHTMLEditor
NS_ERROR_NULL_POINTER
)
;
nsCOMPtr
<
nsINode
>
parent
=
aContent
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
parent
)
;
int32_t
offset
=
parent
-
>
IndexOf
(
aContent
)
;
WSRunObject
leftWSObj
(
aHTMLEditor
parent
offset
)
;
WSRunObject
rightWSObj
(
aHTMLEditor
parent
offset
+
1
)
;
return
leftWSObj
.
PrepareToDeleteRangePriv
(
&
rightWSObj
)
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocks
(
HTMLEditor
*
aHTMLEditor
nsCOMPtr
<
nsINode
>
*
aSplitNode
int32_t
*
aSplitOffset
)
{
NS_ENSURE_TRUE
(
aHTMLEditor
&
&
aSplitNode
&
&
*
aSplitNode
&
&
aSplitOffset
NS_ERROR_NULL_POINTER
)
;
AutoTrackDOMPoint
tracker
(
aHTMLEditor
-
>
mRangeUpdater
aSplitNode
aSplitOffset
)
;
WSRunObject
wsObj
(
aHTMLEditor
*
aSplitNode
*
aSplitOffset
)
;
return
wsObj
.
PrepareToSplitAcrossBlocksPriv
(
)
;
}
already_AddRefed
<
Element
>
WSRunObject
:
:
InsertBreak
(
nsCOMPtr
<
nsINode
>
*
aInOutParent
int32_t
*
aInOutOffset
nsIEditor
:
:
EDirection
aSelect
)
{
NS_ENSURE_TRUE
(
aInOutParent
&
&
aInOutOffset
nullptr
)
;
WSFragment
*
beforeRun
*
afterRun
;
FindRun
(
*
aInOutParent
*
aInOutOffset
&
beforeRun
false
)
;
FindRun
(
*
aInOutParent
*
aInOutOffset
&
afterRun
true
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
-
>
mRangeUpdater
aInOutParent
aInOutOffset
)
;
if
(
!
afterRun
|
|
(
afterRun
-
>
mType
&
WSType
:
:
trailingWS
)
)
{
}
else
if
(
afterRun
-
>
mType
&
WSType
:
:
leadingWS
)
{
nsresult
rv
=
DeleteChars
(
*
aInOutParent
*
aInOutOffset
afterRun
-
>
mEndNode
afterRun
-
>
mEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
else
if
(
afterRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
WSPoint
thePoint
=
GetCharAfter
(
*
aInOutParent
*
aInOutOffset
)
;
if
(
thePoint
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
thePoint
.
mChar
)
)
{
WSPoint
prevPoint
=
GetCharBefore
(
thePoint
)
;
if
(
!
prevPoint
.
mTextNode
|
|
(
prevPoint
.
mTextNode
&
&
!
nsCRT
:
:
IsAsciiSpace
(
prevPoint
.
mChar
)
)
)
{
nsresult
rv
=
ConvertToNBSP
(
thePoint
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
}
}
if
(
!
beforeRun
|
|
(
beforeRun
-
>
mType
&
WSType
:
:
leadingWS
)
)
{
}
else
if
(
beforeRun
-
>
mType
&
WSType
:
:
trailingWS
)
{
nsresult
rv
=
DeleteChars
(
beforeRun
-
>
mStartNode
beforeRun
-
>
mStartOffset
*
aInOutParent
*
aInOutOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
else
if
(
beforeRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
nsresult
rv
=
CheckTrailingNBSP
(
beforeRun
*
aInOutParent
*
aInOutOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
}
RefPtr
<
Selection
>
selection
=
mHTMLEditor
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
nullptr
;
}
RefPtr
<
Element
>
newBRElement
=
mHTMLEditor
-
>
CreateBRImpl
(
*
selection
EditorRawDOMPoint
(
*
aInOutParent
*
aInOutOffset
)
aSelect
)
;
if
(
NS_WARN_IF
(
!
newBRElement
)
)
{
return
nullptr
;
}
EditorRawDOMPoint
atNewBRElement
(
newBRElement
)
;
DebugOnly
<
bool
>
advanced
=
atNewBRElement
.
AdvanceOffset
(
)
;
NS_WARNING_ASSERTION
(
advanced
"
Failed
to
advance
offset
to
after
the
new
<
br
>
element
"
)
;
*
aInOutParent
=
atNewBRElement
.
Container
(
)
;
*
aInOutOffset
=
atNewBRElement
.
Offset
(
)
;
return
newBRElement
.
forget
(
)
;
}
nsresult
WSRunObject
:
:
InsertText
(
nsIDocument
&
aDocument
const
nsAString
&
aStringToInsert
const
EditorRawDOMPoint
&
aPointToInsert
EditorRawDOMPoint
*
aPointAfterInsertedString
)
{
if
(
NS_WARN_IF
(
!
aPointToInsert
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
MOZ_ASSERT
(
aPointToInsert
.
IsSet
(
)
)
;
if
(
aStringToInsert
.
IsEmpty
(
)
)
{
if
(
aPointAfterInsertedString
)
{
*
aPointAfterInsertedString
=
aPointToInsert
;
}
return
NS_OK
;
}
EditorDOMPoint
pointToInsert
(
aPointToInsert
)
;
nsAutoString
theString
(
aStringToInsert
)
;
WSFragment
*
beforeRun
*
afterRun
;
FindRun
(
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
&
beforeRun
false
)
;
FindRun
(
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
&
afterRun
true
)
;
{
AutoTrackDOMPoint
tracker
(
mHTMLEditor
-
>
mRangeUpdater
&
pointToInsert
)
;
if
(
!
afterRun
|
|
afterRun
-
>
mType
&
WSType
:
:
trailingWS
)
{
}
else
if
(
afterRun
-
>
mType
&
WSType
:
:
leadingWS
)
{
nsresult
rv
=
DeleteChars
(
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
afterRun
-
>
mEndNode
afterRun
-
>
mEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
afterRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
nsresult
rv
=
CheckLeadingNBSP
(
afterRun
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
beforeRun
|
|
beforeRun
-
>
mType
&
WSType
:
:
leadingWS
)
{
}
else
if
(
beforeRun
-
>
mType
&
WSType
:
:
trailingWS
)
{
nsresult
rv
=
DeleteChars
(
beforeRun
-
>
mStartNode
beforeRun
-
>
mStartOffset
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
beforeRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
nsresult
rv
=
CheckTrailingNBSP
(
beforeRun
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
0
]
)
)
{
if
(
beforeRun
)
{
if
(
beforeRun
-
>
mType
&
WSType
:
:
leadingWS
)
{
theString
.
SetCharAt
(
nbsp
0
)
;
}
else
if
(
beforeRun
-
>
mType
&
WSType
:
:
normalWS
)
{
WSPoint
wspoint
=
GetCharBefore
(
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
if
(
wspoint
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
wspoint
.
mChar
)
)
{
theString
.
SetCharAt
(
nbsp
0
)
;
}
}
}
else
if
(
mStartReason
&
WSType
:
:
block
|
|
mStartReason
=
=
WSType
:
:
br
)
{
theString
.
SetCharAt
(
nbsp
0
)
;
}
}
uint32_t
lastCharIndex
=
theString
.
Length
(
)
-
1
;
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
lastCharIndex
]
)
)
{
if
(
afterRun
)
{
if
(
afterRun
-
>
mType
&
WSType
:
:
trailingWS
)
{
theString
.
SetCharAt
(
nbsp
lastCharIndex
)
;
}
else
if
(
afterRun
-
>
mType
&
WSType
:
:
normalWS
)
{
WSPoint
wspoint
=
GetCharAfter
(
pointToInsert
.
Container
(
)
pointToInsert
.
Offset
(
)
)
;
if
(
wspoint
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
wspoint
.
mChar
)
)
{
theString
.
SetCharAt
(
nbsp
lastCharIndex
)
;
}
}
}
else
if
(
mEndReason
&
WSType
:
:
block
)
{
theString
.
SetCharAt
(
nbsp
lastCharIndex
)
;
}
}
bool
prevWS
=
false
;
for
(
uint32_t
i
=
0
;
i
<
=
lastCharIndex
;
i
+
+
)
{
if
(
nsCRT
:
:
IsAsciiSpace
(
theString
[
i
]
)
)
{
if
(
prevWS
)
{
theString
.
SetCharAt
(
nbsp
i
-
1
)
;
}
else
{
prevWS
=
true
;
}
}
else
{
prevWS
=
false
;
}
}
nsresult
rv
=
mHTMLEditor
-
>
InsertTextImpl
(
aDocument
theString
pointToInsert
.
AsRaw
(
)
aPointAfterInsertedString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSBackward
(
)
{
WSPoint
point
=
GetCharBefore
(
mNode
mOffset
)
;
NS_ENSURE_TRUE
(
point
.
mTextNode
NS_OK
)
;
if
(
mPRE
&
&
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
|
|
point
.
mChar
=
=
nbsp
)
)
{
return
DeleteChars
(
point
.
mTextNode
point
.
mOffset
point
.
mTextNode
point
.
mOffset
+
1
)
;
}
if
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
RefPtr
<
Text
>
startNodeText
endNodeText
;
int32_t
startOffset
endOffset
;
GetAsciiWSBounds
(
eBoth
point
.
mTextNode
point
.
mOffset
+
1
getter_AddRefs
(
startNodeText
)
&
startOffset
getter_AddRefs
(
endNodeText
)
&
endOffset
)
;
nsCOMPtr
<
nsINode
>
startNode
=
startNodeText
.
get
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
endNodeText
.
get
(
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DeleteChars
(
startNode
startOffset
endNode
endOffset
)
;
}
if
(
point
.
mChar
=
=
nbsp
)
{
nsCOMPtr
<
nsINode
>
node
(
point
.
mTextNode
)
;
int32_t
startOffset
=
point
.
mOffset
;
int32_t
endOffset
=
point
.
mOffset
+
1
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
node
)
&
startOffset
address_of
(
node
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DeleteChars
(
node
startOffset
node
endOffset
)
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteWSForward
(
)
{
WSPoint
point
=
GetCharAfter
(
mNode
mOffset
)
;
NS_ENSURE_TRUE
(
point
.
mTextNode
NS_OK
)
;
if
(
mPRE
&
&
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
|
|
point
.
mChar
=
=
nbsp
)
)
{
return
DeleteChars
(
point
.
mTextNode
point
.
mOffset
point
.
mTextNode
point
.
mOffset
+
1
)
;
}
if
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
RefPtr
<
Text
>
startNodeText
endNodeText
;
int32_t
startOffset
endOffset
;
GetAsciiWSBounds
(
eBoth
point
.
mTextNode
point
.
mOffset
+
1
getter_AddRefs
(
startNodeText
)
&
startOffset
getter_AddRefs
(
endNodeText
)
&
endOffset
)
;
nsCOMPtr
<
nsINode
>
startNode
(
startNodeText
)
endNode
(
endNodeText
)
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
startNode
)
&
startOffset
address_of
(
endNode
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DeleteChars
(
startNode
startOffset
endNode
endOffset
)
;
}
if
(
point
.
mChar
=
=
nbsp
)
{
nsCOMPtr
<
nsINode
>
node
(
point
.
mTextNode
)
;
int32_t
startOffset
=
point
.
mOffset
;
int32_t
endOffset
=
point
.
mOffset
+
1
;
nsresult
rv
=
WSRunObject
:
:
PrepareToDeleteRange
(
mHTMLEditor
address_of
(
node
)
&
startOffset
address_of
(
node
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
DeleteChars
(
node
startOffset
node
endOffset
)
;
}
return
NS_OK
;
}
void
WSRunObject
:
:
PriorVisibleNode
(
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outVisNode
int32_t
*
outVisOffset
WSType
*
outType
)
{
MOZ_ASSERT
(
aNode
&
&
outVisNode
&
&
outVisOffset
&
&
outType
)
;
WSFragment
*
run
;
FindRun
(
aNode
aOffset
&
run
false
)
;
for
(
;
run
;
run
=
run
-
>
mLeft
)
{
if
(
run
-
>
mType
=
=
WSType
:
:
normalWS
)
{
WSPoint
point
=
GetCharBefore
(
aNode
aOffset
)
;
if
(
point
.
mTextNode
&
&
point
.
mTextNode
-
>
Length
(
)
)
{
*
outVisNode
=
point
.
mTextNode
;
*
outVisOffset
=
point
.
mOffset
+
1
;
if
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
|
|
point
.
mChar
=
=
nbsp
)
{
*
outType
=
WSType
:
:
normalWS
;
}
else
{
*
outType
=
WSType
:
:
text
;
}
return
;
}
}
}
*
outVisNode
=
mStartReasonNode
;
*
outVisOffset
=
mStartOffset
;
*
outType
=
mStartReason
;
}
void
WSRunObject
:
:
NextVisibleNode
(
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outVisNode
int32_t
*
outVisOffset
WSType
*
outType
)
{
MOZ_ASSERT
(
aNode
&
&
outVisNode
&
&
outVisOffset
&
&
outType
)
;
WSFragment
*
run
;
FindRun
(
aNode
aOffset
&
run
true
)
;
for
(
;
run
;
run
=
run
-
>
mRight
)
{
if
(
run
-
>
mType
=
=
WSType
:
:
normalWS
)
{
WSPoint
point
=
GetCharAfter
(
aNode
aOffset
)
;
if
(
point
.
mTextNode
&
&
point
.
mTextNode
-
>
Length
(
)
)
{
*
outVisNode
=
point
.
mTextNode
;
*
outVisOffset
=
point
.
mOffset
;
if
(
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
|
|
point
.
mChar
=
=
nbsp
)
{
*
outType
=
WSType
:
:
normalWS
;
}
else
{
*
outType
=
WSType
:
:
text
;
}
return
;
}
}
}
*
outVisNode
=
mEndReasonNode
;
*
outVisOffset
=
mEndOffset
;
*
outType
=
mEndReason
;
}
nsresult
WSRunObject
:
:
AdjustWhitespace
(
)
{
if
(
!
mLastNBSPNode
)
{
return
NS_OK
;
}
WSFragment
*
curRun
=
mStartRun
;
while
(
curRun
)
{
if
(
curRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
nsresult
rv
=
CheckTrailingNBSPOfRun
(
curRun
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
curRun
=
curRun
-
>
mRight
;
}
return
NS_OK
;
}
nsINode
*
WSRunObject
:
:
GetWSBoundingParent
(
)
{
NS_ENSURE_TRUE
(
mNode
nullptr
)
;
OwningNonNull
<
nsINode
>
wsBoundingParent
=
*
mNode
;
while
(
!
IsBlockNode
(
wsBoundingParent
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
wsBoundingParent
-
>
GetParentNode
(
)
;
if
(
!
parent
|
|
!
mHTMLEditor
-
>
IsEditable
(
parent
)
)
{
break
;
}
wsBoundingParent
=
parent
;
}
return
wsBoundingParent
;
}
nsresult
WSRunObject
:
:
GetWSNodes
(
)
{
EditorDOMPoint
start
(
mNode
mOffset
)
end
(
mNode
mOffset
)
;
nsCOMPtr
<
nsINode
>
wsBoundingParent
=
GetWSBoundingParent
(
)
;
if
(
RefPtr
<
Text
>
textNode
=
mNode
-
>
GetAsText
(
)
)
{
const
nsTextFragment
*
textFrag
=
textNode
-
>
GetText
(
)
;
mNodeArray
.
InsertElementAt
(
0
textNode
)
;
if
(
mOffset
)
{
for
(
int32_t
pos
=
mOffset
-
1
;
pos
>
=
0
;
pos
-
-
)
{
if
(
uint32_t
(
pos
)
>
=
textFrag
-
>
GetLength
(
)
)
{
NS_NOTREACHED
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
nbsp
)
{
mStartNode
=
textNode
;
mStartOffset
=
pos
+
1
;
mStartReason
=
WSType
:
:
text
;
mStartReasonNode
=
textNode
;
break
;
}
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
if
(
!
mLastNBSPNode
)
{
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
}
}
start
.
Set
(
textNode
pos
)
;
}
}
}
while
(
!
mStartNode
)
{
nsCOMPtr
<
nsIContent
>
priorNode
=
GetPreviousWSNode
(
start
wsBoundingParent
)
;
if
(
priorNode
)
{
if
(
IsBlockNode
(
priorNode
)
)
{
mStartNode
=
start
.
Container
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
mStartReason
=
WSType
:
:
otherBlock
;
mStartReasonNode
=
priorNode
;
}
else
if
(
priorNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
&
&
priorNode
-
>
IsEditable
(
)
)
{
RefPtr
<
Text
>
textNode
=
priorNode
-
>
GetAsText
(
)
;
mNodeArray
.
InsertElementAt
(
0
textNode
)
;
const
nsTextFragment
*
textFrag
;
if
(
!
textNode
|
|
!
(
textFrag
=
textNode
-
>
GetText
(
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
uint32_t
len
=
textNode
-
>
TextLength
(
)
;
if
(
len
<
1
)
{
start
.
Set
(
priorNode
0
)
;
}
else
{
for
(
int32_t
pos
=
len
-
1
;
pos
>
=
0
;
pos
-
-
)
{
if
(
uint32_t
(
pos
)
>
=
textFrag
-
>
GetLength
(
)
)
{
NS_NOTREACHED
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
nbsp
)
{
mStartNode
=
textNode
;
mStartOffset
=
pos
+
1
;
mStartReason
=
WSType
:
:
text
;
mStartReasonNode
=
textNode
;
break
;
}
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
if
(
!
mLastNBSPNode
)
{
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
}
}
start
.
Set
(
textNode
pos
)
;
}
}
}
else
{
mStartNode
=
start
.
Container
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
if
(
TextEditUtils
:
:
IsBreak
(
priorNode
)
)
{
mStartReason
=
WSType
:
:
br
;
}
else
{
mStartReason
=
WSType
:
:
special
;
}
mStartReasonNode
=
priorNode
;
}
}
else
{
mStartNode
=
start
.
Container
(
)
;
mStartOffset
=
start
.
Offset
(
)
;
mStartReason
=
WSType
:
:
thisBlock
;
mStartReasonNode
=
wsBoundingParent
;
}
}
if
(
RefPtr
<
Text
>
textNode
=
mNode
-
>
GetAsText
(
)
)
{
const
nsTextFragment
*
textFrag
=
textNode
-
>
GetText
(
)
;
uint32_t
len
=
textNode
-
>
TextLength
(
)
;
if
(
uint16_t
(
mOffset
)
<
len
)
{
for
(
uint32_t
pos
=
mOffset
;
pos
<
len
;
pos
+
+
)
{
if
(
pos
>
=
textFrag
-
>
GetLength
(
)
)
{
NS_NOTREACHED
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
nbsp
)
{
mEndNode
=
textNode
;
mEndOffset
=
pos
;
mEndReason
=
WSType
:
:
text
;
mEndReasonNode
=
textNode
;
break
;
}
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
if
(
!
mFirstNBSPNode
)
{
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
}
}
end
.
Set
(
textNode
pos
+
1
)
;
}
}
}
while
(
!
mEndNode
)
{
nsCOMPtr
<
nsIContent
>
nextNode
=
GetNextWSNode
(
end
wsBoundingParent
)
;
if
(
nextNode
)
{
if
(
IsBlockNode
(
nextNode
)
)
{
mEndNode
=
end
.
Container
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
mEndReason
=
WSType
:
:
otherBlock
;
mEndReasonNode
=
nextNode
;
}
else
if
(
nextNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
&
&
nextNode
-
>
IsEditable
(
)
)
{
RefPtr
<
Text
>
textNode
=
nextNode
-
>
GetAsText
(
)
;
mNodeArray
.
AppendElement
(
textNode
)
;
const
nsTextFragment
*
textFrag
;
if
(
!
textNode
|
|
!
(
textFrag
=
textNode
-
>
GetText
(
)
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
uint32_t
len
=
textNode
-
>
TextLength
(
)
;
if
(
len
<
1
)
{
end
.
Set
(
textNode
0
)
;
}
else
{
for
(
uint32_t
pos
=
0
;
pos
<
len
;
pos
+
+
)
{
if
(
pos
>
=
textFrag
-
>
GetLength
(
)
)
{
NS_NOTREACHED
(
"
looking
beyond
end
of
text
fragment
"
)
;
continue
;
}
char16_t
theChar
=
textFrag
-
>
CharAt
(
pos
)
;
if
(
!
nsCRT
:
:
IsAsciiSpace
(
theChar
)
)
{
if
(
theChar
!
=
nbsp
)
{
mEndNode
=
textNode
;
mEndOffset
=
pos
;
mEndReason
=
WSType
:
:
text
;
mEndReasonNode
=
textNode
;
break
;
}
mLastNBSPNode
=
textNode
;
mLastNBSPOffset
=
pos
;
if
(
!
mFirstNBSPNode
)
{
mFirstNBSPNode
=
textNode
;
mFirstNBSPOffset
=
pos
;
}
}
end
.
Set
(
textNode
pos
+
1
)
;
}
}
}
else
{
mEndNode
=
end
.
Container
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
if
(
TextEditUtils
:
:
IsBreak
(
nextNode
)
)
{
mEndReason
=
WSType
:
:
br
;
}
else
{
mEndReason
=
WSType
:
:
special
;
}
mEndReasonNode
=
nextNode
;
}
}
else
{
mEndNode
=
end
.
Container
(
)
;
mEndOffset
=
end
.
Offset
(
)
;
mEndReason
=
WSType
:
:
thisBlock
;
mEndReasonNode
=
wsBoundingParent
;
}
}
return
NS_OK
;
}
void
WSRunObject
:
:
GetRuns
(
)
{
ClearRuns
(
)
;
mHTMLEditor
-
>
IsPreformatted
(
GetAsDOMNode
(
mNode
)
&
mPRE
)
;
if
(
mPRE
|
|
(
(
mStartReason
=
=
WSType
:
:
text
|
|
mStartReason
=
=
WSType
:
:
special
)
&
&
(
mEndReason
=
=
WSType
:
:
text
|
|
mEndReason
=
=
WSType
:
:
special
|
|
mEndReason
=
=
WSType
:
:
br
)
)
)
{
MakeSingleWSRun
(
WSType
:
:
normalWS
)
;
return
;
}
if
(
!
mFirstNBSPNode
&
&
!
mLastNBSPNode
&
&
(
(
mStartReason
&
WSType
:
:
block
)
|
|
mStartReason
=
=
WSType
:
:
br
|
|
(
mEndReason
&
WSType
:
:
block
)
)
)
{
WSType
wstype
;
if
(
(
mStartReason
&
WSType
:
:
block
)
|
|
mStartReason
=
=
WSType
:
:
br
)
{
wstype
=
WSType
:
:
leadingWS
;
}
if
(
mEndReason
&
WSType
:
:
block
)
{
wstype
|
=
WSType
:
:
trailingWS
;
}
MakeSingleWSRun
(
wstype
)
;
return
;
}
mStartRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mStartNode
=
mStartNode
;
mStartRun
-
>
mStartOffset
=
mStartOffset
;
if
(
mStartReason
&
WSType
:
:
block
|
|
mStartReason
=
=
WSType
:
:
br
)
{
mStartRun
-
>
mType
=
WSType
:
:
leadingWS
;
mStartRun
-
>
mEndNode
=
mFirstNBSPNode
;
mStartRun
-
>
mEndOffset
=
mFirstNBSPOffset
;
mStartRun
-
>
mLeftType
=
mStartReason
;
mStartRun
-
>
mRightType
=
WSType
:
:
normalWS
;
WSFragment
*
normalRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mRight
=
normalRun
;
normalRun
-
>
mType
=
WSType
:
:
normalWS
;
normalRun
-
>
mStartNode
=
mFirstNBSPNode
;
normalRun
-
>
mStartOffset
=
mFirstNBSPOffset
;
normalRun
-
>
mLeftType
=
WSType
:
:
leadingWS
;
normalRun
-
>
mLeft
=
mStartRun
;
if
(
mEndReason
!
=
WSType
:
:
block
)
{
normalRun
-
>
mRightType
=
mEndReason
;
normalRun
-
>
mEndNode
=
mEndNode
;
normalRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
normalRun
;
}
else
{
if
(
mLastNBSPNode
=
=
mEndNode
&
&
mLastNBSPOffset
=
=
mEndOffset
-
1
)
{
normalRun
-
>
mRightType
=
mEndReason
;
normalRun
-
>
mEndNode
=
mEndNode
;
normalRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
normalRun
;
}
else
{
normalRun
-
>
mEndNode
=
mLastNBSPNode
;
normalRun
-
>
mEndOffset
=
mLastNBSPOffset
+
1
;
normalRun
-
>
mRightType
=
WSType
:
:
trailingWS
;
WSFragment
*
lastRun
=
new
WSFragment
(
)
;
lastRun
-
>
mType
=
WSType
:
:
trailingWS
;
lastRun
-
>
mStartNode
=
mLastNBSPNode
;
lastRun
-
>
mStartOffset
=
mLastNBSPOffset
+
1
;
lastRun
-
>
mEndNode
=
mEndNode
;
lastRun
-
>
mEndOffset
=
mEndOffset
;
lastRun
-
>
mLeftType
=
WSType
:
:
normalWS
;
lastRun
-
>
mLeft
=
normalRun
;
lastRun
-
>
mRightType
=
mEndReason
;
mEndRun
=
lastRun
;
normalRun
-
>
mRight
=
lastRun
;
}
}
}
else
{
mStartRun
-
>
mType
=
WSType
:
:
normalWS
;
mStartRun
-
>
mEndNode
=
mLastNBSPNode
;
mStartRun
-
>
mEndOffset
=
mLastNBSPOffset
+
1
;
mStartRun
-
>
mLeftType
=
mStartReason
;
if
(
mLastNBSPNode
=
=
mEndNode
&
&
mLastNBSPOffset
=
=
(
mEndOffset
-
1
)
)
{
mStartRun
-
>
mRightType
=
mEndReason
;
mStartRun
-
>
mEndNode
=
mEndNode
;
mStartRun
-
>
mEndOffset
=
mEndOffset
;
mEndRun
=
mStartRun
;
}
else
{
WSFragment
*
lastRun
=
new
WSFragment
(
)
;
lastRun
-
>
mType
=
WSType
:
:
trailingWS
;
lastRun
-
>
mStartNode
=
mLastNBSPNode
;
lastRun
-
>
mStartOffset
=
mLastNBSPOffset
+
1
;
lastRun
-
>
mLeftType
=
WSType
:
:
normalWS
;
lastRun
-
>
mLeft
=
mStartRun
;
lastRun
-
>
mRightType
=
mEndReason
;
mEndRun
=
lastRun
;
mStartRun
-
>
mRight
=
lastRun
;
mStartRun
-
>
mRightType
=
WSType
:
:
trailingWS
;
}
}
}
void
WSRunObject
:
:
ClearRuns
(
)
{
WSFragment
*
tmp
*
run
;
run
=
mStartRun
;
while
(
run
)
{
tmp
=
run
-
>
mRight
;
delete
run
;
run
=
tmp
;
}
mStartRun
=
0
;
mEndRun
=
0
;
}
void
WSRunObject
:
:
MakeSingleWSRun
(
WSType
aType
)
{
mStartRun
=
new
WSFragment
(
)
;
mStartRun
-
>
mStartNode
=
mStartNode
;
mStartRun
-
>
mStartOffset
=
mStartOffset
;
mStartRun
-
>
mType
=
aType
;
mStartRun
-
>
mEndNode
=
mEndNode
;
mStartRun
-
>
mEndOffset
=
mEndOffset
;
mStartRun
-
>
mLeftType
=
mStartReason
;
mStartRun
-
>
mRightType
=
mEndReason
;
mEndRun
=
mStartRun
;
}
nsIContent
*
WSRunObject
:
:
GetPreviousWSNodeInner
(
nsINode
*
aStartNode
nsINode
*
aBlockParent
)
{
MOZ_ASSERT
(
aStartNode
&
&
aBlockParent
)
;
nsCOMPtr
<
nsIContent
>
priorNode
=
aStartNode
-
>
GetPreviousSibling
(
)
;
OwningNonNull
<
nsINode
>
curNode
=
*
aStartNode
;
while
(
!
priorNode
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
curParent
nullptr
)
;
if
(
curParent
=
=
aBlockParent
)
{
return
nullptr
;
}
priorNode
=
curParent
-
>
GetPreviousSibling
(
)
;
curNode
=
curParent
;
}
if
(
IsBlockNode
(
priorNode
)
)
{
return
priorNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
priorNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetRightmostChild
(
priorNode
)
;
if
(
child
)
{
return
child
;
}
}
return
priorNode
;
}
nsIContent
*
WSRunObject
:
:
GetPreviousWSNode
(
const
EditorDOMPoint
&
aPoint
nsINode
*
aBlockParent
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
&
&
aBlockParent
)
;
if
(
aPoint
.
Container
(
)
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
{
return
GetPreviousWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
!
mHTMLEditor
-
>
IsContainer
(
aPoint
.
Container
(
)
)
)
{
return
GetPreviousWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
!
aPoint
.
Offset
(
)
)
{
if
(
aPoint
.
Container
(
)
=
=
aBlockParent
)
{
return
nullptr
;
}
return
GetPreviousWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
priorNode
=
aPoint
.
GetPreviousSiblingOfChildAtOffset
(
)
;
if
(
NS_WARN_IF
(
!
priorNode
)
)
{
return
nullptr
;
}
if
(
IsBlockNode
(
priorNode
)
)
{
return
priorNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
priorNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetRightmostChild
(
priorNode
)
;
if
(
child
)
{
return
child
;
}
}
return
priorNode
;
}
nsIContent
*
WSRunObject
:
:
GetNextWSNodeInner
(
nsINode
*
aStartNode
nsINode
*
aBlockParent
)
{
MOZ_ASSERT
(
aStartNode
&
&
aBlockParent
)
;
nsCOMPtr
<
nsIContent
>
nextNode
=
aStartNode
-
>
GetNextSibling
(
)
;
nsCOMPtr
<
nsINode
>
curNode
=
aStartNode
;
while
(
!
nextNode
)
{
nsCOMPtr
<
nsINode
>
curParent
=
curNode
-
>
GetParentNode
(
)
;
NS_ENSURE_TRUE
(
curParent
nullptr
)
;
if
(
curParent
=
=
aBlockParent
)
{
return
nullptr
;
}
nextNode
=
curParent
-
>
GetNextSibling
(
)
;
curNode
=
curParent
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
nextNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
nextNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetLeftmostChild
(
nextNode
)
;
if
(
child
)
{
return
child
;
}
}
return
nextNode
;
}
nsIContent
*
WSRunObject
:
:
GetNextWSNode
(
const
EditorDOMPoint
&
aPoint
nsINode
*
aBlockParent
)
{
MOZ_ASSERT
(
aPoint
.
IsSet
(
)
&
&
aBlockParent
)
;
if
(
aPoint
.
Container
(
)
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
TEXT_NODE
)
{
return
GetNextWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
!
mHTMLEditor
-
>
IsContainer
(
aPoint
.
Container
(
)
)
)
{
return
GetNextWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
NS_WARN_IF
(
!
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
nextNode
=
aPoint
.
GetChildAtOffset
(
)
;
if
(
!
nextNode
)
{
if
(
aPoint
.
Container
(
)
=
=
aBlockParent
)
{
return
nullptr
;
}
return
GetNextWSNodeInner
(
aPoint
.
Container
(
)
aBlockParent
)
;
}
if
(
IsBlockNode
(
nextNode
)
)
{
return
nextNode
;
}
if
(
mHTMLEditor
-
>
IsContainer
(
nextNode
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
mHTMLEditor
-
>
GetLeftmostChild
(
nextNode
)
;
if
(
child
)
{
return
child
;
}
}
return
nextNode
;
}
nsresult
WSRunObject
:
:
PrepareToDeleteRangePriv
(
WSRunObject
*
aEndObject
)
{
NS_ENSURE_TRUE
(
aEndObject
NS_ERROR_NULL_POINTER
)
;
WSFragment
*
beforeRun
*
afterRun
;
FindRun
(
mNode
mOffset
&
beforeRun
false
)
;
aEndObject
-
>
FindRun
(
aEndObject
-
>
mNode
aEndObject
-
>
mOffset
&
afterRun
true
)
;
if
(
afterRun
&
&
(
afterRun
-
>
mType
&
WSType
:
:
leadingWS
)
)
{
nsresult
rv
=
aEndObject
-
>
DeleteChars
(
aEndObject
-
>
mNode
aEndObject
-
>
mOffset
afterRun
-
>
mEndNode
afterRun
-
>
mEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
afterRun
&
&
afterRun
-
>
mType
=
=
WSType
:
:
normalWS
&
&
!
aEndObject
-
>
mPRE
)
{
if
(
(
beforeRun
&
&
(
beforeRun
-
>
mType
&
WSType
:
:
leadingWS
)
)
|
|
(
!
beforeRun
&
&
(
(
mStartReason
&
WSType
:
:
block
)
|
|
mStartReason
=
=
WSType
:
:
br
)
)
)
{
WSPoint
point
=
aEndObject
-
>
GetCharAfter
(
aEndObject
-
>
mNode
aEndObject
-
>
mOffset
)
;
if
(
point
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
nsresult
rv
=
aEndObject
-
>
ConvertToNBSP
(
point
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
if
(
beforeRun
&
&
(
beforeRun
-
>
mType
&
WSType
:
:
trailingWS
)
)
{
nsresult
rv
=
DeleteChars
(
beforeRun
-
>
mStartNode
beforeRun
-
>
mStartOffset
mNode
mOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
beforeRun
&
&
beforeRun
-
>
mType
=
=
WSType
:
:
normalWS
&
&
!
mPRE
)
{
if
(
(
afterRun
&
&
(
afterRun
-
>
mType
&
WSType
:
:
trailingWS
)
)
|
|
(
afterRun
&
&
afterRun
-
>
mType
=
=
WSType
:
:
normalWS
)
|
|
(
!
afterRun
&
&
(
aEndObject
-
>
mEndReason
&
WSType
:
:
block
)
)
)
{
WSPoint
point
=
GetCharBefore
(
mNode
mOffset
)
;
if
(
point
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
RefPtr
<
Text
>
wsStartNode
wsEndNode
;
int32_t
wsStartOffset
wsEndOffset
;
GetAsciiWSBounds
(
eBoth
mNode
mOffset
getter_AddRefs
(
wsStartNode
)
&
wsStartOffset
getter_AddRefs
(
wsEndNode
)
&
wsEndOffset
)
;
point
.
mTextNode
=
wsStartNode
;
point
.
mOffset
=
wsStartOffset
;
nsresult
rv
=
ConvertToNBSP
(
point
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
PrepareToSplitAcrossBlocksPriv
(
)
{
WSFragment
*
beforeRun
*
afterRun
;
FindRun
(
mNode
mOffset
&
beforeRun
false
)
;
FindRun
(
mNode
mOffset
&
afterRun
true
)
;
if
(
afterRun
&
&
afterRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
WSPoint
point
=
GetCharAfter
(
mNode
mOffset
)
;
if
(
point
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
nsresult
rv
=
ConvertToNBSP
(
point
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
beforeRun
&
&
beforeRun
-
>
mType
=
=
WSType
:
:
normalWS
)
{
WSPoint
point
=
GetCharBefore
(
mNode
mOffset
)
;
if
(
point
.
mTextNode
&
&
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
)
{
RefPtr
<
Text
>
wsStartNode
wsEndNode
;
int32_t
wsStartOffset
wsEndOffset
;
GetAsciiWSBounds
(
eBoth
mNode
mOffset
getter_AddRefs
(
wsStartNode
)
&
wsStartOffset
getter_AddRefs
(
wsEndNode
)
&
wsEndOffset
)
;
point
.
mTextNode
=
wsStartNode
;
point
.
mOffset
=
wsStartOffset
;
nsresult
rv
=
ConvertToNBSP
(
point
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
DeleteChars
(
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
NS_ENSURE_TRUE
(
aStartNode
&
&
aEndNode
NS_ERROR_NULL_POINTER
)
;
if
(
aStartNode
=
=
aEndNode
&
&
aStartOffset
=
=
aEndOffset
)
{
return
NS_OK
;
}
int32_t
idx
=
mNodeArray
.
IndexOf
(
aStartNode
)
;
if
(
idx
=
=
-
1
)
{
idx
=
0
;
}
if
(
aStartNode
=
=
aEndNode
&
&
aStartNode
-
>
GetAsText
(
)
)
{
return
mHTMLEditor
-
>
DeleteText
(
*
aStartNode
-
>
GetAsText
(
)
static_cast
<
uint32_t
>
(
aStartOffset
)
static_cast
<
uint32_t
>
(
aEndOffset
-
aStartOffset
)
)
;
}
RefPtr
<
nsRange
>
range
;
int32_t
count
=
mNodeArray
.
Length
(
)
;
for
(
;
idx
<
count
;
idx
+
+
)
{
RefPtr
<
Text
>
node
=
mNodeArray
[
idx
]
;
if
(
!
node
)
{
return
NS_OK
;
}
if
(
node
=
=
aStartNode
)
{
uint32_t
len
=
node
-
>
Length
(
)
;
if
(
uint32_t
(
aStartOffset
)
<
len
)
{
nsresult
rv
=
mHTMLEditor
-
>
DeleteText
(
*
node
AssertedCast
<
uint32_t
>
(
aStartOffset
)
len
-
aStartOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
if
(
node
=
=
aEndNode
)
{
if
(
aEndOffset
)
{
nsresult
rv
=
mHTMLEditor
-
>
DeleteText
(
*
node
0
AssertedCast
<
uint32_t
>
(
aEndOffset
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
}
else
{
if
(
!
range
)
{
range
=
new
nsRange
(
aStartNode
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
nodeBefore
nodeAfter
;
nsresult
rv
=
nsRange
:
:
CompareNodeToRange
(
node
range
&
nodeBefore
&
nodeAfter
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nodeAfter
)
{
break
;
}
if
(
!
nodeBefore
)
{
rv
=
mHTMLEditor
-
>
DeleteNode
(
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mNodeArray
.
RemoveElement
(
node
)
;
-
-
count
;
-
-
idx
;
}
}
}
return
NS_OK
;
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetCharAfter
(
nsINode
*
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
int32_t
idx
=
mNodeArray
.
IndexOf
(
aNode
)
;
if
(
idx
=
=
-
1
)
{
return
GetWSPointAfter
(
aNode
aOffset
)
;
}
return
GetCharAfter
(
WSPoint
(
mNodeArray
[
idx
]
aOffset
0
)
)
;
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetCharBefore
(
nsINode
*
aNode
int32_t
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
int32_t
idx
=
mNodeArray
.
IndexOf
(
aNode
)
;
if
(
idx
=
=
-
1
)
{
return
GetWSPointBefore
(
aNode
aOffset
)
;
}
return
GetCharBefore
(
WSPoint
(
mNodeArray
[
idx
]
aOffset
0
)
)
;
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetCharAfter
(
const
WSPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
mTextNode
)
;
WSPoint
outPoint
;
outPoint
.
mTextNode
=
nullptr
;
outPoint
.
mOffset
=
0
;
outPoint
.
mChar
=
0
;
int32_t
idx
=
mNodeArray
.
IndexOf
(
aPoint
.
mTextNode
)
;
if
(
idx
=
=
-
1
)
{
return
outPoint
;
}
if
(
static_cast
<
uint16_t
>
(
aPoint
.
mOffset
)
<
aPoint
.
mTextNode
-
>
TextLength
(
)
)
{
outPoint
=
aPoint
;
outPoint
.
mChar
=
GetCharAt
(
aPoint
.
mTextNode
aPoint
.
mOffset
)
;
return
outPoint
;
}
int32_t
numNodes
=
mNodeArray
.
Length
(
)
;
if
(
idx
+
1
<
numNodes
)
{
outPoint
.
mTextNode
=
mNodeArray
[
idx
+
1
]
;
MOZ_ASSERT
(
outPoint
.
mTextNode
)
;
outPoint
.
mOffset
=
0
;
outPoint
.
mChar
=
GetCharAt
(
outPoint
.
mTextNode
0
)
;
}
return
outPoint
;
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetCharBefore
(
const
WSPoint
&
aPoint
)
{
MOZ_ASSERT
(
aPoint
.
mTextNode
)
;
WSPoint
outPoint
;
outPoint
.
mTextNode
=
nullptr
;
outPoint
.
mOffset
=
0
;
outPoint
.
mChar
=
0
;
int32_t
idx
=
mNodeArray
.
IndexOf
(
aPoint
.
mTextNode
)
;
if
(
idx
=
=
-
1
)
{
return
outPoint
;
}
if
(
aPoint
.
mOffset
)
{
outPoint
=
aPoint
;
outPoint
.
mOffset
-
-
;
outPoint
.
mChar
=
GetCharAt
(
aPoint
.
mTextNode
aPoint
.
mOffset
-
1
)
;
return
outPoint
;
}
if
(
idx
)
{
outPoint
.
mTextNode
=
mNodeArray
[
idx
-
1
]
;
uint32_t
len
=
outPoint
.
mTextNode
-
>
TextLength
(
)
;
if
(
len
)
{
outPoint
.
mOffset
=
len
-
1
;
outPoint
.
mChar
=
GetCharAt
(
outPoint
.
mTextNode
len
-
1
)
;
}
}
return
outPoint
;
}
nsresult
WSRunObject
:
:
ConvertToNBSP
(
WSPoint
aPoint
)
{
NS_ENSURE_TRUE
(
aPoint
.
mTextNode
NS_ERROR_NULL_POINTER
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
nbspStr
(
nbsp
)
;
nsresult
rv
=
mHTMLEditor
-
>
InsertTextIntoTextNodeImpl
(
nbspStr
*
aPoint
.
mTextNode
aPoint
.
mOffset
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Text
>
startNode
endNode
;
int32_t
startOffset
=
0
endOffset
=
0
;
GetAsciiWSBounds
(
eAfter
aPoint
.
mTextNode
aPoint
.
mOffset
+
1
getter_AddRefs
(
startNode
)
&
startOffset
getter_AddRefs
(
endNode
)
&
endOffset
)
;
if
(
startNode
)
{
rv
=
DeleteChars
(
startNode
startOffset
endNode
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
WSRunObject
:
:
GetAsciiWSBounds
(
int16_t
aDir
nsINode
*
aNode
int32_t
aOffset
Text
*
*
outStartNode
int32_t
*
outStartOffset
Text
*
*
outEndNode
int32_t
*
outEndOffset
)
{
MOZ_ASSERT
(
aNode
&
&
outStartNode
&
&
outStartOffset
&
&
outEndNode
&
&
outEndOffset
)
;
RefPtr
<
Text
>
startNode
endNode
;
int32_t
startOffset
=
0
endOffset
=
0
;
if
(
aDir
&
eAfter
)
{
WSPoint
point
=
GetCharAfter
(
aNode
aOffset
)
;
if
(
point
.
mTextNode
)
{
startNode
=
endNode
=
point
.
mTextNode
;
startOffset
=
endOffset
=
point
.
mOffset
;
for
(
;
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
&
&
point
.
mTextNode
;
point
=
GetCharAfter
(
point
)
)
{
endNode
=
point
.
mTextNode
;
point
.
mOffset
+
+
;
endOffset
=
point
.
mOffset
;
}
}
}
if
(
aDir
&
eBefore
)
{
WSPoint
point
=
GetCharBefore
(
aNode
aOffset
)
;
if
(
point
.
mTextNode
)
{
startNode
=
point
.
mTextNode
;
startOffset
=
point
.
mOffset
+
1
;
if
(
!
endNode
)
{
endNode
=
startNode
;
endOffset
=
startOffset
;
}
for
(
;
nsCRT
:
:
IsAsciiSpace
(
point
.
mChar
)
&
&
point
.
mTextNode
;
point
=
GetCharBefore
(
point
)
)
{
startNode
=
point
.
mTextNode
;
startOffset
=
point
.
mOffset
;
}
}
}
startNode
.
forget
(
outStartNode
)
;
*
outStartOffset
=
startOffset
;
endNode
.
forget
(
outEndNode
)
;
*
outEndOffset
=
endOffset
;
}
void
WSRunObject
:
:
FindRun
(
nsINode
*
aNode
int32_t
aOffset
WSFragment
*
*
outRun
bool
after
)
{
MOZ_ASSERT
(
aNode
&
&
outRun
)
;
*
outRun
=
nullptr
;
for
(
WSFragment
*
run
=
mStartRun
;
run
;
run
=
run
-
>
mRight
)
{
int32_t
comp
=
run
-
>
mStartNode
?
nsContentUtils
:
:
ComparePoints
(
aNode
aOffset
run
-
>
mStartNode
run
-
>
mStartOffset
)
:
-
1
;
if
(
comp
<
=
0
)
{
if
(
after
)
{
*
outRun
=
run
;
}
else
{
*
outRun
=
nullptr
;
}
return
;
}
comp
=
run
-
>
mEndNode
?
nsContentUtils
:
:
ComparePoints
(
aNode
aOffset
run
-
>
mEndNode
run
-
>
mEndOffset
)
:
-
1
;
if
(
comp
<
0
)
{
*
outRun
=
run
;
return
;
}
else
if
(
!
comp
)
{
if
(
after
)
{
*
outRun
=
run
-
>
mRight
;
}
else
{
*
outRun
=
run
;
}
return
;
}
if
(
!
run
-
>
mRight
)
{
if
(
after
)
{
*
outRun
=
nullptr
;
}
else
{
*
outRun
=
run
;
}
return
;
}
}
}
char16_t
WSRunObject
:
:
GetCharAt
(
Text
*
aTextNode
int32_t
aOffset
)
{
NS_ENSURE_TRUE
(
aTextNode
0
)
;
int32_t
len
=
int32_t
(
aTextNode
-
>
TextLength
(
)
)
;
if
(
aOffset
<
0
|
|
aOffset
>
=
len
)
{
return
0
;
}
return
aTextNode
-
>
GetText
(
)
-
>
CharAt
(
aOffset
)
;
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetWSPointAfter
(
nsINode
*
aNode
int32_t
aOffset
)
{
uint32_t
numNodes
=
mNodeArray
.
Length
(
)
;
if
(
!
numNodes
)
{
WSPoint
outPoint
;
return
outPoint
;
}
uint32_t
firstNum
=
0
curNum
=
numNodes
/
2
lastNum
=
numNodes
;
int16_t
cmp
=
0
;
RefPtr
<
Text
>
curNode
;
while
(
curNum
!
=
lastNum
)
{
curNode
=
mNodeArray
[
curNum
]
;
cmp
=
nsContentUtils
:
:
ComparePoints
(
aNode
aOffset
curNode
0
)
;
if
(
cmp
<
0
)
{
lastNum
=
curNum
;
}
else
{
firstNum
=
curNum
+
1
;
}
curNum
=
(
lastNum
-
firstNum
)
/
2
+
firstNum
;
MOZ_ASSERT
(
firstNum
<
=
curNum
&
&
curNum
<
=
lastNum
"
Bad
binary
search
"
)
;
}
if
(
curNum
=
=
mNodeArray
.
Length
(
)
)
{
RefPtr
<
Text
>
textNode
(
mNodeArray
[
curNum
-
1
]
)
;
WSPoint
point
(
textNode
textNode
-
>
TextLength
(
)
0
)
;
return
GetCharAfter
(
point
)
;
}
else
{
RefPtr
<
Text
>
textNode
(
mNodeArray
[
curNum
]
)
;
WSPoint
point
(
textNode
0
0
)
;
return
GetCharAfter
(
point
)
;
}
}
WSRunObject
:
:
WSPoint
WSRunObject
:
:
GetWSPointBefore
(
nsINode
*
aNode
int32_t
aOffset
)
{
uint32_t
numNodes
=
mNodeArray
.
Length
(
)
;
if
(
!
numNodes
)
{
WSPoint
outPoint
;
return
outPoint
;
}
uint32_t
firstNum
=
0
curNum
=
numNodes
/
2
lastNum
=
numNodes
;
int16_t
cmp
=
0
;
RefPtr
<
Text
>
curNode
;
while
(
curNum
!
=
lastNum
)
{
curNode
=
mNodeArray
[
curNum
]
;
cmp
=
nsContentUtils
:
:
ComparePoints
(
aNode
aOffset
curNode
0
)
;
if
(
cmp
<
0
)
{
lastNum
=
curNum
;
}
else
{
firstNum
=
curNum
+
1
;
}
curNum
=
(
lastNum
-
firstNum
)
/
2
+
firstNum
;
MOZ_ASSERT
(
firstNum
<
=
curNum
&
&
curNum
<
=
lastNum
"
Bad
binary
search
"
)
;
}
if
(
curNum
=
=
mNodeArray
.
Length
(
)
)
{
RefPtr
<
Text
>
textNode
(
mNodeArray
[
curNum
-
1
]
)
;
WSPoint
point
(
textNode
textNode
-
>
TextLength
(
)
0
)
;
return
GetCharBefore
(
point
)
;
}
else
{
RefPtr
<
Text
>
textNode
(
mNodeArray
[
curNum
]
)
;
WSPoint
point
(
textNode
0
0
)
;
return
GetCharBefore
(
point
)
;
}
}
nsresult
WSRunObject
:
:
CheckTrailingNBSPOfRun
(
WSFragment
*
aRun
)
{
NS_ENSURE_TRUE
(
aRun
NS_ERROR_NULL_POINTER
)
;
bool
leftCheck
=
false
;
bool
spaceNBSP
=
false
;
bool
rightCheck
=
false
;
if
(
aRun
-
>
mType
!
=
WSType
:
:
normalWS
)
{
return
NS_ERROR_FAILURE
;
}
WSPoint
thePoint
=
GetCharBefore
(
aRun
-
>
mEndNode
aRun
-
>
mEndOffset
)
;
if
(
thePoint
.
mTextNode
&
&
thePoint
.
mChar
=
=
nbsp
)
{
WSPoint
prevPoint
=
GetCharBefore
(
thePoint
)
;
if
(
prevPoint
.
mTextNode
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
prevPoint
.
mChar
)
)
{
leftCheck
=
true
;
}
else
{
spaceNBSP
=
true
;
}
}
else
if
(
aRun
-
>
mLeftType
=
=
WSType
:
:
text
|
|
aRun
-
>
mLeftType
=
=
WSType
:
:
special
)
{
leftCheck
=
true
;
}
if
(
leftCheck
|
|
spaceNBSP
)
{
if
(
aRun
-
>
mRightType
=
=
WSType
:
:
text
|
|
aRun
-
>
mRightType
=
=
WSType
:
:
special
|
|
aRun
-
>
mRightType
=
=
WSType
:
:
br
)
{
rightCheck
=
true
;
}
if
(
(
aRun
-
>
mRightType
&
WSType
:
:
block
)
&
&
IsBlockNode
(
GetWSBoundingParent
(
)
)
)
{
nsCOMPtr
<
Element
>
brNode
=
mHTMLEditor
-
>
CreateBR
(
aRun
-
>
mEndNode
aRun
-
>
mEndOffset
)
;
NS_ENSURE_TRUE
(
brNode
NS_ERROR_FAILURE
)
;
thePoint
=
GetCharBefore
(
aRun
-
>
mEndNode
aRun
-
>
mEndOffset
)
;
prevPoint
=
GetCharBefore
(
thePoint
)
;
rightCheck
=
true
;
}
}
if
(
leftCheck
&
&
rightCheck
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
spaceStr
(
char16_t
(
32
)
)
;
nsresult
rv
=
mHTMLEditor
-
>
InsertTextIntoTextNodeImpl
(
spaceStr
*
thePoint
.
mTextNode
thePoint
.
mOffset
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
DeleteChars
(
thePoint
.
mTextNode
thePoint
.
mOffset
+
1
thePoint
.
mTextNode
thePoint
.
mOffset
+
2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
!
mPRE
&
&
spaceNBSP
&
&
rightCheck
)
{
RefPtr
<
Text
>
startNode
endNode
;
int32_t
startOffset
endOffset
;
GetAsciiWSBounds
(
eBoth
prevPoint
.
mTextNode
prevPoint
.
mOffset
+
1
getter_AddRefs
(
startNode
)
&
startOffset
getter_AddRefs
(
endNode
)
&
endOffset
)
;
nsresult
rv
=
DeleteChars
(
thePoint
.
mTextNode
thePoint
.
mOffset
thePoint
.
mTextNode
thePoint
.
mOffset
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
nbspStr
(
nbsp
)
;
rv
=
mHTMLEditor
-
>
InsertTextIntoTextNodeImpl
(
nbspStr
*
startNode
startOffset
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
CheckTrailingNBSP
(
WSFragment
*
aRun
nsINode
*
aNode
int32_t
aOffset
)
{
NS_ENSURE_TRUE
(
aRun
&
&
aNode
NS_ERROR_NULL_POINTER
)
;
bool
canConvert
=
false
;
WSPoint
thePoint
=
GetCharBefore
(
aNode
aOffset
)
;
if
(
thePoint
.
mTextNode
&
&
thePoint
.
mChar
=
=
nbsp
)
{
WSPoint
prevPoint
=
GetCharBefore
(
thePoint
)
;
if
(
prevPoint
.
mTextNode
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
prevPoint
.
mChar
)
)
{
canConvert
=
true
;
}
}
else
if
(
aRun
-
>
mLeftType
=
=
WSType
:
:
text
|
|
aRun
-
>
mLeftType
=
=
WSType
:
:
special
)
{
canConvert
=
true
;
}
}
if
(
canConvert
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
spaceStr
(
char16_t
(
32
)
)
;
nsresult
rv
=
mHTMLEditor
-
>
InsertTextIntoTextNodeImpl
(
spaceStr
*
thePoint
.
mTextNode
thePoint
.
mOffset
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
DeleteChars
(
thePoint
.
mTextNode
thePoint
.
mOffset
+
1
thePoint
.
mTextNode
thePoint
.
mOffset
+
2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
CheckLeadingNBSP
(
WSFragment
*
aRun
nsINode
*
aNode
int32_t
aOffset
)
{
bool
canConvert
=
false
;
WSPoint
thePoint
=
GetCharAfter
(
aNode
aOffset
)
;
if
(
thePoint
.
mChar
=
=
nbsp
)
{
WSPoint
tmp
=
thePoint
;
tmp
.
mOffset
+
+
;
WSPoint
nextPoint
=
GetCharAfter
(
tmp
)
;
if
(
nextPoint
.
mTextNode
)
{
if
(
!
nsCRT
:
:
IsAsciiSpace
(
nextPoint
.
mChar
)
)
{
canConvert
=
true
;
}
}
else
if
(
aRun
-
>
mRightType
=
=
WSType
:
:
text
|
|
aRun
-
>
mRightType
=
=
WSType
:
:
special
|
|
aRun
-
>
mRightType
=
=
WSType
:
:
br
)
{
canConvert
=
true
;
}
}
if
(
canConvert
)
{
AutoTransactionsConserveSelection
dontChangeMySelection
(
mHTMLEditor
)
;
nsAutoString
spaceStr
(
char16_t
(
32
)
)
;
nsresult
rv
=
mHTMLEditor
-
>
InsertTextIntoTextNodeImpl
(
spaceStr
*
thePoint
.
mTextNode
thePoint
.
mOffset
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
DeleteChars
(
thePoint
.
mTextNode
thePoint
.
mOffset
+
1
thePoint
.
mTextNode
thePoint
.
mOffset
+
2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
WSRunObject
:
:
Scrub
(
)
{
WSFragment
*
run
=
mStartRun
;
while
(
run
)
{
if
(
run
-
>
mType
&
(
WSType
:
:
leadingWS
|
WSType
:
:
trailingWS
)
)
{
nsresult
rv
=
DeleteChars
(
run
-
>
mStartNode
run
-
>
mStartOffset
run
-
>
mEndNode
run
-
>
mEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
run
=
run
-
>
mRight
;
}
return
NS_OK
;
}
bool
WSRunObject
:
:
IsBlockNode
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsElement
(
)
&
&
HTMLEditor
:
:
NodeIsBlockStatic
(
aNode
-
>
AsElement
(
)
)
;
}
}
