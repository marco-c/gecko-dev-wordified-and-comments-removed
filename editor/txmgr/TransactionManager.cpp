#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
TransactionStack
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITransaction
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
TransactionItem
.
h
"
namespace
mozilla
{
TransactionManager
:
:
TransactionManager
(
int32_t
aMaxTransactionCount
)
:
mMaxTransactionCount
(
aMaxTransactionCount
)
mDoStack
(
TransactionStack
:
:
FOR_UNDO
)
mUndoStack
(
TransactionStack
:
:
FOR_UNDO
)
mRedoStack
(
TransactionStack
:
:
FOR_REDO
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mHTMLEditor
)
tmp
-
>
mDoStack
.
DoUnlink
(
)
;
tmp
-
>
mUndoStack
.
DoUnlink
(
)
;
tmp
-
>
mRedoStack
.
DoUnlink
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHTMLEditor
)
tmp
-
>
mDoStack
.
DoTraverse
(
cb
)
;
tmp
-
>
mUndoStack
.
DoTraverse
(
cb
)
;
tmp
-
>
mRedoStack
.
DoTraverse
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TransactionManager
)
NS_INTERFACE_MAP_ENTRY
(
nsITransactionManager
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsITransactionManager
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TransactionManager
)
void
TransactionManager
:
:
Attach
(
HTMLEditor
&
aHTMLEditor
)
{
mHTMLEditor
=
&
aHTMLEditor
;
}
void
TransactionManager
:
:
Detach
(
const
HTMLEditor
&
aHTMLEditor
)
{
MOZ_DIAGNOSTIC_ASSERT_IF
(
mHTMLEditor
&
aHTMLEditor
=
=
mHTMLEditor
)
;
if
(
mHTMLEditor
=
=
&
aHTMLEditor
)
{
mHTMLEditor
=
nullptr
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
TransactionManager
:
:
DoTransaction
(
nsITransaction
*
aTransaction
)
{
if
(
NS_WARN_IF
(
!
aTransaction
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
OwningNonNull
<
nsITransaction
>
transaction
=
*
aTransaction
;
nsresult
rv
=
BeginTransaction
(
transaction
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TransactionManager
:
:
BeginTransaction
(
)
failed
"
)
;
DidDoNotify
(
transaction
rv
)
;
return
rv
;
}
rv
=
EndTransaction
(
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionManager
:
:
EndTransaction
(
)
failed
"
)
;
DidDoNotify
(
transaction
rv
)
;
return
rv
;
}
MOZ_CAN_RUN_SCRIPT
NS_IMETHODIMP
TransactionManager
:
:
UndoTransaction
(
)
{
return
Undo
(
)
;
}
nsresult
TransactionManager
:
:
Undo
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
nsresult
rv
=
transactionItem
-
>
UndoTransaction
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionItem
:
:
UndoTransaction
(
)
failed
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
transactionItem
=
mUndoStack
.
Pop
(
)
;
mRedoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
}
if
(
transaction
)
{
DidUndoNotify
(
*
transaction
rv
)
;
}
return
rv
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
TransactionManager
:
:
RedoTransaction
(
)
{
return
Redo
(
)
;
}
nsresult
TransactionManager
:
:
Redo
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
nsresult
rv
=
transactionItem
-
>
RedoTransaction
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionItem
:
:
RedoTransaction
(
)
failed
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
transactionItem
=
mRedoStack
.
Pop
(
)
;
mUndoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
}
if
(
transaction
)
{
DidRedoNotify
(
*
transaction
rv
)
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
Clear
(
)
{
return
NS_WARN_IF
(
!
ClearUndoRedo
(
)
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
BeginBatch
(
nsISupports
*
aData
)
{
nsresult
rv
=
BeginBatchInternal
(
aData
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionManager
:
:
BeginBatchInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
TransactionManager
:
:
BeginBatchInternal
(
nsISupports
*
aData
)
{
nsresult
rv
=
BeginTransaction
(
nullptr
aData
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionManager
:
:
BeginTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
EndBatch
(
bool
aAllowEmpty
)
{
nsresult
rv
=
EndBatchInternal
(
aAllowEmpty
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionManager
:
:
EndBatchInternal
(
)
failed
"
)
;
return
rv
;
}
nsresult
TransactionManager
:
:
EndBatchInternal
(
bool
aAllowEmpty
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mDoStack
.
Peek
(
)
;
if
(
NS_WARN_IF
(
!
transactionItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
if
(
NS_WARN_IF
(
transaction
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EndTransaction
(
aAllowEmpty
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionManager
:
:
EndTransaction
(
)
failed
"
)
;
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetNumberOfUndoItems
(
int32_t
*
aNumItems
)
{
*
aNumItems
=
static_cast
<
int32_t
>
(
NumberOfUndoItems
(
)
)
;
MOZ_ASSERT
(
*
aNumItems
>
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetNumberOfRedoItems
(
int32_t
*
aNumItems
)
{
*
aNumItems
=
static_cast
<
int32_t
>
(
NumberOfRedoItems
(
)
)
;
MOZ_ASSERT
(
*
aNumItems
>
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetMaxTransactionCount
(
int32_t
*
aMaxCount
)
{
if
(
NS_WARN_IF
(
!
aMaxCount
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aMaxCount
=
mMaxTransactionCount
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
SetMaxTransactionCount
(
int32_t
aMaxCount
)
{
return
NS_WARN_IF
(
!
EnableUndoRedo
(
aMaxCount
)
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
bool
TransactionManager
:
:
EnableUndoRedo
(
int32_t
aMaxTransactionCount
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
false
;
}
if
(
!
aMaxTransactionCount
)
{
mUndoStack
.
Clear
(
)
;
mRedoStack
.
Clear
(
)
;
mMaxTransactionCount
=
0
;
return
true
;
}
if
(
aMaxTransactionCount
<
0
)
{
mMaxTransactionCount
=
-
1
;
return
true
;
}
if
(
mMaxTransactionCount
>
=
0
&
&
mMaxTransactionCount
<
=
aMaxTransactionCount
)
{
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
size_t
numUndoItems
=
NumberOfUndoItems
(
)
;
size_t
numRedoItems
=
NumberOfRedoItems
(
)
;
size_t
total
=
numUndoItems
+
numRedoItems
;
size_t
newMaxTransactionCount
=
static_cast
<
size_t
>
(
aMaxTransactionCount
)
;
if
(
newMaxTransactionCount
>
total
)
{
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
for
(
;
numUndoItems
&
&
(
numRedoItems
+
numUndoItems
)
>
newMaxTransactionCount
;
numUndoItems
-
-
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
PopBottom
(
)
;
MOZ_ASSERT
(
transactionItem
)
;
}
for
(
;
numRedoItems
&
&
(
numRedoItems
+
numUndoItems
)
>
newMaxTransactionCount
;
numRedoItems
-
-
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
PopBottom
(
)
;
MOZ_ASSERT
(
transactionItem
)
;
}
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
NS_IMETHODIMP
TransactionManager
:
:
PeekUndoStack
(
nsITransaction
*
*
aTransaction
)
{
MOZ_ASSERT
(
aTransaction
)
;
*
aTransaction
=
PeekUndoStack
(
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsITransaction
>
TransactionManager
:
:
PeekUndoStack
(
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
nullptr
;
}
return
transactionItem
-
>
GetTransaction
(
)
;
}
NS_IMETHODIMP
TransactionManager
:
:
PeekRedoStack
(
nsITransaction
*
*
aTransaction
)
{
MOZ_ASSERT
(
aTransaction
)
;
*
aTransaction
=
PeekRedoStack
(
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsITransaction
>
TransactionManager
:
:
PeekRedoStack
(
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
nullptr
;
}
return
transactionItem
-
>
GetTransaction
(
)
;
}
nsresult
TransactionManager
:
:
BatchTopUndo
(
)
{
if
(
mUndoStack
.
GetSize
(
)
<
2
)
{
return
NS_OK
;
}
RefPtr
<
TransactionItem
>
lastUndo
=
mUndoStack
.
Pop
(
)
;
MOZ_ASSERT
(
lastUndo
"
There
should
be
at
least
two
transactions
.
"
)
;
RefPtr
<
TransactionItem
>
previousUndo
=
mUndoStack
.
Peek
(
)
;
MOZ_ASSERT
(
previousUndo
"
There
should
be
at
least
two
transactions
.
"
)
;
nsresult
rv
=
previousUndo
-
>
AddChild
(
*
lastUndo
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionItem
:
:
AddChild
(
)
failed
"
)
;
nsCOMArray
<
nsISupports
>
&
lastData
=
lastUndo
-
>
GetData
(
)
;
nsCOMArray
<
nsISupports
>
&
previousData
=
previousUndo
-
>
GetData
(
)
;
if
(
!
previousData
.
AppendObjects
(
lastData
)
)
{
NS_WARNING
(
"
nsISupports
:
:
AppendObjects
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
lastData
.
Clear
(
)
;
return
rv
;
}
nsresult
TransactionManager
:
:
RemoveTopUndo
(
)
{
if
(
mUndoStack
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
TransactionItem
>
lastUndo
=
mUndoStack
.
Pop
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
ClearUndoStack
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mUndoStack
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
ClearRedoStack
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mRedoStack
.
Clear
(
)
;
return
NS_OK
;
}
void
TransactionManager
:
:
DidDoNotify
(
nsITransaction
&
aTransaction
nsresult
aDoResult
)
{
if
(
mHTMLEditor
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
htmlEditor
-
>
DidDoTransaction
(
*
this
aTransaction
aDoResult
)
;
}
}
void
TransactionManager
:
:
DidUndoNotify
(
nsITransaction
&
aTransaction
nsresult
aUndoResult
)
{
if
(
mHTMLEditor
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
htmlEditor
-
>
DidUndoTransaction
(
*
this
aTransaction
aUndoResult
)
;
}
}
void
TransactionManager
:
:
DidRedoNotify
(
nsITransaction
&
aTransaction
nsresult
aRedoResult
)
{
if
(
mHTMLEditor
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
(
mHTMLEditor
)
;
htmlEditor
-
>
DidRedoTransaction
(
*
this
aTransaction
aRedoResult
)
;
}
}
nsresult
TransactionManager
:
:
BeginTransaction
(
nsITransaction
*
aTransaction
nsISupports
*
aData
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
new
TransactionItem
(
aTransaction
)
;
if
(
aData
)
{
nsCOMArray
<
nsISupports
>
&
data
=
transactionItem
-
>
GetData
(
)
;
data
.
AppendObject
(
aData
)
;
}
mDoStack
.
Push
(
transactionItem
)
;
nsresult
rv
=
transactionItem
-
>
DoTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TransactionItem
:
:
DoTransaction
(
)
failed
"
)
;
transactionItem
=
mDoStack
.
Pop
(
)
;
}
return
rv
;
}
nsresult
TransactionManager
:
:
EndTransaction
(
bool
aAllowEmpty
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mDoStack
.
Pop
(
)
;
if
(
NS_WARN_IF
(
!
transactionItem
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
if
(
!
transaction
&
&
!
aAllowEmpty
)
{
if
(
!
transactionItem
-
>
NumberOfChildren
(
)
)
{
return
NS_OK
;
}
}
if
(
transaction
)
{
bool
isTransient
=
false
;
nsresult
rv
=
transaction
-
>
GetIsTransient
(
&
isTransient
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsITransaction
:
:
GetIsTransient
(
)
failed
"
)
;
return
rv
;
}
if
(
isTransient
)
{
return
NS_OK
;
}
}
if
(
!
mMaxTransactionCount
)
{
return
NS_OK
;
}
RefPtr
<
TransactionItem
>
topTransactionItem
=
mDoStack
.
Peek
(
)
;
if
(
topTransactionItem
)
{
nsresult
rv
=
topTransactionItem
-
>
AddChild
(
*
transactionItem
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TransactionItem
:
:
AddChild
(
)
failed
"
)
;
return
rv
;
}
mRedoStack
.
Clear
(
)
;
topTransactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
transaction
&
&
topTransactionItem
)
{
bool
didMerge
=
false
;
nsCOMPtr
<
nsITransaction
>
topTransaction
=
topTransactionItem
-
>
GetTransaction
(
)
;
if
(
topTransaction
)
{
nsresult
rv
=
topTransaction
-
>
Merge
(
transaction
&
didMerge
)
;
if
(
didMerge
)
{
return
rv
;
}
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsITransaction
:
:
Merge
(
)
failed
but
ignored
"
)
;
}
}
int32_t
sz
=
mUndoStack
.
GetSize
(
)
;
if
(
mMaxTransactionCount
>
0
&
&
sz
>
=
mMaxTransactionCount
)
{
RefPtr
<
TransactionItem
>
overflow
=
mUndoStack
.
PopBottom
(
)
;
}
mUndoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
return
NS_OK
;
}
}
