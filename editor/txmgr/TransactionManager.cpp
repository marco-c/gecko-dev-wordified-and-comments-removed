#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
TransactionStack
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITransaction
.
h
"
#
include
"
nsITransactionListener
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
TransactionItem
.
h
"
namespace
mozilla
{
TransactionManager
:
:
TransactionManager
(
int32_t
aMaxTransactionCount
)
:
mMaxTransactionCount
(
aMaxTransactionCount
)
mDoStack
(
TransactionStack
:
:
FOR_UNDO
)
mUndoStack
(
TransactionStack
:
:
FOR_UNDO
)
mRedoStack
(
TransactionStack
:
:
FOR_REDO
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mListeners
)
tmp
-
>
mDoStack
.
DoUnlink
(
)
;
tmp
-
>
mUndoStack
.
DoUnlink
(
)
;
tmp
-
>
mRedoStack
.
DoUnlink
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListeners
)
tmp
-
>
mDoStack
.
DoTraverse
(
cb
)
;
tmp
-
>
mUndoStack
.
DoTraverse
(
cb
)
;
tmp
-
>
mRedoStack
.
DoTraverse
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TransactionManager
)
NS_INTERFACE_MAP_ENTRY
(
nsITransactionManager
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsITransactionManager
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TransactionManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TransactionManager
)
NS_IMETHODIMP
TransactionManager
:
:
DoTransaction
(
nsITransaction
*
aTransaction
)
{
NS_ENSURE_TRUE
(
aTransaction
NS_ERROR_NULL_POINTER
)
;
bool
doInterrupt
=
false
;
nsresult
rv
=
WillDoNotify
(
aTransaction
&
doInterrupt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
doInterrupt
)
{
return
NS_OK
;
}
rv
=
BeginTransaction
(
aTransaction
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
DidDoNotify
(
aTransaction
rv
)
;
return
rv
;
}
rv
=
EndTransaction
(
false
)
;
nsresult
rv2
=
DidDoNotify
(
aTransaction
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
UndoTransaction
(
)
{
return
Undo
(
)
;
}
nsresult
TransactionManager
:
:
Undo
(
)
{
if
(
!
mDoStack
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
bool
doInterrupt
=
false
;
nsresult
rv
=
WillUndoNotify
(
transaction
&
doInterrupt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
doInterrupt
)
{
return
NS_OK
;
}
rv
=
transactionItem
-
>
UndoTransaction
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
transactionItem
=
mUndoStack
.
Pop
(
)
;
mRedoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
}
nsresult
rv2
=
DidUndoNotify
(
transaction
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
RedoTransaction
(
)
{
return
Redo
(
)
;
}
nsresult
TransactionManager
:
:
Redo
(
)
{
if
(
!
mDoStack
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
bool
doInterrupt
=
false
;
nsresult
rv
=
WillRedoNotify
(
transaction
&
doInterrupt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
doInterrupt
)
{
return
NS_OK
;
}
rv
=
transactionItem
-
>
RedoTransaction
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
transactionItem
=
mRedoStack
.
Pop
(
)
;
mUndoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
}
nsresult
rv2
=
DidRedoNotify
(
transaction
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
Clear
(
)
{
return
ClearUndoRedo
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
TransactionManager
:
:
BeginBatch
(
nsISupports
*
aData
)
{
nsresult
rv
=
BeginBatchInternal
(
aData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
BeginBatchInternal
(
nsISupports
*
aData
)
{
bool
doInterrupt
=
false
;
nsresult
rv
=
WillBeginBatchNotify
(
&
doInterrupt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
doInterrupt
)
{
return
NS_OK
;
}
rv
=
BeginTransaction
(
0
aData
)
;
nsresult
rv2
=
DidBeginBatchNotify
(
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
EndBatch
(
bool
aAllowEmpty
)
{
nsresult
rv
=
EndBatchInternal
(
aAllowEmpty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
EndBatchInternal
(
bool
aAllowEmpty
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mDoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
if
(
transaction
)
{
return
NS_ERROR_FAILURE
;
}
bool
doInterrupt
=
false
;
nsresult
rv
=
WillEndBatchNotify
(
&
doInterrupt
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
doInterrupt
)
{
return
NS_OK
;
}
rv
=
EndTransaction
(
aAllowEmpty
)
;
nsresult
rv2
=
DidEndBatchNotify
(
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
return
rv
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetNumberOfUndoItems
(
int32_t
*
aNumItems
)
{
*
aNumItems
=
static_cast
<
int32_t
>
(
NumberOfUndoItems
(
)
)
;
MOZ_ASSERT
(
*
aNumItems
>
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetNumberOfRedoItems
(
int32_t
*
aNumItems
)
{
*
aNumItems
=
static_cast
<
int32_t
>
(
NumberOfRedoItems
(
)
)
;
MOZ_ASSERT
(
*
aNumItems
>
=
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
GetMaxTransactionCount
(
int32_t
*
aMaxCount
)
{
NS_ENSURE_TRUE
(
aMaxCount
NS_ERROR_NULL_POINTER
)
;
*
aMaxCount
=
mMaxTransactionCount
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
SetMaxTransactionCount
(
int32_t
aMaxCount
)
{
return
EnableUndoRedo
(
aMaxCount
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
bool
TransactionManager
:
:
EnableUndoRedo
(
int32_t
aMaxTransactionCount
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
false
;
}
if
(
!
aMaxTransactionCount
)
{
mUndoStack
.
Clear
(
)
;
mRedoStack
.
Clear
(
)
;
mMaxTransactionCount
=
0
;
return
true
;
}
if
(
aMaxTransactionCount
<
0
)
{
mMaxTransactionCount
=
-
1
;
return
true
;
}
if
(
mMaxTransactionCount
>
=
0
&
&
mMaxTransactionCount
<
=
aMaxTransactionCount
)
{
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
size_t
numUndoItems
=
NumberOfUndoItems
(
)
;
size_t
numRedoItems
=
NumberOfRedoItems
(
)
;
size_t
total
=
numUndoItems
+
numRedoItems
;
size_t
newMaxTransactionCount
=
static_cast
<
size_t
>
(
aMaxTransactionCount
)
;
if
(
newMaxTransactionCount
>
total
)
{
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
for
(
;
numUndoItems
&
&
(
numRedoItems
+
numUndoItems
)
>
newMaxTransactionCount
;
numUndoItems
-
-
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
PopBottom
(
)
;
MOZ_ASSERT
(
transactionItem
)
;
}
for
(
;
numRedoItems
&
&
(
numRedoItems
+
numUndoItems
)
>
newMaxTransactionCount
;
numRedoItems
-
-
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
PopBottom
(
)
;
MOZ_ASSERT
(
transactionItem
)
;
}
mMaxTransactionCount
=
aMaxTransactionCount
;
return
true
;
}
NS_IMETHODIMP
TransactionManager
:
:
PeekUndoStack
(
nsITransaction
*
*
aTransaction
)
{
MOZ_ASSERT
(
aTransaction
)
;
*
aTransaction
=
PeekUndoStack
(
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsITransaction
>
TransactionManager
:
:
PeekUndoStack
(
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
nullptr
;
}
return
transactionItem
-
>
GetTransaction
(
)
;
}
NS_IMETHODIMP
TransactionManager
:
:
PeekRedoStack
(
nsITransaction
*
*
aTransaction
)
{
MOZ_ASSERT
(
aTransaction
)
;
*
aTransaction
=
PeekRedoStack
(
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsITransaction
>
TransactionManager
:
:
PeekRedoStack
(
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mRedoStack
.
Peek
(
)
;
if
(
!
transactionItem
)
{
return
nullptr
;
}
return
transactionItem
-
>
GetTransaction
(
)
;
}
nsresult
TransactionManager
:
:
BatchTopUndo
(
)
{
if
(
mUndoStack
.
GetSize
(
)
<
2
)
{
return
NS_OK
;
}
RefPtr
<
TransactionItem
>
lastUndo
=
mUndoStack
.
Pop
(
)
;
MOZ_ASSERT
(
lastUndo
"
There
should
be
at
least
two
transactions
.
"
)
;
RefPtr
<
TransactionItem
>
previousUndo
=
mUndoStack
.
Peek
(
)
;
MOZ_ASSERT
(
previousUndo
"
There
should
be
at
least
two
transactions
.
"
)
;
nsresult
rv
=
previousUndo
-
>
AddChild
(
lastUndo
)
;
nsCOMArray
<
nsISupports
>
&
lastData
=
lastUndo
-
>
GetData
(
)
;
nsCOMArray
<
nsISupports
>
&
previousData
=
previousUndo
-
>
GetData
(
)
;
NS_ENSURE_TRUE
(
previousData
.
AppendObjects
(
lastData
)
NS_ERROR_UNEXPECTED
)
;
lastData
.
Clear
(
)
;
return
rv
;
}
nsresult
TransactionManager
:
:
RemoveTopUndo
(
)
{
if
(
mUndoStack
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
TransactionItem
>
lastUndo
=
mUndoStack
.
Pop
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
AddListener
(
nsITransactionListener
*
aListener
)
{
if
(
NS_WARN_IF
(
!
aListener
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
AddTransactionListener
(
*
aListener
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
TransactionManager
:
:
RemoveListener
(
nsITransactionListener
*
aListener
)
{
if
(
NS_WARN_IF
(
!
aListener
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
RemoveTransactionListener
(
*
aListener
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
TransactionManager
:
:
ClearUndoStack
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mUndoStack
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TransactionManager
:
:
ClearRedoStack
(
)
{
if
(
NS_WARN_IF
(
!
mDoStack
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mRedoStack
.
Clear
(
)
;
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillDoNotify
(
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillDo
(
this
aTransaction
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidDoNotify
(
nsITransaction
*
aTransaction
nsresult
aDoResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidDo
(
this
aTransaction
aDoResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillUndoNotify
(
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillUndo
(
this
aTransaction
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidUndoNotify
(
nsITransaction
*
aTransaction
nsresult
aUndoResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidUndo
(
this
aTransaction
aUndoResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillRedoNotify
(
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillRedo
(
this
aTransaction
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidRedoNotify
(
nsITransaction
*
aTransaction
nsresult
aRedoResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidRedo
(
this
aTransaction
aRedoResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillBeginBatchNotify
(
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillBeginBatch
(
this
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidBeginBatchNotify
(
nsresult
aResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidBeginBatch
(
this
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillEndBatchNotify
(
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillEndBatch
(
this
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidEndBatchNotify
(
nsresult
aResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidEndBatch
(
this
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
WillMergeNotify
(
nsITransaction
*
aTop
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
WillMerge
(
this
aTop
aTransaction
aInterrupt
)
;
if
(
NS_FAILED
(
rv
)
|
|
*
aInterrupt
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
DidMergeNotify
(
nsITransaction
*
aTop
nsITransaction
*
aTransaction
bool
aDidMerge
nsresult
aMergeResult
)
{
for
(
int32_t
i
=
0
lcount
=
mListeners
.
Count
(
)
;
i
<
lcount
;
i
+
+
)
{
nsITransactionListener
*
listener
=
mListeners
[
i
]
;
NS_ENSURE_TRUE
(
listener
NS_ERROR_FAILURE
)
;
nsresult
rv
=
listener
-
>
DidMerge
(
this
aTop
aTransaction
aDidMerge
aMergeResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
BeginTransaction
(
nsITransaction
*
aTransaction
nsISupports
*
aData
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
new
TransactionItem
(
aTransaction
)
;
if
(
aData
)
{
nsCOMArray
<
nsISupports
>
&
data
=
transactionItem
-
>
GetData
(
)
;
data
.
AppendObject
(
aData
)
;
}
mDoStack
.
Push
(
transactionItem
)
;
nsresult
rv
=
transactionItem
-
>
DoTransaction
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
transactionItem
=
mDoStack
.
Pop
(
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
TransactionManager
:
:
EndTransaction
(
bool
aAllowEmpty
)
{
RefPtr
<
TransactionItem
>
transactionItem
=
mDoStack
.
Pop
(
)
;
if
(
!
transactionItem
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsITransaction
>
transaction
=
transactionItem
-
>
GetTransaction
(
)
;
if
(
!
transaction
&
&
!
aAllowEmpty
)
{
int32_t
nc
=
0
;
transactionItem
-
>
GetNumberOfChildren
(
&
nc
)
;
if
(
!
nc
)
{
return
NS_OK
;
}
}
bool
isTransient
=
false
;
nsresult
rv
=
transaction
?
transaction
-
>
GetIsTransient
(
&
isTransient
)
:
NS_OK
;
if
(
NS_FAILED
(
rv
)
|
|
isTransient
|
|
!
mMaxTransactionCount
)
{
return
rv
;
}
RefPtr
<
TransactionItem
>
topTransactionItem
=
mDoStack
.
Peek
(
)
;
if
(
topTransactionItem
)
{
return
topTransactionItem
-
>
AddChild
(
transactionItem
)
;
}
mRedoStack
.
Clear
(
)
;
topTransactionItem
=
mUndoStack
.
Peek
(
)
;
if
(
transaction
&
&
topTransactionItem
)
{
bool
didMerge
=
false
;
nsCOMPtr
<
nsITransaction
>
topTransaction
=
topTransactionItem
-
>
GetTransaction
(
)
;
if
(
topTransaction
)
{
bool
doInterrupt
=
false
;
rv
=
WillMergeNotify
(
topTransaction
transaction
&
doInterrupt
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
doInterrupt
)
{
rv
=
topTransaction
-
>
Merge
(
transaction
&
didMerge
)
;
nsresult
rv2
=
DidMergeNotify
(
topTransaction
transaction
didMerge
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
rv2
;
}
if
(
NS_FAILED
(
rv
)
)
{
}
if
(
didMerge
)
{
return
rv
;
}
}
}
}
int32_t
sz
=
mUndoStack
.
GetSize
(
)
;
if
(
mMaxTransactionCount
>
0
&
&
sz
>
=
mMaxTransactionCount
)
{
RefPtr
<
TransactionItem
>
overflow
=
mUndoStack
.
PopBottom
(
)
;
}
mUndoStack
.
Push
(
transactionItem
.
forget
(
)
)
;
return
NS_OK
;
}
}
