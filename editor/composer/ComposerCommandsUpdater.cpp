#
include
"
mozilla
/
ComposerCommandsUpdater
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
TransactionManager
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsICommandManager
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsITransactionManager
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPICommandUpdater
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
class
nsITransaction
;
namespace
mozilla
{
ComposerCommandsUpdater
:
:
ComposerCommandsUpdater
(
)
:
mDirtyState
(
eStateUninitialized
)
mSelectionCollapsed
(
eStateUninitialized
)
mFirstDoOfFirstUndo
(
true
)
{
}
ComposerCommandsUpdater
:
:
~
ComposerCommandsUpdater
(
)
{
if
(
mUpdateTimer
)
{
mUpdateTimer
-
>
Cancel
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ComposerCommandsUpdater
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ComposerCommandsUpdater
)
NS_INTERFACE_MAP_BEGIN
(
ComposerCommandsUpdater
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentStateListener
)
NS_INTERFACE_MAP_ENTRY
(
nsITransactionListener
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDocumentStateListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
ComposerCommandsUpdater
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
ComposerCommandsUpdater
mUpdateTimer
mDOMWindow
mDocShell
)
#
if
0
#
pragma
mark
-
#
endif
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
NotifyDocumentCreated
(
)
{
UpdateOneCommand
(
"
obs_documentCreated
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
NotifyDocumentWillBeDestroyed
(
)
{
if
(
mUpdateTimer
)
{
mUpdateTimer
-
>
Cancel
(
)
;
mUpdateTimer
=
nullptr
;
}
#
if
0
UpdateOneCommand
(
"
obs_documentWillBeDestroyed
"
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
NotifyDocumentStateChanged
(
bool
aNowDirty
)
{
return
UpdateDirtyState
(
aNowDirty
)
;
}
#
if
0
#
pragma
mark
-
#
endif
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillDo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidDo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
nsresult
aDoResult
)
{
size_t
undoCount
=
aManager
-
>
AsTransactionManager
(
)
-
>
NumberOfUndoItems
(
)
;
if
(
undoCount
=
=
1
)
{
if
(
mFirstDoOfFirstUndo
)
{
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
undo
"
)
)
;
}
mFirstDoOfFirstUndo
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillUndo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidUndo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
nsresult
aUndoResult
)
{
size_t
undoCount
=
aManager
-
>
AsTransactionManager
(
)
-
>
NumberOfUndoItems
(
)
;
if
(
!
undoCount
)
{
mFirstDoOfFirstUndo
=
true
;
}
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
undo
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillRedo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidRedo
(
nsITransactionManager
*
aManager
nsITransaction
*
aTransaction
nsresult
aRedoResult
)
{
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
undo
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillBeginBatch
(
nsITransactionManager
*
aManager
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidBeginBatch
(
nsITransactionManager
*
aManager
nsresult
aResult
)
{
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillEndBatch
(
nsITransactionManager
*
aManager
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidEndBatch
(
nsITransactionManager
*
aManager
nsresult
aResult
)
{
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
WillMerge
(
nsITransactionManager
*
aManager
nsITransaction
*
aTopTransaction
nsITransaction
*
aTransactionToMerge
bool
*
aInterrupt
)
{
*
aInterrupt
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
DidMerge
(
nsITransactionManager
*
aManager
nsITransaction
*
aTopTransaction
nsITransaction
*
aTransactionToMerge
bool
aDidMerge
nsresult
aMergeResult
)
{
return
NS_OK
;
}
#
if
0
#
pragma
mark
-
#
endif
nsresult
ComposerCommandsUpdater
:
:
Init
(
nsPIDOMWindowOuter
*
aDOMWindow
)
{
if
(
NS_WARN_IF
(
!
aDOMWindow
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mDOMWindow
=
aDOMWindow
;
mDocShell
=
aDOMWindow
-
>
GetDocShell
(
)
;
return
NS_OK
;
}
nsresult
ComposerCommandsUpdater
:
:
PrimeUpdateTimer
(
)
{
if
(
!
mUpdateTimer
)
{
mUpdateTimer
=
NS_NewTimer
(
)
;
;
NS_ENSURE_TRUE
(
mUpdateTimer
NS_ERROR_OUT_OF_MEMORY
)
;
}
const
uint32_t
kUpdateTimerDelay
=
150
;
return
mUpdateTimer
-
>
InitWithCallback
(
static_cast
<
nsITimerCallback
*
>
(
this
)
kUpdateTimerDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
ComposerCommandsUpdater
:
:
TimerCallback
(
)
{
bool
isCollapsed
=
SelectionIsCollapsed
(
)
;
if
(
static_cast
<
int8_t
>
(
isCollapsed
)
!
=
mSelectionCollapsed
)
{
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
select
"
)
)
;
mSelectionCollapsed
=
isCollapsed
;
}
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
style
"
)
)
;
}
nsresult
ComposerCommandsUpdater
:
:
UpdateDirtyState
(
bool
aNowDirty
)
{
if
(
mDirtyState
!
=
static_cast
<
int8_t
>
(
aNowDirty
)
)
{
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
save
"
)
)
;
UpdateCommandGroup
(
NS_LITERAL_STRING
(
"
undo
"
)
)
;
mDirtyState
=
aNowDirty
;
}
return
NS_OK
;
}
nsresult
ComposerCommandsUpdater
:
:
UpdateCommandGroup
(
const
nsAString
&
aCommandGroup
)
{
nsCOMPtr
<
nsPICommandUpdater
>
commandUpdater
=
GetCommandUpdater
(
)
;
NS_ENSURE_TRUE
(
commandUpdater
NS_ERROR_FAILURE
)
;
if
(
aCommandGroup
.
EqualsLiteral
(
"
undo
"
)
)
{
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_undo
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_redo
"
)
;
return
NS_OK
;
}
if
(
aCommandGroup
.
EqualsLiteral
(
"
select
"
)
|
|
aCommandGroup
.
EqualsLiteral
(
"
style
"
)
)
{
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_bold
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_italic
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_underline
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_tt
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_strikethrough
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_superscript
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_subscript
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_nobreak
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_em
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_strong
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_cite
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_abbr
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_acronym
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_code
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_samp
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_var
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_increaseFont
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_decreaseFont
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_paragraphState
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_fontFace
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_fontColor
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_backgroundColor
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_highlight
"
)
;
return
NS_OK
;
}
if
(
aCommandGroup
.
EqualsLiteral
(
"
save
"
)
)
{
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_setDocumentModified
"
)
;
commandUpdater
-
>
CommandStatusChanged
(
"
cmd_save
"
)
;
return
NS_OK
;
}
return
NS_OK
;
}
nsresult
ComposerCommandsUpdater
:
:
UpdateOneCommand
(
const
char
*
aCommand
)
{
nsCOMPtr
<
nsPICommandUpdater
>
commandUpdater
=
GetCommandUpdater
(
)
;
NS_ENSURE_TRUE
(
commandUpdater
NS_ERROR_FAILURE
)
;
commandUpdater
-
>
CommandStatusChanged
(
aCommand
)
;
return
NS_OK
;
}
bool
ComposerCommandsUpdater
:
:
SelectionIsCollapsed
(
)
{
if
(
NS_WARN_IF
(
!
mDOMWindow
)
)
{
return
true
;
}
nsCOMPtr
<
nsISelection
>
domSelection
=
mDOMWindow
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
domSelection
)
)
{
return
false
;
}
return
domSelection
-
>
AsSelection
(
)
-
>
IsCollapsed
(
)
;
}
already_AddRefed
<
nsPICommandUpdater
>
ComposerCommandsUpdater
:
:
GetCommandUpdater
(
)
{
if
(
NS_WARN_IF
(
!
mDocShell
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsICommandManager
>
manager
=
mDocShell
-
>
GetCommandManager
(
)
;
nsCOMPtr
<
nsPICommandUpdater
>
updater
=
do_QueryInterface
(
manager
)
;
return
updater
.
forget
(
)
;
}
NS_IMETHODIMP
ComposerCommandsUpdater
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
ComposerCommandsUpdater
"
)
;
return
NS_OK
;
}
#
if
0
#
pragma
mark
-
#
endif
nsresult
ComposerCommandsUpdater
:
:
Notify
(
nsITimer
*
aTimer
)
{
NS_ASSERTION
(
aTimer
=
=
mUpdateTimer
.
get
(
)
"
Hey
this
ain
'
t
my
timer
!
"
)
;
TimerCallback
(
)
;
return
NS_OK
;
}
#
if
0
#
pragma
mark
-
#
endif
}
