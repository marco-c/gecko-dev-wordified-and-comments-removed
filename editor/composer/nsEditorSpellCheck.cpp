#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsEditorSpellCheck
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentPrefService
.
h
"
#
include
"
nsIContentPrefService2
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISpellChecker
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITextServicesDocument
.
h
"
#
include
"
nsITextServicesFilter
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
UpdateDictionaryHolder
{
private
:
nsEditorSpellCheck
*
mSpellCheck
;
public
:
explicit
UpdateDictionaryHolder
(
nsEditorSpellCheck
*
esc
)
:
mSpellCheck
(
esc
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
BeginUpdateDictionary
(
)
;
}
}
~
UpdateDictionaryHolder
(
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
EndUpdateDictionary
(
)
;
}
}
}
;
#
define
CPS_PREF_NAME
NS_LITERAL_STRING
(
"
spellcheck
.
lang
"
)
static
nsresult
GetDocumentURI
(
nsIEditor
*
aEditor
nsIURI
*
*
aURI
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIDOMDocument
>
domDoc
;
aEditor
-
>
GetDocument
(
getter_AddRefs
(
domDoc
)
)
;
NS_ENSURE_TRUE
(
domDoc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDoc
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIURI
>
docUri
=
doc
-
>
GetDocumentURI
(
)
;
NS_ENSURE_TRUE
(
docUri
NS_ERROR_FAILURE
)
;
*
aURI
=
docUri
;
NS_ADDREF
(
*
aURI
)
;
return
NS_OK
;
}
static
already_AddRefed
<
nsILoadContext
>
GetLoadContext
(
nsIEditor
*
aEditor
)
{
nsCOMPtr
<
nsIDOMDocument
>
domDoc
;
aEditor
-
>
GetDocument
(
getter_AddRefs
(
domDoc
)
)
;
NS_ENSURE_TRUE
(
domDoc
nullptr
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDoc
)
;
NS_ENSURE_TRUE
(
doc
nullptr
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
doc
-
>
GetLoadContext
(
)
;
return
loadContext
.
forget
(
)
;
}
class
DictionaryFetcher
final
:
public
nsIContentPrefCallback2
{
public
:
NS_DECL_ISUPPORTS
DictionaryFetcher
(
nsEditorSpellCheck
*
aSpellCheck
nsIEditorSpellCheckCallback
*
aCallback
uint32_t
aGroup
)
:
mCallback
(
aCallback
)
mGroup
(
aGroup
)
mSpellCheck
(
aSpellCheck
)
{
}
NS_IMETHOD
Fetch
(
nsIEditor
*
aEditor
)
;
NS_IMETHOD
HandleResult
(
nsIContentPref
*
aPref
)
override
{
nsCOMPtr
<
nsIVariant
>
value
;
nsresult
rv
=
aPref
-
>
GetValue
(
getter_AddRefs
(
value
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
value
-
>
GetAsAString
(
mDictionary
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
reason
)
override
{
mSpellCheck
-
>
DictionaryFetched
(
this
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleError
(
nsresult
error
)
override
{
return
NS_OK
;
}
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
uint32_t
mGroup
;
nsString
mRootContentLang
;
nsString
mRootDocContentLang
;
nsString
mDictionary
;
private
:
~
DictionaryFetcher
(
)
{
}
RefPtr
<
nsEditorSpellCheck
>
mSpellCheck
;
}
;
NS_IMPL_ISUPPORTS
(
DictionaryFetcher
nsIContentPrefCallback2
)
NS_IMETHODIMP
DictionaryFetcher
:
:
Fetch
(
nsIEditor
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
;
rv
=
GetDocumentURI
(
aEditor
getter_AddRefs
(
docUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
aEditor
)
;
rv
=
contentPrefService
-
>
GetByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
loadContext
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
static
nsresult
StoreCurrentDictionary
(
nsIEditor
*
aEditor
const
nsAString
&
aDictionary
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
;
rv
=
GetDocumentURI
(
aEditor
getter_AddRefs
(
docUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsVariant
>
prefValue
=
new
nsVariant
(
)
;
prefValue
-
>
SetAsAString
(
aDictionary
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
aEditor
)
;
return
contentPrefService
-
>
Set
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
prefValue
loadContext
nullptr
)
;
}
static
nsresult
ClearCurrentDictionary
(
nsIEditor
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
;
rv
=
GetDocumentURI
(
aEditor
getter_AddRefs
(
docUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
aEditor
)
;
return
contentPrefService
-
>
RemoveByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
loadContext
nullptr
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsEditorSpellCheck
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_BEGIN
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsEditorSpellCheck
mEditor
mSpellChecker
mTxtSrvFilter
)
nsEditorSpellCheck
:
:
nsEditorSpellCheck
(
)
:
mSuggestedWordIndex
(
0
)
mDictionaryIndex
(
0
)
mEditor
(
nullptr
)
mDictionaryFetcherGroup
(
0
)
mUpdateDictionaryRunning
(
false
)
{
}
nsEditorSpellCheck
:
:
~
nsEditorSpellCheck
(
)
{
mSpellChecker
=
nullptr
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CanSpellCheck
(
bool
*
_retval
)
{
nsresult
rv
;
nsCOMPtr
<
nsISpellChecker
>
spellChecker
;
if
(
!
mSpellChecker
)
{
spellChecker
=
do_CreateInstance
(
NS_SPELLCHECKER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
spellChecker
=
mSpellChecker
;
}
nsTArray
<
nsString
>
dictList
;
rv
=
spellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
_retval
=
(
dictList
.
Length
(
)
>
0
)
;
return
NS_OK
;
}
class
CallbackCaller
final
:
public
Runnable
{
public
:
explicit
CallbackCaller
(
nsIEditorSpellCheckCallback
*
aCallback
)
:
mCallback
(
aCallback
)
{
}
~
CallbackCaller
(
)
{
Run
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mCallback
)
{
mCallback
-
>
EditorSpellCheckDone
(
)
;
mCallback
=
nullptr
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
}
;
NS_IMETHODIMP
nsEditorSpellCheck
:
:
InitSpellChecker
(
nsIEditor
*
aEditor
bool
aEnableSelectionChecking
nsIEditorSpellCheckCallback
*
aCallback
)
{
NS_ENSURE_TRUE
(
aEditor
NS_ERROR_NULL_POINTER
)
;
mEditor
=
aEditor
;
nsresult
rv
;
nsCOMPtr
<
nsITextServicesDocument
>
tsDoc
=
do_CreateInstance
(
"
mozilla
.
org
/
textservices
/
textservicesdocument
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
tsDoc
NS_ERROR_NULL_POINTER
)
;
tsDoc
-
>
SetFilter
(
mTxtSrvFilter
)
;
rv
=
tsDoc
-
>
InitWithEditor
(
aEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEnableSelectionChecking
)
{
nsCOMPtr
<
nsISelection
>
domSelection
;
aEditor
-
>
GetSelection
(
getter_AddRefs
(
domSelection
)
)
;
if
(
NS_WARN_IF
(
!
domSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
selection
=
domSelection
-
>
AsSelection
(
)
;
int32_t
count
=
0
;
rv
=
selection
-
>
GetRangeCount
(
&
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
count
>
0
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
bool
collapsed
=
false
;
rv
=
range
-
>
GetCollapsed
(
&
collapsed
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
collapsed
)
{
RefPtr
<
nsRange
>
rangeBounds
=
range
-
>
CloneRange
(
)
;
rv
=
tsDoc
-
>
ExpandRangeToWordBoundaries
(
rangeBounds
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
tsDoc
-
>
SetExtent
(
rangeBounds
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
mSpellChecker
=
do_CreateInstance
(
NS_SPELLCHECKER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NULL_POINTER
)
;
rv
=
mSpellChecker
-
>
SetDocument
(
tsDoc
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
UpdateCurrentDictionary
(
aCallback
)
;
if
(
NS_FAILED
(
rv
)
&
&
aCallback
)
{
RefPtr
<
CallbackCaller
>
caller
=
new
CallbackCaller
(
aCallback
)
;
NS_ENSURE_STATE
(
caller
)
;
rv
=
NS_DispatchToMainThread
(
caller
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetNextMisspelledWord
(
char16_t
*
*
aNextMisspelledWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
nsAutoString
nextMisspelledWord
;
DeleteSuggestedWordList
(
)
;
nsresult
rv
=
mSpellChecker
-
>
NextMisspelledWord
(
nextMisspelledWord
&
mSuggestedWordList
)
;
*
aNextMisspelledWord
=
ToNewUnicode
(
nextMisspelledWord
)
;
return
rv
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetSuggestedWord
(
char16_t
*
*
aSuggestedWord
)
{
nsAutoString
word
;
if
(
mSuggestedWordIndex
<
static_cast
<
int32_t
>
(
mSuggestedWordList
.
Length
(
)
)
)
{
*
aSuggestedWord
=
ToNewUnicode
(
mSuggestedWordList
[
mSuggestedWordIndex
]
)
;
mSuggestedWordIndex
+
+
;
}
else
{
*
aSuggestedWord
=
ToNewUnicode
(
EmptyString
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CheckCurrentWord
(
const
char16_t
*
aSuggestedWord
bool
*
aIsMisspelled
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
return
mSpellChecker
-
>
CheckWord
(
nsDependentString
(
aSuggestedWord
)
aIsMisspelled
&
mSuggestedWordList
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CheckCurrentWordNoSuggest
(
const
char16_t
*
aSuggestedWord
bool
*
aIsMisspelled
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
CheckWord
(
nsDependentString
(
aSuggestedWord
)
aIsMisspelled
nullptr
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
ReplaceWord
(
const
char16_t
*
aMisspelledWord
const
char16_t
*
aReplaceWord
bool
allOccurrences
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
Replace
(
nsDependentString
(
aMisspelledWord
)
nsDependentString
(
aReplaceWord
)
allOccurrences
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
IgnoreWordAllOccurrences
(
const
char16_t
*
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
IgnoreAll
(
nsDependentString
(
aWord
)
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetPersonalDictionary
(
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
mDictionaryList
.
Clear
(
)
;
mDictionaryIndex
=
0
;
return
mSpellChecker
-
>
GetPersonalDictionary
(
&
mDictionaryList
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetPersonalDictionaryWord
(
char16_t
*
*
aDictionaryWord
)
{
if
(
mDictionaryIndex
<
static_cast
<
int32_t
>
(
mDictionaryList
.
Length
(
)
)
)
{
*
aDictionaryWord
=
ToNewUnicode
(
mDictionaryList
[
mDictionaryIndex
]
)
;
mDictionaryIndex
+
+
;
}
else
{
*
aDictionaryWord
=
ToNewUnicode
(
EmptyString
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
AddWordToDictionary
(
const
char16_t
*
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
AddWordToPersonalDictionary
(
nsDependentString
(
aWord
)
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
RemoveWordFromDictionary
(
const
char16_t
*
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
RemoveWordFromPersonalDictionary
(
nsDependentString
(
aWord
)
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetDictionaryList
(
char16_t
*
*
*
aDictionaryList
uint32_t
*
aCount
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
NS_ENSURE_TRUE
(
aDictionaryList
&
&
aCount
NS_ERROR_NULL_POINTER
)
;
*
aDictionaryList
=
0
;
*
aCount
=
0
;
nsTArray
<
nsString
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char16_t
*
*
tmpPtr
=
0
;
if
(
dictList
.
IsEmpty
(
)
)
{
tmpPtr
=
(
char16_t
*
*
)
moz_xmalloc
(
sizeof
(
char16_t
*
)
)
;
NS_ENSURE_TRUE
(
tmpPtr
NS_ERROR_OUT_OF_MEMORY
)
;
*
tmpPtr
=
0
;
*
aDictionaryList
=
tmpPtr
;
*
aCount
=
0
;
return
NS_OK
;
}
tmpPtr
=
(
char16_t
*
*
)
moz_xmalloc
(
sizeof
(
char16_t
*
)
*
dictList
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
tmpPtr
NS_ERROR_OUT_OF_MEMORY
)
;
*
aDictionaryList
=
tmpPtr
;
*
aCount
=
dictList
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
*
aCount
;
i
+
+
)
{
tmpPtr
[
i
]
=
ToNewUnicode
(
dictList
[
i
]
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetCurrentDictionary
(
nsAString
&
aDictionary
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
GetCurrentDictionary
(
aDictionary
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
SetCurrentDictionary
(
const
nsAString
&
aDictionary
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
if
(
!
mUpdateDictionaryRunning
)
{
mDictionaryFetcherGroup
+
+
;
uint32_t
flags
=
0
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
)
{
if
(
!
aDictionary
.
IsEmpty
(
)
&
&
(
mPreferredLang
.
IsEmpty
(
)
|
|
!
mPreferredLang
.
Equals
(
aDictionary
nsCaseInsensitiveStringComparator
(
)
)
)
)
{
StoreCurrentDictionary
(
mEditor
aDictionary
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Writing
content
preferences
for
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
else
{
ClearCurrentDictionary
(
mEditor
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Clearing
content
preferences
for
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
Preferences
:
:
SetString
(
"
spellchecker
.
dictionary
"
aDictionary
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Storing
spellchecker
.
dictionary
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
}
return
mSpellChecker
-
>
SetCurrentDictionary
(
aDictionary
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
UninitSpellChecker
(
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
mDictionaryList
.
Clear
(
)
;
mDictionaryIndex
=
0
;
mSpellChecker
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
SetFilter
(
nsITextServicesFilter
*
filter
)
{
mTxtSrvFilter
=
filter
;
return
NS_OK
;
}
nsresult
nsEditorSpellCheck
:
:
DeleteSuggestedWordList
(
)
{
mSuggestedWordList
.
Clear
(
)
;
mSuggestedWordIndex
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
UpdateCurrentDictionary
(
nsIEditorSpellCheckCallback
*
aCallback
)
{
nsresult
rv
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
nsCOMPtr
<
nsIContent
>
rootContent
;
nsCOMPtr
<
nsIHTMLEditor
>
htmlEditor
=
do_QueryInterface
(
mEditor
)
;
if
(
htmlEditor
)
{
rootContent
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
}
else
{
nsCOMPtr
<
nsIDOMElement
>
rootElement
;
rv
=
mEditor
-
>
GetRootElement
(
getter_AddRefs
(
rootElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rootContent
=
do_QueryInterface
(
rootElement
)
;
}
uint32_t
flags
=
0
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
{
nsCOMPtr
<
nsIDocument
>
ownerDoc
=
rootContent
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
ownerDoc
NS_ERROR_FAILURE
)
;
nsIDocument
*
parentDoc
=
ownerDoc
-
>
GetParentDocument
(
)
;
if
(
parentDoc
)
{
rootContent
=
do_QueryInterface
(
parentDoc
-
>
GetDocumentElement
(
)
)
;
}
}
if
(
!
rootContent
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DictionaryFetcher
>
fetcher
=
new
DictionaryFetcher
(
this
aCallback
mDictionaryFetcherGroup
)
;
rootContent
-
>
GetLang
(
fetcher
-
>
mRootContentLang
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
rootContent
-
>
GetUncomposedDoc
(
)
;
NS_ENSURE_STATE
(
doc
)
;
doc
-
>
GetContentLanguage
(
fetcher
-
>
mRootDocContentLang
)
;
rv
=
fetcher
-
>
Fetch
(
mEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsEditorSpellCheck
:
:
TryDictionary
(
const
nsAString
&
aDictName
nsTArray
<
nsString
>
&
aDictList
enum
dictCompare
aCompareType
)
{
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
for
(
uint32_t
i
=
0
;
i
<
aDictList
.
Length
(
)
;
i
+
+
)
{
nsAutoString
dictStr
(
aDictList
.
ElementAt
(
i
)
)
;
bool
equals
=
false
;
switch
(
aCompareType
)
{
case
DICT_NORMAL_COMPARE
:
equals
=
aDictName
.
Equals
(
dictStr
)
;
break
;
case
DICT_COMPARE_CASE_INSENSITIVE
:
equals
=
aDictName
.
Equals
(
dictStr
nsCaseInsensitiveStringComparator
(
)
)
;
break
;
case
DICT_COMPARE_DASHMATCH
:
equals
=
nsStyleUtil
:
:
DashMatchCompare
(
dictStr
aDictName
nsCaseInsensitiveStringComparator
(
)
)
;
break
;
}
if
(
equals
)
{
rv
=
mSpellChecker
-
>
SetCurrentDictionary
(
dictStr
)
;
#
ifdef
DEBUG_DICT
if
(
NS_SUCCEEDED
(
rv
)
)
printf
(
"
*
*
*
*
*
Set
|
%
s
|
.
\
n
"
NS_ConvertUTF16toUTF8
(
dictStr
)
.
get
(
)
)
;
#
endif
break
;
}
}
return
rv
;
}
nsresult
nsEditorSpellCheck
:
:
DictionaryFetched
(
DictionaryFetcher
*
aFetcher
)
{
MOZ_ASSERT
(
aFetcher
)
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
CallbackCaller
callbackCaller
(
aFetcher
-
>
mCallback
)
;
UpdateDictionaryHolder
holder
(
this
)
;
if
(
aFetcher
-
>
mGroup
<
mDictionaryFetcherGroup
)
{
return
NS_OK
;
}
mPreferredLang
.
Assign
(
aFetcher
-
>
mRootContentLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLang
(
element
)
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
mPreferredLang
)
.
get
(
)
)
;
#
endif
if
(
mPreferredLang
.
IsEmpty
(
)
)
{
mPreferredLang
.
Assign
(
aFetcher
-
>
mRootDocContentLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLang
(
content
-
language
)
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
mPreferredLang
)
.
get
(
)
)
;
#
endif
}
nsresult
rv2
;
nsTArray
<
nsString
>
dictList
;
rv2
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
NS_ENSURE_SUCCESS
(
rv2
rv2
)
;
nsAutoString
dictName
;
uint32_t
flags
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
)
{
dictName
.
Assign
(
aFetcher
-
>
mDictionary
)
;
if
(
!
dictName
.
IsEmpty
(
)
)
{
if
(
NS_SUCCEEDED
(
TryDictionary
(
dictName
dictList
DICT_NORMAL_COMPARE
)
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Assigned
from
content
preferences
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
DeleteSuggestedWordList
(
)
;
return
NS_OK
;
}
ClearCurrentDictionary
(
mEditor
)
;
}
}
dictName
.
Assign
(
mPreferredLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Assigned
from
element
/
doc
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
nsAutoString
preferredDict
;
preferredDict
=
Preferences
:
:
GetLocalizedString
(
"
spellchecker
.
dictionary
"
)
;
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
if
(
!
dictName
.
IsEmpty
(
)
)
{
rv
=
TryDictionary
(
dictName
dictList
DICT_COMPARE_CASE_INSENSITIVE
)
;
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Setting
of
|
%
s
|
failed
(
or
it
wasn
'
t
available
)
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
nsAutoString
langCode
;
int32_t
dashIdx
=
dictName
.
FindChar
(
'
-
'
)
;
if
(
dashIdx
!
=
-
1
)
{
langCode
.
Assign
(
Substring
(
dictName
0
dashIdx
)
)
;
}
else
{
langCode
.
Assign
(
dictName
)
;
}
if
(
!
preferredDict
.
IsEmpty
(
)
&
&
nsStyleUtil
:
:
DashMatchCompare
(
preferredDict
langCode
nsDefaultStringComparator
(
)
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
preference
value
|
%
s
|
since
it
matches
language
code
\
n
"
NS_ConvertUTF16toUTF8
(
preferredDict
)
.
get
(
)
)
;
#
endif
rv
=
TryDictionary
(
preferredDict
dictList
DICT_COMPARE_CASE_INSENSITIVE
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
to
find
match
for
language
code
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
langCode
)
.
get
(
)
)
;
#
endif
rv
=
TryDictionary
(
langCode
dictList
DICT_COMPARE_DASHMATCH
)
;
}
}
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
preferredDict
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
preference
value
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
preferredDict
)
.
get
(
)
)
;
#
endif
rv
=
TryDictionary
(
preferredDict
dictList
DICT_NORMAL_COMPARE
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIXULChromeRegistry
>
packageRegistry
=
mozilla
:
:
services
:
:
GetXULChromeRegistryService
(
)
;
if
(
packageRegistry
)
{
nsAutoCString
utf8DictName
;
rv2
=
packageRegistry
-
>
GetSelectedLocale
(
NS_LITERAL_CSTRING
(
"
global
"
)
false
utf8DictName
)
;
dictName
.
Assign
(
EmptyString
(
)
)
;
AppendUTF8toUTF16
(
utf8DictName
dictName
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
locale
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
rv
=
TryDictionary
(
dictName
dictList
DICT_COMPARE_CASE_INSENSITIVE
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
currentDictionary
;
rv2
=
GetCurrentDictionary
(
currentDictionary
)
;
#
ifdef
DEBUG_DICT
if
(
NS_SUCCEEDED
(
rv2
)
)
{
printf
(
"
*
*
*
*
*
Retrieved
current
dict
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
currentDictionary
)
.
get
(
)
)
;
}
#
endif
if
(
NS_FAILED
(
rv2
)
|
|
currentDictionary
.
IsEmpty
(
)
)
{
char
*
env_lang
=
getenv
(
"
LANG
"
)
;
if
(
env_lang
)
{
nsString
lang
=
NS_ConvertUTF8toUTF16
(
env_lang
)
;
int32_t
dot_pos
=
lang
.
FindChar
(
'
.
'
)
;
if
(
dot_pos
!
=
-
1
)
{
lang
=
Substring
(
lang
0
dot_pos
)
;
}
int32_t
underScore
=
lang
.
FindChar
(
'
_
'
)
;
if
(
underScore
!
=
-
1
)
{
lang
.
Replace
(
underScore
1
'
-
'
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
LANG
from
environment
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
lang
)
.
get
(
)
)
;
#
endif
nsAutoString
lang2
;
lang2
.
Assign
(
lang
)
;
rv
=
TryDictionary
(
lang2
dictList
DICT_COMPARE_CASE_INSENSITIVE
)
;
}
}
if
(
NS_FAILED
(
rv
)
&
&
!
dictList
.
IsEmpty
(
)
)
{
nsAutoString
firstInList
;
firstInList
.
Assign
(
dictList
[
0
]
)
;
rv
=
TryDictionary
(
firstInList
dictList
DICT_NORMAL_COMPARE
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
first
of
list
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictList
[
0
]
)
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
printf
(
"
*
*
*
*
*
Setting
worked
.
\
n
"
)
;
}
#
endif
}
}
}
DeleteSuggestedWordList
(
)
;
return
NS_OK
;
}
