#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
mozSpellChecker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextServicesDocument
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDependentSubstring
.
h
"
#
include
"
nsEditorSpellCheck
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentPrefService2
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsITextServicesFilter
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
intl
:
:
LocaleService
;
class
UpdateDictionaryHolder
{
private
:
nsEditorSpellCheck
*
mSpellCheck
;
public
:
explicit
UpdateDictionaryHolder
(
nsEditorSpellCheck
*
esc
)
:
mSpellCheck
(
esc
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
BeginUpdateDictionary
(
)
;
}
}
~
UpdateDictionaryHolder
(
)
{
if
(
mSpellCheck
)
{
mSpellCheck
-
>
EndUpdateDictionary
(
)
;
}
}
}
;
#
define
CPS_PREF_NAME
NS_LITERAL_STRING
(
"
spellcheck
.
lang
"
)
static
nsresult
GetDocumentURI
(
nsIEditor
*
aEditor
nsIURI
*
*
aURI
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIDOMDocument
>
domDoc
;
aEditor
-
>
GetDocument
(
getter_AddRefs
(
domDoc
)
)
;
NS_ENSURE_TRUE
(
domDoc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDoc
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIURI
>
docUri
=
doc
-
>
GetDocumentURI
(
)
;
NS_ENSURE_TRUE
(
docUri
NS_ERROR_FAILURE
)
;
*
aURI
=
docUri
;
NS_ADDREF
(
*
aURI
)
;
return
NS_OK
;
}
static
already_AddRefed
<
nsILoadContext
>
GetLoadContext
(
nsIEditor
*
aEditor
)
{
nsCOMPtr
<
nsIDOMDocument
>
domDoc
;
aEditor
-
>
GetDocument
(
getter_AddRefs
(
domDoc
)
)
;
NS_ENSURE_TRUE
(
domDoc
nullptr
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDoc
)
;
NS_ENSURE_TRUE
(
doc
nullptr
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
doc
-
>
GetLoadContext
(
)
;
return
loadContext
.
forget
(
)
;
}
class
DictionaryFetcher
final
:
public
nsIContentPrefCallback2
{
public
:
NS_DECL_ISUPPORTS
DictionaryFetcher
(
nsEditorSpellCheck
*
aSpellCheck
nsIEditorSpellCheckCallback
*
aCallback
uint32_t
aGroup
)
:
mCallback
(
aCallback
)
mGroup
(
aGroup
)
mSpellCheck
(
aSpellCheck
)
{
}
NS_IMETHOD
Fetch
(
nsIEditor
*
aEditor
)
;
NS_IMETHOD
HandleResult
(
nsIContentPref
*
aPref
)
override
{
nsCOMPtr
<
nsIVariant
>
value
;
nsresult
rv
=
aPref
-
>
GetValue
(
getter_AddRefs
(
value
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
value
-
>
GetAsAString
(
mDictionary
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleCompletion
(
uint16_t
reason
)
override
{
mSpellCheck
-
>
DictionaryFetched
(
this
)
;
return
NS_OK
;
}
NS_IMETHOD
HandleError
(
nsresult
error
)
override
{
return
NS_OK
;
}
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
uint32_t
mGroup
;
nsString
mRootContentLang
;
nsString
mRootDocContentLang
;
nsString
mDictionary
;
private
:
~
DictionaryFetcher
(
)
{
}
RefPtr
<
nsEditorSpellCheck
>
mSpellCheck
;
}
;
NS_IMPL_ISUPPORTS
(
DictionaryFetcher
nsIContentPrefCallback2
)
class
ContentPrefInitializerRunnable
final
:
public
Runnable
{
public
:
ContentPrefInitializerRunnable
(
nsIEditor
*
aEditor
nsIContentPrefCallback2
*
aCallback
)
:
Runnable
(
"
ContentPrefInitializerRunnable
"
)
mEditor
(
aEditor
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mEditor
-
>
AsEditorBase
(
)
-
>
Destroyed
(
)
)
{
mCallback
-
>
HandleError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
contentPrefService
)
)
{
mCallback
-
>
HandleError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
docUri
;
nsresult
rv
=
GetDocumentURI
(
mEditor
getter_AddRefs
(
docUri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mCallback
-
>
HandleError
(
rv
)
;
return
NS_OK
;
}
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mCallback
-
>
HandleError
(
rv
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
mEditor
)
;
rv
=
contentPrefService
-
>
GetByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
loadContext
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mCallback
-
>
HandleError
(
rv
)
;
return
NS_OK
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIEditor
>
mEditor
;
nsCOMPtr
<
nsIContentPrefCallback2
>
mCallback
;
}
;
NS_IMETHODIMP
DictionaryFetcher
:
:
Fetch
(
nsIEditor
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ContentPrefInitializerRunnable
(
aEditor
this
)
;
NS_IdleDispatchToCurrentThread
(
runnable
.
forget
(
)
1000
)
;
return
NS_OK
;
}
static
nsresult
StoreCurrentDictionary
(
nsIEditor
*
aEditor
const
nsAString
&
aDictionary
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
;
rv
=
GetDocumentURI
(
aEditor
getter_AddRefs
(
docUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsVariant
>
prefValue
=
new
nsVariant
(
)
;
prefValue
-
>
SetAsAString
(
aDictionary
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
aEditor
)
;
return
contentPrefService
-
>
Set
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
prefValue
loadContext
nullptr
)
;
}
static
nsresult
ClearCurrentDictionary
(
nsIEditor
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docUri
;
rv
=
GetDocumentURI
(
aEditor
getter_AddRefs
(
docUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
docUriSpec
;
rv
=
docUri
-
>
GetSpec
(
docUriSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
contentPrefService
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
GetLoadContext
(
aEditor
)
;
return
contentPrefService
-
>
RemoveByDomainAndName
(
NS_ConvertUTF8toUTF16
(
docUriSpec
)
CPS_PREF_NAME
loadContext
nullptr
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsEditorSpellCheck
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_BEGIN
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIEditorSpellCheck
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsEditorSpellCheck
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsEditorSpellCheck
mEditor
mSpellChecker
mTxtSrvFilter
)
nsEditorSpellCheck
:
:
nsEditorSpellCheck
(
)
:
mSuggestedWordIndex
(
0
)
mDictionaryIndex
(
0
)
mEditor
(
nullptr
)
mDictionaryFetcherGroup
(
0
)
mUpdateDictionaryRunning
(
false
)
{
}
nsEditorSpellCheck
:
:
~
nsEditorSpellCheck
(
)
{
mSpellChecker
=
nullptr
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CanSpellCheck
(
bool
*
_retval
)
{
RefPtr
<
mozSpellChecker
>
spellChecker
=
mSpellChecker
;
if
(
!
spellChecker
)
{
spellChecker
=
new
mozSpellChecker
(
)
;
DebugOnly
<
nsresult
>
rv
=
spellChecker
-
>
Init
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsTArray
<
nsString
>
dictList
;
nsresult
rv
=
spellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
_retval
=
(
dictList
.
Length
(
)
>
0
)
;
return
NS_OK
;
}
class
CallbackCaller
final
:
public
Runnable
{
public
:
explicit
CallbackCaller
(
nsIEditorSpellCheckCallback
*
aCallback
)
:
mozilla
:
:
Runnable
(
"
CallbackCaller
"
)
mCallback
(
aCallback
)
{
}
~
CallbackCaller
(
)
{
Run
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mCallback
)
{
mCallback
-
>
EditorSpellCheckDone
(
)
;
mCallback
=
nullptr
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIEditorSpellCheckCallback
>
mCallback
;
}
;
NS_IMETHODIMP
nsEditorSpellCheck
:
:
InitSpellChecker
(
nsIEditor
*
aEditor
bool
aEnableSelectionChecking
nsIEditorSpellCheckCallback
*
aCallback
)
{
NS_ENSURE_TRUE
(
aEditor
NS_ERROR_NULL_POINTER
)
;
mEditor
=
aEditor
;
nsCOMPtr
<
nsIDOMDocument
>
domDoc
;
mEditor
-
>
GetDocument
(
getter_AddRefs
(
domDoc
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDoc
)
;
NS_ENSURE_STATE
(
doc
)
;
nsresult
rv
;
RefPtr
<
TextServicesDocument
>
textServicesDocument
=
new
TextServicesDocument
(
)
;
textServicesDocument
-
>
SetFilter
(
mTxtSrvFilter
)
;
rv
=
textServicesDocument
-
>
InitWithEditor
(
aEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEnableSelectionChecking
)
{
nsCOMPtr
<
nsISelection
>
domSelection
;
aEditor
-
>
GetSelection
(
getter_AddRefs
(
domSelection
)
)
;
if
(
NS_WARN_IF
(
!
domSelection
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
selection
=
domSelection
-
>
AsSelection
(
)
;
if
(
selection
-
>
RangeCount
(
)
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
0
)
;
NS_ENSURE_STATE
(
range
)
;
if
(
!
range
-
>
Collapsed
(
)
)
{
RefPtr
<
nsRange
>
rangeBounds
=
range
-
>
CloneRange
(
)
;
rv
=
textServicesDocument
-
>
ExpandRangeToWordBoundaries
(
rangeBounds
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
textServicesDocument
-
>
SetExtent
(
rangeBounds
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
mSpellChecker
=
new
mozSpellChecker
(
)
;
rv
=
mSpellChecker
-
>
Init
(
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
mSpellChecker
-
>
SetDocument
(
textServicesDocument
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
UpdateCurrentDictionary
(
aCallback
)
;
if
(
NS_FAILED
(
rv
)
&
&
aCallback
)
{
RefPtr
<
CallbackCaller
>
caller
=
new
CallbackCaller
(
aCallback
)
;
rv
=
doc
-
>
Dispatch
(
TaskCategory
:
:
Other
caller
.
forget
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetNextMisspelledWord
(
nsAString
&
aNextMisspelledWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
return
mSpellChecker
-
>
NextMisspelledWord
(
aNextMisspelledWord
&
mSuggestedWordList
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetSuggestedWord
(
nsAString
&
aSuggestedWord
)
{
if
(
mSuggestedWordIndex
<
static_cast
<
int32_t
>
(
mSuggestedWordList
.
Length
(
)
)
)
{
aSuggestedWord
=
mSuggestedWordList
[
mSuggestedWordIndex
]
;
mSuggestedWordIndex
+
+
;
}
else
{
aSuggestedWord
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CheckCurrentWord
(
const
nsAString
&
aSuggestedWord
bool
*
aIsMisspelled
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
return
mSpellChecker
-
>
CheckWord
(
aSuggestedWord
aIsMisspelled
&
mSuggestedWordList
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
CheckCurrentWordNoSuggest
(
const
nsAString
&
aSuggestedWord
bool
*
aIsMisspelled
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
CheckWord
(
aSuggestedWord
aIsMisspelled
nullptr
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
ReplaceWord
(
const
nsAString
&
aMisspelledWord
const
nsAString
&
aReplaceWord
bool
allOccurrences
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
Replace
(
aMisspelledWord
aReplaceWord
allOccurrences
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
IgnoreWordAllOccurrences
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
IgnoreAll
(
aWord
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetPersonalDictionary
(
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
mDictionaryList
.
Clear
(
)
;
mDictionaryIndex
=
0
;
return
mSpellChecker
-
>
GetPersonalDictionary
(
&
mDictionaryList
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetPersonalDictionaryWord
(
nsAString
&
aDictionaryWord
)
{
if
(
mDictionaryIndex
<
static_cast
<
int32_t
>
(
mDictionaryList
.
Length
(
)
)
)
{
aDictionaryWord
=
mDictionaryList
[
mDictionaryIndex
]
;
mDictionaryIndex
+
+
;
}
else
{
aDictionaryWord
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
AddWordToDictionary
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
AddWordToPersonalDictionary
(
aWord
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
RemoveWordFromDictionary
(
const
nsAString
&
aWord
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
RemoveWordFromPersonalDictionary
(
aWord
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetDictionaryList
(
char16_t
*
*
*
aDictionaryList
uint32_t
*
aCount
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
NS_ENSURE_TRUE
(
aDictionaryList
&
&
aCount
NS_ERROR_NULL_POINTER
)
;
*
aDictionaryList
=
0
;
*
aCount
=
0
;
nsTArray
<
nsString
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char16_t
*
*
tmpPtr
=
0
;
if
(
dictList
.
IsEmpty
(
)
)
{
tmpPtr
=
(
char16_t
*
*
)
moz_xmalloc
(
sizeof
(
char16_t
*
)
)
;
NS_ENSURE_TRUE
(
tmpPtr
NS_ERROR_OUT_OF_MEMORY
)
;
*
tmpPtr
=
0
;
*
aDictionaryList
=
tmpPtr
;
*
aCount
=
0
;
return
NS_OK
;
}
tmpPtr
=
(
char16_t
*
*
)
moz_xmalloc
(
sizeof
(
char16_t
*
)
*
dictList
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
tmpPtr
NS_ERROR_OUT_OF_MEMORY
)
;
*
aDictionaryList
=
tmpPtr
;
*
aCount
=
dictList
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
*
aCount
;
i
+
+
)
{
tmpPtr
[
i
]
=
ToNewUnicode
(
dictList
[
i
]
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
GetCurrentDictionary
(
nsAString
&
aDictionary
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
return
mSpellChecker
-
>
GetCurrentDictionary
(
aDictionary
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
SetCurrentDictionary
(
const
nsAString
&
aDictionary
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
if
(
!
mUpdateDictionaryRunning
)
{
mDictionaryFetcherGroup
+
+
;
uint32_t
flags
=
0
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
)
{
if
(
!
aDictionary
.
IsEmpty
(
)
&
&
(
mPreferredLang
.
IsEmpty
(
)
|
|
!
mPreferredLang
.
Equals
(
aDictionary
nsCaseInsensitiveStringComparator
(
)
)
)
)
{
StoreCurrentDictionary
(
mEditor
aDictionary
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Writing
content
preferences
for
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
else
{
ClearCurrentDictionary
(
mEditor
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Clearing
content
preferences
for
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
if
(
XRE_IsParentProcess
(
)
)
{
Preferences
:
:
SetString
(
"
spellchecker
.
dictionary
"
aDictionary
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Possibly
storing
spellchecker
.
dictionary
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
aDictionary
)
.
get
(
)
)
;
#
endif
}
}
}
return
mSpellChecker
-
>
SetCurrentDictionary
(
aDictionary
)
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
UninitSpellChecker
(
)
{
NS_ENSURE_TRUE
(
mSpellChecker
NS_ERROR_NOT_INITIALIZED
)
;
DeleteSuggestedWordList
(
)
;
mDictionaryList
.
Clear
(
)
;
mDictionaryIndex
=
0
;
mSpellChecker
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
SetFilter
(
nsITextServicesFilter
*
filter
)
{
mTxtSrvFilter
=
filter
;
return
NS_OK
;
}
nsresult
nsEditorSpellCheck
:
:
DeleteSuggestedWordList
(
)
{
mSuggestedWordList
.
Clear
(
)
;
mSuggestedWordIndex
=
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsEditorSpellCheck
:
:
UpdateCurrentDictionary
(
nsIEditorSpellCheckCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
!
mSpellChecker
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
nsCOMPtr
<
nsIContent
>
rootContent
;
nsCOMPtr
<
nsIHTMLEditor
>
htmlEditor
=
do_QueryInterface
(
mEditor
)
;
if
(
htmlEditor
)
{
rootContent
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
}
else
{
nsCOMPtr
<
nsIDOMElement
>
rootElement
;
rv
=
mEditor
-
>
GetRootElement
(
getter_AddRefs
(
rootElement
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rootContent
=
do_QueryInterface
(
rootElement
)
;
}
uint32_t
flags
=
0
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
{
nsCOMPtr
<
nsIDocument
>
ownerDoc
=
rootContent
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
ownerDoc
NS_ERROR_FAILURE
)
;
nsIDocument
*
parentDoc
=
ownerDoc
-
>
GetParentDocument
(
)
;
if
(
parentDoc
)
{
rootContent
=
do_QueryInterface
(
parentDoc
-
>
GetDocumentElement
(
)
)
;
}
}
if
(
!
rootContent
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DictionaryFetcher
>
fetcher
=
new
DictionaryFetcher
(
this
aCallback
mDictionaryFetcherGroup
)
;
rootContent
-
>
GetLang
(
fetcher
-
>
mRootContentLang
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
rootContent
-
>
GetUncomposedDoc
(
)
;
NS_ENSURE_STATE
(
doc
)
;
doc
-
>
GetContentLanguage
(
fetcher
-
>
mRootDocContentLang
)
;
rv
=
fetcher
-
>
Fetch
(
mEditor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
nsEditorSpellCheck
:
:
BuildDictionaryList
(
const
nsAString
&
aDictName
const
nsTArray
<
nsString
>
&
aDictList
enum
dictCompare
aCompareType
nsTArray
<
nsString
>
&
aOutList
)
{
for
(
uint32_t
i
=
0
;
i
<
aDictList
.
Length
(
)
;
i
+
+
)
{
nsAutoString
dictStr
(
aDictList
.
ElementAt
(
i
)
)
;
bool
equals
=
false
;
switch
(
aCompareType
)
{
case
DICT_NORMAL_COMPARE
:
equals
=
aDictName
.
Equals
(
dictStr
)
;
break
;
case
DICT_COMPARE_CASE_INSENSITIVE
:
equals
=
aDictName
.
Equals
(
dictStr
nsCaseInsensitiveStringComparator
(
)
)
;
break
;
case
DICT_COMPARE_DASHMATCH
:
equals
=
nsStyleUtil
:
:
DashMatchCompare
(
dictStr
aDictName
nsCaseInsensitiveStringComparator
(
)
)
;
break
;
}
if
(
equals
)
{
aOutList
.
AppendElement
(
dictStr
)
;
#
ifdef
DEBUG_DICT
if
(
NS_SUCCEEDED
(
rv
)
)
{
printf
(
"
*
*
*
*
*
Trying
|
%
s
|
.
\
n
"
NS_ConvertUTF16toUTF8
(
dictStr
)
.
get
(
)
)
;
}
#
endif
return
;
}
}
}
nsresult
nsEditorSpellCheck
:
:
DictionaryFetched
(
DictionaryFetcher
*
aFetcher
)
{
MOZ_ASSERT
(
aFetcher
)
;
RefPtr
<
nsEditorSpellCheck
>
kungFuDeathGrip
=
this
;
BeginUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mGroup
<
mDictionaryFetcherGroup
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
NS_OK
;
}
mPreferredLang
.
Assign
(
aFetcher
-
>
mRootContentLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLang
(
element
)
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
mPreferredLang
)
.
get
(
)
)
;
#
endif
if
(
mPreferredLang
.
IsEmpty
(
)
)
{
mPreferredLang
.
Assign
(
aFetcher
-
>
mRootDocContentLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
mPreferredLang
(
content
-
language
)
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
mPreferredLang
)
.
get
(
)
)
;
#
endif
}
AutoTArray
<
nsString
8
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
rv
;
}
nsAutoString
dictName
;
uint32_t
flags
;
mEditor
-
>
GetFlags
(
&
flags
)
;
if
(
!
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
)
{
dictName
.
Assign
(
aFetcher
-
>
mDictionary
)
;
if
(
!
dictName
.
IsEmpty
(
)
)
{
AutoTArray
<
nsString
1
>
tryDictList
;
BuildDictionaryList
(
dictName
dictList
DICT_NORMAL_COMPARE
tryDictList
)
;
RefPtr
<
nsEditorSpellCheck
>
self
=
this
;
RefPtr
<
DictionaryFetcher
>
fetcher
=
aFetcher
;
mSpellChecker
-
>
SetCurrentDictionaryFromList
(
tryDictList
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Assigned
from
content
preferences
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
self
-
>
DeleteSuggestedWordList
(
)
;
self
-
>
EndUpdateDictionary
(
)
;
if
(
fetcher
-
>
mCallback
)
{
fetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
}
[
self
fetcher
]
(
)
{
ClearCurrentDictionary
(
self
-
>
mEditor
)
;
self
-
>
SetFallbackDictionary
(
fetcher
)
;
}
)
;
return
NS_OK
;
}
}
SetFallbackDictionary
(
aFetcher
)
;
return
NS_OK
;
}
void
nsEditorSpellCheck
:
:
SetFallbackDictionary
(
DictionaryFetcher
*
aFetcher
)
{
MOZ_ASSERT
(
mUpdateDictionaryRunning
)
;
AutoTArray
<
nsString
6
>
tryDictList
;
AutoTArray
<
nsString
8
>
dictList
;
nsresult
rv
=
mSpellChecker
-
>
GetDictionaryList
(
&
dictList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
;
}
nsAutoString
dictName
(
mPreferredLang
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Assigned
from
element
/
doc
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
nsAutoString
preferredDict
;
Preferences
:
:
GetLocalizedString
(
"
spellchecker
.
dictionary
"
preferredDict
)
;
if
(
!
dictName
.
IsEmpty
(
)
)
{
BuildDictionaryList
(
dictName
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
from
element
/
doc
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
nsAutoString
langCode
;
int32_t
dashIdx
=
dictName
.
FindChar
(
'
-
'
)
;
if
(
dashIdx
!
=
-
1
)
{
langCode
.
Assign
(
Substring
(
dictName
0
dashIdx
)
)
;
}
else
{
langCode
.
Assign
(
dictName
)
;
}
if
(
!
preferredDict
.
IsEmpty
(
)
&
&
nsStyleUtil
:
:
DashMatchCompare
(
preferredDict
langCode
nsDefaultStringComparator
(
)
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
preference
value
|
%
s
|
since
it
matches
language
code
\
n
"
NS_ConvertUTF16toUTF8
(
preferredDict
)
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
preferredDict
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
}
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
to
find
match
for
language
code
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
langCode
)
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
langCode
dictList
DICT_COMPARE_DASHMATCH
tryDictList
)
;
}
if
(
!
preferredDict
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
preference
value
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
preferredDict
)
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
preferredDict
dictList
DICT_NORMAL_COMPARE
tryDictList
)
;
}
nsAutoCString
utf8DictName
;
LocaleService
:
:
GetInstance
(
)
-
>
GetAppLocaleAsLangTag
(
utf8DictName
)
;
CopyUTF8toUTF16
(
utf8DictName
dictName
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
locale
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictName
)
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
dictName
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
nsAutoString
currentDictionary
;
GetCurrentDictionary
(
currentDictionary
)
;
if
(
!
currentDictionary
.
IsEmpty
(
)
&
&
tryDictList
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Retrieved
current
dict
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
currentDictionary
)
.
get
(
)
)
;
#
endif
EndUpdateDictionary
(
)
;
if
(
aFetcher
-
>
mCallback
)
{
aFetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
return
;
}
char
*
env_lang
=
getenv
(
"
LANG
"
)
;
if
(
env_lang
)
{
nsString
lang
=
NS_ConvertUTF8toUTF16
(
env_lang
)
;
int32_t
dot_pos
=
lang
.
FindChar
(
'
.
'
)
;
if
(
dot_pos
!
=
-
1
)
{
lang
=
Substring
(
lang
0
dot_pos
)
;
}
int32_t
underScore
=
lang
.
FindChar
(
'
_
'
)
;
if
(
underScore
!
=
-
1
)
{
lang
.
Replace
(
underScore
1
'
-
'
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
LANG
from
environment
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
lang
)
.
get
(
)
)
;
#
endif
BuildDictionaryList
(
lang
dictList
DICT_COMPARE_CASE_INSENSITIVE
tryDictList
)
;
}
}
if
(
!
dictList
.
IsEmpty
(
)
)
{
BuildDictionaryList
(
dictList
[
0
]
dictList
DICT_NORMAL_COMPARE
tryDictList
)
;
#
ifdef
DEBUG_DICT
printf
(
"
*
*
*
*
*
Trying
first
of
list
|
%
s
|
\
n
"
NS_ConvertUTF16toUTF8
(
dictList
[
0
]
)
.
get
(
)
)
;
#
endif
}
RefPtr
<
nsEditorSpellCheck
>
self
=
this
;
RefPtr
<
DictionaryFetcher
>
fetcher
=
aFetcher
;
mSpellChecker
-
>
SetCurrentDictionaryFromList
(
tryDictList
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
fetcher
]
(
)
{
self
-
>
DeleteSuggestedWordList
(
)
;
self
-
>
EndUpdateDictionary
(
)
;
if
(
fetcher
-
>
mCallback
)
{
fetcher
-
>
mCallback
-
>
EditorSpellCheckDone
(
)
;
}
}
)
;
}
