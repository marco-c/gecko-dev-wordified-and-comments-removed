var
EXPORTED_SYMBOLS
=
[
"
maybeOnSpellCheck
"
"
onSpellCheck
"
"
getDictionaryContentPref
"
]
;
const
SPELL_CHECK_ENDED_TOPIC
=
"
inlineSpellChecker
-
spellCheck
-
ended
"
;
const
SPELL_CHECK_STARTED_TOPIC
=
"
inlineSpellChecker
-
spellCheck
-
started
"
;
const
CP
=
Cc
[
"
mozilla
.
org
/
content
-
pref
/
service
;
1
"
]
.
getService
(
Ci
.
nsIContentPrefService2
)
;
function
maybeOnSpellCheck
(
editableElement
callback
)
{
let
editor
=
editableElement
.
editor
;
if
(
!
editor
)
{
let
win
=
editableElement
.
ownerGlobal
;
editor
=
win
.
docShell
.
editingSession
.
getEditorForWindow
(
win
)
;
}
if
(
!
editor
)
{
throw
new
Error
(
"
Unable
to
find
editor
for
element
"
+
editableElement
)
;
}
try
{
var
isc
=
editor
.
getInlineSpellChecker
(
false
)
;
}
catch
(
err
)
{
}
let
waitingForEnded
=
isc
&
&
isc
.
spellCheckPending
;
let
count
=
0
;
function
observe
(
subj
topic
data
)
{
if
(
subj
!
=
editor
)
{
return
;
}
count
=
0
;
let
expectedTopic
=
waitingForEnded
?
SPELL_CHECK_ENDED_TOPIC
:
SPELL_CHECK_STARTED_TOPIC
;
if
(
topic
!
=
expectedTopic
)
{
Cu
.
reportError
(
"
Expected
"
+
expectedTopic
+
"
but
got
"
+
topic
+
"
!
"
)
;
}
waitingForEnded
=
!
waitingForEnded
;
}
let
os
=
Cc
[
"
mozilla
.
org
/
observer
-
service
;
1
"
]
.
getService
(
Ci
.
nsIObserverService
)
;
os
.
addObserver
(
observe
SPELL_CHECK_STARTED_TOPIC
)
;
os
.
addObserver
(
observe
SPELL_CHECK_ENDED_TOPIC
)
;
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
timer
.
init
(
function
tick
(
)
{
if
(
waitingForEnded
|
|
+
+
count
<
100
)
{
return
;
}
timer
.
cancel
(
)
;
os
.
removeObserver
(
observe
SPELL_CHECK_STARTED_TOPIC
)
;
os
.
removeObserver
(
observe
SPELL_CHECK_ENDED_TOPIC
)
;
callback
(
)
;
}
0
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
function
onSpellCheck
(
editableElement
callback
)
{
const
{
TestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TestUtils
.
jsm
"
)
;
let
editor
=
editableElement
.
editor
;
TestUtils
.
topicObserved
(
SPELL_CHECK_ENDED_TOPIC
s
=
>
s
=
=
editor
)
.
then
(
callback
)
;
}
async
function
getDictionaryContentPref
(
)
{
let
dictionaries
=
await
new
Promise
(
resolve
=
>
{
let
value
=
"
"
;
CP
.
getByDomainAndName
(
"
mochi
.
test
"
"
spellcheck
.
lang
"
null
{
handleResult
(
pref
)
{
value
=
pref
.
value
;
}
handleCompletion
(
)
{
resolve
(
value
)
;
}
}
)
;
}
)
;
return
dictionaries
;
}
