template
imports
(
_from
=
"
__builtin__
"
_import
=
"
Exception
"
)
def
_declare_exceptions
(
)
:
class
FatalCheckError
(
Exception
)
:
"
"
"
An
exception
to
throw
from
a
function
decorated
with
checking
.
It
will
result
in
calling
die
(
)
with
the
given
message
.
Debugging
messages
emitted
from
the
decorated
function
will
also
be
printed
out
.
"
"
"
return
(
FatalCheckError
)
(
FatalCheckError
)
=
_declare_exceptions
(
)
del
_declare_exceptions
template
def
checking
(
what
callback
=
None
)
:
def
decorator
(
func
)
:
def
wrapped
(
*
args
*
*
kwargs
)
:
log
.
info
(
"
checking
%
s
.
.
.
"
what
)
with
log
.
queue_debug
(
)
:
error
ret
=
None
None
try
:
ret
=
func
(
*
args
*
*
kwargs
)
except
FatalCheckError
as
e
:
error
=
str
(
e
)
display_ret
=
callback
(
ret
)
if
callback
else
ret
if
display_ret
is
True
:
log
.
info
(
"
yes
"
)
elif
display_ret
is
False
or
display_ret
is
None
:
log
.
info
(
"
no
"
)
else
:
log
.
info
(
display_ret
)
if
error
is
not
None
:
die
(
error
)
return
ret
return
wrapped
return
decorator
template
imports
(
_from
=
"
mozshellutil
"
_import
=
"
quote
"
)
def
check_prog
(
var
progs
what
=
None
input
=
None
allow_missing
=
False
paths
=
None
allow_spaces
=
False
bootstrap
=
None
when
=
None
validate
=
None
bootstrap_search_path
=
None
)
:
if
input
is
not
None
:
depends
(
input
when
=
when
)
def
input
(
value
)
:
if
not
value
:
return
if
isinstance
(
value
str
)
:
return
(
value
)
if
isinstance
(
value
(
tuple
list
)
)
and
len
(
value
)
=
=
1
:
return
value
configure_error
(
"
input
must
resolve
to
a
tuple
or
a
list
with
a
"
"
single
element
or
a
string
"
)
else
:
option
(
env
=
var
nargs
=
1
when
=
when
help
=
"
Path
to
%
s
"
%
(
what
or
"
the
%
s
program
"
%
var
.
lower
(
)
)
)
input
=
var
what
=
what
or
var
.
lower
(
)
progs
=
dependable
(
progs
)
paths
=
dependable
(
paths
)
allow_missing
=
dependable
(
allow_missing
)
if
bootstrap
:
if
input
is
var
:
has_input
=
depends
(
input
when
=
when
)
(
lambda
x
:
x
)
else
:
has_input
=
input
if
when
:
bootstrap_when
=
depends
(
when
has_input
)
(
lambda
w
i
:
w
and
not
i
)
else
:
bootstrap_when
=
depends
(
has_input
)
(
lambda
i
:
not
i
)
paths
=
bootstrap_search_path
(
bootstrap
paths
when
=
bootstrap_when
)
depends_if
(
input
progs
paths
when
=
when
)
def
inputs
(
input
progs
paths
)
:
if
progs
is
None
:
progs
=
(
)
if
not
isinstance
(
progs
(
tuple
list
)
)
:
configure_error
(
"
progs
must
resolve
to
a
list
or
tuple
!
"
)
return
namespace
(
value
=
input
progs
=
progs
paths
=
paths
)
depends
(
inputs
allow_missing
when
=
inputs
)
checking
(
"
for
%
s
"
%
what
lambda
x
:
quote
(
x
)
if
x
else
"
not
found
"
)
def
check
(
inputs
allow_missing
)
:
value
=
inputs
.
value
progs
=
inputs
.
progs
paths
=
inputs
.
paths
for
prog
in
value
or
progs
:
log
.
debug
(
"
%
s
:
Looking
for
%
s
"
var
.
lower
(
)
quote
(
prog
)
)
result
=
find_program
(
prog
paths
allow_spaces
)
if
validate
and
result
and
not
validate
(
result
)
:
log
.
debug
(
"
%
s
:
%
s
found
but
didn
'
t
work
"
var
.
lower
(
)
quote
(
result
)
)
continue
if
result
:
return
result
if
not
allow_missing
or
value
:
raise
FatalCheckError
(
"
Cannot
find
%
s
"
%
what
)
set_config
(
var
check
)
return
check
