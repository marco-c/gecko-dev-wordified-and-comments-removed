template
imports
(
_from
=
"
__builtin__
"
_import
=
"
Exception
"
)
def
_declare_exceptions
(
)
:
class
FatalCheckError
(
Exception
)
:
"
"
"
An
exception
to
throw
from
a
function
decorated
with
checking
.
It
will
result
in
calling
die
(
)
with
the
given
message
.
Debugging
messages
emitted
from
the
decorated
function
will
also
be
printed
out
.
"
"
"
return
(
FatalCheckError
)
(
FatalCheckError
)
=
_declare_exceptions
(
)
del
_declare_exceptions
template
def
checking
(
what
callback
=
None
)
:
def
decorator
(
func
)
:
def
wrapped
(
*
args
*
*
kwargs
)
:
log
.
info
(
"
checking
%
s
.
.
.
"
what
)
with
log
.
queue_debug
(
)
:
error
ret
=
None
None
try
:
ret
=
func
(
*
args
*
*
kwargs
)
except
FatalCheckError
as
e
:
error
=
str
(
e
)
display_ret
=
callback
(
ret
)
if
callback
else
ret
if
display_ret
is
True
:
log
.
info
(
"
yes
"
)
elif
display_ret
is
False
or
display_ret
is
None
:
log
.
info
(
"
no
"
)
else
:
log
.
info
(
display_ret
)
if
error
is
not
None
:
die
(
error
)
return
ret
return
wrapped
return
decorator
template
imports
(
_from
=
"
mozbuild
.
shellutil
"
_import
=
"
quote
"
)
def
check_prog
(
var
progs
what
=
None
input
=
None
allow_missing
=
False
paths
=
None
paths_have_priority
=
False
when
=
None
)
:
if
input
is
not
None
:
depends
(
input
when
=
when
)
def
input
(
value
)
:
if
not
value
:
return
if
isinstance
(
value
str
)
:
return
(
value
)
if
isinstance
(
value
(
tuple
list
)
)
and
len
(
value
)
=
=
1
:
return
value
configure_error
(
"
input
must
resolve
to
a
tuple
or
a
list
with
a
"
"
single
element
or
a
string
"
)
else
:
option
(
env
=
var
nargs
=
1
when
=
when
help
=
"
Path
to
%
s
"
%
(
what
or
"
the
%
s
program
"
%
var
.
lower
(
)
)
)
input
=
var
what
=
what
or
var
.
lower
(
)
progs
=
dependable
(
progs
)
paths
=
dependable
(
paths
)
allow_missing
=
dependable
(
allow_missing
)
depends_if
(
input
progs
paths
when
=
when
)
def
inputs
(
input
progs
paths
)
:
if
progs
is
None
:
progs
=
(
)
if
not
isinstance
(
progs
(
tuple
list
)
)
:
configure_error
(
"
progs
must
resolve
to
a
list
or
tuple
!
"
)
return
namespace
(
value
=
input
progs
=
progs
paths
=
paths
)
depends
(
inputs
allow_missing
when
=
inputs
)
checking
(
"
for
%
s
"
%
what
lambda
x
:
quote
(
x
)
if
x
else
"
not
found
"
)
def
check
(
inputs
allow_missing
)
:
value
=
inputs
.
value
progs
=
inputs
.
progs
paths
=
inputs
.
paths
if
paths_have_priority
:
for
path
in
paths
:
for
prog
in
value
or
progs
:
log
.
debug
(
"
%
s
:
Trying
%
s
"
var
.
lower
(
)
quote
(
prog
)
)
result
=
find_program
(
prog
[
path
]
)
if
result
:
return
result
else
:
for
prog
in
value
or
progs
:
log
.
debug
(
"
%
s
:
Trying
%
s
"
var
.
lower
(
)
quote
(
prog
)
)
result
=
find_program
(
prog
paths
)
if
result
:
return
result
if
not
allow_missing
or
value
:
raise
FatalCheckError
(
"
Cannot
find
%
s
"
%
what
)
set_config
(
var
check
)
return
check
