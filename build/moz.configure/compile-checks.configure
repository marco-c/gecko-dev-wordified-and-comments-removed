template
def
try_compile
(
includes
=
None
body
=
"
"
language
=
"
C
+
+
"
flags
=
None
check_msg
=
None
when
=
None
onerror
=
lambda
:
None
)
:
compiler
=
{
"
C
"
:
c_compiler
"
C
+
+
"
:
cxx_compiler
}
[
language
]
return
compiler
.
try_compile
(
includes
body
flags
check_msg
when
=
when
onerror
=
onerror
)
template
def
try_link
(
includes
=
None
body
=
"
"
language
=
"
C
+
+
"
flags
=
None
check_msg
=
None
when
=
None
onerror
=
lambda
:
None
)
:
compiler
=
{
"
C
"
:
c_compiler
"
C
+
+
"
:
cxx_compiler
}
[
language
]
return
compiler
.
try_link
(
linker_ldflags
includes
body
flags
check_msg
when
=
when
onerror
=
onerror
)
template
def
check_header
(
header
language
=
"
C
+
+
"
flags
=
None
includes
=
None
when
=
None
onerror
=
lambda
:
None
)
:
if
when
is
None
:
when
=
always
if
includes
:
includes
=
includes
[
:
]
else
:
includes
=
[
]
includes
.
append
(
header
)
have_header
=
try_compile
(
includes
=
includes
language
=
language
flags
=
flags
check_msg
=
"
for
%
s
"
%
header
when
=
when
onerror
=
onerror
)
header_var
=
"
HAVE_
%
s
"
%
(
header
.
upper
(
)
.
replace
(
"
-
"
"
_
"
)
.
replace
(
"
/
"
"
_
"
)
.
replace
(
"
.
"
"
_
"
)
)
set_define
(
header_var
have_header
)
return
have_header
template
def
check_headers
(
*
headers
*
*
kwargs
)
:
checks
=
[
]
for
header
in
headers
:
checks
.
append
(
check_header
(
header
*
*
kwargs
)
)
return
checks
depends
(
linker_ldflags
target
.
kernel
)
def
check_symbol_flags
(
linker_ldflags
kernel
)
:
if
kernel
=
=
"
WINNT
"
:
return
[
"
-
fuse
-
ld
=
lld
"
]
return
linker_ldflags
template
def
check_symbol
(
symbol
language
=
"
C
"
flags
=
None
msg_extra
=
"
"
when
=
None
onerror
=
lambda
:
None
)
:
if
when
is
None
:
when
=
always
compiler
extern_c
=
{
"
C
"
:
(
c_compiler
"
"
)
"
C
+
+
"
:
(
cxx_compiler
'
extern
"
C
"
'
)
}
[
language
]
comment
=
[
"
/
*
Override
any
gcc2
internal
prototype
to
avoid
an
error
.
*
/
"
"
/
*
We
use
char
because
int
might
match
the
return
type
of
a
gcc2
"
"
builtin
and
then
its
argument
prototype
would
still
apply
.
*
/
"
]
if
flags
:
depends
(
check_symbol_flags
dependable
(
flags
)
)
def
flags
(
base_flags
extra_flags
)
:
if
base_flags
and
extra_flags
:
return
base_flags
+
list
(
extra_flags
)
if
extra_flags
:
return
extra_flags
return
base_flags
else
:
flags
=
check_symbol_flags
return
compiler
.
try_run
(
header
=
comment
+
[
"
%
schar
%
s
(
)
;
"
%
(
extern_c
symbol
)
]
body
=
"
%
s
(
)
;
"
%
symbol
flags
=
flags
check_msg
=
"
for
%
s
%
s
"
%
(
symbol
msg_extra
)
when
=
when
onerror
=
onerror
)
template
def
check_symbol_in_lib
(
libname
symbol
language
=
"
C
"
when
=
None
onerror
=
lambda
:
None
)
:
flag
=
f
"
-
l
{
libname
}
"
have_symbol
=
check_symbol
(
symbol
flags
=
[
flag
]
msg_extra
=
f
"
in
{
flag
}
"
language
=
language
when
=
when
onerror
=
onerror
)
return
have_symbol
template
def
check_symbol_in_libs
(
libnames
symbol
language
=
"
C
"
when
=
None
onerror
=
lambda
:
None
)
:
have_symbol
=
never
found_lib
=
dependable
(
namespace
(
found
=
False
lib
=
None
)
)
kwargs
=
{
"
symbol
"
:
symbol
"
language
"
:
language
"
when
"
:
when
or
always
"
onerror
"
:
onerror
}
for
libname
in
libnames
:
kwargs
[
"
when
"
]
&
=
~
have_symbol
if
libname
:
have_symbol
=
check_symbol_in_lib
(
libname
*
*
kwargs
)
else
:
have_symbol
=
check_symbol
(
*
*
kwargs
)
add_lib
=
namespace
(
found
=
True
lib
=
libname
)
found_lib
=
depends
(
have_symbol
found_lib
)
(
lambda
h
f
:
add_lib
if
h
else
f
)
return
found_lib
template
def
check_and_add_flags
(
flag
flags_collection
test_flags
=
(
)
compiler
=
None
when
=
None
check
=
True
mode
=
"
compile
"
)
:
assert
mode
in
(
"
compile
"
"
link
"
"
assemble
"
)
if
compiler
is
not
None
:
compilers
=
(
compiler
)
elif
mode
in
(
"
link
"
"
assemble
"
)
:
compilers
=
(
c_compiler
)
else
:
compilers
=
(
c_compiler
cxx_compiler
)
if
when
is
None
:
when
=
always
results
=
[
]
if
test_flags
:
flags
=
test_flags
else
:
flags
=
[
flag
]
for
c
in
compilers
:
assert
c
in
{
c_compiler
cxx_compiler
host_c_compiler
host_cxx_compiler
}
if
mode
=
=
"
compile
"
:
lang
list_of_flags
=
{
c_compiler
:
(
"
C
"
flags_collection
.
cflags
)
cxx_compiler
:
(
"
C
+
+
"
flags_collection
.
cxxflags
)
host_c_compiler
:
(
"
host
C
"
flags_collection
.
host_cflags
)
host_cxx_compiler
:
(
"
host
C
+
+
"
flags_collection
.
host_cxxflags
)
}
[
c
]
elif
mode
=
=
"
assemble
"
:
lang
list_of_flags
=
{
c_compiler
:
(
"
C
"
flags_collection
.
asflags
)
}
[
c
]
elif
mode
=
=
"
link
"
:
lang
list_of_flags
=
{
c_compiler
:
(
"
C
"
flags_collection
.
ldflags
)
cxx_compiler
:
(
"
C
+
+
"
flags_collection
.
ldflags
)
host_c_compiler
:
(
"
host
C
"
flags_collection
.
host_ldflags
)
host_cxx_compiler
:
(
"
host
C
+
+
"
flags_collection
.
host_ldflags
)
}
[
c
]
result
=
when
if
check
:
depends
(
c
dependable
(
flags
)
)
def
flags
(
c
flags
)
:
if
c
.
type
in
(
"
clang
"
"
clang
-
cl
"
)
:
flags
+
=
[
"
-
Wno
-
error
=
unused
-
command
-
line
-
argument
"
]
return
flags
if
mode
=
=
"
link
"
:
def
runner
(
*
args
*
*
kwargs
)
:
if
c
in
(
c_compiler
cxx_compiler
)
:
return
c
.
try_link
(
linker_ldflags
*
args
*
*
kwargs
)
else
:
return
c
.
try_link
(
host_linker_ldflags
*
args
*
*
kwargs
)
tool
=
"
linker
"
elif
mode
=
=
"
assemble
"
:
runner
=
c
.
try_compile
tool
=
"
assembler
"
else
:
runner
=
c
.
try_compile
tool
=
"
compiler
"
result
=
runner
(
flags
=
flags
when
=
result
check_msg
=
"
whether
the
%
s
%
s
supports
%
s
"
%
(
lang
tool
flag
)
)
depends
(
result
list_of_flags
)
def
maybe_add_flag
(
result
list_of_flags
)
:
if
result
:
list_of_flags
.
append
(
flag
)
results
.
append
(
result
)
return
tuple
(
results
)
dependable
def
warnings_flags
(
)
:
return
namespace
(
cflags
=
[
]
cxxflags
=
[
]
host_cflags
=
[
]
host_cxxflags
=
[
]
)
template
def
check_and_add_warning
(
warning
compiler
=
None
when
=
None
check
=
True
)
:
if
warning
.
startswith
(
"
-
Wno
-
"
)
and
not
warning
.
startswith
(
"
-
Wno
-
error
=
"
)
:
flags
=
[
"
-
Werror
"
"
-
W
"
+
warning
[
5
:
]
]
elif
warning
.
startswith
(
"
-
Werror
=
"
)
:
flags
=
[
warning
]
else
:
flags
=
[
"
-
Werror
"
warning
]
return
check_and_add_flags
(
warning
warnings_flags
flags
compiler
=
compiler
when
=
when
check
=
check
)
template
def
add_warning
(
warning
compiler
=
None
when
=
None
)
:
check_and_add_warning
(
warning
compiler
when
check
=
False
)
dependable
def
compilation_flags
(
)
:
return
namespace
(
cflags
=
[
]
cxxflags
=
[
]
host_cflags
=
[
]
host_cxxflags
=
[
]
cmflags
=
[
]
cmmflags
=
[
]
)
template
def
check_and_add_flag
(
flag
compiler
=
None
when
=
None
check
=
True
)
:
flags
=
[
"
-
Werror
"
flag
]
return
check_and_add_flags
(
flag
compilation_flags
flags
compiler
=
compiler
when
=
when
check
=
check
)
template
def
add_flag
(
warning
compiler
=
None
when
=
None
)
:
check_and_add_flag
(
warning
compiler
when
check
=
False
)
dependable
def
asm_flags
(
)
:
return
namespace
(
asflags
=
[
]
)
template
def
check_and_add_asm_flag
(
flag
when
=
None
check
=
True
)
:
return
check_and_add_flags
(
flag
asm_flags
[
flag
]
when
=
when
check
=
check
mode
=
"
assemble
"
)
dependable
def
linker_flags
(
)
:
return
namespace
(
ldflags
=
[
]
host_ldflags
=
[
]
)
dependable
def
dso_flags
(
)
:
return
namespace
(
ldopts
=
[
]
)
template
def
check_and_add_linker_flag
(
flag
compiler
=
None
when
=
None
check
=
True
)
:
return
check_and_add_flags
(
flag
linker_flags
[
flag
]
when
=
when
check
=
check
mode
=
"
link
"
)
dependable
def
linker_optimize_flags
(
)
:
return
namespace
(
ldflags
=
[
]
)
template
def
check_and_add_linker_optimize_flag
(
flag
compiler
=
None
when
=
None
check
=
True
)
:
return
check_and_add_flags
(
flag
linker_optimize_flags
[
flag
]
when
=
when
check
=
check
mode
=
"
link
"
)
template
def
add_linker_flag
(
flag
compiler
=
None
when
=
None
)
:
check_and_add_linker_flag
(
flag
compiler
when
check
=
False
)
