package
org
.
mozilla
.
gecko
.
annotationProcessors
.
classloader
;
import
java
.
util
.
Iterator
;
public
class
JarClassIterator
implements
Iterator
<
ClassWithOptions
>
{
private
IterableJarLoadingURLClassLoader
mTarget
;
private
Iterator
<
String
>
mTargetClassListIterator
;
private
ClassWithOptions
lookAhead
;
public
JarClassIterator
(
IterableJarLoadingURLClassLoader
aTarget
)
{
mTarget
=
aTarget
;
mTargetClassListIterator
=
aTarget
.
classNames
.
iterator
(
)
;
}
Override
public
boolean
hasNext
(
)
{
return
fillLookAheadIfPossible
(
)
;
}
Override
public
ClassWithOptions
next
(
)
{
if
(
!
fillLookAheadIfPossible
(
)
)
{
throw
new
IllegalStateException
(
"
Failed
to
look
ahead
in
next
(
)
!
"
)
;
}
ClassWithOptions
next
=
lookAhead
;
lookAhead
=
null
;
return
next
;
}
private
boolean
fillLookAheadIfPossible
(
)
{
if
(
lookAhead
!
=
null
)
{
return
true
;
}
if
(
!
mTargetClassListIterator
.
hasNext
(
)
)
{
return
false
;
}
String
className
=
mTargetClassListIterator
.
next
(
)
;
try
{
Class
<
?
>
ret
=
mTarget
.
loadClass
(
className
)
;
final
Class
<
?
>
enclosingClass
;
try
{
enclosingClass
=
ret
.
getEnclosingClass
(
)
;
}
catch
(
IncompatibleClassChangeError
e
)
{
return
fillLookAheadIfPossible
(
)
;
}
if
(
enclosingClass
!
=
null
)
{
return
fillLookAheadIfPossible
(
)
;
}
lookAhead
=
new
ClassWithOptions
(
ret
ret
.
getSimpleName
(
)
)
;
return
true
;
}
catch
(
ClassNotFoundException
e
)
{
System
.
err
.
println
(
"
Unable
to
enumerate
class
:
"
+
className
+
"
.
Corrupted
jar
file
?
"
)
;
e
.
printStackTrace
(
)
;
System
.
exit
(
2
)
;
}
return
false
;
}
Override
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
"
Removal
of
classes
from
iterator
not
supported
.
"
)
;
}
}
