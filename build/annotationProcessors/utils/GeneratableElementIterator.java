package
org
.
mozilla
.
gecko
.
annotationProcessors
.
utils
;
import
org
.
mozilla
.
gecko
.
annotationProcessors
.
AnnotationInfo
;
import
org
.
mozilla
.
gecko
.
annotationProcessors
.
classloader
.
AnnotatableEntity
;
import
org
.
mozilla
.
gecko
.
annotationProcessors
.
classloader
.
ClassWithOptions
;
import
java
.
lang
.
annotation
.
Annotation
;
import
java
.
lang
.
reflect
.
AnnotatedElement
;
import
java
.
lang
.
reflect
.
InvocationTargetException
;
import
java
.
lang
.
reflect
.
Member
;
import
java
.
lang
.
reflect
.
Method
;
import
java
.
util
.
Arrays
;
import
java
.
util
.
Comparator
;
import
java
.
util
.
Iterator
;
public
class
GeneratableElementIterator
implements
Iterator
<
AnnotatableEntity
>
{
private
final
ClassWithOptions
mClass
;
private
final
Member
[
]
mObjects
;
private
AnnotatableEntity
mNextReturnValue
;
private
int
mElementIndex
;
private
AnnotationInfo
mClassInfo
;
private
boolean
mIterateEveryEntry
;
public
GeneratableElementIterator
(
ClassWithOptions
annotatedClass
)
{
mClass
=
annotatedClass
;
final
Class
<
?
>
aClass
=
annotatedClass
.
wrappedClass
;
Member
[
]
aMethods
=
aClass
.
getDeclaredMethods
(
)
;
Member
[
]
aFields
=
aClass
.
getDeclaredFields
(
)
;
Member
[
]
aCtors
=
aClass
.
getDeclaredConstructors
(
)
;
Member
[
]
objs
=
new
Member
[
aMethods
.
length
+
aFields
.
length
+
aCtors
.
length
]
;
int
offset
=
0
;
System
.
arraycopy
(
aMethods
0
objs
0
aMethods
.
length
)
;
offset
+
=
aMethods
.
length
;
System
.
arraycopy
(
aFields
0
objs
offset
aFields
.
length
)
;
offset
+
=
aFields
.
length
;
System
.
arraycopy
(
aCtors
0
objs
offset
aCtors
.
length
)
;
Arrays
.
sort
(
objs
new
AlphabeticAnnotatableEntityComparator
<
Member
>
(
)
)
;
mObjects
=
objs
;
for
(
Annotation
annotation
:
aClass
.
getDeclaredAnnotations
(
)
)
{
mClassInfo
=
buildAnnotationInfo
(
aClass
annotation
)
;
if
(
mClassInfo
!
=
null
)
{
mIterateEveryEntry
=
true
;
break
;
}
}
findNextValue
(
)
;
}
private
Class
<
?
>
[
]
getFilteredInnerClasses
(
)
{
final
Class
<
?
>
[
]
candidates
=
mClass
.
wrappedClass
.
getDeclaredClasses
(
)
;
int
count
=
0
;
for
(
int
i
=
0
;
i
<
candidates
.
length
;
+
+
i
)
{
final
GeneratableElementIterator
testIterator
=
new
GeneratableElementIterator
(
new
ClassWithOptions
(
candidates
[
i
]
null
)
)
;
if
(
testIterator
.
hasNext
(
)
|
|
testIterator
.
getFilteredInnerClasses
(
)
!
=
null
)
{
count
+
+
;
continue
;
}
candidates
[
i
]
=
null
;
}
return
count
>
0
?
candidates
:
null
;
}
public
ClassWithOptions
[
]
getInnerClasses
(
)
{
final
Class
<
?
>
[
]
candidates
=
getFilteredInnerClasses
(
)
;
if
(
candidates
=
=
null
)
{
return
new
ClassWithOptions
[
0
]
;
}
int
count
=
0
;
for
(
Class
<
?
>
candidate
:
candidates
)
{
if
(
candidate
!
=
null
)
{
count
+
+
;
}
}
final
ClassWithOptions
[
]
ret
=
new
ClassWithOptions
[
count
]
;
count
=
0
;
for
(
Class
<
?
>
candidate
:
candidates
)
{
if
(
candidate
!
=
null
)
{
ret
[
count
+
+
]
=
new
ClassWithOptions
(
candidate
mClass
.
generatedName
+
"
:
:
"
+
candidate
.
getSimpleName
(
)
)
;
}
}
assert
ret
.
length
=
=
count
;
Arrays
.
sort
(
ret
new
Comparator
<
ClassWithOptions
>
(
)
{
Override
public
int
compare
(
ClassWithOptions
lhs
ClassWithOptions
rhs
)
{
return
lhs
.
generatedName
.
compareTo
(
rhs
.
generatedName
)
;
}
}
)
;
return
ret
;
}
private
AnnotationInfo
buildAnnotationInfo
(
AnnotatedElement
element
Annotation
annotation
)
{
Class
<
?
extends
Annotation
>
annotationType
=
annotation
.
annotationType
(
)
;
final
String
annotationTypeName
=
annotationType
.
getName
(
)
;
if
(
!
annotationTypeName
.
equals
(
"
org
.
mozilla
.
gecko
.
annotation
.
WrapForJNI
"
)
)
{
return
null
;
}
String
stubName
=
null
;
boolean
isMultithreadedStub
=
false
;
boolean
noThrow
=
false
;
boolean
narrowChars
=
false
;
boolean
catchException
=
false
;
try
{
final
Method
stubNameMethod
=
annotationType
.
getDeclaredMethod
(
"
stubName
"
)
;
stubNameMethod
.
setAccessible
(
true
)
;
stubName
=
(
String
)
stubNameMethod
.
invoke
(
annotation
)
;
if
(
element
instanceof
Class
<
?
>
)
{
isMultithreadedStub
=
true
;
}
else
{
final
Method
multithreadedStubMethod
=
annotationType
.
getDeclaredMethod
(
"
allowMultithread
"
)
;
multithreadedStubMethod
.
setAccessible
(
true
)
;
isMultithreadedStub
=
(
Boolean
)
multithreadedStubMethod
.
invoke
(
annotation
)
;
}
final
Method
noThrowMethod
=
annotationType
.
getDeclaredMethod
(
"
noThrow
"
)
;
noThrowMethod
.
setAccessible
(
true
)
;
noThrow
=
(
Boolean
)
noThrowMethod
.
invoke
(
annotation
)
;
final
Method
narrowCharsMethod
=
annotationType
.
getDeclaredMethod
(
"
narrowChars
"
)
;
narrowCharsMethod
.
setAccessible
(
true
)
;
narrowChars
=
(
Boolean
)
narrowCharsMethod
.
invoke
(
annotation
)
;
final
Method
catchExceptionMethod
=
annotationType
.
getDeclaredMethod
(
"
catchException
"
)
;
catchExceptionMethod
.
setAccessible
(
true
)
;
catchException
=
(
Boolean
)
catchExceptionMethod
.
invoke
(
annotation
)
;
}
catch
(
NoSuchMethodException
e
)
{
System
.
err
.
println
(
"
Unable
to
find
expected
field
on
WrapForJNI
annotation
.
Did
the
signature
change
?
"
)
;
e
.
printStackTrace
(
System
.
err
)
;
System
.
exit
(
3
)
;
}
catch
(
IllegalAccessException
e
)
{
System
.
err
.
println
(
"
IllegalAccessException
reading
fields
on
WrapForJNI
annotation
.
Seems
the
semantics
of
Reflection
have
changed
.
.
.
"
)
;
e
.
printStackTrace
(
System
.
err
)
;
System
.
exit
(
4
)
;
}
catch
(
InvocationTargetException
e
)
{
System
.
err
.
println
(
"
InvocationTargetException
reading
fields
on
WrapForJNI
annotation
.
This
really
shouldn
'
t
happen
.
"
)
;
e
.
printStackTrace
(
System
.
err
)
;
System
.
exit
(
5
)
;
}
if
(
stubName
.
isEmpty
(
)
)
{
stubName
=
Utils
.
getNativeName
(
element
)
;
}
return
new
AnnotationInfo
(
stubName
isMultithreadedStub
noThrow
narrowChars
catchException
)
;
}
private
void
findNextValue
(
)
{
while
(
mElementIndex
<
mObjects
.
length
)
{
Member
candidateElement
=
mObjects
[
mElementIndex
]
;
mElementIndex
+
+
;
for
(
Annotation
annotation
:
(
(
AnnotatedElement
)
candidateElement
)
.
getDeclaredAnnotations
(
)
)
{
AnnotationInfo
info
=
buildAnnotationInfo
(
(
AnnotatedElement
)
candidateElement
annotation
)
;
if
(
info
!
=
null
)
{
mNextReturnValue
=
new
AnnotatableEntity
(
candidateElement
info
)
;
return
;
}
}
if
(
mIterateEveryEntry
)
{
AnnotationInfo
annotationInfo
=
new
AnnotationInfo
(
Utils
.
getNativeName
(
candidateElement
)
mClassInfo
.
isMultithreaded
mClassInfo
.
noThrow
mClassInfo
.
narrowChars
mClassInfo
.
catchException
)
;
mNextReturnValue
=
new
AnnotatableEntity
(
candidateElement
annotationInfo
)
;
return
;
}
}
mNextReturnValue
=
null
;
}
Override
public
boolean
hasNext
(
)
{
return
mNextReturnValue
!
=
null
;
}
Override
public
AnnotatableEntity
next
(
)
{
AnnotatableEntity
ret
=
mNextReturnValue
;
findNextValue
(
)
;
return
ret
;
}
Override
public
void
remove
(
)
{
throw
new
UnsupportedOperationException
(
"
Removal
of
methods
from
GeneratableElementIterator
not
supported
.
"
)
;
}
}
