#
include
<
cxxabi
.
h
>
#
include
<
cstddef
>
#
include
<
cassert
>
namespace
{
const
void
*
adjust_pointer
(
const
void
*
p
std
:
:
ptrdiff_t
off
)
{
const
char
*
cp
=
reinterpret_cast
<
const
char
*
>
(
p
)
+
off
;
return
reinterpret_cast
<
const
void
*
>
(
cp
)
;
}
inline
const
void
*
get_vtable
(
const
void
*
p
)
{
return
*
reinterpret_cast
<
void
*
const
*
>
(
p
)
;
}
inline
const
abi
:
:
__class_type_info
*
get_class_type_info
(
const
void
*
vtable
)
{
const
void
*
type_info_ptr
=
adjust_pointer
(
vtable
-
sizeof
(
void
*
)
)
;
return
*
reinterpret_cast
<
abi
:
:
__class_type_info
*
const
*
>
(
type_info_ptr
)
;
}
inline
std
:
:
ptrdiff_t
get_offset_to_top
(
const
void
*
vtable
)
{
const
void
*
type_info_ptr_address
=
adjust_pointer
(
vtable
-
sizeof
(
void
*
)
)
;
const
void
*
offset_to_top_address
=
adjust_pointer
(
type_info_ptr_address
-
sizeof
(
std
:
:
ptrdiff_t
)
)
;
return
*
reinterpret_cast
<
const
std
:
:
ptrdiff_t
*
>
(
offset_to_top_address
)
;
}
const
void
*
get_most_derived_object
(
const
void
*
p
)
{
const
void
*
vtable
=
get_vtable
(
p
)
;
std
:
:
ptrdiff_t
offset_to_top
=
get_offset_to_top
(
vtable
)
;
return
adjust_pointer
(
p
offset_to_top
)
;
}
const
void
*
const
ambiguous_object
=
reinterpret_cast
<
const
void
*
>
(
-
1
)
;
const
void
*
get_subobject
(
const
void
*
object
const
void
*
vtable
const
abi
:
:
__base_class_type_info
*
base_info
)
{
long
offset
=
base_info
-
>
offset
(
)
;
if
(
base_info
-
>
is_virtual
(
)
)
{
const
std
:
:
ptrdiff_t
*
virtual_base_offset_address
=
static_cast
<
const
std
:
:
ptrdiff_t
*
>
(
adjust_pointer
(
vtable
offset
)
)
;
offset
=
*
virtual_base_offset_address
;
}
return
adjust_pointer
(
object
offset
)
;
}
const
void
*
walk_object
(
const
void
*
object
const
abi
:
:
__class_type_info
*
type
const
void
*
match_object
const
abi
:
:
__class_type_info
*
match_type
)
{
if
(
*
type
=
=
*
match_type
)
return
(
match_object
=
=
NULL
|
|
object
=
=
match_object
)
?
object
:
NULL
;
switch
(
type
-
>
code
(
)
)
{
case
abi
:
:
__class_type_info
:
:
CLASS_TYPE_INFO_CODE
:
return
NULL
;
case
abi
:
:
__class_type_info
:
:
SI_CLASS_TYPE_INFO_CODE
:
{
const
abi
:
:
__si_class_type_info
*
ti
=
static_cast
<
const
abi
:
:
__si_class_type_info
*
>
(
type
)
;
return
walk_object
(
object
ti
-
>
__base_type
match_object
match_type
)
;
}
case
abi
:
:
__class_type_info
:
:
VMI_CLASS_TYPE_INFO_CODE
:
{
const
void
*
vtable
=
get_vtable
(
object
)
;
const
abi
:
:
__vmi_class_type_info
*
ti
=
static_cast
<
const
abi
:
:
__vmi_class_type_info
*
>
(
type
)
;
const
void
*
result
=
NULL
;
for
(
unsigned
i
=
0
;
i
<
ti
-
>
__base_count
;
+
+
i
)
{
if
(
!
ti
-
>
__base_info
[
i
]
.
is_public
(
)
)
continue
;
const
void
*
subobject
=
get_subobject
(
object
vtable
&
ti
-
>
__base_info
[
i
]
)
;
const
void
*
walk_subobject_result
=
walk_object
(
subobject
ti
-
>
__base_info
[
i
]
.
__base_type
match_object
match_type
)
;
if
(
walk_subobject_result
=
=
ambiguous_object
)
return
ambiguous_object
;
else
if
(
walk_subobject_result
!
=
NULL
)
{
if
(
result
=
=
NULL
)
{
result
=
walk_subobject_result
;
}
else
if
(
result
!
=
walk_subobject_result
)
return
ambiguous_object
;
}
}
return
result
;
}
default
:
assert
(
0
)
;
}
return
NULL
;
}
struct
cast_context
{
public
:
const
void
*
object
;
const
abi
:
:
__class_type_info
*
src_type
;
const
abi
:
:
__class_type_info
*
dst_type
;
std
:
:
ptrdiff_t
src2dst_offset
;
const
void
*
dst_object
;
const
void
*
result
;
cast_context
(
const
void
*
obj
const
abi
:
:
__class_type_info
*
src
const
abi
:
:
__class_type_info
*
dst
std
:
:
ptrdiff_t
offset
)
:
object
(
obj
)
src_type
(
src
)
dst_type
(
dst
)
src2dst_offset
(
offset
)
dst_object
(
NULL
)
result
(
NULL
)
{
}
}
;
void
base_to_derived_cast
(
const
void
*
object
const
abi
:
:
__class_type_info
*
type
cast_context
*
context
)
{
const
void
*
saved_dst_object
=
context
-
>
dst_object
;
bool
is_dst_type
=
*
type
=
=
*
context
-
>
dst_type
;
if
(
is_dst_type
)
context
-
>
dst_object
=
object
;
if
(
object
=
=
context
-
>
object
&
&
context
-
>
dst_object
!
=
NULL
&
&
*
type
=
=
*
context
-
>
src_type
)
{
if
(
context
-
>
result
=
=
NULL
)
context
-
>
result
=
context
-
>
dst_object
;
else
if
(
context
-
>
result
!
=
context
-
>
dst_object
)
context
-
>
result
=
ambiguous_object
;
context
-
>
dst_object
=
saved_dst_object
;
return
;
}
switch
(
type
-
>
code
(
)
)
{
case
abi
:
:
__class_type_info
:
:
CLASS_TYPE_INFO_CODE
:
break
;
case
abi
:
:
__class_type_info
:
:
SI_CLASS_TYPE_INFO_CODE
:
{
const
abi
:
:
__si_class_type_info
*
ti
=
static_cast
<
const
abi
:
:
__si_class_type_info
*
>
(
type
)
;
base_to_derived_cast
(
object
ti
-
>
__base_type
context
)
;
break
;
}
case
abi
:
:
__class_type_info
:
:
VMI_CLASS_TYPE_INFO_CODE
:
{
const
void
*
vtable
=
get_vtable
(
object
)
;
const
abi
:
:
__vmi_class_type_info
*
ti
=
static_cast
<
const
abi
:
:
__vmi_class_type_info
*
>
(
type
)
;
for
(
unsigned
i
=
0
;
i
<
ti
-
>
__base_count
;
+
+
i
)
{
if
(
!
ti
-
>
__base_info
[
i
]
.
is_public
(
)
)
continue
;
const
void
*
subobject
=
get_subobject
(
object
vtable
&
ti
-
>
__base_info
[
i
]
)
;
base_to_derived_cast
(
subobject
ti
-
>
__base_info
[
i
]
.
__base_type
context
)
;
if
(
context
-
>
result
=
=
ambiguous_object
)
break
;
}
break
;
}
default
:
assert
(
0
)
;
}
context
-
>
dst_object
=
saved_dst_object
;
}
}
namespace
__cxxabiv1
{
#
define
DYNAMIC_CAST_NO_HINT
-
1
#
define
DYNAMIC_CAST_NOT_PUBLIC_BASE
-
2
#
define
DYNAMIC_CAST_MULTIPLE_PUBLIC_NONVIRTUAL_BASE
-
3
extern
"
C
"
void
*
__dynamic_cast
(
const
void
*
v
const
abi
:
:
__class_type_info
*
src
const
abi
:
:
__class_type_info
*
dst
std
:
:
ptrdiff_t
src2dst_offset
)
{
const
void
*
most_derived_object
=
get_most_derived_object
(
v
)
;
const
void
*
vtable
=
get_vtable
(
most_derived_object
)
;
const
abi
:
:
__class_type_info
*
most_derived_class_type_info
=
get_class_type_info
(
vtable
)
;
void
*
t_object
=
const_cast
<
void
*
>
(
walk_object
(
most_derived_object
most_derived_class_type_info
NULL
dst
)
)
;
if
(
t_object
=
=
NULL
)
return
NULL
;
if
(
src2dst_offset
!
=
DYNAMIC_CAST_NOT_PUBLIC_BASE
)
{
if
(
t_object
!
=
ambiguous_object
&
&
src2dst_offset
>
=
0
)
return
const_cast
<
void
*
>
(
adjust_pointer
(
v
-
src2dst_offset
)
)
;
cast_context
context
(
v
src
dst
src2dst_offset
)
;
if
(
t_object
!
=
ambiguous_object
)
base_to_derived_cast
(
t_object
dst
&
context
)
;
else
base_to_derived_cast
(
most_derived_object
most_derived_class_type_info
&
context
)
;
if
(
context
.
result
!
=
NULL
&
&
context
.
result
!
=
ambiguous_object
)
return
const_cast
<
void
*
>
(
context
.
result
)
;
}
if
(
t_object
=
=
ambiguous_object
)
return
NULL
;
const
void
*
v_object
=
walk_object
(
most_derived_object
most_derived_class_type_info
v
src
)
;
return
v_object
=
=
v
?
t_object
:
NULL
;
}
}
