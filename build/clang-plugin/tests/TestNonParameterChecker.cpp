#
define
MOZ_NON_PARAM
__attribute__
(
(
annotate
(
"
moz_non_param
"
)
)
)
struct
Param
{
}
;
struct
MOZ_NON_PARAM
NonParam
{
}
;
union
MOZ_NON_PARAM
NonParamUnion
{
}
;
class
MOZ_NON_PARAM
NonParamClass
{
}
;
enum
MOZ_NON_PARAM
NonParamEnum
{
X
Y
Z
}
;
enum
class
MOZ_NON_PARAM
NonParamEnumClass
{
X
Y
Z
}
;
struct
HasNonParamStruct
{
NonParam
x
;
int
y
;
}
;
union
HasNonParamUnion
{
NonParam
x
;
int
y
;
}
;
struct
HasNonParamStructUnion
{
HasNonParamUnion
z
;
}
;
#
define
MAYBE_STATIC
#
include
"
NonParameterTestCases
.
h
"
#
undef
MAYBE_STATIC
typedef
void
(
*
funcTypeParam
)
(
Param
x
)
;
typedef
void
(
*
funcTypeNonParam
)
(
NonParam
x
)
;
using
usingFuncTypeParam
=
void
(
*
)
(
Param
x
)
;
using
usingFuncTypeNonParam
=
void
(
*
)
(
NonParam
x
)
;
class
class_
{
explicit
class_
(
Param
x
)
{
}
explicit
class_
(
NonParam
x
)
{
}
explicit
class_
(
HasNonParamStruct
x
)
{
}
explicit
class_
(
HasNonParamUnion
x
)
{
}
explicit
class_
(
HasNonParamStructUnion
x
)
{
}
#
define
MAYBE_STATIC
#
include
"
NonParameterTestCases
.
h
"
#
undef
MAYBE_STATIC
}
;
class
classWithStatic
{
#
define
MAYBE_STATIC
static
#
include
"
NonParameterTestCases
.
h
"
#
undef
MAYBE_STATIC
}
;
template
<
typename
T
>
class
tmplClassForParam
{
public
:
void
raw
(
T
x
)
{
}
void
rawDefault
(
T
x
=
T
(
)
)
{
}
void
const_
(
const
T
x
)
{
}
void
ptr
(
T
*
x
)
{
}
void
ref
(
T
&
x
)
{
}
void
constRef
(
const
T
&
x
)
{
}
void
notCalled
(
T
x
)
{
}
}
;
template
<
typename
T
>
class
tmplClassForNonParam
{
public
:
void
raw
(
T
x
)
{
}
void
rawDefault
(
T
x
=
T
(
)
)
{
}
void
const_
(
const
T
x
)
{
}
void
ptr
(
T
*
x
)
{
}
void
ref
(
T
&
x
)
{
}
void
constRef
(
const
T
&
x
)
{
}
void
notCalled
(
T
x
)
{
}
}
;
template
<
typename
T
>
class
tmplClassForHasNonParamStruct
{
public
:
void
raw
(
T
x
)
{
}
void
rawDefault
(
T
x
=
T
(
)
)
{
}
void
const_
(
const
T
x
)
{
}
void
ptr
(
T
*
x
)
{
}
void
ref
(
T
&
x
)
{
}
void
constRef
(
const
T
&
x
)
{
}
void
notCalled
(
T
x
)
{
}
}
;
void
testTemplateClass
(
)
{
tmplClassForParam
<
Param
>
paramClass
;
Param
param
;
paramClass
.
raw
(
param
)
;
paramClass
.
rawDefault
(
)
;
paramClass
.
const_
(
param
)
;
paramClass
.
ptr
(
&
param
)
;
paramClass
.
ref
(
param
)
;
paramClass
.
constRef
(
param
)
;
tmplClassForNonParam
<
NonParam
>
nonParamClass
;
NonParam
nonParam
;
nonParamClass
.
raw
(
nonParam
)
;
nonParamClass
.
rawDefault
(
)
;
nonParamClass
.
const_
(
nonParam
)
;
nonParamClass
.
ptr
(
&
nonParam
)
;
nonParamClass
.
ref
(
nonParam
)
;
nonParamClass
.
constRef
(
nonParam
)
;
tmplClassForHasNonParamStruct
<
HasNonParamStruct
>
hasNonParamStructClass
;
HasNonParamStruct
hasNonParamStruct
;
hasNonParamStructClass
.
raw
(
hasNonParamStruct
)
;
hasNonParamStructClass
.
rawDefault
(
)
;
hasNonParamStructClass
.
const_
(
hasNonParamStruct
)
;
hasNonParamStructClass
.
ptr
(
&
hasNonParamStruct
)
;
hasNonParamStructClass
.
ref
(
hasNonParamStruct
)
;
hasNonParamStructClass
.
constRef
(
hasNonParamStruct
)
;
}
template
<
typename
T
>
class
NestedTemplateInner
{
public
:
void
raw
(
T
x
)
{
}
}
;
template
<
typename
T
>
class
nestedTemplateOuter
{
public
:
void
constRef
(
const
T
&
x
)
{
NestedTemplateInner
<
T
>
inner
;
inner
.
raw
(
x
)
;
}
}
;
void
testNestedTemplateClass
(
)
{
nestedTemplateOuter
<
NonParam
>
outer
;
NonParam
nonParam
;
outer
.
constRef
(
nonParam
)
;
}
template
<
typename
T
>
void
tmplFuncForParam
(
T
x
)
{
}
template
<
typename
T
>
void
tmplFuncForNonParam
(
T
x
)
{
}
template
<
typename
T
>
void
tmplFuncForNonParamImplicit
(
T
x
)
{
}
template
<
typename
T
>
void
tmplFuncForHasNonParamStruct
(
T
x
)
{
}
template
<
typename
T
>
void
tmplFuncForHasNonParamStructImplicit
(
T
x
)
{
}
void
testTemplateFunc
(
)
{
Param
param
;
tmplFuncForParam
<
Param
>
(
param
)
;
NonParam
nonParam
;
tmplFuncForNonParam
<
NonParam
>
(
nonParam
)
;
tmplFuncForNonParamImplicit
(
nonParam
)
;
HasNonParamStruct
hasNonParamStruct
;
tmplFuncForHasNonParamStruct
<
HasNonParamStruct
>
(
hasNonParamStruct
)
;
tmplFuncForHasNonParamStructImplicit
(
hasNonParamStruct
)
;
}
void
testLambda
(
)
{
auto
paramLambda
=
[
]
(
Param
x
)
-
>
void
{
}
;
auto
nonParamLambda
=
[
]
(
NonParam
x
)
-
>
void
{
}
;
auto
nonParamStructLambda
=
[
]
(
HasNonParamStruct
x
)
-
>
void
{
}
;
auto
nonParamUnionLambda
=
[
]
(
HasNonParamUnion
x
)
-
>
void
{
}
;
auto
nonParamStructUnionLambda
=
[
]
(
HasNonParamStructUnion
x
)
-
>
void
{
}
;
(
void
)
[
]
(
Param
x
)
-
>
void
{
}
;
(
void
)
[
]
(
NonParam
x
)
-
>
void
{
}
;
(
void
)
[
]
(
HasNonParamStruct
x
)
-
>
void
{
}
;
(
void
)
[
]
(
HasNonParamUnion
x
)
-
>
void
{
}
;
(
void
)
[
]
(
HasNonParamStructUnion
x
)
-
>
void
{
}
;
}
struct
alignas
(
8
)
AlignasStruct
{
char
a
;
}
;
void
takesAlignasStruct
(
AlignasStruct
x
)
{
}
void
takesAlignasStructByRef
(
const
AlignasStruct
&
x
)
{
}
struct
AlignasMember
{
alignas
(
8
)
char
a
;
}
;
void
takesAlignasMember
(
AlignasMember
x
)
{
}
void
takesAlignasMemberByRef
(
const
AlignasMember
&
x
)
{
}
