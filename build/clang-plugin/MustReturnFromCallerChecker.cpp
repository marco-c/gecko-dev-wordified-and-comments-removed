#
include
"
MustReturnFromCallerChecker
.
h
"
#
include
"
CustomMatchers
.
h
"
void
MustReturnFromCallerChecker
:
:
registerMatchers
(
MatchFinder
*
AstMatcher
)
{
AstMatcher
-
>
addMatcher
(
callExpr
(
callee
(
functionDecl
(
isMozMustReturnFromCaller
(
)
)
)
anyOf
(
hasAncestor
(
lambdaExpr
(
)
.
bind
(
"
containing
-
lambda
"
)
)
hasAncestor
(
functionDecl
(
)
.
bind
(
"
containing
-
func
"
)
)
)
)
.
bind
(
"
call
"
)
this
)
;
}
void
MustReturnFromCallerChecker
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
const
auto
*
ContainingLambda
=
Result
.
Nodes
.
getNodeAs
<
LambdaExpr
>
(
"
containing
-
lambda
"
)
;
const
auto
*
ContainingFunc
=
Result
.
Nodes
.
getNodeAs
<
FunctionDecl
>
(
"
containing
-
func
"
)
;
const
auto
*
Call
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
call
"
)
;
Stmt
*
Body
=
nullptr
;
if
(
ContainingLambda
)
{
Body
=
ContainingLambda
-
>
getBody
(
)
;
}
else
if
(
ContainingFunc
)
{
Body
=
ContainingFunc
-
>
getBody
(
)
;
}
else
{
return
;
}
assert
(
Body
&
&
"
Should
have
a
body
by
this
point
"
)
;
CFG
:
:
BuildOptions
Options
;
std
:
:
unique_ptr
<
CFG
>
TheCFG
=
CFG
:
:
buildCFG
(
nullptr
Body
Result
.
Context
Options
)
;
if
(
!
TheCFG
)
{
return
;
}
StmtToBlockMap
BlockMap
(
TheCFG
.
get
(
)
Result
.
Context
)
;
size_t
CallIndex
;
const
auto
*
Block
=
BlockMap
.
blockContainingStmt
(
Call
&
CallIndex
)
;
assert
(
Block
&
&
"
This
statement
should
be
within
the
CFG
!
"
)
;
if
(
!
immediatelyReturns
(
Block
Result
.
Context
CallIndex
+
1
)
)
{
diag
(
Call
-
>
getBeginLoc
(
)
"
You
must
immediately
return
after
calling
this
function
"
DiagnosticIDs
:
:
Error
)
;
}
}
bool
MustReturnFromCallerChecker
:
:
immediatelyReturns
(
RecurseGuard
<
const
CFGBlock
*
>
Block
ASTContext
*
TheContext
size_t
FromIdx
)
{
if
(
Block
.
isRepeat
(
)
)
{
return
false
;
}
for
(
size_t
I
=
FromIdx
;
I
<
Block
-
>
size
(
)
;
+
+
I
)
{
Optional
<
CFGStmt
>
S
=
(
*
Block
)
[
I
]
.
getAs
<
CFGStmt
>
(
)
;
if
(
!
S
)
{
continue
;
}
auto
AfterTrivials
=
IgnoreTrivials
(
S
-
>
getStmt
(
)
)
;
if
(
isa
<
ReturnStmt
>
(
AfterTrivials
)
|
|
isa
<
CXXConstructExpr
>
(
AfterTrivials
)
|
|
isa
<
DeclRefExpr
>
(
AfterTrivials
)
|
|
isa
<
MemberExpr
>
(
AfterTrivials
)
)
{
continue
;
}
if
(
auto
CE
=
dyn_cast
<
CallExpr
>
(
AfterTrivials
)
)
{
auto
Callee
=
CE
-
>
getDirectCallee
(
)
;
if
(
Callee
&
&
hasCustomAttribute
<
moz_may_call_after_must_return
>
(
Callee
)
)
{
continue
;
}
if
(
Callee
&
&
isa
<
CXXConversionDecl
>
(
Callee
)
)
{
continue
;
}
}
return
false
;
}
for
(
auto
Succ
=
Block
-
>
succ_begin
(
)
;
Succ
!
=
Block
-
>
succ_end
(
)
;
+
+
Succ
)
{
if
(
!
immediatelyReturns
(
Block
.
recurse
(
*
Succ
)
TheContext
0
)
)
{
return
false
;
}
}
return
true
;
}
