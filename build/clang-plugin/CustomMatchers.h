#
ifndef
CustomMatchers_h__
#
define
CustomMatchers_h__
#
include
"
MemMoveAnnotation
.
h
"
#
include
"
Utils
.
h
"
namespace
clang
{
namespace
ast_matchers
{
AST_MATCHER
(
FunctionDecl
heapAllocator
)
{
return
hasCustomAttribute
<
moz_heap_allocator
>
(
&
Node
)
;
}
AST_MATCHER
(
Decl
noArithmeticExprInArgs
)
{
return
hasCustomAttribute
<
moz_no_arith_expr_in_arg
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasTrivialCtorDtor
)
{
return
hasCustomAttribute
<
moz_trivial_ctor_dtor
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXConstructExpr
allowsTemporary
)
{
return
hasCustomAttribute
<
moz_allow_temporary
>
(
Node
.
getConstructor
(
)
)
;
}
AST_MATCHER
(
CXXMethodDecl
isLValueRefQualified
)
{
return
Node
.
getRefQualifier
(
)
=
=
RQ_LValue
;
}
AST_MATCHER
(
CXXMethodDecl
isRValueRefQualified
)
{
return
Node
.
getRefQualifier
(
)
=
=
RQ_RValue
;
}
AST_POLYMORPHIC_MATCHER
(
isFirstParty
AST_POLYMORPHIC_SUPPORTED_TYPES
(
Decl
Stmt
)
)
{
return
!
inThirdPartyPath
(
&
Node
&
Finder
-
>
getASTContext
(
)
)
&
&
!
ASTIsInSystemHeader
(
Finder
-
>
getASTContext
(
)
Node
)
;
}
AST_MATCHER
(
Expr
isTemporary
)
{
return
Node
.
isRValue
(
)
|
|
Node
.
isXValue
(
)
|
|
isa
<
MaterializeTemporaryExpr
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXMethodDecl
noDanglingOnTemporaries
)
{
return
hasCustomAttribute
<
moz_no_dangling_on_temporaries
>
(
&
Node
)
;
}
AST_MATCHER
(
FunctionDecl
hasNoAddRefReleaseOnReturnAttr
)
{
return
hasCustomAttribute
<
moz_no_addref_release_on_return
>
(
&
Node
)
;
}
AST_MATCHER
(
FunctionDecl
hasCanRunScriptAnnotation
)
{
return
hasCustomAttribute
<
moz_can_run_script
>
(
&
Node
)
;
}
AST_MATCHER
(
BinaryOperator
binaryArithmeticOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_Mul
|
|
OpCode
=
=
BO_Div
|
|
OpCode
=
=
BO_Rem
|
|
OpCode
=
=
BO_Add
|
|
OpCode
=
=
BO_Sub
|
|
OpCode
=
=
BO_Shl
|
|
OpCode
=
=
BO_Shr
|
|
OpCode
=
=
BO_And
|
|
OpCode
=
=
BO_Xor
|
|
OpCode
=
=
BO_Or
|
|
OpCode
=
=
BO_MulAssign
|
|
OpCode
=
=
BO_DivAssign
|
|
OpCode
=
=
BO_RemAssign
|
|
OpCode
=
=
BO_AddAssign
|
|
OpCode
=
=
BO_SubAssign
|
|
OpCode
=
=
BO_ShlAssign
|
|
OpCode
=
=
BO_ShrAssign
|
|
OpCode
=
=
BO_AndAssign
|
|
OpCode
=
=
BO_XorAssign
|
|
OpCode
=
=
BO_OrAssign
;
}
AST_MATCHER
(
UnaryOperator
unaryArithmeticOperator
)
{
UnaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
UO_PostInc
|
|
OpCode
=
=
UO_PostDec
|
|
OpCode
=
=
UO_PreInc
|
|
OpCode
=
=
UO_PreDec
|
|
OpCode
=
=
UO_Plus
|
|
OpCode
=
=
UO_Minus
|
|
OpCode
=
=
UO_Not
;
}
AST_MATCHER
(
UnaryOperator
unaryDereferenceOperator
)
{
UnaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
UO_Deref
;
}
AST_MATCHER
(
BinaryOperator
binaryEqualityOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_EQ
|
|
OpCode
=
=
BO_NE
;
}
AST_MATCHER
(
BinaryOperator
binaryCommaOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_Comma
;
}
AST_MATCHER
(
QualType
isFloat
)
{
return
Node
-
>
isRealFloatingType
(
)
;
}
AST_POLYMORPHIC_MATCHER
(
isInSystemHeader
\
AST_POLYMORPHIC_SUPPORTED_TYPES
(
Decl
Stmt
)
)
{
return
ASTIsInSystemHeader
(
Finder
-
>
getASTContext
(
)
Node
)
;
}
AST_MATCHER
(
BinaryOperator
isInWhitelistForNaNExpr
)
{
const
char
*
whitelist
[
]
=
{
"
SkScalar
.
h
"
"
json_writer
.
cpp
"
"
State
.
cpp
"
}
;
SourceLocation
Loc
=
Node
.
getOperatorLoc
(
)
;
auto
&
SourceManager
=
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
;
SmallString
<
1024
>
FileName
=
SourceManager
.
getFilename
(
Loc
)
;
for
(
auto
itr
=
std
:
:
begin
(
whitelist
)
;
itr
!
=
std
:
:
end
(
whitelist
)
;
itr
+
+
)
{
if
(
llvm
:
:
sys
:
:
path
:
:
rbegin
(
FileName
)
-
>
equals
(
*
itr
)
)
{
return
true
;
}
}
return
false
;
}
AST_MATCHER
(
MemberExpr
isAddRefOrRelease
)
{
ValueDecl
*
Member
=
Node
.
getMemberDecl
(
)
;
CXXMethodDecl
*
Method
=
dyn_cast
<
CXXMethodDecl
>
(
Member
)
;
if
(
Method
)
{
const
auto
&
Name
=
getNameChecked
(
Method
)
;
return
Name
=
=
"
AddRef
"
|
|
Name
=
=
"
Release
"
;
}
return
false
;
}
AST_MATCHER
(
CXXRecordDecl
hasRefCntMember
)
{
return
isClassRefCounted
(
&
Node
)
&
&
getClassRefCntMember
(
&
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
isRefCounted
)
{
return
isClassRefCounted
(
&
Node
)
;
}
AST_MATCHER
(
QualType
hasVTable
)
{
return
typeHasVTable
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasNeedsNoVTableTypeAttr
)
{
return
hasCustomAttribute
<
moz_needs_no_vtable_type
>
(
&
Node
)
;
}
AST_MATCHER
(
QualType
isNonMemMovable
)
{
return
NonMemMovable
.
hasEffectiveAnnotation
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableTemplateArg
)
{
return
hasCustomAttribute
<
moz_needs_memmovable_type
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableMembers
)
{
return
hasCustomAttribute
<
moz_needs_memmovable_members
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isInterestingImplicitCtor
)
{
const
CXXConstructorDecl
*
Declaration
=
Node
.
getCanonicalDecl
(
)
;
return
!
ASTIsInSystemHeader
(
Declaration
-
>
getASTContext
(
)
*
Declaration
)
&
&
!
isInIgnoredNamespaceForImplicitCtor
(
Declaration
)
&
&
!
inThirdPartyPath
(
Declaration
)
&
&
Declaration
-
>
isConvertingConstructor
(
false
)
&
&
!
Declaration
-
>
isCopyOrMoveConstructor
(
)
&
&
!
Declaration
-
>
isInheritingConstructor
(
)
&
&
!
Declaration
-
>
isDeleted
(
)
;
}
AST_MATCHER_P
(
Expr
ignoreTrivials
internal
:
:
Matcher
<
Expr
>
InnerMatcher
)
{
return
InnerMatcher
.
matches
(
*
IgnoreTrivials
(
&
Node
)
Finder
Builder
)
;
}
AST_MATCHER_P2
(
Expr
ignoreTrivialsConditional
internal
:
:
Matcher
<
Expr
>
Condition
internal
:
:
Matcher
<
Expr
>
InnerMatcher
)
{
const
Expr
*
node
=
&
Node
;
while
(
true
)
{
if
(
Condition
.
matches
(
*
node
Finder
Builder
)
)
{
return
InnerMatcher
.
matches
(
*
IgnoreTrivials
(
node
)
Finder
Builder
)
;
}
const
Expr
*
newNode
=
MaybeSkipOneTrivial
(
node
)
;
if
(
newNode
=
=
node
)
{
return
false
;
}
node
=
newNode
;
}
}
AST_MATCHER
(
CXXConstructorDecl
isMarkedImplicit
)
{
return
hasCustomAttribute
<
moz_implicit
>
(
&
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
isConcreteClass
)
{
return
!
Node
.
isAbstract
(
)
;
}
AST_MATCHER
(
QualType
autoNonAutoableType
)
{
if
(
const
AutoType
*
T
=
Node
-
>
getContainedAutoType
(
)
)
{
if
(
const
CXXRecordDecl
*
Rec
=
T
-
>
getAsCXXRecordDecl
(
)
)
{
return
hasCustomAttribute
<
moz_non_autoable
>
(
Rec
)
;
}
}
return
false
;
}
AST_MATCHER
(
CXXConstructorDecl
isExplicitMoveConstructor
)
{
return
Node
.
isExplicit
(
)
&
&
Node
.
isMoveConstructor
(
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isCompilerProvidedCopyConstructor
)
{
return
!
Node
.
isUserProvided
(
)
&
&
Node
.
isCopyConstructor
(
)
;
}
AST_MATCHER
(
CallExpr
isAssertAssignmentTestFunc
)
{
static
const
std
:
:
string
AssertName
=
"
MOZ_AssertAssignmentTest
"
;
const
FunctionDecl
*
Method
=
Node
.
getDirectCallee
(
)
;
return
Method
&
&
Method
-
>
getDeclName
(
)
.
isIdentifier
(
)
&
&
Method
-
>
getName
(
)
=
=
AssertName
;
}
AST_MATCHER
(
CallExpr
isSnprintfLikeFunc
)
{
static
const
std
:
:
string
Snprintf
=
"
snprintf
"
;
static
const
std
:
:
string
Vsnprintf
=
"
vsnprintf
"
;
const
FunctionDecl
*
Func
=
Node
.
getDirectCallee
(
)
;
if
(
!
Func
|
|
isa
<
CXXMethodDecl
>
(
Func
)
)
{
return
false
;
}
StringRef
Name
=
getNameChecked
(
Func
)
;
if
(
Name
!
=
Snprintf
&
&
Name
!
=
Vsnprintf
)
{
return
false
;
}
return
!
inThirdPartyPath
(
Node
.
getBeginLoc
(
)
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
)
&
&
!
isIgnoredPathForSprintfLiteral
(
&
Node
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
)
;
}
AST_MATCHER
(
CXXRecordDecl
isLambdaDecl
)
{
return
Node
.
isLambda
(
)
;
}
AST_MATCHER
(
QualType
isRefPtr
)
{
return
typeIsRefPtr
(
Node
)
;
}
AST_MATCHER
(
QualType
isSmartPtrToRefCounted
)
{
auto
*
D
=
getNonTemplateSpecializedCXXRecordDecl
(
Node
)
;
if
(
!
D
)
{
return
false
;
}
D
=
D
-
>
getCanonicalDecl
(
)
;
return
D
&
&
hasCustomAttribute
<
moz_is_smartptr_to_refcounted
>
(
D
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasBaseClasses
)
{
const
CXXRecordDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
Decl
-
>
hasDefinition
(
)
&
&
Decl
-
>
getNumBases
(
)
;
}
AST_MATCHER
(
CXXMethodDecl
isRequiredBaseMethod
)
{
const
CXXMethodDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
hasCustomAttribute
<
moz_required_base_method
>
(
Decl
)
;
}
AST_MATCHER
(
CXXMethodDecl
isNonVirtual
)
{
const
CXXMethodDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
!
Decl
-
>
isVirtual
(
)
;
}
AST_MATCHER
(
FunctionDecl
isMozMustReturnFromCaller
)
{
const
FunctionDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
hasCustomAttribute
<
moz_must_return_from_caller
>
(
Decl
)
;
}
AST_MATCHER
(
CXXDefaultArgExpr
isNullDefaultArg
)
{
const
Expr
*
Expr
=
Node
.
getExpr
(
)
;
return
Expr
&
&
Expr
-
>
isNullPointerConstant
(
Finder
-
>
getASTContext
(
)
Expr
:
:
NPC_NeverValueDependent
)
;
}
#
if
CLANG_VERSION_FULL
<
309
AST_MATCHER_P
(
Stmt
forFunction
internal
:
:
Matcher
<
FunctionDecl
>
InnerMatcher
)
{
const
auto
&
Parents
=
Finder
-
>
getASTContext
(
)
.
getParents
(
Node
)
;
llvm
:
:
SmallVector
<
ast_type_traits
:
:
DynTypedNode
8
>
Stack
(
Parents
.
begin
(
)
Parents
.
end
(
)
)
;
while
(
!
Stack
.
empty
(
)
)
{
const
auto
&
CurNode
=
Stack
.
back
(
)
;
Stack
.
pop_back
(
)
;
if
(
const
auto
*
FuncDeclNode
=
CurNode
.
get
<
FunctionDecl
>
(
)
)
{
if
(
InnerMatcher
.
matches
(
*
FuncDeclNode
Finder
Builder
)
)
{
return
true
;
}
}
else
if
(
const
auto
*
LambdaExprNode
=
CurNode
.
get
<
LambdaExpr
>
(
)
)
{
if
(
InnerMatcher
.
matches
(
*
LambdaExprNode
-
>
getCallOperator
(
)
Finder
Builder
)
)
{
return
true
;
}
}
else
{
for
(
const
auto
&
Parent
:
Finder
-
>
getASTContext
(
)
.
getParents
(
CurNode
)
)
Stack
.
push_back
(
Parent
)
;
}
}
return
false
;
}
#
endif
}
}
#
endif
