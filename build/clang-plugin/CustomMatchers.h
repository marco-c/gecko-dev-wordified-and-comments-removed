#
ifndef
CustomMatchers_h__
#
define
CustomMatchers_h__
#
include
"
MozChecker
.
h
"
#
include
"
MemMoveAnnotation
.
h
"
#
include
"
Utils
.
h
"
namespace
clang
{
namespace
ast_matchers
{
AST_MATCHER
(
FunctionDecl
heapAllocator
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_heap_allocator
"
)
;
}
AST_MATCHER
(
Decl
noArithmeticExprInArgs
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_no_arith_expr_in_arg
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasTrivialCtorDtor
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_trivial_ctor_dtor
"
)
;
}
AST_MATCHER
(
FunctionDecl
hasNoAddRefReleaseOnReturnAttr
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_no_addref_release_on_return
"
)
;
}
AST_MATCHER
(
BinaryOperator
binaryArithmeticOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_Mul
|
|
OpCode
=
=
BO_Div
|
|
OpCode
=
=
BO_Rem
|
|
OpCode
=
=
BO_Add
|
|
OpCode
=
=
BO_Sub
|
|
OpCode
=
=
BO_Shl
|
|
OpCode
=
=
BO_Shr
|
|
OpCode
=
=
BO_And
|
|
OpCode
=
=
BO_Xor
|
|
OpCode
=
=
BO_Or
|
|
OpCode
=
=
BO_MulAssign
|
|
OpCode
=
=
BO_DivAssign
|
|
OpCode
=
=
BO_RemAssign
|
|
OpCode
=
=
BO_AddAssign
|
|
OpCode
=
=
BO_SubAssign
|
|
OpCode
=
=
BO_ShlAssign
|
|
OpCode
=
=
BO_ShrAssign
|
|
OpCode
=
=
BO_AndAssign
|
|
OpCode
=
=
BO_XorAssign
|
|
OpCode
=
=
BO_OrAssign
;
}
AST_MATCHER
(
UnaryOperator
unaryArithmeticOperator
)
{
UnaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
UO_PostInc
|
|
OpCode
=
=
UO_PostDec
|
|
OpCode
=
=
UO_PreInc
|
|
OpCode
=
=
UO_PreDec
|
|
OpCode
=
=
UO_Plus
|
|
OpCode
=
=
UO_Minus
|
|
OpCode
=
=
UO_Not
;
}
AST_MATCHER
(
BinaryOperator
binaryEqualityOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_EQ
|
|
OpCode
=
=
BO_NE
;
}
AST_MATCHER
(
QualType
isFloat
)
{
return
Node
-
>
isRealFloatingType
(
)
;
}
AST_MATCHER
(
BinaryOperator
isInSystemHeader
)
{
return
ASTIsInSystemHeader
(
Finder
-
>
getASTContext
(
)
Node
)
;
}
AST_MATCHER
(
BinaryOperator
isInWhitelistForNaNExpr
)
{
const
char
*
whitelist
[
]
=
{
"
SkScalar
.
h
"
"
json_writer
.
cpp
"
"
State
.
cpp
"
}
;
SourceLocation
Loc
=
Node
.
getOperatorLoc
(
)
;
auto
&
SourceManager
=
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
;
SmallString
<
1024
>
FileName
=
SourceManager
.
getFilename
(
Loc
)
;
for
(
auto
itr
=
std
:
:
begin
(
whitelist
)
;
itr
!
=
std
:
:
end
(
whitelist
)
;
itr
+
+
)
{
if
(
llvm
:
:
sys
:
:
path
:
:
rbegin
(
FileName
)
-
>
equals
(
*
itr
)
)
{
return
true
;
}
}
return
false
;
}
AST_MATCHER
(
MemberExpr
isAddRefOrRelease
)
{
ValueDecl
*
Member
=
Node
.
getMemberDecl
(
)
;
CXXMethodDecl
*
Method
=
dyn_cast
<
CXXMethodDecl
>
(
Member
)
;
if
(
Method
)
{
const
auto
&
Name
=
getNameChecked
(
Method
)
;
return
Name
=
=
"
AddRef
"
|
|
Name
=
=
"
Release
"
;
}
return
false
;
}
AST_MATCHER
(
CXXRecordDecl
hasRefCntMember
)
{
return
isClassRefCounted
(
&
Node
)
&
&
getClassRefCntMember
(
&
Node
)
;
}
AST_MATCHER
(
QualType
hasVTable
)
{
return
typeHasVTable
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasNeedsNoVTableTypeAttr
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_no_vtable_type
"
)
;
}
AST_MATCHER
(
QualType
isNonMemMovable
)
{
return
NonMemMovable
.
hasEffectiveAnnotation
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableTemplateArg
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_memmovable_type
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableMembers
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_memmovable_members
"
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isInterestingImplicitCtor
)
{
const
CXXConstructorDecl
*
Declaration
=
Node
.
getCanonicalDecl
(
)
;
return
!
ASTIsInSystemHeader
(
Declaration
-
>
getASTContext
(
)
*
Declaration
)
&
&
!
isInIgnoredNamespaceForImplicitCtor
(
Declaration
)
&
&
!
isIgnoredPathForImplicitCtor
(
Declaration
)
&
&
Declaration
-
>
isConvertingConstructor
(
false
)
&
&
!
Declaration
-
>
isCopyOrMoveConstructor
(
)
&
&
!
Declaration
-
>
isDeleted
(
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isMarkedImplicit
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_implicit
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
isConcreteClass
)
{
return
!
Node
.
isAbstract
(
)
;
}
AST_MATCHER
(
QualType
autoNonAutoableType
)
{
if
(
const
AutoType
*
T
=
Node
-
>
getContainedAutoType
(
)
)
{
if
(
const
CXXRecordDecl
*
Rec
=
T
-
>
getAsCXXRecordDecl
(
)
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
Rec
"
moz_non_autoable
"
)
;
}
}
return
false
;
}
AST_MATCHER
(
CXXConstructorDecl
isExplicitMoveConstructor
)
{
return
Node
.
isExplicit
(
)
&
&
Node
.
isMoveConstructor
(
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isCompilerProvidedCopyConstructor
)
{
return
!
Node
.
isUserProvided
(
)
&
&
Node
.
isCopyConstructor
(
)
;
}
AST_MATCHER
(
CallExpr
isAssertAssignmentTestFunc
)
{
static
const
std
:
:
string
AssertName
=
"
MOZ_AssertAssignmentTest
"
;
const
FunctionDecl
*
Method
=
Node
.
getDirectCallee
(
)
;
return
Method
&
&
Method
-
>
getDeclName
(
)
.
isIdentifier
(
)
&
&
Method
-
>
getName
(
)
=
=
AssertName
;
}
AST_MATCHER
(
CallExpr
isSnprintfLikeFunc
)
{
static
const
std
:
:
string
Snprintf
=
"
snprintf
"
;
static
const
std
:
:
string
Vsnprintf
=
"
vsnprintf
"
;
const
FunctionDecl
*
Func
=
Node
.
getDirectCallee
(
)
;
if
(
!
Func
|
|
isa
<
CXXMethodDecl
>
(
Func
)
)
{
return
false
;
}
StringRef
Name
=
getNameChecked
(
Func
)
;
if
(
Name
!
=
Snprintf
&
&
Name
!
=
Vsnprintf
)
{
return
false
;
}
return
!
isIgnoredPathForSprintfLiteral
(
&
Node
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
)
;
}
AST_MATCHER
(
CXXRecordDecl
isLambdaDecl
)
{
return
Node
.
isLambda
(
)
;
}
AST_MATCHER
(
QualType
isRefPtr
)
{
return
typeIsRefPtr
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasBaseClasses
)
{
const
CXXRecordDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
Decl
-
>
hasDefinition
(
)
&
&
Decl
-
>
getNumBases
(
)
;
}
AST_MATCHER
(
CXXMethodDecl
isRequiredBaseMethod
)
{
const
CXXMethodDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
MozChecker
:
:
hasCustomAnnotation
(
Decl
"
moz_required_base_method
"
)
;
}
AST_MATCHER
(
CXXMethodDecl
isNonVirtual
)
{
const
CXXMethodDecl
*
Decl
=
Node
.
getCanonicalDecl
(
)
;
return
Decl
&
&
!
Decl
-
>
isVirtual
(
)
;
}
}
}
#
endif
