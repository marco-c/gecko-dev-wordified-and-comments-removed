#
ifndef
MemMoveAnnotation_h__
#
define
MemMoveAnnotation_h__
#
include
"
CustomMatchers
.
h
"
#
include
"
CustomTypeAnnotation
.
h
"
#
include
"
Utils
.
h
"
#
include
<
unordered_set
>
class
MemMoveAnnotation
final
:
public
CustomTypeAnnotation
{
public
:
MemMoveAnnotation
(
)
:
CustomTypeAnnotation
(
moz_non_memmovable
"
non
-
memmove
(
)
able
"
)
{
}
virtual
~
MemMoveAnnotation
(
)
{
}
protected
:
static
bool
is_trivially_relocatable
(
const
TagDecl
*
D
)
{
if
(
auto
RD
=
dyn_cast
<
CXXRecordDecl
>
(
D
)
)
{
if
(
RD
-
>
isCompleteDefinition
(
)
&
&
(
RD
-
>
hasTrivialMoveConstructor
(
)
|
|
(
!
RD
-
>
hasMoveConstructor
(
)
&
&
RD
-
>
hasTrivialCopyConstructor
(
)
)
)
&
&
RD
-
>
hasTrivialDestructor
(
)
)
{
return
true
;
}
if
(
auto
*
Spec
=
dyn_cast
<
ClassTemplateSpecializationDecl
>
(
RD
)
)
{
if
(
getDeclarationNamespace
(
D
)
=
=
"
std
"
&
&
(
getNameChecked
(
D
)
=
=
"
unique_ptr
"
)
)
{
unsigned
ParameterIndex
=
0
;
const
auto
&
TArgs
=
Spec
-
>
getTemplateArgs
(
)
;
if
(
TArgs
.
size
(
)
!
=
2
)
{
return
false
;
}
const
auto
&
Deleter
=
TArgs
[
1
]
;
if
(
Deleter
.
getKind
(
)
!
=
TemplateArgument
:
:
Type
)
return
false
;
QualType
DeleterTy
=
Deleter
.
getAsType
(
)
;
if
(
const
auto
*
TD
=
DeleterTy
-
>
getAsTagDecl
(
)
)
{
return
is_trivially_relocatable
(
TD
)
;
}
else
{
return
false
;
}
}
}
}
return
false
;
}
std
:
:
string
getImplicitReason
(
const
TagDecl
*
D
VisitFlags
&
ToVisit
)
const
override
{
if
(
getDeclarationNamespace
(
D
)
!
=
"
std
"
)
{
return
"
"
;
}
StringRef
Name
=
getNameChecked
(
D
)
;
if
(
is_trivially_relocatable
(
D
)
)
{
ToVisit
=
VISIT_NONE
;
return
"
"
;
}
if
(
isNameExcepted
(
Name
.
data
(
)
)
)
{
ToVisit
=
VISIT_TMPL_ARGS
;
return
"
"
;
}
return
"
it
is
an
stl
-
provided
type
not
guaranteed
to
be
memmove
-
able
"
;
}
private
:
bool
isNameExcepted
(
StringRef
Name
)
const
{
return
Name
=
=
"
pair
"
|
|
Name
=
=
"
atomic
"
|
|
Name
=
=
"
tuple
"
;
}
}
;
extern
MemMoveAnnotation
NonMemMovable
;
#
endif
