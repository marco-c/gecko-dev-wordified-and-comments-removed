#
ifndef
MemMoveAnnotation_h__
#
define
MemMoveAnnotation_h__
#
include
"
CustomMatchers
.
h
"
#
include
"
CustomTypeAnnotation
.
h
"
#
include
"
Utils
.
h
"
#
include
<
unordered_set
>
class
MemMoveAnnotation
final
:
public
CustomTypeAnnotation
{
public
:
MemMoveAnnotation
(
)
:
CustomTypeAnnotation
(
moz_non_memmovable
"
non
-
memmove
(
)
able
"
)
{
}
virtual
~
MemMoveAnnotation
(
)
{
}
protected
:
std
:
:
string
getImplicitReason
(
const
TagDecl
*
D
VisitFlags
&
ToVisit
)
const
override
{
if
(
getDeclarationNamespace
(
D
)
!
=
"
std
"
)
{
return
"
"
;
}
StringRef
Name
=
getNameChecked
(
D
)
;
auto
RD
=
dyn_cast
<
CXXRecordDecl
>
(
D
)
;
if
(
RD
&
&
RD
-
>
isCompleteDefinition
(
)
&
&
(
RD
-
>
hasTrivialMoveConstructor
(
)
|
|
(
!
RD
-
>
hasMoveConstructor
(
)
&
&
RD
-
>
hasTrivialCopyConstructor
(
)
)
)
&
&
RD
-
>
hasTrivialDestructor
(
)
)
{
ToVisit
=
VISIT_NONE
;
return
"
"
;
}
if
(
isNameExcepted
(
Name
.
data
(
)
)
)
{
ToVisit
=
VISIT_TMPL_ARGS
;
return
"
"
;
}
return
"
it
is
an
stl
-
provided
type
not
guaranteed
to
be
memmove
-
able
"
;
}
private
:
bool
isNameExcepted
(
StringRef
Name
)
const
{
return
Name
=
=
"
pair
"
|
|
Name
=
=
"
atomic
"
|
|
Name
=
=
"
tuple
"
;
}
}
;
extern
MemMoveAnnotation
NonMemMovable
;
#
endif
