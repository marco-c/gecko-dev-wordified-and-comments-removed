#
include
"
RefCountedInsideLambdaChecker
.
h
"
#
include
"
CustomMatchers
.
h
"
RefCountedMap
RefCountedClasses
;
void
RefCountedInsideLambdaChecker
:
:
registerMatchers
(
MatchFinder
*
AstMatcher
)
{
AstMatcher
-
>
addMatcher
(
functionDecl
(
returns
(
recordType
(
hasDeclaration
(
cxxRecordDecl
(
isLambdaDecl
(
)
)
.
bind
(
"
decl
"
)
)
)
)
)
this
)
;
AstMatcher
-
>
addMatcher
(
lambdaExpr
(
)
.
bind
(
"
lambdaExpr
"
)
this
)
;
AstMatcher
-
>
addMatcher
(
classTemplateSpecializationDecl
(
hasAnyTemplateArgument
(
refersToType
(
recordType
(
hasDeclaration
(
cxxRecordDecl
(
isLambdaDecl
(
)
)
.
bind
(
"
decl
"
)
)
)
)
)
)
this
)
;
}
void
RefCountedInsideLambdaChecker
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
static
DenseSet
<
const
CXXRecordDecl
*
>
CheckedDecls
;
const
char
*
Error
=
"
Refcounted
variable
%
0
of
type
%
1
cannot
be
captured
by
a
lambda
"
;
const
char
*
Note
=
"
Please
consider
using
a
smart
pointer
"
;
const
CXXRecordDecl
*
Lambda
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
decl
"
)
;
if
(
const
LambdaExpr
*
OuterLambda
=
Result
.
Nodes
.
getNodeAs
<
LambdaExpr
>
(
"
lambdaExpr
"
)
)
{
const
CXXMethodDecl
*
OpCall
=
OuterLambda
-
>
getCallOperator
(
)
;
QualType
ReturnTy
=
OpCall
-
>
getReturnType
(
)
;
if
(
const
CXXRecordDecl
*
Record
=
ReturnTy
-
>
getAsCXXRecordDecl
(
)
)
{
Lambda
=
Record
;
}
}
if
(
!
Lambda
|
|
!
Lambda
-
>
isLambda
(
)
)
{
return
;
}
if
(
CheckedDecls
.
count
(
Lambda
)
)
{
return
;
}
CheckedDecls
.
insert
(
Lambda
)
;
for
(
const
LambdaCapture
Capture
:
Lambda
-
>
captures
(
)
)
{
if
(
Capture
.
capturesVariable
(
)
&
&
Capture
.
getCaptureKind
(
)
!
=
LCK_ByRef
)
{
QualType
Pointee
=
Capture
.
getCapturedVar
(
)
-
>
getType
(
)
-
>
getPointeeType
(
)
;
if
(
!
Pointee
.
isNull
(
)
&
&
isClassRefCounted
(
Pointee
)
)
{
diag
(
Capture
.
getLocation
(
)
Error
DiagnosticIDs
:
:
Error
)
<
<
Capture
.
getCapturedVar
(
)
<
<
Pointee
;
diag
(
Capture
.
getLocation
(
)
Note
DiagnosticIDs
:
:
Note
)
;
return
;
}
}
}
}
