#
include
"
clang
/
AST
/
ASTConsumer
.
h
"
#
include
"
clang
/
AST
/
ASTContext
.
h
"
#
include
"
clang
/
AST
/
RecursiveASTVisitor
.
h
"
#
include
"
clang
/
ASTMatchers
/
ASTMatchFinder
.
h
"
#
include
"
clang
/
ASTMatchers
/
ASTMatchers
.
h
"
#
include
"
clang
/
Basic
/
Version
.
h
"
#
include
"
clang
/
Frontend
/
CompilerInstance
.
h
"
#
include
"
clang
/
Frontend
/
FrontendPluginRegistry
.
h
"
#
include
"
clang
/
Frontend
/
MultiplexConsumer
.
h
"
#
include
"
clang
/
Sema
/
Sema
.
h
"
#
include
"
llvm
/
ADT
/
DenseMap
.
h
"
#
include
"
llvm
/
Support
/
FileSystem
.
h
"
#
include
"
llvm
/
Support
/
Path
.
h
"
#
include
<
memory
>
#
include
<
iterator
>
#
define
CLANG_VERSION_FULL
(
CLANG_VERSION_MAJOR
*
100
+
CLANG_VERSION_MINOR
)
using
namespace
llvm
;
using
namespace
clang
;
#
if
CLANG_VERSION_FULL
>
=
306
typedef
std
:
:
unique_ptr
<
ASTConsumer
>
ASTConsumerPtr
;
#
else
typedef
ASTConsumer
*
ASTConsumerPtr
;
#
endif
#
ifndef
HAVE_NEW_ASTMATCHER_NAMES
#
define
cxxConstructExpr
constructExpr
#
define
cxxConstructorDecl
constructorDecl
#
define
cxxMethodDecl
methodDecl
#
define
cxxNewExpr
newExpr
#
define
cxxRecordDecl
recordDecl
#
endif
bool
hasSideEffectAssignment
(
const
Expr
*
Expression
)
{
if
(
auto
OpCallExpr
=
dyn_cast_or_null
<
CXXOperatorCallExpr
>
(
Expression
)
)
{
auto
BinOp
=
OpCallExpr
-
>
getOperator
(
)
;
if
(
BinOp
=
=
OO_Equal
|
|
(
BinOp
>
=
OO_PlusEqual
&
&
BinOp
<
=
OO_PipeEqual
)
)
{
return
true
;
}
}
else
if
(
auto
BinOpExpr
=
dyn_cast_or_null
<
BinaryOperator
>
(
Expression
)
)
{
if
(
BinOpExpr
-
>
isAssignmentOp
(
)
)
{
return
true
;
}
}
for
(
const
Stmt
*
SubStmt
:
Expression
-
>
children
(
)
)
{
auto
ChildExpr
=
dyn_cast_or_null
<
Expr
>
(
SubStmt
)
;
if
(
ChildExpr
&
&
hasSideEffectAssignment
(
ChildExpr
)
)
{
return
true
;
}
}
return
false
;
}
namespace
{
using
namespace
clang
:
:
ast_matchers
;
class
DiagnosticsMatcher
{
public
:
DiagnosticsMatcher
(
)
;
ASTConsumerPtr
makeASTConsumer
(
)
{
return
AstMatcher
.
newASTConsumer
(
)
;
}
private
:
class
ScopeChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
ArithmeticArgChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
TrivialCtorDtorChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NaNExprChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NoAddRefReleaseOnReturnChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
RefCountedInsideLambdaChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
ExplicitOperatorBoolChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NoDuplicateRefCntMemberChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NeedsNoVTableTypeChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NonMemMovableTemplateArgChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NonMemMovableMemberChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
ExplicitImplicitChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NoAutoTypeChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
NoExplicitMoveConstructorChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
RefCountedCopyConstructorChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
AssertAssignmentChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
class
KungFuDeathGripChecker
:
public
MatchFinder
:
:
MatchCallback
{
public
:
virtual
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
;
}
;
ScopeChecker
Scope
;
ArithmeticArgChecker
ArithmeticArg
;
TrivialCtorDtorChecker
TrivialCtorDtor
;
NaNExprChecker
NaNExpr
;
NoAddRefReleaseOnReturnChecker
NoAddRefReleaseOnReturn
;
RefCountedInsideLambdaChecker
RefCountedInsideLambda
;
ExplicitOperatorBoolChecker
ExplicitOperatorBool
;
NoDuplicateRefCntMemberChecker
NoDuplicateRefCntMember
;
NeedsNoVTableTypeChecker
NeedsNoVTableType
;
NonMemMovableTemplateArgChecker
NonMemMovableTemplateArg
;
NonMemMovableMemberChecker
NonMemMovableMember
;
ExplicitImplicitChecker
ExplicitImplicit
;
NoAutoTypeChecker
NoAutoType
;
NoExplicitMoveConstructorChecker
NoExplicitMoveConstructor
;
RefCountedCopyConstructorChecker
RefCountedCopyConstructor
;
AssertAssignmentChecker
AssertAttribution
;
KungFuDeathGripChecker
KungFuDeathGrip
;
MatchFinder
AstMatcher
;
}
;
namespace
{
std
:
:
string
getDeclarationNamespace
(
const
Decl
*
Declaration
)
{
const
DeclContext
*
DC
=
Declaration
-
>
getDeclContext
(
)
-
>
getEnclosingNamespaceContext
(
)
;
const
NamespaceDecl
*
ND
=
dyn_cast
<
NamespaceDecl
>
(
DC
)
;
if
(
!
ND
)
{
return
"
"
;
}
while
(
const
DeclContext
*
ParentDC
=
ND
-
>
getParent
(
)
)
{
if
(
!
isa
<
NamespaceDecl
>
(
ParentDC
)
)
{
break
;
}
ND
=
cast
<
NamespaceDecl
>
(
ParentDC
)
;
}
const
auto
&
Name
=
ND
-
>
getName
(
)
;
return
Name
;
}
bool
isInIgnoredNamespaceForImplicitCtor
(
const
Decl
*
Declaration
)
{
std
:
:
string
Name
=
getDeclarationNamespace
(
Declaration
)
;
if
(
Name
=
=
"
"
)
{
return
false
;
}
return
Name
=
=
"
std
"
|
|
Name
=
=
"
__gnu_cxx
"
|
|
Name
=
=
"
boost
"
|
|
Name
=
=
"
webrtc
"
|
|
Name
=
=
"
rtc
"
|
|
Name
.
substr
(
0
4
)
=
=
"
icu_
"
|
|
Name
=
=
"
google
"
|
|
Name
=
=
"
google_breakpad
"
|
|
Name
=
=
"
soundtouch
"
|
|
Name
=
=
"
stagefright
"
|
|
Name
=
=
"
MacFileUtilities
"
|
|
Name
=
=
"
dwarf2reader
"
|
|
Name
=
=
"
arm_ex_to_module
"
|
|
Name
=
=
"
testing
"
|
|
Name
=
=
"
Json
"
;
}
bool
isInIgnoredNamespaceForImplicitConversion
(
const
Decl
*
Declaration
)
{
std
:
:
string
Name
=
getDeclarationNamespace
(
Declaration
)
;
if
(
Name
=
=
"
"
)
{
return
false
;
}
return
Name
=
=
"
std
"
|
|
Name
=
=
"
__gnu_cxx
"
|
|
Name
=
=
"
google_breakpad
"
|
|
Name
=
=
"
testing
"
;
}
bool
isIgnoredPathForImplicitCtor
(
const
Decl
*
Declaration
)
{
SourceLocation
Loc
=
Declaration
-
>
getLocation
(
)
;
const
SourceManager
&
SM
=
Declaration
-
>
getASTContext
(
)
.
getSourceManager
(
)
;
SmallString
<
1024
>
FileName
=
SM
.
getFilename
(
Loc
)
;
llvm
:
:
sys
:
:
fs
:
:
make_absolute
(
FileName
)
;
llvm
:
:
sys
:
:
path
:
:
reverse_iterator
Begin
=
llvm
:
:
sys
:
:
path
:
:
rbegin
(
FileName
)
End
=
llvm
:
:
sys
:
:
path
:
:
rend
(
FileName
)
;
for
(
;
Begin
!
=
End
;
+
+
Begin
)
{
if
(
Begin
-
>
compare_lower
(
StringRef
(
"
skia
"
)
)
=
=
0
|
|
Begin
-
>
compare_lower
(
StringRef
(
"
angle
"
)
)
=
=
0
|
|
Begin
-
>
compare_lower
(
StringRef
(
"
harfbuzz
"
)
)
=
=
0
|
|
Begin
-
>
compare_lower
(
StringRef
(
"
hunspell
"
)
)
=
=
0
|
|
Begin
-
>
compare_lower
(
StringRef
(
"
scoped_ptr
.
h
"
)
)
=
=
0
|
|
Begin
-
>
compare_lower
(
StringRef
(
"
graphite2
"
)
)
=
=
0
)
{
return
true
;
}
if
(
Begin
-
>
compare_lower
(
StringRef
(
"
chromium
"
)
)
=
=
0
)
{
+
+
Begin
;
return
Begin
!
=
End
&
&
Begin
-
>
compare_lower
(
StringRef
(
"
sandbox
"
)
)
=
=
0
;
}
}
return
false
;
}
bool
isIgnoredPathForImplicitConversion
(
const
Decl
*
Declaration
)
{
Declaration
=
Declaration
-
>
getCanonicalDecl
(
)
;
SourceLocation
Loc
=
Declaration
-
>
getLocation
(
)
;
const
SourceManager
&
SM
=
Declaration
-
>
getASTContext
(
)
.
getSourceManager
(
)
;
SmallString
<
1024
>
FileName
=
SM
.
getFilename
(
Loc
)
;
llvm
:
:
sys
:
:
fs
:
:
make_absolute
(
FileName
)
;
llvm
:
:
sys
:
:
path
:
:
reverse_iterator
Begin
=
llvm
:
:
sys
:
:
path
:
:
rbegin
(
FileName
)
End
=
llvm
:
:
sys
:
:
path
:
:
rend
(
FileName
)
;
for
(
;
Begin
!
=
End
;
+
+
Begin
)
{
if
(
Begin
-
>
compare_lower
(
StringRef
(
"
graphite2
"
)
)
=
=
0
)
{
return
true
;
}
if
(
Begin
-
>
compare_lower
(
StringRef
(
"
chromium
"
)
)
=
=
0
)
{
+
+
Begin
;
return
Begin
!
=
End
&
&
Begin
-
>
compare_lower
(
StringRef
(
"
sandbox
"
)
)
=
=
0
;
}
}
return
false
;
}
bool
isInterestingDeclForImplicitConversion
(
const
Decl
*
Declaration
)
{
return
!
isInIgnoredNamespaceForImplicitConversion
(
Declaration
)
&
&
!
isIgnoredPathForImplicitConversion
(
Declaration
)
;
}
bool
isIgnoredExprForMustUse
(
const
Expr
*
E
)
{
if
(
const
CXXOperatorCallExpr
*
OpCall
=
dyn_cast
<
CXXOperatorCallExpr
>
(
E
)
)
{
switch
(
OpCall
-
>
getOperator
(
)
)
{
case
OO_Equal
:
case
OO_PlusEqual
:
case
OO_MinusEqual
:
case
OO_StarEqual
:
case
OO_SlashEqual
:
case
OO_PercentEqual
:
case
OO_CaretEqual
:
case
OO_AmpEqual
:
case
OO_PipeEqual
:
case
OO_LessLessEqual
:
case
OO_GreaterGreaterEqual
:
return
true
;
default
:
return
false
;
}
}
if
(
const
BinaryOperator
*
Op
=
dyn_cast
<
BinaryOperator
>
(
E
)
)
{
return
Op
-
>
isAssignmentOp
(
)
;
}
return
false
;
}
template
<
typename
T
>
StringRef
getNameChecked
(
const
T
&
D
)
{
return
D
-
>
getIdentifier
(
)
?
D
-
>
getName
(
)
:
"
"
;
}
bool
typeIsRefPtr
(
QualType
Q
)
{
CXXRecordDecl
*
D
=
Q
-
>
getAsCXXRecordDecl
(
)
;
if
(
!
D
|
|
!
D
-
>
getIdentifier
(
)
)
{
return
false
;
}
StringRef
name
=
D
-
>
getName
(
)
;
if
(
name
=
=
"
RefPtr
"
|
|
name
=
=
"
nsCOMPtr
"
)
{
return
true
;
}
return
false
;
}
const
Stmt
*
IgnoreImplicit
(
const
Stmt
*
s
)
{
while
(
true
)
{
if
(
auto
*
ewc
=
dyn_cast
<
ExprWithCleanups
>
(
s
)
)
{
s
=
ewc
-
>
getSubExpr
(
)
;
}
else
if
(
auto
*
mte
=
dyn_cast
<
MaterializeTemporaryExpr
>
(
s
)
)
{
s
=
mte
-
>
GetTemporaryExpr
(
)
;
}
else
if
(
auto
*
bte
=
dyn_cast
<
CXXBindTemporaryExpr
>
(
s
)
)
{
s
=
bte
-
>
getSubExpr
(
)
;
}
else
if
(
auto
*
ice
=
dyn_cast
<
ImplicitCastExpr
>
(
s
)
)
{
s
=
ice
-
>
getSubExpr
(
)
;
}
else
{
break
;
}
}
return
s
;
}
const
Expr
*
IgnoreImplicit
(
const
Expr
*
e
)
{
return
cast
<
Expr
>
(
IgnoreImplicit
(
static_cast
<
const
Stmt
*
>
(
e
)
)
)
;
}
}
class
CustomTypeAnnotation
{
enum
ReasonKind
{
RK_None
RK_Direct
RK_ArrayElement
RK_BaseClass
RK_Field
RK_TemplateInherited
}
;
struct
AnnotationReason
{
QualType
Type
;
ReasonKind
Kind
;
const
FieldDecl
*
Field
;
bool
valid
(
)
const
{
return
Kind
!
=
RK_None
;
}
}
;
typedef
DenseMap
<
void
*
AnnotationReason
>
ReasonCache
;
const
char
*
Spelling
;
const
char
*
Pretty
;
ReasonCache
Cache
;
public
:
CustomTypeAnnotation
(
const
char
*
Spelling
const
char
*
Pretty
)
:
Spelling
(
Spelling
)
Pretty
(
Pretty
)
{
}
;
virtual
~
CustomTypeAnnotation
(
)
{
}
bool
hasEffectiveAnnotation
(
QualType
T
)
{
return
directAnnotationReason
(
T
)
.
valid
(
)
;
}
void
dumpAnnotationReason
(
DiagnosticsEngine
&
Diag
QualType
T
SourceLocation
Loc
)
;
void
reportErrorIfPresent
(
DiagnosticsEngine
&
Diag
QualType
T
SourceLocation
Loc
unsigned
ErrorID
unsigned
NoteID
)
{
if
(
hasEffectiveAnnotation
(
T
)
)
{
Diag
.
Report
(
Loc
ErrorID
)
<
<
T
;
Diag
.
Report
(
Loc
NoteID
)
;
dumpAnnotationReason
(
Diag
T
Loc
)
;
}
}
private
:
bool
hasLiteralAnnotation
(
QualType
T
)
const
;
AnnotationReason
directAnnotationReason
(
QualType
T
)
;
AnnotationReason
tmplArgAnnotationReason
(
ArrayRef
<
TemplateArgument
>
Args
)
;
protected
:
virtual
bool
hasFakeAnnotation
(
const
TagDecl
*
D
)
const
{
return
false
;
}
}
;
static
CustomTypeAnnotation
StackClass
=
CustomTypeAnnotation
(
"
moz_stack_class
"
"
stack
"
)
;
static
CustomTypeAnnotation
GlobalClass
=
CustomTypeAnnotation
(
"
moz_global_class
"
"
global
"
)
;
static
CustomTypeAnnotation
NonHeapClass
=
CustomTypeAnnotation
(
"
moz_nonheap_class
"
"
non
-
heap
"
)
;
static
CustomTypeAnnotation
HeapClass
=
CustomTypeAnnotation
(
"
moz_heap_class
"
"
heap
"
)
;
static
CustomTypeAnnotation
NonTemporaryClass
=
CustomTypeAnnotation
(
"
moz_non_temporary_class
"
"
non
-
temporary
"
)
;
static
CustomTypeAnnotation
MustUse
=
CustomTypeAnnotation
(
"
moz_must_use_type
"
"
must
-
use
"
)
;
class
MemMoveAnnotation
final
:
public
CustomTypeAnnotation
{
public
:
MemMoveAnnotation
(
)
:
CustomTypeAnnotation
(
"
moz_non_memmovable
"
"
non
-
memmove
(
)
able
"
)
{
}
virtual
~
MemMoveAnnotation
(
)
{
}
protected
:
bool
hasFakeAnnotation
(
const
TagDecl
*
D
)
const
override
{
if
(
getDeclarationNamespace
(
D
)
=
=
"
std
"
)
{
StringRef
Name
=
getNameChecked
(
D
)
;
if
(
Name
=
=
"
pair
"
|
|
Name
=
=
"
atomic
"
|
|
Name
=
=
"
__atomic_base
"
)
{
return
false
;
}
return
true
;
}
return
false
;
}
}
;
static
MemMoveAnnotation
NonMemMovable
=
MemMoveAnnotation
(
)
;
class
MozChecker
:
public
ASTConsumer
public
RecursiveASTVisitor
<
MozChecker
>
{
DiagnosticsEngine
&
Diag
;
const
CompilerInstance
&
CI
;
DiagnosticsMatcher
Matcher
;
public
:
MozChecker
(
const
CompilerInstance
&
CI
)
:
Diag
(
CI
.
getDiagnostics
(
)
)
CI
(
CI
)
{
}
ASTConsumerPtr
getOtherConsumer
(
)
{
return
Matcher
.
makeASTConsumer
(
)
;
}
virtual
void
HandleTranslationUnit
(
ASTContext
&
Ctx
)
override
{
TraverseDecl
(
Ctx
.
getTranslationUnitDecl
(
)
)
;
}
static
bool
hasCustomAnnotation
(
const
Decl
*
D
const
char
*
Spelling
)
{
iterator_range
<
specific_attr_iterator
<
AnnotateAttr
>
>
Attrs
=
D
-
>
specific_attrs
<
AnnotateAttr
>
(
)
;
for
(
AnnotateAttr
*
Attr
:
Attrs
)
{
if
(
Attr
-
>
getAnnotation
(
)
=
=
Spelling
)
{
return
true
;
}
}
return
false
;
}
void
handleUnusedExprResult
(
const
Stmt
*
Statement
)
{
const
Expr
*
E
=
dyn_cast_or_null
<
Expr
>
(
Statement
)
;
if
(
E
)
{
E
=
E
-
>
IgnoreImplicit
(
)
;
QualType
T
=
E
-
>
getType
(
)
;
if
(
MustUse
.
hasEffectiveAnnotation
(
T
)
&
&
!
isIgnoredExprForMustUse
(
E
)
)
{
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Unused
value
of
must
-
use
type
%
0
"
)
;
Diag
.
Report
(
E
-
>
getLocStart
(
)
ErrorID
)
<
<
T
;
MustUse
.
dumpAnnotationReason
(
Diag
T
E
-
>
getLocStart
(
)
)
;
}
}
}
bool
VisitCXXRecordDecl
(
CXXRecordDecl
*
D
)
{
if
(
!
D
-
>
isThisDeclarationADefinition
(
)
)
return
true
;
typedef
std
:
:
vector
<
CXXMethodDecl
*
>
OverridesVector
;
OverridesVector
MustOverrides
;
for
(
CXXRecordDecl
:
:
base_class_iterator
Base
=
D
-
>
bases_begin
(
)
E
=
D
-
>
bases_end
(
)
;
Base
!
=
E
;
+
+
Base
)
{
CXXRecordDecl
*
Parent
=
Base
-
>
getType
(
)
.
getDesugaredType
(
D
-
>
getASTContext
(
)
)
-
>
getAsCXXRecordDecl
(
)
;
if
(
!
Parent
)
{
continue
;
}
Parent
=
Parent
-
>
getDefinition
(
)
;
for
(
CXXRecordDecl
:
:
method_iterator
M
=
Parent
-
>
method_begin
(
)
;
M
!
=
Parent
-
>
method_end
(
)
;
+
+
M
)
{
if
(
hasCustomAnnotation
(
*
M
"
moz_must_override
"
)
)
MustOverrides
.
push_back
(
*
M
)
;
}
}
for
(
OverridesVector
:
:
iterator
It
=
MustOverrides
.
begin
(
)
;
It
!
=
MustOverrides
.
end
(
)
;
+
+
It
)
{
bool
Overridden
=
false
;
for
(
CXXRecordDecl
:
:
method_iterator
M
=
D
-
>
method_begin
(
)
;
!
Overridden
&
&
M
!
=
D
-
>
method_end
(
)
;
+
+
M
)
{
if
(
getNameChecked
(
M
)
=
=
getNameChecked
(
*
It
)
&
&
!
CI
.
getSema
(
)
.
IsOverload
(
*
M
(
*
It
)
false
)
)
{
Overridden
=
true
;
break
;
}
}
if
(
!
Overridden
)
{
unsigned
OverrideID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
%
0
must
override
%
1
"
)
;
unsigned
OverrideNote
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
function
to
override
is
here
"
)
;
Diag
.
Report
(
D
-
>
getLocation
(
)
OverrideID
)
<
<
D
-
>
getDeclName
(
)
<
<
(
*
It
)
-
>
getDeclName
(
)
;
Diag
.
Report
(
(
*
It
)
-
>
getLocation
(
)
OverrideNote
)
;
}
}
return
true
;
}
bool
VisitSwitchCase
(
SwitchCase
*
Statement
)
{
handleUnusedExprResult
(
Statement
-
>
getSubStmt
(
)
)
;
return
true
;
}
bool
VisitCompoundStmt
(
CompoundStmt
*
Statement
)
{
for
(
CompoundStmt
:
:
body_iterator
It
=
Statement
-
>
body_begin
(
)
E
=
Statement
-
>
body_end
(
)
;
It
!
=
E
;
+
+
It
)
{
handleUnusedExprResult
(
*
It
)
;
}
return
true
;
}
bool
VisitIfStmt
(
IfStmt
*
Statement
)
{
handleUnusedExprResult
(
Statement
-
>
getThen
(
)
)
;
handleUnusedExprResult
(
Statement
-
>
getElse
(
)
)
;
return
true
;
}
bool
VisitWhileStmt
(
WhileStmt
*
Statement
)
{
handleUnusedExprResult
(
Statement
-
>
getBody
(
)
)
;
return
true
;
}
bool
VisitDoStmt
(
DoStmt
*
Statement
)
{
handleUnusedExprResult
(
Statement
-
>
getBody
(
)
)
;
return
true
;
}
bool
VisitForStmt
(
ForStmt
*
Statement
)
{
handleUnusedExprResult
(
Statement
-
>
getBody
(
)
)
;
handleUnusedExprResult
(
Statement
-
>
getInit
(
)
)
;
handleUnusedExprResult
(
Statement
-
>
getInc
(
)
)
;
return
true
;
}
bool
VisitBinComma
(
BinaryOperator
*
Op
)
{
handleUnusedExprResult
(
Op
-
>
getLHS
(
)
)
;
return
true
;
}
}
;
typedef
DenseMap
<
const
CXXRecordDecl
*
std
:
:
pair
<
const
Decl
*
bool
>
>
RefCountedMap
;
RefCountedMap
RefCountedClasses
;
bool
classHasAddRefRelease
(
const
CXXRecordDecl
*
D
)
{
const
RefCountedMap
:
:
iterator
&
It
=
RefCountedClasses
.
find
(
D
)
;
if
(
It
!
=
RefCountedClasses
.
end
(
)
)
{
return
It
-
>
second
.
second
;
}
bool
SeenAddRef
=
false
;
bool
SeenRelease
=
false
;
for
(
CXXRecordDecl
:
:
method_iterator
Method
=
D
-
>
method_begin
(
)
;
Method
!
=
D
-
>
method_end
(
)
;
+
+
Method
)
{
const
auto
&
Name
=
getNameChecked
(
Method
)
;
if
(
Name
=
=
"
AddRef
"
)
{
SeenAddRef
=
true
;
}
else
if
(
Name
=
=
"
Release
"
)
{
SeenRelease
=
true
;
}
}
RefCountedClasses
[
D
]
=
std
:
:
make_pair
(
D
SeenAddRef
&
&
SeenRelease
)
;
return
SeenAddRef
&
&
SeenRelease
;
}
bool
isClassRefCounted
(
QualType
T
)
;
bool
isClassRefCounted
(
const
CXXRecordDecl
*
D
)
{
if
(
!
D
-
>
hasDefinition
(
)
)
return
false
;
D
=
D
-
>
getDefinition
(
)
;
if
(
classHasAddRefRelease
(
D
)
)
return
true
;
for
(
CXXRecordDecl
:
:
base_class_const_iterator
Base
=
D
-
>
bases_begin
(
)
;
Base
!
=
D
-
>
bases_end
(
)
;
+
+
Base
)
{
bool
Super
=
isClassRefCounted
(
Base
-
>
getType
(
)
)
;
if
(
Super
)
{
return
true
;
}
}
return
false
;
}
bool
isClassRefCounted
(
QualType
T
)
{
while
(
const
clang
:
:
ArrayType
*
ArrTy
=
T
-
>
getAsArrayTypeUnsafe
(
)
)
T
=
ArrTy
-
>
getElementType
(
)
;
CXXRecordDecl
*
Clazz
=
T
-
>
getAsCXXRecordDecl
(
)
;
return
Clazz
?
isClassRefCounted
(
Clazz
)
:
false
;
}
template
<
class
T
>
bool
ASTIsInSystemHeader
(
const
ASTContext
&
AC
const
T
&
D
)
{
auto
&
SourceManager
=
AC
.
getSourceManager
(
)
;
auto
ExpansionLoc
=
SourceManager
.
getExpansionLoc
(
D
.
getLocStart
(
)
)
;
if
(
ExpansionLoc
.
isInvalid
(
)
)
{
return
false
;
}
return
SourceManager
.
isInSystemHeader
(
ExpansionLoc
)
;
}
const
FieldDecl
*
getClassRefCntMember
(
const
CXXRecordDecl
*
D
)
{
for
(
RecordDecl
:
:
field_iterator
Field
=
D
-
>
field_begin
(
)
E
=
D
-
>
field_end
(
)
;
Field
!
=
E
;
+
+
Field
)
{
if
(
getNameChecked
(
Field
)
=
=
"
mRefCnt
"
)
{
return
*
Field
;
}
}
return
0
;
}
const
FieldDecl
*
getBaseRefCntMember
(
QualType
T
)
;
const
FieldDecl
*
getBaseRefCntMember
(
const
CXXRecordDecl
*
D
)
{
const
FieldDecl
*
RefCntMember
=
getClassRefCntMember
(
D
)
;
if
(
RefCntMember
&
&
isClassRefCounted
(
D
)
)
{
return
RefCntMember
;
}
for
(
CXXRecordDecl
:
:
base_class_const_iterator
Base
=
D
-
>
bases_begin
(
)
E
=
D
-
>
bases_end
(
)
;
Base
!
=
E
;
+
+
Base
)
{
RefCntMember
=
getBaseRefCntMember
(
Base
-
>
getType
(
)
)
;
if
(
RefCntMember
)
{
return
RefCntMember
;
}
}
return
0
;
}
const
FieldDecl
*
getBaseRefCntMember
(
QualType
T
)
{
while
(
const
clang
:
:
ArrayType
*
ArrTy
=
T
-
>
getAsArrayTypeUnsafe
(
)
)
T
=
ArrTy
-
>
getElementType
(
)
;
CXXRecordDecl
*
Clazz
=
T
-
>
getAsCXXRecordDecl
(
)
;
return
Clazz
?
getBaseRefCntMember
(
Clazz
)
:
0
;
}
bool
typeHasVTable
(
QualType
T
)
{
while
(
const
clang
:
:
ArrayType
*
ArrTy
=
T
-
>
getAsArrayTypeUnsafe
(
)
)
T
=
ArrTy
-
>
getElementType
(
)
;
CXXRecordDecl
*
Offender
=
T
-
>
getAsCXXRecordDecl
(
)
;
return
Offender
&
&
Offender
-
>
hasDefinition
(
)
&
&
Offender
-
>
isDynamicClass
(
)
;
}
}
namespace
clang
{
namespace
ast_matchers
{
AST_MATCHER
(
FunctionDecl
heapAllocator
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_heap_allocator
"
)
;
}
AST_MATCHER
(
Decl
noArithmeticExprInArgs
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_no_arith_expr_in_arg
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasTrivialCtorDtor
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_trivial_ctor_dtor
"
)
;
}
AST_MATCHER
(
FunctionDecl
hasNoAddRefReleaseOnReturnAttr
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_no_addref_release_on_return
"
)
;
}
AST_MATCHER
(
BinaryOperator
binaryArithmeticOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_Mul
|
|
OpCode
=
=
BO_Div
|
|
OpCode
=
=
BO_Rem
|
|
OpCode
=
=
BO_Add
|
|
OpCode
=
=
BO_Sub
|
|
OpCode
=
=
BO_Shl
|
|
OpCode
=
=
BO_Shr
|
|
OpCode
=
=
BO_And
|
|
OpCode
=
=
BO_Xor
|
|
OpCode
=
=
BO_Or
|
|
OpCode
=
=
BO_MulAssign
|
|
OpCode
=
=
BO_DivAssign
|
|
OpCode
=
=
BO_RemAssign
|
|
OpCode
=
=
BO_AddAssign
|
|
OpCode
=
=
BO_SubAssign
|
|
OpCode
=
=
BO_ShlAssign
|
|
OpCode
=
=
BO_ShrAssign
|
|
OpCode
=
=
BO_AndAssign
|
|
OpCode
=
=
BO_XorAssign
|
|
OpCode
=
=
BO_OrAssign
;
}
AST_MATCHER
(
UnaryOperator
unaryArithmeticOperator
)
{
UnaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
UO_PostInc
|
|
OpCode
=
=
UO_PostDec
|
|
OpCode
=
=
UO_PreInc
|
|
OpCode
=
=
UO_PreDec
|
|
OpCode
=
=
UO_Plus
|
|
OpCode
=
=
UO_Minus
|
|
OpCode
=
=
UO_Not
;
}
AST_MATCHER
(
BinaryOperator
binaryEqualityOperator
)
{
BinaryOperatorKind
OpCode
=
Node
.
getOpcode
(
)
;
return
OpCode
=
=
BO_EQ
|
|
OpCode
=
=
BO_NE
;
}
AST_MATCHER
(
QualType
isFloat
)
{
return
Node
-
>
isRealFloatingType
(
)
;
}
AST_MATCHER
(
BinaryOperator
isInSystemHeader
)
{
return
ASTIsInSystemHeader
(
Finder
-
>
getASTContext
(
)
Node
)
;
}
AST_MATCHER
(
BinaryOperator
isInWhitelistForNaNExpr
)
{
const
char
*
whitelist
[
]
=
{
"
SkScalar
.
h
"
"
json_writer
.
cpp
"
}
;
SourceLocation
Loc
=
Node
.
getOperatorLoc
(
)
;
auto
&
SourceManager
=
Finder
-
>
getASTContext
(
)
.
getSourceManager
(
)
;
SmallString
<
1024
>
FileName
=
SourceManager
.
getFilename
(
Loc
)
;
for
(
auto
itr
=
std
:
:
begin
(
whitelist
)
;
itr
!
=
std
:
:
end
(
whitelist
)
;
itr
+
+
)
{
if
(
llvm
:
:
sys
:
:
path
:
:
rbegin
(
FileName
)
-
>
equals
(
*
itr
)
)
{
return
true
;
}
}
return
false
;
}
AST_MATCHER
(
MemberExpr
isAddRefOrRelease
)
{
ValueDecl
*
Member
=
Node
.
getMemberDecl
(
)
;
CXXMethodDecl
*
Method
=
dyn_cast
<
CXXMethodDecl
>
(
Member
)
;
if
(
Method
)
{
const
auto
&
Name
=
getNameChecked
(
Method
)
;
return
Name
=
=
"
AddRef
"
|
|
Name
=
=
"
Release
"
;
}
return
false
;
}
AST_MATCHER
(
CXXRecordDecl
hasRefCntMember
)
{
return
isClassRefCounted
(
&
Node
)
&
&
getClassRefCntMember
(
&
Node
)
;
}
AST_MATCHER
(
QualType
hasVTable
)
{
return
typeHasVTable
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
hasNeedsNoVTableTypeAttr
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_no_vtable_type
"
)
;
}
AST_MATCHER
(
QualType
isNonMemMovable
)
{
return
NonMemMovable
.
hasEffectiveAnnotation
(
Node
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableTemplateArg
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_memmovable_type
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
needsMemMovableMembers
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_needs_memmovable_members
"
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isInterestingImplicitCtor
)
{
const
CXXConstructorDecl
*
Declaration
=
Node
.
getCanonicalDecl
(
)
;
return
!
isInIgnoredNamespaceForImplicitCtor
(
Declaration
)
&
&
!
isIgnoredPathForImplicitCtor
(
Declaration
)
&
&
Declaration
-
>
isConvertingConstructor
(
false
)
&
&
!
Declaration
-
>
isCopyOrMoveConstructor
(
)
&
&
!
Declaration
-
>
isDeleted
(
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isMarkedImplicit
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
&
Node
"
moz_implicit
"
)
;
}
AST_MATCHER
(
CXXRecordDecl
isConcreteClass
)
{
return
!
Node
.
isAbstract
(
)
;
}
AST_MATCHER
(
QualType
autoNonAutoableType
)
{
if
(
const
AutoType
*
T
=
Node
-
>
getContainedAutoType
(
)
)
{
if
(
const
CXXRecordDecl
*
Rec
=
T
-
>
getAsCXXRecordDecl
(
)
)
{
return
MozChecker
:
:
hasCustomAnnotation
(
Rec
"
moz_non_autoable
"
)
;
}
}
return
false
;
}
AST_MATCHER
(
CXXConstructorDecl
isExplicitMoveConstructor
)
{
return
Node
.
isExplicit
(
)
&
&
Node
.
isMoveConstructor
(
)
;
}
AST_MATCHER
(
CXXConstructorDecl
isCompilerProvidedCopyConstructor
)
{
return
!
Node
.
isUserProvided
(
)
&
&
Node
.
isCopyConstructor
(
)
;
}
AST_MATCHER
(
CallExpr
isAssertAssignmentTestFunc
)
{
static
const
std
:
:
string
AssertName
=
"
MOZ_AssertAssignmentTest
"
;
const
FunctionDecl
*
Method
=
Node
.
getDirectCallee
(
)
;
return
Method
&
&
Method
-
>
getDeclName
(
)
.
isIdentifier
(
)
&
&
Method
-
>
getName
(
)
=
=
AssertName
;
}
AST_MATCHER
(
CXXRecordDecl
isLambdaDecl
)
{
return
Node
.
isLambda
(
)
;
}
AST_MATCHER
(
QualType
isRefPtr
)
{
return
typeIsRefPtr
(
Node
)
;
}
}
}
namespace
{
void
CustomTypeAnnotation
:
:
dumpAnnotationReason
(
DiagnosticsEngine
&
Diag
QualType
T
SourceLocation
Loc
)
{
unsigned
InheritsID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
%
1
is
a
%
0
type
because
it
inherits
from
a
%
0
type
%
2
"
)
;
unsigned
MemberID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
%
1
is
a
%
0
type
because
member
%
2
is
a
%
0
type
%
3
"
)
;
unsigned
ArrayID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
%
1
is
a
%
0
type
because
it
is
an
array
of
%
0
type
%
2
"
)
;
unsigned
TemplID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
%
1
is
a
%
0
type
because
it
has
a
template
argument
%
0
type
%
2
"
)
;
AnnotationReason
Reason
=
directAnnotationReason
(
T
)
;
for
(
;
;
)
{
switch
(
Reason
.
Kind
)
{
case
RK_ArrayElement
:
Diag
.
Report
(
Loc
ArrayID
)
<
<
Pretty
<
<
T
<
<
Reason
.
Type
;
break
;
case
RK_BaseClass
:
{
const
CXXRecordDecl
*
Declaration
=
T
-
>
getAsCXXRecordDecl
(
)
;
assert
(
Declaration
&
&
"
This
type
should
be
a
C
+
+
class
"
)
;
Diag
.
Report
(
Declaration
-
>
getLocation
(
)
InheritsID
)
<
<
Pretty
<
<
T
<
<
Reason
.
Type
;
break
;
}
case
RK_Field
:
Diag
.
Report
(
Reason
.
Field
-
>
getLocation
(
)
MemberID
)
<
<
Pretty
<
<
T
<
<
Reason
.
Field
<
<
Reason
.
Type
;
break
;
case
RK_TemplateInherited
:
{
const
CXXRecordDecl
*
Declaration
=
T
-
>
getAsCXXRecordDecl
(
)
;
assert
(
Declaration
&
&
"
This
type
should
be
a
C
+
+
class
"
)
;
Diag
.
Report
(
Declaration
-
>
getLocation
(
)
TemplID
)
<
<
Pretty
<
<
T
<
<
Reason
.
Type
;
break
;
}
default
:
return
;
}
T
=
Reason
.
Type
;
Reason
=
directAnnotationReason
(
T
)
;
}
}
bool
CustomTypeAnnotation
:
:
hasLiteralAnnotation
(
QualType
T
)
const
{
#
if
CLANG_VERSION_FULL
>
=
306
if
(
const
TagDecl
*
D
=
T
-
>
getAsTagDecl
(
)
)
{
#
else
if
(
const
CXXRecordDecl
*
D
=
T
-
>
getAsCXXRecordDecl
(
)
)
{
#
endif
return
hasFakeAnnotation
(
D
)
|
|
MozChecker
:
:
hasCustomAnnotation
(
D
Spelling
)
;
}
return
false
;
}
CustomTypeAnnotation
:
:
AnnotationReason
CustomTypeAnnotation
:
:
directAnnotationReason
(
QualType
T
)
{
if
(
hasLiteralAnnotation
(
T
)
)
{
AnnotationReason
Reason
=
{
T
RK_Direct
nullptr
}
;
return
Reason
;
}
void
*
Key
=
T
.
getAsOpaquePtr
(
)
;
ReasonCache
:
:
iterator
Cached
=
Cache
.
find
(
T
.
getAsOpaquePtr
(
)
)
;
if
(
Cached
!
=
Cache
.
end
(
)
)
{
return
Cached
-
>
second
;
}
if
(
const
clang
:
:
ArrayType
*
Array
=
T
-
>
getAsArrayTypeUnsafe
(
)
)
{
if
(
hasEffectiveAnnotation
(
Array
-
>
getElementType
(
)
)
)
{
AnnotationReason
Reason
=
{
Array
-
>
getElementType
(
)
RK_ArrayElement
nullptr
}
;
Cache
[
Key
]
=
Reason
;
return
Reason
;
}
}
if
(
const
CXXRecordDecl
*
Declaration
=
T
-
>
getAsCXXRecordDecl
(
)
)
{
if
(
Declaration
-
>
hasDefinition
(
)
)
{
Declaration
=
Declaration
-
>
getDefinition
(
)
;
for
(
const
CXXBaseSpecifier
&
Base
:
Declaration
-
>
bases
(
)
)
{
if
(
hasEffectiveAnnotation
(
Base
.
getType
(
)
)
)
{
AnnotationReason
Reason
=
{
Base
.
getType
(
)
RK_BaseClass
nullptr
}
;
Cache
[
Key
]
=
Reason
;
return
Reason
;
}
}
for
(
const
FieldDecl
*
Field
:
Declaration
-
>
fields
(
)
)
{
if
(
hasEffectiveAnnotation
(
Field
-
>
getType
(
)
)
)
{
AnnotationReason
Reason
=
{
Field
-
>
getType
(
)
RK_Field
Field
}
;
Cache
[
Key
]
=
Reason
;
return
Reason
;
}
}
if
(
MozChecker
:
:
hasCustomAnnotation
(
Declaration
"
moz_inherit_type_annotations_from_template_args
"
)
)
{
const
ClassTemplateSpecializationDecl
*
Spec
=
dyn_cast
<
ClassTemplateSpecializationDecl
>
(
Declaration
)
;
if
(
Spec
)
{
const
TemplateArgumentList
&
Args
=
Spec
-
>
getTemplateArgs
(
)
;
AnnotationReason
Reason
=
tmplArgAnnotationReason
(
Args
.
asArray
(
)
)
;
if
(
Reason
.
Kind
!
=
RK_None
)
{
Cache
[
Key
]
=
Reason
;
return
Reason
;
}
}
}
}
}
AnnotationReason
Reason
=
{
QualType
(
)
RK_None
nullptr
}
;
Cache
[
Key
]
=
Reason
;
return
Reason
;
}
CustomTypeAnnotation
:
:
AnnotationReason
CustomTypeAnnotation
:
:
tmplArgAnnotationReason
(
ArrayRef
<
TemplateArgument
>
Args
)
{
for
(
const
TemplateArgument
&
Arg
:
Args
)
{
if
(
Arg
.
getKind
(
)
=
=
TemplateArgument
:
:
Type
)
{
QualType
Type
=
Arg
.
getAsType
(
)
;
if
(
hasEffectiveAnnotation
(
Type
)
)
{
AnnotationReason
Reason
=
{
Type
RK_TemplateInherited
nullptr
}
;
return
Reason
;
}
}
else
if
(
Arg
.
getKind
(
)
=
=
TemplateArgument
:
:
Pack
)
{
AnnotationReason
Reason
=
tmplArgAnnotationReason
(
Arg
.
getPackAsArray
(
)
)
;
if
(
Reason
.
Kind
!
=
RK_None
)
{
return
Reason
;
}
}
}
AnnotationReason
Reason
=
{
QualType
(
)
RK_None
nullptr
}
;
return
Reason
;
}
bool
isPlacementNew
(
const
CXXNewExpr
*
Expression
)
{
if
(
Expression
-
>
getNumPlacementArgs
(
)
=
=
0
)
return
false
;
const
FunctionDecl
*
Declaration
=
Expression
-
>
getOperatorNew
(
)
;
if
(
Declaration
&
&
MozChecker
:
:
hasCustomAnnotation
(
Declaration
"
moz_heap_allocator
"
)
)
{
return
false
;
}
return
true
;
}
DiagnosticsMatcher
:
:
DiagnosticsMatcher
(
)
{
AstMatcher
.
addMatcher
(
varDecl
(
)
.
bind
(
"
node
"
)
&
Scope
)
;
AstMatcher
.
addMatcher
(
cxxNewExpr
(
)
.
bind
(
"
node
"
)
&
Scope
)
;
AstMatcher
.
addMatcher
(
materializeTemporaryExpr
(
)
.
bind
(
"
node
"
)
&
Scope
)
;
AstMatcher
.
addMatcher
(
callExpr
(
callee
(
functionDecl
(
heapAllocator
(
)
)
)
)
.
bind
(
"
node
"
)
&
Scope
)
;
AstMatcher
.
addMatcher
(
parmVarDecl
(
)
.
bind
(
"
parm_vardecl
"
)
&
Scope
)
;
AstMatcher
.
addMatcher
(
callExpr
(
allOf
(
hasDeclaration
(
noArithmeticExprInArgs
(
)
)
anyOf
(
hasDescendant
(
binaryOperator
(
allOf
(
binaryArithmeticOperator
(
)
hasLHS
(
hasDescendant
(
declRefExpr
(
)
)
)
hasRHS
(
hasDescendant
(
declRefExpr
(
)
)
)
)
)
.
bind
(
"
node
"
)
)
hasDescendant
(
unaryOperator
(
allOf
(
unaryArithmeticOperator
(
)
hasUnaryOperand
(
allOf
(
hasType
(
builtinType
(
)
)
anyOf
(
hasDescendant
(
declRefExpr
(
)
)
declRefExpr
(
)
)
)
)
)
)
.
bind
(
"
node
"
)
)
)
)
)
.
bind
(
"
call
"
)
&
ArithmeticArg
)
;
AstMatcher
.
addMatcher
(
cxxConstructExpr
(
allOf
(
hasDeclaration
(
noArithmeticExprInArgs
(
)
)
anyOf
(
hasDescendant
(
binaryOperator
(
allOf
(
binaryArithmeticOperator
(
)
hasLHS
(
hasDescendant
(
declRefExpr
(
)
)
)
hasRHS
(
hasDescendant
(
declRefExpr
(
)
)
)
)
)
.
bind
(
"
node
"
)
)
hasDescendant
(
unaryOperator
(
allOf
(
unaryArithmeticOperator
(
)
hasUnaryOperand
(
allOf
(
hasType
(
builtinType
(
)
)
anyOf
(
hasDescendant
(
declRefExpr
(
)
)
declRefExpr
(
)
)
)
)
)
)
.
bind
(
"
node
"
)
)
)
)
)
.
bind
(
"
call
"
)
&
ArithmeticArg
)
;
AstMatcher
.
addMatcher
(
cxxRecordDecl
(
hasTrivialCtorDtor
(
)
)
.
bind
(
"
node
"
)
&
TrivialCtorDtor
)
;
AstMatcher
.
addMatcher
(
binaryOperator
(
allOf
(
binaryEqualityOperator
(
)
hasLHS
(
has
(
declRefExpr
(
hasType
(
qualType
(
(
isFloat
(
)
)
)
)
)
.
bind
(
"
lhs
"
)
)
)
hasRHS
(
has
(
declRefExpr
(
hasType
(
qualType
(
(
isFloat
(
)
)
)
)
)
.
bind
(
"
rhs
"
)
)
)
unless
(
anyOf
(
isInSystemHeader
(
)
isInWhitelistForNaNExpr
(
)
)
)
)
)
.
bind
(
"
node
"
)
&
NaNExpr
)
;
AstMatcher
.
addMatcher
(
callExpr
(
callee
(
functionDecl
(
hasNoAddRefReleaseOnReturnAttr
(
)
)
.
bind
(
"
func
"
)
)
hasParent
(
memberExpr
(
isAddRefOrRelease
(
)
hasParent
(
callExpr
(
)
)
)
.
bind
(
"
member
"
)
)
)
.
bind
(
"
node
"
)
&
NoAddRefReleaseOnReturn
)
;
AstMatcher
.
addMatcher
(
callExpr
(
callee
(
functionDecl
(
hasNoAddRefReleaseOnReturnAttr
(
)
)
.
bind
(
"
func
"
)
)
hasParent
(
castExpr
(
hasParent
(
memberExpr
(
isAddRefOrRelease
(
)
hasParent
(
callExpr
(
)
)
)
.
bind
(
"
member
"
)
)
)
)
)
.
bind
(
"
node
"
)
&
NoAddRefReleaseOnReturn
)
;
AstMatcher
.
addMatcher
(
functionDecl
(
returns
(
recordType
(
hasDeclaration
(
cxxRecordDecl
(
isLambdaDecl
(
)
)
.
bind
(
"
decl
"
)
)
)
)
)
&
RefCountedInsideLambda
)
;
AstMatcher
.
addMatcher
(
lambdaExpr
(
)
.
bind
(
"
lambdaExpr
"
)
&
RefCountedInsideLambda
)
;
AstMatcher
.
addMatcher
(
classTemplateSpecializationDecl
(
hasAnyTemplateArgument
(
refersToType
(
recordType
(
hasDeclaration
(
cxxRecordDecl
(
isLambdaDecl
(
)
)
.
bind
(
"
decl
"
)
)
)
)
)
)
&
RefCountedInsideLambda
)
;
AstMatcher
.
addMatcher
(
cxxMethodDecl
(
anyOf
(
hasName
(
"
operator
bool
"
)
hasName
(
"
operator
_Bool
"
)
)
)
.
bind
(
"
node
"
)
&
ExplicitOperatorBool
)
;
AstMatcher
.
addMatcher
(
cxxRecordDecl
(
)
.
bind
(
"
decl
"
)
&
NoDuplicateRefCntMember
)
;
AstMatcher
.
addMatcher
(
classTemplateSpecializationDecl
(
allOf
(
hasAnyTemplateArgument
(
refersToType
(
hasVTable
(
)
)
)
hasNeedsNoVTableTypeAttr
(
)
)
)
.
bind
(
"
node
"
)
&
NeedsNoVTableType
)
;
AstMatcher
.
addMatcher
(
classTemplateSpecializationDecl
(
allOf
(
needsMemMovableTemplateArg
(
)
hasAnyTemplateArgument
(
refersToType
(
isNonMemMovable
(
)
)
)
)
)
.
bind
(
"
specialization
"
)
&
NonMemMovableTemplateArg
)
;
AstMatcher
.
addMatcher
(
cxxRecordDecl
(
needsMemMovableMembers
(
)
)
.
bind
(
"
decl
"
)
&
NonMemMovableMember
)
;
AstMatcher
.
addMatcher
(
cxxConstructorDecl
(
isInterestingImplicitCtor
(
)
ofClass
(
allOf
(
isConcreteClass
(
)
decl
(
)
.
bind
(
"
class
"
)
)
)
unless
(
isMarkedImplicit
(
)
)
)
.
bind
(
"
ctor
"
)
&
ExplicitImplicit
)
;
AstMatcher
.
addMatcher
(
varDecl
(
hasType
(
autoNonAutoableType
(
)
)
)
.
bind
(
"
node
"
)
&
NoAutoType
)
;
AstMatcher
.
addMatcher
(
cxxConstructorDecl
(
isExplicitMoveConstructor
(
)
)
.
bind
(
"
node
"
)
&
NoExplicitMoveConstructor
)
;
AstMatcher
.
addMatcher
(
cxxConstructExpr
(
hasDeclaration
(
cxxConstructorDecl
(
isCompilerProvidedCopyConstructor
(
)
ofClass
(
hasRefCntMember
(
)
)
)
)
)
.
bind
(
"
node
"
)
&
RefCountedCopyConstructor
)
;
AstMatcher
.
addMatcher
(
callExpr
(
isAssertAssignmentTestFunc
(
)
)
.
bind
(
"
funcCall
"
)
&
AssertAttribution
)
;
AstMatcher
.
addMatcher
(
varDecl
(
hasType
(
isRefPtr
(
)
)
)
.
bind
(
"
decl
"
)
&
KungFuDeathGrip
)
;
}
enum
AllocationVariety
{
AV_None
AV_Global
AV_Automatic
AV_Temporary
AV_Heap
}
;
typedef
DenseMap
<
const
MaterializeTemporaryExpr
*
const
Decl
*
>
AutomaticTemporaryMap
;
AutomaticTemporaryMap
AutomaticTemporaries
;
void
DiagnosticsMatcher
:
:
ScopeChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
AllocationVariety
Variety
=
AV_None
;
SourceLocation
Loc
;
QualType
T
;
if
(
const
ParmVarDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
ParmVarDecl
>
(
"
parm_vardecl
"
)
)
{
if
(
D
-
>
hasUnparsedDefaultArg
(
)
|
|
D
-
>
hasUninstantiatedDefaultArg
(
)
)
{
return
;
}
if
(
const
Expr
*
Default
=
D
-
>
getDefaultArg
(
)
)
{
if
(
const
MaterializeTemporaryExpr
*
E
=
dyn_cast
<
MaterializeTemporaryExpr
>
(
Default
)
)
{
AutomaticTemporaries
[
E
]
=
D
;
}
}
return
;
}
if
(
const
VarDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
VarDecl
>
(
"
node
"
)
)
{
if
(
D
-
>
hasGlobalStorage
(
)
)
{
Variety
=
AV_Global
;
}
else
{
Variety
=
AV_Automatic
;
}
T
=
D
-
>
getType
(
)
;
Loc
=
D
-
>
getLocStart
(
)
;
}
else
if
(
const
CXXNewExpr
*
E
=
Result
.
Nodes
.
getNodeAs
<
CXXNewExpr
>
(
"
node
"
)
)
{
if
(
!
isPlacementNew
(
E
)
)
{
Variety
=
AV_Heap
;
T
=
E
-
>
getAllocatedType
(
)
;
Loc
=
E
-
>
getLocStart
(
)
;
}
}
else
if
(
const
MaterializeTemporaryExpr
*
E
=
Result
.
Nodes
.
getNodeAs
<
MaterializeTemporaryExpr
>
(
"
node
"
)
)
{
switch
(
E
-
>
getStorageDuration
(
)
)
{
case
SD_FullExpression
:
{
AutomaticTemporaryMap
:
:
iterator
AutomaticTemporary
=
AutomaticTemporaries
.
find
(
E
)
;
if
(
AutomaticTemporary
!
=
AutomaticTemporaries
.
end
(
)
)
{
Variety
=
AV_Automatic
;
}
else
{
Variety
=
AV_Temporary
;
}
}
break
;
case
SD_Automatic
:
Variety
=
AV_Automatic
;
break
;
case
SD_Thread
:
case
SD_Static
:
Variety
=
AV_Global
;
break
;
case
SD_Dynamic
:
assert
(
false
&
&
"
I
don
'
t
think
that
this
ever
should
occur
.
.
.
"
)
;
Variety
=
AV_Heap
;
break
;
}
T
=
E
-
>
getType
(
)
.
getUnqualifiedType
(
)
;
Loc
=
E
-
>
getLocStart
(
)
;
}
else
if
(
const
CallExpr
*
E
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
node
"
)
)
{
T
=
E
-
>
getType
(
)
-
>
getPointeeType
(
)
;
if
(
!
T
.
isNull
(
)
)
{
Variety
=
AV_Heap
;
Loc
=
E
-
>
getLocStart
(
)
;
}
}
unsigned
StackID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
variable
of
type
%
0
only
valid
on
the
stack
"
)
;
unsigned
GlobalID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
variable
of
type
%
0
only
valid
as
global
"
)
;
unsigned
HeapID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
variable
of
type
%
0
only
valid
on
the
heap
"
)
;
unsigned
NonHeapID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
variable
of
type
%
0
is
not
valid
on
the
heap
"
)
;
unsigned
NonTemporaryID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
variable
of
type
%
0
is
not
valid
in
a
temporary
"
)
;
unsigned
StackNoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
value
incorrectly
allocated
in
an
automatic
variable
"
)
;
unsigned
GlobalNoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
value
incorrectly
allocated
in
a
global
variable
"
)
;
unsigned
HeapNoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
value
incorrectly
allocated
on
the
heap
"
)
;
unsigned
TemporaryNoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
value
incorrectly
allocated
in
a
temporary
"
)
;
switch
(
Variety
)
{
case
AV_None
:
return
;
case
AV_Global
:
StackClass
.
reportErrorIfPresent
(
Diag
T
Loc
StackID
GlobalNoteID
)
;
HeapClass
.
reportErrorIfPresent
(
Diag
T
Loc
HeapID
GlobalNoteID
)
;
break
;
case
AV_Automatic
:
GlobalClass
.
reportErrorIfPresent
(
Diag
T
Loc
GlobalID
StackNoteID
)
;
HeapClass
.
reportErrorIfPresent
(
Diag
T
Loc
HeapID
StackNoteID
)
;
break
;
case
AV_Temporary
:
GlobalClass
.
reportErrorIfPresent
(
Diag
T
Loc
GlobalID
TemporaryNoteID
)
;
HeapClass
.
reportErrorIfPresent
(
Diag
T
Loc
HeapID
TemporaryNoteID
)
;
NonTemporaryClass
.
reportErrorIfPresent
(
Diag
T
Loc
NonTemporaryID
TemporaryNoteID
)
;
break
;
case
AV_Heap
:
GlobalClass
.
reportErrorIfPresent
(
Diag
T
Loc
GlobalID
HeapNoteID
)
;
StackClass
.
reportErrorIfPresent
(
Diag
T
Loc
StackID
HeapNoteID
)
;
NonHeapClass
.
reportErrorIfPresent
(
Diag
T
Loc
NonHeapID
HeapNoteID
)
;
break
;
}
}
void
DiagnosticsMatcher
:
:
ArithmeticArgChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
cannot
pass
an
arithmetic
expression
of
built
-
in
types
to
%
0
"
)
;
const
Expr
*
Expression
=
Result
.
Nodes
.
getNodeAs
<
Expr
>
(
"
node
"
)
;
if
(
const
CallExpr
*
Call
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
call
"
)
)
{
Diag
.
Report
(
Expression
-
>
getLocStart
(
)
ErrorID
)
<
<
Call
-
>
getDirectCallee
(
)
;
}
else
if
(
const
CXXConstructExpr
*
Ctr
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructExpr
>
(
"
call
"
)
)
{
Diag
.
Report
(
Expression
-
>
getLocStart
(
)
ErrorID
)
<
<
Ctr
-
>
getConstructor
(
)
;
}
}
void
DiagnosticsMatcher
:
:
TrivialCtorDtorChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
class
%
0
must
have
trivial
constructors
and
destructors
"
)
;
const
CXXRecordDecl
*
Node
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
node
"
)
;
bool
BadCtor
=
!
(
Node
-
>
hasConstexprDefaultConstructor
(
)
|
|
Node
-
>
hasTrivialDefaultConstructor
(
)
)
;
bool
BadDtor
=
!
Node
-
>
hasTrivialDestructor
(
)
;
if
(
BadCtor
|
|
BadDtor
)
Diag
.
Report
(
Node
-
>
getLocStart
(
)
ErrorID
)
<
<
Node
;
}
void
DiagnosticsMatcher
:
:
NaNExprChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
if
(
!
Result
.
Context
-
>
getLangOpts
(
)
.
CPlusPlus
)
{
return
;
}
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
comparing
a
floating
point
value
to
itself
for
"
"
NaN
checking
can
lead
to
incorrect
results
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
consider
using
mozilla
:
:
IsNaN
instead
"
)
;
const
BinaryOperator
*
Expression
=
Result
.
Nodes
.
getNodeAs
<
BinaryOperator
>
(
"
node
"
)
;
const
DeclRefExpr
*
LHS
=
Result
.
Nodes
.
getNodeAs
<
DeclRefExpr
>
(
"
lhs
"
)
;
const
DeclRefExpr
*
RHS
=
Result
.
Nodes
.
getNodeAs
<
DeclRefExpr
>
(
"
rhs
"
)
;
const
ImplicitCastExpr
*
LHSExpr
=
dyn_cast
<
ImplicitCastExpr
>
(
Expression
-
>
getLHS
(
)
)
;
const
ImplicitCastExpr
*
RHSExpr
=
dyn_cast
<
ImplicitCastExpr
>
(
Expression
-
>
getRHS
(
)
)
;
if
(
LHS
-
>
getFoundDecl
(
)
=
=
RHS
-
>
getFoundDecl
(
)
&
&
LHSExpr
&
&
RHSExpr
&
&
std
:
:
distance
(
LHSExpr
-
>
child_begin
(
)
LHSExpr
-
>
child_end
(
)
)
=
=
1
&
&
std
:
:
distance
(
RHSExpr
-
>
child_begin
(
)
RHSExpr
-
>
child_end
(
)
)
=
=
1
&
&
*
LHSExpr
-
>
child_begin
(
)
=
=
LHS
&
&
*
RHSExpr
-
>
child_begin
(
)
=
=
RHS
)
{
Diag
.
Report
(
Expression
-
>
getLocStart
(
)
ErrorID
)
;
Diag
.
Report
(
Expression
-
>
getLocStart
(
)
NoteID
)
;
}
}
void
DiagnosticsMatcher
:
:
NoAddRefReleaseOnReturnChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
%
1
cannot
be
called
on
the
return
value
of
%
0
"
)
;
const
Stmt
*
Node
=
Result
.
Nodes
.
getNodeAs
<
Stmt
>
(
"
node
"
)
;
const
FunctionDecl
*
Func
=
Result
.
Nodes
.
getNodeAs
<
FunctionDecl
>
(
"
func
"
)
;
const
MemberExpr
*
Member
=
Result
.
Nodes
.
getNodeAs
<
MemberExpr
>
(
"
member
"
)
;
const
CXXMethodDecl
*
Method
=
dyn_cast
<
CXXMethodDecl
>
(
Member
-
>
getMemberDecl
(
)
)
;
Diag
.
Report
(
Node
-
>
getLocStart
(
)
ErrorID
)
<
<
Func
<
<
Method
;
}
void
DiagnosticsMatcher
:
:
RefCountedInsideLambdaChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
static
DenseSet
<
const
CXXRecordDecl
*
>
CheckedDecls
;
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Refcounted
variable
%
0
of
type
%
1
cannot
be
captured
by
a
lambda
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Please
consider
using
a
smart
pointer
"
)
;
const
CXXRecordDecl
*
Lambda
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
decl
"
)
;
if
(
const
LambdaExpr
*
OuterLambda
=
Result
.
Nodes
.
getNodeAs
<
LambdaExpr
>
(
"
lambdaExpr
"
)
)
{
const
CXXMethodDecl
*
OpCall
=
OuterLambda
-
>
getCallOperator
(
)
;
QualType
ReturnTy
=
OpCall
-
>
getReturnType
(
)
;
if
(
const
CXXRecordDecl
*
Record
=
ReturnTy
-
>
getAsCXXRecordDecl
(
)
)
{
Lambda
=
Record
;
}
}
if
(
!
Lambda
|
|
!
Lambda
-
>
isLambda
(
)
)
{
return
;
}
if
(
CheckedDecls
.
count
(
Lambda
)
)
{
return
;
}
CheckedDecls
.
insert
(
Lambda
)
;
for
(
const
LambdaCapture
Capture
:
Lambda
-
>
captures
(
)
)
{
if
(
Capture
.
capturesVariable
(
)
&
&
Capture
.
getCaptureKind
(
)
!
=
LCK_ByRef
)
{
QualType
Pointee
=
Capture
.
getCapturedVar
(
)
-
>
getType
(
)
-
>
getPointeeType
(
)
;
if
(
!
Pointee
.
isNull
(
)
&
&
isClassRefCounted
(
Pointee
)
)
{
Diag
.
Report
(
Capture
.
getLocation
(
)
ErrorID
)
<
<
Capture
.
getCapturedVar
(
)
<
<
Pointee
;
Diag
.
Report
(
Capture
.
getLocation
(
)
NoteID
)
;
return
;
}
}
}
}
void
DiagnosticsMatcher
:
:
ExplicitOperatorBoolChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
bad
implicit
conversion
operator
for
%
0
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
consider
adding
the
explicit
keyword
to
%
0
"
)
;
const
CXXConversionDecl
*
Method
=
Result
.
Nodes
.
getNodeAs
<
CXXConversionDecl
>
(
"
node
"
)
;
const
CXXRecordDecl
*
Clazz
=
Method
-
>
getParent
(
)
;
if
(
!
Method
-
>
isExplicitSpecified
(
)
&
&
!
MozChecker
:
:
hasCustomAnnotation
(
Method
"
moz_implicit
"
)
&
&
!
ASTIsInSystemHeader
(
Method
-
>
getASTContext
(
)
*
Method
)
&
&
isInterestingDeclForImplicitConversion
(
Method
)
)
{
Diag
.
Report
(
Method
-
>
getLocStart
(
)
ErrorID
)
<
<
Clazz
;
Diag
.
Report
(
Method
-
>
getLocStart
(
)
NoteID
)
<
<
"
'
operator
bool
'
"
;
}
}
void
DiagnosticsMatcher
:
:
NoDuplicateRefCntMemberChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
const
CXXRecordDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
decl
"
)
;
const
FieldDecl
*
RefCntMember
=
getClassRefCntMember
(
D
)
;
const
FieldDecl
*
FoundRefCntBase
=
nullptr
;
if
(
!
D
-
>
hasDefinition
(
)
)
return
;
D
=
D
-
>
getDefinition
(
)
;
if
(
!
RefCntMember
&
&
D
-
>
getNumBases
(
)
<
2
)
{
return
;
}
for
(
auto
&
Base
:
D
-
>
bases
(
)
)
{
const
FieldDecl
*
BaseRefCntMember
=
getBaseRefCntMember
(
Base
.
getType
(
)
)
;
if
(
BaseRefCntMember
)
{
if
(
RefCntMember
)
{
unsigned
Error
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Refcounted
record
%
0
has
multiple
mRefCnt
members
"
)
;
unsigned
Note1
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Superclass
%
0
also
has
an
mRefCnt
member
"
)
;
unsigned
Note2
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Consider
using
the
_INHERITED
macros
for
AddRef
and
Release
here
"
)
;
Diag
.
Report
(
D
-
>
getLocStart
(
)
Error
)
<
<
D
;
Diag
.
Report
(
BaseRefCntMember
-
>
getLocStart
(
)
Note1
)
<
<
BaseRefCntMember
-
>
getParent
(
)
;
Diag
.
Report
(
RefCntMember
-
>
getLocStart
(
)
Note2
)
;
}
if
(
FoundRefCntBase
)
{
unsigned
Error
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Refcounted
record
%
0
has
multiple
superclasses
with
mRefCnt
members
"
)
;
unsigned
Note
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Superclass
%
0
has
an
mRefCnt
member
"
)
;
Diag
.
Report
(
D
-
>
getLocStart
(
)
Error
)
<
<
D
;
Diag
.
Report
(
BaseRefCntMember
-
>
getLocStart
(
)
Note
)
<
<
BaseRefCntMember
-
>
getParent
(
)
;
Diag
.
Report
(
FoundRefCntBase
-
>
getLocStart
(
)
Note
)
<
<
FoundRefCntBase
-
>
getParent
(
)
;
}
FoundRefCntBase
=
BaseRefCntMember
;
}
}
}
void
DiagnosticsMatcher
:
:
NeedsNoVTableTypeChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
%
0
cannot
be
instantiated
because
%
1
has
a
VTable
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
bad
instantiation
of
%
0
requested
here
"
)
;
const
ClassTemplateSpecializationDecl
*
Specialization
=
Result
.
Nodes
.
getNodeAs
<
ClassTemplateSpecializationDecl
>
(
"
node
"
)
;
QualType
Offender
;
const
TemplateArgumentList
&
Args
=
Specialization
-
>
getTemplateInstantiationArgs
(
)
;
for
(
unsigned
i
=
0
;
i
<
Args
.
size
(
)
;
+
+
i
)
{
Offender
=
Args
[
i
]
.
getAsType
(
)
;
if
(
typeHasVTable
(
Offender
)
)
{
break
;
}
}
Diag
.
Report
(
Specialization
-
>
getLocStart
(
)
ErrorID
)
<
<
Specialization
<
<
Offender
;
Diag
.
Report
(
Specialization
-
>
getPointOfInstantiation
(
)
NoteID
)
<
<
Specialization
;
}
void
DiagnosticsMatcher
:
:
NonMemMovableTemplateArgChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Cannot
instantiate
%
0
with
non
-
memmovable
template
argument
%
1
"
)
;
unsigned
Note1ID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
instantiation
of
%
0
requested
here
"
)
;
const
ClassTemplateSpecializationDecl
*
Specialization
=
Result
.
Nodes
.
getNodeAs
<
ClassTemplateSpecializationDecl
>
(
"
specialization
"
)
;
SourceLocation
RequestLoc
=
Specialization
-
>
getPointOfInstantiation
(
)
;
const
TemplateArgumentList
&
Args
=
Specialization
-
>
getTemplateInstantiationArgs
(
)
;
for
(
unsigned
i
=
0
;
i
<
Args
.
size
(
)
;
+
+
i
)
{
QualType
ArgType
=
Args
[
i
]
.
getAsType
(
)
;
if
(
NonMemMovable
.
hasEffectiveAnnotation
(
ArgType
)
)
{
Diag
.
Report
(
Specialization
-
>
getLocation
(
)
ErrorID
)
<
<
Specialization
<
<
ArgType
;
Diag
.
Report
(
RequestLoc
Note1ID
)
<
<
Specialization
;
NonMemMovable
.
dumpAnnotationReason
(
Diag
ArgType
RequestLoc
)
;
}
}
}
void
DiagnosticsMatcher
:
:
NonMemMovableMemberChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
class
%
0
cannot
have
non
-
memmovable
member
%
1
of
type
%
2
"
)
;
const
CXXRecordDecl
*
Declaration
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
decl
"
)
;
for
(
const
FieldDecl
*
Field
:
Declaration
-
>
fields
(
)
)
{
QualType
Type
=
Field
-
>
getType
(
)
;
if
(
NonMemMovable
.
hasEffectiveAnnotation
(
Type
)
)
{
Diag
.
Report
(
Field
-
>
getLocation
(
)
ErrorID
)
<
<
Declaration
<
<
Field
<
<
Type
;
NonMemMovable
.
dumpAnnotationReason
(
Diag
Type
Declaration
-
>
getLocation
(
)
)
;
}
}
}
void
DiagnosticsMatcher
:
:
ExplicitImplicitChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
bad
implicit
conversion
constructor
for
%
0
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
consider
adding
the
explicit
keyword
to
the
constructor
"
)
;
const
CXXConstructorDecl
*
Ctor
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructorDecl
>
(
"
ctor
"
)
;
const
CXXRecordDecl
*
Declaration
=
Result
.
Nodes
.
getNodeAs
<
CXXRecordDecl
>
(
"
class
"
)
;
Diag
.
Report
(
Ctor
-
>
getLocation
(
)
ErrorID
)
<
<
Declaration
-
>
getDeclName
(
)
;
Diag
.
Report
(
Ctor
-
>
getLocation
(
)
NoteID
)
;
}
void
DiagnosticsMatcher
:
:
NoAutoTypeChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Cannot
use
auto
to
declare
a
variable
of
type
%
0
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Please
write
out
this
type
explicitly
"
)
;
const
VarDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
VarDecl
>
(
"
node
"
)
;
Diag
.
Report
(
D
-
>
getLocation
(
)
ErrorID
)
<
<
D
-
>
getType
(
)
;
Diag
.
Report
(
D
-
>
getLocation
(
)
NoteID
)
;
}
void
DiagnosticsMatcher
:
:
NoExplicitMoveConstructorChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Move
constructors
may
not
be
marked
explicit
"
)
;
const
CXXConstructorDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructorDecl
>
(
"
node
"
)
;
Diag
.
Report
(
D
-
>
getLocation
(
)
ErrorID
)
;
}
void
DiagnosticsMatcher
:
:
RefCountedCopyConstructorChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Invalid
use
of
compiler
-
provided
copy
constructor
"
"
on
refcounted
type
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
The
default
copy
constructor
also
copies
the
"
"
default
mRefCnt
property
leading
to
reference
"
"
count
imbalance
issues
.
Please
provide
your
own
"
"
copy
constructor
which
only
copies
the
fields
which
"
"
need
to
be
copied
"
)
;
const
CXXConstructExpr
*
E
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructExpr
>
(
"
node
"
)
;
Diag
.
Report
(
E
-
>
getLocation
(
)
ErrorID
)
;
Diag
.
Report
(
E
-
>
getLocation
(
)
NoteID
)
;
}
void
DiagnosticsMatcher
:
:
AssertAssignmentChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
AssignInsteadOfComp
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Forbidden
assignment
in
assert
expression
"
)
;
const
CallExpr
*
FuncCall
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
funcCall
"
)
;
if
(
FuncCall
&
&
hasSideEffectAssignment
(
FuncCall
)
)
{
Diag
.
Report
(
FuncCall
-
>
getLocStart
(
)
AssignInsteadOfComp
)
;
}
}
void
DiagnosticsMatcher
:
:
KungFuDeathGripChecker
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
DiagnosticsEngine
&
Diag
=
Result
.
Context
-
>
getDiagnostics
(
)
;
unsigned
ErrorID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Error
"
Unused
\
"
kungFuDeathGrip
\
"
%
0
objects
constructed
from
%
1
are
prohibited
"
)
;
unsigned
NoteID
=
Diag
.
getDiagnosticIDs
(
)
-
>
getCustomDiagID
(
DiagnosticIDs
:
:
Note
"
Please
switch
all
accesses
to
this
%
0
to
go
through
'
%
1
'
or
explicitly
pass
'
%
1
'
to
mozilla
:
:
Unused
"
)
;
const
VarDecl
*
D
=
Result
.
Nodes
.
getNodeAs
<
VarDecl
>
(
"
decl
"
)
;
if
(
D
-
>
isReferenced
(
)
|
|
!
D
-
>
hasLocalStorage
(
)
|
|
!
D
-
>
hasInit
(
)
)
{
return
;
}
if
(
isa
<
ImplicitParamDecl
>
(
D
)
|
|
isa
<
ParmVarDecl
>
(
D
)
)
{
return
;
}
const
Expr
*
E
=
IgnoreImplicit
(
D
-
>
getInit
(
)
)
;
const
CXXConstructExpr
*
CE
=
dyn_cast
<
CXXConstructExpr
>
(
E
)
;
if
(
CE
&
&
CE
-
>
getNumArgs
(
)
=
=
0
)
{
return
;
}
while
(
(
CE
=
dyn_cast
<
CXXConstructExpr
>
(
E
)
)
&
&
CE
-
>
getNumArgs
(
)
=
=
1
)
{
E
=
IgnoreImplicit
(
CE
-
>
getArg
(
0
)
)
;
}
if
(
isa
<
CXXThisExpr
>
(
E
)
|
|
isa
<
DeclRefExpr
>
(
E
)
|
|
isa
<
CXXNewExpr
>
(
E
)
)
{
return
;
}
const
TagDecl
*
TD
=
E
-
>
getType
(
)
-
>
getAsTagDecl
(
)
;
if
(
TD
&
&
TD
-
>
getIdentifier
(
)
)
{
static
const
char
*
IgnoreTypes
[
]
=
{
"
already_AddRefed
"
"
nsGetServiceByCID
"
"
nsGetServiceByCIDWithError
"
"
nsGetServiceByContractID
"
"
nsGetServiceByContractIDWithError
"
"
nsCreateInstanceByCID
"
"
nsCreateInstanceByContractID
"
"
nsCreateInstanceFromFactory
"
}
;
for
(
uint32_t
i
=
0
;
i
<
sizeof
(
IgnoreTypes
)
/
sizeof
(
IgnoreTypes
[
0
]
)
;
+
+
i
)
{
if
(
TD
-
>
getName
(
)
=
=
IgnoreTypes
[
i
]
)
{
return
;
}
}
}
const
char
*
ErrThing
;
const
char
*
NoteThing
;
if
(
isa
<
MemberExpr
>
(
E
)
)
{
ErrThing
=
"
members
"
;
NoteThing
=
"
member
"
;
}
else
{
ErrThing
=
"
temporary
values
"
;
NoteThing
=
"
value
"
;
}
Diag
.
Report
(
D
-
>
getLocStart
(
)
ErrorID
)
<
<
D
-
>
getType
(
)
<
<
ErrThing
;
Diag
.
Report
(
E
-
>
getLocStart
(
)
NoteID
)
<
<
NoteThing
<
<
getNameChecked
(
D
)
;
}
class
MozCheckAction
:
public
PluginASTAction
{
public
:
ASTConsumerPtr
CreateASTConsumer
(
CompilerInstance
&
CI
StringRef
FileName
)
override
{
#
if
CLANG_VERSION_FULL
>
=
306
std
:
:
unique_ptr
<
MozChecker
>
Checker
(
llvm
:
:
make_unique
<
MozChecker
>
(
CI
)
)
;
ASTConsumerPtr
Other
(
Checker
-
>
getOtherConsumer
(
)
)
;
std
:
:
vector
<
ASTConsumerPtr
>
Consumers
;
Consumers
.
push_back
(
std
:
:
move
(
Checker
)
)
;
Consumers
.
push_back
(
std
:
:
move
(
Other
)
)
;
return
llvm
:
:
make_unique
<
MultiplexConsumer
>
(
std
:
:
move
(
Consumers
)
)
;
#
else
MozChecker
*
Checker
=
new
MozChecker
(
CI
)
;
ASTConsumer
*
Consumers
[
]
=
{
Checker
Checker
-
>
getOtherConsumer
(
)
}
;
return
new
MultiplexConsumer
(
Consumers
)
;
#
endif
}
bool
ParseArgs
(
const
CompilerInstance
&
CI
const
std
:
:
vector
<
std
:
:
string
>
&
Args
)
override
{
return
true
;
}
}
;
}
static
FrontendPluginRegistry
:
:
Add
<
MozCheckAction
>
X
(
"
moz
-
check
"
"
check
moz
action
"
)
;
#
ifdef
LLVM_EXPORT_REGISTRY
LLVM_EXPORT_REGISTRY
(
FrontendPluginRegistry
)
#
endif
