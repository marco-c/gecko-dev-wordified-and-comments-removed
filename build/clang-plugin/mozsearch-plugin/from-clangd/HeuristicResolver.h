#
ifndef
LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTICRESOLVER_H
#
define
LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTICRESOLVER_H
#
include
"
clang
/
AST
/
Decl
.
h
"
#
include
<
vector
>
namespace
clang
{
class
ASTContext
;
class
CallExpr
;
class
CXXDependentScopeMemberExpr
;
class
DeclarationName
;
class
DependentScopeDeclRefExpr
;
class
NamedDecl
;
class
Type
;
class
UnresolvedUsingValueDecl
;
namespace
clangd
{
class
HeuristicResolver
{
public
:
HeuristicResolver
(
ASTContext
&
Ctx
)
:
Ctx
(
Ctx
)
{
}
std
:
:
vector
<
const
NamedDecl
*
>
resolveMemberExpr
(
const
CXXDependentScopeMemberExpr
*
ME
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveDeclRefExpr
(
const
DependentScopeDeclRefExpr
*
RE
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveTypeOfCallExpr
(
const
CallExpr
*
CE
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveCalleeOfCallExpr
(
const
CallExpr
*
CE
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveUsingValueDecl
(
const
UnresolvedUsingValueDecl
*
UUVD
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveDependentNameType
(
const
DependentNameType
*
DNT
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveTemplateSpecializationType
(
const
DependentTemplateSpecializationType
*
DTST
)
const
;
const
Type
*
resolveNestedNameSpecifierToType
(
const
NestedNameSpecifier
*
NNS
)
const
;
const
Type
*
getPointeeType
(
const
Type
*
T
)
const
;
private
:
ASTContext
&
Ctx
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveDependentMember
(
const
Type
*
T
DeclarationName
Name
llvm
:
:
function_ref
<
bool
(
const
NamedDecl
*
ND
)
>
Filter
)
const
;
const
Type
*
resolveExprToType
(
const
Expr
*
E
)
const
;
std
:
:
vector
<
const
NamedDecl
*
>
resolveExprToDecls
(
const
Expr
*
E
)
const
;
}
;
}
}
#
endif
