#
include
"
JSONFormatter
.
h
"
#
include
<
algorithm
>
#
include
<
cassert
>
#
include
<
string
.
h
>
static
std
:
:
string
replaceAll
(
std
:
:
string
Mangled
std
:
:
string
Pattern
std
:
:
string
Replacement
)
{
size_t
Pos
=
0
;
while
(
(
Pos
=
Mangled
.
find
(
Pattern
Pos
)
)
!
=
std
:
:
string
:
:
npos
)
{
Mangled
=
Mangled
.
replace
(
Pos
Pattern
.
length
(
)
Replacement
)
;
Pos
+
=
Replacement
.
length
(
)
;
}
return
Mangled
;
}
std
:
:
string
JSONFormatter
:
:
escape
(
std
:
:
string
Input
)
{
bool
NeedsEscape
=
false
;
for
(
char
C
:
Input
)
{
if
(
C
=
=
'
\
\
'
|
|
C
=
=
'
"
'
|
|
C
<
32
|
|
C
>
126
)
{
NeedsEscape
=
true
;
break
;
}
}
if
(
!
NeedsEscape
)
{
return
Input
;
}
std
:
:
string
Cur
=
Input
;
Cur
=
replaceAll
(
Cur
"
\
\
"
"
\
\
\
\
"
)
;
Cur
=
replaceAll
(
Cur
"
\
"
"
"
\
\
\
"
"
)
;
Cur
=
replaceAll
(
Cur
"
\
t
"
"
\
\
t
"
)
;
Cur
=
replaceAll
(
Cur
"
\
r
\
n
"
"
\
\
n
"
)
;
Cur
=
replaceAll
(
Cur
"
\
n
"
"
\
\
n
"
)
;
Cur
.
erase
(
std
:
:
remove_if
(
Cur
.
begin
(
)
Cur
.
end
(
)
[
]
(
char
C
)
{
return
C
<
32
|
|
C
>
126
;
}
)
Cur
.
end
(
)
)
;
return
Cur
;
}
void
JSONFormatter
:
:
add
(
const
char
*
Name
const
char
*
Value
)
{
assert
(
PropertyCount
<
kMaxProperties
)
;
Properties
[
PropertyCount
]
=
Property
(
Name
std
:
:
string
(
Value
)
)
;
PropertyCount
+
+
;
Length
+
=
strlen
(
Name
)
+
3
+
strlen
(
Value
)
+
2
+
1
;
}
void
JSONFormatter
:
:
add
(
const
char
*
Name
std
:
:
string
Value
)
{
std
:
:
string
Escaped
=
escape
(
std
:
:
move
(
Value
)
)
;
Length
+
=
strlen
(
Name
)
+
3
+
Escaped
.
length
(
)
+
2
+
1
;
assert
(
PropertyCount
<
kMaxProperties
)
;
Properties
[
PropertyCount
]
=
Property
(
Name
std
:
:
move
(
Escaped
)
)
;
PropertyCount
+
+
;
}
void
JSONFormatter
:
:
add
(
const
char
*
Name
int
Value
)
{
assert
(
Value
>
=
0
&
&
Value
<
10
)
;
assert
(
PropertyCount
<
kMaxProperties
)
;
Properties
[
PropertyCount
]
=
Property
(
Name
Value
)
;
PropertyCount
+
+
;
Length
+
=
strlen
(
Name
)
+
3
+
2
;
}
void
JSONFormatter
:
:
format
(
std
:
:
string
&
Result
)
{
Result
.
reserve
(
Length
+
2
)
;
Result
.
push_back
(
'
{
'
)
;
for
(
int
I
=
0
;
I
<
PropertyCount
;
I
+
+
)
{
Result
.
push_back
(
'
"
'
)
;
Result
.
append
(
Properties
[
I
]
.
Name
)
;
Result
.
push_back
(
'
"
'
)
;
Result
.
push_back
(
'
:
'
)
;
if
(
Properties
[
I
]
.
IsString
)
{
Result
.
push_back
(
'
"
'
)
;
Result
.
append
(
Properties
[
I
]
.
StringValue
)
;
Result
.
push_back
(
'
"
'
)
;
}
else
{
Result
.
push_back
(
Properties
[
I
]
.
IntValue
+
'
0
'
)
;
}
if
(
I
+
1
!
=
PropertyCount
)
{
Result
.
push_back
(
'
'
)
;
}
}
Result
.
push_back
(
'
}
'
)
;
Result
.
push_back
(
'
\
n
'
)
;
assert
(
Result
.
length
(
)
=
=
Length
+
2
)
;
}
