#
include
"
clang
/
AST
/
AST
.
h
"
#
include
"
clang
/
AST
/
ASTConsumer
.
h
"
#
include
"
clang
/
AST
/
ASTContext
.
h
"
#
include
"
clang
/
AST
/
Expr
.
h
"
#
include
"
clang
/
AST
/
ExprCXX
.
h
"
#
include
"
clang
/
AST
/
Mangle
.
h
"
#
include
"
clang
/
AST
/
RecordLayout
.
h
"
#
include
"
clang
/
AST
/
RecursiveASTVisitor
.
h
"
#
include
"
clang
/
Basic
/
FileManager
.
h
"
#
include
"
clang
/
Basic
/
SourceManager
.
h
"
#
include
"
clang
/
Basic
/
Version
.
h
"
#
include
"
clang
/
Frontend
/
CompilerInstance
.
h
"
#
include
"
clang
/
Frontend
/
FrontendPluginRegistry
.
h
"
#
include
"
clang
/
Lex
/
Lexer
.
h
"
#
include
"
clang
/
Lex
/
PPCallbacks
.
h
"
#
include
"
clang
/
Lex
/
Preprocessor
.
h
"
#
include
"
llvm
/
ADT
/
SmallString
.
h
"
#
include
"
llvm
/
Support
/
JSON
.
h
"
#
include
"
llvm
/
Support
/
raw_ostream
.
h
"
#
include
<
fstream
>
#
include
<
iostream
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
<
string
>
#
include
<
tuple
>
#
include
<
unordered_set
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
FileOperations
.
h
"
#
include
"
StringOperations
.
h
"
#
include
"
from
-
clangd
/
HeuristicResolver
.
h
"
#
if
CLANG_VERSION_MAJOR
<
8
#
define
getBeginLoc
getLocStart
#
define
getEndLoc
getLocEnd
#
endif
#
if
__cplusplus
<
201402L
using
llvm
:
:
make_unique
;
#
else
using
std
:
:
make_unique
;
#
endif
using
namespace
clang
;
const
std
:
:
string
GENERATED
(
"
__GENERATED__
"
PATHSEP_STRING
)
;
std
:
:
string
Srcdir
;
std
:
:
string
Objdir
;
std
:
:
string
Outdir
;
enum
class
FileType
{
Unknown
Source
Generated
}
;
FileType
relativizePath
(
std
:
:
string
&
path
)
{
if
(
path
.
compare
(
0
Objdir
.
length
(
)
Objdir
)
=
=
0
)
{
path
.
replace
(
0
Objdir
.
length
(
)
GENERATED
)
;
return
FileType
:
:
Generated
;
}
if
(
path
.
length
(
)
>
Srcdir
.
length
(
)
&
&
path
.
compare
(
0
Srcdir
.
length
(
)
Srcdir
)
=
=
0
)
{
path
.
erase
(
0
Srcdir
.
length
(
)
+
1
)
;
return
FileType
:
:
Source
;
}
return
FileType
:
:
Unknown
;
}
#
if
!
defined
(
_WIN32
)
&
&
!
defined
(
_WIN64
)
#
include
<
sys
/
time
.
h
>
static
double
time
(
)
{
struct
timeval
Tv
;
gettimeofday
(
&
Tv
nullptr
)
;
return
double
(
Tv
.
tv_sec
)
+
double
(
Tv
.
tv_usec
)
/
1000000
.
;
}
#
endif
static
bool
isValidIdentifier
(
std
:
:
string
Input
)
{
for
(
char
C
:
Input
)
{
if
(
!
(
isalpha
(
C
)
|
|
isdigit
(
C
)
|
|
C
=
=
'
_
'
)
)
{
return
false
;
}
}
return
true
;
}
struct
RAIITracer
{
RAIITracer
(
const
char
*
log
)
:
mLog
(
log
)
{
printf
(
"
<
%
s
>
\
n
"
mLog
)
;
}
~
RAIITracer
(
)
{
printf
(
"
<
/
%
s
>
\
n
"
mLog
)
;
}
const
char
*
mLog
;
}
;
#
define
TRACEFUNC
RAIITracer
tracer
(
__FUNCTION__
)
;
class
IndexConsumer
;
struct
FileInfo
{
FileInfo
(
std
:
:
string
&
Rname
)
:
Realname
(
Rname
)
{
switch
(
relativizePath
(
Realname
)
)
{
case
FileType
:
:
Generated
:
Interesting
=
true
;
Generated
=
true
;
break
;
case
FileType
:
:
Source
:
Interesting
=
true
;
Generated
=
false
;
break
;
case
FileType
:
:
Unknown
:
Interesting
=
false
;
Generated
=
false
;
break
;
}
}
std
:
:
string
Realname
;
std
:
:
vector
<
std
:
:
string
>
Output
;
bool
Interesting
;
bool
Generated
;
}
;
class
IndexConsumer
;
class
PreprocessorHook
:
public
PPCallbacks
{
IndexConsumer
*
Indexer
;
public
:
PreprocessorHook
(
IndexConsumer
*
C
)
:
Indexer
(
C
)
{
}
virtual
void
FileChanged
(
SourceLocation
Loc
FileChangeReason
Reason
SrcMgr
:
:
CharacteristicKind
FileType
FileID
PrevFID
)
override
;
virtual
void
InclusionDirective
(
SourceLocation
HashLoc
const
Token
&
IncludeTok
StringRef
FileName
bool
IsAngled
CharSourceRange
FileNameRange
#
if
CLANG_VERSION_MAJOR
>
=
16
OptionalFileEntryRef
File
#
elif
CLANG_VERSION_MAJOR
>
=
15
Optional
<
FileEntryRef
>
File
#
else
const
FileEntry
*
File
#
endif
StringRef
SearchPath
StringRef
RelativePath
const
Module
*
Imported
SrcMgr
:
:
CharacteristicKind
FileType
)
override
;
virtual
void
MacroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Md
)
override
;
virtual
void
MacroExpands
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
const
MacroArgs
*
Ma
)
override
;
virtual
void
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
const
MacroDirective
*
Undef
)
override
;
virtual
void
Defined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
)
override
;
virtual
void
Ifdef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
override
;
virtual
void
Ifndef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
override
;
}
;
class
IndexConsumer
:
public
ASTConsumer
public
RecursiveASTVisitor
<
IndexConsumer
>
public
DiagnosticConsumer
{
private
:
CompilerInstance
&
CI
;
SourceManager
&
SM
;
LangOptions
&
LO
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
FileMap
;
MangleContext
*
CurMangleContext
;
ASTContext
*
AstContext
;
std
:
:
unique_ptr
<
clangd
:
:
HeuristicResolver
>
Resolver
;
typedef
RecursiveASTVisitor
<
IndexConsumer
>
Super
;
struct
AutoSetContext
{
AutoSetContext
(
IndexConsumer
*
Self
NamedDecl
*
Context
bool
VisitImplicit
=
false
)
:
Self
(
Self
)
Prev
(
Self
-
>
CurDeclContext
)
Decl
(
Context
)
{
this
-
>
VisitImplicit
=
VisitImplicit
|
|
(
Prev
?
Prev
-
>
VisitImplicit
:
false
)
;
Self
-
>
CurDeclContext
=
this
;
}
~
AutoSetContext
(
)
{
Self
-
>
CurDeclContext
=
Prev
;
}
IndexConsumer
*
Self
;
AutoSetContext
*
Prev
;
NamedDecl
*
Decl
;
bool
VisitImplicit
;
}
;
AutoSetContext
*
CurDeclContext
;
FileInfo
*
getFileInfo
(
SourceLocation
Loc
)
{
FileID
Id
=
SM
.
getFileID
(
Loc
)
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
:
:
iterator
It
;
It
=
FileMap
.
find
(
Id
)
;
if
(
It
=
=
FileMap
.
end
(
)
)
{
std
:
:
string
Filename
=
std
:
:
string
(
SM
.
getFilename
(
Loc
)
)
;
std
:
:
string
Absolute
;
if
(
!
Filename
.
empty
(
)
)
{
Absolute
=
getAbsolutePath
(
Filename
)
;
if
(
Absolute
.
empty
(
)
)
{
Absolute
=
Filename
;
}
}
std
:
:
unique_ptr
<
FileInfo
>
Info
=
make_unique
<
FileInfo
>
(
Absolute
)
;
It
=
FileMap
.
insert
(
std
:
:
make_pair
(
Id
std
:
:
move
(
Info
)
)
)
.
first
;
}
return
It
-
>
second
.
get
(
)
;
}
bool
isInterestingLocation
(
SourceLocation
Loc
)
{
if
(
Loc
.
isInvalid
(
)
)
{
return
false
;
}
return
getFileInfo
(
Loc
)
-
>
Interesting
;
}
std
:
:
string
locationToString
(
SourceLocation
Loc
size_t
Length
=
0
)
{
std
:
:
pair
<
FileID
unsigned
>
Pair
=
SM
.
getDecomposedLoc
(
Loc
)
;
bool
IsInvalid
;
unsigned
Line
=
SM
.
getLineNumber
(
Pair
.
first
Pair
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Column
=
SM
.
getColumnNumber
(
Pair
.
first
Pair
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
if
(
Length
)
{
return
stringFormat
(
"
%
05d
:
%
d
-
%
d
"
Line
Column
-
1
Column
-
1
+
Length
)
;
}
else
{
return
stringFormat
(
"
%
05d
:
%
d
"
Line
Column
-
1
)
;
}
}
std
:
:
string
lineRangeToString
(
SourceRange
Range
)
{
std
:
:
pair
<
FileID
unsigned
>
Begin
=
SM
.
getDecomposedLoc
(
Range
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End
=
SM
.
getDecomposedLoc
(
Range
.
getEnd
(
)
)
;
bool
IsInvalid
;
unsigned
Line1
=
SM
.
getLineNumber
(
Begin
.
first
Begin
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Line2
=
SM
.
getLineNumber
(
End
.
first
End
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
return
stringFormat
(
"
%
d
-
%
d
"
Line1
Line2
)
;
}
std
:
:
string
fullRangeToString
(
SourceRange
Range
)
{
std
:
:
pair
<
FileID
unsigned
>
Begin
=
SM
.
getDecomposedLoc
(
Range
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End
=
SM
.
getDecomposedLoc
(
Range
.
getEnd
(
)
)
;
bool
IsInvalid
;
unsigned
Line1
=
SM
.
getLineNumber
(
Begin
.
first
Begin
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Column1
=
SM
.
getColumnNumber
(
Begin
.
first
Begin
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Line2
=
SM
.
getLineNumber
(
End
.
first
End
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Column2
=
SM
.
getColumnNumber
(
End
.
first
End
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
return
stringFormat
(
"
%
d
:
%
d
-
%
d
:
%
d
"
Line1
Column1
-
1
Line2
Column2
-
1
)
;
}
std
:
:
string
getQualifiedName
(
const
NamedDecl
*
D
)
{
const
DeclContext
*
Ctx
=
D
-
>
getDeclContext
(
)
;
if
(
Ctx
-
>
isFunctionOrMethod
(
)
)
{
return
D
-
>
getQualifiedNameAsString
(
)
;
}
std
:
:
vector
<
const
DeclContext
*
>
Contexts
;
while
(
Ctx
&
&
isa
<
NamedDecl
>
(
Ctx
)
)
{
Contexts
.
push_back
(
Ctx
)
;
Ctx
=
Ctx
-
>
getParent
(
)
;
}
std
:
:
string
Result
;
std
:
:
reverse
(
Contexts
.
begin
(
)
Contexts
.
end
(
)
)
;
for
(
const
DeclContext
*
DC
:
Contexts
)
{
if
(
const
auto
*
Spec
=
dyn_cast
<
ClassTemplateSpecializationDecl
>
(
DC
)
)
{
Result
+
=
Spec
-
>
getNameAsString
(
)
;
if
(
Spec
-
>
getSpecializationKind
(
)
=
=
TSK_ExplicitSpecialization
)
{
std
:
:
string
Backing
;
llvm
:
:
raw_string_ostream
Stream
(
Backing
)
;
const
TemplateArgumentList
&
TemplateArgs
=
Spec
-
>
getTemplateArgs
(
)
;
printTemplateArgumentList
(
Stream
TemplateArgs
.
asArray
(
)
PrintingPolicy
(
CI
.
getLangOpts
(
)
)
)
;
Result
+
=
Stream
.
str
(
)
;
}
}
else
if
(
const
auto
*
Nd
=
dyn_cast
<
NamespaceDecl
>
(
DC
)
)
{
if
(
Nd
-
>
isAnonymousNamespace
(
)
|
|
Nd
-
>
isInline
(
)
)
{
continue
;
}
Result
+
=
Nd
-
>
getNameAsString
(
)
;
}
else
if
(
const
auto
*
Rd
=
dyn_cast
<
RecordDecl
>
(
DC
)
)
{
if
(
!
Rd
-
>
getIdentifier
(
)
)
{
Result
+
=
"
(
anonymous
)
"
;
}
else
{
Result
+
=
Rd
-
>
getNameAsString
(
)
;
}
}
else
if
(
const
auto
*
Fd
=
dyn_cast
<
FunctionDecl
>
(
DC
)
)
{
Result
+
=
Fd
-
>
getNameAsString
(
)
;
}
else
if
(
const
auto
*
Ed
=
dyn_cast
<
EnumDecl
>
(
DC
)
)
{
if
(
Ed
-
>
isScoped
(
)
|
|
Ed
-
>
getIdentifier
(
)
)
Result
+
=
Ed
-
>
getNameAsString
(
)
;
else
continue
;
}
else
{
Result
+
=
cast
<
NamedDecl
>
(
DC
)
-
>
getNameAsString
(
)
;
}
Result
+
=
"
:
:
"
;
}
if
(
D
-
>
getDeclName
(
)
)
Result
+
=
D
-
>
getNameAsString
(
)
;
else
Result
+
=
"
(
anonymous
)
"
;
return
Result
;
}
std
:
:
string
mangleLocation
(
SourceLocation
Loc
std
:
:
string
Backup
=
std
:
:
string
(
)
)
{
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
std
:
:
string
Filename
=
F
-
>
Realname
;
if
(
Filename
.
length
(
)
=
=
0
&
&
Backup
.
length
(
)
!
=
0
)
{
return
Backup
;
}
if
(
F
-
>
Generated
)
{
char
*
Platform
=
getenv
(
"
MOZSEARCH_PLATFORM
"
)
;
Filename
=
std
:
:
string
(
Platform
?
Platform
:
"
"
)
+
std
:
:
string
(
"
"
)
+
Filename
;
}
return
hash
(
Filename
+
std
:
:
string
(
"
"
)
+
locationToString
(
Loc
)
)
;
}
bool
isAcceptableSymbolChar
(
char
c
)
{
return
isalpha
(
c
)
|
|
isdigit
(
c
)
|
|
c
=
=
'
_
'
|
|
c
=
=
'
/
'
;
}
std
:
:
string
mangleFile
(
std
:
:
string
Filename
FileType
Type
)
{
for
(
size_t
i
=
0
;
i
<
Filename
.
length
(
)
;
i
+
+
)
{
char
c
=
Filename
[
i
]
;
if
(
isAcceptableSymbolChar
(
c
)
)
{
continue
;
}
char
hex
[
4
]
;
sprintf
(
hex
"
%
02X
"
(
(
int
)
c
)
&
0xFF
)
;
Filename
.
replace
(
i
1
hex
)
;
i
+
=
2
;
}
if
(
Type
=
=
FileType
:
:
Generated
)
{
char
*
Platform
=
getenv
(
"
MOZSEARCH_PLATFORM
"
)
;
Filename
=
std
:
:
string
(
Platform
?
Platform
:
"
"
)
+
std
:
:
string
(
"
"
)
+
Filename
;
}
return
Filename
;
}
std
:
:
string
mangleQualifiedName
(
std
:
:
string
Name
)
{
std
:
:
replace
(
Name
.
begin
(
)
Name
.
end
(
)
'
'
'
_
'
)
;
return
Name
;
}
std
:
:
string
getMangledName
(
clang
:
:
MangleContext
*
Ctx
const
clang
:
:
NamedDecl
*
Decl
)
{
if
(
isa
<
FunctionDecl
>
(
Decl
)
&
&
cast
<
FunctionDecl
>
(
Decl
)
-
>
isExternC
(
)
)
{
return
cast
<
FunctionDecl
>
(
Decl
)
-
>
getNameAsString
(
)
;
}
if
(
isa
<
FunctionDecl
>
(
Decl
)
|
|
isa
<
VarDecl
>
(
Decl
)
)
{
const
DeclContext
*
DC
=
Decl
-
>
getDeclContext
(
)
;
if
(
isa
<
TranslationUnitDecl
>
(
DC
)
|
|
isa
<
NamespaceDecl
>
(
DC
)
|
|
isa
<
LinkageSpecDecl
>
(
DC
)
|
|
isa
<
TagDecl
>
(
DC
)
)
{
llvm
:
:
SmallVector
<
char
512
>
Output
;
llvm
:
:
raw_svector_ostream
Out
(
Output
)
;
#
if
CLANG_VERSION_MAJOR
>
=
11
GlobalDecl
GD
;
if
(
const
CXXConstructorDecl
*
D
=
dyn_cast
<
CXXConstructorDecl
>
(
Decl
)
)
{
GD
=
GlobalDecl
(
D
Ctor_Complete
)
;
}
else
if
(
const
CXXDestructorDecl
*
D
=
dyn_cast
<
CXXDestructorDecl
>
(
Decl
)
)
{
GD
=
GlobalDecl
(
D
Dtor_Complete
)
;
}
else
{
GD
=
GlobalDecl
(
Decl
)
;
}
Ctx
-
>
mangleName
(
GD
Out
)
;
#
else
if
(
const
CXXConstructorDecl
*
D
=
dyn_cast
<
CXXConstructorDecl
>
(
Decl
)
)
{
Ctx
-
>
mangleCXXCtor
(
D
CXXCtorType
:
:
Ctor_Complete
Out
)
;
}
else
if
(
const
CXXDestructorDecl
*
D
=
dyn_cast
<
CXXDestructorDecl
>
(
Decl
)
)
{
Ctx
-
>
mangleCXXDtor
(
D
CXXDtorType
:
:
Dtor_Complete
Out
)
;
}
else
{
Ctx
-
>
mangleName
(
Decl
Out
)
;
}
#
endif
return
Out
.
str
(
)
.
str
(
)
;
}
else
{
return
std
:
:
string
(
"
V_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
+
std
:
:
string
(
"
_
"
)
+
hash
(
std
:
:
string
(
Decl
-
>
getName
(
)
)
)
;
}
}
else
if
(
isa
<
TagDecl
>
(
Decl
)
|
|
isa
<
TypedefNameDecl
>
(
Decl
)
|
|
isa
<
ObjCInterfaceDecl
>
(
Decl
)
)
{
if
(
!
Decl
-
>
getIdentifier
(
)
)
{
return
std
:
:
string
(
"
T_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
;
}
return
std
:
:
string
(
"
T_
"
)
+
mangleQualifiedName
(
getQualifiedName
(
Decl
)
)
;
}
else
if
(
isa
<
NamespaceDecl
>
(
Decl
)
|
|
isa
<
NamespaceAliasDecl
>
(
Decl
)
)
{
if
(
!
Decl
-
>
getIdentifier
(
)
)
{
return
std
:
:
string
(
"
NS_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
;
}
return
std
:
:
string
(
"
NS_
"
)
+
mangleQualifiedName
(
getQualifiedName
(
Decl
)
)
;
}
else
if
(
const
ObjCIvarDecl
*
D2
=
dyn_cast
<
ObjCIvarDecl
>
(
Decl
)
)
{
const
ObjCInterfaceDecl
*
Iface
=
D2
-
>
getContainingInterface
(
)
;
return
std
:
:
string
(
"
F_
<
"
)
+
getMangledName
(
Ctx
Iface
)
+
"
>
_
"
+
D2
-
>
getNameAsString
(
)
;
}
else
if
(
const
FieldDecl
*
D2
=
dyn_cast
<
FieldDecl
>
(
Decl
)
)
{
const
RecordDecl
*
Record
=
D2
-
>
getParent
(
)
;
return
std
:
:
string
(
"
F_
<
"
)
+
getMangledName
(
Ctx
Record
)
+
"
>
_
"
+
D2
-
>
getNameAsString
(
)
;
}
else
if
(
const
EnumConstantDecl
*
D2
=
dyn_cast
<
EnumConstantDecl
>
(
Decl
)
)
{
const
DeclContext
*
DC
=
Decl
-
>
getDeclContext
(
)
;
if
(
const
NamedDecl
*
Named
=
dyn_cast
<
NamedDecl
>
(
DC
)
)
{
return
std
:
:
string
(
"
E_
<
"
)
+
getMangledName
(
Ctx
Named
)
+
"
>
_
"
+
D2
-
>
getNameAsString
(
)
;
}
}
assert
(
false
)
;
return
std
:
:
string
(
"
"
)
;
}
void
debugLocation
(
SourceLocation
Loc
)
{
std
:
:
string
S
=
locationToString
(
Loc
)
;
StringRef
Filename
=
SM
.
getFilename
(
Loc
)
;
printf
(
"
-
-
>
%
s
%
s
\
n
"
std
:
:
string
(
Filename
)
.
c_str
(
)
S
.
c_str
(
)
)
;
}
void
debugRange
(
SourceRange
Range
)
{
printf
(
"
Range
\
n
"
)
;
debugLocation
(
Range
.
getBegin
(
)
)
;
debugLocation
(
Range
.
getEnd
(
)
)
;
}
public
:
IndexConsumer
(
CompilerInstance
&
CI
)
:
CI
(
CI
)
SM
(
CI
.
getSourceManager
(
)
)
LO
(
CI
.
getLangOpts
(
)
)
CurMangleContext
(
nullptr
)
AstContext
(
nullptr
)
CurDeclContext
(
nullptr
)
TemplateStack
(
nullptr
)
{
CI
.
getPreprocessor
(
)
.
addPPCallbacks
(
make_unique
<
PreprocessorHook
>
(
this
)
)
;
}
virtual
DiagnosticConsumer
*
clone
(
DiagnosticsEngine
&
Diags
)
const
{
return
new
IndexConsumer
(
CI
)
;
}
#
if
!
defined
(
_WIN32
)
&
&
!
defined
(
_WIN64
)
struct
AutoTime
{
AutoTime
(
double
*
Counter
)
:
Counter
(
Counter
)
Start
(
time
(
)
)
{
}
~
AutoTime
(
)
{
if
(
Start
)
{
*
Counter
+
=
time
(
)
-
Start
;
}
}
void
stop
(
)
{
*
Counter
+
=
time
(
)
-
Start
;
Start
=
0
;
}
double
*
Counter
;
double
Start
;
}
;
#
endif
virtual
void
HandleTranslationUnit
(
ASTContext
&
Ctx
)
{
CurMangleContext
=
clang
:
:
ItaniumMangleContext
:
:
create
(
Ctx
CI
.
getDiagnostics
(
)
)
;
AstContext
=
&
Ctx
;
Resolver
=
std
:
:
make_unique
<
clangd
:
:
HeuristicResolver
>
(
Ctx
)
;
TraverseDecl
(
Ctx
.
getTranslationUnitDecl
(
)
)
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
:
:
iterator
It
;
for
(
It
=
FileMap
.
begin
(
)
;
It
!
=
FileMap
.
end
(
)
;
It
+
+
)
{
if
(
!
It
-
>
second
-
>
Interesting
)
{
continue
;
}
FileInfo
&
Info
=
*
It
-
>
second
;
std
:
:
string
Filename
=
Outdir
+
Info
.
Realname
;
std
:
:
string
SrcFilename
=
Info
.
Generated
?
Objdir
+
Info
.
Realname
.
substr
(
GENERATED
.
length
(
)
)
:
Srcdir
+
PATHSEP_STRING
+
Info
.
Realname
;
ensurePath
(
Filename
)
;
AutoLockFile
Lock
(
SrcFilename
Filename
)
;
if
(
!
Lock
.
success
(
)
)
{
fprintf
(
stderr
"
Unable
to
lock
file
%
s
\
n
"
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
std
:
:
ifstream
Fin
(
Filename
.
c_str
(
)
std
:
:
ios
:
:
in
|
std
:
:
ios
:
:
binary
)
;
FILE
*
OutFp
=
Lock
.
openTmp
(
)
;
if
(
!
OutFp
)
{
fprintf
(
stderr
"
Unable
to
open
tmp
out
file
for
%
s
\
n
"
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
std
:
:
sort
(
Info
.
Output
.
begin
(
)
Info
.
Output
.
end
(
)
)
;
std
:
:
vector
<
std
:
:
string
>
:
:
const_iterator
NewLinesIter
=
Info
.
Output
.
begin
(
)
;
std
:
:
string
LastNewWritten
;
while
(
Fin
.
good
(
)
)
{
std
:
:
string
OldLine
;
std
:
:
getline
(
Fin
OldLine
)
;
if
(
OldLine
.
length
(
)
=
=
0
)
{
continue
;
}
OldLine
.
push_back
(
'
\
n
'
)
;
for
(
;
NewLinesIter
!
=
Info
.
Output
.
end
(
)
;
NewLinesIter
+
+
)
{
if
(
*
NewLinesIter
>
OldLine
)
{
break
;
}
if
(
*
NewLinesIter
=
=
OldLine
)
{
continue
;
}
if
(
*
NewLinesIter
=
=
LastNewWritten
)
{
continue
;
}
if
(
fwrite
(
NewLinesIter
-
>
c_str
(
)
NewLinesIter
-
>
length
(
)
1
OutFp
)
!
=
1
)
{
fprintf
(
stderr
"
Unable
to
write
%
zu
bytes
[
1
]
to
tmp
output
file
for
%
s
\
n
"
NewLinesIter
-
>
length
(
)
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
LastNewWritten
=
*
NewLinesIter
;
}
if
(
fwrite
(
OldLine
.
c_str
(
)
OldLine
.
length
(
)
1
OutFp
)
!
=
1
)
{
fprintf
(
stderr
"
Unable
to
write
%
zu
bytes
[
2
]
to
tmp
output
file
for
%
s
\
n
"
OldLine
.
length
(
)
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
}
Fin
.
close
(
)
;
for
(
;
NewLinesIter
!
=
Info
.
Output
.
end
(
)
;
NewLinesIter
+
+
)
{
if
(
*
NewLinesIter
=
=
LastNewWritten
)
{
continue
;
}
if
(
fwrite
(
NewLinesIter
-
>
c_str
(
)
NewLinesIter
-
>
length
(
)
1
OutFp
)
!
=
1
)
{
fprintf
(
stderr
"
Unable
to
write
%
zu
bytes
[
3
]
to
tmp
output
file
for
%
s
\
n
"
NewLinesIter
-
>
length
(
)
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
LastNewWritten
=
*
NewLinesIter
;
}
fclose
(
OutFp
)
;
if
(
!
Lock
.
moveTmp
(
)
)
{
fprintf
(
stderr
"
Unable
to
move
tmp
output
file
into
place
for
%
s
(
err
%
d
)
\
n
"
Filename
.
c_str
(
)
errno
)
;
exit
(
1
)
;
}
}
}
bool
TraverseEnumDecl
(
EnumDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseEnumDecl
(
D
)
;
}
bool
TraverseRecordDecl
(
RecordDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseRecordDecl
(
D
)
;
}
bool
TraverseCXXRecordDecl
(
CXXRecordDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseCXXRecordDecl
(
D
)
;
}
bool
TraverseFunctionDecl
(
FunctionDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseFunctionDecl
(
D
)
;
}
bool
TraverseCXXMethodDecl
(
CXXMethodDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXMethodDecl
(
D
)
;
}
bool
TraverseCXXConstructorDecl
(
CXXConstructorDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
true
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXConstructorDecl
(
D
)
;
}
bool
TraverseCXXConversionDecl
(
CXXConversionDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXConversionDecl
(
D
)
;
}
bool
TraverseCXXDestructorDecl
(
CXXDestructorDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXDestructorDecl
(
D
)
;
}
struct
Context
{
std
:
:
string
Name
;
std
:
:
string
Symbol
;
Context
(
)
{
}
Context
(
std
:
:
string
Name
std
:
:
string
Symbol
)
:
Name
(
Name
)
Symbol
(
Symbol
)
{
}
}
;
Context
translateContext
(
NamedDecl
*
D
)
{
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
D
)
;
if
(
F
&
&
F
-
>
isTemplateInstantiation
(
)
)
{
D
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
return
Context
(
D
-
>
getQualifiedNameAsString
(
)
getMangledName
(
CurMangleContext
D
)
)
;
}
Context
getContext
(
SourceLocation
Loc
)
{
if
(
SM
.
isMacroBodyExpansion
(
Loc
)
)
{
return
Context
(
)
;
}
if
(
CurDeclContext
)
{
return
translateContext
(
CurDeclContext
-
>
Decl
)
;
}
return
Context
(
)
;
}
Context
getContext
(
Decl
*
D
)
{
if
(
SM
.
isMacroBodyExpansion
(
D
-
>
getLocation
(
)
)
)
{
return
Context
(
)
;
}
AutoSetContext
*
Ctxt
=
CurDeclContext
;
while
(
Ctxt
)
{
if
(
Ctxt
-
>
Decl
!
=
D
)
{
return
translateContext
(
Ctxt
-
>
Decl
)
;
}
Ctxt
=
Ctxt
-
>
Prev
;
}
return
Context
(
)
;
}
struct
AutoTemplateContext
{
AutoTemplateContext
(
IndexConsumer
*
Self
)
:
Self
(
Self
)
CurMode
(
Self
-
>
TemplateStack
?
Self
-
>
TemplateStack
-
>
CurMode
:
Mode
:
:
GatherDependent
)
Parent
(
Self
-
>
TemplateStack
)
{
Self
-
>
TemplateStack
=
this
;
}
~
AutoTemplateContext
(
)
{
Self
-
>
TemplateStack
=
Parent
;
}
enum
class
Mode
{
GatherDependent
AnalyzeDependent
}
;
void
visitDependent
(
SourceLocation
Loc
)
{
if
(
CurMode
=
=
Mode
:
:
AnalyzeDependent
)
{
return
;
}
DependentLocations
.
insert
(
Loc
.
getRawEncoding
(
)
)
;
if
(
Parent
)
{
Parent
-
>
visitDependent
(
Loc
)
;
}
}
bool
inGatherMode
(
)
{
return
CurMode
=
=
Mode
:
:
GatherDependent
;
}
bool
needsAnalysis
(
)
const
{
if
(
!
DependentLocations
.
empty
(
)
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
needsAnalysis
(
)
;
}
return
false
;
}
void
switchMode
(
)
{
CurMode
=
Mode
:
:
AnalyzeDependent
;
}
bool
shouldVisitTemplateInstantiations
(
)
const
{
if
(
CurMode
=
=
Mode
:
:
AnalyzeDependent
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
shouldVisitTemplateInstantiations
(
)
;
}
return
false
;
}
bool
shouldVisit
(
SourceLocation
Loc
)
{
if
(
CurMode
=
=
Mode
:
:
GatherDependent
)
{
return
true
;
}
if
(
DependentLocations
.
find
(
Loc
.
getRawEncoding
(
)
)
!
=
DependentLocations
.
end
(
)
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
shouldVisit
(
Loc
)
;
}
return
false
;
}
private
:
IndexConsumer
*
Self
;
Mode
CurMode
;
std
:
:
unordered_set
<
unsigned
>
DependentLocations
;
AutoTemplateContext
*
Parent
;
}
;
AutoTemplateContext
*
TemplateStack
;
bool
shouldVisitTemplateInstantiations
(
)
const
{
if
(
TemplateStack
)
{
return
TemplateStack
-
>
shouldVisitTemplateInstantiations
(
)
;
}
return
false
;
}
bool
shouldVisitImplicitCode
(
)
const
{
return
CurDeclContext
&
&
CurDeclContext
-
>
VisitImplicit
;
}
bool
TraverseClassTemplateDecl
(
ClassTemplateDecl
*
D
)
{
AutoTemplateContext
Atc
(
this
)
;
Super
:
:
TraverseClassTemplateDecl
(
D
)
;
if
(
!
Atc
.
needsAnalysis
(
)
)
{
return
true
;
}
Atc
.
switchMode
(
)
;
if
(
D
!
=
D
-
>
getCanonicalDecl
(
)
)
{
return
true
;
}
for
(
auto
*
Spec
:
D
-
>
specializations
(
)
)
{
for
(
auto
*
Rd
:
Spec
-
>
redecls
(
)
)
{
if
(
cast
<
CXXRecordDecl
>
(
Rd
)
-
>
isInjectedClassName
(
)
)
continue
;
TraverseDecl
(
Rd
)
;
}
}
return
true
;
}
bool
TraverseFunctionTemplateDecl
(
FunctionTemplateDecl
*
D
)
{
AutoTemplateContext
Atc
(
this
)
;
if
(
Atc
.
inGatherMode
(
)
)
{
Super
:
:
TraverseFunctionTemplateDecl
(
D
)
;
}
if
(
!
Atc
.
needsAnalysis
(
)
)
{
return
true
;
}
Atc
.
switchMode
(
)
;
if
(
D
!
=
D
-
>
getCanonicalDecl
(
)
)
{
return
true
;
}
for
(
auto
*
Spec
:
D
-
>
specializations
(
)
)
{
for
(
auto
*
Rd
:
Spec
-
>
redecls
(
)
)
{
TraverseDecl
(
Rd
)
;
}
}
return
true
;
}
bool
shouldVisit
(
SourceLocation
Loc
)
{
if
(
TemplateStack
)
{
return
TemplateStack
-
>
shouldVisit
(
Loc
)
;
}
return
true
;
}
enum
{
NoCrossref
=
1
<
<
0
NotIdentifierToken
=
1
<
<
1
LocRangeEndValid
=
1
<
<
2
}
;
void
emitStructuredInfo
(
SourceLocation
Loc
const
RecordDecl
*
decl
)
{
std
:
:
string
json_str
;
llvm
:
:
raw_string_ostream
ros
(
json_str
)
;
llvm
:
:
json
:
:
OStream
J
(
ros
)
;
J
.
objectBegin
(
)
;
unsigned
StartOffset
=
SM
.
getFileOffset
(
Loc
)
;
unsigned
EndOffset
=
StartOffset
+
Lexer
:
:
MeasureTokenLength
(
Loc
SM
CI
.
getLangOpts
(
)
)
;
J
.
attribute
(
"
loc
"
locationToString
(
Loc
EndOffset
-
StartOffset
)
)
;
J
.
attribute
(
"
structured
"
1
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
decl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
decl
)
)
;
J
.
attribute
(
"
kind
"
TypeWithKeyword
:
:
getTagTypeKindName
(
decl
-
>
getTagKind
(
)
)
)
;
const
ASTContext
&
C
=
*
AstContext
;
const
ASTRecordLayout
&
Layout
=
C
.
getASTRecordLayout
(
decl
)
;
J
.
attribute
(
"
sizeBytes
"
Layout
.
getSize
(
)
.
getQuantity
(
)
)
;
auto
cxxDecl
=
dyn_cast
<
CXXRecordDecl
>
(
decl
)
;
if
(
cxxDecl
)
{
J
.
attributeBegin
(
"
supers
"
)
;
J
.
arrayBegin
(
)
;
for
(
const
CXXBaseSpecifier
&
Base
:
cxxDecl
-
>
bases
(
)
)
{
const
CXXRecordDecl
*
BaseDecl
=
Base
.
getType
(
)
-
>
getAsCXXRecordDecl
(
)
;
J
.
objectBegin
(
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
BaseDecl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
BaseDecl
)
)
;
J
.
attributeBegin
(
"
props
"
)
;
J
.
arrayBegin
(
)
;
if
(
Base
.
isVirtual
(
)
)
{
J
.
value
(
"
virtual
"
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
J
.
objectEnd
(
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
J
.
attributeBegin
(
"
methods
"
)
;
J
.
arrayBegin
(
)
;
for
(
const
CXXMethodDecl
*
MethodDecl
:
cxxDecl
-
>
methods
(
)
)
{
J
.
objectBegin
(
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
MethodDecl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
MethodDecl
)
)
;
J
.
attributeBegin
(
"
props
"
)
;
J
.
arrayBegin
(
)
;
if
(
MethodDecl
-
>
isStatic
(
)
)
{
J
.
value
(
"
static
"
)
;
}
if
(
MethodDecl
-
>
isInstance
(
)
)
{
J
.
value
(
"
instance
"
)
;
}
if
(
MethodDecl
-
>
isVirtual
(
)
)
{
J
.
value
(
"
virtual
"
)
;
}
if
(
MethodDecl
-
>
isUserProvided
(
)
)
{
J
.
value
(
"
user
"
)
;
}
if
(
MethodDecl
-
>
isDefaulted
(
)
)
{
J
.
value
(
"
defaulted
"
)
;
}
if
(
MethodDecl
-
>
isDeleted
(
)
)
{
J
.
value
(
"
deleted
"
)
;
}
if
(
MethodDecl
-
>
isConstexpr
(
)
)
{
J
.
value
(
"
constexpr
"
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
J
.
objectEnd
(
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
}
J
.
attributeBegin
(
"
fields
"
)
;
J
.
arrayBegin
(
)
;
uint64_t
iField
=
0
;
for
(
RecordDecl
:
:
field_iterator
It
=
decl
-
>
field_begin
(
)
End
=
decl
-
>
field_end
(
)
;
It
!
=
End
;
+
+
It
+
+
iField
)
{
const
FieldDecl
&
Field
=
*
*
It
;
uint64_t
localOffsetBits
=
Layout
.
getFieldOffset
(
iField
)
;
CharUnits
localOffsetBytes
=
C
.
toCharUnitsFromBits
(
localOffsetBits
)
;
J
.
objectBegin
(
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
&
Field
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
&
Field
)
)
;
QualType
FieldType
=
Field
.
getType
(
)
;
J
.
attribute
(
"
type
"
FieldType
.
getAsString
(
)
)
;
QualType
CanonicalFieldType
=
FieldType
.
getCanonicalType
(
)
;
const
TagDecl
*
tagDecl
=
CanonicalFieldType
-
>
getAsTagDecl
(
)
;
if
(
tagDecl
)
{
J
.
attribute
(
"
typesym
"
getMangledName
(
CurMangleContext
tagDecl
)
)
;
}
J
.
attribute
(
"
offsetBytes
"
localOffsetBytes
.
getQuantity
(
)
)
;
if
(
Field
.
isBitField
(
)
)
{
J
.
attributeBegin
(
"
bitPositions
"
)
;
J
.
objectBegin
(
)
;
J
.
attribute
(
"
begin
"
unsigned
(
localOffsetBits
-
C
.
toBits
(
localOffsetBytes
)
)
)
;
J
.
attribute
(
"
width
"
Field
.
getBitWidthValue
(
C
)
)
;
J
.
objectEnd
(
)
;
J
.
attributeEnd
(
)
;
}
else
{
if
(
auto
FieldRec
=
Field
.
getType
(
)
-
>
getAs
<
RecordType
>
(
)
)
{
auto
const
&
FieldLayout
=
C
.
getASTRecordLayout
(
FieldRec
-
>
getDecl
(
)
)
;
J
.
attribute
(
"
sizeBytes
"
FieldLayout
.
getSize
(
)
.
getQuantity
(
)
)
;
}
else
{
uint64_t
typeSizeBits
=
C
.
getTypeSize
(
Field
.
getType
(
)
)
;
CharUnits
typeSizeBytes
=
C
.
toCharUnitsFromBits
(
typeSizeBits
)
;
J
.
attribute
(
"
sizeBytes
"
typeSizeBytes
.
getQuantity
(
)
)
;
}
}
J
.
objectEnd
(
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
J
.
objectEnd
(
)
;
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
ros
<
<
'
\
n
'
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
ros
.
str
(
)
)
)
;
}
void
emitStructuredInfo
(
SourceLocation
Loc
const
FunctionDecl
*
decl
)
{
std
:
:
string
json_str
;
llvm
:
:
raw_string_ostream
ros
(
json_str
)
;
llvm
:
:
json
:
:
OStream
J
(
ros
)
;
J
.
objectBegin
(
)
;
unsigned
StartOffset
=
SM
.
getFileOffset
(
Loc
)
;
unsigned
EndOffset
=
StartOffset
+
Lexer
:
:
MeasureTokenLength
(
Loc
SM
CI
.
getLangOpts
(
)
)
;
J
.
attribute
(
"
loc
"
locationToString
(
Loc
EndOffset
-
StartOffset
)
)
;
J
.
attribute
(
"
structured
"
1
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
decl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
decl
)
)
;
auto
cxxDecl
=
dyn_cast
<
CXXMethodDecl
>
(
decl
)
;
if
(
cxxDecl
)
{
J
.
attribute
(
"
kind
"
"
method
"
)
;
if
(
auto
parentDecl
=
cxxDecl
-
>
getParent
(
)
)
{
J
.
attribute
(
"
parentsym
"
getMangledName
(
CurMangleContext
parentDecl
)
)
;
}
J
.
attributeBegin
(
"
overrides
"
)
;
J
.
arrayBegin
(
)
;
for
(
const
CXXMethodDecl
*
MethodDecl
:
cxxDecl
-
>
overridden_methods
(
)
)
{
J
.
objectBegin
(
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
MethodDecl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
MethodDecl
)
)
;
J
.
objectEnd
(
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
}
else
{
J
.
attribute
(
"
kind
"
"
function
"
)
;
}
J
.
attributeBegin
(
"
props
"
)
;
J
.
arrayBegin
(
)
;
if
(
cxxDecl
)
{
if
(
cxxDecl
-
>
isStatic
(
)
)
{
J
.
value
(
"
static
"
)
;
}
if
(
cxxDecl
-
>
isInstance
(
)
)
{
J
.
value
(
"
instance
"
)
;
}
if
(
cxxDecl
-
>
isVirtual
(
)
)
{
J
.
value
(
"
virtual
"
)
;
}
if
(
cxxDecl
-
>
isUserProvided
(
)
)
{
J
.
value
(
"
user
"
)
;
}
}
if
(
decl
-
>
isDefaulted
(
)
)
{
J
.
value
(
"
defaulted
"
)
;
}
if
(
decl
-
>
isDeleted
(
)
)
{
J
.
value
(
"
deleted
"
)
;
}
if
(
decl
-
>
isConstexpr
(
)
)
{
J
.
value
(
"
constexpr
"
)
;
}
J
.
arrayEnd
(
)
;
J
.
attributeEnd
(
)
;
J
.
objectEnd
(
)
;
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
ros
<
<
'
\
n
'
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
ros
.
str
(
)
)
)
;
}
void
emitStructuredInfo
(
SourceLocation
Loc
const
FieldDecl
*
decl
)
{
if
(
const
ObjCIvarDecl
*
D2
=
dyn_cast
<
ObjCIvarDecl
>
(
decl
)
)
{
return
;
}
std
:
:
string
json_str
;
llvm
:
:
raw_string_ostream
ros
(
json_str
)
;
llvm
:
:
json
:
:
OStream
J
(
ros
)
;
J
.
objectBegin
(
)
;
unsigned
StartOffset
=
SM
.
getFileOffset
(
Loc
)
;
unsigned
EndOffset
=
StartOffset
+
Lexer
:
:
MeasureTokenLength
(
Loc
SM
CI
.
getLangOpts
(
)
)
;
J
.
attribute
(
"
loc
"
locationToString
(
Loc
EndOffset
-
StartOffset
)
)
;
J
.
attribute
(
"
structured
"
1
)
;
J
.
attribute
(
"
pretty
"
getQualifiedName
(
decl
)
)
;
J
.
attribute
(
"
sym
"
getMangledName
(
CurMangleContext
decl
)
)
;
J
.
attribute
(
"
kind
"
"
field
"
)
;
if
(
auto
parentDecl
=
decl
-
>
getParent
(
)
)
{
J
.
attribute
(
"
parentsym
"
getMangledName
(
CurMangleContext
parentDecl
)
)
;
}
J
.
objectEnd
(
)
;
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
ros
<
<
'
\
n
'
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
ros
.
str
(
)
)
)
;
}
void
visitIdentifier
(
const
char
*
Kind
const
char
*
SyntaxKind
llvm
:
:
StringRef
QualName
SourceRange
LocRange
std
:
:
string
Symbol
QualType
MaybeType
=
QualType
(
)
Context
TokenContext
=
Context
(
)
int
Flags
=
0
SourceRange
PeekRange
=
SourceRange
(
)
SourceRange
NestingRange
=
SourceRange
(
)
)
{
SourceLocation
Loc
=
LocRange
.
getBegin
(
)
;
if
(
!
shouldVisit
(
Loc
)
)
{
return
;
}
unsigned
StartOffset
=
SM
.
getFileOffset
(
Loc
)
;
unsigned
EndOffset
=
(
Flags
&
LocRangeEndValid
)
?
SM
.
getFileOffset
(
LocRange
.
getEnd
(
)
)
:
StartOffset
+
Lexer
:
:
MeasureTokenLength
(
Loc
SM
CI
.
getLangOpts
(
)
)
;
std
:
:
string
LocStr
=
locationToString
(
Loc
EndOffset
-
StartOffset
)
;
std
:
:
string
RangeStr
=
locationToString
(
Loc
EndOffset
-
StartOffset
)
;
std
:
:
string
PeekRangeStr
;
if
(
!
(
Flags
&
NotIdentifierToken
)
)
{
const
char
*
StartChars
=
SM
.
getCharacterData
(
Loc
)
;
std
:
:
string
Text
(
StartChars
EndOffset
-
StartOffset
)
;
if
(
!
isValidIdentifier
(
Text
)
)
{
return
;
}
}
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
if
(
!
(
Flags
&
NoCrossref
)
)
{
std
:
:
string
json_str
;
llvm
:
:
raw_string_ostream
ros
(
json_str
)
;
llvm
:
:
json
:
:
OStream
J
(
ros
)
;
J
.
objectBegin
(
)
;
J
.
attribute
(
"
loc
"
LocStr
)
;
J
.
attribute
(
"
target
"
1
)
;
J
.
attribute
(
"
kind
"
Kind
)
;
J
.
attribute
(
"
pretty
"
QualName
.
data
(
)
)
;
J
.
attribute
(
"
sym
"
Symbol
)
;
if
(
!
TokenContext
.
Name
.
empty
(
)
)
{
J
.
attribute
(
"
context
"
TokenContext
.
Name
)
;
}
if
(
!
TokenContext
.
Symbol
.
empty
(
)
)
{
J
.
attribute
(
"
contextsym
"
TokenContext
.
Symbol
)
;
}
if
(
PeekRange
.
isValid
(
)
)
{
PeekRangeStr
=
lineRangeToString
(
PeekRange
)
;
if
(
!
PeekRangeStr
.
empty
(
)
)
{
J
.
attribute
(
"
peekRange
"
PeekRangeStr
)
;
}
}
J
.
objectEnd
(
)
;
ros
<
<
'
\
n
'
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
ros
.
str
(
)
)
)
;
}
std
:
:
string
json_str
;
llvm
:
:
raw_string_ostream
ros
(
json_str
)
;
llvm
:
:
json
:
:
OStream
J
(
ros
)
;
J
.
objectBegin
(
)
;
J
.
attribute
(
"
loc
"
RangeStr
)
;
J
.
attribute
(
"
source
"
1
)
;
if
(
NestingRange
.
isValid
(
)
)
{
std
:
:
string
NestingRangeStr
=
fullRangeToString
(
NestingRange
)
;
if
(
!
NestingRangeStr
.
empty
(
)
)
{
J
.
attribute
(
"
nestingRange
"
NestingRangeStr
)
;
}
}
std
:
:
string
Syntax
;
if
(
Flags
&
NoCrossref
)
{
J
.
attribute
(
"
syntax
"
"
"
)
;
}
else
{
Syntax
=
Kind
;
Syntax
.
push_back
(
'
'
)
;
Syntax
.
append
(
SyntaxKind
)
;
J
.
attribute
(
"
syntax
"
Syntax
)
;
}
if
(
!
MaybeType
.
isNull
(
)
)
{
J
.
attribute
(
"
type
"
MaybeType
.
getAsString
(
)
)
;
QualType
canonical
=
MaybeType
.
getCanonicalType
(
)
;
const
TagDecl
*
decl
=
canonical
-
>
getAsTagDecl
(
)
;
if
(
decl
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
decl
)
;
J
.
attribute
(
"
typesym
"
Mangled
)
;
}
}
std
:
:
string
Pretty
(
SyntaxKind
)
;
Pretty
.
push_back
(
'
'
)
;
Pretty
.
append
(
QualName
.
data
(
)
)
;
J
.
attribute
(
"
pretty
"
Pretty
)
;
J
.
attribute
(
"
sym
"
Symbol
)
;
if
(
Flags
&
NoCrossref
)
{
J
.
attribute
(
"
no_crossref
"
1
)
;
}
J
.
objectEnd
(
)
;
ros
<
<
'
\
n
'
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
ros
.
str
(
)
)
)
;
}
void
normalizeLocation
(
SourceLocation
*
Loc
)
{
*
Loc
=
SM
.
getSpellingLoc
(
*
Loc
)
;
}
SourceLocation
findLeftBraceFromLoc
(
SourceLocation
Loc
)
{
return
Lexer
:
:
findLocationAfterToken
(
Loc
tok
:
:
l_brace
SM
LO
false
)
;
}
SourceRange
getCompoundStmtRange
(
Stmt
*
D
)
{
if
(
!
D
)
{
return
SourceRange
(
)
;
}
CompoundStmt
*
D2
=
dyn_cast
<
CompoundStmt
>
(
D
)
;
if
(
D2
)
{
return
D2
-
>
getSourceRange
(
)
;
}
return
SourceRange
(
)
;
}
SourceRange
getFunctionPeekRange
(
FunctionDecl
*
D
)
{
SourceLocation
Start
=
D
-
>
getBeginLoc
(
)
;
SourceLocation
End
=
D
-
>
getLocation
(
)
;
std
:
:
pair
<
FileID
unsigned
>
FuncLoc
=
SM
.
getDecomposedLoc
(
End
)
;
for
(
ParmVarDecl
*
Param
:
D
-
>
parameters
(
)
)
{
std
:
:
pair
<
FileID
unsigned
>
ParamLoc
=
SM
.
getDecomposedLoc
(
Param
-
>
getLocation
(
)
)
;
if
(
ParamLoc
.
first
=
=
FuncLoc
.
first
)
{
End
=
Param
-
>
getEndLoc
(
)
;
}
}
return
SourceRange
(
Start
End
)
;
}
SourceRange
getTagPeekRange
(
TagDecl
*
D
)
{
SourceLocation
Start
=
D
-
>
getBeginLoc
(
)
;
SourceLocation
End
=
D
-
>
getLocation
(
)
;
std
:
:
pair
<
FileID
unsigned
>
FuncLoc
=
SM
.
getDecomposedLoc
(
End
)
;
if
(
CXXRecordDecl
*
D2
=
dyn_cast
<
CXXRecordDecl
>
(
D
)
)
{
for
(
CXXBaseSpecifier
&
Base
:
D2
-
>
bases
(
)
)
{
std
:
:
pair
<
FileID
unsigned
>
Loc
=
SM
.
getDecomposedLoc
(
Base
.
getEndLoc
(
)
)
;
if
(
Loc
.
first
=
=
FuncLoc
.
first
)
{
End
=
Base
.
getEndLoc
(
)
;
}
}
}
return
SourceRange
(
Start
End
)
;
}
SourceRange
getCommentRange
(
NamedDecl
*
D
)
{
const
RawComment
*
RC
=
AstContext
-
>
getRawCommentForDeclNoCache
(
D
)
;
if
(
!
RC
)
{
return
SourceRange
(
)
;
}
return
RC
-
>
getSourceRange
(
)
;
}
SourceRange
combineRanges
(
SourceRange
Range1
SourceRange
Range2
)
{
if
(
Range1
.
isInvalid
(
)
)
{
return
Range2
;
}
if
(
Range2
.
isInvalid
(
)
)
{
return
Range1
;
}
std
:
:
pair
<
FileID
unsigned
>
Begin1
=
SM
.
getDecomposedLoc
(
Range1
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End1
=
SM
.
getDecomposedLoc
(
Range1
.
getEnd
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
Begin2
=
SM
.
getDecomposedLoc
(
Range2
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End2
=
SM
.
getDecomposedLoc
(
Range2
.
getEnd
(
)
)
;
if
(
End1
.
first
!
=
Begin2
.
first
)
{
return
Range1
;
}
if
(
Begin1
.
second
<
=
End2
.
second
)
{
return
SourceRange
(
Range1
.
getBegin
(
)
Range2
.
getEnd
(
)
)
;
}
else
{
return
SourceRange
(
Range2
.
getBegin
(
)
Range1
.
getEnd
(
)
)
;
}
}
SourceRange
validateRange
(
SourceLocation
Loc
SourceRange
Range
)
{
std
:
:
pair
<
FileID
unsigned
>
Decomposed
=
SM
.
getDecomposedLoc
(
Loc
)
;
std
:
:
pair
<
FileID
unsigned
>
Begin
=
SM
.
getDecomposedLoc
(
Range
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End
=
SM
.
getDecomposedLoc
(
Range
.
getEnd
(
)
)
;
if
(
Begin
.
first
!
=
Decomposed
.
first
|
|
End
.
first
!
=
Decomposed
.
first
)
{
return
SourceRange
(
)
;
}
if
(
Begin
.
second
>
=
End
.
second
)
{
return
SourceRange
(
)
;
}
return
Range
;
}
bool
VisitNamedDecl
(
NamedDecl
*
D
)
{
SourceLocation
Loc
=
D
-
>
getLocation
(
)
;
SourceLocation
expandedLoc
=
Loc
;
if
(
SM
.
isMacroBodyExpansion
(
Loc
)
)
{
Loc
=
SM
.
getFileLoc
(
Loc
)
;
}
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
if
(
isa
<
ParmVarDecl
>
(
D
)
&
&
!
D
-
>
getDeclName
(
)
.
getAsIdentifierInfo
(
)
)
{
return
true
;
}
int
Flags
=
0
;
const
char
*
Kind
=
"
def
"
;
const
char
*
PrettyKind
=
"
?
"
;
bool
wasTemplate
=
false
;
SourceRange
PeekRange
(
D
-
>
getBeginLoc
(
)
D
-
>
getEndLoc
(
)
)
;
SourceRange
NestingRange
;
if
(
FunctionDecl
*
D2
=
dyn_cast
<
FunctionDecl
>
(
D
)
)
{
if
(
D2
-
>
isTemplateInstantiation
(
)
)
{
wasTemplate
=
true
;
D
=
D2
-
>
getTemplateInstantiationPattern
(
)
;
}
Kind
=
(
D2
-
>
isThisDeclarationADefinition
(
)
|
|
D2
-
>
isPure
(
)
)
?
"
def
"
:
"
decl
"
;
PrettyKind
=
"
function
"
;
PeekRange
=
getFunctionPeekRange
(
D2
)
;
if
(
D2
-
>
isThisDeclarationADefinition
(
)
&
&
!
D2
-
>
isTemplateInstantiation
(
)
)
{
NestingRange
=
getCompoundStmtRange
(
D2
-
>
getBody
(
)
)
;
}
}
else
if
(
TagDecl
*
D2
=
dyn_cast
<
TagDecl
>
(
D
)
)
{
Kind
=
D2
-
>
isThisDeclarationADefinition
(
)
?
"
def
"
:
"
forward
"
;
PrettyKind
=
"
type
"
;
if
(
D2
-
>
isThisDeclarationADefinition
(
)
&
&
D2
-
>
getDefinition
(
)
=
=
D2
)
{
PeekRange
=
getTagPeekRange
(
D2
)
;
NestingRange
=
D2
-
>
getBraceRange
(
)
;
}
else
{
PeekRange
=
SourceRange
(
)
;
}
}
else
if
(
isa
<
TypedefNameDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
type
"
;
PeekRange
=
SourceRange
(
Loc
Loc
)
;
}
else
if
(
VarDecl
*
D2
=
dyn_cast
<
VarDecl
>
(
D
)
)
{
if
(
D2
-
>
isLocalVarDeclOrParm
(
)
)
{
Flags
=
NoCrossref
;
}
Kind
=
D2
-
>
isThisDeclarationADefinition
(
)
=
=
VarDecl
:
:
DeclarationOnly
?
"
decl
"
:
"
def
"
;
PrettyKind
=
"
variable
"
;
}
else
if
(
isa
<
NamespaceDecl
>
(
D
)
|
|
isa
<
NamespaceAliasDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
namespace
"
;
PeekRange
=
SourceRange
(
Loc
Loc
)
;
NamespaceDecl
*
D2
=
dyn_cast
<
NamespaceDecl
>
(
D
)
;
if
(
D2
)
{
NestingRange
=
SourceRange
(
findLeftBraceFromLoc
(
D2
-
>
isAnonymousNamespace
(
)
?
D2
-
>
getBeginLoc
(
)
:
Loc
)
D2
-
>
getRBraceLoc
(
)
)
;
}
}
else
if
(
isa
<
FieldDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
field
"
;
}
else
if
(
isa
<
EnumConstantDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
enum
constant
"
;
}
else
{
return
true
;
}
QualType
qtype
=
QualType
(
)
;
if
(
ValueDecl
*
D2
=
dyn_cast
<
ValueDecl
>
(
D
)
)
{
qtype
=
D2
-
>
getType
(
)
;
}
SourceRange
CommentRange
=
getCommentRange
(
D
)
;
PeekRange
=
combineRanges
(
PeekRange
CommentRange
)
;
PeekRange
=
validateRange
(
Loc
PeekRange
)
;
NestingRange
=
validateRange
(
Loc
NestingRange
)
;
std
:
:
string
Symbol
=
getMangledName
(
CurMangleContext
D
)
;
if
(
isa
<
CXXDestructorDecl
>
(
D
)
)
{
PrettyKind
=
"
destructor
"
;
const
char
*
P
=
SM
.
getCharacterData
(
Loc
)
;
if
(
*
P
=
=
'
~
'
)
{
P
+
+
;
unsigned
Skipped
=
1
;
while
(
*
P
=
=
'
'
|
|
*
P
=
=
'
\
t
'
|
|
*
P
=
=
'
\
r
'
|
|
*
P
=
=
'
\
n
'
)
{
P
+
+
;
Skipped
+
+
;
}
Loc
=
Loc
.
getLocWithOffset
(
Skipped
)
;
}
else
{
P
=
SM
.
getCharacterData
(
expandedLoc
)
;
if
(
*
P
!
=
'
~
'
)
{
return
true
;
}
}
}
visitIdentifier
(
Kind
PrettyKind
getQualifiedName
(
D
)
SourceRange
(
Loc
)
Symbol
qtype
getContext
(
D
)
Flags
PeekRange
NestingRange
)
;
if
(
RecordDecl
*
D2
=
dyn_cast
<
RecordDecl
>
(
D
)
)
{
if
(
D2
-
>
isThisDeclarationADefinition
(
)
&
&
!
D2
-
>
isDependentType
(
)
&
&
!
TemplateStack
)
{
emitStructuredInfo
(
Loc
D2
)
;
}
}
if
(
FunctionDecl
*
D2
=
dyn_cast
<
FunctionDecl
>
(
D
)
)
{
if
(
(
D2
-
>
isThisDeclarationADefinition
(
)
|
|
D2
-
>
isPure
(
)
)
&
&
!
D2
-
>
isTemplateInstantiation
(
)
&
&
!
wasTemplate
&
&
!
D2
-
>
isFunctionTemplateSpecialization
(
)
&
&
!
TemplateStack
)
{
emitStructuredInfo
(
Loc
D2
)
;
}
}
if
(
FieldDecl
*
D2
=
dyn_cast
<
FieldDecl
>
(
D
)
)
{
if
(
!
D2
-
>
isTemplated
(
)
&
&
!
TemplateStack
)
{
emitStructuredInfo
(
Loc
D2
)
;
}
}
return
true
;
}
bool
VisitCXXConstructExpr
(
CXXConstructExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
FunctionDecl
*
Ctor
=
E
-
>
getConstructor
(
)
;
if
(
Ctor
-
>
isTemplateInstantiation
(
)
)
{
Ctor
=
Ctor
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Ctor
)
;
visitIdentifier
(
"
use
"
"
constructor
"
getQualifiedName
(
Ctor
)
Loc
Mangled
QualType
(
)
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitCallExpr
(
CallExpr
*
E
)
{
Decl
*
Callee
=
E
-
>
getCalleeDecl
(
)
;
if
(
!
Callee
|
|
!
FunctionDecl
:
:
classof
(
Callee
)
)
{
return
true
;
}
const
NamedDecl
*
NamedCallee
=
dyn_cast
<
NamedDecl
>
(
Callee
)
;
SourceLocation
Loc
;
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
NamedCallee
)
;
if
(
F
-
>
isTemplateInstantiation
(
)
)
{
NamedCallee
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
NamedCallee
)
;
int
Flags
=
0
;
Expr
*
CalleeExpr
=
E
-
>
getCallee
(
)
-
>
IgnoreParenImpCasts
(
)
;
if
(
CXXOperatorCallExpr
:
:
classof
(
E
)
)
{
CXXOperatorCallExpr
*
Op
=
dyn_cast
<
CXXOperatorCallExpr
>
(
E
)
;
Loc
=
Op
-
>
getOperatorLoc
(
)
;
Flags
|
=
NotIdentifierToken
;
}
else
if
(
MemberExpr
:
:
classof
(
CalleeExpr
)
)
{
MemberExpr
*
Member
=
dyn_cast
<
MemberExpr
>
(
CalleeExpr
)
;
Loc
=
Member
-
>
getMemberLoc
(
)
;
}
else
if
(
DeclRefExpr
:
:
classof
(
CalleeExpr
)
)
{
return
true
;
}
else
{
return
true
;
}
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
visitIdentifier
(
"
use
"
"
function
"
getQualifiedName
(
NamedCallee
)
Loc
Mangled
E
-
>
getCallReturnType
(
*
AstContext
)
getContext
(
Loc
)
Flags
)
;
return
true
;
}
bool
VisitTagTypeLoc
(
TagTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
TagDecl
*
Decl
=
L
.
getDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
L
.
getType
(
)
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitTypedefTypeLoc
(
TypedefTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
NamedDecl
*
Decl
=
L
.
getTypedefNameDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
L
.
getType
(
)
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitInjectedClassNameTypeLoc
(
InjectedClassNameTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
NamedDecl
*
Decl
=
L
.
getDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
L
.
getType
(
)
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitTemplateSpecializationTypeLoc
(
TemplateSpecializationTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
TemplateDecl
*
Td
=
L
.
getTypePtr
(
)
-
>
getTemplateName
(
)
.
getAsTemplateDecl
(
)
;
if
(
ClassTemplateDecl
*
D
=
dyn_cast
<
ClassTemplateDecl
>
(
Td
)
)
{
NamedDecl
*
Decl
=
D
-
>
getTemplatedDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
QualType
(
)
getContext
(
Loc
)
)
;
}
else
if
(
TypeAliasTemplateDecl
*
D
=
dyn_cast
<
TypeAliasTemplateDecl
>
(
Td
)
)
{
NamedDecl
*
Decl
=
D
-
>
getTemplatedDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
QualType
(
)
getContext
(
Loc
)
)
;
}
return
true
;
}
bool
VisitDeclRefExpr
(
DeclRefExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getExprLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
if
(
E
-
>
hasQualifier
(
)
)
{
Loc
=
E
-
>
getNameInfo
(
)
.
getLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
}
NamedDecl
*
Decl
=
E
-
>
getDecl
(
)
;
if
(
const
VarDecl
*
D2
=
dyn_cast
<
VarDecl
>
(
Decl
)
)
{
int
Flags
=
0
;
if
(
D2
-
>
isLocalVarDeclOrParm
(
)
)
{
Flags
=
NoCrossref
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
variable
"
getQualifiedName
(
Decl
)
Loc
Mangled
D2
-
>
getType
(
)
getContext
(
Loc
)
Flags
)
;
}
else
if
(
isa
<
FunctionDecl
>
(
Decl
)
)
{
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
Decl
)
;
if
(
F
-
>
isTemplateInstantiation
(
)
)
{
Decl
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
function
"
getQualifiedName
(
Decl
)
Loc
Mangled
E
-
>
getType
(
)
getContext
(
Loc
)
)
;
}
else
if
(
isa
<
EnumConstantDecl
>
(
Decl
)
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
enum
"
getQualifiedName
(
Decl
)
Loc
Mangled
E
-
>
getType
(
)
getContext
(
Loc
)
)
;
}
return
true
;
}
bool
VisitCXXConstructorDecl
(
CXXConstructorDecl
*
D
)
{
if
(
!
isInterestingLocation
(
D
-
>
getLocation
(
)
)
)
{
return
true
;
}
for
(
CXXConstructorDecl
:
:
init_const_iterator
It
=
D
-
>
init_begin
(
)
;
It
!
=
D
-
>
init_end
(
)
;
+
+
It
)
{
const
CXXCtorInitializer
*
Ci
=
*
It
;
if
(
!
Ci
-
>
getMember
(
)
|
|
!
Ci
-
>
isWritten
(
)
)
{
continue
;
}
SourceLocation
Loc
=
Ci
-
>
getMemberLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
continue
;
}
FieldDecl
*
Member
=
Ci
-
>
getMember
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Member
)
;
visitIdentifier
(
"
use
"
"
field
"
getQualifiedName
(
Member
)
Loc
Mangled
Member
-
>
getType
(
)
getContext
(
D
)
)
;
}
return
true
;
}
bool
VisitMemberExpr
(
MemberExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getExprLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
ValueDecl
*
Decl
=
E
-
>
getMemberDecl
(
)
;
if
(
FieldDecl
*
Field
=
dyn_cast
<
FieldDecl
>
(
Decl
)
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Field
)
;
visitIdentifier
(
"
use
"
"
field
"
getQualifiedName
(
Field
)
Loc
Mangled
Field
-
>
getType
(
)
getContext
(
Loc
)
)
;
}
return
true
;
}
void
visitHeuristicResult
(
SourceLocation
Loc
const
NamedDecl
*
ND
)
{
if
(
const
TemplateDecl
*
TD
=
dyn_cast
<
TemplateDecl
>
(
ND
)
)
{
ND
=
TD
-
>
getTemplatedDecl
(
)
;
}
QualType
MaybeType
;
const
char
*
SyntaxKind
=
nullptr
;
if
(
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
ND
)
)
{
MaybeType
=
F
-
>
getType
(
)
;
SyntaxKind
=
"
function
"
;
}
else
if
(
const
FieldDecl
*
F
=
dyn_cast
<
FieldDecl
>
(
ND
)
)
{
MaybeType
=
F
-
>
getType
(
)
;
SyntaxKind
=
"
field
"
;
}
else
if
(
const
EnumConstantDecl
*
E
=
dyn_cast
<
EnumConstantDecl
>
(
ND
)
)
{
MaybeType
=
E
-
>
getType
(
)
;
SyntaxKind
=
"
enum
"
;
}
if
(
SyntaxKind
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
ND
)
;
visitIdentifier
(
"
use
"
SyntaxKind
getQualifiedName
(
ND
)
Loc
Mangled
MaybeType
getContext
(
Loc
)
)
;
}
}
bool
VisitOverloadExpr
(
OverloadExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getExprLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
for
(
auto
*
Candidate
:
E
-
>
decls
(
)
)
{
visitHeuristicResult
(
Loc
Candidate
)
;
}
return
true
;
}
bool
VisitCXXDependentScopeMemberExpr
(
CXXDependentScopeMemberExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getMemberLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
for
(
const
NamedDecl
*
D
:
Resolver
-
>
resolveMemberExpr
(
E
)
)
{
visitHeuristicResult
(
Loc
D
)
;
}
if
(
TemplateStack
)
{
TemplateStack
-
>
visitDependent
(
Loc
)
;
}
return
true
;
}
bool
VisitDependentScopeDeclRefExpr
(
DependentScopeDeclRefExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
for
(
const
NamedDecl
*
D
:
Resolver
-
>
resolveDeclRefExpr
(
E
)
)
{
visitHeuristicResult
(
Loc
D
)
;
}
return
true
;
}
void
enterSourceFile
(
SourceLocation
Loc
)
{
normalizeLocation
(
&
Loc
)
;
FileInfo
*
newFile
=
getFileInfo
(
Loc
)
;
if
(
!
newFile
-
>
Interesting
)
{
return
;
}
FileType
type
=
newFile
-
>
Generated
?
FileType
:
:
Generated
:
FileType
:
:
Source
;
std
:
:
string
symbol
=
std
:
:
string
(
"
FILE_
"
)
+
mangleFile
(
newFile
-
>
Realname
type
)
;
visitIdentifier
(
"
def
"
"
file
"
newFile
-
>
Realname
SourceRange
(
Loc
)
symbol
QualType
(
)
Context
(
)
NotIdentifierToken
|
LocRangeEndValid
)
;
}
void
inclusionDirective
(
SourceRange
FileNameRange
const
FileEntry
*
File
)
{
std
:
:
string
includedFile
(
File
-
>
tryGetRealPathName
(
)
)
;
FileType
type
=
relativizePath
(
includedFile
)
;
if
(
type
=
=
FileType
:
:
Unknown
)
{
return
;
}
std
:
:
string
symbol
=
std
:
:
string
(
"
FILE_
"
)
+
mangleFile
(
includedFile
type
)
;
visitIdentifier
(
"
use
"
"
file
"
includedFile
FileNameRange
symbol
QualType
(
)
Context
(
)
NotIdentifierToken
|
LocRangeEndValid
)
;
}
void
macroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Macro
)
{
if
(
Macro
-
>
getMacroInfo
(
)
-
>
isBuiltinMacro
(
)
)
{
return
;
}
SourceLocation
Loc
=
Tok
.
getLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
;
}
IdentifierInfo
*
Ident
=
Tok
.
getIdentifierInfo
(
)
;
if
(
Ident
)
{
std
:
:
string
Mangled
=
std
:
:
string
(
"
M_
"
)
+
mangleLocation
(
Loc
std
:
:
string
(
Ident
-
>
getName
(
)
)
)
;
visitIdentifier
(
"
def
"
"
macro
"
Ident
-
>
getName
(
)
Loc
Mangled
)
;
}
}
void
macroUsed
(
const
Token
&
Tok
const
MacroInfo
*
Macro
)
{
if
(
!
Macro
)
{
return
;
}
if
(
Macro
-
>
isBuiltinMacro
(
)
)
{
return
;
}
SourceLocation
Loc
=
Tok
.
getLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
;
}
IdentifierInfo
*
Ident
=
Tok
.
getIdentifierInfo
(
)
;
if
(
Ident
)
{
std
:
:
string
Mangled
=
std
:
:
string
(
"
M_
"
)
+
mangleLocation
(
Macro
-
>
getDefinitionLoc
(
)
std
:
:
string
(
Ident
-
>
getName
(
)
)
)
;
visitIdentifier
(
"
use
"
"
macro
"
Ident
-
>
getName
(
)
Loc
Mangled
)
;
}
}
}
;
void
PreprocessorHook
:
:
FileChanged
(
SourceLocation
Loc
FileChangeReason
Reason
SrcMgr
:
:
CharacteristicKind
FileType
FileID
PrevFID
=
FileID
(
)
)
{
switch
(
Reason
)
{
case
PPCallbacks
:
:
RenameFile
:
case
PPCallbacks
:
:
SystemHeaderPragma
:
break
;
case
PPCallbacks
:
:
EnterFile
:
Indexer
-
>
enterSourceFile
(
Loc
)
;
break
;
case
PPCallbacks
:
:
ExitFile
:
break
;
}
}
void
PreprocessorHook
:
:
InclusionDirective
(
SourceLocation
HashLoc
const
Token
&
IncludeTok
StringRef
FileName
bool
IsAngled
CharSourceRange
FileNameRange
#
if
CLANG_VERSION_MAJOR
>
=
16
OptionalFileEntryRef
File
#
elif
CLANG_VERSION_MAJOR
>
=
15
Optional
<
FileEntryRef
>
File
#
else
const
FileEntry
*
File
#
endif
StringRef
SearchPath
StringRef
RelativePath
const
Module
*
Imported
SrcMgr
:
:
CharacteristicKind
FileType
)
{
#
if
CLANG_VERSION_MAJOR
>
=
15
if
(
!
File
)
{
return
;
}
Indexer
-
>
inclusionDirective
(
FileNameRange
.
getAsRange
(
)
&
File
-
>
getFileEntry
(
)
)
;
#
else
Indexer
-
>
inclusionDirective
(
FileNameRange
.
getAsRange
(
)
File
)
;
#
endif
}
void
PreprocessorHook
:
:
MacroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Md
)
{
Indexer
-
>
macroDefined
(
Tok
Md
)
;
}
void
PreprocessorHook
:
:
MacroExpands
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
const
MacroArgs
*
Ma
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
const
MacroDirective
*
Undef
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Defined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Ifdef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Ifndef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
class
IndexAction
:
public
PluginASTAction
{
protected
:
std
:
:
unique_ptr
<
ASTConsumer
>
CreateASTConsumer
(
CompilerInstance
&
CI
llvm
:
:
StringRef
F
)
{
return
make_unique
<
IndexConsumer
>
(
CI
)
;
}
bool
ParseArgs
(
const
CompilerInstance
&
CI
const
std
:
:
vector
<
std
:
:
string
>
&
Args
)
{
if
(
Args
.
size
(
)
!
=
3
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Need
arguments
for
the
source
output
and
object
directories
"
)
;
D
.
Report
(
DiagID
)
;
return
false
;
}
Srcdir
=
getAbsolutePath
(
Args
[
0
]
)
;
if
(
Srcdir
.
empty
(
)
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Source
directory
'
%
0
'
does
not
exist
"
)
;
D
.
Report
(
DiagID
)
<
<
Args
[
0
]
;
return
false
;
}
ensurePath
(
Args
[
1
]
+
PATHSEP_STRING
)
;
Outdir
=
getAbsolutePath
(
Args
[
1
]
)
;
Outdir
+
=
PATHSEP_STRING
;
Objdir
=
getAbsolutePath
(
Args
[
2
]
)
;
if
(
Objdir
.
empty
(
)
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Objdir
'
%
0
'
does
not
exist
"
)
;
D
.
Report
(
DiagID
)
<
<
Args
[
2
]
;
return
false
;
}
Objdir
+
=
PATHSEP_STRING
;
printf
(
"
MOZSEARCH
:
%
s
%
s
%
s
\
n
"
Srcdir
.
c_str
(
)
Outdir
.
c_str
(
)
Objdir
.
c_str
(
)
)
;
return
true
;
}
void
printHelp
(
llvm
:
:
raw_ostream
&
Ros
)
{
Ros
<
<
"
Help
for
mozsearch
plugin
goes
here
\
n
"
;
}
}
;
static
FrontendPluginRegistry
:
:
Add
<
IndexAction
>
Y
(
"
mozsearch
-
index
"
"
create
the
mozsearch
index
database
"
)
;
