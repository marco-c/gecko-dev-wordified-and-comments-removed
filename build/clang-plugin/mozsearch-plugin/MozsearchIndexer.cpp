#
include
"
clang
/
AST
/
AST
.
h
"
#
include
"
clang
/
AST
/
ASTConsumer
.
h
"
#
include
"
clang
/
AST
/
ASTContext
.
h
"
#
include
"
clang
/
AST
/
Expr
.
h
"
#
include
"
clang
/
AST
/
ExprCXX
.
h
"
#
include
"
clang
/
AST
/
Mangle
.
h
"
#
include
"
clang
/
AST
/
RecursiveASTVisitor
.
h
"
#
include
"
clang
/
Basic
/
SourceManager
.
h
"
#
include
"
clang
/
Basic
/
Version
.
h
"
#
include
"
clang
/
Frontend
/
CompilerInstance
.
h
"
#
include
"
clang
/
Frontend
/
FrontendPluginRegistry
.
h
"
#
include
"
clang
/
Lex
/
Lexer
.
h
"
#
include
"
clang
/
Lex
/
PPCallbacks
.
h
"
#
include
"
clang
/
Lex
/
Preprocessor
.
h
"
#
include
"
llvm
/
ADT
/
SmallString
.
h
"
#
include
"
llvm
/
Support
/
raw_ostream
.
h
"
#
include
<
iostream
>
#
include
<
map
>
#
include
<
memory
>
#
include
<
sstream
>
#
include
<
tuple
>
#
include
<
unordered_set
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
FileOperations
.
h
"
#
include
"
JSONFormatter
.
h
"
#
include
"
StringOperations
.
h
"
using
namespace
clang
;
const
std
:
:
string
GENERATED
(
"
__GENERATED__
"
PATHSEP_STRING
)
;
std
:
:
string
Srcdir
;
std
:
:
string
Objdir
;
std
:
:
string
Outdir
;
#
if
!
defined
(
_WIN32
)
&
&
!
defined
(
_WIN64
)
#
include
<
sys
/
time
.
h
>
static
double
time
(
)
{
struct
timeval
Tv
;
gettimeofday
(
&
Tv
nullptr
)
;
return
double
(
Tv
.
tv_sec
)
+
double
(
Tv
.
tv_usec
)
/
1000000
.
;
}
#
endif
static
bool
isValidIdentifier
(
std
:
:
string
Input
)
{
for
(
char
C
:
Input
)
{
if
(
!
(
isalpha
(
C
)
|
|
isdigit
(
C
)
|
|
C
=
=
'
_
'
)
)
{
return
false
;
}
}
return
true
;
}
struct
RAIITracer
{
RAIITracer
(
const
char
*
log
)
:
mLog
(
log
)
{
printf
(
"
<
%
s
>
\
n
"
mLog
)
;
}
~
RAIITracer
(
)
{
printf
(
"
<
/
%
s
>
\
n
"
mLog
)
;
}
const
char
*
mLog
;
}
;
#
define
TRACEFUNC
RAIITracer
tracer
(
__FUNCTION__
)
;
class
IndexConsumer
;
struct
FileInfo
{
FileInfo
(
std
:
:
string
&
Rname
)
:
Realname
(
Rname
)
{
if
(
Rname
.
compare
(
0
Objdir
.
length
(
)
Objdir
)
=
=
0
)
{
Interesting
=
true
;
Realname
.
replace
(
0
Objdir
.
length
(
)
GENERATED
)
;
return
;
}
Interesting
=
(
Rname
.
length
(
)
>
Srcdir
.
length
(
)
)
&
&
(
Rname
.
compare
(
0
Srcdir
.
length
(
)
Srcdir
)
=
=
0
)
;
if
(
Interesting
)
{
Realname
.
erase
(
0
Srcdir
.
length
(
)
+
1
)
;
}
}
std
:
:
string
Realname
;
std
:
:
vector
<
std
:
:
string
>
Output
;
bool
Interesting
;
}
;
class
IndexConsumer
;
class
PreprocessorHook
:
public
PPCallbacks
{
IndexConsumer
*
Indexer
;
public
:
PreprocessorHook
(
IndexConsumer
*
C
)
:
Indexer
(
C
)
{
}
virtual
void
MacroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Md
)
override
;
virtual
void
MacroExpands
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
const
MacroArgs
*
Ma
)
override
;
#
if
CLANG_VERSION_MAJOR
>
=
5
virtual
void
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
const
MacroDirective
*
Undef
)
override
;
#
else
virtual
void
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
)
override
;
#
endif
virtual
void
Defined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
)
override
;
virtual
void
Ifdef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
override
;
virtual
void
Ifndef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
override
;
}
;
class
IndexConsumer
:
public
ASTConsumer
public
RecursiveASTVisitor
<
IndexConsumer
>
public
DiagnosticConsumer
{
private
:
CompilerInstance
&
CI
;
SourceManager
&
SM
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
FileMap
;
MangleContext
*
CurMangleContext
;
ASTContext
*
AstContext
;
typedef
RecursiveASTVisitor
<
IndexConsumer
>
Super
;
struct
AutoSetContext
{
AutoSetContext
(
IndexConsumer
*
Self
NamedDecl
*
Context
bool
VisitImplicit
=
false
)
:
Self
(
Self
)
Prev
(
Self
-
>
CurDeclContext
)
Decl
(
Context
)
{
this
-
>
VisitImplicit
=
VisitImplicit
|
|
(
Prev
?
Prev
-
>
VisitImplicit
:
false
)
;
Self
-
>
CurDeclContext
=
this
;
}
~
AutoSetContext
(
)
{
Self
-
>
CurDeclContext
=
Prev
;
}
IndexConsumer
*
Self
;
AutoSetContext
*
Prev
;
NamedDecl
*
Decl
;
bool
VisitImplicit
;
}
;
AutoSetContext
*
CurDeclContext
;
FileInfo
*
getFileInfo
(
SourceLocation
Loc
)
{
FileID
Id
=
SM
.
getFileID
(
Loc
)
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
:
:
iterator
It
;
It
=
FileMap
.
find
(
Id
)
;
if
(
It
=
=
FileMap
.
end
(
)
)
{
std
:
:
string
Filename
=
SM
.
getFilename
(
Loc
)
;
std
:
:
string
Absolute
;
if
(
!
Filename
.
empty
(
)
)
{
Absolute
=
getAbsolutePath
(
Filename
)
;
if
(
Absolute
.
empty
(
)
)
{
Absolute
=
Filename
;
}
}
std
:
:
unique_ptr
<
FileInfo
>
Info
=
llvm
:
:
make_unique
<
FileInfo
>
(
Absolute
)
;
It
=
FileMap
.
insert
(
std
:
:
make_pair
(
Id
std
:
:
move
(
Info
)
)
)
.
first
;
}
return
It
-
>
second
.
get
(
)
;
}
bool
isInterestingLocation
(
SourceLocation
Loc
)
{
if
(
Loc
.
isInvalid
(
)
)
{
return
false
;
}
return
getFileInfo
(
Loc
)
-
>
Interesting
;
}
std
:
:
string
locationToString
(
SourceLocation
Loc
size_t
Length
=
0
)
{
std
:
:
pair
<
FileID
unsigned
>
Pair
=
SM
.
getDecomposedLoc
(
Loc
)
;
bool
IsInvalid
;
unsigned
Line
=
SM
.
getLineNumber
(
Pair
.
first
Pair
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Column
=
SM
.
getColumnNumber
(
Pair
.
first
Pair
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
if
(
Length
)
{
return
stringFormat
(
"
%
05d
:
%
d
-
%
d
"
Line
Column
-
1
Column
-
1
+
Length
)
;
}
else
{
return
stringFormat
(
"
%
05d
:
%
d
"
Line
Column
-
1
)
;
}
}
std
:
:
string
lineRangeToString
(
SourceRange
Range
)
{
std
:
:
pair
<
FileID
unsigned
>
Begin
=
SM
.
getDecomposedLoc
(
Range
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End
=
SM
.
getDecomposedLoc
(
Range
.
getEnd
(
)
)
;
bool
IsInvalid
;
unsigned
Line1
=
SM
.
getLineNumber
(
Begin
.
first
Begin
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
unsigned
Line2
=
SM
.
getLineNumber
(
End
.
first
End
.
second
&
IsInvalid
)
;
if
(
IsInvalid
)
{
return
"
"
;
}
return
stringFormat
(
"
%
d
-
%
d
"
Line1
Line2
)
;
}
std
:
:
string
getQualifiedName
(
const
NamedDecl
*
D
)
{
const
DeclContext
*
Ctx
=
D
-
>
getDeclContext
(
)
;
if
(
Ctx
-
>
isFunctionOrMethod
(
)
)
{
return
D
-
>
getQualifiedNameAsString
(
)
;
}
std
:
:
vector
<
const
DeclContext
*
>
Contexts
;
while
(
Ctx
&
&
isa
<
NamedDecl
>
(
Ctx
)
)
{
Contexts
.
push_back
(
Ctx
)
;
Ctx
=
Ctx
-
>
getParent
(
)
;
}
std
:
:
string
Result
;
std
:
:
reverse
(
Contexts
.
begin
(
)
Contexts
.
end
(
)
)
;
for
(
const
DeclContext
*
DC
:
Contexts
)
{
if
(
const
auto
*
Spec
=
dyn_cast
<
ClassTemplateSpecializationDecl
>
(
DC
)
)
{
Result
+
=
Spec
-
>
getNameAsString
(
)
;
if
(
Spec
-
>
getSpecializationKind
(
)
=
=
TSK_ExplicitSpecialization
)
{
std
:
:
string
Backing
;
llvm
:
:
raw_string_ostream
Stream
(
Backing
)
;
const
TemplateArgumentList
&
TemplateArgs
=
Spec
-
>
getTemplateArgs
(
)
;
#
if
CLANG_VERSION_MAJOR
>
5
printTemplateArgumentList
(
Stream
TemplateArgs
.
asArray
(
)
PrintingPolicy
(
CI
.
getLangOpts
(
)
)
)
;
#
elif
CLANG_VERSION_MAJOR
>
3
|
|
\
(
CLANG_VERSION_MAJOR
=
=
3
&
&
CLANG_VERSION_MINOR
>
=
9
)
TemplateSpecializationType
:
:
PrintTemplateArgumentList
(
Stream
TemplateArgs
.
asArray
(
)
PrintingPolicy
(
CI
.
getLangOpts
(
)
)
)
;
#
else
TemplateSpecializationType
:
:
PrintTemplateArgumentList
(
stream
templateArgs
.
data
(
)
templateArgs
.
size
(
)
PrintingPolicy
(
CI
.
getLangOpts
(
)
)
)
;
#
endif
Result
+
=
Stream
.
str
(
)
;
}
}
else
if
(
const
auto
*
Nd
=
dyn_cast
<
NamespaceDecl
>
(
DC
)
)
{
if
(
Nd
-
>
isAnonymousNamespace
(
)
|
|
Nd
-
>
isInline
(
)
)
{
continue
;
}
Result
+
=
Nd
-
>
getNameAsString
(
)
;
}
else
if
(
const
auto
*
Rd
=
dyn_cast
<
RecordDecl
>
(
DC
)
)
{
if
(
!
Rd
-
>
getIdentifier
(
)
)
{
Result
+
=
"
(
anonymous
)
"
;
}
else
{
Result
+
=
Rd
-
>
getNameAsString
(
)
;
}
}
else
if
(
const
auto
*
Fd
=
dyn_cast
<
FunctionDecl
>
(
DC
)
)
{
Result
+
=
Fd
-
>
getNameAsString
(
)
;
}
else
if
(
const
auto
*
Ed
=
dyn_cast
<
EnumDecl
>
(
DC
)
)
{
if
(
Ed
-
>
isScoped
(
)
|
|
Ed
-
>
getIdentifier
(
)
)
Result
+
=
Ed
-
>
getNameAsString
(
)
;
else
continue
;
}
else
{
Result
+
=
cast
<
NamedDecl
>
(
DC
)
-
>
getNameAsString
(
)
;
}
Result
+
=
"
:
:
"
;
}
if
(
D
-
>
getDeclName
(
)
)
Result
+
=
D
-
>
getNameAsString
(
)
;
else
Result
+
=
"
(
anonymous
)
"
;
return
Result
;
}
std
:
:
string
mangleLocation
(
SourceLocation
Loc
std
:
:
string
Backup
=
std
:
:
string
(
)
)
{
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
std
:
:
string
Filename
=
F
-
>
Realname
;
if
(
Filename
.
length
(
)
=
=
0
&
&
Backup
.
length
(
)
!
=
0
)
{
return
Backup
;
}
return
hash
(
Filename
+
std
:
:
string
(
"
"
)
+
locationToString
(
Loc
)
)
;
}
std
:
:
string
mangleQualifiedName
(
std
:
:
string
Name
)
{
std
:
:
replace
(
Name
.
begin
(
)
Name
.
end
(
)
'
'
'
_
'
)
;
return
Name
;
}
std
:
:
string
getMangledName
(
clang
:
:
MangleContext
*
Ctx
const
clang
:
:
NamedDecl
*
Decl
)
{
if
(
isa
<
FunctionDecl
>
(
Decl
)
&
&
cast
<
FunctionDecl
>
(
Decl
)
-
>
isExternC
(
)
)
{
return
cast
<
FunctionDecl
>
(
Decl
)
-
>
getNameAsString
(
)
;
}
if
(
isa
<
FunctionDecl
>
(
Decl
)
|
|
isa
<
VarDecl
>
(
Decl
)
)
{
const
DeclContext
*
DC
=
Decl
-
>
getDeclContext
(
)
;
if
(
isa
<
TranslationUnitDecl
>
(
DC
)
|
|
isa
<
NamespaceDecl
>
(
DC
)
|
|
isa
<
LinkageSpecDecl
>
(
DC
)
|
|
isa
<
TagDecl
>
(
DC
)
)
{
llvm
:
:
SmallVector
<
char
512
>
Output
;
llvm
:
:
raw_svector_ostream
Out
(
Output
)
;
if
(
const
CXXConstructorDecl
*
D
=
dyn_cast
<
CXXConstructorDecl
>
(
Decl
)
)
{
Ctx
-
>
mangleCXXCtor
(
D
CXXCtorType
:
:
Ctor_Complete
Out
)
;
}
else
if
(
const
CXXDestructorDecl
*
D
=
dyn_cast
<
CXXDestructorDecl
>
(
Decl
)
)
{
Ctx
-
>
mangleCXXDtor
(
D
CXXDtorType
:
:
Dtor_Complete
Out
)
;
}
else
{
Ctx
-
>
mangleName
(
Decl
Out
)
;
}
return
Out
.
str
(
)
.
str
(
)
;
}
else
{
return
std
:
:
string
(
"
V_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
+
std
:
:
string
(
"
_
"
)
+
hash
(
Decl
-
>
getName
(
)
)
;
}
}
else
if
(
isa
<
TagDecl
>
(
Decl
)
|
|
isa
<
TypedefNameDecl
>
(
Decl
)
|
|
isa
<
ObjCInterfaceDecl
>
(
Decl
)
)
{
if
(
!
Decl
-
>
getIdentifier
(
)
)
{
return
std
:
:
string
(
"
T_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
;
}
return
std
:
:
string
(
"
T_
"
)
+
mangleQualifiedName
(
getQualifiedName
(
Decl
)
)
;
}
else
if
(
isa
<
NamespaceDecl
>
(
Decl
)
|
|
isa
<
NamespaceAliasDecl
>
(
Decl
)
)
{
if
(
!
Decl
-
>
getIdentifier
(
)
)
{
return
std
:
:
string
(
"
NS_
"
)
+
mangleLocation
(
Decl
-
>
getLocation
(
)
)
;
}
return
std
:
:
string
(
"
NS_
"
)
+
mangleQualifiedName
(
getQualifiedName
(
Decl
)
)
;
}
else
if
(
const
ObjCIvarDecl
*
D2
=
dyn_cast
<
ObjCIvarDecl
>
(
Decl
)
)
{
const
ObjCInterfaceDecl
*
Iface
=
D2
-
>
getContainingInterface
(
)
;
return
std
:
:
string
(
"
F_
<
"
)
+
getMangledName
(
Ctx
Iface
)
+
"
>
_
"
+
D2
-
>
getNameAsString
(
)
;
}
else
if
(
const
FieldDecl
*
D2
=
dyn_cast
<
FieldDecl
>
(
Decl
)
)
{
const
RecordDecl
*
Record
=
D2
-
>
getParent
(
)
;
return
std
:
:
string
(
"
F_
<
"
)
+
getMangledName
(
Ctx
Record
)
+
"
>
_
"
+
toString
(
D2
-
>
getFieldIndex
(
)
)
;
}
else
if
(
const
EnumConstantDecl
*
D2
=
dyn_cast
<
EnumConstantDecl
>
(
Decl
)
)
{
const
DeclContext
*
DC
=
Decl
-
>
getDeclContext
(
)
;
if
(
const
NamedDecl
*
Named
=
dyn_cast
<
NamedDecl
>
(
DC
)
)
{
return
std
:
:
string
(
"
E_
<
"
)
+
getMangledName
(
Ctx
Named
)
+
"
>
_
"
+
D2
-
>
getNameAsString
(
)
;
}
}
assert
(
false
)
;
return
std
:
:
string
(
"
"
)
;
}
void
debugLocation
(
SourceLocation
Loc
)
{
std
:
:
string
S
=
locationToString
(
Loc
)
;
StringRef
Filename
=
SM
.
getFilename
(
Loc
)
;
printf
(
"
-
-
>
%
s
%
s
\
n
"
std
:
:
string
(
Filename
)
.
c_str
(
)
S
.
c_str
(
)
)
;
}
void
debugRange
(
SourceRange
Range
)
{
printf
(
"
Range
\
n
"
)
;
debugLocation
(
Range
.
getBegin
(
)
)
;
debugLocation
(
Range
.
getEnd
(
)
)
;
}
public
:
IndexConsumer
(
CompilerInstance
&
CI
)
:
CI
(
CI
)
SM
(
CI
.
getSourceManager
(
)
)
CurMangleContext
(
nullptr
)
AstContext
(
nullptr
)
CurDeclContext
(
nullptr
)
TemplateStack
(
nullptr
)
{
CI
.
getPreprocessor
(
)
.
addPPCallbacks
(
llvm
:
:
make_unique
<
PreprocessorHook
>
(
this
)
)
;
}
virtual
DiagnosticConsumer
*
clone
(
DiagnosticsEngine
&
Diags
)
const
{
return
new
IndexConsumer
(
CI
)
;
}
#
if
!
defined
(
_WIN32
)
&
&
!
defined
(
_WIN64
)
struct
AutoTime
{
AutoTime
(
double
*
Counter
)
:
Counter
(
Counter
)
Start
(
time
(
)
)
{
}
~
AutoTime
(
)
{
if
(
Start
)
{
*
Counter
+
=
time
(
)
-
Start
;
}
}
void
stop
(
)
{
*
Counter
+
=
time
(
)
-
Start
;
Start
=
0
;
}
double
*
Counter
;
double
Start
;
}
;
#
endif
virtual
void
HandleTranslationUnit
(
ASTContext
&
Ctx
)
{
CurMangleContext
=
clang
:
:
ItaniumMangleContext
:
:
create
(
Ctx
CI
.
getDiagnostics
(
)
)
;
AstContext
=
&
Ctx
;
TraverseDecl
(
Ctx
.
getTranslationUnitDecl
(
)
)
;
std
:
:
map
<
FileID
std
:
:
unique_ptr
<
FileInfo
>
>
:
:
iterator
It
;
for
(
It
=
FileMap
.
begin
(
)
;
It
!
=
FileMap
.
end
(
)
;
It
+
+
)
{
if
(
!
It
-
>
second
-
>
Interesting
)
{
continue
;
}
FileInfo
&
Info
=
*
It
-
>
second
;
std
:
:
string
Filename
=
Outdir
;
Filename
+
=
It
-
>
second
-
>
Realname
;
ensurePath
(
Filename
)
;
AutoLockFile
Lock
(
Filename
)
;
if
(
!
Lock
.
success
(
)
)
{
continue
;
}
std
:
:
vector
<
std
:
:
string
>
Lines
;
char
Buffer
[
65536
]
;
FILE
*
Fp
=
Lock
.
openFile
(
"
r
"
)
;
if
(
!
Fp
)
{
fprintf
(
stderr
"
Unable
to
open
input
file
%
s
\
n
"
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
while
(
fgets
(
Buffer
sizeof
(
Buffer
)
Fp
)
)
{
Lines
.
push_back
(
std
:
:
string
(
Buffer
)
)
;
}
fclose
(
Fp
)
;
Lines
.
insert
(
Lines
.
end
(
)
Info
.
Output
.
begin
(
)
Info
.
Output
.
end
(
)
)
;
std
:
:
sort
(
Lines
.
begin
(
)
Lines
.
end
(
)
)
;
std
:
:
vector
<
std
:
:
string
>
Nodupes
;
std
:
:
unique_copy
(
Lines
.
begin
(
)
Lines
.
end
(
)
std
:
:
back_inserter
(
Nodupes
)
)
;
Fp
=
Lock
.
openFile
(
"
w
"
)
;
if
(
!
Fp
)
{
fprintf
(
stderr
"
Unable
to
open
output
file
%
s
\
n
"
Filename
.
c_str
(
)
)
;
exit
(
1
)
;
}
size_t
Length
=
0
;
for
(
std
:
:
string
&
Line
:
Nodupes
)
{
Length
+
=
Line
.
length
(
)
;
if
(
fwrite
(
Line
.
c_str
(
)
Line
.
length
(
)
1
Fp
)
!
=
1
)
{
fprintf
(
stderr
"
Unable
to
write
to
output
file
%
s
\
n
"
Filename
.
c_str
(
)
)
;
}
}
fclose
(
Fp
)
;
if
(
!
Lock
.
truncateFile
(
Length
)
)
{
return
;
}
}
}
void
findOverriddenMethods
(
const
CXXMethodDecl
*
Method
std
:
:
vector
<
std
:
:
string
>
&
Symbols
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Method
)
;
Symbols
.
push_back
(
Mangled
)
;
CXXMethodDecl
:
:
method_iterator
Iter
=
Method
-
>
begin_overridden_methods
(
)
;
CXXMethodDecl
:
:
method_iterator
End
=
Method
-
>
end_overridden_methods
(
)
;
for
(
;
Iter
!
=
End
;
Iter
+
+
)
{
const
CXXMethodDecl
*
Decl
=
*
Iter
;
if
(
Decl
-
>
isTemplateInstantiation
(
)
)
{
Decl
=
dyn_cast
<
CXXMethodDecl
>
(
Decl
-
>
getTemplateInstantiationPattern
(
)
)
;
}
return
findOverriddenMethods
(
Decl
Symbols
)
;
}
}
bool
TraverseEnumDecl
(
EnumDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseEnumDecl
(
D
)
;
}
bool
TraverseRecordDecl
(
RecordDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseRecordDecl
(
D
)
;
}
bool
TraverseCXXRecordDecl
(
CXXRecordDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
return
Super
:
:
TraverseCXXRecordDecl
(
D
)
;
}
bool
TraverseFunctionDecl
(
FunctionDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseFunctionDecl
(
D
)
;
}
bool
TraverseCXXMethodDecl
(
CXXMethodDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXMethodDecl
(
D
)
;
}
bool
TraverseCXXConstructorDecl
(
CXXConstructorDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
true
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXConstructorDecl
(
D
)
;
}
bool
TraverseCXXConversionDecl
(
CXXConversionDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXConversionDecl
(
D
)
;
}
bool
TraverseCXXDestructorDecl
(
CXXDestructorDecl
*
D
)
{
AutoSetContext
Asc
(
this
D
)
;
const
FunctionDecl
*
Def
;
if
(
TemplateStack
&
&
D
-
>
isDefined
(
Def
)
&
&
Def
&
&
D
!
=
Def
)
{
TraverseFunctionDecl
(
const_cast
<
FunctionDecl
*
>
(
Def
)
)
;
}
return
Super
:
:
TraverseCXXDestructorDecl
(
D
)
;
}
struct
Context
{
std
:
:
string
Name
;
std
:
:
vector
<
std
:
:
string
>
Symbols
;
Context
(
)
{
}
Context
(
std
:
:
string
Name
std
:
:
vector
<
std
:
:
string
>
Symbols
)
:
Name
(
Name
)
Symbols
(
Symbols
)
{
}
}
;
Context
translateContext
(
NamedDecl
*
D
)
{
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
D
)
;
if
(
F
&
&
F
-
>
isTemplateInstantiation
(
)
)
{
D
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
vector
<
std
:
:
string
>
Symbols
=
{
getMangledName
(
CurMangleContext
D
)
}
;
if
(
CXXMethodDecl
:
:
classof
(
D
)
)
{
Symbols
.
clear
(
)
;
findOverriddenMethods
(
dyn_cast
<
CXXMethodDecl
>
(
D
)
Symbols
)
;
}
return
Context
(
D
-
>
getQualifiedNameAsString
(
)
Symbols
)
;
}
Context
getContext
(
SourceLocation
Loc
)
{
if
(
SM
.
isMacroBodyExpansion
(
Loc
)
)
{
return
Context
(
)
;
}
if
(
CurDeclContext
)
{
return
translateContext
(
CurDeclContext
-
>
Decl
)
;
}
return
Context
(
)
;
}
Context
getContext
(
Decl
*
D
)
{
if
(
SM
.
isMacroBodyExpansion
(
D
-
>
getLocation
(
)
)
)
{
return
Context
(
)
;
}
AutoSetContext
*
Ctxt
=
CurDeclContext
;
while
(
Ctxt
)
{
if
(
Ctxt
-
>
Decl
!
=
D
)
{
return
translateContext
(
Ctxt
-
>
Decl
)
;
}
Ctxt
=
Ctxt
-
>
Prev
;
}
return
Context
(
)
;
}
static
std
:
:
string
concatSymbols
(
const
std
:
:
vector
<
std
:
:
string
>
Symbols
)
{
if
(
Symbols
.
empty
(
)
)
{
return
"
"
;
}
size_t
Total
=
0
;
for
(
auto
It
=
Symbols
.
begin
(
)
;
It
!
=
Symbols
.
end
(
)
;
It
+
+
)
{
Total
+
=
It
-
>
length
(
)
;
}
Total
+
=
Symbols
.
size
(
)
-
1
;
std
:
:
string
SymbolList
;
SymbolList
.
reserve
(
Total
)
;
for
(
auto
It
=
Symbols
.
begin
(
)
;
It
!
=
Symbols
.
end
(
)
;
It
+
+
)
{
std
:
:
string
Symbol
=
*
It
;
if
(
It
!
=
Symbols
.
begin
(
)
)
{
SymbolList
.
push_back
(
'
'
)
;
}
SymbolList
.
append
(
Symbol
)
;
}
return
SymbolList
;
}
struct
AutoTemplateContext
{
AutoTemplateContext
(
IndexConsumer
*
Self
)
:
Self
(
Self
)
CurMode
(
Mode
:
:
GatherDependent
)
Parent
(
Self
-
>
TemplateStack
)
{
Self
-
>
TemplateStack
=
this
;
}
~
AutoTemplateContext
(
)
{
Self
-
>
TemplateStack
=
Parent
;
}
enum
class
Mode
{
GatherDependent
AnalyzeDependent
}
;
void
visitDependent
(
SourceLocation
Loc
)
{
if
(
CurMode
=
=
Mode
:
:
AnalyzeDependent
)
{
return
;
}
DependentLocations
.
insert
(
Loc
.
getRawEncoding
(
)
)
;
if
(
Parent
)
{
Parent
-
>
visitDependent
(
Loc
)
;
}
}
bool
needsAnalysis
(
)
const
{
if
(
!
DependentLocations
.
empty
(
)
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
needsAnalysis
(
)
;
}
return
false
;
}
void
switchMode
(
)
{
CurMode
=
Mode
:
:
AnalyzeDependent
;
}
bool
shouldVisitTemplateInstantiations
(
)
const
{
if
(
CurMode
=
=
Mode
:
:
AnalyzeDependent
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
shouldVisitTemplateInstantiations
(
)
;
}
return
false
;
}
bool
shouldVisit
(
SourceLocation
Loc
)
{
if
(
CurMode
=
=
Mode
:
:
GatherDependent
)
{
return
true
;
}
if
(
DependentLocations
.
find
(
Loc
.
getRawEncoding
(
)
)
!
=
DependentLocations
.
end
(
)
)
{
return
true
;
}
if
(
Parent
)
{
return
Parent
-
>
shouldVisit
(
Loc
)
;
}
return
false
;
}
private
:
IndexConsumer
*
Self
;
Mode
CurMode
;
std
:
:
unordered_set
<
unsigned
>
DependentLocations
;
AutoTemplateContext
*
Parent
;
}
;
AutoTemplateContext
*
TemplateStack
;
bool
shouldVisitTemplateInstantiations
(
)
const
{
if
(
TemplateStack
)
{
return
TemplateStack
-
>
shouldVisitTemplateInstantiations
(
)
;
}
return
false
;
}
bool
shouldVisitImplicitCode
(
)
const
{
return
CurDeclContext
&
&
CurDeclContext
-
>
VisitImplicit
;
}
bool
TraverseClassTemplateDecl
(
ClassTemplateDecl
*
D
)
{
AutoTemplateContext
Atc
(
this
)
;
Super
:
:
TraverseClassTemplateDecl
(
D
)
;
if
(
!
Atc
.
needsAnalysis
(
)
)
{
return
true
;
}
Atc
.
switchMode
(
)
;
if
(
D
!
=
D
-
>
getCanonicalDecl
(
)
)
{
return
true
;
}
for
(
auto
*
Spec
:
D
-
>
specializations
(
)
)
{
for
(
auto
*
Rd
:
Spec
-
>
redecls
(
)
)
{
if
(
cast
<
CXXRecordDecl
>
(
Rd
)
-
>
isInjectedClassName
(
)
)
continue
;
TraverseDecl
(
Rd
)
;
}
}
return
true
;
}
bool
TraverseFunctionTemplateDecl
(
FunctionTemplateDecl
*
D
)
{
AutoTemplateContext
Atc
(
this
)
;
Super
:
:
TraverseFunctionTemplateDecl
(
D
)
;
if
(
!
Atc
.
needsAnalysis
(
)
)
{
return
true
;
}
Atc
.
switchMode
(
)
;
if
(
D
!
=
D
-
>
getCanonicalDecl
(
)
)
{
return
true
;
}
for
(
auto
*
Spec
:
D
-
>
specializations
(
)
)
{
for
(
auto
*
Rd
:
Spec
-
>
redecls
(
)
)
{
TraverseDecl
(
Rd
)
;
}
}
return
true
;
}
bool
shouldVisit
(
SourceLocation
Loc
)
{
if
(
TemplateStack
)
{
return
TemplateStack
-
>
shouldVisit
(
Loc
)
;
}
return
true
;
}
enum
{
NoCrossref
=
1
<
<
0
OperatorToken
=
1
<
<
1
}
;
void
visitIdentifier
(
const
char
*
Kind
const
char
*
SyntaxKind
std
:
:
string
QualName
SourceLocation
Loc
const
std
:
:
vector
<
std
:
:
string
>
&
Symbols
Context
TokenContext
=
Context
(
)
int
Flags
=
0
SourceRange
PeekRange
=
SourceRange
(
)
)
{
if
(
!
shouldVisit
(
Loc
)
)
{
return
;
}
unsigned
StartOffset
=
SM
.
getFileOffset
(
Loc
)
;
unsigned
EndOffset
=
StartOffset
+
Lexer
:
:
MeasureTokenLength
(
Loc
SM
CI
.
getLangOpts
(
)
)
;
std
:
:
string
LocStr
=
locationToString
(
Loc
EndOffset
-
StartOffset
)
;
std
:
:
string
RangeStr
=
locationToString
(
Loc
EndOffset
-
StartOffset
)
;
std
:
:
string
PeekRangeStr
;
if
(
!
(
Flags
&
OperatorToken
)
)
{
const
char
*
StartChars
=
SM
.
getCharacterData
(
Loc
)
;
std
:
:
string
Text
(
StartChars
EndOffset
-
StartOffset
)
;
if
(
!
isValidIdentifier
(
Text
)
)
{
return
;
}
}
FileInfo
*
F
=
getFileInfo
(
Loc
)
;
std
:
:
string
SymbolList
;
size_t
Total
=
0
;
for
(
auto
It
=
Symbols
.
begin
(
)
;
It
!
=
Symbols
.
end
(
)
;
It
+
+
)
{
Total
+
=
It
-
>
length
(
)
;
}
Total
+
=
Symbols
.
size
(
)
-
1
;
SymbolList
.
reserve
(
Total
)
;
for
(
auto
It
=
Symbols
.
begin
(
)
;
It
!
=
Symbols
.
end
(
)
;
It
+
+
)
{
std
:
:
string
Symbol
=
*
It
;
if
(
!
(
Flags
&
NoCrossref
)
)
{
JSONFormatter
Fmt
;
Fmt
.
add
(
"
loc
"
LocStr
)
;
Fmt
.
add
(
"
target
"
1
)
;
Fmt
.
add
(
"
kind
"
Kind
)
;
Fmt
.
add
(
"
pretty
"
QualName
)
;
Fmt
.
add
(
"
sym
"
Symbol
)
;
if
(
!
TokenContext
.
Name
.
empty
(
)
)
{
Fmt
.
add
(
"
context
"
TokenContext
.
Name
)
;
}
std
:
:
string
ContextSymbol
=
concatSymbols
(
TokenContext
.
Symbols
)
;
if
(
!
ContextSymbol
.
empty
(
)
)
{
Fmt
.
add
(
"
contextsym
"
ContextSymbol
)
;
}
if
(
PeekRange
.
isValid
(
)
)
{
PeekRangeStr
=
lineRangeToString
(
PeekRange
)
;
if
(
!
PeekRangeStr
.
empty
(
)
)
{
Fmt
.
add
(
"
peekRange
"
PeekRangeStr
)
;
}
}
std
:
:
string
S
;
Fmt
.
format
(
S
)
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
S
)
)
;
}
if
(
It
!
=
Symbols
.
begin
(
)
)
{
SymbolList
.
push_back
(
'
'
)
;
}
SymbolList
.
append
(
Symbol
)
;
}
JSONFormatter
Fmt
;
Fmt
.
add
(
"
loc
"
RangeStr
)
;
Fmt
.
add
(
"
source
"
1
)
;
std
:
:
string
Syntax
;
if
(
Flags
&
NoCrossref
)
{
Fmt
.
add
(
"
syntax
"
"
"
)
;
}
else
{
Syntax
=
Kind
;
Syntax
.
push_back
(
'
'
)
;
Syntax
.
append
(
SyntaxKind
)
;
Fmt
.
add
(
"
syntax
"
Syntax
)
;
}
std
:
:
string
Pretty
(
SyntaxKind
)
;
Pretty
.
push_back
(
'
'
)
;
Pretty
.
append
(
QualName
)
;
Fmt
.
add
(
"
pretty
"
Pretty
)
;
Fmt
.
add
(
"
sym
"
SymbolList
)
;
if
(
Flags
&
NoCrossref
)
{
Fmt
.
add
(
"
no_crossref
"
1
)
;
}
std
:
:
string
Buf
;
Fmt
.
format
(
Buf
)
;
F
-
>
Output
.
push_back
(
std
:
:
move
(
Buf
)
)
;
}
void
visitIdentifier
(
const
char
*
Kind
const
char
*
SyntaxKind
std
:
:
string
QualName
SourceLocation
Loc
std
:
:
string
Symbol
Context
TokenContext
=
Context
(
)
int
Flags
=
0
SourceRange
PeekRange
=
SourceRange
(
)
)
{
std
:
:
vector
<
std
:
:
string
>
V
=
{
Symbol
}
;
visitIdentifier
(
Kind
SyntaxKind
QualName
Loc
V
TokenContext
Flags
PeekRange
)
;
}
void
normalizeLocation
(
SourceLocation
*
Loc
)
{
*
Loc
=
SM
.
getSpellingLoc
(
*
Loc
)
;
}
SourceRange
getFunctionPeekRange
(
FunctionDecl
*
D
)
{
SourceLocation
Start
=
D
-
>
getLocStart
(
)
;
SourceLocation
End
=
D
-
>
getLocation
(
)
;
std
:
:
pair
<
FileID
unsigned
>
FuncLoc
=
SM
.
getDecomposedLoc
(
End
)
;
for
(
ParmVarDecl
*
Param
:
D
-
>
parameters
(
)
)
{
std
:
:
pair
<
FileID
unsigned
>
ParamLoc
=
SM
.
getDecomposedLoc
(
Param
-
>
getLocation
(
)
)
;
if
(
ParamLoc
.
first
=
=
FuncLoc
.
first
)
{
End
=
Param
-
>
getLocEnd
(
)
;
}
}
return
SourceRange
(
Start
End
)
;
}
SourceRange
getTagPeekRange
(
TagDecl
*
D
)
{
SourceLocation
Start
=
D
-
>
getLocStart
(
)
;
SourceLocation
End
=
D
-
>
getLocation
(
)
;
std
:
:
pair
<
FileID
unsigned
>
FuncLoc
=
SM
.
getDecomposedLoc
(
End
)
;
if
(
CXXRecordDecl
*
D2
=
dyn_cast
<
CXXRecordDecl
>
(
D
)
)
{
for
(
CXXBaseSpecifier
&
Base
:
D2
-
>
bases
(
)
)
{
std
:
:
pair
<
FileID
unsigned
>
Loc
=
SM
.
getDecomposedLoc
(
Base
.
getLocEnd
(
)
)
;
if
(
Loc
.
first
=
=
FuncLoc
.
first
)
{
End
=
Base
.
getLocEnd
(
)
;
}
}
}
return
SourceRange
(
Start
End
)
;
}
SourceRange
getCommentRange
(
NamedDecl
*
D
)
{
const
RawComment
*
RC
=
AstContext
-
>
getRawCommentForDeclNoCache
(
D
)
;
if
(
!
RC
)
{
return
SourceRange
(
)
;
}
return
RC
-
>
getSourceRange
(
)
;
}
SourceRange
combineRanges
(
SourceRange
Range1
SourceRange
Range2
)
{
if
(
Range1
.
isInvalid
(
)
)
{
return
Range2
;
}
if
(
Range2
.
isInvalid
(
)
)
{
return
Range1
;
}
std
:
:
pair
<
FileID
unsigned
>
Begin1
=
SM
.
getDecomposedLoc
(
Range1
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End1
=
SM
.
getDecomposedLoc
(
Range1
.
getEnd
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
Begin2
=
SM
.
getDecomposedLoc
(
Range2
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End2
=
SM
.
getDecomposedLoc
(
Range2
.
getEnd
(
)
)
;
if
(
End1
.
first
!
=
Begin2
.
first
)
{
return
Range1
;
}
if
(
Begin1
.
second
<
=
End2
.
second
)
{
return
SourceRange
(
Range1
.
getBegin
(
)
Range2
.
getEnd
(
)
)
;
}
else
{
return
SourceRange
(
Range2
.
getBegin
(
)
Range1
.
getEnd
(
)
)
;
}
}
SourceRange
validateRange
(
SourceLocation
Loc
SourceRange
Range
)
{
std
:
:
pair
<
FileID
unsigned
>
Decomposed
=
SM
.
getDecomposedLoc
(
Loc
)
;
std
:
:
pair
<
FileID
unsigned
>
Begin
=
SM
.
getDecomposedLoc
(
Range
.
getBegin
(
)
)
;
std
:
:
pair
<
FileID
unsigned
>
End
=
SM
.
getDecomposedLoc
(
Range
.
getEnd
(
)
)
;
if
(
Begin
.
first
!
=
Decomposed
.
first
|
|
End
.
first
!
=
Decomposed
.
first
)
{
return
SourceRange
(
)
;
}
if
(
Begin
.
second
>
=
End
.
second
)
{
return
SourceRange
(
)
;
}
return
Range
;
}
bool
VisitNamedDecl
(
NamedDecl
*
D
)
{
SourceLocation
Loc
=
D
-
>
getLocation
(
)
;
if
(
SM
.
isMacroBodyExpansion
(
Loc
)
)
{
Loc
=
SM
.
getFileLoc
(
Loc
)
;
}
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
if
(
isa
<
ParmVarDecl
>
(
D
)
&
&
!
D
-
>
getDeclName
(
)
.
getAsIdentifierInfo
(
)
)
{
return
true
;
}
int
Flags
=
0
;
const
char
*
Kind
=
"
def
"
;
const
char
*
PrettyKind
=
"
?
"
;
SourceRange
PeekRange
(
D
-
>
getLocStart
(
)
D
-
>
getLocEnd
(
)
)
;
if
(
FunctionDecl
*
D2
=
dyn_cast
<
FunctionDecl
>
(
D
)
)
{
if
(
D2
-
>
isTemplateInstantiation
(
)
)
{
D
=
D2
-
>
getTemplateInstantiationPattern
(
)
;
}
Kind
=
D2
-
>
isThisDeclarationADefinition
(
)
?
"
def
"
:
"
decl
"
;
PrettyKind
=
"
function
"
;
PeekRange
=
getFunctionPeekRange
(
D2
)
;
}
else
if
(
TagDecl
*
D2
=
dyn_cast
<
TagDecl
>
(
D
)
)
{
Kind
=
D2
-
>
isThisDeclarationADefinition
(
)
?
"
def
"
:
"
decl
"
;
PrettyKind
=
"
type
"
;
if
(
D2
-
>
isThisDeclarationADefinition
(
)
&
&
D2
-
>
getDefinition
(
)
=
=
D2
)
{
PeekRange
=
getTagPeekRange
(
D2
)
;
}
else
{
PeekRange
=
SourceRange
(
)
;
}
}
else
if
(
isa
<
TypedefNameDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
type
"
;
PeekRange
=
SourceRange
(
Loc
Loc
)
;
}
else
if
(
VarDecl
*
D2
=
dyn_cast
<
VarDecl
>
(
D
)
)
{
if
(
D2
-
>
isLocalVarDeclOrParm
(
)
)
{
Flags
=
NoCrossref
;
}
Kind
=
D2
-
>
isThisDeclarationADefinition
(
)
=
=
VarDecl
:
:
DeclarationOnly
?
"
decl
"
:
"
def
"
;
PrettyKind
=
"
variable
"
;
}
else
if
(
isa
<
NamespaceDecl
>
(
D
)
|
|
isa
<
NamespaceAliasDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
namespace
"
;
PeekRange
=
SourceRange
(
Loc
Loc
)
;
}
else
if
(
isa
<
FieldDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
field
"
;
}
else
if
(
isa
<
EnumConstantDecl
>
(
D
)
)
{
Kind
=
"
def
"
;
PrettyKind
=
"
enum
constant
"
;
}
else
{
return
true
;
}
SourceRange
CommentRange
=
getCommentRange
(
D
)
;
PeekRange
=
combineRanges
(
PeekRange
CommentRange
)
;
PeekRange
=
validateRange
(
Loc
PeekRange
)
;
std
:
:
vector
<
std
:
:
string
>
Symbols
=
{
getMangledName
(
CurMangleContext
D
)
}
;
if
(
CXXMethodDecl
:
:
classof
(
D
)
)
{
Symbols
.
clear
(
)
;
findOverriddenMethods
(
dyn_cast
<
CXXMethodDecl
>
(
D
)
Symbols
)
;
}
if
(
isa
<
CXXDestructorDecl
>
(
D
)
)
{
const
char
*
P
=
SM
.
getCharacterData
(
Loc
)
;
assert
(
*
p
=
=
'
~
'
)
;
P
+
+
;
unsigned
Skipped
=
1
;
while
(
*
P
=
=
'
'
|
|
*
P
=
=
'
\
t
'
|
|
*
P
=
=
'
\
r
'
|
|
*
P
=
=
'
\
n
'
)
{
P
+
+
;
Skipped
+
+
;
}
Loc
=
Loc
.
getLocWithOffset
(
Skipped
)
;
PrettyKind
=
"
destructor
"
;
}
visitIdentifier
(
Kind
PrettyKind
getQualifiedName
(
D
)
Loc
Symbols
getContext
(
D
)
Flags
PeekRange
)
;
return
true
;
}
bool
VisitCXXConstructExpr
(
CXXConstructExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getLocStart
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
FunctionDecl
*
Ctor
=
E
-
>
getConstructor
(
)
;
if
(
Ctor
-
>
isTemplateInstantiation
(
)
)
{
Ctor
=
Ctor
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Ctor
)
;
visitIdentifier
(
"
use
"
"
constructor
"
getQualifiedName
(
Ctor
)
Loc
Mangled
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitCallExpr
(
CallExpr
*
E
)
{
Decl
*
Callee
=
E
-
>
getCalleeDecl
(
)
;
if
(
!
Callee
|
|
!
FunctionDecl
:
:
classof
(
Callee
)
)
{
return
true
;
}
const
NamedDecl
*
NamedCallee
=
dyn_cast
<
NamedDecl
>
(
Callee
)
;
SourceLocation
Loc
;
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
NamedCallee
)
;
if
(
F
-
>
isTemplateInstantiation
(
)
)
{
NamedCallee
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
NamedCallee
)
;
int
Flags
=
0
;
Expr
*
CalleeExpr
=
E
-
>
getCallee
(
)
-
>
IgnoreParenImpCasts
(
)
;
if
(
CXXOperatorCallExpr
:
:
classof
(
E
)
)
{
CXXOperatorCallExpr
*
Op
=
dyn_cast
<
CXXOperatorCallExpr
>
(
E
)
;
Loc
=
Op
-
>
getOperatorLoc
(
)
;
Flags
|
=
OperatorToken
;
}
else
if
(
MemberExpr
:
:
classof
(
CalleeExpr
)
)
{
MemberExpr
*
Member
=
dyn_cast
<
MemberExpr
>
(
CalleeExpr
)
;
Loc
=
Member
-
>
getMemberLoc
(
)
;
}
else
if
(
DeclRefExpr
:
:
classof
(
CalleeExpr
)
)
{
return
true
;
}
else
{
return
true
;
}
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
visitIdentifier
(
"
use
"
"
function
"
getQualifiedName
(
NamedCallee
)
Loc
Mangled
getContext
(
Loc
)
Flags
)
;
return
true
;
}
bool
VisitTagTypeLoc
(
TagTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
TagDecl
*
Decl
=
L
.
getDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitTypedefTypeLoc
(
TypedefTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
NamedDecl
*
Decl
=
L
.
getTypedefNameDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitInjectedClassNameTypeLoc
(
InjectedClassNameTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
NamedDecl
*
Decl
=
L
.
getDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
return
true
;
}
bool
VisitTemplateSpecializationTypeLoc
(
TemplateSpecializationTypeLoc
L
)
{
SourceLocation
Loc
=
L
.
getBeginLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
TemplateDecl
*
Td
=
L
.
getTypePtr
(
)
-
>
getTemplateName
(
)
.
getAsTemplateDecl
(
)
;
if
(
ClassTemplateDecl
*
D
=
dyn_cast
<
ClassTemplateDecl
>
(
Td
)
)
{
NamedDecl
*
Decl
=
D
-
>
getTemplatedDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
}
else
if
(
TypeAliasTemplateDecl
*
D
=
dyn_cast
<
TypeAliasTemplateDecl
>
(
Td
)
)
{
NamedDecl
*
Decl
=
D
-
>
getTemplatedDecl
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
type
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
}
return
true
;
}
bool
VisitDeclRefExpr
(
DeclRefExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getExprLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
if
(
E
-
>
hasQualifier
(
)
)
{
Loc
=
E
-
>
getNameInfo
(
)
.
getLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
}
NamedDecl
*
Decl
=
E
-
>
getDecl
(
)
;
if
(
const
VarDecl
*
D2
=
dyn_cast
<
VarDecl
>
(
Decl
)
)
{
int
Flags
=
0
;
if
(
D2
-
>
isLocalVarDeclOrParm
(
)
)
{
Flags
=
NoCrossref
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
variable
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
Flags
)
;
}
else
if
(
isa
<
FunctionDecl
>
(
Decl
)
)
{
const
FunctionDecl
*
F
=
dyn_cast
<
FunctionDecl
>
(
Decl
)
;
if
(
F
-
>
isTemplateInstantiation
(
)
)
{
Decl
=
F
-
>
getTemplateInstantiationPattern
(
)
;
}
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
function
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
}
else
if
(
isa
<
EnumConstantDecl
>
(
Decl
)
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Decl
)
;
visitIdentifier
(
"
use
"
"
enum
"
getQualifiedName
(
Decl
)
Loc
Mangled
getContext
(
Loc
)
)
;
}
return
true
;
}
bool
VisitCXXConstructorDecl
(
CXXConstructorDecl
*
D
)
{
if
(
!
isInterestingLocation
(
D
-
>
getLocation
(
)
)
)
{
return
true
;
}
for
(
CXXConstructorDecl
:
:
init_const_iterator
It
=
D
-
>
init_begin
(
)
;
It
!
=
D
-
>
init_end
(
)
;
+
+
It
)
{
const
CXXCtorInitializer
*
Ci
=
*
It
;
if
(
!
Ci
-
>
getMember
(
)
|
|
!
Ci
-
>
isWritten
(
)
)
{
continue
;
}
SourceLocation
Loc
=
Ci
-
>
getMemberLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
continue
;
}
FieldDecl
*
Member
=
Ci
-
>
getMember
(
)
;
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Member
)
;
visitIdentifier
(
"
use
"
"
field
"
getQualifiedName
(
Member
)
Loc
Mangled
getContext
(
D
)
)
;
}
return
true
;
}
bool
VisitMemberExpr
(
MemberExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getExprLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
ValueDecl
*
Decl
=
E
-
>
getMemberDecl
(
)
;
if
(
FieldDecl
*
Field
=
dyn_cast
<
FieldDecl
>
(
Decl
)
)
{
std
:
:
string
Mangled
=
getMangledName
(
CurMangleContext
Field
)
;
visitIdentifier
(
"
use
"
"
field
"
getQualifiedName
(
Field
)
Loc
Mangled
getContext
(
Loc
)
)
;
}
return
true
;
}
bool
VisitCXXDependentScopeMemberExpr
(
CXXDependentScopeMemberExpr
*
E
)
{
SourceLocation
Loc
=
E
-
>
getMemberLoc
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
true
;
}
if
(
TemplateStack
)
{
TemplateStack
-
>
visitDependent
(
Loc
)
;
}
return
true
;
}
void
macroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Macro
)
{
if
(
Macro
-
>
getMacroInfo
(
)
-
>
isBuiltinMacro
(
)
)
{
return
;
}
SourceLocation
Loc
=
Tok
.
getLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
;
}
IdentifierInfo
*
Ident
=
Tok
.
getIdentifierInfo
(
)
;
if
(
Ident
)
{
std
:
:
string
Mangled
=
std
:
:
string
(
"
M_
"
)
+
mangleLocation
(
Loc
Ident
-
>
getName
(
)
)
;
visitIdentifier
(
"
def
"
"
macro
"
Ident
-
>
getName
(
)
Loc
Mangled
)
;
}
}
void
macroUsed
(
const
Token
&
Tok
const
MacroInfo
*
Macro
)
{
if
(
!
Macro
)
{
return
;
}
if
(
Macro
-
>
isBuiltinMacro
(
)
)
{
return
;
}
SourceLocation
Loc
=
Tok
.
getLocation
(
)
;
normalizeLocation
(
&
Loc
)
;
if
(
!
isInterestingLocation
(
Loc
)
)
{
return
;
}
IdentifierInfo
*
Ident
=
Tok
.
getIdentifierInfo
(
)
;
if
(
Ident
)
{
std
:
:
string
Mangled
=
std
:
:
string
(
"
M_
"
)
+
mangleLocation
(
Macro
-
>
getDefinitionLoc
(
)
Ident
-
>
getName
(
)
)
;
visitIdentifier
(
"
use
"
"
macro
"
Ident
-
>
getName
(
)
Loc
Mangled
)
;
}
}
}
;
void
PreprocessorHook
:
:
MacroDefined
(
const
Token
&
Tok
const
MacroDirective
*
Md
)
{
Indexer
-
>
macroDefined
(
Tok
Md
)
;
}
void
PreprocessorHook
:
:
MacroExpands
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
const
MacroArgs
*
Ma
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
#
if
CLANG_VERSION_MAJOR
>
=
5
void
PreprocessorHook
:
:
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
const
MacroDirective
*
Undef
)
#
else
void
PreprocessorHook
:
:
MacroUndefined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
)
#
endif
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Defined
(
const
Token
&
Tok
const
MacroDefinition
&
Md
SourceRange
Range
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Ifdef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
void
PreprocessorHook
:
:
Ifndef
(
SourceLocation
Loc
const
Token
&
Tok
const
MacroDefinition
&
Md
)
{
Indexer
-
>
macroUsed
(
Tok
Md
.
getMacroInfo
(
)
)
;
}
class
IndexAction
:
public
PluginASTAction
{
protected
:
std
:
:
unique_ptr
<
ASTConsumer
>
CreateASTConsumer
(
CompilerInstance
&
CI
llvm
:
:
StringRef
F
)
{
return
llvm
:
:
make_unique
<
IndexConsumer
>
(
CI
)
;
}
bool
ParseArgs
(
const
CompilerInstance
&
CI
const
std
:
:
vector
<
std
:
:
string
>
&
Args
)
{
if
(
Args
.
size
(
)
!
=
3
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Need
arguments
for
the
source
output
and
object
directories
"
)
;
D
.
Report
(
DiagID
)
;
return
false
;
}
Srcdir
=
getAbsolutePath
(
Args
[
0
]
)
;
if
(
Srcdir
.
empty
(
)
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Source
directory
'
%
0
'
does
not
exist
"
)
;
D
.
Report
(
DiagID
)
<
<
Args
[
0
]
;
return
false
;
}
ensurePath
(
Args
[
1
]
+
PATHSEP_STRING
)
;
Outdir
=
getAbsolutePath
(
Args
[
1
]
)
;
Outdir
+
=
PATHSEP_STRING
;
Objdir
=
getAbsolutePath
(
Args
[
2
]
)
;
if
(
Objdir
.
empty
(
)
)
{
DiagnosticsEngine
&
D
=
CI
.
getDiagnostics
(
)
;
unsigned
DiagID
=
D
.
getCustomDiagID
(
DiagnosticsEngine
:
:
Error
"
Objdir
'
%
0
'
does
not
exist
"
)
;
D
.
Report
(
DiagID
)
<
<
Args
[
2
]
;
return
false
;
}
Objdir
+
=
PATHSEP_STRING
;
printf
(
"
MOZSEARCH
:
%
s
%
s
%
s
\
n
"
Srcdir
.
c_str
(
)
Outdir
.
c_str
(
)
Objdir
.
c_str
(
)
)
;
return
true
;
}
void
printHelp
(
llvm
:
:
raw_ostream
&
Ros
)
{
Ros
<
<
"
Help
for
mozsearch
plugin
goes
here
\
n
"
;
}
}
;
static
FrontendPluginRegistry
:
:
Add
<
IndexAction
>
Y
(
"
mozsearch
-
index
"
"
create
the
mozsearch
index
database
"
)
;
