#
include
"
VariableUsageHelpers
.
h
"
#
include
"
Utils
.
h
"
std
:
:
vector
<
const
Stmt
*
>
getUsageAsRvalue
(
const
ValueDecl
*
ValueDeclaration
const
FunctionDecl
*
FuncDecl
)
{
std
:
:
vector
<
const
Stmt
*
>
UsageStatements
;
auto
Body
=
FuncDecl
-
>
getBody
(
)
;
if
(
!
Body
)
{
return
std
:
:
vector
<
const
Stmt
*
>
(
)
;
}
std
:
:
unique_ptr
<
CFG
>
StatementCFG
=
CFG
:
:
buildCFG
(
FuncDecl
Body
&
FuncDecl
-
>
getASTContext
(
)
CFG
:
:
BuildOptions
(
)
)
;
for
(
auto
&
Block
:
*
StatementCFG
)
{
for
(
auto
&
BlockItem
:
*
Block
)
{
Optional
<
CFGStmt
>
CFGStatement
=
BlockItem
.
getAs
<
CFGStmt
>
(
)
;
if
(
!
CFGStatement
)
{
continue
;
}
if
(
auto
BinOp
=
dyn_cast
<
BinaryOperator
>
(
CFGStatement
-
>
getStmt
(
)
)
)
{
if
(
BinOp
-
>
getOpcode
(
)
!
=
BO_Assign
)
{
continue
;
}
auto
DeclRef
=
dyn_cast
<
DeclRefExpr
>
(
IgnoreTrivials
(
BinOp
-
>
getRHS
(
)
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
DeclRef
-
>
getDecl
(
)
!
=
ValueDeclaration
)
{
continue
;
}
}
else
if
(
auto
Return
=
dyn_cast
<
ReturnStmt
>
(
CFGStatement
-
>
getStmt
(
)
)
)
{
auto
DeclRef
=
dyn_cast_or_null
<
DeclRefExpr
>
(
IgnoreTrivials
(
Return
-
>
getRetValue
(
)
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
DeclRef
-
>
getDecl
(
)
!
=
ValueDeclaration
)
{
continue
;
}
}
else
{
continue
;
}
UsageStatements
.
push_back
(
CFGStatement
-
>
getStmt
(
)
)
;
}
}
return
UsageStatements
;
}
Optional
<
std
:
:
tuple
<
const
Stmt
*
const
Decl
*
>
>
escapesFunction
(
const
Expr
*
Arg
const
CallExpr
*
Call
)
{
auto
FuncDecl
=
Call
-
>
getDirectCallee
(
)
;
if
(
!
FuncDecl
)
{
return
NoneType
(
)
;
}
unsigned
ArgNum
=
0
;
for
(
auto
CallArg
:
Call
-
>
arguments
(
)
)
{
if
(
IgnoreTrivials
(
Arg
)
=
=
IgnoreTrivials
(
CallArg
)
)
{
break
;
}
+
+
ArgNum
;
}
if
(
ArgNum
>
=
Call
-
>
getNumArgs
(
)
)
{
return
NoneType
(
)
;
}
if
(
ArgNum
>
=
FuncDecl
-
>
getNumParams
(
)
)
{
return
NoneType
(
)
;
}
auto
Param
=
FuncDecl
-
>
getParamDecl
(
ArgNum
)
;
if
(
!
Arg
-
>
getType
(
)
-
>
isPointerType
(
)
|
|
!
Param
-
>
getType
(
)
-
>
isPointerType
(
)
)
{
return
NoneType
(
)
;
}
auto
Usages
=
getUsageAsRvalue
(
Param
FuncDecl
)
;
for
(
auto
Usage
:
Usages
)
{
if
(
auto
BinOp
=
dyn_cast
<
BinaryOperator
>
(
Usage
)
)
{
auto
DeclRef
=
dyn_cast
<
DeclRefExpr
>
(
BinOp
-
>
getLHS
(
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
auto
ParamDeclaration
=
dyn_cast
<
ParmVarDecl
>
(
DeclRef
-
>
getDecl
(
)
)
)
{
if
(
!
ParamDeclaration
-
>
getType
(
)
-
>
isReferenceType
(
)
)
{
continue
;
}
return
{
{
Usage
ParamDeclaration
}
}
;
}
else
if
(
auto
VarDeclaration
=
dyn_cast
<
VarDecl
>
(
DeclRef
-
>
getDecl
(
)
)
)
{
if
(
!
VarDeclaration
-
>
hasGlobalStorage
(
)
)
{
continue
;
}
return
{
{
Usage
VarDeclaration
}
}
;
}
}
else
if
(
auto
Return
=
dyn_cast
<
ReturnStmt
>
(
Usage
)
)
{
if
(
!
FuncDecl
-
>
getReturnType
(
)
-
>
isPointerType
(
)
&
&
!
FuncDecl
-
>
getReturnType
(
)
-
>
isReferenceType
(
)
)
{
continue
;
}
return
{
{
Usage
FuncDecl
}
}
;
}
}
return
{
{
nullptr
nullptr
}
}
;
}
