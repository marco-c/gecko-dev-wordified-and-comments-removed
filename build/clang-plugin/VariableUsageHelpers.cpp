#
include
"
VariableUsageHelpers
.
h
"
#
include
"
Utils
.
h
"
std
:
:
vector
<
const
Stmt
*
>
getUsageAsRvalue
(
const
ValueDecl
*
ValueDeclaration
const
FunctionDecl
*
FuncDecl
)
{
std
:
:
vector
<
const
Stmt
*
>
UsageStatements
;
auto
Body
=
FuncDecl
-
>
getBody
(
)
;
if
(
!
Body
)
{
return
std
:
:
vector
<
const
Stmt
*
>
(
)
;
}
std
:
:
unique_ptr
<
CFG
>
StatementCFG
=
CFG
:
:
buildCFG
(
FuncDecl
Body
&
FuncDecl
-
>
getASTContext
(
)
CFG
:
:
BuildOptions
(
)
)
;
for
(
auto
&
Block
:
*
StatementCFG
)
{
for
(
auto
&
BlockItem
:
*
Block
)
{
Optional
<
CFGStmt
>
CFGStatement
=
BlockItem
.
getAs
<
CFGStmt
>
(
)
;
if
(
!
CFGStatement
)
{
continue
;
}
if
(
auto
BinOp
=
dyn_cast
<
BinaryOperator
>
(
CFGStatement
-
>
getStmt
(
)
)
)
{
if
(
BinOp
-
>
getOpcode
(
)
!
=
BO_Assign
)
{
continue
;
}
auto
DeclRef
=
dyn_cast
<
DeclRefExpr
>
(
IgnoreTrivials
(
BinOp
-
>
getRHS
(
)
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
DeclRef
-
>
getDecl
(
)
!
=
ValueDeclaration
)
{
continue
;
}
}
else
if
(
auto
Return
=
dyn_cast
<
ReturnStmt
>
(
CFGStatement
-
>
getStmt
(
)
)
)
{
auto
DeclRef
=
dyn_cast_or_null
<
DeclRefExpr
>
(
IgnoreTrivials
(
Return
-
>
getRetValue
(
)
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
DeclRef
-
>
getDecl
(
)
!
=
ValueDeclaration
)
{
continue
;
}
}
else
{
continue
;
}
UsageStatements
.
push_back
(
CFGStatement
-
>
getStmt
(
)
)
;
}
}
return
UsageStatements
;
}
namespace
std
{
template
<
>
struct
is_error_code_enum
<
EscapesFunctionError
>
:
true_type
{
}
;
}
namespace
{
struct
EscapesFunctionErrorCategory
:
std
:
:
error_category
{
const
char
*
name
(
)
const
noexcept
override
;
std
:
:
string
message
(
int
ev
)
const
override
;
}
;
const
char
*
EscapesFunctionErrorCategory
:
:
name
(
)
const
noexcept
{
return
"
escapes
function
"
;
}
std
:
:
string
EscapesFunctionErrorCategory
:
:
message
(
int
ev
)
const
{
switch
(
static_cast
<
EscapesFunctionError
>
(
ev
)
)
{
case
EscapesFunctionError
:
:
ConstructorDeclNotFound
:
return
"
constructor
declaration
not
found
"
;
case
EscapesFunctionError
:
:
FunctionDeclNotFound
:
return
"
function
declaration
not
found
"
;
case
EscapesFunctionError
:
:
FunctionIsBuiltin
:
return
"
function
is
builtin
"
;
case
EscapesFunctionError
:
:
FunctionIsVariadic
:
return
"
function
is
variadic
"
;
case
EscapesFunctionError
:
:
ExprNotInCall
:
return
"
expression
is
not
in
call
"
;
case
EscapesFunctionError
:
:
NoParamForArg
:
return
"
no
parameter
for
argument
"
;
case
EscapesFunctionError
:
:
ArgAndParamNotPointers
:
return
"
argument
and
parameter
are
not
pointers
"
;
}
}
const
EscapesFunctionErrorCategory
TheEscapesFunctionErrorCategory
{
}
;
}
std
:
:
error_code
make_error_code
(
EscapesFunctionError
e
)
{
return
{
static_cast
<
int
>
(
e
)
TheEscapesFunctionErrorCategory
}
;
}
ErrorOr
<
std
:
:
tuple
<
const
Stmt
*
const
Decl
*
>
>
escapesFunction
(
const
Expr
*
Arg
const
CXXConstructExpr
*
Construct
)
{
auto
CtorDecl
=
Construct
-
>
getConstructor
(
)
;
if
(
!
CtorDecl
)
{
return
EscapesFunctionError
:
:
ConstructorDeclNotFound
;
}
return
escapesFunction
(
Arg
CtorDecl
Construct
-
>
getArgs
(
)
Construct
-
>
getNumArgs
(
)
)
;
}
ErrorOr
<
std
:
:
tuple
<
const
Stmt
*
const
Decl
*
>
>
escapesFunction
(
const
Expr
*
Arg
const
CallExpr
*
Call
)
{
auto
FuncDecl
=
Call
-
>
getDirectCallee
(
)
;
if
(
!
FuncDecl
)
{
return
EscapesFunctionError
:
:
FunctionDeclNotFound
;
}
return
escapesFunction
(
Arg
FuncDecl
Call
-
>
getArgs
(
)
Call
-
>
getNumArgs
(
)
)
;
}
ErrorOr
<
std
:
:
tuple
<
const
Stmt
*
const
Decl
*
>
>
escapesFunction
(
const
Expr
*
Arg
const
CXXOperatorCallExpr
*
OpCall
)
{
auto
FuncDecl
=
OpCall
-
>
getDirectCallee
(
)
;
if
(
!
FuncDecl
)
{
return
EscapesFunctionError
:
:
FunctionDeclNotFound
;
}
auto
Args
=
OpCall
-
>
getArgs
(
)
;
auto
NumArgs
=
OpCall
-
>
getNumArgs
(
)
;
if
(
isInfixBinaryOp
(
OpCall
)
&
&
FuncDecl
-
>
getNumParams
(
)
=
=
1
)
{
Args
+
+
;
NumArgs
-
-
;
}
return
escapesFunction
(
Arg
FuncDecl
Args
NumArgs
)
;
}
ErrorOr
<
std
:
:
tuple
<
const
Stmt
*
const
Decl
*
>
>
escapesFunction
(
const
Expr
*
Arg
const
FunctionDecl
*
FuncDecl
const
Expr
*
const
*
Arguments
unsigned
NumArgs
)
{
if
(
!
NumArgs
)
{
return
std
:
:
make_tuple
(
(
const
Stmt
*
)
nullptr
(
const
Decl
*
)
nullptr
)
;
}
if
(
FuncDecl
-
>
getBuiltinID
(
)
!
=
0
|
|
ASTIsInSystemHeader
(
FuncDecl
-
>
getASTContext
(
)
*
FuncDecl
)
)
{
return
EscapesFunctionError
:
:
FunctionIsBuiltin
;
}
if
(
FuncDecl
-
>
isVariadic
(
)
)
{
return
EscapesFunctionError
:
:
FunctionIsVariadic
;
}
unsigned
ArgNum
=
0
;
for
(
unsigned
i
=
0
;
i
<
NumArgs
;
i
+
+
)
{
if
(
IgnoreTrivials
(
Arg
)
=
=
IgnoreTrivials
(
Arguments
[
i
]
)
)
{
break
;
}
+
+
ArgNum
;
}
if
(
ArgNum
>
=
NumArgs
)
{
return
EscapesFunctionError
:
:
ExprNotInCall
;
}
if
(
ArgNum
>
=
FuncDecl
-
>
getNumParams
(
)
)
{
return
EscapesFunctionError
:
:
NoParamForArg
;
}
auto
Param
=
FuncDecl
-
>
getParamDecl
(
ArgNum
)
;
if
(
(
!
Arg
-
>
getType
(
)
.
getNonReferenceType
(
)
-
>
isPointerType
(
)
&
&
Arg
-
>
getType
(
)
.
getNonReferenceType
(
)
-
>
isBuiltinType
(
)
)
|
|
(
!
Param
-
>
getType
(
)
.
getNonReferenceType
(
)
-
>
isPointerType
(
)
&
&
Param
-
>
getType
(
)
.
getNonReferenceType
(
)
-
>
isBuiltinType
(
)
)
)
{
return
EscapesFunctionError
:
:
ArgAndParamNotPointers
;
}
auto
Usages
=
getUsageAsRvalue
(
Param
FuncDecl
)
;
for
(
auto
Usage
:
Usages
)
{
if
(
auto
BinOp
=
dyn_cast
<
BinaryOperator
>
(
Usage
)
)
{
auto
DeclRef
=
dyn_cast
<
DeclRefExpr
>
(
BinOp
-
>
getLHS
(
)
)
;
if
(
!
DeclRef
)
{
continue
;
}
if
(
auto
ParamDeclaration
=
dyn_cast
<
ParmVarDecl
>
(
DeclRef
-
>
getDecl
(
)
)
)
{
if
(
!
ParamDeclaration
-
>
getType
(
)
-
>
isReferenceType
(
)
)
{
continue
;
}
return
std
:
:
make_tuple
(
Usage
(
const
Decl
*
)
ParamDeclaration
)
;
}
else
if
(
auto
VarDeclaration
=
dyn_cast
<
VarDecl
>
(
DeclRef
-
>
getDecl
(
)
)
)
{
if
(
!
VarDeclaration
-
>
hasGlobalStorage
(
)
)
{
continue
;
}
return
std
:
:
make_tuple
(
Usage
(
const
Decl
*
)
VarDeclaration
)
;
}
else
if
(
auto
FieldDeclaration
=
dyn_cast
<
FieldDecl
>
(
DeclRef
-
>
getDecl
(
)
)
)
{
return
std
:
:
make_tuple
(
Usage
(
const
Decl
*
)
FieldDeclaration
)
;
}
}
else
if
(
isa
<
ReturnStmt
>
(
Usage
)
)
{
if
(
!
FuncDecl
-
>
getReturnType
(
)
-
>
isPointerType
(
)
&
&
!
FuncDecl
-
>
getReturnType
(
)
-
>
isReferenceType
(
)
)
{
continue
;
}
return
std
:
:
make_tuple
(
Usage
(
const
Decl
*
)
FuncDecl
)
;
}
}
return
std
:
:
make_tuple
(
(
const
Stmt
*
)
nullptr
(
const
Decl
*
)
nullptr
)
;
}
