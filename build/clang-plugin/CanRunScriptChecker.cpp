#
include
"
CanRunScriptChecker
.
h
"
#
include
"
CustomMatchers
.
h
"
void
CanRunScriptChecker
:
:
registerMatchers
(
MatchFinder
*
AstMatcher
)
{
auto
InvalidArg
=
ignoreTrivials
(
expr
(
hasType
(
pointerType
(
pointee
(
hasDeclaration
(
cxxRecordDecl
(
isRefCounted
(
)
)
)
)
)
)
unless
(
cxxThisExpr
(
)
)
unless
(
cxxMemberCallExpr
(
on
(
hasType
(
isSmartPtrToRefCounted
(
)
)
)
)
)
unless
(
declRefExpr
(
to
(
parmVarDecl
(
)
)
)
)
unless
(
callExpr
(
callee
(
functionDecl
(
hasName
(
"
MOZ_KnownLive
"
)
)
)
)
)
expr
(
)
.
bind
(
"
invalidArg
"
)
)
)
;
auto
OptionalInvalidExplicitArg
=
anyOf
(
hasAnyArgument
(
InvalidArg
)
anything
(
)
)
;
AstMatcher
-
>
addMatcher
(
expr
(
anyOf
(
cxxMemberCallExpr
(
OptionalInvalidExplicitArg
anyOf
(
on
(
cxxOperatorCallExpr
(
anyOf
(
hasAnyArgument
(
InvalidArg
)
anything
(
)
)
)
)
on
(
InvalidArg
)
anything
(
)
)
expr
(
)
.
bind
(
"
callExpr
"
)
)
callExpr
(
OptionalInvalidExplicitArg
expr
(
)
.
bind
(
"
callExpr
"
)
)
cxxConstructExpr
(
OptionalInvalidExplicitArg
expr
(
)
.
bind
(
"
constructExpr
"
)
)
)
anyOf
(
forFunction
(
functionDecl
(
)
.
bind
(
"
nonCanRunScriptParentFunction
"
)
)
anything
(
)
)
)
this
)
;
}
void
CanRunScriptChecker
:
:
onStartOfTranslationUnit
(
)
{
IsFuncSetBuilt
=
false
;
CanRunScriptFuncs
.
clear
(
)
;
}
namespace
{
class
FuncSetCallback
:
public
MatchFinder
:
:
MatchCallback
{
public
:
FuncSetCallback
(
std
:
:
unordered_set
<
const
FunctionDecl
*
>
&
FuncSet
)
:
CanRunScriptFuncs
(
FuncSet
)
{
}
void
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
override
;
private
:
void
addAllOverriddenMethodsRecursively
(
const
CXXMethodDecl
*
Method
)
;
std
:
:
unordered_set
<
const
FunctionDecl
*
>
&
CanRunScriptFuncs
;
}
;
void
FuncSetCallback
:
:
run
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
const
FunctionDecl
*
Func
;
if
(
auto
*
Lambda
=
Result
.
Nodes
.
getNodeAs
<
LambdaExpr
>
(
"
lambda
"
)
)
{
Func
=
Lambda
-
>
getCallOperator
(
)
;
if
(
!
Func
|
|
!
hasCustomAnnotation
(
Func
"
moz_can_run_script
"
)
)
return
;
}
else
{
Func
=
Result
.
Nodes
.
getNodeAs
<
FunctionDecl
>
(
"
canRunScriptFunction
"
)
;
}
CanRunScriptFuncs
.
insert
(
Func
)
;
if
(
auto
*
Method
=
dyn_cast
<
CXXMethodDecl
>
(
Func
)
)
{
addAllOverriddenMethodsRecursively
(
Method
)
;
}
}
void
FuncSetCallback
:
:
addAllOverriddenMethodsRecursively
(
const
CXXMethodDecl
*
Method
)
{
for
(
auto
OverriddenMethod
:
Method
-
>
overridden_methods
(
)
)
{
CanRunScriptFuncs
.
insert
(
OverriddenMethod
)
;
if
(
!
OverriddenMethod
-
>
isThisDeclarationADefinition
(
)
)
{
if
(
auto
Def
=
OverriddenMethod
-
>
getDefinition
(
)
)
{
CanRunScriptFuncs
.
insert
(
Def
)
;
}
}
addAllOverriddenMethodsRecursively
(
OverriddenMethod
)
;
}
}
}
void
CanRunScriptChecker
:
:
buildFuncSet
(
ASTContext
*
Context
)
{
MatchFinder
Finder
;
FuncSetCallback
Callback
(
CanRunScriptFuncs
)
;
Finder
.
addMatcher
(
functionDecl
(
hasCanRunScriptAnnotation
(
)
)
.
bind
(
"
canRunScriptFunction
"
)
&
Callback
)
;
Finder
.
addMatcher
(
lambdaExpr
(
)
.
bind
(
"
lambda
"
)
&
Callback
)
;
Finder
.
matchAST
(
*
Context
)
;
}
void
CanRunScriptChecker
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
if
(
!
IsFuncSetBuilt
)
{
buildFuncSet
(
Result
.
Context
)
;
IsFuncSetBuilt
=
true
;
}
const
char
*
ErrorInvalidArg
=
"
arguments
must
all
be
strong
refs
or
parent
parameters
when
calling
a
"
"
function
marked
as
MOZ_CAN_RUN_SCRIPT
(
including
the
implicit
object
"
"
argument
)
"
;
const
char
*
ErrorNonCanRunScriptParent
=
"
functions
marked
as
MOZ_CAN_RUN_SCRIPT
can
only
be
called
from
"
"
functions
also
marked
as
MOZ_CAN_RUN_SCRIPT
"
;
const
char
*
NoteNonCanRunScriptParent
=
"
parent
function
declared
here
"
;
const
Expr
*
InvalidArg
=
Result
.
Nodes
.
getNodeAs
<
Expr
>
(
"
invalidArg
"
)
;
const
CallExpr
*
Call
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
callExpr
"
)
;
if
(
Call
&
&
(
!
Call
-
>
getDirectCallee
(
)
|
|
!
CanRunScriptFuncs
.
count
(
Call
-
>
getDirectCallee
(
)
)
)
)
{
Call
=
nullptr
;
}
const
CXXConstructExpr
*
Construct
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructExpr
>
(
"
constructExpr
"
)
;
if
(
Construct
&
&
(
!
Construct
-
>
getConstructor
(
)
|
|
!
CanRunScriptFuncs
.
count
(
Construct
-
>
getConstructor
(
)
)
)
)
{
Construct
=
nullptr
;
}
const
FunctionDecl
*
ParentFunction
=
Result
.
Nodes
.
getNodeAs
<
FunctionDecl
>
(
"
nonCanRunScriptParentFunction
"
)
;
if
(
ParentFunction
&
&
(
CanRunScriptFuncs
.
count
(
ParentFunction
)
|
|
hasCustomAnnotation
(
ParentFunction
"
moz_can_run_script_boundary
"
)
)
)
{
ParentFunction
=
nullptr
;
}
SourceRange
CallRange
;
if
(
Call
)
{
CallRange
=
Call
-
>
getSourceRange
(
)
;
}
else
if
(
Construct
)
{
CallRange
=
Construct
-
>
getSourceRange
(
)
;
}
else
{
return
;
}
if
(
InvalidArg
)
{
diag
(
CallRange
.
getBegin
(
)
ErrorInvalidArg
DiagnosticIDs
:
:
Error
)
<
<
CallRange
;
}
if
(
ParentFunction
)
{
assert
(
!
hasCustomAnnotation
(
ParentFunction
"
moz_can_run_script
"
)
&
&
"
Matcher
missed
something
"
)
;
diag
(
CallRange
.
getBegin
(
)
ErrorNonCanRunScriptParent
DiagnosticIDs
:
:
Error
)
<
<
CallRange
;
diag
(
ParentFunction
-
>
getLocation
(
)
NoteNonCanRunScriptParent
DiagnosticIDs
:
:
Note
)
;
}
}
