#
include
"
DanglingOnTemporaryChecker
.
h
"
#
include
"
CustomMatchers
.
h
"
void
DanglingOnTemporaryChecker
:
:
registerMatchers
(
MatchFinder
*
AstMatcher
)
{
AstMatcher
-
>
addMatcher
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
isRValueRefQualified
(
)
decl
(
)
.
bind
(
"
invalidMethodRefQualified
"
)
)
this
)
;
AstMatcher
-
>
addMatcher
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
unless
(
returns
(
pointerType
(
)
)
)
decl
(
)
.
bind
(
"
invalidMethodPointer
"
)
)
this
)
;
AstMatcher
-
>
addMatcher
(
cxxMemberCallExpr
(
onImplicitObjectArgument
(
materializeTemporaryExpr
(
)
)
callee
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
)
)
anyOf
(
unless
(
hasNonTrivialParent
(
callExpr
(
)
)
)
escapesParentFunctionCall
(
stmt
(
)
.
bind
(
"
escapeStatement
"
)
decl
(
)
.
bind
(
"
escapeDeclaration
"
)
)
)
expr
(
)
.
bind
(
"
memberCallExpr
"
)
)
this
)
;
}
void
DanglingOnTemporaryChecker
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
const
char
*
ErrorInvalidRefQualified
=
"
methods
annotated
with
"
"
MOZ_NO_DANGLING_ON_TEMPORARIES
"
"
cannot
be
&
&
ref
-
qualified
"
;
const
char
*
ErrorInvalidPointer
=
"
methods
annotated
with
"
"
MOZ_NO_DANGLING_ON_TEMPORARIES
must
"
"
return
a
pointer
"
;
if
(
auto
InvalidRefQualified
=
Result
.
Nodes
.
getNodeAs
<
CXXMethodDecl
>
(
"
invalidMethodRefQualified
"
)
)
{
diag
(
InvalidRefQualified
-
>
getLocation
(
)
ErrorInvalidRefQualified
DiagnosticIDs
:
:
Error
)
;
return
;
}
if
(
auto
InvalidPointer
=
Result
.
Nodes
.
getNodeAs
<
CXXMethodDecl
>
(
"
invalidMethodPointer
"
)
)
{
diag
(
InvalidPointer
-
>
getLocation
(
)
ErrorInvalidPointer
DiagnosticIDs
:
:
Error
)
;
return
;
}
const
char
*
Error
=
"
calling
%
0
on
a
temporary
potentially
allowing
use
"
"
after
free
of
the
raw
pointer
"
;
const
char
*
EscapeStmtNote
=
"
the
raw
pointer
escapes
the
function
scope
here
"
;
const
CXXMemberCallExpr
*
MemberCall
=
Result
.
Nodes
.
getNodeAs
<
CXXMemberCallExpr
>
(
"
memberCallExpr
"
)
;
const
Stmt
*
EscapeStmt
=
Result
.
Nodes
.
getNodeAs
<
Stmt
>
(
"
escapeStatement
"
)
;
const
Decl
*
EscapeDecl
=
Result
.
Nodes
.
getNodeAs
<
Decl
>
(
"
escapeDeclaration
"
)
;
if
(
!
MemberCall
)
{
return
;
}
diag
(
MemberCall
-
>
getExprLoc
(
)
Error
DiagnosticIDs
:
:
Error
)
<
<
MemberCall
-
>
getMethodDecl
(
)
-
>
getName
(
)
<
<
MemberCall
-
>
getSourceRange
(
)
;
if
(
!
EscapeStmt
|
|
!
EscapeDecl
)
{
return
;
}
diag
(
EscapeStmt
-
>
getLocStart
(
)
EscapeStmtNote
DiagnosticIDs
:
:
Note
)
<
<
EscapeStmt
-
>
getSourceRange
(
)
;
StringRef
EscapeDeclNote
;
SourceRange
EscapeDeclRange
;
if
(
isa
<
ParmVarDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
parameter
declared
here
"
;
EscapeDeclRange
=
EscapeDecl
-
>
getSourceRange
(
)
;
}
else
if
(
isa
<
VarDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
variable
declared
here
"
;
EscapeDeclRange
=
EscapeDecl
-
>
getSourceRange
(
)
;
}
else
if
(
auto
FuncDecl
=
dyn_cast
<
FunctionDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
return
value
of
the
function
declared
here
"
;
EscapeDeclRange
=
FuncDecl
-
>
getReturnTypeSourceRange
(
)
;
}
else
{
return
;
}
diag
(
EscapeDecl
-
>
getLocation
(
)
EscapeDeclNote
DiagnosticIDs
:
:
Note
)
<
<
EscapeDeclRange
;
}
