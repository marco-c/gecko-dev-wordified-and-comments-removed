#
include
"
DanglingOnTemporaryChecker
.
h
"
#
include
"
CustomMatchers
.
h
"
#
include
"
VariableUsageHelpers
.
h
"
void
DanglingOnTemporaryChecker
:
:
registerMatchers
(
MatchFinder
*
AstMatcher
)
{
AstMatcher
-
>
addMatcher
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
isRValueRefQualified
(
)
decl
(
)
.
bind
(
"
invalidMethodRefQualified
"
)
)
this
)
;
AstMatcher
-
>
addMatcher
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
returns
(
builtinType
(
)
)
unless
(
returns
(
pointerType
(
)
)
)
decl
(
)
.
bind
(
"
invalidMethodPointer
"
)
)
this
)
;
auto
hasParentCall
=
hasParent
(
expr
(
anyOf
(
cxxOperatorCallExpr
(
unless
(
has
(
expr
(
ignoreTrivials
(
lambdaExpr
(
)
)
)
)
)
expr
(
)
.
bind
(
"
parentOperatorCallExpr
"
)
)
callExpr
(
unless
(
has
(
expr
(
ignoreTrivials
(
lambdaExpr
(
)
)
)
)
)
expr
(
)
.
bind
(
"
parentCallExpr
"
)
)
objcMessageExpr
(
unless
(
has
(
expr
(
ignoreTrivials
(
lambdaExpr
(
)
)
)
)
)
expr
(
)
.
bind
(
"
parentObjCMessageExpr
"
)
)
cxxConstructExpr
(
unless
(
has
(
expr
(
ignoreTrivials
(
lambdaExpr
(
)
)
)
)
)
expr
(
)
.
bind
(
"
parentConstructExpr
"
)
)
)
)
)
;
AstMatcher
-
>
addMatcher
(
cxxMemberCallExpr
(
isFirstParty
(
)
on
(
allOf
(
unless
(
hasType
(
pointerType
(
)
)
)
isTemporary
(
)
unless
(
cxxThisExpr
(
)
)
)
)
callee
(
cxxMethodDecl
(
noDanglingOnTemporaries
(
)
)
)
expr
(
)
.
bind
(
"
memberCallExpr
"
)
anyOf
(
allOf
(
hasParentCall
expr
(
)
.
bind
(
"
parentCallArg
"
)
)
hasAncestor
(
expr
(
hasParentCall
expr
(
)
.
bind
(
"
parentCallArg
"
)
)
)
anything
(
)
)
)
this
)
;
}
void
DanglingOnTemporaryChecker
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
const
char
*
ErrorInvalidRefQualified
=
"
methods
annotated
with
"
"
MOZ_NO_DANGLING_ON_TEMPORARIES
"
"
cannot
be
&
&
ref
-
qualified
"
;
const
char
*
ErrorInvalidPointer
=
"
methods
annotated
with
"
"
MOZ_NO_DANGLING_ON_TEMPORARIES
must
"
"
return
a
pointer
"
;
if
(
auto
InvalidRefQualified
=
Result
.
Nodes
.
getNodeAs
<
CXXMethodDecl
>
(
"
invalidMethodRefQualified
"
)
)
{
diag
(
InvalidRefQualified
-
>
getLocation
(
)
ErrorInvalidRefQualified
DiagnosticIDs
:
:
Error
)
;
return
;
}
if
(
auto
InvalidPointer
=
Result
.
Nodes
.
getNodeAs
<
CXXMethodDecl
>
(
"
invalidMethodPointer
"
)
)
{
diag
(
InvalidPointer
-
>
getLocation
(
)
ErrorInvalidPointer
DiagnosticIDs
:
:
Error
)
;
return
;
}
const
char
*
Error
=
"
calling
%
0
on
a
temporary
potentially
allowing
use
"
"
after
free
of
the
raw
pointer
"
;
const
char
*
EscapeStmtNote
=
"
the
raw
pointer
escapes
the
function
scope
here
"
;
const
ObjCMessageExpr
*
ParentObjCMessageExpr
=
Result
.
Nodes
.
getNodeAs
<
ObjCMessageExpr
>
(
"
parentObjCMessageExpr
"
)
;
if
(
ParentObjCMessageExpr
)
{
return
;
}
const
CXXMemberCallExpr
*
MemberCall
=
Result
.
Nodes
.
getNodeAs
<
CXXMemberCallExpr
>
(
"
memberCallExpr
"
)
;
const
CallExpr
*
ParentCallExpr
=
Result
.
Nodes
.
getNodeAs
<
CallExpr
>
(
"
parentCallExpr
"
)
;
const
CXXConstructExpr
*
ParentConstructExpr
=
Result
.
Nodes
.
getNodeAs
<
CXXConstructExpr
>
(
"
parentConstructExpr
"
)
;
const
CXXOperatorCallExpr
*
ParentOperatorCallExpr
=
Result
.
Nodes
.
getNodeAs
<
CXXOperatorCallExpr
>
(
"
parentOperatorCallExpr
"
)
;
const
Expr
*
ParentCallArg
=
Result
.
Nodes
.
getNodeAs
<
Expr
>
(
"
parentCallArg
"
)
;
if
(
!
MemberCall
)
{
return
;
}
if
(
ParentOperatorCallExpr
|
|
ParentCallExpr
|
|
ParentConstructExpr
)
{
if
(
!
ParentCallArg
)
{
return
;
}
auto
FunctionEscapeData
=
ParentOperatorCallExpr
?
escapesFunction
(
ParentCallArg
ParentOperatorCallExpr
)
:
ParentCallExpr
?
escapesFunction
(
ParentCallArg
ParentCallExpr
)
:
escapesFunction
(
ParentCallArg
ParentConstructExpr
)
;
if
(
std
:
:
error_code
ec
=
FunctionEscapeData
.
getError
(
)
)
{
if
(
static_cast
<
EscapesFunctionError
>
(
ec
.
value
(
)
)
=
=
EscapesFunctionError
:
:
FunctionIsVariadic
|
|
static_cast
<
EscapesFunctionError
>
(
ec
.
value
(
)
)
=
=
EscapesFunctionError
:
:
FunctionDeclNotFound
|
|
static_cast
<
EscapesFunctionError
>
(
ec
.
value
(
)
)
=
=
EscapesFunctionError
:
:
FunctionIsBuiltin
)
{
return
;
}
diag
(
MemberCall
-
>
getExprLoc
(
)
std
:
:
string
(
ec
.
category
(
)
.
name
(
)
)
+
"
error
:
"
+
ec
.
message
(
)
DiagnosticIDs
:
:
Error
)
;
return
;
}
const
Stmt
*
EscapeStmt
;
const
Decl
*
EscapeDecl
;
std
:
:
tie
(
EscapeStmt
EscapeDecl
)
=
*
FunctionEscapeData
;
if
(
!
EscapeStmt
|
|
!
EscapeDecl
)
{
return
;
}
diag
(
MemberCall
-
>
getExprLoc
(
)
Error
DiagnosticIDs
:
:
Error
)
<
<
MemberCall
-
>
getMethodDecl
(
)
-
>
getName
(
)
<
<
MemberCall
-
>
getSourceRange
(
)
;
diag
(
EscapeStmt
-
>
getLocStart
(
)
EscapeStmtNote
DiagnosticIDs
:
:
Note
)
<
<
EscapeStmt
-
>
getSourceRange
(
)
;
StringRef
EscapeDeclNote
;
SourceRange
EscapeDeclRange
;
if
(
isa
<
ParmVarDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
parameter
declared
here
"
;
EscapeDeclRange
=
EscapeDecl
-
>
getSourceRange
(
)
;
}
else
if
(
isa
<
VarDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
variable
declared
here
"
;
EscapeDeclRange
=
EscapeDecl
-
>
getSourceRange
(
)
;
}
else
if
(
isa
<
FieldDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
field
declared
here
"
;
EscapeDeclRange
=
EscapeDecl
-
>
getSourceRange
(
)
;
}
else
if
(
auto
FuncDecl
=
dyn_cast
<
FunctionDecl
>
(
EscapeDecl
)
)
{
EscapeDeclNote
=
"
through
the
return
value
of
the
function
declared
here
"
;
EscapeDeclRange
=
FuncDecl
-
>
getReturnTypeSourceRange
(
)
;
}
else
{
return
;
}
diag
(
EscapeDecl
-
>
getLocation
(
)
EscapeDeclNote
DiagnosticIDs
:
:
Note
)
<
<
EscapeDeclRange
;
}
else
{
diag
(
MemberCall
-
>
getExprLoc
(
)
Error
DiagnosticIDs
:
:
Error
)
<
<
MemberCall
-
>
getMethodDecl
(
)
-
>
getName
(
)
<
<
MemberCall
-
>
getSourceRange
(
)
;
}
}
