#
ifndef
__COMPRESS_MTF8_H
#
define
__COMPRESS_MTF8_H
#
include
"
.
.
/
.
.
/
.
.
/
C
/
CpuArch
.
h
"
namespace
NCompress
{
struct
CMtf8Encoder
{
Byte
Buf
[
256
]
;
unsigned
FindAndMove
(
Byte
v
)
throw
(
)
{
size_t
pos
;
for
(
pos
=
0
;
Buf
[
pos
]
!
=
v
;
pos
+
+
)
;
unsigned
resPos
=
(
unsigned
)
pos
;
for
(
;
pos
>
=
8
;
pos
-
=
8
)
{
Buf
[
pos
]
=
Buf
[
pos
-
1
]
;
Buf
[
pos
-
1
]
=
Buf
[
pos
-
2
]
;
Buf
[
pos
-
2
]
=
Buf
[
pos
-
3
]
;
Buf
[
pos
-
3
]
=
Buf
[
pos
-
4
]
;
Buf
[
pos
-
4
]
=
Buf
[
pos
-
5
]
;
Buf
[
pos
-
5
]
=
Buf
[
pos
-
6
]
;
Buf
[
pos
-
6
]
=
Buf
[
pos
-
7
]
;
Buf
[
pos
-
7
]
=
Buf
[
pos
-
8
]
;
}
for
(
;
pos
!
=
0
;
pos
-
-
)
Buf
[
pos
]
=
Buf
[
pos
-
1
]
;
Buf
[
0
]
=
v
;
return
resPos
;
}
}
;
#
ifdef
MY_CPU_64BIT
typedef
UInt64
CMtfVar
;
#
define
MTF_MOVS
3
#
else
typedef
UInt32
CMtfVar
;
#
define
MTF_MOVS
2
#
endif
#
define
MTF_MASK
(
(
1
<
<
MTF_MOVS
)
-
1
)
struct
CMtf8Decoder
{
CMtfVar
Buf
[
256
>
>
MTF_MOVS
]
;
void
StartInit
(
)
{
memset
(
Buf
0
sizeof
(
Buf
)
)
;
}
void
Add
(
unsigned
pos
Byte
val
)
{
Buf
[
pos
>
>
MTF_MOVS
]
|
=
(
(
CMtfVar
)
val
<
<
(
(
pos
&
MTF_MASK
)
<
<
3
)
)
;
}
Byte
GetHead
(
)
const
{
return
(
Byte
)
Buf
[
0
]
;
}
MY_FORCE_INLINE
Byte
GetAndMove
(
unsigned
pos
)
throw
(
)
{
UInt32
lim
=
(
(
UInt32
)
pos
>
>
MTF_MOVS
)
;
pos
=
(
pos
&
MTF_MASK
)
<
<
3
;
CMtfVar
prev
=
(
Buf
[
lim
]
>
>
pos
)
&
0xFF
;
UInt32
i
=
0
;
for
(
;
i
<
lim
;
i
+
+
)
{
CMtfVar
n0
=
Buf
[
i
]
;
Buf
[
i
]
=
(
n0
<
<
8
)
|
prev
;
prev
=
(
n0
>
>
(
MTF_MASK
<
<
3
)
)
;
}
CMtfVar
next
=
Buf
[
i
]
;
CMtfVar
mask
=
(
(
(
CMtfVar
)
0x100
<
<
pos
)
-
1
)
;
Buf
[
i
]
=
(
next
&
~
mask
)
|
(
(
(
next
<
<
8
)
|
prev
)
&
mask
)
;
return
(
Byte
)
Buf
[
0
]
;
}
}
;
}
#
endif
