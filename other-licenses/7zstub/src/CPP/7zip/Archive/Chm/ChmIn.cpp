#
include
"
StdAfx
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
.
.
/
C
/
CpuArch
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
Common
/
IntToString
.
h
"
#
include
"
.
.
/
.
.
/
.
.
/
Common
/
UTFConvert
.
h
"
#
include
"
.
.
/
.
.
/
Common
/
LimitedStreams
.
h
"
#
include
"
ChmIn
.
h
"
#
define
Get16
(
p
)
GetUi16
(
p
)
#
define
Get32
(
p
)
GetUi32
(
p
)
#
define
Get64
(
p
)
GetUi64
(
p
)
namespace
NArchive
{
namespace
NChm
{
static
const
UInt32
kSignature_ITSP
=
0x50535449
;
static
const
UInt32
kSignature_PMGL
=
0x4C474D50
;
static
const
UInt32
kSignature_LZXC
=
0x43585A4C
;
static
const
UInt32
kSignature_IFCM
=
0x4D434649
;
static
const
UInt32
kSignature_AOLL
=
0x4C4C4F41
;
static
const
UInt32
kSignature_CAOL
=
0x4C4F4143
;
static
const
UInt32
kSignature_ITSF
=
0x46535449
;
static
const
UInt32
kSignature_ITOL
=
0x4C4F5449
;
static
const
UInt32
kSignature_ITLS
=
0x534C5449
;
struct
CEnexpectedEndException
{
}
;
struct
CHeaderErrorException
{
}
;
static
const
Byte
kChmLzxGuid
[
16
]
=
{
0x40
0x89
0xC2
0x7F
0x31
0x9D
0xD0
0x11
0x9B
0x27
0x00
0xA0
0xC9
0x1E
0x9C
0x7C
}
;
static
const
Byte
kHelp2LzxGuid
[
16
]
=
{
0xC6
0x07
0x90
0x0A
0x76
0x40
0xD3
0x11
0x87
0x89
0x00
0x00
0xF8
0x10
0x57
0x54
}
;
static
const
Byte
kDesGuid
[
16
]
=
{
0xA2
0xE4
0xF6
0x67
0xBF
0x60
0xD3
0x11
0x85
0x40
0x00
0xC0
0x4F
0x58
0xC3
0xCF
}
;
static
bool
inline
AreGuidsEqual
(
const
Byte
*
g1
const
Byte
*
g2
)
{
return
memcmp
(
g1
g2
16
)
=
=
0
;
}
static
char
GetHex
(
unsigned
v
)
{
return
(
char
)
(
(
v
<
10
)
?
(
'
0
'
+
v
)
:
(
'
A
'
+
(
v
-
10
)
)
)
;
}
static
void
PrintByte
(
Byte
b
AString
&
s
)
{
s
+
=
GetHex
(
b
>
>
4
)
;
s
+
=
GetHex
(
b
&
0xF
)
;
}
AString
CMethodInfo
:
:
GetGuidString
(
)
const
{
char
s
[
48
]
;
RawLeGuidToString_Braced
(
Guid
s
)
;
return
(
AString
)
s
;
}
bool
CMethodInfo
:
:
IsLzx
(
)
const
{
if
(
AreGuidsEqual
(
Guid
kChmLzxGuid
)
)
return
true
;
return
AreGuidsEqual
(
Guid
kHelp2LzxGuid
)
;
}
bool
CMethodInfo
:
:
IsDes
(
)
const
{
return
AreGuidsEqual
(
Guid
kDesGuid
)
;
}
AString
CMethodInfo
:
:
GetName
(
)
const
{
AString
s
;
if
(
IsLzx
(
)
)
{
s
=
"
LZX
:
"
;
s
.
Add_UInt32
(
LzxInfo
.
GetNumDictBits
(
)
)
;
}
else
{
if
(
IsDes
(
)
)
s
=
"
DES
"
;
else
{
s
=
GetGuidString
(
)
;
if
(
ControlData
.
Size
(
)
>
0
)
{
s
+
=
'
:
'
;
for
(
size_t
i
=
0
;
i
<
ControlData
.
Size
(
)
;
i
+
+
)
PrintByte
(
ControlData
[
i
]
s
)
;
}
}
}
return
s
;
}
bool
CSectionInfo
:
:
IsLzx
(
)
const
{
if
(
Methods
.
Size
(
)
!
=
1
)
return
false
;
return
Methods
[
0
]
.
IsLzx
(
)
;
}
UString
CSectionInfo
:
:
GetMethodName
(
)
const
{
UString
s
;
if
(
!
IsLzx
(
)
)
{
UString
temp
;
if
(
ConvertUTF8ToUnicode
(
Name
temp
)
)
s
+
=
temp
;
s
+
=
"
:
"
;
}
FOR_VECTOR
(
i
Methods
)
{
if
(
i
!
=
0
)
s
.
Add_Space
(
)
;
s
+
=
Methods
[
i
]
.
GetName
(
)
;
}
return
s
;
}
Byte
CInArchive
:
:
ReadByte
(
)
{
Byte
b
;
if
(
!
_inBuffer
.
ReadByte
(
b
)
)
throw
CEnexpectedEndException
(
)
;
return
b
;
}
void
CInArchive
:
:
Skip
(
size_t
size
)
{
if
(
_inBuffer
.
Skip
(
size
)
!
=
size
)
throw
CEnexpectedEndException
(
)
;
}
void
CInArchive
:
:
ReadBytes
(
Byte
*
data
UInt32
size
)
{
if
(
_inBuffer
.
ReadBytes
(
data
size
)
!
=
size
)
throw
CEnexpectedEndException
(
)
;
}
UInt16
CInArchive
:
:
ReadUInt16
(
)
{
Byte
b0
b1
;
if
(
!
_inBuffer
.
ReadByte
(
b0
)
)
throw
CEnexpectedEndException
(
)
;
if
(
!
_inBuffer
.
ReadByte
(
b1
)
)
throw
CEnexpectedEndException
(
)
;
return
(
UInt16
)
(
(
(
UInt16
)
b1
<
<
8
)
|
b0
)
;
}
UInt32
CInArchive
:
:
ReadUInt32
(
)
{
Byte
p
[
4
]
;
ReadBytes
(
p
4
)
;
return
Get32
(
p
)
;
}
UInt64
CInArchive
:
:
ReadUInt64
(
)
{
Byte
p
[
8
]
;
ReadBytes
(
p
8
)
;
return
Get64
(
p
)
;
}
UInt64
CInArchive
:
:
ReadEncInt
(
)
{
UInt64
val
=
0
;
for
(
int
i
=
0
;
i
<
9
;
i
+
+
)
{
Byte
b
=
ReadByte
(
)
;
val
|
=
(
b
&
0x7F
)
;
if
(
b
<
0x80
)
return
val
;
val
<
<
=
7
;
}
throw
CHeaderErrorException
(
)
;
}
void
CInArchive
:
:
ReadGUID
(
Byte
*
g
)
{
ReadBytes
(
g
16
)
;
}
void
CInArchive
:
:
ReadString
(
unsigned
size
AString
&
s
)
{
s
.
Empty
(
)
;
if
(
size
!
=
0
)
{
ReadBytes
(
(
Byte
*
)
s
.
GetBuf
(
size
)
size
)
;
s
.
ReleaseBuf_CalcLen
(
size
)
;
}
}
void
CInArchive
:
:
ReadUString
(
unsigned
size
UString
&
s
)
{
s
.
Empty
(
)
;
while
(
size
-
-
!
=
0
)
{
wchar_t
c
=
ReadUInt16
(
)
;
if
(
c
=
=
0
)
{
Skip
(
2
*
size
)
;
return
;
}
s
+
=
c
;
}
}
HRESULT
CInArchive
:
:
ReadChunk
(
IInStream
*
inStream
UInt64
pos
UInt64
size
)
{
RINOK
(
inStream
-
>
Seek
(
pos
STREAM_SEEK_SET
NULL
)
)
;
CLimitedSequentialInStream
*
streamSpec
=
new
CLimitedSequentialInStream
;
CMyComPtr
<
ISequentialInStream
>
limitedStream
(
streamSpec
)
;
streamSpec
-
>
SetStream
(
inStream
)
;
streamSpec
-
>
Init
(
size
)
;
m_InStreamRef
=
limitedStream
;
_inBuffer
.
SetStream
(
limitedStream
)
;
_inBuffer
.
Init
(
)
;
return
S_OK
;
}
HRESULT
CInArchive
:
:
ReadDirEntry
(
CDatabase
&
database
)
{
CItem
item
;
UInt64
nameLen
=
ReadEncInt
(
)
;
if
(
nameLen
=
=
0
|
|
nameLen
>
(
1
<
<
13
)
)
return
S_FALSE
;
ReadString
(
(
unsigned
)
nameLen
item
.
Name
)
;
item
.
Section
=
ReadEncInt
(
)
;
item
.
Offset
=
ReadEncInt
(
)
;
item
.
Size
=
ReadEncInt
(
)
;
database
.
Items
.
Add
(
item
)
;
return
S_OK
;
}
HRESULT
CInArchive
:
:
OpenChm
(
IInStream
*
inStream
CDatabase
&
database
)
{
UInt32
headerSize
=
ReadUInt32
(
)
;
if
(
headerSize
!
=
0x60
)
return
S_FALSE
;
database
.
PhySize
=
headerSize
;
UInt32
unknown1
=
ReadUInt32
(
)
;
if
(
unknown1
!
=
0
&
&
unknown1
!
=
1
)
return
S_FALSE
;
IsArc
=
true
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
Byte
g
[
16
]
;
ReadGUID
(
g
)
;
ReadGUID
(
g
)
;
const
unsigned
kNumSections
=
2
;
UInt64
sectionOffsets
[
kNumSections
]
;
UInt64
sectionSizes
[
kNumSections
]
;
unsigned
i
;
for
(
i
=
0
;
i
<
kNumSections
;
i
+
+
)
{
sectionOffsets
[
i
]
=
ReadUInt64
(
)
;
sectionSizes
[
i
]
=
ReadUInt64
(
)
;
UInt64
end
=
sectionOffsets
[
i
]
+
sectionSizes
[
i
]
;
database
.
UpdatePhySize
(
end
)
;
}
database
.
ContentOffset
=
ReadUInt64
(
)
;
ReadChunk
(
inStream
sectionOffsets
[
0
]
sectionSizes
[
0
]
)
;
if
(
sectionSizes
[
0
]
<
0x18
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
0x01FE
)
return
S_FALSE
;
ReadUInt32
(
)
;
UInt64
fileSize
=
ReadUInt64
(
)
;
database
.
UpdatePhySize
(
fileSize
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadChunk
(
inStream
sectionOffsets
[
1
]
sectionSizes
[
1
]
)
;
if
(
ReadUInt32
(
)
!
=
kSignature_ITSP
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
1
)
return
S_FALSE
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
UInt32
dirChunkSize
=
ReadUInt32
(
)
;
if
(
dirChunkSize
<
32
)
return
S_FALSE
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
UInt32
numDirChunks
=
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadGUID
(
g
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
for
(
UInt32
ci
=
0
;
ci
<
numDirChunks
;
ci
+
+
)
{
UInt64
chunkPos
=
_inBuffer
.
GetProcessedSize
(
)
;
if
(
ReadUInt32
(
)
=
=
kSignature_PMGL
)
{
UInt32
quickrefLength
=
ReadUInt32
(
)
;
if
(
quickrefLength
>
dirChunkSize
|
|
quickrefLength
<
2
)
return
S_FALSE
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
unsigned
numItems
=
0
;
for
(
;
;
)
{
UInt64
offset
=
_inBuffer
.
GetProcessedSize
(
)
-
chunkPos
;
UInt32
offsetLimit
=
dirChunkSize
-
quickrefLength
;
if
(
offset
>
offsetLimit
)
return
S_FALSE
;
if
(
offset
=
=
offsetLimit
)
break
;
RINOK
(
ReadDirEntry
(
database
)
)
;
numItems
+
+
;
}
Skip
(
quickrefLength
-
2
)
;
unsigned
rrr
=
ReadUInt16
(
)
;
if
(
rrr
!
=
numItems
)
{
if
(
rrr
!
=
0
)
return
S_FALSE
;
}
}
else
Skip
(
dirChunkSize
-
4
)
;
}
return
S_OK
;
}
HRESULT
CInArchive
:
:
OpenHelp2
(
IInStream
*
inStream
CDatabase
&
database
)
{
if
(
ReadUInt32
(
)
!
=
1
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
0x28
)
return
S_FALSE
;
UInt32
numHeaderSections
=
ReadUInt32
(
)
;
const
unsigned
kNumHeaderSectionsMax
=
5
;
if
(
numHeaderSections
!
=
kNumHeaderSectionsMax
)
return
S_FALSE
;
IsArc
=
true
;
ReadUInt32
(
)
;
Byte
g
[
16
]
;
ReadGUID
(
g
)
;
UInt64
sectionOffsets
[
kNumHeaderSectionsMax
]
;
UInt64
sectionSizes
[
kNumHeaderSectionsMax
]
;
UInt32
i
;
for
(
i
=
0
;
i
<
numHeaderSections
;
i
+
+
)
{
sectionOffsets
[
i
]
=
ReadUInt64
(
)
;
sectionSizes
[
i
]
=
ReadUInt64
(
)
;
UInt64
end
=
sectionOffsets
[
i
]
+
sectionSizes
[
i
]
;
database
.
UpdatePhySize
(
end
)
;
}
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt64
(
)
;
UInt64
numDirEntries
=
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt64
(
)
;
if
(
ReadUInt32
(
)
!
=
kSignature_CAOL
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
2
)
return
S_FALSE
;
UInt32
caolLength
=
ReadUInt32
(
)
;
if
(
caolLength
>
=
0x2C
)
{
ReadUInt16
(
)
;
ReadUInt16
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
if
(
caolLength
=
=
0x2C
)
{
database
.
ContentOffset
=
0
;
database
.
NewFormat
=
true
;
}
else
if
(
caolLength
=
=
0x50
)
{
ReadUInt32
(
)
;
if
(
ReadUInt32
(
)
!
=
kSignature_ITSF
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
4
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
0x20
)
return
S_FALSE
;
UInt32
unknown
=
ReadUInt32
(
)
;
if
(
unknown
!
=
0
&
&
unknown
!
=
1
)
return
S_FALSE
;
database
.
ContentOffset
=
database
.
StartPosition
+
ReadUInt64
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
}
else
return
S_FALSE
;
}
ReadChunk
(
inStream
database
.
StartPosition
+
sectionOffsets
[
0
]
sectionSizes
[
0
]
)
;
if
(
sectionSizes
[
0
]
<
0x18
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
0x01FE
)
return
S_FALSE
;
ReadUInt32
(
)
;
UInt64
fileSize
=
ReadUInt64
(
)
;
database
.
UpdatePhySize
(
fileSize
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadChunk
(
inStream
database
.
StartPosition
+
sectionOffsets
[
1
]
sectionSizes
[
1
]
)
;
if
(
ReadUInt32
(
)
!
=
kSignature_IFCM
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
1
)
return
S_FALSE
;
UInt32
dirChunkSize
=
ReadUInt32
(
)
;
if
(
dirChunkSize
<
64
)
return
S_FALSE
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
UInt32
numDirChunks
=
ReadUInt32
(
)
;
ReadUInt32
(
)
;
for
(
UInt32
ci
=
0
;
ci
<
numDirChunks
;
ci
+
+
)
{
UInt64
chunkPos
=
_inBuffer
.
GetProcessedSize
(
)
;
if
(
ReadUInt32
(
)
=
=
kSignature_AOLL
)
{
UInt32
quickrefLength
=
ReadUInt32
(
)
;
if
(
quickrefLength
>
dirChunkSize
|
|
quickrefLength
<
2
)
return
S_FALSE
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt64
(
)
;
ReadUInt32
(
)
;
ReadUInt32
(
)
;
unsigned
numItems
=
0
;
for
(
;
;
)
{
UInt64
offset
=
_inBuffer
.
GetProcessedSize
(
)
-
chunkPos
;
UInt32
offsetLimit
=
dirChunkSize
-
quickrefLength
;
if
(
offset
>
offsetLimit
)
return
S_FALSE
;
if
(
offset
=
=
offsetLimit
)
break
;
if
(
database
.
NewFormat
)
{
UInt16
nameLen
=
ReadUInt16
(
)
;
if
(
nameLen
=
=
0
)
return
S_FALSE
;
UString
name
;
ReadUString
(
(
unsigned
)
nameLen
name
)
;
AString
s
;
ConvertUnicodeToUTF8
(
name
s
)
;
Byte
b
=
ReadByte
(
)
;
s
.
Add_Space
(
)
;
PrintByte
(
b
s
)
;
s
.
Add_Space
(
)
;
UInt64
len
=
ReadEncInt
(
)
;
while
(
len
-
-
!
=
0
)
{
b
=
ReadByte
(
)
;
PrintByte
(
b
s
)
;
}
database
.
NewFormatString
+
=
s
;
database
.
NewFormatString
+
=
"
\
r
\
n
"
;
}
else
{
RINOK
(
ReadDirEntry
(
database
)
)
;
}
numItems
+
+
;
}
Skip
(
quickrefLength
-
2
)
;
if
(
ReadUInt16
(
)
!
=
numItems
)
return
S_FALSE
;
if
(
numItems
>
numDirEntries
)
return
S_FALSE
;
numDirEntries
-
=
numItems
;
}
else
Skip
(
dirChunkSize
-
4
)
;
}
return
numDirEntries
=
=
0
?
S_OK
:
S_FALSE
;
}
HRESULT
CInArchive
:
:
DecompressStream
(
IInStream
*
inStream
const
CDatabase
&
database
const
AString
&
name
)
{
int
index
=
database
.
FindItem
(
name
)
;
if
(
index
<
0
)
return
S_FALSE
;
const
CItem
&
item
=
database
.
Items
[
index
]
;
_chunkSize
=
item
.
Size
;
return
ReadChunk
(
inStream
database
.
ContentOffset
+
item
.
Offset
item
.
Size
)
;
}
#
define
DATA_SPACE
"
:
:
DataSpace
/
"
#
define
kNameList
DATA_SPACE
"
NameList
"
#
define
kStorage
DATA_SPACE
"
Storage
/
"
#
define
kContent
"
Content
"
#
define
kControlData
"
ControlData
"
#
define
kSpanInfo
"
SpanInfo
"
#
define
kTransform
"
Transform
/
"
#
define
kResetTable
"
/
InstanceData
/
ResetTable
"
#
define
kTransformList
"
List
"
static
AString
GetSectionPrefix
(
const
AString
&
name
)
{
AString
s
(
kStorage
)
;
s
+
=
name
;
s
+
=
'
/
'
;
return
s
;
}
#
define
RINOZ
(
x
)
{
int
__tt
=
(
x
)
;
if
(
__tt
!
=
0
)
return
__tt
;
}
static
int
CompareFiles
(
const
unsigned
*
p1
const
unsigned
*
p2
void
*
param
)
{
const
CObjectVector
<
CItem
>
&
items
=
*
(
const
CObjectVector
<
CItem
>
*
)
param
;
const
CItem
&
item1
=
items
[
*
p1
]
;
const
CItem
&
item2
=
items
[
*
p2
]
;
bool
isDir1
=
item1
.
IsDir
(
)
;
bool
isDir2
=
item2
.
IsDir
(
)
;
if
(
isDir1
&
&
!
isDir2
)
return
-
1
;
if
(
isDir2
)
{
if
(
!
isDir1
)
return
1
;
}
else
{
RINOZ
(
MyCompare
(
item1
.
Section
item2
.
Section
)
)
;
RINOZ
(
MyCompare
(
item1
.
Offset
item2
.
Offset
)
)
;
RINOZ
(
MyCompare
(
item1
.
Size
item2
.
Size
)
)
;
}
return
MyCompare
(
*
p1
*
p2
)
;
}
void
CFilesDatabase
:
:
SetIndices
(
)
{
FOR_VECTOR
(
i
Items
)
{
const
CItem
&
item
=
Items
[
i
]
;
if
(
item
.
IsUserItem
(
)
&
&
item
.
Name
.
Len
(
)
!
=
1
)
Indices
.
Add
(
i
)
;
}
}
void
CFilesDatabase
:
:
Sort
(
)
{
Indices
.
Sort
(
CompareFiles
(
void
*
)
&
Items
)
;
}
bool
CFilesDatabase
:
:
Check
(
)
{
UInt64
maxPos
=
0
;
UInt64
prevSection
=
0
;
FOR_VECTOR
(
i
Indices
)
{
const
CItem
&
item
=
Items
[
Indices
[
i
]
]
;
if
(
item
.
Section
=
=
0
|
|
item
.
IsDir
(
)
)
continue
;
if
(
item
.
Section
!
=
prevSection
)
{
prevSection
=
item
.
Section
;
maxPos
=
0
;
continue
;
}
if
(
item
.
Offset
<
maxPos
)
return
false
;
maxPos
=
item
.
Offset
+
item
.
Size
;
if
(
maxPos
<
item
.
Offset
)
return
false
;
}
return
true
;
}
bool
CFilesDatabase
:
:
CheckSectionRefs
(
)
{
FOR_VECTOR
(
i
Indices
)
{
const
CItem
&
item
=
Items
[
Indices
[
i
]
]
;
if
(
item
.
Section
=
=
0
|
|
item
.
IsDir
(
)
)
continue
;
if
(
item
.
Section
>
=
Sections
.
Size
(
)
)
return
false
;
}
return
true
;
}
static
int
inline
GetLog
(
UInt32
num
)
{
for
(
int
i
=
0
;
i
<
32
;
i
+
+
)
if
(
(
(
UInt32
)
1
<
<
i
)
=
=
num
)
return
i
;
return
-
1
;
}
HRESULT
CInArchive
:
:
OpenHighLevel
(
IInStream
*
inStream
CFilesDatabase
&
database
)
{
{
RINOK
(
DecompressStream
(
inStream
database
(
AString
)
kNameList
)
)
;
ReadUInt16
(
)
;
UInt16
numSections
=
ReadUInt16
(
)
;
for
(
unsigned
i
=
0
;
i
<
numSections
;
i
+
+
)
{
CSectionInfo
section
;
UInt16
nameLen
=
ReadUInt16
(
)
;
UString
name
;
ReadUString
(
nameLen
name
)
;
if
(
ReadUInt16
(
)
!
=
0
)
return
S_FALSE
;
ConvertUnicodeToUTF8
(
name
section
.
Name
)
;
database
.
Sections
.
Add
(
section
)
;
}
}
unsigned
si
;
for
(
si
=
1
;
si
<
database
.
Sections
.
Size
(
)
;
si
+
+
)
{
CSectionInfo
&
section
=
database
.
Sections
[
si
]
;
AString
sectionPrefix
(
GetSectionPrefix
(
section
.
Name
)
)
;
{
int
index
=
database
.
FindItem
(
sectionPrefix
+
kContent
)
;
if
(
index
<
0
)
return
S_FALSE
;
const
CItem
&
item
=
database
.
Items
[
index
]
;
section
.
Offset
=
item
.
Offset
;
section
.
CompressedSize
=
item
.
Size
;
}
AString
transformPrefix
(
sectionPrefix
+
kTransform
)
;
if
(
database
.
Help2Format
)
{
RINOK
(
DecompressStream
(
inStream
database
transformPrefix
+
kTransformList
)
)
;
if
(
(
_chunkSize
&
0xF
)
!
=
0
)
return
S_FALSE
;
unsigned
numGuids
=
(
unsigned
)
(
_chunkSize
/
0x10
)
;
if
(
numGuids
<
1
)
return
S_FALSE
;
for
(
unsigned
i
=
0
;
i
<
numGuids
;
i
+
+
)
{
CMethodInfo
method
;
ReadGUID
(
method
.
Guid
)
;
section
.
Methods
.
Add
(
method
)
;
}
}
else
{
CMethodInfo
method
;
memcpy
(
method
.
Guid
kChmLzxGuid
16
)
;
section
.
Methods
.
Add
(
method
)
;
}
{
RINOK
(
DecompressStream
(
inStream
database
sectionPrefix
+
kControlData
)
)
;
FOR_VECTOR
(
mi
section
.
Methods
)
{
CMethodInfo
&
method
=
section
.
Methods
[
mi
]
;
UInt32
numDWORDS
=
ReadUInt32
(
)
;
if
(
method
.
IsLzx
(
)
)
{
if
(
numDWORDS
<
5
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
kSignature_LZXC
)
return
S_FALSE
;
CLzxInfo
&
li
=
method
.
LzxInfo
;
li
.
Version
=
ReadUInt32
(
)
;
if
(
li
.
Version
!
=
2
&
&
li
.
Version
!
=
3
)
return
S_FALSE
;
{
UInt32
val32
=
ReadUInt32
(
)
;
int
n
=
GetLog
(
val32
)
;
if
(
n
<
0
|
|
n
>
16
)
return
S_FALSE
;
li
.
ResetIntervalBits
=
n
;
}
{
UInt32
val32
=
ReadUInt32
(
)
;
int
n
=
GetLog
(
val32
)
;
if
(
n
<
0
|
|
n
>
16
)
return
S_FALSE
;
li
.
WindowSizeBits
=
n
;
}
li
.
CacheSize
=
ReadUInt32
(
)
;
numDWORDS
-
=
5
;
while
(
numDWORDS
-
-
!
=
0
)
ReadUInt32
(
)
;
}
else
{
UInt32
numBytes
=
numDWORDS
*
4
;
method
.
ControlData
.
Alloc
(
numBytes
)
;
ReadBytes
(
method
.
ControlData
numBytes
)
;
}
}
}
{
RINOK
(
DecompressStream
(
inStream
database
sectionPrefix
+
kSpanInfo
)
)
;
section
.
UncompressedSize
=
ReadUInt64
(
)
;
}
FOR_VECTOR
(
mi
section
.
Methods
)
{
CMethodInfo
&
method
=
section
.
Methods
[
mi
]
;
if
(
method
.
IsLzx
(
)
)
{
RINOK
(
DecompressStream
(
inStream
database
transformPrefix
+
method
.
GetGuidString
(
)
+
kResetTable
)
)
;
CResetTable
&
rt
=
method
.
LzxInfo
.
ResetTable
;
if
(
_chunkSize
<
4
)
{
if
(
_chunkSize
!
=
0
)
return
S_FALSE
;
if
(
section
.
UncompressedSize
!
=
0
)
return
S_FALSE
;
rt
.
UncompressedSize
=
0
;
rt
.
CompressedSize
=
0
;
}
else
{
UInt32
ver
=
ReadUInt32
(
)
;
if
(
ver
!
=
2
&
&
ver
!
=
3
)
return
S_FALSE
;
UInt32
numEntries
=
ReadUInt32
(
)
;
const
unsigned
kEntrySize
=
8
;
if
(
ReadUInt32
(
)
!
=
kEntrySize
)
return
S_FALSE
;
const
unsigned
kRtHeaderSize
=
4
*
4
+
8
*
3
;
if
(
ReadUInt32
(
)
!
=
kRtHeaderSize
)
return
S_FALSE
;
if
(
kRtHeaderSize
+
kEntrySize
*
(
UInt64
)
numEntries
!
=
_chunkSize
)
return
S_FALSE
;
rt
.
UncompressedSize
=
ReadUInt64
(
)
;
rt
.
CompressedSize
=
ReadUInt64
(
)
;
UInt64
blockSize
=
ReadUInt64
(
)
;
if
(
blockSize
!
=
kBlockSize
)
return
S_FALSE
;
UInt64
numBlocks
=
(
rt
.
UncompressedSize
+
kBlockSize
+
1
)
/
kBlockSize
;
if
(
numEntries
!
=
numBlocks
&
&
numEntries
!
=
numBlocks
+
1
)
return
S_FALSE
;
rt
.
ResetOffsets
.
ClearAndReserve
(
numEntries
)
;
for
(
UInt32
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
UInt64
v
=
ReadUInt64
(
)
;
if
(
i
!
=
0
&
&
v
<
rt
.
ResetOffsets
[
i
-
1
]
)
return
S_FALSE
;
rt
.
ResetOffsets
.
AddInReserved
(
v
)
;
}
if
(
numEntries
!
=
0
)
if
(
rt
.
ResetOffsets
[
0
]
!
=
0
)
return
S_FALSE
;
if
(
numEntries
=
=
numBlocks
+
1
)
{
if
(
rt
.
ResetOffsets
.
Back
(
)
!
=
rt
.
CompressedSize
)
return
S_FALSE
;
}
}
}
}
}
database
.
SetIndices
(
)
;
database
.
Sort
(
)
;
return
database
.
Check
(
)
?
S_OK
:
S_FALSE
;
}
HRESULT
CInArchive
:
:
Open2
(
IInStream
*
inStream
const
UInt64
*
searchHeaderSizeLimit
CFilesDatabase
&
database
)
{
IsArc
=
false
;
HeadersError
=
false
;
UnexpectedEnd
=
false
;
UnsupportedFeature
=
false
;
database
.
Clear
(
)
;
database
.
Help2Format
=
_help2
;
const
UInt32
chmVersion
=
3
;
RINOK
(
inStream
-
>
Seek
(
0
STREAM_SEEK_CUR
&
database
.
StartPosition
)
)
;
if
(
!
_inBuffer
.
Create
(
1
<
<
14
)
)
return
E_OUTOFMEMORY
;
_inBuffer
.
SetStream
(
inStream
)
;
_inBuffer
.
Init
(
)
;
if
(
_help2
)
{
const
unsigned
kSignatureSize
=
8
;
const
UInt64
signature
=
(
(
UInt64
)
kSignature_ITLS
<
<
32
)
|
kSignature_ITOL
;
UInt64
limit
=
1
<
<
18
;
if
(
searchHeaderSizeLimit
)
if
(
limit
>
*
searchHeaderSizeLimit
)
limit
=
*
searchHeaderSizeLimit
;
UInt64
val
=
0
;
for
(
;
;
)
{
Byte
b
;
if
(
!
_inBuffer
.
ReadByte
(
b
)
)
return
S_FALSE
;
val
>
>
=
8
;
val
|
=
(
(
UInt64
)
b
)
<
<
(
(
kSignatureSize
-
1
)
*
8
)
;
if
(
_inBuffer
.
GetProcessedSize
(
)
>
=
kSignatureSize
)
{
if
(
val
=
=
signature
)
break
;
if
(
_inBuffer
.
GetProcessedSize
(
)
>
limit
)
return
S_FALSE
;
}
}
database
.
StartPosition
+
=
_inBuffer
.
GetProcessedSize
(
)
-
kSignatureSize
;
RINOK
(
OpenHelp2
(
inStream
database
)
)
;
if
(
database
.
NewFormat
)
return
S_OK
;
}
else
{
if
(
ReadUInt32
(
)
!
=
kSignature_ITSF
)
return
S_FALSE
;
if
(
ReadUInt32
(
)
!
=
chmVersion
)
return
S_FALSE
;
RINOK
(
OpenChm
(
inStream
database
)
)
;
}
#
ifndef
CHM_LOW
try
{
try
{
HRESULT
res
=
OpenHighLevel
(
inStream
database
)
;
if
(
res
=
=
S_FALSE
)
{
UnsupportedFeature
=
true
;
database
.
HighLevelClear
(
)
;
return
S_OK
;
}
RINOK
(
res
)
;
if
(
!
database
.
CheckSectionRefs
(
)
)
HeadersError
=
true
;
database
.
LowLevel
=
false
;
}
catch
(
.
.
.
)
{
database
.
HighLevelClear
(
)
;
throw
;
}
}
catch
(
CEnexpectedEndException
&
)
{
UnexpectedEnd
=
true
;
}
catch
(
CHeaderErrorException
&
)
{
HeadersError
=
true
;
}
catch
(
.
.
.
)
{
throw
;
}
#
endif
return
S_OK
;
}
HRESULT
CInArchive
:
:
Open
(
IInStream
*
inStream
const
UInt64
*
searchHeaderSizeLimit
CFilesDatabase
&
database
)
{
try
{
try
{
HRESULT
res
=
Open2
(
inStream
searchHeaderSizeLimit
database
)
;
m_InStreamRef
.
Release
(
)
;
return
res
;
}
catch
(
.
.
.
)
{
m_InStreamRef
.
Release
(
)
;
throw
;
}
}
catch
(
const
CInBufferException
&
e
)
{
return
e
.
ErrorCode
;
}
catch
(
CEnexpectedEndException
&
)
{
UnexpectedEnd
=
true
;
}
catch
(
CHeaderErrorException
&
)
{
HeadersError
=
true
;
}
return
S_FALSE
;
}
}
}
