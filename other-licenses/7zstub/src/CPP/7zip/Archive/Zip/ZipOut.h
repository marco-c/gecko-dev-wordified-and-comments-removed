#
ifndef
__ZIP_OUT_H
#
define
__ZIP_OUT_H
#
include
"
.
.
/
.
.
/
.
.
/
Common
/
MyCom
.
h
"
#
include
"
.
.
/
.
.
/
Common
/
OutBuffer
.
h
"
#
include
"
ZipItem
.
h
"
namespace
NArchive
{
namespace
NZip
{
class
CItemOut
:
public
CItem
{
public
:
FILETIME
Ntfs_MTime
;
FILETIME
Ntfs_ATime
;
FILETIME
Ntfs_CTime
;
bool
NtfsTimeIsDefined
;
CItemOut
(
)
:
NtfsTimeIsDefined
(
false
)
{
}
}
;
class
COutArchive
{
COutBuffer
m_OutBuffer
;
CMyComPtr
<
IOutStream
>
m_Stream
;
UInt64
m_Base
;
UInt64
m_CurPos
;
UInt64
m_LocalHeaderPos
;
UInt32
m_LocalFileHeaderSize
;
UInt32
m_ExtraSize
;
bool
m_IsZip64
;
void
WriteBytes
(
const
void
*
data
size_t
size
)
;
void
Write8
(
Byte
b
)
;
void
Write16
(
UInt16
val
)
;
void
Write32
(
UInt32
val
)
;
void
Write64
(
UInt64
val
)
;
void
WriteNtfsTime
(
const
FILETIME
&
ft
)
{
Write32
(
ft
.
dwLowDateTime
)
;
Write32
(
ft
.
dwHighDateTime
)
;
}
void
WriteExtra
(
const
CExtraBlock
&
extra
)
;
void
WriteCommonItemInfo
(
const
CLocalItem
&
item
bool
isZip64
)
;
void
WriteCentralHeader
(
const
CItemOut
&
item
)
;
void
SeekToCurPos
(
)
;
public
:
HRESULT
Create
(
IOutStream
*
outStream
)
;
UInt64
GetCurPos
(
)
const
{
return
m_CurPos
;
}
void
MoveCurPos
(
UInt64
distanceToMove
)
{
m_CurPos
+
=
distanceToMove
;
}
void
WriteLocalHeader
(
CItemOut
&
item
bool
needCheck
=
false
)
;
void
WriteLocalHeader_Replace
(
CItemOut
&
item
)
;
void
WriteDescriptor
(
const
CItemOut
&
item
)
;
void
WriteCentralDir
(
const
CObjectVector
<
CItemOut
>
&
items
const
CByteBuffer
*
comment
)
;
void
CreateStreamForCompressing
(
CMyComPtr
<
IOutStream
>
&
outStream
)
;
void
CreateStreamForCopying
(
CMyComPtr
<
ISequentialOutStream
>
&
outStream
)
;
}
;
}
}
#
endif
